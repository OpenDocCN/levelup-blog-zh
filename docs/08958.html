<html>
<head>
<title>A containerized NodeJS+Express “Hello World” application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个容器化的NodeJS+Express“Hello World”应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-containerized-nodejs-express-hello-world-application-28d286556890?source=collection_archive---------11-----------------------#2021-06-22">https://levelup.gitconnected.com/a-containerized-nodejs-express-hello-world-application-28d286556890?source=collection_archive---------11-----------------------#2021-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c3aec73194d9292f5aaba1a9e8c94073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRN0jjlawK7gJqSq3jZdtA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">货船上的集装箱</figcaption></figure><p id="890d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这篇文章有一个非常简单的目的:帮助任何刚开始使用NodeJS和Docker的人。我们将构建一个简单的API服务器，并将其容器化以便快速部署。</p><h1 id="ac50" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">先决条件</h1><h2 id="784c" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">NodeJS</h2><p id="81b5" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">很明显，NodeJS将是这个项目的先决条件之一。根据您将要开发的操作系统，有不同的安装方法可供使用。官方下载网站位于:<a class="ae mp" href="https://nodejs.org/en/download" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="mq">【https://nodejs.org/en/download】</em></strong></a><strong class="ke ir"><em class="mq">。</em>T12】</strong></p><p id="5c78" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">在Windows上<br/> </em> </strong>在Windows上安装是一个简单的过程。从下载Windows Installer开始(。msi)从官方下载网址:<a class="ae mp" href="https://nodejs.org/en/download" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="mq">https://nodejs.org/en/download</em></strong></a>。如果您的系统是64位的，您将需要64位版本，并且您将希望从<strong class="ke ir"> <em class="mq"> LTS </em> </strong>选项卡下载，而不是从<strong class="ke ir"> <em class="mq">当前</em> </strong>选项卡下载。<strong class="ke ir"><em class="mq"/></strong>代表<strong class="ke ir"><em class="mq"/></strong>长期稳定，这基本上意味着它是一个非常稳定的版本，将在未来相当长的一段时间内得到支持。<strong class="ke ir"> <em class="mq">当前的</em> </strong>往往不太稳定，变化很快——然而，如果你正在寻找最新的特性和功能，那么<strong class="ke ir"> <em class="mq">当前的</em> </strong>正适合你。</p><p id="83be" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，启动<strong class="ke ir"> <em class="mq">。msi </em> </strong>，接受许可协议(前提是你同意并想继续！)，并为所有其他提示选择默认值(包括<strong class="ke ir"> <em class="mq">自定义设置</em> </strong>页面上的选项)，除非您有理由将其安装到默认目录以外的目录(<strong class="ke ir"><em class="mq">C:\ Program Files \ nodejs</em></strong>)。完成安装，您就可以开始了！</p><blockquote class="mr ms mt"><p id="7802" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">抬头！</strong> <br/>如果英语不是您的母语，只需将下载路径中的‘en’替换为西班牙语的<code class="fe mx my mz na b"><strong class="ke ir"><em class="iq">es</em></strong></code>，<code class="fe mx my mz na b"><strong class="ke ir"><em class="iq">de</em></strong></code>为德语，<code class="fe mx my mz na b"><strong class="ke ir"><em class="iq">ru</em></strong></code>为俄语，依此类推。</p></blockquote><p id="3198" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">在Mac上<br/> </em> </strong>在macOS上安装也一样简单。我更喜欢通过家酿安装。<br/> 1。打开一个终端(可以在<strong class="ke ir"> <em class="mq"> Launchpad下找到)</em> </strong></p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/331e501cd08e91cc175cd9bf6966c134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNXh-aqK8S3Z8vK3iYYUNg.png"/></div></div></figure><p id="42b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.更新Home brew</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="53a8" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">brew update</strong></span></pre><p id="ff51" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.安装节点</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="bd8c" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">brew install node</strong></span></pre><p id="a91e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.验证NodeJS的安装</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="4f7d" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">node -v</strong></span></pre><p id="458c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">5.验证NPM的安装(NodeJS包管理器——我们将详细讨论这一点)。</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="f6aa" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">npm -v</strong></span></pre><p id="ed7f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">全部完成！现在，您已经在mac上安装了一个工作节点。</p><p id="c7ae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Linux上的<strong class="ke ir"><em class="mq"><br/></em></strong>当然，Linux的安装过程并不容易，但如果不这样，那会有什么乐趣呢！我们将在Ubuntu上使用这个过程，但是在其他Linux发行版上也是类似的。首先，我们必须选择要安装的版本。看一看<a class="ae mp" href="https://nodejs.org/en/download" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="mq"/></strong></a><strong class="ke ir"><em class="mq"/></strong>我们看到，在撰写本文时，最新的主要LTS(长期稳定)版本是14.17.1。</p><blockquote class="mr ms mt"><p id="2123" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">注意</strong> <br/>你可以在这里找到其他发行版的列表和附加安装说明:<a class="ae mp" href="https://github.com/nodesource/distributions/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">https://github . com/node source/distributions/blob/master/readme . MD</a></p></blockquote><ol class=""><li id="c6ef" class="no np iq ke b kf kg kj kk kn nq kr nr kv ns kz nt nu nv nw bi translated">更新本地apt报告</li></ol><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="0189" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">curl -fsSL </strong><a class="ae mp" href="https://deb.nodesource.com/setup_14.x" rel="noopener ugc nofollow" target="_blank"><strong class="na ir">https://deb.nodesource.com/setup_14.x</strong></a><strong class="na ir"> | sudo -E bash -</strong></span></pre><p id="92b0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.用apt-get安装NodeJS</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="dc02" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">sudo apt-get install -y nodejs</strong></span></pre><p id="e58d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.以帮助确保将来附加组件的构建不会出现问题</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="82e6" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">sudo apt-get install -y build-essential</strong></span></pre><p id="f237" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.验证NodeJS的安装</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="3f48" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">node -v</strong></span></pre><p id="5752" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">5.验证NPM的安装(NodeJS包管理器——我们将详细讨论这一点)。</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="7f00" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">npm -v</strong></span></pre><p id="7a53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">全部完成！现在，您已经在Linux上安装了一个工作节点。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="ec9d" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">码头工人</h2><p id="f74f" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我们需要Docker，这样我们就可以马上测试我们的容器化应用程序，在macOS或Windows上最简单的方法就是安装Docker Desktop。如果你在Linux上，安装将(当然)通过Docker的CLI安装。</p><blockquote class="mr ms mt"><p id="5f75" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">注</strong> <em class="iq"> <br/> </em> Docker桌面包括Docker App、开发者工具、Kubernetes以及与生产Docker引擎的版本同步。Docker Desktop允许您利用经过认证的图像和模板以及您选择的语言和工具。开发工作流利用Docker Hub将您的开发环境扩展到一个安全的存储库，以实现快速自动构建、持续集成和安全协作。</p></blockquote><p id="6487" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以得到。dmg或者。用于Mac和Windows的Docker桌面的exe安装程序</p><p id="4cb5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">在Windows上</em> </strong> <br/>在Windows上，安装就像运行。exe(你知道的，ol '双击？).</p><p id="8094" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">在Mac上</em> </strong> <br/>在macOS上，安装就像运行。dmg，然后常见的拖放到应用程序。</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/42cec51f12338207cb573c17fa282786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Kgi7mz7VmVG9EeTJ.png"/></div></div></figure><blockquote class="mr ms mt"><p id="11cd" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">注意</strong> <br/>在macOS上，您可能需要从您的<strong class="ke ir"> Launchpad </strong>启动<strong class="ke ir"> Docker </strong>以允许它在您能够使用Docker命令之前初始化。</p></blockquote><p id="d3a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">在Linux上</em> </strong> <br/>所以——在Linux上，安装并不那么容易，但也差不多了！同样，我们将在Ubuntu上执行这个安装，就像我们在上面对NodeJS所做的一样——但是同样，在其他Linux平台上的安装也是类似的。</p><p id="88a6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">步骤1 —建立存储库</strong></p><p id="a1a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">1.确保没有现有安装。<br/> <code class="fe mx my mz na b"><strong class="ke ir">sudo apt-get remove docker docker-engine docker.io containerd runc</strong></code></p><p id="1212" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.刷新APT存储库。<br/> <code class="fe mx my mz na b"><strong class="ke ir">sudo apt-get update</strong></code></p><p id="9d90" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.安装支持应用程序。</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="985f" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">sudo apt-get install apt-transport-https ca-certificates curl gnupg    lsb-release</strong></span></pre><p id="eea1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.添加码头工人的GPG键</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="f3d8" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</strong></span></pre><p id="2a51" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">5.建立稳定的Docker存储库</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="e073" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">echo \<br/>  "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \<br/>  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</strong></span></pre><p id="ed95" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">步骤2 —安装Docker引擎</strong></p><ol class=""><li id="2bfd" class="no np iq ke b kf kg kj kk kn nq kr nr kv ns kz nt nu nv nw bi translated">更新APT存储库。<br/> <code class="fe mx my mz na b"><strong class="ke ir">sudo apt-get update</strong></code></li><li id="84e7" class="no np iq ke b kf of kj og kn oh kr oi kv oj kz nt nu nv nw bi translated">安装<strong class="ke ir"> <em class="mq">码头</em> </strong>和<strong class="ke ir"> <em class="mq">集装箱</em> </strong> <em class="mq">。</em>这将安装<em class="mq">最新</em> <em class="mq">稳定</em>版本<strong class="ke ir"> <em class="mq"> Docker </em> </strong> <em class="mq">。</em><br/>T3】</li></ol><p id="93b1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.通过下载并运行样本容器，验证<strong class="ke ir"> <em class="mq"> Docker </em> </strong>引擎是否正常工作。<br/> <code class="fe mx my mz na b"><strong class="ke ir">sudo docker run hello-world</strong></code></p><p id="d3f2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这应该会在您的shell中生成一条如下所示的消息:</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="c10f" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">Unable to find image 'hello-world:latest' locally</strong></span><span id="cdad" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">latest: Pulling from library/hello-world</strong></span><span id="1301" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">b8dfde127a29: Pull complete</strong></span><span id="b361" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">Digest: sha256:9f6ad537c5132bcce57f7a0a20e317228d382c3cd61edae14650eec68b2b345c</strong></span><span id="eb54" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">Status: Downloaded newer image for hello-world:latest</strong></span><span id="0d2b" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">Hello from Docker!</strong></span><span id="ab54" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">This message shows that your installation appears to be working correctly.</strong></span></pre><blockquote class="mr ms mt"><p id="7da3" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">Linux上的Docker引擎</strong> <br/>其他Linux发行版的安装说明可以在这里找到:<a class="ae mp" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/install/</a></p></blockquote><p id="3fba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">全部完成！您已经成功安装并配置了Docker！</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="e528" class="la lb iq bd lc ld ol lf lg lh om lj lk ll on ln lo lp oo lr ls lt op lv lw lx bi translated">该项目</h1><h2 id="cabc" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">创建项目</h2><p id="e351" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">看，先决条件阶段没那么糟糕！现在我们开始构建实际的应用程序。为此，我们希望进入一个shell(Windows上的命令提示符或PowerShell，macOS上的终端，或者bash/zsh/等)。Linux上的shell)。</p><ol class=""><li id="bfb9" class="no np iq ke b kf kg kj kk kn nq kr nr kv ns kz nt nu nv nw bi translated">导航到您希望项目驻留的位置。我喜欢在我的主目录下创建一个名为code的目录，然后将项目存储在这个目录下。</li></ol><blockquote class="mr ms mt"><p id="a77a" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">抬头！</strong> <br/>路径越复杂，以后用起来越费时，越麻烦。软件工程的黄金法则之一是<strong class="ke ir">吻</strong>法:<strong class="ke ir">保持简单，笨蛋</strong>。这意味着<code class="fe mx my mz na b"><strong class="ke ir"><em class="iq">~/code</em></strong></code>或<code class="fe mx my mz na b"><strong class="ke ir"><em class="iq">C:\code</em></strong></code>是完全可以接受的路径，可以在未来为你节省时间和麻烦。</p></blockquote><p id="755a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.为您的项目创建目录</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="5e1f" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">mkdir test-project</strong></span></pre><p id="9c97" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.导航到项目目录</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="9ed5" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">cd test-project</strong></span></pre><p id="ac48" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.设置支持文件(<strong class="ke ir">)。gitignore </strong>和<strong class="ke ir">许可</strong>。</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="0794" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">npx license mit &gt; LICENSE</strong></span><span id="e9eb" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">npx gitignore node</strong></span></pre><blockquote class="mr ms mt"><p id="167c" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">抬头！</strong> <br/>麻省理工是一个许可证类型(我也听说那是一个相当体面的学校… (-:)，但是你可以自由地为你的项目使用你喜欢的任何一个。另一种可能是合适选项的类型是WTFPL。无论如何，您可以在以下网址找到关于其他许可软件许可证的信息:<a class="ae mp" href="https://en.wikipedia.org/wiki/Category:Permissive_software_licenses" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Category:Permissive _ software _ licenses</a></p><p id="c36b" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">注意</strong> <br/>虽然深入探讨远远超出了本文的范围，但是您应该知道npx是npm cli的一部分，它允许您从本地或远程npm存储库运行命令。关于npx的文件可在此处获得:<a class="ae mp" href="https://docs.npmjs.com/cli/v7/commands/npx" rel="noopener ugc nofollow" target="_blank">https://docs.npmjs.org/cli/v7/commands/npx</a></p></blockquote><p id="994e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">5.初始化项目</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="effe" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">npm init -y</strong></span></pre></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="8b74" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">安装软件包</h2><p id="e325" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">现在我们已经创建了我们的项目，我们可以添加我们需要的任何npm包。目前，我们只需要快递。要将它添加到我们的项目中，我们只需发出以下命令:</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="95aa" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">npm install express --save</strong></span></pre><blockquote class="mr ms mt"><p id="8794" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">注意</strong> <br/>我们命令的<code class="fe mx my mz na b"><strong class="ke ir"><em class="iq">--save</em></strong></code>部分告诉npm将它作为一个依赖项写在我们的package.json文件中。这允许我们的项目在另一个系统上“重建”,无论是docker容器还是物理服务器。</p></blockquote></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="a473" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">编写代码</h2><p id="dc8e" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">看起来我们差不多准备好写一些代码了！但是首先，我们需要一些文件来放入代码。</p><blockquote class="mr ms mt"><p id="4fd4" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">比较你的作品</strong> <br/>我已经在<strong class="ke ir"> GitHub </strong>创建了一个包含这个项目的资源库。可以在这里查看:<a class="ae mp" href="https://github.com/johnathanesanders/basic-nodejs-express-docker" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">https://github . com/johnathanesanders/basic-nodejs-express-docker</strong></a></p></blockquote><ol class=""><li id="d259" class="no np iq ke b kf kg kj kk kn nq kr nr kv ns kz nt nu nv nw bi translated">在项目目录的根目录下创建一个名为<strong class="ke ir"> <em class="mq"> index.js </em> </strong>的文件。这可以通过shell中的<code class="fe mx my mz na b"><strong class="ke ir">touch index.js</strong></code> <strong class="ke ir"> </strong>轻松完成。这个文件将保存我们所有的代码。</li></ol><blockquote class="mr ms mt"><p id="fd04" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">注意</strong> <br/>在这样一个简单的项目中，一个单独的<strong class="ke ir"> index.js </strong>就足够了——在一个更复杂的项目中，你会希望将你的代码分成更多的文件和目录。</p></blockquote><p id="d62f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.在项目目录的根目录下创建一个名为<strong class="ke ir"><em class="mq">environment . js</em></strong>的文件。<code class="fe mx my mz na b"><strong class="ke ir">touch environment.js</strong></code> <strong class="ke ir"> </strong>这将用于应用程序运行时的选项。但是在为生产而构建时，会被接下来提到的<strong class="ke ir"><em class="mq">environment . prod . js</em></strong>的内容复制过来。</p><p id="eaba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.在项目目录的根目录下创建一个名为<strong class="ke ir"><em class="mq">environment . prod . js</em></strong>的文件。<code class="fe mx my mz na b"><strong class="ke ir">touch environment.prod.js</strong></code> <strong class="ke ir"> </strong>这将在我们通过Azure DevOps部署我们的应用程序时使用，并且需要在构建时注入变量。</p><p id="7958" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们打开<strong class="ke ir"> <em class="mq"> index.js </em> </strong>文件并开始编码。我更喜欢使用VS代码，但是任何文本编辑器都可以(为了保持我的老伙计技能符合标准，我有时只使用<strong class="ke ir"> vi，</strong>VI，我可以说我自己也快接近老伙计的年龄了)。添加以下几行:</p><p id="008c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq"> index.js </em> </strong></p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="358b" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">const { Environment } = require('./environment.js');<br/>const express = require('express');</strong></span><span id="cb8f" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">const server = express();</strong></span><span id="83c3" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">server.get('/', (request, response) =&gt; {<br/>    response.send('Hello World!');<br/>});</strong></span><span id="a22d" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">server.listen(Environment.port || 3000, () =&gt; {<br/>    console.log(`Server UP!`)<br/>});</strong></span></pre><p id="11ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们来谈谈我们在这里做什么。</p><ul class=""><li id="8910" class="no np iq ke b kf kg kj kk kn nq kr nr kv ns kz oq nu nv nw bi translated">首先，我们在第1行和第2行有两个require语句。第一个在我们的environment.js文件中导入一个名为“Environment”的常量，接下来我们将向该文件添加内容。第二个导入我们之前通过npm安装的Express库。</li><li id="6daa" class="no np iq ke b kf of kj og kn oh kr oi kv oj kz oq nu nv nw bi translated">接下来，我们用<code class="fe mx my mz na b"><strong class="ke ir">express()</strong></code>调用初始化我们的服务器。</li><li id="814c" class="no np iq ke b kf of kj og kn oh kr oi kv oj kz oq nu nv nw bi translated">之后，我们向我们的服务器添加一条路由。我们说，在第6行，当服务器上的<code class="fe mx my mz na b"><strong class="ke ir">GET</strong></code>请求指向我们的根目录<code class="fe mx my mz na b"><strong class="ke ir">/</strong></code> <strong class="ke ir"> </strong>时，我们将接受这些请求，并用一串<em class="mq"> Hello World来响应这些请求！。</em></li><li id="d8be" class="no np iq ke b kf of kj og kn oh kr oi kv oj kz oq nu nv nw bi translated">最后一步是启动我们的服务器。我们必须为它提供一个监听端口，默认为Environment.port(我们希望从前面的第1行导入),然后在没有提供自定义值的情况下提供一个替代端口(这就是<code class="fe mx my mz na b"><strong class="ke ir">|| 3000</strong></code>的用途)。一旦服务器成功启动，第11行的<code class="fe mx my mz na b"><strong class="ke ir">console.log()</strong></code>将输出到服务器的控制台(而不是调用客户机)。</li></ul><p id="7ea1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们的<strong class="ke ir"> <em class="mq"> index.js </em> </strong>文件已经完成，让我们打开我们的<strong class="ke ir"> <em class="mq"> environment.js </em> </strong>文件来添加我们的端口定制。</p><p id="8674" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"><em class="mq">environment . js</em></strong></p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="93f0" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">const Environment = {<br/>    port: '8800'<br/>};</strong></span><span id="b70d" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">module.exports = { Environment };</strong></span></pre><p id="cfdc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个很简单，我们只是导出一个名为Environment的对象，它带有一个端口节点，该节点被设置为我们希望服务器监听的端口号。对于传统的HTTP服务器，您需要监听端口80和/或443。</p><p id="7d80" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一个文件是environment.prod.js，有点不同。在这个文件中，我们希望只有真正的环境变量，我们可以在构建或运行时设置。这样，我们可以随意将它们注入我们的容器。</p><p id="560c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">T16】environment . prod . jsT18】</strong></p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="b8e1" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">export const Environment = {<br/>    port: process.env.HTTP_LISTEN_PORT<br/>};</strong></span><span id="4812" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">module.exports = { Environment };</strong></span></pre><p id="56a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里唯一的区别就是我们把<strong class="ke ir"> <em class="mq"> 8800 </em> </strong>改成了<strong class="ke ir"><em class="mq">process . env . http _ LISTEN _ PORT</em></strong></p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="892e" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">设置package.json</h2><p id="c921" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">代码已经写好了，我们真的很快就能让它运行了。但是，我们想在package.json文件中添加一些脚本，以便基于环境运行。</p><p id="9cc7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq"> package.json </em> </strong></p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="bc41" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">{<br/>    "name": "test-project",<br/>    "version": "1.0.0",<br/>    "description": "",<br/>    "main": "index.js",<br/>    "scripts": {<br/>        "env:prod": "cp -r ./environment.prod.js ./environment.js",<br/>        "start": "node ./index.js",<br/>        "start:prod": "npm run env:prod &amp;&amp; node ./index.js",<br/>        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>    },<br/>    "keywords": [],<br/>    "author": "",<br/>    "license": "MIT",<br/>    "dependencies": {<br/>        "express": "^4.17.1"<br/>  }<br/>}</strong></span></pre><p id="82c6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好的，如果你选择了不同的许可证，或者给它起了别的名字，这可能和你的package.json不同。对于本文的这一部分，重要的是在第7-9行。这些是将为我们执行的脚本，我们可以根据我们的环境运行它们。还记得我们说过以后会在environment.js上复制environment.prod.js吗？</p><p id="d00e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">第7行<br/> </em> </strong> <em class="mq">运行脚本，将environment.prod.js文件复制到environment.js </em></p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="c225" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">"env:prod": "cp -r ./environment.prod.js ./environment.js"</strong></span></pre><p id="e074" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">第8行</em> </strong> <br/> <em class="mq">在本地环境中运行启动应用程序的脚本</em></p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="8973" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">"start": "node ./index.js"</strong></span></pre><p id="df63" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">第9行</em> </strong> <br/> <em class="mq">在生产环境中运行以启动应用程序的脚本。这将执行上面的env:prod脚本，然后启动应用程序。</em></p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="30c0" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">"start:prod": "npm run env:prod &amp;&amp; node ./index.js"</strong></span></pre></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="d45e" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">测试</h2><p id="d643" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">剩下唯一要做的就是测试！我们可以通过在应用程序根目录下的shell中运行<code class="fe mx my mz na b"><strong class="ke ir">npm start</strong></code>来启动我们的应用程序。</p><p id="ea47" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果一切顺利，你应该可以将浏览器指向<code class="fe mx my mz na b">http://localhost:8800</code>并得到一条“Hello World！”。如果您更改了端口号，您将使用该端口号而不是8800。如果您尝试了该端口号，但没有得到响应，请尝试端口3000，看看它是否默认为我们指示的那样，如果有问题或它未设置。</p><blockquote class="mr ms mt"><p id="9579" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">抬头！</strong> <br/>您可以测试生产运行脚本，但是首先备份您的<strong class="ke ir"> environment.js </strong>文件，因为它将被<strong class="ke ir"><em class="iq">environment . prod . js</em></strong>文件永久覆盖！完成后，您需要将原始数据复制回<strong class="ke ir"><em class="iq">environment . js</em></strong>。要测试生产脚本，只需运行:<br/> <code class="fe mx my mz na b"><strong class="ke ir"><em class="iq">npm run start:prod</em></strong></code></p></blockquote></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="f115" class="la lb iq bd lc ld ol lf lg lh om lj lk ll on ln lo lp oo lr ls lt op lv lw lx bi translated">用集装箱装</h1><h2 id="4d0c" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">Dockerfile文件</h2><p id="e06b" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我们的应用程序已经编写好了，可以工作了。所以我们准备用集装箱装运。这就是我们将要使用Docker的地方，我们所需要的只是项目根目录下的一个简单的Docker文件。</p><p id="860d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要用<code class="fe mx my mz na b"><strong class="ke ir">touch Dockerfile</strong></code> <strong class="ke ir"> </strong>创建Dockerfile，或者只在你的GUI中创建它(VS代码有人吗？).然后，我们需要添加一些条目…</p><p id="51f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq"> Dockerfile </em> </strong></p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="3c9d" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">FROM node:alpine</strong></span><span id="5f9a" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">WORKDIR /usr/app</strong></span><span id="5f30" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">RUN apk update &amp;&amp; apk add libstdc++ &amp;&amp; apk add build-base &amp;&amp; apk add python3 &amp;&amp; apk add bash</strong></span><span id="1472" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">COPY . .</strong></span><span id="8c51" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">RUN npm install</strong></span><span id="5c40" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">COPY . .</strong></span><span id="ab09" class="ly lb iq na b gy ok nl l nm nn"><strong class="na ir">CMD ["npm", "run", "start:prod"]</strong></span></pre><p id="8b8c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好吧，让我们来看看这个文件。</p><p id="3703" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"><em class="mq">Line 1<br/></em></strong><em class="mq">我们告诉Docker使用哪个基础镜像，所以我们从一个预建了NodeJS支持的操作系统(这里是Alpine Linux——一个极其轻量级的Linux发行版)开始。<br/></em>T3】</p><p id="7548" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">第3行</em> </strong> <em class="mq"> <br/>我们设置我们的工作目录(我们将从那里运行命令，就像您本地机器上shell提示符中的工作目录一样)。<br/> </em> <code class="fe mx my mz na b"><strong class="ke ir">WORKDIR /usr/app</strong></code></p><p id="cbf1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">第5行<br/> </em> </strong> <em class="mq">通过APK包管理器安装依赖项(不要把这个和我们之前在Ubuntu上用的APT包管理器混淆了！).<br/>注意</em> <code class="fe mx my mz na b"><strong class="ke ir">apk add bash</strong></code> <em class="mq">只有当你想用shell提示符连接到容器时才需要(比如为了调试)。</em></p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="81f2" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">RUN apk update &amp;&amp; apk add libstdc++ &amp;&amp; apk add build-base &amp;&amp; apk add python3 &amp;&amp; apk add bash</strong></span></pre><p id="3739" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">第7行</em> </strong> <br/> <em class="mq">从工作目录复制文件。</em> <br/> <code class="fe mx my mz na b"><strong class="ke ir">COPY . .</strong></code></p><p id="9376" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">第9行</em> </strong> <br/> <em class="mq">安装我们在package.json的依赖项中列出的NPM包。<br/> </em> <code class="fe mx my mz na b"><strong class="ke ir">RUN npm install</strong></code></p><p id="f600" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">第11行</em> </strong> <br/> <em class="mq">现在我们已经完成了npm的安装，再次从工作目录中复制文件。</em> <br/> <code class="fe mx my mz na b"><strong class="ke ir">COPY . .</strong></code></p><p id="5427" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mq">第13行</em> </strong> <br/> <em class="mq">在容器启动时运行该命令。请注意，这与我们之前在生产模式下测试应用程序时运行的命令相同——但它是以逗号分隔的数组格式。<br/> </em> <code class="fe mx my mz na b"><strong class="ke ir">CMD ["npm", "run", "start:prod"]</strong></code></p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="c675" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">建立形象</h2><p id="0f89" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">下一步是使用<strong class="ke ir"> Dockerfile </strong>构建我们的映像。<br/> <code class="fe mx my mz na b"><strong class="ke ir">docker build --no-cache --tag test-img:v1 .</strong></code></p><p id="73fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个命令中发生了什么？ <br/> <code class="fe mx my mz na b"><strong class="ke ir">docker build</strong></code>告诉<strong class="ke ir"> <em class="mq"> Docker </em> </strong>根据Dockerfile的内容构建图像。<br/> <code class="fe mx my mz na b"><strong class="ke ir">--no-cache</strong></code>指示<strong class="ke ir"> <em class="mq"> Docker </em> </strong>不要使用其缓存，而是从头构建。尽管这需要更长的时间，但我更喜欢这种方法，以防止陈旧文件的任何潜在灾难。<br/> <code class="fe mx my mz na b"><strong class="ke ir">--tag test-img:v1</strong></code>标记图像。当您运行<code class="fe mx my mz na b"><strong class="ke ir">docker image ls -a</strong></code>来列出可用图像时，您会看到<em class="mq">存储库</em>列下的<code class="fe mx my mz na b"><strong class="ke ir">test-img</strong></code>，以及<em class="mq">标签</em>列下的<code class="fe mx my mz na b"><strong class="ke ir">v1</strong></code>。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="f708" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">运行容器</h2><p id="b2eb" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我们的形象只是一个形象，直到它被使用，在这一点上，它成为一个容器。</p><pre class="nc nd ne nf gt ng na nh ni aw nj bi"><span id="906c" class="ly lb iq na b gy nk nl l nm nn"><strong class="na ir">docker run -d -p 8800:8800 --name testcontainer --env HTTP_LISTEN_PORT=8800 test-img:v1</strong></span></pre><p id="90c5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mq">这个命令中发生了什么？</em> <br/> <code class="fe mx my mz na b"><strong class="ke ir">docker run</strong></code>告诉<strong class="ke ir"> <em class="mq"> Docker </em> </strong>从图像中初始化并运行容器。<br/> <code class="fe mx my mz na b"><strong class="ke ir">-d</strong></code>(用于<em class="mq"> detach </em>)指示<strong class="ke ir"> <em class="mq"> Docker </em> </strong>在后台运行容器(这样就不会捆绑你的shell)。<br/> <code class="fe mx my mz na b"><strong class="ke ir">-p 8800:8800</strong></code>将容器的端口暴露给宿主。如果不这样做，那么您将无法通过网络访问您的容器。<br/> <code class="fe mx my mz na b"><strong class="ke ir">--name testcontainer</strong></code>将容器的名称设置为<strong class="ke ir"><em class="mq">test container</em></strong>。没有这个，<strong class="ke ir"> <em class="mq"> Docker </em> </strong>会给它分配一个随机的名字，更难找到！。<br/> <code class="fe mx my mz na b"><strong class="ke ir">--env HTTP_LISTEN_PORT=8800</strong></code>将我们的环境变量<em class="mq"> HTTP_LISTEN_PORT </em>设置为值<em class="mq"> 8800 </em>。这允许我们在上面的<strong class="ke ir">环境. prod.js </strong>文件中使用的<em class="mq">process . env . http _ LISTEN _ PORT</em>填充我们的自定义值。<br/> <code class="fe mx my mz na b"><strong class="ke ir">test-img:v1</strong></code>最后我们告诉<strong class="ke ir"> <em class="mq"> Docker </em> </strong>要拉哪个图像运行。对于这篇文章，我们可能应该拉我们上面建立的那个！请注意，我们确实给了它存储库和标记名称。</p><blockquote class="mr ms mt"><p id="4d7e" class="kc kd mq ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz ij bi translated"><strong class="ke ir">注意</strong> <br/>由于我们的应用程序正在监听端口8800，我们通过<code class="fe mx my mz na b"><strong class="ke ir"><em class="iq">-p 8800:8800</em></strong></code>将其映射到同一个端口。但是，如果您想将应用程序的端口8800映射到主机的端口7080(作为一个例子)，那么命令应该是<code class="fe mx my mz na b"><strong class="ke ir"><em class="iq">-p 7080:8800</em></strong></code>。</p></blockquote><p id="9395" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果这个命令成功，您应该得到一个随机字符串，比如:<code class="fe mx my mz na b"><strong class="ke ir">a056f52b3cdf9346601b46a3d1b9ec323a1ce04c0c97fd1908419acf625e16ee</strong></code></p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="8346" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">测试容器</h2><p id="17f9" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">现在，剩下要做的就是测试它！</p><p id="6db9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">打开你的浏览器到http://localhost:8800 ，你应该得到一个简单的“Hello World！”。</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/9461755340f1260d90331d27dfed2fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZU1fv7nv39bIL-5QuvP8Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">浏览器中的Hello World</figcaption></figure></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="e611" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">清理</h2><p id="f76a" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">既然我们已经成功地测试了，让我们清理一下。</p><p id="1155" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">1.停止运行容器。<br/> <code class="fe mx my mz na b"><strong class="ke ir">docker kill testcontainer</strong></code></p><p id="8a6f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.移除容器。<br/> <code class="fe mx my mz na b"><strong class="ke ir">docker rm testcontainer</strong></code></p><p id="73ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.从本地<strong class="ke ir"> <em class="mq"> Docker </em> </strong>库中删除镜像。<br/> <code class="fe mx my mz na b"><strong class="ke ir">docker image rm test-img:v1</strong></code></p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="06a2" class="la lb iq bd lc ld ol lf lg lh om lj lk ll on ln lo lp oo lr ls lt op lv lw lx bi translated">搞定了。</h1><p id="a6ed" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">希望本文已经帮助您开始使用NodeJS和容器化它的基础知识。一旦你准备好了，一定要看看更高级的主题，如:<br/> <a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/up-and-running-with-azure-kubernetes-service-aks-and-devops-pipelines-2208c24378ff">使用Azure Kubernetes服务(AKS)和DevOps管道运行</a></p></div></div>    
</body>
</html>