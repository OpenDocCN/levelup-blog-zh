<html>
<head>
<title>How to Create a Python Plugin System with Stevedore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Stevedore创建一个Python插件系统</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-python-plugin-system-with-stevedore-17d4b4917b57?source=collection_archive---------23-----------------------#2021-11-30">https://levelup.gitconnected.com/how-to-create-a-python-plugin-system-with-stevedore-17d4b4917b57?source=collection_archive---------23-----------------------#2021-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/88c04764c37f7e63b4cf37adff65837c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Bnexfyx193kZ6u24.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@kieran_wood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">基兰伍德</a>在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f082" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我经常看到和听到的一个问题是如何使用Python插件系统来扩展应用程序。对于测试工程师来说，这通常与硬件抽象有关。对于其他人，他们可能希望将核心功能与扩展分开。通过这种方法，可以简化部署，只需通过各自的软件包安装所需的组件。不管是什么原因，有几个库可以解决这个问题。在本文中，将使用<a class="ae kc" href="https://pypi.org/project/stevedore/" rel="noopener ugc nofollow" target="_blank"> Stevedore </a>库构建一个简单的抽象层，我们将介绍构建插件的主要概念。</p><p id="c54e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章中的代码可以在https://github.com/chinghwayu/plugin_tutorial获得。</p><p id="b31d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:虽然代码说明了中继和硬件抽象层，但是相同的概念也可以用于服务，比如带有软件抽象层的数据库。</p><h1 id="e260" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">插件架构</h1></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="79bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管使用什么插件框架，插件实现背后的架构大多是相同的。</p><ul class=""><li id="7494" class="mg mh iq kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">定义抽象基类</li><li id="7970" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">定义从基类继承的插件类</li></ul><h1 id="aaf5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">抽象基类</h1><p id="caa3" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">对于Python插件系统中相似类型的插件，通常有一些共同的功能。基于协议或规范的插件通常具有共同的基本功能。例如，符合IEEE 488.2标准的仪器必须响应对其标识的查询。</p><p id="bd8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管抽象部分有时会被省略，但这是重要的一步，因为它通过定义必须实现哪些方法来建立每个插件的基本结构。在Python中，这是通过模块<a class="ae kc" href="https://docs.python.org/3/library/abc.html" rel="noopener ugc nofollow" target="_blank"> abc </a>来完成的。</p><p id="c3cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所示示例用三种方法定义了一个基本的继电器乐器驱动程序:连接、断开和重新连接。在<code class="fe mz na nb nc b">__init__</code>方法中，<code class="fe mz na nb nc b">connected</code>属性是为状态建立的，因为这在所有插件之间是通用的。</p><p id="930c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于其他抽象方法，只需要文档字符串。没有必要包含<code class="fe mz na nb nc b">pass</code>或其他代码。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="0260" class="nl lc iq nc b gy nm nn l no np">from abc import ABCMeta, abstractmethod<br/><br/><br/>class RelayBase(metaclass=ABCMeta):<br/>    """Base class for relay plugins"""<br/><br/>    def __init__(self) -&gt; None:<br/>        """Define base attributes."""<br/>        self.connected = False<br/><br/>    @abstractmethod<br/>    def disconnect(self) -&gt; None:<br/>        """Disconnects relay."""<br/><br/>    @abstractmethod<br/>    def connect(self) -&gt; None:<br/>        """Connects relay."""<br/><br/>    @abstractmethod<br/>    def reconnect(self, seconds: int) -&gt; None:<br/>        """Disconnects for specified time and reconnects.<br/>        Args:<br/>            seconds (int): Amount of time to sleep between disconnect and connect.<br/>        """</span></pre><h1 id="916c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">插件类</h1><p id="da78" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">当定义实际的实现时，每个插件都将从插件基类继承。在这个例子中，定义了两个继承自<code class="fe mz na nb nc b">RelayBase</code>的插件。</p><p id="0e51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mz na nb nc b">__init__</code>方法中，进行了一个<code class="fe mz na nb nc b">super()</code>调用来创建其他方法将更新的<code class="fe mz na nb nc b">connected</code>属性。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="56b5" class="nl lc iq nc b gy nm nn l no np">class RelayOne(RelayBase):<br/>    def __init__(self):<br/>        super().__init__()<br/><br/>    def disconnect(self):<br/>        self.connected = False<br/>        print("Disconnected One")<br/><br/>    def connect(self):<br/>        self.connected = True<br/>        print("Connected One")<br/><br/>    def reconnect(self, seconds: int = 5):<br/>        self.seconds = seconds<br/>        self.disconnect()<br/>        print(f"One paused for {seconds} seconds...")<br/>        self.connect()<br/><br/><br/>class RelayTwo(RelayBase):<br/>    def __init__(self):<br/>        super().__init__()<br/><br/>    def disconnect(self):<br/>        self.connected = False<br/>        print("Disconnected Two")<br/><br/>    def connect(self):<br/>        self.connected = True<br/>        print("Connected Two")<br/><br/>    def reconnect(self, seconds: int = 5):<br/>        self.seconds = seconds<br/>        self.disconnect()<br/>        print(f"Two paused for {seconds} seconds...")<br/>        self.connect()</span></pre><p id="03d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一点上，你可能认为这是建立一个Python插件系统所需要的。对于简单的插件，这可能是真的。但是，请考虑以下情况:</p><ul class=""><li id="bb09" class="mg mh iq kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">我们如何决定在运行时调用哪个插件？</li><li id="4a4b" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">我们如何在实现之间轻松切换？</li><li id="e5ec" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">如何才能将这些插件打包发行？</li><li id="0aac" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">我们如何测试接口以确保正确的实现被调用？</li></ul><p id="2e37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于简单的应用程序或脚本，我们可以简单地直接调用特定的实现并硬编码。但是请考虑这样一种情况，您可能正在与另一个位置的队友共享代码，而他们没有相同的中继。我们不想用硬编码的替代实现来维护同一代码的另一个版本。我们需要的是在不改变任何代码的情况下在实现之间轻松切换的方法。应该进行的唯一更改是在运行时使用的实现的配置文件中。</p><h1 id="b7ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">插件入口点</h1><p id="bd0c" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">有几种方法可以发现和加载插件。对于Stevedore，它使用<a class="ae kc" href="https://docs.python.org/3/library/importlib.metadata.html#entry-points" rel="noopener ugc nofollow" target="_blank">入口点</a>来建立键，这些键可以作为指向特定代码位置的指针进行查询。这与软件包中常见的机制相同，一旦安装到环境中，就可以将Python代码作为命令行脚本启动。虽然这使用了内置的<code class="fe mz na nb nc b">console_scripts</code>类型的入口点，但是为了管理插件，可以创建定制的入口点类型。</p><p id="91e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于用插件扩展应用程序的完整讨论，请观看《码头工人》的作者Doug Hellman在2013年PyCon上的演讲。该演示将装卸工采用的方法与当时其他现有的方法进行了比较。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="392b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当构建用于分发的包时，我们可以添加入口点，这样当它被安装到Python环境中时，环境就可以立即从已建立的键中知道插件的位置。添加入口点很简单。在包的<code class="fe mz na nb nc b">setup.py</code>中，将字典分配给<code class="fe mz na nb nc b">setup</code>的<code class="fe mz na nb nc b">entry_points</code>参数。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="c7f3" class="nl lc iq nc b gy nm nn l no np">from setuptools import setup<br/><br/>setup(<br/>    entry_points={<br/>        "plugin_tutorial": [<br/>            "relay1 = relay:RelayOne",<br/>            "relay2 = relay:RelayTwo",<br/>        ],<br/>    },<br/>)</span></pre><p id="24d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">plugin_tutorial</code>键被用作插件名称空间。每个插件的名字被定义为<code class="fe mz na nb nc b">relay1</code>和<code class="fe mz na nb nc b">relay2</code>。插件的位置被定义为模块名和模块内的类，用冒号、<code class="fe mz na nb nc b">relay:RelayOne</code>和<code class="fe mz na nb nc b">relay:RelayTwo</code>分隔。</p><p id="fb4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们正在使用插件，但不需要作为软件包安装，我们可以将它们注册到Stevedore的入口点缓存中。这对于开发和实现单元测试非常有用。</p><p id="9f27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的示例检查指定入口点的命名空间。如果入口点不存在，它将被添加。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ns nr l"/></div></figure><h1 id="3893" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">管理插件</h1><p id="91d3" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">使用Stevedore，有几种方法可以管理Python插件系统中的插件。</p><ul class=""><li id="a086" class="mg mh iq kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">驱动程序—单一名称、单一入口点</li><li id="4a5b" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">钩子——单个名字，多个入口点</li><li id="a6cc" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">扩展—许多名称、许多入口点</li></ul><p id="d732" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于本文，将讨论驱动程序方法，因为这是最常见的用例。看一下装卸工文档，其中讨论了其他方法的<a class="ae kc" href="https://docs.openstack.org/stevedore/latest/user/patterns_loading.html" rel="noopener ugc nofollow" target="_blank">装载模式</a>。</p><p id="287f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于一个驱动程序，我们需要调用<code class="fe mz na nb nc b"><a class="ae kc" href="https://docs.openstack.org/stevedore/latest/reference/index.html#stevedore.driver.DriverManager" rel="noopener ugc nofollow" target="_blank">DriverManager</a></code>。在参数表中，只有<code class="fe mz na nb nc b">namespace</code>和<code class="fe mz na nb nc b">name</code>是必需的，它们与入口点直接相关。可选参数可用，本例中使用的是<code class="fe mz na nb nc b">invoke_on_load</code>。虽然relay示例只建立了一个类属性，但是对于实际的仪器驱动程序，我们通常需要执行某种初始化。这可以在加载插件时执行。</p><p id="7b56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用<a class="ae kc" href="https://docs.openstack.org/stevedore/latest/reference/index.html#stevedore.driver.DriverManager" rel="noopener ugc nofollow" target="_blank">驱动管理器</a>将返回一个管理器对象。实际的驱动程序对象可以通过<code class="fe mz na nb nc b">driver</code>属性来访问。根据这个属性，我们还可以创建抽象方法来调用驱动程序方法。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="55ef" class="nl lc iq nc b gy nm nn l no np">from stevedore import driver<br/><br/><br/>class Relay:<br/>    def __init__(self, name="", **kwargs) -&gt; None:<br/>        self._relay_mgr = driver.DriverManager(<br/>            namespace="plugin_tutorial",<br/>            name=name,<br/>            invoke_on_load=True,<br/>            invoke_kwds=kwargs,<br/>        )<br/><br/>    @property<br/>    def driver(self):<br/>        return self._relay_mgr.driver<br/><br/>    def disconnect(self) -&gt; None:<br/>        self.driver.disconnect()<br/><br/>    def connect(self) -&gt; None:<br/>        self.driver.connect()<br/><br/>    def reconnect(self, seconds: int = 5) -&gt; None:<br/>        self.driver.reconnect(seconds)</span></pre><p id="db23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有使用<code class="fe mz na nb nc b">**kwargs</code>参数，但包含该参数是为了展示如何将参数传递给可能具有不同初始化参数的驱动程序。</p><p id="695c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">driver</code>方法的<code class="fe mz na nb nc b">@property</code>装饰器是语法糖，为驱动程序对象提供快捷方式。如果没有提供，我们需要调用驱动程序的<code class="fe mz na nb nc b">disconnect</code>方法，如下所示:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="e3ca" class="nl lc iq nc b gy nm nn l no np">r = Relay(name="relay1")<br/>r._relay_mgr.driver.disconnect()</span></pre><h1 id="8386" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">把它放在一起</h1><p id="acfd" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">对于安装在Python环境中的插件，入口点是在安装包时建立的。通过抽象接口，我们可以决定在运行时加载哪个插件。这里展示的是一个调用插件及其每个方法的单元测试。</p><p id="6b67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了运行它，我们需要首先作为一个包安装。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="2c2c" class="nl lc iq nc b gy nm nn l no np">$ pip install -e /path/to/plugin_tutorial<br/>...<br/>Installing collected packages: plugin-tutorial<br/>  Running setup.py develop for plugin-tutorial<br/>Successfully installed plugin-tutorial<br/>$ pip list | grep plugin_tutorial<br/>plugin-tutorial 1.0.0    /path/to/plugin_tutorial</span></pre><p id="f614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试代码:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="a68e" class="nl lc iq nc b gy nm nn l no np">from relay import Relay<br/><br/><br/>def test_installed_plugin():<br/>    r1 = Relay(name="relay1")<br/>    assert isinstance(r1, Relay)<br/>    assert r1.driver.connected == False<br/>    r1.disconnect()<br/>    assert r1.driver.connected == False<br/>    r1.connect()<br/>    assert r1.driver.connected == True<br/>    r1.reconnect(7)<br/>    assert r1.driver.seconds == 7<br/><br/>    r2 = Relay(name="relay2")<br/>    assert isinstance(r2, Relay)<br/>    assert r2.driver.connected == False<br/>    r2.disconnect()<br/>    assert r2.driver.connected == False<br/>    r2.connect()<br/>    assert r2.driver.connected == True<br/>    r2.reconnect(9)<br/>    assert r2.driver.seconds == 9</span></pre><p id="74e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要调用未通过软件包安装过程安装的插件，我们需要首先注册，然后调用插件。这对于编写包含虚拟插件的单元测试非常有用。显示的是注册了插件的相同单元测试。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="a5a0" class="nl lc iq nc b gy nm nn l no np">from relay import Relay<br/>from register_plugin import register_plugin<br/><br/><br/>def test_register_plugin():<br/>    namespace = "plugin_tutorial"<br/>    register_plugin(<br/>        name="relay1",<br/>        namespace=namespace,<br/>        entry_point="relay:RelayOne",<br/>    )<br/>    register_plugin(<br/>        name="relay2",<br/>        namespace=namespace,<br/>        entry_point="relay:RelayTwo",<br/>    )<br/>    r1 = Relay(name="relay1")<br/>    assert isinstance(r1, Relay)<br/>    assert r1.driver.connected == False<br/>    r1.disconnect()<br/>    assert r1.driver.connected == False<br/>    r1.connect()<br/>    assert r1.driver.connected == True<br/>    r1.reconnect(7)<br/>    assert r1.driver.seconds == 7<br/><br/>    r2 = Relay(name="relay2")<br/>    assert isinstance(r2, Relay)<br/>    assert r2.driver.connected == False<br/>    r2.disconnect()<br/>    assert r2.driver.connected == False<br/>    r2.connect()<br/>    assert r2.driver.connected == True<br/>    r2.reconnect(9)<br/>    assert r2.driver.seconds == 9</span></pre><h1 id="6719" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">资源</h1><p id="f97b" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">欲了解更多信息:</p><ul class=""><li id="2b9b" class="mg mh iq kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">教程代码—<a class="ae kc" href="https://github.com/chinghwayu/plugin_tutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/chinghwayu/plugin_tutorial</a></li><li id="9658" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">装卸工用户指南—<a class="ae kc" href="https://docs.openstack.org/stevedore/latest/user/index.html" rel="noopener ugc nofollow" target="_blank">https://docs.openstack.org/stevedore/latest/user/index.html</a></li><li id="843d" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">抽象基类—<a class="ae kc" href="https://docs.python.org/3/library/abc.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/abc.html</a></li><li id="09e0" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">入口点—<a class="ae kc" href="https://docs.python.org/3/library/importlib.metadata.html#entry-points" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/library/import lib . metadata . html #入口点</a></li><li id="b0da" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">PyCon 2013装卸工展示—<a class="ae kc" href="https://youtu.be/7K72DPDOhWo" rel="noopener ugc nofollow" target="_blank">https://youtu.be/7K72DPDOhWo</a></li><li id="1ca9" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">Yapsy(又一个插件系统)——<a class="ae kc" href="http://yapsy.sourceforge.net/" rel="noopener ugc nofollow" target="_blank">http://yapsy.sourceforge.net/</a></li><li id="e079" class="mg mh iq kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">Pluggy (Pytest插件系统)——<a class="ae kc" href="https://pluggy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">https://pluggy.readthedocs.io/en/stable/</a></li></ul></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="09fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nt">原载于2021年11月30日</em><a class="ae kc" href="https://chinghwayu.com/2021/11/how-to-create-a-python-plugin-system-with-stevedore/" rel="noopener ugc nofollow" target="_blank"><em class="nt">https://chinghwayu.com</em></a><em class="nt">。</em></p></div></div>    
</body>
</html>