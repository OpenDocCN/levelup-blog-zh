<html>
<head>
<title>JavaScript Problem Solvers: Count Negatives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题解决者:计算负数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-problem-solvers-count-negatives-bd182f609551?source=collection_archive---------6-----------------------#2020-08-23">https://levelup.gitconnected.com/javascript-problem-solvers-count-negatives-bd182f609551?source=collection_archive---------6-----------------------#2020-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ed3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">案例012:展平矩阵</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dc497af0e2c2386cea9a2e0638ba7229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QiTmDOyzWaVUCJSEwqzQpQ.png"/></div></div></figure><p id="8488" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本周，我们将回到矩阵，因为它们非常有趣。太有趣了。</p><p id="ec17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">手头的问题不像我们以前解决的问题那样困难，比如<code class="fe lq lr ls lt b">Rotate Image Matrix</code>或<code class="fe lq lr ls lt b">Minimum Time Visiting All Points</code>，但仍然提供了一个很好的练习，让你可以用不同的方法在2D矩阵中处理数据。</p><p id="71f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，让我们开始解决。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="3591" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">问题是</h2><p id="0d25" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><a class="ae mz" href="https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">这里是LeetCode </strong> </a>上问题的链接</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="944f" class="mb mc it lt b gy ne nf l ng nh">Given a m * n matrix grid which is sorted in non-increasing order both row-wise and column-wise.</span><span id="9cda" class="mb mc it lt b gy ni nf l ng nh">Return the number of negative numbers in grid.</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="abac" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">制约因素</h2><p id="880d" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们得到的约束条件是处理2D矩阵问题的标准约束条件。在这一点上，他们是我们所期待的。但是，和往常一样，仔细检查每个约束以确保我们知道我们在处理什么是一个好主意:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="ee4e" class="mb mc it lt b gy ne nf l ng nh">m == grid.length</span></pre><p id="44e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们得到了一个<code class="fe lq lr ls lt b">m * n</code>矩阵<code class="fe lq lr ls lt b">grid</code>，所以给定矩阵中的行和列的数量是线性独立的。我们可以拥有比列更多的行，也可以拥有比行更多的列。<code class="fe lq lr ls lt b">m</code>表示对于任何给定的矩阵，我们应该期望的行数。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="b4fe" class="mb mc it lt b gy ne nf l ng nh">n == grid[i].length</span></pre><p id="766a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">n</code>代表我们应该期待的列数。这里也没什么异常。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="7e08" class="mb mc it lt b gy ne nf l ng nh">1 &lt;= m, n &lt;= 100</span></pre><p id="a5db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们得到了我们期望看到的行数或列数的上限和下限。有了下限<code class="fe lq lr ls lt b">1 &lt;=</code>，我们可以相信不必担心处理空行或空列的事实。上限并不重要，但是如果我们想提出一些定制的测试用例，<code class="fe lq lr ls lt b">&lt;= 100</code>的上限给了我们足够的信息。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="4665" class="mb mc it lt b gy ne nf l ng nh">-100 &lt;= grid[i][j] &lt;= 100</span></pre><p id="cccd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">grid[i][j]</code>表示矩阵中的每个元素，这个约束给了我们每个元素的上下限。由于这是一个严格处理每个元素的值以及一个元素是否是负数的问题，<code class="fe lq lr ls lt b">-100 &lt;=</code>的下限完全有意义，<code class="fe lq lr ls lt b">&lt;= 100</code>的上限也是如此。很高兴知道我们将不必处理任何真正大的数字。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="d643" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">测试</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="3dfb" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">崩溃了</h2><p id="e536" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这个问题的解释和范围相当简单，尽管可能会有一些技巧。因此，像往常一样，让我们分解问题解释的每一行，寻找任何可能引导我们找到解决方案的线索，并确保我们理解我们的任务是解决什么:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="3b2e" class="mb mc it lt b gy ne nf l ng nh">Given a m * n matrix grid which is sorted in non-increasing order both row-wise and column-wise.</span></pre><p id="9297" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">直截了当。正是我喜欢的方式。让我们进一步分解第一部分，因为我们已经在一句话中获得了大量信息:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="155b" class="mb mc it lt b gy ne nf l ng nh">Given a m * n matrix grid</span></pre><p id="3e62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b"><em class="nl">Given a m * n matrix grid</em></code>简单地说就是给定矩阵中的行和列的数量彼此独立。这暗中告诉我，即使我们的一些测试用例可能有相同数量的行和列，其他的可能没有，我们不能同时迭代行和列。如果我们想这样做，我们就必须找到不同的解决办法。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="37bc" class="mb mc it lt b gy ne nf l ng nh">sorted in non-increasing order</span></pre><p id="e990" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b"><em class="nl">sorted in non-increasing order</em></code>是<code class="fe lq lr ls lt b"><em class="nl">sorted in a decreasing order</em></code>的另一种说法，也是<em class="nl">的另一种说法，“数字一直在变小。”</em>这很有帮助，告诉我我们不必担心如何对<code class="fe lq lr ls lt b">grid</code>或<code class="fe lq lr ls lt b">grid[i]</code>中的元素进行排序。这项工作已经为我们做好了。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="fd70" class="mb mc it lt b gy ne nf l ng nh">both row-wise and column-wise</span></pre><p id="e6e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这甚至比以非递增顺序排列元素更有帮助。不仅对每一行进行排序，而且对每一列也进行排序。这意味着矩阵中的第一个元素将始终是整个矩阵中最大的数字，而矩阵中的最后一个数字将始终是整个矩阵中最小(或最负)的数字。</p><p id="8272" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们看一下测试用例1，我们可以自己看到这一点:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="c796" class="mb mc it lt b gy ne nf l ng nh">[ 4, 3, 2, -1]<br/>[ 3, 2, 1, -1]<br/>[ 1, 1,-1, -2]<br/>[-1,-1,-2,-3]</span></pre><p id="73c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">~</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="45b9" class="mb mc it lt b gy ne nf l ng nh">Return the number of negative numbers in grid.</span></pre><p id="5359" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单地说，我们的任务是这样的。我们需要找出一种有效的方法来遍历给定的矩阵，并确定一个元素是负的还是正的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="2d9c" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">嫌疑人</h2><p id="fbbd" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我想到了两个不同但相似的解决方案:一个是嵌套循环，另一个是扁平矩阵。这两种方法都将以独特的方式迭代通过<code class="fe lq lr ls lt b">grid</code>,但仍然产生我们想要的结果。</p><p id="1c35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们需要确定一个数字是否是负数，所以我们可以使用<code class="fe lq lr ls lt b">Math.sign()</code>。<code class="fe lq lr ls lt b">Math.sign()</code>将<code class="fe lq lr ls lt b">return</code> 1如果一个数是正数，0如果一个数是零，和-1如果一个数是负数。</p><p id="c5f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要<code class="fe lq lr ls lt b">return</code>矩阵中负数的数量，我们可以用一个计数器变量来跟踪它。</p><p id="b17a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们只关心一个数字是否是负数。0和正数没关系。所以，如果<code class="fe lq lr ls lt b">Math.sign(&lt;a number&gt;) === -1</code>，我们递增计数器。</p><p id="a5d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们两种解决方案的相似之处。由于我们的任务相当简单，我们可以将注意力转向找出一种有效的方法来迭代给定的矩阵。</p><p id="6c66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以采取两种方法:</p><p id="6655" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">解决方案#1:向后嵌套迭代</strong></p><p id="6f0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们不想变异<code class="fe lq lr ls lt b">grid</code>，我们可以利用给定矩阵的顺序。由于<code class="fe lq lr ls lt b">grid</code>在行和列上都是按非递增顺序排序的，我们可以从<code class="fe lq lr ls lt b">grid</code>的最后一个元素开始遍历<code class="fe lq lr ls lt b">grid</code>的每个子数组。这是我们最有可能找到一个包含负数的子数组的地方。我们也可以从每个子数组<code class="fe lq lr ls lt b">grid[i][j]</code>的最后一个元素开始，因为在那里我们最有可能找到一个负数。</p><p id="adcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从<code class="fe lq lr ls lt b">grid</code>的末尾开始，到<code class="fe lq lr ls lt b">grid[i]</code>的末尾，我们可以迭代<code class="fe lq lr ls lt b">grid[i]</code>并检查<code class="fe lq lr ls lt b">Math.sign(grid[i][j]) === -1</code>是否存在，如果存在，则递增我们的计数器。</p><p id="4479" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe lq lr ls lt b">Math.sign(grid[i][j]) !== -1</code>，那么<code class="fe lq lr ls lt b">grid[i][j]</code>必须是一个正数(或0)，并且由于<code class="fe lq lr ls lt b">grid[i]</code>是按非递增顺序排序的，我们在<code class="fe lq lr ls lt b">grid[i]</code>中找不到更多的负数，子数组的其余部分必须用正数填充。</p><p id="9b10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦<code class="fe lq lr ls lt b">Math.sign(grid[i][j]) !== -1</code>，我们就可以脱离迭代了。</p><p id="5c11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个解决方案的唯一问题是我们需要嵌套一个迭代来访问<code class="fe lq lr ls lt b">grid[i][j]</code>，在最坏的情况下，它将在<code class="fe lq lr ls lt b">O(n²)</code>时间内运行。</p><p id="51ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为我们可以做得更好。</p><p id="6c0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">解决方案2:扁平化的单一迭代</strong></p><p id="19ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以<code class="fe lq lr ls lt b">grid</code>的非递增顺序只在行和列的上下文中有关系。因为我们需要做的就是确定一个数是否是负数，所以顺序并不重要。如果我们去掉所有的行和列，只展平矩阵会怎么样？</p><p id="022c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们展平<code class="fe lq lr ls lt b">grid</code>并将展平后的矩阵设置为类似于<code class="fe lq lr ls lt b">flatGrid</code>的变量，我们可以使用一次迭代遍历<code class="fe lq lr ls lt b">flatGrid</code>并运行与第一个解决方案中相同的<code class="fe lq lr ls lt b">if</code>语句。这确实意味着我们需要检查每个元素，而不能中断迭代。</p><p id="6b3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以对<code class="fe lq lr ls lt b">flatGrid</code>进行排序，但是如果我们在<code class="fe lq lr ls lt b">flatGrid</code>上调用<code class="fe lq lr ls lt b">.sort()</code>来这样做，我们实际上会增加我们的时间复杂度，因为<code class="fe lq lr ls lt b">.sort()</code>通常根据您的运行时环境使用合并和快速排序方法。这两种方法通常在<code class="fe lq lr ls lt b">O(n log n)</code>时间内运行，尽管如果<code class="fe lq lr ls lt b">flatGrid</code>开始变大，合并排序将在<code class="fe lq lr ls lt b">O(n²)</code>时间内结束。</p><p id="2651" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，给定我们的约束<code class="fe lq lr ls lt b">1 &lt;= m, n &lt;= 100</code>，遍历未排序的展平数组实际上会更快。</p><p id="2198" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也可以用<code class="fe lq lr ls lt b">[].concat.apply([], grid)</code>代替<code class="fe lq lr ls lt b">grid.flat()</code>，因为当我们事先不知道数组的长度时，这是一种更有效的展平数组的方法。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="f96a" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">伪代码</h2><p id="4363" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">现在，我们已经完成了几个解决方案，让我们在编写任何代码之前尝试编写一些伪代码:</p><p id="5e6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">解决方案#1:向后嵌套迭代</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b963" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">解决方案#2:扁平化单次迭代</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9082" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="8f40" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">代码</h2><p id="85af" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">现在我们已经知道了我们的两种解决方案应该如何工作，让我们看看它们是否可行:</p><p id="0345" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">解决方案#1:向后嵌套迭代</strong></p><p id="905b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们定义我们的计数器变量，<code class="fe lq lr ls lt b">count</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="80c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们设置两个<code class="fe lq lr ls lt b">for</code>循环。两者分别从<code class="fe lq lr ls lt b">grid</code>和<code class="fe lq lr ls lt b">grid[i]</code>的末端开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7e79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们需要做的就是添加一个逻辑来检查一个数字是否是负数，如果是，就增加<code class="fe lq lr ls lt b">count</code>，如果不是，就停止迭代:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4e5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们添加我们的<code class="fe lq lr ls lt b">return</code>值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2379" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看它是否有效:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9ca5ed6cd1be5e46c496f2d1399e6e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*hl5cfPT51snDmMWZvpkFow.png"/></div></figure><p id="fa59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。</p><p id="103f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">解决方案#2:扁平化单次迭代</strong></p><p id="ed44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们再一次定义出<code class="fe lq lr ls lt b">count</code>变量，以及我们展平的<code class="fe lq lr ls lt b">grid</code>变量<code class="fe lq lr ls lt b">flatGrid</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f6d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们设置我们的<code class="fe lq lr ls lt b">for in</code>循环来遍历<code class="fe lq lr ls lt b">flatGrid</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fe14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们可以添加相同的逻辑来检查一个数字是否为负，并从第一个解开始增加<code class="fe lq lr ls lt b">count</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="380a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们可以添加我们的<code class="fe lq lr ls lt b">return</code>值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4cc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看这是否也有效:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/99bd2268928e04a39b3dffab02958e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*7p3tEyRJq2woxvoh9e2qDg.png"/></div></figure><p id="ef78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="01e5" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">最终解决方案</h2><p id="0d48" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">让我们最后看一下不带注释的解决方案，并清理一些语法:</p><p id="0bb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">解决方案#1:向后嵌套迭代</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8e21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">解决方案2:扁平化的单次迭代</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3230" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="3713" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">任务完成</h2><p id="31a7" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">虽然<code class="fe lq lr ls lt b">countNegatives</code>并不是最困难或最复杂的问题，但我认为我们提出的两个解决方案都是不同的，也足够有趣，值得写一篇关于解决<code class="fe lq lr ls lt b">countNegatives</code>问题的博客。</p><p id="6f9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我很清楚我的解决方案不会是最好或最有效的，但我希望它们能帮助你或其他人找到一种方法来解决你在这个旅程中遇到的问题，我们称之为JavaScript。</p><p id="8d38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管怎样，我希望你得到了一些有用的信息，希望你所有的函数都返回true，所有的请求都用200来响应。</p><p id="6e6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">保持安全…保持健康…继续为正义而战。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b4f3" class="no mc it bd md np nq nr mg ns nt nu mj jz nv ka mm kc nw kd mp kf nx kg ms ny bi translated">分级编码</h1><p id="f74d" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">感谢您成为我们社区的一员！<a class="ae mz" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae mz" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="nz oa gp gr ob oc"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">编写面试问题</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">掌握编码面试的过程</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">技术开发</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div></div></div>    
</body>
</html>