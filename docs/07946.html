<html>
<head>
<title>How To Create Java Services Without Spring Bloat</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建没有Spring膨胀的Java服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-java-services-without-spring-bloat-bd9aba653a55?source=collection_archive---------12-----------------------#2021-03-23">https://levelup.gitconnected.com/how-to-create-java-services-without-spring-bloat-bd9aba653a55?source=collection_archive---------12-----------------------#2021-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2179" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当你无法透过铃声和哨声看到森林</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9cdf0976d2dd19102fe79065afdec6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*083lbc0UVxCN_t7TKkBJQA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@andrewcoelho?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安德鲁·科埃略</a>在<a class="ae ky" href="https://unsplash.com/s/photos/forest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="36c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直在做一系列模拟二手车进气平台的微服务，截至目前，我已经成功避免了春天。当你需要所有的东西时，Spring是一个很好的框架，但是有时候你只需要一个简单的服务，不想要20-30秒的启动时间。</p><p id="d1f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢用JavaScript做简单的小服务的原因之一是它没有开销和样板文件。在微服务的世界里，越小越好，我认为如此多的人在微服务上取得成功失败的原因是他们仍然像建造一个整体一样建造它们。Spring很好地完成了将你的整体连接在一起的工作，但是如果你的服务真的是微服务，就不需要那么多的组装，Spring是多余的。</p><p id="78d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我习惯于用JavaScript制作简单的类似REST的服务，我惊喜地发现有一个名为<a class="ae ky" href="https://github.com/Simonwep/java-express" rel="noopener ugc nofollow" target="_blank"> Java Express </a>的Java库试图模仿JavaScript library Express。我的二手车进气平台的一个问题是它还没有输入或输出服务，所以你必须用测试生成器创建输入数据，你只能通过查看日志和直接在数据库中确认事情是否正常。本文将使用Java Express库制作一个简单的类似REST的输入和输出服务。</p><p id="b34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做的第一件事是添加依赖项。在<a class="ae ky" href="https://github.com/rkamradt/usedvehicles/tree/v0.9" rel="noopener ugc nofollow" target="_blank">这个库</a>中工作，我编辑主<code class="fe lv lw lx ly b">pom.xml</code>并将包括<code class="fe lv lw lx ly b">&lt;version&gt;</code>在内的全部依赖项添加到<code class="fe lv lw lx ly b">&lt;dependencyManagement&gt;</code>部分:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="abca" class="md me it ly b gy mf mg l mh mi">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.github.Simonwep&lt;/groupId&gt;<br/>  &lt;artifactId&gt;java-express&lt;/artifactId&gt;<br/>  &lt;version&gt;0.0.10&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="014e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还将模块添加到了<code class="fe lv lw lx ly b">&lt;modules&gt;</code>部分:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="972e" class="md me it ly b gy mf mg l mh mi">&lt;module&gt;vehicleservice&lt;/module&gt;</span></pre><p id="3edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的是，多模块pom.xml文件中的模块引用子模块所在的目录，而不是工件ID，即使它们经常是相同的。接下来，我设置新的模块，我手动完成，因为当您添加新的模块时，IDE有时会感到困惑。我做了一个名为<code class="fe lv lw lx ly b">vehicleservice</code>的目录，复制了<code class="fe lv lw lx ly b">carconsumer/pom.xml</code>并修改了<code class="fe lv lw lx ly b">&lt;artifactId&gt;</code>和<code class="fe lv lw lx ly b">&lt;name&gt;</code>。我还添加了上面提到的依赖项，但是没有版本(版本继承自<code class="fe lv lw lx ly b">&lt;dependencyManagement&gt;</code>部分)。然后我为Maven、<code class="fe lv lw lx ly b">src/main/java</code>和<code class="fe lv lw lx ly b">src/main/resource</code>创建标准的目录集。由于我在过去处理微服务时解释过的原因，我没有创建单元测试。</p><p id="89c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个项目中，我使用了IntelliJ思想，它在使用Java时做得很好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/5981a2c643cce0085ceead2082f2b94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6F-sNP0nePS-Ul61t-XGA.png"/></div></div></figure><p id="c466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">习惯所有不同的想法是有好处的。您可能不得不使用的一些代码库只有特定的项目文件。我总是让我的项目基于Maven，然后我将IDE项目文件添加到<code class="fe lv lw lx ly b">.gitignore</code>文件中，以允许人们使用他们想要的任何IDE。Maven pom文件还允许您在没有任何IDE的情况下在构建服务器上进行构建，并且大多数IDE都能够从Maven pom引导项目。</p><p id="3f81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个服务，我需要一些东西，输入和输出有效载荷和主类。主类中的所有东西都应该很好地适应，所以我不打算创建很多不同的类。当我说微服务时，我真正的意思是微服务。此外，从其他项目中复制<code class="fe lv lw lx ly b">application.properties</code>文件，这样您的测试配置缺省值将会就位。</p><p id="08af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我打算从小处着手，逐步积累，然后在每一步进行测试。首先，我将用一个GET端点创建主类，我可以用Postman测试它。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="976e" class="md me it ly b gy mf mg l mh mi">public class VehicleService {<br/>    public static void main(String [] args) {<br/>        Express app = new Express();<br/>        app.get("/", (req, res) -&gt; res.send("Hello index!"));<br/>        app.listen();    <br/>    }<br/>}</span></pre><p id="8705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再简单不过了！运行它，它会返回“Hello Index！”忠实地。</p><p id="0a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过在Couchbase的<code class="fe lv lw lx ly b">po</code>桶中创建一个采购订单来尝试一下。我将创建一个名为<code class="fe lv lw lx ly b">/po</code>的POST端点，它将返回一个202状态码，表示它已被接受。我们说接受是因为它只进入消息队列，而不是直接进入数据库。PurchaseOrderConsumer从消息队列中取出它，并将其添加到数据库中。这可以防止服务和数据库在高峰输入期间过载。</p><p id="c6d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要导入配置。我将从另一个服务中剪切并粘贴所有这些内容(我们都知道，当您剪切并粘贴时，一只小狗会死去，但就这样吧)。</p><p id="1a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我将添加后处理程序:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d532" class="md me it ly b gy mf mg l mh mi">app.post("/po", (req, res) -&gt; {<br/>  PurchaseOrderPayload purchaseOrderPayload;<br/>  try {<br/>    purchaseOrderPayload = objectMapper.readValue(req.getBody(),<br/>                        PurchaseOrderPayload.class);<br/>  } catch (IOException e) {<br/>    ContextLogging.log("could not parse payload " + e.getMessage());<br/>    res.setStatus(Status._400);<br/>    res.send("Unable to parse payload");<br/>    return;<br/>  }<br/>  try {<br/>    if(!List.of("Car", "Truck", "Motorcycle")<br/>            .contains(purchaseOrderPayload.type)) {<br/>      ContextLogging.log("invalid type " +<br/>            purchaseOrderPayload.type);<br/>      res.setStatus(Status._400);<br/>      res.send("type must be one of Car, Truck, or Motorcycle");<br/>      return;<br/>    }<br/>    String purchaseOrderId = addPayloadToQueue(<br/>             purchaseOrderPayload, sender)<br/>        .block(Duration.ofSeconds(10));<br/>    res.setStatus(Status._201);<br/>    res.send(purchaseOrderId);<br/>  } catch (Exception ex) {<br/>    ContextLogging.log("uncaught exception " + ex.getMessage());<br/>    res.sendStatus(Status._500);<br/>  }<br/>});</span></pre><p id="81b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在POST处理程序中，我解析有效负载并验证它。如果它无效，我将发送一个状态400，并附上最简单的解释。对错误的过多解释可能是一种利用。当然，您不希望向调用者显示堆栈跟踪。如果它通过了验证，我就调用<code class="fe lv lw lx ly b">addPayloadToQueue</code>,稍后我们将讨论它。它返回一个<code class="fe lv lw lx ly b">Mono&lt;String&gt;</code>,其中的字符串是我们应该保存起来以备后用的采购订单ID(我将只实现按ID搜索；一般搜索是另一篇文章)。因为我们希望能够发送回采购订单ID，所以我们必须阻塞，并且我们应该设置一个超时。我选择10秒钟作为一段有限的时间。任何不是由我们应该在验证中发现的错误输入引起的异常都将被视为500错误。</p><p id="0e61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe lv lw lx ly b">addPayloadToQueue</code>的方法:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="96f2" class="md me it ly b gy mf mg l mh mi">private static Mono&lt;String&gt; addPayloadToQueue(<br/>            final PurchaseOrderPayload purchaseOrderPayload,<br/>            final Sender sender) {<br/>  String eventId = UUID.randomUUID().toString();<br/>  String purchaseOrderId = UUID.randomUUID().toString();<br/>  return sender.sendWithPublishConfirms(<br/>     Mono.just(purchaseOrderPayload)<br/>         .doOnNext(po -&gt; ContextLogging.log(<br/>                        "received: " + po))<br/>         .map(p -&gt; new Payload(eventId, PurchaseOrder<br/>                   .builder()<br/>                   .id(purchaseOrderId)<br/>                   .price(p.getPrice())<br/>                   .time(Instant.now().toString())<br/>                   .type(p.getType())<br/>                   .build()))<br/>         .map(i -&gt; Tuples.of(ContextLogging.builder()<br/>                   .serviceName("VehicleService")<br/>                   .eventId(eventId)<br/>                   .build(), i))<br/>         .doOnNext((o) -&gt; ContextLogging.log(o.getT1(),<br/>                   "adding to queue: " + o.getT2()))<br/>         .map(t -&gt; t.mapT2(PossiblyFunction.of(po -&gt;<br/>                   payloadWriter.writeValueAsString(t.getT2()))))<br/>         .map(i -&gt; new OutboundMessage("",<br/>                   QUEUE_TOPIC_PO,<br/>                   i.getT2()<br/>                     .doOnException(e -&gt;<br/>                          ContextLogging.log(i.getT1(),<br/>                          e.getMessage()))<br/>                     .getValue()<br/>                     .orElseThrow(() -&gt;<br/>                          new RuntimeException(<br/>                              "error sending purchase order"))<br/>                     .getBytes()))</span><span id="66b1" class="md me it ly b gy ml mg l mh mi">     ) // we could check the return here<br/>     .map(r -&gt; purchaseOrderId) // replace with purchaseOrderId<br/>     .singleOrEmpty();<br/>}</span></pre><p id="54dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会从TestGenerator服务中发现很多这种情况，因为我们正在做同样的事情，只是从POST中获取我们的输入，而不是为测试创建随机的购买订单。</p><p id="39ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行我们在上一篇文章中创建的docker-compose文件中的Couchbase、RabbitMQ和PurchaseOrderConsumer服务来测试它。如果它们还在运行，那你很幸运。否则，您必须根据前面提供的说明，使用Couchbase和RabbitMQ管理控制台来创建各种队列和存储桶。一旦在Docker Compose中运行了这三个组件，就可以使用run/debug配置从IntelliJ运行新服务了</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/c3b39105fc2295f79912aeb79ad0f8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iv2QhfZPJyTQZkpedWjz-w.png"/></div></div></figure><p id="27dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在设置配置之后，这只是告诉它哪个模块和哪个启动类，您可以单击绿色箭头来运行。您应该可以在IntelliJ的底部看到日志，并且可以在Docker Compose中看到其他日志。如果您有任何问题，可以单击绿色箭头旁边的绿色bug图标来调试您的程序。我喜欢IntelliJ的一点是，可以在lambdas中设置断点，因此调试函数式程序要容易得多。</p><p id="afef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我应该在这里指出，如果您查看日志，我的服务在半秒钟内就准备好了，相比之下，我的Spring服务加载需要几十秒钟。</p><p id="a563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将制作GET <code class="fe lv lw lx ly b">/po/&lt;poId&gt;</code>端点。希望您在试用时保存了帖子中的采购订单ID(您确实试用了，对吗？).下面是GET处理程序:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6187" class="md me it ly b gy mf mg l mh mi">app.get("/po/:poId", (req, res) -&gt; {<br/>  try {<br/>    String id = req.getParam("poId");<br/>    Tuple2&lt;Status, String&gt; payload = getPayloadById(id)<br/>         .map(PossiblyFunction.of(po -&gt;<br/>                objectMapper.writeValueAsString(po)))<br/>         .map(p -&gt; {<br/>            if(p.exceptional()) {<br/>              return Tuples.of(<br/>                   Status._500, <br/>                   "Uncaught exception " + p.getException().get());<br/>            }<br/>            return Tuples.of(Status._200, p.getValue().get());<br/>         })<br/>         .defaultIfEmpty(Tuples.of(Status._404, id + " not found"))<br/>         .block(Duration.ofSeconds(10));<br/>    res.setStatus(payload.getT1());<br/>    res.send(payload.getT2());<br/>  } catch (Exception ex) {<br/>    ContextLogging.log("uncaught exception " + ex.getMessage());<br/>    res.sendStatus(Status._500);<br/>  }<br/>});</span></pre><p id="390a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以从<code class="fe lv lw lx ly b">req.getParam</code>方法中检索到<code class="fe lv lw lx ly b">id</code>参数，这就是调用返回<code class="fe lv lw lx ly b">Mono&lt;PurchaseOrderPayload&gt;</code>的<code class="fe lv lw lx ly b">getPayloadById</code>方法所需的全部内容。我们把<code class="fe lv lw lx ly b">PurchaseOrderPayload</code>翻译成一个字符串返回。如果序列化出现异常(除非数据库中有坏数据，否则不应该出现异常)，我们希望用一条短消息返回一个状态500。我通过创建一个<code class="fe lv lw lx ly b">Tuple&lt;Status,String&gt;</code>来包含状态和返回消息。如果<code class="fe lv lw lx ly b">Mono</code>为空，我将返回一个404状态。如果有任何未捕获的异常，我将再次返回500错误。就像在POST处理程序中一样，我们不想对伴随500的消息提供太多帮助，但是我们可能希望记录原因。</p><p id="477e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">getPayloadById</code>方法相对简单，只是我无法让Couchbase将返回的字符串解析为它所代表的类型。实际上，我对Couchbase感到非常恼火，我可能不会在未来的项目中使用它。但是下面是检索数据的代码:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1410" class="md me it ly b gy mf mg l mh mi">public static Mono&lt;PurchaseOrderPayload&gt;<br/>                getPayloadById(final String id) {<br/>  final ContextLogging context = ContextLogging.builder()<br/>         .serviceName("VehicleService")<br/>         .eventId(UUID.randomUUID().toString())<br/>         .build();<br/>  return poReactiveCollection<br/>         .get(id)<br/>         .doOnNext(c -&gt; ContextLogging.log(context,<br/>                        "po " + id + " found " + c.toString()))<br/>         .doOnError(e -&gt; ContextLogging.log(context,<br/>                        "error finding po " + id + " " + e))<br/>         .map(r -&gt; r.contentAs(String.class))<br/>         .map(PossiblyFunction.of(ps -&gt; <br/>               objectMapper.readValue(ps, Payload.class)))<br/>         .map(p -&gt; p.map(po -&gt; PurchaseOrderPayload.builder()<br/>                        .price(po.po.getPrice())<br/>                        .type(po.po.getType())<br/>                        .build()))<br/>         .map(p -&gt; p.getValue())<br/>         .onErrorReturn(DocumentNotFoundException.class,<br/>                 Optional.empty())<br/>         .flatMap(p -&gt; p.isEmpty() <br/>                ? Mono.empty() <br/>                : Mono.just(p.get()));<br/>    }</span></pre><p id="0765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我使用了<code class="fe lv lw lx ly b">GetResult.contentAs(String.class)</code>而不是实际的类<code class="fe lv lw lx ly b">Payload</code>，然后我必须使用Jackson的<code class="fe lv lw lx ly b">ObjectMapper</code>来获得<code class="fe lv lw lx ly b">Payload</code>类。还要注意的是，一旦我将它映射到一个<code class="fe lv lw lx ly b">Mono&lt;Optional&lt;PurchaseOrderPayload&gt;&gt;</code>流，我就捕获<code class="fe lv lw lx ly b">DocumentNotFoundException</code>以返回一个Optional.empty，这样处理程序代码将返回一个404。</p><p id="86f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再运行一次，用Postman看看能否创建一个采购订单，然后再检索一次。在我们继续之前，您还应该测试错误条件，尝试创建一个有效负载错误的采购订单，并确保您获得400状态。还要搜索一个不存在的ID，以确保获得404状态。一旦这些都工作正常，您就可以停止IntelliJ中的服务并关闭测试实例:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8c96" class="md me it ly b gy mf mg l mh mi">docker-compose down</span></pre><h2 id="c22b" class="md me it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">在Kubernetes经营一切</h2><p id="5571" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">最后，因为我们的其他服务运行在Kubernetes，所以让这个服务也运行在那里。我们要做的第一件事是制作一个图像，因为我们的父pom包含jib插件，这很简单:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9345" class="md me it ly b gy mf mg l mh mi">mvn clean package jib:build</span></pre><p id="8674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将为所有服务创建新的图像。</p><p id="b9a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望您阅读了我的上一篇文章，在这篇文章中，我为所有的Kubernetes描述符建立了一个目录，还建立了Couchbase和RabbitMQ的Kubernetes实例。如果没有，你真的应该现在就做，否则什么都不会起作用。本文将指导您如何部署所有需要的服务，以便我们可以测试我们的新服务。一旦您完成了所有的设置，将<code class="fe lv lw lx ly b">cd</code>放入部署目录<code class="fe lv lw lx ly b">usedvehicles-deploy</code>。</p><p id="279c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的新服务将与我们的其他描述符略有不同，但我们可以从将<code class="fe lv lw lx ly b">purchaseorderconsumer.yaml</code>复制到<code class="fe lv lw lx ly b">vehicleservice.yaml</code>开始，然后编辑它，将purchaseorderconsumer的所有事件更改为vehicleservice。最大的区别是，这是第一个真正的“服务”，也就是说，它监听HTTP端口。要启用此功能，请将以下内容添加到vehicleservice.yaml:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cf61" class="md me it ly b gy mf mg l mh mi">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: vehicleservice-service<br/>spec:<br/>  type: ClusterIP<br/>  selector:<br/>    app: vehicleservice<br/>  ports:<br/>  - port: 8080<br/>    targetPort: 80</span></pre><p id="f1f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您应该能够使用以下命令启动它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="502f" class="md me it ly b gy mf mg l mh mi">kubectl create -f vehicleservice.yaml</span></pre><p id="8837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe lv lw lx ly b">kubectl get pods</code>直到你看到你的车辆服务舱处于运行状态。为了能够在不设置入口的情况下访问您的新服务，您可以进行端口转发。pod名称应该是<code class="fe lv lw lx ly b">vehicleservice-deployment-xxxxxxxx-xxxx</code>，其中的“x”是随机字符，用于区分该pod和其他pod。由于您只有一个pod用于运行服务，请在该pod上运行port-forward命令:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a72e" class="md me it ly b gy mf mg l mh mi">kubectl port-forward vehicleservice-deployment-xxxxxxxx-xxxx 8080:80</span></pre><p id="9633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以返回到Postman，创建一个采购订单并再次检索它。注意，数据库会有所不同，因为我们在Kubernetes中运行的Couchbase实例与我们在Docker Compose中运行的不同。</p><p id="e6ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，除了所有其他服务之外，我们还有一个可以创建和检索采购订单并完成所有所需处理的服务。我们没有因为Spring的花里胡哨而陷入困境，只用了不到200行代码，这遵循了YAGNI原则。我们创建了小而简单的服务，它们能够很好地沟通，并遵循可靠的原则。就干旱而言，很多小狗死在那座山上，这是我最不喜欢的各种开发商的缩写。最后，我们让一切都在Kubernetes中运行，现在我们可以根据需要自由扩展。如果我们添加一些健康检查，我们还可以通过确保pod在遇到问题时重新启动来实现高可用性。</p><p id="1101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中使用的GitHub存储库:</p><div class="nj nk gp gr nl nm"><a href="https://github.com/rkamradt/usedvehicles/tree/v0.9" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">rkamradt/二手车辆</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">Permalink无法加载最新的提交信息。整个第一阶段使用电抗组件的微服务系统示例…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa ks nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://github.com/rkamradt/usedvehicles-deploy/tree/v0.2" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">rkamradt/used vehicles-部署</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">二手车服务的部署脚本。为rkamradt/used vehicles-部署开发做出贡献，方法是创建…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa ks nm"/></div></div></a></div><p id="6534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提到的其他文章:</p><div class="nj nk gp gr nl nm"><a rel="noopener  ugc nofollow" target="_blank" href="/running-java-microservices-in-kubernetes-57a7a05e85ac"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">在Kubernetes中运行Java微服务</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">微服务与RabbitMQ和Couchbase捆绑在一起</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nv l"><div class="oc l nx ny nz nv oa ks nm"/></div></div></a></div></div></div>    
</body>
</html>