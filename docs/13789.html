<html>
<head>
<title>React Context Pitfall: How to Avoid It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React上下文陷阱:如何避免</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-context-pitfall-how-to-avoid-it-47f8c205d139?source=collection_archive---------7-----------------------#2022-10-05">https://levelup.gitconnected.com/react-context-pitfall-how-to-avoid-it-47f8c205d139?source=collection_archive---------7-----------------------#2022-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c81796a056834d507c7327dc2ee63ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*No3enHTCH3Q-iXuIe5-kCg.jpeg"/></div></div></figure><p id="158d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我正在编写一段代码，遇到了一个有趣的问题。</p><p id="3ecf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题:</strong> <em class="kw">当从一个冗长的操作内部更新</em> <code class="fe kx ky kz la b"><em class="kw">context</em></code> <em class="kw">时，如果两个更新同时发生，先前的值可能被覆盖。</em></p><p id="358d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了重现这个问题，我在这个沙箱中编写了一个简单的应用程序，模拟文件下载并将其放入上下文中，这是在一个带有<code class="fe kx ky kz la b">setTimeout</code>的<code class="fe kx ky kz la b">useEffect</code>中发生的。</p><h1 id="65dd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">动作错误</h1><p id="e09d" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">如果两个文件的下载按顺序进行，则没有问题:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/6889f68250c37a1cb428bbf1d7831263.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*0C2Foy912x13LoDNwacGXA.gif"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">连续下载工作没有问题</figcaption></figure><p id="1acf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果第二次文件下载在第一次下载完成之前开始，第一个文件将被删除:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/63030e1372e309846211eb8f840948c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/1*Y50LDmPyi05YlXzmz7BJTw.gif"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">同时下载会导致第一个文件被删除</figcaption></figure><h1 id="566c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">有问题的代码</h1><p id="5df2" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">在这里，我将简要概述导致这个问题的代码。整个问题代码可以在<a class="ae lb" href="https://codesandbox.io/s/context-issues-problem-code-76nsph?file=/src/DownloadPage.tsx" rel="noopener ugc nofollow" target="_blank">这个沙箱</a>中找到。</p><p id="1025" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">DownloadsContext.tsx</code>:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/291b6b26e6ab079959c95ea5f1598fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFboxV9UPgnczNEz1K6UsA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">DownloadsContext.tsx</figcaption></figure><p id="1dfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上下文提供者在<code class="fe kx ky kz la b">App.tsx</code>中是这样定义的:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/d3506979450346468529aed8e0e962d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KXjO4_A5jdORQLnn52aAXA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">App.tsx</figcaption></figure><p id="582c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">DownloadPage.tsx</code>文件本质上是2个<code class="fe kx ky kz la b">DownloadFile.tsx</code>组件的包装器，显示所有下载的文件名，所以我在这里省略了。</p><p id="0cc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">DownloadFile.tsx</code>组件看起来像这样:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/d90feb5cf9ea389c82d3bfca8ab330c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5GueeR9cG0u79GjcQIjs_A.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">DownloadFile.tsx</figcaption></figure><p id="27a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我使用了一个<code class="fe kx ky kz la b">useEffect</code>块和一个<code class="fe kx ky kz la b">setTimeout</code>块来模拟一个下载文件的异步调用。这只是我想到的一个演示问题的例子，它可以是更新上下文的任何冗长的任务。</p><h1 id="f79d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">问题是</h1><p id="55ce" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">这段代码的问题是，当第二个文件“下载”在第一个文件“下载”启动之后启动，但在第一个文件完成下载之前，传递给<code class="fe kx ky kz la b">updateDownloads</code>的<code class="fe kx ky kz la b">downloads</code>对象已经过期。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/29001958623133990d3579edc82c10ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xUPcPKN5mR3sZowS4icYA.png"/></div></div></figure><p id="4622" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单击“下载文件1”按钮时，上下文为空，单击“下载文件2”按钮时也是如此。即使“文件2”是在“文件1”之后下载的，组件仍然“认为”上下文是空的，因为从上下文中检索的“downloads”变量的值来自先前的渲染。</p><h1 id="8bdd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">解决方案:useRef</h1><p id="c894" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">使用<code class="fe kx ky kz la b">ref</code>值有一个简单的解决方案，如下所示:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/7f81bdb3c8a6c4168b838112e59c152c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABFfxKhWK7wwA7m8kG7L2w.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">DownloadFile.tsx中的解决方案</figcaption></figure><p id="ab53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在第13行初始化一个<code class="fe kx ky kz la b">downloadRef</code>变量来包含<code class="fe kx ky kz la b">downloads</code>值。然后我们可以在第17行的<code class="fe kx ky kz la b">useEffect</code>中更新它(但是只有当<code class="fe kx ky kz la b">downloads</code>的值改变时)。</p><p id="5ba1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我们可以使用上下文的最新值，而不是过时的旧值。当第22行调用<code class="fe kx ky kz la b">updateDownloads</code>时，我们使用上下文中<code class="fe kx ky kz la b">downloads</code>变量的最新值，而不是组件第一次呈现时的值。这个解决方案的全部代码在<a class="ae lb" href="https://codesandbox.io/s/context-issues-solution-code-jswod1?file=/src/DownloadFile.tsx" rel="noopener ugc nofollow" target="_blank">这个沙箱</a>里。</p><p id="9c8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当两个文件同时下载并从<code class="fe kx ky kz la b">useEffect</code>放入上下文时，它按预期工作:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/5b1857acb1c23e1f182c2bf1c5346c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/1*-uK1tDa7H_Xn78EAFw57ow.gif"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">使用ref修复了这个错误，当同时下载时，两个文件都被持久化</figcaption></figure><h1 id="3114" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">解决方案:用函数设置状态</h1><p id="8894" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">另一种方法是将<code class="fe kx ky kz la b">setState</code>定义为前一状态的函数，就像<code class="fe kx ky kz la b">setState(prev =&gt; fn(prev))</code>一样。这更好，因为它不需要我们在一个<code class="fe kx ky kz la b">ref</code>中存储一个<code class="fe kx ky kz la b">download</code>变量的副本，但是它需要更多的修改。整个代码都在这个沙箱里。</p><p id="bc95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在<code class="fe kx ky kz la b">DownloadsContext.tsx</code>中将上下文改成这样:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/196acce35d21d95beaa258f5bbd78125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4Tiipyxfr3mO0Xd0W6z_g.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">已更改DownloadsContext.tsx中的上下文</figcaption></figure><p id="fa57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我更改了函数类型和名称以避免混淆。</p><p id="de55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">App.tsx</code>也必须相应地改变，因为它包含上下文提供者:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a8773c1ee5261885e7cc12815268f759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-XFz1yJ48KecEGgWBI7REQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">App.tsx</figcaption></figure><p id="d020" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里对<code class="fe kx ky kz la b">setDownloads</code>的调用是通过前一状态的函数完成的。这确保了每当调用<code class="fe kx ky kz la b">addDownload</code>时，之前的值不会被删除。</p><p id="6bb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是更新后的<code class="fe kx ky kz la b">DownloadFile.tsx</code>组件:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/36ecf4983a85eac76e16dc5e1ec2025e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CaXzlIpTRTcBoUdiQNw0Tg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">DownloadFile.tsx</figcaption></figure><h1 id="93c7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">比较</h1><p id="ea79" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">第二种方法更好，因为它消除了对<code class="fe kx ky kz la b">ref</code>的需求，T16最终只保存所需数据的副本。</p><p id="54bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在实践中，将所有现有代码改造成这种格式可能非常耗时，因此第一种方法可能更适合作为快速解决方案。</p><h1 id="3068" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="b952" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">在这里，我提出了两个解决问题的方案，一个是使用<code class="fe kx ky kz la b">ref</code>的快速修复方案，另一个更长但更健壮的方案是改变<code class="fe kx ky kz la b">setState</code>调用以使用前一个状态值的函数。</p><p id="a289" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我遇到的一个现实世界的问题，我想分享给大家，希望它能帮助别人避免我犯的同样的错误！</p></div></div>    
</body>
</html>