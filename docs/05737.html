<html>
<head>
<title>Flutter and Hot Reload.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振和热装弹。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-and-hot-reload-17b219362260?source=collection_archive---------12-----------------------#2020-09-26">https://levelup.gitconnected.com/flutter-and-hot-reload-17b219362260?source=collection_archive---------12-----------------------#2020-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7b39" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我一直在为一个简单的特征挠头。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68a86c2430c5ab395dd934fbd6945109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_oYY-8_Wm1HY2IAfAOh6g.png"/></div></div></figure><p id="f9bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个月前开始学flutter。在我取得良好进展的同时，我有机会和一个朋友合作一个项目，这个项目使用<a class="ae lq" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank"> provider </a>包管理状态。我很兴奋，因为我终于有机会参与一个真正的flutter项目，并使用provider学习状态管理。我从简单的东西开始:导航提供商。我想使用provider模式处理应用程序内部的导航。</p><p id="ef0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一切都很好，直到我好奇的头脑开始怀疑性能。在这一点上，考虑性能是不合理的。但我必须找到答案。因此，我浏览了<a class="ae lq" href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/simple" rel="noopener ugc nofollow" target="_blank">这篇</a>文章，并阅读了使用provider时的最佳实践，以保持令人满意的性能(顺便说一下，这里的性能是指防止不必要的小部件构建。).</p><p id="3573" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我快速向你们展示我当时做了什么，以及它给我带来了什么问题。</p><p id="08d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我最初写的代码。只是一些标准的供应商的东西。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="8617" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在<em class="lt"> _HomepageState </em>类的构建方法中添加了一个新的print语句，就在第8行的上面，</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="fae1" class="lz ma it lv b gy mb mc l md me">print("Home Page build called");</span></pre><p id="11f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你熟悉<em class="lt">提供者</em>，你可能知道代码有什么问题。如果没有，第8行应该是这样的:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="d548" class="lz ma it lv b gy mb mc l md me">final navigation = Provider.of&lt;NavigationProvider&gt;(context,<strong class="lv iu"><em class="lt">listen:false</em></strong>);</span></pre><p id="9562" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可以防止每次导航到不同的页面时都运行build方法。因此，我很快做了上面提到的更改，并希望控制台只记录一个名为“的<em class="lt">”主页构建。热装弹完成了任务。print语句执行一次。我迅速切换到不同的页面，希望不要找到更多的“主页构建调用”日志。</em> <strong class="kw iu">但是</strong> <em class="lt">，</em>令我惊讶的是，每次我切换页面的时候，日志都不断出现，这意味着每次都在调用构建方法。我没想到会这样。我已经阅读了flutter文档并做了必要的工作，但不知何故，它似乎不起作用。我关闭了我的编辑器，过了一会儿又回来，再次开始调试会话。Flutter更新了应用程序，这次只有一个日志，即使我不停地切换页面。思考了一会儿后，我确信热重装一定没有能够拾取我所做的更改。</p><p id="d937" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以肯定的是，我撤销了之前所做的更改，从第<em class="lt"> 8 </em>行删除了<em class="lt"> listen:false </em>并保存，Flutter立即将更改推送到应用程序中。但是这一次，更改似乎被热重载选中了，我可以看到打印语句在导航时被执行。</p><p id="cb4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我来说，这种行为很奇怪。</p><blockquote class="mf"><p id="66a3" class="mg mh it bd mi mj mk ml mm mn mo lp dk translated">颤振热重装似乎是选择性的一些变化。</p></blockquote><blockquote class="mp mq mr"><p id="6abf" class="ku kv lt kw b kx ms ju kz la mt jx lc mu mv lf lg mw mx lj lk my mz ln lo lp im bi translated">一旦我开始监听更改，我就不能用热重载删除监听器。</p></blockquote><p id="a043" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在花了一个小时左右的时间进行修改并注意到热重载行为，然后又花了一个小时在线搜索解释后，我最终决定跳到提供者包的源代码中，希望它能回答一些问题。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="8a0e" class="nh ma it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">弄清楚</h1><p id="9991" class="pw-post-body-paragraph ku kv it kw b kx ny ju kz la nz jx lc ld oa lf lg lh ob lj lk ll oc ln lo lp im bi translated">我走进了<em class="lt">里面。发布缓存</em>目录。(我是在flutter安装目录里找到的。详情请点击<a class="ae lq" href="https://dart.dev/tools/pub/cmd/pub-get#the-system-package-cache" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="8acd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我找到Provider.dart文件的路径</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="fc73" class="lz ma it lv b gy mb mc l md me">flutter/.pub-cache/hosted/pub.dartlang.org/provider-4.3.2+1/lib/src</span></pre><p id="5a32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一段相关的代码，是理解当时情况的关键。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="0b6a" class="lz ma it lv b gy mb mc l md me">static T of&lt;T&gt;(BuildContext context, {bool listen = true}) {<br/>    <br/>    assert(context != null);<br/>    assert(<br/>      context.owner.debugBuilding ||<br/>          listen == false ||<br/>          debugIsInInheritedProviderUpdate,<br/>     <br/>        );</span><span id="44b7" class="lz ma it lv b gy od mc l md me">    final inheritedElement = _inheritedElementOf&lt;T&gt;(context);</span><span id="d8ee" class="lz ma it lv b gy od mc l md me">    if (listen) {<br/>       context.dependOnInheritedElement(inheritedElement);<br/>     }</span><span id="108d" class="lz ma it lv b gy od mc l md me">    return inheritedElement.value;<br/> }</span></pre><p id="1e66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，第一个参数是所讨论的上下文，第二个参数listen默认为true。因此，默认情况下，&lt;navigation provider&gt;(context)的<em class="lt"> Provider .会监听更改，并使用提供的上下文重新构建小部件。</em></p><p id="22e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<em class="lt"> listen </em>为<strong class="kw iu"> <em class="lt"> true </em> </strong>时，小部件监听<em class="lt"> InheritedElement </em>的变化，当<strong class="kw iu"> <em class="lt"> false </em> </strong>时，简单地返回该值。</p><p id="04e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了证明这种行为，我只是在代码中添加了这一行。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="c830" class="lz ma it lv b gy mb mc l md me">print(context);</span></pre><p id="430a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是当<em class="lt"> listen </em>设置为false时的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c566a662250a90f78454ae3c6859b6d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCF_m63qVgpzXFRnzqF_0Q.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">当监听设置为假时</figcaption></figure><p id="7800" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我把<em class="lt">监听</em>改成真热重装的时候，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ddd9584530b278d04f70b5e619345634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzKci6WXBR9M8JIWFB0-xw.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">当listen设置为true时(注意如何添加依赖项)</figcaption></figure><p id="2d5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意依赖项是如何添加到列表中的。每当我们导航到不同的页面时，都会调用Homepage小部件的build方法。热重装完成了它应该做的。</p><p id="1260" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我又把<em class="lt">监听</em>改为假，结果是这样的，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/100e1dc4a20bedfed27b8e4db3230e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tbma1fYXbmrtQY1R76mbtw.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">请注意依赖列表是如何保持不变的</figcaption></figure><p id="1c11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么我在热重装时没有看到任何变化。</p><p id="115f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您仔细查看我在上面粘贴的提供者包的代码片段，您会发现一旦我们开始监听这里的变化，</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="9f2d" class="lz ma it lv b gy mb mc l md me">if (listen) {<br/>       context.dependOnInheritedElement(inheritedElement);<br/>     }</span></pre><p id="e233" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后将<em class="lt"> listen </em>设置为false并热重新加载，依赖关系列表不会改变。</p><p id="8182" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码的else部分不关心您是否已经在监听更改，它只是返回inheritedElement.value。因此，当flutter执行热重装时，</p><blockquote class="mp mq mr"><p id="cce9" class="ku kv lt kw b kx ky ju kz la lb jx lc mu le lf lg mw li lj lk my lm ln lo lp im bi translated">我们仍在倾听变化。</p></blockquote><p id="c5f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以猜测为什么“热重启”不会有这个问题。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="548b" class="nh ma it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">结论</h1><p id="c610" class="pw-post-body-paragraph ku kv it kw b kx ny ju kz la nz jx lc ld oa lf lg lh ob lj lk ll oc ln lo lp im bi translated">颤振热重装工程，因为它应该和有时热重启是需要看到一些变化的影响。</p><p id="526a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>