<html>
<head>
<title>Love It Or HATEOAS It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">爱它或恨它</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/love-it-or-hateos-it-3f8d5844e736?source=collection_archive---------4-----------------------#2021-01-02">https://levelup.gitconnected.com/love-it-or-hateos-it-3f8d5844e736?source=collection_archive---------4-----------------------#2021-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b790" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上周，我们就HATEOAS对于我们基于REST的微服务应用套件的功效进行了一次相当长时间的讨论。长话短说，团队在我们是否应该基于REST的“统一接口”特性构建我们的API响应模型上存在意见分歧。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="b3b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么是HATEOAS？<br/> </strong>在我们到达那里之前，我想请你挑战一下自己，给休息下一个正确的定义。我们的API团队中都有一个人会(至少一次)评论说，我们的API不是真正RESTful的。不管怎样，他们可能是绝对正确的。他们的想法很可能基于罗伊·菲尔丁的论文。坚持认为我们可能理解什么是HTTP动词<a class="ae ks" href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="noopener ugc nofollow" target="_blank">，但它们不是超文本驱动的</a>。否则，您的REST API只是一个RPC驱动的基于HTTP的接口。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/5526c111ea8eb742e0a80ddd574f6152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kybyt2qXxx87PWFWKToY_g.png"/></div></div></figure><p id="b9cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，Hypertext<strong class="jp ir">A</strong>S<strong class="jp ir">T</strong>he<strong class="jp ir">E</strong>ngine<strong class="jp ir">O</strong>f<strong class="jp ir">A</strong>application<strong class="jp ir">S</strong>state，或<em class="lf"> HATEOAS </em>意味着我们在响应中嵌入了足够的信息，以便客户端可以智能地选择下一步要做的事情。每种媒体类型都定义了默认的处理模型，例如HTML定义了超文本的呈现过程和每个元素周围的浏览器行为。它与动词GET/PUT/POST/DELETE没有直接的依赖关系。该接口告诉客户端使用什么方法，例如获取用户的数据，这反过来又转换为GET调用。</p><p id="cd46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户端下一步应该做什么转化为资源发现，如果定义正确，资源发现就在响应超媒体中。这将允许客户端计算出哪些资源是可用的，哪些是可以操作的。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="74ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您的API被最终用户和管理员通过相同的接口使用。普通用户将能够获得<code class="fe li lj lk ll b">/users/{​userId}​</code>。超级用户可以上传并修补<code class="fe li lj lk ll b">/users/{​userId}​</code>，管理员拥有删除权限。如果我们停留在Richardson成熟度模型的第2级，我们就会有一个能够理解特权类型并基于此进行渲染的客户端。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="f8b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">听起来很花哨，我该实现吗？<br/> </strong>大多数团队不理解的一点是，HATEOAS不是设计原则，而是架构约束的一部分。构建一个完全解耦、独立可扩展的系统是每个工程师的目标。但我的抱怨是，仅仅因为你在周末读到了一些东西就去实现它，这永远不是正确的方法。</p><p id="558b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看HATEOAS，如果实现正确，它将不再需要显式文档，因为它是<em class="lf">自文档化的。</em>但实际上，我们大多数人不会花时间构建足够智能的客户端来读取<code class="fe li lj lk ll b"><em class="lf">rel = what-this-endpoint-does</em></code>并判断它是否应该为特定用例使用PUT方法或POST方法。我当然希望它这样做，从而允许对我的应用程序进行渐进的非侵入性增强。但我们在这一点上相差甚远。</p><p id="eb3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，大多数API的实现依赖于通过像<a class="ae ks" href="https://cloud.google.com/apigee" rel="noopener ugc nofollow" target="_blank"> Apigee </a>或服务网格这样的网关提供对它的访问，这使得基于HATEOAS的链接几乎不起作用。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="lm lh l"/></div></figure><p id="a8a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，为了让您的REST API真正为可演进性做好准备，它可能需要<a class="ae ks" href="https://medium.com/swlh/api-versioning-7f6f713c6b14" rel="noopener">版本化，对吗</a>。但是对于真正的仇恨来说，这变得有点违反直觉了。</p><p id="57ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">REST仍然是构建API的一种非常好的方式，但是我不会试图为一个虚构的客户端实现它，这个客户端会以某种方式理解我的超媒体格式的语义。每个微服务套件都是不同的，不存在通用的API。尝试构建最终的响应发现引擎是一个很好的最终目标。但是对于任何工程团队来说，僵化的思维模式最终会降低应用程序的可发展性，这不是一个好的方向。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="44bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参考资料:</p><ul class=""><li id="5ed8" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><a class="ae ks" href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="noopener ugc nofollow" target="_blank">http://Roy . gbiv . com/untangled/2008/rest-APIs-must-be-hypertext-driven</a></li><li id="9f18" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae ks" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" rel="noopener ugc nofollow" target="_blank">https://www . ics . UCI . edu/~ fielding/pubs/dissertation/rest _ arch _ style . htm</a></li><li id="95e7" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae ks" href="http://martinfowler.com/articles/richardsonMaturityModel.html" rel="noopener ugc nofollow" target="_blank">http://Martin fowler . com/articles/richardsonmaturitymodel . html</a></li><li id="e4f4" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/No_Silver_Bullet" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/No_Silver_Bullet</a></li></ul></div></div>    
</body>
</html>