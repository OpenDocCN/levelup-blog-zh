<html>
<head>
<title>Building a B-Tree in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript构建B树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-b-tree-in-javascript-4482dee083cb?source=collection_archive---------4-----------------------#2020-05-04">https://levelup.gitconnected.com/building-a-b-tree-in-javascript-4482dee083cb?source=collection_archive---------4-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fcd56f6f35d8c0f973cfb75d02301557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6UIHOAY1MV32U_uuNRubLw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="f867" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">我如何使用JavaScript(和Vue)创建一个动画BTree。JS)</h2></div><h1 id="3e63" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">为什么要这么做？</h1><p id="33ea" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">只是为了好玩！我和一个朋友开始开发一个名为<em class="mh"> Structies </em>的非专业web应用程序，目的是让人们接近最流行的数据结构，能够可视化他们的主要操作，并以友好的方式与他们交互。创建这个站点所选择的框架是:<strong class="ln jf"> VueJS </strong>，所以所有的类都是用<strong class="ln jf"> JavaScript </strong>编写的。这样，想法就是从零开始构建所有这些数据结构。</p><p id="f565" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">本文将详细解释我如何构建BTree类，从一般属性开始，然后描述BTree的主要操作，接着是图形动画和它们的复杂性分析，最后简要解释如何借助结构开发动画。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mn"><img src="../Images/d6519d46403e2480a1f84f9db9370b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxQXaIJTQCPzuBLGuQTmaw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">项目结构标志</figcaption></figure><h1 id="7570" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">什么是B树？</h1><p id="9984" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">定义B树的一种方式是说，它们类似于<strong class="ln jf">二分搜索法树</strong>，但是每个节点有<strong class="ln jf">个以上的键和两个以上的子节点</strong>，具有作为主要属性的搜索树和自平衡的特征。现在，B树是最流行的数据结构，在访问数据和处理数据的时间上有很大的优势。因此，通过这种方式，今天它们主要用于硬盘驱动器，使用分层索引来最大限度地减少磁盘读取次数，并提高访问信息的时间。</p><p id="8703" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">从技术上来说，与堆之类的其他结构相比，它们相当复杂，但是在这里，它的所有操作都将在可视化动画的支持下详细解释，以便充分理解那些机制。</p><p id="3d5e" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">下面，你会发现一个t=2阶的B树的图片，它包含了10到140的所有倍数。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mw"><img src="../Images/3d270fb224ae735a8a643c727fa2f90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TyNTkd9PjGKVNKr-EoH3w.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">阶为2的b树，插入了10到140的所有键的倍数。由于<strong class="bd kv">结构</strong>而创建的BTree</figcaption></figure><h2 id="eb7d" class="mx ku je bd kv my mz dn kz na nb dp ld lu nc nd lf ly ne nf lh mc ng nh lj ni bi translated">但是，为什么是BTrees和JavaScript呢？</h2><p id="f96f" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">JavaScript不仅在大多数前端应用程序中使用，一些流行的后端框架如NodeJS或数据库如<a class="ae nj" href="https://pouchdb.com/" rel="noopener ugc nofollow" target="_blank"> PouchDB </a>被大型科技公司选择来创建强大的服务器。所以我希望这个实现能帮助你学习BTrees是如何工作的，或者是一些专业的实现。</p><h1 id="d7a4" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">主要特征</h1><ul class=""><li id="e21d" class="nk nl je ln b lo lp lr ls lu nm ly nn mc no mg np nq nr ns bi translated">节点可以有多个子节点和键(甚至上千个！).</li><li id="bb6d" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated">从上到下遍历树需要O(log N)。</li><li id="a751" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated">所有像search()、insert()和remove()这样的操作都需要O(log N)。</li><li id="ca1e" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated">为顺序遍历保持键的排序顺序。</li></ul><p id="b4a4" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">通过保留部分满的块，这种结构与它们存储的数据量相比可以快速插入和删除，因此它在磁盘中工作得非常好。</p><h1 id="5e57" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">性能</h1><ul class=""><li id="6883" class="nk nl je ln b lo lp lr ls lu nm ly nn mc no mg np nq nr ns bi translated">每个<strong class="ln jf">树</strong>都有一个根(<strong class="ln jf">树节点</strong>)。</li><li id="841f" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated">每个<strong class="ln jf">b reenode</strong>都有以下属性:<br/> - <strong class="ln jf"> leaf </strong>(布尔):<em class="mh">是否为叶子。<br/> - </em> <strong class="ln jf">值</strong> (number[]) <em class="mh">:按顺序存储的所有值列表，所以:<br/></em><code class="fe ny nz oa ob b">BTree.values[i] &lt;= BTree.values[i+1]</code><em class="mh"><br/>-</em><strong class="ln jf">子树</strong> (BTreeNode[]): <em class="mh">子树子树列表。</em></li><li id="eb06" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated">节点中的每一对直接值定义了它们之间包含的子树中所有值的界限。</li></ul><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="4505" class="mx ku je ob b gy og oh l oi oj"><em class="mh">// (Pseudo code)</em><br/>if (key in BTreeNode.children[i+1]) {<br/>  BTreeNode.values[i] &lt; key &lt; BTreeNode.values[i+1]<br/>}</span></pre><ul class=""><li id="5e1d" class="nk nl je ln b lo mi lr mj lu ok ly ol mc om mg np nq nr ns bi translated">在顺序为<code class="fe ny nz oa ob b">t</code>的BTree中，每个BTreeNode都有<code class="fe ny nz oa ob b">[t-1, 2t-1]</code>键和<code class="fe ny nz oa ob b">[t, 2t]</code>子节点。</li><li id="c4c7" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated">所有的<strong class="ln jf">叶</strong>都一样深(在同一水平线上)。</li></ul><h1 id="54be" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">现在让我们编码！</h1><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="4efe" class="mx ku je bd kv my mz dn kz na nb dp ld lu nc nd lf ly ne nf lh mc ng nh lj ni bi translated">b树节点类</h2><p id="89c7" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在下面的片段中，给出了BTreeNode的基本定义，用<strong class="ln jf"> 4个基本操作</strong>插入和删除子节点的值或引用。所有这些函数都使用JavaScript方法<code class="fe ny nz oa ob b">array.splice()</code>保持引用或值的数组尽可能小。</p><ul class=""><li id="c127" class="nk nl je ln b lo mi lr mj lu ok ly ol mc om mg np nq nr ns bi translated"><em class="mh"> BTreeNode.addValue(数字)</em></li><li id="a4e0" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated"><em class="mh"> BTreeNode.removeValue(位置)</em></li><li id="416c" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated"><em class="mh"> BTreeNode.addChildren(节点，位置)</em></li><li id="2996" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated"><em class="mh"> BTreeNode.removeChildren(位置)</em></li></ul><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="op oo l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">基本BTreeNode类</figcaption></figure><h2 id="34b8" class="mx ku je bd kv my mz dn kz na nb dp ld lu nc nd lf ly ne nf lh mc ng nh lj ni bi translated">BTree类</h2><p id="1f9c" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">以下类声明涵盖了执行方法<strong class="ln jf">搜索</strong>、<strong class="ln jf">插入、</strong>和<strong class="ln jf">删除所需的所有函数。</strong></p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="op oo l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">基本BTree类定义</figcaption></figure><h1 id="8105" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">在BTree中搜索值</h1><p id="0672" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">由于BTrees具有<strong class="ln jf">搜索树</strong>的属性，这个操作非常类似于在二分搜索法树(BST)中的搜索。为了从根开始搜索k值，目标是从上到下遍历树，在每次迭代中寻找正确的子节点。</p><p id="5a2a" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">在BST中，如果目标<code class="fe ny nz oa ob b">k</code>值大于实际节点值，则算法向右，如果小于实际节点值，则向左。保持相同的逻辑，BTree通过与实际节点中存储的值进行比较，继续到应该存储它的子树目标<code class="fe ny nz oa ob b">k</code>。</p><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="517d" class="mx ku je ob b gy og oh l oi oj">/**<br/>* Search a value in the Tree and return the node. O(log N)<br/>* <a class="ae nj" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {number} value<br/>* <a class="ae nj" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {BTreeNode} node<br/>* <a class="ae nj" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {BTreeNode}<br/>*/<br/><strong class="ob jf">searchValue</strong>(node, value) {<br/>  if (node.values.includes(value)) {<br/>    return <strong class="ob jf">node</strong>;<br/>  }<br/>  if (node.leaf) {<br/>    // Value was not found<br/>    return null;<br/>  }<br/>  let child = 0;<br/>  while (child &lt;= node.n &amp;&amp;<br/>    node.values[child] &lt; parseInt(value, 10)) {<br/>    child++;<br/>  }<br/>  return this.<strong class="ob jf">searchValue</strong>(node.children[child]);<br/>}</span></pre><h1 id="d95d" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">在BTree中插入值</h1><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/11a3e45a3c8c08b56e409a461a30d20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Tx5L6obMGOvrcrjwwOVQKA.gif"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">简单的例子:插入70号。由于<strong class="bd kv">结构</strong>而创建的动画</figcaption></figure><p id="3b79" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">在最简单的插入案例中，如上图所示，从树根到树叶，通过其子节点<strong class="ln jf">来浏览树。</strong>对于每个被访问的节点，作为搜索方法，插入的值<code class="fe ny nz oa ob b">k</code>必须找到正确的子节点才能继续，与实际节点中的值进行比较。遍历树，直到到达一片叶子。如果那片叶子有足够的空间，小于<code class="fe ny nz oa ob b">2t — 1</code>值，<code class="fe ny nz oa ob b">k</code>被插入到叶子中。</p><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="8c4a" class="mx ku je ob b gy og oh l oi oj">// Try to add value {number} in node {BTreeNode}<br/>if (node.leaf) {<br/>  node.<strong class="ob jf">addValue</strong>(value);<br/>  return;<br/>}<br/>let temp = node.n;<br/>while (temp &gt;= 1 &amp;&amp; value &lt; node.values[temp - 1]) {<br/>  temp = temp - 1;<br/>}<br/>// Continue searching in -&gt; node.children[temp]</span></pre><p id="ff5f" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">但事情并不总是那么简单。当访问一个<strong class="ln jf">完整节点</strong> ( <code class="fe ny nz oa ob b">2t — 1</code>值)时，事情变得有点复杂。在这种情况下，必须做一个额外的操作:<strong class="ln jf">split</strong>方法。</p><p id="0cdf" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">一个<strong class="ln jf"> split </strong>基本上是给父节点一个值，然后将其余的值和链接的子节点拆分到同一级别的两个不同的新节点中。该算法中使用的机制包括给父节点位置<code class="fe ny nz oa ob b">t — 1</code>的值，换句话说，就是<strong class="ln jf">的中值。</strong>类似地，创建的新兄弟接收从<code class="fe ny nz oa ob b">0</code>到<code class="fe ny nz oa ob b">t — 1</code>的值和从<code class="fe ny nz oa ob b">0</code>到<code class="fe ny nz oa ob b">t — 1</code>的子代。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/26b74b956e7a3ef74cd63780d941d015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MMX-jW3_uDxHFjm92933jg.png"/></div></div></figure><p id="5d3e" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">在下图中，执行数字<code class="fe ny nz oa ob b">k = 130</code>的<strong class="ln jf">插入</strong>，包含值<code class="fe ny nz oa ob b">[60, 80, 100]</code>的节点已满，因此在被访问之前，它将被分割成两个更小的节点。位置<code class="fe ny nz oa ob b">t — 1</code> 80中的值被传送到父节点，其余的值被分成2个新节点。请注意，子节点将被平均共享到新节点中。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/20029f3053184fbc04baaba8160dd2f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*37W3kNl2kIMtZZOZJFTgQA.gif"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">插入编号130，在访问节点中进行拆分。由于<strong class="bd kv">结构</strong>而创建的动画</figcaption></figure><p id="e381" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">下面是包含插入和分割方法的BTree定义。</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="op oo l"/></div></figure><p id="e83c" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">使用这种方法，树的高度<strong class="ln jf">增加的唯一情况是在插入期间，根被访问并发现是满的。因此，在这种情况下，将执行分割操作，并创建一个新节点，将其分配给根引用。在下图中，值<code class="fe ny nz oa ob b">k = 80</code>被插入到树根已满的树中。</strong></p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/0049a58ec334cb68ae5ecf18c0fcda29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Kwqz5c6tgVdWLsxVwIkyWw.gif"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">在一棵有全根的树上插入k=80。由于<strong class="bd kv">结构</strong>而创建的动画</figcaption></figure><p id="9301" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">现在，最困难的部分…</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="os oo l"/></div></figure><h1 id="ca00" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">删除BTree中的值</h1><p id="046f" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">类似于插入，删除操作有简单的情况和一些复杂的情况。移除值<code class="fe ny nz oa ob b"><em class="mh">k</em></code>的主要思想是递归地遍历树<strong class="ln jf">的高度，试图将目标值<em class="mh"> k </em>移动到底部</strong>，但是在访问下一个节点之前，总是确保下一个节点具有多于<code class="fe ny nz oa ob b">t — 1</code>的值，否则，在向下移动之前进行一些操作。</p><p id="2235" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">下面，在遍历树的高度的过程中，删除操作将包含在3个不同的子案例中，每个子案例都提供了示例和图像。为这个方法提供的例子将遍布于一个顺序为<code class="fe ny nz oa ob b">t = 2</code>的B树。</p><ul class=""><li id="f557" class="nk nl je ln b lo mi lr mj lu ok ly ol mc om mg np nq nr ns bi translated"><strong class="ln jf">情况A </strong>:目标位于未最小填充的叶子中。</li></ul><p id="929b" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated"><strong class="ln jf">最简单的</strong>情况是当目标值<code class="fe ny nz oa ob b"><em class="mh">k</em></code>是在中找到的<strong class="ln jf">，而<strong class="ln jf">不是最小填充的</strong>，换句话说，叶子有多于<code class="fe ny nz oa ob b">t — 1</code>的值。</strong></p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/5b700b7bf2eb48b578f30b1c4fd4e612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RmubnrwYNRrGfV0dAsfhpQ.gif"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">从一片叶子上删除数字k=80。由于<strong class="bd kv">结构</strong>而创建的动画</figcaption></figure><p id="4704" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">如图所示，值<code class="fe ny nz oa ob b"><em class="mh">k = 80</em></code>出现在具有多于<code class="fe ny nz oa ob b">t — 1</code>值的叶子中，所以在这种情况下，值<code class="fe ny nz oa ob b"><em class="mh">k</em></code>只是从节点中删除。</p><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="e82f" class="mx ku je ob b gy og oh l oi oj">/**<br/>* Delete a value from a node<br/>* @param {BTreeNode} node<br/>* @param {number} value<br/>*/<br/>deleteFromNode(node, value) {<br/>  // Check if value is in the actual node<br/>  const index = node.values.indexOf(value);<br/>  if (index &gt;= 0) {<br/>    // Value present in the node<br/>    if (<strong class="ob jf">node.leaf</strong> &amp;&amp; <strong class="ob jf">node.n &gt; this.order - 1</strong>) {<br/>      // If the node is a leaf and has more than order-1 values,<br/>      // just delete it<br/>      node.<strong class="ob jf">removeValue</strong>(node.values.indexOf(value));<br/>      return;<br/>    }<br/>  }<br/>  ...<br/>}</span></pre><ul class=""><li id="4ae0" class="nk nl je ln b lo mi lr mj lu ok ly ol mc om mg np nq nr ns bi translated"><strong class="ln jf">情况B: </strong>值<code class="fe ny nz oa ob b"><em class="mh">k</em></code>在实际节点中。</li></ul><p id="35a2" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">首先，关于之前如何简要提及以及如何在<strong class="ln jf">案例C </strong>中解释，在访问下一个孩子之前继续向下树的规则是强制性的，孩子必须至少有<code class="fe ny nz oa ob b">t</code>个值要被访问，否则做一些操作来满足这个条件。</p><p id="bdd9" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">据此，当到达这种情况时意味着实际节点包含目标值<code class="fe ny nz oa ob b">k</code>，具有多于<code class="fe ny nz oa ob b">t — 1</code>的值，并且它不是叶子，因为它将在<strong class="ln jf">情况A </strong>中处理。</p><p id="d14c" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">为了继续通过其一个直接子代(目标值<code class="fe ny nz oa ob b">k</code>的左子代或右子代)沿树向下移动该值，有两种可能的情况:</p><ol class=""><li id="4dad" class="nk nl je ln b lo mi lr mj lu ok ly ol mc om mg ot nq nr ns bi translated"><code class="fe ny nz oa ob b">k</code> <em class="mh"> </em>的左右直接子代都只有<em class="mh"> </em> <code class="fe ny nz oa ob b">t — 1</code>值:</li></ol><p id="1862" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">如果没有具有足够值的直接子节点来继续递归，则值<code class="fe ny nz oa ob b"><em class="mh">k</em></code>必须与两个直接子节点进行<strong class="ln jf">合并</strong>。这样做的方法是定义一个目标(右或左)子节点，其中值<code class="fe ny nz oa ob b"><em class="mh">k</em></code>和其他子节点的所有值将被插入。注意，它会给目标节点留下<code class="fe ny nz oa ob b">(t — 1) + (t — 1) + 1 -&gt; 2t — 1</code>节点，这是最大授权。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/e1ccc7edb6869c75e9fcf878d5697317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*z1xQvz6nceXQ1cR6bF17mw.gif"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">移除节点k=60。由于<strong class="bd kv">结构</strong>而创建的动画</figcaption></figure><p id="3c8b" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">同样，当合并的节点不是叶子时，源节点的子节点也被转移到目标节点。在这种情况下，合并两个直接兄弟，结果将是一个带有<code class="fe ny nz oa ob b">t + t -&gt; 2t</code>子节点的节点，这也是最大授权。</p><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="5c78" class="mx ku je ob b gy og oh l oi oj">...<br/>deleteFromNode(node, value) {<br/>  // Check if value is in the actual node<br/>  const index = node.values.indexOf(value);<br/>  if (index &gt;= 0) {<br/>    ...<br/>    // Check if one children has enough values to transfer<br/>    if (node.children[index].n &gt; this.order - 1 ||<br/>        node.children[index + 1].n &gt; this.order - 1) {<br/>      // One of the immediate children has enough values to transfer<br/>      ...<br/>    }<br/>    // No child with enough values to continue. Do a merge<br/>    this.<strong class="ob jf">mergeNodes</strong>(node.children[index + 1], node.children[index]);<br/>    return this.deleteFromNode(node.children[index], value);<br/>  }<br/>  ...<br/>}</span><span id="f519" class="mx ku je ob b gy ou oh l oi oj">/**<br/>* Merge 2 nodes into one with the parent median value. O(1)<br/>* @param {BTreeNode} origin<br/>* @param {BTreeNode} target<br/>*/<br/><strong class="ob jf">mergeNodes</strong>(origin, target) {<br/>  const indexo = origin.parent.children.indexOf(origin);<br/>  const indext = target.parent.children.indexOf(target);<br/>  target.addValue(target.parent<br/>        .removeValue(Math.min(indexo,indext)));<br/>  for (let i = origin.n - 1; i &gt;= 0; i--) {<br/>     target.addValue(origin.removeValue(i));<br/>  }<br/>  // Remove reference to origin node<br/>  target.parent.deleteChild(indexo);<br/>  // Transfer all the children from origin node to target<br/>  if (!origin.leaf) {<br/>    while (origin.children.length) {<br/>      indexo &gt; indext ?<br/>      target.addChild(<br/>         origin.deleteChild(0), target.children.length) :<br/>      target.addChild(<br/>         origin.deleteChild(origin.children.length-1), 0);<br/>    }<br/>  }<br/>}</span></pre><p id="4988" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">2.左或右直接子到值<code class="fe ny nz oa ob b"><em class="mh">k</em></code>，有超过<code class="fe ny nz oa ob b">t — 1</code>个值:<br/>在这种情况下，<strong class="ln jf">在相邻子树中找到目标值的前置/后续</strong> <code class="fe ny nz oa ob b"><em class="mh">k’</em></code>。然后<strong class="ln jf">将节点中的</strong> <code class="fe ny nz oa ob b"><em class="mh">k</em></code>替换为<code class="fe ny nz oa ob b"><em class="mh">k'</em></code> <em class="mh"> </em>并继续从各自的子节点中递归删除<code class="fe ny nz oa ob b"><em class="mh">k’</em></code> <em class="mh"> </em>。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/09e32ac42a678a3fc5c6cbbf8f12ef5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8CQahf5ZSBHnFRjIIfZjaA.gif"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">移除节点k=40。由于<strong class="bd kv">结构</strong>而创建的动画</figcaption></figure><p id="b0a7" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">在前面的图像中，试图删除当前节点中的目标值<code class="fe ny nz oa ob b">k = 40</code>，在本例中是树的根<em class="mh">的</em>，找到了后继节点<code class="fe ny nz oa ob b">k' = 50</code>并替换了目标值，然后递归继续到具有新目标值<code class="fe ny nz oa ob b">k = 50</code>的右子节点。</p><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="130b" class="mx ku je ob b gy og oh l oi oj">...<br/>deleteFromNode(node, value) {<br/>  // Check if value is in the actual node<br/>  const index = node.values.indexOf(value);<br/>  if (index &gt;= 0) {<br/>    ...<br/>    // Check if one children has enough values to transfer<br/>    if (<strong class="ob jf">node.children[index].n &gt; this.order - 1 ||<br/>        node.children[index + 1].n &gt; this.order - 1</strong>) {<br/>      // One of the immediate children has enough values to transfer<br/>      if (node.children[index].n &gt; this.order - 1) {<br/>        // Left child<br/>        // Replace the target value for the higher of left node.<br/>        // Then delete that value from the child<br/>        const <strong class="ob jf">predecessor</strong> =<br/>          this.<strong class="ob jf">getMinMaxFromSubTree</strong>(node.children[index], 1);<br/>        node.values[index] = predecessor;<br/>        return this.deleteFromNode(node.children[index],<br/>            predecessor);<br/>      }<br/>      // Right child<br/>      const <strong class="ob jf">successor</strong> = <br/>            this.<strong class="ob jf">getMinMaxFromSubTree</strong>(node.children[index+1], 0);<br/>      node.values[index] = successor;<br/>      return this.deleteFromNode(node.children[index+1], successor);<br/>    }<br/>    // No child with enough values to continue. Do a merge<br/>    this.mergeNodes(node.children[index + 1], node.children[index]);<br/>    return this.deleteFromNode(node.children[index], value);<br/>  }<br/>  ...<br/>}</span><span id="92ba" class="mx ku je ob b gy ou oh l oi oj">/**<br/> * Get the lower or higher value in a sub-tree<br/> * @param {BTreeNode} node<br/> * @param { 0 | 1 } max 1 for find max, 0 for min<br/> * @returns {number}<br/>*/<br/><strong class="ob jf">getMinMaxFromSubTree</strong>(node, max) {<br/>  while (!node.leaf) {<br/>    node = node.children[max ? node.n : 0];<br/>  }<br/>  return node.values[max ? node.n - 1 : 0];<br/>}</span></pre><ul class=""><li id="1543" class="nk nl je ln b lo mi lr mj lu ok ly ol mc om mg np nq nr ns bi translated"><strong class="ln jf">案例C: </strong>(也是最后一个！)值<code class="fe ny nz oa ob b">k</code>不在实际节点中。</li></ul><p id="4f2b" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">当被访问的节点不包括目标值<code class="fe ny nz oa ob b">k</code>时，它必须检查这些值以确定要访问的下一个子节点。如果相应的子节点有超过<code class="fe ny nz oa ob b">t — 1</code>的值，则继续该节点上的操作。</p><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="cb9f" class="mx ku je ob b gy og oh l oi oj">...<br/>deleteFromNode(node, value) {<br/>  // Check if value is in the actual node<br/>  const index = node.values.indexOf(value);<br/>  if (index &gt;= 0) {<br/>    ...<br/>  }<br/>  // Value is not present in the node<br/>  if (node.leaf) {<br/>    // Value is not in the tree<br/>    return;<br/>  }<br/>  // Value is not present in the node, search in the children<br/>  let <strong class="ob jf">nextNode</strong> = 0;<br/>  while (nextNode &lt; node.n &amp;&amp; node.values[nextNode] &lt; value) {<br/>    nextNode++;<br/>  }<br/>  if (node.children[nextNode].n &gt; this.order - 1) {<br/>    // Child node has enough values to continue<br/>    return this.<strong class="ob jf">deleteFromNode</strong>(node.children[<strong class="ob jf">nextNode</strong>], value);<br/>  }<br/>  ...<br/>}</span></pre><p id="1f18" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">如果应该拥有<code class="fe ny nz oa ob b">k</code>的相应子节点没有足够的值来继续，它必须找到一个直接兄弟<strong class="ln jf">来为其传递</strong>一个值。如果<strong class="ln jf">的直接兄弟</strong>中的一个有超过<code class="fe ny nz oa ob b">t — 1</code>的值，方法是将中间值<code class="fe ny nz oa ob b">k’</code>从父节点(分隔两个节点的值)转移到目标节点，同时，将源节点中最接近父节点的值<code class="fe ny nz oa ob b">k’’</code>转移到目标节点。下图清楚地说明了这种方法。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/8926a4ce26d370a05568465ffbc8d36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pI-EWdkWhhe-GPDa5ObNgA.gif"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">移除节点k=120。由于<strong class="bd kv">结构</strong>而创建的动画</figcaption></figure><p id="3b5d" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">例如，在上面的图片中，试图删除<code class="fe ny nz oa ob b">k = 120</code>，包含值<code class="fe ny nz oa ob b">[110, 130]</code>的节点被访问。因为要访问的下一个节点，即中间包含<code class="fe ny nz oa ob b">[120]</code>的节点，只有<code class="fe ny nz oa ob b">t — 1</code>个值，所以树搜索一个具有额外值的直接兄弟，该值可以被传输到目标节点，在本例中，就是右边的节点。因此，为了移除<code class="fe ny nz oa ob b">k = 120</code>，该方法将值<code class="fe ny nz oa ob b">k’’ = 140</code>从兄弟节点传输到父节点，并将值<code class="fe ny nz oa ob b">k’ = 130</code>从父节点传输到目标节点，然后继续向下移动到目标节点。</p><p id="7c16" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">当转移方法<strong class="ln jf">中涉及的节点有子节点</strong>时，离源节点最近的子节点被转移到目标节点。</p><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="fba5" class="mx ku je ob b gy og oh l oi oj">deleteFromNode(node, value) {<br/>  ...<br/>  // Child node has not enough values to continue<br/>  if ((nextNode &gt; 0 &amp;&amp;<br/>       node.children[nextNode - 1].n &gt; this.order - 1) <br/>   || (nextNode &lt; node.n &amp;&amp;<br/>       node.children[nextNode + 1].n &gt; this.order - 1)) {<br/>    // One of the immediate children has enough values to transfer<br/>    if (nextNode &gt; 0<br/>      &amp;&amp; node.children[nextNode - 1].n &gt; this.order - 1) {<br/>      this.<strong class="ob jf">transferValue</strong>(node.children[nextNode - 1],<br/>                         node.children[nextNode]);<br/>    } else {<br/>      this.<strong class="ob jf">transferValue</strong>(node.children[nextNode + 1],<br/>                       node.children[nextNode]);<br/>    }<br/>    return this.deleteFromNode(node.children[nextNode], value);<br/>  }<br/>  ...<br/>}</span><span id="af6b" class="mx ku je ob b gy ou oh l oi oj">/**<br/>* Transfer one value from the origin to the target through the parent<br/>* @param {BTreeNode} origin<br/>* @param {BTreeNode} target<br/>*/<br/><strong class="ob jf">transferValue</strong>(origin, target) {<br/>  const indexo = origin.parent.children.indexOf(origin);<br/>  const indext = origin.parent.children.indexOf(target);<br/>  if (indexo &lt; indext) {<br/>    target.<strong class="ob jf">addValue</strong>(target.parent.removeValue(indexo));<br/>    origin.parent.<strong class="ob jf">addValue</strong>(origin.removeValue(origin.n-1));<br/>    if (!origin.leaf) {<br/>      target.<strong class="ob jf">addChild</strong>(<br/>        origin.deleteChild(origin.children.length-1), 0);<br/>    }<br/>  } else {<br/>    target.<strong class="ob jf">addValue</strong>(target.parent.removeValue(indext));<br/>    origin.parent.<strong class="ob jf">addValue</strong>(origin.removeValue(0));<br/>    if (!origin.leaf) {<br/>      target.<strong class="ob jf">addChild</strong>(<br/>        origin.deleteChild(0), target.children.length);<br/>    }<br/>  }<br/>}</span></pre><p id="b02b" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">另一方面，如果要访问的下一个节点刚好有<code class="fe ny nz oa ob b">t — 1</code>个值，并且没有具有足够值的直接兄弟要传输，类似于<strong class="ln jf">案例B </strong>，该节点将不得不<strong class="ln jf">与直接兄弟<strong class="ln jf"> </strong>之一合并</strong>以继续。</p><p id="e9e0" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">下图中，为了去掉<code class="fe ny nz oa ob b">k = 20</code>，在根之后，下一个要访问的节点是左边的第一个孩子。由于该节点仅具有<code class="fe ny nz oa ob b">t — 1</code>值，并且没有具有额外值的直接兄弟要传输，所以实际节点将中间值(在这种情况下为<code class="fe ny nz oa ob b">k' = 40</code>值)下降到目标节点，并传输来自所选直接兄弟的所有节点。然后递归继续向下到目标节点。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/7f02d325825a76ebeb8219e072a3e325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IhwwpCRE5500KoCMtPN4tA.gif"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">删除节点k=20进行合并。由于<strong class="bd kv">结构</strong>而创建的动画</figcaption></figure><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="f495" class="mx ku je ob b gy og oh l oi oj">deleteFromNode(node, value) {<br/>  ...<br/>  // No immediate brother with enough values.<br/>  // Merge node with immediate one brother<br/>  this.mergeNodes( nextNode &gt; 0 ?<br/>      node.children[nextNode - 1] : node.children[nextNode + 1],<br/>      node.children[nextNode]);<br/>  return this.deleteFromNode(node.children[nextNode], value);<br/>}</span></pre><h2 id="65da" class="mx ku je bd kv my mz dn kz na nb dp ld lu nc nd lf ly ne nf lh mc ng nh lj ni bi translated">那么，如何通过删除一个节点来降低树的高度呢？</h2><p id="9cd4" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在进行移除操作但根只有一个值并且两个子节点都只有<code class="fe ny nz oa ob b">t — 1</code>个值的情况下，将不可能满足关于向下移动到下一个节点的值的最小数量的规则。所以唯一的选择是在两个子节点之间进行合并，得到根的唯一值，以确保有一个节点有足够的值继续。但是，这将使根引用成为一个空节点。</p><p id="edb0" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">技术是，在每个删除操作之前，在做任何事情之前检查这个特殊的情况是否存在。如果是这种情况，就像之前解释的那样，树将在高度上收缩，合并两个具有唯一值的子节点，然后<strong class="ln jf">将引用</strong>从旧的根节点更改为具有合并值的节点。下图显示了如何删除目标<code class="fe ny nz oa ob b">k = 10</code>，在继续向下查找目标之前，该树将根与两个子树合并。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/96c39faf0a5eff7af3b9c0719fbbcd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iucvbiIDdpxqmzM5hpOEUw.gif"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">移除节点k=10。一棵树降低了它的高度。由于<strong class="bd kv">结构</strong>而创建的动画</figcaption></figure><p id="75d1" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">下面的代码包含带有remove操作的BTree类。</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="op oo l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">带删除操作的树。</figcaption></figure><h1 id="763e" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">分析操作的复杂性</h1><p id="97c6" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">BTree中的所有操作只取决于树的高度。下表显示了主要BTree方法的复杂性。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/04c0789c415f4b6d2a2c508e9088f3b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dr0jx2UkDMGYSLDPUkSxMQ.png"/></div></div></figure><ul class=""><li id="fc45" class="nk nl je ln b lo mi lr mj lu ok ly ol mc om mg np nq nr ns bi translated"><strong class="ln jf">空格</strong>:对于带有<code class="fe ny nz oa ob b">n</code>值的BTree，空格与插入的值的数量成正比。使用这个<a class="ae nj" href="https://gist.github.com/pgpbpadilla/10344038" rel="noopener ugc nofollow" target="_blank">助手</a>在每次插入后计算b树实例的大小，做了一个小实验来计算树的内存大小，并将其与值的数量进行比较，结果是恒定的:在每个值的平均值<code class="fe ny nz oa ob b">12 bytes</code>左右，这意味着使用的空间与值的数量<code class="fe ny nz oa ob b">n</code>成线性比例。</li></ul><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="f0b5" class="mx ku je ob b gy og oh l oi oj">let count = 0;<br/>const sizes = [];<br/>for (let i = 10; i &lt; 1000; i += 10) {<br/>  count += 1;<br/>  this.bTree.insert(i);<br/>  const size = this.<strong class="ob jf">sizeof</strong>(this.bTree);<br/>  sizes.push(size);<br/>  console.log(size / count); // Around 12<br/>}<br/>console.log(sizes); // [20, 28, 36, 52, 60, 72, 80, 92, 108 ... ]</span></pre><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/215f3a04a408cd3f7995a81f49345ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4tR99v0McfbWF2l3Lxppw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Btree实例在多个节点上的内存分配。</figcaption></figure><ul class=""><li id="4e1e" class="nk nl je ln b lo mi lr mj lu ok ly ol mc om mg np nq nr ns bi translated"><strong class="ln jf"> Search </strong>:在最坏的情况下，当值不存在于树中或者存储在一个叶子中时，搜索方法将对每个访问的节点进行恒定的<code class="fe ny nz oa ob b">c</code>操作，并且它将访问与树的<strong class="ln jf">高度</strong> <code class="fe ny nz oa ob b">log3(N)</code>一样多的节点。所以这个方法的复杂度是:<code class="fe ny nz oa ob b">O(log3(N)*c) -&gt; O(log N)</code></li><li id="e19d" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated"><strong class="ln jf">插入</strong>:在任何情况下，该操作都必须沿着树向下，直到到达一片叶子，因此，与搜索方法一样，复杂度也是<code class="fe ny nz oa ob b">O(log N) </code>。请注意，<em class="mh"> insert() </em>调用的所有子方法，如<em class="mh"> split() </em>或<em class="mh"> insertNonFull() </em>都具有恒定的时间复杂度<code class="fe ny nz oa ob b">O(1)</code>，因为它们只进行值的重新赋值，不进行迭代，也不调用其他复杂度更高的函数。</li></ul><p id="b5e2" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">在下图中，蓝色线条显示了400次连续插入所用时间的结果(以毫秒为单位),在其旁边，红色线条表示累积的平均值。还添加了函数<code class="fe ny nz oa ob b">log3(N)/8</code>来显示两条曲线形状的相似性。有趣的是观察到一些周期性的峰值，这是当插入像<code class="fe ny nz oa ob b">split()</code>那样做额外操作时的情况。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/e7cc02d6cbced9586e788dd26830dfe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WsOuE1Th88av_MCGBi-FRw.png"/></div></div></figure><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="aba6" class="mx ku je ob b gy og oh l oi oj">const times = [];<br/>for (let i = 1; i &lt; 400; i += 1) {<br/>  const init = performance.now();<br/>  <strong class="ob jf">this.bTree.insert(i)</strong>;<br/>  const end = performance.now();<br/>  times.push(end - init);<br/>}<br/>console.log(times); // [0.074999989010393, 0.0099999886006116, ... ]</span></pre><ul class=""><li id="183d" class="nk nl je ln b lo mi lr mj lu ok ly ol mc om mg np nq nr ns bi translated"><strong class="ln jf">删除</strong>:作为搜索和插入方法的删除操作在任何可能的情况下都必须到达一个叶子。在最坏的情况下，当目标值在一个非叶节点中时，这个方法将调用子方法<code class="fe ny nz oa ob b">getMinMaxFromSubTree()</code>，这将把新的目标值留在一个叶节点中。所以这将遍历树两次，但它仍然停留在对数复杂度<code class="fe ny nz oa ob b">O(log N)</code>。其他运算<code class="fe ny nz oa ob b">transferValue()</code>和<code class="fe ny nz oa ob b">mergeNodes()</code>具有线性复杂度<code class="fe ny nz oa ob b">O(1)</code>，因此不影响时间复杂度。</li></ul><p id="3be9" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">下图显示了具有<code class="fe ny nz oa ob b">i</code>值的BTree中<code class="fe ny nz oa ob b">i in 400</code>连续删除的时间性能。结果显示在累积平均值和对数曲线旁边，以显示最后两条曲线之间的形状相似性。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/78d0fdde0392d8ef4dbeb1f5f2c2b306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5TLwmWHKJo2M2lOF8-s1Q.png"/></div></div></figure><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="929a" class="mx ku je ob b gy og oh l oi oj">const times = [];<br/>this.bTree.insert(0);<br/>this.bTree.insert(1);<br/>for (let i = 1; i &lt; 400; i += 1) {<br/>  const init = performance.now();<br/>  this.bTree.delete(i);<br/>  const end = performance.now();<br/>  times.push(end - init);<br/>  this.bTree.insert(i);<br/>  this.bTree.insert(i + 1);<br/>}<br/>console.log(times); // [0.0149999978020787, 0.0200000067707151, ...]</span></pre><h1 id="8920" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">用Vue制作操作动画。射流研究…</h1><h2 id="142e" class="mx ku je bd kv my mz dn kz na nb dp ld lu nc nd lf ly ne nf lh mc ng nh lj ni bi translated">D3 + Vue.js</h2><p id="ab33" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在使用层级和树类的<a class="ae nj" href="https://vuejsexamples.com/tag/d3/" rel="noopener ugc nofollow" target="_blank"> D3库</a>的帮助下(<a class="ae nj" href="https://github.com/d3/d3-hierarchy" rel="noopener ugc nofollow" target="_blank"> Github </a>)，Structies能够可视化一个通用树，以特定的结构向D3提供数据。因此，为了表示和可视化BTree的特定状态，创建了一个新的功能<code class="fe ny nz oa ob b">BTree.toJSON(node)</code>,以便创建D3可以理解的兼容对象，允许创建当前BTree的图形表示。下面有一个<a class="ae nj" href="https://codepen.io/sebastianfdez/pen/VwvMzzj" rel="noopener ugc nofollow" target="_blank"> codepen </a>展示了一个包含子元素和值的简单对象是如何被D3解释成BTree的。</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="ox oo l"/></div></figure><h2 id="6bfe" class="mx ku je bd kv my mz dn kz na nb dp ld lu nc nd lf ly ne nf lh mc ng nh lj ni bi translated">制作动画</h2><p id="70cf" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">为了使事情尽可能简单，这个动画的主要思想是显示插入和删除方法的每一步和每一个比较。注意，在最后一个代码片段中，有一个属性<code class="fe ny nz oa ob b">highlighted</code>将一个节点变成红色，如果两个连接的节点高亮显示，它们之间的链接也变成红色。由于这种突出显示的基本概念，有可能在操作的每个步骤中强调一些节点和链接。</p><p id="5bda" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">结构使用<code class="fe ny nz oa ob b">Sequences</code>和<code class="fe ny nz oa ob b">Frames</code>的概念来表示一个多步骤操作的动画，这样，一个名为<strong class="ln jf"> Visualizer </strong>的组件负责使用D3显示树。这个组件接收一个<code class="fe ny nz oa ob b">Sequences</code>列表来显示，所以每个操作，像<code class="fe ny nz oa ob b">BTree.insert(k)</code>或者<code class="fe ny nz oa ob b">BTree.delete(k)</code>都会返回一个<code class="fe ny nz oa ob b">Sequence</code>对象，里面有多个<code class="fe ny nz oa ob b">Frames</code>；其中每个<code class="fe ny nz oa ob b">Frame</code>包含一个对象<code class="fe ny nz oa ob b">Tree</code>，与D3兼容，带有一些高亮显示的值。</p><p id="4c1f" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">每次操作后，创建一个新的空<code class="fe ny nz oa ob b">Sequence</code>并添加到<strong class="ln jf">可视化器</strong>订阅的列表中，并且立即将<code class="fe ny nz oa ob b">Frames</code>一个接一个地添加到这个新的<code class="fe ny nz oa ob b">Sequence</code>中。默认情况下，可视化工具显示的是最后一个序列的最后一帧，因此这种异步添加帧的技术会产生动画的感觉。</p><pre class="mo mp mq mr gt oc ob od oe aw of bi"><span id="64fe" class="mx ku je ob b gy og oh l oi oj"><strong class="ob jf">addSequenceAsync</strong>(frames) {<br/>  this.isAnimating = true;<br/>  const newSequence = new Sequence();<br/>  newSequence.addFrame(frames[0]);<br/>  this.sequencesList.push(newSequence);<br/>  this.currentSequenceNumber = this.sequencesList.length - 1;<br/>  this.currentFrame = 0;<br/>  <strong class="ob jf">// </strong>Asynchronously<strong class="ob jf"> </strong>add all frames to the last Sequence<br/>  for (let i = 1; i &lt; frames.length; i += 1) {<strong class="ob jf"><br/>    setTimeout</strong>(() =&gt; {<br/>      newSequence.<strong class="ob jf">addFrame</strong>(frames[i]);<br/>      if (i === frames.length - 1) {<br/>        this.isAnimating = false;<br/>      }<br/>      this.currentFrame += 1;<br/>    }, i * 500);<br/>  }<br/>},</span></pre><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/fdaf1207fc0c835110661176e5b4fc01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC7X2RGxrAX2VWLmTCg3Cg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">可视化图表</figcaption></figure><h2 id="6b7a" class="mx ku je bd kv my mz dn kz na nb dp ld lu nc nd lf ly ne nf lh mc ng nh lj ni bi translated">给你。</h2><p id="c5c3" class="pw-post-body-paragraph ll lm je ln b lo lp kf lq lr ls ki lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">我希望这篇文章能帮助你理解BTrees是如何工作的，以及它们是如何在访问大量信息时保持对数复杂度的。</p><p id="418a" class="pw-post-body-paragraph ll lm je ln b lo mi kf lq lr mj ki lt lu mk lw lx ly ml ma mb mc mm me mf mg im bi translated">感谢阅读！</p><div class="is it gp gr iu oz"><a href="https://github.com/sebastianfdez" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd jf gy z fp pe fr fs pf fu fw jd bi translated">sebastianfdez -概述</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">在GitHub上注册你自己的个人资料，这是托管代码、管理项目和构建软件的最佳地方…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">github.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ja oz"/></div></div></a></div><h1 id="f9c8" class="kt ku je bd kv kw kx ky kz la lb lc ld kk le kl lf kn lg ko lh kq li kr lj lk bi translated">参考</h1><ul class=""><li id="cc76" class="nk nl je ln b lo lp lr ls lu nm ly nn mc no mg np nq nr ns bi translated">JavaScript BTree代码:<a class="ae nj" href="https://gist.github.com/sebastianfdez/5113cee7a55dc644be6a09081afd119a" rel="noopener ugc nofollow" target="_blank">要点链接</a></li><li id="7112" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated">D3库:【https://github.com/d3/d3-hierarchy T2】</li><li id="1bff" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated"><em class="mh">算法简介</em> (2001)托马斯H..放大图片作者:Thomas H Cormen，Charles E Leiserson，Ronald L Rivest，Clifford Stein</li><li id="7ee5" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated">结构:<a class="ae nj" href="https://structies.firebaseapp.com/#/" rel="noopener ugc nofollow" target="_blank">https://structies.firebaseapp.com/#/</a></li><li id="5291" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated">作者Github:<a class="ae nj" href="https://github.com/sebastianfdez" rel="noopener ugc nofollow" target="_blank">https://github.com/sebastianfdez</a></li><li id="9c87" class="nk nl je ln b lo nt lr nu lu nv ly nw mc nx mg np nq nr ns bi translated">二叉树:D3 + Vue.js: <a class="ae nj" href="https://bl.ocks.org/ravi4j" rel="noopener ugc nofollow" target="_blank">拉维夏尔马</a>的块。</li></ul></div></div>    
</body>
</html>