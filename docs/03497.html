<html>
<head>
<title>Learning Go — Array, Slice, Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋—数组、切片、地图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-array-slice-map-934eed320b1c?source=collection_archive---------11-----------------------#2020-05-12">https://levelup.gitconnected.com/learning-go-array-slice-map-934eed320b1c?source=collection_archive---------11-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2d3ae06690c3807d8b3042e9afcb2329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6RduVMW39hTPfKo5.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片提供:<a class="ae kf" href="https://www.google.com/search?sa=X&amp;sxsrf=ALeKk01IMcufXyYru_UgGh5vSm0SJTaZGw:1589215435126&amp;source=univ&amp;tbm=isch&amp;q=Learning-Go+images&amp;ved=2ahUKEwiBsu3roKzpAhUBXSsKHfFpDKEQ7Al6BAgLECc&amp;biw=1792&amp;bih=986#imgrc=xHsYWTL_SDGn7M" rel="noopener ugc nofollow" target="_blank">google.com</a></figcaption></figure><p id="ef25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/go-working-with-primitive-data-types-a06245778957">见过</a>如何创建和使用变量、指针和常量。在本文中，我们将看到语言中内置的四种重要的集合类型。</p><p id="823b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从简单的阵列开始，然后我们继续讨论Slice，这是阵列的一个发展版本。从Slice开始，我们讨论映射一个键值对集合。让我们从数组开始。</p><h1 id="102a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">排列</h1><p id="2822" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">就像任何其他编程语言一样，Go中的数组是相似数据类型的固定大小集合。</p><p id="6091" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数组声明和其他语言一样非常简单，但是有一个有趣的变化，</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fb3e" class="mq lf it mm b gy mr ms l mt mu"><strong class="mm iu">   other language syntax          |            Go syntax</strong><br/>  int[] arr = new int[10]         <strong class="mm iu">|</strong>           arr := [10]int</span></pre><p id="1da5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您来自C#或Java之类的编程背景，那么声明的左侧可能看起来很熟悉。Go中唯一的变化是我们在数组的数据类型前指定了带有max-limit的方括号。</p><p id="7884" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何其他变量声明一样，数组也可以用不同的方式声明初始化。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0201" class="mq lf it mm b gy mr ms l mt mu">//Declaration 1<br/>var arr = [5]int{1, 2, 3, 4, 5}</span><span id="8b27" class="mq lf it mm b gy mv ms l mt mu">//Declaration 2<br/>var arr [5]int<br/>arr = [5]int{1, 2, 3, 4, 5}</span><span id="5055" class="mq lf it mm b gy mv ms l mt mu">//Declaration<br/>arr := [5]int{1,2,3,4,5}</span></pre><p id="607d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Go中的数组是从零开始索引的，所以我们可以从“0”开始访问数组元素。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7320" class="mq lf it mm b gy mr ms l mt mu">var arr [5]int<br/>arr[0] = 1<br/>arr[1] = 2<br/>fmt.Printf(arr[1]) //prints: 2 </span></pre><p id="0725" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，Go中的数组是有界的。如果您试图访问超出数组限制的项，Go将抛出运行时错误。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="719c" class="mq lf it mm b gy mr ms l mt mu">var arr [5]int<br/>arr[0] = 1<br/>arr[1] = 2<br/>fmt.Printf(arr[6])</span><span id="19c9" class="mq lf it mm b gy mv ms l mt mu">//Throws below compilation error<br/><strong class="mm iu">invalid array index 6 (out of bounds for 5-element array)</strong></span></pre><p id="65b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Go还支持多维数组:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="51aa" class="mq lf it mm b gy mr ms l mt mu">//Multi dimensional array<br/>var arrTwoD [2][3]int<br/>for i := 0; i &lt; 2; i++ {<br/>  for j := 0; j &lt; 3; j++ {<br/>   arrTwoD[i][j] = i + j<br/>   }<br/> }<br/> fmt.Println("2d: ", arrTwoD) // prints: [[0 1 2] [1 2 3]]</span></pre><p id="3f6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">固定长度的数组总是很难处理。数组的内存分配只在初始化时进行一次，因此很难根据数据大小来增加或减少数组的大小。与动态内存分配数据结构相比，数组具有更好的速度和性能。由于数组的刚性本质，在代码库中切片比数组使用得更频繁是很常见的。接下来让我们看看切片。</p><h1 id="cf5d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">薄片</h1><p id="a930" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">切片是构建在数组之上的数组的进化版本。与数组相反，切片的大小可以根据数据的大小而增长和收缩。切片的灵活性使其值得选择阵列，即使后者与前者相比具有更好的速度和性能。</p><p id="e867" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">宣言</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7b34" class="mq lf it mm b gy mr ms l mt mu">  mySlice := []int{1, 2, 3}</span></pre><p id="1ea3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">片的声明非常简单，类似于数组声明，唯一的区别是我们没有指定大小。这足以让编译器理解数组和切片之间的区别。</p><p id="2379" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">动态调整大小</strong></p><p id="ee25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在幕后，编译器在看到上面的声明时创建了一个大小为3的数组，将元素<code class="fe mw mx my mm b">1,2,3</code>添加到数组中，并将变量<code class="fe mw mx my mm b">mySlice</code>指向数组。我们不必自己处理底层数组。相反，我们只处理slice变量。这可能会引发一个问题:如果要与数组一起工作，切片与数组有何不同。</p><p id="d0a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，切片可以动态改变大小。让我们看看内置方法<code class="fe mw mx my mm b">append()</code>来更好地理解这一点。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a7ed" class="mq lf it mm b gy mr ms l mt mu"> demoSlice := []int{1,2}<br/> fmt.Println(demoSlice) // [1,2]</span><span id="2b15" class="mq lf it mm b gy mv ms l mt mu"> demoSlice = append(demoSlice,3)<br/> fmt.Println(demoSlice) // [1,2,3]</span></pre><p id="7cab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以用<code class="fe mw mx my mm b">append()</code>方法生成切片。Go管理底层数组，它让开发人员不用担心调整大小的开销。</p><p id="8aae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">切片中的切片</strong></p><p id="8cdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Go中的冒号操作符<code class="fe mw mx my mm b">:</code>有助于创建切片中的切片。</p><p id="7460" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">s1 := demoSlice[0:2]</code> —创建一个新数组，其索引<code class="fe mw mx my mm b">0</code>处的元素一直到索引<code class="fe mw mx my mm b">2</code>之前的元素。<code class="fe mw mx my mm b">s1</code>保存一个<code class="fe mw mx my mm b">[1,2]</code>的数组。</p><p id="d45a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">s2 := demoSlice[0:]</code> —创建一个新数组，其元素位于索引<code class="fe mw mx my mm b">0</code>处，直到切片的末尾。<code class="fe mw mx my mm b">s2</code>保存一个<code class="fe mw mx my mm b">[1,2,3]</code>的数组。</p><p id="ad7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">s3 := demoSlice[:2]</code> —创建一个新数组，其元素从片的开始处一直到索引<code class="fe mw mx my mm b">2</code>之前的元素。<code class="fe mw mx my mm b">s3</code>保存一个<code class="fe mw mx my mm b">[1,2]</code>的数组。</p><p id="a90b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">切片是Go的强大特性之一，当我们需要处理更小的数据集时，它提供了动态调整切片大小和创建子切片的能力。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="1093" class="le lf it bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">地图</h1><p id="9818" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">映射是一个集合，类似于其他编程语言中的字典或堆。地图是无序的集合，数据存储为<strong class="ki iu">键值</strong>对。映射用于快速检索、基于键的值查找，并且是其性能常用的数据结构之一。</p><p id="46b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">映射是可变的数据类型，可以添加、修改、删除和清除项目。</p><p id="4174" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，地图是一个无序的集合，这一点非常重要。</p><p id="8111" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">申报</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f351" class="mq lf it mm b gy mr ms l mt mu">var m <strong class="mm iu">map[--KeyType--]--ValueType--</strong></span><span id="b929" class="mq lf it mm b gy mv ms l mt mu">// Example declaration<br/>var demoMap1 map[int]string</span><span id="bdbf" class="mq lf it mm b gy mv ms l mt mu">demoMap2 := map[string]bool{}</span></pre><p id="72a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">从地图分配和检索</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c35b" class="mq lf it mm b gy mr ms l mt mu">employeeMap := map[int]string{}</span><span id="5da0" class="mq lf it mm b gy mv ms l mt mu">//Assignment<br/>employeeMap[1] = "Employee 1"<br/>employeeMap[2] = "Employee 2"<br/>fmt.Println(employee) // map[1:Employee 1 2:Employee 2]</span><span id="2bda" class="mq lf it mm b gy mv ms l mt mu">//Retrieving data<br/>name := employeeMap[2]</span><span id="4f7b" class="mq lf it mm b gy mv ms l mt mu">fmt.Println(employee[1]) //Employee 1<br/>fmt.Println(name) //Employee 2</span></pre><p id="b1d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与一些编程语言不同，Go没有任何方便的函数来列出映射的键或值。然而，它允许通过使用<code class="fe mw mx my mm b">range</code>操作符进行迭代。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="254e" class="mq lf it mm b gy mr ms l mt mu">for key, value := range employeeMap {<br/>    fmt.Printf("%d is the key for the value %q\n", key, value)<br/>}</span><span id="2f5b" class="mq lf it mm b gy mv ms l mt mu"><strong class="mm iu">Output:</strong><br/>2 is the key for the value "Employee 2"<br/>1 is the key for the value "Employee 1"</span></pre><p id="fe3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">检查映射中是否存在关键字</strong></p><p id="0409" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检查map中是否存在键值对是非常方便的操作之一。使用键访问地图中的元素会返回两个值—值和布尔值。bool返回值将有助于理解一个键在映射中是否可用。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9441" class="mq lf it mm b gy mr ms l mt mu">name, ok := employeeMap[1]// Employee 1, true<br/>name, ok := employees[1001]// "",false</span></pre><p id="0000" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">删除</strong></p><p id="4483" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了从映射中删除一个值，我们将使用内置方法<code class="fe mw mx my mm b"><strong class="ki iu">delete</strong></code>。<strong class="ki iu"> </strong>删除会把Map作为第一个参数，把需要删除的值的key作为第二个参数。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2b78" class="mq lf it mm b gy mr ms l mt mu">employeeMap := map[int]string{}</span><span id="daa6" class="mq lf it mm b gy mv ms l mt mu">//Assignment<br/>employeeMap[1] = "Employee 1"<br/>employeeMap[2] = "Employee 2"</span><span id="8512" class="mq lf it mm b gy mv ms l mt mu">delete(employeeMap, 2)<br/>fmt.Println(employeeMap)</span><span id="13fd" class="mq lf it mm b gy mv ms l mt mu"><strong class="mm iu">Output:<br/></strong>map[1:Employee 1]</span></pre><p id="9d27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有从地图上移除所有项目的便捷功能。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dceb" class="mq lf it mm b gy mr ms l mt mu">employeeMap = map[int]string{}<br/>fmt.Println(employeeMap)</span><span id="fce6" class="mq lf it mm b gy mv ms l mt mu"><strong class="mm iu">Output<br/></strong>map[]</span></pre><p id="1d8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">映射由键值对组成，并提供了一种不依赖索引来存储数据的方法。这允许我们根据值的含义和与其他数据类型的关系来检索值。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="3048" class="le lf it bd lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb bi translated">结论</h1><p id="1483" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们首先讨论了数组，以及数组是同一类型实体的固定大小的集合。所以你可以有整数数组，也可以有结构类型的数组。我们在Go中可以使用的任何数据类型，我们都可以创建一个。</p><p id="4207" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们继续讨论切片，以及切片在许多方面如何表现为数组，只是切片不是固定大小的实体。切片可以根据需要调整大小，因此通常用来代替数组，因为改变它们大小的能力使它们更加灵活，并为它们开辟了更多的用例。</p><p id="06e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们讨论了如何在Go中的一个名为map的集合类型中将键和值关联在一起，以及如何创建该映射，如何向该映射添加实体，以及如何从中提取实体。</p><p id="92ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我们将看到Go中的结构。在围棋中我们没有阶级概念。我们有方法，也有字段，但是在这门语言中，这些是以一种更加动态和灵活的方式联系在一起的。让我们在下一篇文章中看到。</p><p id="283a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参考资料和进一步阅读:</p><div class="nm nn gp gr no np"><a href="https://blog.golang.org/slices-intro" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">Go博客</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">Andrew Gerrand 2011年1月5日简介Go的切片类型提供了一种方便有效的工作方式…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">blog.golang.org</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od jz np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://medium.com/rungo/the-anatomy-of-slices-in-go-6450e3bb2b94" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">围棋中的切片剖析</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">切片类似于数组，但它们的长度可以不同。</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od jz np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://medium.com/rungo/the-anatomy-of-maps-in-go-79b82836838b" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">围棋中的地图剖析</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">映射是一种复合数据类型，可以保存由键:值对表示的数据。</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="of l oa ob oc ny od jz np"/></div></div></a></div></div></div>    
</body>
</html>