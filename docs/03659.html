<html>
<head>
<title>Why Floating-Point Numbers are not Always Accurate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么浮点数并不总是准确的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-floating-point-numbers-are-not-always-accurate-9a57e812ace1?source=collection_archive---------11-----------------------#2020-05-21">https://levelup.gitconnected.com/why-floating-point-numbers-are-not-always-accurate-9a57e812ace1?source=collection_archive---------11-----------------------#2020-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0339" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">浮点数不准确或出错的原因。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9ba568df4232c3a79404cf0396f533b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jDnUg1HcQYKwfHzA"/></div></div></figure><p id="16d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您是一名程序员，并且处理带分数的数字(例如，表示从某个事件或交易金额[美元]开始经过的时间[秒])，您可能听说过不应该使用浮点类型，因为它们并不总是准确/精确的。</p><p id="5851" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将解释为什么浮点数并不总是精确的。</p><p id="0205" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我快速提醒一下浮点表示的基础知识。</p><h1 id="df96" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">浮点表示法</strong></h1><p id="e772" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><a class="ae mn" href="https://en.wikipedia.org/wiki/IEEE_754" rel="noopener ugc nofollow" target="_blank"> IEEE 754 </a>浮点标准规定浮点的二进制表示格式如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/c29d8ffcfa3ebb6e832cfcd5b9c90fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRmZCVQEUVB5YJQ60mjE8A.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">由Codekaizen —自己的作品，CC BY 3.0，【https://commons.wikimedia.org/w/index.php?curid=3651274 T4】</figcaption></figure><p id="20f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，浮点值表示具有32位大小(称为<em class="mt">单精度</em>，对于本文的其余部分，我将重点关注单精度浮点)。在C或C++编程语言中，这对应于大多数平台上的<em class="mt"> float </em>类型(C++标准没有规定大小)。</p><ul class=""><li id="62ea" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated">sign:浮点数的符号(1位)。</li><li id="d036" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">指数:放在以2为基数的指数字段中的值(8位)。</li><li id="af32" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">分数:通常介于0和1之间的值，位于分数字段(23位)。</li></ul><p id="688e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了从编码值计算一个数，使用下面的形式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/1038c4f820aa001d4c1a87d0d3d54cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OfmlWADPq9c6PhsJpwyQw.png"/></div></div></figure><p id="79fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">IEEE 754添加了一个值为1的不可见前导位(实际上并未编码),以在分数位中节省更多的位。</p><p id="90bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，为了优化对浮点值的操作，在将指数编码为二进制表示格式时，会将127作为偏差添加到指数中(即指数为-126的值与指数+1一起存储)，因此在从编码值计算数字时，我们需要从指数位中的值减去127。</p><p id="8022" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们刷新了关于浮点表示的记忆，让我们深入了解为什么浮点数并不总是精确的(精度有限)。</p><h1 id="ad57" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">为什么浮点数的精度有限</strong></h1><p id="6ca7" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们讨论了数字是如何编码成浮点格式的。我们还检查了它是如何计算到数字的。</p><p id="b9f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更容易理解为什么浮点精度有限，这一次，我们从编码的浮点计算二进制数。</p><p id="2195" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，1.0(十进制)编码为0011111110000000000000000000，即0(符号)011111111(指数)000000000000000(分数)。</p><p id="02f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们用下面的形式计算二进制数，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/1038c4f820aa001d4c1a87d0d3d54cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OfmlWADPq9c6PhsJpwyQw.png"/></div></div></figure><p id="eae9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1.0000000000000000000000(二进制)× 2⁰</p><p id="a003" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以加减的最小数字是0.00000000000000000001(二进制)= 0.00000011920928955078(十进制)。</p><p id="a169" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果加上或减去一个小于0.00000011920928955078的数，结果不会改变。这是使用单精度浮点数时1.0的精度。</p><p id="3b75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，在这种情况下这不是一个大问题，因为0.00000011920928955078对于大多数应用程序来说已经足够小了(0.00000011920928955078秒已经足够小了)。</p><p id="c533" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们来看看1000000.0(十进制)。编码为0100100101110100001001000000000，即0(符号)10010010010(指数)111010000100000000(分数)。</p><p id="410c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">二进制数是1.111010000100100000000(二进制)× 2 ⁹，也就是11110100001001000000.0000(二进制)。</p><p id="b860" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以加减的最小数字是0.0001(二进制)= <strong class="kw iu"> 0.0625 </strong>(十进制)。</p><p id="ef1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，与数字为1.0时相比，精度要低得多。这可能会有问题。例如，如果使用单精度浮点来表示自应用程序启动以来的时间(秒)，并且应用程序每0.05秒计算一次时间。1000000.0(或更早)之后，时间停止前进！</p><h1 id="8fb8" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">总结</strong></h1><p id="b902" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在这篇文章中，我谈到了单精度浮点编码格式的基础，以及如何从编码值计算数字。然后我解释了为什么浮点数并不总是准确的。</p></div></div>    
</body>
</html>