<html>
<head>
<title>White Label Mobile App with React Native and Babel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有React Native和Babel的白标移动应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/white-label-mobile-app-with-react-native-and-babel-490363ec59?source=collection_archive---------7-----------------------#2020-09-24">https://levelup.gitconnected.com/white-label-mobile-app-with-react-native-and-babel-490363ec59?source=collection_archive---------7-----------------------#2020-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fae2bd5092b3e0e475ad56491ad89624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1JhBpE24eqOMKTiyt9Bkug.png"/></div></div></figure><p id="711c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的<a class="ae kw" href="https://medium.com/swlh/white-label-web-app-with-reactjs-and-webpack-bb3a94a83fe6" rel="noopener">上一篇文章</a>中，我描述了一个白色标签网络应用的解决方案，我在之前的一个项目中使用过。我计划在我目前的项目中使用同样的方法。问题是，在当前项目中，我们还构建了移动应用程序，如果能够在React Native world中解决以下挑战，那就太好了:</p><ul class=""><li id="663f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">每个品牌应用不同的风格/主题</li><li id="9445" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">迎合内容差异</li><li id="388d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">迎合不同品牌之间的布局/结构和行为差异</li><li id="6aad" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">从一个代码库生产多个产品</li></ul><h1 id="44ac" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">研究</h1><p id="dcea" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><a class="ae kw" href="https://hackernoon.com/setting-up-android-like-product-flavors-in-react-native-39b6c011061b" rel="noopener ugc nofollow" target="_blank">现有</a> <a class="ae kw" href="https://medium.com/flawless-app-stories/react-native-white-label-101-163c1967c12a" rel="noopener">篇</a> <a class="ae kw" href="https://medium.com/@dzigorium/one-code-base-for-a-mobile-application-6fe086f24fdd" rel="noopener">篇</a>关于如何在打包层面(bundle IDs，assets等)实现React原生app的白色标签化。)通过利用<a class="ae kw" href="https://developer.android.com/studio/build/build-variants" rel="noopener ugc nofollow" target="_blank"> Android风格</a>和<a class="ae kw" href="https://developer.apple.com/library/archive/documentation/ToolsLanguages/Conceptual/Xcode_Overview/WorkingwithTargets.html" rel="noopener ugc nofollow" target="_blank"> iOS目标</a>。这些将对我们有用，但将只涵盖我们需求的一个子集。提到的文章也试图解决主题化和特性集的差异，但主要是通过平面配置文件和<code class="fe mo mp mq mr b">if () ... else ...</code>逻辑，我认为从长远来看这是不可维护的，所以我继续寻找。</p><p id="32a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自WellD Tech的那个在处理代码级别的差异上更加详细，但是他们的解决方案对我们来说不够灵活，因为它只允许配置给定版本中包含的顶级模块列表。</p><p id="0197" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我能找到的最符合我们标准的解决方案是<a class="ae kw" href="https://medium.com/rbi-tech/a-b-tested-feature-flagged-white-label-apps-with-webpack-fddd4c629f1f" rel="noopener">使用自定义文件扩展名</a>。链接的文章使用了Webpack，但是Metro的<code class="fe mo mp mq mr b"><a class="ae kw" href="https://facebook.github.io/metro/docs/configuration/#sourceexts" rel="noopener ugc nofollow" target="_blank">sourceExts</a></code>设置也可以达到同样的效果。不过，我们可能会对这种方法有所挑战，因为我们使用了一个<a class="ae kw" href="https://www.youi.tv/youi-engine/" rel="noopener ugc nofollow" target="_blank">应用引擎</a>，它包装了React Native，并有自己的内部文件扩展名列表及其优先级，我不想弄乱它。</p><p id="c5a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我决定不再寻找现成的解决方案，自己想办法。</p><h1 id="c8ff" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">第一次尝试(失败)</h1><p id="c3d3" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">既然我已经为ReactJS 解决了这个问题，我想在React Native中肯定也有类似的方法。我的第一次尝试是看看Metro bundler(作为Webpack的等价物)和它的<code class="fe mo mp mq mr b"><a class="ae kw" href="https://facebook.github.io/metro/docs/configuration/#extranodemodules" rel="noopener ugc nofollow" target="_blank">extraNodeModules</a></code>。它看起来很有前途，尤其是与代理对象相结合，代理对象通常在<a class="ae kw" href="https://medium.com/@dushyant_db/how-to-import-files-from-outside-of-root-directory-with-react-native-metro-bundler-18207a348427" rel="noopener">从项目根</a>外部引用文件时使用。</p><p id="09c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，事实证明，使用这种配置设置，没有办法实现我在Web白标应用程序中非常重视的回退机制。</p><h1 id="b7a8" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">一个解决方案</h1><p id="a283" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我的“最终”解决方案是基于<code class="fe mo mp mq mr b"><a class="ae kw" href="https://github.com/tleunen/babel-plugin-module-resolver" rel="noopener ugc nofollow" target="_blank">babel-plugin-module-resolver</a></code>及其处理模块多个根位置的能力。它允许我们在JS捆绑构建阶段解决品牌模块导入，并为不需要为某些品牌定制的模块提供一个备用位置。</p><p id="7eff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> #1基础项目<br/> </strong>作为工作演示的基础，我将使用来自<a class="ae kw" href="https://www.reactnativeschool.com/" rel="noopener ugc nofollow" target="_blank"> ReactNativeSchool </a>的示例<a class="ae kw" href="https://github.com/ReactNativeSchool/react-native-calculator" rel="noopener ugc nofollow" target="_blank">计算器应用</a>。他们的项目使用了<a class="ae kw" href="https://expo.io/" rel="noopener ugc nofollow" target="_blank"> Expo </a>，但这不是必需的，即使你不使用Expo，所描述的解决方案也能工作。最初的项目结构是:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/5f5a494fc3e7a9446c6e1fca3a373061.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/1*5VBjE4GvdT1VmCMPbiYHYw.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">请参见<a class="ae kw" href="https://github.com/jar0s/reactNative-babel-wla/commit/a6ab4a6b02411de1c4535f7cb23d67e6e04d7de9" rel="noopener ugc nofollow" target="_blank">该提交</a></figcaption></figure><p id="9f5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe mo mp mq mr b">yarn run android</code>会显示以下应用程序:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/6d80e29501ee502b9ccf35f82c866e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*kTGl5jnnOLar01n6FKJqVg.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">基本应用</figcaption></figure><p id="34ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> #2引入模块解析器<br/> </strong>让我们添加<code class="fe mo mp mq mr b"><a class="ae kw" href="https://github.com/tleunen/babel-plugin-module-resolver" rel="noopener ugc nofollow" target="_blank">babel-plugin-module-resolver</a></code>，引入一个<code class="fe mo mp mq mr b">brands</code>文件夹，从组件中提取样式。</p><p id="4bea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新的文件夹结构:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/660d46d69f870ff412e70365019941b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*KgSeOGBPOdbRcDpeAYCvCA.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">在<a class="ae kw" href="https://github.com/jar0s/reactNative-babel-wla/commit/d234f6650f6e2ea6dc7ca655cef9d18b77db58f1" rel="noopener ugc nofollow" target="_blank">中看到它这个commit </a></figcaption></figure><p id="ac26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相应的代码更改如下:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">在<a class="ae kw" href="https://github.com/jar0s/reactNative-babel-wla/commit/d234f6650f6e2ea6dc7ca655cef9d18b77db58f1" rel="noopener ugc nofollow" target="_blank">提交</a>中查看</figcaption></figure><p id="2675" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们得到的仍然是同一个应用程序，但结构略有不同。如果您查看新的独立样式的导入语句，您会发现它们没有提供任何相对路径(例如<code class="fe mo mp mq mr b">import ButtonStyles from “ButtonStyles"</code>)。由于新添加的模块解析器，Babel将负责解析实际路径。我们将在下一步中利用这一点。</p><p id="2a93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> #3添加更多品牌<br/> </strong>我们添加<code class="fe mo mp mq mr b">acme</code>和<code class="fe mo mp mq mr b">calc_co</code>作为新品牌，分别定制按钮和显示。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0e0e3e6ea2f7a9c3ce89bfc91eef6715.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*He0t1L5kiEepmzUBPiEwpg.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">在<a class="ae kw" href="https://github.com/jar0s/reactNative-babel-wla/commit/80fe6f8aa9b3edd58b28bacaedcd1258f000af12" rel="noopener ugc nofollow" target="_blank">提交</a>中查看</figcaption></figure><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/ab17fa1004bd8b80597e1794759de8ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yy-WKtALsjIbNhwP9pnmJQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">我选择只为Acme品牌定制按钮的颜色。左边默认，右边acme。</figcaption></figure><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/48a141a7dd136fd94ae611dcbe031e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7MKqYqDtCtSbDtbxW8YGQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">我选择自定义Calc Co显示的颜色和文本对齐。左边是默认，右边是calc_co。</figcaption></figure><p id="871e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要如下更新<code class="fe mo mp mq mr b">babel.config.js</code>:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">在<a class="ae kw" href="https://github.com/jar0s/reactNative-babel-wla/commit/80fe6f8aa9b3edd58b28bacaedcd1258f000af12" rel="noopener ugc nofollow" target="_blank">提交</a>中查看</figcaption></figure><p id="42a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一步需要注意的是<code class="fe mo mp mq mr b">acme</code>和<code class="fe mo mp mq mr b">calc_co</code>都没有完整的文件集。由于默认的回退机制，他们不需要这样做。我们告诉Babel首先在应用程序根中寻找模块，然后在<code class="fe mo mp mq mr b">APP_BRAND</code>环境变量中定义的品牌的文件夹中，然后在默认的备用位置中。</p><p id="7bb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以使用<code class="fe mo mp mq mr b">APP_BRAND={brand_name} yarn run android</code>构建针对特定品牌的应用程序，以获得以下内容:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/9c7d05a85d8e68f20a42f34f297cd597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vco667imFIztqhqTL6Qn2g.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">分别为“纱线运行安卓系统”、“APP_BRAND=acme纱线运行安卓系统”和“APP_BRAND=calc_co纱线运行安卓系统”的结果。</figcaption></figure><p id="ec9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">酷，我们得到不同风格的计算器。因为不同的风格只是众多需求中的一个。接下来让我们进入一些更有趣的东西。</p><p id="1614" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> #4支持结构&amp;内容差异<br/> </strong>作为这一步的准备，我对应用进行了一点重新分解，将其分解为更小的组件。<a class="ae kw" href="https://github.com/jar0s/reactNative-babel-wla/commit/06188f8ad4f1173db06766a43cff0a00c22f7035" rel="noopener ugc nofollow" target="_blank">变更</a>主要是增加了<code class="fe mo mp mq mr b">Calc</code>和<code class="fe mo mp mq mr b">ButtonPanel</code>部件。</p><p id="e1d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了进一步区分品牌，除了造型，让我们引入包装对象(是的，命名很难；)).他们的目的是在避免代码重复的同时，使品牌之间的结构和内容差异成为可能(或者将其保持在最低限度)。这个想法是，主要的业务逻辑和渲染留在顶级组件中(不是特定于品牌的)，但是这些组件通过props进行参数化，以便它们可以根据这些参数有不同的外观或行为。感觉这是一种干净的方式，可以保持特定品牌代码的合理大小，并包含在给定品牌的文件夹中。</p><p id="9f25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个例子:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/685d5b6d5db90f588d761aadbce7cacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*PLuqIdwiCT66OeGET-cfKw.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">新包装对象。在<a class="ae kw" href="https://github.com/jar0s/reactNative-babel-wla/commit/3b224518d726f76c2d3bf1abe9f9044deca0d9d8" rel="noopener ugc nofollow" target="_blank">提交</a>中查看它们。</figcaption></figure><p id="780a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我如何参数化主要组件:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7cc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让包装组件生效，您需要导入它们，而不是主组件。来自<code class="fe mo mp mq mr b">index.js</code>的例子:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="da43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用<code class="fe mo mp mq mr b">CalcWrapper</code>将Calc Co品牌的计算器显示屏放在底部:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/d651dc98ddd9b7ed30b9b12bbbc57ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BIOmu9Jaiax5bfxJE6B1w.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">左边是默认，右边是计算公司。</figcaption></figure><p id="1772" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我对Acme按钮使用了罗马数字:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/3517aaaad3fdad45adf1bc654c1e0966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A-B2gR3DK7ViBTP5KR52aA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">默认在左边，顶点在右边。</figcaption></figure><p id="2b2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我用完全定制的按钮布局为Calc Co:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/fd661b7ae3d179ce1dc3d6b6bbeb1f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yL-sqY2x3OhxMMtXIfHaw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">左边是默认，右边是计算公司。</figcaption></figure><p id="05cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终结果如下:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/2e949b33720f54daa2e7514ae1203f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e4MQ5haGrwSrd8WmM21hrQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">分别为“纱线运行安卓系统”、“APP_BRAND=acme纱线运行安卓系统”和“APP_BRAND=calc_co纱线运行安卓系统”的结果。</figcaption></figure><p id="1e2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，使用这种方法，你不需要太多额外的代码就可以得到明显不同的应用程序。一旦你将主要组件参数化，你就可以很容易地用它们的各种组合来构建应用程序。</p><h1 id="eb8d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">生产解决方案</h1><p id="358e" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><strong class="ka ir"> ESLint </strong> <br/>如巴别模块解析器<a class="ae kw" href="https://github.com/tleunen/babel-plugin-module-resolver#editors-autocompletion" rel="noopener ugc nofollow" target="_blank">文档</a>所述。如果你正在使用ESLint，你应该使用<a class="ae kw" href="https://github.com/benmosher/eslint-plugin-import" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-import </a>和<a class="ae kw" href="https://github.com/tleunen/eslint-import-resolver-babel-module" rel="noopener ugc nofollow" target="_blank">ESLint-import-resolver-babel-module</a>来移除falsy未解析的模块。</p><p id="33d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> IDE支持</strong> <br/>如巴别塔模块解析器<a class="ae kw" href="https://github.com/tleunen/babel-plugin-module-resolver#editors-autocompletion" rel="noopener ugc nofollow" target="_blank">文档</a>所述，您可以使用以下方法</p><ul class=""><li id="90f0" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">Atom:使用<a class="ae kw" href="https://github.com/nkt/atom-autocomplete-modules" rel="noopener ugc nofollow" target="_blank"> atom自动完成模块</a>并启用<code class="fe mo mp mq mr b">babel-plugin-module-resolver</code>选项。</li><li id="18b4" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">IntelliJ/WebStorm:你可以添加自定义资源根目录，确保它与你在这个插件中拥有的相匹配。</li><li id="f9b1" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">VS代码:配置<code class="fe mo mp mq mr b">jsconfig.json</code><code class="fe mo mp mq mr b">tsconfig.json</code>中的<a class="ae kw" href="https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping" rel="noopener ugc nofollow" target="_blank">路径映射</a>，例如:</li></ul><pre class="mt mu mv mw gt nn mr no np aw nq bi"><span id="c539" class="nr lm iq mr b gy ns nt l nu nv">{<br/>  "compilerOptions": {<br/>    "baseUrl": ".",<br/>    "paths": {<br/>      "*": ["App/*", "App/brands/default/*"],<br/>    }<br/>  }<br/>}</span></pre><p id="06af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，jsconfig无法使其动态化，也无法根据环境变量处理其他品牌。</p><p id="f49c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了tsconfig，虽然没有对 a <code class="fe mo mp mq mr b">tsconfig.js</code>的<a class="ae kw" href="https://github.com/microsoft/TypeScript/issues/25271" rel="noopener ugc nofollow" target="_blank">官方支持，但是有一个</a><a class="ae kw" href="https://www.npmjs.com/package/tsconfig.js" rel="noopener ugc nofollow" target="_blank"> npm包</a>可以让你拥有适合这个用例的动态类型脚本配置，因为你可以在其中引用<code class="fe mo mp mq mr b">process.env.APP_BRAND</code>。</p><h1 id="8584" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="5bca" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在你知道如何利用<code class="fe mo mp mq mr b"><a class="ae kw" href="https://github.com/tleunen/babel-plugin-module-resolver" rel="noopener ugc nofollow" target="_blank">babel-plugin-module-resolver</a></code>来让一个白色标签的React原生应用程序从一个代码库构建多个不同品牌的产品。</p><p id="8bf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建的示例项目的源代码可以在<a class="ae kw" href="https://github.com/jar0s/reactNative-babel-wla" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>