# GraphQL 一年的好与坏

> 原文：<https://levelup.gitconnected.com/the-good-and-bad-of-1-year-of-graphql-2167ccd5f6a0>

![](img/bf603a930ac5504f43a9f5a6accf1c8e.png)

GraphQL，作者脸书

今天早上我收到一封来自谷歌域名的邮件，告诉我我的域名即将到期(我从来没有在域名上设置自动续费，我不知道我是否会保留，所以谢谢你的邮件，谷歌！).时光飞逝，我在那个项目上尝试了很多新事物，包括发布我的第一个开源包。

不过，现在，这里是对该项目的一个(大的)方面的反映:GraphQL，我决定使用的 API 语言。

# 一些背景

首先，一些背景:这是一个单人版本，只属于我一个人。这是一个学习项目，虽然(GraphQL，Pulumi，一堆云服务，如 Fargate，workers，frontend testing)它是一个功能丰富的聊天应用程序，具有管理权限，群组线程，web 支持，投票，反应，日历事件等。我从来没有发布过，所以这篇文章中绝对没有关于扩展或实际上面向最终用户的内容。

也就是说，这是一个相当大且功能丰富的应用程序，在大小和完整性上与我专业开发的实际应用程序(代码方面)相当，所以我不会说它是在比较某种“玩具”应用程序。

这里最后要注意的是，我使用了 Hasura，所以后端的许多工作在我需要考虑它之前就已经完成了。这意味着，我所说的许多免费或简单的东西确实需要一些开销，实际上是在后端构建的——这是我完全忽略的开销。我的建议是使用 Postgraphile 或 GraphQL 之类的东西，因为自己设置一个 graphQL 服务器有些痛苦。我对使用 Hasura 最大的恐惧是无法执行定制逻辑，但这对于 events & webhooks 来说不是问题。

# 好人

## 惊人的生产力

毫无疑问:我能够构建这么多东西的唯一原因是因为 GraphQL。REST 范式中的多步骤在 GraphQL 中是单步——而且是相当流畅的单步！总是有人谈论 GraphQL 安全性差的危险，但我发现 Hasura 的权限管理系统非常直观，查询白名单也很棒。

创建应用程序的整个新部分非常容易——创建表、定义关系、定义权限(我发现提前定义所有权限的方法是最实用的——即使您现在不需要用户查询另一个用户的名称，但将来可能需要，所以您应该在后台工作时设置权限)，然后就完成了！你可以回去做一个前端开发者。每当您需要从该表中读取数据时，请随意编写一个查询，并准确获得您需要的数据。如果您最终需要更多或更少的数据，修改该查询以获得您需要的数据是一项简单的任务。

在 REST 中，做简单的事情时，您需要担心很多事情——例如，继续前面给出的例子，如果我们还想将用户名添加到查询中，我们必须将它添加到后端的每个 d to 中，并确保我们每次都查询它。听起来没那么多，但这是个小变化。如果您需要一组全新的数据，该怎么办？如果您需要对路由进行许可，只允许管理员查询发送的消息数量，但允许每个人查询单个消息，该怎么办？一般来说，工程是许多小任务的总和，因此最小化所需的任务量是对生产力的巨大推动。

## 自由反应状态

在这个项目中，我做的一件事就是给组添加线程。当我使用应用程序时，有人告诉我他们从另一台机器上更改了一些内容，通常在我的机器上实际看到这些内容的解决方案是刷新页面或再次冷启动应用程序，它已经调用了 API，在下次没有数据之前，它不会再次调用。

这个问题的解决方案可能是“拉动刷新”类型的东西，或者允许用户以某种方式手动刷新。GraphQL 为您提供的解决方案是将查询中的单词`query`改为`subscription`，有效地让服务器告诉您何时发生了变化，而不是让客户端重新获取它。要在 REST 应用程序中做类似的事情，您需要在后端做一些重要的架构更改(假设您是一个典型的 Express / Spring REST 应用程序)。

而是 GraphQL 免费给你。

## 类型安全

下面，在缺点部分，我将讨论代码生成。一般来说，这是一个缺点，但是你从中获得的最大好处是类型安全。HTTP 客户端通常只返回一个 JSON 主体，您需要将它解析到您的对象中，有时这很麻烦。有了前端的 GraphQL 代码生成，我每次都能得到一个类型正确的对象，只是基于我编写的查询。这是代码生成最有用的特性之一，我不能说我会错过对每个 HTTP 请求做一次`fromJson`。

## 难以置信的描述性 API

游乐场太棒了。我自己构建了整个模式，并手工编写了每个权限，但这并不意味着没有黑暗的角落:如果不实际去手动检查，很容易忘记每个模型的哪个部分是公开的，GraphQL playgrounds 允许您很容易地去手动检查。我发现它甚至比 swagger 文档更有效，因为它是交互式的，而且“搜索时间”更少，需要阅读的内容也更少。如果我不确定一个查询是否有正确的权限，我就偷一个 API 令牌并通过执行来尝试！用 GraphQL 探索和学习 API 是很棒的。

## ●上下文切换

在这方面我已经谈了一点，但我认为 GraphQL 允许非常低的开发人员上下文切换。我个人相信，对工作效率影响最大的是上下文切换——这不是你花在手机上的 5 分钟，而是你需要回到流畅状态的 10 分钟。

GraphQL 使得避免上下文切换变得很容易，因为很少有理由必须进入后端或数据库层，除非您在设计或权限处理阶段严重出错。在前端编写查询足够直观，我认为这不算是上下文切换，当你得到一个良好的设置(适当的钩子或小部件来使用查询)时，我的应用程序的整个部分都非常快地完成了。

# 坏事

## 代码生成无处不在

静态类型语言中 GraphQL 的核心问题就在于此。您需要基于模式拉取来编码生成一切。每次模式提取都会生成大量的代码。需要生成请求、响应、每个片段……这需要生成大量代码！我宁愿让它生成，而不是必须手写，但感觉 GraphQL 就是在考虑 JS 的情况下设计的。我不禁觉得静态类型语言中的 GraphQL 是后来才想到的。

尽管没有其他选择，但对于如何处理 GraphQL 为您提供的巨大灵活性的问题，这是一个非常好的解决方案。我希望有一种方法可以绕过它，但是我不想放弃类型安全，这似乎是目前最好的解决方案。

## 实际上设置好了一切

我不确定 GraphQL 的 Flutter 生态系统是否只是缺少愿意为它创建包的人，或者这个问题在所有 graphQL 生态系统中都存在，但我感觉我用手做了很多东西，这些东西通常是在使用 HTTP 客户端时为我完成的。

编写我自己的挂钩/小部件，使用我自己的定制客户端，当令牌过期时自动刷新令牌并重新链接订阅，并将订阅路由到订阅处理程序…设置起来需要一周时间！不过，一旦设置好了，使用起来就非常好了。TODO 在这里:发布它作为一个包！这些类型的客户端和组件在每个项目中都有写——我应该可以节省很多开发人员的时间！

## 不支持某些用例

我认为这只是一个 Hasura 的事情，因为如果你正在构建自己的解析器，我认为你可以围绕这个进行设计，所以如果你正在评估没有 Hasura 的 GraphQL，也许可以跳过这一部分。

订阅是成批返回的:每次在服务器上发现对该查询的更改，它都会被推送到 web socket——但不是单独的更改，而是整个查询的结果。这意味着，如果您订阅了最后 5 条消息，则每次都会收到一条新消息和四条旧消息(您还必须订阅最后 5 条消息，而不是最新的消息，因为订阅是每 5 秒推送一次，这意味着如果在不到 5 秒的时间内有两条消息，它不会进入订阅)。您不能在 UI 中显示重复项，因此您需要一些逻辑来删除重复项，同时保持排序。

那是令人头痛的！这是应用程序代码的很大一部分，进入管理订阅的兔子洞不是一个好时机。最后，我将逻辑推送到前端控制器，在那里进行重复数据删除以及反应逻辑。

在一个自编码的基于 REST 的应用程序中，您可以准确地决定哪些数据应该用于什么用例。虽然大部分用例比 GraphQL 需要更多的工作，但在少数情况下，能够在后端手写每个控制器查询将会获得它的好处。

## 有点难考

这是代码生成的问题，但是我发现自己在测试查询时遇到了问题。因为每个响应/请求都是它自己的对象，所以设置它们的伪对象有点挑战性，并且会导致测试的大量“运行时”调试——我不知道应该从那个特定的对象中产生什么数据，所以我需要去后端并在许多不同的用例中找到查询的结果。

这并不是世界上最糟糕的事情，但它让我喜欢写测试，当需要测试不同的查询结果时，我想推掉这项活动。

# 摘要

总而言之，我会 100%再次使用 graphql。我不认为我会独自开发 GraphQL 后端，除非我有一些严肃的工程时间来工作，但每当我要从事一个新项目时，GraphQL 将是我的第一选择，除非有真正的理由不使用它。

这是我用过的最有效率的 API，如果你正在寻找一种方法来加速你的个人项目开发，我强烈推荐它。

*最初发布于*[*https://ants . place*](https://ants.place/blog/tech/The-Good-and-Bad-of-1-Year-of-GraphQL)*。*