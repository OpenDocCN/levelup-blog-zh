<html>
<head>
<title>Ultimate React Component Patterns with Typescript 2.8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Typescript 2.8最终反应组件模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ultimate-react-component-patterns-with-typescript-2-8-82990c516935?source=collection_archive---------0-----------------------#2018-02-28">https://levelup.gitconnected.com/ultimate-react-component-patterns-with-typescript-2-8-82990c516935?source=collection_archive---------0-----------------------#2018-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9491" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有状态、无状态、默认属性、渲染回调、组件注入、通用组件、高阶组件、受控组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c50a55b5e78a181ae16380c4341bad5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uMfESBdq9xC3lWrFprtdqw.png"/></div></div></figure><blockquote class="kr ks kt"><p id="3f8a" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">这篇博文的灵感来自</em> <a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/react-component-patterns-ab1f09be2c82"> <em class="iq"> React组件模式帖子</em> </a></p><p id="d2a8" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://codesandbox.io/s/7k236m64w6" rel="noopener ugc nofollow" target="_blank">现场演示</a></p></blockquote><p id="17ef" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">如果你了解我，你已经知道我不写没有类型的javascript，所以是的，我真的很喜欢Typescript，从版本0.9开始。除了类型化的JS之外，我真的很喜欢React，当React + Typescript结合在一起时，我感觉就像在天堂一样:d .整个应用程序和VDOM模板中的完整类型安全，使用它真是太棒了，太令人高兴了。</p><p id="2f58" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">那么这篇文章是关于什么的呢？嗯，互联网上有各种关于React组件模式的文章，但是没有一篇描述如何用Typescript应用这些模式。即将到来的TS 2.8版本也带来了令人兴奋的新特性，如条件类型、标准库中新的预定义条件类型、同态映射类型修饰符等等，这使我们能够以类型安全的方式轻松创建常见的反应模式</p><p id="6e18" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">这篇文章会很长，所以当你用Typescript掌握终极React组件模式的时候，请放松一下。</p><blockquote class="kr ks kt"><p id="abbb" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有模式/示例都使用typescript 2.8和严格模式</p></blockquote><h1 id="49f5" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">开始</h1><p id="f9a3" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">首先，我们需要安装typescript和tslib助手，这样我们发出的代码就更小了</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="4933" class="mx lw iq mt b gy my mz l na nb">yarn add -D typescript@next<br/># tslib will be leveraged only for features that are not natively supported by your compile target<br/>yarn add tslib</span></pre><p id="a0c4" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">这样我们就可以初始化我们的typescript配置:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="371b" class="mx lw iq mt b gy my mz l na nb"># this will create tsconfig.json within our project with sane compiler defaults<br/>yarn tsc --init</span></pre><p id="893a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在让我们安装react、react-dom和它们的类型定义。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="cdb9" class="mx lw iq mt b gy my mz l na nb">yarn add react react-dom<br/>yarn add -D @types/{react,react-dom}</span></pre><p id="101a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">太好了！现在让我们进入这些组件模式，好吗？</p><h1 id="d3c5" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">无状态组件</h1><p id="8a72" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">你猜对了，那些都是没有状态的组件(也叫表象)。大多数时候它们只是纯粹的函数。让我们用Typescript创建人造按钮无状态组件。</p><p id="3612" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">就像在普通JS中一样，我们需要导入React来允许我们使用JSX</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="f34c" class="mx lw iq mt b gy my mz l na nb">import React from 'react'</span><span id="443b" class="mx lw iq mt b gy nc mz l na nb">const Button = ({ onClick: handleClick, children }) =&gt; (<br/>  &lt;button onClick={handleClick}&gt;{children}&lt;/button&gt;<br/>)</span></pre><p id="8d47" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">虽然tsc编译器现在会发出错误！我们需要明确地告诉组件/功能我们的道具是什么类型。让我们定义一下我们的道具:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="aafe" class="mx lw iq mt b gy my mz l na nb">import React, { MouseEvent, ReactNode } from 'react'<br/>type Props = { <br/> onClick(e: MouseEvent&lt;HTMLElement&gt;): void<br/> children?: ReactNode <br/>}</span><span id="493b" class="mx lw iq mt b gy nc mz l na nb">const Button = ({ onClick: handleClick, children }: Props) =&gt; (<br/>  &lt;button onClick={handleClick}&gt;{children}&lt;/button&gt;<br/>)</span></pre><p id="6d9b" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们消除所有错误！太好了！但是我们可以做得更好！</p><p id="39b1" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">在<code class="fe nd ne nf mt b">@types/react</code> = &gt; <code class="fe nd ne nf mt b">type SFC&lt;P&gt;</code>中有一个预定义的类型，它只是<code class="fe nd ne nf mt b">interface StatelessComponent&lt;P&gt;</code>的别名，它有预定义的<code class="fe nd ne nf mt b">children</code>和其他东西(<em class="kw"> defaultProps </em>，<em class="kw"> displayName </em>...)，这样我们就不用每次都自己写了！</p><p id="7df5" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">因此，最终的无状态组件如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/356a2131c6fdbd45dd074f3ad9a82d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeLU7vB6ORtNWIlMnm5C0Q.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">无状态组件</figcaption></figure><h1 id="49eb" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">有状态组件</h1><p id="0ad8" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">让我们创建有状态计数器组件，它将利用我们的<code class="fe nd ne nf mt b">Button</code></p><p id="d417" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">首先我们需要定义<code class="fe nd ne nf mt b">initialState</code></p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="ec45" class="mx lw iq mt b gy my mz l na nb">const initialState = { clicksCount: 0 }</span></pre><p id="e7ff" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在我们将使用Typescript从我们的实现中推断状态类型。</p><blockquote class="kr ks kt"><p id="c850" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">通过这样做，我们不必分别维护类型和实现，我们只有真实的来源，也就是实现。不错！</em></p></blockquote><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="a8da" class="mx lw iq mt b gy my mz l na nb">type State = Readonly&lt;typeof initialState&gt;</span></pre><blockquote class="kr ks kt"><p id="e63e" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">还要注意，type被显式映射为所有属性都是只读的。我们需要再次明确定义，使用我们的状态类型来定义类的状态属性。</em></p></blockquote><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="7654" class="mx lw iq mt b gy my mz l na nb">readonly state: State = initialState</span></pre><blockquote class="kr ks kt"><p id="3a14" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">为什么这有用/需要？</em></p><p id="e898" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="iq">我们知道我们不能直接在React内更新</em> <code class="fe nd ne nf mt b"><em class="iq">state</em></code> <em class="iq">如下:</em></p></blockquote><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="a1df" class="mx lw iq mt b gy my mz l na nb"><em class="kw">this.state.clicksCount = 2 <br/>this.state = { clicksCount: 2 }</em></span></pre><blockquote class="kr ks kt"><p id="dc1c" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将抛出一个运行时错误，但不是在编译时。通过 <code class="fe nd ne nf mt b"><em class="iq">Readonly</em></code> <em class="iq">将我们的</em> <code class="fe nd ne nf mt b"><em class="iq">type State</em></code> <em class="iq">显式映射到</em><strong class="kx ir"/><em class="iq">readonly，并在我们的类组件内设置readonly状态，TS会让我们立刻知道我们做错了什么。</em></p></blockquote><p id="cdaa" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir">例如:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/e4f68895f8470e873dbab57cd7335a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iBI3PaFbcboXP1YQjaQXzw.gif"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">编译时状态类型安全</figcaption></figure><p id="8c67" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir">整体容器/有状态组件实现:</strong></p><p id="b946" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们的容器没有任何Props API，所以我们需要将<code class="fe nd ne nf mt b">Component</code>的第一个泛型参数键入为<code class="fe nd ne nf mt b">object</code>(因为<code class="fe nd ne nf mt b">props</code>在React中始终是一个对象<code class="fe nd ne nf mt b">{}</code>)并将<code class="fe nd ne nf mt b">State</code>类型用作第二个泛型参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/bd7fe4a4beba54fd91da1d5dc4b86b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTk6uX3X_7CKXELlrVe7FA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">有状态组件</figcaption></figure><blockquote class="kr ks kt"><p id="62bf" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可能已经注意到，我们已经将状态更新函数提取到类外的纯函数中。这是一种常见的模式，因为我们可以轻松地测试这些模式，而无需任何渲染器层的知识。还因为我们使用了typescript，并且我们将状态映射为显式只读，这也将阻止我们在那些函数中做任何改变</p></blockquote><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="d043" class="mx lw iq mt b gy my mz l na nb">const decrementClicksCount = (prevState: State) <br/>                      =&gt; ({ clicksCount: prevState.clicksCount-- })<br/><br/>// Will throw following complile error:<br/>//<br/>// [ts]<br/>// Cannot assign to 'clicksCount' because it is a constant or a read-only property.</span></pre><p id="36ab" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">酷吧？；)</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="2321" class="lv lw iq bd lx ly nu ma mb mc nv me mf jw nw jx mh jz nx ka mj kc ny kd ml mm bi translated">默认道具</h1><p id="fd07" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">让我们用string类型的颜色属性来扩展我们的按钮组件。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="0cf9" class="mx lw iq mt b gy my mz l na nb">type Props = { <br/>  onClick(e: MouseEvent&lt;HTMLElement&gt;): void<br/>  color: string <br/>}</span></pre><p id="b5d5" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">如果我们想定义defaultProps，我们可以通过组件上的<code class="fe nd ne nf mt b">Button.defaultProps = {...}</code>来实现。</p><p id="e910" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">通过这样做，我们需要改变我们的道具类型定义，将默认的道具标记为可选的。</p><p id="4db4" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">大概是这样的(注意<code class="fe nd ne nf mt b">?</code>操作符)</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="1e98" class="mx lw iq mt b gy my mz l na nb">type Props = { <br/>  onClick(e: MouseEvent&lt;HTMLElement&gt;): void<br/>  color?: string <br/>}</span></pre><p id="1a6d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们的组件看起来像这样:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="c88a" class="mx lw iq mt b gy my mz l na nb">const Button: SFC&lt;Props&gt; = ({ onClick: handleClick, color, children }) =&gt; (<br/>  &lt;button style={{ color }} onClick={handleClick}&gt;<br/>    {children}<br/>  &lt;/button&gt;<br/>)</span></pre><p id="7a80" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">虽然这对于这个简单的例子是可行的，但是有一个问题。因为我们处于严格模式，可选的属性是我们的<code class="fe nd ne nf mt b">color</code>的<code class="fe nd ne nf mt b">undefined | string</code>类型的联合。</p><p id="7ba2" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">假设我们想对这个特殊的属性做些什么，TS会抛出一个错误，因为它不知道它是由<code class="fe nd ne nf mt b">Component.defaultProps</code> React构造定义的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/8bb9f9fd7827dbc9467ea896811e1513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XWrvmId5Pw2EuUZwIP-CZQ.gif"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">默认道具问题</figcaption></figure><p id="8b70" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">为了满足TS编译器的要求，我们可以使用3种技术:</p><ul class=""><li id="1ae2" class="oa ob iq kx b ky kz lb lc ls oc lt od lu oe lq of og oh oi bi translated">使用<strong class="kx ir"> Bang操作符</strong>显式地告诉编译器这不会是我们渲染中的<code class="fe nd ne nf mt b">undefined</code>，尽管它是可选的，就像这样:<code class="fe nd ne nf mt b">&lt;button onClick={handleClick!}&gt;{children}&lt;/button&gt;</code></li><li id="714d" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq of og oh oi bi translated">使用<strong class="kx ir">条件语句/三元运算符</strong>让编译器理解某些特殊属性不是未定义的:<code class="fe nd ne nf mt b">&lt;button onClick={handleClick ? handleClick: undefined}&gt;{children}&lt;/button&gt;</code></li><li id="1262" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq of og oh oi bi translated">创建可重用的<code class="fe nd ne nf mt b"><strong class="kx ir">withDefaultProps</strong></code>高阶函数，它将更新我们的道具类型定义，并将设置我们的默认道具。这是最干净的解决方案，我的天</li></ul><p id="fef5" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们可以非常容易地实现我们的高阶函数(由于新的TS 2.8条件预定义映射类型):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/01116b830575dcdfbf51fa36c36f3c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qNwv2aE1KgpqErSOg-Z9wQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">withDefaultProps高阶函数通用助手</figcaption></figure><p id="76ee" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在我们可以用我们的<code class="fe nd ne nf mt b">withDefaultProps</code>高阶函数来定义我们的默认道具，这也将解决我们之前的问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/0507cb10a051e615d95ae540d5e247f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBABN7bLq0L1LS2qFH2fzQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">定义按钮组件的默认属性</figcaption></figure><p id="e21e" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">或者直接内联(注意，我们需要显式地提供原始按钮属性类型，因为TS不能从函数中推断参数类型):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/0754cafa1e250317e73d42a728c81822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOgjSZ0l-nKsj9POCj8uKg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">定义与组件实现内联的默认属性</figcaption></figure><blockquote class="or"><p id="1cd8" class="os ot iq bd ou ov ow ox oy oz pa lq dk translated">现在，按钮属性被正确地定义为消费，默认属性在我们的类型定义中被反映并标记为可选的，但在实现中仍然是必需的！</p></blockquote><pre class="pb pc pd pe pf ms mt mu mv aw mw bi"><span id="1033" class="mx lw iq mt b gy my mz l na nb">{<br/>  onClick(e: MouseEvent&lt;HTMLElement&gt;): void<br/>  color?: string<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/e569feb09505f51101435a3552b74255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5heXEL0LfIBtdbYR.png"/></div></div></figure><p id="5548" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">并且用法保持不变:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="c68d" class="mx lw iq mt b gy my mz l na nb">render(){<br/>  return (<br/>    &lt;ButtonWithDefaultProps <br/>      onClick={this.handleIncrement}<br/>    &gt;<br/>      Increment<br/>    &lt;/ButtonWithDefaultProps&gt;<br/>  )<br/>}</span></pre><p id="3fab" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">是的，这也适用于通过<code class="fe nd ne nf mt b">class</code>定义的组件(还要注意，由于ts中类的结构起源，我们不必明确指定我们的<code class="fe nd ne nf mt b">Prop</code>泛型类型)。</p><p id="47da" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/82287e4be998f4e9b6dec14d582493f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UBbwyDREqALFJhxj.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">用组件实现定义内联类的默认属性</figcaption></figure><p id="22a0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">用法也保持不变:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="ec73" class="mx lw iq mt b gy my mz l na nb">render(){<br/>  return (<br/>    &lt;ButtonViaClass<br/>      onClick={this.handleIncrement}<br/>    &gt;<br/>      Increment<br/>    &lt;/ButtonViaClass&gt;<br/>  )<br/>}</span></pre></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="3e87" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">假设您需要构建一个可扩展的菜单组件，当用户单击它时，它会显示一些子内容。我们将通过各种React组件模式实现这种行为。</p><h1 id="ca0f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">渲染回调/渲染道具模式</h1><p id="b449" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">使组件逻辑可重用的最好方法是将你的子组件变成一个函数或者利用<code class="fe nd ne nf mt b">render</code>prop API——这就是为什么渲染回调也被称为子组件函数。</p><p id="390a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">让我们实现一个具有渲染道具功能的<code class="fe nd ne nf mt b">Toggleable</code>组件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/d1feea00f75f747ab581715a7dd27337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pWSAZJbVVACal2DE.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">将RenderProps/Children作为函数模式的可切换组件</figcaption></figure><blockquote class="or"><p id="4eef" class="os ot iq bd ou ov ow ox oy oz pa lq dk translated">那里发生了很多抢劫，对吧？</p><p id="c96e" class="os ot iq bd ou ov pj pk pl pm pn lq dk translated">让我们更深入地了解一下实施的每个重要部分:</p></blockquote><pre class="pb pc pd pe pf ms mt mu mv aw mw bi"><span id="aa63" class="mx lw iq mt b gy my mz l na nb">const initialState = { show: false }<br/>type State = Readonly&lt;typeof initialState&gt;</span></pre><ul class=""><li id="1b12" class="oa ob iq kx b ky kz lb lc ls oc lt od lu oe lq of og oh oi bi translated">在这里，我们像前面的例子一样声明我们的状态，没有什么新的</li></ul><p id="c559" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在我们需要定义我们的组件属性(注意，我们使用的是部分映射类型，因为我们知道所有属性都是可选的，而不是由<code class="fe nd ne nf mt b">?</code>操作者手工注释每个属性):</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="f434" class="mx lw iq mt b gy my mz l na nb">type Props = Partial&lt;{<br/>  children: RenderCallback<br/>  render: RenderCallback<br/>}&gt;</span><span id="672b" class="mx lw iq mt b gy nc mz l na nb">type RenderCallback = (args: ToggleableComponentProps) =&gt; JSX.Element</span><span id="7b8b" class="mx lw iq mt b gy nc mz l na nb">type ToggleableComponentProps = { <br/>  show: State['show']<br/>  toggle: Toggleable['toggle'] <br/>}</span></pre><p id="8b0f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们希望支持两个函数，一个是子函数，另一个是渲染函数，所以这两个函数都是可选的。为了使事情<strong class="kx ir"> <em class="kw">变干</em> </strong>，我们正在创建<code class="fe nd ne nf mt b">RenderCallback</code>类型的我们的渲染函数定义:</p><p id="f176" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><code class="fe nd ne nf mt b">type RenderCallback = (args: ToggleableComponentProps) =&gt; JSX.Element</code></p><blockquote class="kr ks kt"><p id="843e" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于我们的读者来说，可能看起来很奇怪的是我们的最后一个类型别名<code class="fe nd ne nf mt b">type ToggleableComponentProps</code>！</p></blockquote><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="c107" class="mx lw iq mt b gy my mz l na nb">type ToggleableComponentProps = { <br/>  show: State['show']<br/>  toggle: Toggleable['toggle'] <br/>}</span></pre><p id="cdc1" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们再次使用了typescript和<strong class="kx ir"> <em class="kw">查找类型</em> </strong>的强大功能，因此我们在定义类型时不必重复:</p><ul class=""><li id="73f5" class="oa ob iq kx b ky kz lb lc ls oc lt od lu oe lq of og oh oi bi translated"><code class="fe nd ne nf mt b">show: State['show']</code>我们正在通过利用州内现有的类型定义来创建我们的<code class="fe nd ne nf mt b">show</code> prop类型</li><li id="bd72" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq of og oh oi bi translated">通过从我们的方法实现中获取类型，我们利用了TS中类的类型推断和结构特性！不错，确实强大！</li></ul><p id="841f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">剩下的实现很简单，标准的<em class="kw">渲染道具/孩子作为功能</em>模式:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="6bf3" class="mx lw iq mt b gy my mz l na nb">export class Toggleable extends Component&lt;Props, State&gt; {<br/>  // ...<br/>  render() {<br/>    const { children, render } = this.props<br/>    const renderProps = { show: this.state.show, toggle: this.toggle }</span><span id="c12a" class="mx lw iq mt b gy nc mz l na nb">    if (render) {<br/>      return render(renderProps)<br/>    }</span><span id="d65d" class="mx lw iq mt b gy nc mz l na nb">    return isFunction(children) ? children(renderProps) : null<br/>  }<br/>  // ...<br/>}</span></pre><p id="dc1e" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在，我们可以将一个函数作为子级传递给可切换组件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/0702b3b75f2f0fe255361945fb2fe188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BHzZRwRfd_nzkZL8.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">将子组件作为功能的可切换组件</figcaption></figure><p id="2bc0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">或者我们可以传递一个函数来渲染prop:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/bddc4af7b8f285bd7c4b321471dd23bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*20PisS2yDcqoa922.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">具有渲染属性的可切换组件</figcaption></figure><p id="9e6d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">多亏了Typescript，我们还可以随意使用intellisense，并对我们的render prop参数进行适当的类型检查:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/ca3c175c6b9e3744de9febf42c724096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/1*_uwjpiQ3lm8naPzsDpjxxg.gif"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">我们可更换组件的完全可靠性。谢谢打字稿！</figcaption></figure><p id="b320" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">如果我们想重用它(对于多个菜单之类的)，我们可以简单地创建一个使用可切换逻辑的新组件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/83910aeb64adced06676a18366a1176c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5289XeRzsDsgUMKx.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">用Toggleable创建的ToogleableMenu组件</figcaption></figure><p id="74e0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们全新的<strong class="kx ir"> <em class="kw">可切换菜单</em> </strong>组件已经可以在菜单组件中使用了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/29ea83e96eb7bc338085aa5ce25d1638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sSuNZ16Fvu-4Bi_T.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">菜单组件</figcaption></figure><p id="2e40" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">它如预期的那样工作:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/9ae9b4dddd467751e9f23330304cbdba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/1*TJr4pz0Tuz84EJdNm28kkQ.gif"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">带有ToggleableMenu组件的演示</figcaption></figure><blockquote class="or"><p id="a561" class="os ot iq bd ou ov ow ox oy oz pa lq dk translated">当我们想要改变呈现的内容本身而不考虑状态操作时，这种方法非常有用:正如您所看到的，我们已经将呈现逻辑移到了ToggleableMenu子函数中，但是将状态逻辑保留在了Toggleable组件中！</p></blockquote><h1 id="02c3" class="lv lw iq bd lx ly lz ma mb mc md me mf jw pu jx mh jz pv ka mj kc pw kd ml mm bi translated">成分注入</h1><p id="dc7a" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">为了使我们的组件更加灵活，我们可以引入组件注入模式。</p><p id="e614" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">什么是组件注入模式？如果您熟悉React-Router，那么您在通过以下方式定义路由定义时会使用这种模式:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="9334" class="mx lw iq mt b gy my mz l na nb">&lt;Route path="/foo" component={MyView} /&gt;</span></pre><p id="b291" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">因此，我们不是通过渲染/子道具传递函数，而是通过<code class="fe nd ne nf mt b">component</code>道具“注入”组件。为此，我们可以将内联呈现属性函数重构为一个可重用无状态组件:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="f39c" class="mx lw iq mt b gy my mz l na nb">import { ToggleableComponentProps } from './toggleable'</span><span id="ca1e" class="mx lw iq mt b gy nc mz l na nb">type MenuItemProps = { title: string }<br/>const MenuItem: SFC&lt;MenuItemProps &amp; ToggleableComponentProps&gt; = ({<br/>  title,<br/>  toggle,<br/>  show,<br/>  children,<br/>}) =&gt; (<br/>  &lt;&gt;<br/>    &lt;div onClick={toggle}&gt;<br/>      &lt;h1&gt;{title}&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>    {show ? children : null}<br/>  &lt;/&gt;<br/>)</span></pre><p id="9173" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">这样，我们可以用render prop重构我们的<code class="fe nd ne nf mt b">ToggleableMenu</code>,以:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="693d" class="mx lw iq mt b gy my mz l na nb">type Props = { title: string }<br/>const ToggleableMenu: SFC&lt;Props&gt; = ({ title, children }) =&gt; (<br/>  &lt;Toggleable<br/>    render={({ show, toggle }) =&gt; (<br/>      &lt;MenuItem show={show} toggle={toggle} title={title}&gt;<br/>        {children}<br/>      &lt;/MenuItem&gt;<br/>    )}<br/>  /&gt;<br/>)</span></pre><p id="84f0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">至此，让我们定义我们的新API — <code class="fe nd ne nf mt b">component</code> prop。</p><p id="0b6e" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们需要更新我们的道具API。</p><ul class=""><li id="70f7" class="oa ob iq kx b ky kz lb lc ls oc lt od lu oe lq of og oh oi bi translated"><code class="fe nd ne nf mt b">children</code>现在可以是function或ReactNode(当使用组件prop时)</li><li id="112e" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq of og oh oi bi translated"><code class="fe nd ne nf mt b">component</code>是我们的新API，它接受需要在其props上实现<code class="fe nd ne nf mt b">ToggleableComponentProps</code>的组件，它需要是通用的，并设置为<code class="fe nd ne nf mt b">any</code>，因此如果任意组件实现了除<code class="fe nd ne nf mt b">ToggleableComponentProps</code>之外的其他属性，将通过ts验证</li><li id="b7f0" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq of og oh oi bi translated">我们引入了道具属性来传递任意的道具，这是一种常见的模式。它被定义为任何类型的索引类型，所以我们在这里失去了严格的类型安全...</li></ul><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="b21b" class="mx lw iq mt b gy my mz l na nb">// We need create defaultProps with our arbitrary prop type -&gt; props which is gonna be empty object by default<br/>const defaultProps = { props: {} as { [name: string]: any } }<br/>type Props = Partial&lt;<br/>  {<br/>    children: RenderCallback | ReactNode<br/>    render: RenderCallback<br/>    component: ComponentType&lt;ToggleableComponentProps&lt;any&gt;&gt;<br/>  } &amp; DefaultProps<br/>&gt;<br/>type DefaultProps = typeof defaultProps</span></pre><p id="0808" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">接下来我们需要给我们的<code class="fe nd ne nf mt b">ToggleableComponentProps</code>添加新的道具API，这样消费者将被允许在<code class="fe nd ne nf mt b">&lt;Toggleable props={...}/&gt;</code>上使用<code class="fe nd ne nf mt b">props</code>道具:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="de54" class="mx lw iq mt b gy my mz l na nb">export type ToggleableComponentProps&lt;P extends object = object&gt; = {<br/>  show: State['show']<br/>  toggle: Toggleable['toggle']<br/>} &amp; P</span></pre><p id="9d81" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在我们需要更新我们的<code class="fe nd ne nf mt b">render</code>方法</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="733f" class="mx lw iq mt b gy my mz l na nb">render() {<br/>    const { <br/>     component: InjectedComponent, <br/>     children, <br/>     render, <br/>     props <br/>    } = this.props<br/>    const renderProps = { <br/>     show: this.state.show, toggle: this.toggle <br/>    }</span><span id="618a" class="mx lw iq mt b gy nc mz l na nb">    // when component prop api is used children is ReactNode not a function<br/>    if (InjectedComponent) {<br/>      return (<br/>        &lt;InjectedComponent {...props} {...renderProps}&gt;<br/>          {children}<br/>        &lt;/InjectedComponent&gt;<br/>      )<br/>    }</span><span id="3585" class="mx lw iq mt b gy nc mz l na nb">    if (render) {<br/>      return render(renderProps)<br/>    }</span><span id="00ca" class="mx lw iq mt b gy nc mz l na nb">    // children as a function comes last<br/>    return isFunction(children) ? children(renderProps) : null<br/>  }</span></pre><p id="c307" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir">整体实现带渲染道具的Toogleable组件，子组件作为功能，组件注入带任意道具支持:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/4d97208a7c665ca2e93aceb0aee705ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzZjTSgLGplmMKA2O70ctA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">整体实现带渲染道具的Toogleable组件，子组件作为一个功能，组件注入支持任意道具</figcaption></figure><p id="1890" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们最后的利用<code class="fe nd ne nf mt b">component</code>道具的<code class="fe nd ne nf mt b">ToggleableMenuViaComponentInjection</code>组件看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi py"><img src="../Images/4bb3186dbd60386e50923d6e29651e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YQfO__OwF-XEnkZo.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">具有组件注入模式的可切换菜单</figcaption></figure><p id="984d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir">但是请注意</strong>,我们在任意自定义的<code class="fe nd ne nf mt b">props</code>属性中没有类型安全，因为它被定义为索引对象映射<code class="fe nd ne nf mt b">{ [name: string]: any }</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pz"><img src="../Images/082ae44d37e15610f8e670fbb738c38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*v6YXSgdyXiPJhJkHClXoRA.gif"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">我们可以传递任何东西给我们的道具prop:(</figcaption></figure><p id="c498" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们现在可以像以前一样使用我们的<code class="fe nd ne nf mt b">ToggleableMenuViaComponentInjection</code>进行菜单渲染</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="ba04" class="mx lw iq mt b gy my mz l na nb">export class Menu extends Component {<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;ToggleableMenuViaComponentInjection title="First Menu"&gt;<br/>          Some content<br/>        &lt;/ToggleableMenuViaComponentInjection&gt;<br/>        &lt;ToggleableMenuViaComponentInjection title="Second Menu"&gt;<br/>          Another content<br/>        &lt;/ToggleableMenuViaComponentInjection&gt;<br/>        &lt;ToggleableMenuViaComponentInjection title="Third Menu"&gt;<br/>          More content<br/>        &lt;/ToggleableMenuViaComponentInjection&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span></pre><h1 id="5517" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">通用组件</h1><p id="aac1" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">当我们实现“组件注入模式”时，我们在通过<code class="fe nd ne nf mt b">props</code>处理的任意属性上失去了严格的类型安全。我们如何解决这个问题？你猜对了！我们可以把我们的<code class="fe nd ne nf mt b">Toggleable</code>组件写成一个通用组件！</p><p id="591e" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">首先，我们需要使我们的道具通用。我们使用默认的通用参数，所以当我们不想提供它的时候，我们不需要显式地提供它(作为一个函数渲染道具/孩子)。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="ee37" class="mx lw iq mt b gy my mz l na nb">type Props&lt;P extends object = object&gt; = Partial&lt;<br/>  {<br/>    children: RenderCallback | ReactNode<br/>    render: RenderCallback<br/>    component: ComponentType&lt;ToggleableComponentProps&lt;P&gt;&gt;<br/>  } &amp; DefaultProps&lt;P&gt;<br/>&gt;</span></pre><p id="2c39" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们还需要更新我们的<code class="fe nd ne nf mt b">ToggleableComponentProps</code>,使其通用化。哦，等等，已经是了；).所以这方面没有变化。</p><p id="bbe2" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">但是需要改变的是<code class="fe nd ne nf mt b">type DefaultProps</code>的定义，因为不可能从实现中获得泛型类型定义，我们需要将其重构为老式的类型定义- &gt;实现</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="a40b" class="mx lw iq mt b gy my mz l na nb">type DefaultProps&lt;P extends object = object&gt; = { props: P }<br/>const defaultProps: DefaultProps = { props: {} }</span></pre><blockquote class="or"><p id="803d" class="os ot iq bd ou ov ow ox oy oz pa lq dk translated">快好了！</p></blockquote><p id="78ec" class="pw-post-body-paragraph ku kv iq kx b ky qa jr la lb qb ju ld ls qc lg lh lt qd lk ll lu qe lo lp lq ij bi translated">现在让我们使组件类通用化。同样，我们使用默认属性，所以当不使用组件注入时，我们不必指定泛型参数！</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="766e" class="mx lw iq mt b gy my mz l na nb">export class Toggleable&lt;T = {}&gt; extends Component&lt;Props&lt;T&gt;, State&gt; {}</span></pre><p id="9dc4" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">就是这样！就这样？？？嗯，我们如何在我们的JSX中利用这个通用类型呢？</p><p id="9239" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">坏消息是，我们不能…</p><p id="3339" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们需要引入<code class="fe nd ne nf mt b">ofType</code>通用组件工厂模式</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="0265" class="mx lw iq mt b gy my mz l na nb">export class Toggleable&lt;T extends object = object&gt; extends Component&lt;Props&lt;T&gt;, State&gt; {<br/>  static ofType&lt;T extends object&gt;() {<br/>    return Toggleable as Constructor&lt;Toggleable&lt;T&gt;&gt;<br/>  }<br/>}</span></pre><p id="6bb0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir">整体实现带渲染道具的Toogleable组件，子组件作为功能，组件注入带通用道具支持:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qf"><img src="../Images/e6f675b95fcffff147a82a5ebdd65323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6coSnmn3RCef0Ku8.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">具有渲染道具的可缩放组件的整体实现、作为功能的子组件、具有通用道具支持的组件注入:</figcaption></figure><p id="73b5" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在有了<code class="fe nd ne nf mt b">static ofType</code>工厂方法，我们可以创建我们的正确类型的通用组件</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi py"><img src="../Images/ea130d6cc186a4dd9f362bdf45c25aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*83ESeiSupanZXvxA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">带有组件注入模式和泛型的可切换菜单</figcaption></figure><p id="1d62" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">一切都会像以前一样工作，这一次我们的<code class="fe nd ne nf mt b">props={}</code>道具有了适当的类型安全。击掌！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pz"><img src="../Images/c411c51a64472e1bcd1f02d143903449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cafUgvdK5GHafMKy3ZhWUQ.gif"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">类型安全任意道具道具感谢泛型！</figcaption></figure><h1 id="34af" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">高阶组件</h1><p id="cec3" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">因为我们已经创建了具有渲染回调功能的<code class="fe nd ne nf mt b">Toggleable</code>组件，所以实现HOC将会很容易。(这也是渲染回调模式的一大优势，我们可以利用它来实现特定的功能)</p><blockquote class="kr ks kt"><p id="8998" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们实现我们的特设:</p></blockquote><p id="0f42" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们需要创造:</p><ul class=""><li id="4739" class="oa ob iq kx b ky kz lb lc ls oc lt od lu oe lq of og oh oi bi translated">displayName(这样我们可以在devtools中很好地调试)</li><li id="fcef" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq of og oh oi bi translated">WrappedComponent(这样我们就可以访问原始组件——这对测试很有用)</li><li id="a216" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq of og oh oi bi translated">利用<code class="fe nd ne nf mt b">hoist-non-react-statics</code> npm包中的<code class="fe nd ne nf mt b">hoistNonReactStatics</code></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qg"><img src="../Images/4ffca29e08ad5e4ff37aac973fe65269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*346vqDWuQqT6eGZreqJKwQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">具有通过Togglable实现的Togglable</figcaption></figure><p id="aded" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在我们也可以通过HOC来创建我们的Toogleable菜单项了，并且有正确的道具类型安全！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qh"><img src="../Images/9037d105b7f7f233c33f4038428ce79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0efpbg1-DyV20QGd7Y-5Nw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">通过HoC实现的ToggleableMenu</figcaption></figure><blockquote class="or"><p id="94f0" class="os ot iq bd ou ov ow ox oy oz pa lq dk translated">所有的东西都可以工作，并且都被类型所覆盖！耶！</p></blockquote><figure class="pb pc pd pe pf kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qi"><img src="../Images/cb88e74975d65b1863853395dd3a77bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RroTHGvJKWnPcYHJuIdNDg.gif"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">用HoC创建的ToggleableMenu的正确类型注释</figcaption></figure></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="ebaa" class="lv lw iq bd lx ly nu ma mb mc nv me mf jw nw jx mh jz nx ka mj kc ny kd ml mm bi translated">受控组件</h1><p id="77f3" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">我们进入决赛了！假设我们想通过从父节点控制来使我们的<code class="fe nd ne nf mt b">Toggleable</code>高度可配置。这确实是非常强大的模式。我们开始吧。</p><p id="45ea" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我说的受控组件是什么意思？我想控制是否从<code class="fe nd ne nf mt b">Menu</code>组件中直接为我的所有<code class="fe nd ne nf mt b">ToggleableMenu</code>组件显示内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/71e377fb9e98675eb996f8b409caaaaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/1*mfvlSR11Yrcee7z_MS5teg.gif"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">我们的菜单组件可以通过props控制可切换菜单组件</figcaption></figure><p id="e092" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们需要更新ToggleableMenu组件的实现，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qk"><img src="../Images/e518933a2caa8ec2fd801e64bcd29c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMsvWBvN4zXNlz0GgHr1Pw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">通过各种模式实现我们的ToggleableMenu</figcaption></figure><p id="c955" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">现在有了这些更新，我们可以将状态添加到我们的<strong class="kx ir"> <em class="kw">菜单</em> </strong>中，并将其向下传播到<strong class="kx ir"> <em class="kw">可切换菜单</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ql"><img src="../Images/33fcadd933e859204795125ec6258745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOqWKwAbadVefyKxhStQbw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">有状态菜单组件</figcaption></figure><p id="518b" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi qm translated"><span class="l qn qo qp bm qq qr qs qt qu di"> L </span>让我们最后一次更新我们的<code class="fe nd ne nf mt b">Toggleable</code>,以获得终极动力和灵活性</p><p id="6d5f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">要制作可切换的受控组件，我们需要做以下工作:</p><ol class=""><li id="ff2b" class="oa ob iq kx b ky kz lb lc ls oc lt od lu oe lq qv og oh oi bi translated">将<code class="fe nd ne nf mt b">show</code>添加到我们的<code class="fe nd ne nf mt b">Props</code> API中</li><li id="dfe2" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq qv og oh oi bi translated">更新默认道具(因为表演是可选的)</li><li id="271f" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq qv og oh oi bi translated">更新要从Props.show设置的初始Component.state，因为现在设置我们的状态的真实来源可能来自父级的Props。</li><li id="7dfa" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq qv og oh oi bi translated">componentWillReceiveProps生命周期挂钩正确更新公共属性的状态</li></ol><p id="9983" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir"> 1 &amp; 2: </strong></p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="e6bb" class="mx lw iq mt b gy my mz l na nb">const initialState = { show: false }<br/>const defaultProps: DefaultProps = { ...initialState, props: {} }</span><span id="1df9" class="mx lw iq mt b gy nc mz l na nb">type State = Readonly&lt;typeof initialState&gt;<br/>type DefaultProps&lt;P extends object = object&gt; = { props: P } &amp; Pick&lt;State, 'show'&gt;</span></pre><p id="606f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir"> 3 &amp; 4: </strong></p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="90d9" class="mx lw iq mt b gy my mz l na nb">export class Toggleable&lt;T = {}&gt; extends Component&lt;Props&lt;T&gt;, State&gt; {<br/>  static readonly defaultProps: Props = defaultProps<br/>  // Bang operator used, I know I know ...<br/>  state: State = { show: this.props.show! }</span><span id="6711" class="mx lw iq mt b gy nc mz l na nb">  componentWillReceiveProps(nextProps: Props&lt;T&gt;) {<br/>    const currentProps = this.props</span><span id="d9f2" class="mx lw iq mt b gy nc mz l na nb">    if (nextProps.show !== currentProps.show) {<br/>      this.setState({ show: Boolean(nextProps.show) })<br/>    }<br/>  }<br/>}</span></pre><h2 id="18ba" class="mx lw iq bd lx qw qx dn mb qy qz dp mf ls ra rb mh lt rc rd mj lu re rf ml rg bi translated">支持所有模式的最终可切换组件(将道具/子组件渲染为功能/组件注入/通用类型/可控)</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rh"><img src="../Images/4b2abc1d51102105c6049e24ce6210f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xbX1ic8PsoDr77Nc6lCeA.png"/></div></div></figure><h2 id="885f" class="mx lw iq bd lx qw qx dn mb qy qz dp mf ls ra rb mh lt rc rd mj lu re rf ml rg bi translated">最终通过可切换的方式</h2><p id="3407" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">只是轻微更新-&gt;我们需要在我们的HoC中传播<code class="fe nd ne nf mt b">show</code>属性值，并更新我们的<code class="fe nd ne nf mt b">OwnProps</code> API</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/b6520c0dc1994fc1c473eced7d41acc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDBtZh8eAINT1kscZ-sjpA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">具有可控功能的可切换特设</figcaption></figure></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="d65f" class="lv lw iq bd lx ly nu ma mb mc nv me mf jw nw jx mh jz nx ka mj kc ny kd ml mm bi translated">摘要</h1><p id="f0c5" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">用React和Typescript实现正确的类型安全组件可能很棘手。随着Typescript 2.8中新功能的加入，我们几乎可以通过遵循通用的React组件模式来编写类型安全的组件。</p><p id="8f8b" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">在这篇超长的帖子里(抱歉！)多亏了Typescript，我们学会了如何以严格的类型安全方式实现具有各种模式的组件。</p><p id="835b" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">大多数powerfull模式实际上是Render Props，它允许我们实现其他常见的模式，如组件注入或HOC，而无需太多额外的改动。</p><p id="5890" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">这篇文章的所有演示都可以在<a class="ae lr" href="https://github.com/Hotell/blogposts/tree/master/2018-02/ultimate-react-component-patterns/src" rel="noopener ugc nofollow" target="_blank"> my Github repo </a>找到。</p><p id="58f5" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">同样重要的是要意识到，模板中的类型安全，就像本文中演示的，只有在使用VDOM/JSX的库中才有可能</p><ul class=""><li id="547e" class="oa ob iq kx b ky kz lb lc ls oc lt od lu oe lq of og oh oi bi translated">带语言服务的角模板提供了类型安全，但是在简单的构造上，如在ngFor中检查等，稳定性是失败的</li><li id="9aa9" class="oa ob iq kx b ky oj lb ok ls ol lt om lu on lq of og oh oi bi translated">Vue还没有为模板实现类似Angular的东西，所以他们的模板和数据绑定只是神奇的字符串(但这在未来可能会改变。虽然你可以使用VDOM作为模板，但是使用起来很麻烦，因为各种类型的道具定义(“snabdom承担责任……”)</li></ul><p id="3c24" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">像往常一样，如果你有任何问题，请在这里或在twitter上ping我(我的用户名<a class="ae lr" href="https://twitter.com/martin_hotell" rel="noopener ugc nofollow" target="_blank">@马丁_酒店</a>),除此之外，欢迎打字检查人员！干杯！</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt ri"><a href="https://gitconnected.com/learn/typescript" rel="noopener  ugc nofollow" target="_blank"><div class="rj ab fo"><div class="rk ab rl cl cj rm"><h2 class="bd ir gy z fp rn fr fs ro fu fw ip bi translated">学习TypeScript -最佳TypeScript教程(2019) | gitconnected</h2><div class="rp l"><h3 class="bd b gy z fp rn fr fs ro fu fw dk translated">前18名打字稿教程。课程由开发者提交并投票，使您能够找到最好的…</h3></div><div class="rq l"><p class="bd b dl z fp rn fr fs ro fu fw dk translated">gitconnected.com</p></div></div><div class="rr l"><div class="rs l rt ru rv rr rw kp ri"/></div></div></a></div><div class="rx ry gp gr rz ri"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="rj ab fo"><div class="rk ab rl cl cj rm"><h2 class="bd ir gy z fp rn fr fs ro fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="rp l"><h3 class="bd b gy z fp rn fr fs ro fu fw dk translated">前45名React教程。课程由开发人员提交并投票，使您能够找到最佳反应…</h3></div><div class="rq l"><p class="bd b dl z fp rn fr fs ro fu fw dk translated">gitconnected.com</p></div></div><div class="rr l"><div class="sa l rt ru rv rr rw kp ri"/></div></div></a></div></div></div>    
</body>
</html>