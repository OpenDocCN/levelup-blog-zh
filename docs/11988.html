<html>
<head>
<title>Creating a Psychedelic WebAssembly Chrome Extension</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建迷幻的WebAssembly Chrome扩展</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-psychedelic-webassembly-chrome-extension-9c3a5d806e4a?source=collection_archive---------2-----------------------#2022-05-05">https://levelup.gitconnected.com/creating-a-psychedelic-webassembly-chrome-extension-9c3a5d806e4a?source=collection_archive---------2-----------------------#2022-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5450" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将网站上的所有图片变成色彩万花筒</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cb412b614e59da5203d39dc851f49413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_m0pW0Tos_VkwJ9eiW9-g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">CNN体育版的图像处理</figcaption></figure><h2 id="cbaa" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">它的作用</h2><p id="0c08" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我创建了一个chrome扩展，它将:</p><ol class=""><li id="f2a3" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">扫描网站上的所有图像</li><li id="0280" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">用iframes替换那些图像</li><li id="37a3" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">为用C编写的每个iframe加载一个WebAssembly (Wasm)模块</li><li id="753f" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">将原始网站的图像加载到模块的内存中进行操作，并写回到HTML canvas元素中</li></ol><p id="4694" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><strong class="lt ir">为什么？这让我们能够随心所欲地操纵网站上的每一张图片。</strong></p><p id="f323" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">有了这个，我需要决定我想做什么样的操作。我知道我想创造一些奇怪的和视觉上吸引人的东西，但心里没有确切的方向。</p><p id="dee4" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">玩了一会儿后，我想出了<strong class="lt ir"> tripster </strong>回到伍德斯托克的迷幻之旅。😃</p><p id="5516" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">理解这一点的最好方法是通过演示，首先让我们看看扩展如何改变google主页。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a939" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><em class="nf">这是我的最爱之一。我没想到谷歌标题会这样，因为我只是玩了玩算法，然后重新加载看看我得到了什么结果。</em></p><p id="9ccd" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">在这个结果之后，我决定看看它是如何改变BBC主页的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="face" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">得到这个结果后，我知道我得到了我想要的效果。 <strong class="lt ir"> <em class="nf">一个神魂颠倒的图像操纵者！😈</em>T11】</strong></p><p id="f2b9" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">如果您想亲自体验一下，可以访问以下网址找到web扩展:</p><div class="ng nh gp gr ni nj"><a href="https://chrome.google.com/webstore/detail/tripster/joonbncncgdeedndimiojcilgecadckc" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">Tripster</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">这是一个操作网站图片的chrome扩展。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">chrome.google.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kp nj"/></div></div></a></div><h2 id="3c1a" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我为什么建造它</h2><p id="0447" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated"><em class="nf">这首先是一个概念证明(POC)。这只是对我自己的一个学习练习，将来可能对其他人有用。我不会将它用于生产中任何重要的东西。</em></p><p id="211c" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">我想学习的两个主要话题是</p><ol class=""><li id="5093" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">Wasm</li><li id="5b89" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">Chrome扩展</li></ol><p id="1af3" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">我读过很多关于Wasm的东西，但从来没有机会使用它。</p><p id="643e" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">我喜欢Wasm的一点是，你可以用不同的语言为其他平台编写包，并在浏览器中使用它们。这迎合了我懒惰的一面。我喜欢的另一个方面是，由于它的性能增强，它扩展了您在浏览器中可以做的事情。</p><p id="1c1b" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><em class="nf">关于Wasm的性能，需要注意的一点是，即使性能提升往往会成为卖点，但您并不总能获得提升。这真的取决于你写的底层代码和它的作用。</em></p><p id="0905" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">图像处理的想法部分源于我用HTML画布做的另一个项目。chrome扩展部分排在最后，因为这是我创建类似东西的唯一方法，但也很有趣，因为我以前从未创建过。</p><h2 id="ecf9" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">它是如何工作的</h2><p id="f52a" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">该扩展正在使用版本3清单，因为您无法再创建新的版本2扩展。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny ne l"/></div></figure><p id="0142" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">不能使用版本2意味着iframe需要在沙箱中，因为这是唯一可以设置正确内容安全策略的地方:</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="64c4" class="kv kw iq oa b gy oe of l og oh">sandbox allow-scripts script-src 'self' 'unsafe-eval'; img-src data:</span></pre><p id="f490" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这是必需的，这样您就可以加载图像数据blob并运行Wasm模块。如果没有<strong class="lt ir">不安全评估</strong>，Wasm模块将失效，如这里提到的<a class="ae oi" href="https://github.com/WebAssembly/content-security-policy/issues/7" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="de96" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><em class="nf">你可以使用wasm-unsafe-eval。然而，一旦我得到了它的工作，我不敢改变它，因为这是一个噩梦得到这个权利，它是在沙盒中运行，所以不能造成任何伤害。</em></p><p id="ba90" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">您可以看到，在每个页面加载中，内容脚本将执行以下操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny ne l"/></div></figure><p id="375e" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">您可以看到，我们对每种旅行类型<strong class="lt ir">、</strong>做了几乎相同的事情，唯一的区别是我们将不同的类型设置为全局变量，供其他函数使用。</p><p id="77ce" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">触发此事件的事件来自服务人员。这个事件在这里被触发，因为我们希望所有的选项卡都有一个全局类型。所以当我们改变一个选项时</p><ol class=""><li id="8381" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">获取弹出JavaScript (JS)以将类型保存到本地存储</li><li id="9f31" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">在本地存储更改的服务工作器中触发事件处理程序，以将其发送到每个浏览器选项卡</li><li id="ad47" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">触发设置类型的所有浏览器选项卡事件</li></ol><p id="b03f" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><strong class="lt ir">如果你感兴趣，这方面的代码都在完整的回购协议中，这里没有显示。</strong></p><p id="2610" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><em class="nf">上面的代码显然可以重构，因为唯一的区别是NONE开关。此外，我们在第一次加载时运行scroll，这样我们马上就能得到效果。如果我们确保服务人员在内容脚本加载后触发一个事件，就不需要这样做。因为这是一个概念验证，所以我没有打扰。</em></p><p id="e1e7" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">上面使用的实现函数如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny ne l"/></div></figure><p id="f280" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">现在我们有了一个<a class="ae oi" href="https://www.freecodecamp.org/news/javascript-debounce-example/" rel="noopener ugc nofollow" target="_blank">去抖</a>滚动事件的类型和处理程序，我们需要理解滚动函数是做什么的。这里有许多可移动的部分，所以让我们按时间顺序来看一下:</p><ol class=""><li id="c52b" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">收集所有可见图像</li><li id="f9c5" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">为每个图像创建一个iframe，根据要替换的图像传递类型和唯一的ID</li><li id="0a31" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">使用<strong class="lt ir"> getComputedStyle </strong>函数将iframe放在与图像完全相同的位置</li><li id="2870" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">为每个图像创建一个base64编码的数据blob，并在完全加载后将该数据发送到iframe</li></ol><p id="ec72" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">为了达到同样的效果，我们尝试了一些其他的设置，但是由于一些原因失败了:</p><ul class=""><li id="2ced" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj oj ms mt mu bi translated">由于清单版本3的限制，您无法在内容脚本中运行Wasm它一定在沙盒里</li><li id="1656" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj oj ms mt mu bi translated">您也不能将这些数据发送到URL中的iframe，因为URL的大小有限。</li></ul><p id="415a" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">因此，您必须将这些数据作为发布的消息发送给iframe，因为iframe没有数据传输限制。该数据需要在iframe加载了<strong class="lt ir">之后发送，而不是在</strong>之前。因此，我们需要iframe发送一个包含唯一ID的“hello”事件。这个ID是必需的，因为内容页面不知道什么iframe准备好了，需要知道发送什么图像。</p><p id="3bb5" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">您可以在上面看到，我们正在为ID为的iframe“hello”消息创建多个处理程序。每个函数将只响应正确的iframe，因为它通过if语句中的闭包检查iframe的ID:</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="eed1" class="kv kw iq oa b gy oe of l og oh">if ( e.data === iframe.id.substring(0,1000) &amp;&amp; e.origin === "null") {</span></pre><p id="cd7f" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">当你做一些研究时，有另一个推荐的方法来检查这一点:</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="506c" class="kv kw iq oa b gy oe of l og oh">if ( e.data === "loaded" &amp;&amp; e.origin === "null" &amp;&amp; e.source === iframe.contentWindow) {</span></pre><p id="e137" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这在原理上应该是可行的，因为它检查了<strong class="lt ir"> e.source </strong>和<strong class="lt ir"> iframe.contentWindow </strong>是同一个底层对象。然而，这在开发中有效，但在部署的扩展中无效！因此，我使用上面的ID方法。</p><p id="f732" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">此时，我们已经将iframe放在了正确的位置，并将图像数据放在了沙箱中。现在我们需要iframe来接管。下面你可以看到运行在iframe中的JS。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny ne l"/></div></figure><p id="9ffd" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">假设我们已经成功地将图像blob放到了iframe沙箱中，我们来分解一下:</p><ol class=""><li id="42e4" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">blob被加载到一个HTML图像标签中，然后我们可以将它加载到一个HTML画布中</li><li id="0004" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">然后画布数据被加载到Wasm内存中，这样我们就可以在C函数中访问它</li><li id="9335" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">然后，当C函数改变底层像素时，我们在一个循环中渲染画布</li></ol><p id="a9b7" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">我们正在使用的C函数如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny ne l"/></div></figure><p id="bf6e" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><strong class="lt ir">完整披露，以上代码摘自</strong> <a class="ae oi" href="https://compile.fi/canvas-filled-three-ways-js-webassembly-and-webgl/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt ir">本例</strong> </a> <strong class="lt ir">。我无法感谢他们，因为我在这一点上失去了！我所做的只是稍微修改了一下自己函数的代码，以获得我需要的效果。</strong></p><p id="08c8" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">上面你可以看到我们在堆栈中创建了一个巨大的数组，然后我们将它作为指针返回给运行在iframe中的JS。</p><p id="0987" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><em class="nf">这种方法不应该这样做。我们应该已经在堆中为要放置的图像创建了内存。</em></p><p id="5d52" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">现在我们有了我们需要的JS和C代码</p><ol class=""><li id="c4bd" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">用我们的C代码创建编译好的Wasm模块</li><li id="7d70" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">创建JS样板文件，它将把我们的模块加载到浏览器中</li></ol><p id="1f6b" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这可以通过使用<a class="ae oi" href="https://emscripten.org/" rel="noopener ugc nofollow" target="_blank"> Emscripten </a>来完成，在主页上描述为:</p><blockquote class="ok ol om"><p id="5cdb" class="lr ls nf lt b lu mm jr lw lx mn ju lz on na mb mc oo nb me mf op nc mh mi mj ij bi translated">Emscripten是一个完整的WebAssembly编译器工具链，使用LLVM，特别关注速度、大小和Web平台。</p></blockquote><p id="af2b" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">基本上，这就像使用带有一些工具的标准GCC编译器一样。下面你可以看到这一点。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="6df3" class="kv kw iq oa b gy oe of l og oh">emcc --post-js src/post.js -o static/iframe.js src/image/main.c -s WASM=1 -s EXPORTED_FUNCTIONS='["_render", "_init", "_psyrender"]' -s EXPORTED_RUNTIME_METHODS='["cwrap"]' -s ALLOW_MEMORY_GROWTH</span></pre><p id="d9ea" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">该命令将获取上面的JS，然后将其放在样板JS的底部，样板JS将加载Wasm模块。它还导出内置的Emscripten函数，如<strong class="lt ir"> cwrap </strong>，我们用它来调用JS中的C函数。这将输出一个JS文件和一个Wasm文件，您可以像往常一样将它们加载到网页中。</p><p id="e452" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><em class="nf">上面的命令没有经过任何优化，因为这只是一个概念验证。所有可用标志的描述都非常好，如果你使用这个工具，我推荐你看一看。</em></p><p id="79ba" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这样我们就有了想要部署到chrome网络商店的扩展。</p><h2 id="056d" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">部署Chrome扩展</h2><p id="96e8" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">部署chrome扩展相对容易。运行上面的命令创建Wasm文件后，您可以运行</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="bf7a" class="kv kw iq oa b gy oe of l og oh">npm run build<br/>cd dist<br/> zip -r ../extension.zip *</span></pre><p id="ec46" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">npm命令使用webpack将文件打包成一个发行版，我们可以压缩并上传到chrome网络商店。</p><p id="d9b0" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><em class="nf">我把生产版本留为开发版本，因为chrome网上商店要求你不要最小化代码，这样他们就可以审查了。我没有包括C源代码，只有Wasm输出。我预计这可能是一个问题，但令人惊讶的是它通过了审查过程；所以结局好就一切都好😃。</em></p><p id="6f28" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">我用zip创建了一个开发者账户，并按照他们的要求发了一封新邮件，并支付了我5美元。然后我上传了压缩文件和图片，你可以在扩展主页上看到。</p><p id="3044" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">此外，我必须解释为什么我需要在清单中请求的扩展权限。这很简单，因为我需要访问所有网页以使其正常运行，我还需要访问存储器以保存用户选择的最新类型选项。</p><p id="45e6" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这是容易的部分。噩梦的一部分是几天后我的扩展被审查，然后我把它安装在我的浏览器上…<strong class="lt ir">没有效果！</strong></p><p id="6b34" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这个问题是我自己的错，因为我有一个竞争条件，图像数据blob是在模块加载后发送的，所以事件处理程序没有被触发。这完全可以理解。</p><p id="41bd" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">我不明白的是，是什么造成了开发扩展和部署扩展的差异。这非常令人沮丧，因为我必须推测它可能是什么，部署，然后测试，如果需要的话再重复一次。这花了大约一周的时间，因为每次审查需要几天时间。</p><p id="6fb3" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">最后，如你所见，它适用于0.0.3版本。</p><h2 id="419a" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h2><p id="1a03" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">前面提到的这个示例只是一个概念验证，如果您有兴趣，可以在这里找到:</p><div class="ng nh gp gr ni nj"><a href="https://github.com/mortonprod/tripster" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">GitHub - mortonprod/tripster:一个概念验证，使用WebAssembly在</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">在chrome扩展中使用WebAssembly操作网站图像的概念验证</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="oq l nu nv nw ns nx kp nj"/></div></div></a></div><p id="ce80" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">然而，我确实觉得它对其他人有用，因为我一直在努力寻找使用Wasm的平易近人的例子。您可以找到一些例子，但是很多例子有时太基础了，不足以解释像内存管理这样的事情是如何工作的。特别是像图像处理这样复杂的事情，JS和WASM模块之间是如何共享内存的。这甚至没有触及如何让WASM在不同的chrome扩展版本中工作的信息的缺乏。这是完全可以理解的，因为Wasm没有被广泛使用。</p><p id="6b9b" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这并不是说我会在这里详细介绍。像我这样的新手不会这么大胆😄。我只是希望足够多的人埋头苦干，将产生越来越多的例子，使这个过程更容易。</p><p id="9903" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">展望未来，我想看看除了制作奇怪但漂亮的图像之外，我还能用这个装置做些什么。</p></div></div>    
</body>
</html>