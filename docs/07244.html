<html>
<head>
<title>PostgreSQL Views With Ruby on Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Ruby on Rails的PostgreSQL视图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/postgresql-views-with-ruby-on-rails-78260cd6f021?source=collection_archive---------3-----------------------#2021-02-03">https://levelup.gitconnected.com/postgresql-views-with-ruby-on-rails-78260cd6f021?source=collection_archive---------3-----------------------#2021-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d714" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用视图的力量封装复杂的查询。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f325445b36671abb372052c8821c3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5WsGmfRguS28Vidn5Qh2w.png"/></div></div></figure><p id="f0d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Postgres提供了两种类型的视图，普通视图和物化视图。两者都可以解决与封装、抽象和提高性能相关的类似问题。</p><p id="e21b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得一提的是，视图和物化视图不仅仅在使用Postgres作为数据库时可用，几乎所有的关系数据库都支持使用视图和物化视图。</p><p id="383a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们先定义一下Postgres中的视图是什么。</p><h1 id="f94f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">视图</h1><p id="794e" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">视图是一组SQL查询，可以被视为一个表。您可以使用一个模型调用它，该模型将依次执行视图中定义的SQL，并返回数据。</p><p id="b69c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是视图的简单定义，它就是SQL。但是，使用视图有什么好处呢？。</p><p id="e3ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它有助于封装和抽象复杂的SQL查询，这些查询可以存在于模型或服务对象中。它还简化了更改SQL查询的过程，因为只有一个地方可以执行一些更改。</p><p id="2778" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象一下，如果您在应用程序的许多地方使用相同的SQL查询，无论何时您需要重写查询并进行更改，您都必须找到您使用它的所有地方。那不太合适。</p><h2 id="d2e7" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">使用视图的优势</h2><ol class=""><li id="92f3" class="mz na it kw b kx mi la mj ld nb lh nc ll nd lp ne nf ng nh bi translated">封装复杂的查询。</li><li id="43ee" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">抽象联接、group by、where、order by和任何其他SQL语句。</li><li id="000d" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">在应用程序中重用复杂的查询。</li><li id="b7d9" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">消除模型或服务对象中的SQL查询。</li><li id="80c4" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">让你的代码更整洁。</li></ol><p id="8edf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我提到的，视图是我们可以使用模型访问的表格。但是，我们只能查询视图，而不能执行创建、更新或删除操作，因为它不是一个真正的表，它只是一组每当我们访问模型时运行的SQL。</p><p id="c794" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，使用视图的定义和优点已经很清楚了，让我们创建一个rails应用程序。</p><h1 id="3629" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">项目描述</h1><p id="bf1f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">对于这个项目，我们将使用一个视图来封装一个复杂的SQL查询。这个查询将检索一个电视节目的评论。我将使用一个名为<a class="ae nn" href="https://github.com/scenic-views/scenic" rel="noopener ugc nofollow" target="_blank"> scenic </a>的宝石来创建视图。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2002" class="mn lr it np b gy nt nu l nv nw">rails new tv_shows --api -d=postgresql -T</span></pre><p id="9f5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建数据库。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="3f81" class="mn lr it np b gy nt nu l nv nw">rails db:create</span></pre><p id="dc2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们生成模型。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1090" class="mn lr it np b gy nt nu l nv nw">rails g model TvShow name show_type<br/>rails g model Group name contact email<br/>rails g model Team name color description status:integer group:references<br/>rails g model User name email status:integer team:references<br/>rails g model ReviewType name code<br/>rails g model Review description title scheduled_date:datetime votes:integer revenue:integer status:integer user:references review_type:references tv_show:references</span></pre><p id="76e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于应用程序允许用户选择属于某个团队，团队选择属于某个组，而审阅选择属于某个审阅类型或用户。对于每次迁移，请确保将这些外键上的<strong class="kw iu"> null: false </strong>标志更改为true。</p><p id="dea8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里查看<a class="ae nn" href="https://github.com/YairFernando67/tv_shows/tree/master/db/migrate" rel="noopener ugc nofollow" target="_blank">的迁徙。</a></p><p id="7dca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们迁移数据库。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="085e" class="mn lr it np b gy nt nu l nv nw">rails db:migrate</span></pre><p id="c8a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模型间关联的定义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d19b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将使用一个种子文件向数据库中插入一些数据。从repo 中复制<a class="ae nn" href="https://github.com/YairFernando67/tv_shows/blob/master/db/seeds.rb" rel="noopener ugc nofollow" target="_blank"> seed.rb文件的内容，并将其粘贴到您的种子文件中。</a></p><p id="cfe6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们播种DB之前，将faker添加到开发、测试组的Gemfile中。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b03e" class="mn lr it np b gy nt nu l nv nw">gem "faker"</span></pre><p id="2ab5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装gem，然后播种DB。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="025d" class="mn lr it np b gy nt nu l nv nw">bundle install<br/>rails db:seed</span></pre><p id="b2eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将创建一个端点来获取电视节目的评论。为此，让我们创建一个控制器。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9b9f" class="mn lr it np b gy nt nu l nv nw">rails g controller Reviews index</span></pre><p id="3b61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在routes.rb文件中，更改这个文件的路由。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f05f" class="mn lr it np b gy nt nu l nv nw">get 'tv_shows/:id/reviews', action: :index, controller: :reviews</span></pre><p id="f2a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在控制器中放入以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2c40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我使用一个服务对象来构建评论，这样控制器只负责呈现评论，繁重的工作委托给服务对象。</p><p id="cf34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在app文件夹下，创建一个services文件夹，并在其中创建一个新文件reviews_service.rb</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4934" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个服务对象有一个接收参数并初始化类的类方法。这只是抽象初始化步骤的一种方式。然后服务调用get_reviews方法。</p><p id="5936" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事情从这里开始变得更加复杂。这个方法有一个又长又复杂的SQL查询。最重要的是，它真的很难阅读，这使得服务看起来很丑。</p><p id="47d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">暂时不要担心！。我们很快会修理它。</p><p id="84fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们启动服务器，点击端点，我们应该能够看到评论。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d10f" class="mn lr it np b gy nt nu l nv nw">rails s</span><span id="6ba1" class="mn lr it np b gy nz nu l nv nw"><a class="ae nn" href="http://localhost:3000/tv_shows/100/reviews" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/tv_shows/1/reviews</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/09ca1a89df0bed89943e24ee97e807b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-7VMVWKPNc7IMxVBFrszQ.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">复习</figcaption></figure><p id="7fb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们用一个视图来解决这个丑陋的问题。</p><p id="bb88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在宝石文件里面，添加风景宝石。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="669c" class="mn lr it np b gy nt nu l nv nw">gem 'scenic', '~&gt; 1.5', '&gt;= 1.5.4'</span></pre><p id="1e74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装宝石</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="6ebe" class="mn lr it np b gy nt nu l nv nw">bundle install</span></pre><p id="c814" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生成一个新视图，我称之为latest_reviews。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="41aa" class="mn lr it np b gy nt nu l nv nw">rails generate scenic:view latest_reviews</span></pre><p id="4ae5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将创建两个文件。</p><ol class=""><li id="ebb2" class="mz na it kw b kx ky la lb ld of lh og ll oh lp ne nf ng nh bi translated"><strong class="kw iu">db/views/latest _ reviews _ v01 . SQL</strong></li><li id="36dc" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><strong class="kw iu">db/migrate/timestamp _ create _ latest _ reviews . Rb</strong></li></ol><p id="44dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">迁移文件包含在Postgres中创建视图的代码。我们不会修改这个文件。</p><p id="7f2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">SQL文件是我们编写每次调用这个视图时要运行的查询的地方。</p><p id="1884" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们要做的是，把复杂的SQL查询转换成纯SQL。最终的查询如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d4b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以迁移视图了。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="cec5" class="mn lr it np b gy nt nu l nv nw">rails db:migrate</span></pre><p id="5a1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我提到的，要与这个视图交互，我们需要一个模型，所以让我们创建一个。在models文件夹中创建一个新文件。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="667a" class="mn lr it np b gy nt nu l nv nw">touch latest_review.rb</span></pre><p id="2c70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模型是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a1e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于这个模型有两点需要考虑。首先，这个模型是只读的，这意味着我们不能执行任何CRUD操作，其次，我们可以选择性地定义一个主键，在这个例子中，我将主键定义为审查的id，但是我们可以分配任何我们想要的字段，只要它是唯一的值。</p><p id="886c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所看到的，我也定义了一个属于关联，因为最近的评论应该属于一个电视节目。</p><p id="75c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，在tv_show模型中，我们也需要添加这种关联。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="6a0b" class="mn lr it np b gy nt nu l nv nw">has_many :latest_reviews</span></pre><p id="02ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在服务对象中，我们现在可以替换SQL查询，而只调用电视节目对象上的latest_reviews关联。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="ec94" class="mn lr it np b gy nt nu l nv nw">tv_show.latest_reviews</span></pre><p id="a4b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">经过这一更改，服务对象看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7fd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是PostgreSQL中视图的强大之处。我们已经从服务对象中抽象出丑陋而复杂的SQL查询，而且现在我们可以在任何地方重用这个查询，因为它是一个关联。</p><p id="1b19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这允许我们有一个更易维护的代码，因为如果我们想要修改这个查询，只有一个地方可以去，另外它还可以使我们的模型和服务对象避免长时间的SQL查询。</p><p id="04f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了！如果我们重启rails服务器并再次点击端点，我们应该会看到和之前一样的结果。</p><p id="4262" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里找到这个<a class="ae nn" href="https://github.com/YairFernando67/tv_shows" rel="noopener ugc nofollow" target="_blank">项目的代码。</a></p><h1 id="ffb6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="d985" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在封装和抽象复杂的SQL操作时，视图确实非常强大，它还增加了应用程序的可重用性。我强烈建议在您的应用程序充满复杂的SQL时使用视图，这些SQL既不属于模型，也不属于应用程序级别的任何其他层。</p><p id="c6f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有一种视图具有超能力，那就是物化视图。如果您想了解物化视图如何进一步提高性能，请查看本文，<a class="ae nn" href="https://medium.com/swlh/materialized-views-and-sidekiq-jobs-with-rails-f83b1e950f20" rel="noopener"> <strong class="kw iu">物化视图和使用Rails的Sidekiq作业</strong>。</a></p><p id="77b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你在应用程序中使用视图时感觉更舒服，谢谢你的阅读！</p></div></div>    
</body>
</html>