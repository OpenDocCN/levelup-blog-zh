<html>
<head>
<title>Creating a Slideshow with the HTML5 Canvas Element</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用HTML5画布元素创建幻灯片</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-slideshow-with-the-html5-canvas-element-d956c348d9c1?source=collection_archive---------8-----------------------#2022-12-02">https://levelup.gitconnected.com/creating-a-slideshow-with-the-html5-canvas-element-d956c348d9c1?source=collection_archive---------8-----------------------#2022-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="12fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用vanilla JS和canvas元素支持自动和手动滚动图像</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/45438c18e63401b895bddce6ebc9f199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HVKBiIG1QO-GwT1ZYmuclg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><p id="b7df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Web开发人员通常需要创建幻灯片，循环显示一组图像，并依次显示每张图像。本教程提供了一个使用HTML5画布创建这样一个幻灯片的示例，包括如何设置图像的自动循环，以及如何使用户能够使用键盘或鼠标在图像中导航。</p><p id="3b4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的示例中，我们将设置一个幻灯片，显示51个不同的热图(美国每个州一个，DC华盛顿州一个)，显示每个州国会候选人直接向初选委员会捐款的来源。这是我用来制作展示WhoTheyRepresent.org地图的幻灯片的实际方法。</p><p id="df7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">创建基本的自动化幻灯片放映</strong></p><p id="d0aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，我们有一组51个PNG图像，我们希望循环遍历它们，所有这些图像都位于包含这个站点的HTML/JavaScript代码的目录的<code class="fe ls lt lu lv b">img</code>子目录中。我们将通过创建一个<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image" rel="noopener ugc nofollow" target="_blank">Image</a></code>对象并依次将它指向每个不同的图像来做到这一点，在每个转换之间有5秒钟的等待时间。每次<code class="fe ls lt lu lv b">Image</code>对象被指向一张新的图片时，我们将把图像绘制到我们的<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> HTML画布</a>(如果你不熟悉HTML画布元素，Mozilla开发者网络有<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial" rel="noopener ugc nofollow" target="_blank">关于使用它的介绍性教程</a>)，创建我们的幻灯片效果。</p><p id="69e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为第一步，我们将定义我们的HTML canvas对象，并给它一个普通的白色(<a class="ae lr" href="https://en.wikipedia.org/wiki/Web_colors#Hex_triplet" rel="noopener ugc nofollow" target="_blank">十六进制</a>)背景。在我们的JavaScript代码中，我们将定义变量<code class="fe ls lt lu lv b">canvas</code>和<code class="fe ls lt lu lv b">ctx</code>来分别表示我们的canvas元素及其上下文。此外，我们将定义一个新的<code class="fe ls lt lu lv b">Image</code>对象<code class="fe ls lt lu lv b">img</code>，尽管我们还不会给它分配一个实际的PNG图像——这将在稍后的一个单独的函数中处理。</p><p id="e20d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还将初始化其他几个JavaScript变量。为了允许我们在各种状态及其相关的PNG图像中循环，我们将创建一个数组<code class="fe ls lt lu lv b">states</code>，包含每个状态的缩写，并将该数组的长度存储在变量<code class="fe ls lt lu lv b">numStates</code>中。此外，我们将定义<code class="fe ls lt lu lv b">curSt</code>，它将表示当前时间我们想要显示图像的州的<code class="fe ls lt lu lv b">states</code>中的索引，并将其初始化为<code class="fe ls lt lu lv b">0</code>(阿拉斯加)。</p><p id="e2ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于我们在图像转换之间等待5秒的技术将利用<code class="fe ls lt lu lv b">setTimeout()</code>函数，我们将定义一个<code class="fe ls lt lu lv b">timeoutId</code>变量来保存该函数返回的当前定时器ID，并将其初始化为<code class="fe ls lt lu lv b">-1</code>。</p><p id="8e9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果有人打开浏览器访问我们的网站，为了防止我们的幻灯片浪费地继续从我们的服务器加载图像，我们还将定义一个<code class="fe ls lt lu lv b">maxLoads</code>变量，它代表在不刷新页面的情况下允许的自动图像过渡的最大数量，我们将它设置得足够高，以允许我们的图像经过两个完整的周期。我们的<code class="fe ls lt lu lv b">numLoads</code>变量将对已经发生的图像转换次数进行计数(自上次重置以来)，我们的<code class="fe ls lt lu lv b">paused</code>布尔变量将用于确定自动循环是否应该继续运行。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="8dd5" class="ma mb iq lv b be mc md l me mf">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="utf-8" /&gt;<br/>    &lt;title&gt;Heat Maps Example&lt;/title&gt;<br/>    &lt;style&gt;<br/>     * { padding: 0; margin: 0; }<br/>     canvas { background: #FFFFFF; display: block; margin: 0 auto; }<br/>    &lt;/style&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;canvas id="states_map" width="1400" height="720"&gt;&lt;/canvas&gt;<br/>  &lt;script&gt;<br/>   const states = ['AK','AL','AR','AZ','CA','CO','CT','DC','DE','FL',<br/>      'GA','HI','IA','ID','IL','IN','KS','KY','LA','MA',<br/>      'MD','ME','MI','MN','MO','MS','MT','NC','ND','NE',<br/>      'NH','NJ','NM','NV','NY','OH','OK','OR','PA','RI',<br/>      'SC','SD','TN','TX','UT','VA','VT','WA','WI','WV',<br/>      'WY'];<br/>   const numStates = 51;<br/>   var curSt = 0;<br/>   var timeoutId = -1;<br/>   const img = new Image();<br/>   img.crossOrigin = "anonymous";<br/>   const canvas = document.getElementById("states_map");<br/>   const ctx = canvas.getContext("2d");<br/>   var paused = false;<br/>   var numLoads = 0;<br/>   const maxLoads = 2*numStates;<br/></span></pre><p id="29d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经有了画布元素、<code class="fe ls lt lu lv b">Image</code>对象和其他需要的变量，我们可以定义我们的<code class="fe ls lt lu lv b">loadMapImg()</code>函数，它增加我们的状态计数器(如果幻灯片没有暂停的话),并将由<code class="fe ls lt lu lv b">curSt</code>表示的状态的地图分配给我们的<code class="fe ls lt lu lv b">img</code>对象。由于我们示例中的图像遵循标准命名约定，我们只需将来自<code class="fe ls lt lu lv b">states[]</code>的相关州缩写插入到表示相对文件路径的字符串中。如果我们没有标准化的命名约定，我们可以在数组中存储完整的文件名/路径(或者从另一个文件中动态读取它们)。</p><p id="4731" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，当我们递增我们的<code class="fe ls lt lu lv b">curSt</code>变量以指向下一个状态时，我们取这个递增值的结果<a class="ae lr" href="https://en.wikipedia.org/wiki/Modular_arithmetic" rel="noopener ugc nofollow" target="_blank">对</a> <code class="fe ls lt lu lv b">numStates</code>取模，这样当我们到达幻灯片的结尾时，它将返回到开头。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="72bd" class="ma mb iq lv b be mc md l me mf">function loadMapImg() {<br/>  if(paused === false) {<br/>   curSt = (curSt+1)%numStates;<br/>  }<br/>  img.src = "./img/"+states[curSt]+"_indiv_cont_sources_2022.png";<br/> };</span></pre><p id="155b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们可以添加一个事件监听器，它将在每次我们的<code class="fe ls lt lu lv b">img</code>对象加载时触发，这将在每次<code class="fe ls lt lu lv b">img.src</code>被我们的<code class="fe ls lt lu lv b">loadMapImg()</code>函数指向一个新的PNG后不久发生。我们将让这个事件监听器调用一个新函数<code class="fe ls lt lu lv b">drawMaps()</code>，它将把我们的PNG绘制到画布上。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="0af0" class="ma mb iq lv b be mc md l me mf">img.addEventListener("load", () =&gt; {<br/>        drawMaps();<br/> });</span></pre><p id="0cf7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的<code class="fe ls lt lu lv b">drawMaps()</code>函数需要执行几个步骤。首先，它需要使用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" rel="noopener ugc nofollow" target="_blank">ctx.drawImage()</a></code>方法将加载到我们的<code class="fe ls lt lu lv b">img</code>对象的当前PNG文件绘制到画布上。</p><p id="6130" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们的幻灯片被暂停(即如果<code class="fe ls lt lu lv b">paused</code>是<code class="fe ls lt lu lv b">true</code>)，那么这就是这个函数要做的。但是，如果<code class="fe ls lt lu lv b">paused</code>是<code class="fe ls lt lu lv b">false</code>，我们的函数将首先检查我们的<code class="fe ls lt lu lv b">numLoads</code>计数器是否超过我们的最大转换计数<code class="fe ls lt lu lv b">maxLoads</code>。如果是这样，我们将调用另一个函数<code class="fe ls lt lu lv b">pause()</code>(即将定义)，来暂停我们的幻灯片。</p><p id="ce0b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，如果我们还没有达到我们的负载极限，我们将调用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout" rel="noopener ugc nofollow" target="_blank">setTimeout()</a></code>函数并传递它<code class="fe ls lt lu lv b">loadMapImg</code>(我们之前定义的函数)和<code class="fe ls lt lu lv b">5000</code>作为输入。这样，<code class="fe ls lt lu lv b">setTimeout()</code>将在调用我们的<code class="fe ls lt lu lv b">loadMapImg()</code>函数之前等待<code class="fe ls lt lu lv b">5000</code>毫秒(或5秒)，从而创建我们的幻灯片循环(因为<code class="fe ls lt lu lv b">loadMapImg()</code>的完成将触发我们的事件监听器用于<code class="fe ls lt lu lv b">img</code>加载，这又调用<code class="fe ls lt lu lv b">drawMaps()</code>，这将再次调用<code class="fe ls lt lu lv b">loadMapImg()</code>，除非我们达到了我们的加载限制或幻灯片暂停)。</p><p id="1de1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，<code class="fe ls lt lu lv b">setTimeout()</code>的返回值存储在我们的<code class="fe ls lt lu lv b">timeoutID</code>变量中，我们在调用<code class="fe ls lt lu lv b">setTimeout()</code>来跟踪另一个图像已被加载后，递增<code class="fe ls lt lu lv b">numLoads</code>。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="b521" class="ma mb iq lv b be mc md l me mf">function drawMaps() {<br/>  // draw current map<br/>  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);<br/>  <br/>  // automated reload handling if not paused<br/>  if(paused === false) { <br/>     if(numLoads &gt;= maxLoads) { // pause if too many automated loads<br/>       pause();<br/>     } <br/>     else { // otherwise, set reload timer and increment load counter<br/>       timeoutID = setTimeout(loadMapImg, 5000);<br/>       numLoads += 1;<br/>     }<br/>  }<br/> };</span></pre><p id="a1fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">drawMaps()</code>中使用的<code class="fe ls lt lu lv b">pause()</code>函数需要执行两个任务。首先，如果<code class="fe ls lt lu lv b">timeoutID</code>被设置为等于一个实际定时器的ID，我们想要调用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout" rel="noopener ugc nofollow" target="_blank">clearTimeout()</a></code>来阻止当前定时器完成并再次调用<code class="fe ls lt lu lv b">loadMapImg</code>。我们可以在清除相关定时器后将<code class="fe ls lt lu lv b">timeoutID</code>设置为<code class="fe ls lt lu lv b">-1</code>。然后，我们可以将<code class="fe ls lt lu lv b">paused</code>设置为<code class="fe ls lt lu lv b">true</code>，这样对<code class="fe ls lt lu lv b">drawMaps()</code>的调用将不再触发另一个定时器。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="5798" class="ma mb iq lv b be mc md l me mf">function pause() {<br/>  if(timeoutID &gt; -1) {<br/>   clearTimeout(timeoutID);<br/>   timeoutId = -1;<br/>  }<br/>  paused = true;<br/>};</span></pre><p id="eb66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，在我们脚本的底部，我们将调用<code class="fe ls lt lu lv b">loadMapImg()</code>，这将在页面被加载时触发我们的幻灯片循环。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="41e8" class="ma mb iq lv b be mc md l me mf">  loadMapImg();<br/>&lt;/script&gt;</span></pre><p id="1a06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，我们有了一个简单的幻灯片，它将循环显示我们的51幅热图两次。</p><p id="7535" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">添加显示条</strong></p><p id="0227" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了让用户知道他们在幻灯片中的位置，我们可以在图像底部添加一个菜单栏，显示50个不同的州和DC，并突出显示当前显示的是哪个州的热图。幸运的是，canvas元素使得在我们的图像上绘制这样一个菜单栏变得相对简单。</p><p id="a4c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了实现这一点，我们将首先在脚本顶部附近添加一些新的变量声明。这些将代表我们的菜单栏的大小和位置，我们将它们定义为画布宽度和高度的一部分，以使缩放更容易。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="15b3" class="ma mb iq lv b be mc md l me mf">const menuTop = 19*canvas.height/20;<br/>const menuHeight = canvas.height/20;<br/>const menuItemWidth = canvas.width/numStates;</span></pre><p id="5c41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们可以向我们的<code class="fe ls lt lu lv b">drawMaps()</code>函数添加一个代码片段，以循环遍历<code class="fe ls lt lu lv b">states[]</code>中的每一项，并为每个州绘制一个包含州缩写(即存储在<code class="fe ls lt lu lv b">states[]</code>中的关联值)的矩形。我们将使用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rect" rel="noopener ugc nofollow" target="_blank">ctx.rect()</a></code>方法创建矩形，使用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillText" rel="noopener ugc nofollow" target="_blank">ctx.fillText()</a></code>绘制州名缩写。当我们为热图当前显示的状态绘制菜单项时，我们将使用不同的颜色(即<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle" rel="noopener ugc nofollow" target="_blank">ctx.fillStyle</a></code>)来创建高亮效果。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="b634" class="ma mb iq lv b be mc md l me mf">  // draw states menu bar, one state at a time<br/>  for(let i = 0; i &lt; numStates; i++) {<br/>   // draw rectangle in menu representing this state<br/>   ctx.beginPath();<br/>   ctx.rect(i*menuItemWidth, <br/>    menuTop, <br/>    menuItemWidth, <br/>    menuHeight);<br/>   if(i === curSt) { // highlight current state<br/>    ctx.fillStyle= "#00FF00";<br/>   }<br/>   else {<br/>    ctx.fillStyle = "#009900";<br/>   }<br/>   ctx.fill();<br/>   ctx.closePath();<br/>   // write state abbr to menu bar<br/>   ctx.font = "14px sarif";<br/>   ctx.fillStyle = "#000000";<br/>   ctx.fillText(states[i], <br/>       (i+0.05)*canvas.width/numStates, <br/>       59*canvas.height/60);<br/>  }</span></pre><p id="8c17" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们最终的<code class="fe ls lt lu lv b">drawMaps()</code>函数将如下所示:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="ca7e" class="ma mb iq lv b be mc md l me mf">function drawMaps() {<br/>  // draw current map<br/>  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);<br/>  // draw states menu bar, one state at a time<br/>  for(let i = 0; i &lt; numStates; i++) {<br/>   // draw rectangle in menu representing this state<br/>   ctx.beginPath();<br/>   ctx.rect(i*menuItemWidth, <br/>    menuTop, <br/>    menuItemWidth, <br/>    menuHeight);<br/>   if(i === curSt) { // highlight current state<br/>    ctx.fillStyle= "#00FF00";<br/>   }<br/>   else {<br/>    ctx.fillStyle = "#009900";<br/>   }<br/>   ctx.fill();<br/>   ctx.closePath();<br/>   // write state abbr to menu bar<br/>   ctx.font = "14px sarif";<br/>      ctx.fillStyle = "#000000";<br/>      ctx.fillText(states[i], <br/>       (i+0.05)*canvas.width/numStates, <br/>       59*canvas.height/60);<br/>  }<br/>  // automated reload handling if not paused<br/>  if(paused === false) { <br/>     if(numLoads &gt;= maxLoads) { // pause if too many automated loads<br/>       pause();<br/>     } <br/>     else { // otherwise, set reload timer and increment load counter<br/>       timeoutID = setTimeout(loadMapImg, 5000);<br/>       numLoads += 1;<br/>     }<br/>  }<br/> };</span></pre><p id="1f79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，我们可以循环播放幻灯片，并在图像底部绘制适当的菜单栏，创建如下效果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/443f17c146e70a5eb9284318d66cdb6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czEuSkiYOx0wNSQLfvCzTA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供，使用由<a class="ae lr" href="https://www.mapchart.net/usa.html" rel="noopener ugc nofollow" target="_blank">https://www.mapchart.net/usa.html</a>提供的美国基本州地图和<a class="ae lr" href="https://github.com/wistia/heatmap-palette" rel="noopener ugc nofollow" target="_blank"> Wistia色盲友好热图调色板</a>中描述的配色方案创建。</figcaption></figure><p id="359d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">启用用户对幻灯片放映的控制</strong></p><p id="bedd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用户可能对特定州的热图最感兴趣，或者他们可能希望暂停幻灯片放映，以便给自己更多时间来查看给定的地图。为了方便起见，我们将实现按键处理，让左/右箭头键用于图像之间的滚动，空格键用于暂停或恢复幻灯片放映。我们还将允许单击菜单栏中的一个状态来选择其热图。</p><p id="32b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将首先处理键盘控制。为了监听点击，我们需要添加一个<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" rel="noopener ugc nofollow" target="_blank">事件监听器</a>到我们的脚本中，它将在每次按键时调用一个定制的处理函数(<code class="fe ls lt lu lv b">keyDownHandler()</code>)。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="3ee0" class="ma mb iq lv b be mc md l me mf">document.addEventListener("keydown", keyDownHandler, false);</span></pre><p id="8dae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们可以定义我们的<code class="fe ls lt lu lv b">keyDownHandler()</code>函数，它将有一系列的if/else语句来执行特定的动作，如果特定的键被按下，这是基于输入对象<code class="fe ls lt lu lv b">e</code>的<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code" rel="noopener ugc nofollow" target="_blank">code</a></code>属性的值来确定的，由我们的事件监听器传递。</p><p id="b3e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果<code class="fe ls lt lu lv b">e.code</code>的值为<code class="fe ls lt lu lv b">'Space’</code>，那么空格键被按下。在这种情况下，用户可能想要暂停幻灯片放映，或者如果已经暂停，则继续播放。所以，如果<code class="fe ls lt lu lv b">paused</code>当前是<code class="fe ls lt lu lv b">true</code>，我们将调用一个新函数<code class="fe ls lt lu lv b">unpause()</code>(稍后定义)来恢复幻灯片放映。否则，我们将调用我们现有的<code class="fe ls lt lu lv b">pause()</code>函数。请注意，我们还调用了<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault" rel="noopener ugc nofollow" target="_blank">e.preventDefault()</a></code>方法，以便当用户试图暂停或继续播放幻灯片时，按下空格键不会导致用户页面向下滚动(按下空格键时的默认操作)。</p><p id="e30a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果用户按下右箭头，那么我们将使用我们的<code class="fe ls lt lu lv b">pause()</code>功能暂停幻灯片放映，以防止自动滚动干扰用户的手动滚动。然后，在调用<code class="fe ls lt lu lv b">loadMapImg()</code>加载对应于下一个状态的PNG之前，我们将递增<code class="fe ls lt lu lv b">curSt</code>计数器，使其指向下一个状态(或者回到第一个状态，如果我们达到其最大值)。</p><p id="c0b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，如果用户按下左箭头，我们将在从<code class="fe ls lt lu lv b">curSt</code>中减去<code class="fe ls lt lu lv b">1</code>之前调用<code class="fe ls lt lu lv b">pause()</code>(或者如果<code class="fe ls lt lu lv b">curSt</code>已经是<code class="fe ls lt lu lv b">0</code>的最小值，则将<code class="fe ls lt lu lv b">curSt</code>设置为其最大可能值)，然后我们将调用<code class="fe ls lt lu lv b">loadMapImg()</code>加载相应的热图图像。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="d3c4" class="ma mb iq lv b be mc md l me mf">function keyDownHandler(e) {<br/>  if(e.code === 'Space') { // spacebar<br/>   e.preventDefault(); // Prevent spacebar from scrolling down<br/>   if(paused) {<br/>    unpause();<br/>   }<br/>   else {<br/>    pause();<br/>   }<br/>  }<br/>  else if(e.code === 'ArrowRight') { // right arrow<br/>   pause();<br/>   curSt = (curSt+1)%numStates;<br/>   loadMapImg();<br/>  }<br/>  else if(e.code === 'ArrowLeft') { // left arrow<br/>   pause();<br/>   if(curSt === 0) {<br/>    curSt = numStates-1;<br/>   }<br/>   else {<br/>    curSt = (curSt-1)%numStates;<br/>   }<br/>   loadMapImg();<br/>  }<br/> };</span></pre><p id="24f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，左右箭头应该能够成功地滚动不同的状态，空格键应该能够暂停幻灯片放映，但是我们仍然需要定义我们的<code class="fe ls lt lu lv b">unpause()</code>函数来恢复幻灯片放映。为此，我们将把<code class="fe ls lt lu lv b">paused</code>设置为<code class="fe ls lt lu lv b">false</code>，并调用<code class="fe ls lt lu lv b">loadMapImg()</code>，这将加载下一张图像，从而恢复我们的幻灯片放映周期。我们还会将<code class="fe ls lt lu lv b">numLoads</code>重置为<code class="fe ls lt lu lv b">0</code>，因为用户可能希望如果按下恢复键的话，能够再次观看完整的幻灯片。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="4880" class="ma mb iq lv b be mc md l me mf">function unpause() {<br/>  paused = false;<br/>  numLoads = 0;<br/>  loadMapImg();<br/> };</span></pre><p id="07c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的键盘命令现在应该都可以工作了，但是我们还希望能够单击一个菜单选项来选择该州的热图。为此，我们将添加另一个事件侦听器，这次是针对画布上的点击事件。当canvas元素上的某处有一个点击时，这个监听器将调用一个新的<code class="fe ls lt lu lv b">clickHandler()</code>函数，并将点击事件作为输入传递。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="0567" class="ma mb iq lv b be mc md l me mf">canvas.addEventListener("click", (event) =&gt; clickHandler(event));</span></pre><p id="aef8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ls lt lu lv b">clickHandler()</code>中，我们将使用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" rel="noopener ugc nofollow" target="_blank">canvas.getBoundingClientRect()</a></code>方法返回一个表示包含画布的矩形的对象，通过从单击位置的x坐标中减去矩形左侧的位置，从单击位置的y坐标中减去矩形顶部的位置，我们可以找到画布上单击的(x，y)坐标的相对位置。我们将把这些新坐标存储在<code class="fe ls lt lu lv b">x</code>和<code class="fe ls lt lu lv b">y</code>变量中，这些坐标适合我们的画布。</p><p id="f87c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从那里，我们需要检查点击是否落在我们的一个菜单项的边界内。由于所有菜单项的垂直位置是相同的，我们可以简单地检查<code class="fe ls lt lu lv b">y</code>是否大于<code class="fe ls lt lu lv b">menuTop</code>但小于<code class="fe ls lt lu lv b">menuTop + menuHeight</code>以确定它是否在适当的垂直范围内。由于菜单跨越了我们画布的整个宽度，我们可以做一个快速的安全检查来确保<code class="fe ls lt lu lv b">x</code>既大于<code class="fe ls lt lu lv b">0</code>又小于<code class="fe ls lt lu lv b">canvas.width</code>，以确保点击落在菜单上的某个地方。</p><p id="3208" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设满足以上条件，我们可以调用<code class="fe ls lt lu lv b">pause()</code>来停止自动滚动。然后我们可以设置<code class="fe ls lt lu lv b">curSt</code>等于所选状态对应的值，用<code class="fe ls lt lu lv b">x</code>除以每个菜单项的宽度(<code class="fe ls lt lu lv b">menuItemWidth</code>)再取结果的<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor" rel="noopener ugc nofollow" target="_blank">底</a>即可得到。为了理解这种计算，请记住<code class="fe ls lt lu lv b">x</code>代表从画布左侧的距离，这个距离对应于一个特定的项目。所以，如果我们将<code class="fe ls lt lu lv b">x</code>除以每个项目的宽度并向下舍入，我们可以找到代表包含<code class="fe ls lt lu lv b">x</code>的特定项目的顺序(从最左边的项目开始)的数字。</p><p id="069a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们调用<code class="fe ls lt lu lv b">loadMapImg()</code>来显示与<code class="fe ls lt lu lv b">curSt</code>的新值对应的PNG。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="fa77" class="ma mb iq lv b be mc md l me mf">function clickHandler(event) {<br/>   const bounding = canvas.getBoundingClientRect();<br/>   const x = event.clientX - bounding.left;<br/>   const y = event.clientY - bounding.top;<br/>   <br/>   if((y &gt; menuTop) &amp;&amp; (y &lt; menuTop + menuHeight)) { //verify within vertical range of menu<br/>    if((x &gt;= 0) &amp;&amp; (x &lt; canvas.width)) { // verify within horizontal range of menu<br/>     pause();<br/>     curSt = Math.floor(x/menuItemWidth);<br/>     loadMapImg();<br/>    }<br/>   }<br/> };</span></pre><p id="bf99" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">结论</strong></p><p id="236b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在已经创建了一个具有自动和手动滚动功能的基本幻灯片。使用canvas元素，您还可以在图像上动态地覆盖额外的绘图或文本，或者在图像之间切换时实现某种过渡动画。探索可能性，快乐编码！</p><p id="8b52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">资源</strong></p><p id="7c06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用这种技术的示例网站:<a class="ae lr" href="http://whotheyrepresent.org" rel="noopener ugc nofollow" target="_blank">WhoTheyRepresent.org</a></p><p id="914e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MDN HTML画布教程:<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Canvas _ API/Tutorial</a></p><p id="fa2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MDN图像对象文档:<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/HTMLImageElement/Image</a></p><p id="ee06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MDN setTimeout文档:【https://developer.mozilla.org/en-US/docs/Web/API/setTimeout T21】</p><p id="c4f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MDN clearTimeout文档:<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/clear time out</a></p><p id="1b90" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MDN canvas drawImage文档:<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/canvasrenderingcontext 2d/draw image</a></p><p id="bd1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MDN事件监听器文档:<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/event target/addevent listener</a></p><p id="258b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MDN getBoundingClientRect文档:<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Element/getBoundingClientRect</a></p></div></div>    
</body>
</html>