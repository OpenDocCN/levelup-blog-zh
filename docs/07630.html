<html>
<head>
<title>Hidden Power of Polymorphism in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中多态隐藏的力量</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/hidden-power-of-polymorphism-in-python-c9e2539c1633?source=collection_archive---------0-----------------------#2021-03-02">https://levelup.gitconnected.com/hidden-power-of-polymorphism-in-python-c9e2539c1633?source=collection_archive---------0-----------------------#2021-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="bf79" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Python中的干净架构</h2><div class=""/><div class=""><h2 id="187e" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何在应用程序中实现多态接口？</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/790c6f9a1db66e51df918fc408581784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Di_LfHQupjYqsHnh"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@victorserban?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维克多·塞尔班</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2410" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">多态性通常被解释为面向对象的范例的一部分。但是除了面向对象的设计，Python还有其他强大的特性来实现抽象。在应用程序中创建多态接口有几种主要方法。当我们想要实现干净而强大的<strong class="lh ja">架构</strong>时，选择合适的方式变得很重要。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="eea4" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">理论</h1><p id="66d6" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated"><strong class="lh ja">多态性</strong>和<strong class="lh ja">类型系统</strong>是一种语言的主要特征，它允许我们用代码来交流思想。实际上，<strong class="lh ja">多态性</strong>帮助我们使代码可重用、可测试和可维护。</p><p id="a616" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们从维基百科的一些正式定义开始。</p><blockquote class="nf ng nh"><p id="209d" class="lf lg ni lh b li lj ka lk ll lm kd ln nj lp lq lr nk lt lu lv nl lx ly lz ma ij bi translated"><a class="ae le" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja"/></a>多态是提供单一的<strong class="lh ja"><em class="iq"/></strong>接口给不同的<strong class="lh ja"><em class="iq"/></strong>类型的实体或者使用单一的符号来表示不同的类型。</p></blockquote><p id="099c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">多态性的主要种类有:</p><ul class=""><li id="3375" class="nm nn iq lh b li lj ll lm lo no ls np lw nq ma nr ns nt nu bi translated">特定多态性</li><li id="efff" class="nm nn iq lh b li nv ll nw lo nx ls ny lw nz ma nr ns nt nu bi translated">参数的</li><li id="d5cb" class="nm nn iq lh b li nv ll nw lo nx ls ny lw nz ma nr ns nt nu bi translated">分型</li><li id="6896" class="nm nn iq lh b li nv ll nw lo nx ls ny lw nz ma nr ns nt nu bi translated">行多态性</li><li id="8011" class="nm nn iq lh b li nv ll nw lo nx ls ny lw nz ma nr ns nt nu bi translated">鸭子打字</li></ul><p id="bade" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">特殊</strong>变量用于可能重载函数的语言，例如<strong class="lh ja"> C </strong>。<strong class="lh ja">参数化</strong>是针对<strong class="lh ja"> </strong>有泛型和类型推理的语言(<strong class="lh ja"> C++，Haskell </strong>)。我们可以在<strong class="lh ja">类型脚本</strong>中使用<strong class="lh ja">行</strong> <strong class="lh ja">多态性</strong>。Python有这两种类型。它们是<strong class="lh ja">分型</strong>和<strong class="lh ja">鸭分型。</strong></p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="c52c" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">显示优点的东西</h1><p id="c60c" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">例如，让我们设计一个简单的储物展示。这个存储可以通过主键<code class="fe oa ob oc od b">add</code>一个条目并<code class="fe oa ob oc od b">get</code>它。这是一个商业案例，我们不知道我们有什么存储。它可以是一个数据库，甚至是另一个服务。我们不担心这些细节。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">商业案例</figcaption></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="90b9" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">子类型/子类化</h1><p id="6e93" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">当我们开始谈论代码的模式和架构时，类和OOP设计经常出现。<strong class="lh ja">继承</strong>允许从现有对象定义新对象。通过定义类的层次结构，我们可以在我们的领域中对对象之间的复杂关系进行建模。</p><p id="db8f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们定义<strong class="lh ja">抽象类</strong> <code class="fe oa ob oc od b">Storage</code>，它有一个<strong class="lh ja">接口</strong>到<code class="fe oa ob oc od b">add</code>和<code class="fe oa ob oc od b">get</code>项。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">抽象存储</figcaption></figure><p id="1bb0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们定义类时，我们在代码中引入了一个新的<strong class="lh ja">类型</strong>。我们可以给函数<code class="fe oa ob oc od b">use_storage(storage: Storage)</code>添加类型提示。并且使用类型跳棋，例如，<a class="ae le" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja"> mypy </strong> </a>或<a class="ae le" href="https://github.com/facebook/pyre-check" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja"> pyre </strong> </a>。</p><p id="cf3b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后我们定义了两个特定的类<code class="fe oa ob oc od b">Memory</code>和<code class="fe oa ob oc od b">Persistent</code>，它们是从我们的抽象<code class="fe oa ob oc od b">Storage</code>中的<strong class="lh ja">子类</strong>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">特定存储</figcaption></figure><p id="0b25" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这两个类继承了它们的<strong class="lh ja">父</strong> <strong class="lh ja">类</strong> <code class="fe oa ob oc od b">Storage</code>的方法和属性。我们可以在任何需要使用<code class="fe oa ob oc od b">Storage</code>的地方使用它们，并将这些类的实例传递给我们的<code class="fe oa ob oc od b">use_storage</code>函数。</p><p id="36c6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">定义抽象<code class="fe oa ob oc od b">Storage</code>和引入类的层次结构的<strong class="lh ja">优点</strong>和<strong class="lh ja">缺点</strong>是什么？</p><p id="896f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">优点:</strong></p><ul class=""><li id="134f" class="nm nn iq lh b li lj ll lm lo no ls np lw nq ma nr ns nt nu bi translated">定义<strong class="lh ja">接口</strong>以显示我们必须为<code class="fe oa ob oc od b">Storage</code>实现的方法；</li><li id="651b" class="nm nn iq lh b li nv ll nw lo nx ls ny lw nz ma nr ns nt nu bi translated">我们可以使用类型检查器。</li></ul><p id="c590" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">缺点:</strong></p><ul class=""><li id="92f1" class="nm nn iq lh b li lj ll lm lo no ls np lw nq ma nr ns nt nu bi translated">我们真的不需要它。</li></ul><p id="83d8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">抽象有两个方面，一方面，它们帮助隐藏复杂性，另一方面，它们增加了复杂性。保持平衡很重要。</p><p id="1bb3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这种情况下，我会说，这是“<strong class="lh ja">Y</strong>ou<strong class="lh ja">A</strong>ren ' t<strong class="lh ja">G</strong>onna<strong class="lh ja">N</strong>eed<strong class="lh ja">I</strong>t”(<strong class="lh ja">YAGNI</strong>)比谈实际利益。如果我们去掉抽象类，只使用具体的实现，会怎么样呢？这让我们想到了<strong class="lh ja">鸭子打字</strong>。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="ef1f" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">鸭子打字带类</h1><p id="72a2" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">作为一种高度动态的语言，Python的一些<strong class="lh ja">原则以协议的形式存在。<strong class="lh ja">类中<strong class="lh ja">私有属性</strong>的封装</strong>就是一个经典的例子。有一个约定，以双下划线(__)开头的方法或属性是私有的。此外，我们可以记住定义整个语言哲学的<code class="fe oa ob oc od b">import this</code>。我们可以说<strong class="lh ja">鸭分型</strong>也是一种约定。</strong></p><blockquote class="nf ng nh"><p id="6ac4" class="lf lg ni lh b li lj ka lk ll lm kd ln nj lp lq lr nk lt lu lv nl lx ly lz ma ij bi translated">如果它的行为像只鸭子，那么它一定是只鸭子。</p></blockquote><p id="0dbf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">Python中的Duck typing </strong>是与类型无关的<strong class="lh ja">行多态性</strong>。在这种情况下，对象的行为由其结构决定。这意味着我们可以提供任何包含我们期望的方法或属性的实体。</p><p id="6149" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">实际上，当我们定义一个类时，我们定义了一个接口。从这个意义上说，我们定义了如何与类的实例交互。</p><p id="a93a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我们的例子中，我们去掉了<strong class="lh ja">抽象类</strong>和<strong class="lh ja">继承</strong>，只留下我们的特定类。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">分类存储</figcaption></figure><p id="4902" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些实现仍然遵循相同的接口，并且可以在相同的<code class="fe oa ob oc od b">use_storage</code>函数中使用。</p><p id="3fbc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">优点:</strong></p><ul class=""><li id="f0b0" class="nm nn iq lh b li lj ll lm lo no ls np lw nq ma nr ns nt nu bi translated">让事情变得简单。</li></ul><p id="1d0d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">缺点:</strong></p><ul class=""><li id="aaf9" class="nm nn iq lh b li lj ll lm lo no ls np lw nq ma nr ns nt nu bi translated">没有带有显式<strong class="lh ja">接口</strong>的<strong class="lh ja">类</strong>。</li></ul><p id="f28e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">类</strong>是在我们的代码中模拟真实世界行为的一个很好的工具。但有时，我们没有一个应该被<strong class="lh ja">封装</strong>和/或改变的内部状态，或者一些实体将作为单个<strong class="lh ja">实例存在。</strong>有<strong class="lh ja">类</strong>变得过度工程化的情况。</p><p id="d9ae" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以更进一步，取消课程。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="5a31" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">用模块进行鸭式打字</h1><p id="7354" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">一个实体不需要成为多态的<strong class="lh ja">类</strong>。模块也可以遵循<strong class="lh ja">鸭子打字</strong>的规则。我们可以通过使用模块、它们的层次结构和导入在更高的层次上定义<strong class="lh ja">接口</strong>。</p><p id="5994" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们继续为我们的例子定义一个目录结构。</p><pre class="kp kq kr ks gt og od oh oi aw oj bi"><span id="9787" class="ok mj iq od b gy ol om l on oo">storage/<br/>  __init__.py<br/>  memory.py<br/>  persistent.py</span></pre><p id="6560" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后分别搬出实现。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">带模块的储物件</figcaption></figure><p id="b1bc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以在同样的功能中使用它<code class="fe oa ob oc od b">use_storage</code>。</p><pre class="kp kq kr ks gt og od oh oi aw oj bi"><span id="d76d" class="ok mj iq od b gy ol om l on oo">import storage.memory<br/>import storage.persistent</span><span id="0919" class="ok mj iq od b gy op om l on oo">use_storage(storage.memory)<br/># or<br/>use_storage(storage.persistent)</span></pre><p id="feeb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些物品具有所有的优点。</p><p id="446a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">优点:</strong></p><ul class=""><li id="5e8b" class="nm nn iq lh b li lj ll lm lo no ls np lw nq ma nr ns nt nu bi translated">在<code class="fe oa ob oc od b">unittest.mock</code>库的帮助下，它们是可测试的；</li><li id="a6e6" class="nm nn iq lh b li nv ll nw lo nx ls ny lw nz ma nr ns nt nu bi translated">它们可以遵循<strong class="lh ja">封装</strong>，使用导入可以隐藏模块内部的细节；</li><li id="3e58" class="nm nn iq lh b li nv ll nw lo nx ls ny lw nz ma nr ns nt nu bi translated">默认情况下，你有<strong class="lh ja">单例</strong>模式。</li></ul><p id="ac8a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">缺点:</strong></p><ul class=""><li id="a570" class="nm nn iq lh b li lj ll lm lo no ls np lw nq ma nr ns nt nu bi translated">模块没有<strong class="lh ja">继承</strong>，但是在某些情况下可以用<strong class="lh ja">组合</strong>来代替。</li></ul><p id="3e00" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一个好处是，你可以在应用程序中拥有一个富有表现力的、命名良好的结构。由模块定义高级代码流，并在代码中显式使用它们。我想这就是<strong class="lh ja">罗伯特·马丁</strong>所说的<strong class="lh ja">尖叫建筑</strong>。</p><blockquote class="nf ng nh"><p id="a567" class="lf lg ni lh b li lj ka lk ll lm kd ln nj lp lq lr nk lt lu lv nl lx ly lz ma ij bi translated">那么，你的应用程序的架构在尖叫什么呢？当你查看顶层目录结构，以及最高层包中的源文件时，它们是在喊“医疗保健系统”，还是“会计系统”，还是“库存管理系统”？或者他们会喊“Rails”，或者“Spring/ Hibernate”，或者“ASP”？</p><p id="138c" class="lf lg ni lh b li lj ka lk ll lm kd ln nj lp lq lr nk lt lu lv nl lx ly lz ma ij bi translated">罗伯特。马丁。干净的建筑。第196页</p></blockquote><h1 id="ba86" class="mi mj iq bd mk ml oq mn mo mp or mr ms kf os kg mu ki ot kj mw kl ou km my mz bi translated">结论</h1><p id="c018" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">在<strong class="lh ja"> Python </strong>中有大量的编程概念，开发者可以根据当前的任务选择函数式的、面向对象的或过程式的范例。没有放之四海而皆准的建议。</p><p id="db3c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">多态接口也是一样，我们可以选择任何一种方式来实现代码中的实体及其关系。干净、富于表现力和可扩展是我们希望看到的结果。抽象可以隐藏复杂性，<strong class="lh ja">吻</strong>和<strong class="lh ja"> YAGNI </strong>可以帮助保持清晰，记住这一点</p><blockquote class="nf ng nh"><p id="fbcb" class="lf lg ni lh b li lj ka lk ll lm kd ln nj lp lq lr nk lt lu lv nl lx ly lz ma ij bi translated">简单比复杂好。</p></blockquote><p id="3669" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">代码示例可以在我的GitHub repo<a class="ae le" href="https://github.com/fokinpv/py-polymorphism-study" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja">py-polymorphism-study</strong></a><strong class="lh ja">中找到。</strong></p><h2 id="7a13" class="ok mj iq bd mk ov ow dn mo ox oy dp ms lo oz pa mu ls pb pc mw lw pd pe my iw bi translated">相关阅读</h2><div class="pf pg gp gr ph pi"><a href="https://medium.com/@pavelfokin/why-do-programming-languages-have-types-c9346faf9559" rel="noopener follow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd ja gy z fp pn fr fs po fu fw iz bi translated">为什么编程语言有类型？</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">从非类型化到类型化的演练</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">medium.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw ky pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a rel="noopener  ugc nofollow" target="_blank" href="/tenet-of-inversion-with-python-9759ef73dbcf"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd ja gy z fp pn fr fs po fu fw iz bi translated">Python中的反转原则</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">打破依赖倒置原则。</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pr l"><div class="px l pt pu pv pr pw ky pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://towardsdatascience.com/how-to-track-hazardous-asteroids-with-composition-of-iterators-in-python-3945cf8e8f84" rel="noopener follow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd ja gy z fp pn fr fs po fu fw iz bi translated">如何用Python中迭代器的组合追踪危险的小行星</h2><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="py l pt pu pv pr pw ky pi"/></div></div></a></div></div></div>    
</body>
</html>