<html>
<head>
<title>Understanding Recursion By Dropping It Eventually</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过最终放弃递归来理解递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-recursion-by-dropping-it-eventually-be442c8141f2?source=collection_archive---------11-----------------------#2022-07-31">https://levelup.gitconnected.com/understanding-recursion-by-dropping-it-eventually-be442c8141f2?source=collection_archive---------11-----------------------#2022-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jq jr js jt"><div class="bz fp l di"><div class="ju jv l"/></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk translated">GIPHY工作室原创GIF(Giphy.com)</figcaption></figure><blockquote class="ka"><p id="390c" class="kb kc it bd kd ke kf kg kh ki kj kk dk translated">递归，初级开发者的噩梦！</p></blockquote><p id="53d3" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh kk im bi translated">对人类来说很难，对计算机来说也同样很费力。</p><p id="9bb5" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">当你写一个递归函数时，计算机必须维护一个<strong class="kn iu">调用栈</strong>，它跟踪所有递归调用的<strong class="kn iu">执行上下文</strong>。</p><p id="1691" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">这使得递归成为一项内存密集型任务。</p><p id="ab35" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">如果多次调用递归函数，计算机可能会不堪重负，并抛出堆栈溢出错误！</p><p id="ef29" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">这是一种让计算机惊慌失措的方式，它大喊自己再也无法跟踪执行上下文了。</p><p id="fb4b" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">事情正在流出调用栈！</p><figure class="ln lo lp lq gt jt"><div class="bz fp l di"><div class="lr jv l"/></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk translated">早安动画GIF由金伯格里(Giphy.com)制作</figcaption></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="f3dc" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">为了更好地理解这一点，让我们先用递归来解决一个问题，然后再用普通的迭代。</p><h1 id="879f" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">问题陈述</h1><p id="3048" class="pw-post-body-paragraph kl km it kn b ko mx kq kr ks my ku kv kw mz ky kz la na lc ld le nb lg lh kk im bi translated">求第n个斐波那契数</p><h1 id="9cab" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">什么是斐波那契数？</h1><p id="a776" class="pw-post-body-paragraph kl km it kn b ko mx kq kr ks my ku kv kw mz ky kz la na lc ld le nb lg lh kk im bi translated">在数学中，斐波那契数列形成了一个数列，其中每个数字都是前面数字的总和。</p><figure class="ln lo lp lq gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/7b44ca165220dc3e0f88fd2925fe0306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kVS991xQnUXDijHL.png"/></div></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk translated">图片来自维基百科</figcaption></figure><h1 id="6a3c" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">递归求解</h1><p id="3954" class="pw-post-body-paragraph kl km it kn b ko mx kq kr ks my ku kv kw mz ky kz la na lc ld le nb lg lh kk im bi translated">给定一个数字<code class="fe nj nk nl nm b">n</code>，我们需要写一个函数返回第<code class="fe nj nk nl nm b">n</code>个斐波那契数。</p><p id="f0f4" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">递归为这个问题提供了一个简单而优雅的解决方案。</p><p id="e23f" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">为了继续递归解决方案，我们需要考虑:</p><ul class=""><li id="8a61" class="nn no it kn b ko li ks lj kw np la nq le nr kk ns nt nu nv bi translated"><strong class="kn iu">基础案例</strong></li><li id="f1e4" class="nn no it kn b ko nw ks nx kw ny la nz le oa kk ns nt nu nv bi translated"><strong class="kn iu">递归步骤</strong>到达基本情况</li></ul><p id="a986" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">在Python中，具有基本情况的函数可以写成如下形式。</p><pre class="ln lo lp lq gt ob nm oc od aw oe bi"><span id="fccb" class="of ma it nm b gy og oh l oi oj">def findNthFibonacci(n):<br/>    #Base Case 1<br/>    if n &lt; = 0: <br/>        raise ValueError("n should be more than 0")</span><span id="b363" class="of ma it nm b gy ok oh l oi oj">    #Base Case 2<br/>    elif n == 1:<br/>        return 0</span><span id="e000" class="of ma it nm b gy ok oh l oi oj">    #Base Case 3<br/>    elif n == 2:<br/>        return 1</span></pre><p id="10aa" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">如果<code class="fe nj nk nl nm b">n ≤ 2</code>，功能<code class="fe nj nk nl nm b">findNthFibonacci</code>将立即返回</p><p id="5524" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">接下来，我们需要一个<strong class="kn iu">递归步骤</strong>来得到一个基本案例。</p><pre class="ln lo lp lq gt ob nm oc od aw oe bi"><span id="d7ec" class="of ma it nm b gy og oh l oi oj">def findNthFibonacci(n):<br/>    #Base Case 1<br/>    if n &lt; = 0: <br/>        raise ValueError("n should be more than 0")</span><span id="eaed" class="of ma it nm b gy ok oh l oi oj">    #Base Case 2<br/>    elif n == 1:<br/>        return 0</span><span id="ac37" class="of ma it nm b gy ok oh l oi oj">    #Base Case 3<br/>    elif n == 2:<br/>        return 1</span><span id="f7ff" class="of ma it nm b gy ok oh l oi oj">    #Recursive Step<br/>    else:<br/>        return findNthFibonacci(n-1) + findNthFibonacci(n-2)</span></pre><p id="ab64" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">很优雅，不是吗？</p><figure class="ln lo lp lq gt jt"><div class="bz fp l di"><div class="ol jv l"/></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk translated">哦，我的上帝哇GIF(Giphy.com)</figcaption></figure><p id="29bd" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">不幸的是，当我们深入挖掘时，我们发现这个算法运行在:</p><ul class=""><li id="11f9" class="nn no it kn b ko li ks lj kw np la nq le nr kk ns nt nu nv bi translated">O (2^n) 的时间复杂度，因为递归步骤在每一步调用函数本身两次</li><li id="b9a1" class="nn no it kn b ko nw ks nx kw ny la nz le oa kk ns nt nu nv bi translated">O (n) 的空间复杂度，因为递归步骤将执行上下文存储在一个调用堆栈中，该堆栈将与<code class="fe nj nk nl nm b">n</code>成比例增长</li></ul><figure class="ln lo lp lq gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi om"><img src="../Images/e7028cc7855453a39b18ee7c84cce63f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJABjWq3HTgR7gXw9lNYZQ.png"/></div></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk translated">具有递归解的事件序列(图片由作者提供)</figcaption></figure><p id="3aeb" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">如何优化解决方案？</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5693" class="lz ma it bd mb mc on me mf mg oo mi mj mk op mm mn mo oq mq mr ms or mu mv mw bi translated">最佳化</h1><p id="917c" class="pw-post-body-paragraph kl km it kn b ko mx kq kr ks my ku kv kw mz ky kz la na lc ld le nb lg lh kk im bi translated">我们看到，当我们用上面的解决方案解决这个问题时，我们正在多次重复这些步骤。</p><p id="dad9" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">如果我们将计算的结果存储在一个数据结构中，我们可以在恒定时间内访问其中的值，会发生什么？</p><p id="075f" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">当然可以！</p><h2 id="aa40" class="of ma it bd mb os ot dn mf ou ov dp mj kw ow ox mn la oy oz mr le pa pb mv pc bi translated">方法一:记忆</h2><p id="2458" class="pw-post-body-paragraph kl km it kn b ko mx kq kr ks my ku kv kw mz ky kz la na lc ld le nb lg lh kk im bi translated">记忆化是将计算结果存储在临时内存(缓存)中，并在下次需要时检索它，而不是再次计算它的过程。</p><p id="bd4b" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">为此，我们将创建一个名为<code class="fe nj nk nl nm b">memo</code>的字典/哈希映射，它将默认存储第一个和第二个斐波那契数。</p><p id="9045" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">如果我们在这个字典中找到第<code class="fe nj nk nl nm b">n</code>个斐波那契数的值，我们将返回它(在常数时间内)。</p><p id="e2f8" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">否则，我们将计算结果并在返回之前将其添加到这个字典中。</p><pre class="ln lo lp lq gt ob nm oc od aw oe bi"><span id="f517" class="of ma it nm b gy og oh l oi oj">def findNthFibonacci(n, memo:{1:0, 2:1}):</span><span id="c8b8" class="of ma it nm b gy ok oh l oi oj">    if n in memo:<br/>        return memo[n]</span><span id="1d9d" class="of ma it nm b gy ok oh l oi oj">    else:<br/>        memo[n] = findNthFibonacci(n-1, memo) + findNthFibonacci(n-2, memo)<br/>        return memo[n]</span></pre><p id="7137" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">该算法运行于:</p><ul class=""><li id="b0d6" class="nn no it kn b ko li ks lj kw np la nq le nr kk ns nt nu nv bi translated"><strong class="kn iu"> O (n) </strong>的时间复杂度，因为递归步骤计算每个斐波纳契数一次，然后将其存储在字典中<code class="fe nj nk nl nm b">memo</code></li><li id="39ba" class="nn no it kn b ko nw ks nx kw ny la nz le oa kk ns nt nu nv bi translated">O (n) 的空间复杂度，因为递归步骤将每个斐波纳契数存储在字典<code class="fe nj nk nl nm b">memo</code>中，该字典将与<code class="fe nj nk nl nm b">n</code>成比例增长。此外，递归步骤将执行上下文存储在一个调用堆栈中，该堆栈将与<code class="fe nj nk nl nm b">n</code>成比例增长。</li></ul><h2 id="6aac" class="of ma it bd mb os ot dn mf ou ov dp mj kw ow ox mn la oy oz mr le pa pb mv pc bi translated">方法2:迭代</h2><p id="f57c" class="pw-post-body-paragraph kl km it kn b ko mx kq kr ks my ku kv kw mz ky kz la na lc ld le nb lg lh kk im bi translated">为了使我们的解决方案最有效，我们将返回到我们简单的老迭代。</p><p id="5b82" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">让我们写一个问题的迭代解。</p><pre class="ln lo lp lq gt ob nm oc od aw oe bi"><span id="424e" class="of ma it nm b gy og oh l oi oj">def findNthFibonacci(n):<br/>    firstFib, secondFib = 0, 1</span><span id="18d5" class="of ma it nm b gy ok oh l oi oj">    for _ in range(n-1):<br/>        firstFib, secondFib = secondFib, (firstFib + secondFib)<br/>    <br/>    return firstFib</span></pre><p id="1c57" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">该解决方案将第一个和第二个斐波那契数存储在函数内部的两个局部变量<code class="fe nj nk nl nm b">firstFib</code>和<code class="fe nj nk nl nm b">secondFib</code>中。</p><p id="a2e5" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">我们将循环<code class="fe nj nk nl nm b">n-1</code>次，并不断改变<code class="fe nj nk nl nm b">firstFib</code>和<code class="fe nj nk nl nm b">secondFib</code>的值，直到我们到达存储在<code class="fe nj nk nl nm b">firstFib</code>中的第<code class="fe nj nk nl nm b">n</code>个斐波那契数。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="2919" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">希望这能让你更容易理解递归！</p><p id="7789" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated"><em class="pd">感谢阅读！</em></p><div class="pe pf gp gr pg ph"><a href="https://bamania-ashish.medium.com/membership" rel="noopener follow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">通过我的推荐链接加入Medium-Ashish Bama nia博士</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">阅读Ashish Bamania博士(以及Medium上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">bamania-ashish.medium.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv nh ph"/></div></div></a></div><figure class="ln lo lp lq gt jt"><div class="bz fp l di"><div class="pw jv l"/></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk translated">狗谢谢你GIF由穆德曼(Giphy.com)</figcaption></figure><p id="05f2" class="pw-post-body-paragraph kl km it kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk im bi translated">如果你觉得这篇文章有用，你可以在这里看看我的其他文章:</p><div class="pe pf gp gr pg ph"><a rel="noopener  ugc nofollow" target="_blank" href="/node-js-how-to-optimise-server-performance-35c85421db18"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">Node.js:如何优化服务器性能？</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">优化节点/快速服务器指南。</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pq l"><div class="px l ps pt pu pq pv nh ph"/></div></div></a></div><div class="pe pf gp gr pg ph"><a rel="noopener  ugc nofollow" target="_blank" href="/array-methods-that-every-javascript-developer-must-know-6e85fe2580ec"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">每个Javascript开发人员都必须知道的数组方法</h2><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pq l"><div class="py l ps pt pu pq pv nh ph"/></div></div></a></div><div class="pe pf gp gr pg ph"><a rel="noopener  ugc nofollow" target="_blank" href="/build-a-full-stack-web-application-for-real-time-skin-cancer-detection-5bda4f43681f"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">学习构建一个完整的实时皮肤癌检测的网络应用程序…</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">学习使用React.js、Tensorflow.js、Keras、Express、Firebase &amp; Heroku构建全栈web应用程序</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pq l"><div class="pz l ps pt pu pq pv nh ph"/></div></div></a></div><div class="pe pf gp gr pg ph"><a rel="noopener  ugc nofollow" target="_blank" href="/a-simple-looking-tricky-dsa-problem-217512363a99"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">一个看起来简单但棘手的DSA问题！</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">返回一个排序的平方数组并不像看起来那么简单！</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pq l"><div class="qa l ps pt pu pq pv nh ph"/></div></div></a></div></div></div>    
</body>
</html>