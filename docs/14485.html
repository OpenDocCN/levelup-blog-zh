<html>
<head>
<title>Tomcat parameter optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tomcat参数优化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tomcat-parameter-optimization-11246402f810?source=collection_archive---------10-----------------------#2022-12-01">https://levelup.gitconnected.com/tomcat-parameter-optimization-11246402f810?source=collection_archive---------10-----------------------#2022-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3a8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何对Tomcat进行性能优化？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/a7e6950a0a079a46109bc9b36a174f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Edp96CLfV4809JUM6Sg0Eg.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">照片由<a class="ae la" href="https://unsplash.com/@niko_photos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> niko photos </a>在<a class="ae la" href="https://unsplash.com/s/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="83f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于提供接口服务的应用，很多都使用SpringBoot默认的Servlet容器Tomcat。</p><p id="0d1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上线初期，因为大部分流量较小，所以我们不会对Tomcat进行特殊的参数调整。</p><p id="955b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是随着流量的增加，应用的性能指标越来越差。这个时候，我们大多数人都会选择扩大容量。</p><p id="4427" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了容量扩展，我们还可以选择在Tomcat上执行性能调优，在不增加成本的情况下提高性能。</p><p id="f167" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天我们将分享如何在Tomcat上执行简单的性能调优来提高应用程序性能。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="8d22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">Tomcat的架构。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi li"><img src="../Images/b254c6de0f2d974e2791345bb538cced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nhVY0KVLO_9LhRodvp0DQ.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</figcaption></figure><p id="70f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上图可以看出，Tomcat将其业务抽象为组件，如<code class="fe ln lo lp lq b">Server, Service, Connector, Container</code>等。，每个组件都有不同的作用。</p><p id="6320" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务器组件是Tomcat最外层的组件，它是Tomcat实例本身的抽象，代表Tomcat本身。一个服务器组件可以有一个或多个服务组件。</p><p id="e8df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务组件是Tomcat中提供服务和处理请求的一组组件。一个服务组件可以有多个连接器和一个容器。多个连接器表示它可以使用多个协议同时接收用户请求。</p><p id="d1b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">连接器负责处理客户端连接，并为各种服务协议提供支持，包括BIO、NIO、AIO等。它存在的价值在于屏蔽了多协议容器的复杂性，统一了容器的处理标准。</p><p id="b94f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">容器组件是负责特定业务逻辑处理的容器。当连接器组件与客户机建立连接时，它将请求转发给容器组件的引擎组件进行处理。</p><p id="659e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，Tomcat的核心组件基本完成。事实上，容器组件中有许多细分的组件。事实上，如果您对业务的抽象感兴趣，您可以继续查看。</p><ul class=""><li id="d30a" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated">引擎组件表示一个可运行的Servlet实例，包括Servlet容器的核心功能，它可以有一个或多个虚拟主机(Host)。其主要作用是将请求委托给合适的虚拟主机进行处理，即根据URL路径的配置匹配合适的虚拟主机进行处理。</li><li id="8c66" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">主机组件负责运行多个应用程序，并负责安装这些应用程序。它的主要功能是解析web.xml文件，并将其匹配到相应的上下文组件。</li><li id="fc38" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">上下文组件表示特定的Web应用程序本身，它最重要的功能是管理内部的Servlet实例。一个上下文可以有一个或多个Servlet实例。</li><li id="572d" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">包装器组件代表一个Servlet，它负责管理一个Servlet，包括Servlet加载、初始化、执行和资源恢复。包装器是最底层的容器。</li></ul><p id="2459" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以看出，Host是虚拟主机的抽象，Context是应用的抽象，Wrapper是Servlet的抽象，Engine是处理层的抽象。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="1ff5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">核心参数。</strong></p><p id="5b9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在了解核心参数之前，我们需要对Tomcat对请求的处理流程有一个大致的了解。Tomcat对请求的处理流程如下。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mf"><img src="../Images/2a131218a16aeefad93a60762d709f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D14SX7kF6RgToUU8q6imeg.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</figcaption></figure><p id="7fe8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的原理图中，有三个非常关键的核心参数，也是性能调优的关键。</p><ul class=""><li id="8435" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated"><code class="fe ln lo lp lq b">acceptCount</code>:当容器线程池达到最大数量且没有空闲线程，连接器队列达到最大数量时，操作系统可以接受的最大连接数。</li><li id="1c4f" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated"><code class="fe ln lo lp lq b">maxConnections</code>:当容器线程池达到最大数量并且没有空闲线程时，连接器队列可以接收的最大线程数量。</li><li id="3907" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated"><code class="fe ln lo lp lq b">maxThreads</code>:容器线程池中处理线程的最大数量。</li></ul><p id="dda2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从以上三个参数的意义，我们可以知道以下结论。</p><p id="7ef2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客户端并不直接与Tomcat的连接器组件建立联系，而是先与操作系统建立联系，然后将其交给连接器。</p><p id="df20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一点很重要，否则，你不会理解<code class="fe ln lo lp lq b">acceptCount</code>参数。</p><p id="3021" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不仅连接器组件中有一个队列，操作系统中也有一个队列来临时存储与客户端的连接，这也是一个关键点。</p><p id="87e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们所说的线程池是指Container容器中的线程池。</p><p id="cc0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理解这三个核心参数的含义非常重要，否则后续的性能调优工作就无从开展。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="1db5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> maxThreads。</strong></p><p id="71c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们知道<code class="fe ln lo lp lq b">maxThreads</code>指的是请求处理线程的最大数量，在Tomcat7和Tomcat8中默认为<code class="fe ln lo lp lq b">200</code>。</p><p id="87a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该参数的设置需要根据任务的执行内容进行调整。一般来说，计算公式是:<code class="fe ln lo lp lq b">maximum number of threads = ((IO time + CPU time)/CPU time) * number of CPU cores</code>。</p><p id="7a2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个公式的思路其实很简单，就是最大化的利用CPU资源。</p><p id="3d35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个任务的时间消耗分为IO时间消耗和CPU时间消耗。基本上IO时间消耗是最多的，CPU这个时候没事干。</p><p id="b971" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以如果可以允许CPU在任务等待IO的同时处理其他任务，那么CPU利用率就会提高。</p><p id="cf1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，由于IO时间消耗远大于CPU时间消耗，所以根据公式计算出来的<code class="fe ln lo lp lq b">maxThreads</code>数会远大于CPU核数，这是正常的。</p><p id="4d49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的是，这个数值并不是越高越好。因为一旦线程过多，CPU就需要进行上下文切换，这就消耗了部分CPU资源。</p><p id="c417" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以最好的办法就是用上面的公式算出一个基准值，然后进行压力测试，调整到一个合理的值。</p><p id="229e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，如果<code class="fe ln lo lp lq b">maxThreads</code>的值增加了，但是吞吐量不增不减，可能说明已经到了瓶颈。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="2796" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> maxConnections。</strong></p><p id="6611" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp lq b">maxConnections</code>指线程池中的线程达到最大值且全部繁忙时，连接器中队列所能容纳的最大连接数。</p><p id="ea79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，我们必须设定一个合理的值，不能允许它无限制地堆积。</p><p id="d082" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为Tomcat的处理能力肯定是有限的，到了一定程度肯定就处理不过来了。所以，积累多了也没用。反而会造成内存堆积，最终导致内存溢出OOM。</p><p id="e77e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般情况下，经验值可以设置为与<code class="fe ln lo lp lq b">maxThreads</code>相同的大小。</p><p id="07bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我觉得这样比较合理，因为队列中的连接最多只需要等待线程处理一个任务，不会等待太久，响应时间也不会太长。</p><p id="c743" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果想缩短响应时间，可以将<code class="fe ln lo lp lq b">maxConnections</code>调得比<code class="fe ln lo lp lq b">maxThreads</code>低一些，这样可以减少一些响应时间。</p><p id="eabe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但需要注意的是，如果降得太低，可能会严重降低性能，降低吞吐量。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="cf5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">接受计数。</strong></p><p id="1c16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ln lo lp lq b">acceptCount</code>指容器线程池达到最大数量且没有空闲线程，连接器队列达到最大数量时，操作系统可以接受的最大连接数。</p><p id="423b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当队列中的数量达到最大值时，所有传入的请求都将被拒绝。默认值为<code class="fe ln lo lp lq b">100</code>。这可以理解为操作系统的一种自我保护机制。如果积累太多处理不了，那就拒绝掉，保护自己的资源。</p><p id="6546" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该参数的调谐数据相对较少，但根据其含义，不建议该值大于<code class="fe ln lo lp lq b">maxConnections</code>。</p><p id="ff9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为该队列中的连接需要等待。如果该值太大，则意味着将有许多连接没有被处理。</p><p id="aaa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">连接数越多，等待时间越长，响应时间越慢。如果您想要更短的响应时间，您可能应该降低这个值。</p><p id="a6c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有些同学会想，我们有了<code class="fe ln lo lp lq b">maxConnections</code>，为什么还需要<code class="fe ln lo lp lq b">acceptCount</code>？这不是复读吗？其实在BIO时代，这两种价值观基本是一致的。</p><p id="b788" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我猜是因为后来<code class="fe ln lo lp lq b">NIO</code>、<code class="fe ln lo lp lq b">AIO</code>等技术的出现，操作系统可以接受更多的客户端连接。</p><p id="8a23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，操作系统可以先建立连接缓存，然后连接器可以直接从操作系统获取连接，这样就不需要等待操作系统进行耗时的TCP连接，从而提高效率。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="1aec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了以上三个参数，还有几个非核心参数，不过我觉得还是有一定作用的。</p><ul class=""><li id="af63" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated"><code class="fe ln lo lp lq b">connectionTimeout</code>:表示连接建立后等待的超时时间。如果超过这个时间，将直接返回超时。</li><li id="c93d" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated"><code class="fe ln lo lp lq b">minSpareThreads</code>:表示存活线程的最小数量，即如果没有请求，那么必须保持存活的线程的最小数量。该参数与是否存在突发流有关。在突发流量的情况下，如果值太低，瞬时响应时间会比较长。</li></ul></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="158d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">总结一下。</strong></p><p id="ec46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天我们分享了Tomcat的核心组件，然后讲解了Tomcat在处理请求时的三个核心参数和调优经验。</p><p id="886b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe ln lo lp lq b">maxThreads</code>参数，如果按照公式计算，我们需要获得IO时间和CPU时间，但实际上这两个值并不容易获得。</p><p id="9c39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以一般来说，我们可以通过压力测试来获得一个比较合适的<code class="fe ln lo lp lq b">maxThreads</code>。</p><p id="cfe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe ln lo lp lq b">maxConnections</code>参数，可以设置一个与<code class="fe ln lo lp lq b">maxThreads</code>相同的值，然后根据具体情况进行调整。</p><p id="6771" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果想减少响应时间，可以稍微关小一点，否则可以开大一点。</p><p id="0a5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe ln lo lp lq b">acceptCount</code>参数，其调谐逻辑类似于<code class="fe ln lo lp lq b">maxConnections</code>，可以设置成类似于<code class="fe ln lo lp lq b">maxConnections</code>，然后根据相应的时间要求进行微调。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="e976" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这样的故事，想支持我，请给我鼓掌。</p><p id="5f98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你的支持对我很重要，谢谢。</p></div></div>    
</body>
</html>