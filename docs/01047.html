<html>
<head>
<title>10 Techniques to Master Coding Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握编码面试问题的10个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/10-techniques-to-master-coding-interview-questions-b3216d3d3920?source=collection_archive---------1-----------------------#2019-10-29">https://levelup.gitconnected.com/10-techniques-to-master-coding-interview-questions-b3216d3d3920?source=collection_archive---------1-----------------------#2019-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8426325521b4741cc50ebf821e9655fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vMVgb2W0qHds6Lxo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">为解决大量的安置问题而烦恼？别担心！尝试这些技术，将帮助您更快地解决大多数问题。</figcaption></figure><h1 id="51ee" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">介绍</h1><p id="9e91" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在经历了今年早些时候的技术面试后，我有了写这篇文章的灵感。在浏览不同公司的相关博客时，我发现有些公司要求在第一轮中找到斐波那契数列的第n个数字。</p><p id="aa2b" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">很自然地，我想知道为什么一家公司会问这样一个简单的问题？到时候大家不都行了吗？他们将如何筛选出候选人？直到我发现第n个斐波那契数可以用公式<code class="fe md me mf mg b">F(n)={[(√5+1)/2]^n}/√5</code>在O(log n) 中求解。它将复杂度从O(n)降低到O(log n)！我们大多数人甚至没有意识到这一点。</p><blockquote class="mh"><p id="3007" class="mi mj iq bd mk ml mm mn mo mp mq lx dk translated">毕竟，不是谁得到正确的解决方案，而是谁得到最优的解决方案！</p></blockquote><p id="11bd" class="pw-post-body-paragraph la lb iq lc b ld mr lf lg lh ms lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">这只是一个简单的例子，但是花在准备解决编码问题上的时间有时会变得相当繁重。由于有大量的话题需要准备，人们经常花时间费力地研究数百个不同的问题(就像我最初做的那样)。最后，一些重要的主题被遗漏了。因此，在这种时候需要一种有组织有系统的方法！</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/16680783a8556574d162d800b76a14ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*dFfNRJ5IqC8JBPhH.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd ke">与其努力学习，不如聪明学习！</strong></figcaption></figure><p id="78d3" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">为了加快这个过程，我创建了这个教程。我在这里巩固了一些技巧(是的，在淘了几百个问题之后，感叹！).它们可用于在更短的时间内以更好的性能解决安置期间的一些常见问题。</p><p id="1729" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">你彻底理解这些方法了吗？那么，你肯定是在坚实的基础上，几乎可以走了！</p><blockquote class="nb nc nd"><p id="0ec1" class="la lb ne lc b ld ly lf lg lh lz lj lk nf ma ln lo ng mb lr ls nh mc lv lw lx ij bi translated">虽然我无法在这篇博客中涵盖所有内容，但对于那些正在经历面试的人，我强烈建议你参考这些书籍——破解编码面试(<a class="ae ni" href="https://www.pdfdrive.com/cracking-the-coding-interview-d52072841.html" rel="noopener ugc nofollow" target="_blank">此处</a>)、探索编码面试(<a class="ae ni" href="https://www.educative.io/collection/5668639101419520/5671464854355968" rel="noopener ugc nofollow" target="_blank">此处</a>)、Narsimha Karumanchi的《数据结构和算法变得简单》(此处<a class="ae ni" href="https://www.docdroid.net/ZPfHmS5/data-structures-and-algorithms-narasimha-karumanchi.pdf" rel="noopener ugc nofollow" target="_blank">此处</a>)。当然还有一个我在准备时发现非常有用的网站，<a class="ae ni" href="https://www.geeksforgeeks.org/company-interview-corner/" rel="noopener ugc nofollow" target="_blank"> GeeksForGeeks </a>。</p></blockquote><h1 id="27c0" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">1.推拉窗</h1><p id="9a77" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">滑动窗口是一种非常流行的技术，用于在通常大小固定的子数组或子串上执行操作。<br/> <strong class="lc ir">将时间复杂度降低到O(n) </strong>。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/0be92f58405dda793d77f60b53611de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*0BP5ffOsjx4CnzAy-q788A.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:搜索编码面试</figcaption></figure><h2 id="db1f" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated">推拉窗的常见问题:</h2><p id="b0a9" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir"> (i) Kadane的算法:</strong> <br/>大小为<code class="fe md me mf mg b">k</code>的最大和子阵列或要移除的最小元素数，使得剩余元素的和等于<code class="fe md me mf mg b">k</code> — <br/>该循环迭代<code class="fe md me mf mg b">(n-k)</code>次。首先计算从索引0到<code class="fe md me mf mg b">kth</code>元素的元素之和，并存储在一个变量中(<code class="fe md me mf mg b">sum</code>)。每次窗口滑动1个元素，减去现有窗口的第一个元素，并在新窗口中添加<code class="fe md me mf mg b">(k+1)th</code>元素。</p><p id="65e5" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (ii) </strong>尺寸为k的最小乘积子阵列</p><p id="a51f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (ii) </strong>具有k个不同字符的最长子串</p><p id="ef2b" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iii) </strong>作为另一个字符串的任何子字符串的变位词的子字符串的数目</p><blockquote class="nb nc nd"><p id="7641" class="la lb ne lc b ld ly lf lg lh lz lj lk nf ma ln lo ng mb lr ls nh mc lv lw lx ij bi translated">注意:窗口的大小可能是固定的，也可能不是固定的。我们可以根据问题的要求修改窗口大小。</p></blockquote><h1 id="fe71" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> 2。慢速指针和快速指针(弗洛伊德循环寻找算法):</strong></h1><p id="7008" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">一个非常喜欢在面试中被问到的问题！这种技术主要用于与链表相关的问题。它使用两个指针，一个慢速指针和一个快速指针。每当慢速指针移动一个节点，快速指针就移动两个节点。<br/> <strong class="lc ir">它把时间复杂度降低了一半。</strong></p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/f4749c62a137c5d3e98f0b6091db69f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ICegWsQQtZYvcdZJ1SrNQ.png"/></div></div></figure><h2 id="ede3" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated">使用快速和慢速指针的常见问题:</h2><p id="ebce" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir"> (i) </strong>检查链表是否为回文:使用快指针和慢指针遍历链表。直到快速指针到达链表的末尾，将慢速指针访问的每个元素推入堆栈。慢速指针现在将到达中间元素，并且堆栈将具有从第一个到中间的逆序的所有元素</p><p id="0ba8" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (ii) </strong>检测链表中的循环:如果快速指针在任意一点变得与慢速指针相等，则链表中存在循环</p><p id="d03b" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iii) </strong>在链表中寻找中间节点:当快指针到达链表的末尾时，慢指针将已经到达中间节点。</p><p id="3eaf" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iv) </strong>寻找一个快乐的数字:如果一个数字在一系列步骤之后导致1，其中每个步骤的数字被其数字的平方和代替，则该数字被称为“快乐”。</p><h1 id="7843" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">3.在中间相遇</h1><p id="0a9e" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">“折中”是一种技术，它将一个问题分成大小相等的两个部分，解决它们，然后将两个部分的相应结果合并在一起，得到一个整体最优解。当两个解决方案的合并是一个<strong class="lc ir">聚合函数</strong>，如<strong class="lc ir"> count，sum，max </strong>时，可以执行该操作。它可以用于线性数据结构。</p><h2 id="a874" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated">雇主的常见问题是折中的:</h2><p id="f40c" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir"> (i) </strong>寻找给定乘积的所有三元组:使用三个指针。对于每次迭代，指针1保持固定在n(其中n =初始大小-1)。指针2位于第0个位置，指针3位于(大小为2)的位置。这将检查ptr2和ptr3处的元素是否给出ptr1处的相应元素作为结果。ptr1每次递减1，直到找到三元组。这又需要O(n)。使用散列法可以将其降低到O(n)。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/58755595b470b62363c8648237f38117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jkdemJTEsu7F_soSHgZNA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用给定的乘积寻找三元组</figcaption></figure><p id="592d" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">(二)</strong>寻找毕达哥拉斯的三胞胎</p><p id="5b49" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iii) </strong>从一个数组中找出两个数相加得到一个给定的和s。这需要O(n)。</p><p id="4879" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iv) </strong>在不重新排列的情况下，构成字符串回文的最小追加数</p><h1 id="e5bb" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">4.散列法</h1><p id="8dd2" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这是降低时间复杂度的另一个极其重要的技巧！但是请记住，它会导致额外空间的使用。哈希表用于将键与值相关联。它用于快速存储和检索信息。</p><p id="72c0" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">时间复杂度:</strong>虽然<strong class="lc ir">哈希算法最坏情况下的时间复杂度是O(n)，但它平均给出O(1)。</strong></p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/8498773c448c41b0db696fba097da4af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MPwR73RPLtDoiQ4v.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">散列函数计算值的索引后，值被映射到桶中</figcaption></figure><h2 id="0c93" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated">哈希下的常见问题:</h2><p id="356d" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir"> (i) </strong>从数组中寻找重复和缺失的元素:使用大小为256的整数数组(<code class="fe md me mf mg b">arr[256]</code>)。对数组进行迭代，对于每个元素，将对应于元素的ASCII值的数组索引处的值增加1 ( <code class="fe md me mf mg b">arr[ASCII value of element]+=1</code>)。遍历新数组，当值大于1时，该ASCII值处的元素将重复，当值为0时，对应于该ASCII值的元素将丢失。</p><p id="5873" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">从一个a字符串中删除重复项</p><p id="2b68" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iii) </strong>检查链表中的循环</p><p id="bf02" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iv) </strong>从一个字符串中删除存在于另一个字符串中的字符</p><p id="51f4" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (v) </strong>从一个和为s的数组中找出所有的对，这需要O(n)的时间复杂度。</p><h1 id="6995" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> 5。堆栈和队列</strong></h1><p id="31c4" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这是我们大多数人都非常熟悉的东西。为了唤起你的记忆，栈是一种遵循<strong class="lc ir"> LIFO(后进先出)</strong>原则的数据结构，最后进入的元素最先出来。另一方面，队列是一种遵循<strong class="lc ir"> FIFO(先进先出)</strong>原则的数据结构。使用堆栈和队列的概念可以解决许多问题。</p><h2 id="d025" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated"><strong class="ak">堆栈和队列常见问题:</strong></h2><p id="d22c" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">使用堆栈实现队列</p><p id="062c" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (ii) </strong>使用临时堆栈对堆栈进行排序</p><p id="009d" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iii) </strong>中缀、前缀和后缀形式之间的转换</p><p id="e3f1" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iv) </strong>检查表达式中的平衡括号</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/59f5018183d36d4bfa78e9c3704114a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-wAHzA3m5z-y3FbE.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:GeeksforGeeks</figcaption></figure><p id="f970" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (v) </strong>股票跨度问题</p><p id="85d2" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">(六)</strong>名人问题</p><p id="609d" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (vii) </strong> LRU缓存使用队列实现</p><p id="eb4c" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (viii) </strong>使用优先级队列找到3个元素的最大值</p><h1 id="3dae" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">6。广度优先搜索(BFS)或层次顺序遍历(树):</h1><p id="775b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">使用层次顺序遍历可以解决树的许多问题。是的，这是面试中另一个最受欢迎的问题！</p><p id="d732" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">树的层次顺序遍历只不过是树的广度优先遍历。它从根节点开始逐层遍历树的所有节点。图形的BFS也以类似的方式工作。只有在这里，第(n+1)层的顶点是第n层节点的所有相邻的<strong class="lc ir">未访问的</strong>邻居。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9f2a652c9af2dfe49355290f780854c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*9tTcPHrubtLhC3KovQc6NQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd ke">对上图的BFS遍历:A B D C E </strong></figcaption></figure><p id="1a68" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">一般来说，队列用于存储图形和树的顶点。你可以用这种方法来解决所有那些需要一个接一个处理级别的问题。</p><p id="2d4d" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">时间复杂度</strong> — O(n)其中n是树中节点的数量。</p><h2 id="94c9" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated"><strong class="ak">树的层次顺序遍历常见问题:</strong></h2><p id="faff" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir"> (i) </strong>之字形层次顺序遍历一个BST。需要O(n)额外空间。</p><p id="7deb" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (ii) </strong>寻找二叉树的深度/寻找距离为k的所有节点</p><p id="00b3" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iii) </strong>寻找二叉树中节点的有序后继</p><p id="de21" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iv) </strong>求BT中每个级别的平均值</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用于查找二叉树中每一层的平均值的函数</figcaption></figure><p id="2ef9" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (v) </strong>连接所有级别顺序的同级。时间复杂度是O(n ),其中n是节点的数量。</p><h2 id="bf4f" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated"><strong class="ak">图的层次顺序遍历常见问题:</strong></h2><p id="8210" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir"> (vi) </strong>无向图中的圈检测:如果所有顶点都是可达的，则该图是连通的。如果任何节点保持标记为未访问，那么它是不可访问的。</p><p id="e806" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (vii) </strong>单词阶梯:从给定单词开始，遍历其所有邻居(相差1个字符的单词)。重复这一过程，直到找到目标单词或遍历完所有单词。</p><p id="788c" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (viii) </strong>腐烂一格中所有橙子所用的时间</p><p id="5034" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (ix) </strong>迷宫中到达目的地的方法有多少种</p><p id="b37c" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">时间复杂度</strong> — O(V+E)其中V是图中顶点的个数，E是图中边的个数。</p><h2 id="ed8e" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated"><strong class="ak">问:检查一个图是否是树:</strong></h2><p id="1338" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">无向图是树如果— <br/> (i)没有圈— O(V+E) <br/> (ii)图是连通的—O(V)<br/>总时间复杂度— O(V+E) <br/>由于图是无向图，所以可以用BFS，也可以用DFS。</p><h1 id="0db4" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> 7。深度优先搜索(DFS) </strong></h1><p id="667b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">它用于遍历树和图。该算法从根节点开始(在图的情况下选择一些任意节点作为根节点),并在回溯之前沿着每个分支尽可能远地探索。<br/> —维基百科</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9f2a652c9af2dfe49355290f780854c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*9tTcPHrubtLhC3KovQc6NQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd ke">上图的DFS遍历:A B C D E </strong></figcaption></figure><h2 id="fb62" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated">DFS下的常见问题有:</h2><p id="0ff5" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir"> (i) </strong>检测图形中的周期</p><p id="57c5" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">(二)</strong>迷宫中到达目的地的方法有多少种</p><p id="f4f7" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iii) </strong>寻找图的强连通分量— O(V+E)</p><p id="a11f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iv) </strong>寻找从给定节点可到达的所有节点</p><p id="a8eb" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">检查一个图是否是二分的</p><h1 id="fdcc" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">8。二进制堆</h1><p id="4422" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这是一个完整的树，其中每个父节点的值要么更大(对于MaxHeap)要么更小(对于MinHeap ),并且该属性对所有节点都成立。</p><p id="38fe" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">为什么使用堆来解决问题？时间的复杂性！</strong> <br/>获得最小或最大元素需要O(1)，与O(n)相比，这是一个显著的减少。堆排序的时间复杂度为O(n log n)。像提取最小元素、插入或删除键这样的操作需要O(log n)。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e8bdf5e326273c5452cc11efdfae4f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*IJHC2JHYn3kfhQOBiMxEtg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd ke">最大堆</strong></figcaption></figure><blockquote class="nb nc nd"><p id="dd4d" class="la lb ne lc b ld ly lf lg lh lz lj lk nf ma ln lo ng mb lr ls nh mc lv lw lx ij bi translated">注意:<br/>堆不遵循二叉查找树的规则。在堆中，左兄弟可能比右兄弟小，也可能不比右兄弟小。</p></blockquote><h2 id="bc24" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated">使用堆的常见问题有:</h2><p id="11ae" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir"> (i) </strong>实现优先级队列(也可用于使用二项式堆执行更快的联合操作)</p><p id="3a6f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (ii) </strong>查找数组中第k个最大或最小的元素</p><p id="ac3f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iii) </strong>对一个几乎排序好的数组进行排序</p><p id="1f30" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iv) </strong>合并k个排序后的数组</p><h1 id="76b3" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> 9。二分搜索法</strong></h1><p id="3319" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这是一种我们都非常熟悉的技术。但是不应该掉以轻心，因为对于大多数被问到的问题，你将不得不稍微修改一下传统的二分搜索法。所以，如果你在面试前先试着回答几个关于改良二分搜索法的问题会更好。</p><p id="852f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">简单概括一下，二分搜索法通过将一个元素分成两半来寻找一个排序数组中的元素。如果键大于中间的元素，值可能在数组的右半部分，否则可能在左半部分。</p><p id="566b" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">时间复杂度:</strong>在最坏的情况下，给出了O(log n)的时间复杂度。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">二进位检索</figcaption></figure><p id="0803" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">对二分搜索法稍加修改就能帮助解决许多问题。</p><h2 id="64d9" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated">二分搜索法面临的常见问题:</h2><p id="e814" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir"> (i) </strong>在排序旋转后的数组中查找元素</p><p id="a40f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (ii) </strong>大于/小于给定数字的最小元素的索引</p><p id="b773" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iii) </strong>寻找矩阵中具有最大和最小数量的零的行</p><p id="c912" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iv) </strong>数组中第k个最小的元素使用常数空间</p><p id="6b4b" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (v) </strong>将一个数组拆分成K个子数组，使得所有子数组的最大和最小</p><h1 id="0176" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> 10。合并k个数组</strong></h1><p id="b298" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这包括从所有k个数组中找到最小元素。可以使用堆来找到最小元素，如在第8点中已经讨论过的，或者通过使用锦标赛树或展曲树来找到最小元素，所有这些都在<strong class="lc ir"> O(log k) </strong>中。然后，最小元素被下一个最小元素重复替换。</p><p id="a19e" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">时间复杂度:</strong>得到的运行时间为<strong class="lc ir"> O(n log k)。</strong></p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/f8e6206599b7280107d50c5a4f2662d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LWIrs_DZJBCvB2XX4k-J4A.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:谷歌k-way合并图片</figcaption></figure><h2 id="33b8" class="nk kd iq bd ke nl nm dn ki nn no dp km ll np nq kq lp nr ns ku lt nt nu ky nv bi translated">k路合并下的常见问题有:</h2><p id="7989" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir"> (i) </strong>合并k个大小相同的排序数组:将所有子数组的第一个元素插入一个min堆中。将堆的最小元素放入另一个数组。然后用数组中的下一个元素替换堆的根。重复这(nk)次。</p><p id="1134" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (ii) </strong>合并k个不同大小的排序数组</p><p id="2e20" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> (iii) </strong>寻找相邻子阵列的中间值</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><blockquote class="nb nc nd"><p id="f0bd" class="la lb ne lc b ld ly lf lg lh lz lj lk nf ma ln lo ng mb lr ls nh mc lv lw lx ij bi translated">仅此而已！感谢您一路阅读！请留下您的反馈。如果你喜欢这个博客，请留下一些掌声👏太。</p><p id="821e" class="la lb ne lc b ld ly lf lg lh lz lj lk nf ma ln lo ng mb lr ls nh mc lv lw lx ij bi translated">你可以在—<br/>LinkedIn:<a class="ae ni" href="https://www.linkedin.com/in/spreehadutta/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/spreehadutta/</a><br/>Twitter:<a class="ae ni" href="https://twitter.com/DuttaSpreeha" rel="noopener ugc nofollow" target="_blank">https://twitter.com/DuttaSpreeha</a>与我联系</p></blockquote></div></div>    
</body>
</html>