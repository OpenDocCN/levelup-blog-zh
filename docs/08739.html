<html>
<head>
<title>Implementing worker queues for processing datasets in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中实现用于处理数据集的工作队列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-worker-queues-for-processing-datasets-in-node-js-8f060d434b91?source=collection_archive---------12-----------------------#2021-05-31">https://levelup.gitconnected.com/implementing-worker-queues-for-processing-datasets-in-node-js-8f060d434b91?source=collection_archive---------12-----------------------#2021-05-31</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/4c94b240d045772d12a26b252c815be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qgywkV-2Zl391YVU.jpg"/></div></div><figcaption class="kc kd gk gi gj ke kf bd b be z dk translated">图片由作者大卫·赫伦提供</figcaption></figure><p id="3a05" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">处理大型数据集可以通过简单的<em class="le"> for </em>循环来完成。但是，一次处理一个数据项消除了并行处理数据可能带来的效率提升。但是，并行处理是不可伸缩的，因为它很容易淹没CPU或内存资源。Worker queue包通过限制同时执行的并行任务的数量来提供帮助。</p><p id="0255" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">有时我们有大量的任务，例如处理数百个图像文件。总的想法是输入数据集，其中您需要对一些或所有数据项应用转换。这是<em class="le">地图</em>图案，但是比例比正常的要大。</p><p id="dd56" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">一个用例是在<em class="le">机器学习</em>阶段，在训练模型之前，收集训练和测试数据。你可能有一百万张图像，对于每张图像，你应用视觉算法来识别图像的特征。这些特征被转化成数字，这些数字实际上被用于训练模型中。</p><p id="dfbf" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">在我的例子中，我开发了一个静态网站生成工具AkashaCMS，其中的工作是将Markdown或Nunjucks模板之类的输入文件渲染到网站的HTML中。我使用AkashaCMS来发布这个站点(TechSparx)和其他几个站点。这个站点上有超过1500个页面，这意味着重新生成站点会呈现所有1500+个页面。AkashaCMS内部有一个循环，它首先找到所有的内容文件，然后一个接一个地将内容呈现为HTML。为了提高AkashaCMS的性能，我用一个工作队列替换了那个循环。</p><p id="a80f" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">处理大型数据集可以通过工作队列来完成。您的程序将任务添加到队列中，队列管理模块调度任务执行，并交付结果。管理模块约束同时执行的任务，以避免淹没系统。</p><p id="0bfd" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">有一个缩放的问题。您希望数据集的处理速度有多快？您想分配多少个CPU？分布式任务队列可以将工作分散到多台计算机上。有了足够多的计算机，数据集可以在瞬间得到处理。但是分布式任务队列更复杂，在本教程中，我们将重点关注内存中的工作队列，它将所有内容保持在传统Node.js事件队列的边界内。</p><h1 id="4621" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">数据集处理101</h1><p id="5d96" class="pw-post-body-paragraph kg kh iu ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld in bi translated">最简单的方法是编写一个简单的循环:</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="d925" class="mr lg iu mn b gz ms mt l mu mv">let array = []; // Fill this array with data to process </span><span id="2d69" class="mr lg iu mn b gz mw mt l mu mv">for (let item of array) {<br/>     processItem(item); <br/>}</span></pre><p id="b043" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">创建和维护这样的循环是很容易的。但是，这是最好的方法吗？例如，<code class="fe mx my mz mn b">processItem</code>步骤可能有暂停，比如从磁盘或数据库读取数据，在此期间工作可以并行化。并行处理项目可能会减少处理所有项目的总时间。</p><p id="10c4" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">记住Node.js最初的灵感是关于处理异步执行的。有一段时间，另一个系统正在处理对数据的异步请求。我们被要求考虑这一陈述:</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="c1b9" class="mr lg iu mn b gz ms mt l mu mv">database.query('SELECT * FROM ...', function(err, result) {<br/>    if (err) handleErrors(err);<br/>    else handleResult(result);<br/>}</span></pre><p id="4568" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">是的，我知道今天这将是一个<code class="fe mx my mz mn b">async</code>函数，我们将使用<code class="fe mx my mz mn b">await</code>。关键是，在调用<code class="fe mx my mz mn b">database.query</code>和调用回调函数之间发生了什么？那可能是几毫秒的时间。对计算机来说，这是一个永恒，在此期间，计算机可以做其他事情。</p><p id="4538" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">对于简单的处理循环，等待来自其他系统的数据是浪费时间。Node.js所做的是返回到事件循环，以便它可以处理其他任务。</p><p id="a748" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">对于上面的简单的一次一个循环，Node.js在等待异步结果时没有机会处理任何其他任务。</p><p id="322c" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">想想静态网站生成任务。呈现每个页面是一项独立的任务。它首先读取一个Markdown文件，然后应用几个模板，将结果写入输出目录。因此，页面可以并行呈现。当renderer循环正在读取一个文件的模板或等待来自数据库的数据时，Node.js事件循环可能正在为另一个页面呈现模板。页面呈现可以很容易地并行化，因为通常一个页面的呈现不依赖于其他页面的呈现。</p><p id="2b66" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">概括的场景是拥有一系列数据对象，其中每个对象都可以独立处理，同时处理其他对象。在这种情况下，可以对每个项目并行运行<code class="fe mx my mz mn b">processItem</code>。</p><p id="3f6d" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">例如，我们可以像这样重写上面的循环:</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="2eb0" class="mr lg iu mn b gz ms mt l mu mv">let items = []; // Fill with data objects<br/>let tasks = [];<br/>for (let item of items) {<br/>     tasks.push(processItemAsync(item)); <br/>}<br/>await new Promise.all(tasks);</span><span id="ab1b" class="mr lg iu mn b gz mw mt l mu mv">async function processItemAsync(item) { ... }</span></pre><p id="9908" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这样做的是在每一项上调用一个异步函数，因此<code class="fe mx my mz mn b">tasks</code>数组被Promise对象填充。这些承诺开始时处于未解决的状态，但是随着任务的完成，它们会翻转到已解决或被拒绝的状态。<code class="fe mx my mz mn b">Promise.all</code>步骤将等待，直到每个承诺都解析为已解析或已拒绝状态。对于任何失败，都会抛出一个错误。</p><p id="c38a" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这也是一个易于编码和维护的简单循环。但是，考虑一下这个网站上的1500+页面，尝试同时生成1500个页面是否可行。不，那不可行。</p><p id="1656" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">相反，最好采取中间立场。也就是说，要有某种任务管理器来维护最大数量的同时处理任务，同时确保所有任务完成，并处理任何抛出的错误。</p><p id="d04b" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">例如，我们可能会想，我们有一个<code class="fe mx my mz mn b">items</code>数组，我们将来自<code class="fe mx my mz mn b">processItemAsync</code>的承诺推入到一个<code class="fe mx my mz mn b">workers</code>数组中，确保该数组中最多有10个项目，并且一旦有任何项目完成，就将另一个工作线程排入队列。但是，当你试图解决这个问题时，你的眼睛开始被细节和潜在的复杂情况所迷惑。</p><p id="3596" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">幸运的是，我们的前辈程序员已经认识到了这一需求，并编写了解决方案。在本教程中，我们将研究两个这样的Node.js库，<em class="le"> FastQ </em>和<em class="le"> Better Queue </em>。</p><h1 id="78d8" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用fastq构建任务队列</h1><p id="7dd3" class="pw-post-body-paragraph kg kh iu ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld in bi translated">在内存工作队列中，<a class="ae na" href="https://www.npmjs.com/package/fastq" rel="noopener ugc nofollow" target="_blank"> fastq </a>包将自己标记为<em class="le"> Fast。</em>文章包括性能声明，表明它比其他替代产品更快。</p><p id="9141" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">需要了解的一件事情是，这个包是33kb的，并且只有一个依赖项。换句话说，它不会导致膨胀。</p><p id="34b6" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">为了用<em class="le"> FastQ </em>建立一个处理队列，我们这样做:</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="0c76" class="mr lg iu mn b gz ms mt l mu mv">const fastq = require('fastq').promise;<br/>let concurrency = 10;<br/>async function worker(item) {<br/>     ...<br/>     return processedItem;<br/>}</span><span id="5828" class="mr lg iu mn b gz mw mt l mu mv">const queue = fastq(worker, concurrency);</span></pre><p id="0ad6" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">也就是说，我们传入一个<em class="le">工作器</em>函数以及一个<em class="le">并发</em>配置。对于每个推入队列的项，调用一次worker函数。顾名思义，并发设置决定了有多少工作线程将同时执行。</p><p id="a7da" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们来试一个具体的例子。我们将用ES6模块来编写这个，这样我们就可以使用<a class="ae na" href="https://techsparx.com/nodejs/async/top-level-async.html" rel="noopener ugc nofollow" target="_blank">顶级</a> <code class="fe mx my mz mn b"><a class="ae na" href="https://techsparx.com/nodejs/async/top-level-async.html" rel="noopener ugc nofollow" target="_blank">async</a></code> <a class="ae na" href="https://techsparx.com/nodejs/async/top-level-async.html" rel="noopener ugc nofollow" target="_blank"> / </a> <code class="fe mx my mz mn b"><a class="ae na" href="https://techsparx.com/nodejs/async/top-level-async.html" rel="noopener ugc nofollow" target="_blank">await</a></code> <a class="ae na" href="https://techsparx.com/nodejs/async/top-level-async.html" rel="noopener ugc nofollow" target="_blank">语句</a>。将此另存为<code class="fe mx my mz mn b">fq.mjs</code>，用Node.js 14.8或更高版本运行。</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="5142" class="mr lg iu mn b gz ms mt l mu mv">import { promise as fastq } from 'fastq';</span><span id="8070" class="mr lg iu mn b gz mw mt l mu mv">let concurrency = 5;</span><span id="e8c9" class="mr lg iu mn b gz mw mt l mu mv">async function worker(item) {<br/>     return await new Promise((resolve, reject) =&gt; {<br/>         setTimeout(() =&gt; { resolve(item * 2); }, 1000);<br/>     });<br/>}</span><span id="b133" class="mr lg iu mn b gz mw mt l mu mv">const queue = fastq(worker, concurrency);<br/>const tasks = [];<br/>for (let item of [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]) {<br/>     tasks.push(queue.push(item));<br/>}<br/>await Promise.all(tasks);<br/>console.log(tasks);</span><span id="0955" class="mr lg iu mn b gz mw mt l mu mv">const results = [];<br/>for (let result of tasks) {<br/>     results.push(await result);<br/>}<br/>console.log(results);</span></pre><p id="3922" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">worker函数通过使用<code class="fe mx my mz mn b">setTimeout</code>函数模拟一个长时间运行的任务。函数结果是一个简单的数学计算。</p><p id="fff2" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们使用<code class="fe mx my mz mn b">queue.push</code>将数字添加到要处理的队列中。在我们正在使用的FastQ的Promises版本中，<code class="fe mx my mz mn b">queue.push</code>函数返回一个承诺。当任务完成时，Promise解析为从worker函数返回的任何值。这意味着<code class="fe mx my mz mn b">tasks</code>数组充满了Promise对象。</p><p id="21da" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们用<code class="fe mx my mz mn b">Promise.all</code>等待每一个承诺的解决。这使得<code class="fe mx my mz mn b">tasks</code>数组充满了已经被解析的Promise对象。</p><p id="ffef" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">下一个循环只是将每个Promise对象的值提取到一个新数组中，<code class="fe mx my mz mn b">results</code>。</p><p id="10df" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">结果看起来像这样:</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="ab1f" class="mr lg iu mn b gz ms mt l mu mv">$ node fq.mjs<br/>[<br/>   Promise { 2 },<br/>   Promise { 4 },<br/>   Promise { 6 },<br/>   Promise { 8 },<br/>   Promise { 10 },<br/>   Promise { 12 },<br/>   Promise { 14 },<br/>   Promise { 16 },<br/>   Promise { 18 },<br/>   Promise { 20 }<br/>]<br/>[    2,  4,  6,  8, 10,<br/>   12, 14, 16, 18, 20 <br/>]</span></pre><p id="453f" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">第一个数组确实填充了已解析的Promise对象，第二个数组包含每个Promise的值。</p><p id="493f" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">进一步考虑这个问题，试着注释掉第<code class="fe mx my mz mn b">Promise.all</code>行和紧随其后的第<code class="fe mx my mz mn b">console.log</code>行。在<code class="fe mx my mz mn b">tasks</code>数组上的循环等同于<code class="fe mx my mz mn b">Promise.all</code>将要做的，不需要第二步。</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="05de" class="mr lg iu mn b gz ms mt l mu mv">const tasks = [];<br/>for (let item of [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]) {<br/>         tasks.push(queue.push(item));<br/>}<br/>// await Promise.all(tasks);<br/>// console.log(tasks);</span><span id="5d5f" class="mr lg iu mn b gz mw mt l mu mv">const results = [];<br/>for (let result of tasks) {<br/>     results.push(await result);<br/>}<br/>console.log(results);</span></pre><p id="fa60" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这个循环等待每个承诺被解决，这正是<code class="fe mx my mz mn b">Promise.all</code>所做的。因此使用<code class="fe mx my mz mn b">Promise.all</code>等待任务完成是多余的，这个循环也等待任务完成。</p><p id="1891" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这让我们可以一步直接检索结果:</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="8c57" class="mr lg iu mn b gz ms mt l mu mv">$ node fq.mjs<br/>[<br/>    2,  4,  6,  8, 10,<br/>   12, 14, 16, 18, 20 <br/>]</span></pre><p id="a598" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我们已经展示了FastQ易于使用，并且能够处理几个相同的任务。我已经在AkashaCMS中编写了一个几乎相同的循环，并可以验证它确实可以在更复杂的应用程序中工作。</p><h1 id="a726" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用更好的队列构建任务队列</h1><p id="c69c" class="pw-post-body-paragraph kg kh iu ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld in bi translated">另一个队列处理器包是<a class="ae na" href="https://www.npmjs.com/package/better-queue" rel="noopener ugc nofollow" target="_blank"><em class="le">Better queue</em></a>。正如你可能想象的那样，它被描述为更好，能够处理更复杂的情况。</p><p id="bea5" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">全面的特性集也意味着Better Queue更大，达到78千字节，并且它有三个依赖项。这不完全是膨胀，但比FastQ要大。</p><p id="68c4" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">API使用老式的回调方法，而不是新的<code class="fe mx my mz mn b">async</code> / <code class="fe mx my mz mn b">await</code>方法。为了了解这意味着什么，让我们来看一个与前一个例子相当的例子:</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="49db" class="mr lg iu mn b gz ms mt l mu mv">import Queue from 'better-queue';</span><span id="dc2e" class="mr lg iu mn b gz mw mt l mu mv">function worker(item, cb) {<br/>     setTimeout(() =&gt; { cb(undefined, item * 2); }, 1000);<br/>}</span><span id="2469" class="mr lg iu mn b gz mw mt l mu mv">const queue = new Queue(worker, { concurrent: 5 });</span><span id="a064" class="mr lg iu mn b gz mw mt l mu mv">const finished = new Promise((resolve, reject) =&gt; {<br/>     queue.on('drain', function() { resolve(); });<br/>});<br/>await new Promise((resolve, reject) =&gt; {<br/>     queue.on('task_failed', function (taskId, err, stats) {<br/>         reject(err);<br/>     });<br/>});</span><span id="aaa5" class="mr lg iu mn b gz mw mt l mu mv">const results = [];<br/>queue.on('task_finish', function(taskId, result, stats) {<br/>     results.push(result);<br/>});</span><span id="7f38" class="mr lg iu mn b gz mw mt l mu mv">for (let item of [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]) {<br/>     queue.push(item);<br/>}</span><span id="01e6" class="mr lg iu mn b gz mw mt l mu mv">await finished;</span><span id="262b" class="mr lg iu mn b gz mw mt l mu mv">console.log(results);</span></pre><p id="212c" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">在<code class="fe mx my mz mn b">cb</code>参数中，worker函数需要接受一个回调函数。<code class="fe mx my mz mn b">cb</code>的签名有一个<code class="fe mx my mz mn b">error</code>指示器作为第一个参数，结果作为第二个参数。</p><p id="2934" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">创建队列时，第一个参数是worker函数，第二个是options对象。有一个很长的选项列表，这是为什么Better Queue团队可以正确地说他们支持复杂操作的部分原因。</p><p id="0075" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">最终的对象支持事件监听器，你可以看到我们使用了三个— <code class="fe mx my mz mn b">drain</code>、<code class="fe mx my mz mn b">task_failed</code>和<code class="fe mx my mz mn b">task_finish</code>。当队列被完全处理时，触发<code class="fe mx my mz mn b">drain</code>事件。我们在这里所做的是建立一个Promise对象，当<code class="fe mx my mz mn b">drain</code>事件触发时，这个对象将被解析。当其中一个任务发生错误时，触发<code class="fe mx my mz mn b">task_failed</code>事件。我们已经用Promise包装器对此进行了配置，因此错误会出现在我们的应用程序中。顾名思义，<code class="fe mx my mz mn b">task_finish</code>函数在每个任务完成时触发。我们用它将结果推入<code class="fe mx my mz mn b">results</code>数组。</p><p id="9f6d" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">除了这个事件处理程序之外，API没有提供收集结果的方法。</p><p id="ccb1" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">接下来，我们使用一个简单的<code class="fe mx my mz mn b">for</code>循环调用<code class="fe mx my mz mn b">queue.push</code>，将工作推入队列。因为<code class="fe mx my mz mn b">queue.push</code>返回一个发出事件的任务对象，我们可以用一个承诺包装器来重新构造它。该包装器将捕获<code class="fe mx my mz mn b">failed</code>或<code class="fe mx my mz mn b">finish</code>事件，并以不同的方式捕获结果(或失败)。</p><p id="1dc9" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">语句<code class="fe mx my mz mn b">await finished</code>是指当<code class="fe mx my mz mn b">drain</code>事件被触发时将触发的承诺。换句话说，脚本将一直等到承诺兑现，这意味着所有任务都已完成，并且所有<code class="fe mx my mz mn b">task_finish</code>事件都已触发。此时，<code class="fe mx my mz mn b">results</code>数组应该已经被数据填充。</p><p id="53cc" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">要运行脚本:</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="a103" class="mr lg iu mn b gz ms mt l mu mv">$ node bq.mjs  <br/>[<br/>    2,  4,  6,  8, 10,<br/>   12, 14, 16, 18, 20 <br/>]</span></pre><p id="8e7f" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">事实上，我们得到了预期的输出。</p><p id="2129" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这里有一个受前面讨论启发的替代实现:</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="7bbb" class="mr lg iu mn b gz ms mt l mu mv">import Queue from 'better-queue';</span><span id="72ff" class="mr lg iu mn b gz mw mt l mu mv">function worker(item, cb) {<br/>     setTimeout(() =&gt; { cb(undefined, item * 2); }, 1000); <br/>}</span><span id="7c4e" class="mr lg iu mn b gz mw mt l mu mv">const queue = new Queue(worker, { concurrent: 5 });</span><span id="7294" class="mr lg iu mn b gz mw mt l mu mv">const tasks = [];<br/>for (let item of [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]) {<br/>     let task = queue.push(item);<br/>     tasks.push(new Promise((resolve, reject) =&gt; {<br/>         task.on('failed', function(err) { reject(err); });<br/>         task.on('finish', function(result) { resolve(result); });<br/>     }))<br/>}</span><span id="032a" class="mr lg iu mn b gz mw mt l mu mv">const results = [];<br/>for (let result of tasks) {<br/>     results.push(await result);<br/>}<br/>console.log(results);</span></pre><p id="2a18" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这种实现可能更容易理解和维护。</p><p id="f128" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><code class="fe mx my mz mn b">tasks</code>数组现在包含一个对应于队列中每个任务的Promise对象。对于成功的任务，结果存储在承诺中，否则存储错误。与FastQ示例一样，第二个循环等待所有任务完成，并从每个承诺中检索结果。</p><p id="c081" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">结果是一样的:</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="bc33" class="mr lg iu mn b gz ms mt l mu mv">$ node bq.mjs  <br/>[<br/>    2,  4,  6,  8, 10,<br/>   12, 14, 16, 18, 20 <br/>]</span></pre><p id="806c" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这表明Better Queue为组织如何使用队列提供了许多选项。您需要过滤添加到队列中的项目，还是拒绝处理某些项目？更好的队列允许您配置这些行为中的任何一个，以及更多。</p><h1 id="8538" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="7e2a" class="pw-post-body-paragraph kg kh iu ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld in bi translated">在本教程中，我们学习了两个可以帮助应用程序处理大型数据集的包。虽然可以使用简单的循环来处理数据集，但显然可以通过并行运行任务来减少所需的总时间。</p><p id="e7b7" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">例如，在并发度为<code class="fe mx my mz mn b">1</code>(无并行执行)的AkashaCMS中，处理一个测试网站需要32秒，并发度为<code class="fe mx my mz mn b">10</code>的需要9秒。</p><p id="fced" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">让我们用FastQ例子来尝试同样的区别。</p><pre class="mi mj mk ml gu mm mn mo mp aw mq bi"><span id="f02b" class="mr lg iu mn b gz ms mt l mu mv">$ time node fq.mjs  <br/>[    2,  4,  6,  8, 10,<br/>   12, 14, 16, 18, 20 <br/>]</span><span id="7697" class="mr lg iu mn b gz mw mt l mu mv">real    0m10.573s<br/>user    0m0.120s<br/>sys     0m0.029s</span><span id="a90b" class="mr lg iu mn b gz mw mt l mu mv">$ time node fq.mjs  <br/>[<br/>    2,  4,  6,  8, 10,<br/>   12, 14, 16, 18, 20<br/>]</span><span id="0972" class="mr lg iu mn b gz mw mt l mu mv">real    0m1.255s<br/>user    0m0.110s<br/>sys     0m0.028s</span></pre><p id="1295" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">第一次计时是将<code class="fe mx my mz mn b">concurrency</code>设置为<code class="fe mx my mz mn b">1</code>，这意味着没有并行执行。请记住，工人功能包括1秒钟的延迟。因此，这里显示的时间，大约10秒，与执行<code class="fe mx my mz mn b">10</code>任务是一致的。第二个计时是将<code class="fe mx my mz mn b">concurrency</code>设置为<code class="fe mx my mz mn b">10</code>，这允许最多十个任务并行执行。这里显示的时间也与并行执行10个任务一致。</p><p id="2764" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">在现实环境中，任务需要执行大量的工作，增加并行性会造成压力。一方面，您的程序可以同时执行并行任务，但另一方面，这会扩大Node.js进程对内存和CPU的影响。最好在不同的并发级别测量您的应用程序，并根据您的需要调整并发性。</p></div><div class="ab cl nb nc hy nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="in io ip iq ir"><p id="884a" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><em class="le">最初发表于</em><a class="ae na" href="https://techsparx.com/nodejs/async/queue-processing.html" rel="noopener ugc nofollow" target="_blank"><em class="le">https://techsparx.com</em></a><em class="le">。</em></p></div><div class="ab cl nb nc hy nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="in io ip iq ir"><h1 id="f18d" class="lf lg iu bd lh li ni lk ll lm nj lo lp lq nk ls lt lu nl lw lx ly nm ma mb mc bi translated">分级编码</h1><p id="2956" class="pw-post-body-paragraph kg kh iu ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld in bi translated">感谢您成为我们社区的一员！<a class="ae na" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank">订阅我们的YouTube频道</a>或者加入<a class="ae na" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iv"> Skilled.dev编码面试课程</strong> </a>。</p><div class="nn no gq gs np nq"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fp"><div class="ns ab nt cl cj nu"><h2 class="bd iv gz z fq nv fs ft nw fv fx it bi translated">编写面试问题+获得开发工作</h2><div class="nx l"><h3 class="bd b gz z fq nv fs ft nw fv fx dk translated">掌握编码面试的过程</h3></div><div class="ny l"><p class="bd b dl z fq nv fs ft nw fv fx dk translated">技术开发</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ka nq"/></div></div></a></div></div></div>    
</body>
</html>