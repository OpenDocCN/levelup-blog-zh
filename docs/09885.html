<html>
<head>
<title>Making a Homing Projectile 2: Targeting Behavior</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制造制导炮弹2:瞄准行为</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/making-a-homing-projectile-2-targeting-behavior-9181e1899097?source=collection_archive---------4-----------------------#2021-09-27">https://levelup.gitconnected.com/making-a-homing-projectile-2-targeting-behavior-9181e1899097?source=collection_archive---------4-----------------------#2021-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c394502b3a304e72203a9682074891a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*c4WyTofP_h6RiTAQPD8pzA.gif"/></div></div></figure><div class=""/><p id="836b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在“寻的炮弹”系列文章的第二部分中，我深入研究了寻的行为。我这篇文章的<strong class="kd jf">目标</strong>是让<em class="kz">的归巢长牙</em>瞄准<em class="kz">最近的</em>敌人。我还想让它在<em class="kz">当前目标</em>被摧毁的情况下找到一个<em class="kz">新目标</em>，并在没有<em class="kz">目标</em>剩余的情况下恢复正常的<em class="kz">直线</em>前进<em class="kz">运动</em>。</p><p id="f69d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里在共享的<strong class="kd jf">弹丸类</strong> <em class="kz">【长牙】</em>中，我将需要一把<strong class="kd jf">变量</strong>。我有一个值为<strong class="kd jf"> 10 </strong>的<strong class="kd jf">速度</strong> <em class="kz">变量</em>，我最终在<strong class="kd jf">检查器</strong>中将它重置为<strong class="kd jf"> 250 </strong>。然后有一个<strong class="kd jf">距离</strong> <em class="kz">变量</em>用来保持寻的炮弹和目标之间的距离。有一个<strong class="kd jf">最近距离</strong> <em class="kz">变量</em>类似地存储目标之间测量的最近距离。这使得<em class="kz">被分配</em>给<strong class="kd jf"> Mathf。无穷大</strong>，将初始距离设置为井…无限！我有一个<strong class="kd jf">转速</strong> <em class="kz">变量</em>，以及一个<strong class="kd jf">弹丸ID </strong> <em class="kz">变量</em>，这就是让我在所有弹丸类型之间共享这个脚本的原因。有一个<strong class="kd jf">有敌方目标</strong> <em class="kz">布尔</em>为<strong class="kd jf">真</strong>或<strong class="kd jf">假</strong>取决于是否有目标参与。<strong class="kd jf">敌人</strong>的<strong class="kd jf">游戏对象</strong> <em class="kz">阵列</em>会储存所有进入游戏场的敌人。然后<strong class="kd jf">变换</strong>变量<em class="kz">变量</em>会存储目标敌人的变换供追击。最后，我有一个<strong class="kd jf">刚体2D </strong> <em class="kz">变量</em>用于抛射体，因为我将用它来移动它。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi la"><img src="../Images/766a6525e1fc82c5949c9db2e5f88285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exNgE5lqRab93lwO4qvsRA.png"/></div></div></figure><p id="e4a8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="kz">无效</em> <strong class="kd jf">开始</strong>中，我检查<strong class="kd jf">弹丸ID </strong>是否为<strong class="kd jf"> 5 </strong> <em class="kz">(归巢长牙)</em>。然后使用<strong class="kd jf"> GetComponent </strong>通过从对象上抓取<strong class="kd jf">rigid body 2d</strong><em class="kz">变量</em>进行赋值。我<strong class="kd jf">空检查</strong>刚体以确保有一个，因为这个脚本需要一个来工作。最后，我把这种<strong class="kd jf">发现敌人目标的</strong> <em class="kz">方法叫做</em>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lf"><img src="../Images/8efba2ad41ece329cce54ac4360ba558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hd5-ccFuoinW9u9GEDFugw.png"/></div></div></figure><p id="651d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">沿着脚本向南移动，我使用一个<strong class="kd jf">固定更新</strong> <em class="kz">方法</em>来移动抛射体，被移动的是使用Unity的<strong class="kd jf">物理</strong>引擎。我再次检查<strong class="kd jf">弹丸ID </strong>为<strong class="kd jf"> 5 </strong>，然后调用<strong class="kd jf">寻的獠牙运动</strong> <em class="kz">方法</em>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lg"><img src="../Images/ff11cf516cca48a80000b4f986c9afd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVtyLpg8UKG8C6rR-YHBVQ.png"/></div></div></figure><p id="fd9d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是在<em class="kz">虚空</em>开始中调用的<strong class="kd jf">发现敌人目标</strong> <em class="kz">方法</em>。为了更深入地研究代码，<strong class="kd jf">有敌人目标</strong> <em class="kz">布尔</em>需要为<strong class="kd jf">假</strong>。如果我已经有了一个目标，我不想再找更多的了。<strong class="kd jf">敌人阵</strong> <em class="kz">变量</em>寻找<strong class="kd jf">敌人</strong>的<strong class="kd jf">标签</strong>的<strong class="kd jf">游戏对象</strong>，我所有的敌人都有。这将在他们进入游戏时将他们聚集到一个数组中。聚集场景中的敌人后，运行一个<strong class="kd jf">foreach</strong>T26】循环来迭代<strong class="kd jf">敌人数组</strong>中的每个<em class="kz">个体</em>敌人<strong class="kd jf">敌人</strong>。然后测量<strong class="kd jf">敌人</strong> <em class="kz">变换</em>位置<strong class="kd jf"> </strong>和<strong class="kd jf">抛射体</strong> <em class="kz">变换</em>位置之间的距离，以分配<strong class="kd jf">距离</strong> <em class="kz">变量</em>的<em class="kz">值</em>。这种计算针对敌人阵列中的每个敌人运行<strong class="kd jf">，因此被称为<em class="kz"> foreach循环！</em>下面的<strong class="kd jf"> if语句</strong>询问，如果<strong class="kd jf">距离</strong> <em class="kz">变量</em>比<strong class="kd jf">最近距离</strong> <em class="kz">变量</em>少<strong class="kd jf">，则可以输入。<strong class="kd jf">最近距离</strong>仍然设置为<strong class="kd jf">无限远</strong>，所以阵中第一个敌人会自动设置为最近。这是通过将<strong class="kd jf">最近距离</strong>的<em class="kz">值</em>指定为<strong class="kd jf">距离</strong>变量<em class="kz">来实现的。随着<strong class="kd jf"> foreach </strong>循环的运行，如果发现另一个敌人比其他敌人距离更近，它将<em class="kz">重新分配</em>最近距离<strong class="kd jf">变量</strong>和<em class="kz">变量</em>为最近的目标之一。找到距离最近的游戏对象后，将<strong class="kd jf">敌人目标</strong> <em class="kz">变量</em>分配给<strong class="kd jf">敌人.变换</strong>，即特定的<em class="kz">局部</em> <strong class="kd jf">敌人</strong> <em class="kz">游戏对象</em>运行通过<em class="kz">循环</em>。既然射弹有了目标，那么<strong class="kd jf">就有了敌人目标</strong> <em class="kz"> bool </em>设置为<strong class="kd jf"> true </strong>来阻止它寻找更多目标。我向最后的<em class="kz">控制台</em>发送一条<strong class="kd jf"> debug.log </strong>消息，告诉我<strong class="kd jf">目标敌人</strong>的<strong class="kd jf">名称</strong>以及到它的<strong class="kd jf">距离</strong>。</em></strong></strong></p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lh"><img src="../Images/da682b5752f1e50a489d6b403ba60a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wLGkt5SlDewg11R1CWhqg.png"/></div></div></figure><p id="753f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在投射物有了一个敌人<em class="kz">转换</em>为目标，我可以进入归航行为了。这里是<strong class="kd jf">寻牙动作</strong> <em class="kz">方法</em>，在<strong class="kd jf">修复更新</strong>中被调用。<strong class="kd jf"> homingTuskRB </strong> <em class="kz">变量</em>用于将对象的<strong class="kd jf">刚体2D </strong>向<em class="kz"/><strong class="kd jf">方向</strong>移动，该方向基于<em class="kz">变换</em>的开始方向。我的抛射体开始向右移动，所以这将在抛射体开始改变方向和旋转后，甚至在没有目标时，保持抛射体在视觉上移动<em class="kz">【向前】</em>。这个运动然后被<em class="kz">乘以<strong class="kd jf">速度</strong> <em class="kz">变量</em>和<strong class="kd jf">增量时间</strong>。我先检查一下<strong class="kd jf">敌方目标</strong>是否为<strong class="kd jf"> null </strong>，因为我不想在追死物体的时候抛出错误。如果目标是活的，射弹使用<strong class="kd jf">敌人目标</strong> <em class="kz">位置</em>减去它自己的<em class="kz">位置</em>来找到目标的<em class="kz">矢量2 </em> <strong class="kd jf">方向</strong>。我的游戏对象<em class="kz">位置</em>是<strong class="kd jf">向量3 </strong>位置，所以我<em class="kz">在计算之前将</em>我的值作为<strong class="kd jf">向量2 </strong>。然后，声明的方向变量被<em class="kz">归一化</em>。<strong class="kd jf">正常化</strong>将保持相同的<em class="kz">方向</em>但保持长度值为<strong class="kd jf"> 1 </strong>。一个<em class="kz">局部</em> <strong class="kd jf">旋转量</strong> <em class="kz">变量</em>介绍。这使用了两个矢量的<strong class="kd jf">叉积</strong>，产生了与两个输入矢量</em>垂直的第三个矢量<strong class="kd jf"/>。正在使用的两个向量是最近分配的<strong class="kd jf">方向</strong> <em class="kz">变量</em>，以及<em class="kz">抛射体的</em>自身的<strong class="kd jf">变换</strong>，再次引用从变换而来的<em class="kz">右</em>方向。Z轴<strong class="kd jf">也需要确认，以使<em class="kz">矢量3 </em>满意。<strong class="kd jf">刚体</strong>将其<strong class="kd jf">角速度</strong>设置为负<em class="kz"/><strong class="kd jf">旋转量</strong>乘以<strong class="kd jf">转速</strong> <em class="kz">变量</em>。一个常规的<strong class="kd jf">矢量3.cross </strong>正旋转<em class="kz">远离</em>目标，因此应用负<strong class="kd jf">值</strong>使其<em class="kz">向</em>目标旋转。最后，再次增加<strong class="kd jf">向右<strong class="kd jf">移动</strong>的速度。</strong></strong></p><p id="5862" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果<strong class="kd jf">敌人目标</strong>为<strong class="kd jf">空</strong>，则触发<strong class="kd jf"> else if </strong>自变量。<strong class="kd jf">有</strong> <strong class="kd jf">敌目标</strong> <em class="kz">变量</em>被设置为<strong class="kd jf">假</strong>，使其能够寻找另一个目标，最近距离<strong class="kd jf">被重置为<strong class="kd jf">无限远</strong>，再次调用<strong class="kd jf">寻找敌目标</strong> <em class="kz">方法</em>。</strong></p><p id="695b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">河豚脊椎边界</strong> <em class="kz">方法</em>如果抛射体从任何方向离开屏幕，都会将其摧毁。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lh"><img src="../Images/37f94e9bbcaf308d68df7a64be50a925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JQDDmfo-804a-WAt3s-xA.png"/></div></div></figure><p id="3a8a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个测试环境剪辑，我用<em class="kz">三个</em> <strong class="kd jf">引导牙</strong>对准<em class="kz">两个</em>敌人。三者都瞄准最近的敌人，直到它被摧毁。他们立即瞄准下一个可用的敌人，最后一发炮弹在没有敌人留下后直接向前移动。值得一提的是，我在<em class="kz">检查器</em>中给了导弹上的<strong class="kd jf">刚体2D </strong>一个<strong class="kd jf">角阻</strong>值<strong class="kd jf"> 2 </strong>。这就是让它在追逐和转弯之后理顺的东西。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c394502b3a304e72203a9682074891a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*c4WyTofP_h6RiTAQPD8pzA.gif"/></div></div></figure><p id="0089" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是常规游戏中玩家被胁迫的最后一个片段。这是所有的归巢行为，所以下次我会在产卵管理器中平衡我的敌人和力量。感谢阅读！</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi li"><img src="../Images/e387aebbcf6c7b221daea4ed3139340b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EXtkhs5XV4TsizTsbD_rCw.gif"/></div></div></figure></div></div>    
</body>
</html>