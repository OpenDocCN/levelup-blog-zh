<html>
<head>
<title>Building a GraphQL API with Koa and the MongoDB native driver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Koa和MongoDB本地驱动程序构建GraphQL API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-graphql-api-with-koa-and-the-mongodb-native-driver-1a76c3930e9b?source=collection_archive---------5-----------------------#2020-03-14">https://levelup.gitconnected.com/building-a-graphql-api-with-koa-and-the-mongodb-native-driver-1a76c3930e9b?source=collection_archive---------5-----------------------#2020-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="70fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然MERN堆栈是构建丰富、响应迅速且可扩展的web应用最常用的模式之一，但堆栈中组成层的灵活性和相对非个性化的特性导致了结构选择的不断变化。</p><p id="b89d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本着用最佳组件选择来减少一些负担的精神，让我们看看如何构建由Node.js框架Koa和MongoDB本地数据库访问驱动程序支持的基于GraphQL的API。不用多说，GraphQL已经宣称自己是API开发的标准，因为它能够增加参数的选择性、服务器端数据转换、API调用到单个端点的优化捆绑，以及传输的整体生产化。</p><p id="6da9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Koa是一个极简的、占用空间小的、精简的样板框架，它可能是从Express中派生出来的，但是通过采用基于异步/承诺的中间件链范式，它擅长于当代Node.js API开发。最后，Mongo原生驱动程序是对这个开发人员方便的堆栈的一个不同寻常的偏离，它有意省略了MongoDB访问的任何中间层ODM。</p><p id="d58f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将从设置和连接MongoDB数据库、Koa框架、用于Koa的GraphQL Apollo服务器和Mongo本地驱动程序开始。我们将在Mongo原生驱动程序上花费最多的时间，以涵盖由原生调用驱动的MongoDB的基本更新/查询操作，并了解MongoDB的强大功能之一，即用于高级查询的聚合管道。</p><p id="434f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以事不宜迟，让我们开始安装组件。</p><h2 id="a9b7" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">软先决条件:</h2><p id="466e" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">对节点和Javascript的基本编程概念有基本的理解(最好是Promises、async/await)</p><h2 id="7cbe" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">软件先决条件:</h2><ul class=""><li id="22c5" class="lm ln it js b jt lh jx li kb lo kf lp kj lq kn lr ls lt lu bi translated">Atom或VSCode(或任何替代)Javascript编辑器。</li><li id="4948" class="lm ln it js b jt lv jx lw kb lx kf ly kj lz kn lr ls lt lu bi translated">Node.js和npm的最新版本(以下示例已经在node v 8.16上测试过)</li></ul><h2 id="ed26" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak"> MongoDB </strong></h2><p id="acf6" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">让我们从MongoDB开始，它是文档数据库中最受欢迎的。</p><p id="7cdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以选择按照平台特定说明安装MongoDB Community edition，网址为【https://www.mongodb.com/cloud/atlas/register.】<a class="ae ma" href="https://docs.mongodb.com/manual/administration/install-community/" rel="noopener ugc nofollow" target="_blank">https://docs . MongoDB . com/manual/administration/install-Community/</a>，或者您也可以通过注册免费试用版@ <a class="ae ma" href="https://www.mongodb.com/cloud/atlas/register." rel="noopener ugc nofollow" target="_blank">来使用MongoDB Atlas cloud版本</a></p><p id="9db0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外请注意，本文中的所有软件都已经安装在Ubuntu 16.04 (Xenial)上。</p><p id="7781" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本地安装MongoDB版本的情况下，一旦安装完毕，从命令行启动数据库，然后在Unix提示符下使用以下命令调用mongo db shell</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="050e" class="ko kp it mg b gy mk ml l mm mn"> $ sudo service mongod start <br/> $ mongo </span></pre><p id="6794" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在mongo shell中，发出以下命令</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c2d2" class="ko kp it mg b gy mk ml l mm mn">use blogdb</span><span id="6ec7" class="ko kp it mg b gy mo ml l mm mn">db.blogs.insertOne({ post_id: 1, post_title: “First Post”, post_text: “… Lorem ipsum..”, post_date: ISODate(‘2019–10–09’), author: “John S”, comments : [{ comment_id: 1, parent: 0, comment_text: “…First comment on Lorem ipsum..”, author:”Mark S.”}, {comment_id: 2, parent: 0, comment_text: “…Second comment on Lorem ipsum..”, author:”Jill”}, {comment_id: 3, parent: 2, comment_text: “…something to add to the comment by Jill..”,author: “Bruce P.”}, {comment_id: 4, parent: 3, comment_text: “…something to add to the comment by Bruce on the comment by Jill..”, author:”Brian”}, {comment_id: 5, parent: 1, comment_text: “…comment on first comment on Lorem Ipsum..”, author:”Ravi K”}]})</span></pre><p id="20ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这</p><ul class=""><li id="f796" class="lm ln it js b jt ju jx jy kb mp kf mq kj mr kn lr ls lt lu bi translated">创建一个名为blogdb的数据库并切换到它</li><li id="f13a" class="lm ln it js b jt lv jx lw kb lx kf ly kj lz kn lr ls lt lu bi translated">插入一个名为blogs的集合，其中包含帖子和每个帖子的评论(一个数组)。</li></ul><p id="5868" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Mongo中的集合对应于RDBMS中的表，第一次使用数据库名称和集合会创建它们，如上面的语句所示。db。{收藏}。insert使用基于Javascript-JSON的数据表示，而不是SQL，与上面一样直观简单。字段名在这里是不言自明的。</p><p id="01fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在这里再添加一个文档。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="67f4" class="ko kp it mg b gy mk ml l mm mn">db.blogs.insertOne({ post_id: 2, post_title: “Just another Post”, post_text: “… Lorem ipsum once again..”, post_date: ISODate(‘2019–10–09’), author: “Bill M”, comments : [{ comment_id: 1, parent: 0, comment_text: “…First comment on Lorem ipsum once again..”, author:”Brian S.”}, {comment_id: 2, parent: 0, comment_text: “…Second comment on Lorem ipsum once again..”, author:”Jill”}]})```</span></pre><h2 id="2796" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak"> Koa </strong></h2><p id="0e7b" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">让我们转到KOA——轻量级最小node.js框架，特别适合API。</p><p id="9c52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装说明:这里是我们创建工作目录并放入内容的地方。还可以使用以下命令在该文件夹中创建一个package.json文件:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7596" class="ko kp it mg b gy mk ml l mm mn">$ mkdir apiserver<br/>$ cd apiserver<br/>$ npm init -y<br/>$ npm install koa</span></pre><p id="d8d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用VS代码或您选择的文本编辑器创建一个app.js文件。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4cf7" class="ko kp it mg b gy mk ml l mm mn">const Koa = require('koa');<br/>const app = new Koa();<br/>app.use(async ctx =&gt; {<br/>  ctx.body = 'Just a placebo';<br/>});<br/>app.listen(3000, () =&gt; console.log('listening....') );</span></pre><p id="3a2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单的服务器设置和一些样板文件——任何有“快速”经验的人都可以看到4个命令的基本效用。该框架的核心是koa应用程序(app ),它可以附加一堆级联中间件。</p><p id="d5d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">app.use (async function…)在这里仅用作占位符，以展示koa与promise wrapped async functions的中间件链接特性。</p><p id="2361" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于那些后来加入Javascript promise(d)聚会的人来说，async表示中间件函数异步运行，最终将返回值。</p><h2 id="2212" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak"> GraphQL </strong></h2><p id="ebdc" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">现在让我们把GraphQL连接起来。</p><p id="eec1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装:因为我们将GraphQL用于koa，所以我们将使用Apollo集成包用于koa。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="cb97" class="ko kp it mg b gy mk ml l mm mn"> $ npm install apollo-server-koa</span></pre><p id="45e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着Apollo的安装，我们开始定义模式，它基本上是GraphQL查询的一种元数据。添加一个新文件schema.js，该文件将包含:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="f1d5" class="ko kp it mg b gy mk ml l mm mn">const { ApolloServer, gql } = require('apollo-server-koa');<br/>const typeDefs = gql`<br/>type Query  {<br/> posts: [ PostSummary],<br/> postById (id: ID!): Post,<br/> authorsByComments: [ AuthCommSummary ]<br/>}</span><span id="daf8" class="ko kp it mg b gy mo ml l mm mn">type Mutation {<br/> addPost (postTitle: String!, postText: String!,  author: String!) :  PostSummary<br/>}</span><span id="4487" class="ko kp it mg b gy mo ml l mm mn">type Post {<br/> postTitle: String<br/> postText: String<br/> author: String<br/>}</span><span id="4c90" class="ko kp it mg b gy mo ml l mm mn">type PostSummary {<br/> postTitle: String<br/>}</span><span id="bcbf" class="ko kp it mg b gy mo ml l mm mn">type AuthCommSummary {<br/> author: String<br/> comments: Int<br/>}<br/>`;</span><span id="2f83" class="ko kp it mg b gy mo ml l mm mn">module.exports =  typeDefs ;</span></pre><p id="0cc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们稍微检查一下-</p><p id="3451" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">typeDefs列出了GraphQL的所有数据定义，即我们将在API中公开的数据类型和操作。</p><p id="0611" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型Post、PostSummary和AuthCommSummary在这里基本上是对象类型，它们的每个组成元素都是标量(基本)类型。</p><p id="aacb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查询“posts”是我们将定义的第一个API，它返回先前定义的PostSummary数据类型的数组。类似地，postById接受一个非空值(由！)id输入参数并返回Post数据类型。对于authorsByComments查询也是如此。</p><p id="de3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变异意味着在服务器上进行写操作——类似于REST的PUT或Post动词——我们的模式中的变异指定向数据库中插入一个新的Post数据类型，由构成新POST的参数来指示(Mongo的字段灵活性允许我们更改或减少插入的新文档结构，因此我们在这里保留了注释数组),整个变异操作返回一个PostSummary数据类型作为成功的确认。</p><p id="d761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面所有的定义都被传递到以Apollo 'gql '函数为前缀的带标签的模板文字反斜杠(` ),该函数会将它们转换成GraphQL的抽象语法树进行解析。</p><p id="b08f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们定义解析器，即实际返回请求的数据或处理请求的更新的函数。我们的resolvers.js运行如下:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ca76" class="ko kp it mg b gy mk ml l mm mn">const { ApolloServer } = require('apollo-server-koa');<br/>const resolvers = {<br/>  Query: {<br/>    posts:  getPostList,<br/>    postById:  getPostById,<br/>    authorsByComments:  getAuthorsbyComments,<br/>  },</span><span id="371b" class="ko kp it mg b gy mo ml l mm mn">  Mutation: {<br/>    addPost: addPostDetails,<br/>  }<br/>}</span><span id="66e9" class="ko kp it mg b gy mo ml l mm mn">module.exports = resolvers;</span></pre><p id="859f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这基本上意味着，对于查询帖子，解析器将是函数getPostList(尚未实现)。postById、authorsByComments和addPost GraphQL API端点也是如此。</p><p id="886c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">值得注意的是，GraphQL解析器可以返回Javascript承诺，这使得它们非常适合facading数据库调用，因为我们将进行的大多数Mongo DB调用都是回调或异步结构的，并且必须包装在隐式或显式承诺中。</p><p id="1a3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们把它插入我们的app.js，得到最终的app.js，看起来像-</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="3bf0" class="ko kp it mg b gy mk ml l mm mn">const Koa = require('koa');<br/>const { ApolloServer } = require('apollo-server-koa');<br/>const { initDB, closeDB } = require('./mongoadapter');<br/>const typeDefs = require('./schema');<br/>const resolvers = require('./resolvers');<br/>const port = process.env.PORT || 8080;<br/>const app = new Koa();<br/>const server = new ApolloServer (<br/>  {<br/>    typeDefs,<br/>    resolvers,<br/>  });</span><span id="9334" class="ko kp it mg b gy mo ml l mm mn">app.use(server.getMiddleware());<br/>const koaServer = app.listen(port, () =&gt; {<br/>  console.log(`listening....at path ${server.graphqlPath}`);<br/>  initDB();<br/>});</span><span id="945b" class="ko kp it mg b gy mo ml l mm mn">process.on('SIGTERM', () =&gt; {<br/>  closeDB();<br/>  koaServer.close();<br/>})</span></pre><p id="0f4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将启动作为GraphQL API服务器的ApolloServer，并带有模式和解析器的参数。将ApolloServer实例传递给koa应用程序，帮助后者将其作为另一个中间件。</p><h2 id="015b" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak">最后是MongoDB原生驱动:</strong></h2><p id="0dc4" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">虽然对象数据管理(ODM)存储从RDBMS时代就开始流行，特别是对于新开发人员来说，以避免复杂的SQL语义，但Mongo的Javascript内在语法使DB bridge的应用层更容易克服，此外，在具有本机驱动程序的node.js环境中使用Mongo shell类语法时，还能影响更快的学习曲线和更大的灵活性。因此，值得考虑通过直接使用原生Mongo驱动程序从API开发栈中分离出一个额外的处理层，尤其是在并发需求不断增长的应用程序场景中。</p><p id="a5a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，必须指出的是，由于Mongo原生驱动程序不像Mongoose那样具有任何内置的模式验证器，因此必须使用某种级别的数据净化来缓解NoSQL注入漏洞，例如mongo-sanitize等软件包所提供的数据净化。</p><p id="dfc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以让我们通过安装将mongo原生驱动程序添加到我们的package.json中。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7f12" class="ko kp it mg b gy mk ml l mm mn">$ npm install mongodb — save</span></pre><p id="49cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们回到resolvers.js，在require列表中添加下面一行。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b306" class="ko kp it mg b gy mk ml l mm mn">const { getPostList, getPostById, addPostDetails, getAuthorsbyComments } = require(‘./mongoadapter’);</span></pre><p id="659b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是mongoadapter.js</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="065b" class="ko kp it mg b gy mk ml l mm mn">const MongoClient = require('mongodb').MongoClient<br/>const { UserInputError } = require('apollo-server-koa');<br/>const url = 'mongodb://localhost:27017'<br/>const client  = new MongoClient(url, { useNewUrlParser: true,   <br/>     useUnifiedTopology: true  })<br/>var db  =  null;</span></pre><p id="0e8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">url可能会根据您是使用Mongo Atlas连接还是通过网络安装Mongo而有所变化。让我们在服务器启动时连接到数据库。</p><p id="462f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">按照MongoDB驱动程序文档的建议，MongoClient.connect被调用一次，回调返回的数据库变量将被所有后续数据库操作重用。数据库初始化和关闭代码的其余部分是简单的搭建，用于连接到Mongo，该连接将在请求间共享。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="d66a" class="ko kp it mg b gy mk ml l mm mn">async function initDB() {<br/>  if (!db)<br/>  {<br/>    db = await new Promise( (resolve, reject) =&gt;<br/>        client.connect((err) =&gt;<br/>        {<br/>           if (err)<br/>             return reject(err)<br/>           let database = client.db('blogdb')<br/>           resolve (database);<br/>        })<br/>  ).catch(e =&gt; {<br/>        console.log('Could not get connection to MongoDB..\n' + e)<br/>        process.exit(1)<br/>   })<br/>  }<br/>}<br/>function closeDB() {<br/>  if (db)<br/>    client.close()<br/>}</span></pre><p id="c0a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们来看看查询getPostById的解析器</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="3020" class="ko kp it mg b gy mk ml l mm mn">async function getPostById(root, {id}, {dataSources}) {<br/>  const blogsCollection = db.collection('blogs')<br/>  let pid = parseInt(id);<br/>  return blogsCollection.findOne({ post_id: pid }, { projection: {_id: 0, post_title:1, post_text:1, author: 1 }}).then( res =&gt; {<br/>    if (!res)<br/>      throw new UserInputError('Cound not find Post for the ID   specified.', {ID: id});<br/>    return  { postTitle: res.post_title, postText: res.post_text,  author: res.author } ;<br/>  })<br/>}</span></pre><p id="f366" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用之前初始化的“db”连接来获取对我们之前创建的MongoDB集合“blogs”的引用。对db.collection的调用返回的驱动程序集合类提供了查询和更新特定数据库集合(在本例中是博客)的方法。{MongoCollection}上的select/WHERE谓词。findOne在第一个参数中指定，即{post_id: pid}，第二个参数(“列”投影，如果可以的话)指示要返回或隐藏的字段。</p><p id="45cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Mongo集合类提供的“findOne”方法用于查询文档，顾名思义，它只需要一个结果。请注意，findOne的返回值是一个隐含的承诺，所以我们只需要“然后”返回成功解析该承诺的响应。</p><p id="e553" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(关于async/await和Promises的更详细的演练，请参考Javascript教程。现在，让我们试着把承诺理解为一种“未来”,它将返回预期的结果，或者作为另一个“那时”能够处理的承诺，或者作为一个直接解析的值。这非常适合GraphQL的情况，在这种情况下，GraphQL服务器可以接受来自解析器的各种结果类型，尤其是异步承诺，它将等待。因此这里的语法更简洁，解析器简单地返回对驱动程序的承诺返回API调用。</p><p id="36fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是getPostList</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c336" class="ko kp it mg b gy mk ml l mm mn">async function getPostList() {<br/>  const blogsCollection = db.collection('blogs')<br/>  let res = null;<br/>  res = await new Promise( (resolve, reject) =&gt; {<br/>    blogsCollection.find( {}, { projection: {_id:0, post_title:1    <br/>    }}).toArray( (err, items) =&gt; { <br/>            if (err)<br/>              return reject(err)<br/>            resolve(items)<br/>            }<br/>          )<br/>        }<br/>      )<br/>   return res.map( x =&gt;  ( { "postTitle": x.post_title } ))<br/>}</span></pre><p id="ce52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上类似地实现，除了我们使用“find”的一个版本，与之前遇到的findOne不同，它同步返回一个MongoDB游标，而MongoDB游标又有基于回调的方法(next、each、toArray等)用于遍历结果集。因此，我们需要显式地将整个调用包装在一个承诺中(手动“承诺”它)并等待它，就像res = await new Promise( (resolve，reject)…。</p><p id="6869" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这里等待异步承诺，因为我们需要在将结果值传递回GraphQL服务器之前对其进行处理。</p><p id="3595" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意这里两个例子中方法的不同。</p><p id="4fc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是突变</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="34b3" class="ko kp it mg b gy mk ml l mm mn">async function addPostDetails(root, {postTitle, postText,  author}) {<br/>  let validationErrors = {}<br/>  if ( postTitle.length &gt;= 100 )<br/>    validationErrors.postTitle = 'postTitle should be less than 100      characters';</span><span id="2a17" class="ko kp it mg b gy mo ml l mm mn">  if ( author.length &gt;= 50 )<br/>    validationErrors.author = 'author should be less than 50 characters';</span><span id="0079" class="ko kp it mg b gy mo ml l mm mn">  if (Object.keys(validationErrors).length &gt; 0)<br/>    throw new UserInputError('Post update failed due to incorrect data. Please correct the below fields before proceeding.', validationErrors);</span><span id="99b7" class="ko kp it mg b gy mo ml l mm mn">  const blogsCollection = db.collection('blogs')<br/>  let res = null;<br/>  res = await new Promise( (resolve, reject) =&gt; {<br/>          blogsCollection.insertOne( { post_title:postTitle, <br/>            post_text: postText, author: author }, {},  (err,  <br/>            result) =&gt; {<br/>              if (err)<br/>                return reject(err)<br/>              resolve(result.ops[0].post_title)<br/>            }<br/>         )<br/>       }<br/>   )<br/>   return { postTitle: res };<br/>}</span></pre><p id="edce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们再花一点时间来检验这一点。</p><p id="081c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Apollo Server for GraphQL提供了一个UserInputError异常类，我们可以使用它来合并任何验证失败，并将其发送回客户端。</p><p id="9aa8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像所有的Apollo异常一样，它也为用户定义的错误消息附加一个扩展和用户特定的代码。在这种情况下，我们附加validationErrors对象。</p><p id="9653" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的insert语句向成功回调(第三个参数)返回一个结果，该结果分别包含“result.ops”数组和“result.insertedCount”中新插入/更新的文档和受影响的行/文档数。我们可以利用这些来制定适当的对策。</p><p id="4bdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，对于Mongo聚合，使用本地驱动程序就可以实现。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="abcf" class="ko kp it mg b gy mk ml l mm mn">async function getAuthorsbyComments() {<br/>  const blogsCollection = db.collection('blogs')<br/>  return new Promise( (resolve, reject) =&gt; {<br/>          blogsCollection.aggregate([ { $unwind: "$comments" }, { $group: { _id: "$author", count: {$sum : 1} } }, ], {}, (err, aggreCursor) =&gt; {<br/>           if (err)<br/>             return reject(err)<br/>           aggreCursor.toArray( (errInner, results) =&gt; {<br/>              if (errInner)<br/>                return reject(errInner)<br/>              documents = []<br/>              for (i in results)<br/>              {<br/>                documents.push({ author: results[i]._id, comments:  results[i].count })<br/>              }<br/>              resolve(documents)<br/>             })<br/>            }<br/>          )<br/>        }<br/>      )<br/>   }</span></pre><p id="6a34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了看起来相当有趣的Collection.aggregate函数之外，其他一切都与我们处理以前的解析器的方式一致。</p><p id="ad03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这基本上是SQL Group by子句的MongoDB等价物，在这种情况下，它为我们提供了作者列表，以及他们在他们发布的所有文章中收到的所有评论的计数。</p><p id="e008" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Mongo中的聚合管道是一个操作数组(每个操作在{}之间指定，并由分隔)，它就像一个管道一样工作，将每个操作的结果传送到下一个阶段，以实现数据转换…因此要分解聚合[ { $unwind: "$comments" }，{ $group: { _id: "$author "，count: {$sum : 1} }，] -</p><p id="b935" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.聚合的第一阶段使用“展开”操作符{ $unwind: "$comments" }意味着将展开聚合操作符应用于字段注释，以将每篇文章的每个注释转置/透视到单独的行中(或者按照Mongo的说法是文档)。这使得通过评论进行聚集变得容易。请注意，这需要在这里完成，因为如果我们重新访问blogs集合定义，comments嵌入字段当前是每个父文档中的一个数组类型。</p><p id="1650" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.第二阶段{ $group: { _id: "$author "，count: {$sum : 1} } }执行实际的分组方式，用an _id = "$author "指定作者列(作为" Group By "列)。group函数是包含相应作者的注释的行的计数(对每行的1个单元应用$sum操作符)。</p><p id="b670" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们找到了..一个post pivot group by函数可以像在Mongo shell中一样轻松地执行，这反映了Mongo原生驱动程序的强大功能。</p><p id="da0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后是mongoadapter.js末尾的导出函数</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="142f" class="ko kp it mg b gy mk ml l mm mn">module.exports = { initDB, getPostList, getPostById, addPostDetails, getAuthorsbyComments, closeDB }</span></pre><h2 id="6a75" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak">测试您的API: </strong></h2><p id="c75d" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">在Unix命令行执行应用程序</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5236" class="ko kp it mg b gy mk ml l mm mn">$ node app.js</span></pre><p id="f394" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我们使用的是Apollo服务器，GraphQL Playground，当我们在浏览器中点击测试URL时，一个交互式的双面板浏览器内IDE将被激活，在我们的例子中，这个测试URL将是<a class="ae ma" href="http://localhost:8080/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/graph QL</a></p><p id="77bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在左侧输入GraphQL查询，点击中间的按钮获得结果</p><p id="ca67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们对上述模式的查询将是-</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="eaa4" class="ko kp it mg b gy mk ml l mm mn">{ posts {<br/>  postTitle<br/>}}</span><span id="c51c" class="ko kp it mg b gy mo ml l mm mn">{ postById (id: 1)<br/>{postTitle<br/> postText<br/> author}}</span><span id="2b9f" class="ko kp it mg b gy mo ml l mm mn">{ authorsByComments {<br/> author<br/> comments<br/>}}</span><span id="4e70" class="ko kp it mg b gy mo ml l mm mn">mutation {<br/>addPost (postTitle: “Newest post”, postText: “..some text”, author:”B Rogers”)<br/>{ postTitle<br/>}}</span></pre><p id="2183" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> GraphQL游乐场</strong></p><figure class="mb mc md me gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/b1eba805183b9fb540d4234e79aefcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFKr4RcpcrHLzznWR6mgPw.jpeg"/></div></div></figure><h2 id="6d42" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak">包装完毕</strong></h2><p id="d116" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">仅此而已。</p><p id="097f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从这里开始，我们可以随着代码大小的增加和模块化需求来组织文件夹结构。下一个合乎逻辑的步骤是构建React客户端UI，该UI将使用GraphQL ApolloClient使用API，并显示可以由Mongo的复杂数据场景表示的结果。</p><p id="ccf5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上所有代码都可以在<a class="ae ma" href="https://github.com/kundanj/koa-graphql-nativemongo-api" rel="noopener ugc nofollow" target="_blank"> github </a>上找到。</p></div></div>    
</body>
</html>