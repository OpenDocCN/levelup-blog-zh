<html>
<head>
<title>Ticket to Kotlin — using Google Maps in React web application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin的门票——在React web应用程序中使用谷歌地图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ticket-to-kotlin-using-google-maps-in-react-web-application-745d8fb0ab08?source=collection_archive---------10-----------------------#2020-06-06">https://levelup.gitconnected.com/ticket-to-kotlin-using-google-maps-in-react-web-application-745d8fb0ab08?source=collection_archive---------10-----------------------#2020-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5185763f05a7378eff2ee8e863801b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DdEXz7xrFd2Dnx3n"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">西蒙·米加吉在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2837" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的网页版<a class="ae kf" href="https://github.com/Kiryushin-Andrey/TicketToRide" rel="noopener ugc nofollow" target="_blank">游戏乘车券</a>需要的第一件东西(见<a class="ae kf" href="https://medium.com/@kiryushin.andrey/ticket-to-kotlin-building-an-online-board-game-8ac8466fe142" rel="noopener">上一篇文章</a>的故事开头)是一张画路线的地图。在可以滚动和放大缩小的真实地图上玩游戏似乎是个好主意，所以我转向了谷歌地图。将谷歌地图嵌入网站是一个简单且有据可查的过程。首先，注册谷歌云平台账户并获得一个API密匙——完成这个的步骤在<a class="ae kf" href="https://developers.google.com/maps/gmp-get-started" rel="noopener ugc nofollow" target="_blank">这里</a>有详细描述。然后在脚本查询字符串中嵌入一个带有这个API键的脚本标记(静态或动态)，并创建一个地图实例，提供初始地图中心位置、缩放和目标元素来包含地图。<a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/tutorial" rel="noopener ugc nofollow" target="_blank">这个来自谷歌的教程</a>详细描述了你入门需要的一切。</p><p id="8dbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了玩这个游戏，我必须在地图上画出城市标记和路线。谷歌地图JavaScript API允许不同的选项来实现这一点。您可以在这里找到这些选项<a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/overlays" rel="noopener ugc nofollow" target="_blank">的概述。基本上，您可以在基本的开箱即用的基础上构建，如标记、形状和信息窗口，或者创建自己的自定义叠加。基本原语易于使用，非常适合普通任务。它们也可以在一定程度上进行定制——您可以使用任意的SVG图像作为标记，将您自己的HTML内容放入“简介”窗口，或者设置线条或形状的颜色和笔触。但是有些事情你不能用基本的原语来做。另一方面，自定义覆盖允许您在地图上呈现任意的HTML元素，但是您要对创建和定位这些元素的每个方面负责。特别是，您需要注意将纬度\经度坐标转换成像素。Google Maps API为这种转换提供了帮助方法，但是必须正确使用它们来设置所有相关元素的位置和大小。</a></p><p id="9585" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谷歌地图一次显示几个覆盖图，在引擎盖下，基本的图元也驻留在它们自己的覆盖图中，所以你可以根据需要混合和匹配这些方法。这就是我的游戏的结局。我正在用简单的折线绘制路线，自定义它们的颜色和笔画。但是我选择了一个<a class="ae kf" href="https://github.com/google-map-react/google-map-react" rel="noopener ugc nofollow" target="_blank"> google-map-react </a>库，而不是内置的城市标记，在内部，这个库使用一个定制的覆盖图来呈现地图的子组件。</p><h1 id="e75e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">谷歌地图的包装组件</h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/f3ded5e7d4e945766ae296a5fc79007d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W_RJ1lx1LJOtaB7w"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">自由股</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="86fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以直接使用Google Maps JavaScript API，或者依赖于您选择的框架的一些包装组件。包装组件的好处在于，它们将地图实例公开为React、Vue或Angular组件，您可以使用属性对其进行设置，并以熟悉的方式在应用程序中使用。GitHub上有多个组件为所有主要的网络框架包装谷歌地图。但是在选择包装组件时，有许多因素需要考虑。我建议你先熟悉一下Google Maps API上的<a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/" rel="noopener ugc nofollow" target="_blank">第一手文档</a>，决定你需要哪些特性，然后再对现有的包装器组件做一个概述，特别注意它们的TypeScript定义。因此，您将能够做出更好的选择，而不会在不能满足您需求的组件上浪费时间。</p><p id="3be1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您喜欢静态类型，那么TypeScript声明非常重要(如果您不喜欢，为什么要编写Kotlin呢？).检查包装组件的npm包或附带的<code class="fe mh mi mj mk b">@types/&lt;component&gt;</code> npm包中的<code class="fe mh mi mj mk b">index.d.ts</code>文件，看看这些定义有多完整，每个文件有多少个<code class="fe mh mi mj mk b">any</code>。您总是可以自己为JS代码构建Kotlin包装器。但是探索一个组件并同时为它编写TypeScript定义是困难的。您可能会想到依赖组件文档的捷径，但是当文档与实现不完全匹配时，或者当作者确实使用了一些难以用静态类型化方式表达的巧妙技巧时，这种方法可能会导致运行时错误。理清这些差异可能会让您对TypeScript定义语法和组件本身有一个非常复杂的了解，所以在为第三方组件编写自己的类型定义之前，请确保这是您想要的。看加里·伯恩哈特的《T4》很有趣；处理这种事情大多不是。</p><p id="708a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经把React作为我的乘车票游戏的前端，所以这里是我找到的谷歌地图的三个React包装库的简要概述。他们的名字并不太有创意，有时会忘记我现在正在处理哪个组件:)</p><h2 id="1bcd" class="ml lf it bd lg mm mn dn lk mo mp dp lo kr mq mr ls kv ms mt lw kz mu mv ma mw bi translated"><a class="ae kf" href="https://github.com/tomchentw/react-google-maps" rel="noopener ugc nofollow" target="_blank"> react-google-maps </a></h2><p id="ea68" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">这是谷歌地图JavaScript API的一个非常薄的包装。它负责将地图及其部分(标记、形状等)作为React组件公开，仅此而已。这个库并没有吹嘘任何一步一步的教程或示例，而是希望您非常熟悉Google Maps JavaScript API本身(这是一个好主意)。同时，这个库为谷歌地图功能的一个非常广泛的子集提供了包装器——仅举几个例子，如<a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/kmllayer" rel="noopener ugc nofollow" target="_blank"> KML层</a>、<a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/heatmaplayer" rel="noopener ugc nofollow" target="_blank">热图层</a>、<a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/drawinglayer" rel="noopener ugc nofollow" target="_blank">绘图管理器</a>和g <a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/groundoverlays" rel="noopener ugc nofollow" target="_blank">圆形覆盖图</a>。TypeScript定义已经存在并且非常好，所以使用Kotlin的这个库将是轻而易举的事情(每663行<code class="fe mh mi mj mk b">index.d.ts</code>文件只有3个<code class="fe mh mi mj mk b">any</code>,太棒了！).</p><p id="7f93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Kotlin的这个库有一个小问题，因为它使用了几个高阶组件来呈现地图实例，而Kotlin React包装器文档并不清楚如何在Kotlin中使用这些组件。诀窍是修改<a class="ae kf" href="https://github.com/Kotlin/dukat" rel="noopener ugc nofollow" target="_blank"> Dukat </a>生成的Kotlin定义来使用<code class="fe mh mi mj mk b">HOC</code>函数，如下所示:</p><pre class="md me mf mg gt nc mk nd ne aw nf bi"><span id="42d2" class="ml lf it mk b gy ng nh l ni nj">@JsName("default")<br/><strong class="mk iu">external val</strong> withGoogleMap : HOC&lt;GoogleMapProps, WithGoogleMapProps&gt;</span></pre><p id="dd54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参见GitHub上的这个<a class="ae kf" href="https://github.com/JetBrains/kotlin-wrappers/issues/13" rel="noopener ugc nofollow" target="_blank">线程</a>以获得关于处理Kotlin的高阶React组件的更详细讨论，并阅读我的下一个故事以获得关于<a class="ae kf" href="https://github.com/Kotlin/dukat" rel="noopener ugc nofollow" target="_blank"> Dukat </a>工具的介绍和我的使用经验。</p><h2 id="537b" class="ml lf it bd lg mm mn dn lk mo mp dp lo kr mq mr ls kv ms mt lw kz mu mv ma mw bi translated"><a class="ae kf" href="https://github.com/fullstackreact/google-maps-react" rel="noopener ugc nofollow" target="_blank">谷歌地图反应</a></h2><p id="d9e4" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">这个库是和一篇详细的描述如何构建这样一个包装器组件的博客文章一起构建的。该组件本身涵盖了谷歌地图的最基本功能——渲染地图本身，并在其上绘制标记、线条和简单的形状。不支持数据可视化或叠加等高级功能。</p><p id="7bbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管所支持的特性对于我的用例来说已经足够了，但是这个组件没有提供像样的TypeScript定义。定义文件<a class="ae kf" href="https://github.com/fullstackreact/google-maps-react/blob/master/index.d.ts" rel="noopener ugc nofollow" target="_blank">存在于</a>中，但是它只是为除了地图本身之外的所有组件属性抛出了<code class="fe mh mi mj mk b">any</code>，所以它对任何静态类型的代码库几乎没有用处。尽管如此，如果您正在考虑编写自己的包装器组件，这个组件及其附带的博客文章是一个很好的起点。</p><h2 id="9873" class="ml lf it bd lg mm mn dn lk mo mp dp lo kr mq mr ls kv ms mt lw kz mu mv ma mw bi translated"><a class="ae kf" href="https://github.com/google-map-react/google-map-react" rel="noopener ugc nofollow" target="_blank">谷歌地图反应</a></h2><p id="255b" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">这个库是我用来买我的<a class="ae kf" href="https://github.com/Kiryushin-Andrey/TicketToRide" rel="noopener ugc nofollow" target="_blank">票来玩</a>游戏的。这个库的杀手锏是它允许你渲染任意的React组件，这些组件依赖于由纬度/经度对指定的地图上的某个点。该库不是通过自定义标记来实现的，而是通过在<a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/customoverlays" rel="noopener ugc nofollow" target="_blank">自定义覆盖图</a>中渲染地图的所有子组件来实现的。这个功能工作得很好，非常方便我的游戏在地图上绘制城市，根据游戏状态用不同的图标表示它们，并用工具提示装饰它们。</p><p id="ec68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该库还提供了大量漂亮的示例，但是要注意，存在所谓的新示例和旧示例，并且相对于库代码库的当前状态，并不是所有的示例都是最新的。在撰写本文时，新的示例页面被标记为进行中，但看起来中途被放弃了一段时间。</p><p id="05c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了将成熟的React组件呈现为地图上的标记这一独特功能之外，该库没有为其他Google Maps功能提供任何包装器。但是它允许轻松访问底层的地图对象，这样您就可以通过直接使用Google Maps API和这个对象来实现您需要的一切。这是我在游戏中采用的方法。我在map组件中嵌套了两种不同类型的组件。<a class="ae kf" href="https://github.com/Kiryushin-Andrey/TicketToRide/blob/master/src/jsMain/kotlin/ticketToRide/components/MapCityMarker.kt" rel="noopener ugc nofollow" target="_blank">其中一个</a>负责渲染一个城市标记。它只是一个常规的React组件，生成虚拟DOM树的某个部分，对它所呈现的地图一无所知。包含地图的组件负责在地图的指定点呈现该元素。<a class="ae kf" href="https://github.com/Kiryushin-Andrey/TicketToRide/blob/master/src/jsMain/kotlin/ticketToRide/components/MapSegmentComponent.kt" rel="noopener ugc nofollow" target="_blank">另一个组件</a>为地图上的一条路线呈现一条<a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/shapes#polylines" rel="noopener ugc nofollow" target="_blank">折线</a>——但与城市标记组件不同，它完全知道地图实例，并与之交互来呈现这条线。因此，该组件的<code class="fe mh mi mj mk b">render</code>方法初始化<code class="fe mh mi mj mk b">Polyline</code>实例，并将其附加到包含它的map，但不对父组件的虚拟DOM做任何贡献。</p><p id="15ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至于这个库的TypeScript定义，它们在<a class="ae kf" href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/google-map-react" rel="noopener ugc nofollow" target="_blank">中有明确的类型化</a>，但很难称之为完整——许多属性和函数参数都留有<code class="fe mh mi mj mk b">any</code>类型。但是我只使用了组件公共接口的一小部分(实例化地图)，现有的TypeScript定义对我来说已经足够了。我用特定的类型替换了几个<code class="fe mh mi mj mk b">any</code>，调整了生成的声明，使它们可以很好地与<a class="ae kf" href="https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react" rel="noopener ugc nofollow" target="_blank"> Kotlin React wrapper </a>库配合使用，一切顺利。</p><p id="6d22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本系列的下一篇文章<a class="ae kf" href="https://medium.com/@kiryushin.andrey/ticket-to-kotlin-using-dukat-to-bridge-kotlin-with-the-js-world-431a2458b95c" rel="noopener">中，我分享了我使用Kotlin的JavaScript库的经历——如果您对更多细节感兴趣，请继续阅读。</a></p></div></div>    
</body>
</html>