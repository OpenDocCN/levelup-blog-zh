<html>
<head>
<title>Transpiling Typescript into double packages (CommonJS + ESM)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将类型脚本转换成双包(CommonJS + ESM)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/transpiling-typescript-into-double-packages-commonjs-esm-d6b62cfc851c?source=collection_archive---------4-----------------------#2022-09-22">https://levelup.gitconnected.com/transpiling-typescript-into-double-packages-commonjs-esm-d6b62cfc851c?source=collection_archive---------4-----------------------#2022-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="ce8a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">错误。他们无处不在</h1><p id="84e8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">写这篇文章的原因是这样的错误:</p><blockquote class="lj lk ll"><p id="47f3" class="kl km lm kn b ko ln kq kr ks lo ku kv lp lq ky kz lr ls lc ld lt lu lg lh li ij bi translated">错误[ERR_REQUIRE_ESM]:不支持来自…/file.ts的ES模块…/index.js的REQUIRE()。</p><p id="ace4" class="kl km lm kn b ko ln kq kr ks lo ku kv lp lq ky kz lr ls lc ld lt lu lg lh li ij bi translated">相反，将…/file.ts中index.js的require改为所有CommonJS模块中都可用的动态导入()。</p></blockquote><p id="1972" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">发生这种情况是因为您试图从CommonJS模块连接ES模块。唉，近年来，在更新软件包和切换到新版本时，此类错误的数量一直在无情地增长。为什么会出现这样的错误？让我们来了解一下这种现象的本质。要做到这一点，你需要一头扎进JS的历史。</p><h1 id="5804" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">射流研究…</h1><p id="a1e6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">JS出生于1995年。是在几个月内写成的。它最初是通过标记脚本加载到页面上的。页面上加载的所有JS都属于全局范围。因此，当加载多个外部脚本时，会出现冲突、变量重载和其他副作用。没有这样的进出口。虽然语言中保留了关键字。</p><h1 id="8fe3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Node.js和CommonJS</h1><p id="194b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">到2009年，这项技术变得如此流行，以至于有人问为什么不在后端使用JS。于是，Node.js出现了。尽管语法相似，但排列方式略有不同。因为与浏览器不同，run-time Node缺少html和script标记，所以加载JS需要一些其他机制来加载模块。需要这样一种机制。值得注意的是，require并不是一个新的语言属性。这种机制内置于运行时。</p><p id="0bb9" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">Require.js解析一个模块，在其中构建一个语法树，找到与其中其他模块的连接，选择第一个，将其连接到语法树，然后解析下一个模块。这个过程一直持续到整个树构建完成。直到这时，模块才被认为是加载的，也不可能对其进行分析。在解析和构建树之后，require公开了module.exports对象，并提供了一个API来使用它，隐藏了实现细节。</p><p id="37b4" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">还值得注意的是，与浏览器不同，node.js不能通过URL进行搜索，而是通过文件的路径进行搜索，如果没有提供路径，则在本地node_module文件夹中搜索模块，如果为空，则在同名但级别更高的文件夹中搜索，以此类推，直到node.js到达根文件夹。这种惯例被称为CommonJS。为了加载外部库，创建了npm，它在外部共享存储库中或用户指定的存储库中查找包，并将必要的外部库拖到相应的node_modules文件夹中。</p><h1 id="4169" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Require.js和AMD等</h1><p id="2c11" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在Node.js发布和require机制出现一段时间后，来自浏览器世界的人欣赏这种方法，并采取措施将这种方法应用到自己身上。将1in1 CommonJS移植到浏览器是不可能的。第一个原因:在Node.js内部的JS和浏览器的工作中，是浏览器没有访问文件系统的权限，对url进行操作，而node.js对文件系统进行操作。原因二:运行时可以在脚本中添加任何变量。Module.exports在浏览器中不可用。因此，在2010年，创建了RequireJS库。它为名为AMD的浏览器提供了CommonJS的改编版本。需要注意的是，AMD和CommonJS并没有改变语言本身。</p><h1 id="bef4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">ES6和ESM:</h1><p id="a5d0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">2015年，ES6出现了，它包含了很多社区要求的改变。除其他外，它描述了进口和出口。2017年，这些标准在Node.js的8版本中实验性地实现。它们是ESM标题。ESM和CommonJS之间的主要区别是动态导入，它允许在使用模块的各个部分时加载它们。同时，使用await import构造保留了静态导入的可能性，就实现而言，它类似于CommonJS中require的实现</p><h1 id="05b0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">事件年表:</h1><p id="90a9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">按时间顺序描述的事件可以表示如下。</p><p id="9055" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi">1995:</p><ul class=""><li id="981f" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated"><em class="lm">浏览器(脚本)</em></li></ul><p id="43b4" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi">2009:</p><ul class=""><li id="032f" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated">节点. js</li><li id="0a2d" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">CommonJS(节点。JS):要求|模块.导出</li></ul><p id="7d4c" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi">2010:</p><ul class=""><li id="2992" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated">AMD(需要。JS | Browser):要求|模块.导出|定义</li></ul><p id="253c" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi">2015:</p><ul class=""><li id="3987" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated">ES6标准:导入|导出</li></ul><p id="486b" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi">2017:</p><ul class=""><li id="af25" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated">ESM (Node.js 8.0.0 2017实验| Node.js 12 2018):导入|导出</li></ul><h1 id="8232" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">以打字打的文件</h1><p id="2c37" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们再增加一层复杂性。从历史上看，Typescript已经被移植到CommonJS，并且是JS的严格语法超集。也就是说，它支持JS语言的所有属性，但同时向该语言添加了自己的语法结构。需要注意的是，浏览器和节点本身不支持Typescript。要使用TS，您必须首先将TS翻译成节点和浏览器可以理解的语言。第二个要点是，ESM支持从2022年4月8日开始对nodeResolution NodeNext可用。</p><p id="8e17" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">至此，TS无法:</p><ul class=""><li id="c13d" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated">创建带有扩展名的正确导入；</li><li id="70ee" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">解析package.json中的导出和导入部分；文档链接:<a class="ae mj" href="https://www.typescriptlang.org/docs/handbook/esm-node.html#packagejson-exports-imports-and-self-referencing" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/ESM-node . html # package JSON-exports-imports-and-self-referencing</a></li></ul><p id="4995" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">同样需要注意的是，jest仍然不完全支持ESM。</p><h1 id="bad3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">为什么CommonJS和ESM之间的过渡会很痛苦</h1><ol class=""><li id="6592" class="lv lw iq kn b ko kp ks kt kw mk la ml le mm li mn mb mc md bi translated">将CommonJS包导入ESM非常容易。同时，反向移植也伴随着困难。</li><li id="7cf8" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li mn mb mc md bi translated">Node.js最初面向CommonJS</li><li id="b801" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li mn mb mc md bi translated">有大量用CommonJS编写的包。例如，所有工具(ts-node、typescript等)等。</li><li id="292b" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li mn mb mc md bi translated">CommonJS使得以不同的方式在包中实现模块化成为可能。因此，不同的工具有不同的模块化实现。</li><li id="4b4f" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li mn mb mc md bi translated">CommonJS允许外部进程修改node，例如，ts-node可以在运行时修改node.js。现在这是不可能的。</li><li id="201f" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li mn mb mc md bi translated">ESM强加了某种模块化，因此平稳过渡是不可能的。</li></ol><h1 id="b7f4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Node.js对新鲜包的建议:</h1><p id="89d2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">需要注意的是，对于新的包，ESM是包重用代码的官方标准格式。必须使用import和export语句定义模块。官方文件链接:<a class="ae mj" href="https://nodejs.org/api/esm.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/esm.html</a>因此，我们得出结论，这种转变是不可避免的，也是令人不快的。Node.js的哪些变化让这个过渡在当下更有利？对动态运行ESM的实验性支持出现在Node.js的另外14个版本中，但只有在版本18中才变得稳定。除此之外，ts-node的最新版本引入了动态传输。</p><h1 id="917c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我们做了什么？</h1><p id="3f69" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">创建了一个库<a class="ae mj" href="https://src.aligntech.com/projects/CCW/repos/ipl-shared/browse" rel="noopener ugc nofollow" target="_blank">https://src . align tech . com/projects/CCW/repos/IPL-shared/browse</a>我们在它里面创建了一个ESM包，在最新的JS栈上:NodeJS 18。检查发射。一切都好。我们试图把它拖进基础设施:Jest，Eslint。添加了单元测试。一切正常。我们将包转换为Typescript，并尝试通过TS-node运行它。一切正常。有一个微妙的问题，在早期的第18版中，不可能影响其内部结构的工作，因此我们必须编写以下包装程序来运行Typescript:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/39057a4eb2c60cd4e25b4e39904327d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BP_naKhwe1H0dnBnDQqaMA.png"/></div></div></figure><p id="f275" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">但是所有这些机制只能在单一存储库的框架内工作。为什么？因为对于外部包，有必要以CommonJS或ESM的形式准备一个项目。</p><p id="e393" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">当然，我们可以通过静态导入const X = await import(' Y ')；但是没什么成效。</p><p id="39b8" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">为此，我们设置transpiler来生成esm和commonJS模块。</p><p id="06d6" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">下面的结构出来了:</p><p id="0815" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">距离/</p><ul class=""><li id="815e" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated">esm/</li><li id="f60c" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">commonJS/</li></ul><p id="3fcf" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">src/</p><ul class=""><li id="472b" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated">Package.json(其中指定了模块类型)</li></ul><p id="3038" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">在我们的情况下，我们可以从三个点导入包:</p><ol class=""><li id="9b3a" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li mn mb mc md bi translated">从相邻的工作区通过。/src/index.ts文件夹</li></ol><p id="6192" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">2.当我们从另一个库导入编译后的代码时:</p><p id="1454" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">a.来自ESM</p><p id="dd02" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">b.来自CommonJS</p><p id="76cc" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">该计划正在发挥作用，但遗憾的是，对于全面的工作来说，这还不够。我将用一个例子来说明这个论点:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi na"><img src="../Images/366d8da0990234cf854c287b683b733c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4MsJDXO-pavWMqMM9pQ3UQ.png"/></div></div></figure><p id="9677" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">当然，你可以使用createRequire和await import，但我更愿意用传统的方式连接:从“@ align tech-IPL/translations-core”导入{ something }；const { something } = require(" @ align tech-IPL/translations-core ")；</p><h1 id="ca7f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">为什么不这样做比较好？</h1><ul class=""><li id="d51c" class="lv lw iq kn b ko kp ks kt kw mk la ml le mm li ma mb mc md bi translated">进入实现细节</li><li id="2a5f" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">人为因素，因为我们添加了潜在的错误，以防包结构发生变化</li></ul><h1 id="5924" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">有条件出口</h1><p id="9a53" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了简化代码中的导入，我们在package.json中使用了两个构造:</p><ul class=""><li id="813b" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated">PublishConfig —此字段包含一个对象，该对象的属性将在为发布而构建包后被替换为同名的属性</li></ul><p id="aaa5" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">结果是这样的:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/44e3d4bab38de8e1d64067bde95bfcf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*XwJP4iSxD7c0a1hirqLPdQ.png"/></div></figure><p id="5e4f" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">我给截图补充一些细节:</p><ul class=""><li id="8abb" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated">"."是子路径导出。多亏了他，我们可以一路实施不同的出口条件</li><li id="e34a" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">“类型”—允许您根据条件指定不同的类型</li><li id="b09a" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">“默认”是通用的入口点</li></ul><h1 id="d783" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我们还必须做什么？</h1><ul class=""><li id="439c" class="lv lw iq kn b ko kp ks kt kw mk la ml le mm li ma mb mc md bi translated">即使在使用条件导出的情况下，我们也必须在ESM或CommonJS包中将js扩展改为mjs (cjs)。</li><li id="7fa9" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">默认情况下，js文件将由node.js根据package.json中type字段的值进行解释。</li><li id="46c9" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">此外，我们需要将非双重软件包替换为CommonJS和ESM版本软件包的相应版本。例如，在ESM中使用lodash-es，在commonJS中使用lodash。</li></ul><h1 id="5850" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">总结:</h1><ul class=""><li id="c131" class="lv lw iq kn b ko kp ks kt kw mk la ml le mm li ma mb mc md bi translated">我们设法建立了终端节点发射</li><li id="367a" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">飞行中的蒸发证明:</li><li id="cd50" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">与类似的发射相比，测试发射的速度提高了6-10倍。</li><li id="d631" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">原来是设置了双包(commonJS | esm)</li></ul><h1 id="8c1f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">链接:</h1><ul class=""><li id="d119" class="lv lw iq kn b ko kp ks kt kw mk la ml le mm li ma mb mc md bi translated"><a class="ae mj" href="https://nodejs.org/docs/latest-v18.x/api/packages.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v18.x/api/packages.html</a></li><li id="558d" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated"><a class="ae mj" href="https://medium.com/sungthecoder/javascript-module-module-loader-module-bundler-es6-module-confused-yet-6343510e7bde" rel="noopener">https://medium . com/sung the code/JavaScript-module-module-loader-module-bundler-es6-module-confused-yet-6343510 e 7 bde</a></li><li id="8df2" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated"><a class="ae mj" href="https://nodejs.org/api/packages.html#dual-commonjses-module-packages" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/API/packages . html # dual-commonjses-module-packages</a></li><li id="3263" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated"><a class="ae mj" href="https://nodejs.org/api/packages.html#conditional-exports" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/packages.html#conditional-exports</a></li><li id="c19f" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated"><a class="ae mj" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#packagejson-exports-imports-and-self-referencing" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/release-notes/typescript-4-7 . html # package JSON-exports-imports-and-self-referencing</a></li><li id="1686" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated"><a class="ae mj" href="https://2ality.com/2019/10/hybrid-npm-packages.html" rel="noopener ugc nofollow" target="_blank">https://2ality.com/2019/10/hybrid-npm-packages.html</a></li><li id="0e8d" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated"><a class="ae mj" href="https://www.typescriptlang.org/docs/handbook/esm-node.html#packagejson-exports-imports-and-self-referencing" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/ESM-node . html # package JSON-exports-imports-and-self-referencing</a></li></ul></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="f6e4" class="jn jo iq bd jp jq nj js jt ju nk jw jx jy nl ka kb kc nm ke kf kg nn ki kj kk bi translated">分级编码</h1><p id="61ed" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="ec2d" class="lv lw iq kn b ko ln ks lo kw lx la ly le lz li ma mb mc md bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="e5b3" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">📰更多内容请查看<a class="ae mj" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="fa86" class="lv lw iq kn b ko me ks mf kw mg la mh le mi li ma mb mc md bi translated">🔔关注我们:<a class="ae mj" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae mj" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae mj" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="4b6c" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lq ky kz la ls lc ld le lu lg lh li ij bi translated">🚀👉<a class="ae mj" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir">将像你这样的开发人员安置在顶级创业公司和科技公司</strong> </a></p></div></div>    
</body>
</html>