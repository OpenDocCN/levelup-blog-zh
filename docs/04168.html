<html>
<head>
<title>Protocols in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的协议</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/protocols-in-swift-7359a88248b4?source=collection_archive---------10-----------------------#2020-06-12">https://levelup.gitconnected.com/protocols-in-swift-7359a88248b4?source=collection_archive---------10-----------------------#2020-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1046" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我从初级到中级都解释过，有代码示例和快照。🚀</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/023967500df407f9402215ddacb91b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bC-b36-6SF57TM_sufKyQQ.jpeg"/></div></div></figure><blockquote class="la lb lc"><p id="6a57" class="jq jr ld js b jt ju jv jw jx jy jz ka le kc kd ke lf kg kh ki lg kk kl km kn im bi translated">有了协议，你就定义了一组具体类型实现的公共属性和行为<em class="it">🤓</em>。<em class="it">让我们来看一个例子:</em></p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/692d2634ad0fbbba6fed41eaea07ed65.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*FjNJU9Q2Qt6eUjcLXoC2RQ.png"/></div></figure><p id="a6fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关键字<code class="fe li lj lk ll b">protocol</code>后面是协议的名称，后面是花括号，里面是协议的成员。</p><p id="5fd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">您会注意到的最大区别是协议<em class="ld">不包含任何实现</em>。</strong>你在这里定义的是类似于车辆的<em class="ld">概念</em>的东西——它可以加速和停止。💯</p><h2 id="3ddb" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">让我们理解它的语法</h2><p id="1ccc" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">一个协议可以被一个类、结构或枚举<strong class="js iu">采用</strong>——当另一个类型采用一个协议时，它需要实现协议中定义的方法和属性。一旦一个类型实现了一个协议的所有成员，这个类型就被认为<strong class="js iu">符合</strong>该协议。例如:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/7976b8703ed75574f5c0087d458dd09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*rrXUzePOPvtb8TMwiuer3A.png"/></div></figure><blockquote class="la lb lc"><p id="9734" class="jq jr ld js b jt ju jv jw jx jy jz ka le kc kd ke lf kg kh ki lg kk kl km kn im bi translated">在命名类型的名称后面加上一个冒号和您想要遵循的协议的名称。这种语法可能看起来很熟悉，因为它与您用来使一个类从另一个类继承的语法相同。在这个例子中，Unicycle符合车辆协议。</p></blockquote><p id="bb16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意，它<em class="ld">看起来</em>像类继承，但它不是；结构和枚举也可以符合这种语法的协议。</strong></p><p id="e8ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，一个类可以采用一个协议。在这里，我们创建了一个名为<code class="fe li lj lk ll b">Unicycle</code>的<code class="fe li lj lk ll b">Vehicle</code>类型的类，并且我们使用了协议<code class="fe li lj lk ll b">accelerate</code>和<code class="fe li lj lk ll b">stop</code>的属性，我们通过将兜售虚假作为代码块来定义该方法。</p><p id="a24c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果您要从上面的</strong> <code class="fe li lj lk ll b"><strong class="js iu">Unicycle</strong></code> <strong class="js iu">类中删除</strong> <code class="fe li lj lk ll b"><strong class="js iu">stop()</strong></code> <strong class="js iu">的定义，Swift会显示一个错误，因为Unicycle不会完全符合</strong> <code class="fe li lj lk ll b"><strong class="js iu">Vehicle</strong></code> <strong class="js iu">协议😮。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ml"><img src="../Images/350bcc3b7d0052b472f889c690165435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-U1w30KOg3TImKDTPlcOSw.png"/></div></div></figure><p id="8f33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为您没有同时使用加速和停止，错误显示为类型“独轮车”不符合协议“车辆”。</p><h1 id="f08c" class="mm ln it bd lo mn mo mp lr mq mr ms lu mt mu mv lx mw mx my ma mz na nb md nc bi translated">协议中的属性</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f10b188ad0d85fffcf30f0d3e9dc59ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*rHRmhaA8SQb3VeYFuyFong.png"/></div></figure><p id="fdf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当在协议中定义属性时，您必须显式地将它们标记为<code class="fe li lj lk ll b">get</code>或<code class="fe li lj lk ll b">get set</code>，有点类似于您声明计算属性的方式。然而，就像方法一样，您不包含任何属性的实现。</p><p id="34f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们之前说过的，在协议括号中，我们只写协议能做的事情。</p><p id="31cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不熟悉计算属性，getter和setter。那么你可以通过下面的解释:<a class="ae ne" href="https://medium.com/dev-genius/what-are-properties-in-swift-2ec8aba9a378" rel="noopener"><em class="ld">https://medium . com/dev-genius/what-are-properties-in-swift-2 EC 8 ABA 9a 378</em></a></p><h1 id="ead2" class="mm ln it bd lo mn mo mp lr mq mr ms lu mt mu mv lx mw mx my ma mz na nb md nc bi translated">协议中的初始化器</h1><p id="addc" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><strong class="js iu"> Swift </strong>允许程序员通过符合其类型直接初始化<strong class="js iu">协议</strong>。我们可以将<strong class="js iu">初始化器</strong>声明为<strong class="js iu">协议</strong>的一部分，就像普通的<strong class="js iu">初始化器</strong>一样，但是我们不会使用花括号或者<strong class="js iu">初始化器</strong>体。</p><p id="5655" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看代码，并通过示例来探索它:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/10aa839dc56ec015ec3fc94e14bbf6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K429hFdI2FxyNtjnlYo8ng.png"/></div></div></figure><p id="5142" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的<em class="ld"> Account </em>协议中，您定义了两个初始化器作为协议的一部分。在这种情况下，任何符合Account的类型都需要有这些初始化器。如果你使用一个类类型遵循一个带有必需初始化器的协议，那些初始化器必须使用<strong class="js iu">必需的</strong>关键字。</p><h1 id="e185" class="mm ln it bd lo mn mo mp lr mq mr ms lu mt mu mv lx mw mx my ma mz na nb md nc bi translated">协议继承</h1><p id="79b2" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">您可能希望定义一个协议，该协议包含车辆的所有质量，但也特定于带车轮的车辆。为此，您可以拥有从其他协议继承的协议，就像您可以拥有从其他类继承的类。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/0e45ba448dc91454ee59e15aed4ede78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*hcw-OGTyS7GDy9vmr1LnCQ.png"/></div></figure><p id="3b5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，<em class="ld"> WheeledVehicle </em>协议继承自另一个协议，即<em class="ld"> Vehicle </em>。所以这个<em class="ld">轮式车辆</em>协议将包括<em class="ld">车辆</em>协议及其自身的所有属性。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="a5e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">定义一个协议保证任何符合该协议的类型都将拥有<em class="ld">所有</em>你在该协议中定义的成员。</strong></p><h1 id="968c" class="mm ln it bd lo mn mo mp lr mq mr ms lu mt mu mv lx mw mx my ma mz na nb md nc bi translated">实现多个协议</h1><p id="16fd" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">一个类只能继承一个类——这就是“单一继承”的属性。相比之下，一个类可以采用任意多的协议！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi no"><img src="../Images/0ebb842cd2088746fcad0108f6a9ef14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5XYjN3JxdmC-HwoC3UDjw.png"/></div></div></figure><p id="7c1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于协议还有很多要学的，但这已经足够在日常代码中实现了。</p><blockquote class="la lb lc"><p id="4ea3" class="jq jr ld js b jt ju jv jw jx jy jz ka le kc kd ke lf kg kh ki lg kk kl km kn im bi translated">一些主题，如标准库中的协议、等价、可比、“自由”函数、Hashable、CustomStringConvertible等，可以在另一篇关于协议的高级文章中讨论。</p></blockquote><h1 id="7fe9" class="mm ln it bd lo mn mo mp lr mq mr ms lu mt mu mv lx mw mx my ma mz na nb md nc bi translated">要点</h1><ul class=""><li id="7221" class="np nq it js b jt mf jx mg kb nr kf ns kj nt kn nu nv nw nx bi translated">协议定义了一个契约，类、结构和枚举可以<strong class="js iu">采用</strong>。</li><li id="ebba" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">通过采用协议，类型需要通过实现协议的所有方法和属性来使<strong class="js iu">符合</strong>协议。</li><li id="301c" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">一个类型可以采用任意数量的协议，这允许通过子类化不允许的准多重继承。</li><li id="e287" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">您可以使用扩展来实现协议的采用和一致性。</li><li id="6c67" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">Swift标准库广泛使用协议。您可以在自己的命名类型上使用其中的许多类型，例如Equatable和Hashable。</li></ul></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt od"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">编写面试问题</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">技术开发</p></div></div><div class="om l"><div class="on l oo op oq om or ky od"/></div></div></a></div></div></div>    
</body>
</html>