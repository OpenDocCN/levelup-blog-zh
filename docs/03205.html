<html>
<head>
<title>JavaScript Refactoring Tips — Classes and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript重构技巧—类和函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-refactoring-tips-classes-and-functions-55e29086224?source=collection_archive---------4-----------------------#2020-04-25">https://levelup.gitconnected.com/javascript-refactoring-tips-classes-and-functions-55e29086224?source=collection_archive---------4-----------------------#2020-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/46027bc679d8b94a742bfc94056d0a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PVq0FaL6KbedkDI2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@ninjason?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梁杰森</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="503a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难写出一段干净的JavaScript代码。</p><p id="ef77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何重构我们的JavaScript函数，使其清晰易读。</p><h1 id="8dce" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将构造函数重构为类</h1><p id="4bcd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，类只是构造函数的语法糖，所以它们实际上是函数。</p><p id="dfdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们扩展另一个构造函数时，通过避免处理原型和使用<code class="fe mh mi mj mk b">call</code>调用父构造函数，类所做的就是为构造函数提供更直观的语法。</p><p id="7d0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8383" class="mt lf it mk b gy mu mv l mw mx">function Foo(name) {<br/>  this.name = name;<br/>}</span><span id="5607" class="mt lf it mk b gy my mv l mw mx">Foo.prototype.getName = function() {<br/>  return this.name;<br/>}</span></pre><p id="13e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8c67" class="mt lf it mk b gy mu mv l mw mx">class Foo {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="26a9" class="mt lf it mk b gy my mv l mw mx">  getName() {<br/>    return this.name;<br/>  }<br/>}</span></pre><p id="cc5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，使用类语法，构造函数在哪里以及我们的类包含哪些实例方法就很清楚了。</p><p id="1a93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们没有将实例方法附加到构造函数的原型上，而是将其添加到类中。</p><p id="4ba2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也不必一直写出关键字<code class="fe mh mi mj mk b">function</code>，这使得打字更短，同时保持代码易于理解。这种语法没有歧义。</p><p id="4164" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想做继承，而不是写作:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4ef5" class="mt lf it mk b gy mu mv l mw mx">function Animal(name) {<br/>  this.name = name;<br/>}<br/>Animal.prototype.getName = function() {<br/>  return this.name;<br/>}</span><span id="308b" class="mt lf it mk b gy my mv l mw mx">function Cat(name) {<br/>  Animal.call(this, name);<br/>}<br/>Cat.prototype.constructor = Animal;</span></pre><p id="728c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bd47" class="mt lf it mk b gy mu mv l mw mx">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  getName() {<br/>    return this.name;<br/>  }<br/>}</span><span id="6463" class="mt lf it mk b gy my mv l mw mx">class Cat extends Animal {<br/>  constructor(name) {<br/>    super(name);<br/>  }<br/>}</span></pre><p id="87ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们会得到一个错误，就是我们忘记了调用父构造函数，而在构造函数的例子中，当我们忘记调用父构造函数时，我们不会得到这个错误。</p><p id="77f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还明确表示，我们正在用关键字<code class="fe mh mi mj mk b">extends</code>扩展<code class="fe mh mi mj mk b">Animal</code>类，而不是必须自己在子构造函数中设置父构造函数。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/61df319a03d6929179adda7bd24565ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4lKLV3GHnOKPJ8SJ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Clode </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="beba" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">尽可能避免传统功能</h1><p id="3ba1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">ES2015之前的一切都使用传统功能。它被用于封装代码，被用作块，被用于我们上面提到的构造函数，被用于回调，等等。</p><p id="a064" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些情况中的大多数已经被ES2015中引入的其他构造函数所取代。</p><p id="14f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想封装代码，我们可以使用块。例如，代替编写如下的立即调用的函数表达式(IIFE ):</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="60b0" class="mt lf it mk b gy mu mv l mw mx">(function() {<br/>  let x = 1;<br/>  console.log(x);<br/>})()</span></pre><p id="bba1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以改为写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d8e5" class="mt lf it mk b gy mu mv l mw mx">{<br/>  let x = 1;<br/>  console.log(x);<br/>}</span></pre><p id="e8eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个例子更短，我们只需要用花括号来分隔代码块。</p><p id="93c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量<code class="fe mh mi mj mk b">x</code>在上面代码的代码块之外不可用。</p><p id="486c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">封装代码的另一种方法是使用模块。例如，我们可以编写以下代码:</p><p id="c1dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">module.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b42b" class="mt lf it mk b gy mu mv l mw mx">export const x = 1;<br/>const y = 2;<br/>const z = 3;<br/>export default y;</span></pre><p id="3b1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">index.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="61a2" class="mt lf it mk b gy mu mv l mw mx">import { x } from "./module";<br/>import y from "./module";<br/>console.log(x, y);</span></pre><p id="0fda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们只在用<code class="fe mh mi mj mk b">export</code>关键字导出它们的时候暴露我们所拥有的。因此，<code class="fe mh mi mj mk b">x</code>和<code class="fe mh mi mj mk b">y</code>可以从另一个模块导入。</p><p id="83eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，<code class="fe mh mi mj mk b">x</code>和<code class="fe mh mi mj mk b">y</code>是从<code class="fe mh mi mj mk b">module.js</code>导入的。但是<code class="fe mh mi mj mk b">z</code>不可能是因为没有出口。</p><p id="656f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不再需要像下面这样的生活:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5d95" class="mt lf it mk b gy mu mv l mw mx">const module = (function() {<br/>  const x = 1;<br/>  const y = 2;<br/>  const z = 3;<br/>  return {<br/>    x,<br/>    y<br/>  }<br/>})();</span></pre><p id="f4b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码比较长，并且使用了一个不必要的函数。此外，随着函数的成员越来越多，它会变得越来越长，使用长函数并不是一个好主意。</p><p id="7b31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于回调，我们可以使用箭头函数来代替。例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fb1e" class="mt lf it mk b gy mu mv l mw mx">const arr = [1, 2, 3].map(function(a) {<br/>  return a * 2;<br/>})</span></pre><p id="d457" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="993e" class="mt lf it mk b gy mu mv l mw mx">const arr = [1, 2, 3].map(a =&gt; a * 2)</span></pre><p id="aa4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它更短，所以我们不必键入太多，就像我们不必键入我们的<code class="fe mh mi mj mk b">function</code>关键字一样。此外，对于单行箭头函数，返回是隐式的。我们也不必担心<code class="fe mh mi mj mk b">this</code>和<code class="fe mh mi mj mk b">arguments</code>的值，因为箭头函数不会绑定到这些值。</p><h1 id="fc05" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="3e80" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要重构函数，我们应该将构造函数转换为类。否则，我们应该将它们转换成我们认为合适的块、模块和箭头函数。</p></div></div>    
</body>
</html>