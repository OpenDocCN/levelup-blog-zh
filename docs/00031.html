<html>
<head>
<title>Finding the Right Balance: An Intro to the Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">找到正确的平衡:二叉查找树介绍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-binary-search-tree-80de5570f88a?source=collection_archive---------0-----------------------#2017-11-03">https://levelup.gitconnected.com/the-binary-search-tree-80de5570f88a?source=collection_archive---------0-----------------------#2017-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/4c4ad4137f47e646acf37c8af4a4daa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-pypJeQfQQ2pnyE6p9GEQ.jpeg"/></div></figure><div class=""/><p id="160e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我编程之旅的开始，我有一长串的问题要问，也有一长串的问题要问<em class="ks">我</em>。我最喜欢的问题是:“你如何平衡二叉查找树？”我最初对这个问题的回答是，“什么是二叉查找树？会用在什么地方？它的替代品是什么？”最后，“什么时候使用它不是最佳的，甚至是有害的？”这就是我的发现。</p><p id="735b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">二叉查找树(BST)是一种应用二分搜索法算法原理的数据树结构，用于查找目标在分类数据集合中的位置。一个常见的例子是这样的:</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/354bd492f96e0153d7557c8394caa10c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*upeO9MmSh-8uhPKwy7wjKg.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://en.wikipedia.org/wiki/Binary_search_tree#/media/File:Binary_search_tree.svg" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Binary _ search _ tree #/media/File:Binary _ search _ tree . SVG</a></figcaption></figure><p id="0a47" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该树由节点组成，每个节点代表树中的一个点，并且每个节点具有一个<em class="ks">可比较的关键字</em>；单个节点的连续分支称为其子节点。虽然其他树数据结构的节点可以有任意数量的子节点，但二叉树的每个节点最多只能有两个子节点。此外，BST不是随机集合；每个<em class="ks">左</em>子节点小于或等于父节点，每个<em class="ks">右</em>子节点大于或等于父节点。由于这个原因，BST也被称为排序树。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h2 id="35f6" class="lk ll ix bd lm ln lo dn lp lq lr dp ls kf lt lu lv kj lw lx ly kn lz ma mb mc bi translated">建筑</h2><p id="b7a2" class="pw-post-body-paragraph ju jv ix jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">用Javascript之类的语言以编程方式构建它是一个相对简单的递归函数，它依赖于两个类:一个Node类和一个BST类。</p><figure class="ku kv kw kx gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="cbe3" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">节点的构造函数有三个属性:节点的<em class="ks">值</em>，左<em class="ks">值</em>和右<em class="ks">值</em>；后两个缺省值为null，直到其他节点被添加到树中。这就把我们带到了BST类:</p><figure class="ku kv kw kx gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b605" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最基本的，BST包含两个函数:<code class="fe mk ml mm mn b">constructor()</code>和<code class="fe mk ml mm mn b">add()</code>。这些允许我们以树格式构建数据的编程表示。一旦我们的节点被组织在这个架构中，使用BST类中的其他函数(例如，<code class="fe mk ml mm mn b">findMin()</code>和<code class="fe mk ml mm mn b">findMax()</code>函数分别映射过滤器通过树的左或右分支)对我们的数组进行排序以找到最小值、最大值和目标值在集合中的位置就变得非常容易。</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/0866bfe4dbd82535ed6b163f7667e20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/1*OmRV7P0YluY2ToRj44jKGA.gif"/></div></figure><p id="f6af" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么什么时候我们会在另一个数据结构上使用BST呢？好吧，让我们来看看不同之处…</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h2 id="07a1" class="lk ll ix bd lm ln lo dn lp lq lr dp ls kf lt lu lv kj lw lx ly kn lz ma mb mc bi translated">大O符号</h2><p id="c7b0" class="pw-post-body-paragraph ju jv ix jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">BST的一种常见替代数据结构是哈希表。相比之下，哈希表在最坏的情况下是线性的，O(n)，随着数据集的增长，效率变得更低。在最好的情况下，它可以是常数或O(1)，尽管在Big-O符号中，我们通常关心最坏的情况。</p><p id="3b19" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，BST是一种对数方法，O(log n)，随着数据集的增长和我们沿着曲线前进，最终会趋于平稳。正因为如此，后者可以被视为在时间和内存方面具有成本效益，只存储需要的内容。</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/e56727b39f6b5b7220e95c10402879d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*euZeucSj-TxWNYbcJf0GBg.png"/></div></figure><p id="3b58" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然<em class="ks">和</em>结构都映射为键值对，但是哈希表并不维护数据结构的顺序。因此，当我们想要高效地对大型数据集进行排序并保持有序时，BST被认为是更理想的结构。但是当我们的BST速度慢，效率低的时候呢？我们如何做到这一点？</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h2 id="3174" class="lk ll ix bd lm ln lo dn lp lq lr dp ls kf lt lu lv kj lw lx ly kn lz ma mb mc bi translated">平衡我们的BST</h2><p id="c80e" class="pw-post-body-paragraph ju jv ix jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">根据我们插入和删除数据的方式，二叉查找树可能会变得不平衡。让我们考虑一下，如果我们将一个顺序递增的数组中的元素一次一个地添加到一个空的BST中，会发生什么情况。假设我们正确地构造了它，结果将是一个完全右侧的树，其高度与项目总数相同。虽然从技术上讲，这种顺序仍然是一种排序结构，但它完全破坏了BST的好处和优势，并被认为是最坏的情况，将BST简化为O(n)的线性结构/链表。</p><p id="97c4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以想象，如果只有一边有物品，没有东西可以比较，或者更糟的是，如果空的时候两边的重量不一样，秤会变得多么无用。同样的想法也适用于BST。</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/2b7286227a0a3d81acb21125cc77cd2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*wJeUR4KyxUdVHCNEDX60Qw.jpeg"/></div></figure><p id="534c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了纠正这一点，我们在插入和移除时采用了一种平衡方法，将高度限制在一个下限的常数因子内。通常，对于节点的分支，该界限或平衡因子(BF)具有[-1，+1]的整数范围。节点的BF由其左右分支的高度差决定。如果我们添加或删除一个节点，父节点的左或右高度将需要相应地更新，因此BF已经改变。这分别通过树继续向后，直到触及根。</p><p id="3f11" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">自平衡BST的一个常见示例是AVL树。例如，在一个JavaScript AVL树中，我们可以使用构造函数中的一个<code class="fe mk ml mm mn b">this.depth</code>属性并设置值等于<code class="fe mk ml mm mn b">1</code>，一个初始为<code class="fe mk ml mm mn b">0</code>的左右高度，以及一个递归的<code class="fe mk ml mm mn b">BST.balance()</code>函数来比较每个分支的高度。当任何节点的左右高度差大于1时，BF超过范围，树<em class="ks">旋转</em>进行补偿。我们旋转树的方向有两种可能的方式:单次旋转或两次旋转。</p><p id="732e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，如果我们的不平衡是在一个节点的左分支，我们做一个单一的右旋转，旋转我们的树，使不平衡的左子节点现在是父节点；换句话说，如果左边更重，我们向右旋转，反之亦然。</p><p id="e7fe" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下面的右旋转示例中，由于A小于或等于B，α小于A，因此当A成为父对象并向上旋转时，它会保留α作为其左子对象。</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/eddcb3bb33e18a273b0f7f92e8d784d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*KFvuhHf007DbjeXAwv3W2A.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://en.wikipedia.org/wiki/Tree_rotation" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Tree_rotation</a></figcaption></figure><p id="b432" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为在我们的pivot中B大于A，所以它现在是正确的孩子。因为γ大于B，而B又大于A，所以γ仍然是B的右子节点。但是请记住，当我们将A作为父节点时，它已经有了两个子节点，不能再有第三个了。那么我们用β做什么呢？</p><p id="fb9a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以在这里应用一些基本的逻辑:A小于或等于B，而β大于或等于A。这意味着β在这个能力上是有限的，如果它是A的子节点，它就不能大于B。由于A以前是B的左子节点，现在已经旋转到父节点，B没有左子节点。这个空间现在被β占据了。如果我们做单次<em class="ks">向左</em>旋转，我们可以反过来应用同样的逻辑。</p><p id="c18b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，如果不平衡在<em class="ks">左</em>子<em class="ks">右</em>子树中，简单的单次右旋转将导致另一个不平衡。例如，如果我们如上所述对-2不平衡执行一次旋转，我们的新父节点实际上以+2不平衡结束。</p><p id="9235" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了纠正这一点，我们将执行双旋转或三节点重组:首先向右旋转，然后再次沿着新的不平衡节点旋转树，这次是向左。同样，如果我们做左右旋转，我们可以反过来应用同样的逻辑。</p><p id="8fcc" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要查看AVL树的JS实现示例，我们可以参考Joselito的以下公开要点:</p><figure class="ku kv kw kx gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a39c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>