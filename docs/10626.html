<html>
<head>
<title>Ransom note challenge in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的勒索信挑战</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ransom-note-challenge-in-kotlin-bfe334fe2e15?source=collection_archive---------17-----------------------#2021-12-27">https://levelup.gitconnected.com/ransom-note-challenge-in-kotlin-bfe334fe2e15?source=collection_archive---------17-----------------------#2021-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="94d0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">微软根据LeetCode最常问的面试问题。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5cdbd946b6eb446f8b0a019680f03af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWEuY4evjmJ3rbDbkpXvLw.png"/></div></div></figure><p id="5c01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">给定一个任意的赎金通知字符串和另一个包含来自所有杂志的信件的字符串，写一个函数，如果赎金通知可以从杂志中构造，该函数将返回true否则，返回<em class="lq">假</em>。</p><p id="57b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">杂志上的每个字母在你的勒索信里只能用一次。</strong></p><p id="7ad1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑这个例子:</p><p id="f5d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">"a", "b" -&gt; false</code></p><p id="4aed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">"aa", "ab" -&gt; false</code></p><p id="f29c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">"aa", "aab" -&gt; true</code></p><h1 id="94c9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">哈希快速回顾</h1><p id="1718" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">在下面的解决方案中，我们使用hashmap来保存数据。因此，在展示解决方案之前，快速回顾一下<strong class="kw iu">哈希</strong>非常重要。</p><p id="785f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">哈希</strong>用于将任意大小的数据映射到固定大小的数据。</p><p id="ed96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个<strong class="kw iu">哈希映射</strong>是一个可以将<em class="lq">键</em>映射到<em class="lq">值</em>的结构。他们使用散列函数智能地计算出在哪里存储元素。所有操作<em class="lq">读取</em>、<em class="lq">插入</em>和<em class="lq">删除</em>花费恒定的时间<code class="fe lr ls lt lu b">O(1)</code>。</p><p id="f350" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果两个键映射到相同的值，就会发生<strong class="kw iu">冲突</strong>。</p><p id="bdb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">处理<em class="lq">碰撞</em>的一种常见方式是使用<strong class="kw iu">链接</strong>。用<strong class="kw iu">链接</strong> <em class="lq">键</em>和它们的<em class="lq">值</em>不直接存储在数组中。每个数组元素是零个或多个键/值对的列表。在这种情况下，哈希映射操作的时间是找到存储桶的时间(常量时间)，加上遍历列表的时间。</p><h1 id="e2c7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解决方案</h1><p id="4df3" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">一个可能的解决方案是统计<em class="lq">库</em>串中的出现次数，并保存在<code class="fe lr ls lt lu b">hashmap</code>中。之后，循环赎金<em class="lq">注意</em>并减少遇到的每个字符的值。如果hash内的对应值小于零，则返回<strong class="kw iu">假</strong>，否则返回<strong class="kw iu">真</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="ba55" class="mu lw it bd lx mv mw dn mb mx my dp mf ld mz na mh lh nb nc mj ll nd ne ml nf bi translated">时间和空间复杂性</h2><p id="979f" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated"><strong class="kw iu">时间</strong>复杂度等于弹匣管柱的<code class="fe lr ls lt lu b">O(m)</code>和赎金管柱的<code class="fe lr ls lt lu b">O(n)</code>。最后的结果是<code class="fe lr ls lt lu b">O(m) + O(n).</code></p><p id="582a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">空间</strong>复杂度等于<code class="fe lr ls lt lu b">O(n)</code>内存中保存<code class="fe lr ls lt lu b">hash</code>的空间。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="e4dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在结束之前，我建议你喜欢并分享这篇文章，并留下评论。它不会让你付出任何代价，同时鼓励我继续创作其他类似的内容。谢谢你的支持。</p><p id="dd08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下节课再见。😉</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="0fa8" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">本系列的其他帖子</h1><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/find-the-non-duplicate-number-in-an-array-e7d56544b5d6"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">在数组中寻找不重复的数字。</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">给定一个非空的整数数组，除了一个元素外，每个元素都出现两次。找到那个单身的。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div></div></div>    
</body>
</html>