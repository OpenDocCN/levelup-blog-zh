<html>
<head>
<title>Building Immutable Data Structures In Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中构建不可变的数据结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-immutable-data-structures-in-go-56a1068c76b2?source=collection_archive---------0-----------------------#2018-12-30">https://levelup.gitconnected.com/building-immutable-data-structures-in-go-56a1068c76b2?source=collection_archive---------0-----------------------#2018-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7e1b3068b5b62acef8f8fb284b97a1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-uPi3TS9eE47EoIRvEOLw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@frantzou?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Frantzou Fleurine </a>在<a class="ae kc" href="https://unsplash.com/search/photos/solid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">共享状态很容易理解和使用，但是会导致难以追踪的细微错误。尤其是当你的数据结构只有一部分是通过引用传递的时候。切片就是一个很好的例子。稍后我会更详细地解释这一点。</p><p id="05f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不可变数据结构在处理经过几个转换阶段的数据时非常有用，或者说<em class="lb">状态</em>。不可变仅仅意味着原始结构没有改变，而是用新的属性值创建了该结构的新副本。</p><p id="c7e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们先来看一个简单的案例:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5bf0" class="ll lm iq lh b gy ln lo l lp lq">type Person struct {<br/>    Name           string<br/>    FavoriteColors []string<br/>}</span></pre><p id="a7e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然我们可以实例化一个<code class="fe lr ls lt lh b">Person</code>并随意修改属性。这种方法本身没有任何问题。然而，当您进入更复杂的嵌套结构(通过通道传递引用、切片和副本)时，数据的共享副本可能会被修改，从而产生非常微妙的错误。</p><h1 id="b3ca" class="lu lm iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">为什么我以前没有遇到过这些问题？</strong></h1><p id="92e1" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">如果您没有大量使用通道，或者您的代码以非常线性的方式工作，那么您不太可能会遇到微妙的错误，因为根据定义，一次只有一件事情在操作您的数据。</p><p id="223b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，除了避免错误之外，不可变数据结构还有其他好处:</p><ol class=""><li id="b469" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">由于状态从未原地改变，因此最好进行一般调试，并记录转换的每一步，以便以后仔细检查。</li><li id="2892" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">撤销，或“回到过去”的能力不仅是可能的，而且是微不足道的，因为它是通过赋值来完成的。</li><li id="9ee2" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">共享状态被广泛认为是一个坏主意，因为要正确和安全地实现它，需要仔细放置/测试内存锁定的性能和复杂性。</li></ol><h1 id="9f35" class="lu lm iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">吸气剂和<em class="nk">萎</em>和</strong></h1><p id="18c9" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated"><em class="lb">getter</em>返回数据，<em class="lb">setter</em>变异状态，<em class="lb"> withers </em>创建新状态。</p><p id="ce8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用getters和withers，我们可以精确地控制哪些属性可以被改变。这也给了我们一个很好的方法来记录过渡(稍后)。</p><p id="3896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新代码如下所示:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="f1d4" class="ll lm iq lh b gy ln lo l lp lq">type Person struct {<br/>    name           string<br/>    favoriteColors []string<br/>}</span><span id="55d7" class="ll lm iq lh b gy nl lo l lp lq">func (p Person) WithName(name string) Person {<br/>    p.name = name<br/>    return p<br/>}</span><span id="009e" class="ll lm iq lh b gy nl lo l lp lq">func (p Person) Name() string {<br/>    return p.name<br/>}</span><span id="abb6" class="ll lm iq lh b gy nl lo l lp lq">func (p Person) WithFavoriteColors(favoriteColors []string) Person {<br/>    p.favoriteColors = favoriteColors<br/>    return p<br/>}</span><span id="6383" class="ll lm iq lh b gy nl lo l lp lq">func (p Person) FavoriteColors() []string {<br/>    return p.favoriteColors<br/>}</span></pre><p id="8be1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要注意的重要事项是:</p><ol class=""><li id="457e" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><code class="fe lr ls lt lh b">Person</code>属性是私有的，因此外部包不能绕过这些方法。</li><li id="8581" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe lr ls lt lh b">Person</code> <strong class="kf ir">的功能不</strong>接收<code class="fe lr ls lt lh b">*Person</code>。这确保了结构通过值传递并通过值返回。</li><li id="953f" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">请注意，我使用了“With”一词，而不是“Set ”,以区分返回值是重要的，原始对象没有像setter暗示的那样被修改。</li><li id="9e85" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">这个包中的其他代码仍然可以访问这些属性(因此是可变的)。永远不要直接与属性交互，即使在同一个包中也要使用这些方法。</li><li id="8390" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">每个萎者返回<code class="fe lr ls lt lh b">Person</code>，这样他们就可以被锁住:</li></ol><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="49cf" class="ll lm iq lh b gy ln lo l lp lq">me := Person{}.<br/>    WithName("Elliot").<br/>    WithFavoriteColors([]string{"black", "blue"})<br/>        <br/>fmt.Printf("%+#v\n", me)</span><span id="9223" class="ll lm iq lh b gy nl lo l lp lq">// main.Person{name:"Elliot", favoriteColors:[]string{"black", "blue"}}</span></pre><h1 id="2272" class="lu lm iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">处理切片</strong></h1><p id="368f" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">到目前为止，它仍然不理想，因为我们正在返回一个最喜欢的颜色的切片。由于切片是通过引用传递的，因此我们可以看到一个可能被忽略的错误示例:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5d2c" class="ll lm iq lh b gy ln lo l lp lq">func updateFavoriteColors(p Person) Person {<br/>    colors := p.FavoriteColors()<br/>    colors[0] = "red"<br/>    <br/>    return p<br/>}</span><span id="0025" class="ll lm iq lh b gy nl lo l lp lq">func main() {<br/>    me := Person{}.<br/>        WithName("Elliot").<br/>        WithFavoriteColors([]string{"black", "blue"})<br/>        <br/>    me2 := updateFavoriteColors(me)<br/>        <br/>    fmt.Printf("%+#v\n", me)<br/>    fmt.Printf("%+#v\n", me2)<br/>}</span><span id="d9db" class="ll lm iq lh b gy nl lo l lp lq">// main.Person{name:"Elliot", favoriteColors:[]string{"red", "blue"}}<br/>// main.Person{name:"Elliot", favoriteColors:[]string{"red", "blue"}}</span></pre><p id="496e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们打算改变第一种颜色，但是它也有改变<code class="fe lr ls lt lh b">me</code>变量的副作用。因为这不会阻止代码在更复杂的应用程序中继续运行，所以试图寻找这样的突变会非常令人沮丧和耗时。</p><p id="a5cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种解决方案是确保我们从不按索引分配，而总是分配新的切片:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="4b1f" class="ll lm iq lh b gy ln lo l lp lq">func updateFavoriteColors(p Person) Person {<br/>    return p.<br/>        WithFavoriteColors(append([]string{"red"}, p.FavoriteColors()[1:]...))<br/>}</span><span id="fedc" class="ll lm iq lh b gy nl lo l lp lq">// main.Person{name:"Elliot", favoriteColors:[]string{"black", "blue"}}<br/>// main.Person{name:"Elliot", favoriteColors:[]string{"red", "blue"}}</span></pre><p id="9a63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我看来，这既笨拙又容易出错。更好的方法是一开始就不要返回切片。扩展getters和withers，只对元素(而不是整个切片)进行操作:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e02d" class="ll lm iq lh b gy ln lo l lp lq">func (p Person) NumFavoriteColors() int {<br/>    return len(p.favoriteColors)<br/>}</span><span id="f42e" class="ll lm iq lh b gy nl lo l lp lq">func (p Person) FavoriteColorAt(i int) string {<br/>    return p.favoriteColors[i]<br/>}</span><span id="2245" class="ll lm iq lh b gy nl lo l lp lq">func (p Person) WithFavoriteColorAt(i int, favoriteColor string) Person {<br/>    p.favoriteColors = append(p.favoriteColors[:i],<br/>        append([]string{favoriteColor}, p.favoriteColors[i+1:]...)...)<br/>    return p<br/>}</span></pre><p id="2683" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以安全地使用:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="9798" class="ll lm iq lh b gy ln lo l lp lq">func updateFavoriteColors(p Person) Person {<br/>    return p.WithFavoriteColorAt(0, "red")<br/>}</span></pre><p id="94ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看这个伟大的维基来学习切片技巧:<a class="ae kc" href="https://github.com/golang/go/wiki/SliceTricks" rel="noopener ugc nofollow" target="_blank">https://github.com/golang/go/wiki/SliceTricks</a></p><h1 id="1ec8" class="lu lm iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">构造函数</strong></h1><p id="dbb0" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在某些情况下，我们可以假设结构默认值是合理的。但是，最好总是创建一个构造函数，这样如果我们将来需要更改默认值，它就存在于一个地方:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="cc09" class="ll lm iq lh b gy ln lo l lp lq">func NewPerson() Person {<br/>    return Person{}<br/>}</span></pre><p id="ffb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以随意实例化<code class="fe lr ls lt lh b">Person</code>,但是我更喜欢总是通过设置器来进行状态转换，以保持一致性:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e213" class="ll lm iq lh b gy ln lo l lp lq">func NewPerson() Person {<br/>    return Person{}.<br/>        WithName("No Name")<br/>}</span></pre><h1 id="e6e8" class="lu lm iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">接口</strong></h1><p id="e678" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">到目前为止，我们仍然使用公共结构。这对于测试来说可能是痛苦的，因为我们受到这些方法的支配，并且创建模拟可能会有不想要的副作用。</p><p id="1e66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建一个同名的接口，并通过将其重命名为<code class="fe lr ls lt lh b">person</code>来使该结构私有:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ce12" class="ll lm iq lh b gy ln lo l lp lq">type Person interface {<br/>    WithName(name string) Person<br/>    Name() string<br/>    WithFavoriteColors(favoriteColors []string) Person<br/>    NumFavoriteColors() int<br/>    FavoriteColorAt(i int) string<br/>    WithFavoriteColorAt(i int, favoriteColor string) Person<br/>}</span><span id="5e4e" class="ll lm iq lh b gy nl lo l lp lq">type person struct {<br/>    name           string<br/>    favoriteColors []string<br/>}</span></pre><p id="98f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以通过仅覆盖我们希望存根的逻辑来创建测试模拟:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="4b4d" class="ll lm iq lh b gy ln lo l lp lq">type personMock struct {<br/>    Person<br/>    receivedNewColor string<br/>}</span><span id="5c04" class="ll lm iq lh b gy nl lo l lp lq">func (m personMock) WithFavoriteColorAt(i int, favoriteColor string) Person {<br/>    m.receivedNewColor = favoriteColor<br/>    return m<br/>}</span></pre><p id="a8b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试代码可能看起来像这样:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="8606" class="ll lm iq lh b gy ln lo l lp lq">mock := personMock{}<br/>result := updateFavoriteColors(mock)<br/>    <br/>result.(personMock).receivedNewColor // "red"</span></pre><h1 id="01e3" class="lu lm iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">记录变化</strong></h1><p id="49ea" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">正如我前面提到的，全状态转换非常适合调试，我们可以通过挂钩withers来捕获所有或部分转换:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="d939" class="ll lm iq lh b gy ln lo l lp lq">func (p person) nextState() Person {<br/>    fmt.Printf("nextState: %#+v\n", p)<br/>    return p<br/>}</span><span id="dcb4" class="ll lm iq lh b gy nl lo l lp lq">func (p person) WithName(name string) Person {<br/>    p.name = name<br/>    return p.nextState() // &lt;- Use "nextState" whenever you return.<br/>}</span></pre><p id="6f0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您有更复杂的逻辑，或者如果您愿意，您可以使用<code class="fe lr ls lt lh b">defer</code>来代替:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="dc09" class="ll lm iq lh b gy ln lo l lp lq">func (p person) WithFavoriteColors(favoriteColors []string) Person {<br/>    defer func() {<br/>        p.nextState()<br/>    }()</span><span id="85dc" class="ll lm iq lh b gy nl lo l lp lq">    p.favoriteColors = favoriteColors<br/>    return p<br/>}</span></pre><p id="7e24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以看到变化:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="2ac1" class="ll lm iq lh b gy ln lo l lp lq">nextState: main.person{name:"No Name", favoriteColors:[]string(nil)}<br/>nextState: main.person{name:"Elliot", favoriteColors:[]string(nil)}<br/>nextState: main.person{name:"Elliot", favoriteColors:[]string{"black", "blue"}}</span></pre><p id="5ac4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能需要添加更多的信息。例如时间戳、堆栈跟踪或其他定制上下文，以便于调试。</p><h1 id="9cae" class="lu lm iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">历史和回滚</strong></h1><p id="bc97" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们可以收集状态作为历史，而不是打印更改:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="b977" class="ll lm iq lh b gy ln lo l lp lq">type Person interface {<br/>    // ...<br/>    AtVersion(version int) Person<br/>}</span><span id="d054" class="ll lm iq lh b gy nl lo l lp lq">type person struct {<br/>    // ...<br/>    history        []person<br/>}</span><span id="c19a" class="ll lm iq lh b gy nl lo l lp lq">func (p *person) nextState() Person {<br/>    p.history = append(p.history, *p)<br/>    return *p<br/>}</span><span id="e8fb" class="ll lm iq lh b gy nl lo l lp lq">func (p person) AtVersion(version int) Person {<br/>    return p.history[version]<br/>}</span><span id="d97c" class="ll lm iq lh b gy nl lo l lp lq">func main() {<br/>    me := NewPerson().<br/>        WithName("Elliot").<br/>        WithFavoriteColors([]string{"black", "blue"})<br/>    <br/>    // We discard the result, but it will be put into the history.    <br/>    updateFavoriteColors(me)</span><span id="fb90" class="ll lm iq lh b gy nl lo l lp lq">    fmt.Printf("%s\n", me.AtVersion(0).Name())<br/>    fmt.Printf("%s\n", me.AtVersion(1).Name())<br/>}</span><span id="5313" class="ll lm iq lh b gy nl lo l lp lq">// No Name<br/>// Elliot</span></pre><p id="239f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于最后需要进行自省的时候非常有用。如果以后出现问题，记录要记录的所有历史也是有用的，否则历史可以随实例一起丢弃。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="611e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">原载于2018年12月30日</em><a class="ae kc" href="http://elliot.land/post/building-immutable-data-structures-in-go" rel="noopener ugc nofollow" target="_blank"><em class="lb">http://Elliot . land</em></a><em class="lb">。</em></p></div></div>    
</body>
</html>