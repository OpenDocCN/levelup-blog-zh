# 如何用 Kotlin 编写线程安全的代码

> 原文：<https://levelup.gitconnected.com/how-to-write-thread-safe-code-with-kotlin-8a56ca6ff7a>

![](img/773165e2fea884aebaf00c984a6c274c.png)

Kotlin 使得编写**线程安全**代码变得容易(特别是如果我们把它与 Java 相比的话)，然而如果开发者想要他/她的代码真正是线程安全的，他/她仍然必须遵循一些基本规则。这个故事将介绍要遵循的主要规则，以及 Kotlin 提供的工具，但首先让我们讨论一下什么是*线程安全*代码。

## 线程安全代码

当代码需要使用多个线程运行时，可能会出现各种各样的问题，主要分为以下几类:

*   **并发修改**(或竞争条件):两个线程同时试图修改一个对象，如果对象是一个集合，通常会导致应用崩溃；这个问题通常可以通过使用同步节来解决。
*   **死锁(或活锁)**:当尝试使用同步段时，我们可能会创建两个线程互相等待的情况；这导致应用程序冻结。

防止这些问题的黄金法则是只使用**不可变对象**。不可变对象是其状态在创建后不能改变的对象。因此，不存在并发修改的风险，并且由于不需要同步，我们还防止了死锁的风险。这也是为什么在本文**中，我们将关注无需同步就能实现线程安全的技术**。

但是说起来容易，实现起来通常更难，尤其是当来自传统上对象是有状态的 Java 背景时(POJO、beans 等)。).幸运的是，Kotlin 提供了大量的语法糖，这将帮助我们在不损失太多性能的情况下，创建不可变的对象，以及更一般的线程安全代码。

## 尽可能使用 val

在 Kotlin 中声明变量或类成员时，我们可以在两个关键字之间进行选择: **val** 和 **var** 。

*var* 基本上是指引用或变量的值是可以改变的，而 *val* 是指它将是常量(只初始化一次)。

如果我们想要创建一个不可变的对象，那么它的所有成员都应该用关键字 *val* 声明。 *var* 关键字应该只用于局部变量(即函数或方法内部的变量)。

## 使用科特林的不可变集合

使用 *val* 关键字只能确保变量总是引用同一个对象。如果我写:

> **val**list = ArrayList<String>()

那么“列表”将总是引用同一个列表，但这并不意味着列表将是恒定的:我们仍然可以从列表中添加或删除元素。这意味着**如果这个列表是类的成员，代码有可能不是线程安全的**:如果两个线程试图调用一个改变列表内容的方法，将会有一个并发修改异常。

为了避免这种情况，最好使用 Kotlin 的不可变集合。而不是写:

> **val**list = arrayListOf<String>()

偏好写作:

> **val**list = list of<String>()

当第一个创建一个可变列表时，第二个将创建一个没有任何方法来从列表中添加或删除元素的列表。当然，这意味着在创建列表时，我们必须知道我们希望列表中包含哪些元素。

在这种情况下，列表可能会像这样初始化:

在第一个例子中，我们给出了列表中的所有值。对于第二个，使用 lambda 表达式初始化值，该表达式的参数是列表中元素的索引(列表构造函数的第一个参数是列表的期望大小)。注意:在 Kotlin 中， *List* 是一种不可变列表，而 *ArrayList* 是一种可变列表。

对于不可变列表的初始化，也可以将可变列表声明为局部变量，然后将对该列表的引用存储为不可变列表:

在这种情况下，我们必须确保我们不会保留对可变列表的任何引用，因为它应该只是一个帮助我们编写不可变列表初始化的工具，而不是我们以后要使用的东西。

## 使用数据类

数据类是一种特殊的类，其主要目的是保存数据。像任何其他类一样，这些数据类可以有成员和方法，但是它们在编写线程安全代码时也提供了一个非常有用的方法: *copy()* 方法。

假设我们声明一个数据类来保存一些数据。我们希望这个类中的对象是不可变的，因为我们正在编写线程安全的代码，所以所有的属性都必须用关键字 *val* 声明。现在，我们正在操作这个类中的一个对象，我们想“改变”它的一个成员的值:我们没有其他选择，只能用这个成员的新值创建一个相同类的新对象。

对于标准类，编写起来相当烦人。但是数据类提供了语法上的好处来使它变得容易。它是这样工作的:

当然，也可以封装此行为，使其看起来像是我们真的在修改对象，而实际上我们是在创建一个新对象:

在这里，我们提出一个线程安全的 *changePassword* 方法，它并不真正改变用户的密码，而是通过创建一个新用户来看起来像是这样，这个新用户是原始用户的精确副本，但是具有新的密码。

注意: *copy()* 没有对对象进行深度复制，因此如果数据对象存储了对可变对象的引用，那么对该对象内容的任何更改都将出现在原始数据对象及其副本中。

## 使用同步块

只使用不可变对象并不总是可能的。有时，如果我们必须频繁地编辑对象的内容，那么为了改变属性值而创建不可变对象的新副本的成本会非常高。

如果是这种情况，我们将不得不切换回更经典的方法，使用同步块。

与 Java 不同，Kotlin 不提供一个*同步*关键字来允许我们编写互斥部分。但是，这并不重要，因为 Kotlin 提供了一个*同步*函数来实现相同的目的:

但是正如我上面所说的，**如果可能的话，我们应该避免使用同步块**，因为这会导致死锁问题。这种解决方案只有在使用不可变对象严重影响性能时才有好处。

## 使用已经定义的线程安全结构

如果不能套用之前给的建议，还是有办法的。JVM 定义了几个基本上线程安全的类和集合。

还有*原子*原语，比如*原子集成器*。即使几个线程试图同时修改一个 *AtomicInteger* 的值，我们也永远不会有一个由竞争条件引起的这种对象的未定义状态。

还有线程安全的集合，比如*collections . synchronized list*。

我个人不建议使用这些解决方案，原因有二:

*   它们不是多平台的:它们依赖于 JVM，所以不能与 Kotlin/Native(当然还有 Kotlin/JS)一起使用
*   同步的集合并不完全是线程安全的，仍然有可能触发 ConcurrentModificationException，所以开发人员通常必须添加额外的同步层

总之，我们已经看到了 Kotlin 提供的确保线程安全的主要工具:

*   val 关键字帮助我们定义不可变的对象
*   提供**不可变集合**的标准库
*   由**数据类**提供的一些语法糖，帮助我们操作不可变的对象

如果我们没有选择，我们仍然可以依靠:

*   语言的**同步机制**，这里快速介绍
*   Java 标准库的同步类(如果我们计划在 JVM 上运行)

当然，多线程的主题非常广泛，Kotlin 为此提供了许多便利的特性，我们在那里没有研究过。但是如果您想丰富您的文化，您可以看看 Kotlin 提供的高级同步机制和协程的用法。

然而，这些解决方案并不神奇，如果您不小心，它们不会让您编写线程安全的代码，这就是为什么线程安全数据结构的定义(主要使用不可变对象)应该始终作为编写多线程代码的基础。

[](https://skilled.dev) [## 编写面试问题

### 一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…

技术开发](https://skilled.dev)