# 到目前为止，作为一名专业开发人员，我学到了什么

> 原文：<https://levelup.gitconnected.com/what-ive-learned-working-as-a-professional-developer-so-far-412b4eb6e402>

![](img/9423bc11f0516a7b546e48b6c2c61ee1.png)

凯利·西克玛在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

我在 2018 年开始学习如何编码，当时我刚开始在 FreeCodeCamp 上工作。

当时，我想找到一个很好的利用时间的方法，并认为编码是一个很好的方法。我记得我的第一个项目，一个简单的计算器，以及我第一次安装它时的兴奋，尤其是当所有的东西第一次一起点击的时候。然而，我从来没有认真对待过它，直到一年后我进了大学。

不久之后，当我在达洛帕开始第一份实习工作时，我发现自己陷入了一场严峻的考验。现在，这个夏天我在 Holmusk 做软件工程师，在过去的几个月里我学到了很多。我想我应该简单地写下这篇文章，来反思我从艰难的道路中学到的一些教训。

# 保持简单愚蠢(吻)

当我第一次开始阅读编程文章时，我经常听到这个咒语，但从未真正掌握它。直到我在一个专业的环境中工作，我的代码被仔细检查，我才意识到保持你的代码简单和精确的重要性。

我个人觉得这样做主要有两个原因。

1.  您的代码将在未来构建。人们会阅读它并努力扩展它的功能。通过使您的代码更加通用，您可能已经节省了 100 行代码，但是如果它是以特殊性和冗长性为代价的，它将使将来的功能难以添加。相反，考虑先写代码，然后抽象
2.  当你提出拉取请求或要求人们阅读你的代码时，你占用了他们一天中宝贵的时间。高级工程师/你的同事不会整天无止境地等待。每一个你要求评审的拉动式请求都会消耗他们的时间和脑力，潜在地延误他们自己的工作和项目

对此，我找到了一些简单的解决方法，就是编写更简洁、功能更强的代码。让我们举一个例子

1.  筛选出显示属性为 true 的所有项目
2.  将 abc 的 newProp 的新属性添加到这些项目中

```
*//Sample Input
input = [{…,item:{display:true}},{…,item:{display:false}},{…,item:{display:true}}]*//Sample Output*Desired Output = [{…item,{display:true},newProp:abc},{…item,{display:true},newProp:abc},{…item,{display:true},newProp:abc}…]*
```

我们已经写好了现有的代码。

```
//A little bad Code
x = []
for (let i = 0 ;i < something.length;i++){
    const item = items[i]
    const item_trueness = item['display']
    if(item_trueness!==true){x.push(item)}
    else{pass}
}new_items = []for(let j = 0 ; j < x.length; x++ ){
    let new_object = x[j]
    new_object[newProp] = "abc"
    new_items.push(new_object)}
```

代码本身并不差。就其目的而言，这有点罗嗦，而且会让人花费不必要的时间去理解它。相反，让我们应用一些**析构**、**移除不必要的控制流**和**利用扩展操作符。**

```
x = []
for (let i = 0 ;i < items.length;i++){    
    const {display} = item
    if(display){x.push(item)}
}new_items = []for(let j = 0 ; j < x.length; x++ ){
    new_items.push({...x[j],newProp:"abc"}
}
```

在这种情况下，我们甚至可以更进一步，使用更纯粹的函数，比如 filter 和 map。我不会在这篇文章中重复这些函数的作用。并不是每个人都熟悉它们，但是如果你的团队能够自如地使用它们，我强烈建议尝试一下。

```
return items.filter(item=>item['display']).map(item=>{...item,newProp:"abc"})
```

# 问问题

当我刚开始问问题时，我会问一些非常糟糕的问题。让他们变坏的是他们缺乏特异性。

例如，我会问**我如何让 X 发生？**

这不是一个好问题，不仅因为它把责任放在了你要问的人身上，而且也没有让他们突出你思考过程中的问题。相反，考虑用这些格式重新表述你的问题。

## 样本 1

> 你好，我试着做 Y 来让 X 发生。我对 Y 的理解是，它做 Z，反过来允许 X 发生。我也尝试过将 H 作为替代措施来实施，但发现它不起作用。我的方法有什么问题。

## **样品二**

> 你好，我在做 x 时遇到了一些困难。错误似乎发生在我做 Y 时，我还在测试 a 时发现了问题。我认为这在我们实现 BC 时可能会有点问题。这是一个有意的设计特性还是一个我应该等待修复的 bug？

通过这样做，你强迫自己以一种主动寻求解决方案的方式来组织你的问题。不仅如此，一旦你把它呈现给你要问的人，你也将能够得到一个更具体的答案！

作为亲尖，不要心疼提问！在一天结束的时候，我仍然会纠结于此，我认为询问和确认比假设一些事情并最终解决它更好。

# 计划

计划的重要性不能低估，尽管你也不能过度计划。关键在于找到两者之间的平衡。

以下是我目前的计划流程。

1.  以待办事项列表的形式勾勒出大致的需求
2.  用**的黑白和灰色制作一个 UX 的线框。此处不允许颜色**
3.  划分所有允许的粗略组件
4.  想想用最不复杂的方式来完成需要做的事情
5.  一起砸东西。
6.  重申并清理代码。

好吧，如果我说 6 经常发生，那我是在撒谎。老实说，我对技术债务并不陌生。但我发现坚持这种精益计划过程迫使我提前思考我可能面临的问题，并主动寻找解决方案。

你不仅使你自己的生活变得更容易，而且你也加快了你的编码，因为你头脑中有一个更好的思维框架来处理需要做的事情。

# 玩得开心，休息一下

我认为这可能是我们所做的编码或编程工作中最重要的部分。从本质上来说，每个程序员都是修补匠。他或她使用一个概念性的心智模型来摆弄代码，让事情发生。

我希望这对你来说是一种乐趣！我个人喜欢在业余时间尝试各种不同的技术，并从中找到了很多乐趣。这些兼职项目不仅给我带来了很多快乐，也让我能够更好地工作。

他们中的很多人都是以“如果……会怎样”这个问题开始的..? "在你知道之前，我们正在建造一些东西。我喜欢编程，我无法想象在最好的日子里做其他事情，我希望你也这样做！

那个 GTA 迷因我无法从脑海中抹去