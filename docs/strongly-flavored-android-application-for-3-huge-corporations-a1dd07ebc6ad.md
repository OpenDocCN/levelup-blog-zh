# 为 3 家大公司开发的味道浓郁的 Android 应用程序

> 原文：<https://levelup.gitconnected.com/strongly-flavored-android-application-for-3-huge-corporations-a1dd07ebc6ad>

![](img/cdb48c658fc0446e8c96e54e467594d7.png)

Photo by [贝莉儿 DANIST](https://unsplash.com/@danist07?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/skyscrapers?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

这篇文章的灵感来自真实事件。一些角色，名字，生意，事件和某些地点和事件被虚构为戏剧目的。与任何人的姓名、性格或历史的任何相似之处完全是巧合和无意的。

今天，您将为我们的三个商业客户构建一个 Android 应用程序。他们是我们的主要合作伙伴，所以我们真的不想搞砸。否则，它会带来一些不愉快的后果…但是让我们乐观一点，我们已经做过很多次了。一个项目中的三个应用程序；几个独立的模块，几个构建变体，每个人都会满意。小菜一碟！我们开始吧！哦，万一遇到麻烦，我会在这里指引你，别担心。

# 要求

好吧，让我们从模块开始。我们需要什么:

*   **驱动模块** —我们的一些客户要求我们实施一种机制，允许他们将客户的数据与外部存储同步。
*   **分析模块**——显然，他们希望优化他们的策略，这样我们就可以收集一些关于用户的基本信息。
*   **广告模块**——他们中的一些人选择了这种货币化方式，所以让我们为他们提供一个简洁的模块。

嗯？啊，不，我们的顾客不是秘密。目前，以下公司对此感兴趣:

*   **Defrag GmbH** —我们的德国合作伙伴希望他们的解决方案中包含驱动器和分析模块。
*   赎金软件基金会(Ransom Software Foundation)——我知道你对他们的看法，我也不是他们的粉丝，但企业不知道个人感情。他们需要驱动器和 ads 模块。
*   **Truman SA** —我们最大的客户要求我们提供分析和广告模块。

众所周知，我们创造了一个高质量的软件，所以让我们一如既往地聪明。你不希望这些组织使用他们没有付费的模块，对吗？当然，您可以通过编程来阻止它，但是最好不要包含这些模块。不仅他们不能去泡沫化(虽然我非常怀疑这些公司里有一个人知道去泡沫化是什么)，而且 apk 文件也会变小。好了，够了。现在是喝一杯好咖啡的时候了。稍后我们会做一个原型的原型，好吗？

# 项目结构草图

干得好。感谢包括文件大小的报告，我很感激。

```
┌────────────────────────┬────────┐
│        Modules         │  Size  │
├────────────────────────┼────────┤
│ Clean project          │ 1MiB   │
│ Drive                  │ 1,2MiB │
│ Drive & Analytics      │ 1,4MiB │
│ Drive, Analytics & Ads │ 2,4MiB │
└────────────────────────┴────────┘
```

现在让我们来思考如何把所有这些整合成一个连贯的整体。嗯。你的想法是用四种风格的维度来代表所有的客户和独立的模块，还是用一个维度的三种风格来代表每个客户的变体？有意思。让我们看看两者会是什么样子，然后我们会选择一些东西。对不起，老板刚刚开完另一个电视会议，叫我去他办公室一会儿。祝我好运！

# 风味

我带着好消息和坏消息回来了。但首先让我看看你做了什么有趣的东西。

## 模块集成

太好了！**反思+进步法则**，就是这么做的。如果这些模块在它们的 Android 活动中是独立的，那就更容易了，因为活动不需要额外的异常。Proguard 在默认情况下保留所有这些文件，所以使用它们的包名启动它们是绝对安全的(因此通过反射隐式地启动它们)。)但这只是我的一点题外话。继续走。

## 四维方法

啊！这是什么食物？！我感觉像在一家印度餐馆。让我数一数…三种公司风格乘以两种驱动模块风格乘以两种分析模块风格乘以两种广告模块风格乘以两种构建类型…

![](img/fe1ebe5657a62e290af88b6a34500c21.png)

正在计算…

它给了我们**四十八种口味**！的确是印度菜！它使依赖管理变得更简单，对吧，但是看看我们为此付出的代价。完全不值得。

## 三味方法

嗯。是的，很有前途。简单，**最少数量的风格**，甚至可以防止未定义的`buildConfigField`(或者如果你愿意，可以防止不使用给定模块的每个风格中的`false`定义。)聪明。只有一个缺点**你必须为每个客户端单独定义所有的依赖关系**。如果有更多的客户端或模块，不仅**会扩大依赖部分**，而且**容易出错**。在乐观的情况下，您可以简单地得到一个适当的消息，说明有未解析的引用，但是在最坏的情况下，您不会得到通知，我们的一个客户将收到一个模块比他购买的更多的应用程序。老板会杀了我们的。或者更糟…解雇我们！

嗯……说到更多的客户，这个应用程序的概念受到了许多商业伙伴的喜爱。这是好消息。坏消息是，现在我们必须为四个额外的客户端准备这个应用程序…和四个更多的模块。是的，我知道，这很疯狂。幸运的是，我有个主意。跟我来，我们会稍微改进你的解决方案…

## 最后的方法

瞧啊。我们成功了！现在我们既有**合理数量的口味**又有**大大简化的依赖管理**。让我总结一下我们取得的成就:

*   我们已经创建了一个代表模块的**枚举类型**，这使得构建脚本稍微**清晰**并且**不容易出错**。
*   我们已经编写了**扩展函数**以便让构建脚本**更容易阅读**和更短的**来编写**。当然，它只不过是糖，但它是健康的！
*   大概这个解决方案的要点是一个叫做`getSelectedBuildVariant`的函数。不幸的是，我不知道从`DependencyHandlerScope`获取信息的标准/官方方法，所以我们不得不使用一个小技巧，从 IML (IntelliJ IDEA 模块)文件中检索口味列表。
*   使用我们的扩展函数，我们已经为每种风格定义了`buildConfigField`来**指示哪个风格可以访问哪个模块**。
*   我们已经将所有缺失的构建配置字段设置为`false`。它创建未使用的模块标志**，而不必显式定义它们**，从而**防止未解决的引用错误**。
*   我们把依赖味道的进口稍微复杂化了一点，以利于自动管理。得益于此，我们可以确定**如果模块标志被置位，适当的依赖关系存在**，并且**如果标志未置位，相应的依赖关系甚至不会占用一个字节的内存**。

最后，报告指出:

```
┌────────────────────────────┬────────┐
│           Flavor           │  Size  │
├────────────────────────────┼────────┤
│ Defrag GmbH                │ 1,4MiB │
│ Ransom Software Foundation │ 2,2MiB │
│ Truman SA                  │ 2,2MiB │
└────────────────────────────┴────────┘
```

![](img/82b4510bdeda9dca4b8e569946b1cc35.png)

**搞定！**照片由[阿里·叶海亚](https://unsplash.com/@ayahya09?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

# 坚持住！

没那么快…首先，我很高兴我们在这里相遇，在结束这个半故事半文章。😃我希望你喜欢这种有点不寻常的形式。**在评论里让我知道或者干脆拍手**👏！非常感谢。🙂

**弊端的时间**！好吧，据我所知有两个。这不太可能，但是如果您的项目有两种风格，一种风格的名称包含在另一种风格中，那么每当选择较长的一种时，代码都会错误地检测较短的一种。这个解释可能不是很清楚，所以这里有一个例子:

```
Defined flavors: cheese, cheesecake
┌─────────────────┬────────────────────┐
│ Selected flavor │  Detected flavors  │
├─────────────────┼────────────────────┤
│ cheese          │ cheese             │
│ cheesecake      │ cheesecake, cheese │
└─────────────────┴────────────────────┘
```

另一个缺点只是潜在的危险，但仍然值得一提。我不知道 IML 文件的结构有多稳定，但我认为有一天 JetBrains 会改变它，比如 JSON 格式。不用说，`getSelectedBuildVariant`功能将会崩溃。

之前，我使用的是一个小定制版本的[波拉纳阿普阿纳的](https://stackoverflow.com/users/4350967/poiana-apuana)脚本发现[在这里](https://stackoverflow.com/a/34679933)。这是一个非常有趣的解决方案，我鼓励你也去看看。然而，它有一个缺点。在某些情况下，特别是在同步期间，它根本没有发现任何味道，这使得动态依赖管理在最好的情况下是痛苦的，在最坏的情况下是不可能的。

# 下一步是什么

[](/the-pursuit-of-the-cross-platform-holy-grail-part-1-ionic-2d56b640a6b3) [## 对跨平台圣杯的追求。第一部分:离子

### 这是寻找最佳跨平台应用程序开发框架系列文章的第一部分。的…

levelup.gitconnected.com](/the-pursuit-of-the-cross-platform-holy-grail-part-1-ionic-2d56b640a6b3) [](/what-is-the-context-in-object-oriented-programming-9dda02d3328d) [## 面向对象编程中的上下文是什么？

### 这个问题永远改变了我对面向对象编程的看法。那是几年前，我偶然发现…

levelup.gitconnected.com](/what-is-the-context-in-object-oriented-programming-9dda02d3328d)