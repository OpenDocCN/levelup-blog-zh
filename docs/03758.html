<html>
<head>
<title>Creating a Board Game (Checkers) With JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript创建棋盘游戏(跳棋)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-board-game-checkers-with-javascript-ecd562f985c2?source=collection_archive---------1-----------------------#2020-05-26">https://levelup.gitconnected.com/creating-a-board-game-checkers-with-javascript-ecd562f985c2?source=collection_archive---------1-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2828" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">学习web开发的最好方法之一是创建一个游戏。有了javascript的基本工具，就可以开始了。作为一个初学者，这可能是令人生畏的。很容易陷入“教程地狱”,因为你认为你需要在开始创作之前不断学习。我将通过演示如何创建棋盘游戏跳棋向您证明事实并非如此。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/595ac5915ec7f2b9f14933f914b40b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*It9pYu-PxzDW27IHVT-LwQ.png"/></div></div></figure><p id="6388" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我只涉及HTML、JavaScript(包括DOM)和非常少量的CSS，所以我假设你知道如何使用它们的基础知识。你当然也应该知道如何玩跳棋…</p><p id="cedf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想看到完成的代码，你可以访问GitHub库，这里:<a class="ae la" href="https://github.com/RyanBranco/Checkers" rel="noopener ugc nofollow" target="_blank">https://github.com/RyanBranco/Checkers</a></p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="cd1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先是HTML。</p><p id="4792" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了给用户画板，我使用了一个<code class="fe li lj lk ll b">&lt;table&gt;</code>。使用表格可以很容易地创建棋盘，因为这正是棋盘；一张8×8的桌子。在开始和结束标签之间，我们需要8个<code class="fe li lj lk ll b">&lt;tr&gt;</code>(表格行)。<code class="fe li lj lk ll b">&lt;tr&gt;</code>并不实际创建行中的单元格，它只是定义了一个新行供您输入单元格；因此，在您刚刚创建的8个<code class="fe li lj lk ll b">&lt;tr&gt;</code>中，需要有8个<code class="fe li lj lk ll b">&lt;td&gt;</code>(表格数据)来为电路板创建实际的单元格。</p><p id="51e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">骨骼应该是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lm"><img src="../Images/17bf4507fdefe78f0ebcf7820eee9656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*38B1LIeG08ocfn0KTYoczg.png"/></div></div></figure><p id="41b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你看不到网页上显示的任何内容，因为表格中没有数据。这将是下一步。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="b33a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是每个<code class="fe li lj lk ll b">&lt;td&gt;</code>应该有的HTML。</p><p id="6f03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">棋盘上有永远不会有棋子的单元格，我给它们一个<code class="fe li lj lk ll b">class=”noPieceHere”</code>。这对javascript逻辑(稍后介绍)和CSS(所以它们有不同的颜色)很重要。第一个<code class="fe li lj lk ll b">&lt;td&gt;</code>应该有<code class="fe li lj lk ll b">noPieceHere</code>类，并且应该在整个棋盘中交替出现(创建棋盘效果)。下面是一行的样子:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ln"><img src="../Images/41e4d1e273dff1e184d2f02fc29308ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDmgz4gKqAXU6tYhAD3P1A.png"/></div></div></figure><p id="52bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，这需要为所有其他7行复制，记住，这需要交替。这意味着下一个<code class="fe li lj lk ll b">&lt;tr&gt;</code>将从没有<code class="fe li lj lk ll b">noPieceHere</code>类的<code class="fe li lj lk ll b">&lt;td&gt;</code>开始。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="61c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是单元格的CSS。</p><p id="f6ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每一个<code class="fe li lj lk ll b">&lt;td&gt;</code>都有一个<code class="fe li lj lk ll b">background-color: #BA7A3A</code>、<code class="fe li lj lk ll b">Width</code>、&amp;、<code class="fe li lj lk ll b">Height</code>、<code class="fe li lj lk ll b">text-align: center</code>(使每个单元格看起来像一个正方形)。然后<code class="fe li lj lk ll b">.noPieceHere</code>覆盖<code class="fe li lj lk ll b">&lt;td&gt;</code>到<code class="fe li lj lk ll b">#F0D2B4</code>的颜色(这样看起来就像棋盘)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lo"><img src="../Images/115c84e4ffabdaed087d341f3880c223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-egvC51812Xji8FCtYk2uw.png"/></div></div></figure><p id="736a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">*单元格可以根据您的意愿进行定制*</p><p id="2270" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦完成，你应该有一个空的棋盘！现在让我们用棋子填充棋盘。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="d66d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在每个没有<code class="fe li lj lk ll b">class=”noPieceHere”</code>的<code class="fe li lj lk ll b">&lt;td&gt;</code>中，是棋子将要放置的地方。我用空的<code class="fe li lj lk ll b">&lt;p&gt;</code>标记红色的棋子，空的<code class="fe li lj lk ll b">&lt;span&gt;</code>标记黑色的棋子；这并不是绝对必要的，但我认为一旦我们转向JavaScript，迭代这些部分会变得更容易。</p><p id="a036" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">红色棋子有一个<code class="fe li lj lk ll b">class=”red-piece”</code>，黑色棋子有一个<code class="fe li lj lk ll b">class=”black-piece”</code>，每一个棋子都应该有其唯一的<code class="fe li lj lk ll b">id</code>。</p><p id="e949" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每种颜色在相对的两端有12块，中间应该留有2排。</p><p id="3467" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是两端各有一行的示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lp"><img src="../Images/e86093c7d88110dbfc99deb121dd63ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZZtQv3RjmlScz304J2tpA.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lp"><img src="../Images/0e502474987867439c906daf066fcdf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nwauMnZ587HPg--jVLCO1A.png"/></div></div></figure></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="5936" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在JavaScript中，一旦棋子到达棋盘的另一端，我们需要给棋子一个<code class="fe li lj lk ll b">class=”king”</code>,所以我们需要在CSS中定义<code class="fe li lj lk ll b">.king</code>,以备JS追加。</p><p id="1ac6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是棋子和国王类的CSS:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lq"><img src="../Images/8823cb831b844f4187b30c40edb0ddbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdCWSTM5RBkYB9dgF8fZsQ.png"/></div></div></figure><p id="855d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">*您可以随心所欲地定制作品*</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="68fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想让玩家知道轮到谁了，你可以在棋盘下面添加一些HTML，它会根据轮到谁而改变颜色。</p><p id="a24c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JavaScript将改变文本颜色，但这里是静态HTML:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lr"><img src="../Images/34e2b999e5fe7aee3df79ea0c6d8fd71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmnfmvT0I1IbELYcRZU-NQ.png"/></div></div></figure><p id="dbec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要忘记给每个<code class="fe li lj lk ll b">&lt;div&gt;</code>添加类，因为我们需要在JavaScript中引用这些类，这样我们就可以根据玩家的回合改变样式。</p><p id="64c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以随心所欲地设计它们，但我首先给<code class="fe li lj lk ll b">.black-turn-text</code>一种灰色，让它看起来淡出(这样用户就知道游戏在红色回合开始)。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="4121" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">HTML和CSS的最终结果应该如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0a235b4282810f765d07fd8266127449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kLCfAx_t7FStRgrO0FruQ.png"/></div></div></figure><p id="623e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不错！HTML和CSS完成了！现在真正有趣的开始了… JavaScript！</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="14cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JavaScript逻辑中将有三个主要事件:</p><ol class=""><li id="ba8d" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">当一块被点击时</li><li id="674c" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">当单元格被单击时</li><li id="8b8b" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">单击单元格后更改的数据</li></ol><p id="68f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在我们进入逻辑之前，我们需要初始化游戏状态数据，并声明引用DOM中项目的变量。让我们跳进来吧！</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mg"><img src="../Images/02aad3685c5b5dcfec7d25472cfd0873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZBnfP2ZHpoBHeyuRwt1hg.png"/></div></div></figure><p id="b8b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要在后端创建一个董事会的表示。这可以用一个64项的数组来完成(每一项代表一个单元)。</p><p id="37f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你看到的硬编码的数字是棋盘上棋子的id，并被放置在棋盘上它们应该在的地方。这很容易让我们的代码“看到”片段在哪里。稍后，我们将操纵这个数组，根据棋子移动的位置进行改变。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="3e44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要建立引用事物的变量(在DOM和player属性中)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mh"><img src="../Images/33b111639cc418510f925317c5a1a8ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbssftZ7XWj6USL9f4Yvow.png"/></div></div></figure><p id="a5d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先通过使用DOM，我们获取所有的<code class="fe li lj lk ll b">cells</code>(第23行)，每边的所有棋子(第24和25行)，每边的回合文本，这样用户就可以看到该轮到谁了(第26和27行)，然后是<code class="fe li lj lk ll b">divider</code>(第28行)。如果你没有分隔线，不要担心，我所要做的就是改变<code class="fe li lj lk ll b">display: none</code>,让它在显示赢家时消失。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/b297c9154638093463831397796e1f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*i6FiRBV7j0lFQDjsZERRyQ.png"/></div></figure><p id="8854" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们需要保存用户变量来跟踪游戏状态。</p><p id="76e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我用<code class="fe li lj lk ll b">turn</code>变量来代表当前玩家回合(<code class="fe li lj lk ll b">true</code> ===红人回合&amp;= T5】= = =黑人回合【31线】)。一旦一个玩家有0个棋子，对面的玩家就赢了，所以我们需要记录每个玩家的“分数”(第32和33行)。最后是<code class="fe li lj lk ll b">playerPieces</code>变量。这个变量允许我们动态地保存所有当前玩家的棋子。这样做的好处是，我们不必编写两次代码(红色转弯和黑色转弯)。我们将动态地改变什么样的玩家角色被引用，所以我们只需要写一次代码。</p><p id="dca6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe li lj lk ll b">playerPieces</code>变量有点混乱，不要担心，我很快就会看一遍。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/ab3a1cfdda95ce8f2e64d82d9b5f0c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*oXOtYkR0npbLkUa9TvSLCg.png"/></div></figure><p id="adb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在出现了保存这些片段属性的对象。</p><p id="9bc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当一个棋子被点击时，<code class="fe li lj lk ll b">selectedPiece </code>对象将根据用户点击的棋子的属性动态变化。我们将编写Javascript来分析它周围可能的移动，并根据可能的移动更改真/假值。稍后我将展示这是如何实现的。它涉及到之前创建的<code class="fe li lj lk ll b">board</code>数组。</p><p id="5d77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当一个棋子被点击时，我们需要获取一些东西:该棋子的具体<code class="fe li lj lk ll b">id</code>(第38行)，该棋子所在的棋盘棋子的索引(第39行)，如果它是一个国王(第40行)，以及所有可用的可能移动(第41-48行)。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="38fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们进入游戏的实际功能之前，我将解释我在移动方式上的设计选择。</p><p id="c70a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">棋盘上的棋子原本只能往相反的方向走，但是一旦它到达棋盘的另一端，它就变成了“国王”，然后开始了全方位的移动。我发现用一种“向后”的方式来设计棋子的运动需要更少的代码。因此，首先我们将分析棋子可以跳的所有可用方格(不考虑棋子的颜色，或者是否是王)，然后根据玩家的回合限制移动。</p><p id="69c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果不这样做，将不得不编写三个看起来几乎相同的函数；一个给红棋子，一个给黑棋子，一个给国王。复制代码不是好的做法，因为它更容易出现错误，更难调试，编写起来乏味，并且有很多不必要的代码。我描述的方法只涉及一个分析周围可用单元格的函数，另一个函数将根据玩家的回合轻松编辑<code class="fe li lj lk ll b">selectedPiece</code>属性。如果这有点令人困惑，我将很快向您展示这将如何完成。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mk"><img src="../Images/e56affef8052d59ca3a29546c6090d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Jnneqqia4aJL0aPkuHLrQ.png"/></div></div></figure><p id="8cc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们需要给这些部分一个<code class="fe li lj lk ll b">click</code>事件监听器。<code class="fe li lj lk ll b">givePiecesEventListeners()</code>函数将为这些片段提供一个事件监听器，该监听器将调用函数<code class="fe li lj lk ll b">getPlayerPieces</code>。<code class="fe li lj lk ll b">getPlayerPieces()</code>是操作我之前展示的<code class="fe li lj lk ll b">selectedPiece</code>对象的函数链的开始。</p><p id="7799" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以在JavaScript文件的最底层，调用初始化事件监听器的函数，就像这样:<code class="fe li lj lk ll b">givePiecesEventListeners()</code>。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="4437" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来的几个函数起初看起来可能有些混乱，因为它将涉及到我还没有在代码中涉及到的东西。它们重置了代码中尚未改变的特征。但它需要在链中首先完成，因为如果用户单击一个棋子移动，所有东西都将被分析，并且它周围的单元格将根据棋子可以移动的位置得到“<code class="fe li lj lk ll b">onclick</code>”。但是，如果用户决定他们不想移动那个棋子呢？他们应该可以选择另一件作品。因此，为了实现这一点，需要在代码中重置某些属性，以便所选的新块能够正确移动。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ml"><img src="../Images/b64f323f06a389c176dd3aa01a139aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1RpKJZ1QSpHd5qthsBsrXg.png"/></div></div></figure><p id="5782" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是<code class="fe li lj lk ll b">playerPieces</code>变量将要被改变的地方。简单来说，<code class="fe li lj lk ll b">if (turn)</code>(意为其转红)，设置<code class="fe li lj lk ll b">playerPieces</code>变量为<code class="fe li lj lk ll b">redsPieces</code>，<code class="fe li lj lk ll b">else…</code>(意为其转黑)设置<code class="fe li lj lk ll b">playerPieces</code>为<code class="fe li lj lk ll b">blacksPieces</code>。然后调用函数<code class="fe li lj lk ll b">removeCellonclick()</code>。然后一旦<code class="fe li lj lk ll b">removeCellonclick()</code>完成，运行<code class="fe li lj lk ll b">resetBorders()</code>。</p><p id="cc69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">先来盖<code class="fe li lj lk ll b">removeCellonclick()</code>。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mm"><img src="../Images/f17fe37b3a0f37d79b48c51c4dee3545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bg1MBCede4YKDRybKUIa6A.png"/></div></div></figure><p id="0a14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个函数遍历棋盘上的所有单元格(第81行)。然后删除<code class="fe li lj lk ll b">onclick</code>属性(第82行)。</p><p id="a135" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">稍后我将向您展示为什么单元格的<code class="fe li lj lk ll b">onclick</code>需要是属性，但是现在您需要知道的是，这是因为我们需要动态地添加和删除它们。</p><p id="006c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们来看看之前调用的<code class="fe li lj lk ll b">resetBorders()</code>。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mn"><img src="../Images/13719b8fac11a4c1afa766be893febcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnbDqb51-PjHQZKKy8wLug.png"/></div></div></figure><p id="6807" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">稍后我们会给选中的棋子加一个绿色的边框(表示该棋子被选中移动)，但是如果用户选择了不同的棋子，旧的棋子需要重置回默认值。因此，该函数循环通过所有的<code class="fe li lj lk ll b">playerPieces</code>(这是之前设置的)并将改变片段以具有一条<code class="fe li lj lk ll b">border = “ 1px solid white”</code>线(89)。一旦完成，调用<code class="fe li lj lk ll b">resetSelectedPieceProperties()</code>，然后调用<code class="fe li lj lk ll b">getSelectedPiece()</code>。</p><p id="4197" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先让我们来看看<code class="fe li lj lk ll b">resetSelectedPieceProperties()</code>是做什么的。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/4ae4fae68e7ecbffba109878771c3aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbO3p8GLPjMcn5L_ITTyeQ.png"/></div></div></figure><p id="d38e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将重置<code class="fe li lj lk ll b">selectedPiece</code>对象的所有属性，恢复正常。这需要在每次单元格单击时发生，因为我们不知道前一个选定部分的属性是什么。由于单元格是基于<code class="fe li lj lk ll b">selectedPiece</code>条件得到<code class="fe li lj lk ll b">onclick</code>的，所以每次点击一个棋子都需要重置，否则单元格将会有不正确的<code class="fe li lj lk ll b">onclick</code>属性。</p><p id="cabb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在转到<code class="fe li lj lk ll b">getSelectedPiece()</code>。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mp"><img src="../Images/0f401e0f657ac62acdf9fb01b11ef19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RA6owckA_OA8vX8Mz-B6Qw.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mq"><img src="../Images/32b74f324a1cfab7d04d8aef42745c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDXnZlVgz7cGjg1UyedQoQ.png"/></div></div></figure><p id="9ad2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要找到棋子在棋盘上的位置。这就是<code class="fe li lj lk ll b">getSelectedPiece()</code>开始发挥作用的时候。</p><p id="04eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当一块被点击时，它会给你一个<code class="fe li lj lk ll b">event</code>。我们可以通过输入<code class="fe li lj lk ll b">event.target.id</code>来获取片段的<code class="fe li lj lk ll b">id</code>。<code class="fe li lj lk ll b">event.target.id</code>返回一个<code class="fe li lj lk ll b">id</code>的字符串，我们希望它是一个数字，这样当我们将它与<code class="fe li lj lk ll b">board</code>数组相关联时，JavaScript可以正确地读取它。所以通过包围<code class="fe li lj lk ll b">parseInt()</code>(第112行)，我们可以把字符串变成一个数字。我们还需要找到棋子在棋盘上的位置。这就是<code class="fe li lj lk ll b">findPiece</code>功能发挥作用的地方。</p><p id="6e36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe li lj lk ll b">findPiece()</code>接受一个参数，即片段的id。一旦我们保存了片段的<code class="fe li lj lk ll b">parseInt()</code>版本(第18行)，我们就将它传递给javascript方法<code class="fe li lj lk ll b">indexOf</code>(第19行)并<code class="fe li lj lk ll b">return</code>它。这将为您提供所选棋子的准确索引位置。</p><p id="69a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数链上的下一个是<code class="fe li lj lk ll b">isPieceKing()</code>。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mr"><img src="../Images/e558d151f85a585da83e8ddfe389d9be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*btPwhuvw0Z86vzEnwbqhVA.png"/></div></div></figure><p id="6349" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe li lj lk ll b">isPieceKing()</code>函数应该是不言自明的，它确定所选的棋子是否为王。</p><p id="5f91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过在选中的HTML元素(第119行)上使用<code class="fe li lj lk ll b">.classList.contains(“king”)</code>,我们可以确定它是否是一个国王。轻松点。稍后你会看到这首曲子是如何被评为国王级的。</p><p id="74a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后调用<code class="fe li lj lk ll b">getAvailableSpaces()</code></p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ms"><img src="../Images/414c75e574ce8cae6d00412917fd7e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7WNfb9NzEbK1ObeHTTiDQ.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/86d2f67e53310af8826a7ad26ec37245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3L4dS3_C2EWZtqvMtZg6aQ.png"/></div></div></figure><p id="8a99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe li lj lk ll b">getAvailableSpaces()</code>分析一个棋子在不跳转到另一个棋子的情况下可以形成的周围单元格(下一个函数将覆盖跳转空间)。</p><p id="1db6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果计算单元格，棋子可以移动+/-7个单元格或+/-9个单元格(正或负，取决于棋子是红色还是黑色)。让我们看一下第一个<code class="fe li lj lk ll b">if</code>语句，因为一旦理解了其中一个，就理解了其余的(第129-131行)。</p><p id="277d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe li lj lk ll b">selectedPiece.indexOfBoardPiece + 7 === null</code>(表示该位置可用)和同一单元格没有<code class="fe li lj lk ll b">noPieceHere</code>(第130行)的类别，则该棋子可以移动！所以我们在<code class="fe li lj lk ll b">selectedPiece = true</code>行(131)设置了这个属性。</p><p id="d4b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第130行很重要，因为边上有7或9个空格，是棋盘另一端的单元格，显然我们不能跳到那里，但幸运的是这些单元格有一个<code class="fe li lj lk ll b">noPieceHere</code>类。所以我们需要确保我们没有跳到那里的选择。第130行阻止了这一点。</p><p id="cef2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们来看看<code class="fe li lj lk ll b">checkAvailableJumpSpaces()</code>。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mu"><img src="../Images/6fb22c6d8f6f2a2d63f92251070b29b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTBjx1YeRBnSfGVIkyxP3g.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/4fb05b53e918e5279179fabfe5e65ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_viD9y49k5wj0YxXjFh6Q.png"/></div></div></figure><p id="9900" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe li lj lk ll b">checkAvailableJumpSpace()</code>做与<code class="fe li lj lk ll b">checkAvailableSpaces()</code>相同的事情，除了…你猜对了…跳棋子。</p><p id="ec07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">功能差不多，区别是+/-14或者+/-18(加减取决于棋子是红还是黑)。<code class="fe li lj lk ll b">if</code>语句中的额外条件是，如果被跳转的位置是<code class="fe li lj lk ll b">&gt;= 12</code>，意味着棋子是黑色的(因为黑色棋子的<code class="fe li lj lk ll b">id</code>大于或等于12)，红色棋子的<code class="fe li lj lk ll b">id</code>小于12。</p><p id="f6ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，这个函数需要为每一面(红色和黑色)复制代码。这是因为我们必须指定片段<code class="fe li lj lk ll b">id</code>的方式。可能有一种方法可以消除重复的代码，但我不确定如何去做。因此，如果有人能找到消除重复代码的方法，请在下面的评论中发表。</p><p id="bc25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确保在这个函数之后我们调用下一个函数，也就是<code class="fe li lj lk ll b">checkPieceConditions()</code>。我不在图中展示，但这是绝对必要的，因为我们需要延续链条。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mn"><img src="../Images/ca60ccb367ae78001dda96937870f3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dqyjnnv3m00rAjPh2MvhYw.png"/></div></div></figure><p id="4d3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经分析了棋子所有可能的移动，我们需要根据回合来限制移动。</p><p id="604a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然一个国王有完全的移动能力，不管他在哪边，我们都不需要操纵任何属性。所以我们可以继续下一个函数，也就是<code class="fe li lj lk ll b">givePieceBorder()</code>(第199行)。</p><p id="597a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果不是国王，我们需要移除红色棋子的所有“负”移动属性，并移除黑色棋子的正常移动属性。我们就是这样限制运动的。</p><p id="6af4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后…我们进入下一个功能，<code class="fe li lj lk ll b">givePieceBorder()</code>。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/829faa17b48dba7cfc3baa3595d21079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xwk-tcRUcUUr8hAq3b5LQg.png"/></div></div></figure><p id="a2fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使作品看起来被选中，我们需要给它一个绿色的亮点。所以…如果任何<code class="fe li lj lk ll b">selectedPiece</code>运动属性为真，我们改变<code class="fe li lj lk ll b">document.getElementById(selectedPiece.pieceId).style.border = “3px solid green”</code>。然后进入下一个功能<code class="fe li lj lk ll b">giveCellsClick()</code>(第221行)。</p><p id="8e23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果这些都不是真的，意味着棋子没有可能的移动，什么都不做(<code class="fe li lj lk ll b">return;</code>)</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/6040a4c384dddc0d335a2a8437456327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAS-LcIoduaPsGM9IlGdCg.png"/></div></div></figure><p id="3c9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们需要给单元格一个<code class="fe li lj lk ll b">onclick</code>属性，基于<code class="fe li lj lk ll b">selectedPiece</code>可能的移动。</p><p id="3528" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果<code class="fe li lj lk ll b">selectedPiece.[movement property]</code>为真，则给该单元格赋予一个<code class="fe li lj lk ll b">onclick</code>属性<code class="fe li lj lk ll b">makeMove()</code>。</p><p id="ca8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe li lj lk ll b">makeMove()</code>将接受棋子将要移动的数字或位置的参数。如果棋子要移动七格(<code class="fe li lj lk ll b">selectedPiece.seventhSpace</code>)，给单元格一个<code class="fe li lj lk ll b">makeMove(7)</code>的<code class="fe li lj lk ll b">onclick</code>，所有可能的移动都会这样做。</p><p id="903f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是为什么我们需要给单元格一个<code class="fe li lj lk ll b">onclick</code>属性而不是<code class="fe li lj lk ll b">event listener</code>属性的原因:如果我们给单元格一个事件监听器并传递一个参数，函数将立即运行，因为从技术上来说它是被调用的。使用匿名函数是不可能的，因为它需要被删除，并且您不能删除匿名事件侦听器。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="1f95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你点击一个片段时，这是函数链的结尾，所以我们不需要自动调用更多的函数。下一个函数(<code class="fe li lj lk ll b">makeMove()</code>)是当一个单元格被选中后被点击时调用的函数。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/d8f050a5b647c289afb49878e0499588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFnZCM2jfX8ijPtmzTP-6w.png"/></div></div></figure><p id="657d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该是做大量繁重工作的函数的时候了！这有点复杂，但请试着和我一起分享。</p><p id="974c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先我们需要移除前端的部分，我们可以很容易地用<code class="fe li lj lk ll b">.remove()</code>(第259行)来完成，并将单元格的<code class="fe li lj lk ll b">.innerHTML</code>改为空字符串(第260行)。有了这两者的结合，细胞看起来就像什么都没有过。</p><p id="1408" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在来说一下<code class="fe li lj lk ll b">if…else</code>的说法。<code class="fe li lj lk ll b">if (turn)</code>(第261行)，然后……<code class="fe li lj lk ll b">if (selectedPiece.isKing)</code>我们想为这个片段创建一个新的HTML元素，在被点击的新单元格中有一个king类(第263行)。然后将redPieces变量重置为<code class="fe li lj lk ll b">querySelectorAll(“p”)</code>(第264行)；这非常重要，因为如果没有这样做，刚刚创建的新片段将不会保存在JavaScript内存中。所以当你在下一轮点击新的部分时，什么也不会发生，因为JavaScript不会给它一个事件监听器。所以一定要把这一行加进去。</p><p id="06e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为第265行的<code class="fe li lj lk ll b">else</code>语句复制这段代码，但是不包含king类。</p><p id="e121" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码可以复制用于外部的<code class="fe li lj lk ll b">else</code>语句(第269行)，但是将所有关于红色块的内容都改为黑色块，并且不要忘记将<code class="fe li lj lk ll b">“p”</code>改为<code class="fe li lj lk ll b">“span”</code>(第272行&amp; 275)。</p><p id="2be3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我将<code class="fe li lj lk ll b">selectedPiece.indexOfBoardPiece</code>保存到一个变量中(第279行)。我不确定为什么，但是你不能把对象属性直接传递给函数的参数，所以这需要保存为一个变量。</p><p id="b418" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe li lj lk ll b">if</code>该数字是一个跳跃移动(第280行)，将调用的下一个函数将第三个参数作为被跳跃的棋子的位置(这是必需的，因为我们将从棋盘上移除被跳跃的棋子)。<code class="fe li lj lk ll b">else</code>用两个指定的参数调用下一个函数，即旧点和新点。</p><p id="54f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一个功能，我们将更改后端的所有数据，以反映前端的电路板。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/707d75be913513e74ec3b149f9a2b44d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_YL8NemmX5zpJAlps7PB1A.png"/></div></div></figure><p id="3bf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们将在后端操纵一切。如果有必要的话，也可以给这个作品一个国王的级别。</p><p id="f3ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先我们将选定棋子的原始位置改为<code class="fe li lj lk ll b">null</code>(第289行)，因为该棋子已不存在；然后改变新的工件位置，使其等于被移动的工件的<code class="fe li lj lk ll b">id</code>(第290行)。</p><p id="f3b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第291行的<code class="fe li lj lk ll b">if</code>语句说:如果它的红色变成了<code class="fe li lj lk ll b">selectedPiece.pieceId &lt; 12</code>，并且它的新位置是<code class="fe li lj lk ll b">&gt;= 51</code> (≥ 51是棋盘上的最后一行)，那么给这个棋子一个类别<code class="fe li lj lk ll b">“king”</code>。然后做相反的黑色转弯(第294-296行)。</p><p id="05cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果removePiece参数存在(第297行)，将<code class="fe li lj lk ll b">board</code>数组上移除的部分更改为<code class="fe li lj lk ll b">null</code>。现在，如果它变成红色(第299行)，让棋子在前端消失，并从黑色(第301行)移除一个分数。如果轮到黑人，反之亦然。</p><p id="ccfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有这些完成后，调用3个函数:<code class="fe li lj lk ll b">resetSelectedPieceProperties()</code>、<code class="fe li lj lk ll b">removeCellonclick()</code>和<code class="fe li lj lk ll b">removeEventListeners()</code>。前两个我们已经写好了，所以我就不赘述了，但是它们需要被调用，这样所有的数据才能在下一轮被重置(这就是为什么我们没有在这两个函数中调用任何其他新的函数:这样它们就可以被重用)。</p><p id="50b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是<code class="fe li lj lk ll b">removeEventListeners()</code>的时候了。</p><p id="c478" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">别担心…我们快完成了。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/7bc7e01f799fa7d58f662981dfaf2890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKe5yaqq-2MV_k46yDZD3A.png"/></div></div></figure><p id="0a5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果是reds turn(第315行)，循环所有的<code class="fe li lj lk ll b">redsPieces</code>并删除<code class="fe li lj lk ll b">click</code>事件监听器，然后在<code class="fe li lj lk ll b">else</code>语句中对<code class="fe li lj lk ll b">blacksPieces</code>做同样的操作。</p><p id="977d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后调用<code class="fe li lj lk ll b">checkForWin() </code>功能。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/8dcc3697949e139bb3ac30ecefb3c006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeF5Pw10PeKvkNWKUjGnjQ.png"/></div></div></figure><p id="f71f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果任何一个分数为0，则将反回合文本更改为<code class="fe li lj lk ll b">.style.display = “none”</code>，并将获胜的玩家更改为“红色获胜！”。</p><p id="ce1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只要玩家知道他们赢了，你就可以随心所欲地发挥创造力。</p><p id="756a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几个旁注:如果你没有分割器，不要担心，你在第331和338行看到的循环，是因为我有多个<code class="fe li lj lk ll b">[player]TurnText</code>(一个用于移动设备，一个用于桌面设备)，所以如果你只有一个<code class="fe li lj lk ll b">[player]TurnText</code>，循环是不必要的。</p><p id="e260" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在最后一个功能<code class="fe li lj lk ll b">changePlayer()</code>！</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/01bcbd31b33abf29b8ed9cdf64d8ea50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bpVwRiZbmUdzJjS02LG4A.png"/></div></div></figure><p id="7e38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果它变成红色，将<code class="fe li lj lk ll b">turn</code>变量更改为false，然后将<code class="fe li lj lk ll b">blackTurnText</code>的颜色更改为黑色，将<code class="fe li lj lk ll b">redTurnText</code>的颜色更改为浅灰色(反之，如果turn为false，则表示它变成黑色)。</p><p id="f11b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">循环的相同逻辑适用于前面的函数。所以如果你只有一个<code class="fe li lj lk ll b">[player]TurnText</code>，循环就没必要了。</p><p id="6604" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，调用从头开始的函数:<code class="fe li lj lk ll b">givePiecesEventListeners()</code>，重新开始整个循环。</p><p id="04af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第365行是JavaScript文件的最后一行。这需要在全局级别被调用，所以一旦页面被加载，这个循环就开始了(我在最初回顾这个函数时是如何解释的)。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><h1 id="914a" class="nc nd it bd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz bi translated">🎉恭喜你！你现在有一个工作跳棋棋盘游戏！🎉</h1><p id="46a6" class="pw-post-body-paragraph jq jr it js b jt oa jv jw jx ob jz ka kb oc kd ke kf od kh ki kj oe kl km kn im bi translated">如果你想得到我的代码，你可以在这里找到:<a class="ae la" href="https://github.com/RyanBranco/Checkers" rel="noopener ugc nofollow" target="_blank">https://github.com/RyanBranco/Checkers</a></p><p id="588c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您应该已经了解了如何利用JavaScript(甚至大多数编程语言)工具。我鼓励你自己创造一些东西，因为那是最好的学习方式！现在你没有借口了。</p></div></div>    
</body>
</html>