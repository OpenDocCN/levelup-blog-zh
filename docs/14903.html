<html>
<head>
<title>Creating a REST API with Node.js and Express: A step-by-step guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js和Express创建REST API:分步指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-rest-api-with-node-js-and-express-a-step-by-step-guide-3bd7188fa219?source=collection_archive---------4-----------------------#2022-12-31">https://levelup.gitconnected.com/creating-a-rest-api-with-node-js-and-express-a-step-by-step-guide-3bd7188fa219?source=collection_archive---------4-----------------------#2022-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="77cc" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="df42" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">欢迎来到我们用Node.js和Express构建REST API的教程！在本文中，我们将指导您使用Node.js和Express库从头开始创建REST API。在本教程结束时，您将拥有一个全功能的API，可以用来构建强大的数据驱动的应用程序。</p><p id="1237" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">但是首先，让我们后退一步，讨论什么是REST API，以及为什么您可能想要构建一个REST API。</p><p id="bc62" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">REST API(表述性状态转移API的缩写)是一个允许您通过互联网访问和操作数据的接口。它被称为“代表性的”API，因为它被设计成以一种易于客户理解和使用的方式来表示底层数据。REST APIs通常用于提供对存储在数据库中的数据的访问，或者支持不同系统和应用程序之间的通信。</p><p id="cbf7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">例如，假设您有一个需要从服务器获取最新帖子的社交媒体应用程序。您可以构建一个REST API来处理这项任务，允许应用程序向API发送请求，并接收包含最新帖子的响应。通过这种方式，应用程序可以保持最新的内容，并且您可以将数据保存在一个可供多个客户端访问的中心位置。</p><p id="c0a9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在本教程中，我们将使用Node.js和Express库来构建我们的REST API。Node.js是一个强大的JavaScript运行时，允许您使用JavaScript构建服务器端应用程序，而Express是一个流行的库，用于使用Node.js构建API和web应用程序。这些工具结合在一起，可以轻松构建快速、可伸缩的API，从而处理各种请求和工作负载。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/08856188a00366324f27c7a93de548a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sr9D-0Nbru2BmvMPt-MA7w.png"/></div></div></figure><h1 id="787c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">设置项目</h1><p id="013b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">既然我们已经很好地理解了什么是REST API，以及为什么我们可能想要构建一个REST API，那么是时候开始着手建立我们的项目了。</p><p id="a3e6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们需要做的第一件事是在我们的机器上安装Node.js。Node.js是一个JavaScript运行时，它允许我们在服务器端运行JavaScript，这是构建我们的API所必需的。可以从官网(<a class="ae ma" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/</a>)下载安装Node.js的最新版本。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mb"><img src="../Images/080b1fa59abe87443798e17c92f96cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rRFQGy2aEfNqitW81DUy5A.png"/></div></div></figure><p id="be52" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一旦安装了Node.js，就可以通过打开终端并导航到要存储项目的目录来创建一个新项目。然后，运行以下命令创建一个新的Node.js项目:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="195e" class="mh jo iq md b be mi mj l mk ml">npm init</span></pre><p id="eb26" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">该命令将提示您输入一些关于项目的信息，例如名称、版本和描述。您可以通过按Enter键接受默认值，也可以根据自己的喜好进行自定义。完成后，您应该会在项目目录中看到一个名为“package.json”的新文件。该文件包含关于您的项目的元数据，包括您需要安装的依赖项(即库和框架)。</p><p id="b095" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">接下来，我们将安装Express库，我们将使用它来构建我们的API。要安装Express，请在终端中运行以下命令:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="1ea9" class="mh jo iq md b be mi mj l mk ml">npm install express</span></pre><p id="a9fb" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这将下载并安装最新版本的Express，并将其添加到package.json文件的“dependencies”部分。</p><p id="d316" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在我们已经设置了Node.js和Express，我们可以开始构建API的基本结构了。在项目目录的根目录下，创建一个名为“app.js”的新文件。这将是我们的API的入口点，我们将在这里设置Express应用程序并配置路线。</p><p id="f563" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在app.js文件中，添加以下代码以导入Express库并创建新的Express应用程序:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="490f" class="mh jo iq md b be mi mj l mk ml">const express = require('express');<br/>const app = express();</span></pre><p id="c3a4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">接下来，我们将设置一个简单的路由来处理对API根路径的GET请求。将以下代码添加到app.js中:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="7ef8" class="mh jo iq md b be mi mj l mk ml">app.get('/', (req, res) =&gt; {<br/>  res.send('Hello, World!');<br/>});</span></pre><p id="7194" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这段代码定义了一个路由，该路由监听到API根路径的GET请求，并发送一个带有消息“Hello，World！”的响应。</p><p id="0469" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">最后，我们需要启动服务器并使API对客户机可用。将以下代码添加到app.js中:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="55b5" class="mh jo iq md b be mi mj l mk ml">const port = process.env.PORT || 3000;<br/>app.listen(port, () =&gt; {<br/>  console.log(`API server listening on port ${port}`);<br/>});</span></pre><p id="3c43" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这段代码设置API将监听的端口。我们在这里使用<code class="fe mm mn mo md b">process.env.PORT</code>变量来允许将API部署到像AWS或Azure这样的云平台，这将自动设置端口。如果没有设置<code class="fe mm mn mo md b">process.env.PORT</code>变量，我们将使用端口3000。</p><p id="e197" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">就是这样！现在，您已经有了一个使用Node.js和Express设置的基本API。您可以通过在终端中运行以下命令来启动API:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="b323" class="mh jo iq md b be mi mj l mk ml">node app.js</span></pre><p id="357e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这将启动API服务器，您应该在终端中看到消息“API服务器监听端口[port]”。</p><p id="4f6a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，如果你打开网络浏览器，导航到<code class="fe mm mn mo md b">http://localhost:[port]</code>，你应该会看到“你好，世界！”显示在浏览器中。恭喜你，你有了一个工作的REST API！</p><h1 id="00e7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">定义路由和处理HTTP请求</h1><p id="872d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上一节中，我们使用Node.js和Express设置了一个基本的API，并处理了对API根路径的GET请求。在这一节中，我们将更深入地定义路由和处理不同类型的HTTP请求。</p><p id="ab4b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">路由是客户端可以访问以检索或操作数据的API的端点。在Express中，您可以使用<code class="fe mm mn mo md b">app.METHOD()</code>函数定义路由，其中<code class="fe mm mn mo md b">METHOD</code>是路由将处理的HTTP方法(例如，GET、POST、PUT、DELETE)。例如，下面是如何定义一个路由来处理对<code class="fe mm mn mo md b">/posts</code>路径的GET请求:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="1dc3" class="mh jo iq md b be mi mj l mk ml">app.get('/posts', (req, res) =&gt; {<br/>  // Code to handle the request and send a response<br/>});</span></pre><p id="f4c9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><code class="fe mm mn mo md b">req</code> (request)对象包含关于传入请求的信息，比如HTTP方法、URL、请求头和请求体(如果是POST或PUT请求)。<code class="fe mm mn mo md b">res</code> (response)对象包含可以用来向客户端发送响应的方法，例如<code class="fe mm mn mo md b">res.send()</code>、<code class="fe mm mn mo md b">res.json()</code>和<code class="fe mm mn mo md b">res.render()</code>。</p><p id="ec82" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">下面是一个例子，说明如何使用<code class="fe mm mn mo md b">req</code>和<code class="fe mm mn mo md b">res</code>对象来处理对<code class="fe mm mn mo md b">/posts</code>路由的GET请求，并发送一个带有帖子列表的JSON响应:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="4b83" class="mh jo iq md b be mi mj l mk ml">app.get('/posts', (req, res) =&gt; {<br/>  const posts = [<br/>    { id: 1, title: 'Post 1' },<br/>    { id: 2, title: 'Post 2' },<br/>    { id: 3, title: 'Post 3' }<br/>  ];<br/>  res.json(posts);<br/>});</span></pre><p id="1583" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">除了GET之外，您还可以分别使用<code class="fe mm mn mo md b">app.post()</code>、<code class="fe mm mn mo md b">app.put()</code>和<code class="fe mm mn mo md b">app.delete()</code>函数处理其他HTTP方法，比如POST、PUT和DELETE。下面是一个例子，说明如何处理对<code class="fe mm mn mo md b">/posts</code>路由的post请求，以创建一个新的POST:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="f2d2" class="mh jo iq md b be mi mj l mk ml">app.post('/posts', (req, res) =&gt; {<br/>  const newPost = {<br/>    id: 4,<br/>    title: req.body.title<br/>  };<br/>  // Add the new post to the list of posts<br/>  res.json(newPost);<br/>});</span></pre><p id="40fe" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在这个例子中，我们使用<code class="fe mm mn mo md b">req.body</code>属性来访问post请求的主体，它应该包含新POST的数据。根据API的需要，您可以使用类似的技术来处理PUT和DELETE请求。</p><h1 id="1746" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用数据和数据库</h1><p id="c091" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在前面的章节中，我们学习了如何在我们的API中定义路由和处理HTTP请求。在这一节中，我们将深入研究使用数据和数据库在我们的API中存储和检索数据的细节。</p><p id="4844" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">根据您的需求和应用程序的复杂性，在API中存储数据有许多不同的方式。一种简单的方法是使用变量或数组将数据存储在内存中。例如，您可以将帖子列表存储在一个变量中，如下所示:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="1e6f" class="mh jo iq md b be mi mj l mk ml">let posts = [<br/>  { id: 1, title: 'Post 1' },<br/>  { id: 2, title: 'Post 2' },<br/>  { id: 3, title: 'Post 3' }<br/>];</span></pre><p id="263f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这种方法对于测试和原型开发很有用，但是它有一些缺点。首先，数据不会在API重新启动时保持不变，所以每次停止和启动服务器时都会丢失所有数据。此外，随着数据集的增长，内存中的数据存储可能会变得缓慢和低效，并且它们不能很好地扩展以支持多个客户端。</p><p id="6ce9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">更可靠的解决方案是使用数据库来存储您的数据。您可以使用许多不同的数据库，比如MongoDB、MySQL、PostgreSQL和SQLite。每个数据库都有自己的优点和缺点，最佳选择将取决于您的特定需求和要求。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mp"><img src="../Images/a57e665b4c56861b325e46fd07cde279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FbFTTBSzhv2VyhP2RjsnA.png"/></div></div></figure><p id="de06" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在本教程中，我们将以MongoDB为例。要在API中使用MongoDB，您需要为Node.js安装MongoDB驱动程序，并连接到MongoDB数据库。这里有一个你可以如何做的例子:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="2451" class="mh jo iq md b be mi mj l mk ml">const mongoose = require('mongoose');<br/><br/>mongoose.connect('mongodb://localhost/myapi', {<br/>  useNewUrlParser: true,<br/>  useUnifiedTopology: true<br/>});<br/><br/>const db = mongoose.connection;<br/>db.on('error', console.error.bind(console, 'connection error:'));<br/>db.once('open', () =&gt; {<br/>  console.log('Connected to MongoDB!');<br/>});</span></pre><p id="7dd5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这段代码使用<code class="fe mm mn mo md b">mongoose</code>库连接到本地机器上运行的MongoDB数据库。<code class="fe mm mn mo md b">db</code>变量代表与数据库的连接，我们使用<code class="fe mm mn mo md b">db.on()</code>和<code class="fe mm mn mo md b">db.once()</code>函数来处理连接错误，并在连接成功时记录一条消息。</p><p id="7f3d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一旦建立了数据库连接，就可以开始定义模式和模型来表示数据。模式定义数据的结构，模型用于创建和操作数据的实例。下面是一个如何定义文章模式和模型的例子:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="10a4" class="mh jo iq md b be mi mj l mk ml">const postSchema = new mongoose.Schema({<br/>  title: String,<br/>  body: String<br/>});<br/><br/>const Post = mongoose.model('Post', postSchema);</span></pre><p id="1b9c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">定义了模式和模型后，您可以使用Mongoose的方法创建、读取、更新和删除数据库中的数据。下面是一个示例，说明如何使用<code class="fe mm mn mo md b">Post</code>模型从数据库中检索所有帖子，并向客户端发送JSON响应:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="03ad" class="mh jo iq md b be mi mj l mk ml">app.get('/posts', (req, res) =&gt; {<br/>  Post.find((err, posts) =&gt; {<br/>    if (err) return res.status(500).send(err);<br/>    res.json(posts);<br/>  });<br/>});</span></pre><p id="b6a4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">除了处理数据和数据库，在API中处理数据验证和错误处理也很重要。数据验证确保提交给API的数据格式正确，并且符合您定义的任何业务规则。错误处理确保您的API优雅地处理和响应请求处理过程中可能出现的任何错误。</p><p id="f693" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">有许多不同的方法可以在API中实现数据验证和错误处理。一种简单的方法是使用<code class="fe mm mn mo md b">joi</code>库进行数据验证，使用<code class="fe mm mn mo md b">express-async-errors</code>库处理异步错误。下面是一个示例，说明如何使用这些库来验证POST请求的主体并处理可能出现的任何错误:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="3f1c" class="mh jo iq md b be mi mj l mk ml">const Joi = require('joi');<br/><br/>app.post('/posts', async (req, res) =&gt; {<br/>  const schema = Joi.object().keys({<br/>    title: Joi.string().min(3).max(255).required(),<br/>    body: Joi.string().min(3).required()<br/>  });<br/>  const { error } = Joi.validate(req.body, schema);<br/>  if (error) return res.status(400).send(error.details[0].message);<br/><br/>  try {<br/>    const post = new Post(req.body);<br/>    await post.save();<br/>    res.send(post);<br/>  } catch (error) {<br/>    res.status(500).send(error);<br/>  }<br/>});</span></pre><p id="3f66" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在这个例子中，我们使用<code class="fe mm mn mo md b">joi</code>库为POST请求的主体定义一个模式，并根据这个模式验证请求主体。如果数据无效，我们将发送一个状态代码为400(错误请求)的响应和错误消息。如果数据有效，我们将使用<code class="fe mm mn mo md b">Post</code>模型创建一个新帖子，并将其保存到数据库中。如果在保存操作过程中出现任何错误，我们将捕获错误并发送一个状态代码为500(内部服务器错误)的响应。</p><h1 id="ecbc" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">测试API</h1><p id="5e8a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在前面的章节中，我们学习了如何定义路由和处理HTTP请求，以及如何使用数据和数据库在我们的API中存储和检索数据。在这最后一节，我们将看看如何测试我们的API，以确保它按预期工作。</p><p id="2347" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">测试是软件开发过程中的一个重要部分，因为它可以帮助您在bug和错误进入生产之前捕捉它们。有两种主要的测试类型:单元测试和集成测试。单元测试包括单独测试代码的单个单元或组件，而集成测试包括测试代码的不同单元如何协同工作。</p><p id="c5f7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在本教程中，我们将关注集成测试，因为它允许我们测试API的全部功能。要为我们的API编写集成测试，我们将使用Mocha和Chai库。Mocha是一个测试运行器，它使设置和运行测试变得容易，Chai是一个断言库，它为测试提供了丰富的断言集。</p><p id="b866" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">要安装Mocha和Chai，请在您的终端中运行以下命令:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="9ad2" class="mh jo iq md b be mi mj l mk ml">npm install --save-dev mocha chai</span></pre><p id="0b7f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">安装了Mocha和Chai之后，您就可以开始为您的API路由编写测试用例了。测试用例是测试代码特定方面的一组步骤，通常由三部分组成:测试描述、测试设置和测试断言。下面是测试响应状态代码和响应主体的<code class="fe mm mn mo md b">/posts</code>路由的测试用例示例:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="400b" class="mh jo iq md b be mi mj l mk ml">describe('GET /posts', () =&gt; {<br/>  it('should return all posts', (done) =&gt; {<br/>    chai.request(app)<br/>      .get('/posts')<br/>      .end((err, res) =&gt; {<br/>        should.not.exist(err);<br/>        res.status.should.equal(200);<br/>        res.type.should.equal('application/json');<br/>        res.body.should.be.an('array');<br/>        res.body.length.should.equal(3);<br/>        done();<br/>      });<br/>  });<br/>});</span></pre><p id="7a22" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在这个测试用例中，我们使用<code class="fe mm mn mo md b">chai.request()</code>函数向<code class="fe mm mn mo md b">/posts</code>路由发送GET请求，使用<code class="fe mm mn mo md b">end()</code>函数处理响应。<code class="fe mm mn mo md b">done</code>回调用于告诉Mocha测试何时完成。在<code class="fe mm mn mo md b">end()</code>函数中，我们使用Chai提供的<code class="fe mm mn mo md b">should</code>语法来断言响应状态代码、响应类型、响应主体和响应主体的长度。</p><p id="0d84" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">要运行测试，您可以在终端中使用<code class="fe mm mn mo md b">mocha</code>命令。默认情况下，Mocha会在<code class="fe mm mn mo md b">test</code>目录中查找测试文件，所以您需要创建一个<code class="fe mm mn mo md b">test</code>目录，并将测试文件放在那里。下面是一个如何从终端运行测试的示例:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="3b64" class="mh jo iq md b be mi mj l mk ml">mocha</span></pre><p id="f636" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果所有测试都通过了，您应该会看到一条消息，表明所有测试都通过了。如果有任何测试失败，您将会看到一条详细的错误消息，指出哪里出错了。</p><h1 id="695b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">部署API</h1><p id="d577" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">既然您已经有了功能齐全且经过测试的API，那么是时候让用户使用它了。根据您的需求和预算，部署API有许多不同的选择。一些常见的选择包括部署到云平台，如亚马逊网络服务(AWS)或微软Azure，或使用Heroku或Zeit等托管服务。</p><p id="4525" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在本教程中，我们将了解如何使用Amazon弹性容器服务(ECS)将API部署到AWS。AWS ECS是一个完全托管的容器编排服务，使其易于运行、扩展和监控容器化的应用程序。要将API部署到ECS，您需要创建一个AWS帐户并设置一个ECS集群。</p><h2 id="0a6d" class="mq jo iq bd jp mr ms dn jt mt mu dp jx kw mv mw kb la mx my kf le mz na kj nb bi translated">创建AWS帐户</h2><p id="5a21" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要创建AWS帐户，请转到AWS主页并单击“创建免费帐户”按钮。按照提示输入您的联系和帐单信息，并选择一个支持计划。一旦您的帐户设置完毕，您将被带到AWS管理控制台。</p><h2 id="e74f" class="mq jo iq bd jp mr ms dn jt mt mu dp jx kw mv mw kb la mx my kf le mz na kj nb bi translated">创建ECS群集</h2><p id="1135" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要创建ECS群集，请单击顶部导航栏中的“服务”下拉列表，并从列表中选择“ECS”。在ECS控制面板上，单击“Create cluster”按钮。选择“EC2 Linux + Networking”作为集群模板，并为集群命名。</p><p id="e9cd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">单击“创建”按钮创建集群。创建群集可能需要几分钟时间。一旦集群准备就绪，您会在集群名称旁边看到一个绿色的勾号。</p><p id="f205" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">要将您的API部署到ECS集群，您需要创建您的API的Docker映像，并将其推送到Docker注册中心。Docker是一个容器化平台，允许您将应用程序及其依赖项打包到一个自包含的单元中，该单元可以在任何安装了Docker的机器上轻松部署和运行。</p><h2 id="bc70" class="mq jo iq bd jp mr ms dn jt mt mu dp jx kw mv mw kb la mx my kf le mz na kj nb bi translated">创建Docker图像</h2><p id="1213" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要创建API的Docker映像，您需要在项目的根目录下创建一个<code class="fe mm mn mo md b">Dockerfile</code>。<code class="fe mm mn mo md b">Dockerfile</code>是一个文本文件，包含构建Docker映像的指令。下面是一个Node.js API的<code class="fe mm mn mo md b">Dockerfile</code>的例子:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="6997" class="mh jo iq md b be mi mj l mk ml">FROM node:14<br/>WORKDIR /usr/src/app<br/>COPY package*.json ./<br/>RUN npm install<br/>COPY . .<br/>EXPOSE 3000<br/>CMD ["npm", "start"]</span></pre><p id="1229" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">该<code class="fe mm mn mo md b">Dockerfile</code>使用<code class="fe mm mn mo md b">node:14</code>图像作为基础图像，并将工作目录设置为<code class="fe mm mn mo md b">/usr/src/app</code>。然后，它将<code class="fe mm mn mo md b">package.json</code>和<code class="fe mm mn mo md b">package-lock.json</code>文件复制到工作目录，并运行<code class="fe mm mn mo md b">npm install</code>来安装依赖项。它将剩余的文件复制到工作目录，公开端口3000，并运行<code class="fe mm mn mo md b">npm start</code>命令来启动API。</p><p id="e4b6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">要构建Docker映像，请在终端中运行以下命令:</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="2459" class="mh jo iq md b be mi mj l mk ml">docker build -t my-api .</span></pre><p id="c323" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这个命令将构建Docker映像，并用名称<code class="fe mm mn mo md b">my-api</code>标记它。要将图像推送到Docker注册中心，您需要登录注册中心，然后运行</p><pre class="lp lq lr ls gt mc md me bn mf mg bi"><span id="c696" class="mh jo iq md b be mi mj l mk ml">docker push my-api</span></pre><p id="26c2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你可以使用许多不同的Docker注册中心，但是最流行的是Docker Hub。要将您的图像推送到Docker Hub，您需要创建一个帐户，然后使用<code class="fe mm mn mo md b">docker login</code>命令登录。</p><p id="2265" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">将Docker映像推送到注册表后，现在就可以将其部署到ECS集群了。为此，您需要创建一个任务定义和一个服务。任务定义是描述如何运行容器化应用程序的蓝图，而服务是一个长期运行的任务，代表在集群上运行的一组相同的任务。</p><h2 id="6ce4" class="mq jo iq bd jp mr ms dn jt mt mu dp jx kw mv mw kb la mx my kf le mz na kj nb bi translated">创建任务定义</h2><p id="aff0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要创建任务定义，请转到ECS控制面板，然后单击左侧导航栏中的“任务定义”链接。单击“创建新任务定义”按钮，并选择“Fargate”作为启动类型。为您的任务定义命名，然后单击“添加容器”按钮将容器添加到任务中。</p><p id="a870" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在容器定义表单中，输入容器的名称、Docker映像的映像URI和端口映射。端口映射应该将主机端口映射到容器端口。例如，如果您的API监听端口3000，您可以将主机端口3000映射到容器端口3000。单击“添加”按钮将容器添加到任务定义中，然后单击“创建”按钮创建任务定义。</p><h2 id="a9c1" class="mq jo iq bd jp mr ms dn jt mt mu dp jx kw mv mw kb la mx my kf le mz na kj nb bi translated">创建服务</h2><p id="b475" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要创建服务，请单击左侧导航栏中的“服务”链接，然后单击“创建服务”按钮。选择您之前创建的集群，并选择您刚刚创建的任务定义。为您的服务命名，然后单击“创建”按钮创建服务。</p><p id="57dc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">创建服务和启动任务可能需要几分钟时间。任务运行后，您将看到服务的状态变为“活动”。您可以单击“查看服务”按钮来查看有关服务的更多详细信息，包括任务状态、正在运行的任务数量以及任务的公共IP地址。</p><h2 id="e39b" class="mq jo iq bd jp mr ms dn jt mt mu dp jx kw mv mw kb la mx my kf le mz na kj nb bi translated">访问您的API</h2><p id="36b4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要从互联网访问您的API，您需要为您的任务分配一个公共IP地址。为此，请单击“任务”选项卡，然后单击要更新的任务旁边的“编辑”按钮。在“网络”部分，选择“分配公共IP ”,并从下拉列表中选择“启用”。单击“更新”按钮保存更改。</p><p id="13b4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为您的任务分配一个公共IP地址后，您现在可以使用公共IP地址和您在端口映射中指定的端口从互联网访问您的API。例如，如果您的API监听端口3000，并且有一个公共IP地址<code class="fe mm mn mo md b">1.2.3.4</code>，您可以在<code class="fe mm mn mo md b"><a class="ae ma" href="http://1.2.3.4:3000." rel="noopener ugc nofollow" target="_blank">http://1.2.3.4:3000</a></code> <a class="ae ma" href="http://1.2.3.4:3000." rel="noopener ugc nofollow" target="_blank">访问它。</a></p><h1 id="9642" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="714a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本教程中，我们讨论了以下主题:</p><ul class=""><li id="3bd4" class="nc nd iq kn b ko lj ks lk kw ne la nf le ng li nh ni nj nk bi translated">什么是REST API，为什么您可能想要构建一个</li><li id="8157" class="nc nd iq kn b ko nl ks nm kw nn la no le np li nh ni nj nk bi translated">使用Node.js和Express设置项目</li><li id="c128" class="nc nd iq kn b ko nl ks nm kw nn la no le np li nh ni nj nk bi translated">定义路由和处理HTTP请求</li><li id="c4b6" class="nc nd iq kn b ko nl ks nm kw nn la no le np li nh ni nj nk bi translated">使用数据和数据库</li><li id="2514" class="nc nd iq kn b ko nl ks nm kw nn la no le np li nh ni nj nk bi translated">测试API</li><li id="8dcd" class="nc nd iq kn b ko nl ks nm kw nn la no le np li nh ni nj nk bi translated">将API部署到AWS ECS</li></ul><p id="cea5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我希望本教程对您有所帮助，并且您现在有信心构建自己的REST APIs。如果您希望在API的基础上进行构建并添加额外的功能，这里有一些想法可以考虑:</p><ul class=""><li id="c070" class="nc nd iq kn b ko lj ks lk kw ne la nf le ng li nh ni nj nk bi translated">认证和授权:您可以使用像Passport或JWT这样的库来向您的API添加用户认证和授权。</li><li id="288c" class="nc nd iq kn b ko nl ks nm kw nn la no le np li nh ni nj nk bi translated">缓存:您可以使用像<code class="fe mm mn mo md b">node-cache</code>或<code class="fe mm mn mo md b">redis</code>这样的缓存库，通过在内存中存储频繁访问的数据来提高API的性能。</li><li id="4005" class="nc nd iq kn b ko nl ks nm kw nn la no le np li nh ni nj nk bi translated">负载平衡:如果您希望您的API接收大量流量，您可以使用类似NGINX或Amazon Elastic Load Balancer这样的负载平衡器来将负载分布到多个任务或实例中。</li><li id="7f93" class="nc nd iq kn b ko nl ks nm kw nn la no le np li nh ni nj nk bi translated">监控和日志记录:您可以使用AWS CloudWatch或Loggly等工具来监控API的性能和日志，并在出现问题时接收警报。</li></ul></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="d8e5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">不要错过我即将发布的内容和技术指南:</strong></p><div class="nx ny gp gr nz oa"><a href="https://medium.com/@nicchong/subscribe" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">每当Nic Chong发布时收到电子邮件。</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">每当Nic Chong发布时收到电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ly oa"/></div></div></a></div><p id="9e1f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果你有什么问题，我在这里帮忙，在评论区等你:)</p></div></div>    
</body>
</html>