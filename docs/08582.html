<html>
<head>
<title>Treat If-Else as a Code Smell Until Proven Otherwise</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将If-Else视为代码气味，直到被证明并非如此</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/treat-if-else-as-a-code-smell-until-proven-otherwise-3bd2c4c577bf?source=collection_archive---------6-----------------------#2021-05-14">https://levelup.gitconnected.com/treat-if-else-as-a-code-smell-until-proven-otherwise-3bd2c4c577bf?source=collection_archive---------6-----------------------#2021-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c00a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">C#中If-Else重构技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/33f0eda99225c67872bd31075bcc0c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k8-u7p7FhIny4rn_"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@garri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗拉季斯拉夫·巴比延科</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="358e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">If-Else是任何软件应用程序中使用的最简单和最常见的编程结构之一，不管它有多复杂。</p><p id="e267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要使用得当，使用If-Else语句并没有错。</p><p id="0974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">If-Else语句相当简单，写起来也很快，这使得它很容易被滥用。</p><p id="d3f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发者无意识或有意识地可以选择If-Else作为问题的短期解决方案。If-Else通常是一种代码气味，它可能预示着糟糕的设计决策和重构的需要。</p><p id="cefe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何知道If-Else是否被误用？你如何知道在If-Else中选择哪个？</p><p id="7410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们深潜吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9a45" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将If-Else重构为值对象</h1><p id="9db4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对原始数据类型的条件检查可以隐藏原始困扰问题。</p><p id="9c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个验证和更改用户电子邮件地址的简单例子。</p><h2 id="4a89" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">If-Else方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0ad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串数据类型用于存储用户的电子邮件地址。从编程语言的角度来看，这种方法是完全有效的，因为可以存储在字符串类型中的所有可能的字符串的范围比所有可能的电子邮件地址的范围大得多。换句话说，每个电子邮件都是一个字符串，但不是每个字符串都是电子邮件。</p><p id="10d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，由于一个字符串可能不仅包含电子邮件，我们必须在每次保存电子邮件、更改电子邮件、发送电子邮件或从应用程序的不同部分执行一些其他重要操作之前编写验证逻辑，以确保该字符串包含有效的电子邮件。这可能导致复制和粘贴验证规则。</p><p id="3600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过创建一个单独的类来解决原语困扰问题，该类包含原语字段和与该字段相关联的验证逻辑。</p><h2 id="370b" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">价值对象方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b49a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述方法的主要好处是一旦<code class="fe nn no np nq b">UserEmail</code>对象被创建，我们不再需要验证它。该对象将始终有效。</p><p id="0672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何将字符串赋给<code class="fe nn no np nq b">UserEmail</code>的尝试都将导致编译器错误，因此不需要像原语一样不断检查<code class="fe nn no np nq b">UserEmail</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="769d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重构If-Else来陈述设计模式</h1><p id="5512" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你有没有注意到，你第一次点击YouTube上的喜欢按钮，喜欢的数量增加，但再次点击后，喜欢的数量减少了？或者，如果你点击了不喜欢按钮，不喜欢的数量会增加，但如果你点击了喜欢按钮后又点击了不喜欢，喜欢的数量也会减少？</p><p id="d89e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">做同样的动作会导致不同的结果，这意味着正在跟踪喜欢和不喜欢数量的对象有一个状态。</p><p id="d129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先用一种简单的方法实现这个逻辑:</p><h2 id="77cb" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">If-Else方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象的状态存储在<code class="fe nn no np nq b">Current</code>属性中。每次我们调用<code class="fe nn no np nq b">Like</code>方法，状态都会发生变化。每个后续调用将执行不同的条件分支，因此行为会有所不同。</p><p id="056f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何使用状态设计模式实现相同的逻辑:</p><h2 id="6267" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">状态设计模式</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子<strong class="lb iu">纯粹是教育性的</strong>，目的是演示如何实现状态模式。事实上，这是过度工程化，因为有少量固定数量的状态具有简单的逻辑。</p><p id="80d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下情况下，开发人员可以考虑使用状态设计模式:</p><ul class=""><li id="1fad" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">对象的行为取决于其状态。</li><li id="baea" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">与每个状态相关的逻辑是复杂的。</li><li id="7f6d" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">有许多条件决定了从一种状态到另一种状态的转变。</li></ul><p id="4b5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果开发人员使用一个if-else块来实现满足上述所有三个条件的逻辑，代码就变成了意大利面条代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="82fa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重构If-Else到表驱动方法</h1><p id="e643" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通常在软件开发过程中，有必要根据提供的输入参数来解析一个值。</p><p id="4927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，范围1 … 12对应于月份名称“一月”…“十二月”。或者像json、xml、yaml这样的扩展类型对应于<code class="fe nn no np nq b">JsonParser</code>、<code class="fe nn no np nq b">XmlParser</code>和<code class="fe nn no np nq b">YamlParser.</code>类</p><p id="ce60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常应该有一种方法可以根据提供的输入来解析值，使用条件语句似乎是很自然的。</p><h2 id="7de9" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">If-Else方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="21a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，表示文件扩展名的字符串对应于具体的类类型。</p><p id="a1af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种重复的代码可以通过引入一个<code class="fe nn no np nq b">Dictionary&lt;TKey, TValue&gt;</code>来简化，其中key是extension，value是lambda函数，它实例化并返回一个解析器的实例。</p><h2 id="852e" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">表格驱动方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1f59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，字典的值也可以只是<code class="fe nn no np nq b">Parser</code>而不是<code class="fe nn no np nq b">Func&lt;Parser&gt;</code>类型。这完全取决于你的具体情况。如果每次通过键访问字典时都需要一个新的实例，请选择lambda表达式。如果您希望所有的解析器实例被创建一次，使用<code class="fe nn no np nq b">Dictionary&lt;string, Parser&gt;</code>类型并初始化它，如下所示:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="5fbe" class="mz md it nq b gy oj ok l ol om">Dictionary&lt;string, Parser&gt; _parsers = <br/>   new Dictionary&lt;string, Parser&gt;()<br/>   {<br/>      { ".json", new JsonParser() },<br/>      { ".xml", new XmlParser() },<br/>      { ".yaml", new YamlParser() }<br/>   };</span></pre><p id="4386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转向表驱动的方法有几个好处:</p><ul class=""><li id="4fe4" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">代码变得更加紧凑，可读性更强。</li><li id="5ef3" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">不应该再修改<code class="fe nn no np nq b">Create</code>方法来引入新的解析器类型(<strong class="lb iu">开/闭原则</strong>)。</li><li id="bcce" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">存储扩展和解析器之间映射的字典可以被其他代码重用，因为它不再被硬编码在<code class="fe nn no np nq b">Create</code>方法中。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7aa9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重构If-Else以切换表达式</h1><p id="a6d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">实现输入到值的映射的另一种方法是构造一个开关表达式。</p><p id="c06f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们记住基于If-Else的<code class="fe nn no np nq b">ParserFatory</code>类的实现:</p><h2 id="bd29" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">If-Else方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="320a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何使用开关表达式语法来简化它:</p><h2 id="43fe" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">开关表达式方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7a5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，每次调用<code class="fe nn no np nq b">GetParser</code>方法时，解析器都会被实例化。如果您希望它们只被创建一次，您需要使用<code class="fe nn no np nq b">Dictionary&lt;string, Parser&gt;</code>类型并初始化它一次。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0a35" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重构If-Else到策略设计模式</h1><p id="4052" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据一组规则检查对象的需要会导致代码中出现单一的if-else块。</p><h2 id="4aa8" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">If-Else方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="25bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们根据一组规则检查文件。检查文件名长度的规则总是应用于每个文件，其余的检查取决于用户的类型。特权用户可以上传扩展名范围更广的较大文件。</p><p id="008a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们只需要在应用程序的不同位置为标准用户重用文件验证逻辑时，就会出现问题。没有复制和粘贴，这是不可能的，因为我们只有一个monolith方法可以做所有的事情。此外，大型方法更难进行单元测试，因为更难确保覆盖所有情况。</p><p id="9ac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些问题可以通过将代码重构为策略模式来解决。</p><h2 id="7499" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">战略设计模式</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最终得到了更小的方法<code class="fe nn no np nq b">ValidateFile</code>和两个封装了特定于用户的验证规则的新的可重用类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e3d2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重构If-Else到Lazy <t>类</t></h1><p id="9f8b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对象的延迟加载可以用几行代码实现。</p><h2 id="f704" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">If-Else方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="cc80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当客户端调用<code class="fe nn no np nq b">Instance</code>属性时，才会创建<code class="fe nn no np nq b">Config</code>类的实例。不早也不晚。</p><p id="2476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用条件检查来实现延迟加载对于多线程环境来说是一种代码味道，因为这样的实现不是线程安全的。</p><p id="3c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该使用<code class="fe nn no np nq b">Lazy&lt;T&gt;</code>类，而不是手写的惰性加载模式。</p><h2 id="8b0e" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">懒惰的<t>方法</t></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="de6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b"> Lazy&lt;T&gt;</code>对象是懒惰的、线程安全的，并且还实现了一种性能更好的<a class="ae ky" href="https://en.wikipedia.org/wiki/Double-checked_locking" rel="noopener ugc nofollow" target="_blank">双重检查锁定</a>技术。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ab0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="44dc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们不能完全摆脱If-Else语句，这也不是我们真正的目标。除了执行各种代码分支的主要目的之外，If-Else结构还有一个次要目的——向我们展示通过应用适当的面向对象设计模式和技术，我们可以在哪些地方改进系统。为什么不利用这些技巧呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="c983" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">我的其他文章:</h2><div class="on oo gp gr op oq"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">如何专业地对Bug修复进行代码审查</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">审查bug修复时要问的几个重要问题。</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a rel="noopener  ugc nofollow" target="_blank" href="/the-simplest-explanation-of-adapter-design-pattern-cd37f02bfecd"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">适配器设计模式的最简单解释</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">C#中的真实世界示例</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a rel="noopener  ugc nofollow" target="_blank" href="/you-are-simply-injecting-a-dependency-thinking-that-you-are-following-the-dependency-inversion-32632954c208"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">你只是简单地注入一个依赖，认为你在遵循依赖倒置…</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">澄清差异。</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oz l"><div class="pg l pb pc pd oz pe ks oq"/></div></div></a></div></div></div>    
</body>
</html>