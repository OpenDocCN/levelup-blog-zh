<html>
<head>
<title>Priority Messages in Distributed Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统中的优先级消息</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/priority-messages-in-distributed-systems-369a844316a3?source=collection_archive---------7-----------------------#2021-05-23">https://levelup.gitconnected.com/priority-messages-in-distributed-systems-369a844316a3?source=collection_archive---------7-----------------------#2021-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4fd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分布式系统可能使用消息队列或消息流在服务之间进行异步通信。系统设计者可以从许多产品中进行选择，考虑到特定的特性，比如消息优先级。在这篇文章中，我将关注如何在几乎所有的消息系统中设计上述优先级。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1b9b429f0d02163e252412e7e2f32ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8qpjSorus-NniA3w"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Marc-Olivier Jodoin 在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="abb3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">信息系统</h1><p id="c348" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">简单地说，消息系统允许<em class="mf">生产者</em>使用<em class="mf">代理</em>向<em class="mf">消费者</em>发送<em class="mf">消息</em>。消息通常包含:</p><ul class=""><li id="a79b" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">数据(字节序列)，</li><li id="df3d" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">元数据(例如，创建时间戳、创建者信息或传输控制信息)。</li></ul><p id="10e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">支持<em class="mf">主题</em>(通道、桶)的系统要求生产者在消息元数据中声明预期的目的地。</p><p id="4b63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代理接收消息，然后将其提供给消费者。</p><p id="7fdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者不是…</p><p id="bee9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据系统的不同，代理可能会首先为更紧急的消息让路，也可能会根据消息的元数据阻止消息。你可能认为经纪人决定消息何时到达消费者手中，但是实际发生的事情比看上去的要多。</p><p id="0b0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">系统中的所有消费者都可能在高负载下运行，所有消费者都可能由于网络故障而变得不可用，或者所有消费者都因为最新部署中引入的错误而拒绝消息。任何分布式系统都有一个冷酷的事实——总是存在许多可能的故障点。即使利用代理在两个组件之间中继数据也不能保证完成。</p><h1 id="158a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">本机消息优先级</h1><p id="1c54" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我之前暗示过，消息系统可能不支持优先级。要使它工作，所有3个组件类型(生产者、代理和消费者)需要协调工作。实际的实现取决于所选择的解决方案。</p><p id="cc42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">支持优先化的架构不能提供可靠的消息排序。我发现这在基于事件和基于命令的系统中很明显，在这些系统中，以任意顺序处理消息可能会带来巨大的问题。保持优先顺序可能意味着一些数据可能会由于缺乏消息的自然顺序而消失。</p><h1 id="6349" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">自定义邮件优先级</h1><p id="9dbf" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">其他架构要求系统设计人员自己解决优先级问题。怎么会？通过在选择的消息系统之上设计<em class="mf">一个</em> <em class="mf">优先级感知层</em>。</p><h2 id="4972" class="mu ld iq bd le mv mw dn li mx my dp lm jy mz na lq kc nb nc lu kg nd ne ly nf bi translated">优先主题</h2><p id="a750" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">使用主题的系统(有时称为通道或桶)对我们有利。我们可以将主题分成子主题，每个子主题负责不同的优先级。例如，我可以用<code class="fe ng nh ni nj b">orders-0</code>、<code class="fe ng nh ni nj b">orders-1</code>和<code class="fe ng nh ni nj b">orders-2</code>来替换名为<code class="fe ng nh ni nj b">orders</code>的主题(请注意，我在这里不是故意使用<code class="fe ng nh ni nj b">priority</code>这个术语的！).</p><p id="14cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生产者会将大部分数据发送给<code class="fe ng nh ni nj b">orders-1</code>，同时向<code class="fe ng nh ni nj b">orders-0</code>发出仓促的消息；<code class="fe ng nh ni nj b">orders-2</code>应接收最不重要的信息。设计者应该分配足够的消费者来处理来自三个不同主题的负载。</p><p id="fe93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前述解决方案有几个问题。首先，生产者和消费者都需要承认额外主题的存在。其次，制作人在发布消息之前必须选择主题。第三，主题划分没有考虑不同的负载场景。</p><h2 id="e67c" class="mu ld iq bd le mv mw dn li mx my dp lm jy mz na lq kc nb nc lu kg nd ne ly nf bi translated">优先级元数据</h2><p id="0fbd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们可以在消息元数据中传递优先级提示，而不是利用多个主题进行优先级排序。如果在特定时刻可行，这种方法允许代理和消费者移动执行队列中的消息。我已经创建了一个TypeScript项目来演示这个方法，可以在这里找到<a class="ae lb" href="https://github.com/grzpab/priority-message-system" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="9e83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优先级消息系统允许存在多个生产者和消费者，但只有一个代理。消息从生产者流向代理，按到达时间戳排序。代理以固定的时间间隔向消费者传输消息；只有一个消费者可以获得特定的消息。</p><p id="68d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个重要的发现——消费者充当生产者——允许将消息添加回队列。我将用它来实现优先化，使用消费者策略。我准备了其中的三个作为例子。</p><h2 id="eb34" class="mu ld iq bd le mv mw dn li mx my dp lm jy mz na lq kc nb nc lu kg nd ne ly nf bi translated">基于谓词的消费者策略</h2><p id="a927" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">基于谓词的策略将运行一个函数来判断消息是现在需要处理还是以后需要处理。如果没有，消费者将把它发送回队列，并增加谓词执行的次数。如果上述数字增加到任意的最大值，消息无论如何都会被处理。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">谓词消费者策略的示例性实现。</figcaption></figure><p id="a5d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谓词可能不仅会考虑消息数据，还会考虑系统状态。这一特性使用户能够适应当前的负载。作为一个故障保险，所有的消息在几个周期后最终得到处理。</p><h2 id="0ab7" class="mu ld iq bd le mv mw dn li mx my dp lm jy mz na lq kc nb nc lu kg nd ne ly nf bi translated">基于优先级的消费者策略</h2><p id="fa2d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">基于优先级的策略强制实施一个优先级阈值，低于该阈值则不进行处理。不同的消费者可能使用不同的阈值进行操作。系统环境的变化也可能影响这些数字。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">优先消费者战略的典型实施。</figcaption></figure><p id="91a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该策略通过在将消息发送回代理之前增加优先级来补偿优先级较低的消息。这确保了每个消息的成功处理。</p><h2 id="6586" class="mu ld iq bd le mv mw dn li mx my dp lm jy mz na lq kc nb nc lu kg nd ne ly nf bi translated">基于TTL的消费者策略</h2><p id="50f4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">基于TTL的策略处理特定生存时间范围内的消息。消费者将丢弃低TTL消息并减少高TTL消息的TTL。与前面的示例类似，接受范围可能会在运行时发生变化。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">TTL消费者策略的典型实施。</figcaption></figure><p id="0793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果管理员以错误的方式修改TTL范围，该策略可能会从系统中删除数据。我将让您来找出潜在的失败案例。我添加这个概念是为了说明简单的想法在不小心使用时会变得有问题。</p><p id="44f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以谨慎地交替使用不同的策略。我总是建议在将变更应用到生产系统之前先使用测试。</p><h1 id="2e15" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摘要</h1><p id="056d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我相信理解系统的局限性并找到解决它们的方法是这篇文章的关键。尽管有些消息系统本身不支持消息优先级，但我们总是可以在现有技术的基础上构建它。如果你对添加优先级处理有其他想法，请在评论区留言！</p></div></div>    
</body>
</html>