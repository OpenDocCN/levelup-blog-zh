<html>
<head>
<title>Write a Linux firewall from scratch based on Netfilter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Netfilter从头编写一个Linux防火墙</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/write-a-linux-firewall-from-scratch-based-on-netfilter-462013202686?source=collection_archive---------2-----------------------#2022-06-26">https://levelup.gitconnected.com/write-a-linux-firewall-from-scratch-based-on-netfilter-462013202686?source=collection_archive---------2-----------------------#2022-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="e7ea" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="7131" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lj lk ll lm b">Firewalls</code>是一个重要的工具，可以通过配置来保护您的服务器和基础设施。防火墙的主要功能是过滤数据、重定向流量和防范网络攻击。既有基于硬件的防火墙，也有基于软件的防火墙。这里我就不多讨论背景了，因为你可以在网上找到很多关于<a class="ae ln" href="https://en.wikipedia.org/wiki/Firewall_(computing)" rel="noopener ugc nofollow" target="_blank"> it </a>的文档。</p><p id="8560" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">你有没有想过从头开始实现一个简单的迷你防火墙？听起来很疯狂？但是借助Linux的力量，你可以做到这一点。当你看完这一系列文章后，你会发现，其实，这很简单。</p><p id="c608" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">你可能曾经在Linux上使用过各种防火墙，如<a class="ae ln" href="https://en.wikipedia.org/wiki/Iptables" rel="noopener ugc nofollow" target="_blank"> iptables </a>、<a class="ae ln" href="https://en.wikipedia.org/wiki/Nftables" rel="noopener ugc nofollow" target="_blank"> nftables </a>、<a class="ae ln" href="https://en.wikipedia.org/wiki/Uncomplicated_Firewall" rel="noopener ugc nofollow" target="_blank"> UFW </a>等。所有这些防火墙工具都是用户空间实用程序，它们都依赖于<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/Netfilter" rel="noopener ugc nofollow" target="_blank">Netfilter</a></code>。<code class="fe lj lk ll lm b">Netfilter</code>是Linux内核子系统，允许实现各种与网络相关的操作。<code class="fe lj lk ll lm b">Netfilter</code>允许你使用<code class="fe lj lk ll lm b">Linux Kernel Module</code>开发你的防火墙。如果您不知道Linux内核模块和Netfilter之类的技术，不要担心。在本文中，让我们基于Netfilter从头开始编写一个Linux防火墙。可以了解以下几个有趣的点:</p><ul class=""><li id="5c81" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">Linux内核模块开发。</li><li id="04e3" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">Linux内核网络编程。</li><li id="0f09" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">Netfilter模块开发。</li></ul><p id="a74d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这篇文章会稍微长一点，由五个部分组成:</p><ul class=""><li id="f5ae" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">Netfilter和内核模块的背景:介绍Netfilter和内核模块的相关理论。</li><li id="3069" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">制作第一个内核模块:学习如何编写一个简单的内核模块。</li><li id="4a94" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">Netfilter架构和API:回顾Netfilter钩子架构和源代码。</li><li id="10a4" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">Impement迷你防火墙:为我们的迷你防火墙编写代码。</li></ul><h1 id="81a2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Netfilter和内核模块的背景</h1><h2 id="9ca4" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">Netfilter的基础</h2><p id="0e1a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lj lk ll lm b">Netfilter</code>可以认为是Linux上的第三代<code class="fe lj lk ll lm b">firewall</code>。在Linux内核2.4引入<code class="fe lj lk ll lm b">Netfilter</code>之前，Linux上有以下两个老一代防火墙:</p><ul class=""><li id="3a3f" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">第一代是BSD UNIX的早期版本<code class="fe lj lk ll lm b">ipfw</code>到Linux 1.1的移植。</li><li id="0a55" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">第二代是Linux内核2.2系列开发的<code class="fe lj lk ll lm b">ipchains</code>。</li></ul><p id="7948" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">正如我们上面提到的，<code class="fe lj lk ll lm b">Netfilter</code>被设计为在Linux内核中为各种网络操作提供基础设施。所以<code class="fe lj lk ll lm b">firewall</code>只是<code class="fe lj lk ll lm b">Netfilter</code>提供的如下多种功能之一:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/6924b6d934daed0699a966e2da3aec2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/0*uCRQyLWynybGcifR.png"/></div></figure><ul class=""><li id="3533" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated"><strong class="kn ir">包过滤</strong>:负责根据规则过滤数据包。也是本文的主题。</li><li id="ee33" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><strong class="kn ir"> NAT(网络地址转换)</strong>:负责转换网络数据包的IP地址。<code class="fe lj lk ll lm b">NAT</code>是一个重要的协议，在<code class="fe lj lk ll lm b">conserving global address space in the face of IPv4 address exhaustion</code>中已经成为一个流行的必备工具。如果不了解<code class="fe lj lk ll lm b">NAT</code>协议，可以参考其他<a class="ae ln" href="https://en.wikipedia.org/wiki/Network_address_translation" rel="noopener ugc nofollow" target="_blank">文档</a>。我将在以后的文章中研究它。</li><li id="0bae" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><strong class="kn ir">报文篡改</strong>:负责修改报文内容(其实<code class="fe lj lk ll lm b">NAT</code>也是报文篡改的一种，修改源或目的IP地址)。例如，TCP SYN数据包的<code class="fe lj lk ll lm b">MSS (Maximum Segment Size)</code>值可以改变，以允许通过网络传输大尺寸的数据包。</li></ul><p id="66be" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">注意:本文将着重于基于Netfilter构建一个简单的防火墙来过滤数据包。所以<code class="fe lj lk ll lm b">NAT</code>和<code class="fe lj lk ll lm b">Packet Mangling</code>部分不在本文讨论范围内。</p><p id="fb3f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">包过滤只能在Linux内核中完成(Netfilter的代码也在内核中)，如果我们想写一个迷你防火墙，它必须在内核空间中运行。对吗？这是否意味着我们需要将代码添加到内核中并重新编译内核？想象一下，每次您想要添加新的包过滤规则时，您都必须重新编译内核。那是个坏主意。好消息是<code class="fe lj lk ll lm b">Netfilter</code>允许您使用<code class="fe lj lk ll lm b"><a class="ae ln" href="https://wiki.archlinux.org/title/Kernel_module" rel="noopener ugc nofollow" target="_blank">Linux kernel modules</a></code>添加扩展。</p><h2 id="8d8c" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">Linux内核模块基础</h2><p id="4b43" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">虽然Linux是一个<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/Monolithic_kernel" rel="noopener ugc nofollow" target="_blank">monolithic kernel</a></code>，但是可以使用内核模块进行扩展。模块可以插入内核，也可以按需移除。Linux隔离了内核，但允许您通过模块动态添加特定的功能。这样，Linux在稳定性和可用性之间保持了平衡。</p><p id="94fb" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我想在这里检查一下关于内核模块的一个令人困惑的地方:在<code class="fe lj lk ll lm b">driver</code>和<code class="fe lj lk ll lm b">module</code>之间有什么区别:</p><ul class=""><li id="2a7f" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">驱动程序是在内核中运行的一段代码，用来与一些硬件设备对话。它驱动硬件。标准的做法是尽可能将驱动程序构建为内核模块，而不是将它们静态地链接到内核，因为这样可以提供更大的灵活性。</li><li id="eb29" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">内核模块可能根本不是设备驱动程序。</li></ul><p id="a329" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在下一节中，我们将动手实现我们的迷你防火墙。我们将一步一步地介绍整个过程。第一步，让我们用一个简单的<code class="fe lj lk ll lm b">hello world</code>演示来编写我们的第一个Linux内核模块。然后让我们学习如何构建模块(这与在用户空间编译应用程序非常不同)以及如何在内核中加载它。</p><h1 id="b00f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">制作第一个内核模块</h1><p id="3027" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，我必须承认Linux内核模块开发是一个庞大而复杂的技术课题。有许多关于它的很棒的网上资源。本系列文章的重点是开发基于Netfilter的迷你防火墙，因此我们无法涵盖内核模块本身的所有方面。在以后的文章中，我将更深入地研究内核模块的知识。</p><h2 id="c16a" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">编写模块</h2><p id="b78e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以用一个单独的<code class="fe lj lk ll lm b">C</code>源代码文件<code class="fe lj lk ll lm b">hello.c</code>编写<code class="fe lj lk ll lm b">hello world</code>内核模块，如下所示:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c4ab" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我们可以用如此简单的方式编写一个内核模块，因为Linux内核为你创造了奇迹。记住Linux(Unix)的设计哲学:<strong class="kn ir"> <em class="nd">为简单而设计；只在必须</em> </strong>的地方增加复杂度。</p><p id="aa06" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">让我们来考察以下几个值得注意的技术要点:</p><p id="2c16" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">首先，内核模块必须至少有两个函数:一个是“开始”函数，当模块加载到内核中时调用；另一个是“结束”函数，在模块从内核中移除之前调用。在内核2.3.13之前，这两个函数的名字被硬编码为<code class="fe lj lk ll lm b">init_module()</code>和<code class="fe lj lk ll lm b">cleanup_module()</code>。但是在新版本中，通过使用<code class="fe lj lk ll lm b">module_init</code>和<code class="fe lj lk ll lm b">module_exit</code>宏，你可以为一个模块的开始和结束函数取任何你喜欢的名字。宏在<code class="fe lj lk ll lm b">include/linux/module.h</code>和<code class="fe lj lk ll lm b">include/linux/init.h</code>中定义。你可以参考那里的详细信息。</p><p id="157b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">通常，<code class="fe lj lk ll lm b">module_init</code>要么在内核中注册一个处理程序(例如，本文中开发的迷你防火墙)，要么用自己的代码替换一个内核函数(通常是做一些事情然后调用原始函数的代码)。<code class="fe lj lk ll lm b">module_exit</code>函数应该撤销<code class="fe lj lk ll lm b">module_init</code>所做的一切，因此模块可以安全卸载。</p><p id="6ab0" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">其次，<code class="fe lj lk ll lm b">printk</code>函数提供了与<code class="fe lj lk ll lm b">printf</code>相似的行为，它接受<code class="fe lj lk ll lm b">format string</code>作为第一个参数。<code class="fe lj lk ll lm b">printk</code>功能原型如下:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="978e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">printk</code>函数允许调用者指定<code class="fe lj lk ll lm b">log level</code>来指示发送到内核消息日志的消息的类型和重要性。例如，在上面的代码中，日志级别<code class="fe lj lk ll lm b">KERN_INFO</code>是通过添加到格式字符串中来指定的。在C编程中，这种语法被称为<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/String_literal#String_literal_concatenation" rel="noopener ugc nofollow" target="_blank">string literal concatenation</a></code>。(在其他高级编程语言中，字符串串联一般用<code class="fe lj lk ll lm b">+</code>运算符完成)。关于功能<code class="fe lj lk ll lm b">printk</code>和<code class="fe lj lk ll lm b">log level</code>，您可以在<code class="fe lj lk ll lm b">include/linux/kern_levels.h</code>和<code class="fe lj lk ll lm b">include/linux/printk.h</code>中找到更多信息。</p><p id="8594" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">注意:Linux内核模块开发的头文件路径不同于您在应用程序开发中经常使用的路径。不要试图在<em class="nd"> /usr/include/linux </em>中找到头文件，而是请使用下面的路径<em class="nd">/lib/modules/` uname-r `/ build/include/Linux</em>(<code class="fe lj lk ll lm b">uname -r</code>命令返回您的内核版本)。</p><p id="95e0" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">接下来，让我们构建这个hello-world内核模块。</p><h2 id="7e52" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">构建模块</h2><p id="2158" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">构建内核模块的方式与构建用户空间应用程序的方式略有不同。构建内核映像及其模块的高效解决方案是<code class="fe lj lk ll lm b">Kernel Build System(Kbuild)</code>。</p><p id="76e7" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">Kbuild</code>是一个复杂的话题，我不会在这里解释太多细节。简单来说，<code class="fe lj lk ll lm b">Kbuild</code>允许你创建高度定制的内核二进制镜像和模块。从技术上讲，每个子目录都包含一个<code class="fe lj lk ll lm b">Makefile</code>，只编译其目录中的源代码文件。顶层Makefile递归地执行每个子目录的Makefile来生成二进制对象。并且可以通过定义<code class="fe lj lk ll lm b">config files</code>来控制包含哪些子目录。详细可以参考其他<a class="ae ln" href="https://www.linuxjournal.com/content/kbuild-linux-kernel-build-system" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><p id="ad39" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">以下是<code class="fe lj lk ll lm b">hello world</code>模块的生成文件:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ef8e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在读取makefiles或做任何其他事情之前,<code class="fe lj lk ll lm b">make -C dir</code>命令改变到目录dir。将使用<em class="nd">/lib/modules/$(shell uname-r)/build</em>中的顶层Makefile。你可以发现命令<code class="fe lj lk ll lm b">make M=dir modules</code>是用来使所有模块都在指定的目录下。</p><p id="eb3a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">并且在模块级Makefile中，<code class="fe lj lk ll lm b">obj-m</code>语法告诉<code class="fe lj lk ll lm b">kbuild</code>系统从<code class="fe lj lk ll lm b">module_name.c</code>构建<code class="fe lj lk ll lm b">module_name.o</code>，链接后会产生内核模块<code class="fe lj lk ll lm b">module_name.ko</code>。在我们的例子中，模块名是<code class="fe lj lk ll lm b">hello</code>。</p><p id="400b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">构建过程如下:</p><pre class="mu mv mw mx gt ne lm nf ng aw nh bi"><span id="3c15" class="mh jo iq lm b gy ni nj l nk nl">chrisbao:~$ sudo make<br/>make -C /lib/modules/4.15.0-176-generic/build M=/home/DIR/jbao6/develop/kernel/hello-1  modules<br/>make[1]: Entering directory '/usr/src/linux-headers-4.15.0-176-generic'<br/>  CC [M]  /home/DIR/jbao6/develop/kernel/hello-1/hello.o<br/>  Building modules, stage 2.<br/>  MODPOST 1 modules<br/>  CC      /home/DIR/jbao6/develop/kernel/hello-1/hello.mod.o<br/>  LD [M]  /home/DIR/jbao6/develop/kernel/hello-1/hello.ko<br/>make[1]: Leaving directory '/usr/src/linux-headers-4.15.0-176-generic'</span></pre><p id="ba48" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">构建完成后，您可以在同一个目录中获得几个新文件:</p><pre class="mu mv mw mx gt ne lm nf ng aw nh bi"><span id="a585" class="mh jo iq lm b gy ni nj l nk nl">chrisbao:~$ ls<br/>hello.c  hello.ko  hello.mod.c  hello.mod.o  hello.o  Makefile  modules.order  Module.symvers</span></pre><p id="0662" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">以<code class="fe lj lk ll lm b">.ko</code>结尾的文件是内核模块。你现在可以忽略其他文件，我稍后会写另一篇文章来深入讨论内核模块系统。</p><h2 id="545e" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">加载模块</h2><p id="6f5e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用<code class="fe lj lk ll lm b">file</code>命令，您可以注意到内核模块是一个<code class="fe lj lk ll lm b">ELF(Executable and Linkable Format)</code>格式的文件。ELF文件通常是编译器或链接器的输出，并且是二进制格式。</p><pre class="mu mv mw mx gt ne lm nf ng aw nh bi"><span id="b61e" class="mh jo iq lm b gy ni nj l nk nl">chrisba:~$ file hello.ko<br/>hello.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=f0da99c757751e7e9f9c4e55f527fb034a0a4253, not stripped</span></pre><p id="7993" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">下一步，让我们尝试动态安装和移除模块。您需要知道以下三个命令:</p><ul class=""><li id="9237" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated"><em class="nd"> lsmod </em>:显示当前加载的内核模块列表。</li><li id="23be" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><em class="nd"> insmod </em>:通过运行<code class="fe lj lk ll lm b">sudo insmod module_name.ko</code>将模块插入Linux内核</li><li id="0b71" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><em class="nd"> rmmod </em>:通过运行<code class="fe lj lk ll lm b">sudo rmmod module_name</code>从Linux内核中删除一个模块</li></ul><p id="9b21" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">由于<code class="fe lj lk ll lm b">hello world</code>模块非常简单，您可以根据自己的意愿轻松安装和移除该模块。我不会在这里显示详细的命令，留给读者。</p><p id="8a7c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">注意</strong>:这并不意味着你可以毫无问题地轻松安装和移除任何内核模块。如果你加载的模块有错误，整个系统会崩溃。</p><h2 id="aae6" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">调试模块</h2><p id="b9ba" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下一步，让我们证明<code class="fe lj lk ll lm b">hello world</code>模块是按预期安装和移除的。我们将使用<code class="fe lj lk ll lm b">dmesg</code>命令。<code class="fe lj lk ll lm b">dmesg</code>(诊断信息)可以打印<code class="fe lj lk ll lm b">kernel ring buffer</code>中的信息。</p><p id="3658" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">首先，<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/Circular_buffer" rel="noopener ugc nofollow" target="_blank">ring buffer</a></code>是一种数据结构，它使用单个固定大小的缓冲区，就好像它是端到端连接的一样。<code class="fe lj lk ll lm b">kernel ring buffer</code>是一个环形缓冲区，记录与内核操作相关的消息。正如我们上面提到的，由<code class="fe lj lk ll lm b">printk</code>函数打印的内核日志将被发送到内核环形缓冲区。</p><p id="8c48" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我们可以通过命令<code class="fe lj lk ll lm b">dmesg | grep world</code>找到模块产生的消息，如下所示:</p><pre class="mu mv mw mx gt ne lm nf ng aw nh bi"><span id="a846" class="mh jo iq lm b gy ni nj l nk nl">chrisbao:~$ dmesg | grep world<br/><br/>[2147137.177254] Hello, world<br/>[3281962.445169] Goodbye, world<br/>[3282008.037591] Hello, world<br/>[3282054.921824] Goodbye, world</span></pre><p id="b135" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在你可以看到<code class="fe lj lk ll lm b">hello world</code>被正确地加载到内核中。并且它也可以被动态移除。太好了。</p><p id="0160" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">基于对内核模块的理解，让我们继续写一个<code class="fe lj lk ll lm b">Netfilter</code>模块作为我们的迷你防火墙。</p><h1 id="979b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Netfilter架构。</h1><h2 id="be2d" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">Netfilter挂钩的基础知识</h2><p id="3c06" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir"/><code class="fe lj lk ll lm b"><strong class="kn ir">Netfilter</strong></code><strong class="kn ir">框架提供了一堆Linux内核中的</strong> <code class="fe lj lk ll lm b"><strong class="kn ir">hooks</strong></code> <strong class="kn ir">。当网络数据包通过内核中的协议栈时，它们也会穿过这些钩子</strong>。Netfilter允许你用这些钩子写模块和注册回调函数。当钩子被触发时，回调函数将被调用。这是Netfilter架构背后的基本思想。不难理解吧？</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/4987641018b85eac9dca5a57e42c7362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4K-8qo1ro6CDNWms.png"/></div></div></figure><p id="f21e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">目前，Netfilter为<code class="fe lj lk ll lm b">IPv4</code>提供了以下5个钩子:</p><ul class=""><li id="b357" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated"><em class="nd"> NF_INET_PRE_ROUTING </em>:网卡收到数据包后立即触发。该挂钩在<code class="fe lj lk ll lm b">routing decision</code>制作前触发。然后，内核确定该数据包的目的地是否是当前主机。根据条件，将触发以下两个挂钩。</li><li id="9bdb" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><em class="nd"> NF_INET_LOCAL_IN </em>:针对发往当前主机的网络数据包触发。</li><li id="0608" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><em class="nd"> NF_INET_FORWARD </em>:针对应该转发的网络数据包触发。</li><li id="3f72" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><em class="nd"> NF_INET_POST_ROUTING </em>:针对已经路由的网络数据包，在发送到网卡之前触发。</li><li id="8536" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><em class="nd"> NF_INET_LOCAL_OUT </em>:由当前主机上的进程产生的网络数据包触发。</li></ul><p id="77b8" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">您在模块中定义的钩子函数可以破坏或过滤数据包，但它最终必须向Netfilter返回一个状态代码。代码有几个可能的值，但是现在，您只需要理解其中的两个:</p><ul class=""><li id="8159" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated"><em class="nd"> NF_ACCEPT </em>:这意味着钩子函数接受数据包，它可以继续网络堆栈之旅。</li><li id="befe" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><em class="nd"> NF_DROP </em>:这意味着数据包被丢弃，不再遍历网络堆栈的其他部分。</li></ul><p id="8ff0" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">Netfilter允许你用不同的优先级注册多个回调函数到同一个钩子。如果第一个钩子函数接受了这个包，那么这个包将被传递给下一个低优先级的函数。如果数据包被一个回调函数丢弃，那么下一个函数(如果存在)将不会被遍历。</p><p id="177b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如你所见，<code class="fe lj lk ll lm b">Netfilter</code>的范围很广，我不可能在文章中涵盖每个细节。所以这里开发的迷你防火墙将在钩子<code class="fe lj lk ll lm b">NF_INET_PRE_ROUTING</code>上工作，这意味着它通过控制入站网络流量来工作。但是注册钩子和处理包的方式可以应用于所有其他钩子。</p><p id="519b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><em class="nd">注</em>:还有一个值得注意的问题:<code class="fe lj lk ll lm b">Netfilter</code>和<code class="fe lj lk ll lm b">eBPF</code>有什么区别？如果你不了解eBPF，请参考我之前的<a class="ae ln" href="https://organicprogrammer.com/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/" rel="noopener ugc nofollow" target="_blank">文章</a>。它们都是Linux内核中重要的网络特性。重要的是<code class="fe lj lk ll lm b">Netfilter</code>和<code class="fe lj lk ll lm b">eBPF</code>钩子位于内核的不同层。正如我在上图中所画的，<code class="fe lj lk ll lm b">eBPF</code>位于较低的一层。</p><h2 id="5574" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">Netfilter钩子的内核代码</h2><p id="1681" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了清楚地了解<code class="fe lj lk ll lm b">Netfilter</code>框架是如何在协议栈内部实现的，让我们再深入一点，看看内核源代码(不要担心，只展示了几个简单的函数)。让我们以钩子<code class="fe lj lk ll lm b">NF_INET_PRE_ROUTING</code>为例；因为迷你防火墙将基于它来编写。</p><p id="b18d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">当接收到IPv4数据包时，其处理函数<code class="fe lj lk ll lm b">ip_rcv</code>将被调用如下:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2654" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在这个处理函数中，你可以看到钩子被传递给了函数<code class="fe lj lk ll lm b">NF_HOOK</code>。根据名字<code class="fe lj lk ll lm b">NF_HOOK</code>，你可以猜测它是用来触发Netfilter钩子的。对吗？让我们继续检查<code class="fe lj lk ll lm b">NF_HOOK</code>是如何实现的，如下所示:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="776c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">功能<code class="fe lj lk ll lm b">NF_HOOK</code>包含两个步骤:</p><ul class=""><li id="2886" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">首先，通过调用底层函数<code class="fe lj lk ll lm b">nf_hook</code>运行钩子的回调函数。</li><li id="eeb7" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">第二，调用函数<code class="fe lj lk ll lm b">okfn</code>(作为参数传递给<em class="nd"> NF_HOOK </em>)，如果数据包通过钩子函数并且没有丢失。</li></ul><p id="0e66" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">对于钩子<em class="nd"> NF_INET_LOCAL_IN </em>，函数<code class="fe lj lk ll lm b">ip_rcv_finish</code>将在钩子函数通过后被调用。它的工作是将数据包传递给协议栈中的下一个协议处理器(TCP或UDP)继续它的旅程！</p><p id="29c7" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">其他4个钩子都使用相同的函数<code class="fe lj lk ll lm b">NF_HOOK</code>来触发回调函数。下表显示了钩子嵌入内核的位置，我将它们留给读者。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nr"><img src="../Images/94d47ebf0e290e4042a864fc291d6418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bEjInWInIPJzQ9X8i0M-Jg.png"/></div></div></figure><p id="79c2" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">接下来，让我们回顾一下创建和注册钩子函数的Netfilter API。</p><h1 id="b163" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Netfilter API</h1><p id="4329" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">创建Netfilter模块很简单，包括三个步骤:</p><ul class=""><li id="0bba" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">定义钩子函数。</li><li id="7cfb" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">在内核模块初始化过程中注册钩子函数。</li><li id="6b3a" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">在内核模块清理过程中注销钩子函数。</li></ul><p id="6498" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">让我们一个一个地快速浏览一下。</p><h2 id="0e29" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">定义一个钩子函数</h2><p id="44dd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">钩子函数名可以是您想要的任何名称，但是它必须遵循下面的签名:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="47b5" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">钩子函数可以破坏或过滤其数据存储在<code class="fe lj lk ll lm b">sk_buff</code>结构中的包(我们可以忽略另外两个参数；因为我们在迷你防火墙中不使用它们)。正如我们上面提到的，回调函数必须返回一个整数形式的Netfilter状态代码。例如，<code class="fe lj lk ll lm b">accepted</code>和<code class="fe lj lk ll lm b">dropped</code>状态定义如下:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="4381" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">注册和注销一个钩子函数</h2><p id="80c0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">注册一个钩子函数，我们要把定义好的钩子函数和相关信息，比如你想绑定到哪个钩子，钩子函数的协议族和优先级，包装成一个结构<code class="fe lj lk ll lm b">struct nf_hook_ops</code>，传递给函数<code class="fe lj lk ll lm b">nf_register_net_hook</code>。</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ebdb" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">大多数字段都非常容易理解。需要强调的是字段<code class="fe lj lk ll lm b">hooknum</code>，它就是上面讨论的Netfilter钩子。它们被定义为枚举器，如下所示:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="29ed" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">接下来，让我们来看看注册和注销钩子函数的函数如下:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9ae2" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">第一个参数<code class="fe lj lk ll lm b">struct net</code>与网络名称空间相关，我们现在可以忽略它，使用默认值。</p><p id="c482" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">接下来，让我们基于这些API实现我们的迷你防火墙。好吗？</p><h1 id="53d3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">实施小型防火墙</h1><p id="8be1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，我们需要明确迷你防火墙的要求。我们将在迷你防火墙中实施两个网络流量控制规则，如下所示:</p><ul class=""><li id="2905" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated"><em class="nd">网络协议规则</em>:丢弃<a class="ae ln" href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol" rel="noopener ugc nofollow" target="_blank"> ICMP </a>协议数据包。</li><li id="91cd" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><em class="nd"> IP地址规则</em>:丢弃来自一个特定IP地址的数据包。</li></ul><p id="4978" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">完整的代码实现在这个Github <a class="ae ln" href="https://github.com/baoqger/linux-mini-firewall-netfilter/blob/main/mini_firewall.c" rel="noopener ugc nofollow" target="_blank"> repo </a>中。</p><h2 id="a856" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">丢弃ICMP协议数据包</h2><p id="9eb3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lj lk ll lm b">ICMP</code>是现实世界中广泛使用的网络协议。像<code class="fe lj lk ll lm b">ping</code>和<code class="fe lj lk ll lm b">traceroute</code>这样的流行诊断工具运行ICMP协议。我们可以使用下面的钩子函数根据IP报头中的协议类型过滤出ICMP数据包:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="8cf9" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">上面钩子函数中的逻辑很容易理解。首先，我们从网络数据包中检索IP报头。然后根据报头中的<code class="fe lj lk ll lm b">protocol</code>类型字段，我们决定接受TCP和UDP数据包，但丢弃ICMP数据包。我们唯一需要注意的技术是函数<code class="fe lj lk ll lm b">ip_hdr</code>，它是定义如下的内核函数:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="981e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">函数<code class="fe lj lk ll lm b">ip_hdr</code>将任务委托给函数<code class="fe lj lk ll lm b">skb_network_header</code>。它根据以下两个数据获取IP报头:</p><ul class=""><li id="1026" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">head:是指向数据包的指针；</li><li id="ba24" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">network_header:是指向数据包的指针和指向网络层协议头的指针之间的偏移量。详细可以参考这个<a class="ae ln" href="https://linux-kernel-labs.github.io/refs/heads/master/labs/networking.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</li></ul><p id="99f4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">接下来，我们可以注册上面的钩子函数如下:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3bd3" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">以上逻辑不言自明。我不会在这里花太多时间。</p><p id="55ea" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">接下来，是时候演示我们的迷你防火墙如何工作了。</p><h2 id="d54b" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">演示时间</h2><p id="bb41" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们加载迷你防火墙模块之前，<code class="fe lj lk ll lm b">ping</code>命令可以正常工作:</p><pre class="mu mv mw mx gt ne lm nf ng aw nh bi"><span id="9289" class="mh jo iq lm b gy ni nj l nk nl">chrisbao@CN0005DOU18129:~$ lsmod | grep mini_firewall<br/>chrisbao@CN0005DOU18129:~$ ping www.google.com<br/>PING www.google.com (142.250.4.103) 56(84) bytes of data.<br/>64 bytes from sm-in-f103.1e100.net (142.250.4.103): icmp_seq=1 ttl=104 time=71.9 ms<br/>64 bytes from sm-in-f103.1e100.net (142.250.4.103): icmp_seq=2 ttl=104 time=71.8 ms<br/>64 bytes from sm-in-f103.1e100.net (142.250.4.103): icmp_seq=3 ttl=104 time=71.9 ms<br/>64 bytes from sm-in-f103.1e100.net (142.250.4.103): icmp_seq=4 ttl=104 time=71.8 ms<br/>^C<br/>--- www.google.com ping statistics ---<br/>4 packets transmitted, 4 received, 0% packet loss, time 3005ms<br/>rtt min/avg/max/mdev = 71.857/71.902/71.961/0.193 ms</span></pre><p id="f032" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">相反，在迷你防火墙模块构建和加载之后(基于我们之前讨论的命令):</p><pre class="mu mv mw mx gt ne lm nf ng aw nh bi"><span id="0149" class="mh jo iq lm b gy ni nj l nk nl">chrisbao@CN0005DOU18129:~$ lsmod | grep mini_firewall<br/>mini_firewall          16384  0<br/>chrisbao@CN0005DOU18129:~$ ping www.google.com<br/>PING www.google.com (142.250.4.105) 56(84) bytes of data.<br/>^C<br/>--- www.google.com ping statistics ---<br/>6 packets transmitted, 0 received, 100% packet loss, time 5097ms</span></pre><p id="51f3" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">你可以看到所有的数据包都丢失了；因为它被我们的迷你防火墙丢弃了。我们可以通过运行命令<code class="fe lj lk ll lm b">dmesg</code>来验证这一点:</p><pre class="mu mv mw mx gt ne lm nf ng aw nh bi"><span id="a7dc" class="mh jo iq lm b gy ni nj l nk nl">chrisbao@CN0005DOU18129:~$ dmesg | tail -n 5<br/>[ 1260.184712] Drop ICMP packet<br/>[ 1261.208637] Drop ICMP packet<br/>[ 1262.232669] Drop ICMP packet<br/>[ 1263.256757] Drop ICMP packet<br/>[ 1264.280733] Drop ICMP packet</span></pre><p id="00c9" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">但是其他协议数据包仍然可以通过防火墙。例如，命令<code class="fe lj lk ll lm b">wget 142.250.4.103</code>可以正常返回如下:</p><pre class="mu mv mw mx gt ne lm nf ng aw nh bi"><span id="f52e" class="mh jo iq lm b gy ni nj l nk nl">chrisbao@CN0005DOU18129:~$ wget 142.250.4.103<br/>--2022-06-25 10:12:39--  http://142.250.4.103/<br/>Connecting to 142.250.4.103:80... connected.<br/>HTTP request sent, awaiting response... 302 Moved Temporarily<br/>Location: http://142.250.4.103:6080/php/urlblock.php?args=AAAAfQAAABAjFEC0HSM7xhfO~a53FMMaAAAAEILI_eaKvZQ2xBfgKEgDtwsAAABNAAAATRPNhqoqFgHJ0ggbKLKcdinR4UvnlhgAR4~YyrY4tAnroOFkE_IsHsOg9~RFPc7nEoj6YdiDgqZImAmb_xw9ZuFLvF91P2HzP5tlu1WX&amp;url=http://142.250.4.103%2f [following]<br/>--2022-06-25 10:12:39--  http://142.250.4.103:6080/php/urlblock.php?args=AAAAfQAAABAjFEC0HSM7xhfO~a53FMMaAAAAEILI_eaKvZQ2xBfgKEgDtwsAAABNAAAATRPNhqoqFgHJ0ggbKLKcdinR4UvnlhgAR4~YyrY4tAnroOFkE_IsHsOg9~RFPc7nEoj6YdiDgqZImAmb_xw9ZuFLvF91P2HzP5tlu1WX&amp;url=http://142.250.4.103%2f<br/>Connecting to 142.250.4.103:6080... connected.<br/>HTTP request sent, awaiting response... 200 OK<br/>Length: 3248 (3.2K) [text/html]<br/>Saving to: ‘index.html’<br/><br/>index.html                                           100%[===================================================================================================================&gt;]   3.17K  --.-KB/s    in 0s<br/><br/>2022-06-25 10:12:39 (332 MB/s) - ‘index.html’ saved [3248/3248]</span></pre><p id="a0b1" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">接下来，让我们尝试禁止来自该IP地址的流量。</p><h2 id="aba2" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">丢弃来自一个特定IP地址的数据包</h2><p id="62d6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如我们上面提到的，允许在同一个Netfilter钩子上注册多个回调函数。所以我们将用不同的优先级定义第二个钩子函数。这个钩子函数的逻辑是这样的:我们可以从IP头中获得源IP地址，并根据它做出丢弃或接受的决定。代码如下所示:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0124" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这个钩子函数使用了两种有趣的技术:</p><ul class=""><li id="a47c" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated"><code class="fe lj lk ll lm b">ntohl</code>:内核函数，用于将值从<code class="fe lj lk ll lm b">network byte order</code>转换为<code class="fe lj lk ll lm b">host byte order</code>。<code class="fe lj lk ll lm b">Byte order</code>与<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/Endianness" rel="noopener ugc nofollow" target="_blank">Endianness</a></code>的计算机科学概念有关。字节序定义了计算机内存中数字数据字的字节顺序。<code class="fe lj lk ll lm b">big-endian</code>系统将一个字的最高有效字节存储在最小的内存地址中。相反，<code class="fe lj lk ll lm b">little-endian</code>系统将最低有效字节存储在最小的地址。网络协议采用<code class="fe lj lk ll lm b">big-endian</code>系统。但是不同操作系统和平台运行不同的字符顺序系统。所以它可能需要基于主机的这种转换。</li><li id="6304" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><code class="fe lj lk ll lm b">IPADDRESS</code>:是一个宏，从一个32位整数生成标准的IP地址格式(4个8位字段，用句点分隔)。它使用了<code class="fe lj lk ll lm b"><a class="ae ln" href="https://www.eskimo.com/~scs/cclass/notes/sx10e.html" rel="noopener ugc nofollow" target="_blank">the equivalence of arrays and pointers in C</a></code>的技术。我将写另一篇文章来研究它是什么以及它是如何工作的。请继续关注我的更新！</li></ul><p id="e7fc" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">接下来，我们可以用上面讨论的相同方式注册这个钩子函数。唯一值得注意的一点是这个回调函数应该有不同的优先级，如下所示:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0649" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">让我们通过演示来看看它是如何工作的。</p><h2 id="1fc3" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">演示时间</h2><p id="c1b0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在重新构建和重新加载模块后，我们可以得到:</p><pre class="mu mv mw mx gt ne lm nf ng aw nh bi"><span id="c191" class="mh jo iq lm b gy ni nj l nk nl">chrisbao@CN0005DOU18129:~$ wget 142.250.4.103<br/>--2022-06-25 10:20:07--  http://142.250.4.103/<br/>Connecting to 142.250.4.103:80... failed: Connection timed out.<br/>Retrying.</span></pre><p id="a2f6" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">wget 142.250.4.103</code>无法返回响应。因为它被我们的迷你防火墙丢弃了。太好了！</p><pre class="mu mv mw mx gt ne lm nf ng aw nh bi"><span id="d01c" class="mh jo iq lm b gy ni nj l nk nl">chrisbao@CN0005DOU18129:~$ dmesg | tail -n 5<br/>[ 3162.064284] Drop packet from 142.250.4.103<br/>[ 3166.089466] Drop packet from 142.250.4.103<br/>[ 3166.288603] Drop packet from 142.250.4.103<br/>[ 3174.345463] Drop packet from 142.250.4.103<br/>[ 3174.480123] Drop packet from 142.250.4.103</span></pre><h1 id="6f79" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">更多扩展空间</h1><p id="238b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你可以在这里找到完整的代码实现<a class="ae ln" href="https://github.com/baoqger/linux-mini-firewall-netfilter/blob/main/mini_firewall.c" rel="noopener ugc nofollow" target="_blank"/>。但是我不得不说，我们的迷你防火墙仅仅触及了Netfilter所能提供的表面。您可以继续扩展功能。例如，目前规则是硬编码的，为什么不可以动态地配置规则呢？有很多很酷的想法值得一试。我把它留给读者。</p><h1 id="5a69" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="14c2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我们一步一步地实现了迷你防火墙，并研究了许多详细的技术。不仅仅是代码；但是我们也通过运行真实的演示来验证迷你防火墙的行为。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="d6c2" class="jn jo iq bd jp jq nz js jt ju oa jw jx jy ob ka kb kc oc ke kf kg od ki kj kk bi translated">分级编码</h1><p id="b80e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae ln" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>。<br/>跟随:<a class="ae ln" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae ln" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae ln" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="kn ir">升一级正在改造理工大招聘➡️ </strong> <a class="ae ln" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>