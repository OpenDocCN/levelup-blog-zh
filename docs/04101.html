<html>
<head>
<title>Pagination with ElasticSearch using NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NodeJS的ElasticSearch分页</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pagination-with-elasticsearch-using-node-js-3fd6c5d2adb1?source=collection_archive---------3-----------------------#2020-06-09">https://levelup.gitconnected.com/pagination-with-elasticsearch-using-node-js-3fd6c5d2adb1?source=collection_archive---------3-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi jx"><img src="../Images/eed483ce289b05bb9df30577bab3043f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*563tBjMv1FD12DfxRYyOWA.png"/></div></div></figure><p id="ddab" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">嘿，伙计们，今天我要谈谈我在后端使用Elasticsearch分页的策略。</p><p id="931f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><em class="lh">原因:</em></p><p id="46ad" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我被分配了一项任务，开发一个包含500多种产品的页面，在这些页面上，除了许多产品图像之外，还会有许多产品数据，甚至一个产品可以包含不止一个图像。</p><p id="d37e" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在这个应用程序中，我们使用的是Elasticsearch，所以最初我想看看一个页面加载所有产品而不分页会是什么样子。</p><p id="2fd4" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">举例来说，一个项目可以像这样排序:</p><pre class="jy jz ka kb gt li lj lk ll aw lm bi"><span id="cfcf" class="ln lo it lj b gy lp lq l lr ls">{</span><span id="fd70" class="ln lo it lj b gy lt lq l lr ls">  "id": 123,</span><span id="ddfe" class="ln lo it lj b gy lt lq l lr ls">"image": ["http://...",http://...,http://...],</span><span id="969d" class="ln lo it lj b gy lt lq l lr ls">  "base_produto": "",</span><span id="404e" class="ln lo it lj b gy lt lq l lr ls">  "categoria": "",</span><span id="d940" class="ln lo it lj b gy lt lq l lr ls">  "cor_produto": "",</span><span id="7e69" class="ln lo it lj b gy lt lq l lr ls">  "data_primeira_venda": "2100-12-31",</span><span id="7793" class="ln lo it lj b gy lt lq l lr ls">  "desc_cor_produto": "",</span><span id="ba21" class="ln lo it lj b gy lt lq l lr ls">  "desc_produto": "",</span><span id="4e0f" class="ln lo it lj b gy lt lq l lr ls">  "distribuicao": false,</span><span id="bd71" class="ln lo it lj b gy lt lq l lr ls">  "programacoes": [</span><span id="064b" class="ln lo it lj b gy lt lq l lr ls">    {</span><span id="0051" class="ln lo it lj b gy lt lq l lr ls">      "nome_programacao": "",</span><span id="350f" class="ln lo it lj b gy lt lq l lr ls">      "qtde_entregue": 0,</span><span id="9c4a" class="ln lo it lj b gy lt lq l lr ls">      "qtde_programada": 220</span><span id="3d9c" class="ln lo it lj b gy lt lq l lr ls">    }</span><span id="7cf0" class="ln lo it lj b gy lt lq l lr ls">  ]</span><span id="00af" class="ln lo it lj b gy lt lq l lr ls"><em class="lh"> ...</em></span><span id="37ea" class="ln lo it lj b gy lt lq l lr ls">}</span></pre><p id="de75" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">所以我测试了一下加载全部500个产品的页面，结果如下:</p><figure class="jy jz ka kb gt kc"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">没有分页的网页</figcaption></figure><pre class="jy jz ka kb gt li lj lk ll aw lm bi"><span id="b0d1" class="ln lo it lj b gy lp lq l lr ls">As can be seen, the page is not performing at all and loading takes extremely long, that's because it's very high load to the browser to render 500 hundred items and a lot of Images</span></pre><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi ma"><img src="../Images/0cf2a704b3952ab3b6f709e52b5cc20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqPOwjFa2-ys3BKjXBapjA.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">显示物品数量的网络选项卡</figcaption></figure><p id="c9e7" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">好了，我们看到我们真的需要对这些数据进行分页。</p></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="7802" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">现在，我将展示我的策略，这样我们就可以通过只查看后端来对数据进行分页。</p><p id="eeff" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><strong class="kl iu">这里我们使用NodeJS和express来处理路由。</strong></p><p id="7399" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">弹性搜索已经有了一种处理分页的方法，它叫做<strong class="kl iu">滚动</strong></p><div class="mb mc gp gr md me"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-request-body.html#request-body-search-scroll" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd iu gy z fp mj fr fs mk fu fw is bi translated">请求身体搜索|弹性搜索参考[7.7] |弹性</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">将搜索标准指定为请求正文参数。GET/Twitter/_ search { " query ":{ " term ":{ " user ":" Kim chy " }…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">www.elastic.co</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms kh me"/></div></div></a></div><p id="9946" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">scroll基本上有2个主要参数:<br/> <strong class="kl iu"> scroll </strong> : <em class="lh"> scroll参数告诉Elasticsearch在你花费的时间内保持搜索上下文打开。</em></p><p id="7b66" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><strong class="kl iu"> scroll_id </strong> : <em class="lh">是用于搜索下一页项目的参照。</em></p><p id="5215" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><em class="lh">滚动帖子示例:</em></p><pre class="jy jz ka kb gt li lj lk ll aw lm bi"><span id="c9df" class="ln lo it lj b gy lp lq l lr ls">POST /_search/scroll <br/>{<br/>    "scroll" : "1m", <br/>    "scroll_id" : "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==" <br/>}</span></pre><p id="1210" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">所以，基本上在后端我们创建了一个函数来搜索我们的项目并接收两个参数:<strong class="kl iu"> indexName </strong>和<strong class="kl iu"> query </strong>。</p><p id="d7fe" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><strong class="kl iu">索引名</strong>:<em class="lh">elastic search将搜索的索引名。</em> <br/> <strong class="kl iu">查询</strong> : <em class="lh">我们用来过滤项目等的查询… </em></p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi mt"><img src="../Images/ce1060c302c7f52b49162c6e23cdc260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jreuajJMlOyCugIkHJfCig.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">搜索数据</figcaption></figure><p id="e5cc" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">这个<strong class="kl iu"> searchData </strong>是什么？</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi mu"><img src="../Images/8cfc808092dea5d50e247cf1a4f2dbc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NH2EcDB4oNPtzg-kGeEttw.png"/></div></div></figure><p id="0ee9" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">基本上，它是我们的弹性应用程序的端点。</p><p id="2e0c" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">(<em class="lh">为了更好地研究这个问题，我推荐elastic的正确文档</em>:<a class="ae mv" href="https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html" rel="noopener ugc nofollow" target="_blank">https://www . elastic . co/guide/en/elastic search/client/JavaScript-API/current/index . html</a>)</p></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/833585502462e42ccbd3787decf9d334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*YnA9iH9751o6ElBTAP5b3Q.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">路线<strong class="bd mx">getSingleCollectionProducts</strong></figcaption></figure><p id="3a5e" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">现在，我将向您展示一条路线，从我拥有的500种产品中选择前10种产品。</p><pre class="jy jz ka kb gt li lj lk ll aw lm bi"><span id="72e4" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">async</strong> <strong class="lj iu">getSingleCollectionProducts</strong>(req, res) {</span><span id="c8c8" class="ln lo it lj b gy lt lq l lr ls"><em class="lh"> const</em> <em class="lh">{</em> <em class="lh">collection,</em> <em class="lh">id_marca_estilo,</em> <em class="lh">next_page </em>} = await req.query;</span><span id="c0e5" class="ln lo it lj b gy lt lq l lr ls"> const payload = {<br/> <strong class="lj iu"> //<em class="lh">HERE</em> <em class="lh">I`M JUST PUTTING TO ONLY RETURNS TO ME<br/>  // 10 ITEMS</em></strong><em class="lh"><br/>  from</em>: 0, <em class="lh">size</em>: 10,<br/> },</span><span id="a935" class="ln lo it lj b gy lt lq l lr ls"> query: {<br/> <strong class="lj iu"> //here will enter your query, you can use your on query<br/>  // on kibana.</strong><br/> },</span><span id="d576" class="ln lo it lj b gy lt lq l lr ls">};</span><span id="a278" class="ln lo it lj b gy lt lq l lr ls">try {                         <strong class="lj iu">//<em class="lh">indexName</em></strong>    <strong class="lj iu">//<em class="lh">Query</em></strong><br/><em class="lh">const</em> <em class="lh">resp</em> <em class="lh">=</em> <em class="lh">await</em> <em class="lh">searchData('produto_cor',</em> <em class="lh">payload);</em>  <br/> <strong class="lj iu">//<em class="lh">RETURNS</em> <em class="lh">TO</em> <em class="lh">ME</em> <em class="lh">AN</em> <em class="lh">ARRAY</em> <em class="lh">OF</em> <em class="lh">DATA</em> <em class="lh">FROM</em> <em class="lh">0</em> <em class="lh">TO</em> <em class="lh">10</em></strong></span><span id="5ffa" class="ln lo it lj b gy lt lq l lr ls"><em class="lh"> const</em> <em class="lh">produtos</em> <em class="lh">=</em> <em class="lh">[]; </em><strong class="lj iu"><em class="lh">// just creating an more useful array of datas</em></strong><em class="lh"><br/> await</em> <em class="lh">resp.body.hits.hits.map(products</em> <em class="lh">=&gt;</em> <em class="lh">{<br/>  produtos.push({<br/>   id</em>: <em class="lh">products._id</em>,<br/>   <em class="lh">data</em>: <em class="lh">products._source</em>,<br/> });<br/>});</span><span id="e88e" class="ln lo it lj b gy lt lq l lr ls"> const <strong class="lj iu">pro</strong> = {};<br/> // because i used the parameter <strong class="lj iu">scroll</strong> on my <strong class="lj iu">searchData function</strong>,<br/> // I have the <strong class="lj iu">scroll_id</strong> value</span><span id="3443" class="ln lo it lj b gy lt lq l lr ls"> pro.next_page = resp.body._scroll_id; <br/> <strong class="lj iu">// I create a value on my object that has the value from the next <br/> // page</strong><br/> <br/> pro.data = produtos;</span><span id="ae1d" class="ln lo it lj b gy lt lq l lr ls"> return res.status(200).send(<strong class="lj iu">pro</strong>); // return the value </span><span id="0438" class="ln lo it lj b gy lt lq l lr ls">} catch (err) {<br/><em class="lh">  console.log('Error</em> <em class="lh">getting</em> <em class="lh">products</em> <em class="lh">from</em> <em class="lh">a</em> <em class="lh">single</em> <em class="lh">collection',</em>     <em class="lh">err);</em></span><span id="7cfe" class="ln lo it lj b gy lt lq l lr ls"><em class="lh">  return</em> <em class="lh">res.status(500).send(err);<br/>  </em>}<br/>}</span></pre><p id="3917" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">当我们到达这条路线时，最终结果将是:</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi my"><img src="../Images/370085e189e80c37a21fc6a38e34a612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCDEu6eD_epaUgXlKabikA.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">10项，现在我们有了scroll_id</figcaption></figure><p id="d6bb" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated"><strong class="kl iu">注意，我们的<em class="lh"> scroll_id </em>现在叫做<em class="lh"> next_page。</em> </strong></p><p id="a2af" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">现在页面速度非常快，因为我们只加载前10项。</p><figure class="jy jz ka kb gt kc"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">仅呈现10个项目的页面</figcaption></figure><p id="cf3f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">我们现在的目标是加载下一个项目。我们现在有了被我<strong class="kl iu"/><strong class="kl iu"/>称为next_page的<strong class="kl iu"> scroll_id </strong>，它拥有我们想要呈现的下一页项目的id。</p><p id="145f" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">现在这是最简单的部分，我们只需要再创建一个包含<strong class="kl iu"> scroll_id </strong>作为参数的路径，Elasticsearch将负责返回我们下一个数据和一个包含页面上下一个项目的新scroll_id。</p><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi mz"><img src="../Images/600760825a8280462e0fcb3194553807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QL-qiIsgNcobjdK5FZpyVw.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">下一页的路线</figcaption></figure><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi na"><img src="../Images/865b45ab79749e5b201813e575fb2e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-owQ3XHXWltlRsbcUNhhuQ.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">项目的下一页</figcaption></figure><p id="ca71" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">实际上与之前创建的路线相同，唯一的细节是，现在我们不使用searchData，而是创建一个名为scrollData的新函数，它与elastic client(<a class="ae mv" href="https://github.com/elastic/elasticsearch-js" rel="noopener ugc nofollow" target="_blank">https://github.com/elastic/elasticsearch-js</a>)一起提供</p><p id="f5ff" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">(<a class="ae mv" href="https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/scroll_examples.html" rel="noopener ugc nofollow" target="_blank">https://www . elastic . co/guide/en/elastic search/client/JavaScript-API/current/scroll _ examples . html</a>)</p><p id="6616" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">基本上，滚动函数接收两个参数:</p><pre class="jy jz ka kb gt li lj lk ll aw lm bi"><span id="c833" class="ln lo it lj b gy lp lq l lr ls">scroll_id: String(id of the next page containing the next 10 items)<br/>scroll: String(number of times that the id will exist)</span></pre><figure class="jy jz ka kb gt kc gh gi paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="gh gi nb"><img src="../Images/95689e06296d27f64dcb5ef21b61c83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-mLeemtoySaKwa3o8UKmQ.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">scrollData函数</figcaption></figure><p id="e373" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">在改变了前端的一些东西后，使用我创建的路线，我们得到了我们的结果:</p><figure class="jy jz ka kb gt kc"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">使用滚动分页的页面</figcaption></figure><p id="e6cd" class="pw-post-body-paragraph kj kk it kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg im bi translated">ElasticSearch是一个拥有自己世界的神奇工具，一路上可能会出现很多疑惑，但是如果你需要帮助可以找我，希望我帮到你了！</p></div></div>    
</body>
</html>