<html>
<head>
<title>Securely Authorizing Connected Devices using API Tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用API令牌安全授权连接的设备</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/securely-authorizing-connected-devices-using-api-tokens-6e35248baf4e?source=collection_archive---------22-----------------------#2020-08-03">https://levelup.gitconnected.com/securely-authorizing-connected-devices-using-api-tokens-6e35248baf4e?source=collection_archive---------22-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1e18" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用GraphQL、Javascript和无服务器功能为连接的设备设置注册和授权系统。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6946d6f8dd64220f6e54b02addfee905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2htw-7AEmW29XcrO.png"/></div></div></figure><p id="7e4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们在应用程序开发中考虑授权时，通常是从拥有特定角色和权限的用户的角度出发。例如，一个跟踪用户锻炼的健身应用程序可能允许一个<em class="lq">运动员</em>(用户角色)创建日志条目，并且只从API中读取他们自己的日志条目。大多数以用户为中心和数据驱动的应用程序最终会考虑和定义这些类型的场景；<em class="lq">谁</em>能做<em class="lq">什么</em>？</p><p id="2f13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也就是说，并不是所有的应用程序都以单独登录的用户为中心。给定应用程序的授权需要在设备环境中处理，这种情况并不少见。想想物联网(IoT)设备、虚拟现实耳机、登记亭以及其他设备本身(或安装的应用程序)是经过身份验证的实体。</p><p id="0bfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有时，这种类型的授权纯粹用于安全的机器对机器应用，例如工厂监控设备，其中传感器将设备数据发送到中央监控系统。其他时候，单个设备被授权，以便多个用户可以在给定时间访问它，就像事件注册亭一样。不管具体的用例是什么，我们都需要一个可靠的系统来认证设备，生成API令牌，为这些令牌分配必要的授权，并将凭证返回给设备。</p><h1 id="ed8e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">辅导的</h1><p id="1231" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在本教程中，我们将制定一个注册设备的策略。这个系统可以为许多不同的用例工作，所以如果您需要帮助来使它更适合您自己的应用程序，请大胆地提出问题。此外，下面的视频是教程的一步一步走。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">在8base中使用API令牌和授权管理连接的设备</figcaption></figure><p id="936b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">技术:</strong></p><ol class=""><li id="ae1f" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><em class="lq">8基本工作空间</em> —使用GraphQL API的后端即服务</li><li id="d1a4" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated"><em class="lq"> Node.js </em> —在web浏览器外执行JavaScript代码的JavaScript运行时环境</li></ol><h1 id="7f9f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">步骤1 —设置“设备”</h1><p id="3794" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们将编写几个可以从命令行手动执行的简单脚本。一个将允许我们注册设备并接收一个令牌，另一个将发出向API发送数据和从API读取数据的认证请求。在这个场景中，把<em class="lq">设备</em>想象成你的电脑。</p><p id="e683" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">克隆这个项目，这样当我们引用正在发生的事情时，您可以浏览每个脚本。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8b00" class="nn ls it nj b gy no np l nq nr"># Clone the repo<br/>git clone <a class="ae ns" href="https://github.com/8base/managing-devices-using-api-tokens.git" rel="noopener ugc nofollow" target="_blank">https://github.com/8base/managing-devices-using-api-tokens.git</a> eighbase-device-tokens-tutorial</span><span id="b1e7" class="nn ls it nj b gy nt np l nq nr"># Move into the directory<br/>cd eighbase-device-tokens-tutorial</span></pre><p id="5efc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了对我们正在处理的事情有一个大致的了解，下面是<em class="lq">设备</em>回购结构。可以使用命令<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">npm run exec [FUNCTION_NAME] [ARG]</em></strong></code>运行设备/src/功能目录中的每个功能。同时，<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">device/src/utils/api.js</em></strong></code>是我们执行GraphQL请求的API模块，<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">device/src/storage/index.js</em></strong></code>只是将JSON数据写入本地文件。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2e48" class="nn ls it nj b gy no np l nq nr">device/<br/> ├── package-lock.json<br/> ├── package.json<br/> └── src<br/> ├── functions<br/> │ ├── readActivity.js<br/> │ ├── registerDevice.js<br/> │ └── sendActivity.js<br/> ├── index.js<br/> ├── storage<br/> │ ├── data.json<br/> │ └── index.js<br/> └── utils<br/> └── api.js</span></pre><p id="2aad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这三个函数非常简单。<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">registerDevice.js</em></strong></code>脚本是我们用来发送注册码和接收API令牌的脚本，而<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">readActivity.js</em></strong></code>运行查询，<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">sendActivity.js</em></strong></code>运行变异。使用这些，我们将能够测试我们的设备正在工作。</p><p id="ef74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你花点时间浏览这些文件，你会发现它们都有非常相似的结构。每一个都定义一个GraphQL调用，运行它，然后处理响应或错误。如果你想要更多的上下文，所有的代码文件都有行内注释。</p><p id="1a7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码中只有一处需要更新值。在<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">device/src/utils/api.js</em></strong></code>的第12行，用您的工作区端点更新占位符。</p><h1 id="6a6c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">步骤2 —设置后端</h1><p id="9b54" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这里有一些非常有用的功能，我们可以从8base中加以利用。它们是API令牌、角色和权限以及无服务器功能。如果你想花些时间学习如何构建数据模型，这个视频和这个文档是一个很好的起点。然而，对于本教程，我们可以使用8base CLI将所需的模式导入到我们的工作空间中。</p><p id="1659" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您还没有，请继续安装8base CLI工具。我们将使用它来导入我们的模式文件，并向您的8base工作区部署一个无服务器功能，该功能将处理设备的注册。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="b71d" class="nn ls it nj b gy no np l nq nr"># Install the 8base CLI<br/>npm install — global 8base-cli</span><span id="0d92" class="nn ls it nj b gy nt np l nq nr"># Move into the server directory<br/>cd ../server</span><span id="4b00" class="nn ls it nj b gy nt np l nq nr"># Authenticate the 8base CLI<br/>8base login</span><span id="c583" class="nn ls it nj b gy nt np l nq nr"># Configure the project to your workspace (Select your workspace)<br/>8base configure</span><span id="24d8" class="nn ls it nj b gy nt np l nq nr"># Import the schema to your workspace<br/>8base import -f schema.json</span></pre><p id="219e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦导入完成，进入<a class="ae ns" href="https://app.8base.com/" rel="noopener ugc nofollow" target="_blank">8 base工作区控制台</a>。在<em class="lq">数据构建器</em>中，您应该看到已经创建的3个表格。下面是他们的列表以及他们的关系。‍</p><p id="9447" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="lq">注册码</em> </strong> —设备将用于注册的代码。</p><ul class=""><li id="dc14" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp nx na nb nc bi translated"><em class="lq">有一个</em>装置</li></ul><p id="57f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="lq">设备</em> </strong> —为单个注册设备创建的记录。</p><ul class=""><li id="1c79" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp nx na nb nc bi translated"><em class="lq">有一个</em>注册码<em class="lq"> ‍ </em></li><li id="6e1c" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp nx na nb nc bi translated"><em class="lq">有_many个</em>数据条目</li></ul><p id="6fbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="lq">数据条目</em> </strong> —我们将用来保存设备数据并回读的记录。<em class="lq"> ‍ </em></p><ul class=""><li id="d1b8" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp nx na nb nc bi translated"><em class="lq">有_个</em>装置</li></ul><p id="e80e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">8base控制台中的‍Data生成器，用于设置api令牌教程表</p><h1 id="8dac" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">步骤2.1 —定义角色和权限</h1><p id="bcf6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们需要采取的下一步是定义设备将拥有的<em class="lq">角色</em>及其相关权限。</p><p id="a25d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">导航到<a class="ae ns" href="https://app.8base.com/app-services/roles" rel="noopener ugc nofollow" target="_blank"> <em class="lq">应用服务&gt;角色</em> </a>，点击“+”按钮添加角色。将它命名为“设备”,如果你喜欢的话，可以随意添加一段描述。创建后，单击角色进入权限视图。</p><p id="364c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于任何给定的项目/实现，角色和权限都是极其特定的。也就是说，为了成功运行它的脚本，我们的设备需要一些权限。首先，请确保所有权限都已关闭。</p><p id="68aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了确保任何已注册的设备只能访问与其自身相关的记录，我们将使用自定义过滤器，这些过滤器使用API令牌来授权请求以确定记录的范围。</p><p id="4533" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">数据条目</strong></p><ul class=""><li id="e176" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp nx na nb nc bi translated"><em class="lq">创建</em>(勾选)</li><li id="0c1f" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp nx na nb nc bi translated"><em class="lq">改为</em>(自定义过滤器)<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">{ “device”: { “apiToken”: { “token”: { “equals”: “__requestingApiToken” } } } }</em></strong></code></li></ul><p id="3f1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">装置</strong></p><ul class=""><li id="8bd2" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp nx na nb nc bi translated"><em class="lq">阅读</em>(自定义滤镜)<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">{ “apiToken”: { “token”: { “equals”: “__requestingApiToken” } } }</em></strong></code></li><li id="299d" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp nx na nb nc bi translated"><em class="lq">更新</em>(自定义滤镜)<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">{ “apiToken”: { “token”: { “equals”: “__requestingApiToken” } } }</em></strong></code></li></ul><p id="d63d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个经过身份验证的API请求进来时，8base会用API令牌替换掉<code class="fe nu nv nw nj b">__requestingApiToken</code>变量。这允许您在权限的自定义筛选器中使用API令牌作为动态变量，根据给定的角色来确定数据的范围。</p><p id="89ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在8base控制台中为设备角色设置角色和权限</p><h1 id="1684" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">2.2部署我们的无服务器功能</h1><p id="7677" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">虽然8base提供了完全托管的应用后端，但我们能够扩展API，并使用无服务器功能部署/执行服务器端逻辑。在这种情况下，我们将添加一个名为<code class="fe nu nv nw nj b"><em class="lq">registerDevice</em></code>的函数，它将处理API令牌和注册码的验证、创建、分配和发布。</p><p id="734b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">返回到您克隆的项目的服务器目录。下面是在<code class="fe nu nv nw nj b"><strong class="kw iu"><em class="lq">server/src/resolvers/registerDevice/*</em></strong></code> <em class="lq">找到的带有内联注释的代码。</em>在将它部署到工作区之前，让我们浏览一下注释。</p><p id="f51b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">‍</p><p id="d554" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> schema.graphql </strong></p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0a7b" class="nn ls it nj b gy no np l nq nr"># Returns device ID and apiToken<br/>type RegisterDeviceResult {<br/> id: String!<br/> apiToken: String!<br/>}</span><span id="e831" class="nn ls it nj b gy nt np l nq nr"># Mutation accepts registration code as argument<br/>extend type Mutation {<br/> registerDevice(code: String!): RegisterDeviceResult<br/>}‍</span></pre><p id="a5bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> handler.js </strong></p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="d0dc" class="nn ls it nj b gy no np l nq nr">import gql from "graphql-tag";</span><span id="e15f" class="nn ls it nj b gy nt np l nq nr">/* Disable permissions when making server-side API calls */<br/>const NoCheck = {<br/>  checkPermissions: false,<br/>};</span><span id="0c79" class="nn ls it nj b gy nt np l nq nr">/**<br/> * Query for the registration code.<br/> */<br/>const REGISTRATION_CODE_QUERY = gql`<br/>  query($code: String!) {<br/>    registrationCode(code: $code) {<br/>      id<br/>      code<br/>      device {<br/>        id<br/>      }<br/>    }<br/>  }<br/>`;</span><span id="e03e" class="nn ls it nj b gy nt np l nq nr">/**<br/> * Create the API Token Mutation. When creating the api token<br/> * we also go ahead and connect our Device role to it.<br/> */<br/>const CREATE_API_TOKEN_MUTATION = gql`<br/>  mutation($name: String!) {<br/>    apiTokenCreate(<br/>      data: { name: $name, roles: { connect: { name: "Device" } } }<br/>    ) {<br/>      id<br/>      token<br/>    }<br/>  }<br/>`;</span><span id="bfed" class="nn ls it nj b gy nt np l nq nr">/**<br/> * Create the device Device and connect it with the<br/> * token and registration code.<br/> */<br/>const CREATE_DEVICE_MUTATION = gql`<br/>  mutation($tokenId: ID!, $codeId: ID!, $name: String!) {<br/>    deviceCreate(<br/>      data: {<br/>        name: $name<br/>        apiToken: { connect: { id: $tokenId } }<br/>        registrationCode: { connect: { id: $codeId } }<br/>      }<br/>    ) {<br/>      id<br/>      createdAt<br/>    }<br/>  }<br/>`;</span><span id="ad7e" class="nn ls it nj b gy nt np l nq nr">export default async (event, ctx) =&gt; {<br/>  /* Get registration code from mutation args */<br/>  const { code } = event.data;</span><span id="337f" class="nn ls it nj b gy nt np l nq nr">  /* Query the code to see if it actually exists */<br/>  const { registrationCode } = await ctx.api.gqlRequest(<br/>    REGISTRATION_CODE_QUERY,<br/>    { code },<br/>    NoCheck<br/>  );</span><span id="8d38" class="nn ls it nj b gy nt np l nq nr">  /* Variables */<br/>  let tokenId = "";<br/>  let apiToken = "";</span><span id="f829" class="nn ls it nj b gy nt np l nq nr">  /* If no code is found, return not found error */<br/>  if (!registrationCode) {<br/>    return {<br/>      data: {<br/>        apiToken,<br/>      },<br/>      errors: [<br/>        {<br/>          message: "The submitted registration code was not found.",<br/>          code: "code_not_found",<br/>        },<br/>      ],<br/>    };<br/>    /* If code is already assigned to device, return code assigned error */<br/>  } else if (registrationCode.device) {<br/>    return {<br/>      data: {<br/>        apiToken,<br/>      },<br/>      errors: [<br/>        {<br/>          message: "The submitted registration code was already used.",<br/>          code: "code_assigned",<br/>        },<br/>      ],<br/>    };<br/>    /* If the code is valid, create a new API Token */<br/>  } else {<br/>    ({<br/>      apiTokenCreate: { id: tokenId, token: apiToken },<br/>    } = await ctx.api.gqlRequest(<br/>      CREATE_API_TOKEN_MUTATION,<br/>      {<br/>        name: `DEVICE_${code}_TOKEN`,<br/>      },<br/>      NoCheck<br/>    ));<br/>  }</span><span id="473f" class="nn ls it nj b gy nt np l nq nr">  /**<br/>   * Create a new device and connect it to<br/>   * the API Token and Registration code.<br/>   */<br/>  const {<br/>    deviceCreate: { createdAt, id },<br/>  } = await ctx.api.gqlRequest(<br/>    CREATE_DEVICE_MUTATION,<br/>    {<br/>      codeId: registrationCode.id,<br/>      name: `DEVICE_${code}`,<br/>      tokenId,<br/>    },<br/>    NoCheck<br/>  );</span><span id="e75e" class="nn ls it nj b gy nt np l nq nr">  /* eslint-disable-next-line no-console */<br/>  console.log(`Token added to device with ID ${id} at ${createdAt}`);</span><span id="f245" class="nn ls it nj b gy nt np l nq nr">  /**<br/>   * Return device id and apiToken in response<br/>   */<br/>  return {<br/>    data: {<br/>      id,<br/>      apiToken,<br/>    },<br/>    errors: [],<br/>  };<br/>};</span></pre><p id="20ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">熟悉了解析器函数之后，让我们来部署它。继续从服务器目录中运行8base deploy。部署完成后，您需要更新角色和权限中的最后一项内容。</p><p id="27d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，<em class="lq"> Guest </em>角色定义了未经身份验证的请求可以访问哪些资源和权限。由于设备在收到API令牌之前需要注册，我们需要确保对我们的<em class="lq"> registerDevice </em>操作有公共访问。‍</p><p id="9a93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<a class="ae ns" href="https://app.8base.com/app-services/roles" rel="noopener ugc nofollow" target="_blank"> <em class="lq">应用服务&gt;角色</em> </a>中，点击<em class="lq">访客</em>角色，进入<em class="lq">应用</em>选项卡。部署该功能后，“注册设备”应该出现在<em class="lq"> Api </em>部分下。确保它已启用！</p><p id="bcf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正在更新8base console‍中来宾角色的角色和权限</p><h1 id="14fb" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">测试设备</h1><p id="ed6e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们继续尝试我们的设备吧！使用命令行返回到设备目录，并安装所有必需的依赖项。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="1058" class="nn ls it nj b gy no np l nq nr"># Change into devices directory<br/>cd ../devices</span><span id="a6e7" class="nn ls it nj b gy nt np l nq nr"># Install dependencies<br/>npm install</span></pre><p id="eb8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们确保我们的API拒绝未经验证的请求。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7c9f" class="nn ls it nj b gy no np l nq nr">npm run exec readActivity<br/>=&gt; [<br/>  {<br/>    message: "You don't have permission to perform this operation",<br/>    locations: [[Object]],<br/>    path: ["dataEntriesList"],<br/>    code: "NotAuthorizedError",<br/>    details: {<br/>      permissions: "You don't have permission to perform this operation",<br/>    },<br/>  },<br/>];</span></pre><p id="b4e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们注册我们的设备。在您的8base工作区中，添加一个新的<em class="lq">注册码</em>，代码设置为“1234567890”。</p><p id="0426" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在数据库viewer‍中创建注册码</p><p id="1d74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">添加后，返回终端并运行以下命令。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2630" class="nn ls it nj b gy no np l nq nr">npm run exec registerDevice 1234567890</span><span id="bb68" class="nn ls it nj b gy nt np l nq nr">=&gt; Adding to storage: {<br/> id: ‘ckd8ykgbu002n08mo4ea59wby’,<br/> apiToken: ‘415029c8-ecac-44bd-bfa4–97fc18388afa’<br/>}</span><span id="a7aa" class="nn ls it nj b gy nt np l nq nr">Device registered</span></pre><p id="ea63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">厉害！设备已注册。如果您想查看服务器端发生了什么变化，请跳回8base控制台的<em class="lq">数据查看器</em>，您将看到所有的关系和设备记录都已创建。此外，将生成一个API令牌，可在<a class="ae ns" href="https://app.8base.com/settings/api-tokens" rel="noopener ugc nofollow" target="_blank"> <em class="lq">设置&gt; API令牌</em> </a>中找到。</p><p id="bab4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们添加一些活动。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="f62e" class="nn ls it nj b gy no np l nq nr">npm run exec sendActivity 100</span><span id="224b" class="nn ls it nj b gy nt np l nq nr">=&gt; Entry 100 saved to device ckd8ykgbu002n08mo4ea59wby</span></pre><p id="036b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，阅读活动。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="3fff" class="nn ls it nj b gy no np l nq nr">npm run exec readActivity</span><span id="b8dd" class="nn ls it nj b gy nt np l nq nr">=&gt; [<br/>  {<br/>    createdAt: "2020–07–30T15:35:47.565Z",<br/>    value: 100,<br/>    __typename: "DataEntry",<br/>  },<br/>];</span></pre><p id="1837" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一切似乎都在工作！</p><h1 id="1ece" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="feb3" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在本教程中，我们实现了一个使用API令牌、GraphQL API、角色和权限以及无服务器功能来认证连接设备的策略。可以对它进行许多增强和改进，比如注册码的截止日期。也就是说，这个总体结构提供了一个很好的起点，你可以从这里继续前进。</p><p id="ee37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您有任何问题，请随时联系我们。这个项目中使用的所有代码都可以在GitHub上的<a class="ae ns" href="https://github.com/8base/managing-devices-using-api-tokens" rel="noopener ugc nofollow" target="_blank">教程的repo </a>中获得。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="df61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">最初发表于</em><a class="ae ns" href="https://www.8base.com/blog/securely-authorizing-connected-devices-using-api-tokens" rel="noopener ugc nofollow" target="_blank">T5【https://www.8base.com】</a><em class="lq">。</em></p></div></div>    
</body>
</html>