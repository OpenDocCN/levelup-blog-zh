<html>
<head>
<title>How to Securely Implement OAuth in Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Vue.js中安全实现OAuth</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-securely-implement-oauth-in-vue-js-57d08724efe1?source=collection_archive---------9-----------------------#2020-08-14">https://levelup.gitconnected.com/how-to-securely-implement-oauth-in-vue-js-57d08724efe1?source=collection_archive---------9-----------------------#2020-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b8e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将讨论在Vue.js应用程序中实现OAuth授权代码授权的逐步过程。我们将使用FusionAuth作为IdP，并向您展示如何配置FusionAuth。</p><p id="01ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，您的应用将能够:</p><ul class=""><li id="38ad" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">让用户登录</li><li id="bff9" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">注销用户</li><li id="4702" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">从FusionAuth读取用户数据</li><li id="1ca3" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">将用户数据写入FusionAuth</li></ul><p id="9f65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用Express作为我们的后端服务器，它将充当我们的Vue客户端和FusionAuth之间的中间件。它将安全地存储访问令牌、客户机id、客户机机密和其他信息。</p><p id="4691" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">先决条件</strong></p><ul class=""><li id="521a" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">Vue知识和表达概念。</li><li id="e4ca" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">Docker(可选，但安装FusionAuth时首选)。</li><li id="88cb" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">本地计算机上的节点(12.x)/NPM。</li><li id="6f5d" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">您选择的任何代码编辑器。</li></ul><p id="e26e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还需要确保您的系统满足FusionAuth的<a class="ae lc" href="https://fusionauth.io/docs/v1/tech/installation-guide/system-requirements" rel="noopener ugc nofollow" target="_blank">内存、存储和CPU要求</a>。</p><p id="f720" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你在任何时候卡住了，可以随时参考完成的app的<a class="ae lc" href="https://github.com/fusionauth/fusionauth-example-vue" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><h1 id="0cc0" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用Docker Compose设置FusionAuth</h1><p id="ab30" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">如果您还没有安装FusionAuth，我们建议您使用Docker Compose选项来实现最快的设置:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="5ce3" class="mp le it ml b gy mq mr l ms mt">curl -o docker-compose.yml https://raw.githubusercontent.com/FusionAuth/fusionauth-containers/master/docker/fusionauth/docker-compose.yml<br/>curl -o .env https://raw.githubusercontent.com/FusionAuth/fusionauth-containers/master/docker/fusionauth/.env<br/>docker-compose up</span></pre><p id="a70d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您没有安装Docker，请查看<a class="ae lc" href="https://fusionauth.io/download" rel="noopener ugc nofollow" target="_blank"> FusionAuth下载页面</a>了解其他安装选项(rpm、deb等)。您也可以遵循<a class="ae lc" href="https://fusionauth.io/docs/v1/tech/installation-guide/fusionauth-app" rel="noopener ugc nofollow" target="_blank"> FusionAuth安装指南</a>了解更多详细步骤。</p><p id="d3f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">FusionAuth运行后(默认地址是<a class="ae lc" href="http://localhost:9011/)," rel="noopener ugc nofollow" target="_blank">http://localhost:9011/),</a>创建一个新的应用程序。本教程使用一个名为<code class="fe mu mv mw ml b">fusionauth-vue-example</code>的应用程序。</p><p id="313a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，配置您的应用程序。对于本教程，您只需要更改两个配置设置。在应用程序的<strong class="js iu"> OAuth </strong>选项卡中:</p><ul class=""><li id="a39d" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">将<code class="fe mu mv mw ml b">Authorized redirect URLs</code>设置为<code class="fe mu mv mw ml b">http://localhost:9000/oauth-callback</code>。这是Express服务器URL，它将在用户登录后处理FusionAuth回调。</li><li id="1c1f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">将<code class="fe mu mv mw ml b">Logout URL</code>设置为<code class="fe mu mv mw ml b">http://localhost:8081</code>。这是FusionAuth服务器在注销后将我们重定向到的URL。这也是Vue应用程序存在的地方。注销后，用户会到达应用程序的主登录页面。</li></ul><p id="4cf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击<strong class="js iu">保存</strong>。</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/cbcbd524c528f50c5ea9e728c7198700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-vbIr2z3Hp-kS73N.png"/></div></div></figure><p id="06b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，将我们的当前用户添加到新应用程序中。在仪表盘上选择<strong class="js iu">用户</strong>，选择<strong class="js iu">管理</strong>，进入<strong class="js iu">注册</strong>选项卡。然后点击<code class="fe mu mv mw ml b">Add Registration</code>，将自己添加到刚刚创建的应用程序中。</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/1b86c9136d2bc9e54a6eb6ab6c75eca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wZOI9QjKhemVe6cG.png"/></div></div></figure><p id="94f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，导航至<strong class="js iu">设置</strong>，然后导航至<strong class="js iu"> API键</strong>。您应该有一个API密匙，但是可以随意创建一个。对于本教程，我们不会限制权限，但是您应该为生产部署进行限制。记录API键值以备后用。</p><p id="5a2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们今天不会讨论这个，但是您可以在FusionAuth中创建多个应用程序并配置多租户。如果您有多个应用程序，并且希望它们的所有用户数据都存储在FusionAuth中，这将非常有用。</p><p id="04aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在您已经完成了FusionAuth的配置。我们可以开始开发我们最初的Vue应用程序。</p><h1 id="1efa" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">项目结构</h1><p id="e372" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">下面是这个项目目录的样子:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e69f" class="mp le it ml b gy mq mr l ms mt">fusionauth-example-vue<br/>├─client<br/>└─server</span></pre><p id="e47f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有的Express或服务器端代码都将在<code class="fe mu mv mw ml b">server</code>文件夹中，我们的Vue应用程序将驻留在<code class="fe mu mv mw ml b">client</code>文件夹中。您不需要立即创建文件夹；我们将在接下来的步骤中这样做。</p><h1 id="50ba" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">创建Vue应用程序</h1><p id="e1dc" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们将使用官方的Vue CLI来初始化我们的项目。这是搭建单页面应用程序(spa)的最佳方式。它为现代前端工作流程提供包含电池的构建设置。只需几分钟就可以启动并运行热重装、lint-on-save和生产就绪版本。你可以在这里阅读更多关于Vue CLI的信息。</p><p id="6b3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们创建我们的Vue应用程序之前，我建议安装官方的Vue.js浏览器扩展，以便于调试和检查。你可以在这里下载。</p><p id="8d99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用以下命令全局安装Vue CLI:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="001d" class="mp le it ml b gy mq mr l ms mt">$ npm install -g @vue/cli<br/># OR<br/>$ yarn global add @vue/cli</span></pre><p id="2aaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，通过在项目目录中运行以下命令来创建项目:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="bd72" class="mp le it ml b gy mq mr l ms mt">$ vue create client</span></pre><p id="1619" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">系统会提示您选择一个预设。通过选择<strong class="js iu">手动选择功能</strong>，您可以选择带有基本<strong class="js iu"> Babel + ESLint </strong>设置或手动选项的<strong class="js iu">默认预设</strong>。后者将允许您根据自己的需要定制功能。此项目将使用默认预设。你可以在这里了解更多。</p><p id="21a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">项目初始化后，通过运行以下命令启动开发服务器:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a0be" class="mp le it ml b gy mq mr l ms mt">$ cd client<br/>$ npm run serve -- --port 8081</span></pre><p id="c417" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开浏览器，查看<a class="ae lc" href="http://localhost:8081/." rel="noopener ugc nofollow" target="_blank"> http://localhost:8081/。这是你的应用程序的外观:</a></p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/738a8ef980d4b4394bfd102e14e87007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5xp268XqmcvyrHcQ.png"/></div></div></figure><h1 id="2ea0" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">删除示例代码</h1><p id="8361" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">现在，您需要清理并删除CLI生成的一些示例代码。</p><blockquote class="nf ng nh"><p id="fc8f" class="jq jr ni js b jt ju jv jw jx jy jz ka nj kc kd ke nk kg kh ki nl kk kl km kn im bi translated">根据您选择的配置，您可能会看到不同的项目结构。如果你不确定如何清理，就坚持这个例子。</p></blockquote><p id="4c72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">删除<code class="fe mu mv mw ml b">src</code>中的<code class="fe mu mv mw ml b">components</code>、<code class="fe mu mv mw ml b">views</code>、<code class="fe mu mv mw ml b">router</code>和<code class="fe mu mv mw ml b">assets</code>文件夹，然后修改你的<code class="fe mu mv mw ml b">main.js</code>文件，如下所示:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6ce4" class="mp le it ml b gy mq mr l ms mt">import Vue from 'vue';<br/>import App from './App.vue';</span><span id="1fc7" class="mp le it ml b gy nm mr l ms mt">Vue.config.productionTip = false;</span><span id="009c" class="mp le it ml b gy nm mr l ms mt">new Vue({<br/>  render: (h) =&gt; h(App),<br/>}).$mount('#app');</span></pre><p id="e4f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，修改您的<code class="fe mu mv mw ml b">App.vue</code>文件，如下所示:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="c3bb" class="mp le it ml b gy mq mr l ms mt">&lt;template&gt;<br/>  &lt;div id='app'&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="7d62" class="mp le it ml b gy nm mr l ms mt">&lt;script&gt;<br/>export default {<br/>  name: 'app',<br/>  components: {<br/>  },<br/>};<br/>&lt;/script&gt;</span><span id="8f3e" class="mp le it ml b gy nm mr l ms mt">&lt;style&gt;<br/>&lt;/style&gt;</span></pre><p id="064a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">访问<a class="ae lc" href="http://localhost:8081/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8081/ </a>现在会给你一个黑屏。</p><blockquote class="nf ng nh"><p id="42f8" class="jq jr ni js b jt ju jv jw jx jy jz ka nj kc kd ke nk kg kh ki nl kk kl km kn im bi translated">有趣的事实:您可以在大多数SPA模板中加载环境变量，如Vue或React，而无需安装任何额外的依赖项。Vue的一个小区别是您必须在每个环境变量前添加<code class="fe mu mv mw ml b">VUE_APP_</code>。您可以在<a class="ae lc" href="https://cli.vuejs.org/guide/mode-and-env.html#environment-variables" rel="noopener ugc nofollow" target="_blank">模式和环境变量</a> Vue文档中了解更多信息。</p></blockquote><p id="8bae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们暂时把客户机放在一边，把注意力放在Express服务器上</p><h1 id="5fbf" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用Express作为我们的后端服务器</h1><p id="bfaa" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们将使用<a class="ae lc" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express.js </a>作为我们的后端服务器。这是一个被开发人员广泛使用的流行库。</p><blockquote class="nf ng nh"><p id="736a" class="jq jr ni js b jt ju jv jw jx jy jz ka nj kc kd ke nk kg kh ki nl kk kl km kn im bi translated">有趣的事实:字母<strong class="js iu"> E </strong>在<strong class="js iu"> MERN </strong>、<strong class="js iu">梅文</strong>或<strong class="js iu">中的意思是</strong>代表快递。</p></blockquote><p id="3a7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在根目录中，我们将创建另一个名为<code class="fe mu mv mw ml b">server</code>的文件夹，并在其中初始化一个NodeJS应用程序。在您的根应用程序目录中运行以下命令:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="abe7" class="mp le it ml b gy mq mr l ms mt">$ mkdir server<br/>$ cd server<br/>$ npm init -y<br/>$ npm install express cors morgan nodemon dotenv axios express-session query-string</span></pre><p id="ba9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们安装了很多包，所以让我们来看看它们:</p><ul class=""><li id="270a" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">这是一个帮助我们进行跨来源请求的中间件。</li><li id="8ee7" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">这是一个用于node.js的HTTP请求日志中间件，你可以用它来生产。</li><li id="9161" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">每次我们做出改变时重启服务器是一件麻烦的事情。当检测到文件更改时，Nodemon会自动重启节点应用程序。</li><li id="f39e" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a> —从<code class="fe mu mv mw ml b">.env</code>文件加载环境变量。我们将使用它来保护我们的API密钥和客户端配置。</li><li id="a40a" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios </a> —这允许我们发出HTTP请求。</li><li id="87bd" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://www.npmjs.com/package/express-session" rel="noopener ugc nofollow" target="_blank">快速会话</a> —它安全地存储我们的访问令牌。</li><li id="d839" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://www.npmjs.com/package/query-string" rel="noopener ugc nofollow" target="_blank"> query-string </a> —这用于将我们使用<code class="fe mu mv mw ml b">axios</code>发送的数据字符串化。</li></ul><p id="6548" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们已经安装了<code class="fe mu mv mw ml b">nodemon</code>，要在<code class="fe mu mv mw ml b">package.json</code>中使用它，只需添加以下脚本:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="f66e" class="mp le it ml b gy mq mr l ms mt">//...<br/>"scripts": {<br/>  "start": "node index.js",<br/>  "dev": "nodemon index.js"<br/>},<br/>//...</span></pre><p id="c2f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，设置您的环境变量。在<code class="fe mu mv mw ml b">server</code>文件夹中创建一个<code class="fe mu mv mw ml b">.env</code>文件，并在其中存储您的配置，比如客户端信息、端口或API凭证:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6c17" class="mp le it ml b gy mq mr l ms mt">SERVER_PORT = 9000<br/>FUSIONAUTH_PORT = 9011<br/>CLIENT_ID = 'c8642b18-5d1d-42b4-89fb-a37a5b750186'<br/>CLIENT_SECRET = 'oo06PflPxQrpfxqP8gY9ioOmfzQxARIW5R3BjJrlbS4'<br/>REDIRECT_URI = 'http://localhost:9000/oauth-callback'<br/>APPLICATION_ID = 'c8642b18-5d1d-42b4-89fb-a37a5b750186'<br/>API_KEY = 'Dy9bphElA3L3_ayW86T5KvrZkyK1Gj5EDV_2m9i39ow'</span></pre><p id="b631" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能会注意到，每个环境变量都是大写字母。这不是一条规则，只是将环境变量与代码中的变量分开的惯例。</p><p id="2dc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mu mv mw ml b">REDIRECT_URI</code>与您在FusionAuth <code class="fe mu mv mw ml b">Authorized redirect URLs</code>字段中配置的URL相同。<code class="fe mu mv mw ml b">APPLICATION_ID</code>与<code class="fe mu mv mw ml b">CLIENT_ID</code>相同。你可以把<code class="fe mu mv mw ml b">SERVER_PORT</code>换成任何你想要的端口；本教程将为Express服务器使用端口<strong class="js iu"> 9000 </strong>。使用上面创建的API密钥。</p><p id="69e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可能想知道从哪里为您的<code class="fe mu mv mw ml b">.env</code>文件获取所有这些信息。转到您之前在FusionAuth仪表板中创建的应用程序，并单击<code class="fe mu mv mw ml b">View</code>按钮。这是绿色放大镜。您可以从那里复制/粘贴<code class="fe mu mv mw ml b">CLIENT_ID</code>和<code class="fe mu mv mw ml b">CLIENT_SECRET</code>:</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/7f054cecb44574d9ae231b5c9910deab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EmktxjJpEBPUBJ6M.png"/></div></div></figure><p id="d973" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是基本Express服务器的代码。注意，我们通过在<code class="fe mu mv mw ml b">index.js</code>文件中添加以下代码来使用<code class="fe mu mv mw ml b">dotenv</code>包:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="75f8" class="mp le it ml b gy mq mr l ms mt">//...<br/>require("dotenv").config();<br/>//...</span></pre><p id="c352" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，只要我们在代码中需要，我们就可以通过在环境变量的名字前写<code class="fe mu mv mw ml b">process.env.</code>来读取环境变量。</p><p id="8d9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于<code class="fe mu mv mw ml b">.env</code>文件由于<code class="fe mu mv mw ml b">.gitignore</code>文件而被git忽略，您会注意到源代码中有一个<code class="fe mu mv mw ml b">.env.example</code>文件。要在本地机器上运行，将文件重命名为<code class="fe mu mv mw ml b">.env</code>，并添加您的客户端Id、客户端密码等。</p><p id="c4b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个Express服务器的示例代码，它使用了我们所有已安装的软件包:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="95a9" class="mp le it ml b gy mq mr l ms mt">const express = require("express");<br/>const cors = require("cors");<br/>const morgan = require("morgan");</span><span id="e114" class="mp le it ml b gy nm mr l ms mt">// dotenv<br/>require("dotenv").config();</span><span id="fd59" class="mp le it ml b gy nm mr l ms mt">const app = express();</span><span id="ba9c" class="mp le it ml b gy nm mr l ms mt">// Use our middlewares<br/>app.use(cors({ origin: true, credentials: true }));<br/>app.use(morgan("common"));<br/>app.use(express.json());</span><span id="3515" class="mp le it ml b gy nm mr l ms mt">// Provide a default port <br/>const port =  process.env.SERVER_PORT || 3000;</span><span id="18cf" class="mp le it ml b gy nm mr l ms mt">// Listen to server  <br/>app.listen(port, () =&gt; {<br/>  console.log(`Listening on port ${port}`);<br/>});</span></pre><p id="5c7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了从浏览器访问我们的服务器，我们需要<code class="fe mu mv mw ml b">cors</code>中间件。记得使用选项<code class="fe mu mv mw ml b">{ origin: true, credentials: true }</code>和<code class="fe mu mv mw ml b">app.use(cors())</code>通话。你可以在这里阅读更多关于这个<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">的内容</a>。</p><p id="6315" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在新的终端窗口中运行以下命令，启动开发服务器:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="0b06" class="mp le it ml b gy mq mr l ms mt">$ npm run dev</span></pre><p id="9685" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能是我们唯一一次启动服务器；由于我们已经安装了<code class="fe mu mv mw ml b">nodemon</code>，服务器将在每次检测到文件更改时重启。</p><p id="3b28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前往<a class="ae lc" href="http://localhost:9000/;" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/；</a>您将看到一个错误！</p><blockquote class="nf ng nh"><p id="fdab" class="jq jr ni js b jt ju jv jw jx jy jz ka nj kc kd ke nk kg kh ki nl kk kl km kn im bi translated">有趣的事实:这实际上是意料之中的，因为我们还没有创建任何路线。</p></blockquote><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/3d935b6e70b662efb6a8ed5c6a0fa57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rs83N3Uri43xM8b_.png"/></div></div></figure><p id="123b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在你的终端，你可以看到<code class="fe mu mv mw ml b">morgan</code>在行动。每当向我们的服务器发出请求时，它都会像这样在终端中记录它:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a150" class="mp le it ml b gy mq mr l ms mt">::ffff:127.0.0.1 - - [10/Jul/2020:08:48:21 +0000] "GET / HTTP/1.1" 404 139</span></pre><p id="bb8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这对于在开发和生产中调试应用程序都很有用。</p><p id="5a89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将它添加到<code class="fe mu mv mw ml b">index.js</code>文件中，为我们的主页创建一个简单的路径:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="7099" class="mp le it ml b gy mq mr l ms mt">//...<br/>// Main Page<br/>app.get("/", (req, res) =&gt; {<br/>  res.send({<br/>   message:"FusionAuth Example With Vue"<br/>  });<br/>});<br/>//...</span></pre><p id="6391" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果您访问<a class="ae lc" href="http://localhost:9000/:" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/:</a>，您将看到一个响应</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="0045" class="mp le it ml b gy mq mr l ms mt">{<br/>  "message": "FusionAuth Example With Vue"<br/>}</span></pre><h1 id="ea13" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">为我们的Vue应用程序创建登录</h1><p id="49ef" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们将开始为我们的应用程序创建登录功能。我们的Vue应用程序是空的，主要是因为我们删除了样板文件。让我们添加一个标题和一个容器，我们将在其中呈现不同的组件。</p><p id="0aa7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mu mv mw ml b">client/src/App.vue</code>内添加以下内容:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3693" class="mp le it ml b gy mq mr l ms mt">&lt;template&gt;<br/>  &lt;div id='app'&gt;<br/>    &lt;header&gt;<br/>      &lt;h1&gt;FusionAuth Example Vue&lt;/h1&gt;<br/>    &lt;/header&gt;<br/>    &lt;div id = 'container'&gt;&lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>export default {<br/>  name: 'app',<br/>  components: {<br/>  },<br/>};<br/>&lt;/script&gt;<br/>&lt;style&gt;<br/>h1 {<br/>  text-align: center;<br/>  font-size: 40px;<br/>  font-family: Arial, Helvetica, sans-serif;<br/>}<br/>#container{<br/>  box-sizing: border-box;<br/>  border: 5px solid gray;<br/>  border-radius: 15%;<br/>  width: 400px;<br/>  height: 400px;<br/>  margin: auto;<br/>}<br/>&lt;/style&gt;</span></pre><p id="ca70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CSS将不在本教程中涉及；用自定义CSS或UI库美化这个应用程序是你自己的事。</p><p id="ef37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是您的应用程序的外观:</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/f90cbdf7c3ac10ae5955d976034cd390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hYnuPbZ1rqDnHuOI.png"/></div></div></figure><p id="4846" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据用户是否登录，我们应该显示不同的消息。例如，只有当用户<code class="fe mu mv mw ml b">dinesh@fusionauth.io</code>登录时，才会显示“欢迎光临，dinesh@fusionauth.io”的消息。</p><p id="1521" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将首先对这个响应进行硬编码，然后修改代码以显示我们从FusionAuth获得的响应。</p><p id="e7c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mu mv mw ml b">src</code>文件夹中创建一个名为<code class="fe mu mv mw ml b">Greeting.vue</code>的新文件。我们将添加逻辑来检查用户是否登录；我们将使用条件渲染。如果<code class="fe mu mv mw ml b">email</code>存在，则用户登录，否则不登录。你可以<a class="ae lc" href="https://vuejs.org/v2/guide/conditional.html" rel="noopener ugc nofollow" target="_blank">在这里</a>阅读更多相关内容。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="d40a" class="mp le it ml b gy mq mr l ms mt">&lt;template&gt;<br/>  &lt;div class="greet"&gt;<br/>    &lt;h3 v-if="email"&gt;Welcome  &lt;/h3&gt;<br/>    &lt;h3 v-else&gt;You are not logged in&lt;/h3&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>export default {<br/>  name: 'Greet',<br/>  props: ["email"],<br/>};<br/>&lt;/script&gt;<br/>&lt;style &gt; <br/>*{<br/>  margin-top:30px;<br/>  text-align: center;<br/>  font-size: 20px;<br/>  font-family: 'Courier New', Courier, monospace;<br/>}<br/>&lt;/style&gt;</span></pre><p id="4504" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您会注意到上面的代码有些奇怪，我们使用<code class="fe mu mv mw ml b">email</code>来检查用户是否登录。但是<code class="fe mu mv mw ml b">email</code>值是从哪里来的呢？</p><p id="6ecc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们正在传递<code class="fe mu mv mw ml b">App.vue</code>的道具<code class="fe mu mv mw ml b">email</code>。因此，为什么在<code class="fe mu mv mw ml b">&lt;script&gt;</code>部分有一个<code class="fe mu mv mw ml b">prop</code>字段。至于我们为什么现在这样做，这可能没有意义，但请记住，我们的应用程序中还会有其他组件需要我们从服务器获得的响应数据。与其在每个单独的组件中调用相同的数据，不如在我们的中央<code class="fe mu mv mw ml b">App.vue</code>文件中请求它，然后将所需的数据作为道具传递给其他组件。</p><p id="5ad1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要在<code class="fe mu mv mw ml b">App.vue</code>中导入这个文件，并将数据发送到<code class="fe mu mv mw ml b">&lt;Greet /&gt;</code>组件。这是通过<code class="fe mu mv mw ml b">v-bind</code>完成的:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="220b" class="mp le it ml b gy mq mr l ms mt">&lt;template&gt;<br/>  &lt;div id='app'&gt;<br/>    &lt;header&gt;<br/>      &lt;h1&gt;FusionAuth Example Vue&lt;/h1&gt;<br/>    &lt;/header&gt;<br/>    &lt;div id = 'container'&gt;<br/>      &lt;Greet v-bind:email="email" /&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>import Greet from './Greeting';<br/>export default {<br/>  name: 'app',<br/>  components: {<br/>      Greet,<br/>  },<br/>  data(){<br/>    return {<br/>      email : 'dinesh@fusionauth.io'<br/>    }<br/>  }<br/>};<br/>&lt;/script&gt;<br/>&lt;style&gt;<br/>h1 {<br/>  text-align: center;<br/>  font-size: 40px;<br/>  font-family: Arial, Helvetica, sans-serif;<br/>}<br/>#container{<br/>  box-sizing: border-box;<br/>  border: 5px solid gray ;<br/>  border-radius: 15%;<br/>  width: 400px;<br/>  height: 400px;<br/>  margin: auto;<br/>}<br/>&lt;/style&gt;</span></pre><p id="3d5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在你的浏览器中，进入<a class="ae lc" href="http://localhost:8081/;" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/；</a>你会看到<code class="fe mu mv mw ml b">Welcome dinesh@fusionauth.io</code>:</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/737bd8373986bdfce9a2b8a8a809c28b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e2J6eX-qODePn9v6.png"/></div></div></figure><p id="ae89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在注释掉<code class="fe mu mv mw ml b">App.vue</code>调用中的<code class="fe mu mv mw ml b">email</code>。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="05ee" class="mp le it ml b gy mq mr l ms mt">//...<br/>data(){<br/>  return {<br/>    //email : "dinesh@fusionauth.io"<br/>    }<br/>}<br/>//...</span></pre><p id="5bea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次前往<a class="ae lc" href="http://localhost:8081/." rel="noopener ugc nofollow" target="_blank"> http://localhost:8081/。</a>如您所见，由于我们移除了<code class="fe mu mv mw ml b">email</code>，我们现在看到了“您没有登录”的消息。</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/07e4c2a347b790d26e4111b032327e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v_ZY1Qsn379i8jeh.png"/></div></div></figure><p id="3d33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了，客户成功了！我们现在将基于来自服务器的数据实现相同的逻辑。</p><h1 id="852f" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">从Express服务器获取用户信息</h1><p id="d2a8" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们将在Express服务器中创建一个<code class="fe mu mv mw ml b">user</code>路由，向我们的应用程序发送虚假的用户数据。然后，我们将基于对FusionAuth的请求用真实数据替换它。</p><p id="fa85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在您的<code class="fe mu mv mw ml b">server</code>文件夹中，创建一个新文件夹<code class="fe mu mv mw ml b">routes</code>，并在该文件夹中创建一个名为<code class="fe mu mv mw ml b">user.js</code>的新文件。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ad5c" class="mp le it ml b gy mq mr l ms mt">server<br/>├──node_modules<br/>├──routes<br/>│  └─user.js<br/>├──index.js<br/>├──package.json<br/>└─package-lock.json</span></pre><p id="e83c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用代码在<code class="fe mu mv mw ml b">user.js</code>中创建新的<code class="fe mu mv mw ml b">get</code>路线:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8aad" class="mp le it ml b gy mq mr l ms mt">const express = require('express');<br/>const router = express.Router();<br/>    <br/>router.get('/', (req, res) =&gt; {<br/>  res.send({<br/>    user: {<br/>      email: 'dinesh@fusionauth.io'<br/>    }<br/>  });<br/>});<br/>module.exports = router;</span></pre><p id="bb44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要让Express公开这条路线，请将以下内容添加到我们的<code class="fe mu mv mw ml b">index.js</code>文件中:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="fdff" class="mp le it ml b gy mq mr l ms mt">app.use('/user', require('./routes/user'))</span></pre><p id="07b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">转到<a class="ae lc" href="http://localhost:9000/user," rel="noopener ugc nofollow" target="_blank"> http://localhost:9000/user，</a>会看到以下响应:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="19c0" class="mp le it ml b gy mq mr l ms mt">{<br/>  "user": {<br/>    "email": "dinesh@fusionauth.io"<br/>  }<br/>}</span></pre><p id="f2f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住，从FusionAuth返回的一个真正的用户对象不仅仅是一个电子邮件地址，还会有更多的属性。它看起来会像这样:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="2849" class="mp le it ml b gy mq mr l ms mt">{<br/>  active: true,<br/>  applicationId: '1ac76336-9dd9-4048-99cb-f998af681d3e',<br/>  aud: '1ac76336-9dd9-4048-99cb-f998af681d3e',<br/>  authenticationType: 'PASSWORD',<br/>  email: 'dinesh@fusionauth.io',<br/>  email_verified: true,<br/>  exp: 1594893748,<br/>  iat: 1594890148,<br/>  iss: 'acme.com',<br/>  roles: [],<br/>  sub: 'abdee025-fa3c-4ce2-b6af-d0931cfb4cea'<br/>}</span></pre><p id="a983" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的<code class="fe mu mv mw ml b">App.vue</code>文件中，我们将使用<code class="fe mu mv mw ml b">mounted()</code>生命周期钩子调用服务器获取我们需要的数据:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ebc5" class="mp le it ml b gy mq mr l ms mt">//...<br/>mounted() {<br/>  fetch(`http://localhost:9000/user`, {<br/>    credentials: "include" // fetch won't send cookies unless you set credentials<br/>  })<br/>  .then(response =&gt; response.json())<br/>  .then(data=&gt; console.log(data));<br/>}<br/>//...</span></pre><p id="3430" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是控制台中上述代码的输出:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="77ab" class="mp le it ml b gy mq mr l ms mt">{<br/>  "user": {<br/>    "email": "dinesh@fusionauth.io"<br/>  }<br/>}</span></pre><p id="4d3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以使用这个对象来检查用户是否登录。我们需要首先在<code class="fe mu mv mw ml b">data()</code>函数中将<code class="fe mu mv mw ml b">email</code>定义为<code class="fe mu mv mw ml b">null</code>。如果从服务器收到响应，我们将用收到的值更新<code class="fe mu mv mw ml b">email</code>属性。在本例中，这是一个属性为<code class="fe mu mv mw ml b">email</code>的对象，因此我们将确保取消对它的引用，以便将<code class="fe mu mv mw ml b">email</code>属性设置为一个电子邮件地址，而不是一个JavaScript对象。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="689b" class="mp le it ml b gy mq mr l ms mt">&lt;template&gt;<br/>  &lt;div id="app"&gt;<br/>    &lt;header&gt;<br/>      &lt;h1&gt;FusionAuth Example Vue&lt;/h1&gt;<br/>    &lt;/header&gt;<br/>    &lt;div id="container"&gt;<br/>      &lt;Greet v-bind:email="email" /&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>import Greet from "./Greeting";<br/>export default {<br/>  name: "app",<br/>  components: {<br/>    Greet<br/>  },<br/>  data() {<br/>    return {<br/>      email: null<br/>    };<br/>  },<br/>  mounted() {<br/>    fetch(`http://localhost:9000/user`, {<br/>      credentials: "include" // fetch won't send cookies unless you set credentials<br/>    })<br/>      .then(response =&gt; response.json())<br/>      .then(data =&gt; (this.email = data.user.email));<br/>  }<br/>};<br/>&lt;/script&gt;<br/>&lt;style&gt;<br/>h1 {<br/>  text-align: center;<br/>  font-size: 40px;<br/>  font-family: Arial, Helvetica, sans-serif;<br/>}<br/>#container {<br/>  box-sizing: border-box;<br/>  border: 5px solid gray;<br/>  border-radius: 15%;<br/>  width: 400px;<br/>  height: 400px;<br/>  margin: auto;<br/>}<br/>&lt;/style&gt;</span></pre><p id="60bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的输出与我们在<code class="fe mu mv mw ml b">data()</code>中硬编码<code class="fe mu mv mw ml b">email</code>值时的输出相同:</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/ebd7bef43f4953c8b773f154e9a5200d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xKFCiqH4xjxxnBRw.png"/></div></div></figure><p id="df62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们在<code class="fe mu mv mw ml b">server/routes/user.js</code>中注释掉<code class="fe mu mv mw ml b">email</code>，我们将在应用程序中看到“您没有登录”的消息。我们可以在<code class="fe mu mv mw ml b">server/routes/user.js</code>中更改电子邮件，并查看相应的DOM更改:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8bec" class="mp le it ml b gy mq mr l ms mt">user: {<br/>  email: 'richard@fusionauth.io'<br/>}</span></pre><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/b664708cc620d9291a854e973d3abd1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xWbB93koClnewLRw.png"/></div></div></figure><h1 id="1f5a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">从FusionAuth发送数据</h1><p id="551f" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">最后，我们将从FusionAuth中提取数据，而不是使用硬编码的值。为此，我们首先需要创建一条<code class="fe mu mv mw ml b">login</code>路线；如果没有用户登录，我们如何发送用户数据？</p><p id="d51a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个新文件<code class="fe mu mv mw ml b">server/routes/login.js</code>并将此<code class="fe mu mv mw ml b">route</code>添加到<code class="fe mu mv mw ml b">index.js</code>中。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="537c" class="mp le it ml b gy mq mr l ms mt">server<br/>├──node_modules<br/>├──routes<br/>│  ├─login.js<br/>│  └─user.js<br/>├──index.js<br/>├──package.json<br/>└─package-lock.json</span></pre><p id="3a33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mu mv mw ml b">index.js</code>中，添加登录路径:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a2ed" class="mp le it ml b gy mq mr l ms mt">//...<br/>// Routes<br/>app.use('/user', require('./routes/user'))<br/>app.use('/login', require('./routes/login'))<br/>//...</span></pre><p id="6fc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是<code class="fe mu mv mw ml b">login.js</code>的代码:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ae2e" class="mp le it ml b gy mq mr l ms mt">const express = require('express');<br/>const router = express.Router();</span><span id="7ad7" class="mp le it ml b gy nm mr l ms mt">router.get('/', (req, res) =&gt; {</span><span id="1aa3" class="mp le it ml b gy nm mr l ms mt">  const stateValue = Math.random().toString(36).substring(2,15) + Math.random().toString(36).substring(2,15) + Math.random().toString(36).substring(2,15) + Math.random().toString(36).substring(2,15) + Math.random().toString(36).substring(2,15) + Math.random().toString(36).substring(2,15);</span><span id="c93e" class="mp le it ml b gy nm mr l ms mt">  req.session.stateValue = stateValue</span><span id="ea1d" class="mp le it ml b gy nm mr l ms mt">  res.redirect(`http://localhost:${process.env.FUSIONAUTH_PORT}/oauth2/authorize?client_id=${process.env.CLIENT_ID}&amp;redirect_uri=${process.env.REDIRECT_URI}&amp;response_type=code&amp;state=${stateValue}`);<br/>});<br/>module.exports = router;</span></pre><p id="4c40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的一件重要事情是我们发出请求的端点:<code class="fe mu mv mw ml b">/oauth2/authorize</code>。这个端点将为我们提供一个授权代码，我们稍后将讨论这个代码。你可以在这里了解更多。</p><p id="b18d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一件事是<code class="fe mu mv mw ml b">stateValue</code>或状态参数，它通常被用作跨站点请求伪造(CSRF)保护令牌。该字段中提供的任何值都必须在成功重定向时返回，如果不存在，则通信可能已经受损。我们稍后将在<code class="fe mu mv mw ml b">oauth-callback</code>路线中使用这个值。你可以在这里阅读更多相关内容。</p><p id="7df9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们讨论一下上面使用的其他参数。<code class="fe mu mv mw ml b">redirect_uri</code>通知FusionAuth登录后将用户重定向到哪里。<code class="fe mu mv mw ml b">response_type</code>告诉FusionAuth我们正在使用哪个OAuth授权(本例中是授权代码)。</p><p id="1f3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尝试导航到<a class="ae lc" href="http://localhost:9000/login." rel="noopener ugc nofollow" target="_blank">http://localhost:9000/log in。如果一切都是正确的，你会看到一个<code class="fe mu mv mw ml b">invalid_client</code>错误。是的，你的代码工作正常，不需要重新检查。</a></p><p id="3cb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你再看一下<code class="fe mu mv mw ml b">login.js</code>，你会发现<code class="fe mu mv mw ml b">REDIRECT_URI</code>被设置为我们<code class="fe mu mv mw ml b">.env</code>文件中<code class="fe mu mv mw ml b">http://localhost:9000/oauth-callback</code>的值。但是我们实际上还没有创建那条路线。所以这个错误是有道理的。我们实际上已经登录，因为我们在设置FusionAuth的过程中登录了FusionAuth仪表板。</p><p id="ec57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您使用新的浏览器或匿名窗口，您可能会看到登录屏幕:</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/9a13e051cd086a62e45c73f17e2eadce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jyWsWhMgOLM0iLq-.png"/></div></div></figure><h1 id="baa0" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">为授权代码授权创建OAuth回调</h1><p id="c688" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">现在，让我们通过创建一条<code class="fe mu mv mw ml b">oauth-callback</code>路线来消除这个错误。在<code class="fe mu mv mw ml b">routes</code>中创建一个新文件<code class="fe mu mv mw ml b">oauth-callback.js</code>。</p><p id="f42f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将此路线添加到<code class="fe mu mv mw ml b">index.js</code>:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6b21" class="mp le it ml b gy mq mr l ms mt">//...<br/>// Routes<br/>app.use('/user', require('./routes/user'))<br/>app.use('/login', require('./routes/login'))<br/>app.use('/oauth-callback', require('./routes/oauth-callback'))<br/>//...</span></pre><p id="5938" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在重定向期间，<code class="fe mu mv mw ml b">/oauth-callback</code>路由将从FusionAuth接收一个授权码。大概是这样的(注意<code class="fe mu mv mw ml b">code=</code>后面的字符串):</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="aaad" class="mp le it ml b gy mq mr l ms mt"><a class="ae lc" href="http://localhost:9000/oauth-callback?code=SSXVv3xkNTKEhnY4XzjUVvRZp7eyhgCuuREAgSeByrw&amp;locale=en&amp;userState=Authenticated" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/oauth-callback?code=SSXVv3xkNTKEhnY4XzjUVvRZp7eyhgCuuREAgSeByrw&amp;locale=en&amp;userState=Authenticated</a></span></pre><p id="36b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此授权码不足以访问用户信息。为此，我们需要一个<code class="fe mu mv mw ml b">access_token</code>。为了获得一个<code class="fe mu mv mw ml b">access_token</code>,我们将用这个授权码向<code class="fe mu mv mw ml b">/oauth2/token</code>端点发出post请求。</p><p id="6b30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们发出请求后，我们需要存储<code class="fe mu mv mw ml b">access_token</code>。我们不能将它存储在内存变量中，因为我们需要它用于将来的请求。我们需要一个安全的存储机制，不会暴露给我们的Vue客户端，因为它运行的浏览器容易受到XSS攻击。我们将使用<code class="fe mu mv mw ml b">express-session</code>中间件存储这个<code class="fe mu mv mw ml b">access_token</code>；我们需要导入<code class="fe mu mv mw ml b">express-session</code>。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="2baf" class="mp le it ml b gy mq mr l ms mt">//...<br/>const session = require("express-session")<br/>//...</span></pre><p id="08fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们需要在<code class="fe mu mv mw ml b">index.js</code>中添加以下内容。查看<a class="ae lc" href="https://github.com/expressjs/session#readme" rel="noopener ugc nofollow" target="_blank">快速会议文档</a>以获取更多信息可能是值得的。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="db2a" class="mp le it ml b gy mq mr l ms mt">//...<br/>// configure sessions<br/>app.use(session(<br/>  {<br/>    secret: '1234567890', // don't use this secret in prod :)<br/>    resave: false,<br/>    saveUninitialized: false,<br/>    cookie: {<br/>      secure: 'auto',<br/>      httpOnly: true,<br/>      maxAge: 3600000<br/>    }<br/>  })<br/>);<br/>//...</span></pre><p id="4bf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以继续编写<code class="fe mu mv mw ml b">oauth-callback.js</code>文件了。我们将发出post请求来接收<code class="fe mu mv mw ml b">access_token</code>。不要让下面的代码迷惑了你，我们会一条一条的讨论。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="9998" class="mp le it ml b gy mq mr l ms mt">const express = require("express");<br/>const router = express.Router();<br/>const axios = require("axios").default;<br/>const qs = require("query-string");</span><span id="d146" class="mp le it ml b gy nm mr l ms mt">const config = {<br/>  headers: {<br/>    "Content-Type": "application/x-www-form-urlencoded",<br/>  },<br/>};<br/>const url = `http://localhost:${process.env.FUSIONAUTH_PORT}/oauth2/token`;</span><span id="18aa" class="mp le it ml b gy nm mr l ms mt">router.get("/", (req, res) =&gt; {<br/>// State from Server<br/>const stateFromServer = req.query.state;<br/>if (stateFromServer !== req.session.stateValue) {<br/>  console.log("State doesn't match. uh-oh.");<br/>  console.log(`Saw: ${stateFromServer}, but expected: &amp;{req.session.stateValue}`);<br/>  res.redirect(302, '/');<br/>  return;<br/>}<br/>  //post request to /token endpoint<br/>  axios<br/>    .post(<br/>      url,<br/>      qs.stringify({<br/>        client_id: process.env.CLIENT_ID,<br/>        client_secret: process.env.CLIENT_SECRET,<br/>        code: req.query.code,<br/>        grant_type: "authorization_code",<br/>        redirect_uri: process.env.REDIRECT_URI,<br/>      }),<br/>      config<br/>    )<br/>    .then((result) =&gt; {</span><span id="0de5" class="mp le it ml b gy nm mr l ms mt">      // save token to session<br/>      req.session.token = result.data.access_token;<br/>      console.log(result)<br/>      //redirect to Vue app<br/>     res.redirect(`http://localhost:8081`);<br/>    })<br/>    .catch((err) =&gt; {<br/>      console.error(err);<br/>    });<br/>});<br/>module.exports = router;</span></pre><p id="2903" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从路线的标准代码开始，就像<code class="fe mu mv mw ml b">login.js</code>。然后我们进口<code class="fe mu mv mw ml b">axios</code>和<code class="fe mu mv mw ml b">querystring</code>。然后我们使用一个<code class="fe mu mv mw ml b">if</code>语句来检查状态参数；如果不匹配，我们会记录一条错误消息。</p><p id="dbcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<code class="fe mu mv mw ml b">axios</code>向<code class="fe mu mv mw ml b">oauth2/token</code>端点发出post请求；这是我们将请求的完整URL:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="998b" class="mp le it ml b gy mq mr l ms mt">const url = `http://localhost:${process.env.FUSIONAUTH_PORT}/oauth2/token`;</span></pre><p id="cc93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会注意到的另一件事是<code class="fe mu mv mw ml b">config</code>变量。<code class="fe mu mv mw ml b">oauth2/token</code>端点需要表单编码的数据，这就是我们在头中显式设置内容类型的原因:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="befe" class="mp le it ml b gy mq mr l ms mt">//...<br/>const config = {<br/>  headers: {<br/>    "Content-Type": "application/x-www-form-urlencoded",<br/>  },<br/>};<br/>//...</span></pre><p id="38dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们来谈谈请求的主体。如果你浏览一下<a class="ae lc" href="https://fusionauth.io/docs/v1/tech/oauth/endpoints#token" rel="noopener ugc nofollow" target="_blank"> FusionAuth文档</a>，你会发现有<code class="fe mu mv mw ml b">oauth2/token</code>端点所期望的标准请求参数。有些是可选的，有些是必需的。<code class="fe mu mv mw ml b">code</code>是我们从<code class="fe mu mv mw ml b">oauth2/authorize</code>端点收到的授权码，而<code class="fe mu mv mw ml b">grant_type</code>告诉FusionAuth我们正在使用授权码流。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6077" class="mp le it ml b gy mq mr l ms mt">//...<br/>qs.stringify({<br/>  client_id: process.env.CLIENT_ID,<br/>  client_secret: process.env.CLIENT_SECRET,<br/>  code: req.query.code,<br/>  grant_type: "authorization_code",<br/>  redirect_uri: process.env.REDIRECT_URI,<br/>})<br/>//...</span></pre><p id="755b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mu mv mw ml b">query-string</code>库字符串表示这个请求对象，如下所示。这使我们不必手动这样做，并使代码更具可读性:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="662d" class="mp le it ml b gy mq mr l ms mt">// the stringified parameters<br/>'client_id=1ac76336-9dd9-4048-99cb-f998af681d3e&amp;client_secret=NLmIgHC65zHeHOPlQMmOMG4Nberle41GT85RUgijdqA&amp;code=e_oTyBn_7WPTPgtFUjvEZk6TwBBLYajRi8NMixQehd0&amp;grant_type=authorization_code&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Foauth-callback'</span></pre><p id="6300" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在成功的post请求之后，我们使用<code class="fe mu mv mw ml b">.then()</code>方法来访问来自端点的响应。我们用名称<code class="fe mu mv mw ml b">token</code>存储在会话中收到的<code class="fe mu mv mw ml b">access_token</code>。上面的代码记录了这个响应，以便您可以在调试时看到它。我们只关心<code class="fe mu mv mw ml b">data.access_token</code>值，尽管会返回其他信息。存储此<code class="fe mu mv mw ml b">access_token</code>后，我们重定向到我们的Vue应用程序。下面是一个向<code class="fe mu mv mw ml b">token</code>端点成功请求后可能返回的内容的示例:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="71ca" class="mp le it ml b gy mq mr l ms mt">data: {<br/>  access_token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjcxNDcxZGE3ZiJ9.eyJhdWQiOiIxYWM3NjMzNi05ZGQ5LTQwNDgtOTljYi1mOTk4YWY2ODFkM2UiLCJleHAiOjE1OTQ4ODkzODAsImlhdCI6MTU5NDg4NTc4MCwiaXNzIjoiYWNtZS5jb20iLCJzdWIiOiJhYmRlZTAyNS1mYTNjLTRjZTItYjZhZi1kMDkzMWNmYjRjZWEiLCJhdXRoZW50aWNhdGlvblR5cGUiOiJQQVNTV09SRCIsImVtYWlsIjoiYXNodXNpbmdoMTU2NzNAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsImFwcGxpY2F0aW9uSWQiOiIxYWM3NjMzNi05ZGQ5LTQwNDgtOTljYi1mOTk4YWY2ODFkM2UiLCJyb2xlcyI6W119.Dcktd6933XI7iDEsH2RbR49lse-Mamx7B5k1q4hSz_o',<br/>  expires_in: 3599,<br/>  token_type: 'Bearer',<br/>  userId: 'abdee025-fa3c-4ce2-b6af-d0931cfb4cea'<br/>}</span></pre><p id="1f9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以看到一个<code class="fe mu mv mw ml b">access_token</code>长什么样；这是JWT。axios请求以catch块结束，以处理我们可能遇到的任何错误。</p><p id="6a95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前往<a class="ae lc" href="http://localhost:9000/login." rel="noopener ugc nofollow" target="_blank">http://localhost:9000/log in。</a>如果一切顺利，您将会出现在您的Vue应用主页上，因为这是我们在<code class="fe mu mv mw ml b">redirect_uri</code>中设置的。您应该在控制台(运行服务器的终端)中看到响应，因为您已经登录了。</p><h1 id="0cbf" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">添加注销路由</h1><p id="d36e" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">因此，我们有一个<code class="fe mu mv mw ml b">login</code>路径，用户登录后会重定向回我们的Vue应用。在我们在Vue应用程序中添加链接之前，让我们在Express服务器中创建一条<code class="fe mu mv mw ml b">logout</code>路线。然后，我们将能够轻松地将它们添加到Vue应用程序中。</p><p id="8711" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mu mv mw ml b">server/routes</code>中创建一个名为<code class="fe mu mv mw ml b">logout.js</code>的新文件。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="64bd" class="mp le it ml b gy mq mr l ms mt">server<br/>├──node_modules<br/>├──routes<br/>│  ├─login.js<br/>│  ├─oauth-callback.js<br/>│  ├─logout.js<br/>│  └─user.js<br/>├──index.js<br/>├──package.json<br/>└─package-lock.json</span></pre><p id="100b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加然后将这条路线添加到<code class="fe mu mv mw ml b">index.js</code>:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a137" class="mp le it ml b gy mq mr l ms mt">//...<br/>// Routes<br/>app.use('/user', require('./routes/user'))<br/>app.use('/login', require('./routes/login'))<br/>app.use('/logout', require('./routes/logout'))<br/>app.use('/oauth-callback', require('./routes/oauth-callback'))<br/>//...</span></pre><p id="6bf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mu mv mw ml b">logout.js</code>文件中添加以下代码:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="2ca7" class="mp le it ml b gy mq mr l ms mt">const express = require('express');<br/>const router = express.Router();<br/>router.get('/', (req, res) =&gt; {<br/>  // delete the session<br/>  req.session.destroy();<br/>  // end FusionAuth session<br/>  res.redirect(`http://localhost:${process.env.FUSIONAUTH_PORT}/oauth2/logout?client_id=${process.env.CLIENT_ID}`);<br/>});<br/>module.exports = router;</span></pre><p id="c219" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与<code class="fe mu mv mw ml b">oauth-callback.js</code>相比，这相当简单。我们首先销毁Express服务器端会话(以及我们存储的<code class="fe mu mv mw ml b">token</code>),然后用我们的<code class="fe mu mv mw ml b">CLIENT_ID</code>重定向到<code class="fe mu mv mw ml b">oauth2/logout</code>端点。</p><p id="a750" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前往<a class="ae lc" href="http://localhost:9000/logout" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/logout</a>，你将被注销。导航到<a class="ae lc" href="http://localhost:9000/login" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/log in</a>，您将看到登录页面。登录后，您将回到您的Vue应用程序。</p><p id="3c4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能想知道为什么在<strong class="js iu">注销</strong>后，我们<strong class="js iu">重定向回我们的Vue应用</strong>，然而我们在<code class="fe mu mv mw ml b">logout.js</code>文件中没有做任何类似的事情。这是因为我们将Vue应用程序的主入口点配置为FusionAuth中的注销URL。</p><h1 id="b024" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">正在检索用户数据</h1><p id="2675" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">到目前为止，我们一直在使用伪造的用户数据。因为我们现在已经将<code class="fe mu mv mw ml b">access_token</code>存储在会话中，所以我们可以使用它从FusionAuth请求用户数据。</p><p id="bfdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将<code class="fe mu mv mw ml b">user.js</code>文件内容修改为:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a473" class="mp le it ml b gy mq mr l ms mt">const express = require("express");<br/>const router = express.Router();<br/>const axios = require("axios");<br/>const qs = require("querystring");<br/>  <br/>router.get("/", (req, res) =&gt; {<br/>  // token in session -&gt; get user data and send it back to the vue app<br/>  if (req.session.token) {<br/>    axios<br/>      .post(<br/>        `http://localhost:${process.env.FUSIONAUTH_PORT}/oauth2/introspect`,<br/>        qs.stringify({<br/>          client_id: process.env.CLIENT_ID,<br/>          token: req.session.token,<br/>        })<br/>      )<br/>      .then((result) =&gt; {<br/>        let introspectResponse = result.data;<br/>        // valid token -&gt; get more user data and send it back to the Vue app<br/>        if (introspectResponse) {<br/>          <br/>          // GET request to /registration endpoint<br/>          axios<br/>            .get(<br/>              `http://localhost:${process.env.FUSIONAUTH_PORT}/api/user/registration/${introspectResponse.sub}/${process.env.APPLICATION_ID}`,<br/>              {<br/>                headers: {<br/>                  Authorization: process.env.API_KEY,<br/>                },<br/>              }<br/>            )<br/>            .then((response) =&gt; {<br/>              res.send({<br/>                introspectResponse: introspectResponse,<br/>                body: response.data.registration,<br/>              });<br/>            })<br/>        }<br/>      // expired token -&gt; send nothing <br/>        else {<br/>          req.session.destroy();<br/>          res.send({});<br/>        }<br/>      })<br/>      .catch((err) =&gt; {<br/>        console.log(err);<br/>      });<br/>  }<br/>  // no token -&gt; send nothing<br/>  else {<br/>    res.send({});<br/>  }<br/>});<br/>module.exports = router;</span></pre><p id="6f65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查一下这段代码。首先，我们检查一个<code class="fe mu mv mw ml b">access_token</code>是否存在，然后向<code class="fe mu mv mw ml b">oauth2/introspect</code>端点发出一个<strong class="js iu"> POST </strong>请求，该请求需要客户端Id和令牌。像<code class="fe mu mv mw ml b">oauth2/token</code>端点一样，这个端点期望表单编码的数据，所以我们再次使用了<code class="fe mu mv mw ml b">query-string</code>库。</p><p id="94bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当这个请求成功时，我们得到一个响应对象。这包含用户数据。</p><p id="2210" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个JSON的例子:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="68cd" class="mp le it ml b gy mq mr l ms mt">{<br/>  active: true,<br/>  applicationId: '9d5119d4-71bb-495c-b762-9f14277c116c',<br/>  aud: '9d5119d4-71bb-495c-b762-9f14277c116c',  <br/>  authenticationType: 'PASSWORD',<br/>  email: 'richard@fusionauth.io',<br/>  email_verified: true,<br/>  exp: 1594904052,<br/>  iat: 1594900452,<br/>  iss: 'acme.com',<br/>  roles: [],<br/>  sub: 'abdee025-fa3c-4ce2-b6af-d0931cfb4cea'   <br/>}</span></pre><p id="090a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们再次请求收集更多的用户信息。这次我们向<code class="fe mu mv mw ml b">/api/user/registration</code>端点发出一个<strong class="js iu"> GET </strong>请求。这个API需要用户Id，它与由<code class="fe mu mv mw ml b">introspect</code>端点提供的<code class="fe mu mv mw ml b">sub</code>值相同。对<strong class="js iu"> GET </strong>请求的响应包含用户<code class="fe mu mv mw ml b">data</code>属性，其中有我们需要的信息。注意，这不是标准的，但是来自<code class="fe mu mv mw ml b">/oauth2/introspect</code>端点的响应是标准的。</p><p id="b3b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当这个最终请求成功时，我们通过<code class="fe mu mv mw ml b">res.send()</code>将所有数据发送到我们的Vue客户端。下面是来自<code class="fe mu mv mw ml b">/api/user/registration</code>调用的响应:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="f1f4" class="mp le it ml b gy mq mr l ms mt">{<br/>  "applicationId": "9d5119d4-71bb-495c-b762-9f14277c116c",<br/>  "data": "",<br/>  "id": "c756e203-ea1f-491e-9446-b70ed4eecc17",<br/>  "insertInstant": 1594898302209,<br/>  "lastLoginInstant": 1594900452281,<br/>  "username": "ashu",<br/>  "usernameStatus": "ACTIVE",<br/>  "verified": true<br/>}</span></pre><p id="148d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在<code class="fe mu mv mw ml b">Authorization</code> HTTP头中传递的API键不是OAuth标准的一部分。您需要它来调用非标准端点，如<a class="ae lc" href="https://fusionauth.io/docs/v1/tech/apis/registrations#retrieve-a-user-registration" rel="noopener ugc nofollow" target="_blank">用户注册API </a>。我们添加这一点是为了展示如果您决定访问受API密钥保护的端点，如何使用该密钥。</p><h1 id="fe47" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">显示用户数据</h1><p id="d3ac" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">Express服务器现在可以访问存储在FusionAuth中的用户信息。下一步是显示数据。在我们的<code class="fe mu mv mw ml b">App.vue</code>文件中，我们修改了<code class="fe mu mv mw ml b">mounted()</code>方法，因为这次我们得到了一个包含来自<code class="fe mu mv mw ml b">introspect</code>和<code class="fe mu mv mw ml b">registration</code>端点的数据的响应对象。</p><p id="1c08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只需要在<code class="fe mu mv mw ml b">App.vue</code>中增加一行。不是<code class="fe mu mv mw ml b">data.user.email</code>，这次会是<code class="fe mu mv mw ml b">data.introspectResponse.email</code>。当我们这样做时，让我们在<code class="fe mu mv mw ml b">data()</code>中将<code class="fe mu mv mw ml b">body</code>定义为null，并将响应对象的<code class="fe mu mv mw ml b">body</code>字段存储在其中。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8fd5" class="mp le it ml b gy mq mr l ms mt">//...<br/>data() {<br/>  return {<br/>    email: null,<br/>    body: null,<br/>  };<br/>},<br/>mounted() {<br/>  fetch(`http://localhost:9000/user`, {<br/>    credentials: "include" // fetch won't send cookies unless you set credentials<br/>  })<br/>  .then((response) =&gt; response.json())<br/>  .then((data) =&gt; {<br/>    this.email = data.introspectResponse.email;<br/>    this.body= data.body;<br/>  });<br/>}<br/>//...</span></pre><p id="7fe1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他一切都保持不变。我们现在在应用程序中从FusionAuth获取用户信息，而不是伪造的用户数据。</p><p id="61d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次执行登录过程，在成功认证后，您应该会看到“欢迎[您的电子邮件地址]”。</p><h1 id="8a4b" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">在Vue中添加登录和注销</h1><p id="fc7f" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们之前已经为<code class="fe mu mv mw ml b">login</code>和<code class="fe mu mv mw ml b">logout</code>创建了服务器端点。让我们将它们添加到Vue应用程序中。创建一个名为<code class="fe mu mv mw ml b">Login.vue</code>的新文件，并添加以下内容:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e723" class="mp le it ml b gy mq mr l ms mt">&lt;template&gt;<br/>  &lt;h1 v-if="email"&gt;&lt;a href='http://localhost:9000/logout'&gt;Sign Out&lt;/a&gt;&lt;/h1&gt;<br/>  &lt;h1 v-else&gt;&lt;a href='http://localhost:9000/login'&gt;Sign In&lt;/a&gt;&lt;/h1&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>export default {<br/>  name: "Login",<br/>  props: ["email"],<br/>};<br/>&lt;/script&gt;</span></pre><p id="8311" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据上面的代码，如果用户没有登录，将显示<code class="fe mu mv mw ml b">Sign In</code>文本，否则将显示一条<code class="fe mu mv mw ml b">Sign Out</code>消息。<code class="fe mu mv mw ml b">email</code>预计会从<code class="fe mu mv mw ml b">App.vue</code>这里传过来作为道具，那就这么办吧。在我们的<code class="fe mu mv mw ml b">App.vue</code>文件中，首先导入<code class="fe mu mv mw ml b">Login</code>组件:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="1d7e" class="mp le it ml b gy mq mr l ms mt">//...<br/>import Login from "./Login";<br/>//...</span></pre><p id="2efd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后把这个加到<code class="fe mu mv mw ml b">components</code>:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e438" class="mp le it ml b gy mq mr l ms mt">//...<br/>components: {<br/>  Greet,<br/>  Login <br/>}<br/>//...</span></pre><p id="0e18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后在<code class="fe mu mv mw ml b">&lt;template&gt;</code>标签中使用它，将<code class="fe mu mv mw ml b">email</code>作为属性传递:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="2d24" class="mp le it ml b gy mq mr l ms mt">//...<br/>&lt;div id="container"&gt;<br/>  &lt;Greet v-bind:email="email" /&gt;<br/>  &lt;Login v-bind:email="email" /&gt;<br/>&lt;/div&gt;<br/>//...</span></pre><p id="0b44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以点击登录和注销。这是您注销后的应用程序:</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/136c74339e6a895f82ea44fb9dfb26c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3B8tmt-5c-IBf6AY.png"/></div></div></figure><p id="4cd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是你登录时的应用程序(如果你用<code class="fe mu mv mw ml b">richard@fusionauth.io</code>注册的话):</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/158c8bd2c36466a6faaf2a08cb6be54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MSt5jp3iyVSw3oOm.png"/></div></div></figure><h1 id="18f1" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">更改用户信息</h1><p id="2ccb" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">这最后一节处理从我们的Vue应用程序设置FusionAuth用户数据。</p><p id="6853" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将创建<code class="fe mu mv mw ml b">/set-user-data</code>路线；在<code class="fe mu mv mw ml b">routes</code>中添加一个<code class="fe mu mv mw ml b">set-user-data.js</code>文件，并将以下代码添加到其中:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4093" class="mp le it ml b gy mq mr l ms mt">const express = require("express");<br/>const router = express.Router();<br/>const axios = require("axios");<br/>const qs = require("query-string");<br/>router.post("/", (req, res) =&gt; {<br/>  // POST request to /introspect endpoint<br/>  axios<br/>    .post(<br/>      `http://localhost:${process.env.FUSIONAUTH_PORT}/oauth2/introspect`,<br/>      qs.stringify({<br/>        client_id: process.env.CLIENT_ID,<br/>        token: req.session.token,<br/>      })<br/>    )<br/>    .then((response) =&gt; {<br/>      let introspectResponse = response.data;<br/>    <br/>      // PATCH request to /registration endpoint<br/>      axios.patch(<br/>        `http://localhost:${process.env.FUSIONAUTH_PORT}/api/user/registration/${introspectResponse.sub}/${process.env.APPLICATION_ID}`,<br/>        {<br/>          registration: {<br/>            data: req.body,<br/>          },<br/>        },<br/>        {<br/>          headers: {<br/>            Authorization: process.env.API_KEY,<br/>          },<br/>        }<br/>      ).catch(err=&gt;{<br/>          console.log(err)<br/>      })<br/>    })<br/>    .catch((err) =&gt; {<br/>      console.error(err);<br/>    });</span><span id="ef4a" class="mp le it ml b gy nm mr l ms mt">});<br/>module.exports = router;</span></pre><p id="bb28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了确保我们正在更新当前登录的用户，我们通过向<code class="fe mu mv mw ml b">oauth/introspect</code>端点发出<strong class="js iu"> POST </strong>请求，从我们的FusionAuth服务器中找到令牌；这类似于我们在<code class="fe mu mv mw ml b">user</code>路线中所做的。</p><p id="57b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦这个请求成功，我们就向<code class="fe mu mv mw ml b">/api/user/registration</code> API发出一个<strong class="js iu">补丁</strong>请求。如果你浏览一下<a class="ae lc" href="https://fusionauth.io/docs/v1/tech/apis/registrations#update-a-user-registration" rel="noopener ugc nofollow" target="_blank">用户注册文档</a>，你会发现这个API同时接受<strong class="js iu">上传</strong>和<strong class="js iu">补丁</strong>请求。这里我们使用<strong class="js iu">补丁</strong>，因为我们只想更新用户注册对象的单个部分，而<strong class="js iu">补丁</strong>会将请求参数合并到现有对象中。</p><p id="c25f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要发送的<code class="fe mu mv mw ml b">data</code>存储在从<code class="fe mu mv mw ml b">req.body</code>获取值的<code class="fe mu mv mw ml b">registration</code>对象中。这个<code class="fe mu mv mw ml b">registration</code>表示用户与应用程序的关联。属性允许我们在应用程序中存储与用户注册相关的任意键值数据。</p><p id="c745" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在从Express到FusionAuth的通信中使用了<strong class="js iu">补丁</strong>，但是我们将通过JSON在<strong class="js iu"> POST </strong> HTTP消息的正文中把用户数据从我们的Vue应用程序发送到Express服务器。</p><h1 id="b675" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">从Vue设置用户数据</h1><p id="1ee0" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">既然我们已经创建了用于更新用户数据的服务器路由，那么让我们在Vue应用程序中创建一个<code class="fe mu mv mw ml b">text-area</code>。用户将在那里输入数据，当点击<code class="fe mu mv mw ml b">Submit</code>按钮时，数据将被发送到服务器。</p><p id="4546" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mu mv mw ml b">client/src</code>中，创建一个名为<code class="fe mu mv mw ml b">Update.vue</code>的新文件，并添加以下内容:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="bce5" class="mp le it ml b gy mq mr l ms mt">&lt;template&gt;<br/>  &lt;form&gt;<br/>    &lt;textarea<br/>      v-model="userData"<br/>      placeholder="Update FusionAuth user data."<br/>    &gt;&lt;/textarea&gt;<br/>    &lt;button type="submit" class="button"&gt;Submit&lt;/button&gt;<br/>  &lt;/form&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>export default {<br/>  name: "Update",<br/>  data() {<br/>    return {<br/>      userData: "",<br/>    };<br/>  },<br/>&lt;/script&gt;<br/>&lt;style&gt;<br/>textarea {<br/>  display: block;<br/>  margin-left: auto;<br/>  margin-right: auto;<br/>}<br/>button {<br/>  margin-left: auto;<br/>  margin-right: auto;<br/>  margin-top: 5px;<br/>}<br/>&lt;/style&gt;</span></pre><p id="966f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Vue的一个很酷的特性是，通过在<code class="fe mu mv mw ml b">data()</code>函数中使用<code class="fe mu mv mw ml b">v-model="userData"</code>并将<code class="fe mu mv mw ml b">userData</code>初始化为空字符串，在<code class="fe mu mv mw ml b">textarea</code>元素和<code class="fe mu mv mw ml b">userData</code>属性之间配置了双向数据绑定。</p><p id="687e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以在<code class="fe mu mv mw ml b">userData</code>中访问我们在<code class="fe mu mv mw ml b">textarea</code>中输入的任何内容。你可以在这里了解更多。</p><p id="a7cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将该组件添加到<code class="fe mu mv mw ml b">App.vue</code>。然而，当用户没有登录时，显示这个组件是没有意义的。要隐藏它，将<code class="fe mu mv mw ml b">v-if="email"</code>添加到该组件。它将检查<code class="fe mu mv mw ml b">email</code>是否存在。因此，如果用户注销，该组件将隐藏自己。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="9b29" class="mp le it ml b gy mq mr l ms mt">&lt;Update v-if="email" /&gt;</span></pre><p id="27c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还没有配置<code class="fe mu mv mw ml b">Submit</code>按钮。让我们这样做，将我们在<code class="fe mu mv mw ml b">textarea</code>中键入的任何内容发送到我们的服务器进行存储。在<code class="fe mu mv mw ml b">methods()</code>部分创建一个函数<code class="fe mu mv mw ml b">update</code>。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a2e1" class="mp le it ml b gy mq mr l ms mt">//...<br/>methods: {<br/>  update: function() {<br/>    fetch(`http://localhost:9000/set-user-data`, {<br/>      credentials: "include",<br/>      method: "POST",<br/>      headers: {<br/>        "Content-Type": "application/json",<br/>      },<br/>      body: JSON.stringify({<br/>        userData: this.userData,<br/>      }),<br/>    }).catch((err) =&gt; {<br/>        console.log(err);<br/>      });<br/>      this.userData=''<br/>  },<br/>},<br/>//...</span></pre><p id="abd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的函数中，我们用<code class="fe mu mv mw ml b">fetch()</code>到<strong class="js iu"> POST </strong> JSON编码的数据来表示。如果你熟悉<code class="fe mu mv mw ml b">fetch()</code>，你会看到这是一个简单的<strong class="js iu">岗位</strong>要求，没什么花哨的。你可以<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank">在这里</a>了解更多。</p><p id="c807" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们将<code class="fe mu mv mw ml b">userData</code>发送到我们的服务器，我们通过设置<code class="fe mu mv mw ml b">userData</code>等于<code class="fe mu mv mw ml b">''</code>来重置<code class="fe mu mv mw ml b">textarea</code>，因为这是一个双向绑定。为了将该函数绑定到<code class="fe mu mv mw ml b">submit</code>事件，我们将在<code class="fe mu mv mw ml b">form</code>标签中添加以下内容:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6d7d" class="mp le it ml b gy mq mr l ms mt">&lt;form @submit.prevent="update"&gt;<br/>  //<br/>&lt;/form&gt;</span></pre><blockquote class="nf ng nh"><p id="0ec8" class="jq jr ni js b jt ju jv jw jx jy jz ka nj kc kd ke nk kg kh ki nl kk kl km kn im bi translated">有趣的事实:每当点击提交按钮时，使用<code class="fe mu mv mw ml b">.prevent</code>可以阻止页面重新加载。</p></blockquote><p id="a6f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是我们的应用程序现在的样子:</p><figure class="mg mh mi mj gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/bb0fd2e62fbe88597fc119f642d2e71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gh7vCbC61BO2sRrF.png"/></div></div></figure><p id="ca53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">转到您的Vue应用程序，在<code class="fe mu mv mw ml b">textarea</code>中键入一些文本，然后单击提交按钮。如果您登录到FusionAuth仪表板，您现在可以看到您添加的文本存储在FusionAuth中。它位于您的用户帐户详细信息中的<strong class="js iu">用户数据</strong>选项卡下。</p><h1 id="6ca9" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="ae92" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">恭喜，您已经构建了一个Vue应用程序，它允许用户登录、注销和修改他们的用户数据。本文是使用FusionAuth实现OAuth的基础。您可以添加许多其他特性、组件和路线来扩展这个应用程序。</p><p id="d0e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，这里有<a class="ae lc" href="https://github.com/fusionauth/fusionauth-example-vue" rel="noopener ugc nofollow" target="_blank">代码</a>，你可以派生并试验。</p><p id="1285" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是您接下来可以做的一些想法:</p><ul class=""><li id="f049" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><a class="ae lc" href="https://fusionauth.io/docs/v1/tech/apis/registrations#create-a-user-and-registration-combined" rel="noopener ugc nofollow" target="_blank">从App本身注册用户。</a></li><li id="b474" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">使用像<a class="ae lc" href="https://www.npmjs.com/package/helmet" rel="noopener ugc nofollow" target="_blank">头盔</a>这样的中间件来保护你的服务器</li><li id="4540" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">探索第三方认证选项，如<a class="ae lc" href="https://fusionauth.io/docs/v1/tech/apis/identity-providers/google" rel="noopener ugc nofollow" target="_blank"> Google </a>、<a class="ae lc" href="https://fusionauth.io/docs/v1/tech/apis/identity-providers/twitter" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或其他。</li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="d9d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ni">原载于</em><a class="ae lc" href="https://fusionauth.io/blog/2020/08/06/securely-implement-oauth-vuejs" rel="noopener ugc nofollow" target="_blank"><em class="ni">https://fusion auth . io</em></a><em class="ni">。</em></p></div></div>    
</body>
</html>