<html>
<head>
<title>The Complete Guide to Immutability in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中不变性的完全指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-complete-guide-to-immutability-in-typescript-99154f859fdb?source=collection_archive---------0-----------------------#2021-03-08">https://levelup.gitconnected.com/the-complete-guide-to-immutability-in-typescript-99154f859fdb?source=collection_archive---------0-----------------------#2021-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/3977f715a02f4b9ca59a504c2e406f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*Um0CIm7TvhSOpsy6yVc3Aw.png"/></div></figure><p id="c5b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最保守的不变性定义可以归结为拥有在初始赋值后各自状态不能改变的对象。投资将这种软件模式应用于项目中的所有对象，可以带来更好的可读性、更好的代码理解和高级线程安全(在支持线程的系统中)方面的回报。下面的文章提供了我发现的与TypeScript开发人员相关的所有信息，这样他们就可以根据底层的函数式编程理论、语言中对上述概念的本机支持以及最佳实践，推断出他们的项目中普遍存在的不变性的需求。</p><h1 id="feb6" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">不变性的论据</h1><p id="1bae" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在传统的面向对象的软件体系结构方法中，任何类实例都可能包含一个状态，该状态只与一个特定的实例相关并且是其固有的。状态初始化发生在类构造函数中，当调用类方法时，将更改应用到该状态。尽管所描述的参与规则听起来很合理，但类的可变性严重影响了依赖可变性的代码结构。</p><p id="e6b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了清楚起见，我必须引入几个概念来描述支持可变性的架构的缺点，首先从定义两种类型的函数的执行开始:</p><ul class=""><li id="7737" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated"><em class="me">同步</em>(在当前执行上下文中执行并立即返回)，</li><li id="a8da" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated"><em class="me">异步</em>(它在不同的执行上下文中执行，获取返回值需要在当前上下文中等待它)。</li></ul><p id="4b0c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">根据环境的不同，如果一个闭包在没有等待完成的情况下调用一个异步函数，并且该函数确实改变了某个状态，那么没有人能够可靠地推断出调用之后该闭包中该状态的变化的可见性。这种副作用不适用于同步调用——但是，在同步函数从内部改变了状态之后，所有以前基于相关状态的计算都将失效。</p><p id="bc55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">其次，我可以区分<em class="me">不可变的</em>和<em class="me">可变的</em>函数。调用一个不可变的函数没有副作用(没有任何状态的改变)，只有一个<em class="me">效果</em>(这个词来自函数式编程的世界)——从它返回的值。一个可变函数有<em class="me">改变状态的潜力</em>，根据定义，这会产生副作用。</p><p id="aa13" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第三，在面向对象的体系结构中，开发人员可以为任何类定义getters和setters。getter表现为一个不可变的函数，它将选定的状态属性返回给它的调用方。另一方面，setter通过在选定的状态属性上设置特定的值来改变状态。</p><p id="8765" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，将所有这些概念结合在一起，热心的读者应该看到在代码的不同位置和各种执行上下文(线程或回调等)中任何状态变异所带来的潜在复杂性。在没有首先确保开发人员遵循明确的指导方针(保护他们免于未来的复杂性)的情况下，对这样的代码进行调试或简单推理，甚至对于能够在复杂系统中工作的人来说，也可能是令人头疼的。这定义了应用不变性的基本原因——希望将执行的上下文减少到支持所讨论项目的可维护性所需的最小值。</p><h1 id="74e7" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">JavaScript中的不变性</h1><p id="aebb" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">JavaScript是一种多范式语言，它实现了函数式编程的某些方面，而没有将函数式思维方式强加给开发人员。这种语言本身确实支持不变性，不变性是上述范例的核心概念之一，但也有一些附加条件。大部分负担来自于这样一个事实，即利用不变性需要对所讨论的对象执行<em class="me">明确表达的</em>操作。</p><h2 id="3d2f" class="mk kt iq bd ku ml mm dn ky mn mo dp lc kf mp mq lg kj mr ms lk kn mt mu lo mv bi translated">原始和包装类型</h2><p id="449b" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">存在以下原始类型:<code class="fe mw mx my mz b">boolean</code>、<code class="fe mw mx my mz b">number</code>、<code class="fe mw mx my mz b">bigint</code>、<code class="fe mw mx my mz b">string</code>、<code class="fe mw mx my mz b">symbol</code>、<code class="fe mw mx my mz b">null</code>和<code class="fe mw mx my mz b">undefined</code>。它们都没有关联的方法；源自这些类型的原始值以不可变的方式表现，这意味着在函数中传递它们不会产生副作用。根据我的经验，大多数JavaScript开发人员不知道五种包装器(对象)类型，即<code class="fe mw mx my mz b">Boolean</code>、<code class="fe mw mx my mz b">Number</code>、<code class="fe mw mx my mz b">BigInt</code>、<code class="fe mw mx my mz b">String</code>和<code class="fe mw mx my mz b">Symbol</code>，因为该语言在大多数情况下允许原语和包装器对象的(隐式)可互换使用，从而隐藏了包装器的真实本质。</p><p id="cdd2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">任何对象(包括函数在内的任何非原语对象)都有可能暴露变异行为，因为它包含一些方法。根据定义，一个对象有一个相关的原型(也是一个对象)，改变原型可能会改变所述对象的行为。我发现在处理可变性时，最好考虑对象的整个上下文，包括所有嵌套的属性和它们各自的属性，直到最后一个原语。</p><h2 id="9f67" class="mk kt iq bd ku ml mm dn ky mn mo dp lc kf mp mq lg kj mr ms lk kn mt mu lo mv bi translated">变量声明</h2><p id="9e4c" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">开发人员应该使用<code class="fe mw mx my mz b">const</code>或<code class="fe mw mx my mz b">let</code>在新的JavaScript项目中声明变量。我个人不鼓励使用<code class="fe mw mx my mz b">let</code>,因为我预计开发人员很难在几十行代码中找出对相同变量的多次重新分配。如果有疑问，任何有经验的程序员都可以将重新赋值重构为一个单独的函数，该函数计算有问题的变量值并返回它。</p><h2 id="b4aa" class="mk kt iq bd ku ml mm dn ky mn mo dp lc kf mp mq lg kj mr ms lk kn mt mu lo mv bi translated">物体冻结</h2><p id="209d" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">JavaScript包含了使对象变得不可变的功能。我用<em class="me">浅显地用</em>来标记，在转换发生后，除了嵌套在其中的结构化对象，没有人可以改变对象属性(包括它们的属性和值)。<code class="fe mw mx my mz b">Object.freeze</code>函数冻结了一个对象，使它变得不可变，如下面的代码片段所示:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">JavaScript中冻结功能的演示</figcaption></figure><p id="8c7e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个热心的读者可能会意识到<code class="fe mw mx my mz b">Object.freeze</code>在所讨论的对象的内在状态上工作，直接在运行时级别上实施限制。冻结对象会移除其可扩展性(添加新属性的能力)并锁定对象属性的属性，将它们的<code class="fe mw mx my mz b">writable</code>和<code class="fe mw mx my mz b">configurable</code>键设置为<code class="fe mw mx my mz b">false</code>。为了实现深度不变性，人们应该使用第三方库来完成这样的任务，或者自己编写实现(我推荐前者，因为库通常可以满足单个开发人员可以预见的更多边缘情况)。</p><h2 id="3e54" class="mk kt iq bd ku ml mm dn ky mn mo dp lc kf mp mq lg kj mr ms lk kn mt mu lo mv bi translated">功能属性</h2><p id="e6f0" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">任何函数属性，如果被理解为一个对象，就暴露了变异的可能性。为了简单起见，我假设通过(memory) <em class="me">引用</em>将对象传递给函数，通过<em class="me">值</em>传递原语。有趣的是，JavaScript允许使用函数名来重新分配函数参数，这显然在函数范围之外没有影响，遵循闭包内的命名规则。</p><h1 id="0999" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">类型脚本中的不变性</h1><p id="b783" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">TypeScript是JavaScript社区的一次飞跃，尤其是考虑到不变性的时候。通过利用编译时类型系统的存在，开发人员可以忘记指定和依赖运行时级别的限制，更不用说减少交付给最终用户的代码量了。该语言引入了类型化只读属性的概念来实现浅层不变性，如以下段落所示。</p><h2 id="4417" class="mk kt iq bd ku ml mm dn ky mn mo dp lc kf mp mq lg kj mr ms lk kn mt mu lo mv bi translated">只读修饰符</h2><p id="1f01" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">readonly修饰符处理类型和接口属性(包括类属性和类构造函数)。它有两种可用形式:</p><ul class=""><li id="bbfc" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated"><code class="fe mw mx my mz b">readonly</code>(其中应用了修饰符)，</li><li id="988b" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated"><code class="fe mw mx my mz b">-readonly</code>(移除修饰词)。</li></ul><p id="cd02" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在类级别上定义常量定义了上述修饰符的最明显的用法，更不用说在对象构造期间只赋值一次的不可变属性的偶然用法了。</p><h2 id="b34b" class="mk kt iq bd ku ml mm dn ky mn mo dp lc kf mp mq lg kj mr ms lk kn mt mu lo mv bi translated">只读类型族</h2><p id="e672" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">TypeScript的标准库包含以下支持浅层不变性的类型:</p><ul class=""><li id="4bf7" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated"><code class="fe mw mx my mz b">Readonly&lt;T&gt;</code>类型，它将<em class="me">只读</em>修饰符应用于泛型类型<code class="fe mw mx my mz b">T</code>的所有编译时属性，</li><li id="6031" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated"><code class="fe mw mx my mz b">ReadonlyArray&lt;T&gt;</code>类型，作为提供泛型<code class="fe mw mx my mz b">T</code>的只读数组的接口，</li><li id="850a" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated"><code class="fe mw mx my mz b">ReadonlySet&lt;T&gt;</code>类型，用作提供通用类型<code class="fe mw mx my mz b">T</code>的只读集合的接口，</li><li id="ad5f" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated"><code class="fe mw mx my mz b">ReadonlyMap&lt;K, V&gt;</code>类型，用作提供只读映射的接口，该映射具有通用类型<code class="fe mw mx my mz b">K</code>的键和通用类型<code class="fe mw mx my mz b">V</code>的值。</li></ul><p id="0675" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管由于TypeScript编译器中包含的某些优化，看起来像是<code class="fe mw mx my mz b">Readonly&lt;T&gt;</code>的类型等同于<code class="fe mw mx my mz b">ReadonlyArray&lt;T&gt;</code>的类型，但我总是建议选择专用(后一种)类型，尤其是在稍后使用<code class="fe mw mx my mz b">infer</code>关键字提取泛型类型时。我发现需要注意的是，<code class="fe mw mx my mz b">Object.freeze&lt;T&gt;</code>方法返回了<code class="fe mw mx my mz b">Readonly&lt;T&gt;</code>类型，这在JavaScript中冻结对象的概念和TypeScript中只读类型的概念之间架起了一座桥梁。</p><h2 id="152a" class="mk kt iq bd ku ml mm dn ky mn mo dp lc kf mp mq lg kj mr ms lk kn mt mu lo mv bi translated">深度不变性</h2><p id="532b" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">如前所述，<em class="me"> readonly </em>修饰符不强制深度不变性，因此开发人员应该使用第三方库来实现，或者编写自定义实现。我可以推荐类型<code class="fe mw mx my mz b">DeepReadonly</code>，作为<code class="fe mw mx my mz b">ts-essentials</code>库的一部分实现。我不建议花时间从头开始构建深度不变性的类型定义，除非开发人员完全理解TypeScript类型系统的许多复杂性。</p><h1 id="469c" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">不变性准则</h1><p id="9ba8" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">对一个项目中的一个对象应用不变性，对于任何开发人员来说都不会提供多少可度量的附加值，因此不变性需要集成到项目的核心架构原则中。软件专业人员应该在多大程度上实施这种模式仍然是一个有争议的问题，在我的职业生涯中，我在这个问题上已经有了自己的看法。我根据自己使用许多当代语言的经验，并考虑到我在函数式编程方面的漫长历程，收集了以下关于TypeScript开发的指南:</p><ul class=""><li id="c359" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">开发者应该用<code class="fe mw mx my mz b">const</code>关键字声明变量(之前已经解释过了)，</li><li id="782c" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">开发人员应该只在编译类型上使用不变性保证(前面已经解释过了)，</li><li id="329e" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">开发人员应该将类实例的使用限制在构造它的函数上，</li><li id="0467" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">开发人员应该使用<code class="fe mw mx my mz b">Readonly&lt;T&gt;</code>包装器类型(有或没有可变类型帮助器)为全局使用声明不可变类型，</li><li id="d319" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">开发人员应该通过从不可变类型中提取适当的子类型来声明可变类型以供本地使用(或者使用可变类型帮助器，无论哪个更容易)，</li><li id="39e0" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">浅层不变性提供了有效实施深层不变性的所有必要功能，</li><li id="e594" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">函数应该期望不可变的参数(对象和原语一样)，</li><li id="a9e1" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">函数应该返回不可变的值，</li><li id="c0e8" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">理想函数以纯粹的方式工作，没有副作用。</li></ul><p id="944b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了给上面收集的要点提供一个有根据的解释，我将从在创建类实例的方法中包含类实例的用法开始。类的概念与函数式编程的概念如不变性和函数纯度并不一致，但是，我不能阻止任何人使用面向对象的模式，因为它们带来了价值。因此，为了保持代码的可读性，如果可能的话，开发人员应该构造类实例(或原型实例)并在一个函数中使用它们，而不要将它们传递给其他函数。</p><p id="84ce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为全局(项目范围)空间声明不可变类型允许开发人员首先考虑不变性，并确保在有限的场景中显式地创建可变类型——如果需要，开发人员可以使用助手类型来构造更复杂的类型。系统中的大多数功能应该接受并产生不变的结构。为了向读者展示如何从不可变类型构建可变类型，我为这种转换定义了实用程序类型，如下所示:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">从只读类型中提取泛型类型的实用程序</figcaption></figure><p id="a200" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有了正确的思维模式，使用浅不变性类型应该允许开发人员获得与在<code class="fe mw mx my mz b">DeepReadonly</code>包装器类型中包装每个类型相同的结果。我还认为，在代码中处处使用深度不变性会迫使编译器在每次高引用类型发生变化时执行更复杂的计算，这可能会减少某些ide中操作的无缝性。最后，类型系统不需要保护开发人员不犯错误，只要所述开发人员以防御的方式开发他们的代码。</p><p id="c3cb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">纯函数(不产生副作用的函数)是函数式编程最重要的特征之一。为了在类型级别上加强纯洁性，开发人员应该将不可变的结构传递给这样的函数，将它们的返回类型作为不可变的类型，并且避免修改全局变量或执行全局可访问的可变代码。我写了一个片段，将所有相关的发现总结如下:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">关于TypeScript中不变性的大部分准则的示例</figcaption></figure><h1 id="15a5" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">重构</h1><p id="8da8" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">开始新的项目给了系统设计者许多尝试新范例的可能性，比如不变性，这在已经存在的项目中通常不会发生。即使对于经验丰富的开发人员来说，重构旧的代码库也可能是有问题的，因此软件专业人员应该总是提前计划这种项目范围的变化。我整理了一系列想法，说明如何通过指定开发人员应该:</p><ul class=""><li id="5f7a" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">将旧函数的返回类型更改为它们的不可变对应物，并修复类型问题，</li><li id="51e7" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">将旧函数的参数类型更改为它们的不可变对应物，并修复类型问题，</li><li id="28b6" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">使用浅层复制将不可变结构转换为可变结构，或者在失败的情况下，使用深层复制，</li><li id="1c4f" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">使用上述指南以不可变的方式编写新代码，</li><li id="add4" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">不完全信任编译器在转换期间显示所有潜在的错误，</li><li id="ec93" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">(很可能)依赖于产品化过程中的大量测试。</li></ul><p id="5c46" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使返回类型不可变是我所做的所有重构的第一步。它不需要对正在讨论的函数进行任何更改，因为编译器会根据协方差规则将任何可变的返回值提升为其不可变的对应值(与面向对象编程中完全一样，它将较宽的类型理解为较窄的类型)。使用上述函数返回值的函数需要:</p><ul class=""><li id="a111" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">浅层复制这些值以满足编译器，或者</li><li id="2a0a" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">以不同的方式调整代码。</li></ul><p id="6d84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不可变值到它们的浅不可变版本的转换可能使用在JavaScript的标准库中定义的已经可用的对象方法来进行:</p><ul class=""><li id="8488" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">对于物体<code class="fe mw mx my mz b">obj</code> - <code class="fe mw mx my mz b">Object.assign({}, obj)</code>或<code class="fe mw mx my mz b">{ ...obj }</code>，</li><li id="0177" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">对于阵列<code class="fe mw mx my mz b">arr</code> - <code class="fe mw mx my mz b">arr.slice()</code>或<code class="fe mw mx my mz b">[ ...arr ]</code>。</li></ul><p id="6d3f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我建议在使用<code class="fe mw mx my mz b">...</code>操作符之前，根据目标语言和所用的transpiler检查一下项目的翻译规则，因为一些优化可能不会产生高性能代码。任何开发人员都应该考虑到依赖于不变性的代码库有可能使用大量的浅层复制。</p><p id="3a1c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将函数参数类型提升到它们的不可变版本是第二步。与第一步相反，这种变化并不影响正在讨论的函数之外的代码(由于前面提到的协方差规则)。我写了一个片段，展示了如何重构一个使用可变参数的函数，如下所示:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">支持TypeScript中不变性概念的重构示例</figcaption></figure><p id="5622" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于性能原因，开发人员应该避免深度复制，尤其是在涉及大量对象时。如果存在一个函数，它接受一个对象并改变该对象中嵌套对象的一个属性，那么下面的观察可能适用:</p><ul class=""><li id="8616" class="lv lw iq jw b jx jy kb kc kf lx kj ly kn lz kr ma mb mc md bi translated">所使用的数据结构与它的用法不一致，那么它显然需要纠正(涉及潜在的重构)，</li><li id="041f" class="lv lw iq jw b jx mf kb mg kf mh kj mi kn mj kr ma mb mc md bi translated">正在讨论的函数应该期望嵌套的对象，而不是所述的对象(可能无法解决那里存在的架构问题)。</li></ul><p id="d883" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果开发人员想要对特定对象中的嵌套结构进行更改，我推荐阅读关于<em class="me">光学</em>的函数式编程概念(即<em class="me">透镜</em>和<em class="me">棱镜</em>)。<code class="fe mw mx my mz b">monocle-ts</code>库提供了这些思想的示例性实现。</p><p id="6b52" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我发现值得注意的是，引入不变性可能会暴露业务逻辑实现中先前存在的错误，不管有没有编译器的明确帮助。在任何项目中，开发人员都应该认识到工具链仅仅是一套增强他们工作流程的工具，仅此而已。我认为好的产品是那些覆盖了合理数量的有意义的测试的产品，这些测试有望确保最终用户的良好体验。</p><h1 id="0d33" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">摘要</h1><p id="8086" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">最后，我不会将不变性作为一个简单的概念应用于架构层面，尤其是在TypeScript中。这种设计模式本身并不能保证创建出优秀的软件，但是，根据我的经验，我相信它可以让许多开发人员理解由于不变性的范围因素而导致的变更的含义和局限性。由于我是函数式编程的坚定支持者，我也是上述概念的坚定支持者，但这并不意味着它可以无缝地与每一个可以想到的项目一起工作。</p></div></div>    
</body>
</html>