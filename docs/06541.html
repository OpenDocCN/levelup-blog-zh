<html>
<head>
<title>CI Pipelines and SemVer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CI管道和SemVer</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ci-pipelines-and-semver-391c0e1c15e7?source=collection_archive---------6-----------------------#2020-12-04">https://levelup.gitconnected.com/ci-pipelines-and-semver-391c0e1c15e7?source=collection_archive---------6-----------------------#2020-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="db97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">借助语义版本控制的命令配置项管道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/96df8b5630080cf1f96d0f282297ba2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fa59v24wmTs8dcaNeAfqEg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">semver cli决定管道</figcaption></figure><p id="9a37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">语义版本化(也称为<em class="lu"> SemVer </em>)是一个标准的版本化系统，已经被软件工程师和开发人员遵循了一段时间。这是为了保持应用程序的依赖关系图不变而引入的。</p><p id="f951" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过保持依赖图的完整性，应用程序可以保持稳定。为了做到这一点，语义版本标准被定义为一个三部分的数字，格式为<strong class="la iu"> X.Y.Z </strong>，其中</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/7188272c65720159133d86f0d27b24f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/0*1sHx5BKc9U_hbHlK.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">资料来源:geeksforgeeks.org</figcaption></figure><p id="b926" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时至今日，这种语义版本化标准几乎在所有语言和工件中都得到了广泛的遵循。从节点开始。JS npm包到Kubernetes发布版本。</p><p id="9de7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个循环中，在CI/CD管道中，根据正在运行的CI管道中的语义版本做出一些决策变得非常重要。例如，让我们深入一个简单的舵图场景。舵图打包成<code class="fe lw lx ly lz b">tgz</code>文件。当然，现在掌舵的包都是OCI的抱怨。这不会改变图表的过程和命名惯例。这些'<em class="lu"> tgz' </em>文件以图表的版本为后缀。这意味着打包图表的名称将是<code class="fe lw lx ly lz b">chart-name-x.x.x.tgz</code>。这是为了始终获取图表的最新版本，除非用户指定从图表注册表中获取该版本。</p><p id="d950" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上述场景要求开发人员将<code class="fe lw lx ly lz b">Chart.yml</code>文件中定义的图表版本与来自GitHub等源代码控制系统的发布分支的<code class="fe lw lx ly lz b">tag version</code>同步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/df1f774477f55f5183ca105d09b444c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rU1s_S7x9UfLhpTMEOlMvw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">管道中的semver cli剪切舵图的标记</figcaption></figure><p id="1632" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开源贡献者在贡献过程中经常遇到的问题是他们错过了图表的版本。或者他们错过了已经遵循了一段时间的版本标签逻辑。</p><p id="c46f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免这种情况，我们需要验证Chart.yml的版本和标记版本是否相同。类似地，在一些场景中，机器人需要提交代码并发布相同的版本。在这种情况下，我们需要一种简单的机制来进行语义版本化发布。</p><h1 id="46d7" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">我们如何做到这一点？</h1><p id="7176" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">因此，如果我们有一个简单的<strong class="la iu">二进制代码</strong>，以上所有这些都可以在流水线中实现。现在我们有了。</p><p id="3bd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="lu"> semver </em> </strong>是一个二进制程序，可以进行比较，也可以在semver标准中为我们增加版本。在Helm chart示例中，标记的CI作业需要验证版本，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">比较Chart.yaml中的GitHub发布标签和版本</figcaption></figure><p id="627b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的shell脚本显示了如何比较GitHub release标签和helm chart版本。在第5行，semver二进制码比较出<code class="fe lw lx ly lz b">$CHART_VERSION</code>和<code class="fe lw lx ly lz b">$TAG</code>相等。否则，semver将会死机并退出(1 ),在管道进程中抛出一个错误。</p><p id="056a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，将第一行替换为<code class="fe lw lx ly lz b">TAG: $(Build.SourceBranchName)</code>将从Azure DevOps管道中选取标签值。运行与上述相同的脚本将进行验证，如果不相等，则<em class="lu">退出(1) </em>至错误，如果相等，则<em class="lu">退出(0) </em>，为进一步运行流水线铺平道路。</p><h1 id="e244" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">永远</strong></h1><p id="c113" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><em class="lu"> semver </em>是一个简单的命令行包装器，位于来自<a class="ae na" href="https://github.com/Masterminds/semver" rel="noopener ugc nofollow" target="_blank"> Masterminds </a>的出色的semver包之上，使用<a class="ae na" href="https://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank"> Cobra </a> cli实用程序。</p><p id="b398" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该二进制文件可用于Linux、Windows、T21和Mac平台。要查看用法，只需输入<code class="fe lw lx ly lz b">semver</code>，将显示以下帮助信息</p><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="3eba" class="nf mc it lz b gy ng nh l ni nj">A cli to work with the semver for comparison and incrementing via command line.<br/>For example:<br/><br/>	$ semver inc 1.6.0-alpha.30 alpha<br/>will return 1.6.0-alpha.31<br/><br/>	$ semver inc 1.5.89 patch alpha<br/>will return 1.5.90-alpha<br/><br/>	$ semver greater 1.6.0-alpha.30 1.6.0-alpha<br/>will result in exit(0)<br/><br/>Usage:<br/>  semver [command]<br/><br/>Available Commands:<br/>  equal       Compares the equality of two given semver<br/>  greater     Compare two given semver<br/>  help        Help about any command<br/>  inc         Increments the semver against the given flag<br/>  lesser      Compare two given semver<br/><br/>Flags:<br/>  -h, --help      help for semver<br/>  -v, --verbose   verbose output<br/><br/>Use "semver [command] --help" for more information about a command.</span></pre><p id="c317" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要比较两个相等的版本，请提供如下所示的版本。如果两个版本相同，将退出(0 ),否则将退出(1)到</p><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="df9f" class="nf mc it lz b gy ng nh l ni nj">$ semver equal 1.6.8 1.6.8</span></pre><p id="73d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，为了验证LeftHandSide(LHS)版本是否大于RightHandSide(RHS)版本，可以使用以下子命令。</p><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="fccc" class="nf mc it lz b gy ng nh l ni nj">$ semver greater 1.4.5 0.3.9</span></pre><h1 id="5545" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">自动版本递增</h1><p id="7268" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><strong class="la iu"> semver </strong>也可用于自动增加提供组件引用字符串的版本。例如，<code class="fe lw lx ly lz b">semver inc 1.6.0 major</code>将增加所提供的<code class="fe lw lx ly lz b">1.6.0</code>中的主要版本，导致<code class="fe lw lx ly lz b">2.0.0</code>成为增加的版本。</p><p id="c35e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更多示例可在<a class="ae na" href="https://github.com/gkarthiks/semver" rel="noopener ugc nofollow" target="_blank">自述文件</a>中找到。欢迎以PRs或GitHub问题的形式投稿。</p><p id="0123" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，请通过拍手帮助其他人找到，并在这里和twitter上关注我以获取更多更新。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="bec8" class="mb mc it bd md me nr mg mh mi ns mk ml jz nt ka mn kc nu kd mp kf nv kg mr ms bi translated">参考:</h1><ul class=""><li id="5465" class="nw nx it la b lb mt le mu lh ny ll nz lp oa lt ob oc od oe bi translated"><a class="ae na" href="http://semver.org/" rel="noopener ugc nofollow" target="_blank">http://semver.org/</a></li><li id="46a7" class="nw nx it la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated"><a class="ae na" href="https://github.com/gkarthiks/semver" rel="noopener ugc nofollow" target="_blank">https://github.com/gkarthiks/semver</a></li><li id="5778" class="nw nx it la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated"><a class="ae na" href="https://github.com/Masterminds/semver" rel="noopener ugc nofollow" target="_blank">https://github.com/Masterminds/semver</a></li><li id="0e23" class="nw nx it la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated"><a class="ae na" href="https://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank">https://github.com/spf13/cobra</a></li></ul></div></div>    
</body>
</html>