# 一个自学成才的程序员的自白

> 原文：<https://levelup.gitconnected.com/confessions-of-a-self-taught-programmer-8b4aa8a99809>

## 对 20 多年的反思。

![](img/3ce39258ba1ef4c0828125b1f8103cab.png)

马修·费尼在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

我将在这里展示我的年龄，但是我在 1980 年左右在[的 Commodore 宠物电脑](https://en.wikipedia.org/wiki/Commodore_PET)上写了我的第一行代码。我学过一些课程，甚至去了大专学校学习编程和计算机技术。然而在现实中，我所知道的几乎所有编程知识都来自于艰苦的磨练——我不得不自学。

1999 年，我第一次被聘为专业开发人员，从那以后我一直从事这项工作。每一项任务都代表着一个新的机会去学习更多的东西，或者更深入地钻研我可能听说过的概念。

在我的职业生涯中，我自学了[设计模式](https://en.wikipedia.org/wiki/Software_design_pattern)、[修订控制](https://en.wikipedia.org/wiki/Version_control)、[数据结构&算法](https://en.wikipedia.org/wiki/Data_structure)、业务逻辑、模块化设计、数据库设计/管理、系统管理、邮件系统、网络工程、安全等等。我有机会深入研究这些领域中的大部分——在某一点上，我可以从内存中告诉您 IP 数据报的数据包结构，或 SMTP 协议。我可以和大多数经验丰富的开发人员保持一致，并对大多数编程主题有所了解。我甚至已经正式或非正式地教授过其中的一些话题。

我仍然深受冒名顶替综合症的折磨。

我经常怀疑自己是否足够优秀，这导致我对下一件事了解得足够详细，以至于可以轻松地用它来解决编码问题。但我有时觉得自己在追赶那些“真正的专家”。

有一次我建了一个系统“玩股市”。这是一个研究项目，教我 a)股票市场如何更详细地运作，以及 b)更深入地研究一些编程技术。这个系统没能让我赚到几百万。但是，我确实学到了更高级的编程方法。

大约 15 年前，我用 PHP 开发了股票市场工具。后来当我决定探索 [AI](https://en.wikipedia.org/wiki/Artificial_intelligence) 和[机器学习](https://en.wikipedia.org/wiki/Machine_learning) (ML)时，我用 Python 重新做了同样的工具。这次的目标是学习人工智能和人工智能——股票市场方面只是一个人工智能和人工智能可能应用的样本问题。这些天我学到了什么是 ML 和 AI，至少足够好地理解了它们的局限性以及如何在需要的时候实现它们。将来，我会更深入地研究神经网络。

今天，我发现自己在业余时间接了一个又一个项目，自学一些新的课题。我通过尝试创建一种更快的方法来建立 PHP 开发平台，并成功地学习了 Docker。我学了 Node。JS 部分是通过工作，部分是通过试图建立一个基于 [Laravel](https://laravel.com/) 类型系统的节点。通过这样做，我了解到 Node 不需要类似 Laravel 的系统。Laravel 中有一些很棒的技术是适用的(数据库迁移、命令行工具等)。)，但 Node 的用途与 Laravel 不同。我的努力得到了回报，教会了我很多关于 Node 的知识。

作为一名自学成才的程序员，我发现找工作非常困难。我经历过这个过程很多次，每次都遇到同样的挑战。如何将 20 多年的开发经验转化为对大学学位的需求？有些职位提供“或同等经验”，但不是全部。或者发布的内容非常具体——如果你从未使用过相关的语言或平台，你自然不适合这个角色。即使你有能力在短时间内学会该语言或平台。

当你自学时，你可能会被一些更学术性的问题绊倒。有一次，我被一位首席技术官叫去参加第二轮面试。他问的是排序算法。我有点困惑，因为我以为我申请的角色是负责调用现有 API 的*前端工作*。我的理解是基于本地语言的分类程序是最快/最有效的。毕竟，他们正在将输出呈现到浏览器中——繁重的工作应该在这之前完成。我受到了更大的压力，不得不解释说[冒泡排序](https://en.wikipedia.org/wiki/Bubble_sort)在逻辑上非常简单，可以在几分钟内完成编码，更有效的搜索应该是类似于[快速排序](https://en.wikipedia.org/wiki/Quicksort)的东西。这仍然不是被问到的问题。有人问我最快的排序算法是什么，我有一个明显的印象，当我不能马上回答这个问题时，我和他们相处的机会就消失了。一分钟后，谷歌证明了我的直觉是正确的，快速排序是(现在仍然是)最快的排序算法。我不知道他在那里寻找什么，但我只是把它写下来，作为我如果有传统学术背景就会“知道”的事情之一。

> 注意——有*次本地排序例程不够用。以我的经验来看，这通常是在你处理离线功能，需要浏览器来处理大型数据集的时候。在这些(罕见的)情况下，在客户端应用适当的数据结构是有意义的。*

人力资源游戏继续以其他方式困扰着我。像“ [*FizzBuzz 问题*](https://wiki.c2.com/?FizzBuzzTest)*”*或“编码测试”这样的愚蠢游戏让我感到沮丧，因为它们只是表面证明。我的简历显示了多年的经验，但我仍然被要求证明我的技能水平，这就好像我的 GitHub repos 或以前项目的代码片段没有给出任何我声称的指示。公平地说，人力资源专家不是编码专家，他确实需要一些方法来审查那些只知道如何通过认证测试的候选人。我觉得，如果我有负面的面试经历，我会质疑这是缺乏学术培训，还是只是不适合。

这些年来，我和一些伟大的人一起工作过，并且能够和传统的受过教育的人保持一致。“做”往往是优越的书本学习。理解为什么书上说这样做和知道什么是正确的方法一样重要。知道什么时候这本书不适合你的特殊情况也很重要。有时候，不管教科书怎么说，捷径*就是正确答案*。在我看来，拥有解释“黑客”相对于“学术上正确的方式”的利弊的背景是最好的经验之谈。

传统的学术培训对进入行业大有帮助。我不禁认为它总是会过时的(除了在研究特定的课程中)。大学和学院关注公司使用的工具。这意味着这些工具已经存在了一段时间，并获得了一些行业认可。然后有人围绕这些工具开发了一门课程，并开始教授它。因此，那个班的学生正在学习重要的技能，这些技能可能在他们进入市场的那一刻就过时了。

自学意味着我必须密切关注这个行业的兴衰。有时我在玩追赶游戏，有时我在玩新的代码，只有少数人(象征性地)知道它。对我来说，Laravel 就是其中之一。5 年前，我经常使用 Laravel，但在就业市场上很少被企业接受。今天，当我看 PHP 的帖子时，我看到很多人对 Laravel 感兴趣。你永远无法预测什么技术会被长期接受。这是自学的挑战，但也是自学的最大优势。努力跟上技术趋势会迅速扩展你的技能，你会开始看到同样的技术被一遍又一遍地使用。

我已经专业地写了 20 多年的代码。我的大部分知识都是自学的。我写过汇编，C/C++，Java，Cold Fusion，Visual Basic，C#，JavaScript，PHP 等等。其中一些是遥远的记忆，但有助于扩展我的基础。我会愉快地与我的同行讨论这些话题，并成功地编写代码来解决手头的问题。

考虑一个受过大学教育的开发人员。他们进入劳动力市场的那一刻，就有了一个基础。但是从那一点开始，就要靠他们来保持基础的更新和增加。开发人员和自学开发人员之间的唯一区别是初始基础和一张纸的范围。在所有情况下，开发者必须继续在他们的基础上工作。做不到这一点意味着增长停滞，变得无法就业。

那么我真的是冒名顶替的吗？

我假设没有，然后继续。到目前为止，我已经用这种方法有了一个很好的职业生涯，并将继续向前看。