<html>
<head>
<title>Developers Shouldn’t be Afraid of Deadlocks in SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发人员不应该害怕SQL Server中的死锁</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/developers-shouldnt-be-afraid-of-deadlocks-in-sql-server-8f8f4578675f?source=collection_archive---------0-----------------------#2021-08-07">https://levelup.gitconnected.com/developers-shouldnt-be-afraid-of-deadlocks-in-sql-server-8f8f4578675f?source=collection_archive---------0-----------------------#2021-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3d7b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">后端开发人员处理死锁的策略。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ccf518ef682bad21dfbfa2dad834dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*klkPwVBsVomiD2BG"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@kmuza?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Carlos Muza </a>拍摄的照片</figcaption></figure><p id="1118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在项目中使用MS SQL Server时，软件开发人员可能会遇到以下错误信息:</p><p id="0aa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">事务(进程ID 69)与另一个进程在锁资源上死锁，并被选为死锁牺牲品。重新运行交易。</em> </strong></p><p id="25b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在某些情况下，死锁可以简单地通过一个更改来修复，但死锁通常可能是低效的数据库设计甚至是应用程序架构的结果，并且可能需要开发人员付出许多努力来最小化它们。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="140c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#0564" rel="noopener ugc nofollow">什么是死锁？</a> <br/> <a class="ae ky" href="#07f1" rel="noopener ugc nofollow">受害者事务的重试逻辑</a> <br/> <a class="ae ky" href="#c4bd" rel="noopener ugc nofollow">如何最小化死锁？</a> <br/> ∘ <a class="ae ky" href="#e6f2" rel="noopener ugc nofollow">提高数据库性能</a> <br/> ∘ <a class="ae ky" href="#28f5" rel="noopener ugc nofollow">降低事务隔离级别</a> <br/> ∘ <a class="ae ky" href="#ff22" rel="noopener ugc nofollow">按相同顺序访问对象</a> <br/> <a class="ae ky" href="#34d4" rel="noopener ugc nofollow">限制并发事务数量</a> <br/> <a class="ae ky" href="#20b5" rel="noopener ugc nofollow">汇总</a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0564" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是死锁？</h1><p id="1d38" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当两个事务都在等待对方完成时，就会发生死锁，如果没有MS SQL server的干预，这种情况可能会无休止地继续下去。</p><p id="00ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过下面的示例来看看如何再现死锁:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e6de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">在这个例子中，死锁问题可以通过将事务降级到读提交隔离级别来解决。但是，会有更新丢失的问题。你可以在</em> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/transaction-isolation-levels-in-ms-sql-guide-for-backend-developers-6a5998e34f6c#b494"> <em class="lv">我的另一篇文章</em> </a> <em class="lv">中阅读更多关于丢失的更新。</em></p><p id="9bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在一个会话中启动第一个事务，然后立即在另一个会话中启动第二个事务，您将看到死锁错误消息，因为:</p><ul class=""><li id="04e4" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第一个事务开始并获取该行的共享锁(第9行),并持有它直到事务结束(共享锁在可重复读取隔离级别的事务结束时被释放)。</li><li id="b380" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">第二个事务启动并获取第一个事务锁定的同一行的共享锁(第18行)。</li><li id="cf1f" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">第一个事务试图获取一个排他锁(第11行),但是<strong class="lb iu">等待</strong>,直到第二个事务从该行释放共享锁。</li><li id="4c71" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">第二个事务试图获取一个排他锁(第19行)，但是<strong class="lb iu">等待</strong>直到第一个事务从该行释放共享锁。</li></ul><p id="2abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个事务都在等待对方从同一行释放共享锁，这是一个死锁问题。</p><p id="6109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与此同时，一个名为<strong class="lb iu"> LOCK_MONITOR </strong>的独立MS SQL server线程在后台检查所有活动锁的周期。</p><p id="5a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦锁监视器检测到死锁(循环)，它将执行以下操作:</p><ul class=""><li id="0138" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">选择其中一个事务作为受害者。</li><li id="cd0d" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">终止受害者事务。</li><li id="5e1f" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">回滚受害者事务所做的所有更改。</li></ul><p id="ddb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，牺牲事务是对数据库进行较少更改的事务，因此回滚会更便宜。但是，开发人员可以通过设置事务的死锁优先级来更改默认行为:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="5886" class="nv me it nr b gy nw nx l ny nz">SET DEADLOCK_PRIORITY LOW;</span></pre><p id="b93c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可用选项有低、正常或高。此外，优先级可以设置在-10到10之间。事务的默认优先级是正常的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="07f1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">受害者事务的重试逻辑</h1><p id="6a1f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当后端应用程序从数据库接收到死锁异常时，它可以向用户返回500错误。在这种情况下，用户将不得不手动重复他的动作一次或几次，直到它被服务器成功接受。</p><p id="bff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，用户体验是可以改进的，改进的提示在死锁错误消息中，即在第二句话中:</p><p id="cca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">事务(进程ID 69)被另一个进程死锁在锁资源上，并被选为死锁牺牲品。</em> <strong class="lb iu"> <em class="lv">重新运行交易。</em>T11】</strong></p><p id="b503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MS SQL server在检测到死锁后发出的错误消息提示我们重新运行受害者事务。重新执行的事务通常会成功，所以用户永远不会知道出错了。</p><p id="e1ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">项目的数据访问层应该能够使用线性或指数回退，在有限的尝试次数内重新运行受害者事务。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="31da" class="nv me it nr b gy nw nx l ny nz">private int retryCount = 3;<br/>private readonly TimeSpan delay = TimeSpan.FromSeconds(2);</span><span id="cc26" class="nv me it nr b gy oa nx l ny nz">private const int DeadlockErrorCode = 1205;</span><span id="f40f" class="nv me it nr b gy oa nx l ny nz">public async Task DatabaseCallWithRetryAsync()<br/>{<br/>    int currentRetry = 0;</span><span id="da10" class="nv me it nr b gy oa nx l ny nz">    for (; ;)<br/>    {<br/>        try<br/>        {<br/>            await ExecuteDatabaseCallAsync();<br/>            break;<br/>        }<br/>        catch (SqlException ex)<br/>        {<br/>            currentRetry++;</span><span id="ca9d" class="nv me it nr b gy oa nx l ny nz">            if (currentRetry &gt; retryCount ||<br/>                   ex.ErrorCode == DeadlockErrorCode)<br/>            {<br/>                throw;<br/>            }<br/>        }</span><span id="86b3" class="nv me it nr b gy oa nx l ny nz">        await Task.Delay(delay);<br/>    }<br/>}</span></pre><p id="a2c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/retry" rel="noopener ugc nofollow" target="_blank">重试模式</a>，您可以开发一个更加健壮和可用的应用程序。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c4bd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">如何最大限度地减少死锁？</h1><p id="71b1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">重新运行受害者事务并不是开发人员在试图缓解死锁问题时应该做的唯一事情。尽量减少死锁的数量很重要，因为死锁会导致性能问题和应用程序延迟。</p><h2 id="e6f2" class="nv me it bd mf ob oc dn mj od oe dp mn li of og mp lm oh oi mr lq oj ok mt ol bi translated">提高数据库性能</h2><p id="ceab" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当事务由于长时间运行SELECT、UPDATE或其他语句而长时间运行时，死锁的可能性会增加。语句执行的时间越长，它对正在处理的资源的锁定时间就越长。</p><p id="911a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">各种常见的数据库性能改进技术将降低死锁的可能性。这些技术包括:</p><ul class=""><li id="70a9" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">使用聚集索引、非聚集索引和覆盖索引。</li><li id="5d33" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">使用非规范化数据进行读取，使用规范化数据进行写入。</li><li id="7b8e" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">仅检索某些列并缩小查询谓词的范围。</li><li id="9ad3" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">对表列使用最小的数据类型。例如，<strong class="lb iu"> tinyint </strong>而不是<strong class="lb iu"> int </strong>就足以存储一个人的年龄。</li><li id="c0f5" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">没有光标。</li></ul><p id="0af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这些和其他方法将改善数据库的整体健康状况、性能、内存消耗和更少的死锁将是一个不错的奖励。</p><h2 id="28f5" class="nv me it bd mf ob oc dn mj od oe dp mn li of og mp lm oh oi mr lq oj ok mt ol bi translated">降低事务隔离级别</h2><p id="290a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">降低隔离级别可以提高性能，但另一方面，也会增加并发问题的可能性。虽然在最高的可序列化级别不会出现任何并发问题，但最低的未提交读取级别会遇到所有这些问题，例如脏读取、不可重复读取、更新丢失和幻影读取。</p><p id="d63e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">降低事务的隔离级别应该根据具体情况仔细考虑。例如，如果您的事务读取大量静态数据，您可以设置<strong class="lb iu"> read uncommitted </strong>隔离级别，而不用担心并发问题。只有当事务修改同时被另一个事务读取或修改的数据时，才可能出现并发问题，但静态数据永远不会改变。</p><p id="0214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以查看我的另一篇文章，以更好地理解事务隔离级别之间的差异:</p><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/transaction-isolation-levels-in-ms-sql-guide-for-backend-developers-6a5998e34f6c"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">MS SQL中的事务隔离级别:后端开发人员终极指南</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">选择正确的事务隔离级别是设计和开发过程中的一个重要部分</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><h2 id="ff22" class="nv me it bd mf ob oc dn mj od oe dp mn li of og mp lm oh oi mr lq oj ok mt ol bi translated">以相同的顺序访问对象</h2><p id="4a19" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当并发事务以相同的顺序访问对象时，死锁情况不太常见。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，死锁的根本原因在于事务访问两个表的顺序。</p><ul class=""><li id="bf41" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第一个事务开始并获得用户行的一个独占锁(第10行)。独占锁将保持到事务结束。</li><li id="c84d" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">第二个事务开始并获得admin行的独占锁(第17行)。独占锁将保持到事务结束。</li><li id="13d4" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">第一个事务继续执行，并试图获取被第二个事务阻塞的管理行(第12行)的锁。</li><li id="4f59" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">第二个事务继续执行，并试图获取被第一个事务<strong class="lb iu">阻塞的用户行(第18行)的锁。</strong></li></ul><p id="088a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与第一个事务相比，第二个事务以相反的顺序访问表，在第二个事务中简单地交换两个update语句(第17行和第18行)将消除死锁。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="34d4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">限制并发事务的数量</h1><p id="f3e7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">重试逻辑和应用技术来最小化死锁的数量可以在一定程度上帮助处理死锁问题。但是，在一些高负载的应用程序中，死锁仍然会导致性能问题，减少死锁的唯一方法是重新设计应用程序。</p><p id="2acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在具有大量长时间运行的并发事务的应用程序中，重试后的受害者事务可能会第二次陷入死锁，被选为受害者，以此类推。受害者事务可能会超过有限的重试次数，因此它不会将其更改应用到数据库。</p><p id="5c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果后端接收到用户请求并立即启动数据库调用来处理这些请求，那么所描述的场景是可能的。</p><p id="b9d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多并发请求将导致相同数量的并发数据库事务，这将锁定共享资源并导致死锁。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/427374c03dbe730e921fdac5fc18d13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*4FF6j-LoK52CaKon_1UdLg.png"/></div></figure><p id="1909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种架构无法扩展。可伸缩性差的一个标志是常规的数据库死锁。</p><p id="6429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，一个可能的解决方案是减少并发数据库事务的数量，这可以通过使用<strong class="lb iu">队列</strong>来实现。</p><p id="faca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个流程将发生如下变化:</p><ul class=""><li id="0353" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">用户向后端应用程序提交请求。</li><li id="711c" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">后端服务向队列发布消息，队列可以是简单的内存队列，也可以是RabbitMQ这样的独立队列，并向用户返回响应。</li><li id="6e14" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">单独的线程(在内存队列的情况下)或微服务(在独立队列的情况下)从队列中读取传入的消息，并启动数据库事务来处理该消息。</li><li id="0f25" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">在处理完消息并完成事务后，服务可以开始处理队列中的下一条消息。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/c1036db3a4b2229a5574b3da043ef53d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*EximZSO4rDGuvlBLYSVdfw.png"/></div></figure><p id="bd3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理用户请求的基于队列的方法允许应用程序控制并发事务的数量，甚至将它们限制为一次一个事务(每个用户或其他类别)，因此死锁的可能性可以大大降低。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="20b5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">摘要</h1><ul class=""><li id="a407" class="nc nd it lb b lc mv lf mw li pg lm ph lq pi lu nh ni nj nk bi translated">死锁是关系数据库中的自然现象，无法完全避免。</li><li id="3c0f" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">后端应用程序应该使用重试模式重新运行受害者事务。</li><li id="8468" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">提高数据库性能、降低事务隔离级别、以相同的顺序访问对象可以最大限度地减少死锁。</li><li id="1c2d" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">使用队列处理用户请求允许应用程序控制并发事务的数量，这提高了可伸缩性。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="e17e" class="nv me it bd mf ob oc dn mj od oe dp mn li of og mp lm oh oi mr lq oj ok mt ol bi translated">我的其他文章</h2><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/fast-database-fast-application-useful-db-performance-optimization-techniques-34b6926d1196"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">快速数据库—快速应用程序(有用的数据库性能优化技术)</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">了解加速关系数据库的最佳实践。</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oy l"><div class="pj l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/50-software-engineering-best-practices-for-technical-leaders-and-seniors-cfcdf6a17e44"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">面向技术领导者和资深人士的50个软件工程最佳实践</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">最佳工程师的最佳实践。</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oy l"><div class="pk l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">5种免费提高C#代码性能的方法</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">慢速代码是可选的。</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oy l"><div class="pl l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>