<html>
<head>
<title>Python Auto-instrumentation with OpenTelemetry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenTelemetry的Python自动仪器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-auto-instrumentation-with-opentelemetry-ccd603c665af?source=collection_archive---------6-----------------------#2020-05-12">https://levelup.gitconnected.com/python-auto-instrumentation-with-opentelemetry-ccd603c665af?source=collection_archive---------6-----------------------#2020-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/130f6474f4b66c14f38824ab85b67216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kfiz3DNYfj0N0-V3wQ1img.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">艾米·利·巴纳德在<a class="ae kc" href="https://unsplash.com/s/photos/telescope?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="37e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都经历过。您想开始使用分布式跟踪，但是没有时间重新查看系统中的几十个服务的代码库。别担心，OpenTelemetry会保护你。由于来自许多组织成员的巨大社区努力，OpenTelemetry项目已经能够快速提升其自动检测许多广泛使用的第三方库的各种语言代码的能力。</p><h1 id="5f20" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么选择自动仪器？</h1><p id="0440" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于许多组织的工程团队来说，使用分布式跟踪并因此使操作员的生活至少改善10，000倍的最大障碍是检测系统所需的时间。自动插装通过直接挂钩到现有代码来帮助减轻这一负担。借助自动化仪器，工程师可以</p><ul class=""><li id="c05d" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">只需对代码进行少量(如果有)更改，即可实现插装</li><li id="1035" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">了解图书馆正在做什么，而不必先了解所有细节</li><li id="8e94" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">期望利用这些库的应用程序之间有一致的插装</li></ul><p id="c36a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">插装是在应用程序中开发<a class="ae kc" href="https://lightstep.com/observability" rel="noopener ugc nofollow" target="_blank">可观察性</a>的第一步，它给了开发人员询问关于他们代码的有意义问题的超能力。</p><h1 id="e17d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我如何使用它？</h1><p id="7de9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我可以不停地谈论自动化仪表如何让生活变得更好、更容易，但是还有什么比尝试更好的方法来证明这一点呢？以下示例将介绍如何使用OpenTelemetry检测Python应用程序。如果您已经有了一个使用任何支持库的应用程序，请随意跳过这一步，直接进入配置导出器一节。</p><p id="2dd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们将创建一个接收web请求并向上游发出请求的小应用程序。</p><h1 id="ce54" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">要求</h1><ul class=""><li id="124d" class="me mf iq kf b kg lz kk ma ko ms ks mt kw mu la mj mk ml mm bi translated">使用OpenTelemetry需要Python 3.4以上版本</li><li id="3fae" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">如果你想在本地运行Jaeger，Docker是必需的</li></ul><h1 id="4981" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">这个例子</h1><p id="7faa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，我们将安装我们的应用程序将使用的Python包:</p><p id="99ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将下面的代码保存在新文件<code class="fe mv mw mx my b">server.py</code>中。你可以在<a class="ae kc" href="https://github.com/lightstep/opentelemetry-examples/tree/master/python/auto-instrumentation" rel="noopener ugc nofollow" target="_blank">light step/open telemetry-examples</a>repo中找到这个例子的所有代码。</p><p id="f61f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">注意:这可能是有史以来最差的代理服务器</em><em class="mz"/></p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="3db1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">配置导出器</h1><p id="ff4f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们将在本地运行一个<a class="ae kc" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank">积家</a>后端来收集和显示追踪信息。如果您的环境中已经有Jaeger在运行，您可以跳过以下步骤:</p><pre class="na nb nc nd gt ng my nh ni aw nj bi"><span id="7e0b" class="nk lc iq my b gy nl nm l nn no">docker run --name jaeger -d -p 6831:6831/udp -p 16686:16686 jaegertracing/all-in-one:latest</span></pre><p id="bd67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了允许我们的应用程序将其遥测具体化，我们需要将OpenTelemetry配置为使用导出器。</p><p id="6452" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们之前创建的<code class="fe mv mw mx my b">server.py</code>文件的顶部附近插入以下代码。</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="50ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将通过<code class="fe mv mw mx my b">pip</code>安装自动仪器包和Jaeger exporter包。</p><pre class="na nb nc nd gt ng my nh ni aw nj bi"><span id="2f15" class="nk lc iq my b gy nl nm l nn no">pip3 install opentelemetry-instrumentation opentelemetry-exporter-jaeger opentelemetry-instrumentation-flask</span></pre><p id="3bd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在准备运行我们的应用程序！打开一个终端，用我们的应用程序作为参数运行<code class="fe mv mw mx my b">opentelemetry-instrument</code>可执行文件。</p><p id="a568" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">注意:我们正在导出一个环境变量来将OpenTelemetry TracerProvider设置为opentelemetry-sdk的TracerProvider。在启动自动检测之前对其进行配置，可以确保所有检测都将使用相同的TracerProvider。</em></p><pre class="na nb nc nd gt ng my nh ni aw nj bi"><span id="aa0a" class="nk lc iq my b gy nl nm l nn no">export OTEL_PYTHON_TRACER_PROVIDER=sdk_tracer_provider<br/>opentelemetry-instrument ./server.py</span></pre><p id="c33c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在另一个终端中，我们将向我们的应用程序发出一些请求。其中一个请求通过代理，这会导致响应延迟。</p><pre class="na nb nc nd gt ng my nh ni aw nj bi"><span id="22de" class="nk lc iq my b gy nl nm l nn no">curl -s "localhost:5000/?url=https://en.wikipedia.org/wiki/Mars"  &gt; /dev/null</span><span id="bf8e" class="nk lc iq my b gy np nm l nn no">curl -s "localhost:5000/?url=http://slowwly.robertomurray.co.uk/delay/3000/url/http://www.google.com" &gt; /dev/null</span><span id="f757" class="nk lc iq my b gy np nm l nn no">curl -s "localhost:5000/cache"  &gt; /dev/null</span></pre><h1 id="59f9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">看着这些痕迹</h1><p id="497f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">激动人心的部分来了。让我们到<a class="ae kc" href="http://localhost:16686/" rel="noopener ugc nofollow" target="_blank"> http://localhost:16686/ </a>的Jaeger界面中搜索踪迹。马上，我们可以看到我们对应用程序发出的所有请求的踪迹，我们编写了<strong class="kf ir"> ZERO </strong>检测代码。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/dd6d9844528aa7b39728dcf0375bd6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bu5Qsw-P6-f_frir.png"/></div></div></figure><p id="45b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过自动检测可以获得的一条有价值的信息是附加在每个库的跨度上的标签。在下面的例子中，确定应用程序响应缓慢的根本原因变得很简单。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/fbf6d7d82cf7bb917086473d6deab7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r7lcG7VuZWUp_U_5.png"/></div></div></figure><h1 id="45ef" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自动仪器的限制</h1><p id="0e10" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">自动插装与它插装的库紧密耦合。如果一个应用程序依赖于自动化工具尚不支持的库，将不会获得额外的洞察力。令人欣慰的是，OpenTelemetry项目中有很多人每天都在努力增加受支持库的数量。花些时间通读一下<a class="ae kc" href="https://opentelemetry.io/registry/" rel="noopener ugc nofollow" target="_blank">注册表</a>，看看支持的语言和框架。有一个你正在使用的框架，但在注册表中看不到它？在项目中创建一个问题，让我们合作解决它！在<a class="ae kc" href="https://opentelemetry.io/" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry.io </a>关注项目，了解最新消息。</p><p id="0fac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是什么？开始追踪！自动检测可能永远不会像手动检测那样彻底，但是它是您的可观察性之旅的一个很好的起点。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="624b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">2020–08–28:更新以反映opentelemetry-python 0.12b0中的变化</em></p><p id="2b46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz"> 2020年6月11日:更新以反映opentelemetry-python 0.9b0 </em>中的变化</p><p id="aba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz">最初发表于</em><a class="ae kc" href="https://lightstep.com/blog/python-auto-instrumentation-with-opentelemetry/" rel="noopener ugc nofollow" target="_blank">T5【https://lightstep.com】</a><em class="mz">。</em></p></div></div>    
</body>
</html>