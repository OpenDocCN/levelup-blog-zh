<html>
<head>
<title>Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functions-in-javascript-20fc230a0327?source=collection_archive---------7-----------------------#2020-03-24">https://levelup.gitconnected.com/functions-in-javascript-20fc230a0327?source=collection_archive---------7-----------------------#2020-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/427f423b2959ac110af95821d924f42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H2nQbHPN68BCGQuv"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">艾莉·史密斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="63fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数是一组可重用的代码，可以在程序中的任何地方调用。这消除了反复编写相同代码的需要。它帮助程序员编写模块化代码。函数允许程序员将一个大的程序分成许多小的、易管理的函数。</p><p id="7b0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们讨论一下函数的类型以及如何使用:</p><p id="16e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">函数声明<br/> </strong>函数A(){ }；</p><p id="631c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">函数表达式</strong><br/>var B = Function(){ }；</p><p id="fccf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">带分组运算符的函数表达式</strong><br/>var C =(Function(){ })；</p><p id="d0ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">命名函数表达式</strong>T15】var D = Function foo(){ }；</p><p id="01b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">life</strong><br/>var E =(function(){<br/>return function(){ }<br/>}))；</p><p id="83f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">函数构造器</strong><br/>var F = new Function()；</p><p id="828c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">特例:对象构造器</strong><br/>var G = new function(){ }；</p><p id="4f21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> ES6箭头功能</strong><br/>var H = x =&gt;x * 2；</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="2c78" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">函数声明</h1><p id="751d" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">函数声明可能是JavaScript领域中最熟悉和最古老的方式。这就创建了一个在当前范围内可访问的变量A。</p><p id="f404" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">提升</strong> <br/>有趣的是，它们被“提升”到了自己作用域的顶端:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b974" class="mx lm it mt b gy my mz l na nb">A();</span><span id="171f" class="mx lm it mt b gy nc mz l na nb">function A() {<br/>  console.log(‘foo’);<br/>};</span></pre><p id="0763" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码执行如下:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="682d" class="mx lm it mt b gy my mz l na nb">function A() {<br/>  console.log(‘foo’);<br/>};</span><span id="b1dc" class="mx lm it mt b gy nc mz l na nb">A();</span></pre><p id="6ce0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着，您可以在将函数写入代码之前调用它们。这无关紧要，因为整个函数都被提升到了其包含范围的顶部。(这与变量相反，变量只提升声明，而不提升内容)。</p><p id="e0a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">if语句中没有函数声明(或循环等)</strong> <br/>您不能在表达式中以这种方式定义函数，例如if语句，这是常见的，如果我们想为不同的情况定义不同版本的函数，通常是为了解决浏览器的不一致性。嗯，你<em class="nd">在某些实现中可以</em>，但是代码处理的方式不一致。如果您想使用这种模式，请改用函数表达式。</p><p id="af91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">函数声明必须有名字</strong> <br/>这个方法不允许你创建匿名函数，这意味着你必须给它一个标识符(在这个例子中我们用了“A”)。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="907f" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">函数表达式</h1><p id="50bb" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">函数表达式看起来类似于函数声明，除了函数被赋予一个变量名。虽然函数不是JavaScript中的原始值，但这是在这种函数式语言中充分利用它们的方式。</p><p id="1428" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript支持将函数作为参数传递给其他函数，将它们作为其他函数的值返回，并将它们赋给变量或存储在数据结构中。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="80a7" class="mx lm it mt b gy my mz l na nb">var B = function(){};</span></pre><p id="d94b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">匿名函数(它们不需要名字)</strong> <br/>函数名在函数表达式中是可选的，我们称这些为匿名。在上面的例子中，我们将变量B设置为一个匿名函数。</p><p id="d30c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">变量声明提升</strong>所有变量都会发生这种情况，这意味着我们的函数也会发生这种情况，现在我们把它们赋给变量。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ed2a" class="mx lm it mt b gy my mz l na nb">var A = function() {...};<br/>var B = function() {...};<br/>var C = function() {...};</span></pre><p id="ac67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述代码将被执行为</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4a34" class="mx lm it mt b gy my mz l na nb">var A, B, C; // variable declarations are hoisted</span><span id="04c1" class="mx lm it mt b gy nc mz l na nb">A = function() {...};<br/>B = function() {...};<br/>C = function() {...};</span></pre><p id="49a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，设置和调用此类函数的顺序非常重要:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c276" class="mx lm it mt b gy my mz l na nb">// this works<br/>var B = function() {};<br/>B();</span><span id="318d" class="mx lm it mt b gy nc mz l na nb">// this doesn’t work<br/>B2(); // TypeError (B2 is undefined)<br/>var B2 = function() {};</span></pre><p id="6a77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个例子给了我们一个错误，因为只有变量B2的声明被提升，而不是定义，因此“未定义”的错误。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="4aad" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">带分组运算符的函数表达式</strong></h1><p id="f97f" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这些真的和普通的旧函数表达式没有什么不同，在野外也看不到。让我们看看发生了什么:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5dd2" class="mx lm it mt b gy my mz l na nb">var B = (function() {});</span></pre><p id="2e85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当JavaScript引擎遇到这里的左括号时，我们实际上是在说“开始把它和其他东西组合在一起”。我们告诉引擎我们不是在做一个函数声明，而是一个函数表达式。然后将结果赋给一个变量:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="fa55" class="mx lm it mt b gy my mz l na nb">(function(){});  //resulting function not assigned</span><span id="b6a1" class="mx lm it mt b gy nc mz l na nb">var foo = (function(){}); //resulting function assigned to foo</span><span id="53a0" class="mx lm it mt b gy nc mz l na nb">var bar = function(){};  //resulting function assigned to bar</span></pre><p id="5353" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们可以看到foo和bar实际上是一样的，因为在foo中，除了函数本身之外，我们没有将函数组合在一起。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="f63a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">命名函数表达式</h1><p id="0faf" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这里，我们不是将变量赋给匿名函数，而是赋给一个命名函数。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9a76" class="mx lm it mt b gy my mz l na nb">var D = function foo() {};</span></pre><p id="751a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">函数名只能在函数<br/> </strong>中访问，我们没有将函数名(foo)暴露给封闭作用域(这里是全局作用域):</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="23c1" class="mx lm it mt b gy my mz l na nb">var D = function foo() {<br/>  console.log(type of foo);<br/>};</span><span id="898f" class="mx lm it mt b gy nc mz l na nb">D();                      // function<br/>console.log(typeof foo);  // undefined</span></pre><p id="3d11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">对递归有用<br/> </strong>因为函数名可以在函数本身中访问，所以这对递归函数很有用。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="755d" class="mx lm it mt b gy my mz l na nb">var countdown = function a (count) {<br/>  if (count &gt; 0) {<br/>    count--;<br/>    return a(count);  //we can also do this: a(--count)<br/>  }<br/>  console.log(‘End of recursive function’);<br/>}</span><span id="ec6b" class="mx lm it mt b gy nc mz l na nb">countdown(5);</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="e043" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">立即调用函数表达式(life)</strong></h1><p id="a13a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">执行这个函数，它的返回值是另一个函数，并将它赋给变量。这种模式非常强大，并且有很多有用的应用。其中最著名的是模块模式。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bae3" class="mx lm it mt b gy my mz l na nb">var E = (function() {<br/>  return function(){<br/>    ...<br/>  }<br/>})();</span></pre><p id="cbf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经学习了上面的分组操作符，所以你应该觉得这是等价的。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3dd8" class="mx lm it mt b gy my mz l na nb">var foo = function() {<br/>  return ‘bar’;<br/>};</span><span id="cffa" class="mx lm it mt b gy nc mz l na nb">var output = foo();</span><span id="bc39" class="mx lm it mt b gy nc mz l na nb">console.log(output); //bar</span></pre><p id="4aeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于foo指向我们的函数表达式，我们知道我们可以简单地避免使用变量“foo ”,并将整个函数作为匿名函数放入(毕竟函数是第一类的！).</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0e6e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">函数构造函数</h1><p id="9378" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这种方法非常古老，不建议使用。您在前面传入无限数量的参数，然后实际的函数体在最后一个参数中显示为一个字符串(因为它是一个字符串，它实际上相当于eval()，不推荐使用)。</p><p id="b770" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">定义函数<br/> </strong>你可以创建这样一个函数</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a571" class="mx lm it mt b gy my mz l na nb">var F = new Function('arg1', 'arg2', 'console.log(arg1 + ", " + arg2)');</span><span id="f648" class="mx lm it mt b gy nc mz l na nb">F('foo', 'bar');  // 'foo, bar'</span></pre><p id="8e98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">不需要新的运算符<br/>T5】你可以简单的写var F = Function()；得到同样的结果。</strong></p><p id="c630" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">怪癖</strong></p><p id="cf88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着它们不能访问其封闭范围内的变量，这不是特别有用:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6f47" class="mx lm it mt b gy my mz l na nb">function foo() {<br/>  var bar = 'blah';<br/>  var first = new Function('console.log(typeof bar)');<br/>  <br/>  first();   // undefined<br/>  <br/>  var second = function(){<br/>    console.log(typeof bar);<br/>  }<br/>  second();  // string<br/>}</span><span id="8d82" class="mx lm it mt b gy nc mz l na nb">foo();</span></pre><p id="ab2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在函数“first”中，我们使用了函数构造函数，所以它不能访问变量栏。然而，如果我们使用函数“second”，这是一个函数表达式，它实际上可以访问其封闭范围内定义的变量(通过闭包)。</p><p id="8153" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">换句话说，<em class="nd">不要使用函数构造器</em>。</strong></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="14fe" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">特例—对象构造器</h1><p id="a451" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在这种情况下，我们并没有真正定义一个函数，尽管我们使用了function关键字。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bdb8" class="mx lm it mt b gy my mz l na nb">var G = new function() { ... };</span></pre><p id="6f7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="nd">新功能(){ }；</em> </strong>创建一个新对象，并调用匿名函数作为其构造函数。如果从函数中返回一个对象，则该对象成为结果对象，否则将从头创建一个新对象，并在该新函数的上下文中执行函数。</p><p id="002a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以这种形式来看，有点不寻常。让我们用正确的方式来做:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2e5c" class="mx lm it mt b gy my mz l na nb">var Person = function(){<br/>  console.log(this);  // Person<br/>}<br/>var joe = new Person();</span></pre><p id="a63a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以实际上对于新的操作符，我们给它一个新的“this”上下文，然后用这个新的上下文执行给定的函数。与我们之前讨论的函数定义有很大不同。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="a543" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">箭头功能</h1><p id="9285" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">随着ES6的加入，出现了这些所谓的“胖箭头”功能，或者如果你喜欢精简的版本，就简单地称为“箭头功能”。</p><p id="7750" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">箭头函数没有带来全新的功能，而是提供了一些语法上的好处，这意味着最终我们开发人员将不得不输入更少的代码来达到同样的结果。</p><p id="1665" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">箭头函数在以前有单行函数的情况下特别方便，比如ES5 JavaScript:</p><p id="de8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个例子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b961" class="mx lm it mt b gy my mz l na nb">[1, 2, 3].map(function(x) {return x * 2});<br/>// [2, 4, 6]</span></pre><p id="1c3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述情况，现在我们可以写成如下:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="48a4" class="mx lm it mt b gy my mz l na nb">[1, 2, 3].map(x =&gt; x * 2);<br/>// [2, 4, 6]</span></pre><p id="9979" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">箭头函数的第二个好处是它们保留了上下文，这非常方便。通常，试图在JavaScript中保持作用域是一项乏味的任务，通常是通过使用bind()。但这让我们可以绕过它，少写点。</p><p id="8d6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再举一个例子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6bd6" class="mx lm it mt b gy my mz l na nb">function multiply(array) {<br/>  this.multiplier = 2;<br/>  return array.map(function(x) {return x * this.multiplier});<br/>};<br/><br/>var fakeContext = {};<br/><br/>multiply.call(fakeContext, [1, 2, 3]);<br/>//[NaN, NaN, NaN]</span></pre><p id="f367" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不起作用是因为乘法函数的<strong class="ki iu"> <em class="nd"> this </em> </strong>上下文没有保存在<strong class="ki iu"> <em class="nd"> map() </em> </strong>函数中，迫使我们稍微重写一些东西，通过在<strong class="ki iu"><em class="nd">【multiple()</em></strong>(如<strong class="ki iu"> <em class="nd"> var self = this </em> </strong>)中定义一个变量或者通过使用<strong class="ki iu"><em class="nd">【bind()</em></strong>来保存函数上下文。</p><p id="a382" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，使用一个箭头函数，我们知道我们的上下文将被保留，允许我们用一个小的调整来写:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="09d2" class="mx lm it mt b gy my mz l na nb">function multiply(valuesArray) {<br/>  this.multiplier = 2;<br/>  return valuesArray.map(x =&gt; x * this.multiplier);<br/>};<br/><br/>var fakeContext = {};<br/><br/>multiply.call(fakeContext, [1, 2, 3]);<br/>// [2, 4, 6]</span></pre><p id="e8d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇<a class="ae kf" href="https://medium.com/@kanth.vallampati/learning-javascript-es6-arrow-functions-a3bf9caaecee" rel="noopener"> ES6箭头功能</a>的文章有详细的解释。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="e36d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><p id="e9ef" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">函数是脚本的主要组成部分。</p><ul class=""><li id="4a9d" class="ne nf it ki b kj kk kn ko kr ng kv nh kz ni ld nj nk nl nm bi translated">函数定义被提升了——表达式没有。</li><li id="394b" class="ne nf it ki b kj nn kn no kr np kv nq kz nr ld nj nk nl nm bi translated">函数在被调用时被执行。这就是所谓的<strong class="ki iu"> <em class="nd">调用</em> </strong>一个函数。</li><li id="2bef" class="ne nf it ki b kj nn kn no kr np kv nq kz nr ld nj nk nl nm bi translated">值可以通过<strong class="ki iu"><em class="nd"/></strong>传入函数并在函数内使用。该值的名称称为参数。实际值本身称为自变量。</li><li id="153b" class="ne nf it ki b kj nn kn no kr np kv nq kz nr ld nj nk nl nm bi translated">功能<strong class="ki iu"> <em class="nd">总是</em> </strong> <code class="fe ns nt nu mt b">return</code>的一个值。在JavaScript中，如果没有指定<code class="fe ns nt nu mt b">return</code>值，函数将默认返回<code class="fe ns nt nu mt b">undefined</code>。</li><li id="9124" class="ne nf it ki b kj nn kn no kr np kv nq kz nr ld nj nk nl nm bi translated">功能有<strong class="ki iu"> <em class="nd">对象</em> </strong>。</li></ul></div></div>    
</body>
</html>