# 在 go 1.18 泛型中使用单子(第 1 部分—也许)

> 原文：<https://levelup.gitconnected.com/using-monads-with-go-1-18-generics-part-1-maybe-bb42d3e09968>

![](img/33b53d345a2b1b392146d75034bfcdc1.png)

Go 1.18 为 Go 编程语言引入了期待已久的泛型。这次更新为类型安全编程增加了许多新的可能性。

其中一种可能性是使用一种众所周知的模式，这种模式来自函数式编程，称为 monads。单子是一种将你的计算包装在容器中的方法，容器将你的计算粘合在一起，在这个过程中产生一些效果。例如，在 Haskell 中你不能直接执行任何副作用——你需要将它们包装在 IO monad 中，这一点我们将在后面讨论。

让我们从最简单的单子开始——也许吧。也许是一个容器，要么有值，要么什么都没有。它有一些方法，允许我们将它们组合在一起，过滤，并从中获取值。

这个接口有两个实现——一个用于我们有价值的情况，另一个用于我们一无所有的情况。

链接计算的最简单方法是使用 Map 和 FlatMap:

Map 采用任何取值并返回值的函数并将此函数应用于我们的 Maybe 值 m，如果 m 有值，它就对其运行函数，如果没有值，它什么也不做。这样，如果我们有一个很长的计算序列，其中第一个可能失败并且不返回任何东西，我们就不必在过程中的每一站都编写 if 检查。

FlatMap 以同样的方式工作，但是对于一个也返回 Maybe 的函数。

还有一些实用方法，如 IsPresent，它对 Just 返回 true，对 Nothing 返回 false。

现在让我们看一些实际例子，看看如何使用 monad 来减少代码混乱。

假设我们有以下的划分顺序:

x := a / b

y := c/x

z := d/ y

b 和 d 可以是零，x 和 y 也可以是零。

下面是我们如何使用 if 语句来实现它:

可能用单子:

可能是单子的完整代码:

您可以在 [go-monads github repo](https://github.com/OlegStotsky/go-monads) 中找到这些代码以及其他 monads 的代码。在本系列的下一篇文章中，我们将关注木卫一。敬请期待！