<html>
<head>
<title>The Go Microservice Toolkit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go微服务工具包</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-golang-microservice-toolkit-7521516ee4b?source=collection_archive---------1-----------------------#2021-01-06">https://levelup.gitconnected.com/the-golang-microservice-toolkit-7521516ee4b?source=collection_archive---------1-----------------------#2021-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="17f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">很多年来，我认为自己是一个语言无关的软件开发人员，因为当谈到编程语言时，我总是优先掌握基础知识和学习新概念，而不是“偏爱”。在我15年的职业生涯中，我编写了数千行跨多种语言的代码(例如，<em class="ku"> Java </em>、<a class="ae kv" href="https://georgefrancisjr.medium.com/the-essential-scala-toolkit-1fd2e43220a9" rel="noopener">T5】Scala</a>、<em class="ku"> Go、</em>等)。).直到我掌握了Go <em class="ku"> </em>之后，我才意识到:选择正确的语言很重要。我成了一个真正的忠诚者；今天，它是我最喜欢的语言。它的简单和优雅，加上它强大的并发范例，使它成为下一代分布式服务的完美选择。</p><p id="fbf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了表达我对这门语言的热爱，我开发了一个工具包来帮助其他希望使用to power微服务的开发人员。</p><p id="0039" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1。REST + gRPC:创造完美婚姻</strong></p><p id="ded0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微服务通常有REST、<em class="ku"> </em> gRPC <em class="ku">等HTTP或RPC框架做后盾。</em></p><p id="eb64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">REST伴随着对面向<strong class="jp ir"> <em class="ku"> </em> </strong>设计的<a class="ae kv" href="https://www.collinsdictionary.com/us/dictionary/english/entity" rel="noopener ugc nofollow" target="_blank">实体</a> <em class="ku"> - </em>的熟悉——这种设计方法是HTTP协议的<a class="ae kv" href="https://tools.ietf.org/html/rfc2616#page-42" rel="noopener ugc nofollow" target="_blank">构件</a>。<strong class="jp ir"><em class="ku"/></strong>CRUD<strong class="jp ir"/>(<strong class="jp ir">C</strong>reate<strong class="jp ir">R</strong>EAD<strong class="jp ir">U</strong>pdate<strong class="jp ir">D</strong>elete)操作定义了一个实体的一组行为。REST APIs使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" rel="noopener ugc nofollow" target="_blank"> HTTP方法</a>的一个子集在一个通常被表示/序列化为JSON的实体上执行CRUD操作。</p><p id="6193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">gRPC是一个高性能的RPC框架(作为背景，RPC APIs允许开发人员访问分布式过程或方法，它们在语法上与集中式过程或方法没有区别，隐藏了网络上数据序列化/传输的复杂性)。它提供客户端、服务器和双向流。</p><p id="b25e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在底层，gRPC使用HTTP/2(用于传输)和协议缓冲区(用于高效的序列化)来实现优于REST+JSON的性能。它为代码生成提供了一流的支持。protobuf编译器生成客户机和服务器代码，这有助于快速开发应用程序，并减少发布新服务所需的工作量。</p><p id="d3ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过结合REST + gRPC，我们可以创建高性能的分布式服务，为客户提供双重访问模式，同时保留面向实体的设计方法的优点。</p><p id="f782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是上面的一个例子，在这个例子中，我们首先定义一个gRPC服务，使用protobuf规范以面向实体的方式放置<code class="fe kw kx ky kz b">orders</code>。使用<code class="fe kw kx ky kz b">order</code>作为我们的实体，我们需要定义对应于服务将支持的CRUD操作的RPC方法。我们将添加一个额外的RPC方法<code class="fe kw kx ky kz b">List</code>来支持现有订单的列表/过滤。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">订单.原型</figcaption></figure><p id="f759" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们使用带有必要Go选项的<code class="fe kw kx ky kz b">protoc</code>来编译我们的<code class="fe kw kx ky kz b">order.proto</code> <em class="ku"> </em>。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ll"><img src="../Images/c1885a28028dfabaf13972636886a2d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIr6hVDCYL9ce4KT0sJczA.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">编译顺序. proto</figcaption></figure><p id="d1ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行上面的命令将生成两个文件:<code class="fe kw kx ky kz b">order.pb.go</code>和<code class="fe kw kx ky kz b">order_grpc.pb.go</code>。<code class="fe kw kx ky kz b">order.pb.go</code>包含order.proto中定义的每个protobuf <code class="fe kw kx ky kz b">message</code>类型的结构。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ll"><img src="../Images/9304f1b0c3082bc5855d781ab05760af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4W_4GBmD7sWttHv8kPfObQ.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">订单结构(生成的代码)</figcaption></figure><p id="da65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kw kx ky kz b">order_grpc.pb.go</code>提供与订单服务交互的客户端/服务器代码。这个文件中包含的是<code class="fe kw kx ky kz b">OrderServiceServer</code><em class="ku"/>——<code class="fe kw kx ky kz b">OrderService</code>的接口翻译(出于婚姻类比的目的，就当它是司仪)。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ls"><img src="../Images/a9b31d6c9230363fd8b00296fe76ff10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86gRvTSsUkUZsWEsklet8Q.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">OrderServiceServer接口(生成的代码)</figcaption></figure><p id="d574" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要启动并运行gRPC服务器，我们需要实现<code class="fe kw kx ky kz b">OrderServiceServer</code> <strong class="jp ir"> </strong>接口。对于这个练习，我们可以使用<code class="fe kw kx ky kz b">UnimplementedOrderServiceServer</code>(生成的代码中提供的基本实现)。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lt"><img src="../Images/ff1749c75d9a047c47ac4134947807b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NK2kVVaS3lvgjmWEdgj1JQ.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated"><code class="fe kw kx ky kz b">UnimplementedOrderServiceServer (generated code)</code></figcaption></figure><p id="51a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kw kx ky kz b">RegisterOrderServiceServer</code>(生成代码)方法接受一个<code class="fe kw kx ky kz b">grpc.Server</code>和一个<code class="fe kw kx ky kz b">OrderServiceServer</code>接口；这个方法在我们的订单服务接口的实现周围包装了一个<code class="fe kw kx ky kz b">grpc.Server</code>，并且必须在调用服务器的<code class="fe kw kx ky kz b">Serve()</code>方法之前被调用。参见下面的例子。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">初始化gRPC服务器</figcaption></figure><p id="6487" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这一步，gRPC订单服务只用几行代码就完成了。最后一步是开发一个REST服务器。通过在REST服务器中注入<code class="fe kw kx ky kz b">OrderServiceServer</code>接口，我们可以让这场“联姻”正式化。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">嵌入订单服务接口的示例REST服务器</figcaption></figure><p id="ed27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，更新<code class="fe kw kx ky kz b">main</code>方法，与REST + gRPC联姻。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">使用服务接口统一REST + gRPC服务器</figcaption></figure><p id="d3d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，gRPC和REST服务器都使用相同的订单服务实现启动并运行。<strong class="jp ir"> <em class="ku"> </em> </strong>注意，我们可以对上面的代码片段进行一些优化，因为它涉及到错误处理、并发性、可读性等。记住以后解决这些问题。</p><p id="8a5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，gRPC框架提供了丰富的protobuf工具，可促进快速应用程序开发，使开发人员能够生成客户机/服务器代码，包括可用于将gRPC与REST或其他HTTP APIs结合的服务接口。</p><h2 id="ede5" class="lu lv iq bd lw lx ly dn lz ma mb dp mc jy md me mf kc mg mh mi kg mj mk ml mm bi translated">2.并发性— Goroutines和通道</h2><p id="3527" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated"><code class="fe kw kx ky kz b">Goroutines</code>是与其他函数同时执行的函数。我们可以认为它们是后台进程，不会阻塞当前的执行线程。在幕后，这些轻量级线程被复用到一个或多个(多:1) <code class="fe kw kx ky kz b"><a class="ae kv" href="https://en.wikipedia.org/wiki/Thread_(computing)" rel="noopener ugc nofollow" target="_blank">OS threads</a></code>上。这允许Go程序处理数百万个<code class="fe kw kx ky kz b">goroutines</code>，而Java可以处理的<code class="fe kw kx ky kz b">futures</code>的数量将受到可用OS线程数量的限制(因为Java线程与OS线程是1:1)。对于这种性能优势的警告是，Go线程共享内存空间，并且对该内存空间的访问必须是同步的(这对于Java开发人员来说应该很熟悉)。这就是<code class="fe kw kx ky kz b">channels</code>将我们从自由落体状态和死锁地狱中解救出来的地方。</p><p id="8d96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通道是基本的<a class="ae kv" href="https://tour.golang.org/concurrency/2" rel="noopener ugc nofollow" target="_blank">类型的管道</a>(你可以把它们想象成邮箱)，它允许goroutines在没有互斥体(锁)的情况下安全地来回共享数据。通道读/写<a class="ae kv" href="https://en.wikipedia.org/wiki/Blocking_(computing)" rel="noopener ugc nofollow" target="_blank">阻塞当前执行线程</a>，直到发送方或接收方准备就绪。</p><p id="1776" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一些常见的任务，goroutines可能会有用。</p><ul class=""><li id="c7f4" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><strong class="jp ir">应用任务</strong>:运行web服务器、数据库连接池、守护进程、API轮询、数据处理队列</li><li id="e6a2" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">请求/事件任务</strong>:处理传入的HTTP请求，执行昂贵的子任务(例如多个网络调用)来完成请求，向卡夫卡发布新消息</li><li id="f616" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">触发&amp;忘记任务</strong>:日志记录、警报、指标</li></ul><p id="e7f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">web服务器是一个应用级进程，通常有一个<code class="fe kw kx ky kz b">start</code> <em class="ku"> / </em> <code class="fe kw kx ky kz b">serve</code>方法来阻塞当前的执行线程，直到服务器完成对请求的服务。如果你很好奇Go的HTTP服务器是如何处理请求的，那就结账<a class="ae kv" href="https://github.com/golang/go/blob/520f3b72db7befab2028d9a47376267cf2d274a9/src/net/http/server.go#L3013" rel="noopener ugc nofollow" target="_blank">源码<em class="ku"> </em>代码</a><em class="ku"/>(TL；对于每个传入的HTTP请求，都会产生一个<code class="fe kw kx ky kz b">goroutine</code>。</p><p id="5e00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<code class="fe kw kx ky kz b">grpcServer.Serve()</code>和<code class="fe kw kx ky kz b">restServer.Start()</code>都是阻塞调用，所以在<code class="fe kw kx ky kz b">main</code>的执行线程中只能执行其中一个调用。另一个必须在后台执行。我们其余的&amp; gRPC服务器的<code class="fe kw kx ky kz b">start</code> <em class="ku"> / </em> <code class="fe kw kx ky kz b">serve</code>方法也会返回错误，我们需要优雅地处理这些错误。(这方面的一个快速提示:将每个服务器包装在一个公开错误通道的结构中。调用将错误写入错误通道的<code class="fe kw kx ky kz b">goroutine</code>中的<em class="ku">启动/服务</em>方法。这允许我们使用<code class="fe kw kx ky kz b"><a class="ae kv" href="https://tour.golang.org/concurrency/5" rel="noopener ugc nofollow" target="_blank">select</a></code>来等待多个通道操作完成)。</p><p id="2bbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码演示了如何针对后台处理和基于通道的错误传播优化REST &amp; gRPC服务器。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">RestServer重构</figcaption></figure><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">GrpcServer</figcaption></figure><p id="f14f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记得把你的Go app当做一个实体。很多时候，开发人员可以编写可靠的服务级别代码，然后在他们的<code class="fe kw kx ky kz b">main</code>方法中加入大量的条件<code class="fe kw kx ky kz b">log.Fatal()</code>语句和其他难以理解的逻辑。</p><p id="9cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑为应用程序创建一个包含配置、服务器和其他应用程序级依赖项的结构。尽管Go提供了创建多个<a class="ae kv" href="https://golang.org/doc/effective_go.html#init" rel="noopener ugc nofollow" target="_blank"> init </a>函数的能力，但是尽可能避免使用<code class="fe kw kx ky kz b">init</code> <em class="ku"> </em>。Init函数有一些缺点，包括它们有空返回。具体来说，Go <a class="ae kv" href="https://golang.org/doc/faq#runtime" rel="noopener ugc nofollow" target="_blank">运行时</a>寻找具有以下签名的包级函数</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ll"><img src="../Images/65e0b8904add510e67c7c8c2d08fcbf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xg2q6l3EFpBNP73OeFwf5w.png"/></div></div></figure><p id="9df8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着您不能从<code class="fe kw kx ky kz b">init</code>函数返回值。如果你试图初始化一个变量，出现错误，你可能会被迫<a class="ae kv" href="https://go-proverbs.github.io/" rel="noopener ugc nofollow" target="_blank">死机</a>，退出应用程序，或者编写<code class="fe kw kx ky kz b">recover</code>逻辑。Init函数会使代码更难理解。相反，探索创建您自己的定制的类似构造函数的函数，该函数创建一个新的应用程序，执行所有必要的应用程序初始化，并返回应用程序。如果应用程序初始化过程中出现错误，只需更改函数的返回签名，返回一个应用程序实例和一个错误。</p><p id="b486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是<code class="fe kw kx ky kz b">main</code>的优化版本，它为应用程序创建了一个结构，使用<code class="fe kw kx ky kz b">select</code>来监听来自其余&amp; gRPC服务器的错误，并处理应用程序的启动/关闭(包括操作系统终止信号)。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">主重构</figcaption></figure><p id="1a9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们创建或更新<code class="fe kw kx ky kz b">order</code>之前，我们需要获得支付方式的预授权批准，并且我们应该确认要购买的商品有库存。假设这些子任务可能出错(失败或超时)，并且可以独立执行。处理请求级并发有几个选项。我们可以使用标准的goroutines和频道，但也许有更好的选择。</p><p id="385b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等待组允许我们开始一组goroutines并等待它们完成。一个<code class="fe kw kx ky kz b">waitGroup</code> <em class="ku"> </em>可以工作，但是这伴随着管理<a class="ae kv" href="https://golang.org/pkg/sync/#example_WaitGroup" rel="noopener ugc nofollow" target="_blank"> waitGroup </a>计数器的责任。错误组非常适合执行一组相关的子任务。一个<code class="fe kw kx ky kz b">errGroup</code>由执行子任务和处理错误传播的goroutines集合组成。一个<code class="fe kw kx ky kz b">errGroup</code>等待(阻塞)直到所有子任务完成。</p><p id="5431" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将<a class="ae kv" href="https://golang.org/pkg/context/" rel="noopener ugc nofollow" target="_blank">上下文</a>用于传入和传出的服务器请求。上下文允许在客户机和服务器之间传播请求范围的值、截止时间和取消信号。<code class="fe kw kx ky kz b">Context</code>有一个<code class="fe kw kx ky kz b">Done()</code>通道，可以在<code class="fe kw kx ky kz b">Context</code>被取消时通知goroutines，允许它们提前退出并释放系统资源。当使用<code class="fe kw kx ky kz b">errgroup.WithContext()</code>时，在第一次遇到子任务错误或第一次<code class="fe kw kx ky kz b">wait()</code>返回时，派生上下文被取消。</p><p id="d6e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，<code class="fe kw kx ky kz b">validateOrder</code>创建了一个<code class="fe kw kx ky kz b">errGroup</code>，它派生出两个并发的子任务，一个任务给<code class="fe kw kx ky kz b">preAuthorizePayment</code>，另一个任务给<code class="fe kw kx ky kz b">checkInventory</code>，并确认是否所有的<code class="fe kw kx ky kz b">items</code>都有库存。在两个子任务中调用的函数接受一个<code class="fe kw kx ky kz b">Context</code>，并且能够在发生上下文取消(或请求超时)时提前返回。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="7f3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数仓库(和履行中心)都有订单管理系统来实现高效和经济的订单履行。类似地，管理并发性对于保持应用程序的质量至关重要。下面的例子使用了一个<code class="fe kw kx ky kz b">waitgroup</code>和通道来限制我们的仓库一次可以处理的订单数量。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">限制等级的等待组</figcaption></figure><h2 id="b2ef" class="lu lv iq bd lw lx ly dn lz ma mb dp mc jy md me mf kc mg mh mi kg mj mk ml mm bi translated">3.有效单元测试</h2><p id="e434" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">在我职业生涯的早期(Java时代)，<a class="ae kv" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank">单元测试</a>让我想起了我妈妈总是放在我餐盘里的那份蔬菜。小时候，我总是先吃好吃的，然后偷偷把蔬菜铲进垃圾桶。换句话说，单元测试给我留下了不好的印象。这主要是因为它需要团队跟上新的模仿框架，用一个通常很难掌握的框架创建一个陡峭的学习曲线。更不用说，这些嘲讽的框架依赖于反射——正如Rob Pike曾经说过的,<a class="ae kv" href="https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=15m22s" rel="noopener ugc nofollow" target="_blank">反射永远不会清晰</a>。</p><p id="cf38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，Go改变了我对单元测试的看法。以下是我一路走来学到的一些测试技巧。</p><ul class=""><li id="d6d4" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><strong class="jp ir">用纯函数代替方法。</strong>最容易测试的代码单元之一是纯函数。纯函数是确定性的，不需要初始化来测试。方法是定义在一个<code class="fe kw kx ky kz b">type</code>(例如。结构)。为了测试一个方法，必须初始化它的父类型。见下文。</li></ul><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">方法与纯函数(示例)</figcaption></figure><ul class=""><li id="20f1" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><strong class="jp ir">创建功能依赖关系。</strong> <em class="ku"> </em>函数执行任务需要的任何外部依赖(DB、web服务调用、事件生产者等)都可以作为参数注入到函数中。具有嵌入式依赖关系的函数很难测试。开发人员通常通过使用能够在运行时(通过反射)改变(模仿)外部依赖关系值的测试框架来避开这种<a class="ae kv" href="https://martinfowler.com/bliki/CodeSmell.html#:~:text=A%20code%20smell%20is%20a,me%20with%20my%20Refactoring%20book.&amp;text=The%20best%20smells%20are%20something,you%20to%20really%20interesting%20problems." rel="noopener ugc nofollow" target="_blank">代码味道</a>。如果您再看一下<code class="fe kw kx ky kz b">validateOrder</code>函数(在上面的一个代码片段中)，您可能会注意到外部依赖项<code class="fe kw kx ky kz b">preAuthorizePayment</code>和<code class="fe kw kx ky kz b">verifyInventory</code>是嵌入的。这个函数很难测试。因为Go支持一级函数——我们可以通过把<code class="fe kw kx ky kz b">validateOrder</code>变成一个<a class="ae kv" href="https://georgefrancisjr.medium.com/the-essential-scala-toolkit-1fd2e43220a9" rel="noopener">高阶</a>函数来解决这个问题。</li></ul><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="2875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个将事情联系在一起的示例测试用例。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div></figure><ul class=""><li id="d7be" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">当用作工具而不是拐杖时，嘲讽框架是有用的。即使我们可以在没有第三方朋友的情况下模仿外部依赖，这些框架仍然为单元测试的乏味部分提供了价值，例如执行测试断言。</li><li id="d793" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">对你的队友友好。</strong>正如罗布派克<a class="ae kv" href="https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=14m35s" rel="noopener ugc nofollow" target="_blank">所说</a>“清晰胜于巧妙。”我总是鼓励开发人员在编写代码时考虑到受众。清晰的代码易于编写，易于测试，并且应该易于开发人员(和非开发人员)理解。</li></ul><p id="3ac7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">享受你掌握围棋的旅程。请在下面留下您的评论。</p></div></div>    
</body>
</html>