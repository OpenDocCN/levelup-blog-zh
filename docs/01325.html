<html>
<head>
<title>How to Implement Queues In Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js中实现队列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-implement-queues-in-node-js-8b3a06ce0dd0?source=collection_archive---------1-----------------------#2019-12-14">https://levelup.gitconnected.com/how-to-implement-queues-in-node-js-8b3a06ce0dd0?source=collection_archive---------1-----------------------#2019-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9d50" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Javascript编程</h2><div class=""/><div class=""><h2 id="f2cf" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何用Bull/Redis/Node.js/Javascript实现作业队列的演示</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/06f8647721e4100136555f2f5fbce98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sbBAV4IBWj-BhL6R"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">freestocks.org</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="0b24" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">队列可以以一种优雅的方式解决许多不同的问题，从消除处理高峰到在微服务之间创建健壮的通信通道，或者将繁重的工作从一个服务器卸载到许多较小的工作人员，等等。那么，如何在JavaScript世界中实现这一点呢？</p><p id="98bd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">答案是扯淡。<a class="ae le" href="https://github.com/OptimalBits/bull" rel="noopener ugc nofollow" target="_blank"> Bull </a>是一个节点库，基于<a class="ae le" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>实现了一个快速健壮的队列系统。在我看来，如果您想利用队列机制，这可能是Node.js的最佳解决方案。</p><p id="d8cd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一个bull队列实例通常有3个主要的不同角色:一个作业生产者、一个作业消费者和/或一个事件监听器。</p><blockquote class="mb mc md"><p id="6e7b" class="lf lg me lh b li lj ka lk ll lm kd ln mf lp lq lr mg lt lu lv mh lx ly lz ma ij bi translated"><strong class="lh ja">生产者</strong>:向队列添加作业的节点程序<br/> <strong class="lh ja">消费者</strong>:定义流程函数的节点程序，作业内容<br/> <strong class="lh ja">事件监听器</strong>:你可以只监听队列中发生的事件，对不同的事件进行不同的处理。</p></blockquote><h1 id="2f5c" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">公牛队列实现</h1><h2 id="dbda" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">目的:</h2><p id="79f3" class="pw-post-body-paragraph lf lg iq lh b li nl ka lk ll nm kd ln lo nn lq lr ls no lu lv lw np ly lz ma ij bi translated">为作业创建一个队列解决方案，以便将文件上传到互联网。该API由第三方实施。我们需要创建一个可以调用这个API的作业，并将作业放入队列中；此外，我们必须保持接口开放给更多的工作/队列在未来。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="2340" class="na mj iq nr b gy nv nw l nx ny">const uploadFiles = require("../../../operations/uploadFiles");</span></pre><h2 id="71fd" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">解决方案结构:</h2><p id="90e7" class="pw-post-body-paragraph lf lg iq lh b li nl ka lk ll nm kd ln lo nn lq lr ls no lu lv lw np ly lz ma ij bi translated">典型的多头队列解决方案结构如下所示:</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="e431" class="na mj iq nr b gy nv nw l nx ny">├── queues<br/>│   ├── index.js<br/>│   └── process.js<br/>└── tasks<br/>    └── file<br/>        ├── processor.js<br/>        ├── queue.js</span></pre><p id="053f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> queues/index.js </strong>是<strong class="lh ja">声明</strong>队列的节点代码(在我们的例子中，只有一个队列叫做“UPLOAD_FILE_BY_ID”)。<strong class="lh ja"> <em class="me">第一部制片人。</em> </strong></p><p id="003a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> queues/process.js </strong>是通过将队列与其处理器链接来定义流程的地方。换句话说，一个队列(例如通过ID上传文件)专门负责一种类型的作业(通过ID上传文件，不通过名称上传文件，等等)。但是，就业岗位的数量会很多。此外，它是定义侦听器的地方，这意味着如何反映队列中作业的不同状态。<strong class="lh ja"> <em class="me">听者</em> </strong></p><p id="9141" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">tasks/file/processor . js</strong>是做真正工作的节点代码，比如用某些参数调用/触发API。<strong class="lh ja"> <em class="me">处理器</em> </strong></p><p id="c309" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> task/file/queue.js </strong>是app在队列外调用的节点代码，触发生产者添加作业。换句话说——<strong class="lh ja">特定队列的API/entry和生产者的第二<em class="me">部分。</em></strong></p><h2 id="f68c" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">履行</h2><p id="1511" class="pw-post-body-paragraph lf lg iq lh b li nl ka lk ll nm kd ln lo nn lq lr ls no lu lv lw np ly lz ma ij bi translated"><strong class="lh ja"> <em class="me">监制</em> </strong></p><p id="8941" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我使用2个文件来完成定义，而不是1个。原因是我们需要创建一个入口，让对方app可以调用job add函数；更重要的是，当队列的数量变得越来越大时，通过这种方式，解决方案更容易维护。</p><p id="6ecf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这里的代码也是一个重用Redis连接的例子，因为我的解决方案将部署在Heroku上，更多详细信息，请参考<a class="ae le" href="https://github.com/OptimalBits/bull/blob/master/PATTERNS.md#reusing-redis-connections" rel="noopener ugc nofollow" target="_blank">https://github . com/optimal bits/bull/blob/master/patterns . MD # reuse-Redis-Connections</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">队列/index.js</figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">任务/文件/队列. js</figcaption></figure><p id="aa4e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> <em class="me">消费者</em> </strong></p><p id="28c4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面是一份工作的真实内容。我们可以看到，它基本上是从uploadFiles调用另一个API来按ID上传文件。值得注意的是，异步函数更好。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">处理器. js</figcaption></figure><p id="ec66" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> <em class="me">听者</em> </strong></p><p id="b786" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">将最大侦听器增加到50，以避免EventEmitter内存泄漏警告；</p><p id="4c86" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为3种类型的事件定义处理程序。</p><p id="fa17" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">使用数组来保持定义过程的接口对更多队列开放。换句话说，我们构建了一个队列引擎。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">js通过将处理器链接到queue.process()来定义处理器/工作者</figcaption></figure><h2 id="a871" class="na mj iq bd mk nb nc dn mo nd ne dp ms lo nf ng mu ls nh ni mw lw nj nk my iw bi translated">注意事项:</h2><ul class=""><li id="a705" class="ob oc iq lh b li nl ll nm lo od ls oe lw of ma og oh oi oj bi translated">在上面的例子中，我们将过程函数定义为<code class="fe ok ol om nr b">async</code>，这是一种强烈推荐的定义方法。如果您的节点运行时不支持async/await，那么您可以在流程函数结束时返回一个承诺来获得类似的结果。</li><li id="3ec7" class="ob oc iq lh b li on ll oo lo op ls oq lw or ma og oh oi oj bi translated">我们使用两个文件来完成worker/processor的定义，它们是process.js和processor.js。</li><li id="cd43" class="ob oc iq lh b li on ll oo lo op ls oq lw or ma og oh oi oj bi translated">下面是侦听器的示例，很容易看出，当前这个队列只处理3种类型的事件:失败、完成和停止。</li></ul><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="7a7b" class="na mj iq nr b gy nv nw l nx ny">// here are samples of listener events : //"failed","completed","stalled", the other events will be ignored  queue.on("failed", failHandler);  <br/>queue.on("completed", completedHandler);  <br/>queue.on("stalled", handleStalled);</span><span id="d3e4" class="na mj iq nr b gy os nw l nx ny">// link the correspondant processor/worker  <br/>queue.process(processor);</span></pre><h1 id="4372" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">运行队列</h1><p id="cbe5" class="pw-post-body-paragraph lf lg iq lh b li nl ka lk ll nm kd ln lo nn lq lr ls no lu lv lw np ly lz ma ij bi translated">我们现在可以使用以下命令来运行/开发/调试队列</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="de15" class="na mj iq nr b gy nv nw l nx ny">"process-queues": "node ./src/jobs/queues/process.js",</span><span id="685b" class="na mj iq nr b gy os nw l nx ny">"dev-queues": "nodemon ./src/jobs/queues/process.js",</span><span id="bfa7" class="na mj iq nr b gy os nw l nx ny">"debug-queues": "node --nolazy --inspect-brk=9242 ./src/jobs/queues/process.js"</span></pre><p id="c4b9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">更多API参考详情，请参考<a class="ae le" href="https://github.com/OptimalBits/bull/blob/master/REFERENCE.md" rel="noopener ugc nofollow" target="_blank">https://github . com/optimal bits/bull/blob/master/reference . MD</a></p><p id="133e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">更多关于更通用的公会详情，请参考<a class="ae le" href="https://optimalbits.github.io/bull/" rel="noopener ugc nofollow" target="_blank">https://optimalbits.github.io/bull/</a></p></div></div>    
</body>
</html>