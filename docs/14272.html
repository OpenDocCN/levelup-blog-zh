<html>
<head>
<title>Python Class Decorators — An Easy Guide to Write Your Own</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python类装饰器——编写自己的简单指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-class-decorators-an-easy-guide-to-write-your-own-941fa2ad0ad9?source=collection_archive---------4-----------------------#2022-11-13">https://levelup.gitconnected.com/python-class-decorators-an-easy-guide-to-write-your-own-941fa2ad0ad9?source=collection_archive---------4-----------------------#2022-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="90e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章旨在以一种简单实用的方式展示Python类装饰器。之后，您应该能够将类定义为装饰器。让我们开始吧…</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/fe77dfb57fde254746424a2f09af73d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*p9f2mpIX0YilmyWkKKKPCQ.jpeg"/></div></figure><h1 id="7cda" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">我们能对类装饰者做些什么？</h1><ul class=""><li id="a31b" class="lu lv it js b jt lw jx lx kb ly kf lz kj ma kn mb mc md me bi translated">消除重复代码(多个功能共享相同的代码)</li><li id="22b2" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">防止不良输入(数据验证，查看我关于这个主题的另一篇文章<a class="ae mk" href="https://medium.com/@caopengau/python-data-pipeline-first-and-foremost-step-data-validation-e15017b7ef8d" rel="noopener">这里</a></li><li id="c2f3" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">日志记录(事实上我们将在本文中构建一个，一个有趣的时间跟踪器<a class="ae mk" href="https://github.com/koaning/memo/blob/main/memo/_util.py" rel="noopener ugc nofollow" target="_blank">这里是</a>)</li><li id="7f64" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">证明</li></ul><h1 id="6aa9" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Python类装饰器简介</h1><p id="4374" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">例如，下面的<code class="fe mo mp mq mr b">logger</code>函数在调用修饰函数之前和之后打印出一些<code class="fe mo mp mq mr b">=</code>字符:</p><pre class="kp kq kr ks gt ms mr mt bn mu mv bi"><span id="2708" class="mw kx it mr b be mx my l mz na">def logger(n):<br/>    def decorate(fn):<br/>        def wrapper(*args, **kwargs):<br/>            print(n*'=')<br/>            result = fn(*args, **kwargs)<br/>            print(result)<br/>            print(n*'=')<br/>            return result<br/>        return wrapper<br/>    return decorate</span></pre><p id="f0b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mo mp mq mr b">logger</code>是一个返回装饰器的装饰器工厂。它接受一个指定要显示的<code class="fe mo mp mq mr b">=</code>字符数的参数。<code class="fe mo mp mq mr b">*args</code>和<code class="fe mo mp mq mr b">**kwargs</code>是特殊关键字，允许函数采用可变长度参数。</p><p id="7580" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面说明了如何使用<code class="fe mo mp mq mr b">logger</code>装饰工厂:</p><pre class="kp kq kr ks gt ms mr mt bn mu mv bi"><span id="9b08" class="mw kx it mr b be mx my l mz na">@logger(5)<br/>def add(a, b):<br/>    return a + b<br/><br/>add(10, 20)</span></pre><p id="5c71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出:</p><pre class="kp kq kr ks gt ms mr mt bn mu mv bi"><span id="04f5" class="mw kx it mr b be mx my l mz na">=====<br/>30<br/>=====</span></pre><p id="aefd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">装饰工厂接受一个参数并返回一个可调用的。callable接受一个参数(<code class="fe mo mp mq mr b">fn</code>)，这是一个将被修饰的函数。同样，callable可以访问传递给装饰器工厂的参数(<code class="fe mo mp mq mr b">n</code>)。</p><p id="3f2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当类实例实现<code class="fe mo mp mq mr b">__call__</code>方法时，它可以是可调用的。因此，您可以将<code class="fe mo mp mq mr b">__call__</code>方法作为装饰器。</p><p id="95f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的例子使用一个类重写了<code class="fe mo mp mq mr b">logger</code>装饰工厂:</p><pre class="kp kq kr ks gt ms mr mt bn mu mv bi"><span id="8b61" class="mw kx it mr b be mx my l mz na">class logger:<br/>    def __init__(self, n):<br/>        self.n = n<br/>    def __call__(self, fn):<br/>        def wrapper(*args, **kwargs):<br/>            print(self.n*'=')<br/>            result = fn(*args, **kwargs)<br/>            print(result)<br/>            print(self.n*'=')<br/>            return result<br/>        return wrapper</span></pre><p id="dc99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以像这样使用<code class="fe mo mp mq mr b">logger</code>类作为装饰器:</p><pre class="kp kq kr ks gt ms mr mt bn mu mv bi"><span id="11fd" class="mw kx it mr b be mx my l mz na">@logger(5)<br/>def add(a, b):<br/>    return a + b</span></pre><p id="1461" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mo mp mq mr b">@logger(5)</code>返回一个<code class="fe mo mp mq mr b">logger</code>类的实例。该实例是一个可调用的实例，因此您可以这样做:</p><pre class="kp kq kr ks gt ms mr mt bn mu mv bi"><span id="7fe9" class="mw kx it mr b be mx my l mz na">add = logger(5)(add)</span></pre><p id="fdd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以你可以用可调用的类来修饰函数。</p><p id="805d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将所有这些放在一起:</p><pre class="kp kq kr ks gt ms mr mt bn mu mv bi"><span id="6169" class="mw kx it mr b be mx my l mz na">from functools import wraps<br/><br/>class logger:<br/>    def __init__(self, n):<br/>        self.n = n<br/>    def __call__(self, fn):<br/>        @wraps(fn)<br/>        def wrapper(*args, **kwargs):<br/>            print(self.n*'=')<br/>            result = fn(*args, **kwargs)<br/>            print(result)<br/>            print(self.n*'=')<br/>            return result<br/>        return wrapper<br/><br/>@logger(5)<br/>def add(a, b):<br/>    return a + b<br/><br/>add(10, 20)</span></pre><h1 id="4dc5" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><ul class=""><li id="c429" class="lu lv it js b jt lw jx lx kb ly kf lz kj ma kn mb mc md me bi translated">通过实现<code class="fe mo mp mq mr b">__call__</code>方法，使用可调用类作为装饰器。</li><li id="893f" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">将装饰器参数传递给<code class="fe mo mp mq mr b">__init__</code>方法。</li></ul><p id="2d79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">呼吁行动</strong></p><p id="dd3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你觉得这个指南有帮助，请鼓掌并跟我来。通过<a class="ae mk" href="https://medium.com/@caopengau/membership" rel="noopener">链接</a>加入medium，获取我和所有其他优秀作家在medium上的优质文章。</p></div></div>    
</body>
</html>