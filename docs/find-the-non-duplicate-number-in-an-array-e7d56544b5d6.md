# 在数组中寻找不重复的数字。

> 原文：<https://levelup.gitconnected.com/find-the-non-duplicate-number-in-an-array-e7d56544b5d6>

## 给定一个**非空的**整数数组，每个元素出现*两次*，只有一个除外。找到那个单身的。

![](img/8f01156debe1ad3c1d19d0082ac65a39.png)

例如，这个数组[4，3，2，4，1，3，2]的特点是其中包含的所有数字都是重复的，只有一个除外。在这种特殊情况下，不重复的号码是`1`

# 第一种解决方案

一个可能的解决方案是使用一个`hashmap`并保存数组中每个数字的出现次数。

末了`hashmap`包含:

`4 => 2`

`3 => 2`

`2 => 2`

`1 => 1`

`key`表示我的数组中的数字，而`value`表示出现次数。只需滚动我们的散列表，返回一次出现的值。

第一种解决方案

## 时间和空间复杂性

第一个周期的**时间**复杂度为`O(n)`，第二个周期的`O(n)`。
**空间**复杂度等于`O(n)`内存中数组大小对应的复杂度。

# 第二种解决方案

第二个更好的解决方案是使用`XOR`操作符。

`XOR`操作员的简要概述:

`1 xor 1 = 0`

`0 xor 0 = 0`

`1 xor 0 = 1`

`0 xor 1 = 1`

让我们考虑下面的数组[5，4，5]并执行`xor`操作符:

`101 xor 100 => 001 xor 101 => 100`

最后的结果是`100`,它对应的`4`实际上在我们的数组中只出现过一次。

现在让我们考虑这个数组[5，4，4，5]并执行`xor`操作符:

`101 xor 100 => 001 xor 100 => 101 xor 101 => 000`

最终结果是`000`，在第二个数组中，所有元素都被复制。

第二种解决方案

## 时间和空间复杂性

第二个解决方案的**时间**复杂度是`for`循环的`O(n)`。
**空间**复杂度等于`O(1)`，因为在每次迭代中，我们在内存中只有一个数字。

在结束之前，我建议你喜欢并分享这篇文章，并留下评论。它不会让你付出任何代价，同时鼓励我继续创作其他类似的内容。谢谢你的支持。

下节课再见。😉