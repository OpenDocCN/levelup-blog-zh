<html>
<head>
<title>Pass-By Value vs. Pass-By Reference in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的传递值与传递引用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pass-by-value-vs-pass-by-reference-in-javascript-82fa8736c9f7?source=collection_archive---------4-----------------------#2020-07-25">https://levelup.gitconnected.com/pass-by-value-vs-pass-by-reference-in-javascript-82fa8736c9f7?source=collection_archive---------4-----------------------#2020-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e3a64ebd41a081f6f0083ac25370963b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3baHLoIfmoFuXAtGLlTydA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@sigmund?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kf" href="https://unsplash.com/s/photos/copy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="eb8e" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="5bdf" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">编程中我最喜欢的话题之一是理解按值传递和按引用传递。这是我在一次技术面试中提出的一个概念，如果你还不知道，你应该知道。</p><p id="0d46" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">按引用传递和按值传递的区别在于，按值传递会在内存中创建一个新空间并复制一个值，而按引用传递则不会。引用传递不是复制，而是做听起来完全一样的事情；存储在内存中的值被引用。</p><p id="0d97" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><em class="mh">简记方式</em> : <strong class="lg iu"> <em class="mh">复杂</em> </strong> <em class="mh">值为按引用传递，</em> <strong class="lg iu"> <em class="mh">原语</em> </strong> <em class="mh">值为按值传递。</em></p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/4136c5ca2534d1831981c7c2e1a28354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILZKGHjL2JUNQpo49ylNJQ.png"/></div></div></figure><h1 id="ccdb" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">按引用传递:</h1><h2 id="c5f9" class="mn kh it bd ki mo mp dn km mq mr dp kq lp ms mt ku lt mu mv ky lx mw mx lc my bi translated">目标</h2><p id="d907" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">首先，我将创建一个对象文本，并将其赋给变量<code class="fe mz na nb nc b">john</code>。该对象将包含简单的属性，如姓名、年龄和性别。让我们创建另一个名为<code class="fe mz na nb nc b">newJohn</code>的变量，并将其设置为等于<code class="fe mz na nb nc b">john</code>对象。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="177d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">此时，您可能认为这是两个独立的对象，您现在可以以任何方式对其进行修改。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nf ne l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">不要。！！！！</figcaption></figure><h2 id="8d94" class="mn kh it bd ki mo mp dn km mq mr dp kq lp ms mt ku lt mu mv ky lx mw mx lc my bi translated"><strong class="ak">还记得我说过不做副本，会引用内存中的一个值吗？</strong></h2><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c859" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe mz na nb nc b">newJohn</code>对象不是存储在<code class="fe mz na nb nc b">john</code>变量中的对象的副本。相反，变量<code class="fe mz na nb nc b">newJohn</code>引用原始的<code class="fe mz na nb nc b">john</code>对象。</p><p id="56c3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这意味着如果你决定编辑<code class="fe mz na nb nc b">newJohn</code>对象(<strong class="lg iu"> </strong>，例如将第3行<code class="fe mz na nb nc b">newJohn</code>的<code class="fe mz na nb nc b">name</code>属性改为<code class="fe mz na nb nc b">"Tom Doe"</code>，你实际上是在修改<code class="fe mz na nb nc b">john</code>对象！</p><p id="8054" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">正如您在第16行和第19行看到的，两个对象的<code class="fe mz na nb nc b">name</code>属性都有一个值<code class="fe mz na nb nc b">"Tom Doe"</code>。</p><h2 id="92f8" class="mn kh it bd ki mo mp dn km mq mr dp kq lp ms mt ku lt mu mv ky lx mw mx lc my bi translated">数组</h2><p id="8430" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">数组的工作方式与对象相同。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8911" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们将得到与对象示例相同的结果。</p><p id="12c0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们将创建一个名为<code class="fe mz na nb nc b">john</code>的变量，并将其初始化为一个数组。然后我们将创建一个名为<code class="fe mz na nb nc b">newJohn</code>的新变量，并给它赋值<code class="fe mz na nb nc b">john</code>。</p><p id="d076" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">然而，当我们试图向存储在<code class="fe mz na nb nc b">newJohn</code>变量中的数组添加一个新项时，它也会影响到<code class="fe mz na nb nc b">john</code>数组。同样，这是因为我们只处理<strong class="lg iu"> <em class="mh">的一个数组，而不是数组</em> </strong>的两个独立副本。变量<code class="fe mz na nb nc b">newJohn</code>引用了在变量<code class="fe mz na nb nc b">john</code>中初始化的同一个数组。</p><p id="45d9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">当处理按值传递的值时，情况并非如此。</p><h1 id="5474" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">传递值</h1><p id="7454" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">与对象和数组不同，诸如数字或字符串之类的原始值实际上会创建一个副本。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7305" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这里，我们创建了一个变量<code class="fe mz na nb nc b">const num</code>，并给它赋值<code class="fe mz na nb nc b">25</code>。我们还将创建一个名为<code class="fe mz na nb nc b">passByValue</code>的函数，它接受一个参数，并在该参数上加2。我们将传入的参数是<code class="fe mz na nb nc b">num</code>变量。</p><p id="e49d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">正如我们在引用传递中看到的，当我们试图改变<code class="fe mz na nb nc b">newJohn</code>中的对象时，我们实际上是引用了存储在变量<code class="fe mz na nb nc b">john</code>中的对象并改变了该对象。通过值传递，当我们将变量<code class="fe mz na nb nc b">num</code>传递给函数并返回<code class="fe mz na nb nc b">27</code>、<em class="mh">的值时，我们并没有改变</em>变量<code class="fe mz na nb nc b">num</code>的原始值。</p><p id="0dab" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这是因为当我们将<code class="fe mz na nb nc b">num</code>传递给函数时，它会创建一个副本，并在内存中给它自己的空间。</p><p id="38c2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">当我们在第14行<code class="fe mz na nb nc b">console.log(num)</code>时，我们仍然有我们原来的<code class="fe mz na nb nc b">25</code>。</p><p id="fca1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">数值</strong> <code class="fe mz na nb nc b"><strong class="lg iu">const num</strong></code> <strong class="lg iu">不变！</strong></p><h1 id="82ca" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="070d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">理解PBV和PBR是有帮助的，因为如果你正在写代码，你想设置一个变量等于另一个变量，或者在上面的例子中，把一个变量作为一个参数传入一个函数，你需要知道这个值是按值传递还是按引用传递。这将有助于您在处理数据时避免错误。</p></div></div>    
</body>
</html>