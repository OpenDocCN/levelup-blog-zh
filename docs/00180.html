<html>
<head>
<title>Heapsort for Javascript Newbies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript新手堆排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/heapsort-for-javascript-newbies-598d25477d55?source=collection_archive---------0-----------------------#2018-07-26">https://levelup.gitconnected.com/heapsort-for-javascript-newbies-598d25477d55?source=collection_archive---------0-----------------------#2018-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="341a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">准备好愤怒吧，因为今天我们谈论的是堆排序！我将以一种初学者友好的方式，一步一步地向您介绍这个算法。到这篇文章结束时，我们将成为堆创建和排序的专家。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="9894" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated"><strong class="ak">请问什么是heapsort？</strong></h2><p id="a395" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我很高兴你问了。Heapsort是一种排序算法！更具体地说，它是一种不稳定的基于比较的排序算法，使用一种称为max-heap的数据结构。这意味着什么呢？</p><h2 id="3829" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">不稳定</h2><p id="18c1" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">这意味着，如果两个元素具有相同的值，heapsort可能会切换它们，而不是让它们保持彼此相关的位置。</p><p id="847c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设你有三张扑克牌:依次是方块王、梅花7和黑桃王。</p><p id="f3f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">k♠7♣的k</p><p id="22f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你要根据它们的价值把这些卡片按升序排列。</p><p id="cfce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个稳定的排序会看到两个国王是相同的价值，并会离开方块国王<strong class="js iu">在</strong>黑桃国王之前。</p><p id="7a8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">k♠7♣</p><p id="b7b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个不稳定的排序可能会交换两个国王，把方块国王<strong class="js iu">放在黑桃国王</strong>之后。</p><p id="4d27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">k♠7♣</p><p id="0495" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们说堆排序不稳定的意思。这并不理想，但heapsort还有其他亮点。太好了！下一个！</p><h2 id="e182" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">什么是堆？</h2><p id="d078" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">堆只是添加了一些规则的二叉树。</p><p id="037a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一条规则是，它必须是一个完整的二叉树，这意味着在添加另一层之前，我们要填满当前层上的所有节点。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/6c78e7cffde2259d5080d15580fb58d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*KJcoEAIQ_nLgqODn3ZpHFQ.jpeg"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">看到我们是如何在没有填满第三层的情况下增加第四层的了吗？</figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/190c33523be60821ed7474529e0d8b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*fP7AYeX8SXAhwtidrI7vTw.jpeg"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">我们走吧！现在第三层已经满了！</figcaption></figure><p id="4d5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个规则定义了堆中的父关系和子关系。有两种类型的堆:最大堆和最小堆。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/f82ef687c1950149d5f665bba37134d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*PBgtMpgZ6gFvui02zoqWhg.jpeg"/></div></figure><p id="4996" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在一个<strong class="js iu">最大堆</strong>中，所有父元素必须比它们的两个子元素<strong class="js iu">大</strong>。稍后我们会看到，这对我们非常有用，因为我们知道最大的数字在顶部。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/09c2722a86a47ab7bbcd1b00d2782717.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*8l3xJzbnuMi5yJ_SkW5HKg.jpeg"/></div></figure><p id="2ff4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">最小堆</strong>中，父元素必须<strong class="js iu">比它们的子元素</strong>小。我们不会在这里讨论min heaps，但是了解它们是很好的！</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="aa07" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">heapsort是如何工作的？</h2><p id="f554" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">因此，堆排序的步骤如下:</p><ol class=""><li id="ab56" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">构建一个最大堆，使具有最大值的元素位于顶部。</li><li id="50c1" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">将它与最后一个元素交换，并将其从堆中移除。</li><li id="20d5" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">重复第一步和第二步，直到堆只剩下一个元素。</li></ol><h2 id="b4eb" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">但是等等，javascript中没有“堆”数据类型…</h2><p id="9fc4" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">你完全正确。这似乎是一个很难克服的问题…</p><p id="4e2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以事情是这样的，我们可以用一个数组<strong class="js iu"> <em class="mt">表示</em> </strong>一个堆。看看下面的min堆:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/ad16ad3202b9a0d4de6d44d556e02e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*dhTQLPcuRbG10d7OIruNHQ.jpeg"/></div></figure><p id="c0a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设这些数字是一个数组的索引。酷的是，我们可以使用数组的索引来表示我们的堆。</p><p id="1f50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要找到任何父元素的左子元素的索引，我们可以将父元素的索引乘以2，再加1。像这样:</p><p id="099c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mu mv mw mx b">let left = 2 * parent + 1</code></p><p id="22ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么右边的孩子就是左边的孩子加1。</p><p id="c5b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mu mv mw mx b">let right = left + 1</code></p><p id="b17f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">于是我们有了:<code class="fe mu mv mw mx b">let array = [6, 5, 3, 1, 8, 7, 2, 4]</code></p><p id="50d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一棵二叉树(我们稍后将对其进行填充),它看起来像这样:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/0753574ea62022a00ab6abb276f2d5fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*Og2Xxrj1qtpNqG8q0s6j-w.jpeg"/></div></figure><h2 id="072f" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">太棒了。让我们建造那个堆！</h2><p id="1ab8" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">因此，我们将构建一个名为“heapify”的函数来比较三个元素(一个父元素和两个子元素)，并确保它们对于一个<strong class="js iu"> max heap </strong>来说顺序正确。这个函数将接受三个参数:数组，我们要用来构建堆的数组的长度，以及我们要堆的父对象的索引。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/6db45fd9a8b4bd42be0fee51a2d127e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqFLeMKe8frYFhPCbw0whA.png"/></div></div></figure><p id="a72f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们像以前一样，相对于父节点来定义我们的左右子节点。我们还创建了这个名为“largest”的变量，我们将使用它进行比较，并在需要时交换元素。</p><p id="8edb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们看看我们的父母是否比左边的孩子大。如果不是，我们将把我们的变量<code class="fe mu mv mw mx b">largest</code> <em class="mt"> </em>赋给左边的孩子，因为它目前是最大的！</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/49b9fcd040401ea20cc0fa925265d042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FY0-gJVSvHa8FHdm2AFxLw.png"/></div></div></figure><p id="e16a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！现在<code class="fe mu mv mw mx b">largest</code>指的是父母或者左边的孩子，以较大者为准。现在，如果我们将<code class="fe mu mv mw mx b">largest</code>与正确的孩子进行比较，我们就会知道哪个孩子实际上最大。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/3d31b146e5285620eb99362970fe7296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yTHLAiPJqQDiRSmZzXxOQw.png"/></div></div></figure><p id="e962" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太棒了。现在我们可以检查一下<code class="fe mu mv mw mx b">largest</code>是否还在引用父元素。如果不是，我们将与父元素交换最大的元素，将它们放入适当的位置。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nd"><img src="../Images/2699d86b9634e93fab5e9990a27a2dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOrGF6Ko12ZnnCa8labzUA.png"/></div></div></figure><p id="b9fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止还不错，对吧？！</p><p id="3e97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事情变得有点棘手了。</p><p id="0454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们一次只比较三个元素，我们需要一种方法来确保我们的交换不会影响堆中更靠后的元素。我们将从  <strong class="js iu"> <em class="mt">开始自下而上</em> </strong>的堆积这个数组<strong class="js iu"> <em class="mt">。这意味着我们所做的任何交换都会改变下面节点的父元素。我们需要在适当的位置进行某种检查，以确保我们的下层元素仍然正常！让我们抛出一个递归调用在那里，以确保！</em></strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nd"><img src="../Images/6362c84fb560ecd7d2113246e5085735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*id456UzuXopLXRwzCjVmNw.png"/></div></div></figure><p id="9c9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要的最后一样东西。每次我们进行切换时，这个递归调用都会波及到我们的堆。当我们检查堆的底部元素时，它们将紧挨着我们已经从堆中取出并排序的元素。所以我们要确保他们不受干扰。这就是为什么我们传入在堆中使用的数组的长度。让我们确保不要超过那个长度！</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nd"><img src="../Images/18a3c10f589cfc85886d84114791f6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DwmfnKsZhQEP1_dqiydoHg.png"/></div></div></figure><p id="56fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重要的是要记住<code class="fe mu mv mw mx b">largest</code>和<code class="fe mu mv mw mx b">i</code>只是指索引。在我们交换那些元素之后，<code class="fe mu mv mw mx b">largest</code>指的是在交换 之前最大元素为<strong class="js iu"> <em class="mt">的索引。所以我们可以用它作为递归调用的父对象，来检查它下面的元素。</em></strong></p><p id="4abe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">邪恶。我们的健康建立了！让我们建立我们的堆！</p><h2 id="fe55" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">分类堆</h2><p id="de3c" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">还记得我说过我们将从<strong class="js iu"> <em class="mt">自下而上</em> </strong>排序吗？这意味着我们需要找到堆中的最后一个父节点，我们称之为<code class="fe mu mv mw mx b">i</code>。幸运的是，这将总是等于数组长度除以2减1。不相信我？向上滚动，看看我们的带有索引的示例堆！</p><p id="7aeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还需要找到最后一个孩子，我们称之为<code class="fe mu mv mw mx b">k</code>。这个很简单，因为它是数组中的最后一个元素。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ne"><img src="../Images/dbefeaf6ffbaa4c01d496b6728bc8648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOASpZP6Kk4Pql9nNOU24A.png"/></div></div></figure><p id="af2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很好。现在我们可以从最后一个父节点开始，然后一路向上！</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ne"><img src="../Images/75730937dfa937aeceacbedcdc5c5a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHKwDJ5c2bPJyflsHHx2iQ.png"/></div></div></figure><p id="522e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧！现在我们有了最大堆。在第一轮堆化之后，我们的堆应该是这样的:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/16480036088112ab8663f304b2b76ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*mD_-x_X0I1qxRxPZvCQDnw.jpeg"/></div></figure><p id="2992" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以进入算法的第二步了！让我们再来看看我们的步骤:</p><ol class=""><li id="6548" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">构建一个最大堆，让值最大的元素在最上面。(搞定！)</li><li id="ab36" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">将它与最后一个元素交换，并将其从堆中移除。</li><li id="17cf" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">重复第一步和第二步，直到堆只剩下元素</li></ol><p id="118d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，现在我们要把8和1换一下，这样我们就有了:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/92380e2b3297ab72d1ffa488262e9b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*_50m8QGuOvRYP-EXod7nYw.jpeg"/></div></figure><p id="09b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们从堆中移除8:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/a2de54d88b79ffd388dd931bcc315ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*Whz6V7MbPFiMvu-GD1wc6Q.jpeg"/></div></figure><p id="f9c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将通过简单地缩短我们正在堆积的数组的长度来表示最大元素的移除。此时，我们的数组如下所示:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nf"><img src="../Images/c72e2853edb0efce468c7ed95523f440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTDerwpmKRerQpFeOBeIIA.png"/></div></div></figure><p id="b583" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们可以再次heapify我们的数组，这次传入的长度是7，所以我们的heapify函数将忽略最后一项。步骤3说我们将“重复步骤1和2，直到堆只剩下一个元素。”听起来像是一个while循环！</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ng"><img src="../Images/93b22b80e51406f51171930bf37360f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0isybKjBzHgqvVgv--Wxhg.png"/></div></div></figure><p id="ebdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里记住<code class="fe mu mv mw mx b">k</code>是我们堆里最后一个<strong class="js iu"><em class="mt"/></strong><em class="mt"/>的孩子。它目前等于<code class="fe mu mv mw mx b">length — 1</code>，这意味着我们可以在第12行<strong class="js iu"> <em class="mt">和</em> </strong>的交换中使用它，作为我们下一个heapify调用的长度参数。然后，我们可以继续递减它，并将其用作heapify的长度参数，直到堆中没有任何内容，并且所有内容都已排序。不错！</p><p id="977b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这个算法将我们的数组<strong class="js iu"> <em class="mt">排序到</em> </strong>的位置，这意味着它切换了我们原始数组的元素，而不是创建一个新的数组，它是我们原始数组的排序版本，我们可以简单地返回原始数组。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ng"><img src="../Images/807fe0f14de0e9669d6ae936bcfed6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KB2yIM09VYELUpP4j4IYog.png"/></div></div></figure><p id="1624" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以现在把我们所有的代码放在一起，我们得到…</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nd"><img src="../Images/e951eafa1ed856b67dd4d04e55d1a02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VE8QBpRoRknooajwLvbEQg.png"/></div></div></figure><p id="b51f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">去吧！试试吧！</p><h2 id="b854" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">最后的想法和GIF</h2><p id="218f" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我知道这很难理解。但是，如果我不提及几件事，那我就失职了。</p><p id="e1c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，这个堆排序就地对我们的数组<strong class="js iu"><em class="mt"/></strong>进行排序，这是一个副作用，因为它改变了我们的原始数组。这意味着它不适合函数式编程范式。所以如果你想让你的程序保持在函数式编程的范围内，就不要使用堆排序！</p><p id="3b1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做的好处是，它不会消耗太多额外的内存来运行，这使它比其他一些排序算法(如quicksort)更有优势。对于你们这些大O怪胎来说，heapsort的空间复杂度是O(1)，这真的非常好。</p><p id="f9be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我现在所有的额外想法。感谢阅读！我希望你受到鼓励，走出去尽情享受吧！如果您仍然感到有些困惑，请查看这张gif，看看heapsort的运行情况。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0218770e99cc0ade5996b15e18828e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/1*LVcbTeL6zPLfDHiQ2w3Jtw.gif"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">从维基百科的堆排序页面中提取</figcaption></figure></div></div>    
</body>
</html>