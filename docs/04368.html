<html>
<head>
<title>Angular vs. React Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度与反应形式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-vs-react-forms-e2c6cc0270da?source=collection_archive---------9-----------------------#2020-06-23">https://levelup.gitconnected.com/angular-vs-react-forms-e2c6cc0270da?source=collection_archive---------9-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d7d21d7794a3231a4eaec7ac5827c46e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xd9eM5cycWTz6O9Fh1SVzg.jpeg"/></div></div></figure><p id="a389" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">许多开发人员在实现web应用程序时会问自己使用哪个框架/库。大多是有棱角的，有反应的，有问题的。</p><p id="42ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为许多web应用程序都基于表单(大多数是复杂的表单)，所以了解每个框架/库如何处理和支持构建表单是至关重要的。我希望这篇文章能够回答许多关于表单的问题。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4459" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">挑战🔥</h1><p id="da57" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">实现表单时最大的挑战是什么？</p><h2 id="a8db" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">表单模型和验证</h2><p id="5ad1" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">表单模型的定义方式和位置，以及如何处理验证。</p><h2 id="916c" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">动态表单和可重用表单</h2><p id="324f" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">如何动态添加表单并使其可重用？子表单及其验证器是如何与父表单连接的。</p><h2 id="4104" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">表单状态</h2><p id="2d80" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">如何定义以及在哪里定义。确定表单及其控件是否被触摸很重要，例如启用/禁用提交按钮。还需要跟踪值的变化、状态的变化、获取值等</p><h2 id="3227" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">更复杂的验证</h2><p id="0e34" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">通常，某些特性会推动对更复杂验证的需求，如交叉验证、异步验证、正则表达式验证和任何其他自定义验证。例如，一旦一个复选框被选中，就会显示一个新的表单，或者一个字段的值决定了另一个字段允许的值。</p><h2 id="af2d" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">正式安排</h2><p id="b7e8" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">表单控件的聚合器和容器。例如项目列表。</p><h1 id="2685" class="lg lh it bd li lj mv ll lm ln mw lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">应用✍️</h1><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="595e" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">有角的</h1><h2 id="3c0c" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">表单模型和验证</h2><p id="bd69" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Angular提供了两种不同形式的方法:</p><p id="a392" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<strong class="kd iu">模板驱动的表单</strong></p><p id="6ded" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<strong class="kd iu">反应形式</strong></p><p id="28ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">他们实际上做什么？它们捕获基本上所有的用户输入事件，验证它们，并提供一种跟踪所有变化的方法。</p><p id="31dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两种方法的主要区别是管理表单数据。</p><p id="135b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总的来说:</p><p id="4839" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<strong class="kd iu">反应形式</strong>更强大，更好测试和扩展(围绕可观察的流构建)。它们是同步的，这就是为什么它们更容易预测。</p><p id="fa32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<strong class="kd iu">模板驱动表单</strong>将整个逻辑封装在一个模板(html)中。它们主要适用于简单的场景(比如注册表单)。与反应型相比，扩展和测试它们更加困难。它们是<strong class="kd iu">异步</strong>。</p><p id="b251" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为反应式表单是同步的，而模板驱动的是异步的，所以这两种方法不应该混合使用(在一个模板中),因为这会导致一些不可预知的结果和行为。</p><p id="2650" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">免责声明:</strong>我在我的应用程序<strong class="kd iu"> </strong>中只使用<strong class="kd iu">反应式表单</strong>，我不会描述验证和其他机制是如何在模板驱动的表单中解决和设计的。</p><p id="9b79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个如何定义表单模型的例子。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">组件中的表单模型</figcaption></figure><p id="2690" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nl">表单组</em>基本上是一个<em class="nl">表单控件</em>的容器，并跟踪其所有控件的状态和变化。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">模板中的表单模型</figcaption></figure><p id="a5fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该模板还包含一个<em class="nl">表单组</em>。它在组件中的模型和包含输入的html模板中的表单之间进行通信。</p><p id="6046" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nl"> FormControlName </em>绑定<em class="nl"> FormGroup </em>(组件中)<em class="nl">中定义的每个<em class="nl"> FormControl </em>输入。</em></p><h2 id="0cef" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">表单状态</h2><p id="8e85" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">反应式表单控件基于<a class="ae nm" href="https://gist.github.com/enestoro/ab518ce2139bb3a0258171d42e284076" rel="noopener ugc nofollow" target="_blank"> <em class="nl">抽象控件</em> </a> <em class="nl"> </em>类。它包含以下字段:</p><p id="227a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl">值、错误、有效、禁用、触摸、… </em></p><p id="3c73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和方法，例如:</p><p id="7197" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl"> valueChanges和statusChanges </em>(两者都返回一个<a class="ae nm" href="https://www.learnrxjs.io/" rel="noopener ugc nofollow" target="_blank">可观察值</a>)，<em class="nl">禁用、启用、设置错误、设置验证器、设置值、重置、标记关闭、… </em></p><h2 id="640d" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">动态表单和可重用表单</h2><p id="c6f4" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">为了创建可重用的表单<a class="ae nm" href="https://angular.io/api/forms/ControlValueAccessor" rel="noopener ugc nofollow" target="_blank"><em class="nl">ControlValueAccessor</em></a><em class="nl"/>【CVA】<em class="nl"/>进场。它充当了Angular Forms API和原生DOM元素之间的桥梁。它可以用于许多不同的表单控件，如输入、单选、选择、范围……但也可以用于可重用的表单，如下例所示:a<em class="nl">address组件</em>。</p><p id="927b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的应用程序中，如果帐单和送货地址不同，可以动态添加一个新地址。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">控制值存取器</figcaption></figure><p id="5bae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了能够将组件用作CVA，您需要从其接口实现方法并正确注册它:</p><p id="7440" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl"> writeValue </em>向元素写入新值(model = &gt; view)</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="ff98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl"> registerOnChange </em>注册一个回调函数，当输入元素发生变化事件时调用该函数(view = &gt; model)</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="e974" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl">register intouched</em>到<em class="nl"> </em>注册一个回调函数，当输入元素上发生模糊事件时调用该函数(view = &gt; model)</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="f09a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl"> NG_VALUE_ACCESSOR </em>和<em class="nl"> NG_VALIDATORS </em></p><p id="dbdd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nl"> NG_VALUE_ACCESSOR </em>注册一个组件，并将一个自定义表单控件集成到反应角度表单<em class="nl">。</em></p><p id="5bea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nl"> NG_VALIDATORS </em>集成对控制值访问器的验证。例如，有一个父表单需要顶层<em class="nl"> </em>的CVA子表单状态来启用/禁用提交按钮。CVA的状态是封装的，所以父节点看不到是否没有提供<em class="nl"> NG_VALIDATORS </em>以及是否没有实现<em class="nl"> validate </em>方法。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><h2 id="8c56" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">验证&amp;更复杂的验证</h2><p id="7f91" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Angular提供了两种类型的验证函数:</p><p id="dbf7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉同步验证器，返回一组错误或空值(如果没有错误)</p><p id="f1dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<strong class="kd iu">异步验证器</strong>，它返回一个发出一组错误或空值的可观察对象或承诺</p><blockquote class="nn no np"><p id="749f" class="kb kc nl kd b ke kf kg kh ki kj kk kl nq kn ko kp nr kr ks kt ns kv kw kx ky im bi translated">出于性能原因，Angular只在所有同步验证器都通过的情况下运行异步验证器。每个都必须在设置错误之前完成。</p></blockquote><p id="47fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Angular有一套内置的<a class="ae nm" href="https://angular.io/api/forms/Validators" rel="noopener ugc nofollow" target="_blank">验证器</a>，例如:必选、最小/最大、电子邮件、模式、最小长度/最大长度、…</p><p id="61c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">内置角度验证器的使用示例:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="074e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也可以定义自定义验证器，就像我所做的那样:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><h2 id="9234" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">形成数组</h2><p id="d07c" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Angular提供了<a class="ae nm" href="https://angular.io/api/forms/FormArray" rel="noopener ugc nofollow" target="_blank">形式数组</a>来支持表单控件数量动态变化的用例。想象一个巨大的表单，您可以在其中的一个列表中输入任意数量的递送地址:</p><p id="cb98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl">控制，长度，at(索引)</em></p><p id="0553" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl"> push，insert(index，control)，removeAt(index)，patchValue，setValue，clear，… </em></p><p id="a108" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一篇关于表单数组的非常好的文章:<a class="ae nm" href="https://netbasal.com/angular-reactive-forms-the-ultimate-guide-to-formarray-3adbe6b0b61a" rel="noopener ugc nofollow" target="_blank">https://net basal . com/angular-reactive-forms-the-ultimate-guide-to-formarray-3 adbe 6b 0 b 61 a</a></p><h1 id="8a90" class="lg lh it bd li lj mv ll lm ln mw lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">反应</h1><h2 id="f968" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">表单模型和验证</h2><p id="653f" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在React中，三个最流行的表单库是:</p><p id="5466" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<a class="ae nm" href="https://react-hook-form.com/" rel="noopener ugc nofollow" target="_blank">反应挂钩形式</a></p><p id="81a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<a class="ae nm" href="https://jaredpalmer.com/formik/" rel="noopener ugc nofollow" target="_blank">福米克</a></p><p id="b79b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<a class="ae nm" href="https://redux-form.com" rel="noopener ugc nofollow" target="_blank">还原形式</a></p><p id="83ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的应用中，我使用了<strong class="kd iu">反应钩子形式</strong>。我选择这个非常强大的库的一些原因:</p><p id="d9d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉API非常简单和直观</p><p id="6814" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉非常<strong class="kd iu">小</strong>库<strong class="kd iu">没有任何依赖</strong></p><p id="ca73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<strong class="kd iu">非常好的性能</strong>(避免了不必要的重新渲染周期；非常短的安装时间)</p><p id="020f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<strong class="kd iu">减少了</strong>要写的代码量</p><p id="4a3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<strong class="kd iu">易于适配</strong>和<strong class="kd iu">将</strong> <strong class="kd iu">与任何框架或UI库</strong>集成</p><p id="75f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">详细的对比检查<a class="ae nm" href="https://blog.logrocket.com/react-hook-form-vs-formik-a-technical-and-performance-comparison/" rel="noopener ugc nofollow" target="_blank">请点击</a>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="f2b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个如何定义表单模型的例子。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="2494" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用<a class="ae nm" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank">是的</a>进行<a class="ae nm" href="https://react-hook-form.com/api#validationSchema" rel="noopener ugc nofollow" target="_blank">基于模式的表单验证</a>。Yup允许对复杂的验证和值转换进行建模。这种形式与角形完全相同。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="41cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae nm" href="https://react-hook-form.com/api/#useForm" rel="noopener ugc nofollow" target="_blank"><em class="nl"/></a><em class="nl"/>方法一旦被调用，就会提供很多有用的方法，如:<code class="fe nt nu nv nw b">register</code>、<code class="fe nt nu nv nw b">unregister</code>、<code class="fe nt nu nv nw b">errors</code>、<code class="fe nt nu nv nw b">watch</code>、<code class="fe nt nu nv nw b">handleSubmit</code>、<code class="fe nt nu nv nw b">reset</code>、<code class="fe nt nu nv nw b">setError</code>、<code class="fe nt nu nv nw b">clearError</code>、<code class="fe nt nu nv nw b">setValue</code>、<code class="fe nt nu nv nw b">getValues</code>、<code class="fe nt nu nv nw b">triggerValidation</code>、<code class="fe nt nu nv nw b">control</code>和<code class="fe nt nu nv nw b">formState.</code></p><p id="b25d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我设置了一些可选参数，如<em class="nl">模式</em>和<em class="nl">验证模式</em>。</p><p id="4922" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl">模式</em>定义何时触发验证(<em class="nl"> onSubmit </em>、<em class="nl"> onBlur </em>、<em class="nl"> onChange </em>)</p><p id="a895" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl">验证模式a </em>用<code class="fe nt nu nv nw b">Yup</code>应用表单验证规则</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="cc45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nl"> InputRef </em>是<a class="ae nm" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank">material-ui</a><a class="ae nm" href="https://material-ui.com/api/form-control-label/" rel="noopener ugc nofollow" target="_blank"><em class="nl">FormControlLabel</em></a>组件(带标签的复选框)的一部分。它将一个<strong class="kd iu"> ref </strong>传递给<em class="nl"> input </em>元素，这样就可以注册一个表单控件。</p><h2 id="4243" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">表单状态</h2><p id="5e0c" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">如前所述，<em class="nl"> useForm </em>提供了一个<a class="ae nm" href="https://react-hook-form.com/api/#formState" rel="noopener ugc nofollow" target="_blank"><em class="nl">formState</em></a><em class="nl"/>对象，其中包含了关于表单状态的信息。</p><p id="aec5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它包含以下信息:</p><p id="71eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl">脏，脏字段，已提交，已触摸，有效，正在提交，提交计数</em></p><h2 id="3692" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">动态表单和可重用表单</h2><p id="1646" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">AddressDataForm 是一个动态的、可重用的表单。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="0c30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了将该表单与父表单OrderDataForm连接起来，我在子表单中使用了<a class="ae nm" href="https://react-hook-form.com/advanced-usage#ConnectForm" rel="noopener ugc nofollow" target="_blank">表单上下文</a>:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="a65d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在父表单中，我使用了<em class="nl"> FormContext </em>并传递了<em class="nl">表单:</em></p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><h2 id="4141" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">验证&amp;更复杂的验证</h2><p id="e945" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">我使用yup作为验证模式。也可以使用任何其他外部验证，如<a class="ae nm" href="https://github.com/hapijs/joi" rel="noopener ugc nofollow" target="_blank"> joi </a>或<a class="ae nm" href="https://github.com/ianstormtaylor/superstruct" rel="noopener ugc nofollow" target="_blank"> Superstruct </a>。</p><p id="c39a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是如何定义验证模式以及如何定义其消息错误的示例:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="ea6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并且在父表单中，父表单的模式包含子表单的模式:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="0bc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为billingAddress表单是有条件地添加的(在复选框上)，所以它的验证将被有条件地添加和激活。</p><p id="e848" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是非常强大的，使添加交叉验证成为可能，见<em class="nl">之一:</em></p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ng nf l"/></div></figure><h2 id="c94f" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">形成数组</h2><p id="95d2" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">React-Hook-Form支持<a class="ae nm" href="https://react-hook-form.com/advanced-usage#FieldArrays" rel="noopener ugc nofollow" target="_blank">形式数组</a>(字段数组)也非常类似于Angular。</p><p id="7593" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉字段<em class="nl">，… </em></p><p id="4b83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">👉<em class="nl">追加、前置、移除、交换、移动、插入……</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="08c8" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">摘要😎</h1><p id="bf63" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">看到了最相关的外形特征:这两种解决方案的优点和缺点分别是什么？</p><h2 id="1644" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated"><strong class="ak">有角度的</strong></h2><h2 id="f4a2" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">表单模型和验证</h2><p id="c46f" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">✅ <strong class="kd iu">两种表单类型</strong>:反应式/模板驱动及其模式，这些都有很好的文档记录(如何使用它们，有什么区别)。</p><h2 id="f358" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">动态表单和可重用表单</h2><p id="18b5" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">✅ <strong class="kd iu">定制表单控件:</strong> ControlValueAccessors API，用于构建定制表单控件或具有许多字段的可重用表单。</p><h2 id="1eaa" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">表单状态</h2><p id="ef84" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">✅ <strong class="kd iu">表单状态和表单模型</strong>:包含(几乎😉)一切——表单控件、表单数组、表单组。还有:表单状态、流(值改变、状态改变)和非常重要👉所有这些都在表单级别和<strong class="kd iu">表单控制</strong>级别。</p><p id="3175" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🔴对于现场状态(反应式)来说，没有什么比监听器更好的了</p><h2 id="a5f7" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">更复杂的验证</h2><p id="65ec" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">✅ <strong class="kd iu">内置验证器和定制验证器</strong>:实现和附加定制验证器是可能的。</p><h2 id="e791" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">正式安排</h2><p id="64c9" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">完全支持✅表单容器。</p><h2 id="0a9a" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">🎁测试</h2><p id="982d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Angular有一个很好的测试设置，并提供了很多单元和集成测试的技巧和技术。<strong class="kd iu">反应式表单</strong>非常容易测试(在组件级)和定制验证器。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="4bf7" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">反应</h2><h2 id="9ada" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">表单模型和验证</h2><p id="05a9" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">✅表单模型包含所有需要的信息。</p><p id="d790" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">✅ / 🔴不同的库(例如<em class="nl"> material-ui </em>)提供了其他方法来添加表单控件到模型中。有时需要使用某种类似<a class="ae nm" href="https://react-hook-form.com/api#Controller" rel="noopener ugc nofollow" target="_blank"> <em class="nl">控制器</em> </a>的桥接器。</p><h2 id="df39" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">动态表单和可重用表单</h2><p id="110e" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">✅使用React Hook表单可以构建可重用的表单，并将它们连接到父表单及其验证。</p><h2 id="ae72" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">表单状态</h2><p id="6220" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">✅表单状态也包含所有需要的信息。</p><p id="b4a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🔴我在文档中找不到类似Angular的<em class="nl"> statusChange </em>这样的东西。我觉得真的很有用。也没有什么比表单控件状态改变了:<em class="nl">感动，质朴，… </em></p><h2 id="a6df" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">更复杂的验证</h2><p id="e676" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">✅:有很多模式和验证器，比如支持更复杂验证的Yup。</p><p id="7a17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🔴因为有很多可能性，并且不是每个外部验证器都支持我们需要的，所以需要有一个很好的概述，应该使用哪一个，哪一个最适合我们的用例。</p><h2 id="8077" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">正式安排</h2><p id="7bd2" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">完全支持✅形式的安排。</p><h2 id="79fd" class="mj lh it bd li mk ml dn lm mm mn dp lq km mo mp lu kq mq mr ly ku ms mt mc mu bi translated">🎁测试</h2><p id="4e20" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">测试是可能的，但不像Angular那样容易和有据可查。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="4051" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Angular </strong>它的模式、内置特性和开箱即用的文档对我来说似乎更强大💪。然而，如果您更看重灵活性，并且愿意花一些时间来构建一个更定制的解决方案，那么React 可能更适合您的用例。</p></div></div>    
</body>
</html>