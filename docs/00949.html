<html>
<head>
<title>New Javascript Features in 2019: Optional Chaining and Null-Coalescing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2019年新增的Javascript特性:可选链接和空合并</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/new-javascript-features-in-2019-optional-chaining-null-coalescing-a7fd38f4ef2d?source=collection_archive---------0-----------------------#2019-09-28">https://levelup.gitconnected.com/new-javascript-features-in-2019-optional-chaining-null-coalescing-a7fd38f4ef2d?source=collection_archive---------0-----------------------#2019-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/577379011108ab1f8c32efee0f423e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K-_PS05PiFvMB1Ff"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@maxcodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">麦克斯·尼尔森</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="695e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我所有的文章现在都是免费的<a class="ae kf" href="https://brandonburrus.com/blog" rel="noopener ugc nofollow" target="_blank">这里</a>，不需要订阅Medium！</p><p id="7110" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您知道Javascript代码库中最常见的错误是什么吗？按顺序，它们是:</p><ul class=""><li id="e8f6" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">TypeError:无法读取属性</li><li id="9e13" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">type error:“undefined”不是对象</li><li id="368d" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">TypeError: null不是对象</li></ul><p id="581e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么所有这些错误有什么共同点呢？它们都处理<em class="ls">引用</em>，特别是不存在的引用，要么是因为引用不存在(它是<code class="fe lt lu lv lw b">undefined</code>)，要么是引用已经被显式地设置为nothing(删除或设置为<code class="fe lt lu lv lw b">null</code>)。</p><p id="0578" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Javascript中，我们需要显式地检查每个引用，以确保它是定义好的。如果我们在一个对象中有一个深度嵌套的引用，它可能看起来像这样:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="5274" class="mf mg it lw b gy mh mi l mj mk">// quick note: this is very abstract pseudo-code!<br/>let referenceToSomeObject = {};</span><span id="fa86" class="mf mg it lw b gy ml mi l mj mk">let dataThatIWant = referenceToSomeObject<br/>  &amp;&amp; referenceToSomeObject.level1<br/>  &amp;&amp; referenceToSomeObject.level1.level2<br/>  &amp;&amp; referenceToSomeObject.level1.level2.dataIActuallyWant<br/>  || 'This is the fallback value if anything in the above check is falsy';</span><span id="46d8" class="mf mg it lw b gy ml mi l mj mk">// Now I can actually safely use dataThatIWant with peace of mind!</span></pre><p id="e9d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唷！你可以看到，为了安全地使用<code class="fe lt lu lv lw b">dataThatIWant</code>,你必须让JS解释器经受考验，让它检查每一件小事，然后提供一个缺省值，以防检查中的任何事情是假的(是的，假的是正确的词，我们稍后将回到这一点)。</p><p id="23fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但这是一个相当可笑的例子。实际上，我们只需要对实际上更有可能拥有不存在的引用的东西进行这样的检查。类似于网络获取:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="9d9e" class="mf mg it lw b gy mh mi l mj mk">let networkFetchResult = await fetch("https://myfriends.com/user/123").then(res =&gt; res.json());</span><span id="f026" class="mf mg it lw b gy ml mi l mj mk">// Let's assume that the first friend of our request user is our best friend<br/>let bestFriendsName = networkFetchResult<br/>  &amp;&amp; networkFetchResult.data<br/>  &amp;&amp; networkFetchResult.data.user<br/>  &amp;&amp; networkFetchResult.data.user.friends<br/>  &amp;&amp; networkFetchResult.data.user.friends[0]<br/>  &amp;&amp; networkFetchResult.data.user.friends[0].name<br/>  || "You don't have any friends!";</span></pre><p id="b105" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">又快又乱又难看，这就是为什么前三种Javascript错误都与不存在的引用有关，因为没有人想写那样的代码。对我们来说幸运的是，Javascript有一些新的特性，这些特性将使编写安全的代码变得干净。</p><p id="ddd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们可以使用可选的链接安全地遍历对象中的嵌套引用。你可以把它看作是一种点符号链表达式的懒惰计算。如果在链中的任何一点一个引用被破坏，并证明是不存在的，整个可选链表达式简单地返回为' undefined '。使用可选链接，我们的获取现在可能看起来像这样:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="5060" class="mf mg it lw b gy mh mi l mj mk">let networkFetchResult = await fetch("https://myfriends.com/user/123").then(res =&gt; res.json());</span><span id="9e4a" class="mf mg it lw b gy ml mi l mj mk">// Still assuming that our first friend is our best friend<br/>let bestFriendsName = networkFetchResult?.data?.user?.friends?.[0]?.name || "You don't have any friends!";</span></pre><p id="d64a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哇，我们的代码立刻干净了很多，但仍然相当安全。如果我们提取的用户有一个最好的朋友，我们得到他们的名字，或者我们得到我们提供的默认回退值。我们所要做的就是使用可选的点符号操作符，而不是常规的点符号。这种新语法真正令人惊叹的地方是，您可以看到它也适用于数组索引，因此我们可以安全地访问可能也不存在的数组索引。(这也适用于调用函数时，查看<a class="ae kf" href="https://github.com/tc39/proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank"> TC39可选链接建议</a>了解更多详情！)</p><p id="d9e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就把我们带到了下一部分，因为我们还有一个小问题。如果我们最好的朋友的名字存在，但是是空的，我们的价值会是什么？如果我们最好的朋友的名字是一个空字符串，这被认为是一个假值，这意味着即使我们的值存在，它仍然会使用我们的后备值。幸运的是，这就是我们下一个新功能出现的地方。</p><p id="c1bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Null-Coalescing操作符有一个听起来很吓人的名字，但是你可以把它看作是<code class="fe lt lu lv lw b">||</code>操作符的孪生兄弟。不同之处在于，新的操作符<code class="fe lt lu lv lw b">??</code>仅在评估值为<code class="fe lt lu lv lw b">undefined</code>或<code class="fe lt lu lv lw b">null</code>时提供默认值。了解这一点后，让我们在示例中使用它:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="2fca" class="mf mg it lw b gy mh mi l mj mk">let networkFetchResult = await fetch("https://myfriends.com/user/123").then(res =&gt; res.json());</span><span id="cec9" class="mf mg it lw b gy ml mi l mj mk">let bestFriendsName = networkFetchResult?.data?.user?.friends?.[0]?.name ?? "You don't have any friends!";</span></pre><p id="a376" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些新特性使得编写安全、简洁的代码变得异常容易。那么我们什么时候可以使用这些新功能呢？嗯，看情况。到目前为止，这些新特性只是最近才被证实会出现在下一个Javascript版本中，也就是明年的某个时候。不幸的是，因为这个版本只是对Javascript规范的更新，所以何时添加这些新特性取决于浏览器厂商。</p><p id="93f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，多亏了Typescript，我们将能够更早地使用这些新功能。Typescript的下一个版本，<a class="ae kf" href="https://github.com/Microsoft/TypeScript/wiki/Roadmap#37-november-2019" rel="noopener ugc nofollow" target="_blank"> version 3.7 </a>将于今年11月发布，将包含这两个新特性(以及一些非常好的Typescript新增功能)。如果您希望避免Typescript而支持babel，并且仍然希望利用这些新的JS特性，请查看babel插件中的<a class="ae kf" href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a>和<a class="ae kf" href="https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator" rel="noopener ugc nofollow" target="_blank">无效合并</a>。</p><p id="2351" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参考资料:</p><p id="9073" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[[1]滚动条最常见的Javascript错误:<a class="ae kf" href="https://rollbar.com/blog/top-10-javascript-errors/" rel="noopener ugc nofollow" target="_blank">https://rollbar.com/blog/top-10-javascript-errors/</a></p><p id="3aa5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[[2] TC39可选链接建议:【https://github.com/tc39/proposal-optional-chaining】T2</p><p id="1f74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[[3] TC39无效合并运算符提议:【https://github.com/tc39/proposal-nullish-coalescing<a class="ae kf" href="https://github.com/tc39/proposal-nullish-coalescing" rel="noopener ugc nofollow" target="_blank"/></p><p id="a2f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[[4] Typescript 3.7路线图:<a class="ae kf" href="https://github.com/Microsoft/TypeScript/wiki/Roadmap#37-november-2019" rel="noopener ugc nofollow" target="_blank">https://github . com/Microsoft/Typescript/wiki/Roadmap # 37-2019年11月</a> ]</p><p id="497e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[[5]可选链接Babel插件:<a class="ae kf" href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank">https://Babel js . io/docs/en/Babel-Plugin-proposal-Optional-Chaining</a>]</p><p id="ad33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[[6] Nullish-Coalescing Babel插件:<a class="ae kf" href="https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator" rel="noopener ugc nofollow" target="_blank">https://Babel js . io/docs/en/Babel-Plugin-proposal-Nullish-Coalescing-operator</a></p></div></div>    
</body>
</html>