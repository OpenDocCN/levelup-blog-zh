<html>
<head>
<title>Java Changed How I Write Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java改变了我编写Python的方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-changed-how-i-write-python-f556bda69bbf?source=collection_archive---------12-----------------------#2020-07-16">https://levelup.gitconnected.com/java-changed-how-i-write-python-f556bda69bbf?source=collection_archive---------12-----------------------#2020-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6357" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从两种语言中吸取的经验教训</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c9b7008fdf31fd11552d4499610f1fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuVRXs2-zkFXUS_d9RyKTA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">明智的选择—图片信用edu reka:<a class="ae ky" href="https://www.youtube.com/watch?v=s3Ejdx6cIho" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=s3Ejdx6cIho</a></figcaption></figure><p id="62ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">即将发布第2部分:Python改变了我编写Java的方式</em></p><p id="dab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从研究生院毕业后，我非常喜欢用Python写代码，而且只喜欢用Python。其他语言似乎太冗长，尤其是Java。只需对比这些<strong class="lb iu"> helloworld </strong>的例子。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2979" class="mb mc it lx b gy md me l mf mg">print('hello world')   </span><span id="2b99" class="mb mc it lx b gy mh me l mf mg">---------------</span><span id="67a4" class="mb mc it lx b gy mh me l mf mg">public class Main {    <br/>    public static void main(String[] args) {<br/>        System.out.println("hello world");<br/>    }<br/>}<!-- --> </span></pre><p id="842a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可惜当时(2015年)我能找到的工作只有在企业，在企业<a class="ae ky" href="https://remotejavadev.com/java-is-still-king/" rel="noopener ugc nofollow" target="_blank"> Java为王</a>。不知何故，我找到了一个，随着时间的推移，我开始学习并尊重Java及其周围的生态系统。然而，我仍然怀念Python的简单性，企业还没有准备好向更新的JVM语言如<a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>过渡。</p><p id="cdff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">终于在2019年，我用一个真正的Python栈(Python/Flask/PostgreSQL/React)找到了一份新工作。令人惊讶的是，并不全是阳光和玫瑰。事实证明，Java对我对好软件的看法有很大的影响。哦，转盘有多好...不管怎样，原因如下。</p><h1 id="bdd3" class="mi mc it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">打字和红酒一样，适量有益健康</h1><p id="8258" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><strong class="lb iu">更新:</strong>Python 3.8中的新特性是<code class="fe ne nf ng lx b">typing.Protocol</code>(在3.5中是实验性的)，它让我们更接近接口:<a class="ae ky" href="https://www.python.org/dev/peps/pep-0544/#explicitly-declaring-implementation" rel="noopener ugc nofollow" target="_blank">来看看</a>。</p><p id="107a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java和Python的一个关键区别是类型系统。Java是静态类型的；Python不是(<a class="ae ky" href="https://stackoverflow.com/questions/11328920/is-python-strongly-typed/45359010#45359010" rel="noopener ugc nofollow" target="_blank">虽然两者都使用强类型</a>)。每一种都有优点和缺点，例如静态类型允许Java编译器在代码运行之前捕捉简单的错误。它还支持ide更好的内省，这就是为什么<a class="ae ky" href="https://www.jetbrains.com/idea/" rel="noopener ugc nofollow" target="_blank"> IntelliJ </a>比它的<a class="ae ky" href="https://www.jetbrains.com/pycharm/" rel="noopener ugc nofollow" target="_blank"> PyCharm </a>对手有更好的智能感知。另一方面，许多优秀的语言特性，如monkeypatching、可变函数参数和整体简洁，都是Python动态类型的结果。</p><p id="8f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们承认打字经常是多余的，</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="83bf" class="mb mc it lx b gy md me l mf mg">name = 'Steve'     </span><span id="6935" class="mb mc it lx b gy mh me l mf mg">---------------</span><span id="2f8d" class="mb mc it lx b gy mh me l mf mg">String name = 'Steve'   </span></pre><p id="f424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中,“Steve”是一个字符串的事实是显而易见的。Python为胜利而战！然而，考虑一下Python和Java中的函数签名</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="cf5f" class="mb mc it lx b gy md me l mf mg">def randomize(names):</span><span id="b04c" class="mb mc it lx b gy mh me l mf mg">---------------</span><span id="bc85" class="mb mc it lx b gy mh me l mf mg">public static Set randomize(List&lt;String&gt; names);</span></pre><p id="8bcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python版本太模糊了。<code class="fe ne nf ng lx b">names</code>是列表、集合还是无关紧要？<code class="fe ne nf ng lx b">randomize</code>是返回一个新的集合还是随机选择现有的集合(即。不返回)？对于这些细节，您需要阅读docstring或代码。同时，Java方法签名虽然冗长，却传达了所有这些信息。很明显，预期的输入是一个列表，返回的实际上是一个集合。</p><p id="f9b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这通常会导致Python变量的过度命名，</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9ec7" class="mb mc it lx b gy md me l mf mg">def randomize_to_set(names_list)</span></pre><p id="4368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要这样！相反，通过核心库使用类型提示<code class="fe ne nf ng lx b">typing</code></p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="af80" class="mb mc it lx b gy md me l mf mg"># Python 3.9 only<br/>def randomize(names: list) -&gt; set</span><span id="862f" class="mb mc it lx b gy mh me l mf mg"># Python 3.5 - 3.8<br/>from typing import List, Set <br/>def randomize(names: List) -&gt; Set</span></pre><p id="a2e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当很少使用和使用复杂IO类型的函数时，比如使用<code class="fe ne nf ng lx b">ndarrays</code>和定制类时，类型化是非常有用的。</p><p id="3a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">小心:</strong>Python中<code class="fe ne nf ng lx b">typing</code>的一个重要方面是这些只是<em class="lv">提示</em>。<code class="fe ne nf ng lx b">randomize</code>仍可通过非列表输入调用。像PyCharm这样的IDE至少会抱怨这个问题，但是实际上没有什么能阻止代码脱离a linter运行！要通过验证更严格地执行输入，请查看如下所示的<a class="ae ky" href="https://marshmallow.readthedocs.io/en/latest/extending.html#schema-level-validation" rel="noopener ugc nofollow" target="_blank">棉花糖</a>或<code class="fe ne nf ng lx b">@dataclass</code>。</p><h1 id="726f" class="mi mc it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">对接口编程</h1><p id="91a8" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Python中非常缺乏的一个Java特性是接口，<a class="ae ky" href="https://www.quora.com/Why-doesnt-Python-have-full-OOP-features-like-private-methods-interfaces-etc#:~:text=Python%20doesn't%20have%20interfaces,implements%20a%20set%20of%20methods." rel="noopener ugc nofollow" target="_blank">也是类型系统</a>的一个折衷。已经有人尝试这么做了，但是它不太可能成为语言的一部分。</p><p id="018d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口基本上是代码库中的规范或API。如果你不熟悉，这个StackOverflow帖子上的公认答案用一个很好的例子解释了它。Python中带有类型提示的抽象类可以实现同样的事情。</p><h2 id="e410" class="mb mc it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">虚构的例子</h2><p id="670c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我和我的伙伴约翰正在开发一个交易系统。John已经同意构建底层的实用程序来实际进行交易，而我则负责更高级别的投资组合管理。我和约翰如何同时独立完成这些任务？关键是在约翰的交易系统中定义一个清晰的边界，或者说<em class="lv">界面</em>。约翰和我坐在一起，敲出这样的东西:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c912" class="mb mc it lx b gy md me l mf mg"><em class="lv">from </em>abc <em class="lv">import </em>abstractmethod<br/><em class="lv">from </em>collections <em class="lv">import </em>ABC<br/><br/><br/><em class="lv">class </em>TradingSystem(ABC):<br/><br/>    @abstractmethod<br/>    <em class="lv">def </em>buy(<em class="lv">stock</em>: <em class="lv">str</em>, account: <em class="lv">int</em>, amount: <em class="lv">float</em>) -&gt; <em class="lv">str</em>:<br/>        <em class="lv">"""<br/>        </em><strong class="lx iu"><em class="lv">:param</em></strong><em class="lv"> stock: ISIN code for stock, eg. BNY<br/>        </em><strong class="lx iu"><em class="lv">:param</em></strong><em class="lv"> account: Account number to bill order<br/>        </em><strong class="lx iu"><em class="lv">:type</em></strong><em class="lv"> amount: How much to buy in dollars<br/>        </em><strong class="lx iu"><em class="lv">:return</em></strong><em class="lv">: Unique order ID for this transaction<br/>        """<br/><br/>    </em>@abstractmethod<br/>    <em class="lv">def </em>sell(<em class="lv">stock</em>: <em class="lv">str</em>, account: <em class="lv">int</em>, amount: <em class="lv">float</em>) -&gt; <em class="lv">str</em>:<br/>        ...</span></pre><p id="bd42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实际上是一个契约——John的实现必须至少实现带有这些调用签名的<code class="fe ne nf ng lx b">buy/sell</code>方法。只要契约有效，实现细节并不重要(比如WebSockets vs HTTP)。我现在可以参考<code class="fe ne nf ng lx b">TradingSystem</code>接口<code class="fe ne nf ng lx b">sell</code>方法开始工作了，</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="e94b" class="mb mc it lx b gy md me l mf mg"><em class="lv">def </em>liquidate_financials(system: TradingSystem):<br/>    """ Sell a bunch of stock in banks """<br/>    <em class="lv">for </em>stock <em class="lv">in </em>['BNY', 'GS', 'MS']:<br/>        system.sell(stock)</span></pre><p id="484e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:I </strong>接口/抽象类可以有多个实现，例如<code class="fe ne nf ng lx b">DowJonesTradingSystem</code>和<code class="fe ne nf ng lx b">NasdaqTradingSystem</code>，但是代码只引用通用的<code class="fe ne nf ng lx b">TradingSystem</code>抽象。</p><h1 id="bdfa" class="mi mc it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">隐私和不变性</h1><p id="dfac" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在Java中，我真正怀念的一件事是变量和方法的<code class="fe ne nf ng lx b">public/protected/private</code>修饰符。其他语言Javascript和Kotlin也分别通过<code class="fe ne nf ng lx b">const</code>和<code class="fe ne nf ng lx b">val</code>支持可变不变性Javascript和Kotlin。另一方面，在Python中，没有什么是真正私有的；相反，使用<code class="fe ne nf ng lx b">_</code>或<code class="fe ne nf ng lx b">__</code>意味着隐私<a class="ae ky" href="https://stackoverflow.com/questions/1641219/does-python-have-private-variables-in-classes" rel="noopener ugc nofollow" target="_blank">，如这里所描述的</a>。以我的经验来看，这通常会导致一切都是公开的，这会模糊意图并产生泄漏的抽象。</p><h2 id="ba98" class="mb mc it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">数据类别和属性</h2><p id="8e80" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">数据类是在Python 3.7中引入的，其作用类似于Java中的<a class="ae ky" href="https://www.baeldung.com/java-pojo-class" rel="noopener ugc nofollow" target="_blank">POJO</a>。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f0e3" class="mb mc it lx b gy md me l mf mg">from dataclasses import dataclass<br/><br/>@dataclass<br/>class Book:<br/>    author: str<br/>    title: str<br/><br/><br/>book = Book('Great Expectations', 'Dickens')<br/>print(book)</span></pre><p id="f1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哪些输出</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="54b5" class="mb mc it lx b gy md me l mf mg">Book(author='Great Expectations', title='Dickens')</span></pre><p id="7e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng lx b">@dataclass</code>减少了类样板文件，例如覆盖了<code class="fe ne nf ng lx b">__hash__</code>和<code class="fe ne nf ng lx b">__repr__</code>，这就是为什么打印输出是可读的，而不是<code class="fe ne nf ng lx b">&lt;__main__.Book object at 0x00000285EBF56320&gt;</code>。还要注意，它接受了没有显式<code class="fe ne nf ng lx b">__init__</code>方法的关键字参数。</p><p id="063a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng lx b">attrs</code>包与此类似，但是与Python的旧版本兼容，并且更加全面——最好通过示例来学习<a class="ae ky" href="https://www.attrs.org/en/stable/examples.html" rel="noopener ugc nofollow" target="_blank">。再考虑一下<code class="fe ne nf ng lx b">Book</code>类，这次是用<code class="fe ne nf ng lx b">attrs</code>写的</a></p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="a1b3" class="mb mc it lx b gy md me l mf mg">import attr<br/><br/><br/>@attr.s(frozen=True, auto_attribs=True)<br/>class Book(object):<br/>    author: str<br/>    _pagecount: int = 0<br/>    title: str = 'untitled'<br/><br/><br/>book = Book(author='Dickens', title='Great Expectations', pagecount=10)<br/>print(book)</span></pre><p id="45fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其输出非常相似</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="7567" class="mb mc it lx b gy md me l mf mg">Book(author='Dickens', _pagecount=10, title='Great Expectations')</span></pre><p id="f0e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表面下隐藏着大量的东西。首先，<code class="fe ne nf ng lx b">frozen=True</code>关键字确保属性是不可变的:试图覆盖一个属性(例如<code class="fe ne nf ng lx b">book.author='other author'</code>)会引发一个异常。<code class="fe ne nf ng lx b"> auto_attribs=True</code>与<code class="fe ne nf ng lx b">@data_class</code>装饰器的作用相同；也就是说，<code class="fe ne nf ng lx b">Book</code>下的所有属性都是<em class="lv">必需的</em>并且是可公开访问的。对于细粒度的控制，分别为每个属性声明<code class="fe ne nf ng lx b">attr.ib()</code>(<a class="ae ky" href="https://www.attrs.org/en/stable/examples.html" rel="noopener ugc nofollow" target="_blank">示例</a>)。还要注意,<code class="fe ne nf ng lx b">title</code>属性有一个默认值。最后，注意<code class="fe ne nf ng lx b">pagecount</code>是使用不带<code class="fe ne nf ng lx b">_</code>的关键字设置的，但仍然会产生一个私有属性。</p><p id="fe4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了深入比较<code class="fe ne nf ng lx b">attrs</code>与其替代品(数据类、命名元组等..)<a class="ae ky" href="https://www.attrs.org/en/stable/why.html" rel="noopener ugc nofollow" target="_blank">看到这里</a>。</p><h1 id="055c" class="mi mc it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">编码不仅仅是代码</h1><p id="a21c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在研究生院，我负责编码。在我的工作中，我负责T21软件。差别是巨大的。文档、性能、API、测试套件、构建管道、持续部署、容器化、工件存储库——清单还在继续。在这方面，Python令人惊讶地笨拙。</p><h2 id="ee2b" class="mb mc it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">投诉1:可执行二进制文件</h2><p id="0d4f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在Java中，将代码和运行时依赖捆绑到一个<a class="ae ky" href="https://www.javatpoint.com/how-to-make-an-executable-jar-file-in-java" rel="noopener ugc nofollow" target="_blank">可执行jar </a>中是非常简单的。然后，jar可以在任何其他安装了Java的机器上运行，而不考虑操作系统。这对于与非技术人员分享小脚本和一次性工具非常有用。与Python相比，Python的代码是解释的，通常从源代码运行(毕竟它是一种解释型语言……)。</p><p id="f48d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的可执行二进制文件利用了几个第三方<a class="ae ky" href="https://python-guide-cn.readthedocs.io/en/latest/shipping/freezing.html" rel="noopener ugc nofollow" target="_blank">的“冻结”工具</a>。生成的二进制文件通常只与编译它的操作系统兼容。例如，Mac用户不能冻结Windows二进制文件，反之亦然。此外，当这个黑盒冻结过程失败时，很难调试，并且对于具有许多依赖项的大型程序来说，失败是可能的。</p><h2 id="c116" class="mb mc it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">那么我们能做些什么呢</h2><p id="54e6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这对于一个托管服务来说是一个很好的机会，它可以在许多不同的操作系统上冻结Python代码。但在有人建造它之前，这里有一些建议:</p><ol class=""><li id="f03f" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">如果可能，确保冻结脚本的消费者使用相同的操作系统。</li><li id="80b1" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">考虑用web服务替换脚本，即。烧瓶。</li></ol><p id="90ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然第2点听起来很简单，但是这些脚本通常是一次性的，并且是为非技术人员准备的，所以期望他们提交POST请求是不现实的。</p><h2 id="6837" class="mb mc it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">抱怨2:没有全面的SDLC工具</h2><p id="70e7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Java项目通常使用像Maven或Gradle这样的<em class="lv">声明性</em>工具来管理软件开发生命周期(SDLC)的几个方面，包括:</p><ul class=""><li id="cd97" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu og ny nz oa bi translated">管理依赖关系。</li><li id="61eb" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">编译/林挺代码</li><li id="6e96" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">运行测试</li><li id="9839" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">创建本地构建工件</li><li id="44ab" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">将二进制文件部署到像<a class="ae ky" href="https://www.sonatype.com/product-nexus-repository" rel="noopener ugc nofollow" target="_blank"> Nexus </a>这样的artifactory中(Python等价于<a class="ae ky" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank"> PyPI </a>)</li><li id="f86a" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/introduction-semantic-versioning/" rel="noopener ugc nofollow" target="_blank">语义版本化</a></li></ul><p id="1a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">免责声明:</strong> Maven是一个通用的项目管理工具，但是它是如此的集成，并且在Java中被广泛采用，以至于我将它视为Java的一部分<em class="lv">。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/900c0ac1e4d16e3878b8f08233a29795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R7IYMVAr4e2xS-aL.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">玛芬:你对那个济贫院太冷淡了。</figcaption></figure><p id="26e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，这些是以一种<em class="lv">命令式</em>异构的方式拼凑在一起的。挑选新项目时的典型流程:</p><ul class=""><li id="a8a2" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu og ny nz oa bi translated">使用pip和Anaconda创建一个干净的虚拟环境。来自需求文件的依赖关系。希望它不会因为操作系统/架构的假设(JVM没有这个问题)或者包版本不兼容(Java确实有这个问题，但是以我的经验来看不太常见)而失败。</li><li id="a195" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">使用我的IDE PyCharm在本地运行测试。</li><li id="824f" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">使用IDE绑定虚拟环境。项目的Python解释器。</li><li id="33d9" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">如果需要的话，手动安装本地的<code class="fe ne nf ng lx b">python setup.py install</code>(也要小心哪个虚拟环境。是活动的)</li><li id="affc" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">使用<a class="ae ky" href="https://realpython.com/pypi-publish-python-package/" rel="noopener ugc nofollow" target="_blank">pip install，make和<a class="ae ky" href="http://bump2version" rel="noopener ugc nofollow" target="_blank"> bump2version </a>的笨拙组合</a>部署到PyPI。</li><li id="cf58" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">PS——什么时候想要一个<a class="ae ky" href="https://packaging.python.org/discussions/wheel-vs-egg/#:~:text=Wheel%20and%20Egg%20are%20both,by%20PEP%20427%20in%202012." rel="noopener ugc nofollow" target="_blank">轮子和一个鸡蛋</a>？嘘…</li></ul><p id="3c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要误解我，Maven是XML和<a class="ae ky" href="https://maven.apache.org/guides/plugin/guide-java-report-plugin-development.html" rel="noopener ugc nofollow" target="_blank">不讨人喜欢的文档</a>的一个丑陋的大杂烩，但是一旦你掌握了窍门，它就非常强大。</p><h2 id="f983" class="mb mc it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">那么我们能做些什么呢</h2><ul class=""><li id="5f5f" class="ns nt it lb b lc mz lf na li oi lm oj lq ok lu og ny nz oa bi translated">考虑用Docker容器替换虚拟环境，并用<code class="fe ne nf ng lx b">docker-compose.</code>来管理它们<a class="ae ky" href="https://docs.docker.com/compose/gettingstarted/" rel="noopener ugc nofollow" target="_blank">实际上非常简单</a>，并且避免管理本地虚拟环境。PyCharm也有Docker集成<a class="ae ky" href="https://www.jetbrains.com/teamcity/" rel="noopener ugc nofollow" target="_blank">,它在本地甚至远程容器之外提供运行时服务。<strong class="lb iu">保护</strong> : </a><a class="ae ky" href="https://stackoverflow.com/questions/25305788/how-to-avoid-reinstalling-packages-when-building-docker-image-for-python-project" rel="noopener ugc nofollow" target="_blank">不要在每个<code class="fe ne nf ng lx b">docker build</code>上重新安装依赖关系</a>。</li><li id="9b18" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">利用<a class="ae ky" href="https://github.com/c4urself/bump2version" rel="noopener ugc nofollow" target="_blank"> bump2version </a>进行语义版本化。</li><li id="931d" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">全押在一个成熟的CI/CD工具上，如<a class="ae ky" href="https://circleci.com/continuous-integration/?utm_source=Google&amp;utm_medium=SEM&amp;utm_campaign=(Alpha)%20Search%20Signup%20Non%20Branded&amp;utm_content=(Alpha)%20Search%20Signup%20Non%20Branded-Eng-NonBranded-Continuous%20Integration&amp;utm_term=ciPage&amp;gclid=Cj0KCQjw0rr4BRCtARIsAB0_48PIs-To_IvIwaYQD32hryf-HFhS7VywdHHjMTGhjFqBbvOUDQfr35UaAictEALw_wcB" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>、<a class="ae ky" href="https://docs.gitlab.com/ee/ci/pipelines/" rel="noopener ugc nofollow" target="_blank"> Gitlab Pipelines </a>或<a class="ae ky" href="https://www.jetbrains.com/teamcity/" rel="noopener ugc nofollow" target="_blank"> Teamcity </a>。使用它来尽可能自动化SDLC管道。</li><li id="16cf" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">如果到了紧要关头，Maven可以用来管理Python。这在大量使用Java的企业中很有用，在这些企业中，Maven与许多内部服务很好地集成在一起，否则就会受到束缚。</li></ul><p id="ec85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我确信更复杂的团队已经完全自动化了Python SDLC，但是对于新手或普通程序员来说，与固执己见的Java/Maven惯例相比，它只是感觉麻烦。</p><h2 id="be0e" class="mb mc it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">抱怨三:Python速度慢</h2><p id="5f26" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这是对Python无处不在的批评。这种说法太宽泛了，不可能绝对正确或错误，而且一直争论到死(<a class="ae ky" href="https://www.monterail.com/blog/is-python-slow" rel="noopener ugc nofollow" target="_blank">这里有一个很好的起点</a>)。我把它作为一个解决更广泛问题的机会添加进来:由于以下原因，在Python中测量/调优性能可能比在Java中更困难:</p><ul class=""><li id="d562" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu og ny nz oa bi translated">JVM是超级优化的，Java是一种编译语言——因此基本代码通常比解释的Python代码运行得更快。</li><li id="f4b8" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">Python剖析</li><li id="7834" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">JVM有很好的工具，比如用于性能监控的<a class="ae ky" href="https://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank"> JMeter </a>。Python也有解决方案(例如<a class="ae ky" href="https://www.blazemeter.com/blog/jmeter-vs-locust-which-one-should-you-choose" rel="noopener ugc nofollow" target="_blank"> BlazeMeter </a>)，但它们通常依赖于应用程序工具，要么不是免费的，要么不容易设置。</li></ul><h2 id="3015" class="mb mc it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">那么我们能做些什么呢</h2><ul class=""><li id="5f71" class="ns nt it lb b lc mz lf na li oi lm oj lq ok lu og ny nz oa bi translated">什么都不做。通常应用已经足够好了，对性能的追求是一种过早的优化。不要担心扩展到10亿并发用户。</li><li id="9e33" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">I <strong class="lb iu">带有哨兵</strong>或相关<a class="ae ky" href="https://info.honeycomb.io/distributed-tracing/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=na_search_tracing&amp;utm_keyword=distributed%20tracing&amp;utm_content=distributed_tracing&amp;gclid=Cj0KCQjw0rr4BRCtARIsAB0_48NLmVy1B9gM-ITC8TyZ5MaSctQDVSrGRuSn02IbXm7SEU6fn2yzfNEaAg0AEALw_wcB" rel="noopener ugc nofollow" target="_blank">追踪/监控工具</a>的仪器。总的来说，这是一个好主意，比cProfile提供的信息多得多。</li><li id="add0" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated"><strong class="lb iu">使用框架。</strong>Python中的数据科学工具建立在Numpy、TensorFlow等已经C优化的核心技术之上。类似的，像Flask，Django和FastAPI这样的web框架都很圆滑。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/f61cc5c568b74b5c01b4e2a7b09c2889.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/0*LRIpHR5T5G_sc_r6.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="om">用各种语言(</em> <a class="ae ky" href="https://medium.com/pyslackers/yes-python-is-slow-and-i-dont-care-13763980b5a1" rel="noopener"> <em class="om"> Prechelt和Garret </em> </a> <em class="om">)编写一个字符串处理应用需要多长时间。缓慢的开发周期是真正的瓶颈/费用。</em></figcaption></figure><ul class=""><li id="1ba2" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu og ny nz oa bi translated"><strong class="lb iu">借力云</strong>。云之前(即。AWS)，应用程序代码负责除数据持久性之外的几乎所有事情。现在，我们可以将责任转移到Redis、Kafka、Lambda等高度可用的强大工具上，以降低应用程序的复杂性和瓶颈。</li><li id="1e92" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated"><strong class="lb iu">使用Cython </strong>。<a class="ae ky" href="https://cython.org/" rel="noopener ugc nofollow" target="_blank"> Cython </a>通过用c语言编译Python代码，加速了Python代码的精选部分。虽然理论上很方便，但我从未在实践中使用过它。</li><li id="21d8" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated"><strong class="lb iu">使用微服务</strong>。我不会用Python写高频交易系统或3D渲染引擎。对于某些应用，最好只使用<code class="fe ne nf ng lx b">C++</code>。微服务模式支持这种灵活性。</li></ul><h2 id="c926" class="mb mc it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">投诉4:没有物料清单</h2><p id="f5b1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Maven通常使用物料清单或BOM来定义项目间依赖关系的兼容版本。<a class="ae ky" href="https://www.baeldungtest.com/spring-maven-bom" rel="noopener ugc nofollow" target="_blank">示例</a>充满了Java/XML，所以我将提供一个Python元代码示例。</p><p id="ce1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设一个开发团队在他们的项目中发现了共同的依赖关系。为简单起见，假设他们只使用以下三个库:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0a29" class="mb mc it lx b gy md me l mf mg">numpy<br/>tensorflow<br/>flask</span></pre><p id="4178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TensorFlow有两个主要版本，1。x和2。x，它们与numpy和flask的所有版本都不兼容。通过研究或反复试验，您的团队决定采用以下(假设的)兼容版本。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9e72" class="mb mc it lx b gy md me l mf mg"># old_reliable.txt<br/>numpy=1.5.1<br/>tensorflow=1.14<br/>flask=0.7</span><span id="5817" class="mb mc it lx b gy mh me l mf mg"># latest_greatest.txt<br/>numpy=1.19<br/>tensorflow=2.0<br/>flask=1.1.2</span></pre><p id="b81b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BOM将这些关系集中在一个文件中，然后由包管理工具使用。如果<code class="fe ne nf ng lx b">pip</code>支持BOM，那么flask/numpy项目的<code class="fe ne nf ng lx b">requirements.txt</code>文件可能看起来像</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="19b5" class="mb mc it lx b gy md me l mf mg">bom=/path/to/old_reliable.txt   # Local or Remote location</span><span id="9f81" class="mb mc it lx b gy mh me l mf mg">flask<br/>numpy</span></pre><p id="0bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照<code class="fe ne nf ng lx b">old_reliable.txt</code>中的规定安装<code class="fe ne nf ng lx b">numpy=1.19</code>和<code class="fe ne nf ng lx b">flask=1.1.2</code>。相当简单，但也相当强大</p><h2 id="d70e" class="mb mc it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">那么我们能做些什么呢:</h2><ul class=""><li id="81c5" class="ns nt it lb b lc mz lf na li oi lm oj lq ok lu og ny nz oa bi translated">如本<a class="ae ky" href="https://stackoverflow.com/questions/50751234/store-a-bill-of-materials-in-python" rel="noopener ugc nofollow" target="_blank">中所述，我们可以滚动自己的线程</a>；似乎很粗糙。</li><li id="fe02" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">对于每个BOM文件，用一个<code class="fe ne nf ng lx b">requirements.txt</code>文件创建一个repo并指定包。然后<code class="fe ne nf ng lx b">pip install</code>此处所示的回购为<a class="ae ky" href="https://adamj.eu/tech/2019/03/11/pip-install-from-a-git-repository/" rel="noopener ugc nofollow" target="_blank"/>。这将确保兼容的依赖项，但是<em class="lv">也会安装所有指定的依赖项</em>，其中许多可能是多余的——唉<strong class="lb iu">。</strong></li><li id="99a2" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu og ny nz oa bi translated">提交一份<code class="fe ne nf ng lx b">pip</code>的PR支持BOMs，成为我的英雄！</li></ul></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="d9d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">我是不是漏掉了什么或者完全弄错了？留下评论，我会努力改进文章。</em> </strong></p></div></div>    
</body>
</html>