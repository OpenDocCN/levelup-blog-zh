<html>
<head>
<title>Go — working with primitive data types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">go-使用原始数据类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-working-with-primitive-data-types-a06245778957?source=collection_archive---------31-----------------------#2020-05-04">https://levelup.gitconnected.com/go-working-with-primitive-data-types-a06245778957?source=collection_archive---------31-----------------------#2020-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0de9547034ba97fbf9a5b3e685c75a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vv6HNsYtBQ7y2r17"/></div></div></figure><p id="81eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是我们开始深入研究Go语言的时候了，简单谈谈所使用的原始数据类型。我们将把这次讨论分成三个部分。</p><ol class=""><li id="1679" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">Go中的变量声明和可用的原始数据类型</li><li id="ec6a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">围棋中的指针及其特点</li><li id="5173" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">常数以及它们与其他语言的不同之处。</li></ol><p id="5f33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你来自任何其他编程语言，每一个都将与你所知道的不同。让我们详细看看它们，并试着理解这些特性。</p><h1 id="ad80" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">变量声明:</h1><p id="dfbd" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">与大多数语言不同，Go有多种声明变量的方式。</p><p id="4601" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要在Go中声明一个变量，我们指定关键字<code class="fe mn mo mp mq b">var</code>，后跟变量的名称和变量的数据类型。需要提醒你的是，Go是一种静态类型语言。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="031a" class="mz ll iq mq b gy na nb l nc nd">//classic variable declaration</span><span id="272d" class="mz ll iq mq b gy ne nb l nc nd">var age int<br/>age = 35</span></pre><p id="77db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您来自任何其他静态类型的语言，这可能对我们大多数人来说很熟悉，因为我们可能经常使用这种类型的东西。然而，这种声明是相当冗长的，仅仅为了一个声明就要举行许多仪式。</p><p id="1f85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以将声明和赋值压缩到下面的语句中，这也是完全有效的。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="62ba" class="mz ll iq mq b gy na nb l nc nd">var age int = 35</span></pre><p id="8c6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，声明仍然冗长。</p><p id="9cfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数时候我们只想声明一个变量并初始化它。我们不想要键入<code class="fe mn mo mp mq b">var</code>关键字和数据类型的所有仪式。这是我们在做编译器在大多数情况下应该能够为我们做的工作。</p><p id="64dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go也为我们解决了这个问题。我们不是以<code class="fe mn mo mp mq b">var</code>开始声明，而是以变量的名字开始，后面跟着一个<code class="fe mn mo mp mq b">:</code>，紧挨着<code class="fe mn mo mp mq b">=</code>符号。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="bbaf" class="mz ll iq mq b gy na nb l nc nd">age := 35</span></pre><p id="0bbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<code class="fe mn mo mp mq b">:=</code>将触发Go来允许我们使用我们的隐式初始化语法，这意味着Go将根据我们赋予它的内容来暗示<code class="fe mn mo mp mq b">firstName</code>的数据类型。这可能是所有Go代码库中最常用的语法。</p><p id="ad55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里还要注意的一点是，与任何其他编程语言不同，你声明一个变量而不在代码中使用它们会抛出一个编译时错误<code class="fe mn mo mp mq b">declared not used</code>。这是一个维护的事情，所以，如果你有一个变量数据类型在本地初始化，那么你必须使用这个变量。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="c4d3" class="lk ll iq bd lm ln nm lp lq lr nn lt lu lv no lx ly lz np mb mc md nq mf mg mh bi translated">指针及其功能:</h1><p id="5bc4" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">还有一种数据类型叫做<strong class="ka ir">指针</strong>。我们之前看到的数据类型是值类型。所以当你声明一个变量<code class="fe mn mo mp mq b">i</code>并赋值<code class="fe mn mo mp mq b">4</code>时，这个变量指向内存中保存值<code class="fe mn mo mp mq b">4</code>的位置。</p><p id="da62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">指针正如你可能已经知道的那样，它不是保存变量中的实际值，而是保存存储该值的内存位置的地址。指针变量的声明有点独特。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="1630" class="mz ll iq mq b gy na nb l nc nd">var firstName *string<br/>firstName = "dan"</span></pre><p id="4ca2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与普通值类型不同，打印指针变量不会给出值。相反，你会看到变量中的内存位置，比如存储值的<code class="fe mn mo mp mq b">0x40e020</code>。</p><p id="b6b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">解引用:</strong>解引用一个指针可以让我们访问指针所指向的值。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="4e6d" class="mz ll iq mq b gy na nb l nc nd">var firstName *string<br/>firstName = "dan"<br/>fmt.Println(firstName) // this prints 0x40e020<br/>fmt.Println(*firstName) // this prints dan</span></pre><p id="08d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相同的星号操作符用于表示指针变量和取消引用。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="52e1" class="lk ll iq bd lm ln nm lp lq lr nn lt lu lv no lx ly lz np mb mc md nq mf mg mh bi translated">常数</h1><p id="7389" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">在很多方面，常量和变量在Go中的作用是一样的。唯一的区别是，我们不能改变它被初始化后的值。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="0c44" class="mz ll iq mq b gy na nb l nc nd">const pi = 3.14<br/>const pi float32= 3.14</span></pre><p id="12cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">常数不能改变它的值，所以你不能声明常数，然后在以后初始化它。这里我们需要注意的另一件事是常量的数据类型需要在编译时可用。所以不能将函数的返回值赋给常数，因为函数只在运行时计算。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="8d1a" class="mz ll iq mq b gy na nb l nc nd">package main</span><span id="bfb6" class="mz ll iq mq b gy ne nb l nc nd">import(<br/> "fmt"<br/>)</span><span id="3a6e" class="mz ll iq mq b gy ne nb l nc nd">func main(){<br/>  const c = 6<br/>  fmt.Println(c + 3) //Prints 9<br/>  fmt.Println(c + 1.3) //Prints 7.3<br/>}</span></pre><p id="8feb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码片段中，我们没有指定<code class="fe mn mo mp mq b">const</code> <code class="fe mn mo mp mq b">c</code>的数据类型，所以在第一个<code class="fe mn mo mp mq b">Println</code>中，常量<code class="fe mn mo mp mq b">c</code>被计算为整数，而在下一行中，它被解释为浮点类型。这就是所谓的<strong class="ka ir">隐式类型常量</strong>。编译器会在每次遇到该类型时将它解释为适当的类型。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="8a30" class="lk ll iq bd lm ln nm lp lq lr nn lt lu lv no lx ly lz np mb mc md nq mf mg mh bi translated">结论</h1><p id="5b6a" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">Go的设计和开发秉承了简单的理念。简单，我指的是我们从中获得的极端复杂。非常冗长的语法是在非常特殊的情况下使用的，但是我们最终使用的一定是比较简单的语法。指针在其他语言中更难理解和使用，当然，它带来了额外的好处，但是这些好处被简单性超过了。此外，要注意复杂的实现和细节需要非常陡峭的学习曲线。</p><p id="07e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你还没有读过我之前关于设计Go的想法的博客，这种语言是根据今天的问题构建的，我推荐你在这里阅读<a class="ae nr" rel="noopener ugc nofollow" target="_blank" href="/go-a-quick-guide-for-getting-started-1f7a60c0512e"/>。</p><p id="a190" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go中的下一个集合数据类型实现。</p></div></div>    
</body>
</html>