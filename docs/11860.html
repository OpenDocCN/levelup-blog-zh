<html>
<head>
<title>Immutability &amp; Equality in Flutter &amp; Dart [Functional Programming — Part 4]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter和Dart中的不变性和相等性[函数式编程—第4部分]</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/immutability-equality-in-flutter-dart-functional-programming-part-4-339a4e9312bb?source=collection_archive---------6-----------------------#2022-04-24">https://levelup.gitconnected.com/immutability-equality-in-flutter-dart-functional-programming-part-4-339a4e9312bb?source=collection_archive---------6-----------------------#2022-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="c071" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@yogi-6/list/functional-programming-in-dart-flutter-2f3ac9d7fa39" rel="noopener">功能编程</a>/不变性&amp;相等</h2><div class=""/><div class=""><h2 id="989d" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用不可变的数据结构和值相等来最小化bug并维护大型应用程序。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/bc07184cf528db66afe01bf78583f28e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PioNEk2RJ5yw3g5pAm3SsA.png"/></div></div></figure><p id="0ff7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">之前，我们讨论了如何使用<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/composition-in-flutter-dart-functional-programming-part-3-ffba917aee3d">组合</a>构建模块化和可伸缩的应用程序。本文涵盖Dart &amp;颤振中的不变性和相等性。</p><h1 id="0ca8" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">目录</h1><ul class=""><li id="f795" class="mp mq iq lc b ld mr lg ms lj mt ln mu lr mv lv mw mx my mz bi translated"><a class="ae lw" href="#e905" rel="noopener ugc nofollow"> <strong class="lc ja">定义不可变的</strong> </a></li><li id="e8ee" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="#6135" rel="noopener ugc nofollow"> <strong class="lc ja">最终vs常量</strong> </a></li><li id="5750" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="#5b0f" rel="noopener ugc nofollow"> <strong class="lc ja">为什么偏爱不变性？</strong> </a></li><li id="a681" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="#ee05" rel="noopener ugc nofollow"> <strong class="lc ja">如何更新不可变状态？</strong>T24】</a></li><li id="d737" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="#c2f1" rel="noopener ugc nofollow"> <strong class="lc ja">不可变列表，地图</strong> </a></li><li id="5be2" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="#79af" rel="noopener ugc nofollow"> <strong class="lc ja">相等</strong> </a></li><li id="d085" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="#0c30" rel="noopener ugc nofollow"> <strong class="lc ja">相等运算符</strong> </a></li><li id="dcb1" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="#504d" rel="noopener ugc nofollow">T38】hashCodeT40】</a></li><li id="e5e2" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="#3659" rel="noopener ugc nofollow"> <strong class="lc ja">列表，贴图，设置等式</strong> </a></li><li id="a92d" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="#f657" rel="noopener ugc nofollow"> <strong class="lc ja">最终想法</strong> </a></li><li id="46ce" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="#8c72" rel="noopener ugc nofollow"> <strong class="lc ja">本系列其他文章</strong> </a></li></ul><h1 id="e905" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">不可变？</h1><p id="411d" class="pw-post-body-paragraph la lb iq lc b ld mr ka lf lg ms kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">首先，可变的:可以随时间变化的东西。例如，当我们定义一个变量<code class="fe ni nj nk nl b">int a = 10</code>时，它很容易改变。<code class="fe ni nj nk nl b">a=20</code>完全有效。相比之下，我们有不变性。</p><p id="8874" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">正如你可能已经猜到的，不变性是无法改变的。当我第一次听到它时，它没有多大意义。一个不改变状态的应用有什么用？现在，我问自己，我怎么没有早点遇到这种情况。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/798dc67ed7e8966e72be2c903bba1d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkrHH6zxLygz-Yh6QYuYRw.png"/></div></div></figure><p id="355d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在Dart中使用两个关键字可以实现不变性:<code class="fe ni nj nk nl b">final</code>和<code class="fe ni nj nk nl b">const</code>。什么时候更喜欢哪个？让我们来了解一下！</p><h1 id="6135" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">最终与常量</h1><h2 id="71d0" class="nn ly iq bd lz no np dn md nq nr dp mh lj ns nt mj ln nu nv ml lr nw nx mn iw bi translated">最后的</h2><p id="7adc" class="pw-post-body-paragraph la lb iq lc b ld mr ka lf lg ms kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated"><code class="fe ni nj nk nl b">final</code>变量在运行时被求值。如果我们不打算更改值，建议使用final而不是var关键字，或者指定显式类型(int，String)。Dart分析器足够智能来推断类型。</p><h2 id="3ab7" class="nn ly iq bd lz no np dn md nq nr dp mh lj ns nt mj ln nu nv ml lr nw nx mn iw bi translated">常数</h2><p id="8c10" class="pw-post-body-paragraph la lb iq lc b ld mr ka lf lg ms kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">另一方面，<code class="fe ni nj nk nl b">const</code>是一个编译时常数，并且是隐式的final。因此该值在编译时必须是已知的，并且不能被重新分配。</p><p id="eefd" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好吧，但是我们为什么要努力实现不可变的数据结构呢？</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="5b0f" class="lx ly iq bd lz ma of mc md me og mg mh kf oh kg mj ki oi kj ml kl oj km mn mo bi translated">为什么更喜欢不变性？</h1><ul class=""><li id="4bde" class="mp mq iq lc b ld mr lg ms lj mt ln mu lr mv lv mw mx my mz bi translated"><strong class="lc ja">bug更少:</strong>就地改变值有破坏代码库的可能。不变性有助于避免意外的重新分配。使用mutable，有人可以意外地更新我们正在访问的对象，导致难以跟踪的错误。</li><li id="86d1" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">代码变得可预测和易于阅读。</li><li id="f43f" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">当const在编译时求值时，编译器预先知道这个值，并把它存储在内存中。在整个应用程序中引用确切的值，而不是每次都创建新的对象。因此，这有助于节省一些内存，并具有较小的性能优势。</li></ul><p id="17c0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在我们的Flutter应用程序中，我们有10个地方使用了<code class="fe ni nj nk nl b">EdgeInsets.all(8.0)</code>,作为一个例子。通过使用<code class="fe ni nj nk nl b">const</code>，我们告诉编译器只创建一个实例，并在需要填充10的应用程序中使用同一个实例。</p><p id="2e37" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe ni nj nk nl b">const</code>不仅可用于原语，还可用于值不变的类、列表、映射和集合。</p><p id="59bf" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好吧，很公平！但是如果我们一直到处使用不可变的数据结构，我们将如何更新状态呢？</p><h1 id="ee05" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">如何更新不可变状态？</h1><p id="f0db" class="pw-post-body-paragraph la lb iq lc b ld mr ka lf lg ms kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">当然，一个不改变，只显示静态内容的应用有多大用处？不多，对吧？那么我们如何更新状态呢？<strong class="lc ja"> <em class="ok">我们不是改变值，而是替换它们</em> </strong>。我们创建需要访问和使用的实例的副本。它可以防止意想不到的副作用。</p><p id="8543" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们可以使用<code class="fe ni nj nk nl b">copyWith</code>方法让我们的生活变得更容易，但是我们需要首先实施它。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/7ce37c90b5310728b3b5bd257e7b0974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFdB91Xii411hsw4hOxSuQ.png"/></div></div></figure><p id="370c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe ni nj nk nl b">copwWith</code>创建实例的副本，并且只更新显式传递的值。</p><p id="53ae" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">像<code class="fe ni nj nk nl b">int</code>这样的原语在默认情况下是不可变的。比如一个8永远是一个8；我们不能把它突变成其他数字。在上面的代码片段中，我们看到了如何使一个类不可变。</p><blockquote class="om on oo"><p id="8d30" class="la lb ok lc b ld le ka lf lg lh kd li op lk ll lm oq lo lp lq or ls lt lu lv ij bi translated">使用<strong class="lc ja"> @immutable </strong>注释来获得分析器对创建不可变类的支持。</p></blockquote><p id="83f5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">像列表、映射等其他数据结构呢？？让我们来了解一下！</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="c2f1" class="lx ly iq bd lz ma of mc md me og mg mh kf oh kg mj ki oi kj ml kl oj km mn mo bi translated">不可变的列表、映射</h1><p id="07f2" class="pw-post-body-paragraph la lb iq lc b ld mr ka lf lg ms kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">我们可以在列表中使用<code class="fe ni nj nk nl b">final</code>和<code class="fe ni nj nk nl b">const</code>，但是有一个警告。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi os"><img src="../Images/0b06bdb37e0aa31b00103a08ad4e4219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5AHLwRezdzlRP9tnUUv3DQ.png"/></div></div></figure><p id="9565" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">由于两个列表都是<code class="fe ni nj nk nl b">final</code>或<code class="fe ni nj nk nl b">const</code>，我们不能分配新列表(参考。第5行和第6行)。但是，在final的情况下，我们仍然可以添加/删除列表中的元素。我们可以利用<code class="fe ni nj nk nl b">unmodifiable</code>工厂构造函数使这些数据结构完全不可变。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/23eaa6276dfea547f7c98b1bd607b7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZlxF2SpR8eyf4tnov6Zsg.png"/></div></div></figure><p id="0ef6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果我们试图添加/删除元素，我们将在运行时得到以下错误。这当然可行，但是如果我们能在编译时实现这一点不是更好吗？kt_dart包用不可变的数据结构帮助我们，但是因为我们已经在使用dartz，我们可以使用<code class="fe ni nj nk nl b">IList</code>，它提供了一个不可变的列表。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ou"><img src="../Images/97a2a56398cac6619859192c112d3156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZA7DCCDQIGG9Epr_3mPbkw.png"/></div></div></figure><p id="267a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在第2行，我们从一个常规列表中创建了一个<code class="fe ni nj nk nl b">IList</code>实例。这是完全不可改变的。为了添加/删除元素，我们有<code class="fe ni nj nk nl b">appendElement</code>和<code class="fe ni nj nk nl b">prependElement</code>，它们分别在最后一个位置和第一个位置添加元素。它不会就地更新元素，而是返回一个新列表。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="79af" class="lx ly iq bd lz ma of mc md me og mg mh kf oh kg mj ki oi kj ml kl oj km mn mo bi translated">平等</h1><p id="73d5" class="pw-post-body-paragraph la lb iq lc b ld mr ka lf lg ms kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">在开始之前，这里有一个有趣的练习。试着猜测下面的输出。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/f79d038b56e199ecc90b356531c12ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXVlPEREQQmW8uXLfRFCcg.png"/></div></div></figure><p id="2993" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">相等是通过使用<code class="fe ni nj nk nl b">==</code>操作符检查两个对象是否相等的方法。平等有两种类型:指称平等和价值平等。例如，我们有一个包含两个字段的用户类:姓名和年龄。当我们初始化用户类时，对象被创建并存储在内存中。每个对象都有一个唯一的分配给它的内存地址。</p><p id="4443" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">引用相等</strong>当两个对象引用同一个对象时返回true。对于返回true的对象，它们应该指向内存中的同一个对象。</p><p id="fccb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">值相等</strong>当两个对象具有相同的值时，返回true。对象可以在内存中的不同位置，但是如果它们具有相同的值，则返回true。</p><h1 id="0c30" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">等式运算符</h1><p id="f614" class="pw-post-body-paragraph la lb iq lc b ld mr ka lf lg ms kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">默认情况下，Dart检查引用是否相等。如果我们比较dart中任意两个具有相同值的非常数对象，它的计算结果为false。<code class="fe ni nj nk nl b">==</code>操作符的默认实现是，如果两个对象相同，换句话说，如果两个对象相同，则返回true。</p><p id="2b30" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了支持值相等，类需要:</p><ul class=""><li id="f448" class="mp mq iq lc b ld le lg lh lj ow ln ox lr oy lv mw mx my mz bi translated"><strong class="lc ja"> Total: </strong>它应该总是返回一个布尔值，并且从不抛出错误或返回null。</li><li id="34ca" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><strong class="lc ja">反身:</strong> a == a应该总是返回true。</li><li id="4803" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><strong class="lc ja">对称:</strong> a == b应该与b == a相同，要么两者都应该求值为true，要么两者都应该求值为false。如果a等于b，那么b应该等于a。</li><li id="fed6" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><strong class="lc ja">传递:</strong>如果a == b为真，b == c为真那么a == c应该为真。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oz"><img src="../Images/9836b00454a8a697f01c5a1ec9d458a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyKFUdh79STtri1zDtH7Lg.png"/></div></div></figure><p id="7817" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe ni nj nk nl b">User</code>，常规类，<code class="fe ni nj nk nl b">User2</code>，值相等的类。当比较两个具有相同值的<code class="fe ni nj nk nl b">User</code>对象时，它的计算结果为false，因为它默认使用引用相等。然而，当比较两个具有相似值的<code class="fe ni nj nk nl b">User2</code>对象时，它评估为true，因为我们已经实现了值相等。</p><p id="ab88" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是等等，还没完呢！</p><h1 id="504d" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">哈希码</h1><p id="a505" class="pw-post-body-paragraph la lb iq lc b ld mr ka lf lg ms kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">在覆盖<code class="fe ni nj nk nl b">==</code>操作符时，我们需要确保覆盖hashCode。但是首先，到底什么是hashCode？</p><p id="14bf" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">hashCode的类型是<code class="fe ni nj nk nl b">int</code>，表示对象的状态。默认实现表示对象的标识。</p><p id="3635" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果<code class="fe ni nj nk nl b">==</code>操作符被覆盖，我们也应该覆盖hashCode来表示状态；否则，这些对象就不能用在像Map这样的基于散列的数据结构中。</p><blockquote class="om on oo"><p id="8873" class="la lb ok lc b ld le ka lf lg lh kd li op lk ll lm oq lo lp lq or ls lt lu lv ij bi translated">hash_and_equals将它添加到您的analysis_options.yaml中，以获得分析器对hashCode的支持。</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pa"><img src="../Images/7eb1fbe1083a8087df28e5c245e7161e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NRtnZkeiuw-jwiT36J_s5w.png"/></div></div></figure></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="3659" class="lx ly iq bd lz ma of mc md me og mg mh kf oh kg mj ki oi kj ml kl oj km mn mo bi translated">列表、映射、集合等式</h1><p id="72dc" class="pw-post-body-paragraph la lb iq lc b ld mr ka lf lg ms kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">比较列表和映射等集合时，会检查引用是否相等。当我们需要检查值是否相等时，像<code class="fe ni nj nk nl b">listEquals</code>和<code class="fe ni nj nk nl b">mapEquals</code>这样的方法可以帮助我们。</p><p id="67d5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了逐个元素地检查，我们需要集合包通过<code class="fe ni nj nk nl b">DeepCollectionEquality</code>提供的深度相等，这是Flutter用作依赖的包之一。它支持两种模式:有序和无序。</p><p id="9a56" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果我们使用的是<code class="fe ni nj nk nl b">IList</code>，默认情况下我们会得到值相等的支持。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/a1277a9068e482f431938d7031108158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mr7zVz99DLY9CfBgBr3w6w.png"/></div></div></figure><p id="3243" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在是揭晓上述测验答案的好时机。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/c46bf4d4a9821777dfa0575846cdee69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*70mJOnwhohcwNzhMRBRcKg.png"/></div></div></figure><p id="22f2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe ni nj nk nl b">print(1 == 1)</code>和<code class="fe ni nj nk nl b">print(10 == 01)</code>如您所料分别返回true和false。</p><p id="63e2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">第5行返回false，因为默认情况下，dart检查引用是否相等。为了支持值相等，我们需要覆盖<code class="fe ni nj nk nl b">==</code>操作符和<code class="fe ni nj nk nl b">hashCode</code>。</p><p id="2d4d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">对于第6–11行，表达式的计算结果为false。像<code class="fe ni nj nk nl b">listEquals</code>和<code class="fe ni nj nk nl b">mapEquals</code>这样的方法来比较集合包中的值相等或<code class="fe ni nj nk nl b">DeepCollectionEquality</code>。</p><p id="8e3f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">对于打印<code class="fe ni nj nk nl b">(1 == 1.0)</code>和<code class="fe ni nj nk nl b">print(1 is double)</code>有更多的引擎盖下发生的事情，访问<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/why-dividing-by-0-does-not-throw-an-error-in-dart-how-dart-handles-numbers-a17ac8e5630c">这篇文章</a>了解更多。</p><h1 id="f657" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">最后的想法</h1><p id="7af7" class="pw-post-body-paragraph la lb iq lc b ld mr ka lf lg ms kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">因此，不变性和相等性将有助于减少意外的错误，并使代码可预测。在开始的时候，这看起来像是很多工作，但在我看来，这是值得努力的。在下一篇文章中，我们将深入探讨高阶函数和递归。</p><p id="0d5d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">牛逼！</strong>拍拍自己的背，因为你坚持到了最后。我希望我为你投入的时间增加了一些价值。在<a class="ae lw" href="https://github.com/Yogi-6/functional_programming_dart" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja"> GitHub </strong> </a>知识库上找到更多例子，并在<a class="ae lw" href="https://twitter.com/_yogi_6" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja"> Twitter </strong> </a>或<a class="ae lw" href="https://www.linkedin.com/in/yogi6/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja"> LinkedIn </strong> </a>上寻求建议/问题或任何你希望我涵盖的主题。你可以鼓掌支持👏，感谢您的阅读:)更多信息请关注😄</p><p id="7863" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下次见，伙计们！</p><h1 id="8c72" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">本系列的其他文章</h1><ul class=""><li id="7d56" class="mp mq iq lc b ld mr lg ms lj mt ln mu lr mv lv mw mx my mz bi translated"><a class="ae lw" href="https://yogi-6.medium.com/functional-programming-in-dart-foundation-part-0-7e932517b824" rel="noopener">基础</a></li><li id="dd88" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="https://yogi-6.medium.com/pure-functions-side-effects-in-dart-functional-programming-part-1-fb931d6c0351" rel="noopener">纯功能&amp;副作用</a></li><li id="a408" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/arity-closure-currying-partial-application-more-in-dart-functional-programming-part-2-4534a8b7f374"> Arity、Closure、Currying、Partial Application &amp; more。</a></li><li id="83a9" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/composition-in-flutter-dart-functional-programming-part-3-ffba917aee3d">作文</a></li><li id="1b24" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">不变性和平等</li><li id="d96f" class="mp mq iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><a class="ae lw" href="https://medium.com/flutter-community/higher-order-functions-recursion-in-dart-functional-programming-part-5-4237bc114005" rel="noopener">高阶函数&amp;递归</a></li></ul></div></div>    
</body>
</html>