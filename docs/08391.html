<html>
<head>
<title>Docker Storage Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker储物教程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-storage-tutorial-ecbd91db5b9?source=collection_archive---------16-----------------------#2021-04-27">https://levelup.gitconnected.com/docker-storage-tutorial-ecbd91db5b9?source=collection_archive---------16-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7fda" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Docker卷的演练教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a4a630df9feb7bd061b23090e33b2e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VSWlp3p_43UXYrvn.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">不溅</figcaption></figure><div class="ky kz gp gr la lb"><a href="https://jorgepit-14189.medium.com/membership" rel="noopener follow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd iu gy z fp lg fr fs lh fu fw is bi translated">用我的推荐链接加入媒体-乔治皮皮斯</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">阅读乔治·皮皮斯(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">jorgepit-14189.medium.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp ks lb"/></div></div></a></div><p id="f9e5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Docker有两个主要的数据存储类别，持久的T7和非持久的T9。</p><h1 id="9f2f" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">持久数据存储</h1><p id="a580" class="pw-post-body-paragraph lq lr it ls b lt ne ju lv lw nf jx ly lz ng mb mc md nh mf mg mh ni mj mk ml im bi translated">持久数据存储是与容器分离的卷。</p><h1 id="a889" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">体积:</h1><ul class=""><li id="62fa" class="nj nk it ls b lt ne lw nf lz nl md nm mh nn ml no np nq nr bi translated">为持久数据使用卷:首先创建卷，然后创建容器。</li><li id="4d10" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">挂载到容器中的目录</li><li id="a024" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">数据被写入卷中</li><li id="1ea0" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">删除容器不会删除卷</li><li id="8587" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">一等公民</li><li id="2649" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">使用本地驱动程序</li><li id="5541" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">第三方驱动程序:块存储、文件存储、对象存储</li><li id="2d29" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">存储位置:Linux: /var/lib/docker/volumes/，Windows:C:\ program data \ Docker \ volumes</li></ul><h1 id="55d1" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">非持久性数据存储</h1><p id="b00b" class="pw-post-body-paragraph lq lr it ls b lt ne ju lv lw nf jx ly lz ng mb mc md nh mf mg mh ni mj mk ml im bi translated"><strong class="ls iu">非持续性</strong></p><ul class=""><li id="0456" class="nj nk it ls b lt lu lw lx lz nx md ny mh nz ml no np nq nr bi translated">局部存储器</li><li id="f474" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">短暂的数据</li><li id="b3d2" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">每个集装箱都有</li><li id="d471" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">依赖于容器的生命周期</li></ul><p id="0c02" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">默认情况下所有容器都使用本地存储</strong></p><p id="ed85" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">存放位置</strong></p><ul class=""><li id="7d1c" class="nj nk it ls b lt lu lw lx lz nx md ny mh nz ml no np nq nr bi translated">Linux:/var/lib/docker/[存储驱动程序]/</li><li id="6120" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">windows:C:\ program data \ Docker \ windows filter \</li></ul><p id="c93a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">存储驱动程序</strong></p><ul class=""><li id="c6e8" class="nj nk it ls b lt lu lw lx lz nx md ny mh nz ml no np nq nr bi translated">RHEL使用重叠2。</li><li id="ef2e" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">Ubuntu使用overlay2或aufs。</li><li id="0bd8" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">SUSE使用btrfs。</li><li id="0414" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated">Windows使用自己的。</li></ul><h1 id="606c" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">音量命令</h1><p id="9e26" class="pw-post-body-paragraph lq lr it ls b lt ne ju lv lw nf jx ly lz ng mb mc md nh mf mg mh ni mj mk ml im bi translated">列出所有Docker音量命令:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="efea" class="of mn it ob b gy og oh l oi oj">docker volume -h</span></pre><ul class=""><li id="77dc" class="nj nk it ls b lt lu lw lx lz nx md ny mh nz ml no np nq nr bi translated"><code class="fe ok ol om ob b">create</code>:创建一个卷。</li><li id="b6fc" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated"><code class="fe ok ol om ob b">inspect</code>:显示一个或多个卷的详细信息。</li><li id="e64c" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated"><code class="fe ok ol om ob b">ls</code>:列表卷。</li><li id="b062" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated"><code class="fe ok ol om ob b">prune</code>:移除所有未使用的本地卷。</li><li id="5262" class="nj nk it ls b lt ns lw nt lz nu md nv mh nw ml no np nq nr bi translated"><code class="fe ok ol om ob b">rm</code>:删除一个或多个卷。</li></ul><p id="6f55" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">列出所有卷:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="3903" class="of mn it ob b gy og oh l oi oj">docker volume ls</span></pre><p id="1d2c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">创建两个新卷:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="1d57" class="of mn it ob b gy og oh l oi oj">docker volume create test-volume1 docker volume create test-volume2</span></pre><p id="c00d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">创建卷时获取可用标志:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="1b6b" class="of mn it ob b gy og oh l oi oj">docker volume create -h</span></pre><p id="0061" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">检查卷:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ca81" class="of mn it ob b gy og oh l oi oj">docker volume inspect test-volume1</span></pre><p id="de89" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">删除卷:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="cc2f" class="of mn it ob b gy og oh l oi oj">docker volume rm test-volume</span></pre><p id="d17d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">删除所有未使用的卷:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="6f29" class="of mn it ob b gy og oh l oi oj">docker volume prune</span></pre><h1 id="9e38" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">绑定安装</h1><p id="f809" class="pw-post-body-paragraph lq lr it ls b lt ne ju lv lw nf jx ly lz ng mb mc md nh mf mg mh ni mj mk ml im bi translated">绑定挂载从Docker早期就已经出现了。与卷相比，它们的功能有限。使用绑定装载，主机上的文件或目录被装载到容器中。</p><p id="c87e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">卷使用在主机上Docker的存储目录中创建的新目录，Docker管理该目录的内容。</p><p id="1784" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">使用挂载标志:</strong></p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="e6e8" class="of mn it ob b gy og oh l oi oj">docker container run -d --name &lt;NAME&gt; --mount type=bind, source=&lt;SOURCE&gt;, target=&lt;TARGET&gt; &lt;IMAGE&gt;</span></pre><p id="e5cb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">使用音量标志:</strong></p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="90e1" class="of mn it ob b gy og oh l oi oj">docker container run -d --name &lt;NAME&gt; -v &lt;SOURCE&gt;:&lt;TARGET&gt; &lt;IMAGE&gt;</span></pre><p id="45c0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们提供一个如何运行带有卷的容器的示例。在我们的工作目录中，我们创建了一个名为的文件夹，该文件夹将与文件夹下的docker容器相连接，其中我们的案例是<code class="fe ok ol om ob b">nginx</code>。让我们运行命令(注意，我是在Windows上，这是在源路径中使用反斜杠的原因):</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="a755" class="of mn it ob b gy og oh l oi oj">docker container run -d --name nginx_with_volume -v C:\ForTheBlog\VolumeExample\mysource:/mytarget nginx</span></pre><p id="9663" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，假设我们创建一个名为<strong class="ls iu"> </strong> <code class="fe ok ol om ob b"><strong class="ls iu">myfile1.txt</strong></code>的新文件，放在我们本地PC的文件夹下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4fa1c2d800e88bd217ece3fef0223447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*df4FiEx4uVadZhF_.png"/></div></div></figure><p id="ecd7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，我们期望在文件夹下的容器中找到。让我们在交互式终端(<code class="fe ok ol om ob b">-it</code>)中运行bash命令:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="333b" class="of mn it ob b gy og oh l oi oj">docker exec -it nginx_with_volume bash</span></pre><p id="9b28" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们在集装箱里。我们可以用<code class="fe ok ol om ob b">ls</code>命令搜索文件和目录:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="018d" class="of mn it ob b gy og oh l oi oj">ls -ltr</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/7b522da854906d430ef55f6579d48ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uPw9bB645xZurar_.png"/></div></div></figure><p id="f59f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们可以将目录(<code class="fe ok ol om ob b">cd</code>)改为<code class="fe ok ol om ob b">mytarget</code>:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="a19c" class="of mn it ob b gy og oh l oi oj">cd mytarget ls -ltr</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/7a5065beb42a371dccbdbd4777eaaba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/0*tRZGqDk7Yb7ppJBE.png"/></div></figure><p id="3697" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们可以看到<code class="fe ok ol om ob b">file1.txt</code>从我们的本地电脑安装在集装箱内。最后，让我们在<code class="fe ok ol om ob b">mytarget</code>文件夹下的容器中创建一个名为<code class="fe ok ol om ob b"><strong class="ls iu">file2.txt</strong></code>的新文件。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="a90c" class="of mn it ob b gy og oh l oi oj">touch file2.txt echo "A file created within the container" &gt; file2.txt</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5901b909d84a7cc5a64d8215f92e4292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fjxk03O-1yk_wgBK.png"/></div></div></figure><p id="7659" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们期望在本地PC的文件夹下找到<code class="fe ok ol om ob b"><strong class="ls iu">file2.txt</strong></code>。正如我们所见，它就在那里！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fd1eafb63ecd76485847eb6b2e249185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zRYSAJYpqw40JSJ8.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/64269af4974bb363edebf9201b3273a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/0*eb0R-XSHHw20UEPg.png"/></div></figure><h1 id="8eff" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">移除容器</h1><p id="69cd" class="pw-post-body-paragraph lq lr it ls b lt ne ju lv lw nf jx ly lz ng mb mc md nh mf mg mh ni mj mk ml im bi translated">既然我们完成了这个教程，是时候清理我们的烂摊子了:)。所以，让我们停下来，然后移除容器。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="8d3f" class="of mn it ob b gy og oh l oi oj">docker stop nginx_with_volume docker rm nginx_with_volume</span></pre><h1 id="0408" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">参考</h1><p id="d68e" class="pw-post-body-paragraph lq lr it ls b lt ne ju lv lw nf jx ly lz ng mb mc md nh mf mg mh ni mj mk ml im bi translated">[1] <a class="ae oq" href="https://linuxacademy.com/cp/modules/view/id/314" rel="noopener ugc nofollow" target="_blank"> Linux学院</a></p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><p id="fba3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><em class="oy">原载于</em><a class="ae oq" href="https://predictivehacks.com/docker-storage-tutorial/" rel="noopener ugc nofollow" target="_blank"><em class="oy">https://predictivehacks.com</em></a><em class="oy">。</em></p></div></div>    
</body>
</html>