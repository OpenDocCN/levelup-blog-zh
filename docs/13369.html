<html>
<head>
<title>Improved Fraud Detection with RediSearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过重新搜索改进欺诈检测</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improved-fraud-detection-with-redisearch-acf1a5fa835b?source=collection_archive---------8-----------------------#2022-08-30">https://levelup.gitconnected.com/improved-fraud-detection-with-redisearch-acf1a5fa835b?source=collection_archive---------8-----------------------#2022-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a7488807cead0faf0d8e48ea93e15093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFbAlHjduSehQhg_h33I7g.jpeg"/></div></div></figure><p id="4100" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你在某种程度上参与了<a class="ae kz" href="https://medium.com/gitconnected/event-driven-architectures-in-software-design-757d92b85df5" rel="noopener">事件驱动设计</a>(或者软件工程)的世界，你肯定听说过卡夫卡。同时，作为任何软件社区的一员，我想你应该熟悉我们钟爱的Redis。</p><p id="1016" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kafka是一个分布式流平台，有大量很酷的应用程序，允许我们构建可扩展的高性能分布式系统。它通常作为一个通信通道，以高性能的方式连接<a class="ae kz" href="https://medium.com/geekculture/brief-introduction-to-microservices-b99a91c77c72" rel="noopener">微服务</a>，同时为其他应用程序保存不可变的数据。</p><p id="6146" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redis是一个内存中的数据存储，它也有很多有趣的应用。</p><p id="b6a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谈到Redis，你可能更熟悉它的开源数据存储版本，我们可以将其用作高性能缓存数据库，但多年来<a class="ae kz" href="https://redis.com/" rel="noopener ugc nofollow" target="_blank"> Redis </a>一直在构建一个名为<a class="ae kz" href="https://redis.io/docs/stack/" rel="noopener ugc nofollow" target="_blank"> Redis Stack </a>的数据模型集合，其中大多数都在他们的企业产品下。</p><p id="5236" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这有什么关系呢？</p><p id="c6de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在[智能]软件工程中，我们的工作不是重新发明轮子，Redis Stack添加了许多现成的现代数据模型，使我们的生活变得更加简单。</p><p id="e8ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将重点关注<a class="ae kz" href="https://redis.io/docs/stack/search/" rel="noopener ugc nofollow" target="_blank">重新搜索</a>，但也可以在<a class="ae kz" href="https://redis.io/docs/stack/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中随意查看它们的完整内容。</p><h1 id="770a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">关于再研究的更多信息</h1><p id="aa4b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">对于我的许多EDA应用程序，我特别喜欢Redis。在我工作的环境中，事件驱动是常态，Redis数据存储允许我们在所有微服务上使用高效的缓存，以加快速度。使用Redis作为缓存的理由非常充分。</p><p id="edd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您在事件驱动的设置中工作时，通常需要本地缓存来聚集事件数据。例如，如果您有传入的用户配置文件更改事件，您可能有一个微服务从流中读取并聚合一个整合的用户配置文件。这就是Redis派上用场的地方。</p><p id="9296" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你想要一个真正快速的本地缓存，由于Kafka的性质，你可以通过重新处理Kafka主题来重建这些缓存，例如当启动一个新的微服务时。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi md"><img src="../Images/a9be4a957fc50a2119712320bd719790.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*5WBL5LizuG9p8vzcBqojZQ.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">从一个主题消费简单的服务并写入Redis</figcaption></figure><p id="9e15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，再搜索变得更有趣了。</p><p id="a8db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据<a class="ae kz" href="https://redis.com/" rel="noopener ugc nofollow" target="_blank"> Redis </a>(前Redis实验室)的说法，RediSearch是Redis的一个强大的索引、查询和全文搜索引擎。</p><p id="6b7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，这到底是什么意思？</p><p id="2061" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能已经猜到了，RediSearch允许您以一种高效的方式对Redis数据进行搜索或查询。</p><p id="612b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以标准Redis为例。用户配置文件哈希可以有以下格式的主索引:</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="23ab" class="mr lb it mn b gy ms mt l mu mv">users:profiles:user_id</span></pre><p id="1e48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以用这个键执行搜索操作，Redis将使用主索引来找到它并检索其中存储的内容。这是标准的<code class="fe mw mx my mn b">HGETALL users:profiles:user_id</code>命令。</p><p id="9f3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用RediSearch，您可以基于内容在同一个键上创建一个二级索引。如果用户配置文件包含姓名和电子邮件，您可以索引姓名字段，并根据该姓名执行搜索操作。</p><p id="45d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很酷，是吧？</p><p id="c36e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以运行复杂的聚合、存储分析数据、使用纯文本甚至模糊匹配进行搜索等等。</p><p id="efdd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我敢打赌，您可以看到如何在分布式环境中使用它。您可能有不同的数据流，从系统的不同部分收集和聚合数据，然后跨不同的服务构建本地缓存，并使用RediSearch以多种方式索引数据。</p><p id="e45d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，您可以汇总有关您业务的关键指标，以便让决策者占上风，或者您可以存储实时分析和监控性能等。</p><p id="d889" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">这与开箱即用的Redis有何不同？</strong></p><p id="142d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RediSearch是建立在Redis之上的一个模块，它是一个现成的解决方案，这意味着我们不需要对它包含的任何数据存储进行建模。界面也是不同的，它超级加载了大量的新命令和功能。这是它自己的产物，否则你就得自己建造。</p><h1 id="c6e5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们如何利用这一点进行欺诈检测？</h1><p id="21bf" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">让我们挑选一个特定的用例，看看再搜索如何帮助我们。</p><p id="37d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">欺诈检测是一个充满挑战和机遇的领域。问题是复杂的，坏演员总是在门口等着尝试新的方法。</p><p id="4685" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么就要靠软件工程中可怜的灵魂来坚持我们的立场并为此做些什么了😅</p><p id="ecbf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将描述一个非常常见的群体欺诈用例，它可以适用于任何类型的欺诈检测，因为欺诈检测本身的细节现在并不相关。</p><h1 id="b905" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">问题是</h1><p id="315e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">假设我们有一个系统，它很容易被具有相似行为的用户组滥用，这意味着实施欺诈的用户很可能与实施欺诈的其他用户具有相似的特征。</p><p id="a4be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以用许多不同的方法来解决这个问题。你可以使用机器学习将具有相似行为的用户聚集在一起，或者你可以制定特定的规则来确定和检测欺诈对你意味着什么，或者你可以让分析师检查用户配置文件并寻找不寻常的标志，或者以上所有方式。</p><p id="45ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实上，很可能你会使用多种技术和检查来捕捉滥用者。</p><p id="4332" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">知道相似的滥用者可能会有相似的行为方式，一旦您确定某个用户是欺诈性的，您如何利用这种行为并抓住其他人呢？</p><h1 id="cbde" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用标准Redis缓存</h1><p id="728b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在标准的现代架构中，我们可能有一个包含一些微服务的系统，通过Kafka进行通信，并将其数据存储在本地Redis缓存中。</p><p id="90fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像这样的东西:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1cf82883658fa5b518477d48cd4730c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMsBExFUzjrclRDKUA-vrg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">简单的EDA设置，有多个消费者和生产者</figcaption></figure><p id="1e65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们有一个专门用于欺诈检测的服务，监听多个数据流并将所有数据聚合到Redis中。</p><p id="1e96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用户配置文件可以存储在Redis哈希中，如下所示:</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="da9e" class="mr lb it mn b gy ms mt l mu mv"># key: users:profiles:my_user_id<br/>{<br/>  name: John,<br/>  lastname: Wick,<br/>  email: john.wick@defonotfrauddomain.com,<br/>  registration_ip_address: 156.33.241.5,<br/>  latest_ip_address: 156.33.241.5,<br/>  country: usa,<br/>}</span></pre><p id="bd75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用<a class="ae kz" href="https://github.com/redis/node-redis" rel="noopener ugc nofollow" target="_blank"> node-redis </a>库来创建它:</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="95e9" class="mr lb it mn b gy ms mt l mu mv">import { createClient, SchemaFieldTypes } from 'redis';<br/>const client = createClient();<br/>await client.connect();</span><span id="b745" class="mr lb it mn b gy na mt l mu mv">await client.hSet('users:profiles:my_user_id', {<br/>  name: 'John',<br/>  lastname: 'Wick',<br/>  email: 'john.wick@defonotfrauddomain.com',<br/>  registration_ip_address: '156.33.241.5',<br/>  latest_ip_address: '156.33.241.56',<br/>  country: 'usa'<br/>})</span></pre><p id="09d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，在实践中，我们会从现有的不同传入数据流中构建这个配置文件。</p><p id="cecc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然数据已经集中在一个地方，我们就可以对它进行检查了。</p><p id="2e9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们可以根据用户的注册IP地址对接收位置进行检查。</p><p id="8dc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们收到一个IP地址如下的登录事件:<code class="fe mw mx my mn b">91.218.114.206</code>。我们可以存储它，对照用户的注册IP进行检查，并注意到它们非常不同，所以这可能是一个基本的位置检查。</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="1562" class="mr lb it mn b gy ms mt l mu mv">await client.hSet('users:profiles:my_user_id', {<br/>  latest_ip_address: '91.218.114.206'<br/>})</span><span id="5b4a" class="mr lb it mn b gy na mt l mu mv">if (isIpAddressSuspicious(registrationIp, latestIp)) {<br/>  // Do something about this login attempt<br/>}</span></pre><p id="6aea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个使用Redis作为我们的数据存储的基本欺诈检查的非常简单的例子。</p><h1 id="17a2" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">包括再研究</h1><p id="eea2" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了让事情变得有趣，我们可以利用Redis中已经存在的关于我们用户的数据，并通过RediSearch在他们之间建立联系。</p><p id="2388" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了Redis中的这个IP地址数据，我们可以假设被标记为可疑的用户是从可疑的位置连接的。</p><p id="1df1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于这个假设，我们可以搜索以前使用过这个IP的用户。</p><p id="f1a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一种解决方案是将所有传入的IP地址及其用户存储在主索引中；但是这可能不是一个好的解决方案，因为它需要存储比我们需要的更多的数据。</p><p id="bacd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一种方法是使用RediSearch在用户的IP地址上创建二级索引，这将允许我们搜索所有提到该IP的用户，然后对结果用户进行单独的质量检查。</p><p id="dc10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RediSearch现在将适合我们的模型，作为一个模块附加到Redis本地缓存:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/da633e1dfe1d4f72a1c07bcf841f184e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzjo0RUMp7aP8xxSLrUPgw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">RediSearch作为一个模块附属于Redis</figcaption></figure><p id="5578" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了创建二级索引，我们可以使用同一个<code class="fe mw mx my mn b">node-redis</code>库:</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="9c33" class="mr lb it mn b gy ms mt l mu mv">await client.ft.create('idx:user_ip_address', {<br/>  latest_ip_address: {<br/>    type: SchemaFieldTypes.TEXT,<br/>    sortable: true<br/>  }<br/>}, {<br/>  ON: 'HASH',<br/>  PREFIX: 'users:profiles'<br/>});</span></pre><p id="455f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将在<code class="fe mw mx my mn b">latest_ip_address</code>上创建一个名为<code class="fe mw mx my mn b">idx:user_ip_address</code>的二级索引，它将对以<code class="fe mw mx my mn b">user:profiles</code>为前缀的散列进行操作。</p><p id="0ff7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这个索引，我们现在可以搜索所有与这个IP地址相关的用户，并对他们进行质量检查:</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="85e5" class="mr lb it mn b gy ms mt l mu mv">const ipAddressToCheck = '91.218.114.206';</span><span id="6b4d" class="mr lb it mn b gy na mt l mu mv">// Finding users that have used this IP address in the past<br/>const usersWithSameIp = await client.ft.search(<br/>  'idx:user_ip_address', <br/>  `@latest_ip_address:{${ipAddressToCheck}}`<br/>);</span><span id="746a" class="mr lb it mn b gy na mt l mu mv">// Sending users for further inspection<br/>if (usersWithSameIp.total &gt; 0) {<br/>  kafkaProduce('users.suspicious-ips', usersWithSameIp.documents)<br/>}</span></pre><p id="2c54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意我们是如何将所有匹配的用户发送到Kafka的，这样系统中的其他消费者就可以对这些用户进行进一步的质量检查，并为他们实现更广泛的欺诈检测规则。</p><p id="c2c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像这样，我们通过使用再搜索检查具有相似特征的用户，稍微改进了我们的欺诈检测。</p><p id="118f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以按照自己认为合适的方式对该用例进行分割，但简单来说，这是要遵循的原则:</p><ul class=""><li id="8fbf" class="nb nc it kd b ke kf ki kj km nd kq ne ku nf ky ng nh ni nj bi translated">将流中的一些数据聚合到Redis中。</li><li id="1467" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">根据数据的性质为数据创建辅助索引。</li><li id="c14f" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">运行进一步的搜索以扩展检查。</li></ul><h1 id="3ef5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">改进RedisJSON的使用</h1><p id="260e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">与RediSearch类似，您可以使用RedisJSON让您的生活更加轻松。您可以为用户存储一个复杂的JSON对象(或任何数据模型)，并以同样的方式索引路径，而不是将数据存储在散列中。</p><p id="3d42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，您可以用不同的方式将您的用户资料分段，如下所示:</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="2ffb" class="mr lb it mn b gy ms mt l mu mv">{<br/>  profile: {<br/>    name: John,<br/>    lastname: Wick,<br/>    email: john.wick@defonotfrauddomain.com,<br/>},<br/>  location: {<br/>    registration_ip_address: 156.33.241.5,<br/>    latest_ip_address: 156.33.241.5,<br/>    country: usa,<br/>  },<br/>  ...<br/>}</span></pre><p id="7d68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用RedisJSON以这种格式存储数据相当简单</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="c0bd" class="mr lb it mn b gy ms mt l mu mv">await client.json.set('users:json_profiles:my_user_id', '$', {<br/>  profile: {<br/>    name: 'John',<br/>    lastname: 'Wick',<br/>    email: 'john.wick@defonotfrauddomain.com',<br/>  },<br/>  location: {<br/>    registration_ip_address: '156.33.241.5',<br/>    latest_ip_address: '156.33.241.5',<br/>    country: 'usa',<br/>  }<br/>});</span></pre><p id="a316" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，您可能会慢慢地构建这个对象，并随着时间的推移不断丰富它。</p><p id="758a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，要在IP地址上创建索引，您所要做的就是引用路径:</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="7ed1" class="mr lb it mn b gy ms mt l mu mv">await client.ft.create('idx:user_ip_address', {<br/>  '$.location.registration_ip_address': {<br/>    type: SchemaFieldTypes.TEXT,<br/>    SORTABLE: true,<br/>    AS: 'reg_ip_address'<br/>  }<br/>}, {<br/>  ON: 'JSON',<br/>  PREFIX: 'users:json_profiles'<br/>});</span></pre><p id="4cb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要使用它，同样的想法也适用:</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="6adb" class="mr lb it mn b gy ms mt l mu mv">const usersWithSameIp = await client.ft.search(<br/>  'idx:user_ip_address', <br/>  `@reg_ip_address:{${ipAddressToCheck}}`<br/>);</span></pre><p id="296f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这方面的应用有很多。您可能会检查用户的电子邮件地址与相同的领域，或具有类似的名称，或任何其他用户数据，您正在收集和寻找关系。</p><h1 id="b6a2" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">替代解决方案</h1><p id="dca3" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如果你没有使用RediSearch来寻找这些关联，你仍然有很多选择，但没有多少是如此简单和有效的。</p><p id="dc79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在关系数据库中存储数据</strong></p><p id="e461" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以将您的IP数据存储在关系数据库中，并针对传入的IP地址运行查询，但这远不如将其存储在内存中快。</p><p id="c869" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在图形数据库中存储关系</strong></p><p id="bb12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在图形数据库中建立用户和他们的IP地址之间的关系模型，但这也没有重新搜索快，而且数据模型更复杂，需要更多的维护。</p><p id="947c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">仅使用主索引</strong></p><p id="fa79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以创建另一个主索引，但是如前所述，我们会在没有任何实际需要的情况下复制数据。</p><h1 id="5e87" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="d162" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">欺诈检测是一个需要解决有趣问题的世界，正如您所看到的，值得探索哪些选项可以保持对用户行为模式的了解。</p><p id="6bd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redis Stack提供了一套很好的工具来帮助你，老实说，它们用起来很有趣。</p><p id="7ed2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不要试图重新发明轮子，而是使用久经考验的解决方案。</p><p id="6dea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，Redis有一个很好的企业产品，它带有<a class="ae kz" href="https://redis.com/redis-enterprise-cloud/overview/" rel="noopener ugc nofollow" target="_blank"> Redis Cloud </a>，其中包括所有这些工具，这是了解Redis及其所有组件的最快方式。</p><p id="6c3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以免费开始，并在此基础上进行构建。</p><p id="7211" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编码快乐！</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="90d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章是与Redis合作的。</p><p id="993e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">了解详情:</strong></p><ul class=""><li id="1c5f" class="nb nc it kd b ke kf ki kj km nd kq ne ku nf ky ng nh ni nj bi translated"><a class="ae kz" href="https://redis.info/3NBGJRT" rel="noopener ugc nofollow" target="_blank">免费试用Redis云</a></li><li id="0051" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae kz" href="https://redis.info/3Ga9YII" rel="noopener ugc nofollow" target="_blank">观看此视频，了解Redis云相对于其他Redis提供商的优势</a></li><li id="64a8" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae kz" href="https://redis.info/3LC4GqB" rel="noopener ugc nofollow" target="_blank"> Redis开发者中心——关于Redis的工具、指南和教程</a></li><li id="812c" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae kz" href="https://redis.info/3wMR7PR" rel="noopener ugc nofollow" target="_blank"> RedisInsight桌面图形用户界面</a></li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="5e98" class="la lb it bd lc ld nw lf lg lh nx lj lk ll ny ln lo lp nz lr ls lt oa lv lw lx bi translated">分级编码</h1><p id="9b3f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="f8be" class="nb nc it kd b ke kf ki kj km nd kq ne ku nf ky ng nh ni nj bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="011e" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">📰查看<a class="ae kz" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="563c" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">🔔关注我们:<a class="ae kz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kz" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kz" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="8e79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🚀👉<a class="ae kz" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">加入人才集体，找到一份令人惊喜的工作</strong> </a></p></div></div>    
</body>
</html>