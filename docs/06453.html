<html>
<head>
<title>How you can use React Suspense for data fetching in real-world applications now</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现在，您如何在现实世界的应用程序中使用React Suspense获取数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-you-can-use-react-suspense-for-data-fetching-in-real-world-applications-now-9fda8138f687?source=collection_archive---------0-----------------------#2020-11-26">https://levelup.gitconnected.com/how-you-can-use-react-suspense-for-data-fetching-in-real-world-applications-now-9fda8138f687?source=collection_archive---------0-----------------------#2020-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/da24a9c29ddbe2f86a5bc3f036a5b934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*loUqLbneLU7aDLad"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ferenc Almasi </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9d5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React暂停数据获取仍然是React中的一个实验性特性。虽然不太可能，但规范可能会改变，您的代码可能会中断。</p><p id="d4db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，这项技术非常有用。如果您的应用程序使用存储在数据库中的数据，与REST api通信，或者以任何其他方式异步加载数据，那么使用暂记获取数据可以从多方面改进您的代码:</p><ul class=""><li id="7b2d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">它可以<strong class="kf ir">清除样板文件</strong></li><li id="e96d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">它可以让你的代码<strong class="kf ir">更易读</strong></li><li id="acae" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">它可以让你的代码<strong class="kf ir">更具声明性</strong></li><li id="91ef" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">最重要的是，它可以<strong class="kf ir">让你的应用更快</strong></li></ul><p id="2ecd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，只有几个库可以帮助你实现悬念。如果您的应用程序改变数据，监听实时数据，或者如果您想要实现任何更高级的悬念，您基本上只能自己解决。</p><p id="2615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将向您展示如何在您的应用程序中实现这些功能。为此，我们将使用传统的React编写一个简单的To do列表。然后，我们将分两步重构这个应用程序。首先通过引入误差边界，然后通过引入悬念。我们最终得到了一个速度更快、可读性更强、功能相同的应用程序。</p><p id="8205" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">读完这篇文章，你就能够实现:</strong></p><ul class=""><li id="cc73" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">带暂停提取数据</li><li id="80ef" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">暂停变异数据</li><li id="8bd8" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">带着悬念听连续的数据流</li></ul><h1 id="575c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">经典(协作)待办事项列表</h1><p id="c96a" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们从一个使用传统React编写的超级简单的待办事项列表应用程序开始。在此应用程序中，您只能完成待办事项。其他人每隔几秒钟就会添加一个新的待办事项。</p><p id="60de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们列出构成这个简单应用程序的要素:</p><p id="1ac9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先是我们的<code class="fe ms mt mu mv b">&lt;Todo /&gt;</code>组件:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3269" class="ne lq iq mv b gy nf ng l nh ni">function Todo({ todo, onComplete }) {<br/>  const [isLoading, setLoading] = useState(false);<br/>  const isMounted = useIsMounted();<br/>  return (<br/>    &lt;li&gt;<br/>      &lt;label&gt;<br/>        &lt;button<br/>          onClick={async () =&gt; {<br/>            setLoading(true);<br/>            await onComplete();<br/>            if (isMounted()) {<br/>              setLoading(false);<br/>            }<br/>          }}<br/>          disabled={isLoading}<br/>        &gt;<br/>          {isLoading ? &lt;div className="spinner" /&gt; : "Complete"}<br/>        &lt;/button&gt;{" "}<br/>        {todo.label}<br/>      &lt;/label&gt;<br/>    &lt;/li&gt;<br/>  );<br/>}</span></pre><p id="9e8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe ms mt mu mv b">isMounted</code>的使用。因为<code class="fe ms mt mu mv b">onComplete</code>是异步的，组件可能在<code class="fe ms mt mu mv b">onComplete</code>完成之前被卸载。当组件被卸载时调用<code class="fe ms mt mu mv b">setLoading</code>会导致内存泄漏。调用<code class="fe ms mt mu mv b">isMounted</code>可以防止这种情况。</p><p id="7b0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们的<code class="fe ms mt mu mv b">&lt;Todos /&gt;</code>组件:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="19f1" class="ne lq iq mv b gy nf ng l nh ni">function Todos({ todos, completeTodo }) {<br/>  return (<br/>    &lt;ul&gt;<br/>      {todos.map((todo) =&gt; (<br/>        &lt;Todo<br/>          key={todo.id}<br/>          todo={todo}<br/>          onComplete={() =&gt; completeTodo(todo.id)}<br/>        /&gt;<br/>      ))}<br/>      {todos.length === 0 &amp;&amp; &lt;li&gt;You're all done!&lt;/li&gt;}<br/>    &lt;/ul&gt;<br/>  );<br/>}</span></pre><p id="b98e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该组件列出所有todo项目，并在没有剩余项目时显示一条消息。</p><p id="f70c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们的todo存储在键值存储中。这里的实现模拟了位于服务器上的数据库。因此，读取和更新数据是异步进行的。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="47e8" class="ne lq iq mv b gy nf ng l nh ni"><em class="nj">// Key-value database<br/></em>class KeyValueStore {<br/><em class="nj">  // Read the value at some key<br/>  </em>async read(key)</span><span id="2861" class="ne lq iq mv b gy nk ng l nh ni"><em class="nj">  // Update the value at some key<br/>  </em>async update(key, newValue)</span><span id="f498" class="ne lq iq mv b gy nk ng l nh ni"><em class="nj">  // Register an observer for some key<br/>  // onNext is called every time the value in "key" changes<br/>  // Returns unregister function<br/>  </em>onUpdate(key, onNext)<br/>}</span></pre><p id="93c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些组件，我们就可以构建我们的应用程序了。请注意，这段代码相当复杂。之后我们一步一步地走过去。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d5bf" class="ne lq iq mv b gy nf ng l nh ni">function App() {<br/>  const [isLoading, setLoading] = useState(true);<br/>  const [error, setError] = useState();<br/>  const [todos, setTodos] = useState();<br/>  const isMounted = useIsMounted();</span><span id="ab31" class="ne lq iq mv b gy nk ng l nh ni"><em class="nj">  // Fetch todos</em><br/>  useEffect(() =&gt; {<br/>    setLoading(true);<br/>    keyValueStore<br/>      .read("todos")<br/>      .then((todos) =&gt; {<br/>        if (isMounted()) {<br/>          setTodos(todos);<br/>          setError(null);<br/>          setLoading(false);<br/>        }<br/>      })<br/>      .catch((error) =&gt; {<br/>        if (isMounted()) {<br/>          setError(error);<br/>          setLoading(false);<br/>        }<br/>      });<br/>  }, [isMounted]);</span><span id="fa9d" class="ne lq iq mv b gy nk ng l nh ni"><em class="nj">  // Complete todo</em><br/>  const completeTodo = useCallback(async (todoId) =&gt; {<br/>    try {<br/>      await keyValueStore.update("todos", (todos) =&gt;<br/>        todos.filter((todo) =&gt; todo.id !== todoId)<br/>      );<br/>      setError(null);<br/>    } catch (error) {<br/>      setError(error);<br/>    }<br/>  }, []);</span><span id="713d" class="ne lq iq mv b gy nk ng l nh ni"><em class="nj">  // Listen to incoming updates to todos</em><br/>  useEffect(() =&gt; keyValueStore.onUpdate("todos", setTodos), []);</span><span id="4184" class="ne lq iq mv b gy nk ng l nh ni">  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Todo list&lt;/h1&gt;<br/>      &lt;p&gt;Someone else may be adding todo's...&lt;/p&gt;<br/>      {isLoading ? (<br/>        &lt;div className="spinner" /&gt;<br/>      ) : error ? (<br/>        &lt;ErrorFallback error={error} /&gt;<br/>      ) : (<br/>        &lt;Todos todos={todos} completeTodo={completeTodo} /&gt;<br/>      )}<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="3e2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们仔细分析这段代码。发生了四件事:</p><h2 id="82c5" class="ne lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">1.正在提取待办事项:</h2><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d54b" class="ne lq iq mv b gy nf ng l nh ni">useEffect(() =&gt; {<br/>  setLoading(true);<br/>  keyValueStore<br/>    .read("todos")<br/>    .then((todos) =&gt; {<br/>      if (isMounted()) {<br/>        setTodos(todos);<br/>        setError(null);<br/>        setLoading(false);<br/>      }<br/>    })<br/>    .catch((error) =&gt; {<br/>      if (isMounted()) {<br/>        setError(error);<br/>        setLoading(false);<br/>      }<br/>    });<br/>}, [isMounted])</span></pre><p id="f3f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当应用程序挂载时，这个<code class="fe ms mt mu mv b">useEffect</code>钩子触发。它从键值存储的“todos”键中读取数据。成功时，数据保存在组件的状态中。当错误发生时，该错误也存储在状态中。</p><h2 id="d693" class="ne lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">2.完成待办事项</h2><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="45d1" class="ne lq iq mv b gy nf ng l nh ni">const completeTodo = useCallback(async (todoId) =&gt; {<br/>  try {<br/>    await keyValueStore.update("todos", (todos) =&gt;<br/>      todos.filter((todo) =&gt; todo.id !== todoId)<br/>    );<br/>    setError(null);<br/>  } catch (error) {<br/>    setError(error);<br/>  }<br/>}, []);</span></pre><p id="f314" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数更新键值存储中“todos”键的值。它通过从当前待办事项中过滤来完成待办事项。</p><p id="a801" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意跟踪错误所需的样板文件。我们稍后将对此进行重构…</p><h2 id="4339" class="ne lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">3.用键值存储保持组件状态最新</h2><p id="194f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">数据突变尚未反映在组件状态中。为了实现这一点，我们需要监听数据库更新:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="91b5" class="ne lq iq mv b gy nf ng l nh ni">useEffect(() =&gt; {<br/>  const unsubscribe = keyValueStore.onUpdate("todos", setTodos);<br/>  return () =&gt; {<br/>    unsubscribe();<br/>  }<br/>}, []);</span></pre><p id="6993" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<code class="fe ms mt mu mv b">useEffect</code>钩子就是这样做的。当组件挂载时，它设置一个到键值存储的监听器。每当“todos”键中的数据发生变化时，就会用新数据调用<code class="fe ms mt mu mv b">setTodos</code>。当组件被卸载时，它会再次删除该侦听器。这种模式在React中很常见。即使不使用悬念，我们也可以将其重构为一行:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a409" class="ne lq iq mv b gy nf ng l nh ni">useEffect(() =&gt; keyValueStore.onUpdate("todos", setTodos), []);</span></pre><h2 id="9bcf" class="ne lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">4.呈现待办事项列表</h2><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="9bed" class="ne lq iq mv b gy nf ng l nh ni">isLoading ? (<br/>  &lt;div className="spinner" /&gt;<br/>) : error ? (<br/>  &lt;ErrorFallback error={error} /&gt;<br/>) : (<br/>  &lt;Todos todos={todos} completeTodo={completeTodo} /&gt;<br/>)</span></pre><p id="822a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们的组件的状态是最新的，我们可以渲染。对于这样一个简单的组件，相当多的代码。</p><p id="8600" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始重构之前，让我们来看看todo应用程序的运行情况:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="c5d9" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">第一次重构:引入一个错误边界</h1><p id="ccf5" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">重构我们的应用程序来直接使用悬念会变得混乱。我们需要首先处理一件事:错误处理。</p><p id="7ef9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，错误在多个地方被捕获。这降低了代码的可读性。而且，它对我们施加了一个限制:组件中抛出的错误只能在组件本身中处理。</p><p id="2804" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了绕过这个限制，我们可以将我们的todo列表包装在一个<code class="fe ms mt mu mv b">&lt;ErrorBoundary /&gt;</code>中。当一个组件抛出一个错误时，这个错误沿着组件树向上传播，直到某个组件使用<a class="ae kc" href="https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries" rel="noopener ugc nofollow" target="_blank">componentiddcatch</a>捕获到它。这种捕捉错误的组件称为错误边界。错误边界允许我们在错误发生时轻松控制应用程序的哪一部分退出。此外，我们可以使用它们来指定向用户显示什么样的回退。</p><p id="7c0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以<a class="ae kc" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">自己写一个错误边界</a>。然而，对于这个应用，我们使用来自<a class="ae kc" href="https://github.com/bvaughn/react-error-boundary" rel="noopener ugc nofollow" target="_blank"> react-error-boundary </a>的流行实现。</p><p id="0be4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在应用程序中使用错误边界，如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="0d7f" class="ne lq iq mv b gy nf ng l nh ni">async function completeTodo(todoId) {<br/>  await keyValueStore.update("todos", (todos) =&gt;<br/>    todos.filter((todo) =&gt; todo.id !== todoId)<br/>  );<br/>}</span><span id="6e3f" class="ne lq iq mv b gy nk ng l nh ni">function Todolist() {<br/>  const [isLoading, setLoading] = useState(true);<br/>  const [todos, setTodos] = useState();<br/>  const isMounted = useIsMounted();</span><span id="1769" class="ne lq iq mv b gy nk ng l nh ni"><em class="nj">  // Fetch todos</em><br/>  useEffect(() =&gt; {<br/>    setLoading(true);<br/>    keyValueStore.read("todos").then((todos) =&gt; {<br/>      if (isMounted()) {<br/>        setTodos(todos);<br/>        setLoading(false);<br/>      }<br/>    });<br/>  }, [isMounted]);</span><span id="31f1" class="ne lq iq mv b gy nk ng l nh ni"><em class="nj">  // Listen to incoming updates to todos</em><br/>  useEffect(() =&gt; keyValueStore.onUpdate("todos", setTodos), []);</span><span id="71c0" class="ne lq iq mv b gy nk ng l nh ni">  return isLoading ? (<br/>    &lt;div className="spinner" /&gt;<br/>  ) : (<br/>    &lt;Todos todos={todos} completeTodo={completeTodo} /&gt;<br/>  );<br/>}</span><span id="1549" class="ne lq iq mv b gy nk ng l nh ni">function App() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Todo list&lt;/h1&gt;<br/>      &lt;p&gt;Someone else may be adding todo's...&lt;/p&gt;<br/>      &lt;ErrorBoundary FallbackComponent={ErrorFallback}&gt;<br/>        &lt;Todolist /&gt;<br/>      &lt;/ErrorBoundary&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="3b2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本结构保持不变。在挂载时，我们仍然获取todos，并且在挂载时，我们仍然监听来自键值存储的更新。然而，<code class="fe ms mt mu mv b">completeTodo</code>已经干净了很多，因为它现在只需要担心更新键值存储。所以渲染，现在只需要关注加载状态。</p><p id="181b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将<code class="fe ms mt mu mv b">&lt;Todolist /&gt;</code>组件包装在<code class="fe ms mt mu mv b">&lt;ErrorBoundary /&gt;</code>中，所有在<code class="fe ms mt mu mv b">&lt;Todolist /&gt;</code>组件中抛出的错误都会被自动处理。</p><h1 id="de8b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">一些基本的悬念—获取数据一次</h1><p id="ad15" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">悬念与错误界限非常相似。就像错误边界一样，您可以在某个组件周围包裹一个悬念边界。错误边界和暂停边界有一个很大的区别。悬念边界不捕捉错误，它捕捉承诺。</p><p id="c409" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解这一点，请考虑以下示例:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="de74" class="ne lq iq mv b gy nf ng l nh ni">&lt;Suspense fallback={&lt;p&gt;Searching for food...&lt;/p&gt;}&gt;<br/>  &lt;ErrorBoundary FallbackComponent={ErrorFallback}&gt;<br/>    &lt;RandomFood /&gt;<br/>  &lt;/ErrorBoundary&gt;<br/>&lt;/Suspense&gt;</span></pre><p id="67a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们有以下3种状态:</p><ol class=""><li id="99e2" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la ny lh li lj bi translated">加载:<code class="fe ms mt mu mv b">RandomFood = () =&gt; { return "Eggs"; }</code>在这种情况下，我们实际上会渲染<code class="fe ms mt mu mv b">"Eggs"</code></li><li id="13e0" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ny lh li lj bi translated">错误:<code class="fe ms mt mu mv b">RandomFood = () =&gt; { throw new Error("No food left"); }</code>在这种情况下，我们实际上会渲染<code class="fe ms mt mu mv b">&lt;ErrorFallback error={new Error("No food left")} /&gt;</code></li><li id="a16d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ny lh li lj bi translated">待定:<code class="fe ms mt mu mv b">RandomFood = () =&gt; { throw new Promise(() =&gt; {}) }</code>在这种情况下，我们实际上会渲染<code class="fe ms mt mu mv b">&lt;p&gt;Searching for food...&lt;/p&gt;</code></li></ol><p id="5367" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种三态模式在加载任何资源时都很常见。事实上，它是如此普遍，以至于它有一个名字。任何包含类似这种三态模式的<code class="fe ms mt mu mv b">read</code>函数的对象都被称为<code class="fe ms mt mu mv b">resource</code>。</p><p id="8418" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看最基本的资源:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a6a7" class="ne lq iq mv b gy nf ng l nh ni">class BaseResource {<br/>  data = undefined;<br/>  status = "pending";<br/>  error = undefined;<br/>  promise = null;</span><span id="3b2f" class="ne lq iq mv b gy nk ng l nh ni">  read() {<br/>    switch (this.status) {<br/>      case "pending":<br/>        throw this.promise;<br/>      case "error":<br/>        throw this.error;<br/>      default:<br/>        return this.data;<br/>    }<br/>  }<br/>}</span></pre><p id="11ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mv b">BaseResource</code>本身不做任何事情，但是我们可以把它作为基础来构建<code class="fe ms mt mu mv b">AsyncResource</code>。<code class="fe ms mt mu mv b">AsyncResource</code>接受任何承诺，并将其转换为符合资源规范的对象:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a1d2" class="ne lq iq mv b gy nf ng l nh ni">class AsyncResource extends BaseResource {<br/>  constructor(promise) {<br/>    super();<br/>    this.promise = promise<br/>      .then((data) =&gt; {<br/>        this.status = "success";<br/>        this.data = data;<br/>      })<br/>      .catch((error) =&gt; {<br/>        this.status = "error";<br/>        this.error = error;<br/>      });<br/>  }<br/>}</span></pre><p id="945f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仅仅使用这个简单的<code class="fe ms mt mu mv b">AsyncResource</code>，我们现在可以编写一个简单的应用程序。这个应用程序从随机食物api中读取一个随机食物，并在准备好的时候显示结果:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c299" class="ne lq iq mv b gy nf ng l nh ni">const foodResource = new AsyncResource(<br/>  fetch("/api/random_food").then((data) =&gt; data.json())<br/>);</span><span id="117d" class="ne lq iq mv b gy nk ng l nh ni">function RandomFood() {<br/>  const food = foodResource.read();<br/>  return (<br/>    &lt;fieldset&gt;<br/>      &lt;h2&gt;{food.dish}&lt;/h2&gt;<br/>      &lt;p&gt;{food.description}&lt;/p&gt;<br/>    &lt;/fieldset&gt;<br/>  );<br/>}</span><span id="7837" class="ne lq iq mv b gy nk ng l nh ni">function App() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Random food&lt;/h1&gt;<br/>      &lt;Suspense fallback={&lt;div className="spinner" /&gt;}&gt;<br/>        &lt;ErrorBoundary FallbackComponent={ErrorFallback}&gt;<br/>          &lt;RandomFood /&gt;<br/>        &lt;/ErrorBoundary&gt;<br/>      &lt;/Suspense&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="888f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，这里没有使用任何逻辑语句，而是使用了声明性的优点。</p><p id="6942" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，<code class="fe ms mt mu mv b">foodResource</code>被定义在需要数据的组件之外。通过这样做，可以在呈现组件之前获取数据。这节省了一些宝贵的时间。</p><p id="69ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看这个随机食物应用程序的运行情况:<em class="nj">(重新加载以查看不同的食物)</em></p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="aa5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的应用程序只需要这种类型的数据获取，一定要查看库<a class="ae kc" href="https://github.com/andreiduca/use-async-resource" rel="noopener ugc nofollow" target="_blank"> use-async-resource </a>。这个库允许这样做，甚至更多。</p><h1 id="3ada" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">暂停数据更新和实时数据</h1><p id="5275" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">有了基础知识，是时候将悬念引入我们的待办事项列表应用程序了。</p><p id="ecad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以实现<code class="fe ms mt mu mv b">todosResource = new AsyncResource(() =&gt; keyValueStore.read("todos"))</code>。然后我们可以使用<code class="fe ms mt mu mv b">todos = todosResource.read()</code>获得todos数据。然而，通过这种方式，我们只能接收到初始的todos数据。</p><p id="f30d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了处理数据突变和实时数据更新，我们需要另一种类型的资源。由于这种资源必须是“可观察的”，我们称之为<code class="fe ms mt mu mv b">ObservableResource</code>。它这样延伸<code class="fe ms mt mu mv b">BaseResource</code>:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="b6e0" class="ne lq iq mv b gy nf ng l nh ni">class ObservableResource extends BaseResource {<br/>  observers = [];</span><span id="de54" class="ne lq iq mv b gy nk ng l nh ni">  constructor(promise) {<br/>    super();<br/>    this.promise = promise<br/>      .then((data) =&gt; this.onNext(data))<br/>      .catch((error) =&gt; this.onError(error));<br/>  }</span><span id="8ef2" class="ne lq iq mv b gy nk ng l nh ni">  onNext(data) {<br/>    this.status = "success";<br/>    this.data = data;<br/>    this.observers.forEach(({ onNext }) =&gt;<br/>      typeof onNext === "function" &amp;&amp; onNext(this.data)<br/>    );<br/>  }</span><span id="f87b" class="ne lq iq mv b gy nk ng l nh ni">  onError(error) {<br/>    this.status = "error";<br/>    this.error = error;<br/>    this.observers.forEach(({ onError }) =&gt;<br/>      typeof onError === "function" &amp;&amp; onError(this.error)<br/>    );<br/>  }</span><span id="9cc6" class="ne lq iq mv b gy nk ng l nh ni">  observe(onNext, onError) {<br/>    const observer = { onNext, onError };<br/>    this.observers.push(observer);<br/>    return () =&gt; {<br/>      this.observers = this.observers.filter((other) =&gt;<br/>        other !== observer);<br/>    };<br/>  }<br/>}</span></pre><p id="ec1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要消耗这样一种可观察的资源，我们需要做两件事:</p><ol class=""><li id="da67" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la ny lh li lj bi translated">我们需要<code class="fe ms mt mu mv b">read()</code>它。这样我们可以在必要的时候抛出错误和承诺。</li><li id="8813" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ny lh li lj bi translated">我们需要解决它。这样，我们就可以在数据发生变化时得到通知。</li></ol><p id="3655" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在监听更新的每个组件中显式地编写这两个操作。然而，这又会导致一些样板文件。这就是我们推出<code class="fe ms mt mu mv b">useResource</code>挂钩的原因:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c897" class="ne lq iq mv b gy nf ng l nh ni">function useResource(resource) {<br/><em class="nj">  // Use state to force re-renders when data changes</em><br/>  const [, forceUpdate] = useState();<br/>  <em class="nj">// On every change, forceUpdate is called</em><br/>  useLayoutEffect(() =&gt; resource.observe(forceUpdate), [resource]);<br/>  <em class="nj">// Actually read the resource to get the correct data / error</em><br/>  return resource.read();<br/>}</span></pre><p id="9ab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们的todo应用程序运行起来，我们需要最后一个要素:一个与我们的键值存储一起工作的具体的可观察资源。我们可以这样定义它:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="0b2a" class="ne lq iq mv b gy nf ng l nh ni">class KeyValueStoreResource extends ObservableResource {<br/>  constructor(key) {<br/>    super(keyValueStore.read(key));<br/>    this.key = key;<br/><em class="nj">    // subscribe to mutations</em><br/>    keyValueStore.onUpdate(key, (data) =&gt; this.onNext(data));<br/>  }</span><span id="6e8b" class="ne lq iq mv b gy nk ng l nh ni">  async update(value) {<br/>    try {<br/>      this.onNext(await keyValueStore.update(this.key, value));<br/>    } catch (error) {<br/>      this.onError(error);<br/>    }<br/>  }<br/>}</span></pre><p id="766e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，我们的类层次结构如下:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c5cc" class="ne lq iq mv b gy nf ng l nh ni">BaseResource               <em class="nj">base class</em><br/>├ AsyncResource            <em class="nj">use for simple promise,</em><br/>|                          <em class="nj">consume with </em><strong class="mv ir"><em class="nj">.read()</em></strong><br/>└ ObservableResource       <em class="nj">use for mutable / real-time data,</em><br/>  |                        <em class="nj">consume with </em><strong class="mv ir"><em class="nj">useResource</em></strong><br/>  └ KeyValueStoreResource  <em class="nj">concrete implementation for KeyValueStore</em></span></pre><p id="7820" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们准备将这些元素组合成一个优雅的待办事项列表应用程序:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6478" class="ne lq iq mv b gy nf ng l nh ni">const todosResource = new KeyValueStoreResource("todos");</span><span id="ed5d" class="ne lq iq mv b gy nk ng l nh ni">const completeTodo = async (todoId) =&gt;<br/>  await todosResource.update((todos) =&gt;<br/>    todos.filter((todo) =&gt; todo.id !== todoId)<br/>  );</span><span id="7e90" class="ne lq iq mv b gy nk ng l nh ni">function TodosList() {<br/>  const todos = useResource(todosResource);<br/>  return &lt;Todos todos={todos} completeTodo={completeTodo} /&gt;;<br/>}</span><span id="befb" class="ne lq iq mv b gy nk ng l nh ni">function App() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Todo list&lt;/h1&gt;<br/>      &lt;p&gt;Someone else may be adding todo's...&lt;/p&gt;<br/>      &lt;Suspense fallback={&lt;div className="spinner" /&gt;}&gt;<br/>        &lt;ErrorBoundary FallbackComponent={ErrorFallback}&gt;<br/>          &lt;TodosList /&gt;<br/>        &lt;/ErrorBoundary&gt;<br/>      &lt;/Suspense&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="9cd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，所有的逻辑都是抽象的。这使得发现正在发生的事情变得非常容易。我们得到了一个漂亮的、声明性的待办事项列表应用程序。</p><h1 id="36a6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">这就是现在如何在应用程序中使用React Suspense获取数据。</h1><p id="e06f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">当然，还有更多的东西可以探究。有趣的下一步包括<code class="fe ms mt mu mv b"><a class="ae kc" href="https://reactjs.org/docs/concurrent-mode-patterns.html#suspenselist" rel="noopener ugc nofollow" target="_blank">&lt;SuspenseList /&gt;</a></code>、<code class="fe ms mt mu mv b"><a class="ae kc" href="https://reactjs.org/docs/concurrent-mode-patterns.html#transitions" rel="noopener ugc nofollow" target="_blank">useTransition</a></code>和<code class="fe ms mt mu mv b"><a class="ae kc" href="https://reactjs.org/docs/concurrent-mode-patterns.html#deferring-a-value" rel="noopener ugc nofollow" target="_blank">useDeferredValue</a></code>。这些比<code class="fe ms mt mu mv b">&lt;Suspense /&gt;</code>更具实验性，因此更有可能改变。</p><p id="6004" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是你的待办事项列表应用程序。我鼓励你<a class="ae kc" href="https://codesandbox.io/s/todo-list-with-suspense-v5xkx" rel="noopener ugc nofollow" target="_blank">用它来玩</a>，我很想听听你用悬念创造了什么。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div></div>    
</body>
</html>