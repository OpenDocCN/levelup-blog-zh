<html>
<head>
<title>The most common bugs in Java concurrent programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java并发编程中最常见的错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-most-common-bugs-in-java-concurrent-programming-498d33330423?source=collection_archive---------6-----------------------#2022-09-15">https://levelup.gitconnected.com/the-most-common-bugs-in-java-concurrent-programming-498d33330423?source=collection_archive---------6-----------------------#2022-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="049c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并发编程注意事项</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/df8702ee9072b8fbf8598cd485c71d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DznzObLAYprLzFrW"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@insolitus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Rowan Heuvel </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6ff5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于从事后端开发的同学来说，并发编程一定很熟悉。</p><p id="dcb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">说实话，java的并发编程是一个很难的部分，至少我是这么认为的。不仅更难理解，使用起来也更容易出现bug。</p><p id="ddc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天，我将和大家分享一些并发编程中最常见的bug。希望对你有帮助。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="20ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> ThreadLocal已用完，未清除。</strong></p><p id="66b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Java中有很多技术可以保证线程安全。可以使用<code class="fe lm ln lo lp b">synchronized</code>、<code class="fe lm ln lo lp b">Lock</code>等关键字锁定代码块。</p><p id="1929" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是它们有一个共同的特点，就是加锁会对代码的性能有一定的损失。</p><p id="8170" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，《JDK》中还提供了另一种观点，即:<code class="fe lm ln lo lp b">exchange space for time</code>。</p><p id="e168" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没错，使用<code class="fe lm ln lo lp b">ThreadLocal</code>类就是这种思路的具体体现。</p><p id="604c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">ThreadLocal</code>为每个使用该变量的线程提供一个独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的相应副本。</p><p id="5c7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">ThreadLocal</code>的用法大致是这样的:</p><ol class=""><li id="03b2" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn lv lw lx ly bi translated">首先创建一个CurrentUser类，它包含ThreadLocal的逻辑。</li></ol><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ec7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.在业务代码中调用CurrentUser类。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="8ac3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在业务代码的第一行，将<code class="fe lm ln lo lp b">userInfo</code>对象设置为<code class="fe lm ln lo lp b">CurrentUser</code>，这样在业务代码中，就可以通过<code class="fe lm ln lo lp b">CurrentUser.get()</code>获取刚刚设置的<code class="fe lm ln lo lp b">userInfo</code>对象。</p><p id="671d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尤其是当业务代码的调用层次比较深的时候，这种用法非常有用，可以减少很多不必要的参数传递。</p><p id="1626" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，在高并发场景中，这段代码存在一个问题。数据只存储在<code class="fe lm ln lo lp b">ThreadLocal</code>中，数据用完后没有及时清理。</p><p id="994a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使<code class="fe lm ln lo lp b">ThreadLocal</code>使用了<code class="fe lm ln lo lp b">WeakReference</code>，也可能存在内存泄漏问题，因为只有key在entry对象中被设置为弱引用，而<code class="fe lm ln lo lp b">value</code>没有。</p><p id="bc13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，如何解决这个问题呢？</p><p id="6be7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方法很简单，调用<code class="fe lm ln lo lp b">finally</code>块中的remove方法清理无用数据即可。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="3127" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">自旋锁浪费CPU资源，引发bug。</strong></p><p id="91e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在并发编程中，自旋锁想必大家都很熟悉。</p><p id="3e5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自旋锁的一个非常经典的使用场景是CAS(即比较交换)，这是一种无锁的思想(说白了就是使用了无限循环)，用来解决高并发场景下的数据更新问题。</p><p id="8389" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">atomic</code>包下的很多类，比如<code class="fe lm ln lo lp b">AtomicInteger</code>、<code class="fe lm ln lo lp b">AtomicLong</code>、<code class="fe lm ln lo lp b">AtomicBoolean</code>等。，是用CAS实现的。</p><p id="e3f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们以<code class="fe lm ln lo lp b">AtomicInteger</code>类为例，它的<code class="fe lm ln lo lp b">incrementAndGet</code>并不是每次都给变量加1。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ba52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它的底层是用自旋锁实现的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4a4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lm ln lo lp b">do…while</code>无限循环中，不断进行数据的比较和交换。如果一直失败，就会一直重试。</p><p id="a9ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在高并发的情况下，<code class="fe lm ln lo lp b">compareAndSwapInt</code>会大概率失效，从而导致CPU不断旋转，严重浪费CPU资源。</p><p id="8564" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，如果这个问题被解决了呢？</p><p id="7cdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方法是使用<code class="fe lm ln lo lp b">LockSupport</code>类的<code class="fe lm ln lo lp b">parkNanos</code>方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="e265" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当CAS失败时，调用<code class="fe lm ln lo lp b">LockSupport</code>类的<code class="fe lm ln lo lp b">parkNanos</code>方法休眠，相当于调用<code class="fe lm ln lo lp b">Thread.Sleep</code>方法。</p><p id="d884" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样可以有效减少频繁旋转造成的CPU资源过度浪费的问题。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="8a3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">对</strong>的陷阱<code class="fe lm ln lo lp b"><a class="ae le" href="http://twitter.com/Async" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">@Async</strong></a></code>对<strong class="js iu">的注解。</strong></p><p id="e64b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Java并发编程中实现异步函数之前，通常需要使用线程或线程池。</p><p id="cd84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">线程池的底层也使用线程。</p><p id="21a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要实现一个线程，要么继承<code class="fe lm ln lo lp b">Thread</code>类，要么实现<code class="fe lm ln lo lp b">Runnable</code>接口，然后在<code class="fe lm ln lo lp b">run</code>方法中编写具体的业务逻辑代码。</p><p id="e035" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">Spring</code>开发者为了简化这种异步操作，已经帮我们封装了异步功能。</p><p id="c324" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">Spring</code>提供了<code class="fe lm ln lo lp b">@Async</code>注释，通过它我们可以启用异步功能，使用起来非常方便。</p><ol class=""><li id="b8d0" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn lv lw lx ly bi translated">将<code class="fe lm ln lo lp b">@EnableAsync</code>注释添加到<code class="fe lm ln lo lp b">SpringBoot</code>的启动类。</li></ol><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="fc4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.向需要执行异步调用的业务方法添加<code class="fe lm ln lo lp b">@Async</code>注释。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="8600" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.在<code class="fe lm ln lo lp b">controller</code>方法中调用这个业务方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ad3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将启用异步功能。</p><p id="39dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">容易吗？</p><p id="41ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是有一个坏消息:用<code class="fe lm ln lo lp b"> @Async</code>注释启用的异步函数将调用<code class="fe lm ln lo lp b">AsyncExecutionAspectSupport</code>类的<code class="fe lm ln lo lp b">doSubmit</code>方法。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mb"><img src="../Images/eb7585b622639ef679219534976aa07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5V7gH6DNwpYnltc3ERNoQ.png"/></div></div></figure><p id="79e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，将遵循<code class="fe lm ln lo lp b">else</code>逻辑。</p><p id="f78a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">else逻辑最终将调用<code class="fe lm ln lo lp b">doExecute</code>方法:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c218" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您使用<code class="fe lm ln lo lp b">@Async</code>注释来启用异步函数，这将导致一个问题，默认情况下，每次都会创建一个新线程。</p><p id="5e8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在高并发情况下，可能会生成大量线程，从而导致OOM问题。</p><p id="0b17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建议您不要忘记在通过<code class="fe lm ln lo lp b">@Async</code>注释启用异步功能时定义一个线程池。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="217d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用默认线程池。</strong></p><p id="2daf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们都知道JDK1.5之后提供了<code class="fe lm ln lo lp b">ThreadPoolExecutor</code>类，可以用来自定义线程池。</p><p id="759a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">线程池有许多好处，例如:</p><ul class=""><li id="71e1" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn mc lw lx ly bi translated">减少资源消耗，避免频繁创建和销毁线程，可以直接重用现有线程。</li><li id="5261" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated">提供速度，任务来了之后，因为线程已经存在，可以直接使用。</li><li id="8845" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated">提高线程的可管理性。线程是非常宝贵的资源。如果创建过多的线程，不仅会消耗系统资源，甚至会影响系统的稳定性。</li><li id="0b69" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated">使用线程池，可以非常方便地创建、管理和监控线程。</li></ul><p id="c002" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，JDK专门提供了<code class="fe lm ln lo lp b">Executors</code>类供我们更方便地使用，它可以快速地为我们创建一个线程池。</p><p id="69c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个类包含许多静态方法:</p><ul class=""><li id="88d6" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn mc lw lx ly bi translated"><code class="fe lm ln lo lp b">newCachedThreadPool</code>:创建可缓冲的线程。如果线程池的大小超过处理需要，它可以灵活地回收空闲线程。如果没有回收，则创建一个新线程。</li><li id="81da" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated"><code class="fe lm ln lo lp b">newFixedThreadPool</code>:创建一个固定大小的线程池。如果任务的数量超过了线程池的大小，多余的任务将被放入队列中。</li><li id="ab10" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated"><code class="fe lm ln lo lp b">newScheduledThreadPool</code>:创建一个固定大小的线程池，可以执行定时的周期性任务。</li><li id="3355" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated"><code class="fe lm ln lo lp b">newSingleThreadExecutor</code>:创建一个只有一个线程的线程池，保证所有任务按顺序安装执行。</li></ul><p id="9f20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在高并发场景下，如果使用这些静态方法创建线程池，会出现一些问题。</p><p id="ad9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，我们来看看到底有什么问题。</p><ul class=""><li id="f576" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn mc lw lx ly bi translated"><code class="fe lm ln lo lp b">newFixedThreadPool</code>:允许请求的队列长度为整数。MAX_VALUE，可能会累积大量请求，导致OOM。</li><li id="4ab2" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated"><code class="fe lm ln lo lp b">newSingleThreadExecutor</code>:请求允许的队列长度是整数。MAX_VALUE，可能会累积大量请求，导致OOM。</li><li id="8013" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated"><code class="fe lm ln lo lp b">newCachedThreadPool</code>:允许创建的线程数为整数。MAX_VALUE，可能会创建大量线程，导致OOM。</li></ul><p id="86c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么我们该怎么办呢？</p><p id="2eca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建议先用<code class="fe lm ln lo lp b">ThreadPoolExecutor</code>类，我们自定义线程池。</p><p id="cdf5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">具体代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="8b6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便说一句，如果是一些低并发的场景，使用Executors类创建线程池也不是不可以，在所有场景中使用也不是不可以。</p><p id="3642" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这些低并发场景下，很难出现OOM问题，需要根据实际业务场景进行选择。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="d9d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> HashMap导致内存溢出。</strong></p><p id="ece7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在实际工作场景中，<code class="fe lm ln lo lp b">HashMap</code>的使用频率相当高，比如:接收参数、缓存数据、汇总数据等。</p><p id="5355" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果在多线程环境下使用<code class="fe lm ln lo lp b">HashMap</code>，可能会导致非常严重的后果。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7f6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">成员变量<code class="fe lm ln lo lp b">HashMap</code>在<code class="fe lm ln lo lp b">HashMapService</code>类中定义，数据被添加到<code class="fe lm ln lo lp b">add</code>方法中的<code class="fe lm ln lo lp b">HashMap</code>中。</p><p id="ef0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">调用<code class="fe lm ln lo lp b">controller</code>层的<code class="fe lm ln lo lp b">interface</code>中的<code class="fe lm ln lo lp b">add</code>方法会使用tomcat的线程池来处理请求，相当于在多线程场景下调用<code class="fe lm ln lo lp b">add</code>方法。</p><p id="1ca1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在JDK1.7中，HashMap使用的数据结构是<code class="fe lm ln lo lp b">array + linked list</code>。</p><p id="5b59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在多线程的情况下继续向HashMap添加数据，它会调用<code class="fe lm ln lo lp b">resize</code>方法进行扩展。</p><p id="4b74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将元素复制到新数组时，此方法使用头插入方法，这在某些情况下会导致链表中出现无限循环。</p><p id="4919" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无限循环的最终结果会导致<strong class="js iu">内存溢出</strong>。</p><p id="ea4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，如果HashMap中有很多数据，那么链表就会很长。在搜索一个元素时，需要遍历一个链表，查询效率不是很高。</p><p id="dce8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，在JDK1.8之后，HashMap的数据结构改为<strong class="js iu">数组+链表+红黑树</strong>。</p><p id="056d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果同一个数组元素中的数据项少于8个，则仍然使用链表来保存数据。如果超过8棵，会自动转换成红黑树。</p><p id="74e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么要用红黑树？</p><p id="7284" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为链表的时间复杂度为<code class="fe lm ln lo lp b">O(n)</code>，红黑树的时间复杂度为<code class="fe lm ln lo lp b">O(logn)</code>，红黑树的复杂度优于链表。</p><p id="d200" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然如此，为什么不用红黑树呢？</p><p id="b712" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为树节点占用的存储空间是链表节点的两倍，所以在节点较少的情况下，红黑树在时间复杂度上略优于链表。</p><p id="ff29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但由于红黑树占用的空间较大，综合考虑HashMap后，认为在节点数较少的情况下，使用占用存储空间较多的红黑树并不划算。</p><p id="4f4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JDK1.8中的HashMap不会出现无限循环？</p><p id="9cbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">错了，它在多线程环境下还是有无限循环的。</p><p id="e8f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在扩展过程中，链表转换成树时，for循环无法跳出，导致无限循环。</p><p id="d4b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，如果想在多线程环境中使用HashMap呢？</p><p id="4927" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答案是用<code class="fe lm ln lo lp b">ConcurrentHashMap</code>。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="e417" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">忘记解锁。</strong></p><p id="a17e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Java中，除了使用<code class="fe lm ln lo lp b">synchronized</code>关键字来锁定我们需要的代码块，我们还可以使用<code class="fe lm ln lo lp b">Lock</code>关键字来锁定。</p><p id="5030" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe lm ln lo lp b">synchronized</code>关键字锁定后，如果程序执行完毕，或者程序异常，锁定会自动解除。</p><p id="a29c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果使用<code class="fe lm ln lo lp b">Lock</code>关键字进行锁定，开发者需要在代码中手动解除锁定。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="743d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码首先创建一个<code class="fe lm ln lo lp b">ReentrantLock</code>类的实例对象<code class="fe lm ln lo lp b">rLock</code>，并调用它的lock方法来锁定。然后执行业务代码，最后调用<code class="fe lm ln lo lp b">finally</code>代码块中的<code class="fe lm ln lo lp b">unlock</code>方法。</p><p id="a27f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果您不通过调用<code class="fe lm ln lo lp b">finally</code>块中的<code class="fe lm ln lo lp b">unlock</code>方法来手动释放锁，线程持有的锁将不会被释放。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="f0ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">程序死锁。</strong></p><p id="3d32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">死锁可能是大家都不希望遇到的问题因为一旦程序在没有外力的情况下出现死锁，程序就会因为资源竞争而一直处于假死状态。</p><p id="9f1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">死锁示例代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1a12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当线程获得OBJECT_1锁时，它不释放锁，然后申请OBJECT_2锁。</p><p id="b6d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这时另一个线程获取了OBJECT_2锁，没有释放锁去申请OBJECT_1锁。</p><p id="c4a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于OBJECT_1和OBJECT_2锁都没有释放，两个线程会一起请求，陷入无限循环，即出现死锁情况。</p><p id="9975" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么如果避免了死锁问题呢？</p><p id="04e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mi"> # 1。缩小锁的范围。</em>T12】</strong></p><p id="e33e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">死锁情况可能是由于锁范围如上所述太大造成的。</p><p id="d3a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，解决方案就是缩小锁的范围。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="cfbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在获取OBJECT_1锁的代码块中，不包括获取OBJECT_2锁的代码。</p><p id="62ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同时，用于获取OBJECT_2锁的代码块不包含用于获取OBJECT_1锁的代码。</p><p id="df20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mi"> # 2。锁的保证顺序。</em> </strong></p><p id="1950" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在死锁的情况下，线程获取锁的顺序是OBJECT_1和OBJECT_2。</p><p id="1a2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个线程以相反的顺序获取锁:OBJECT_2和OBJECT_1。</p><p id="0c8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，如果能保证每次获取锁的顺序都一样，就不会出现死锁问题。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="210f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两个线程，每个线程先获取OBJECT_1锁，再获取OBJECT_2锁。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="602e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> SimpleDateFormat不是线程安全的。</strong></p><p id="1b97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Java8之前，我们通常使用SimpleDateFormat类来格式化时间。例如:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0b4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你真的这么写，那也没关系。</p><p id="c766" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果有一天你觉得dateFormat是一段固定的代码，你就应该把它提取出来作为一个常量。</p><p id="68cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，将代码更改为以下内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b8b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">dateFormat</code>对象被定义为一个静态常量，这样它可以被所有对象共享。</p><p id="4b76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果只有一个线程调用<code class="fe lm ln lo lp b">time</code>方法也没有问题。</p><p id="cfc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，<code class="fe lm ln lo lp b">Serivce</code>类的方法经常被<code class="fe lm ln lo lp b">Controller</code>类调用，控制器类的接口方法被Tomcat线程池调用。</p><p id="6039" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，多个线程可能调用同一个控制器类的同一个方法，也就是多个线程可能同时调用<code class="fe lm ln lo lp b">time</code>方法。</p><p id="288e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">time</code>方法调用<code class="fe lm ln lo lp b">SimpleDateFormat</code>类的<code class="fe lm ln lo lp b">parse</code>方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="49e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个方法将调用<code class="fe lm ln lo lp b">establish</code>方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a720" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">步骤1、2和3是非原子操作。</p><p id="7b38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果<code class="fe lm ln lo lp b">cal</code>对象是局部变量，那就好了，但是不好了。当<code class="fe lm ln lo lp b">parse</code>方法调用<code class="fe lm ln lo lp b">establish</code>方法时，传入的<code class="fe lm ln lo lp b">calendar</code>是<code class="fe lm ln lo lp b">SimpleDateFormat</code>类的父类<code class="fe lm ln lo lp b">DateFormat</code>的成员变量。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1153" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样可能会有多个线程同时修改同一个对象:<code class="fe lm ln lo lp b">dateFormat</code>，同一个成员变量:<code class="fe lm ln lo lp b">Calendar</code>值。</p><p id="57d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，可能会发生一个线程设置了时间，而被其他线程修改，导致时间错误。</p><p id="2864" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，如何解决这个问题呢？</p><ul class=""><li id="330d" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn mc lw lx ly bi translated"><code class="fe lm ln lo lp b">SimpleDateFormat</code>类的对象不应该被定义为静态的，而是可以被改变为方法的局部变量。</li><li id="9c79" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated">使用<code class="fe lm ln lo lp b">ThreadLocal</code>保存<code class="fe lm ln lo lp b">SimpleDateFormat</code>类的数据。</li><li id="f9e3" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated">使用Java8的<code class="fe lm ln lo lp b">DateTimeFormatter</code>类。</li></ul></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="13a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">双重检查锁定漏洞。</strong></p><p id="3b84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单身模式更多的出现在实际工作或面试中。</p><p id="9237" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们都知道有两种类型的单例模式:饥饿模式和懒惰模式。</p><p id="72b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">饥饿模式代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a5b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用饥饿模式的好处是:没有线程安全问题，但缺点也很明显。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ca48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对象在开始时被实例化。如果实例化过程非常耗时，最后没有用到对象，岂不是浪费资源？</p><p id="7dec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这时候你可能会想，不需要提前实例化对象，可以等实际使用的时候再实例化吗？</p><p id="422f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我接下来要讲的:懒惰模式。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="54bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例中的<code class="fe lm ln lo lp b">INSTANCE</code>对象开始时为空，只有在调用<code class="fe lm ln lo lp b">getInstance</code>方法时才会被实例化。</p><p id="6571" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，还不错。但是这段代码仍然存在一个问题。</p><p id="6c74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果有多个线程调用<code class="fe lm ln lo lp b">getInstance</code>方法，那么当它们都到达<code class="fe lm ln lo lp b">if (INSTANCE == null)</code>判断时，可能同时建立，因为<code class="fe lm ln lo lp b">INSTANCE</code>初始化时默认值为<code class="fe lm ln lo lp b">null</code>。</p><p id="ab9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将导致在多个线程中同时创建<code class="fe lm ln lo lp b">INSTANCE</code>对象，即多次创建<code class="fe lm ln lo lp b">INSTANCE</code>对象，违背了只创建一个<code class="fe lm ln lo lp b">INSTANCE</code>对象的初衷。</p><p id="00c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决饿模式和懒模式各自的问题，有了<code class="fe lm ln lo lp b">double-checked lock</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c562" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要在<code class="fe lm ln lo lp b">synchronized</code>前后对null进行两次求值。</p><p id="50d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但我要告诉你的是:这段代码有问题。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1491" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<code class="fe lm ln lo lp b">getInstance</code>方法的代码，我是按照<code class="fe lm ln lo lp b">1, 2, 3, 4, and 5</code>的顺序写的，我希望按照这个顺序执行。</p><p id="64f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是Java虚拟机实际上会做一些优化，重新安排一些代码指令。重排后的顺序可能会变成:<code class="fe lm ln lo lp b">1, 3, 2, 4, 5</code>，这样在多线程的情况下也会创建多个实例。重新排列后的代码可能如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2dd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原来如此，有什么解决办法？</p><p id="2de6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答:可以在<code class="fe lm ln lo lp b">INSTANCE</code>的定义中加入<code class="fe lm ln lo lp b">volatile</code>关键字。具体代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="5564" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">volatile</code>关键字可以保证多线程的可见性但不保证原子性，也可以禁止指令重排序。</p><p id="0d42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与直接锁定相比，双重检查锁定机制不仅确保了线程安全，还提高了执行效率并节省了内存空间。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="1d6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"/><code class="fe lm ln lo lp b"><strong class="js iu">volatile</strong></code><strong class="js iu">的原子性导致bug。</strong></p><p id="b481" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前面我们已经知道<code class="fe lm ln lo lp b">volatile</code>是一个非常好的关键字，它可以保证多线程中变量的可见性，它也可以禁止指令重排，但是它不能保证原子性。</p><p id="b866" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可见性主要体现在:一个线程修改一个变量，另一个线程每次都能得到该变量的最新值。</p><p id="5fd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看错误的例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d906" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，<code class="fe lm ln lo lp b">VolatileTest</code>是Thread类的一个子类。其成员变量<code class="fe lm ln lo lp b">stopFlag</code>默认为<code class="fe lm ln lo lp b">false</code>，在其<code class="fe lm ln lo lp b">run</code>方法中修改为<code class="fe lm ln lo lp b">true</code>。</p><p id="3216" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后在main方法的<code class="fe lm ln lo lp b">main</code>线程中，使用<code class="fe lm ln lo lp b">vt.isStopFlag()</code>方法进行判断，如果其值为<code class="fe lm ln lo lp b">true</code>，则打印<code class="fe lm ln lo lp b">stop</code>关键字。</p><p id="1124" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，如何修改<code class="fe lm ln lo lp b">stopFlag</code>的值，并通过主线程中的<code class="fe lm ln lo lp b">vt.isStopFlag()</code>方法获取最新值呢？</p><p id="8b71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正确的例子如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="5f32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用volatile关键字修改<code class="fe lm ln lo lp b">stopFlag</code>。</p><p id="567a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面重点介绍volatile的原子性。</p><p id="552f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用多线程给<code class="fe lm ln lo lp b">count</code>加1，代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="502a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每次执行结果不一样，但可以肯定的是每次计数值都小于20000，比如<code class="fe lm ln lo lp b">19999</code>。</p><p id="df72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，<code class="fe lm ln lo lp b">count</code>是一个成员变量。虽然定义为<code class="fe lm ln lo lp b">volatile</code>，但是<code class="fe lm ln lo lp b">add</code>方法中的<code class="fe lm ln lo lp b">count++</code>是非原子操作。在多线程环境中，数据可能会有问题。</p><p id="985f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可见<code class="fe lm ln lo lp b">volatile</code>并不能保证原子性。</p><p id="0d79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，如何解决这个问题呢？</p><p id="cb64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答案是使用<code class="fe lm ln lo lp b">synchronized</code>关键字。</p><p id="8001" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">修改后的代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lz ma l"/></div></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="02bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您阅读这篇文章。</p><p id="00c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">敬请关注更多内容。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="ce10" class="mj mk it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">分级编码</h1><p id="caa0" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="e35a" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn mc lw lx ly bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="b0e7" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated">📰查看<a class="ae le" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="7600" class="lq lr it js b jt md jx me kb mf kf mg kj mh kn mc lw lx ly bi translated">🔔关注我们:<a class="ae le" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae le" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae le" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="4a37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🚀👉<a class="ae le" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>