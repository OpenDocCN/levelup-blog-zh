<html>
<head>
<title>Efficiently Scraping Multiple Pages of Data: A Guide to Handling Pagination with Selenium and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高效抓取多页数据:使用Selenium和Python处理分页的指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/efficiently-scraping-multiple-pages-of-data-a-guide-to-handling-pagination-with-selenium-and-3ed93857f596?source=collection_archive---------4-----------------------#2022-12-28">https://levelup.gitconnected.com/efficiently-scraping-multiple-pages-of-data-a-guide-to-handling-pagination-with-selenium-and-3ed93857f596?source=collection_archive---------4-----------------------#2022-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/35ce54c622f17dd65d3252f18174c4d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UEx_HZtXOJm8ZWA-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@roman34nov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗曼·特里福诺夫</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c0d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么分页对网页抓取器来说是一个如此大的挑战？</p><p id="22b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它从来不只是一页，它总是一页接一页的…</p><p id="a52e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您是否厌倦了手动单击分页元素的无尽页面来收集数据？不要害怕，因为我们已经为您找到了解决方案！在本文中，我们将向您展示如何使用Selenium和Python来为您完成所有困难的工作。想象一下再也不用点击“下一步”了！只是坐下来，放松，让计算机做一页又一页的数据抓取的繁琐任务。如果出现任何问题，不要担心，我们也有一些关于错误处理的提示。所以不要等待，今天就带着微笑开始刮那些页面吧！</p><p id="3702" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分页是网站上的一个常见功能，它允许您浏览多个内容页面。当使用分页抓取网站时，考虑如何处理分页以确保能够抓取所有需要的数据是很重要的。</p><p id="7681" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个演示中，我们将使用selenium包Selenium是一个自动化web浏览器的流行工具。它允许您控制web浏览器并执行操作，例如导航到网页、与页面上的元素交互以及从页面提取数据。这对于抓取需要执行JavaScript的网站或者使用AJAX动态加载内容的网站特别有用。</p><h2 id="ae05" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">设置环境</h2><p id="2832" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">安装Selenium</p><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="4ed0" class="mi lc iq me b be mj mk l ml mm">pip install selenium</span></pre><p id="c62d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装web驱动程序管理器</p><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="b501" class="mi lc iq me b be mj mk l ml mm">pip install webdriver-manager</span></pre><p id="e174" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">启动浏览器</p><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="873d" class="mi lc iq me b be mj mk l ml mm"># selenium 4<br/>from selenium import webdriver<br/>from selenium.webdriver.chrome.service import Service as ChromeService<br/>from webdriver_manager.chrome import ChromeDriverManager<br/><br/>driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()))<br/>driver.get('https://pagination.js.org/')<br/>driver.maximize_window()</span></pre><p id="4cc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码描述</p><ul class=""><li id="511f" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">这段代码将使用<code class="fe mw mx my me b">webdriver_manager</code>库安装ChromeDriver可执行文件，并使用Selenium启动Chrome浏览器。浏览器将导航到网站“<a class="ae kc" href="https://pagination.js.org/" rel="noopener ugc nofollow" target="_blank">https://pagination.js.org/</a>”并最大化窗口。</li><li id="af90" class="mn mo iq kf b kg mz kk na ko nb ks nc kw nd la ms mt mu mv bi translated"><code class="fe mw mx my me b">ChromeService</code>类用于创建管理ChromeDriver进程的服务。它允许你根据需要启动和停止ChromeDriver进程。</li><li id="8bc6" class="mn mo iq kf b kg mz kk na ko nb ks nc kw nd la ms mt mu mv bi translated"><code class="fe mw mx my me b">webdriver_manager</code>库中的<code class="fe mw mx my me b">ChromeDriverManager</code>类用于下载和安装ChromeDriver可执行文件。它将自动下载与您安装的Chrome版本兼容的最新版本的ChromeDriver。</li><li id="5482" class="mn mo iq kf b kg mz kk na ko nb ks nc kw nd la ms mt mu mv bi translated">注意，为了使用这段代码，你需要安装<code class="fe mw mx my me b">webdriver_manager</code>库。</li></ul><h2 id="c3bd" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">与页面上的Web元素交互</h2><p id="89d2" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们将处理正常的分页，并从表中提取数字。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/76eeadf495bc551fdb58a350f9d076d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGuAdRyU2Hj_WxJZ5URSIA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">正常分页</figcaption></figure><p id="1ca1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步骤:</p><ul class=""><li id="076a" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">右键单击下一个页面元素并检查</li></ul><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/ad5a63632b88b486744782af271961e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqYSPteOED5VTnLF-pt9ew.png"/></div></div></figure><ul class=""><li id="ecc1" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">转到元素，我们可以观察到该元素包含一个下一个箭头，因此我们使用Xpath函数text()来捕获该元素。</li></ul><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="5e29" class="mi lc iq me b be mj mk l ml mm">//a[text()='›']</span></pre><p id="2a51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">复制xpath并将其粘贴到python脚本中</p><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="467b" class="mi lc iq me b be mj mk l ml mm">from selenium.webdriver.common.by import By <br/>next_page = driver.find_element(By.XPATH,'//a[text()='›']').click()</span></pre><p id="c7e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my me b">find_element</code>方法用于根据指定的搜索标准定位网页上的元素。在这种情况下，<code class="fe mw mx my me b">By.XPATH</code>标准用于使用XPath表达式搜索元素。XPath表达式指定元素在HTML DOM树中的位置。</p><p id="61d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my me b">click</code>方法用于模拟鼠标点击元素。这将触发与该元素相关联的任何JavaScript事件或动作。在这种情况下，我们可以看到我们移动到第二页。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/81c861078e74af5f0a5d8df653e1310f.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*CYDIcO34etmD8KdZreid8A.png"/></div></figure><p id="c1c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们创建一个循环，点击下一步按钮，直到到达页面的结尾，但这里最大的挑战是我们如何理解我们已经到达了页面的结尾。</p><p id="4b1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分页的逻辑构建</p><ul class=""><li id="2b54" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">检查分页列表</li></ul><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/634b8409e5a51e9904b78de73b91957c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*tInU0A1A2impXqd3eem3Ug.png"/></div></figure><ul class=""><li id="5652" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">我们最后观察到的分页列表的Dom结构，但是无序列表的一个元素给出了页数。</li></ul><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="d0c0" class="mi lc iq me b be mj mk l ml mm">&lt;div class="paginationjs-pages"&gt;<br/>    &lt;ul&gt;<br/>        &lt;li class="paginationjs-prev disabled "&gt;&lt;a&gt;‹&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li class="paginationjs-page J-paginationjs-page  active" data-num="1"&gt;&lt;a&gt;1&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li class="paginationjs-page J-paginationjs-page " data-num="2"&gt;&lt;a&gt;2&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li class="paginationjs-page J-paginationjs-page " data-num="3"&gt;&lt;a&gt;3&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li class="paginationjs-page J-paginationjs-page " data-num="4"&gt;&lt;a&gt;4&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li class="paginationjs-page J-paginationjs-page " data-num="5"&gt;&lt;a&gt;5&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li class="paginationjs-ellipsis disabled"&gt;&lt;a&gt;...&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li class="paginationjs-page paginationjs-last J-paginationjs-page " data-num="20"&gt;&lt;a&gt;20&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li class="paginationjs-next J-paginationjs-next " data-num="2" title="Next page"&gt;&lt;a&gt;›&lt;/a&gt;&lt;/li&gt;<br/>    &lt;/ul&gt;<br/>&lt;/div&gt;</span></pre><ul class=""><li id="3dcf" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">使用浏览器中的检查工具找到这个无序列表元素的xpath。</li></ul><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="94b2" class="mi lc iq me b be mj mk l ml mm">all_list_elements = driver.find_elements(By.XPATH,'//*[@id="demo1"]/div[2]/div/ul/li')<br/>number_of_pages = int(all_list_elements[-2].text)</span></pre><p id="b7b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码将使用Selenium来定位pagination元素中的所有页面元素，并提取页面总数。</p><p id="dc13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my me b">find_elements</code>方法类似于<code class="fe mw mx my me b">find_element</code>方法，但是它返回匹配搜索标准的元素列表，而不是单个元素。</p><p id="81c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，代码搜索id为“demo1”的所有元素、类为“ul”的子元素和类为“li”的子元素。然后它会将元素列表存储在<code class="fe mw mx my me b">all_list_elements</code>变量中。</p><p id="cfbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过选择列表中的倒数第二个元素(<code class="fe mw mx my me b">all_list_elements[-2]</code>)并提取文本内容来提取总页数。文本内容是页数。然后它被转换成一个整数并存储在<code class="fe mw mx my me b">number_of_pages</code>变量中。</p><ul class=""><li id="e328" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">一旦我们找到了页数，我们就写一个for循环来迭代直到页面结束</li></ul><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="66de" class="mi lc iq me b be mj mk l ml mm">for _ in range(number_of_pages):<br/>    next_page = driver.find_element(By.XPATH,"//a[text()='›']").click()<br/>    time.sleep(2)</span></pre><p id="531e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my me b">for</code>循环将迭代指定的次数(<code class="fe mw mx my me b">number_of_pages</code>)，在每次迭代中，它将使用<code class="fe mw mx my me b">find_element</code>方法和<code class="fe mw mx my me b">By.XPATH</code>标准定位“下一步”按钮。然后它将使用<code class="fe mw mx my me b">click</code>方法点击按钮。</p><p id="659a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my me b">time.sleep</code>函数用于将脚本暂停指定的秒数(在本例中为2秒)。这有助于在与网页交互之前让网页完全载入。</p><ul class=""><li id="77d4" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">现在我们已经演示了如何遍历页面，让我们编写一个脚本来捕获表中的所有元素</li></ul><p id="8aa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步伐</p><ul class=""><li id="2833" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">转到有数字的表格，右键单击并检查</li></ul><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/afaf667ff148178526fd9154113904fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*3kM-LLYbtF9jX5BeMc3ZUg.png"/></div></figure><ul class=""><li id="a78f" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">我们注意到该表是一个无序列表</li></ul><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/155fecd636bb7dcc116c57faff35df20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnunlosCfKS81jMUXjV52g.png"/></div></div></figure><ul class=""><li id="7d38" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">并且每个数字都在无序列表的一个<li>元素中。</li></li></ul><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="7511" class="mi lc iq me b be mj mk l ml mm">&lt;div class="data-container"&gt;<br/>    &lt;ul&gt;<br/>        &lt;li&gt;1&lt;/li&gt;<br/>        &lt;li&gt;2&lt;/li&gt;<br/>        &lt;li&gt;3&lt;/li&gt;<br/>        &lt;li&gt;4&lt;/li&gt;<br/>        &lt;li&gt;5&lt;/li&gt;<br/>        &lt;li&gt;6&lt;/li&gt;<br/>        &lt;li&gt;7&lt;/li&gt;<br/>        &lt;li&gt;8&lt;/li&gt;<br/>        &lt;li&gt;9&lt;/li&gt;<br/>        &lt;li&gt;10&lt;/li&gt;<br/>    &lt;/ul&gt;<br/>&lt;/div&gt;</span></pre><ul class=""><li id="bd7d" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">为了捕获无序列表中的所有元素，我们可以编写一个xpath</li></ul><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="b781" class="mi lc iq me b be mj mk l ml mm"># Locate all elements on the current page of the pagination element<br/>page_elements = driver.find_elements(By.XPATH,'//*[@id="demo1"]/div[1]/ul/li')<br/><br/># Extract the text content of the first element in the list<br/>text_content = page_elements[0].get_attribute('innerHTML')<br/><br/># Print the text content to the console<br/>print(text_content)</span></pre><p id="3c30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码使用Selenium来定位pagination元素的当前页面上匹配指定XPath表达式的所有元素。然后使用<code class="fe mw mx my me b">get_attribute</code>方法和<code class="fe mw mx my me b">'innerHTML'</code>属性提取列表中第一个元素的文本内容。最后，它使用<code class="fe mw mx my me b">print</code>函数将文本内容打印到控制台。</p><ul class=""><li id="2873" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">让我们将上面讨论的逻辑组合到一个函数中，并在上面编码的for循环中使用它来单击下一页。</li></ul><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="713f" class="mi lc iq me b be mj mk l ml mm">def extract_page_data(driver):<br/>    # Initialize an empty list to store the data<br/>    page_output = []<br/><br/>    # Locate all elements on the current page of the pagination element<br/>    page_elements = driver.find_elements(By.XPATH,'//*[@id="demo1"]/div[1]/ul/li')<br/><br/>    # Iterate through the list of elements<br/>    for each_element in page_elements:<br/>        # Extract the text content of each element<br/>        each_element_value = each_element.get_attribute('innerHTML')<br/>        # Add the extracted text content to the page_output list<br/>        page_output.append(each_element_value)<br/><br/>    # Return the page_output list<br/>    return page_output<br/><br/><br/># Initialize an empty list to store the data from all pages<br/>final_out = []<br/><br/># Iterate through the pages<br/>for page_num in range(number_of_pages):<br/>    # Extract the data from the current page<br/>    page_output = extract_page_data(driver)<br/>    # Add the data to the final_out list as a dictionary with the page number as the key<br/>    final_out.append({<br/>        page_num: page_output<br/>    })<br/>    # Locate the "Next" button on the webpage and click it to navigate to the next page<br/>    next_page = driver.find_element(By.XPATH, "//a[text()='›']").click()</span></pre><p id="009d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文章的完整代码</p><pre class="lz ma mb mc gt md me mf bn mg mh bi"><span id="f0d3" class="mi lc iq me b be mj mk l ml mm"># Import the necessary libraries<br/>from selenium import webdriver<br/>from selenium.webdriver.chrome.service import Service as ChromeService<br/>from webdriver_manager.chrome import ChromeDriverManager<br/>from selenium.webdriver.common.by import By<br/>import time<br/><br/># Install the ChromeDriver executable and start a Chrome browser using Selenium<br/>driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()))<br/><br/># Navigate to the website and maximize the window<br/>driver.get('https://pagination.js.org/')<br/>driver.maximize_window()<br/><br/># Locate all elements in the pagination element and extract the total number of pages<br/>all_list_elements = driver.find_elements(By.XPATH,'//*[@id="demo1"]/div[2]/div/ul/li')<br/>number_of_pages = int(all_list_elements[-2].text)<br/><br/># Define a function to extract the data from the current page of the pagination element<br/>def extract_page_data(driver):<br/>    # Initialize an empty list to store the data<br/>    page_output = []<br/><br/>    # Locate all elements on the current page of the pagination element<br/>    page_elements = driver.find_elements(By.XPATH,'//*[@id="demo1"]/div[1]/ul/li')<br/><br/>    # Iterate through the list of elements<br/>    for each_element in page_elements:<br/>        # Extract the text content of each element<br/>        each_element_value = each_element.get_attribute('innerHTML')<br/>        # Add the extracted text content to the page_output list<br/>        page_output.append(each_element_value)<br/><br/>    # Return the page_output list<br/>    return page_output<br/><br/># Initialize an empty list to store the data from all pages<br/>final_out = []<br/><br/># Iterate through the pages<br/>for page_num in range(number_of_pages):<br/>    # Extract the data from the current page<br/>    page_output = extract_page_data(driver)<br/>    # Add the data to the final_out list as a dictionary with the page number as the key<br/>    final_out.append({<br/>        page_num: page_output<br/>    })<br/>    # Locate the "Next" button on the webpage and click it to navigate to the next page<br/>    next_page = driver.find_element(By.XPATH, "//a[text()='›']").click()</span></pre><p id="6201" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总结:</p><p id="45d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们演示了如何使用Selenium和Python从网站的分页元素中抓取数据。我们展示了如何在pagination元素中提取总页数，定义一个函数从每个页面中提取数据，并使用一个<code class="fe mw mx my me b">for</code>循环遍历页面并提取数据。我们还提供了关于错误处理和测试代码的技巧，以确保代码正常运行。通过遵循本文概述的步骤，您应该能够使用Selenium和Python成功地从分页元素中抓取数据。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="1420" class="nr lc iq bd ld ns nt nu lg nv nw nx lj ny nz oa lm ob oc od lp oe of og ls oh bi translated">分级编码</h1><p id="ecfd" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="dc46" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="d581" class="mn mo iq kf b kg mz kk na ko nb ks nc kw nd la ms mt mu mv bi translated">📰查看<a class="ae kc" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="2097" class="mn mo iq kf b kg mz kk na ko nb ks nc kw nd la ms mt mu mv bi translated">🔔关注我们:<a class="ae kc" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kc" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kc" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="bca5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">🚀👉<a class="ae kc" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>