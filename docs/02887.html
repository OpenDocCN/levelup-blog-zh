<html>
<head>
<title>Send Files over a Data Channel: Video Call with WebRTC Step 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过数据通道发送文件:使用WebRTC进行视频通话步骤6</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/send-files-over-a-data-channel-video-call-with-webrtc-step-6-d38f1ca5a351?source=collection_archive---------0-----------------------#2020-04-09">https://levelup.gitconnected.com/send-files-over-a-data-channel-video-call-with-webrtc-step-6-d38f1ca5a351?source=collection_archive---------0-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0a4bc83029613cd1f7d344a836a42c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdtNajBcZKkR239WpiXd1w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯蒂娜·特里普科维奇在<a class="ae kf" href="https://unsplash.com/s/photos/post?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5c33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">WebRTC通常用于创建视频和语音呼叫，但这只是它所能做的一部分。它在用户之间建立了对等连接，我们可以将其用于任何目的，例如文件共享。</p><p id="44d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文是关于WebRTC的系列文章的第六篇。</p><ul class=""><li id="4709" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/data-stream-from-your-webcam-and-microphone-videochat-with-javascript-step-1-29895b70808b">第一步:来自网络摄像头和麦克风的数据流</a></li><li id="78a3" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/set-up-a-connection-over-websocket-videochat-with-javascript-step-2-f78c307c4fd3">第二步:通过WebSocket建立连接</a></li><li id="45dc" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/establishing-the-webrtc-connection-videochat-with-javascript-step-3-48d4ae0e9ea4">第三步:建立WebRTC连接</a></li><li id="e105" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/find-your-contact-videochat-with-javascript-step-4-4d527576b8cf">第四步:找到你的联系人</a></li><li id="3b57" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/share-your-screen-with-webrtc-video-call-with-webrtc-step-5-b3d7890c8747">第五步:分享你的屏幕</a></li></ul><p id="802c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我们已经能够在两个用户之间创建视频聊天，其中他们也可以共享他们的屏幕。我们现在希望允许用户通过连接共享文件。</p><p id="77bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里假设您已经能够在对等体之间建立WebRTC连接。如果没有，可以按照<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/establishing-the-webrtc-connection-videochat-with-javascript-step-3-48d4ae0e9ea4">第三篇</a>的步骤。</p><h2 id="1330" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">创建数据通道</h2><p id="ad73" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">一旦连接建立，WebRTC允许我们在对等体之间创建一些网络通道。这些通道可用于传输任何类型的数据。<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel" rel="noopener ugc nofollow" target="_blank">rtcdata channel</a>JavaScript接口代表了它们。</p><p id="d357" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样的通道是通过调用peerConnection对象的函数<em class="mq"> createDataChannel </em>创建的。如果一方创建了一个通道，另一方必须实现<em class="mq"> ondatachannel </em>事件处理程序来与之交互。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2cd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个例子，我们在对等连接上实现了<em class="mq"> ondatachannel </em>事件处理程序。当收到消息时，我们将它记录在控制台中，并回答“嗨，回来！”。</p><p id="4e90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了自己测试，您可以创建一个id为<em class="mq"> say-hello-button的按钮(不管在哪里，只是为了测试)。</em>点击此按钮，创建一个名为“测试通道”(通道必须有名称)的数据通道，它立即发送“Hello！”给它的同伴。</p><p id="17b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在两个选项卡中打开您的应用程序，并在建立WebRTC连接后，单击一个选项卡中的按钮。在第二个选项卡的控制台中，您现在应该看到“Hello！”。在你点击按钮的标签页中，你应该看到“嗨，回来！”。我们已经通过数据通道进行了交流。</p><h1 id="53ec" class="mx lt it bd lu my mz na lx nb nc nd ma ne nf ng md nh ni nj mg nk nl nm mj nn bi translated">传输文件</h1><p id="9328" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们希望使用数据通道在共享连接的两个对等体之间传输文件，文件可能很大。</p><h2 id="d801" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">阅读文件</h2><p id="aee3" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在能够向对等方发送文件之前，第一步是在浏览器中加载文件。我们将使用一个标准的<em class="mq">输入</em>元素来实现。</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="0855" class="ls lt it np b gy nt nu l nv nw">&lt;input type="file"&gt;</span></pre><p id="84ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您正在阅读本系列，让我们从上一篇文章停止的地方继续。如果没有，只要您有办法建立WebRTC连接并从JavaScript访问文件，您就可以跳过下面的内容，直接跳到“发送文件”部分。</p><p id="df93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户首先需要输入代码来开始与对等方(具有相同的代码)的视频呼叫。建立连接后，界面如下所示:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/0c562f2446bca789bbcad30bd64e3a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNN6dLQaL3EdK3skH2-UsQ.png"/></div></div></figure><p id="fe9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在左上角，用户看到自己，在中间的大视频元素中看到他的联系人。目前只有一个按钮共享屏幕的工具栏位于远程视频的底部，只有悬停时才可见。</p><p id="26be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先添加一个共享文件的按钮:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/8a8df1489bd2ea93c9713f6be7c2bc59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8qU8RSv8iAURBzTtHKbcg.png"/></div></div></figure><p id="fec8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">点击此按钮时，要求用户选择一个文件:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/23d9595d203664ffc8940ddce1593bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWTCNX_V-X_rU61T2PMHqw.png"/></div></div></figure><p id="a9fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个手工制作的对话框。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d045" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于有点长的CSS，请查看Github <a class="ae kf" href="https://github.com/Dornhoth/VideoChatWebRTC.git" rel="noopener ugc nofollow" target="_blank">库</a>。</p><p id="4c20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦用户选择了一个文件,“确定”按钮被激活。当用户点击它时，文件被存储在全局变量<em class="mq">文件</em>中，我们可以通过数据通道发送这个文件。</p><h2 id="8489" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">发送文件</h2><p id="fc63" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们首先需要创建数据通道:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b503" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们可以为一个对等连接创建许多数据通道，所以我们必须给它一个标签。我们取文件名。我们不是通过信道打招呼，而是发送文件:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0907" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通道中默认的预期二进制类型是Blob，但Google Chrome不支持，所以在内部将binary type设置为“arraybuffer”。另一方面，Firefox支持blob，因此需要blob。为了在两种浏览器中都能工作，我们还需要将通道的二进制类型声明为“arraybuffer ”,并将Blob转换为数组缓冲区。</p><p id="10df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在连接的另一端，我们也声明了binaryType。当我们收到这些字节时，我们再次将它们做成一个Blob，下载它并关闭数据通道。(如果你不知道Blobs是什么，查看<a class="ae kf" href="https://codeburst.io/javascript-interview-question-what-is-a-blob-f54482317e7f" rel="noopener" target="_blank">这篇文章</a>)。当数据通道关闭时，发送方关闭文件选择对话框。</p><p id="17df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了测试这一点，我创建了一个包含两行文本的小文件，并通过信道发送出去。我在Chrome中的自己和Firefox中的自己之间创建了一个连接，并将文件从第一个浏览器发送到第二个浏览器。不出所料，Firefox收到了文件，并请求我允许下载它:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/acce0fd40d384e2794e43c9ada0ba59c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEDT6tiymVOTNi7rpxA9Jw.png"/></div></div></figure><p id="cf4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将文件从Firefox发送回Google Chrome也不成问题。然后，我尝试使用一个更大的文件，一个500 kB的图像。从Firefox到Chrome，我在试图通过通道发送字节数组时出错，对话框没有关闭(意味着文件没有到达另一端)。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/50f88abdb7a30d2273e2b98a6a2c125b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmmPN7RYi81qi-sBgUv9dA.png"/></div></div></figure><p id="70e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">反过来，从Chrome到Firefox，对话框关闭了，但什么也没发生。图像未发送。</p><h1 id="6f0e" class="mx lt it bd lu my mz na lx nb nc nd ma ne nf ng md nh ni nj mg nk nl nm mj nn bi translated">大文件问题</h1><p id="2f67" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">文件传输适用于小文件，但不适用于大文件。你可以尝试不同的文件，在Firefox和Google Chrome之间，什么可以，什么不可以的界限应该是256kiB(大约260kB)。为什么？</p><h2 id="f5e7" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">SCTP</h2><p id="b663" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">您可能想知道哪个传输层协议位于WebRTC数据通道之下。如果是TCP，我们会有一个可靠的传输，数据包肯定会以正确的顺序到达，但我们会为此付出延迟的代价。如果是UDP，我们会有更快的传输，但我们需要确保我们的数据包到达，我们必须重新排序。对于一些转会，你可能更喜欢一种选择，对于一些其他的选择。指定WebRTC协议的人不想一劳永逸地替你做决定，所以他们选择了一个替代方案:SCTP(流控制传输协议)。</p><p id="07dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SCTP是一个很老的协议(2000年)，你可能没听说过，因为在WebRTC之前它用得不多。为什么用这个？</p><p id="1444" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为它是可配置的。在创建数据通道时，您可以决定是否需要可靠的通道。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/264eab27beceea6d2e097c4ff402e942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Gwk0J4j08AwNsLIuT8YPg.png"/></div></div></figure><h2 id="80bc" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">最大缓冲区大小</h2><p id="6366" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">Chromium和Firefox使用相同的协议实现，<em class="mq"> usrsctp </em>。在这个实现中，默认的最大缓冲区是256kiB。当你通过数据通道发送一个小于256kiB的文件时，Firefox和Chromium会将消息分成小块发送。对于超过这个限制的文件，块不再适合缓冲区，并且<em class="mq"> usrsctp </em>抛出一个EMSGSIZE错误，这使得浏览器关闭通道。</p><p id="a2bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Chromium和Firefox允许你发送高达256kiB的消息(Firefox到Firefox甚至可以发送高达1gb的消息),但不是所有其他浏览器。一般来说，浏览器间的限制是棘手的，而且不断变化。为了安全起见，我们应该自己拆分数据包，然后一个接一个地发送。</p><h2 id="c85c" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">发送块</h2><p id="ba6f" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们将保持我们的消息小:64kb(65535字节)。</p><p id="f74f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先使用Blob方法<em class="mq"> arrayBuffer将文件转换成数组缓冲区。然后，我们一个接一个地发送数据块，直到整个文件都发送完毕。最后，我们发送“文件结束”消息。</em></p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0023" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在通道的另一端，我们创建一个数组，当数据块(数组缓冲区)到来时，我们将在其中存储它们。当我们收到一个消息时，只要它不是“文件结束”消息，那么它一定还是我们文件的一个块，所以我们把它添加到我们的块数组中。一旦我们收到“文件结束”消息，我们就可以把我们的块放在一个大的数组缓冲区中。我们将这个数组缓冲区转换成一个Blob，并下载这个Blob。最后，我们关闭通道。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0b4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要做到这一点，所有的数据块都必须到达，并且顺序正确。这是数据通道的默认行为。如果您不需要如此昂贵的选项，您可以在创建数据通道时将选项<em class="mq">命令</em>设置为<em class="mq">假</em>。有关选项的完整列表，请查看<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createDataChannel" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="4ee8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户现在可以通过WebRTC连接交换任意大小的文件。这种文件传输机制本身就是使用WebRTC的一个很好的理由。我们有可能直接在我们的同事之间安全快速地传输文件。你可以在这里找到全部代码(信令机制的客户端和websocket服务器)<a class="ae kf" href="https://github.com/Dornhoth/VideoChatWebRTC.git" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="335f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了保持示例简单，我们没有做任何错误处理。您可以通过向发送者添加一个加载栏和一个成功/错误消息来改进这个例子。另一个值得指出的是，这个例子只适用于Google Chrome和Mozilla Firefox。Safari不支持数据通道接口的事件处理程序o <em class="mq"> nclose </em>。</p><p id="3294" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以查看本系列中关于WebRTC的下一篇文章，在这篇文章中，我们将允许两个以上用户之间的连接。</p></div></div>    
</body>
</html>