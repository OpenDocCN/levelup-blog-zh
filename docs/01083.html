<html>
<head>
<title>Write better test cases with JUnit and Hamcrest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JUnit和Hamcrest编写更好的测试用例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/write-better-test-cases-with-junit-and-hamcrest-45a750a3b223?source=collection_archive---------4-----------------------#2019-11-07">https://levelup.gitconnected.com/write-better-test-cases-with-junit-and-hamcrest-45a750a3b223?source=collection_archive---------4-----------------------#2019-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="73b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JUnit是一个简单的开源框架，可以用Java编写可重复的测试用例。Hamcrest是一个以声明方式定义匹配器对象的框架。总之，它们允许我们编写强大、高效的单元测试用例。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/71d15dd8090a5a0e41d4c01049af26fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZhtCFidrT5-pQHw7Bzvdw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片提供:<a class="ae ky" href="https://www.pexels.com/photo/board-chalk-chalkboard-exam-459793/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/board-chalk-chalk board-exam-459793/</a></figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3e29" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">概观</h1><p id="eb3d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi mu translated">J  Unit和Hamcrest是两个灵活的单元测试框架，用Java编写干净高效的单元测试用例。JUnit是Java中事实上的单元测试框架，拥有开发人员编写单元测试所需的大部分必要工具。在JUnit之上，Hamcrest提供了一些非常强大的matcher对象来断言一个测试用例。在本文中，我们将深入JUnit和matcher对象，看看如何编写有效的测试。</p><h1 id="c5e8" class="lg lh it bd li lj nd ll lm ln ne lp lq jz nf ka ls kc ng kd lu kf nh kg lw lx bi translated">属国</h1><p id="721d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们将使用一个Apache Maven项目来演示这两个框架的用法。下面是带有依赖项的pom文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">pom.xml</figcaption></figure><p id="da5d" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">当前的JUnit版本是JUnit 5。然而，在本文中，我们将关注JUnit 4，因为这是使用最广泛的JUnit版本，并且有成千上万的测试套件在JUnit 4上运行。</p><h1 id="9b8b" class="lg lh it bd li lj nd ll lm ln ne lp lq jz nf ka ls kc ng kd lu kf nh kg lw lx bi translated">我们的第一个单元测试案例</h1><p id="ca07" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">下面是一个用JUnit编写的单元测试用例的例子。是的，就是这么简单:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b60d" class="nu lh it nq b gy nv nw l nx ny">@Test<br/><strong class="nq iu">public void </strong>testByteArrayEquals(){<br/>    <strong class="nq iu">byte</strong>[] actual = <strong class="nq iu">"junit"</strong>.getBytes();<br/>    <strong class="nq iu">byte</strong>[] expected = <strong class="nq iu">"junit"</strong>.getBytes();<br/>    <em class="nz">assertArrayEquals</em>(<strong class="nq iu">"bytes should be same"</strong>, expected, actual);<br/>}</span></pre><p id="1a38" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">为了更好地理解，我们来分解一下:</p><ol class=""><li id="ff91" class="oa ob it ma b mb nk me nl mh oc ml od mp oe mt of og oh oi bi translated">JUnit测试用例是用<code class="fe oj ok ol nq b">@Test</code> <strong class="ma iu"> </strong>注释来注释的。这个注释向JUnit表明，这个方法不是普通的方法，必须作为JUnit测试来执行。</li><li id="26d1" class="oa ob it ma b mb om me on mh oo ml op mp oq mt of og oh oi bi translated">接下来，我们有一组特定的语句。这些语句通常用于设置和调用我们正在测试的代码。</li><li id="804f" class="oa ob it ma b mb om me on mh oo ml op mp oq mt of og oh oi bi translated">最后，测试用例以断言语句结束。在我们的例子中，我们断言预期的和实际的结果。JUnit为断言提供了过多的断言类型。在本文的后面，我们将看到其中的一些。</li></ol><p id="f79f" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">附加说明:</p><ol class=""><li id="78e3" class="oa ob it ma b mb nk me nl mh oc ml od mp oe mt of og oh oi bi translated">JUnit测试用例总是有一个<code class="fe oj ok ol nq b">void</code> <strong class="ma iu"> </strong>返回类型。对你来说可能不是很有意义。在JUnit测试案例中，您正在对代码进行单元测试。您设置了前提条件，并调用了一段正在测试的代码。最后，用实际结果断言计算结果。因此，JUnit测试用例没有什么可返回的。此外，这些测试用例是由JUnit框架调用的，因此返回值无论如何都会被忽略。</li><li id="315c" class="oa ob it ma b mb om me on mh oo ml op mp oq mt of og oh oi bi translated">历史上，JUnit测试用例方法是从<code class="fe oj ok ol nq b">test</code> <strong class="ma iu"> </strong>关键字开始的。因此，您应该将测试用例命名为<code class="fe oj ok ol nq b">testGivenWhenThen</code> <strong class="ma iu"> </strong>格式的理想方式。这使得任何阅读你的代码的人都能理解测试用例是关于什么的</li></ol></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f9f8" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">使用断言</h1><p id="0617" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi mu translated"><span class="l mv mw mx bm my mz na nb nc di"> T </span> he心JUnit测试用例是我们如何<code class="fe oj ok ol nq b">assert</code> <strong class="ma iu"> </strong>预期的和实际的结果。因为这是几乎每个测试用例都会有的语句，所以JUnit提供了如此多不同的方法来断言不同的类型。这些断言方法中的大多数都出现在<code class="fe oj ok ol nq b">org.junit.Assert</code> <strong class="ma iu"> </strong>类中。</p><p id="98a1" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">所有的断言方法都是静态的，我们可以使用<code class="fe oj ok ol nq b">Assert.methodName()</code>来断言。我们还可以使用Java的静态导入机制来去掉Assert类前缀。</p><p id="4a2c" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">例如:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="ebaf" class="nu lh it nq b gy nv nw l nx ny"><em class="nz">Assert.assertArrayEquals</em>(<strong class="nq iu">"bytes should be same"</strong>, expected, actual);</span></pre><p id="330d" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">和</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9ac5" class="nu lh it nq b gy nv nw l nx ny"><em class="nz">assertArrayEquals</em>(<strong class="nq iu">"bytes should be same"</strong>, expected, actual);</span></pre><p id="d496" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">两者都一样。但是，第二个语句更清晰，更容易阅读。</p><h2 id="6bcb" class="nu lh it bd li or os dn lm ot ou dp lq mh ov ow ls ml ox oy lu mp oz pa lw pb bi translated">断言的类型</h2><p id="a3b4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><strong class="ma iu">断言整数数组相等</strong></p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="fd07" class="nu lh it nq b gy nv nw l nx ny">@Test<br/><strong class="nq iu">public void </strong>testIntArrayEquals(){<br/>    <strong class="nq iu">int</strong>[] actual = {1,2,3};<br/>    <strong class="nq iu">int</strong>[] expected = {1,2,3};<br/>    <em class="nz">assertArrayEquals</em>(<strong class="nq iu">"Ints should be same"</strong>, expected, actual);<br/>}</span></pre><p id="f0d4" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">上述方法确保两个数组相等。对于这个断言，我们使用了<code class="fe oj ok ol nq b">assertArrayEquals</code> <em class="nz"> </em>。</p><p id="eea4" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated"><strong class="ma iu">断言一个对象不为空</strong></p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="e0eb" class="nu lh it nq b gy nv nw l nx ny">@Test<br/><strong class="nq iu">public void </strong>testAssertNotNull(){<br/>    <em class="nz">assertNotNull</em>(<strong class="nq iu">"Should not be null"</strong>, <strong class="nq iu">new </strong>String());<br/>}</span></pre><p id="603a" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">我们用<code class="fe oj ok ol nq b">assertNotNull</code> <em class="nz"> </em>来断言一个对象不为空。</p><p id="9ebe" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">同理，我们还有其他的断言方法，比如<code class="fe oj ok ol nq b">assertEquals</code> <em class="nz">、</em> <code class="fe oj ok ol nq b">assertTrue</code> <em class="nz">、</em> <code class="fe oj ok ol nq b">assertFalse</code> <em class="nz">、</em> <code class="fe oj ok ol nq b">assertSame</code> <em class="nz">、</em>等等。</p><h2 id="bf6d" class="nu lh it bd li or os dn lm ot ou dp lq mh ov ow ls ml ox oy lu mp oz pa lw pb bi translated"><strong class="ak">使用Hamcrest匹配器</strong></h2><p id="eb18" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Hamcrest提供了一些非常强大的匹配器类型来定义我们的断言。我们使用<code class="fe oj ok ol nq b">assertThat</code> <em class="nz"> </em>断言方法来使用Hamcrest匹配器。该方法的语法如下:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b3f9" class="nu lh it nq b gy nv nw l nx ny">assertThat(T actual, Matcher&lt;? <strong class="nq iu">super </strong>T&gt; matcher)<br/>assertThat(String reason, T actual, Matcher&lt;? <strong class="nq iu">super </strong>T&gt; matcher)</span></pre><p id="fdde" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">Hamcrest匹配器可以在<code class="fe oj ok ol nq b">org.hamcrest.CoreMatchers</code>类中找到。以下是匹配器的几个例子。</p><p id="1e3b" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">使用<code class="fe oj ok ol nq b">is</code> <strong class="ma iu"> <em class="nz"> </em> </strong>匹配器:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9e21" class="nu lh it nq b gy nv nw l nx ny"><strong class="nq iu">import static </strong>org.junit.Assert.<em class="nz">assertThat</em>;<br/><strong class="nq iu">import static </strong>org.hamcrest.CoreMatchers.<em class="nz">is</em>;</span><span id="6d57" class="nu lh it nq b gy pc nw l nx ny">@Test<br/><strong class="nq iu">public void </strong>testAddition(){<br/>    <em class="nz">assertThat</em>(<strong class="nq iu">"Sum is not correct"</strong>, 2+2, <em class="nz">is</em>(4));<br/>}</span></pre><p id="9992" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">在上面的例子中，我们使用了<code class="fe oj ok ol nq b">is</code>匹配器。这个测试用例非常简单，非常容易阅读。听起来更像英语句子。</p><p id="b3d8" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">以下是更多Hamcrest匹配器的示例:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="2298" class="nu lh it nq b gy nv nw l nx ny">@Test<br/><strong class="nq iu">public void </strong>coreHamcrestMathers(){<br/>    <em class="nz">assertThat</em>(<strong class="nq iu">"good"</strong>, <em class="nz">allOf</em>(<em class="nz">equalTo</em>(<strong class="nq iu">"good"</strong>), <em class="nz">startsWith</em>(<strong class="nq iu">"go"</strong>), <em class="nz">is</em>(<strong class="nq iu">"good"</strong>)));<br/>    <em class="nz">assertThat</em>(<strong class="nq iu">"good"</strong>, <em class="nz">not</em>(<em class="nz">allOf</em>(<em class="nz">equalTo</em>(<strong class="nq iu">"bad"</strong>), <em class="nz">startsWith</em>(<strong class="nq iu">"k"</strong>), <em class="nz">is</em>(<strong class="nq iu">"bad"</strong>))));<br/><br/>    <em class="nz">assertThat</em>(<strong class="nq iu">"bad"</strong>, <em class="nz">anyOf</em>(<em class="nz">equalTo</em>(<strong class="nq iu">"excellent"</strong>), <em class="nz">equalTo</em>(<strong class="nq iu">"bad"</strong>)));<br/>    <em class="nz">assertThat</em>(7, <em class="nz">not</em>(<em class="nz">either</em>(<em class="nz">equalTo</em>(3)).or(<em class="nz">equalTo</em>(4))));<br/>}</span></pre><p id="bd83" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">匹配器比其他断言方法更容易阅读。例如，第一条语句读作:</p><blockquote class="pd pe pf"><p id="dea5" class="ly lz nz ma b mb nk ju md me nl jx mg pg nm mj mk ph nn mn mo pi no mr ms mt im bi translated">断言“好”等于“好”的一切，并从“去”开始</p></blockquote><p id="7611" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">在新的测试用例中，由于更好的可读性，建议使用<code class="fe oj ok ol nq b">assertThat</code> <strong class="ma iu"> </strong>代替旧的<code class="fe oj ok ol nq b">assert*</code>方法。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8391" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">包扎</h1><p id="1c36" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi mu translated">在本文中，我们介绍了如何用Hamcrest编写JUnit测试用例。这两个框架提供了无数其他有用的特性来编写高效的测试用例。要了解更多，请参考个人文档页面<a class="ae ky" href="https://junit.org/junit4/" rel="noopener ugc nofollow" target="_blank">这里</a> (JUnit)和<a class="ae ky" href="http://hamcrest.org/JavaHamcrest/index" rel="noopener ugc nofollow" target="_blank">这里</a> (Hamcrest)。</p></div></div>    
</body>
</html>