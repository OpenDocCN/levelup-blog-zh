<html>
<head>
<title>Simplify exporting and importing of your JavaScript utility functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化JavaScript实用函数的导出和导入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simplify-exporting-and-importing-of-your-javascript-utility-functions-2bfcb436c2d9?source=collection_archive---------2-----------------------#2022-04-01">https://levelup.gitconnected.com/simplify-exporting-and-importing-of-your-javascript-utility-functions-2bfcb436c2d9?source=collection_archive---------2-----------------------#2022-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ff924876937d240a919b7a51aeb77b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X063JrXWBpFm_puv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">布雷特·乔丹在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4491" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个“好”的开发者，你知道不要在你的项目中重复代码。为了做到这一点，我通常会创建可以在整个项目中轻松调用的实用函数。</p><p id="07dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文解释了我如何构建我的实用函数，以便新函数可以立即使用，而不需要执行额外的导出/导入步骤。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="7f2f" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">“旧”方法</h1><p id="8eb8" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">假设我需要处理一些日期操作。为此，我将创建一个<code class="fe ml mm mn mo b">src/utils/dates.js</code>文件:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="6bfd" class="mx lj iq mo b gy my mz l na nb">exports.startOfDay = (dt) =&gt; {  <br/>  dt = dt ? new Date(dt) : new Date()  <br/>  return dt.setHours(0,0,0,0) <br/>}</span></pre><p id="309a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这种模式，我放在这个文件中的每个函数都将被单独导出。现在我想从一个导入中获得所有的功能。我通过创建一个<code class="fe ml mm mn mo b">src/utils/index.js</code>文件来做到这一点:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="8012" class="mx lj iq mo b gy my mz l na nb">const { startOfDay } = require('./dates')</span><span id="bb2b" class="mx lj iq mo b gy nc mz l na nb">module.exports = function useUtils() {  <br/>  return { startOfDay } <br/>}</span></pre><p id="6753" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种模式的问题是，每次在我的dates文件中添加或删除函数时，我都需要更新索引文件。</p><p id="b02b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看一个更好的方法，也是我今天使用的方法。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c564" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">“新”方法</h1><p id="ac31" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">唯一需要更改的是我们的索引文件:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="947a" class="mx lj iq mo b gy my mz l na nb">const dates = require('./dates')<br/>  <br/>module.exports = function useUtils() {  <br/>  return { ...dates }<br/>}</span></pre><p id="c8e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">区别在于两个部分。首先，我们正在导入<code class="fe ml mm mn mo b">dates</code>，而不是使用“对象析构”来指定每个函数。<code class="fe ml mm mn mo b">dates</code>变量是一个包含日期文件中所有函数的对象。</p><p id="4828" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，在导出中，我们创建了一个新函数，<code class="fe ml mm mn mo b">useUtils()</code>，它使用一个扩展操作符返回<code class="fe ml mm mn mo b">dates</code>中的每个函数。这才是真正的神奇！这确保了在<code class="fe ml mm mn mo b">dates</code>对象中找到的每个函数都被单独导出。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c078" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用</h1><p id="8552" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在让我们看看如何使用我们的效用函数。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="76e1" class="mx lj iq mo b gy my mz l na nb">const useUtils = require('src/utils')</span><span id="76fe" class="mx lj iq mo b gy nc mz l na nb">const util = useUtils()</span><span id="c5d5" class="mx lj iq mo b gy nc mz l na nb">const startOfDay = util.startOfDay('2022-3-1 09:09:00')<br/>console.log(startOfDay) // (1646114400000)</span></pre><p id="0eec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的进口是<code class="fe ml mm mn mo b">useUtils</code>。为了简化使用，我们将其赋给变量<code class="fe ml mm mn mo b">util</code>。现在我们可以使用<code class="fe ml mm mn mo b">util</code>变量访问所有函数。比如我们可以叫<code class="fe ml mm mn mo b">util.startOfDay()</code>。</p><p id="3e66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，假设我们想在日期文件中添加另一个与日期相关的函数:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="5e0c" class="mx lj iq mo b gy my mz l na nb">// Existing function<br/>exports.startOfDay = (dt) =&gt; {  <br/>  dt = dt ? new Date(dt) : new Date()  <br/>  return dt.setHours(0,0,0,0) <br/>}</span><span id="6afc" class="mx lj iq mo b gy nc mz l na nb">// New function<br/>exports.endOfDay = (dt) =&gt; {  <br/>  dt = dt ? new Date(dt) : new Date()  <br/>  return dt.setHours(23,59,59,999) <br/>}</span></pre><p id="3c06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的新功能<code class="fe ml mm mn mo b">endOfDay()</code>立即可用。让我们使用它！</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="27a3" class="mx lj iq mo b gy my mz l na nb">const useUtils = require('src/utils')</span><span id="b27a" class="mx lj iq mo b gy nc mz l na nb">const util = useUtils()</span><span id="3db6" class="mx lj iq mo b gy nc mz l na nb">const startOfDay = util.startOfDay('2022-3-1 09:09:00')<br/>console.log(startOfDay) // (1646114400000)</span><span id="6160" class="mx lj iq mo b gy nc mz l na nb">// New<br/>const endOfDay = util.endOfDay('2022-3-1 09:09:00')<br/>console.log(endOfDay) // 1646200799999</span></pre><p id="6827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们把这个概念更进一步。在我的项目中，我需要一些实用函数来处理不同的字符串场景。为此，我创建了一个新的实用程序文件<code class="fe ml mm mn mo b">src/utils/strings.js</code>:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="bb75" class="mx lj iq mo b gy my mz l na nb">exports.toCamelCase = (str) =&gt; <em class="nd">str.trim</em>()<em class="nd">.replace</em>(/[-_\s]+(.)?/g, (_, c) =&gt; (c ? <em class="nd">c.toUpperCase</em>() : ''))</span><span id="00f7" class="mx lj iq mo b gy nc mz l na nb">exports.toTitleCase = (str) =&gt; <em class="nd">str.replace</em>(/<em class="nd">^</em>(.)|\s+(.)/g, (c) =&gt; <em class="nd">c.toUpperCase</em>())</span></pre><p id="d7fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这是一个新文件，我需要将它包含在实用程序索引文件中:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="cdcd" class="mx lj iq mo b gy my mz l na nb">const dates = require('./dates')<br/>const strings = require('./strings')<br/>  <br/>module.exports = function useUtils() {  <br/>  return { ...dates, ...strings }<br/>}</span></pre><p id="c312" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我只需要接触索引文件这一次。现在，我添加到字符串文件中的任何新函数都将自动包含在内。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="c382" class="mx lj iq mo b gy my mz l na nb">const useUtils = require('src/utils')</span><span id="f2cd" class="mx lj iq mo b gy nc mz l na nb">const util = useUtils()</span><span id="164f" class="mx lj iq mo b gy nc mz l na nb">const startOfDay = util.startOfDay('2022-3-1 09:09:00')<br/>console.log(startOfDay) // (1646114400000)</span><span id="0052" class="mx lj iq mo b gy nc mz l na nb">const endOfDay = util.endOfDay('2022-3-1 09:09:00')<br/>console.log(endOfDay) // 1646200799999</span><span id="75bd" class="mx lj iq mo b gy nc mz l na nb">const toCamel = util.toCamelCase('this_is_not_camel_case')<br/>console.log(toCamel) // thisIsNotCamelCase</span><span id="81b5" class="mx lj iq mo b gy nc mz l na nb">const toTitle = util.toTitleCase('troy moreland')<br/>console.log(toTitle) // Troy Moreland</span></pre><p id="78ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码示例都在使用CommonJS语法(例如Node.js)。这里有一种使用ES6语法(例如Vue/React)实现相同功能的方法。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="b139" class="mx lj iq mo b gy my mz l na nb">// src/utils/dates.js</span><span id="9095" class="mx lj iq mo b gy nc mz l na nb">export const startOfDay = (dt) =&gt; {  <br/>  dt = dt ? new Date(dt) : new Date()  <br/>  return dt.setHours(0,0,0,0) <br/>}</span><span id="1b20" class="mx lj iq mo b gy nc mz l na nb">export const endOfDay = () =&gt; {...}</span><span id="b9c8" class="mx lj iq mo b gy nc mz l na nb">// src/utils/index.js</span><span id="5e77" class="mx lj iq mo b gy nc mz l na nb">import * as dates from './dates'</span><span id="9e3e" class="mx lj iq mo b gy nc mz l na nb">export default function useUtils() {<br/>  return { ...dates }<br/>}</span><span id="d371" class="mx lj iq mo b gy nc mz l na nb">// src/some-other-file.js</span><span id="0e32" class="mx lj iq mo b gy nc mz l na nb">import useUtils from 'src/utils'</span><span id="d6f6" class="mx lj iq mo b gy nc mz l na nb">const utils = useUtils()</span><span id="01b4" class="mx lj iq mo b gy nc mz l na nb">const startOfDay = util.startOfDay('2022-3-1 09:09:00')<br/>console.log(startOfDay) // (1646114400000)</span><span id="ec53" class="mx lj iq mo b gy nc mz l na nb">const endOfDay = util.endOfDay('2022-3-1 09:09:00')<br/>console.log(endOfDay) // 1646200799999</span><span id="c779" class="mx lj iq mo b gy nc mz l na nb">const toCamel = util.toCamelCase('this_is_not_camel_case')<br/>console.log(toCamel) // thisIsNotCamelCase</span><span id="50db" class="mx lj iq mo b gy nc mz l na nb">const toTitle = util.toTitleCase('troy moreland')<br/>console.log(toTitle) // Troy Moreland</span></pre><h1 id="44d7" class="li lj iq bd lk ll ne ln lo lp nf lr ls lt ng lv lw lx nh lz ma mb ni md me mf bi translated">结论</h1><p id="7b4b" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">为了消除代码重复，创建一些实用函数。这也有利于跨项目的可重用性。</p><p id="a423" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后使用演示的方法来最小化管理函数库的开销。只需添加和使用！</p><p id="617f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我知道这是不是一个有用的帖子！</p></div></div>    
</body>
</html>