<html>
<head>
<title>Using SOPS and git hooks to share secrets — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用sop和git挂钩共享秘密—第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-sops-and-git-hook-to-share-secrets-part-1-d1d4475a4b46?source=collection_archive---------8-----------------------#2020-03-16">https://levelup.gitconnected.com/using-sops-and-git-hook-to-share-secrets-part-1-d1d4475a4b46?source=collection_archive---------8-----------------------#2020-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="5f25" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">DevOps将一切都驱动到代码中(包括秘密)</h1><p id="9c6a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">DevOps是一个教义，而不是一个框架。如果你问10个人什么是DevOps，你会得到10个不同的答案。但是在这些答案中，自动化和作为代码的基础设施多少会是其中的一部分。由于有了可用的工具，我们现在可以将这些基础架构配置和手动部署命令交给计算机，并与每个人共享。然而，我们应该如何处理我们的秘密，比如访问密钥和密码？我们应该与我们的团队分享它们吗？我们应该把它们放在哪里？</p><h1 id="f13a" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">场景:共享部署配置</h1><p id="fb17" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">假设我正在使用AWS SAM开发一个无服务器应用程序。我创建了下面的<code class="fe lm ln lo lp b">Makefile</code>，这样我就可以用一个简单的<code class="fe lm ln lo lp b">make</code>命令来部署这个应用程序。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="7bad" class="ly jr it lp b gy lz ma l mb mc">deploy:<br/>    sam build<br/>    sam package --output-template packaged.yaml --s3-bucket $(BUCKET_NAME)<br/>    sam deploy--template-file packaged.yaml --stack-name $(STACK_NAME) --capabilities CAPABILITY_IAM</span></pre><p id="d6f2" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">我还创建了一个<code class="fe lm ln lo lp b">.env</code>文件来存储S3存储桶名和CloudFormation堆栈名</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="290b" class="ly jr it lp b gy lz ma l mb mc">export BUCKET_NAME=my-dummy-bucket<br/>export STACK_NAME=dummy-stack</span></pre><p id="ec63" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">为了让我的队友(或者明天的我)知道我用的是哪个桶和哪个CloudFormation栈，我必须在某个地方保存<code class="fe lm ln lo lp b">.env</code>。虽然这不是最高机密，但我不想让团队以外的人知道我使用的是哪种S3铲斗，或者我们的命名惯例是什么。因此，我不得不用另一种方式存储这个文件，而不是直接将它推送到存储库。</p><h2 id="7003" class="ly jr it bd js mi mj dn jw mk ml dp ka kz mm mn ke ld mo mp ki lh mq mr km ms bi translated">方法1:使用参数存储/秘密管理器</h2><p id="2f3f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这应该是最常用的方法。我们可以利用托管的参数存储或秘密管理器(例如AWS参数存储、秘密管理器/Azure Key Vault/<a class="ae mt" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank">hashi corp Vault</a>)，而不是将信息存储在文本文件中。</p><figure class="lq lr ls lt gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mu"><img src="../Images/aa896113b08078893f07ff1c860bd302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1I2jOkC9U_X07XidbPGU7w.jpeg"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">有许多秘密经理选项</figcaption></figure><p id="be22" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">比如，我可以把<code class="fe lm ln lo lp b">Makefile</code>改成这样:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="d443" class="ly jr it lp b gy lz ma l mb mc">BUCKET_NAME=$(shell aws ssm get-parameter --name BUCKET_NAME --query 'Parameter.Value' --output text)<br/>STACK_NAME=$(shell aws ssm get-parameter --name STACK_NAME --query 'Parameter.Value' --output text)</span><span id="b7ea" class="ly jr it lp b gy ng ma l mb mc">deploy:<br/>    sam build<br/>    sam package --output-template packaged.yaml --s3-bucket $(BUCKET_NAME)<br/>    sam deploy --template-file packaged.yaml --stack-name $(STACK_NAME) --capabilities CAPABILITY_IAM</span></pre><p id="5a06" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">现在我用awscli从AWS参数库中抓取<code class="fe lm ln lo lp b">BUCKET_NAME</code>和<code class="fe lm ln lo lp b">STACK_NAME</code>。我可以授予我的队友访问权限，这样他们就可以像我在我的电脑上一样运行<code class="fe lm ln lo lp b">make</code>命令。如果我的一个队友离开了公司，我可以简单地撤销他的访问权限，而不必担心在他的电脑上留下任何秘密。</p><p id="affd" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">然而，由于秘密保存在存储库之外，我们必须单独管理它们。我们如何跟踪哪些参数属于哪个项目？我们如何对这些参数进行版本控制？</p><p id="3712" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">很多参数存储支持版本化特性，但是管理两套版本树(代码库和参数存储)还是比较困难的。当问题出现时，我们必须匹配两个版本树的时间线，以获得状态变化的全貌。</p><figure class="lq lr ls lt gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nh"><img src="../Images/c07182c0e44974b318f8bbc22bb80d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzEiLJUJ9i6ZQA-HwG-_Ww.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">AWS参数存储支持版本控制</figcaption></figure><p id="4a8e" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">优点:<br/> 1。完全控制的秘密<br/> 2。本地计算机中没有明文副本</p><p id="fe62" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">缺点:<br/> 1。需要管理两套资源</p><h2 id="24aa" class="ly jr it bd js mi mj dn jw mk ml dp ka kz mm mn ke ld mo mp ki lh mq mr km ms bi translated">方法2:加密机密</h2><p id="2650" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了避免管理两个独立资源的开销，我们可以将秘密和代码放在同一个存储库中。但为了防止任何数据泄露，我们必须确保不把它们明文放在网上。</p><p id="2a5d" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">如果你在谷歌上搜索一些相关关键词，你可能会找到<a class="ae mt" href="https://git-secret.io/" rel="noopener ugc nofollow" target="_blank"> git-secret </a>。这是一个非常好的工具，它允许你使用GPG加密任何文件。基本上，您添加来自队友的GPG公钥，git-secret将使用它们来加密您指定的文件。</p><p id="cc8f" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">然而，git-secret假设开发人员应该有他们自己的GPG密钥对，但我认为在许多组织中情况并非如此。此外，因为它使用每个人的公钥来加密文件。当新成员加入时，你必须收集他们的公钥，并再次加密每个文件，以便他们可以解密。同样，如果有人离开团队，您必须删除他的公钥并重新加密所有文件，这样他就不能再访问了。</p><figure class="lq lr ls lt gt mv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/32e7bae369b42872d81569dee2af6259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*TapRiKb4lyyEvB8hK4tVeA.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">管理GPG群岛是另一个地狱</figcaption></figure><p id="be96" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">这种方法的另一个问题是推和拉代码的过程。开发人员可能会意外地以明文形式推送秘密。或者他们可能在修改后忘记加密和推送秘密。</p><p id="e130" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">优点:<br/> 1。你可以在1库<br/> 2集中管理项目的一切。易于开发，因为本地的所有内容都以明文显示</p><p id="ca4b" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">缺点:<br/> 1。管理密钥的开销<br/> 2。这使得推/拉过程变得复杂</p><h1 id="59a8" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">SOPS:使用中央密钥库加密</h1><p id="d7d0" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">经过一番研究，终于找到了Mozilla <a class="ae mt" href="https://github.com/mozilla/sops" rel="noopener ugc nofollow" target="_blank"> SOPS </a>。SOPS的原理类似于git-secret，它帮助您在将文件推送到存储库之前对文件进行加密。与众不同的是，除了GPG，它还支持许多不同的主要商店，如AWS KMS。使用sop，我们现在可以在代码库中保存秘密，同时集中控制访问。</p><p id="b907" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">我将带你了解我是如何在项目中整合sop的</p><h2 id="6259" class="ly jr it bd js mi mj dn jw mk ml dp ka kz mm mn ke ld mo mp ki lh mq mr km ms bi translated">第一步:安装标准操作程序</h2><p id="fc1b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">转到SOPS <a class="ae mt" href="https://github.com/mozilla/sops/releases" rel="noopener ugc nofollow" target="_blank">发布页面</a>并下载最新版本。它有Windows，macOS，Ubuntu/Debian(。deb)和CentOS(。rpm)版本。</p><h2 id="cd70" class="ly jr it bd js mi mj dn jw mk ml dp ka kz mm mn ke ld mo mp ki lh mq mr km ms bi translated">步骤2:配置IAM用户</h2><p id="ac61" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">SOPS需要我们的凭证来访问KMS密钥，我将为我的每个队友创建IAM用户(如果他们还没有),并在我的计算机中配置访问密钥</p><ol class=""><li id="81f6" class="nj nk it kq b kr md kv me kz nl ld nm lh nn ll no np nq nr bi translated"><a class="ae mt" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html" rel="noopener ugc nofollow" target="_blank">创建具有编程访问权限的IAM用户</a></li><li id="4f03" class="nj nk it kq b kr ns kv nt kz nu ld nv lh nw ll no np nq nr bi translated"><a class="ae mt" href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html" rel="noopener ugc nofollow" target="_blank">安装AWS CLI </a></li><li id="20fa" class="nj nk it kq b kr ns kv nt kz nu ld nv lh nw ll no np nq nr bi translated">运行<code class="fe lm ln lo lp b">aws configure</code>向AWS CLI提供IAM用户的访问密钥</li></ol><h2 id="b81e" class="ly jr it bd js mi mj dn jw mk ml dp ka kz mm mn ke ld mo mp ki lh mq mr km ms bi translated">步骤3:设置KMS自定义密钥</h2><p id="90cb" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们必须创建一个可以与所有队友共享的密钥，以便我们都可以使用它来加密/解密秘密。在我的情况下，我使用AWS KMS，你可以使用其他支持的关键商店。</p><ol class=""><li id="9a1e" class="nj nk it kq b kr md kv me kz nl ld nm lh nn ll no np nq nr bi translated">转到<a class="ae mt" href="https://console.aws.amazon.com/kms/home#/kms/keys" rel="noopener ugc nofollow" target="_blank">https://console.aws.amazon.com/kms/home#/kms/keys</a></li><li id="efd0" class="nj nk it kq b kr ns kv nt kz nu ld nv lh nw ll no np nq nr bi translated">点击“创建密钥”，保留所有默认设置</li><li id="ff0b" class="nj nk it kq b kr ns kv nt kz nu ld nv lh nw ll no np nq nr bi translated">给它一个别名，例如“我的sam项目加密密钥”</li><li id="3757" class="nj nk it kq b kr ns kv nt kz nu ld nv lh nw ll no np nq nr bi translated">定义谁将是密钥管理员(谁可以配置密钥)</li><li id="341a" class="nj nk it kq b kr ns kv nt kz nu ld nv lh nw ll no np nq nr bi translated">定义谁可以使用密钥(将使用密钥加密/解密机密的用户)</li><li id="eb6a" class="nj nk it kq b kr ns kv nt kz nu ld nv lh nw ll no np nq nr bi translated">复制密钥的ARN，我们稍后会用到它</li></ol><figure class="lq lr ls lt gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nx"><img src="../Images/4b8cf90fde8f5595fb0a56da8e256a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VxjEybPawBDrLntgiyO_UQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">选择将访问机密的用户</figcaption></figure><figure class="lq lr ls lt gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ny"><img src="../Images/413c171e197732d10e27fa9bed8dc4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wS5mwI6i_lYU8Irsz8HsOA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">复制KMS密钥ID以备后用</figcaption></figure><h2 id="e782" class="ly jr it bd js mi mj dn jw mk ml dp ka kz mm mn ke ld mo mp ki lh mq mr km ms bi translated">步骤4:配置sop</h2><p id="66b4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">sop使用<code class="fe lm ln lo lp b">.sops.yaml</code>文件来配置加密文件时使用的密钥。在我的项目中，我使用了以下配置:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="46c7" class="ly jr it lp b gy lz ma l mb mc">creation_rules:<br/>  - path_regex: \.env<br/>    kms: 'arn:aws:kms:us-east-1:xxxxxxxxxxxx:key/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'</span></pre><p id="bc5a" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">这个文件只是告诉SOPS使用我指定的KMS(我在上一步中复制的ARN)来加密<code class="fe lm ln lo lp b">.env</code>文件。如果有多个权限级别，可以在KMS创建多个关键字，并定义多个创建规则。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="8fee" class="ly jr it lp b gy lz ma l mb mc">creation_rules:<br/>  - path_regex: \.env$<br/>    kms: 'arn:aws:kms:us-east-1:xxxxxxxxxxxx:key/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'<br/>  - path_regex: \.prod\.env$<br/>    kms: 'arn:aws:kms:us-east-1:xxxxxxxxxxxx:key/yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy</span></pre><p id="6f90" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">这样，我可以确保<code class="fe lm ln lo lp b">.env</code>和<code class="fe lm ln lo lp b">.prod.env</code>将使用两个不同的密钥进行加密。这样我就可以确保开发团队成员不一定能够访问生产环境。</p><h2 id="d29e" class="ly jr it bd js mi mj dn jw mk ml dp ka kz mm mn ke ld mo mp ki lh mq mr km ms bi translated">步骤5:加密秘密</h2><p id="216b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在提交项目之前，我们可以运行<code class="fe lm ln lo lp b">sops -e --output .enc.env .env</code>这个命令将文件<code class="fe lm ln lo lp b">.env</code>加密成<code class="fe lm ln lo lp b">.enc.env</code>如果你有多个</p><p id="0753" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">加密后，我的<code class="fe lm ln lo lp b">.enc.env</code>看起来是这样的:</p><figure class="lq lr ls lt gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nz"><img src="../Images/e3acbbc72a0591bcb2d02863104ea32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLdVlPu9enXzfJka8q6hKg.png"/></div></div></figure><p id="7946" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">可以看到我的bucket名和CloudFormation栈名已经加密了。sop还为文件附加一些元数据，尤其是用于加密的密钥。</p><h2 id="b7b4" class="ly jr it bd js mi mj dn jw mk ml dp ka kz mm mn ke ld mo mp ki lh mq mr km ms bi translated">步骤6:将原始机密文件添加到。gitignore</h2><p id="135b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了防止开发人员意外地将明文秘密提交到存储库中，我们应该将它的文件名添加到<code class="fe lm ln lo lp b">.gitignore</code>中，这样git就不会跟踪它们。在我的例子中，我的<code class="fe lm ln lo lp b">.gitignore</code>应该是这样的:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="05a1" class="ly jr it lp b gy lz ma l mb mc"># Do not commit secret files<br/>.env</span></pre><h2 id="2058" class="ly jr it bd js mi mj dn jw mk ml dp ka kz mm mn ke ld mo mp ki lh mq mr km ms bi translated">步骤7:提取更新后解密机密</h2><p id="9e50" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们已经完成了加密部分，现在我的队友们必须在提取存储库后解密它。获取更新后，只需运行<code class="fe lm ln lo lp b">sops -d --output .env .enc.env</code>即可。如果我的队友正确配置了访问密钥，并且可以访问KMS密钥，那么它会将文件解密为原始的<code class="fe lm ln lo lp b">.env</code></p><h1 id="b6a8" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">下一步是什么？</h1><p id="fe82" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我们可以通过同一个存储库安全地与队友共享项目秘密。我们还可以集中管理谁可以通过AWS KMS访问这个秘密。然而，仍然存在人工进程(加密和解密文件),这在DevOps世界中并不是一个好的实践。在第二部分中，我们将讨论如何自动化这些过程。</p></div></div>    
</body>
</html>