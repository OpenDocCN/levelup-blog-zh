<html>
<head>
<title>Unit Testing in Python — Patching, Mocks and Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的单元测试——补丁、模拟和依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-testing-in-python-mocking-patching-and-dependency-injection-301280db2fed?source=collection_archive---------2-----------------------#2020-07-09">https://levelup.gitconnected.com/unit-testing-in-python-mocking-patching-and-dependency-injection-301280db2fed?source=collection_archive---------2-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ad4e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何测试代码中的困难部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/691a1c454a3183f76642b7ee2c6c0deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XdmfXa2AogI719K0diQQ0A.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.pexels.com/photo/woman-in-white-shirt-showing-frustration-3807738/" rel="noopener ugc nofollow" target="_blank">安德里亚·皮亚卡迪奥</a></figcaption></figure><p id="bac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Python和pytest进行单元测试通常是微不足道的，但是当许多开发人员不得不修补依赖关系以使代码可测试时，他们会感到沮丧。在本文中，您将学习如何修补和使用模拟。如果您想重温Python中单元测试的基础知识，请看一下本系列的第一部分:<a class="ae ky" href="https://medium.com/swlh/unit-testing-in-python-basics-21a9a57418a0#0e28" rel="noopener">Python中的单元测试—基础知识</a>。</p><h1 id="7bc5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题的抽象模式</h1><p id="c520" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们想要测试的函数的一个依赖项会以三种不同的方式产生影响:副作用、返回值或异常。</p><p id="9769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题1:依赖性副作用</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b1a4" class="mx lw it mt b gy my mz l na nb">def a_function():<br/>    ...  # Application code to be tested<br/>    a_dependency()<br/>    ...  # Application code to be tested</span></pre><p id="8993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题2:依赖项返回值</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bca1" class="mx lw it mt b gy my mz l na nb">def a_function():<br/>    ...  # Application code to be tested<br/>    foo = a_dependency()<br/>    ...  # Application code to be tested; it might use foo</span></pre><p id="87db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题3:依赖关系抛出异常</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="87e7" class="mx lw it mt b gy my mz l na nb">def a_function():<br/>    ...  # Application code to be tested<br/>    try:<br/>        foo = a_dependency()<br/>    except:<br/>        ...  # Application code to be tested<br/>        ...  # this might depend on the type of Exception<br/>   ...  # Application code to be tested</span></pre><h1 id="1a1d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题——简单的例子</h1><p id="e753" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">大多数例子都要复杂得多，通常还需要一些重构来使代码更容易维护。所以我创建了三个例子，它们更接近真实的应用程序，同时又避免了真实应用程序的膨胀。</p><p id="2686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例1:我们想向数据库添加一个用户。你可以看到<code class="fe nc nd ne mt b">db</code>没有返回任何东西，但是我们改变了系统的状态。我们希望确保在单元测试运行时，我们实际上没有改变我们的生产系统！</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="16b0" class="mx lw it mt b gy my mz l na nb">import bcrypt<br/>from models import db, User</span><span id="a8f3" class="mx lw it mt b gy nf mz l na nb">def insert_user_into_db(username, password):<br/>    password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(12))<br/>    user = User(password=password_hash, username=username)<br/>    db.session.add(user)<br/>    db.session.commit()</span></pre><p id="026d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例2:基于当前日期生成文件名。您可以看到依赖关系<code class="fe nc nd ne mt b">datetime</code>返回值:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ba12" class="mx lw it mt b gy my mz l na nb">import datetime</span><span id="7ab1" class="mx lw it mt b gy nf mz l na nb">def generate_filename():<br/>    return f"{datetime.datetime.now():%Y-%m-%d}.png"</span></pre><p id="fe1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，您可以想象一个函数，它返回英语句子中的天气，并使用API获得实际的天气(<a class="ae ky" href="https://gist.github.com/MartinThoma/5c7224ceae47e74645e0145d26dc03ec" rel="noopener ugc nofollow" target="_blank">示例</a>)。</p><p id="be5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例3:在我的项目<code class="fe nc nd ne mt b"><a class="ae ky" href="https://github.com/MartinThoma/edapy" rel="noopener ugc nofollow" target="_blank">edapy</a></code>中，我查看了PDF文件中的元数据。我使用依赖项PdfFileReader，并将文件本身作为依赖项。由于PDF文件可能会被破坏，PyPDF2可能会抛出异常。所以你可以想象这样的代码:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="654c" class="mx lw it mt b gy my mz l na nb">import PyPDF2.utils<br/>from PyPDF2 import PdfFileReader</span><span id="3a7d" class="mx lw it mt b gy nf mz l na nb">def get_pdf_info(pdf_path):<br/>    info = {}<br/>    try:<br/>        pdf_toread = PdfFileReader(fp, strict=False)<br/>    except PyPDF2.utils.PdfReadError:<br/>        info["is_errornous"] = True<br/>        return info</span><span id="784a" class="mx lw it mt b gy nf mz l na nb"># a lot more<br/>    return info</span></pre><p id="76b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你想测试这样的函数时，你会遇到这样的问题:期望的输出不仅依赖于函数本身，还依赖于外部的东西。在上面的例子中，系统时间、外部服务和文件系统。</p><h1 id="f43b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">外部依赖关系的示例</h1><p id="d3e2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您的测试可能有许多外部依赖:</p><ul class=""><li id="82a7" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">日期或时间</li><li id="b064" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">互联网:你需要使用的网络服务</li><li id="f31e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">文件系统:您需要创建/读取/编辑/删除的文件</li><li id="529b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">数据库:您选择/插入/更新/删除的数据</li><li id="07f7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">随机性:您的代码可能会使用<code class="fe nc nd ne mt b">random</code>或<code class="fe nc nd ne mt b">np.random</code></li></ul><p id="618a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像上面的例子一样，它们使得独立的单元测试变得困难甚至不可能。</p><h1 id="9df2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解决方案:打补丁！</h1><p id="d7f6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">测试这一点的总体策略总是相同的:用你能控制的东西来代替让你头疼的外部依赖。替换依赖的行为叫做<strong class="lb iu"> <em class="nu">打补丁</em> </strong>，替换的行为叫做<strong class="lb iu"> <em class="nu">嘲弄</em> </strong>。根据mock具体做什么，您可能还会听到它被称为Test Double、Test Stub、Test Spy或Fake Object。在Python的实践中，这种区别并不重要。如果你感兴趣，我推荐<a class="ae ky" href="https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs#TheDifferenceBetweenMocksAndStubs" rel="noopener ugc nofollow" target="_blank">马丁·福勒:《模仿和树桩的区别</a>。我会把它们都叫做嘲笑。</p><p id="bdfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个小例子，如何使用补丁！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c3e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您使用哪个<code class="fe nc nd ne mt b">transaction</code>，函数<code class="fe nc nd ne mt b">is_credit_card_fraud</code>都会抛出一个ValueError。</p><p id="2166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你如何用装饰者<code class="fe nc nd ne mt b">@patch</code>修补依赖性的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f13f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是如何用上下文处理程序(<code class="fe nc nd ne mt b">with ...</code>)修补依赖关系<code class="fe nc nd ne mt b">fraud_example.dark_magic</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您现在执行<code class="fe nc nd ne mt b">pytest</code>时，测试将会成功。你将总是得到0.999作为<code class="fe nc nd ne mt b">dark_magic</code>的返回值🎉</p><p id="94bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本例中可能令人惊讶的部分是<code class="fe nc nd ne mt b">patch</code>装饰器的第一个参数:它是<code class="fe nc nd ne mt b">"fraud_example.dark_magic"</code>而不是<code class="fe nc nd ne mt b">"external_dependency.dark_magic"</code>！替换的目标总是您想要测试的文件中加载的内容，而不是它是从哪里加载的。丽莎·罗奇在她的演讲<a class="ae ky" href="https://www.youtube.com/watch?v=ww1UsGZV8fQ" rel="noopener ugc nofollow" target="_blank">中优雅地指出了这一点，揭开了补丁功能的神秘面纱</a>。</p><h1 id="4013" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">直接替换:不要这样！</h1><p id="3750" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下面是一个不使用<code class="fe nc nd ne mt b">patch</code>的例子，看似可行，但有一个很大的缺陷。如果您直接替换<code class="fe nc nd ne mt b">datetime.datetime</code>而不是修补它，它将在之后的所有其他上下文中被覆盖！⚠️</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="50a3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模仿和魔术</h1><p id="37ef" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您现在知道了如何替换一个依赖项，因此是时候讨论用什么来替换它了。这就是<code class="fe nc nd ne mt b">unittest.mock.Mock</code>和<code class="fe nc nd ne mt b">unittest.mock.MagicMock</code>发挥作用的地方。</p><p id="d474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你用Mock做的所有事情都会返回一个Mock。调用函数？获取一个Mock作为返回值。访问属性？获取一个模拟值。</p><p id="d8c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python有所谓的“神奇”方法。我更喜欢术语“dunder”方法——它只是指所有以分数<strong class="lb iu">d</strong>double<strong class="lb iu">开始和结束的方法。例如<code class="fe nc nd ne mt b">__iter__</code>或<code class="fe nc nd ne mt b">__contains__</code>。MagicMock有这些定义，Mock没有。我会在任何地方使用MagicMock，除非被模仿的对象没有定义任何魔法函数。</strong></p><p id="04ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">mock类的一个核心特性是，它们不仅允许您删除难以测试的依赖项，还允许您断言与mock交互的方式。典型的方法有<a class="ae ky" href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_called" rel="noopener ugc nofollow" target="_blank"> assert_called </a>()，<a class="ae ky" href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_called_with" rel="noopener ugc nofollow" target="_blank"> assert_called_with </a>()，<a class="ae ky" href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_not_called" rel="noopener ugc nofollow" target="_blank"> assert_not_called </a>()。</p><h1 id="4edf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">规格，自动规格&amp;规格集</h1><p id="8c84" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe nc nd ne mt b">MagicMock</code>真正不好的一点是，你可以用它做任何事情——包括访问不存在的属性、调用不存在的方法或者用错误的参数个数调用现有的方法。模拟对象缺少一个T21规格。如果你不喜欢这样，在修补对象时使用<code class="fe nc nd ne mt b">autospec=True</code>:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5985" class="mx lw it mt b gy my mz l na nb">patch.object(Foo, 'foo', autospec=True)</span></pre><p id="5eb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者你可以创建一个这样的模拟:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="93e8" class="mx lw it mt b gy my mz l na nb">&gt;&gt;&gt; import datetime<br/>&gt;&gt;&gt; from unittest.mock import Mock<br/>&gt;&gt;&gt; a = Mock(spec=datetime)</span><span id="4ec2" class="mx lw it mt b gy nf mz l na nb"># Not Ok!<br/>&gt;&gt;&gt; a.foo<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>  File "/home/moose/.pyenv/versions/3.8.1/lib/python3.8/unittest/mock.py", line 635, in __getattr__<br/>    raise AttributeError("Mock object has no attribute %r" % name)<br/>AttributeError: Mock object has no attribute 'foo'</span><span id="26c3" class="mx lw it mt b gy nf mz l na nb"># That is ok:<br/>&gt;&gt;&gt; a.datetime<br/>&lt;Mock name='mock.datetime' id='139883597784544'&gt;</span></pre><p id="0b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne mt b">patch</code>的下一个参数是autospec。spec查看被模仿的对象，<code class="fe nc nd ne mt b">autospec</code>也查看该对象的属性(以及它们的属性和那些属性，…)。</p><p id="f0cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后还有<code class="fe nc nd ne mt b">spec_set</code>。这可以防止你设置不存在的属性。</p><p id="f5f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，我会在任何地方使用<code class="fe nc nd ne mt b">autospec=True</code>和<code class="fe nc nd ne mt b">spec_set=True</code>。使用自省的代码可能是一个你不想要的例子。</p><h1 id="d2cb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">猴子补丁</h1><p id="6885" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe nc nd ne mt b">monkeypatch</code>是pytest的夹具。我将在下一篇文章中解释什么是夹具。现在，只需接受它作为一个参数，您可以在不指定它的情况下将其赋予您的测试，pytest会处理它。你甚至不需要导入任何东西。</p><p id="06b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于信用卡欺诈的例子，它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ef88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，什么时候应该使用<code class="fe nc nd ne mt b">unittest.mock.patch</code>和——如果必要的话——<code class="fe nc nd ne mt b">unittest.mock.Mock</code>或者pytests <code class="fe nc nd ne mt b">monkeypatch</code>的问题可以归结为个人喜好。核心Python补丁/模仿只存在于Python 3.3之后，我想这是<code class="fe nc nd ne mt b">monkeypatch</code>存在的主要原因。</p><h1 id="9622" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">外部包装</h1><p id="915e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有几个软件包旨在简化修补，并为众所周知的依赖关系提供更好的模拟。</p><p id="c156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以使用<a class="ae ky" href="https://pypi.org/project/freezegun/" rel="noopener ugc nofollow" target="_blank">冷冻枪</a>来模拟系统时间:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c256" class="mx lw it mt b gy my mz l na nb">import freezegun<br/>from mock_example import generate_filename</span><span id="45bc" class="mx lw it mt b gy nf mz l na nb">def test_generate_filename():<br/>    with freeze_time("1990-04-28"):<br/>        assert generate_filename() == "1990-04-28"</span></pre><p id="6279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于boto3 / botocore (Cloud-stuff)，有<a class="ae ky" href="https://pypi.org/project/moto/" rel="noopener ugc nofollow" target="_blank"> moto </a>。</p><p id="9c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe nc nd ne mt b"><a class="ae ky" href="https://pypi.org/project/requests/" rel="noopener ugc nofollow" target="_blank">requests</a></code>，有<code class="fe nc nd ne mt b"><a class="ae ky" href="https://pypi.org/project/responses/" rel="noopener ugc nofollow" target="_blank">responses</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="45c3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">依赖注入</h1><p id="9629" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果以上听起来很复杂，还有一个更简单的选择:依赖注入。本质上是将外部状态明确地添加为一个参数，这使得在测试中容易调整。例如，上面的代码可能是:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a96b" class="mx lw it mt b gy my mz l na nb">import datetime</span><span id="f9c4" class="mx lw it mt b gy nf mz l na nb">def generate_filename(now=None):<br/>    if now is None:<br/>        now = datetime.datetime.now()<br/>    return f"{now:%Y-%m-%d}.png"</span></pre><p id="efcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在测试很简单:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2869" class="mx lw it mt b gy my mz l na nb">import datetime<br/>from mock_example import generate_filename</span><span id="f556" class="mx lw it mt b gy nf mz l na nb">def test_generate_filename():<br/>    now = datetime.datetime(1990, 4, 28)<br/>    assert generate_filename(now) == "1990-04-28.png"</span></pre><p id="10ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，应用这种模式感觉非常自然，而在其他情况下则不然。只有在感觉自然的时候才这样做。例如，我不太可能将模块作为参数传递，尽管这是可能的。那会感觉很奇怪。</p><h1 id="75d2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">临时文件:模拟是代码的味道吗？</h1><p id="482c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这很大程度上取决于细节，但我喜欢尽可能少地嘲讽。原因很简单，不嘲笑意味着你要测试更多的系统。严格地说，如果你测试了不止一个单元，你就不能再称这个测试为单元测试了。这将是一个整合测试，但这也是必不可少的，对不对？如果宝马卖给你一台发动机、一些座椅和一个方向盘，并声称“所有部件都能工作”，你不会高兴的。他们需要合作。大量的模拟可能会阻止您测试事物如何协同工作。</p><p id="204c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个理想的世界中，你将拥有两者:单元测试是非常可控的，并且在失败的情况下，可以很容易地缩小错误的来源。和集成/端到端测试，表明整个系统工作正常。</p><p id="9b3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也有人认为嘲笑的需求是重构需求的指示器(<a class="ae ky" href="https://github.com/pytest-dev/pytest/issues/4576#issuecomment-449865322" rel="noopener ugc nofollow" target="_blank">讨论</a>)。Harry Percival在PyCon 2020上发表了演讲<a class="ae ky" href="https://www.youtube.com/watch?v=rk-f3B-eMkI" rel="noopener ugc nofollow" target="_blank">停止使用模拟(一段时间)</a>，并指出使用模拟的测试代码往往很脆弱，因为它与实现细节紧密相关。</p><p id="9e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通常不嘲笑任何东西的一个好例子是文件系统交互。如果可能的话，我会像在实际应用程序中一样编写文件。当测试完成时，测试也需要清理。为此我使用了<code class="fe nc nd ne mt b"><a class="ae ky" href="https://docs.python.org/3/library/tempfile.html" rel="noopener ugc nofollow" target="_blank">tempfile</a></code>模块。</p><h1 id="48de" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">依赖注入:随机性</h1><p id="4a0e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">就像给默认使用当前时间的函数添加一个时间参数可能会让你的代码更容易测试一样，给使用随机性的函数添加一个<code class="fe nc nd ne mt b">random_state</code>参数或者一个<code class="fe nc nd ne mt b">seed</code>参数也会有所帮助。</p><p id="a458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是生成随机数生成器的一些方法:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="87a2" class="mx lw it mt b gy my mz l na nb">&gt;&gt;&gt; import random<br/>&gt;&gt;&gt; random.seed(0)<br/>&gt;&gt;&gt; random.random()<br/>0.8444218515250481</span><span id="214f" class="mx lw it mt b gy nf mz l na nb">&gt;&gt;&gt; import numpy as np<br/>&gt;&gt;&gt; np.random.seed(0)<br/>&gt;&gt;&gt; np.random.random()<br/>0.5488135039273248</span><span id="aa5e" class="mx lw it mt b gy nf mz l na nb">&gt;&gt;&gt; random_state = np.random.RandomState(seed=0)<br/>&gt;&gt;&gt; random_state.random()<br/>0.5488135039273248</span></pre><p id="a45d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置一个随机状态/种子对调试也很有帮助。如果你没有听说过海森堡或希格斯粒子，你就错过了一些编程术语。如果你对研究感兴趣，再现性很重要。</p><h1 id="c7f0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">术语</h1><ul class=""><li id="e106" class="ng nh it lb b lc mn lf mo li nx lm ny lq nz lu nl nm nn no bi translated"><strong class="lb iu">修补vs嘲讽</strong>:修补一个函数就是调整它的功能。在单元测试的上下文中，我们修补掉依赖关系；所以我们替换了依赖关系。嘲讽就是模仿。通常我们修补一个函数来使用我们控制的模拟，而不是我们不控制的依赖。</li><li id="5092" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">猴子补丁vs嘲讽</strong>:在开发环境中，嘲讽很明显是关于单元测试的(<a class="ae ky" href="https://stackoverflow.com/a/2666006/562769" rel="noopener ugc nofollow" target="_blank">例子</a>)。然而，除了单元测试之外，monkey patching还有几个应用。例如，如果缺少一小部分功能或部分代码被破坏，您可以在运行时修补第三方代码。你只要扩展代码。PyCharm调试器中使用了Monkey补丁(<a class="ae ky" href="https://youtu.be/ZpJxwpyJpq4?t=367" rel="noopener ugc nofollow" target="_blank">来源</a>)。</li><li id="93a9" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">Monkey patching vs pytest . Monkey patch</strong>:第一个是一般概念，第二个是pytest中的具体函数，它将Monkey patching应用于单元测试。</li><li id="9a76" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">unittest . mock . patch vs pytest . monkey patch</strong>:这是个人喜好。每当第三方选项没有太大优势时，我更喜欢坚持使用内置。在这种情况下，我甚至认为核心Python unittest.mock.patch更干净。由于这个原因，到目前为止我没有解释pytest.monkeypatch。如果你想知道其中的区别，有一篇关于它的不错的<a class="ae ky" href="https://krzysztofzuraw.com/blog/2016/mocks-monkeypatching-in-python.html" rel="noopener ugc nofollow" target="_blank">博文</a>。</li></ul><h1 id="f910" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关于建筑的一个注记</h1><p id="dc2c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了保持代码的整洁，包装第三方依赖项通常是个好主意。例如，你可以有一个处理I/O的模块，或者一个处理API请求的模块。然后你有几个模块可能需要很多嘲讽，或者单元测试是没有意义的，因为有趣的部分是与第三方的集成。您的代码的其余部分保持易于测试，保持您定义的语言，并关心您知道的对象。这被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Adapter_pattern" rel="noopener ugc nofollow" target="_blank">适配器模式</a>。</p><h1 id="f4f4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">还有什么？</h1><ul class=""><li id="0fe0" class="ng nh it lb b lc mn lf mo li nx lm ny lq nz lu nl nm nn no bi translated">其他类型的模拟，如<a class="ae ky" href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.PropertyMock" rel="noopener ugc nofollow" target="_blank"> PropertyMock </a>或</li><li id="8f74" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://pypi.org/project/pytest-mock/" rel="noopener ugc nofollow" target="_blank"> pytest-mock </a>，提供模拟夹具；虽然我不确定这主要是Python 3.3之前的遗留问题，还是它真的让事情变得更简单了。</li><li id="81a5" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第三方包<a class="ae ky" href="https://pypi.org/project/mock/" rel="noopener ugc nofollow" target="_blank">模仿</a>，不应该和Python 3.3+一起安装，因为它被放在了标准库中。</li></ul><p id="f044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于默认模拟的信息，可以看看耶尔雷·迪亚兹写的一篇很棒的文章:<a class="ae ky" href="https://medium.com/@yeraydiazdiaz/what-the-mock-cheatsheet-mocking-in-python-6a71db997832" rel="noopener">什么是模拟？Python中嘲讽的备忘单</a>。</p><h1 id="74a5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">下一步是什么？</h1><p id="83d7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这个系列中，我们已经有了:</p><ul class=""><li id="d9d4" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">第1部分:<a class="ae ky" href="https://medium.com/swlh/unit-testing-in-python-basics-21a9a57418a0" rel="noopener">Python中单元测试的基础知识</a></li><li id="3d83" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第2部分:<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/unit-testing-in-python-mocking-patching-and-dependency-injection-301280db2fed">补丁、模拟和依赖注入</a></li><li id="2a61" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第3部分:<a class="ae ky" href="https://medium.com/analytics-vidhya/how-to-test-flask-applications-aef12ae5181c" rel="noopener">如何用数据库、模板和受保护的页面测试Flask应用程序</a></li><li id="846f" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第4部分:<a class="ae ky" href="https://medium.com/python-in-plain-english/unit-testing-in-python-tox-and-nox-833e4bbce729" rel="noopener">毒性和氮氧化物</a></li><li id="c009" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第5部分:<a class="ae ky" href="https://medium.com/python-in-plain-english/unit-testing-in-python-structure-57acd51da923" rel="noopener">结构化单元测试</a></li><li id="5816" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第6部分:<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/ci-pipelines-for-python-projects-9ac2830d2e38">CI-管道</a></li><li id="e69d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第7部分:<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/unit-testing-in-python-property-based-testing-892a741fc119">基于属性的测试</a></li><li id="f1ac" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第八部分:<a class="ae ky" href="https://medium.com/analytics-vidhya/unit-testing-in-python-mutation-testing-7a70143180d8" rel="noopener">突变测试</a></li><li id="88cd" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第9部分:<a class="ae ky" href="https://towardsdatascience.com/static-code-analysis-for-python-bdce10b8d287" rel="noopener" target="_blank">静态代码分析</a> — Linters、类型检查和代码复杂性</li><li id="6beb" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第10部分:<a class="ae ky" href="https://towardsdatascience.com/pytest-plugins-to-love-%EF%B8%8F-9c71635fbe22" rel="noopener" target="_blank"> Pytest插件来爱</a></li></ul><p id="f65c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对使用Python测试的其他主题感兴趣，请告诉我。</p></div></div>    
</body>
</html>