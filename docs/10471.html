<html>
<head>
<title>A Case for gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC的一个案例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grpc-part-1-a-case-for-grpc-69592155cfbd?source=collection_archive---------9-----------------------#2021-12-10">https://levelup.gitconnected.com/grpc-part-1-a-case-for-grpc-69592155cfbd?source=collection_archive---------9-----------------------#2021-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7265090bb41ffe8fc946dae8bf152dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gswr-SizURu82yrC8RqlIQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图片由Renee French提供</figcaption></figure><h2 id="2ad2" class="jg jh ji bd b dl jj jk jl jm jn jo dk jp translated" aria-label="kicker paragraph">GRPC:第一部分</h2><div class=""/><div class=""><h2 id="645b" class="pw-subtitle-paragraph ko jr ji bd b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dk translated">gRPC将继续存在，这就是原因。</h2></div><p id="e4b3" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">从REST/HTTP 1.x到gRPC的服务间通信点的<em class="mc">进度方向箭头</em>，这是从Josh Wolfe借用的术语，我希望在本系列中向您展示为什么。以下大部分评测是由Kasun Indrasiri和Danesh Kuruppu编写的<em class="mc"> gRPC Up &amp; Running </em>的总结。您将会看到，gRPC克服了REST的许多缺点，并且通过对gRPC进行少量扩展，REST的一些优点也变得可用。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="3da1" class="mk ml ji bd mm mn mo mp mq mr ms mt mu kx mv ky mw la mx lb my ld mz le na nb bi translated">休息</h1><p id="a4ae" class="pw-post-body-paragraph lg lh ji li b lj nc ks ll lm nd kv lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">代表性状态转移(REST)是Roy Fielding博士论文提出的一组最佳实践。它是一种架构风格，提供了通过HTTP动词改变资源状态的最佳实践。例如，维护<strong class="li js">人员</strong>资源的服务通常会支持以下API来改变人员<strong class="li js">的状态。</strong></p><ul class=""><li id="5cf2" class="nh ni ji li b lj lk lm ln lp nj lt nk lx nl mb nm nn no np bi translated"><strong class="li js">岗位</strong>/人员<br/>/T33】创建一个新人</li><li id="9d38" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated"><strong class="li js"> PUT / </strong> person <br/> &gt;更新现有人员</li><li id="3697" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated"><strong class="li js">GET/</strong>person/:id<br/>&gt;检索人员</li><li id="6bab" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated"><strong class="li js">删除/ </strong>人员/:id <br/> &gt;删除一个人员</li></ul><h2 id="3444" class="nv ml ji bd mm nw nx dn mq ny nz dp mu lp oa ob mw lt oc od my lx oe of na jo bi translated">RESTful服务的优势</h2><ol class=""><li id="9f12" class="nh ni ji li b lj nc lm nd lp og lt oh lx oi mb oj nn no np bi translated">人类可读资源<br/>  RESTful服务在HTTP 1.x上运行，这需要发送文本消息。本质上，这种需求使得我们与RESTful服务交互变得很熟悉，因为我们可以直观地读写服务存储的资源数据。</li><li id="0ffe" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb oj nn no np bi translated"><strong class="li js">丰富的交互工具<br/></strong>HTTP 1 . x世界中的工具生态系统是多样的。比如你可以用cURL、Postman、失眠等与任何HTTP 1.x服务进行交互。</li><li id="a446" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb oj nn no np bi translated">RESTful服务不是强类型的，所以不需要单独的构建步骤来向客户端发布类型。</li></ol><h2 id="6c1c" class="nv ml ji bd mm nw nx dn mq ny nz dp mu lp oa ob mw lt oc od my lx oe of na jo bi translated">RESTful服务的缺点</h2><ol class=""><li id="bc24" class="nh ni ji li b lj nc lm nd lp og lt oh lx oi mb oj nn no np bi translated">低效的基于文本的消息协议HTTP 1.x服务，例如RESTful服务，需要在客户端和服务器之间发送人类可读的基于文本的消息。对于客户端和服务器之间的每个通信流，服务器必须将二进制转换为人类可读的文本，并发送给客户端，然后客户端必须将文本转换为二进制并继续。这个过程会降低性能。在微服务的世界里，通信流中没有人类。因此，不需要将数据转换为人类可读文本的额外步骤。任何坚持在服务间通信中使用人类可读文本来减轻人类工作的观点都应该用更好的工具来粉碎。</li><li id="6ad8" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb oj nn no np bi translated">缺乏强类型接口<br/>  RESTful服务可以通过Swagger之类的事后技术广播它们的服务定义。虽然这些技术允许人们阅读服务的模式并根据它进行开发，但它们没有与架构风格和消息协议紧密集成。由于松散耦合的客户机-服务器服务定义，客户机面临着运行时错误的风险。要回答这个问题，“<em class="mc">客户是否了解最新的服务？”<strong class="li js"> <em class="mc"> </em> </strong>变得极其困难。</em></li><li id="5e08" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb oj nn no np bi translated">REST仅仅是对最佳实践的一个建议。因此，维护RESTful服务很困难。许多原本打算成为RESTful的服务失去了对其结构的跟踪，变成了简单地通过HTTP 1.x发送文本消息的服务。</li></ol></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="bc55" class="mk ml ji bd mm mn mo mp mq mr ms mt mu kx mv ky mw la mx lb my ld mz le na nb bi translated">gRPC</h1><p id="cefb" class="pw-post-body-paragraph lg lh ji li b lj nc ks ll lm nd kv lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">2015年，Google发布了gRPC作为开源的远程过程调用(RPC)框架。这个项目被业界领袖网飞、Square、Lyft、Docker等采用。并加入了云原生计算基金会。gRPC旨在克服其前身的许多缺点，并且越来越受欢迎。</p><h2 id="cfd4" class="nv ml ji bd mm nw nx dn mq ny nz dp mu lp oa ob mw lt oc od my lx oe of na jo bi translated">gRPC的优势</h2><ol class=""><li id="a50d" class="nh ni ji li b lj nc lm nd lp og lt oh lx oi mb oj nn no np bi translated"><strong class="li js">高效的进程间通信<br/> </strong> gRPC以协议缓冲区的形式在客户端和服务器之间发送数据。整个协议缓冲区事务中的数据保持二进制形式，这消除了REST中文本消息转换的开销。此外，这些协议缓冲区是在比HTTP 1.x更快的HTTP/2之上发送的。协议缓冲区和HTTP/2的结合使gRPC成为传输数据最快的技术。</li><li id="676d" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb oj nn no np bi translated"><strong class="li js">有形成本节约<br/> </strong>随着容器、微服务的广泛采用以及应用程序在公共云中必须达到的运行规模，计算的经济性变得越来越重要。与HTTP1.x通信协议相比，gRPC在CPU级别上的<a class="ae ok" href="https://medium.com/@EmperorRXF/evaluating-performance-of-rest-vs-grpc-1b8bdf0b22da" rel="noopener">性能提升是非常明显的，可能会节省大量资金。仅此一点可能就足以让市场向gRPC靠拢。</a></li><li id="87cd" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb oj nn no np bi translated"><strong class="li js">界面优先构建<br/> </strong> gRPC要求界面优先的方法，没有如果和但是！</li><li id="7a86" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb oj nn no np bi translated">gRPC协议缓冲区需要一个强类型的服务定义。这些服务定义被版本化和编码。因此，运行时互操作性错误基本上被消除了。</li><li id="e8dc" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb oj nn no np bi translated">gRPC服务定义是语言不可知的，也就是说，一旦你定义了接口，你就可以利用自动代码生成工具以你选择的语言创建客户端和服务器gRPC代码。<a class="ae ok" href="https://www.cncf.io/case-studies/netflix/" rel="noopener ugc nofollow" target="_blank">网飞采用了gRPC </a>，将客户端构建时间从数周缩短至数秒，并且提高了一致性。</li></ol><h2 id="6f51" class="nv ml ji bd mm nw nx dn mq ny nz dp mu lp oa ob mw lt oc od my lx oe of na jo bi translated">gRPC的缺点</h2><ol class=""><li id="bfde" class="nh ni ji li b lj nc lm nd lp og lt oh lx oi mb oj nn no np bi translated"><strong class="li js">人类可读问题<br/> </strong>在实践中，会有一些客户因为许多不同的有效原因而无法与gRPC服务进行交互。此外，许多生产问题不是由计算机，而是由人来解决的。也就是说，重要的是人类可以与服务进行交互，而他们不能直接通过gRPC进行交互。像grpc-gateway这样的技术可以解决这个问题。</li><li id="b2cc" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb oj nn no np bi translated"><strong class="li js">一个小的(但正在增长的)生态系统<br/> </strong>随着时间的推移，gRPC生态系统将大幅增长。然而，如果你现在开发一个gRPC服务，你将会看到生态系统的实时发展。支持可能是有限的，Github问题很多。也就是说，gRPC经过了世界上最大的公司的大量测试，这表明如果你掌握了gRPC知识的基础，开发肯定是可行的。</li></ol></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="be4c" class="mk ml ji bd mm mn mo mp mq mr ms mt mu kx mv ky mw la mx lb my ld mz le na nb bi translated">摘要</h1><ul class=""><li id="55f4" class="nh ni ji li b lj nc lm nd lp og lt oh lx oi mb nm nn no np bi translated">REST是一种方便的、人类可读的服务间通信方法，这种方法已经变得过时和缓慢。</li><li id="d336" class="nh ni ji li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">gRPC是REST的后继者，它克服了REST的大部分缺点，并且稍加努力就保持了它的优点。</li></ul></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="1fae" class="mk ml ji bd mm mn mo mp mq mr ms mt mu kx mv ky mw la mx lb my ld mz le na nb bi translated">延伸阅读…</h1><p id="3b74" class="pw-post-body-paragraph lg lh ji li b lj nc ks ll lm nd kv lo lp ne lr ls lt nf lv lw lx ng lz ma mb im bi translated">本文是四篇系列文章中的第一篇，它将带您步入gRPC的正轨。点击下面的链接查看本系列的下一篇文章。</p><div class="is it gp gr iu ol"><a rel="noopener  ugc nofollow" target="_blank" href="/grpc-part-2-declaring-a-grpc-service-definition-df9ae0847e4c"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd js gy z fp oq fr fs or fu fw jr bi translated">声明gRPC服务定义</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">服务定义是gRPC开发的基础部分，所以让我们从正确的方面开始。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ja ol"/></div></div></a></div></div></div>    
</body>
</html>