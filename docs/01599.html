<html>
<head>
<title>React Redux and the Strategy Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应冗余与策略模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-redux-and-the-strategy-pattern-8019c0c5bb54?source=collection_archive---------6-----------------------#2020-01-15">https://levelup.gitconnected.com/react-redux-and-the-strategy-pattern-8019c0c5bb54?source=collection_archive---------6-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/df7d0ec231ae0a77ea177342322469f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHUKZRyBUcra9NssUAgUmw.jpeg"/></div></div></figure><p id="b8e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们在大多数Redux教程中看到构建Redux的例子时，通常我们会看到它们使用<code class="fe kz la lb lc b">switch</code>语句，每个动作类型一个<code class="fe kz la lb lc b">case</code>语句，就像这样:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">典型教程减压器</figcaption></figure><p id="dcb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然这相当简单，但也可能有点多，这取决于案例的数量和复杂性。</p><p id="3971" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，我们可以通过将逻辑提取到它自己的一组函数中来使它更具可读性，但是我们仍然从下面的案例列表开始:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">教程减压器，增强</figcaption></figure><h1 id="f1d1" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">从切换到策略</h1><p id="1e7f" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">这种变化可能会使每个案例的逻辑有一个相似的接口:</p><pre class="ld le lf lg gt mq lc mr ms aw mt bi"><span id="1eda" class="mu lo it lc b gy mv mw l mx my">(state, action) =&gt; state</span></pre><p id="73eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们会根据我们需要做的事情，从众多算法中选择一种来处理状态。我们选择的任何算法都有相同的签名，所以我们可以调用它，而不必知道它实际上做什么。这就是所谓的<a class="ae mz" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">战略模式</a>。</p><p id="bdba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在开创性的著作<em class="na">设计模式:可重用面向对象软件的元素中定义，</em>策略模式让我们以两种方式简化我们的reducers。首先，它让我们将变形金刚拉入地图，知道地图中的每个元素都以相同的方式调用。这张图向我们展示了我们的行动和它们的算法之间的一一对应关系:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">定义为策略的动作算法</figcaption></figure><p id="8b5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们没有用case语句玩缩进反弹游戏，而是有一个简单的键值对映射，在末尾有一个“默认”case，以防我们收到一个这个reducer不能处理的动作。(由于我们不关心默认情况下的动作，所以我懒得把它包含在签名里。对于更强类型的语言，如TypeScript，即使不使用，也可能需要它。)</p><p id="846e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二种简化更加明显。减速器本身现在变成这样:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">我们的减速器</figcaption></figure><p id="3d0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样。两条线。没有控制逻辑。一个快捷操作符，如果没有与动作类型相关联的转换器，它将为我们提供默认值。如果我们想牺牲可读性，我们可以把它变成一行，但是可读的代码是值得的。</p><p id="a097" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个地方的所有代码如下所示:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">瞧啊。</figcaption></figure><p id="8993" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Redux reducer中使用策略模式可以清晰地分离关注点:</p><ul class=""><li id="5286" class="nb nc it kd b ke kf ki kj km nd kq ne ku nf ky ng nh ni nj bi translated">动作类型显然与它们请求的状态改变相关联。</li><li id="9633" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">缩减器代码变得琐碎而容易被遗忘。</li><li id="fda1" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">各个特定于类型的更改被封装在它们自己的函数中，这些函数可以在任何地方定义，包括在复杂情况下从其他文件导入。</li></ul><h1 id="162e" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用策略创建减速器工厂</h1><p id="7929" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">我们可以更进一步。如果我们创建多个reducer来处理不同的状态片段，我们可以使用一个reducer工厂:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">我用实际的默认函数替换了__default__键，使它成为一行程序，不需要在提供的映射中定义默认值。可读性到此为止。称之为傲慢吧。</figcaption></figure><p id="6fab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的减速器代码变成了:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">棒极了。</figcaption></figure><p id="dda5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的样板文件现在只有一行。五个字。</p><p id="74bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其他的一切要么是将我们的动作类型映射到我们的变形金刚，要么是变形金刚本身。我们的reducers现在有一个一致的、可读的模式:一个映射、一行样板文件和算法本身。</p><h1 id="f880" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">最后的话</h1><p id="76d2" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">这就结束了我们从<code class="fe kz la lb lc b">switch</code>到战略的转换。希望这说明了使用一些老派设计模式使我们的代码更具可读性和可插入性的价值。</p><p id="29e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">说到“老派”，你可能已经注意到我比箭头符号更经常使用<code class="fe kz la lb lc b">function</code>符号。这在可读性方面有明显的优势，因为函数可以在它的作用域内随时被调用，<em class="na">甚至在它被定义之前。</em>箭头函数是表达式，在定义时计算，在定义前不能调用。</p><p id="5c74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过使用<code class="fe kz la lb lc b">function</code>符号，我可以用自顶向下的方式编写代码。首先出现的行为后面出现的行提供了上下文。如果我使用<code class="fe kz la lb lc b">const</code>来代替我的函数，我必须在我所有的变形金刚之后定义策略地图。它会被遗忘在页面的底部。相反，在被所有的变形金刚淹没之前，读者会看到给定的动作需要哪个变形金刚。</p><p id="a3a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！</p></div></div>    
</body>
</html>