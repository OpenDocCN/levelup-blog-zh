<html>
<head>
<title>Why Experienced Developers Still Use JIT and JVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么有经验的开发人员仍然使用JIT和JVM</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-experienced-developers-still-use-jit-and-jvm-706a2ba091bf?source=collection_archive---------4-----------------------#2022-08-11">https://levelup.gitconnected.com/why-experienced-developers-still-use-jit-and-jvm-706a2ba091bf?source=collection_archive---------4-----------------------#2022-08-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="8e77" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">为什么即使我们有AOT，JIT仍然是相关的，并且使你的构建更好的3个原因</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj kj"><img src="../Images/3d0cfc491f3e0f053d514eda97fd4edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lHm2JREtQw5oLN3O.jpeg"/></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated">照片由来自<a class="ae kv" href="https://www.pexels.com/photo/woman-in-orange-long-sleeve-shirt-standing-beside-woman-in-black-long-sleeve-shirt-5439487/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae kv" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>拍摄</figcaption></figure><p id="736c" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><em class="ls">JVM能在云环境中生存吗？JIT还有用吗？使用AOT时，我们可以改进哪些工具？如何降低JIT中的内存占用？</em></p><p id="c49f" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">一些开发人员发现JVM是一个额外的层。因为JVM是用来解释字节码的，而不是在容器中运行的。今天，我们有了其他编译成本地代码(Go)的选择。</p><p id="3073" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">让我们看看为什么JIT和JVM即使在今天的云环境中也会保持相关性。T9】</p><h1 id="b456" class="lt lu iu bd lv lw lx ly lz ma mb mc md ka me kb mf kd mg ke mh kg mi kh mj mk bi translated">为什么JIT编译的代码仍然有用？</h1><p id="2b38" class="pw-post-body-paragraph kw kx iu ky b kz ml jv lb lc mm jy le lf mn lh li lj mo ll lm ln mp lp lq lr in bi translated">大多数人会认为用JVM发布字节码和解释是一种浪费。</p><p id="e53d" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">您将增加内存占用，因为您需要JDK。此外，您在容器顶部添加了一个额外的层。如果部署本机代码，可以避免额外的一层。所有这些都让人们认为字节码没有用。</p><p id="1f93" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><strong class="ky iv"> <em class="ls">原生编译器在内存占用上胜出。</em> </strong>但在此期间，他们缺乏吞吐量。</p><p id="86ac" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><strong class="ky iv"> <em class="ls">尽管AOT编译的二进制代码在启动时速度更快，但在运行时它还是比不上JITted代码。</em>T19】</strong></p><p id="1ccf" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">为了解决这个问题，本机编译器增加了配置文件导向优化(<a class="ae kv" href="https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/native-image/PGO/" rel="noopener ugc nofollow" target="_blank"> PGO </a>)。即便如此，PGO也适用于企业GraalVM用户。</p></div><div class="ab cl mq mr hy ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="in io ip iq ir"><p id="51b0" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><strong class="ky iv"> <em class="ls">短命app——AOT。长寿— JIT。</em>T25】</strong></p><p id="da9a" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">对于短命的应用程序，启动是很重要的。如果你使用AOT，编译将是唯一的瓶颈，但是启动会更快。对于其他人来说，最好依赖于只有JIT编译才有的运行时配置文件。</p></div><div class="ab cl mq mr hy ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="in io ip iq ir"><p id="12d5" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><strong class="ky iv"> <em class="ls">长寿app崩溃怎么办？我们还能从JIT中得到优化吗？</em>T29】</strong></p><p id="8caa" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">缓存JIT编译的代码是一个问题。JIT编译的代码基于运行时变量进行优化/去优化。也就是说不可能缓存。</p><p id="55ff" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><strong class="ky iv"> <em class="ls">相反，我们可以缓存概要分析数据。</em> </strong>那是来自JIT编译的分析。如果前提条件没有变化，这可以重复使用。一个选择是<a class="ae kv" href="https://github.com/alibaba/dragonwell8/wiki/Alibaba-Dragonwell8-User-Guide?spm=a2c41.12911801.0.0.57544839B5EtTB#jwarmup" rel="noopener ugc nofollow" target="_blank">jvamup</a>，这个解决方案将会包含在未来的JDK版本中。</p></div><div class="ab cl mq mr hy ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="in io ip iq ir"><p id="6cee" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><strong class="ky iv"> <em class="ls">难道AOT不会在每个CI上要求大量的资源吗？</em>T9】</strong></p><ul class=""><li id="6d72" class="mx my iu ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><em class="ls">AOT——适用于小型应用程序，以及那些规模不会增长的应用程序</em></li><li id="4dcf" class="mx my iu ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><em class="ls">JIT——更适合发展解决方案</em></li></ul><p id="803c" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">随着AOT提前编译每条路径，这可能会耗尽资源。JIT编译不会预先编译所有的路径。</p><p id="49b9" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">我们来看一些现实生活中的例子。</p><p id="18e5" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><em class="ls">“比如我看到一个用Go做的开源项目。对于单一架构来说，构建时间很快。即便如此，他们还是为每个架构/平台组合构建了30次。因此，虽然Go编译速度很快，但一次潜在的代码更改就占用了大量Azure/Github资源。”</em> — <a class="ae kv" href="https://www.reddit.com/r/java/comments/wbtz24/comment/iidiyau/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank">来源</a></p><p id="f728" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">同样的事情也会发生在NodeJS身上。</p><p id="eec4" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><em class="ls">“Node的CI非常愚蠢，因为它生成了大约50多个docker映像，每个微服务一个。换了一个LoC又推？每个构建都提供了一个temp Ubuntu实例来构建Docker映像。并且每个构建从头开始下载每个依赖项！”</em>——<a class="ae kv" href="https://www.reddit.com/r/java/comments/wbtz24/comment/iigj9ny/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank">来源</a></p><p id="e3f7" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">构建时间很重要，因为CI可以触发很多构建时间。</p><p id="7c93" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">构建时间会阻塞CI。用AOT编译一遍又一遍地做构建，最终会产生大笔的云提供商账单。</p><p id="babb" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">对于Java编译的工件，您可以在env变量中指向所需的工件。不需要全部重建(并重启JVM ),只需更改classpath env变量。</p><h1 id="ab4d" class="lt lu iu bd lv lw lx ly lz ma mb mc md ka me kb mf kd mg ke mh kg mi kh mj mk bi translated">我们今天能为AOT做些什么？</h1><p id="707a" class="pw-post-body-paragraph kw kx iu ky b kz ml jv lb lc mm jy le lf mn lh li lj mo ll lm ln mp lp lq lr in bi translated">从Java 9开始，您可以使用AOT编译。更多关于提前编译的信息可以在<a class="ae kv" href="https://openjdk.org/jeps/295" rel="noopener ugc nofollow" target="_blank"> JEP-295 </a>中找到。</p><p id="7492" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">因此，随着AOT在Java中的出现，许多构建系统可以通过使用这个特性得到改进。</p><p id="fd5e" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">春天本地人就是一个例子。</p><p id="c382" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">GraalVM编译器用于编译Spring原生项目。通过这种编译，您将获得更快启动的好处。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj kj"><img src="../Images/b6f7e8ddf064b7447dc81d1d274ed872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLBmqu5QbsRDP9zdyC7d9w.png"/></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated"><a class="ae kv" href="https://betterprogramming.pub/how-to-integrate-spring-native-into-spring-boot-microservices-add2ece541b8" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="b483" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">即便如此，使用AOT编译时，构建时间会更长。这是本机编译所需要的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj kj"><img src="../Images/f0fdab78b1bfa3b4b4b7dfe409cb15bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KaLt0iuvAnM_sPEguad5-A.png"/></div></figure><p id="1569" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><strong class="ky iv"> <em class="ls">但是春原生和倒影还是有问题。</em></strong>Spring团队为这些问题创造了一个术语:<a class="ae kv" href="https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/#native-hints" rel="noopener ugc nofollow" target="_blank">原生提示</a></p><p id="20ea" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">对于反射需求，仍然需要配置。详细配置请访问<a class="ae kv" href="https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/#native-hints" rel="noopener ugc nofollow" target="_blank">本机提示</a>。</p></div><div class="ab cl mq mr hy ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="in io ip iq ir"><p id="a096" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">所以如果AOT在这里，我们能让一切都本土化吗？  <em class="ls">原生编译会减少启动次数和内存占用。</em></p><p id="bdf8" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">一种流行的构建系统是用Java编写的。它以JIT编译代码的形式发布。</p><p id="2852" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><em class="ls">建造系统是</em> <a class="ae kv" href="https://bazel.build/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">巴泽尔</em> </a> <em class="ls">。</em></p><p id="3a04" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">一个人试图改变这一切。他试图<strong class="ky iv"> <em class="ls">做出一个本土版的巴泽尔。</em>T25】</strong></p><p id="b17b" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">旅程如下:<br/> <a class="ae kv" href="https://github.com/bazelbuild/bazel/issues/7884" rel="noopener ugc nofollow" target="_blank"> GraalVM原生映像问题# 7884 bazelbuild/bazel GitHub</a></p><p id="a8c7" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">我们可以用Spring Native构建本地可执行文件。 这里是<a class="ae kv" href="https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/#executable-jar-to-native" rel="noopener ugc nofollow" target="_blank">关于如何将可执行JAR转换成本机的文档</a>。即便如此，这也不是这里的问题，因为我们正在尝试从<em class="ls">到</em> <a class="ae kv" href="https://github.com/bazelbuild/bazel/issues/7884#issuecomment-547687174" rel="noopener ugc nofollow" target="_blank"> <em class="ls">制作一个原生的Bazel版本</em> </a> <em class="ls">。</em></p><p id="cff4" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">他遇到了反思的问题。因为一些类需要反射，所以需要配置<a class="ae kv" href="https://github.com/bazelbuild/bazel/issues/7884#issuecomment-478361453" rel="noopener ugc nofollow" target="_blank">大部分</a>。如果需要反射，一些类<a class="ae kv" href="https://www.graalvm.org/22.1/reference-manual/native-image/Reflection/#automatic-detection" rel="noopener ugc nofollow" target="_blank">会被自动解析</a>，但是仍然有一些不属于这个类别。</p><ul class=""><li id="d779" class="mx my iu ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><em class="ls"> JIT —反射是免费的</em></li><li id="a6d4" class="mx my iu ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><em class="ls">AOT——反思是有代价的</em></li></ul><p id="8d8d" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">所以问题出在这个原生二进制文件的原生类库的初始化上。初始化类需要手动初始化。这一切都发生在AOT编译期间的虚拟机中。</p><p id="0d4c" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">根据一个故事，Micronaut有办法解决反射问题。对于GraalVM编译器，需要提前指定具有反射需求的类。</p><p id="9030" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><strong class="ky iv"> <em class="ls">今天我们能和巴泽尔做些什么？</em> </strong>我们可以把JVM二进制变成原生二进制:<a class="ae kv" href="https://github.com/andyscott/rules_graal" rel="noopener ugc nofollow" target="_blank"> Bazel规则把JVM二进制变成原生二进制</a>。它是<a class="ae kv" href="https://github.com/andyscott/rules_graal/commits/master" rel="noopener ugc nofollow" target="_blank">经常更新的</a>，所以如果你需要原生二进制，值得一试。尽管如此，还是有必要将反思包含在项目本身中。</p><p id="2642" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><em class="ls">即使Bazel Native很远，我们也可以用rules_graal来编译原生二进制。</em></p><h1 id="ae62" class="lt lu iu bd lv lw lx ly lz ma mb mc md ka me kb mf kd mg ke mh kg mi kh mj mk bi translated">当前的Java工具如何应对内存占用？</h1><p id="2147" class="pw-post-body-paragraph kw kx iu ky b kz ml jv lb lc mm jy le lf mn lh li lj mo ll lm ln mp lp lq lr in bi translated">我们已经看到了本机编译如何提高吞吐量。所以即使这样也不再是问题了。这指的是GraalVM的概要引导优化。</p><p id="1b22" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">也由于航运整体，JDK JIT编译未能与AOT竞争。所以如果你真的需要压缩你当前的JIT代码，你会怎么做？</p><p id="a804" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">一种方法是使用jdeps和jlink。 </p><p id="7426" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">这里有一个真实的例子。Joe使用这些工具创建了一个定制的JRE。这样做，他削减了大量脂肪或250兆脂肪。</p><p id="1135" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">巴泽尔还对Java有依赖性。这意味着它与JDK一起发货。</p><p id="706c" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">作为一个RFC，这里有<a class="ae kv" href="https://docs.google.com/document/d/1Igmv-2GfXkoVFWTXvBYPeniQom8nLAwzqzridDlBIS4/edit" rel="noopener ugc nofollow" target="_blank">关于内存占用改进的文档</a>。另外，你可以在GitHub 上查看<a class="ae kv" href="https://github.com/bazelbuild/bazel/milestone/13?closed=1" rel="noopener ugc nofollow" target="_blank">实际里程碑。</a></p><p id="5934" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">即便如此，这只使用了Java 9模块和其他专有特性(Proguard)来减少Bazel二进制文件的大小。做这些步骤削减了一个不坏的56兆字节的JDK大小。和大约20个额外的MiB。</p><p id="71e2" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><strong class="ky iv"> <em class="ls">因此，当启动Bazel </em> </strong> <code class="fe nl nm nn no b"><strong class="ky iv"><em class="ls">version</em></strong></code> <strong class="ky iv"> <em class="ls">时，我们获得的速度是之前“胖”Bazel二进制的两倍。</em> </strong></p></div><div class="ab cl mq mr hy ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="in io ip iq ir"><p id="3d14" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><strong class="ky iv"> <em class="ls">当然，还是有一些内存占用，因为需要JDK/JRE。</em>T3】</strong></p><p id="14a2" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated"><a class="ae kv" href="https://mail.openjdk.org/pipermail/leyden-dev/2022-June/thread.html#42" rel="noopener ugc nofollow" target="_blank">莱登项目</a>将尝试修复内存足迹。</p><p id="b256" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">结合jdeps、jlink和AppCDS应该会产生更好的内存占用。查看<a class="ae kv" href="https://medium.com/@toparvion/appcds-for-spring-boot-applications-first-contact-6216db6a4194" rel="noopener"> AppCDS如何在Spring Boot应用上工作。</a></p><p id="0d68" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">AppCDS 背后的主要思想是为类使用一个共享的归档。这个档案将存储“不可变的”类，并在必要时从档案中加载它们。这样，每次后续运行的内存消耗都会变小。当然，你的里程数可能会有所不同，但仍然，它看起来很有希望。</p><p id="4bd1" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">今天，由于莱登仍在发展中，我们只能遵循<em class="ls">“jdeps和jlink”</em>的方法。此外，我们可以检查Bazel团队用他们的JDK做了什么。这两种途径都应该导致更好的内存占用。</p><h1 id="9fad" class="lt lu iu bd lv lw lx ly lz ma mb mc md ka me kb mf kd mg ke mh kg mi kh mj mk bi translated">继续阅读相关文章:</h1><p id="08bf" class="pw-post-body-paragraph kw kx iu ky b kz ml jv lb lc mm jy le lf mn lh li lj mo ll lm ln mp lp lq lr in bi translated">认为JVM在当今时代没有必要的开发人员:<a class="ae kv" href="https://medium.com/star-gazers/java-and-c-is-obsolete-in-the-age-of-docker-39fb0d28f8b6" rel="noopener"> Java和C#在Docker时代已经过时|作者Erik eng heim | Star Gazers | Medium</a></p><div class="np nq gq gs nr ns"><a href="https://blogs.oracle.com/javamagazine/post/java-cloud-services" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fp"><div class="nu ab nv cl cj nw"><h2 class="bd iv gz z fq nx fs ft ny fv fx it bi translated">面向云的Java，以及面向Java的云</h2><div class="nz l"><h3 class="bd b gz z fq nx fs ft ny fv fx dk translated">下载这篇文章的PDF文档。许多组织选择在云中运行现有的Java应用程序——并且…</h3></div><div class="oa l"><p class="bd b dl z fq nx fs ft ny fv fx dk translated">blogs.oracle.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kp ns"/></div></div></a></div></div><div class="ab cl mq mr hy ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="in io ip iq ir"><h1 id="f7be" class="lt lu iu bd lv lw oh ly lz ma oi mc md ka oj kb mf kd ok ke mh kg ol kh mj mk bi translated">分级编码</h1><p id="c176" class="pw-post-body-paragraph kw kx iu ky b kz ml jv lb lc mm jy le lf mn lh li lj mo ll lm ln mp lp lq lr in bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="83f8" class="mx my iu ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="f4e3" class="mx my iu ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">📰查看<a class="ae kv" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="6946" class="mx my iu ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">🔔关注我们:<a class="ae kv" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kv" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kv" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="11d2" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">🚀👉<a class="ae kv" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ky iv">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>