# 。Net 核心依赖注入:生存期和一些最佳实践

> 原文：<https://levelup.gitconnected.com/net-core-dependency-injection-lifetimes-and-few-best-practices-e194d2a39eff>

![](img/6bbf1ad6483612b6592456c41847d434.png)

礼貌:google.com

在我们深入研究 ***依赖注入(DI)*** 之前。理解我们为什么需要魔法是很重要的。

我们先来探讨一下什么是 ***依存倒置原理(DIP)*** 是什么。DIP 允许您解耦两个类，否则这两个类会非常紧密地耦合在一起，这有助于提高可重用性和可维护性。

> 倾斜状态，
> 
> 1.高层模块不应该依赖低层模块。两者都应该依赖于抽象。
> 
> 2.抽象不应该依赖于细节。细节应该依赖于抽象。

为了便于讨论，让我们忽略后者，用一个例子更深入地研究前者

```
class Foo {
  Foo(Car _car){
    // something
  }
}
```

在上面的代码片段中，类`Foo`直接依赖于类`car`。这些类之间的紧密耦合会带来两个主要问题

1.  `Foo`不能用不同风格的`car`来实例化，也就是说，如果有一个新的汽车类，比如:`Sedan`来了，`Foo`不能被重用
2.  `car`合同的任何变化现在都会影响`Foo`，直接增加维护费用。

为了避免这两个问题，DIP 建议高层模块`Foo`不应该直接依赖于低层模块`Car`，而是应该依赖于一个抽象，例如:接口。

```
class Foo {
  Foo(ICar _car){
    // something
  }
}class Car : ICar {

}class Sedan : ICar{}
```

仅仅通过引入一个简单的抽象`ICar`,`Foo`变得兼容于任何遵循契约或抽象`ICar`的类。

那么现在这如何链接到依赖注入呢？

DIP 提高了代码的可重用性，并在需要更改较低级别的类时限制了波动效应。即使当 DIP 被完美地实现时，该接口也只是在高级类中解耦了低级类的使用，而不是它的实例化。在代码的某个地方，您需要实例化接口的一个实现。这可以防止您动态地用不同的接口替换该接口的实现。

依赖注入在这里发挥作用，帮助将使用从创建中分离出来。简单地说，每当 DI 框架发现一个类中任何注册服务的依赖时，它将提供一个具体的实例化。

假设`ICar`在 DI 框架中注册提供了一个`Car`的实例，那么对于每个`Foo`对象的实例化，`Foo`的构造器总是接收到一个`car`的具体实例。

## 迪在。网络核心:

在……Net 核心框架来了，我们应该配置一个第三方的 DI 框架，像[温莎城堡](https://github.com/castleproject/Windsor)， [Autofac](https://github.com/autofac/Autofac) 和许多其他的。然而，在。Net core DI 开箱即用。“Startup”类提供了一个名为`configureServices`的方法，这是开发人员向容器注册服务和类的地方。

```
public class Startup { // ... public void ConfigureServices(IServiceCollection services) {
    services.AddTransient<ICar, Car>();
  }
  // ...
}
```

因此，对于每个请求，控制器被调用，所有依赖项都从容器中解析出来。所有这些都可以在。没有复杂配置的 Net core。。Net 也没有在创建实例的生命周期中提供一些在特定动机下可能会派上用场的味道。让我们来看看这些。

## 依赖项生存期:

在注册时，需要指定服务的生命周期。这个生存期定义给出了一个新实例何时创建的概念。有三种不同的味道。

1.  短暂的
2.  审视
3.  一个

**Transient:** 这个生存期定义使得 DI 可以在任何需要的时候创建一个新的实例

**Scoped:** 这使得 DI 为每个新作用域创建一个新实例。这里的范围通常是指一个新的 web 请求。

**Singleton:** 这只会在第一次请求时创建一个新的实例，在应用程序的剩余生命周期中，同一个实例会提供给所有的消费者类。

## 良好做法

1.  作用域服务通常应该由单个 web 请求/线程使用。因此，您不应该跨线程共享服务范围。
2.  配置为单例的服务可能会导致应用程序中的内存泄漏。
3.  **内存泄漏**一般是由单体服务引起的。这是因为创建的实例没有被释放，它将一直留在内存中，直到应用程序结束。所以一旦不用了就释放它们是好的。
4.  注册为 transient 的服务寿命较短，所以你可能不太关心**多线程**和**内存泄漏。**
5.  **不要依赖**单例服务中的瞬态服务或作用域服务。因为当单例服务注入瞬态服务时，瞬态服务变成了单例实例，如果瞬态服务没有被设计成支持这样的场景，这可能会导致问题。ASP.NET 核心的默认 DI 容器已经在这种情况下抛出了**异常**。

## 摘要

DIP 坚持在一个更高级别的类和它的依赖之间创建一个抽象(接口)。这有助于将较高级别的类从其依赖项中分离出来，这样对较低级别的类的任何更改都不会影响较高级别的类。唯一直接使用依赖项的代码是负责实例化实现接口的类的对象的代码。

依赖注入技术使您能够进一步改进这一点。它提供了一种将对象的创建和使用分开的方法。通过这样做，您可以在不更改任何代码的情况下替换依赖项，并且还可以减少业务逻辑中的样板代码。