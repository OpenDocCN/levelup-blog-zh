<html>
<head>
<title>When to Use the Java “this” Keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时使用Java“this”关键字</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/when-to-use-the-java-this-keyword-cfbfbffc8ab8?source=collection_archive---------7-----------------------#2020-05-28">https://levelup.gitconnected.com/when-to-use-the-java-this-keyword-cfbfbffc8ab8?source=collection_archive---------7-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b65c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于一个最普遍的Java关键字的权威指南，带有示例。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb0e2660ec9293f19d7afd18a6487b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c-CDkgkPDj9dSfuo"/></div></div></figure><p id="8966" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码评审是一份不断赠送的礼物。即使在你和你的同事一起研究过之后，进一步发现的潜力还是被低估了。</p><p id="e3bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前几天，我在查看一个拉取请求的一些评论时，我发现了这样的内容:</p><blockquote class="lq lr ls"><p id="2127" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated"><em class="it">“这个”这里不需要。</em></p></blockquote><p id="b870" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而<code class="fe lx ly lz ma b">this</code>是Java关键字。在这部分代码中，它被用来给一个测试类变量分配一个mock。类似于:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3fd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你知道吗，评论是100%正确的。测试按预期运行，但是在这种情况下我们不需要<code class="fe lx ly lz ma b">this</code>。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="8a62" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">什么是Java this关键字的原子解释</h1><p id="fb54" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">使用<code class="fe lx ly lz ma b">this</code>,你可以从当前对象的一个方法中获得对当前对象的直接引用。</p><p id="661f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样。</p><p id="2ff5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我敢打赌，您也想象到了在使用它时可能出现的混乱和冗余。如果不使用<code class="fe lx ly lz ma b">this</code> <em class="lt"> </em>关键字也可以访问当前对象的方法和变量，为什么还需要一个特殊的关键字呢？</p><p id="7d49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为你可能会面临以下五种情况之一:</p><h1 id="262c" class="mk ml it bd mm mn nh mp mq mr ni mt mu jz nj ka mw kc nk kd my kf nl kg na nb bi translated">当实例变量和方法参数之间有歧义时</h1><p id="4544" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">Java最佳实践促进了一种编写setter方法的特定方式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="72cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我敢说这是<code class="fe lx ly lz ma b">this</code>最常见的用法。当一个方法接受一个与其对象的一个变量同名的参数时，你需要一种方法来识别哪个是哪个。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="018a" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">当您想从同一个类中的另一个构造函数调用构造函数时</h1><p id="15e0" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">如果您接受不同的参数集来创建同一类型的对象，那么您很可能要么使用生成器，要么使用重载的构造函数。如果是后者，不管调用哪个构造函数，您可能都需要调用另一个来处理默认属性，这些属性应该总是初始对象定义的一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="809d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次出手相救。这一次我们用它从另一个方法内部引用一个方法(更确切地说是一个构造函数)。要记住的重要Java规则:<code class="fe lx ly lz ma b">this()</code>需要是每个构造函数调用另一个构造函数的第一条语句。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="cc11" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">当您需要从方法中返回当前的类实例时</h1><p id="8424" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">这是赋予构建器设计模式权力的规则。您可以将连续的属性链接到一个对象定义，因为每次添加都会返回更新的对象。更新后的对象由<code class="fe lx ly lz ma b">this</code>返回。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="0691" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦你看到它的实际应用，你会印象更加深刻:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="262b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像装配线一样，这里的汽车也是一步一步制造的，每个工位都完成了之前的所有工作，并增加了一点点。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="8cf3" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">当您需要将当前类实例传递给方法时</h1><p id="4b6b" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">就像你从一个方法返回<code class="fe lx ly lz ma b">this</code>一样简单，你可以把它作为一个参数传递给另一个方法。它们带着实例变量和方法，允许在其他类中访问它们。权力越大，责任越大！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="b00d" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">当嵌套的非静态类需要访问外部类的实例时</h1><p id="f337" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">我们必须将嵌套类视为外部类的任何其他成员。</p><blockquote class="lq lr ls"><p id="ecb9" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">写这篇文章时我才知道的一些很酷的事情。 <a class="ae nm" href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" rel="noopener ugc nofollow" target="_blank"> <em class="it">非静态嵌套类称为</em> <strong class="kw iu">内部类</strong> <em class="it">，静态嵌套类称为</em><strong class="kw iu"/></a><em class="it">。</em></p></blockquote><p id="6065" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像上面例子中的方法一样，Java允许你通过关键字<code class="fe lx ly lz ma b">this</code>获得对父类实例的引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="bd58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lx ly lz ma b">this</code>关键字的这个特性不仅允许你访问汽车实例变量，就像例子中一样，而且如果需要的话，还可以访问汽车实例本身。</p></div></div>    
</body>
</html>