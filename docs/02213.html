<html>
<head>
<title>From AngularJS to React Bit By Bit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从角度到一点一点的反应</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/from-angularjs-to-react-bit-by-bit-9bf5b4610a7?source=collection_archive---------9-----------------------#2020-02-26">https://levelup.gitconnected.com/from-angularjs-to-react-bit-by-bit-9bf5b4610a7?source=collection_archive---------9-----------------------#2020-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eb2715d7da2bb09283b1b1a81928fe68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4JMr2R01Ynl6bmqm.jpg"/></div></div></figure><blockquote class="kb kc kd"><p id="d75d" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> <em class="it">总结:</em> </strong> <em class="it"> <br/>将你的应用从AngularJS迁移到React(坦白地说，迁移到任何其他现代框架/库)肯定有好处。如果完全重写不适合你，在本文中，我将带你通过一个简单的方法将React引入到AngularJS应用程序中。即使您最终使用开源库来桥接AngularJS来作出反应，这篇文章也会让您理解它的基本原理。</em></p></blockquote><p id="a259" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">想跳过所有解释？直接跳到<a class="ae lg" href="https://dev.to/kaplona/angularjs-to-react-migration-184g#full-example" rel="noopener ugc nofollow" target="_blank">完整的工作示例</a>。</p><p id="e6b4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">因此，您决定将应用程序从AngularJS切换到React。很好！因为坦率地说，您应该从那个不再受支持的框架转向其他任何东西。任何现代的框架/库都更有性能，更容易使用，并且有更大的社区。</p><h1 id="20f2" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">理由</h1><p id="3086" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">在<a class="ae lg" href="https://www.awesense.com/" rel="noopener ugc nofollow" target="_blank"> Awesense </a>我们有两个用例，用AngularJS很难实现，但用React却非常简单:</p><ol class=""><li id="5b97" class="mk ml it kh b ki kj km kn ld mm le mn lf mo lc mp mq mr ms bi translated"><strong class="kh iu">动态内容。</strong>我们希望让用户能够定制他们的仪表板页面。React元素及其属性只是JS类、函数和对象，您不需要做任何特殊的事情就可以将用户配置映射到正确的UI。</li><li id="eedf" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc mp mq mr ms bi translated"><strong class="kh iu">地图覆盖。Awesense客户端应用程序是以地图为中心的，我们需要从普通的JavaScript呈现各种UI元素。有了React，你可以随时创建根组件，而AngularJS被设计成只需引导一次，就可以处理你的应用程序中的所有事情。从AngularJS的宇宙中跳进跳出是可能的，但肯定没有React中的一行代码优雅。</strong></li></ol><p id="a2e3" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">完全重写很少是一个好的决定。逐渐迁移使我们能够在平静时期花更多时间在AngularJS的技术债务上，并在重要时加快功能开发以支持业务增长，这是一个每个人都满意的良好平衡。</p><p id="e4f4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">你可以使用像<a class="ae lg" href="https://github.com/ngReact/ngReact" rel="noopener ugc nofollow" target="_blank">n react</a>、<a class="ae lg" href="https://github.com/coatue-oss/react2angular" rel="noopener ugc nofollow" target="_blank"> react2angular </a>、<a class="ae lg" href="https://github.com/coatue-oss/angular2react" rel="noopener ugc nofollow" target="_blank"> angular2react </a>这样的库来帮助你完成迁移，但是实现你自己的解决方案只需要很少的代码，而且完全理解它是如何工作的也很好。Awesense解决方案的灵感来自这个小改进<a class="ae lg" href="https://tech.small-improvements.com/how-to-migrate-an-angularjs-1-app-to-react/" rel="noopener ugc nofollow" target="_blank">博客文章</a>和他们的开源<a class="ae lg" href="https://github.com/sfroestl/angular-react-migration" rel="noopener ugc nofollow" target="_blank">例子</a>。</p><h1 id="19df" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">初始步骤</h1><p id="7ab7" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">为了使过渡更加顺利，你应该首先按照以下步骤准备好AngularJS代码库:</p><ul class=""><li id="5f53" class="mk ml it kh b ki kj km kn ld mm le mn lf mo lc my mq mr ms bi translated">在同一个文件中定义您的控制器和组件模板，如果您还没有这样做的话。</li><li id="11ca" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc my mq mr ms bi translated">开始使用AngularJS <a class="ae lg" href="https://docs.angularjs.org/guide/component" rel="noopener ugc nofollow" target="_blank">组件</a>代替指令。组件提供了生命周期挂钩。虽然React和AngularJS生命周期方法在组件渲染周期的不同时间被调用，但熟悉这个概念是有益的。</li><li id="322f" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc my mq mr ms bi translated">将你的组件分成<a class="ae lg" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">容器和表示</a>组件。这种关注点的分离使得您的代码更容易管理和重用。</li><li id="4a38" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc my mq mr ms bi translated">拥抱单向数据流架构:停止使用<code class="fe mz na nb nc b">=</code>双向绑定，转而使用<code class="fe mz na nb nc b">&lt;</code>绑定将输入传递给子组件。将您的子组件视为不会改变传递参数的纯函数。相反，孩子应该通过调用作为输出传递给他们的回调来更新父母的状态。这将使您更好地了解数据如何流经您的应用程序，在哪里更新，以及谁拥有它。</li></ul><h1 id="3759" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">成分</h1><p id="fd4b" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">我们的策略是从“叶子”表示的组件开始迁移，向上迁移到有状态的组件，最终迁移到在路由中呈现的顶级组件。这样，您就不需要在React组件中加载AngularJS代码，也不需要在最后处理路由。</p><h2 id="9bc8" class="nd li it bd lj ne nf dn ln ng nh dp lr ld ni nj lv le nk nl lz lf nm nn md no bi translated">简单组件</h2><p id="489d" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">首先，您需要一种在现有AngularJS代码中使用React组件的方法。我不会讨论如何在React组件中使用AngularJS组件，因为我们的策略不需要这样做，我们的最终目标是无论如何都不使用AngularJS。</p><p id="5d51" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">创建一个简单的React组件:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="16f5" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">一个等效的AngularJS组件如下所示:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3d84" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">因此，我们需要一个helper函数，将我们的React组件包装到一个AngularJS组件中，该组件可以从我们的旧AngularJS代码库中使用:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="dc10" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">这里我们的帮助函数<code class="fe mz na nb nc b">reactToAngularComponent</code>返回一个简单的AngularJS组件配置，没有模板。相反，该配置使用<code class="fe mz na nb nc b">$element[0]</code>访问底层父DOM元素，并使用<code class="fe mz na nb nc b">$onInit</code>和<code class="fe mz na nb nc b">$onDestroy</code> AngularJS <a class="ae lg" href="https://docs.angularjs.org/guide/component" rel="noopener ugc nofollow" target="_blank">生命周期方法</a>在创建时挂载<code class="fe mz na nb nc b">ReactExample</code>组件，在销毁<code class="fe mz na nb nc b">reactExampleBridge</code>组件时卸载它。</p><p id="6b83" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">注意<code class="fe mz na nb nc b">reactExampleBridge</code>组件名称中的后缀“Bridge”。在迁移过程中，这种命名约定将使识别只剩下桥组件子组件的AngularJS组件变得容易(这意味着我们现在可以在React中重写父组件并删除所有桥)。</p><p id="9736" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在我们可以在另一个AngularJS组件模板中使用<code class="fe mz na nb nc b">reactExampleBridge</code>:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="3a91" class="nd li it bd lj ne nf dn ln ng nh dp lr ld ni nj lv le nk nl lz lf nm nn md no bi translated">传递道具</h2><p id="6f40" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">让我们改变<code class="fe mz na nb nc b">ReactExample</code>组件，让它接受一些道具:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="be48" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">我们不需要对<code class="fe mz na nb nc b">reactExampleBridge</code>组件做任何修改，但是<code class="fe mz na nb nc b">reactToAngularComponent</code>助手函数需要一些调整:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e63f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">如您所见，我们增加了两个辅助函数:</p><ul class=""><li id="6c96" class="mk ml it kh b ki kj km kn ld mm le mn lf mo lc my mq mr ms bi translated"><code class="fe mz na nb nc b"><strong class="kh iu">toBindings</strong></code> -从React组件<code class="fe mz na nb nc b">propTypes</code>中生成AngularJS组件绑定对象。我们只需要在注册AngularJS包装组件时使用它一次。</li><li id="2897" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc my mq mr ms bi translated"><code class="fe mz na nb nc b"><strong class="kh iu">toProps</strong></code> -从AngularJS控制器值创建一个反应道具对象。每次控制器值改变时，我们都需要使用它，这就是为什么<code class="fe mz na nb nc b">$onInit</code>生命周期挂钩被替换为<code class="fe mz na nb nc b">$onChanges</code>。方便的是，同样的<code class="fe mz na nb nc b">ReactDOM</code>方法可以用于第一次将React元素装载到DOM中，以及用新的props有效地更新已经装载的React元素。</li></ul><p id="52bc" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">这对如何声明React组件以及如何在桥组件中使用它们施加了一些限制:</p><ul class=""><li id="9fd3" class="mk ml it kh b ki kj km kn ld mm le mn lf mo lc my mq mr ms bi translated">所有属性必须在<code class="fe mz na nb nc b">propTypes</code>对象中显式声明。我们的<code class="fe mz na nb nc b">ReactExample</code>组件不会收到任何未指定的道具。出于文档目的，在所有React组件上定义<code class="fe mz na nb nc b">propTypes</code>是一个好的实践。这也使得调试更加容易，因为当一个意外类型的属性被传递给一个组件时，React会在控制台中输出警告。</li><li id="4efb" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc my mq mr ms bi translated">传递给桥组件的所有输入必须是不可变的，否则<code class="fe mz na nb nc b">$onChanges</code>生命周期方法将不会被触发，并且<code class="fe mz na nb nc b">ReactExample</code>组件将不会接收到更新的值。</li><li id="2c21" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc my mq mr ms bi translated">传递给<code class="fe mz na nb nc b">reactExampleBridge</code>的所有输入必须是表达式，因为<code class="fe mz na nb nc b">toBindings</code>助手函数只使用<a class="ae lg" href="https://docs.angularjs.org/guide/component#component-based-application-architecture" rel="noopener ugc nofollow" target="_blank"/><code class="fe mz na nb nc b"><a class="ae lg" href="https://docs.angularjs.org/guide/component#component-based-application-architecture" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu">&lt;</strong></a></code><a class="ae lg" href="https://docs.angularjs.org/guide/component#component-based-application-architecture" rel="noopener ugc nofollow" target="_blank">类型的绑定</a>。</li></ul><p id="6489" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在我们可以将<code class="fe mz na nb nc b">example-text</code>输入传递给我们的<code class="fe mz na nb nc b">reactExampleBridge</code>组件:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="3db3" class="nd li it bd lj ne nf dn ln ng nh dp lr ld ni nj lv le nk nl lz lf nm nn md no bi translated">不同类型的绑定</h2><p id="008e" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">通常在定义AngularJS组件时，你会使用三种类型的绑定:<code class="fe mz na nb nc b">&lt;</code>、<code class="fe mz na nb nc b">@</code>和<code class="fe mz na nb nc b">&amp;</code>。一个简单的todo list AngularJS组件如下所示:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="546d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">然而，我们的<code class="fe mz na nb nc b">reactToAngularComponent</code>助手只使用<code class="fe mz na nb nc b">&lt;</code>类型的绑定。让我们将我们的<code class="fe mz na nb nc b">todoList</code> AngularJS组件重写为一个React桥，看看如何向它传递不同类型的绑定。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3b1e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated"><code class="fe mz na nb nc b">items</code>输入最初是用<code class="fe mz na nb nc b">&lt;</code>绑定类型定义的，所以我们不需要对它做任何修改，但是对于<code class="fe mz na nb nc b">title</code>和<code class="fe mz na nb nc b">on-select</code>我们必须做如下调整:</p><ul class=""><li id="7d84" class="mk ml it kh b ki kj km kn ld mm le mn lf mo lc my mq mr ms bi translated">最初<code class="fe mz na nb nc b">title</code>是用<code class="fe mz na nb nc b">@</code>绑定定义的，所以我们可以马上传递一个字符串。现在对于<code class="fe mz na nb nc b">todoListBridge</code>组件，AngularJS将把传递的<code class="fe mz na nb nc b">title</code>输入作为一个表达式进行计算，所以我们需要用双引号将字符串括起来:</li></ul><p id="b6a8" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated"><code class="fe mz na nb nc b"><strong class="kh iu">title="'Tasks For Tomorrow'"</strong></code></p><ul class=""><li id="35e1" class="mk ml it kh b ki kj km kn ld mm le mn lf mo lc my mq mr ms bi translated">最初<code class="fe mz na nb nc b">on-select</code>是用<code class="fe mz na nb nc b">&amp;</code>绑定定义的，要求我们指定回调需要什么参数。现在我们不需要这样做，因为我们传递了底层函数本身:</li></ul><p id="97f3" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated"><code class="fe mz na nb nc b"><strong class="kh iu">on-select="::$ctrl.handleItemSelect"</strong></code></p><p id="60c0" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">由于<code class="fe mz na nb nc b">handleItemSelect</code>函数从不改变，我们可以通过使用<code class="fe mz na nb nc b">::</code> <a class="ae lg" href="https://docs.angularjs.org/guide/expression#one-time-binding" rel="noopener ugc nofollow" target="_blank">一次性绑定</a>语法来优化我们的父组件，告诉AngularJS不要注意<code class="fe mz na nb nc b">handleItemSelect</code>的变化。</p><h2 id="dcd1" class="nd li it bd lj ne nf dn ln ng nh dp lr ld ni nj lv le nk nl lz lf nm nn md no bi translated">不可变数据</h2><p id="98ab" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">让我们实现<code class="fe mz na nb nc b">handleItemSelect</code>逻辑:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9efb" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">我们通过使用ES6<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">array . prototype . map</a>将<code class="fe mz na nb nc b">todoItems</code>数组替换为它的副本。如果您简单地就地更新todo项，<code class="fe mz na nb nc b">todoBridge</code>组件的<code class="fe mz na nb nc b">$onChange</code>方法不会检测到这种变化。因此，底层的<code class="fe mz na nb nc b">TodoList</code> React组件将不会被重新呈现，UI将保持陈旧。</p><p id="a3c2" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">我强烈建议不要改变你的数据，这使得对你的应用程序状态的推理更加容易，并且防止了许多错误。拥有不可变的数据也将通过<code class="fe mz na nb nc b">shouldComponentUpdate</code>和<code class="fe mz na nb nc b">React.PureComponent</code>为React 的进一步优化打开一扇门。</p><h2 id="e69b" class="nd li it bd lj ne nf dn ln ng nh dp lr ld ni nj lv le nk nl lz lf nm nn md no bi translated">复试</h2><p id="cb0f" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">由于我们将<code class="fe mz na nb nc b">handleItemSelect</code>回调作为表达式传递，当在<code class="fe mz na nb nc b">TodoList</code>组件中调用该函数时，它不知道它最初是在<code class="fe mz na nb nc b">AppController</code>上定义的。对于回调中指向控制器的<code class="fe mz na nb nc b">this</code>关键字，我们既可以用<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" rel="noopener ugc nofollow" target="_blank">function . prototype . bind()</a>方法将上下文绑定到函数，也可以用<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">胖箭头</a>函数将方法定义为<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Class_fields" rel="noopener ugc nofollow" target="_blank">类实例字段</a>，所有这些都将绑定正确的<code class="fe mz na nb nc b">this</code>。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="eafd" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">对于所有用<code class="fe mz na nb nc b">&amp;</code>绑定声明的输出，每当调用回调时，AngularJS将触发一个摘要循环。现在我们需要手动完成它，否则你会得到相当奇怪的行为:你的UI只会在下一个摘要周期更新。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="015c" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">服务和工厂</h1><p id="2358" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">AngularJS是一个大框架，它提供了很多现成的功能。你的最终目标是找到你使用的所有AngularJS服务的替代品。但是在此之前，您的React组件需要一种方法来访问这些服务。为此，我们需要另一个助手函数:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6f9d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">添加一些健全性检查以便于调试:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3641" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">让我们向React <code class="fe mz na nb nc b">TodoList</code>组件添加一个按钮，该按钮滚动到列表的顶部，并使用AngularJS <code class="fe mz na nb nc b">$anchorScroll</code>服务来执行该滚动:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="50b5" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">让您的迁移变得更容易的几个技巧:</p><ul class=""><li id="f46d" class="mk ml it kh b ki kj km kn ld mm le mn lf mo lc my mq mr ms bi translated">如果一个服务没有任何AngularJS依赖，不要在你的应用模块上注册它。将它直接导入到使用它的文件中。</li><li id="fede" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc my mq mr ms bi translated">将每个AngularJS服务隐藏在一个只公开您需要的功能的包装器中。这样，当需要替换底层AngularJS服务时，您可以更容易地将其切换出来。</li></ul><h2 id="5fdc" class="nd li it bd lj ne nf dn ln ng nh dp lr ld ni nj lv le nk nl lz lf nm nn md no bi translated">使用AngularJS之外的服务</h2><p id="fc58" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">选择AngularJS服务，例如<code class="fe mz na nb nc b">$http</code>。创建一个新的<code class="fe mz na nb nc b">myHttpService</code>类，并通过<code class="fe mz na nb nc b">getAngularService</code>助手函数获得AngularJS服务。仅添加您的应用程序需要的那些<code class="fe mz na nb nc b">$http</code>方法。此外，您可以隔离代码中经常重复使用的相关逻辑，例如在使用<code class="fe mz na nb nc b">$http</code>包装器的情况下的自定义服务器错误处理程序。</p><p id="a60d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">最后，实例化您的新服务:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="082a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">只有当底层AngularJS服务已经向AngularJS注册时，才能导入这样的包装器。一种安全的方法是在组件初始化时。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9253" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">这种方法的好处是，对于React和AngularJS组件，以相同的方式导入包装器。</p><h1 id="7b28" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">完全码</h1><p id="9f9a" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">让我们回忆一下。下面是一个完整的待办事项示例代码。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ef09" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">在Awesense，我们遵循简单的规则来确保迁移顺利进行:</p><ul class=""><li id="e6ee" class="mk ml it kh b ki kj km kn ld mm le mn lf mo lc my mq mr ms bi translated">所有新功能都是用React编写的；</li><li id="25d5" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc my mq mr ms bi translated">如果开发人员接触旧代码，他们会根据公司当时的业务优先级重写它或它的一部分。</li></ul><p id="9ddb" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">在第一年，我们将40%的前端代码转换为React。两年后，我们超过三分之二的代码都是用React编写的。</p><p id="10a5" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">我希望您知道AngularJS-React桥接是如何工作的后会感到更有力量，并且迁移到React的选项看起来不再那么令人生畏。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="0f6c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated"><em class="kg">原载于2020年2月26日</em><a class="ae lg" href="https://dev.to/kaplona/angularjs-to-react-migration-184g" rel="noopener ugc nofollow" target="_blank"><em class="kg">https://dev . to</em></a><em class="kg">。</em></p></div></div>    
</body>
</html>