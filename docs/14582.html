<html>
<head>
<title>Parallel code in Julia with threads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia中带线程的并行代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/parallel-code-in-julia-with-threads-b2e7c97f071b?source=collection_archive---------6-----------------------#2022-12-09">https://levelup.gitconnected.com/parallel-code-in-julia-with-threads-b2e7c97f071b?source=collection_archive---------6-----------------------#2022-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="30b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提高代码速度的最简单方法:ThreadsX.jl</p><p id="37c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我从2014年左右开始关注茱莉亚语言。Julia最吸引人的一点是，它从一开始就是为多核机器而构建的(在Python中使用joblib简直是一场噩梦……)。但是最近，该语言的多线程能力变得更好了，所以我花了一些时间来探索在2022年你可以用Julia和一些额外的内核做些什么。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5e9d8f372961c9b72ec5e78abd6395fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8u_rLrwc9svou_o2uRYAg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@phorgod?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿巴斯·特拉尼</a>在<a class="ae le" href="https://unsplash.com/s/photos/parallel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="67ac" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用更多线程启动Julia</h1><p id="abee" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在我们深入探讨可以使用什么来并行运行代码之前，我们必须<strong class="js iu">确保有可供Julia </strong>使用的线程。要检查Julia正在运行多少线程，只需运行以下代码:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="77cc" class="mn lg it mj b gy mo mp l mq mr">julia&gt; using Base.Threads</span><span id="0b9b" class="mn lg it mj b gy ms mp l mq mr">julia&gt; Threads.nthreads()<br/>1</span></pre><p id="0f97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了用更多的线程启动我们的REPL，我们可以将<code class="fe mt mu mv mj b">--threads</code>选项传递给Julia并获得更多的能力！！！</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="13a0" class="mn lg it mj b gy mo mp l mq mr">julia --threads 6</span></pre><blockquote class="mw mx my"><p id="3d0a" class="jq jr mz js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated">注意:我在这里使用6个内核，因为我的机器上有6个内核。</p></blockquote><p id="5f4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您使用的是VSCode，您可以编辑您的<code class="fe mt mu mv mj b">settings.json</code>文件，通过添加下面一行来指定您希望Julia使用的线程数量。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="e4f9" class="mn lg it mj b gy mo mp l mq mr">"julia.NumThreads": 6</span></pre><h1 id="caa5" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们愚蠢的功能</h1><p id="8a9b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了演示如何并行运行代码，我们应该首先想出一个我们想要运行的函数，然后<strong class="js iu">建立我们的单核基础案例</strong>。内核越多并不总是越好，因为并行代码也会带来开销。这些进程必须相互通信，这需要资源和时间。</p><p id="3beb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想保持简单，所以我们的函数会找到所有能被12整除的数字。然后我们将使用这个函数来找出在1到10，000之间有多少个数字能被12整除。我知道这是一个愚蠢的例子，但我们必须从某个地方开始。😅</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9118" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以看到我已经为我们的函数加入了几个<strong class="js iu">单元测试</strong>来确保我们的函数做了正确的事情。我鼓励你对你所有的功能都这样做。随着事情变得越来越复杂，这将使你的生活变得容易得多。</p><blockquote class="nf"><p id="1c83" class="ng nh it bd ni nj nk nl nm nn no kn dk translated">如果你以前从未使用过单元测试，开始在你的Julia代码中加入一些<code class="fe mt mu mv mj b">@test</code>宏吧！这是迄今为止我见过的所有语言中最简单的单元测试框架。</p></blockquote><p id="6f02" class="pw-post-body-paragraph jq jr it js b jt np jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj nt kl km kn im bi translated">我们将使用来自<code class="fe mt mu mv mj b">BenchmarkTools</code>的<code class="fe mt mu mv mj b">@btime</code>来为我们的运行时间获得一个好的时间估计，我将展示一些不同的方法来将这个函数应用到更多的数字:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="069c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你所看到的，仅仅通过不使用广播<code class="fe mt mu mv mj b">.</code>和利用<code class="fe mt mu mv mj b">sum</code>有多个相关方法的事实，我们已经可以减少40%的时间。上面<code class="fe mt mu mv mj b">sum</code>的第一个用法是取一个数组，并对其求和。第二种方法采用一个函数，将它应用于一个iterable的所有元素，并将这些结果相加。</p><blockquote class="nf"><p id="982f" class="ng nh it bd ni nj nk nl nm nn no kn dk translated">请务必阅读关于您正在使用的功能的文档。可能有一种方法可以让你的代码更快更优雅！</p></blockquote><h1 id="3d3e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq nu ls lt lu nv lw lx ly nw ma mb mc bi translated">朴素并行for循环</h1><p id="c289" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">现在我们已经有了一个基准，让我们看看如何让它并行运行。我们的第一次尝试将使用<code class="fe mt mu mv mj b">Threads</code>,我把它放在这里，因为这可以抓住一些初学者。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="66c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你可能认为这段代码没有问题，但这正是拥有一个单一核心基线对我们有所帮助的地方。如果你运行上面的代码，你会得到一个与我们简单的<code class="fe mt mu mv mj b">sum</code>解决方案不同的答案。事实上，每次运行这个函数时，您可能会得到不同的答案，而这个答案与真实答案相差甚远:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="c901" class="mn lg it mj b gy mo mp l mq mr">julia&gt; sum(ismultiple12.(1:N))<br/>833</span><span id="67ed" class="mn lg it mj b gy ms mp l mq mr">julia&gt; for _ in 1:10<br/>           println(sumupto(ismultiple12, N))<br/>       end<br/>263<br/>265<br/>329<br/>268<br/>322<br/>479<br/>382<br/>270<br/>484<br/>361</span></pre><p id="fb6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为我们的变量<code class="fe mt mu mv mj b">s</code>不是原子的。这意味着一个线程可能在另一个线程试图访问它的同时将其值从<code class="fe mt mu mv mj b">0</code>更新到<code class="fe mt mu mv mj b">1</code>。因此会发生以下情况:</p><ol class=""><li id="5549" class="nx ny it js b jt ju jx jy kb nz kf oa kj ob kn oc od oe of bi translated">当<code class="fe mt mu mv mj b">s</code>为0时，线程1获取其值</li><li id="5eaa" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn oc od oe of bi translated">Thread2得到了<code class="fe mt mu mv mj b">s</code>的值，它仍然是0</li><li id="d070" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn oc od oe of bi translated">Thread1加0 + 1并将<code class="fe mt mu mv mj b">s</code>的值更新为1</li><li id="da7d" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn oc od oe of bi translated">Thread2加0 + 1并将<code class="fe mt mu mv mj b">s</code>的值更新为1 — <strong class="js iu">它不知道Thread1已经给它加了1</strong>。</li></ol><p id="97c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以很明显我们应该两次给<code class="fe mt mu mv mj b">s</code>加1，但是我们搞砸了。你可以试着把<code class="fe mt mu mv mj b">s</code>做成一个原子数组并解决这个问题，但是这对我们的例子来说是混乱和不必要的，所以我会让你去阅读Julia文档中的相关内容。此外，还有一个更简单的方法…</p><h1 id="818c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">ThreadsX.jl简介</h1><div class="ol om gp gr on oo"><a href="https://github.com/tkf/ThreadsX.jl" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">GitHub - tkf/ThreadsX.jl:并行化的基本函数</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">添加前缀ThreadsX。如果支持的话，调用Base中的函数来获得一些加速。示例:要了解支持的功能…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ky oo"/></div></div></a></div><p id="ed65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ThreadsX.jl是一个开源的Julia包，同样令人印象深刻，使用简单。它以并行的方式实现了通用的基本Julia函数，例如<code class="fe mt mu mv mj b">sum</code>、<code class="fe mt mu mv mj b">map</code>、<code class="fe mt mu mv mj b">findall</code>、<code class="fe mt mu mv mj b">minimum</code>以及许多其他函数。使用这些超级简单，只需用<code class="fe mt mu mv mj b">ThreadsX</code>版本替换你的函数调用:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a557" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你不必担心比赛条件，只需申请和享受。🎉</p><blockquote class="mw mx my"><p id="b28f" class="jq jr mz js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated">感谢开发人员制作了这个包！在<a class="ae le" href="https://github.com/tkf/ThreadsX.jl" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看该包！</p></blockquote><h1 id="0c38" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">但是我们更快了吗？</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pd"><img src="../Images/f393f3b1b1276b5df4142aea77474607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dSaSPSvOREP8-RRs"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@pavlenko?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">михаилпавленко</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e72e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有两个并行的实现，但是我们有没有更快呢？<strong class="js iu">我们正在使用这些内核吗？</strong>让我们做一些基准测试:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="c384" class="mn lg it mj b gy mo mp l mq mr">julia&gt; <a class="ae le" href="http://twitter.com/btime" rel="noopener ugc nofollow" target="_blank">@btime</a> sum(ismultiple12, 1:N)<br/>  5.712 μs (4 allocations: 112 bytes)<br/>833</span><span id="d4c4" class="mn lg it mj b gy ms mp l mq mr">julia&gt; <a class="ae le" href="http://twitter.com/btime" rel="noopener ugc nofollow" target="_blank">@btime</a> ThreadsX.sum(ismultiple12, 1:N)<br/>  36.061 μs (423 allocations: 30.86 KiB)<br/>833</span></pre><p id="5b63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，我们得到了正确的答案，但实际上我们变得慢了很多。好像慢了6倍。这是因为我们需要协调所有这些核心。</p><p id="8e7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们犯了计算机编程的一个大罪:<strong class="js iu">过早优化</strong>！让这成为你的警告，如果你的功能足够快，你不需要让它更快。而是做一些有用的事情。😉</p><h1 id="706b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">是的，我们更快！</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pe"><img src="../Images/d32451dd8c31a4982097438a7fe0deea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jx3oHb0G9ARtOPo6"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@vr2ysl?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sammy Wong </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0e63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，为了演示一个更真实的场景，我们将把我们的函数复杂化。这将确保并行计算的<strong class="js iu">收益可以抵消内核协调的开销</strong>。我仍然想保持简单，所以我们将寻找增加每个整数的质数，直到10，000。为此，我们将使用Primes.jl，并且我们将在前期进行通常的单元测试:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0474" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这个新函数运行我们的sum函数会得到以下结果:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="1b11" class="mn lg it mj b gy mo mp l mq mr">julia&gt; @btime sum(num_prime_divisors, 1:N)<br/>  734.400 μs (10037 allocations: 1.23 MiB)<br/>24300<br/><br/>julia&gt; @btime ThreadsX.sum(num_prime_divisors, 1:N)<br/>  163.300 μs (10518 allocations: 1.26 MiB)<br/>24300</span></pre><p id="a1e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们获得了4.5倍的加速，这意味着我们的6个线程最终得到了利用。</p><h1 id="3c51" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">再举一个例子</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/0bea93b377390b5b1bd88843b501b3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*69MnGPlceoSPtUI1"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="eba0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从技术上讲，这不是本文所必需的，因为我已经展示了如何使用ThreadsX轻松地并行化一些单线程Julia函数。然而，有一个叫做<a class="ae le" href="http://exercism.org" rel="noopener ugc nofollow" target="_blank">exercism.org</a>的很棒的网站，上面有一些非常好的练习让你学习茱莉亚。我最喜欢的运动之一是拼字游戏评分。一件事接着一件事，我发现自己在问这样一个问题:“莎士比亚在拼字游戏《罗密欧与朱丽叶》中能得多少分？”。我们能同时计算他的分数吗？</p><p id="63a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要一些函数来计算每个字符的分数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d633" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的评分函数看起来有点复杂，所以让我解释一下:</p><ul class=""><li id="7811" class="nx ny it js b jt ju jx jy kb nz kf oa kj ob kn pg od oe of bi translated"><code class="fe mt mu mv mj b">mapreduce</code>将对每封信应用匿名函数<code class="fe mt mu mv mj b">letter -&gt; get(scores, letter, 0)</code>。这将尝试在我们的字典中查找每个字母，并把它变成一个数字。如果在字典里找不到，我们就用0代替。这个功能就是<code class="fe mt mu mv mj b">map</code>部分</li><li id="6f41" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn pg od oe of bi translated">下一个操作符<code class="fe mt mu mv mj b">+</code>意味着我们将把所有结果相加。这是<code class="fe mt mu mv mj b">reduce</code>的部分。这可以是对2个输入进行操作的任何函数。</li><li id="28f5" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn pg od oe of bi translated">第三个参数是我们想要减少的文本。</li><li id="1646" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn pg od oe of bi translated">最后，我们从0开始计数，因此我们的累加器应该从那里开始。这在向<code class="fe mt mu mv mj b">mapreduce</code>传递空字符串的情况下很有用。</li></ul><p id="e6b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当得到罗密欧与朱丽叶文本时，我不会费心去清理编辑的名字等，我宁愿只使用<code class="fe mt mu mv mj b">Pipe</code>包来写一些整洁的代码并继续工作:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7d24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经准备好并行运行它，因为ThreadsX已经实现了<code class="fe mt mu mv mj b">mapreduce</code>，所以这非常简单:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b48d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基准时间:</p><pre class="kp kq kr ks gt mi mj ph bn pi pj bi"><span id="02a3" class="pk lg it mj b be pl pm l pn mr">julia&gt; @btime score(romeoAndJuliet)<br/>  5.770 ms (136306 allocations: 2.48 MiB)<br/>184297<br/><br/>julia&gt; @btime score_parallel(romeoAndJuliet)<br/>  1.976 ms (227097 allocations: 3.91 MiB)<br/>184297</span></pre><h1 id="6e5a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="5114" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">总之，如果你想让Julia充分利用你的计算机内部的内核，可以看看ThreadsX.jl，它可以消除线程化代码的麻烦，并让你的速度得到快速提升。</p><p id="ec73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你还可以尝试很多其他功能，只需在REPL中键入<code class="fe mt mu mv mj b">ThreadsX.</code>并点击tab键，就可以看到他们还有什么功能。</p><pre class="kp kq kr ks gt mi mj ph bn pi pj bi"><span id="b426" class="pk lg it mj b be pl pm l pn mr">julia&gt; ThreadsX.<br/>Implementations  all              count            foreach          mapreduce        sort<br/>MergeSort        any              extrema          issorted         maximum          sort!<br/>QuickSort        collect          findall          map              minimum          sum<br/>Set              copy!            findfirst        map!             prod             unique<br/>StableQuickSort  copyto!          findlast         mapi             reduce</span></pre></div><div class="ab cl po pp hx pq" role="separator"><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt"/></div><div class="im in io ip iq"><p id="34ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你觉得exercism.org的练习很有趣，那就去看看吧。我还有一篇文章，是关于我在那里完成一系列Julia练习后学到的所有东西的:</p><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/15-things-i-learned-about-julia-after-completing-all-easy-exercism-tasks-b982643d79df"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">完成所有简单的锻炼任务后，我对Julia了解了15件事</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">Julia语言的一些很酷的特性</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ox l"><div class="pv l oz pa pb ox pc ky oo"/></div></div></a></div><blockquote class="mw mx my"><p id="607f" class="jq jr mz js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated">我写朱莉娅和其他很酷的东西。如果你喜欢这样的文章，请考虑关注我。要获得所有媒体文章的完整访问权限，包括我的文章，请考虑在此订阅<a class="ae le" href="https://niczky12.medium.com/membership" rel="noopener"/>。</p></blockquote></div><div class="ab cl po pp hx pq" role="separator"><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt"/></div><div class="im in io ip iq"><h1 id="9ec3" class="lf lg it bd lh li pw lk ll lm px lo lp lq py ls lt lu pz lw lx ly qa ma mb mc bi translated">分级编码</h1><p id="6183" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="be8d" class="nx ny it js b jt ju jx jy kb nz kf oa kj ob kn pg od oe of bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="2683" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn pg od oe of bi translated">📰查看<a class="ae le" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="2a14" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn pg od oe of bi translated">🔔关注我们:<a class="ae le" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae le" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae le" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="f223" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🚀👉<a class="ae le" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>