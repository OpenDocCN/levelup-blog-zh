<html>
<head>
<title>Comparing the JavaScript typeof and instanceof Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较JavaScript typeof和instanceof运算符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/comparing-the-javascript-typeof-and-instanceof-operators-8844f23633a?source=collection_archive---------2-----------------------#2020-03-17">https://levelup.gitconnected.com/comparing-the-javascript-typeof-and-instanceof-operators-8844f23633a?source=collection_archive---------2-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/162c0429b2e2433089a3400bd0a4909b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fMoXwv_CPqF2kYpC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@niklasgarnholz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Niklas Garnholz </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="56e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，有<code class="fe le lf lg lh b">typeof</code>和<code class="fe le lf lg lh b">instanceof</code>运算符。</p><p id="38f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们看起来很相似，但是他们做不同的事情。</p><p id="30f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看它们之间的区别以及如何使用它们。</p><h1 id="b891" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">运算符的类型</h1><p id="42c7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">typeof</code>算子主要用于获取原始值的类型。</p><p id="542d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有数字、字符串、符号、布尔值、bigint和未定义的值，我们可以用它们来检查。</p><p id="4797" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="43bf" class="mt lj it lh b gy mu mv l mw mx">console.log(typeof 1);</span></pre><p id="1d64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe le lf lg lh b">'number'</code>日志。</p><p id="45b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有变量会更有用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="98e4" class="mt lj it lh b gy mu mv l mw mx">let foo = 1;<br/>console.log(typeof foo);</span></pre><p id="3f33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用<code class="fe le lf lg lh b">typeof</code>操作符来检查数据类型<code class="fe le lf lg lh b">foo</code>，这也可以得到<code class="fe le lf lg lh b">'number'</code>。</p><p id="dcaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的是，它不能用于检查<code class="fe le lf lg lh b">null</code>类型。如果我们写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="14f9" class="mt lj it lh b gy mu mv l mw mx">console.log(typeof null);</span></pre><p id="8864" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe le lf lg lh b">'object'</code>。相反，我们应该使用<code class="fe le lf lg lh b">===</code>操作符来检查<code class="fe le lf lg lh b">null</code>，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ab31" class="mt lj it lh b gy mu mv l mw mx">foo === null</span></pre><p id="21f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以检查表达式的类型，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b864" class="mt lj it lh b gy mu mv l mw mx">let foo = 1;<br/>let bar = '1';<br/>console.log(typeof (foo + bar));</span></pre><p id="f5f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe le lf lg lh b">'string'</code>日志。</p><p id="22e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他示例包括检查布尔值:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9026" class="mt lj it lh b gy mu mv l mw mx">typeof false === 'boolean';<br/>typeof Boolean(0) === 'boolean';</span></pre><p id="12b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以检查数字，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="82bf" class="mt lj it lh b gy mu mv l mw mx">typeof Number('1') === 'number';<br/>typeof Number('foo') === 'number';<br/>typeof NaN === 'number';</span></pre><p id="39e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<code class="fe le lf lg lh b">NaN</code>和像<code class="fe le lf lg lh b">Number(‘foo’ )</code>一样返回<code class="fe le lf lg lh b">NaN</code>的计算也是<code class="fe le lf lg lh b">'number'</code>类型。我们应该用<code class="fe le lf lg lh b">Number.isNaN()</code>方法检查它们。</p><p id="eb58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要检查BigInt，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c972" class="mt lj it lh b gy mu mv l mw mx">typeof 2n === 'bigint';</span></pre><p id="e775" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了检查字符串，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="bf75" class="mt lj it lh b gy mu mv l mw mx">typeof '' === 'string';<br/>typeof 'foo' === 'string';</span></pre><p id="6872" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要检查符号类型，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="14e3" class="mt lj it lh b gy mu mv l mw mx">typeof Symbol() === 'symbol'<br/>typeof Symbol('bar') === 'symbol'</span></pre><p id="9481" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用<code class="fe le lf lg lh b">typeof</code>操作符来检查<code class="fe le lf lg lh b">undefined</code>，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3340" class="mt lj it lh b gy mu mv l mw mx">typeof undefined === 'undefined';<br/>let x;<br/>typeof x === 'undefined';</span></pre><p id="b649" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以使用它们来检查对象。然而，所有对象都返回类型<code class="fe le lf lg lh b">'object'</code>，所以这不是很有用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b44d" class="mt lj it lh b gy mu mv l mw mx">typeof new Date() === 'object';<br/>typeof /foo/ === 'object';</span></pre><p id="252e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">new</code>操作符创建的任何东西都属于<code class="fe le lf lg lh b">'object'</code>类型，包括<code class="fe le lf lg lh b">String</code>、<code class="fe le lf lg lh b">Boolean</code>和<code class="fe le lf lg lh b">Number</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3f80" class="mt lj it lh b gy mu mv l mw mx">typeof new String('foo') === 'object';<br/>typeof new Number(1) === 'object';</span></pre><p id="2c6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们将<code class="fe le lf lg lh b">typeof</code>操作符应用于正则表达式文字时，一些较老的浏览器会返回<code class="fe le lf lg lh b">‘function'</code>。然而，这在今天应该不是问题。</p><h2 id="482f" class="mt lj it bd lk my mz dn lo na nb dp ls kr nc nd lw kv ne nf ma kz ng nh me ni bi translated">例外</h2><p id="0a96" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">typeof document.all</code>总是返回<code class="fe le lf lg lh b">‘undefined'</code>，即使它在所有浏览器中都有定义。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/eb00742da9d43e1a4812bea4425d03ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zt76EiHLybzlibeR"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">米哈伊尔·瓦西里耶夫在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7d10" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">运算符的实例</h1><p id="47ee" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">instanceof</code>操作符测试构造函数的<code class="fe le lf lg lh b">prototype</code>属性是否出现在对象的原型链中。</p><p id="f395" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们可以使用它来检查对象是否是来自给定类或构造函数的构造函数。</p><p id="93de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一个对象是一个类或构造函数的实例，它返回<code class="fe le lf lg lh b">true</code>，否则返回<code class="fe le lf lg lh b">false</code>。</p><p id="80ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5b6c" class="mt lj it lh b gy mu mv l mw mx">class Foo {};<br/>let foo = new Foo();<br/>console.log(foo instanceof Foo);</span><span id="9f55" class="mt lj it lh b gy nk mv l mw mx">function Bar (){};<br/>let bar = new Bar();<br/>console.log(bar instanceof Bar);</span></pre><p id="c784" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后它们都从<code class="fe le lf lg lh b">console.log</code>输出<code class="fe le lf lg lh b">true</code>。</p><h2 id="3fea" class="mt lj it bd lk my mz dn lo na nb dp ls kr nc nd lw kv ne nf ma kz ng nh me ni bi translated">多个框架和窗口</h2><p id="dfeb" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当我们有多个框架和窗口时，<code class="fe le lf lg lh b">instanceof</code>操作符可能不会返回我们期望的结果，因为不同的执行上下文和不同的内置全局对象和构造函数。</p><p id="e488" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们检查一个变量是否是一个数组的实例，我们必须意识到这一点。</p><p id="e73c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，有一个<code class="fe le lf lg lh b">Array.isArray()</code>方法可以处理数组。</p><h2 id="23af" class="mt lj it bd lk my mz dn lo na nb dp ls kr nc nd lw kv ne nf ma kz ng nh me ni bi translated">用new创建的任何东西都可以用instanceof操作符来检查</h2><p id="2649" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">instanceof</code>用于检查使用<code class="fe le lf lg lh b">new</code>操作符创建的任何东西，包括字符串、布尔值和数字。</p><p id="c709" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5ea1" class="mt lj it lh b gy mu mv l mw mx">let foo = new String('foo');<br/>console.log(typeof foo);<br/>console.log(foo instanceof String);</span></pre><p id="4fe7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们从第一个<code class="fe le lf lg lh b">console.log</code>得到<code class="fe le lf lg lh b">'object'</code>，第二个得到<code class="fe le lf lg lh b">true</code>。</p><p id="c9f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为我们创建了一个<code class="fe le lf lg lh b">String</code>对象的实例，而不是原始值字符串，即使我们可以以同样的方式使用原始字符串和字符串对象。</p><h2 id="f4e9" class="mt lj it bd lk my mz dn lo na nb dp ls kr nc nd lw kv ne nf ma kz ng nh me ni bi translated">对象文字</h2><p id="532b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">不是用<code class="fe le lf lg lh b">new</code>操作符创建的对象文字是<code class="fe le lf lg lh b">Object</code>的实例。</p><p id="9906" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1a68" class="mt lj it lh b gy mu mv l mw mx">console.log({} instanceof Object);</span></pre><p id="463f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe le lf lg lh b">true</code>输出。</p><p id="5aac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有对象都是<code class="fe le lf lg lh b">Object</code>的实例，同时也是创建它们的构造函数的实例。例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="207d" class="mt lj it lh b gy mu mv l mw mx">let date = new Date();<br/>console.log(date instanceof Object);<br/>console.log(date instanceof Date);</span></pre><p id="b094" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">两个<code class="fe le lf lg lh b">console.log</code>都输出<code class="fe le lf lg lh b">true</code>，因为<code class="fe le lf lg lh b">date</code>既是<code class="fe le lf lg lh b">Date</code>构造函数的实例，所有非原始对象都是<code class="fe le lf lg lh b">Object</code>的实例。</p><h1 id="9d19" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="5227" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">typeof</code>和<code class="fe le lf lg lh b">instanceof</code>操作符完全不同。<code class="fe le lf lg lh b">typeof</code>返回它所操作的实体的类型。</p><p id="3aea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一个对象是从给定的构造函数创建的，则返回<code class="fe le lf lg lh b">true</code>，否则返回<code class="fe le lf lg lh b">false</code>。</p><p id="fd9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有非原始对象都是<code class="fe le lf lg lh b">Object</code>的实例，所以总是返回<code class="fe le lf lg lh b">true</code>。</p></div></div>    
</body>
</html>