<html>
<head>
<title>React &amp; Rails Auth From Scratch using JWT Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JWT第一部分从头开始进行React &amp; Rails验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-rails-full-auth-from-scratch-using-jwt-part-i-963c4b83cbe8?source=collection_archive---------5-----------------------#2021-03-06">https://levelup.gitconnected.com/react-rails-full-auth-from-scratch-using-jwt-part-i-963c4b83cbe8?source=collection_archive---------5-----------------------#2021-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c8b86ba73f26f6397353f7471f235133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BqqzpviM04gqW3j0JoHIw.jpeg"/></div></div></figure><div class=""/></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="42db" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">先决条件:</p><p id="10f0" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><a class="ae lg" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank">反应</a>安装完毕</p><p id="7ae2" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><a class="ae lg" href="https://guides.rubyonrails.org/getting_started.html" rel="noopener ugc nofollow" target="_blank">轨道</a>安装完毕</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h2 id="3bdb" class="lh li je bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">开始使用:</h2><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/622554fc17384aa1b7eae07259dace28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*Q6JClfFgs2G5C4tvoOdcEw.png"/></div></figure><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mf"><img src="../Images/0cb7cae23ea5da981deb1ec2c4c68289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jmlw5DiXyz2UT45aYpsirw.png"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="f762" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们将首先通过创建用户模型、控制器、迁移以及打开必要的路径来构建我们的Rails后端。要做到这一点，请确保cd进入我们的rails项目auth_backend。要一次性轻松完成这项工作，我们只需运行:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mg"><img src="../Images/837360842eef65bdeb4d3207f3d649fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ObCjvStgxMUyvMulAFgrfg.png"/></div></div></figure><p id="947c" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这将创建上面列出的所有内容，但是在我们开始之前，我们还需要做一些其他的事情。首先，我们将通过运行以下命令将JWT添加到我们的gem文件中:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mh"><img src="../Images/0c882c0f974782d719d293336ac00cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHCosm7GOIwMlG8GlBRowg.png"/></div></div></figure><p id="5d93" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">打开Gemfile后，您会看到它已经被添加。在Gemfile中，您还需要取消bcrypt和rack-cors的注释。这样做将确保我们的用户能够有一个安全的密码，并给你交叉引用的能力。请注意，并非所有的Gemfiles都附带rack-cors，在这种情况下，请跳到下一节。您还需要确保您的origin和resource设置为all，简称为*。您的cors.rb文件位于config/initializer中，应该是这样的:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/6008d89c585a617ec6dc05b567da7b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*0SIDHxYSZcX1Fr-NdWo27w.png"/></div></figure><p id="e52b" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您的Gemfile不包含rack-cors，我们需要进行一点额外的设置。首先，您需要将rack-cors添加到您的gem文件中。为此，我们只需运行:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mj"><img src="../Images/73cd88438c5605a860690ca7f8922ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zu56wb5sTjp_cWu1HPO2Q.png"/></div></div></figure><p id="8d46" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您想再次检查rack-cors是否添加正确，您可以检查您的gem文件。所有新增加的宝石将会在底部。</p><p id="e733" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这样做之后，我们需要进入config文件夹，打开application.rb。我个人把它放在类Application &lt; Rails:: Application的下面，但是如果需要的话，可以在类内随意调整位置。为此，我们需要添加以下代码:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/85c5a8334f264cf660bf3800d2551b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*nSnOrfBnScK449JKu97dpg.png"/></div></figure><p id="61e3" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">确保它被放置在您的后端模块中</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/2ae739a9a608dc04acc3e43f0cac0385.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*02dn_E5fMci8d9D0kbvOXw.png"/></div></figure><p id="b6c3" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个过程的最后一步是转到我们的application_controller.rb，它位于我们的app/controller文件夹中。您应该只看到一个空类，但是我们需要添加下面的代码行来防止rails令牌问题。</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/a77b4e8246da8cf5c6fedee1d0875b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*czb4WJlR8P9EG8N3HqTjiQ.png"/></div></figure><p id="cb04" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在进行了添加这些新的依赖项所需的更改之后，我们将安装这些新添加的gem，并运行我们的rails迁移。为此，我们只需在终端中运行:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mn"><img src="../Images/92a326c25d79a9edea15fc6d971e43e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DFFJwSvcqOLjU_AeEAvtQ.png"/></div></div></figure><p id="efb3" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mo"><img src="../Images/41656cf60419111200b85dc8e92e767a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIczyQqIF3ULI5erhzIz0w.png"/></div></div></figure><p id="88ad" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们现在需要做的最后一件事是确保我们的用户有一个安全的密码。这都是由bcrypt gem处理的，但是我们需要添加一行代码。在您的应用程序文件夹中，向下滚动到您的模型文件夹并打开您的用户模型。您需要添加的只是has_secure_password。它应该是这样的:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/c24df2d30597484b4d9f18e6128cc3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*_lDWoZbMgHwAB1t8YNYCaw.png"/></div></figure><p id="291a" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我强烈建议在你的终端上打开两个标签，这将允许我们同时运行后端服务器(Rails)和前端服务器(React)。如果您像我一样喜欢在VScode中编码或使用ConEmu终端，请不要担心。</p><p id="66e7" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在VScode中，在你的终端中，你可以通过简单地点击新建终端按钮a +和终止终端按钮垃圾桶之间的按钮来“拆分”你的终端。这将使您可以使用两个终端进行任何调试。使用ConEmu就简单多了，您只需要在该目录中创建另一个选项卡。</p><p id="5bff" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">此锅炉铭牌的副本可在<a class="ae lg" href="https://github.com/TheRealKevBot/Auth_Boiler_Plate" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="7c79" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在分割你的终端后，一个在你的auth_backend目录中，另一个在你的auth_frontend目录中。在各自的终端中运行:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi gj"><img src="../Images/2cec4181beb18d46b3efd372508caa9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjCWSWWTNzlej5cH-sR9zw.png"/></div></div></figure><p id="a103" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">和</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mq"><img src="../Images/b7d04707c29c401200b3420494497171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1BLRwlFU-KK3zgHHmxo2w.png"/></div></div></figure><p id="f245" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">注意，你应该总是在你的前端之前启动你的后端服务器，因为rails将默认为localhost:3000。React也希望这样做，但是如果使用了以前的端口，它将适应在localhost:3001上启动。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="fdae" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">一旦我们的后端和前端服务器启动并运行，我们可以分别访问<a class="ae lg" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>和<a class="ae lg" href="http://localhost:3001" rel="noopener ugc nofollow" target="_blank"> http://localhost:3001 </a>。既然我们已经运行了前端和后端服务器，我们现在不必担心它们。</p><p id="7bf3" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在查看我们的前端页面时，我们看到了这个可爱的自动生成的react显示页面。如前所述，我们需要编辑App.js，它位于auth_frontend目录下的src文件夹中。对于这个例子，我们将不使用钩子，而是使用类和函数组件。</p><p id="e04d" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们需要做的第一步是将App变成一个类。为此，我们必须记住从react导入组件并呈现我们的返回。此外，我们还将删除div应用程序中的所有html元素，以及徽标导入，因为我们不再需要它们。我们最好现在就将用户的状态设置为一个空对象。</p><p id="180a" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">您的代码应该是这样的:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/67b41a83ca552fd2096d56288a068011.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*QU2i38Dk9NInDRXMNPv8aA.png"/></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="233c" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们有了空白画布，我们可以开始创建我们的注册表单。首先，我们需要在src文件夹中创建一个名为components的新文件夹。在这个文件夹中，我们将创建一个名为SignUp.js的文件，它将保存我们的注册表单。一旦创建，我们将使它成为一个类组件。您的代码应该是这样的:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/c8c4855c1cc3a25f2e0d79e1b99d61fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*YiplmUpRB7r2M1JOF7nH7Q.png"/></div></div></figure><p id="6ad7" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们需要为我们的用户提供一些输入，我们碰巧刚刚为rails创建了这些输入。我们需要为用户需要的所有内容创建一个输入，如用户名、密码、名字和姓氏。在我们的表单中，我们将为每一个创建标签和输入。我们还将添加一个额外的输入作为我们的提交按钮。您的代码应该是这样的:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/859ecb26dfa1ad8a50df458b027ac92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*r-NR335bumkuL1B6MR_9zQ.png"/></div></figure><blockquote class="mu mv mw"><p id="6f7e" class="ki kj mx kk b kl km kn ko kp kq kr ks my ku kv kw mz ky kz la na lc ld le lf im bi translated">请注意，我使用了密码输入类型password。这将掩饰或隐藏屏幕上看到的值。</p></blockquote><p id="6656" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因为我们使用的是一个受控的表单，所以我们需要为每个输入添加状态和道具。尤其重要的是，您的状态键名称要与您的输入名称直接匹配，否则您将面临一些问题。同样重要的是，我们的输入值被设置为state。为此，我们将输入值设置为this.state.the inputs name。到目前为止，您完成的表单应该是这样的:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f3a7b8e785faf33cd0ed942d5dcc5a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*jI1CeBrREpEBJTo2drGdJA.png"/></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="c5f7" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们将创建一个名为handleChange的函数，你猜对了，它将处理我们的on change事件，我们将把它放在我们的每个输入上。我们可以单独设置每个输入的状态，但是我的一个好朋友，独一无二的达蒙·齐沃斯，教了我一种将四个独立的功能合并为一个的方法，这就是设置匹配名称的重要性发挥作用的地方。</p><p id="9414" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们的handleChange函数将从接受事件作为参数开始。我们将设置我们的键来接受事件目标名称，我们的值将是事件目标值。您的功能应该是这样的:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/74d68a0e46d682dabea467b8611457ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*AxXdPDLFC0KZ0UUnEMTfwg.png"/></div></figure><p id="56cd" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了更好地理解这个函数，我们将进一步对它进行分解。设置状态的关键是我们的输入名称，它恰好与我们的状态属性完全匹配。因此，由于我们的动态名称匹配方案，我们现在可以为每个输入重用这个函数。</p><p id="11d8" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们现在需要向所有的文本输入添加一个on change事件，这样我们的新函数就可以实际运行了。每个输入都应该有这样的onChange附加项:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/89b205f377851de5697114a7db26e306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*CIhKeXpcpH-g6dicLKrz1A.png"/></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="939b" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在，我们已经准备好了所有的功能，看起来我们的主要问题是让它显示在页面上，因为在之前对App.js进行删除后，它应该是空白的。现在，这似乎是显而易见的，但我们需要将我们的注册表单导入到我们的App.js中，并将我们的新注册组件放在我们的div中。您的App.js应该如下所示:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/2f988e743f0909dd08038d89afdf7135.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*StLuYEYybx-GIIB1ykw2-Q.png"/></div></figure><p id="bd11" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">刷新后，你的网页应该显示一个非常基本和丑陋的注册表单，但不用担心，我会给你提供一些css来帮助你。首先，我们将转到App.css文件，删除所有内容并从头开始。由于我们的注册表单是我们的应用程序的一部分，我们可以直接从out App.css对其进行样式化。请确保您的css文件匹配以获得最佳结果:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/81e56d1af68db411af6511d3c9189593.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*74O4o7tBWW3YT6XIwrEY7g.png"/></div></figure><p id="4124" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们已经有了一些看起来还不错的东西，让我们继续让我们的表单实际做一些事情，给它一些功能。为此，我们将把注意力转回到SignUp.js上，并在表单上放置一个on submit事件，这样我们就可以对该状态做一些事情。例如，将它设置为我们实际用户的…在我们的提交事件中，我们希望放置一个handleSubmit，这是我们将构建的另一个函数。您的表单添加应该如下所示:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7fb418f28483e6e95ad6bef48faeca97.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*8lTmAc6Ncf3dG24Iv-CKQA.png"/></div></figure><p id="90bd" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在handleChange函数的正下方，我们将构建handleSubmit函数来捕获注册表单的状态。我们将在App.js中构建真正的函数，所以让我们快速切换到那里，创建一个名为signUp的匿名函数。在这个函数中，我们将设置用户的状态，并将该用户存储在我们的后端，但首先让我们实际上对我们的后端进行一些添加。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="5bb1" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了让这个注册功能进入高速档，我们需要在我们的用户控制器的后端添加以下内容。我们将首先定义一个索引方法，这不是必需的，但却是查看后端信息的好方法。然后，我们将需要定义我们的创建方法，该方法实际上允许我们创建我们的用户。最后，我们将创建一个私有方法来存储用户的参数。虽然这可以在create方法中定义，但它增加了额外的安全层。完成更改后，您的代码看起来应该是这样。</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ad11b2874be1156c5f8bbfedc56b68ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*uKZ-hPmcE0Tbdjzyrvpq4w.png"/></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="94d9" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在终于到了将所有这些绑成一个漂亮、整洁的蝴蝶结的时候了。让我们回到我们的前端，进入App.js中的注册功能。我们将获取我们的后端，特别是我们的用户所在的位置。这也是您可以去的地方，检查您的数据库中当前有哪些用户，<a class="ae lg" href="http://localhost:3000/users" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/users</a>。我们的基本获取将包含一个post方法，带有通常的头，以及一个需要包含后端所期望的内容的主体。这很关键，因为如果你的键和值不匹配，你会收到一个错误。</p><p id="eb5d" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">紧盯哪个是JavaScript，哪个是ruby。这可以通过将ruby放在snake_case中，将JavaScript放在camelCase中轻松实现。最重要的是，在获取结束时，我们需要解析我们的响应，然后设置用户的状态。要完成所有这些，您的注册函数应该是这样的:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d72921d704577183940a0a705955fc56.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*EbG7UpX_vASBytBbQSZ3pA.png"/></div></figure><p id="6845" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们已经完成了注册功能，我们将使用turnery操作进行一些条件渲染，如果用户处于状态，将显示一个简单的欢迎页面。如果没有，我们将看到注册表单，这样我们就可以进入该页面。我们还将把注册函数传递给注册表单组件，这样我们就可以调用它来完成表单。您需要在App.js上的div之间放置以下代码:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/a33d28fd347e5dce4ac93837023e9988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*ev4bm3gnjoxNicS9bwoREw.png"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="5763" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们已经可以访问SignUp.js中的注册函数，我们将完成handleSubmit函数。它需要接受事件，就像我们的handleChange函数一样。我们还需要防止默认，所以表单不会自动提交自己，因为默认是提交。通过将我们的注册函数作为道具传递到handleSubmit中，我们可以调用它来从我们的参数中设置用户的状态。您的句柄提交代码应该如下所示:</p><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5e2fb5537a3b8e06a8dc8ad0bdc0eaec.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*GdOJrTRV8MW_lQ9ueVKjjQ.png"/></div></figure><p id="c917" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">恭喜你成功了！如果您正确地遵循了所有步骤，您应该能够注册，然后会看到您的登录页面。要再次检查您的用户是否确实访问了后端，您可以再次访问<a class="ae lg" href="http://localhost:3000/users" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/users</a>，在那里您将能够查看所有注册了您的应用程序的用户。</p><p id="82b4" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果你想看第一部分已完成的回购，你可以在这里找到<a class="ae lg" href="https://github.com/TheRealKevBot/Auth_Part-I_Complete" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5604" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果你喜欢本演练的第一部分，请加入我的第二部分，我们将学习如何认证我们的新用户<a class="ae lg" href="https://real-kevbot.medium.com/react-rails-full-auth-from-scratch-using-jwt-part-ii-1da2b54b7cb1" rel="noopener">这里</a>！！！</p></div></div>    
</body>
</html>