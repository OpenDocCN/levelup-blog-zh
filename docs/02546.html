<html>
<head>
<title>What Is Event Driven Architecture, and When Should I Use It?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是事件驱动架构，我应该什么时候使用它？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-event-driven-architecture-and-when-should-i-use-it-1ea9987b85d?source=collection_archive---------0-----------------------#2020-03-21">https://levelup.gitconnected.com/what-is-event-driven-architecture-and-when-should-i-use-it-1ea9987b85d?source=collection_archive---------0-----------------------#2020-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ef0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">克雷格·戈登-佩恩@beardy.digital </h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/d987b2cb4e596727597379065e2e889c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P1X-2-o-DsgVzI--.jpg"/></div></div></figure><p id="c377" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">事件驱动架构是一种软件架构范例，它促进事件的产生、检测、消费和反应。</p><h1 id="895c" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">事件驱动架构是如何实现的，什么时候使用它？</h1><p id="7549" class="pw-post-body-paragraph kw kx it ky b kz mk ju lb lc ml jx le lf mm lh li lj mn ll lm ln mo lp lq lr im bi translated">事件驱动架构与微服务齐头并进。当一个动作发生时，一个事件被创建，然后这个事件被用来驱动任何等待该事件发生的事物的决策。</p><p id="035a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">服务不再绑定在一起，因为在发布订阅类型模型中，调用者不再同步调用被调用者。相反，被调用者以一种最终一致的方式作用于一个事件。</p><p id="2409" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">正因为如此，事件驱动的架构可能更可靠，因为它们不必立即对服务调用做出反应(允许服务失败直到成功)，但是不太容易预测何时执行了某个动作(出于同样的原因)。</p><p id="c223" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">事件驱动架构的一个简单例子是Amazon。如果你曾经在一个繁忙的时期，比如黑色星期五，在亚马逊购物，有可能订购一件商品，但事后只会收到一封电子邮件，说你订购的商品实际上缺货。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/4000cb8acef5fb00d6da41494b148f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FLp7yj84T0trjYN9.jpg"/></div></div></figure><p id="d725" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果您从事件驱动架构的角度来考虑这一流程，它可能以如下方式工作:</p><ul class=""><li id="c517" class="mp mq it ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">客户订购商品，并发布一个订购事件</li><li id="ac87" class="mp mq it ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">股票服务订阅了事件，但是当它处理事件时，它检查股票，现在它是0</li><li id="39e6" class="mp mq it ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">然后，库存服务发布缺货事件</li><li id="bf89" class="mp mq it ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">电子邮件服务订阅该事件，并向客户发送电子邮件，解释该商品缺货。</li></ul><p id="ef9a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">事件驱动架构可以使用队列作为与发布/订阅模型相结合的后备模型。这是为了在链中的某个服务无法处理事件时保证事件消息的传递。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nd"><img src="../Images/355f8d9aedf631979b307bc187c8b5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uFL0EYqQcQTdzgcs"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">照片由<a class="ae ni" href="https://unsplash.com/@ed259?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ed 259 </a>在<a class="ae ni" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="bdb4" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">事件驱动架构的利弊</h1><p id="87e1" class="pw-post-body-paragraph kw kx it ky b kz mk ju lb lc ml jx le lf mm lh li lj mn ll lm ln mo lp lq lr im bi translated">有几个原因可以解释为什么使用事件驱动架构比其他架构更有优势。</p><p id="0296" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><strong class="ky iu">松耦合</strong> —服务不需要相互依赖。这适用于不同的因素，例如传输协议、可用性(服务在线)和正在发送的数据。消费者仍然需要知道如何解释事件或消息，因此在两个服务之间仍然应该使用严格的契约，但是契约的实现细节应该无关紧要。</p><p id="b0a9" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><strong class="ky iu">可扩展性</strong> —由于服务不再耦合，服务1的吞吐量不再需要满足服务2的吞吐量。这有助于降低成本，因为服务不再需要24/7在线，并且可以利用无限扩展的无服务器计算。</p><p id="0fca" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><strong class="ky iu">异步</strong>——因为服务不再依赖于同步返回的结果，所以可以使用一劳永逸的模型，这可以大大加快流程。这可能有不利的一面，这将在下面概述。</p><p id="0fb1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><strong class="ky iu">时间点恢复</strong> —如果事件由队列支持或维护某种历史，则可以重放事件，甚至可以及时返回并恢复状态。</p><p id="366a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">使用事件驱动架构也有缺点。</p><p id="0e33" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><strong class="ky iu">流程的过度工程化</strong> —有时一个服务对另一个服务的简单调用就足够了。如果一个流程使用事件驱动架构，它通常需要更多的基础设施来支持它，这将增加成本(因为它需要一个排队系统)</p><p id="ee9a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><strong class="ky iu">不一致性</strong> —因为流程现在依赖于最终的一致性，所以通常不支持ACID(原子性、一致性、隔离性、持久性)事务，所以对重复或无序事件的处理会使服务代码更加复杂，并且更难测试和调试所有情况。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nj"><img src="../Images/f032ef429d6cde32e4da9e41a27cd022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*53tXfUSaCxStSt5G"/></div></div></figure><h1 id="21d4" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">当事件改变时会发生什么？</h1><p id="240e" class="pw-post-body-paragraph kw kx it ky b kz mk ju lb lc ml jx le lf mm lh li lj mn ll lm ln mo lp lq lr im bi translated">想象一下，当我想要添加或更改事件的合同时，例如，在一个订单事件中，将数量从整数更改为浮点数。</p><p id="363c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果订户没有预料到这种变化，这种情况会使订户崩溃。</p><p id="b974" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">你需要修改活动的合同，以防止这种破损。一个很好的经验法则是，通常对合同的任何添加都是可以的，但是如果要删除或更改某些内容，则必须发布活动的新版本，并且订阅者也期待新的活动合同。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nj"><img src="../Images/430d0bc391c5b7f79ffd7c873f2bb1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*27yF1QiNV1PW8EMr"/></div></div></figure></div></div>    
</body>
</html>