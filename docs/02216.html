<html>
<head>
<title>Using Templates and Generics in C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C #中使用模板和泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-templates-and-generics-in-c-968da223154d?source=collection_archive---------2-----------------------#2020-02-27">https://levelup.gitconnected.com/using-templates-and-generics-in-c-968da223154d?source=collection_archive---------2-----------------------#2020-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/444ac886822a4f50caab2a1bc0086610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*7PY7AkVSyOJ7WrcoMWcyQg.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">学分:PamperedChef</figcaption></figure><p id="b8c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">泛型是编程语言的语法组件，可以重复用于不同类型的对象。通常，泛型采用类或函数的形式，它们将类型作为参数。泛型通常也被称为<code class="fe kw kx ky kz b">templates</code>，在C++中被正式称为模板。通常，缺乏泛型或模板的编程语言会受到批评。能够在类型之间共享过程代码极大地提高了质量和开发。本文描述了在pure <code class="fe kw kx ky kz b">C</code>中实现类似模板功能的一些技术和方法。</p><h1 id="05fa" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是类型？</h1><p id="67dc" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">泛型和模板允许类型使用相同的代码。但是，在像C这样的语言中，真正构成“类型”的是什么呢？与其他面向对象的编程语言不同，C没有构造和销毁对象的固有概念。语言中也没有固有的继承概念。c将类型视为内存中具有特定已知数据格式的部分。正式来说，类型分为两类，<em class="md">标量</em>和<em class="md">聚集</em>类型。</p><p id="1d14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">标量类型只保存一个数据项，如<code class="fe kw kx ky kz b">int</code>或<code class="fe kw kx ky kz b">char*</code>。这些通常是整数或指针类型。聚合类型保存一个或多个数据值，如任何数组或结构。类型<code class="fe kw kx ky kz b">void*</code>代表一种特殊的指针类型，它可以指向任何类型，标量或聚集。事实上，<code class="fe kw kx ky kz b">void*</code>有时可以作为通用代码的一种形式。<code class="fe kw kx ky kz b">string.h</code>中相当多的函数使用<code class="fe kw kx ky kz b">void*</code>来读写不同大小的内存块。</p><p id="42ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，C #中的类型必须具有:</p><ul class=""><li id="0161" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">已知大小</li><li id="3ecc" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">一种已知的格式</li></ul><p id="2c90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两种类型可能大小相同，但格式不同。比如，在大多数平台上，<code class="fe kw kx ky kz b">float</code>和<code class="fe kw kx ky kz b">int</code>。它们通常具有相同的大小，因此，<code class="fe kw kx ky kz b">sizeof(int) == sizeof(float)</code>也是如此。然而，它们有完全不同的格式，因此当用特定的函数调用时会有不同的行为。</p><h1 id="7b01" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">静态模板</h1><p id="2675" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">可以在C中实现的主要模板类型是静态模板。静态模板是在编译时创建的，并且不执行运行时大小检查，因为它们将这一责任转移给了编译器。C中使用的静态模板类似于C++语言中的模板，因为它们依赖于实际的类型成员，例如在<code class="fe kw kx ky kz b">struct</code>的情况下。在C #中，创建静态模板的唯一本地方法是使用宏。</p><p id="03c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="md">注意:使用“静态”一词仅表示“在编译时”。与C关键字</em> <code class="fe kw kx ky kz b"><em class="md">static</em></code> <em class="md">无关，表示一个函数有内部联动</em></p><p id="f1dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们观察静态模板的最简单形式，定义宏:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="2c3d" class="na lb iq kz b gy nb nc l nd ne">#define DEF(type, name, val) type name = val <br/>DEF(int, foo, 5); <br/>// Then used as normal <br/>printf("%d", foo);</span></pre><p id="30a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上述的<code class="fe kw kx ky kz b">DEF</code>宏可以使用任何类型的宏，这些宏可以通过<code class="fe kw kx ky kz b">=</code>操作符初始化。它还可以通过以下方式发挥作用:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="d120" class="na lb iq kz b gy nb nc l nd ne">DEF(const char*, txt, "foo");</span></pre><p id="e1bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模板允许定义基本类型变量所需的代码被<em class="md">一般化</em>和<em class="md">抽象化</em>。目标是使代码在不同类型之间是可共享的和相似的。然而，这个例子是琐碎的，因为它只提供了很少的简化。真正的力量来自执行更复杂任务的代码。</p><h1 id="3857" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为每一个</h1><p id="7b99" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在C语言中，<code class="fe kw kx ky kz b">for</code>循环会导致大量的代码非常类型化，导致冗余代码和巨大的源文件。在宏形式的静态模板的帮助下，我们可以使c语言中的循环更加流畅。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="8449" class="na lb iq kz b gy nb nc l nd ne">for (int i = 0; i &lt; 10; i++) { <br/>    printf("%d", i); // ... // <br/>}</span></pre><p id="f285" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有四种不同的语法成分。变量的初始化、终止条件、增量步骤，最后是循环中每次增量执行的实际代码块。给定这四个元素，我们可以构造一个宏，作为一个<code class="fe kw kx ky kz b">foreach</code>循环。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="a47d" class="na lb iq kz b gy nb nc l nd ne">#define FOREACH(type, start, end, fn) \ <br/>        for (type _foreach_var = start; _foreach_var != end; _foreach_var++) { \ <br/>        fn(_foreach_var); \ <br/>                 }</span></pre><p id="5bf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模板适用于原始类型<em class="md">范围</em>，其中有一个已知类型、一个起始值、一个结束值和一个适用于该范围每个成员的期望函数。选择名称<code class="fe kw kx ky kz b">_foreach_var</code>是为了有目的地减少与宏参数之一冲突的可能性。请注意，<code class="fe kw kx ky kz b">fn</code> <em class="md">不一定是函数。在这种情况下，您可以为<code class="fe kw kx ky kz b">fn</code>传递一个宏，它也被称为高阶宏:</em></p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="509f" class="na lb iq kz b gy nb nc l nd ne">#define PRINT_INT(n) printf("%d", n) <br/>// use FOREACH <br/>FOREACH(int, 0, 5, PRINT_INT)</span></pre><p id="f020" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">For循环模板也可以用在<em class="md">在一个集合类型的内容上迭代</em>的循环上，比如一个数组。对于宏来说，使用聚合类型有时甚至更直接，因为我们可以从聚合类型中获得比标量类型更多的信息。使用<code class="fe kw kx ky kz b">sizeof</code>操作符，我们可以确定一个数组中元素的数量。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="c804" class="na lb iq kz b gy nb nc l nd ne">long nums[4]; <br/>const size_t nums_count = sizeof(nums) / sizeof(nums[0]); printf("%zu\n", nums_count); <br/>// 4</span></pre><p id="caa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">sizeof</code>操作符总是以字节为单位获取<code class="fe kw kx ky kz b">value</code>的大小。这意味着传递数组将计算该数组的总大小。这不适用于指针类型，因为任何指针的大小总是与<code class="fe kw kx ky kz b">sizeof(void*)</code>相同。可以从数组中推断出的这些信息可以用来制作一个强大的“foreach”模板:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="0f20" class="na lb iq kz b gy nb nc l nd ne">#define FOREACH(arr, fn) \ <br/>         for (size_t _ind = 0; <br/>              _ind &lt; sizeof(arr) / sizeof(arr[0]); <br/>              _ind++) { \ <br/>       fn(arr[_ind]); \ <br/>}</span></pre><p id="2974" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的<code class="fe kw kx ky kz b">FOREACH</code>宏中，唯一需要的两个参数是数组本身、<code class="fe kw kx ky kz b">arr</code>和一些应用于<code class="fe kw kx ky kz b">arr</code>中每个元素的可调用参数。类型可以用来访问任何数组元素。我们不需要也传入<code class="fe kw kx ky kz b">arr</code>的类型，因为我们不需要它，我们可以让<code class="fe kw kx ky kz b">fn</code>处理它。</p><h1 id="bca3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">功能</h1><p id="ac50" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">静态模板也可以在C中实现，以体现整个功能。当期望的行为比面向循环的模板所能捕获的更复杂时，就需要这种泛型和模板化的方法。通常在C中，采用多种不同类型形式的参数将被赋予类型<code class="fe kw kx ky kz b">void*</code>，另一个<code class="fe kw kx ky kz b">size_t</code>参数表示<code class="fe kw kx ky kz b">void*</code>指向的内存大小。这种类型的函数定义用于标准库中，例如函数<code class="fe kw kx ky kz b">memcpy</code>和<code class="fe kw kx ky kz b">memset</code>。</p><p id="1a03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe kw kx ky kz b">void*</code>的一个问题是缺少类型检查。C语言中任何类型的地址都可以存储在<code class="fe kw kx ky kz b">void*</code>中，比如</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="4a90" class="na lb iq kz b gy nb nc l nd ne">int s = 3; <br/>char mes[50]; <br/>long b = 6754333; </span><span id="7a90" class="na lb iq kz b gy nf nc l nd ne">void* ps = &amp;s; <br/>void* pmes = mes; <br/>void* pb = &amp;b;</span></pre><p id="c040" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些都是有效的定义。编译器没有办法解释一个不正确的类型被传递给一个不同类型的<code class="fe kw kx ky kz b">void*</code>。因此，函数模板提供了一种限制泛型函数接受的类型范围的方法。首先，让我们看一个通过特定字段的值来比较两种聚合类型是否相等的示例:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b7d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的模板是一个宏，每次被调用时都会产生一个函数定义。该函数接受两个指定类型的<code class="fe kw kx ky kz b">const</code>指针，并返回比较<code class="fe kw kx ky kz b">field</code>的结果。所产生的函数名称的末尾附加了类型的名称。我们需要这个等式模板函数的每个定义都有自己的名字，因为C不允许函数有相同的名字和冲突的类型。这意味着，使用这个模板</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="4d03" class="na lb iq kz b gy nb nc l nd ne">FIELD_EQ(point_t, x)<br/>FIELD_EQ(foo_t, x)</span></pre><p id="8482" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上会分别产生<code class="fe kw kx ky kz b">FIELD_EQ_point_t</code>和<code class="fe kw kx ky kz b">FIELD_EQ_foo_t</code>。这里的优点是，我们可以为多种类型创建相同的函数，而无需多次显式写出这些函数。下面是一个既使用函数模板又调用生成函数的示例:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="aa3e" class="na lb iq kz b gy nb nc l nd ne">typedef struct { <br/>     int x;<br/>     int y; <br/>} point_t; </span><span id="ec67" class="na lb iq kz b gy nf nc l nd ne">FIELD_EQ(point_t, x) </span><span id="d172" class="na lb iq kz b gy nf nc l nd ne">int main(void) { <br/>     point_t f1 = {3, 5}; <br/>     point_t f2 = {3, 3}; <br/>     printf("result is %d\n", FIELD_EQ_point_t(&amp;f1, &amp;f2)); <br/>     return 0; <br/>}</span></pre><p id="a00d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种函数产生模式可用于在不同类型之间创建相同的C APIs。</p><h1 id="cc7f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结构</h1><p id="7182" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在C语言中，结构，简称为“结构”，是可以包含不同种类的命名数据字段的集合类型。与其他语言相比，<code class="fe kw kx ky kz b">struct</code>就像一个没有方法、构造函数和析构函数的对象。结构是由多种标量类型组成的格式化数据块。结构不同于其他语言中的对象，因为没有实现多态性的内置方法。也没有实现继承的本机方法，例如在父结构和子结构的理想情况下。</p><p id="5f76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解释编程语言，特别是Python，使用对象“头”方法。这意味着，任何被认为是语言的“对象”的结构，在其定义的开头都有一个特殊的字段集合，保存与结构标识相关的信息。这允许所有的结构被转换成一个公共的基本类型<code class="fe kw kx ky kz b">struct</code>，只要它们在定义任何其他特定字段之前携带这些字段。Python C API通过一个叫做<code class="fe kw kx ky kz b">PyObject_HEAD</code>的宏来完成这个任务。这个宏带有标识结构类型、大小等等的字段。</p><p id="d84a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个更基本的示例如下所示:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="71d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，<code class="fe kw kx ky kz b">obj_t</code>是所有其他<code class="fe kw kx ky kz b">obj_*_t</code>相关结构的基础<code class="fe kw kx ky kz b">struct</code>。它纯粹是用宏<code class="fe kw kx ky kz b">OBJECT_HEAD</code>定义的，保存了关于结构的类型信息。这个宏是一个模板，任何其他包含<code class="fe kw kx ky kz b">OBJECT_HEAD</code>的结构都可以被转换成<code class="fe kw kx ky kz b">obj_t</code>。这可以在<code class="fe kw kx ky kz b">struct</code>型<code class="fe kw kx ky kz b">obj_int_t</code>中看到。可转换为<code class="fe kw kx ky kz b">obj_t</code>的结构类型的创建可通过更高阶的宏模板简单实现:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="690d" class="na lb iq kz b gy nb nc l nd ne">#define OBJECT_START(name) \ <br/>            struct name { \ <br/>                  OBJECT_HEAD; </span><span id="ca6e" class="na lb iq kz b gy nf nc l nd ne">#define OBJECT_END(name) }; \ <br/>           typedef struct name name</span></pre><p id="944a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两个宏，<code class="fe kw kx ky kz b">OBJECT_START</code>和<code class="fe kw kx ky kz b">OBJECT_END</code>允许模板结构的更多标准类型定义。它们保证开始和结束宏之间的任何定义语句将形成一个<code class="fe kw kx ky kz b">obj_t</code>兼容类型。更重要的是，它确保了类型的名称将存在于<code class="fe kw kx ky kz b">struct &lt;name&gt;</code>和<code class="fe kw kx ky kz b">&lt;name&gt;</code>名称空间下。</p><h1 id="1aaf" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="c2c0" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">总的来说，用C实现模板可以使C代码可读性更好，冗余更少，更不容易出错。如果需要的话，它允许有效的开发，而不需要合并或切换到C++或具有内置模板系统的语言。在C中使用泛型和模板还可以使程序更加类型安全，并防止对内存的不当访问。</p></div></div>    
</body>
</html>