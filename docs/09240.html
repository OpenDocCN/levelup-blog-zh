<html>
<head>
<title>Modelling Saga as a State Machine : An orchestrator driven approach for managing distributed and long-running transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Saga建模为状态机:管理分布式和长时间运行的事务的orchestrator驱动方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/modelling-saga-as-a-state-machine-cec381acc3ef?source=collection_archive---------2-----------------------#2021-07-20">https://levelup.gitconnected.com/modelling-saga-as-a-state-machine-cec381acc3ef?source=collection_archive---------2-----------------------#2021-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b3df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章描述了在微服务生态系统中管理分布式和长时间运行的事务的架构和概念框架。本文主要讨论分布式事务面临的挑战以及如何有效地解决这个问题。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/edd320719e6a283574892e3f67cc5125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*ZbA4HrE9XKF4FziPs2MNfQ.png"/></div></div></figure><h1 id="843b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">概观</h1><p id="7c29" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">微服务，在其真正的上下文中，是一个分布式系统。一个事务被分配给多个服务，这些服务被顺序或并行调用以完成整个事务。在微服务架构中，单个服务中的事务使用ACID事务来提供数据一致性。然而，挑战在于处理跨多个服务的事务，在某些情况下需要很长时间才能完成。在这种情况下，应用程序必须使用复杂的机制来管理事务。</p><h1 id="71b4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">方案</h1><p id="f0ba" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">考虑一个使用微服务架构实现的简单机票预订场景。将会有一个微服务阻塞座位，另一个接受付款，最后，另一个微服务分配阻塞的座位，每个微服务实现一个本地事务。要成功完成旅行者的航班预订流程，必须完成所有三个步骤。如果任何一个步骤失败，前面完成的所有步骤都必须回滚。因为整个事务边界跨越多个服务和数据库，所以它被认为是一个分布式事务。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mb"><img src="../Images/f32bcc54ea4d39f31ed527260187b260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wcDVr4Crwo4FdG1TBwuduQ.png"/></div></div></figure><p id="9fe4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑通过微服务方法实现的订单履行的另一个场景。工作流事务从订单服务开始，首先创建订单，然后转到下一个服务进行支付，然后为事务创建发票，之后发送发货，最后订单交付并完成工作流，同样每个都实现本地事务。这里的订单处理实际上是分布式的，完成工作流程可能需要几天到几周的时间。这种事务可以称为长时间运行的事务，因为所有步骤不能一次执行，并且使用传统的ACID事务语义。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mc"><img src="../Images/25895b28ab36bc7a3db392a809f9f169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlzoRAvZIN0nNQeli0ZHHA.png"/></div></div></figure><h1 id="5329" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">挑战</h1><p id="7117" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">随着微服务架构的出现，关于分布式事务管理有两个关键问题:</p><ul class=""><li id="09f9" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">原子性:原子性意味着事务中的所有步骤都必须成功，或者如果某个步骤失败，那么之前完成的所有步骤都应该回滚。然而，在微服务架构中，一个事务可以由不同微服务处理的多个本地事务组成。因此，如果其中一个本地事务失败，如何回滚以前完成的成功事务？</li><li id="aae1" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">隔离:事务隔离级别指定了事务中一个语句可见的数据量，特别是当多个服务调用同时访问同一个数据源时。如果来自任何一个微服务的对象被持久化到数据库，而另一个请求同时读取相同的对象，那么服务应该返回旧数据还是新数据？</li></ul><p id="73bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这些问题并提供有效的事务管理能力，可以采用两种方法:</p><ul class=""><li id="645b" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">两阶段提交(2PC)</li><li id="00de" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">冒险故事</li></ul><h1 id="17e7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">2PC</h1><p id="a33e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">跨多个服务维护数据一致性的传统方法是使用分布式事务。这方面的实际标准是2PC(两阶段提交)。2PC确保事务中的所有参与者不是提交就是回滚。它分两个阶段工作，第一阶段称为准备阶段，控制节点询问所有参与节点是否准备好提交，第二阶段称为提交阶段，如果所有节点的回答都是肯定的，则控制节点要求它们提交，否则回滚。尽管2PC可以帮助在分布式系统中提供事务管理，但它也成为了单点故障，因为事务的责任落在了协调器的身上，而且这种协调器的典型实现本质上是同步的，这可能会导致未来吞吐量的降低。因此，2PC仍然有以下缺点:</p><ul class=""><li id="1d10" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">像MongoDB和Cassandra这样的现代NoSQL数据库不支持它们。</li><li id="85b3" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">像Apache Kafka这样的现代消息代理不支持它们。</li><li id="7133" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">同步IPC降低了可用性。</li><li id="bd42" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">所有的参与者都必须到场。</li></ul><h1 id="3d54" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">冒险故事</h1><p id="ac35" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">为了解决在微服务架构中维护数据一致性这一更复杂的问题，应用程序必须使用一种不同的机制，这种机制建立在松耦合、异步服务的概念之上。这就是传奇故事的由来。Saga是一种架构模式，它提供了一种优雅的方法来实现跨多个服务的事务，本质上是异步和反应式的。因此，可以将saga定义为事件驱动的本地事务序列，其中每个本地事务更新数据库并发布命令或事件来触发saga中的下一个本地事务。如果本地事务由于违反业务规则而失败，那么saga将执行一系列补偿事务，这些补偿事务将撤销之前的本地事务所做的更改。saga实现确保执行所有事务或撤消所有更改，从而提供原子性保证。将saga设计为状态机模型将提供处理隔离的对策。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mr"><img src="../Images/9d9289139db7edb0fd61328277a5b63d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xf7IsGyhejaCgB_-0fgrhQ.png"/></div></div></figure><h1 id="7774" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">传奇模式有什么帮助</h1><p id="572b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">使用微服务架构，单个业务流程将多个微服务集合在一起，以提供整体解决方案。使用微服务架构实现<strong class="jp ir"> ACID </strong>(原子性、一致性、隔离性、持久性)事务非常困难，在某些情况下是不可能的。例如，在前面提到的机票预订场景中，具有block seat功能的微服务不能获得支付数据库的锁，因为在大多数情况下它可能是一个外部服务。但是仍然需要某种形式的事务管理，这种事务被称为<strong class="jp ir"> <em class="kl">基本</em> </strong>事务:<strong class="jp ir"> B </strong>基本<strong class="jp ir"> A </strong>可用，<strong class="jp ir"> S </strong> oft状态，<strong class="jp ir"> E </strong>最终一致。必须采取补偿措施来恢复作为事务一部分发生的任何事情。下面，我们可以看到一个传奇故事是如何在前面提到的机票预订场景中可视化的。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ms"><img src="../Images/464dd6f1c3b2fba4e1605de8057ccbaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFdr3EFKIYRbnb_1ASODow.png"/></div></div></figure><h1 id="fa05" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">补偿交易</h1><p id="0dac" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当saga的某个步骤由于违反业务规则而失败时，saga必须通过执行补偿事务来显式撤销之前步骤所做的更新。假设一个saga的第(<em class="kl"> n </em> + 1)笔交易失败。之前的<em class="kl"> n </em>交易的影响必须撤销。从概念上讲，每个步骤Ti都有一个相应的补偿事务Ci，它撤消Ti的影响。要取消前<em class="kl"> n </em>步的效果，saga必须以相反的顺序执行每个Ci。步骤顺序是T1 … Tn，Cn … C1，如图所示。在本例中，Tn+1失败，这需要撤消步骤T1 … Tn。saga以与远期交易相反的顺序执行补偿交易:Cn … C1。对ci进行排序的机制与对ti进行排序没有任何不同。Ci的完成必须触发Ci-1的执行。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mt"><img src="../Images/4ce01e3df96468f3f28f274d45abba82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQEStGswSuaS2fLIuCgupA.png"/></div></div></figure><h1 id="9674" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">透视和可重试的交易</h1><p id="33ea" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">下表显示了航班预订过程中每一步的补偿交易。机票预订传奇的三个步骤被称为补偿交易，因为接下来的步骤可能会失败。还需要注意的是，并非所有步骤都需要补偿事务。在saga模式中还有两种其他的事务类型，一种是Pivot事务，它就像saga中的go/no-go点。如果pivot事务提交，saga将一直运行到完成。另一种是可重试交易<em class="kl">、</em>跟随枢纽交易并保证成功的交易。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mu"><img src="../Images/4ad4e160a5618ca918001418fc4d5ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KmfPn_F0TufOQSfv4sHdGQ.png"/></div></div></figure><h1 id="63ef" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">世家担保</h1><p id="37a5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">分布式传奇保证了以下两种结果之一。要么成功完成saga中的所有请求，要么执行请求及其补偿请求的子集。请求和补偿请求都需要遵守某些原则:</p><ul class=""><li id="4e8d" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">单个事务可以中止，并且必须是幂等的。</li><li id="4e04" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">补偿事务必须是幂等的、可交换的，并且不能中止(必须无限期重试，或者在必要时通过手动干预解决)。</li></ul><h1 id="98d9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Saga协调策略</h1><p id="b02e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">saga执行协调员(SEC)是实施成功Saga流程的核心组件。Saga协调可以在以下情况下实施:</p><ul class=""><li id="c159" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated"><strong class="jp ir">编排</strong> —在saga参与者之间分配决策和排序。换句话说，参与者在没有集中控制点的情况下交换事件，并且每个本地事务发布触发其他服务中的本地事务的域事件。虽然saga编排是简单可靠的基于事件的通信，但是它对于简单的用例是理想的，并且有一些限制，这使得它不是管理分布式事务的理想候选。基于编排的传奇很难理解，经常产生循环依赖，而且传奇参与者之间存在紧密耦合的风险。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/e9f74bd5e45c6e8f8425e01a58e623a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*mOJWSNV7E8j8OmlRbpKH2g.png"/></div></figure><ul class=""><li id="30ef" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated"><strong class="jp ir">编排— </strong>将saga的协调逻辑集中在一个saga orchestrator类中。saga协调人员向saga参与者发送命令，并对事件结果采取行动。orchestrator执行saga请求，存储和解释每个任务的状态，并使用补偿事务处理故障恢复。基于Orchestrator的sagas更适合复杂的事件处理，是管理分布式事务的理想选择。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/377935e9d20747acc139af7aa321ff2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*1hqTFjLEdUBpFqDOF-Td6w.png"/></div></figure><h1 id="8a51" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">佐贺管弦乐团</h1><p id="af78" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">正如Saga“编排”模式所建议的，有一个单一的编排器组件负责管理整个流程工作流。使用编排时，定义一个编排器类，它的唯一职责是告诉saga参与者做什么。saga orchestrator使用命令/异步回复式交互与参与者交流。为了执行saga步骤，它向参与者发送命令消息，告诉它要执行什么操作。saga参与者执行完操作后，会向编制者发送回复消息。然后，编排器处理该消息，并确定下一步执行哪个saga步骤。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mx"><img src="../Images/38c1d45f9bc0b0aa415c04c8485b311b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNu0uOIH1tj7xgC1_UHIBA.png"/></div></div></figure><p id="b836" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图显示了基于编排的航班预订传奇版本的设计。SagaOrchestrator组件对saga进行编排，该组件使用异步请求/响应调用saga参与者。Saga orchestrator跟踪流程，并通过命令生成器组件向Saga参与者发送命令操作，如SeatBlockingService和PaymentService，并通过事件处理器从其回复通道读取回复消息，然后确定saga中的下一步(如果有)。快乐日传奇之路的步骤如下:</p><ol class=""><li id="fd71" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk my mj mk ml bi translated">前端UI向saga orchestrator发送座位预订请求。</li><li id="c941" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">saga orchestrator启动新的工作流程，并向SeatBlockingService发送SeatBlockingCommand。</li><li id="c6fc" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">SeatBlockingService处理命令，并使用SeatBlockedEvent进行回复。</li><li id="ae61" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">saga orchestrator触发工作流中的下一个操作，并向PaymentService发送PaymentRequestCommand。</li><li id="89eb" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">PaymentService用PaymentSuccessEvent进行回复。</li><li id="00d4" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">然后，saga orchestrator向SeatAllocationService发送SeatAllocationCommand。</li><li id="893e" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">SeatAllocationService用SeatAllocatedEvent进行回复。</li><li id="d5ed" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">saga orchestrator结束事务并完成工作流程。</li></ol><p id="7a7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，由于SeatBlockingService、PaymentService或SeatAllocationService中的一个故障，整个航班预订场景可能会失败。为了有效地管理工作流和处理故障，建议将saga建模为状态机，因为它描述了所有可能的场景，并让orchestrator确定需要执行什么操作。</p><h1 id="03ed" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">作为国家机器的佐贺</h1><p id="57a6" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">将saga orchestrator建模为状态机不仅是管理分布式事务的有效方法，也是支持长期运行的业务事务的有效方法。状态机由一组状态和一组由事件触发的状态之间的转换组成。每个转换都可以有一个动作，对于一个saga来说就是调用一个saga参与者。状态之间的转换由saga参与者执行的本地交易的完成触发。本地事务的当前状态和特定结果决定了状态转换和要执行的动作(如果有的话)。因此，使用状态机模型使得设计、实现和测试sagas变得更加容易。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mz"><img src="../Images/feab281c639b0f8872f5797181c6f8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Du-Nc0UCLoaRAqQp4PGFoQ.png"/></div></div></figure><p id="56cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图突出显示了机票预订的状态机模型。该状态机由许多状态和转换组成，包括:</p><ul class=""><li id="a116" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">订单打开—初始状态。Saga在工作流程开始时设置此状态。</li><li id="4e13" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">阻塞座位—在此状态下，saga等待SeatBlockingService阻塞座位进行预订。</li><li id="de39" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">授权支付saga正在等待PaymentService对支付授权命令的回复。</li><li id="62f3" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">分配座位—支付成功后，等待SeatAllocationService分配座位。</li><li id="efe1" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">反向支付-如果座位分配失败，saga将发送退款请求。</li><li id="ca2a" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">解锁席位—如果支付授权失败，saga将向解锁席位发送失败事件。</li><li id="53cf" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">订单完成——表示传奇成功完成的最终状态。</li><li id="9725" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">订单被拒绝——最终状态，表示订单被其中一个参与者拒绝。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi na"><img src="../Images/d2fb0fc93bc9cfe8979141427e70c551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7gSdsTjVWmA1fOIRnm5Vw.png"/></div></div></figure><p id="b5f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，saga工作流可以重新设计为saga状态机，如下所示。saga orchestrator链接到一个状态机，该状态机负责通过状态管理器API管理事务状态。除此之外，它还负责将事务状态存储在持久数据存储中，以确保系统故障发生时的恢复。因此，saga状态机有责任完成整个业务事务，或者让系统处于已知状态，以便它可以确定潜在执行下一个动作状态或补偿活动的顺序，无论发生的事务是自然分布的还是长期存在的。</p><h1 id="5116" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">优势和潜在使用案例</h1><ul class=""><li id="237a" class="md me iq jp b jq lw ju lx jy nb kc nc kg nd kk mi mj mk ml bi translated"><strong class="jp ir">更简单的依赖关系—</strong>saga orchestrator调用saga参与者，但参与者不调用orchestrator。因此，编排者依赖于参与者，而不是相反，所以没有循环依赖。</li><li id="7ff0" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">耦合度更低— </strong>每个服务都实现了一个由orchestrator调用的API，因此它不需要知道saga参与者发布的事件。</li><li id="e363" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">关注点分离—</strong>saga协调逻辑在saga orchestrator中本地化。领域对象更简单，不知道它们参与的故事。</li><li id="0baf" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">数据一致性— </strong>保持多个微服务之间的数据一致性，无需紧密耦合。</li><li id="abaf" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">开发人员体验— </strong>设计允许开发人员只关注saga参与者的业务逻辑，并简化saga orchestrator上有状态工作流的实施。</li></ul><p id="cd3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以实现这种实现的几个潜在用例:</p><ol class=""><li id="27f9" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk my mj mk ml bi translated">订单管理系统</li></ol><ul class=""><li id="e522" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">电子商务</li><li id="b78d" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">食品配送</li><li id="b4cc" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">机票预订</li><li id="050c" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">酒店/出租车预订</li></ul><p id="6c98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.结算交易。</p><h1 id="bf27" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">指导方针和建议</h1><p id="ef15" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如果我们正在设计和构建orchestrator驱动的saga以支持分布式和长时间运行的事务，建议遵循以下指导原则:</p><ol class=""><li id="d1aa" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk my mj mk ml bi translated">Orchestrator应该只负责管理事务和状态，这里不应该添加任何业务逻辑。业务逻辑应该在单个服务参与者中定义。</li><li id="9d28" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">所有进出orchestrator的事件和命令应该只携带事务数据，而不是引用数据。</li><li id="8757" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">使用异步风格的消息传递在服务之间进行通信。</li><li id="88a0" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">如果使用像Kafka这样的消息代理，实现幂等性和弹性状态检查。</li><li id="99ef" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk my mj mk ml bi translated">适用于设计CQRS中的命令端(写模型)和事件源架构。</li></ol><h2 id="7371" class="ne kz iq bd la nf ng dn le nh ni dp li jy nj nk lm kc nl nm lq kg nn no lu np bi translated"><strong class="ak">参考文献</strong></h2><p id="0534" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><a class="ae nq" href="https://learning.oreilly.com/library/view/microservices-patterns/9781617294549/" rel="noopener ugc nofollow" target="_blank">T3【https://learning . oreilly . com/library/view/microservice-patterns/9781617294549T5】</a></p><p id="d575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nq" href="https://developer.ibm.com/depmodels/microservices/articles/use-saga-to-solve-distributed-transaction-management-problems-in-a-microservices-architecture/" rel="noopener ugc nofollow" target="_blank"><em class="kl">https://developer . IBM . com/dep models/micro services/articles/use-saga-to-solve-distributed-transaction-management-problems-in-a-micro services-architecture</em></a></p></div></div>    
</body>
</html>