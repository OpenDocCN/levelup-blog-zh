<html>
<head>
<title>Improving JavaScript Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高JavaScript性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improving-javascript-performance-f34ef3ed903b?source=collection_archive---------19-----------------------#2020-10-26">https://levelup.gitconnected.com/improving-javascript-performance-f34ef3ed903b?source=collection_archive---------19-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b3ebd84f71f192eaa4ed7fd21bed66b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzAXxknvpvGP3fCHtK-spw.jpeg"/></div></div></figure><div class=""/><p id="5d7c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JavaScript已经成为领先的脚本语言之一。JavaScript无处不在——在客户端和服务器端。它也是GitHub上最流行的语言之一。</p><h1 id="b9d1" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">循环—如果不需要，请避免使用它们</h1><p id="78d1" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">JavaScript中的循环被认为不是一件好事，因为它会给浏览器带来额外的压力。循环中的代码量应该尽可能少。我们在循环中做的工作越少，循环就越快。此外，我们还可以采用一些简单的技巧，比如，我们可以将数组的长度存储在不同的变量中，而不是在循环的每次迭代中读取长度。这对于优化我们的代码和以更有效的方式运行有很大的帮助。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/9212e3c59daf19a6071e27ba27508c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*_fZ3CHilyPK4Gsip"/></div></figure><h1 id="5669" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">最小化DOM访问，以获得响应更快的页面</h1><p id="4b51" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">任何发生在JavaScript本地环境之外的交互都会导致显著的性能延迟和不可预测性。例如，如果主机浏览器在环境之外与DOM对象进行多次交互，这将降低我们的性能，因为浏览器每次都必须刷新。为了避免这种情况，我们应该尽量减少DOM访问。有几种方法可以实现这一点。例如，我们可以存储对浏览器对象的引用，或者减少DOM遍历的总次数。</p><h1 id="c402" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">异步编程</h1><p id="d306" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在任何应用程序中，我们都需要对多个API进行几次内部调用来获取数据。做到这一点的一种方法是为每种功能配备单独的中间件。然而，JavaScript是单线程的，有许多同步组件。这些组件具有冻结应用程序的能力。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/cfb2d8ab2810e37b801099d02ad1db2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/0*AY8ZwvQiG8gMsAoZ.png"/></div></figure><p id="19ec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JavaScript的async.js特性在这种情况下非常方便。它有助于高效管理异步代码。这导致异步代码被推送到事件队列，在那里它在所有其他代码执行之后触发。然而，即使有JavaScript的异步特性，仍然有可能使用外部库，这可能会无意中导致同步阻塞调用。这可能会对应用程序的整体性能产生负面影响。</p><p id="a1c2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，为了以最好的方式解决这些问题，我们应该总是在代码中使用异步API。然而，我们也需要记住异步编程的复杂性，因为它对于新生来说是一个挑战。</p><h1 id="a080" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">问题检测</h1><p id="94f4" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Lighthouse是一款广泛用于网页的工具。它有助于可访问性、审计性能、SEO和其他最佳实践。类似地，<a class="ae mi" href="https://developers.google.com/speed/pagespeed/insights/" rel="noopener ugc nofollow" target="_blank"> Google PageSpeed </a>旨在帮助JavaScript开发人员了解网站的改进和性能优化领域。</p><p id="c087" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Chrome的主菜单中，有一个“更多工具”选项，显示每个标签的内存和CPU使用情况。我们还可以使用Chrome或Firefox中的Performance视图进行更详细的分析。有了它，我们能够分析各种指标，例如:</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mj"><img src="../Images/430f9936c36d0024dcc45952d4a27c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hiXNeh3RAZNIr4Qg.png"/></div></div></figure><p id="3687" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想潜得更深，我们可以使用<a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/navigation-timing-browser-api-track-and-improve-website-performance-in-javascript-f1dbfb45612"> <strong class="kd jf">导航定时API </strong> </a>。它提供了可以用来衡量网站性能的数据。</p><h1 id="3e3d" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">变量的范围</h1><p id="7215" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">每当我们调用某个函数时，用来定义该函数的变量都存储在里面。变量可以分为两种类型。</p><ul class=""><li id="e48e" class="mk ml je kd b ke kf ki kj km mm kq mn ku mo ky mp mq mr ms bi translated">局部变量:只在自身内部定义的变量。</li><li id="53fc" class="mk ml je kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">全局变量:在整个脚本中使用的变量。</li></ul><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi my"><img src="../Images/55c8be702227bc6fc219500e1f5e467d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CEnkPGCbr-fENOsA.png"/></div></div></figure><p id="262e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在函数调用期间，JavaScript编译器对正在使用的变量进行范围查找。随着作用域链中作用域数量的增加，访问当前作用域之外的变量所需的时间也会增加。</p><p id="8fbc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是引擎访问全局变量比访问局部变量花费更长时间的原因。这意味着如果我们在本地定义大多数变量，变量搜索所需的时间将会迅速减少。最终，它将提升应用程序的整体性能。</p><h1 id="7d3b" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">事件委托</h1><p id="cd64" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">只有当我们使用事件委托时，使用单个事件处理程序来有效地处理多个事件才是可能的，这最终有助于有效地管理整个页面的一类事件。如果我们不使用事件委托，几个事件处理程序的存在会降低大型web应用程序的性能，在最坏的情况下，它可能会停止应用程序。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/89c7deda684b00fadd394cd4ba920e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WL4FJB3f11zk5iyi.jpg"/></div></div></figure><p id="1d53" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">活动授权附带许多额外福利，例如:</p><p id="8c5b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">需要管理的功能更少</p><p id="3a3e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">处理所需的内存更少</p><p id="02c4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">DOM和代码之间的联系越来越少，等等。</p><h1 id="03a4" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">对象缓存</h1><p id="62e5" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">缓存是将频繁访问的数据临时存储在缓存中的过程，以便您可以在后续请求中重用它。</p><p id="aaf0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是缓存可以帮助减轻服务器负载的地方。它存储每个请求的副本，然后在下一次相同的请求到达时，它检查缓存并从那里提供服务。如果没有副本，请求会被发送到服务器进行处理和编译，在返回浏览器的途中，会在缓存中存储一个副本。</p><p id="bc30" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">我们可以通过两种方式做到这一点。</strong></p><blockquote class="na nb nc"><p id="b682" class="kb kc nd kd b ke kf kg kh ki kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx ky im bi translated"><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" rel="noopener ugc nofollow" target="_blank"> HTTP协议缓存</a>。</p><p id="f5fe" class="kb kc nd kd b ke kf kg kh ki kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx ky im bi translated">或者JavaScript缓存API，可以通过服务人员安装来完成。</p></blockquote><p id="fe64" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过在对该对象的引用中使用变量，或者简单地将重复访问对象存储在用户定义的变量中，我们可以显著提高性能。</p><h1 id="afe1" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">限制内存使用</h1><p id="70ff" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">限制内存使用是JavaScript开发人员必须掌握的主要技能之一。原因是，当我们的应用程序在设备上运行时，很难确定设备所需的确切内存。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/569f775d3f71c1c0b40bf9d46749b2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/0*JDUpX8teQ6-Z6_jY.png"/></div></figure><p id="5c6f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果应用程序请求为浏览器保留新的内存，那么浏览器的垃圾收集器就会开始工作，并尝试释放一些内存。JavaScript代码必须等到有内存的时候。如果这种情况持续发生，那么它会降低页面速度。</p><h1 id="87a6" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">JavaScript延迟加载</h1><p id="a836" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">很明显，用户希望页面能够快速加载。然而，没有必要在页面初始加载时所有的功能都可用。如果用户执行各种功能，比如单击和更改标签，那么您可以将该功能的加载推迟到初始页面完成加载之后。</p><p id="229c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法帮助我们避免加载和编译JavaScript代码，否则这些代码会保存页面的初始显示。一旦页面被加载，我们就可以开始加载用户以后需要的所有功能，当它开始与应用程序交互时。根据Google的RAIL模型，我们应该在50毫秒内延迟加载。这将避免用户与页面交互的任何影响。</p><h1 id="49d0" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">对内存泄漏说不</h1><p id="e3f1" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在内存泄漏的情况下，页面将使用越来越多的内存，并最终占用设备中所有可用的内存。这将对整体性能产生不利影响。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/aa2dc841dd5b73d156f46770eac2291b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/0*Ognw9GXn2vuM4V1r.png"/></div></figure><p id="5fb1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一些工具可以用来分析内存泄漏问题。Chrome Dev Tools就是这样一个工具，它在performance选项卡中记录时间线。通常，从页面中移除的DOM片段会导致内存泄漏，因为它们有一些负责引用的变量，这些变量会阻止垃圾收集器清除它们。</p><h1 id="8a41" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用各种优化</h1><p id="e87e" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">为了用最优的数据结构解决所有的任务，我们应该总是使用计算复杂度最低的算法。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/cd43cb3358cd8b298a3b76eebabbaed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M29nQOjxPMAuVMv_.jpg"/></div></div></figure><ul class=""><li id="ec1f" class="mk ml je kd b ke kf ki kj km mm kq mn ku mo ky mp mq mr ms bi translated">避免递归。</li><li id="8961" class="mk ml je kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">使用搜索数组获取基于另一个数组的值，而不是基于case语句或开关的值。</li><li id="82ca" class="mk ml je kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">为所有重复的函数输入计算、调用和变量</li><li id="525f" class="mk ml je kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">重写算法，用更少的计算得到相同的结果。</li><li id="41ae" class="mk ml je kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">通过利用处理器推测性执行来创建可能为真的条件。</li></ul></div></div>    
</body>
</html>