<html>
<head>
<title>Goodbye Lerna (sorta), hello Bazel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">再见，勒纳，你好，巴泽尔</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/goodbye-lerna-sorta-hello-bazel-f47ef1a01f73?source=collection_archive---------7-----------------------#2020-07-16">https://levelup.gitconnected.com/goodbye-lerna-sorta-hello-bazel-f47ef1a01f73?source=collection_archive---------7-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a557908a488080a6415034e4728060fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnCS09nWSrDjhtYEHZHV9Q.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">你好，巴泽尔</figcaption></figure><div class=""/><h1 id="f371" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">语境</h1><p id="afd6" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">作为<a class="ae ly" href="https://github.com/formatjs/formatjs" rel="noopener ugc nofollow" target="_blank"> formatjs &amp; react-intl </a>的维护者，我使用<a class="ae ly" href="https://lerna.js.org/" rel="noopener ugc nofollow" target="_blank"> lerna </a>来管理monorepo，它包括几个任务:</p><ol class=""><li id="b5fd" class="lz ma jf lc b ld mb lh mc ll md lp me lt mf lx mg mh mi mj bi translated">管理npm依赖项安装</li><li id="eb8f" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mg mh mi mj bi translated">按照拓扑排序的顺序运行npm脚本，例如<code class="fe mp mq mr ms b">build</code>或<code class="fe mp mq mr ms b">test</code></li><li id="073a" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mg mh mi mj bi translated">创建新的GitHub版本</li><li id="530f" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mg mh mi mj bi translated">生成变更日志</li><li id="4aa3" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mg mh mi mj bi translated">发布到npm</li></ol><p id="82fa" class="pw-post-body-paragraph la lb jf lc b ld mb lf lg lh mc lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">Lerna非常擅长完成所有这5项任务，但是随着monorepo的增长和<code class="fe mp mq mr ms b">build</code>时间的增加，我想我们可能需要更适合选择性构建的东西。在这篇博文中，我将向你介绍我放弃lerna作为构建系统而选择bazel的决定。</p><h1 id="fc9f" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">首先，结果</h1><p id="0ce5" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们现在有了一个带缓存的GitHub动作工作流:</p><ul class=""><li id="716f" class="lz ma jf lc b ld mb lh mc ll md lp me lt mf lx mw mh mi mj bi translated">CI:我们与旧系统不相上下，具有更高的正确性和再现性(大约14分钟)。</li><li id="4575" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mw mh mi mj bi translated">选择性构建(本地):我们的构建步骤从9分钟变成了50-10分钟(取决于发生了什么变化)。</li><li id="8745" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mw mh mi mj bi translated">选择性测试(本地):我们的构建步骤从4分钟变成了20-5分钟(取决于发生了什么变化)。</li><li id="5958" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mw mh mi mj bi translated">大大减少了“<strong class="lc jg">在我的机器上工作</strong>”的问题。</li></ul><h1 id="0c74" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">我们的构建设置</h1><p id="a2ed" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们的monorepo包含8个ECMA 402<a class="ae ly" href="https://formatjs.io/docs/polyfills" rel="noopener ugc nofollow" target="_blank">Intl poly fill</a>，每个都有自己的数据集。我们大部分的<code class="fe mp mq mr ms b">build</code>时间都花在处理<a class="ae ly" href="http://cldr.unicode.org/" rel="noopener ugc nofollow" target="_blank"> CLDR </a> &amp; <a class="ae ly" href="https://www.iana.org/time-zones" rel="noopener ugc nofollow" target="_blank"> IANA时区数据库</a>上。预处理步骤允许我们的运行时实现具有高性能，同时保持符合ECMA402规范。</p><p id="b1ce" class="pw-post-body-paragraph la lb jf lc b ld mb lf lg lh mc lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">我的第一个设置是处理来自源代码的所有东西，包括像IANA这样的远程工件获取。这是没有规模的。在一个冷的GitHub Action CI构建中，我们的<code class="fe mp mq mr ms b">build</code>步骤可能需要30分钟，瓶颈是<code class="fe mp mq mr ms b">zdump</code>对于所有IANA时区大约需要20分钟。这使得DevEx非常痛苦，因为一个小的doc更改会导致长时间的CI等待。</p><p id="a099" class="pw-post-body-paragraph la lb jf lc b ld mb lf lg lh mc lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">我的第二次尝试是提交几个生成的工件，以及IANA数据库中的vendoring。这在大规模CI构建中并不少见。<code class="fe mp mq mr ms b">git</code>有内置的支持，通过<code class="fe mp mq mr ms b">.gitattributes</code>对它们进行不同的标记，GitHub也通过<code class="fe mp mq mr ms b">linguist-generated</code> &amp; <code class="fe mp mq mr ms b">linguist-vendored</code>提供支持。这极大地减少了我们在冷CI构建上的构建时间到大约15分钟，没有“黄金”测试来验证生成的工件是最新的&amp;确定性的(为了这样做，我们必须重新运行生成步骤，这仍然需要花费很长时间)。</p><h1 id="af5a" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">我们的测试设置</h1><p id="8808" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们的<code class="fe mp mq mr ms b">test</code>设置非常标准:</p><ul class=""><li id="7222" class="lz ma jf lc b ld mb lh mc ll md lp me lt mf lx mw mh mi mj bi translated"><code class="fe mp mq mr ms b">jest</code>中的单元测试</li><li id="5925" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mw mh mi mj bi translated">由<a class="ae ly" href="https://saucelabs.com/" rel="noopener ugc nofollow" target="_blank">酱料实验室</a>提供支持的<code class="fe mp mq mr ms b">karma</code>中的硒测试</li><li id="1c69" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mw mh mi mj bi translated"><code class="fe mp mq mr ms b">test262-harness</code>中的Test262符合性测试</li></ul><p id="2b26" class="pw-post-body-paragraph la lb jf lc b ld mb lf lg lh mc lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">令人惊讶的是，我们的瓶颈不是Selenium，而是<code class="fe mp mq mr ms b">test262</code>，因为它是一个相当全面的测试套件。对于那些不熟悉<code class="fe mp mq mr ms b">test262</code>的人来说，TC39符合性测试套件确保任何规范实现都是符合规范的。为了防止污染，它还为每个测试旋转新的v8上下文，使其正确而缓慢(我们仍然会超时)。</p><p id="7110" class="pw-post-body-paragraph la lb jf lc b ld mb lf lg lh mc lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">排除偶尔的超时，我们的测试大约需要4分钟。</p><h1 id="43c2" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">选择性构建</h1><p id="877f" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">选择性构建基本上是只重建系统中发生变化的部分，从而提高性能的能力。由于潜在的缓存问题和构建环境设置中的差异，通常需要权衡正确性。除了<code class="fe mp mq mr ms b"><a class="ae ly" href="https://github.com/lerna/lerna/tree/master/core/filter-options#--since-ref" rel="noopener ugc nofollow" target="_blank">--since</a></code>标志之外，Lerna本身并没有很好的(或者任何)支持。这使用<code class="fe mp mq mr ms b">git</code> ref作为过滤机制来过滤已更改的内容。然而，这有几个问题:</p><ol class=""><li id="4eea" class="lz ma jf lc b ld mb lh mc ll md lp me lt mf lx mg mh mi mj bi translated">执行单位仍然是包。</li><li id="1f14" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mg mh mi mj bi translated">可传递依赖是选择加入的。这导致dep的缺失构建，导致整个构建失败。包括那些基本上成为一个完整的重建。</li><li id="36c3" class="lz ma jf lc b ld mk lh ml ll mm lp mn lt mo lx mg mh mi mj bi translated">修改<code class="fe mp mq mr ms b">git</code>输出的<code class="fe mp mq mr ms b">git</code>别名的问题(我们的一个合作者就是这样)。</li></ol><p id="4eb0" class="pw-post-body-paragraph la lb jf lc b ld mb lf lg lh mc lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">在高层次上，检测变更的底层机制(例如<code class="fe mp mq mr ms b">git</code> ) &amp;重建粒度(包)都存在问题。</p><h1 id="f15e" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">向<a class="ae ly" href="https://bazel.build/" rel="noopener ugc nofollow" target="_blank">巴泽尔</a>问好，具体是<a class="ae ly" href="https://github.com/bazelbuild/rules_nodejs" rel="noopener ugc nofollow" target="_blank"> rules_nodejs </a></h1><p id="1d9b" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">Bazel是一个密封的建筑系统，可重复，确定性和快速。它的核心是<code class="fe mp mq mr ms b">rule</code>(如何构建东西)&amp; <code class="fe mp mq mr ms b">file</code>(嗯，文件)。构建系统的机制用<strong class="lc jg">源文件</strong>和<strong class="lc jg">生成文件</strong>之间的关系表示，用<strong class="lc jg">规则</strong>表示。Bazel维护自己的输出目录，不会污染源代码树(除非您告诉它这样做)。因为它是密封的，它可以安全地缓存构建输出&amp;测试结果，允许我有选择地重新构建&amp;只重新测试发生变化的部分。</p><p id="2f5e" class="pw-post-body-paragraph la lb jf lc b ld mb lf lg lh mc lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">bazel解决的另一类问题是最大化再现性，这有效地消除了“<strong class="lc jg">在我的机器上工作</strong>的问题。我们已经习惯了典型的<code class="fe mp mq mr ms b">rm -rf node_modules &amp;&amp; git clean -fd</code>，然后重新安装所有的东西并尝试重新运行，这已经成为一种常态。这个问题在OSS中变得更加困难，因为合作者之间的交流是一个挑战。</p><p id="02b9" class="pw-post-body-paragraph la lb jf lc b ld mb lf lg lh mc lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">在加入Dropbox之前，我没有听说过bazel，老实说，我并不喜欢它。它有一个相当高的学习曲线，从定制语言<a class="ae ly" href="https://docs.bazel.build/versions/master/skylark/language.html" rel="noopener ugc nofollow" target="_blank"> Starlark </a>到它的哲学<a class="ae ly" href="https://docs.bazel.build/versions/master/bazel-vision.html" rel="noopener ugc nofollow" target="_blank">再到它的设置。它不能很好地与现有的web构建生态系统互操作，主要是由于现有构建工具链中隐含的目录假设。然而，一旦我完成了学习曲线的第<strong class="lc jg">部分</strong>，结果就相当惊人了。</a></p><h1 id="8965" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">最后的话</h1><p id="b98f" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">让我们明确一点，bazel并不能解决所有的用例。如果您的构建/测试相当快，并且您熟悉现有的工具链，那么没有理由转换。如果你正在处理一个构建/测试循环缓慢的monorepo，这可能会大大加快你的速度。</p><p id="e57c" class="pw-post-body-paragraph la lb jf lc b ld mb lf lg lh mc lj lk ll mt ln lo lp mu lr ls lt mv lv lw lx ij bi translated">我们目前的设置在https://github.com/formatjs/formatjs的<a class="ae ly" href="https://github.com/formatjs/formatjs" rel="noopener ugc nofollow" target="_blank">结束。这个社区非常有帮助，也非常活跃，所以如果你感兴趣的话，可以随时加入bazel的Slack。</a></p></div></div>    
</body>
</html>