<html>
<head>
<title>Devastatingly Dynamic Programming for Directionless Dummies in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中无方向虚拟对象的毁灭性动态编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/devastatingly-dynamic-programming-for-directionless-dummies-in-javascript-1f1bd128b081?source=collection_archive---------13-----------------------#2020-03-19">https://levelup.gitconnected.com/devastatingly-dynamic-programming-for-directionless-dummies-in-javascript-1f1bd128b081?source=collection_archive---------13-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/42f6153a30b82d7683cd508b7896f30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*2w5eCnz76GKzGToXjsowKQ.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我也是伦敦政坛的发电机</figcaption></figure><p id="ec16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在疫情大灾难期间，我试图变得更聪明，但我发现了许多令人分心的事情。我已经开始和朋友们一起参加Zoom会议和Google Hangouts。我对乔布斯做过一些电话采访和视频采访。我在布鲁克林区绕着我的滑板车走了很长一段路。我甚至开始学习<a class="ae kz" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">角形</a>和<a class="ae kz" href="https://medium.com/p/aa0f7b76f235/" rel="noopener">烧瓶</a>。</p><p id="2447" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，在这个病毒横行的环境中，除了不要让医院挤满病人和彻底洗手之外，唯一重要的事情是什么呢？找工作。</p><p id="9148" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也就是说理解编程和面试问题。例如，您是否知道在JS“for”循环中，您可以通过在循环前的变量中定义其长度来增强其性能？这是因为”。长度”实际上是一个在每次迭代中都会被调用的函数！</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi la"><img src="../Images/af7016bf85b42c25a8bedc481f89551e.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*fXXWhX2m90VvKIxkE5AH_g.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">优化了！</figcaption></figure><p id="8b0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是也有一些方法可以让昂贵的功能变得更快！我说的是<strong class="kd iu">记忆</strong>和<strong class="kd iu">制表</strong>。如果你有“重叠的子问题和一个最优的子结构”,这些都是可能发生的效果，但是这真的令人困惑！</p><p id="d6a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有另一种说法:<strong class="kd iu">如果你正在做一个包括许多较小的相同计算的和或积的计算，你可以存储小计算的结果，这样你就不必一直做它们。</strong></p><p id="c919" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一些斐波纳契数列<a class="ae kz" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank">的代码，摘自柯尔特·斯蒂尔在Udemy </a>上的算法课程，这就是我如何学习大部分算法的。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/74bc391f8b380f690fc50e0a6de7c022.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*riCnVq2qiTf-XsPm9n2HMw.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我不能撒一个谎…哦，不，不，不。</figcaption></figure><p id="153a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波那契数列</a>非常有趣，在设计和自然中也被用作<a class="ae kz" href="https://en.wikipedia.org/wiki/Golden_ratio" rel="noopener ugc nofollow" target="_blank">“黄金比例”</a>，但我们在这里不讨论这个！</p><p id="ca8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本上，<strong class="kd iu">斐波纳契数列中的每个数字都是数列中后面两个数字的和，第一个和第二个数字都是1 </strong>。</p><p id="6023" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是你所需要知道的，希望这在上面的代码中是显而易见的，除了它使用了<a class="ae kz" href="https://www.geeksforgeeks.org/recursion/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"/></a>，这是你应该检查的，因为它在面试问题中也非常常见</p><p id="be3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么问题出在哪里？我们谈完了，对吗？</p><p id="d9ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哦，错了。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/53254bd478819854611012fb380ca512.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*MRHpk-Fbmh9DXlbo.jpg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">归威利所有。</figcaption></figure><p id="b0d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们用甚至像“100”这样的正常值来调用上面的函数，会发生什么？根据您的系统或可用内存，它可能会工作，但您也可能会得到一个<a class="ae kz" href="https://en.wikipedia.org/wiki/Stack_overflow" rel="noopener ugc nofollow" target="_blank">“堆栈溢出”</a>或甚至崩溃您的浏览器！这是因为<strong class="kd iu">递归</strong>导致太多的计算同时发生。</p><p id="6b8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其实这个解的<a class="ae kz" href="https://medium.com/javascript-in-plain-english/an-intro-to-big-o-in-javascript-a-k-a-dont-mess-up-ur-interview-u-silly-nub-8082005e47c2" rel="noopener">大o(或者说时间复杂度)</a>就是O(2^n)，除了不好你不用知道。事实上，它是一个算法或函数在O(n！)或n阶乘。</p><p id="d19d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么我们如何更好地？这个怎么样？</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/3d3439bd9f494c5e56756881dccb749e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*M21AeKu-M81sNc5Z64qnHA.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我们要走了！</figcaption></figure><p id="94ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是<strong class="kd iu">记忆化</strong>，这很复杂，但基本上意味着<strong class="kd iu">每次我们计算一个新值，我们可能能够用它来计算另一个值，我们保存它并把它传递回我们的函数</strong>。</p><p id="239f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们使用一个数组，但是你也可以使用一个javascript对象，顺便说一下，对于另一个JS面试问题，几乎所有东西都是JS中的一个对象！</p><p id="4ff4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，就像我们已经知道fib(1)和fib(2)是-1一样，我们从每次迭代<strong class="kd iu">中知道先前的值是什么，因为我们已经计算了它们！</strong></p><p id="9026" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有<strong class="kd iu">制表！</strong></p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi li"><img src="../Images/257fc034a47c0218f925fe04d7aecdc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*_4dgs0vnWAP3Sm1LaWv4HQ.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我想已经没有汽水了。</figcaption></figure><p id="3ef0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">制表</strong>存储斐波纳契数列的最后值，<strong class="kd iu">从0、1和2开始，</strong>在<strong class="kd iu">数组</strong>和<strong class="kd iu">中迭代</strong>继续<strong class="kd iu">改变数组中的值</strong>以跟踪需要累加哪些值来找到数列的下一个数字。</p><p id="0be1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两种解决方案都有很大的时间复杂度，这意味着它们<strong class="kd iu">不会变得</strong> <strong class="kd iu">更加难以计算</strong>，因为需要通过它们计算大量的数据。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/0c02ce3061429deb8f7224673429ebb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/0*Lh_XxO1wjUIHgh2u"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我也是</figcaption></figure><p id="1a82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记忆、制表和动态规划是很难的话题。有些我几乎听不懂！但它们也是谷歌等公司为其搜索和地图开发复杂算法的基础，这使他们成为市场领导者。</p><p id="dc38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着所有编程新手继续我们的旅程，我们将继续面临类似这样的难题。我发现的诀窍是休息一下，吃一些不可能的巨无霸，看看可爱狗狗的照片。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lr"><img src="../Images/f5860ddb5d707874d888f7bb2c77aa8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFfvAS3aeOzgCs8c_BVQHQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">比如拍林戈。</figcaption></figure><p id="365b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是澳洲牧羊犬林戈/许多其他可爱的狗杂种狗。他喜欢拥抱和抚摸，喜欢在沙发上做你的朋友。他不在乎下雨或炎热。</p><p id="8b2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">他是你在阿尔戈斯海上的绿洲。</p><p id="9179" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">白现在来说，</p><p id="8f40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">网卡</p></div></div>    
</body>
</html>