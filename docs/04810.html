<html>
<head>
<title>Crash Course on AWS CDK and Serverless with REST API and Data Lake Analytical Querying</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS CDK速成班和无服务器REST API和数据湖分析查询</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/crash-course-on-aws-cdk-and-serverless-with-rest-api-and-data-lake-analytical-querying-37500b6625c0?source=collection_archive---------14-----------------------#2020-07-16">https://levelup.gitconnected.com/crash-course-on-aws-cdk-and-serverless-with-rest-api-and-data-lake-analytical-querying-37500b6625c0?source=collection_archive---------14-----------------------#2020-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d92be9450962af53d5bb81e4cd290647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAOvoyu4H-JUCAALtLNisw.png"/></div></div></figure><p id="6d6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原文在此:<a class="ae kz" href="https://dashbird.io/blog/crash-course-aws-cdk-serverless-rest-api-data-lake-analytical-querying/" rel="noopener ugc nofollow" target="_blank">https://dash bird . io/blog/crash-course-AWS-CDK-server less-rest-API-data-lake-analytical-query/</a></p><p id="c6c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一门关于如何使用<a class="ae kz" href="https://aws.amazon.com/cdk/" rel="noopener ugc nofollow" target="_blank"> AWS CDK </a>部署完全无服务器的web应用的实践课程。您将学习如何:</p><ul class=""><li id="be5a" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">构建**CDK堆栈* *以部署端到端的应用</li><li id="9c55" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">部署一个与<strong class="kd iu"> AWS Lambda </strong>集成的<strong class="kd iu"> REST API </strong>,用于动态请求处理</li><li id="d5cf" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">使用<strong class="kd iu"> DynamoDB </strong>以快速且经济的方式存储数据</li><li id="6896" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">在事件驱动架构中使用<strong class="kd iu"> DynamoDB流</strong>作为<strong class="kd iu">λ</strong>的源</li><li id="6725" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">使用<strong class="kd iu"> Kinesis Firehose </strong>摄取和处理大量数据流</li><li id="c4db" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">用<strong class="kd iu">雅典娜</strong>、<strong class="kd iu"> S3 </strong>和<strong class="kd iu">胶水</strong>部署并查询一个<strong class="kd iu">数据湖</strong></li><li id="0476" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">使用<a class="ae kz" href="https://dashbird.io/?utm_source=dashbird-blog&amp;utm_medium=article&amp;utm_campaign=aws-cdk&amp;utm_content=tutorial-serverless-website" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>在一个地方监控</strong>您的整个应用程序的健康状况</li></ul><p id="cf08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用这个演示应用程序中声明的资源作为起点，在以后混合和适应您自己的体系结构，这将节省您相当多的时间。</p><h1 id="40e8" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">应用和架构</h1><p id="dcd3" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">演示应用是一个公共博客，任何人都可以阅读、发布和喜欢帖子。此链接上有<a class="ae kz" href="https://d1qmte5oc6ndq5.cloudfront.net/" rel="noopener ugc nofollow" target="_blank">可用。继续在左上角(黄色按钮)发表一些东西，并“喜欢”已经发表的文章。查看本报告</a>中<a class="ae kz" href="https://github.com/byrro/serverless-website-demo" rel="noopener ugc nofollow" target="_blank">的代码库。</a></p><h1 id="c8f1" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">前端</h1><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/2d924b72b8f3db049a16763bde43818b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YzDPniVfQKOokkBV.png"/></div></div></figure><h1 id="b848" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">后端</h1><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/8aca3afd12c7a7ce899b39bd39c56aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4s2m2IN4mmQVwkyq.png"/></div></div></figure><h1 id="581a" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">数据湖和分析查询</h1><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/21c81998898ca63963ff7a3d89c722c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p_h_LXiuIRW4byXh.png"/></div></div></figure><h1 id="ebf2" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">什么是自动气象站CDK</h1><p id="ff6e" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">CDK代表云开发工具包。用你喜欢的语言(Python、Typescript、C#等)把它想象成CloudFormation (CF)。大致说来，它是这样工作的:</p><ol class=""><li id="b86a" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky my lg lh li bi translated">您使用CDK库提供的类来声明云资源。示例:</li></ol><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="6097" class="ne lp it na b gy nf ng l nh ni">from aws_cdk import aws_s3<br/>my_bucket = aws_s3.Bucket(self, 'MyBucket')</span></pre><ol class=""><li id="ec7f" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky my lg lh li bi translated">运行<code class="fe nj nk nl na b">cdk deploy</code></li><li id="808b" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky my lg lh li bi translated">CDK将它转化为云形成模板，并为你部署在AWS上</li></ol><p id="8fb4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想更深入地了解，AWS也有一个研讨会,可以让你从基础开始。我也强烈推荐阅读CDK官方文档。</p><h1 id="aaa8" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用自动气象站CDK的优势</h1><ol class=""><li id="52be" class="la lb it kd b ke mm ki mn km nm kq nn ku no ky my lg lh li bi translated">例如，使用比YAML或JSON更有表现力的语言</li><li id="120d" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky my lg lh li bi translated">少——少得多！—比云信息模板详细</li><li id="37d7" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky my lg lh li bi translated">更容易将可重用性和继承原则应用于基础设施代码</li><li id="f63a" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky my lg lh li bi translated">更好地与ide集成，实现代码完成、智能感知等</li><li id="e832" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky my lg lh li bi translated">可以测试你的基础代码，就像其他软件一样</li><li id="734d" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky my lg lh li bi translated">可移植性:因为它只是CF的包装器，我们可以很容易地将其移植到JSON或YAML</li></ol><h1 id="8dce" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用自动气象站CDK的缺点</h1><p id="bf32" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">尽管AWS团队发布了一个稳定的项目，但许多部分(许多好的部分)仍然是实验性的，API可能会以向后不兼容的方式改变。</p><p id="2e56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它正在不断发展。在准备这门课程的过程中，我不得不三次升级我的库。</p><p id="8145" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">某些部分仍然缺少文档，你需要偶尔看看CDK代码，以理解如何声明某些东西。</p><h1 id="aae6" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">自己部署</h1><p id="6860" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">虽然我们提供了在线演示，但您也可以在自己的AWS帐户中部署此应用程序:</p><ol class=""><li id="73c2" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky my lg lh li bi translated">克隆回购:<code class="fe nj nk nl na b">git clone git@github.com:byrro/serverless-website-demo.git sls-demo; cd sls-demo</code></li><li id="a9e8" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky my lg lh li bi translated">设置您的虚拟环境:<code class="fe nj nk nl na b">virtualenv -p /urs/bin/python3.8 .env; source .env/bin/activate; pip install -r requirements</code></li><li id="62b0" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky my lg lh li bi translated">指定AWS帐户ID: <code class="fe nj nk nl na b">export AWS_ACCOUNT_ID=1234567890</code> **</li><li id="e9b3" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky my lg lh li bi translated">部署所有三个堆栈:<code class="fe nj nk nl na b">cdk deploy sls-blog; cdk deploy sls-blog-api; cdk deploy sls-blog-analytical</code></li></ol><p id="b11b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">**您还可以在CDK项目中硬编码您的帐户ID，我马上会展示这一点；</p><p id="8b1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当从头开始一个新项目时，你会运行<code class="fe nj nk nl na b">cdk init --language [python|typescript|...]</code>。对于本演示，这不是必需的，因为项目已经创建。</p><h1 id="502f" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">监视</h1><p id="bf22" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在云中部署这种架构并盲目相信它会完美地工作是不合理的。我们想成为第一个知道什么时候不对劲并尽快采取行动的人。</p><p id="c622" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个项目中，我使用了<a class="ae kz" href="https://dashbird.io/?utm_source=dashbird-blog&amp;utm_medium=article&amp;utm_campaign=aws-cdk&amp;utm_content=tutorial-serverless-website" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>，因为它易于使用和无缝集成。Dashbird不需要在我的代码中部署代理，而是通过一个CloudFormation模板插入到我的堆栈<a class="ae kz" href="https://dashbird.io/docs/quickstart/setting-up-dashbird/?utm_source=dashbird-blog&amp;utm_medium=article&amp;utm_campaign=aws-cdk&amp;utm_content=tutorial-serverless-website" rel="noopener ugc nofollow" target="_blank">中，我只需点击一下鼠标就可以完成部署。它不仅监视Lambda函数错误，还监视我们正在使用的其他资源，比如DynamoDB表。他们甚至建议</a><a class="ae kz" href="https://dashbird.io/features/insights-engine/?utm_source=dashbird-blog&amp;utm_medium=article&amp;utm_campaign=aws-cdk&amp;utm_content=tutorial-serverless-website" rel="noopener ugc nofollow" target="_blank">架构改进的见解</a>与行业最佳实践相互参照。</p><p id="2bfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，Dashbird提供了一个永远免费的计划。通过<a class="ae kz" href="https://dashbird.io/register/?utm_source=dashbird-blog&amp;utm_medium=article&amp;utm_campaign=aws-cdk&amp;utm_content=tutorial-serverless-website" rel="noopener ugc nofollow" target="_blank">免费注册</a>来尝试它是显而易见的。</p><h1 id="ca1e" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">CDK项目是如何构建的</h1><p id="d746" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">一个CDK项目创建了一个“应用程序”。此应用程序可能有一个或多个“堆栈”。栈是一组使用CDK类实例化的云资源(Lambda函数、S3桶等)。在一个CDK项目中也可以有多个应用程序。</p><h1 id="5400" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">应用程序对象</h1><p id="b5f8" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">创建CDK应用程序非常简单:</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="4cde" class="ne lp it na b gy nf ng l nh ni">app = core.App()</span></pre><blockquote class="np nq nr"><p id="d802" class="kb kc ns kd b ke kf kg kh ki kj kk kl nt kn ko kp nu kr ks kt nv kv kw kx ky im bi translated">当您运行<code class="fe nj nk nl na b">cdk init --language [language]</code>时，在<code class="fe nj nk nl na b">app.py</code>下的项目根目录中会为您创建一个带有基本样板代码的初始应用程序。</p></blockquote><p id="af73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来我们需要一个环境，它由一个AWS帐户ID和区域组成:</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="14e0" class="ne lp it na b gy nf ng l nh ni">env = env = core.Environment(<br/>    account=1234567890,<br/>    region='us-east-1',<br/>)</span></pre><p id="e86d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">声明一个环境并不是必需的(CDK可以从您的AWS凭证中推断出来)，但这是一个很好的实践。我们大多数人都使用多个AWS帐户。搞几个项目、账户、凭证很容易。当我们在CDK应用程序中明确设置环境时，它会被锁定，以防止错误的部署。</p><p id="066f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们声明我们的堆栈:</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="4d86" class="ne lp it na b gy nf ng l nh ni">from my_project.my_project_stack import MyStack</span><span id="66d1" class="ne lp it na b gy nw ng l nh ni">my_stack = MyStack(<br/>    app,<br/>    'my-stack',<br/>    env=env,<br/>)</span></pre><p id="81ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们如何<em class="ns">为部署实例化</em>我们的堆栈。在下一节中，我们将看到如何<em class="ns">声明</em>那些堆栈。</p><h1 id="3643" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">堆栈对象</h1><p id="5da5" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">堆栈对象是我们声明AWS资源的地方。它继承自<code class="fe nj nk nl na b">core.Stack</code> CDK类，并接受一个作用域——也就是我们的<code class="fe nj nk nl na b">app</code>对象——一个字符串标识符和一个环境。</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="5924" class="ne lp it na b gy nf ng l nh ni">class MyStack(core.Stack):<br/>    def __init__(<br/>            self,<br/>            scope: core.Construct,<br/>            id: str,<br/>            env: core.Environment,<br/>            **kwargs,<br/>            ) -&gt; None:<br/>        super().__init__(scope, id, **kwargs)</span><span id="baac" class="ne lp it na b gy nw ng l nh ni">        # Declare AWS resources here</span></pre><h1 id="4c29" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">声明AWS资源</h1><p id="0626" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">为了声明AWS资源，我们需要为每个服务提供一个特定的库。这里列出了所有的<a class="ae kz" href="https://docs.aws.amazon.com/cdk/api/latest/python/index.html" rel="noopener ugc nofollow" target="_blank"> Python库</a>和它们的<a class="ae kz" href="https://docs.aws.amazon.com/cdk/api/latest/typescript/api/index.html" rel="noopener ugc nofollow" target="_blank"> Typescript </a>副本。其他口味还有<a class="ae kz" href="https://docs.aws.amazon.com/cdk/api/latest/java/index.html" rel="noopener ugc nofollow" target="_blank"> Java </a>和<a class="ae kz" href="https://docs.aws.amazon.com/cdk/api/latest/dotnet/api/index.html" rel="noopener ugc nofollow" target="_blank">。网</a>。</p><p id="ce7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看如何声明一个基本的REST API(为了可读性，去掉了类型表达式):</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="0aeb" class="ne lp it na b gy nf ng l nh ni">from aws_cdk import aws_apigateway, aws_lambda</span><span id="c6ae" class="ne lp it na b gy nw ng l nh ni">class MyStack(core.Stack):<br/>    def __init__(self, scope, id, env):<br/>        super().__init__(scope, id, **kwargs)</span><span id="39e6" class="ne lp it na b gy nw ng l nh ni">        my_lambda = aws_lambda.Function(<br/>            self,<br/>            'MyLambda',<br/>            runtime=aws_lambda.Runtime.PYTHON_3_8,<br/>            code=aws_lambda.Code.asset('my_lambda_folder),<br/>            handler='my_lambda.handler',<br/>        )</span><span id="acda" class="ne lp it na b gy nw ng l nh ni">        aws_apigateway.LambdaRestApi(<br/>            self,<br/>            'sls-blog-rest-api-gateway',<br/>            handler=my_lambda,<br/>        )</span></pre><p id="eb00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先声明一个Lambda函数<code class="fe nj nk nl na b">my_lambda</code>。我们将其代码指向<code class="fe nj nk nl na b">my_lambda_folder</code>。在这个文件夹中，应该有一个<code class="fe nj nk nl na b">my_lambda.py</code>文件，包含一个名为<code class="fe nj nk nl na b">handler</code>的函数。这个处理函数应该正常接受Lambda调用(一个<code class="fe nj nk nl na b">event</code>和<code class="fe nj nk nl na b">context</code>对象)。</p><p id="cb43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来声明一个<code class="fe nj nk nl na b">LambdaRestApi</code>，使用<code class="fe nj nk nl na b">my_lambda</code>作为处理器(不要与Lambda的处理器函数混淆)。这将使用<code class="fe nj nk nl na b"><a class="ae kz" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-integration-types.html" rel="noopener ugc nofollow" target="_blank">AWS_PROXY</a></code> <a class="ae kz" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-integration-types.html" rel="noopener ugc nofollow" target="_blank">集成类型</a>创建一个与<code class="fe nj nk nl na b">my_lambda</code>集成的新API Gateway REST API。所有HTTP请求都将被路由到Lambda函数。</p><h1 id="d015" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">我们的项目应用和堆栈</h1><p id="407e" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">这个项目由一个应用程序和三个堆栈组成。它们都在<code class="fe nj nk nl na b">[app.py](https://github.com/byrro/serverless-website-demo/blob/master/app.py)</code>和<code class="fe nj nk nl na b">[sls_website_stack.py](https://github.com/byrro/serverless-website-demo/blob/master/sls_website/sls_website_stack.py)</code>文件中声明。</p><p id="47c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面我们将简要介绍所有筹码。我鼓励你检查一下<a class="ae kz" href="https://github.com/byrro/serverless-website-demo/blob/master/sls_website/sls_website_stack.py" rel="noopener ugc nofollow" target="_blank">栈文件</a>，以了解这些资源是如何声明和集成的。例如:在一个堆栈中创建一个Kinesis Firehose，并在另一个堆栈中引用它，以将其名称作为Lambda函数的环境变量，与它进行交互。</p><p id="1ad0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了前端静态堆栈——它很小——您会注意到资源在开始时用一个<code class="fe nj nk nl na b">None</code> (null)值初始化。原因是，尽管CDK通常比云形成更简洁，但它仍然可能很长，足以扰乱整个堆栈的视图。在一行中首先声明每个资源，我可以提供堆栈中所有内容的简短摘要，然后在其他方法中实例化CDK类。</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="f034" class="ne lp it na b gy nf ng l nh ni">class SlsBlogApiStack(core.Stack):<br/>    def __init__(self, scope, id, env, static_stack):<br/>        super().__init__(scope, id, **kwargs)</span><span id="275e" class="ne lp it na b gy nw ng l nh ni">        self.static_stack = static_stack</span><span id="960a" class="ne lp it na b gy nw ng l nh ni">        # SQS Queues<br/>        self.queue_ddb_streams_dlq = None  # Dead-letter-queue for DDB streams</span><span id="3d0c" class="ne lp it na b gy nw ng l nh ni">        # DynamoDB Tables<br/>        self.ddb_table_blog = None  # Single-table for all blog content</span><span id="d63e" class="ne lp it na b gy nw ng l nh ni">        # DynamoDB Event Sources<br/>        self.ddb_source_blog = None  # Blog table streams source</span><span id="87c3" class="ne lp it na b gy nw ng l nh ni">        # DynamoDB Indexes<br/>        self.ddb_gsi_latest = None  # GSI ordering articles by timestamp</span><span id="72d3" class="ne lp it na b gy nw ng l nh ni">        # Lambda Functions<br/>        self.lambda_blog = None  # Serves requests to the blog public API<br/>        self.lambda_stream_reader = None  # Processes DynamoDB streams</span><span id="2148" class="ne lp it na b gy nw ng l nh ni">        # Continues with other resources...</span></pre><p id="ec8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，它将另一个Stack对象(<code class="fe nj nk nl na b">static_stack</code>)作为其初始化的参数。在<code class="fe nj nk nl na b">[app.py](https://github.com/byrro/serverless-website-demo/blob/master/app.py)</code>文件中，您可以看到<code class="fe nj nk nl na b">SlsBlogApiStack</code>是通过将<code class="fe nj nk nl na b">SlsBlogStack</code>作为参数进行初始化的。</p><p id="c2ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用它来引用Lambda环境变量中的CloudFront分布域(<a class="ae kz" href="https://d1qmte5oc6ndq5.cloudfront.net/" rel="noopener ugc nofollow" target="_blank">d1qmte5oc6ndq5.cloudfront.net</a>)。该变量可用于定制HTTP响应头<code class="fe nj nk nl na b">Access-Control-Allow-Origin</code>以符合<a class="ae kz" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-cors.html" rel="noopener ugc nofollow" target="_blank"> CORS标准</a>。这说明了一种在CDK项目中将信息从一个堆栈轻松集成和引用到另一个堆栈的方法。</p><p id="5e83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在初始化结束时，调用另一个方法来实例化每个资源的CDK类并配置它们的参数。</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="e74a" class="ne lp it na b gy nf ng l nh ni">self.create_cdk_resources()</span></pre><p id="47a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将遍历项目的每个堆栈。</p><h1 id="9f52" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">堆栈1:静态网站</h1><p id="33ea" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">我们关注的是无服务器的后端，所以这里的前端非常粗糙和简单。它存储在S3桶中，并通过CloudFront CDN分发。</p><p id="000b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CDK有一个叫做BucketDeployment的有用的类。它获取目录的内容并同步到S3存储桶。在这种情况下，我们将前端代码存储在<code class="fe nj nk nl na b">website_static</code>文件夹中。</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="3c02" class="ne lp it na b gy nf ng l nh ni">aws_s3_deployment.BucketDeployment(<br/>    self,<br/>    'SlsBlogStaticS3Deployment',<br/>    sources=[aws_s3_deployment.Source.asset('website_static')],<br/>    destination_bucket=static_bucket,<br/>    distribution=cdn,<br/>)</span></pre><h1 id="d4b9" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">堆栈2:API/后端</h1><p id="6b50" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">我们的后端由一个API网关(REST)组成，连接到一个<a class="ae kz" href="https://dashbird.io/knowledge-base/well-architected/monolith-vs-microservices/?utm_source=dashbird-blog&amp;utm_medium=article&amp;utm_campaign=aws-cdk&amp;utm_content=tutorial-serverless-website" rel="noopener ugc nofollow" target="_blank">单片Lambda函数</a>。微服务受到了很多压力，但是你可能不应该总是把你的应用程序分成几个功能。一整块就可以了——<a class="ae kz" href="https://www.martinfowler.com/bliki/MonolithFirst.html" rel="noopener ugc nofollow" target="_blank">，有时还推荐</a>——真的。</p><p id="d834" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个API &amp; Lambda支持带有query string“action”单个端点(带有GET和POST方法),它有三个参数:</p><ul class=""><li id="016f" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><code class="fe nj nk nl na b">get-latest-articles</code>:填充最新的博客文章</li><li id="b7ab" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><code class="fe nj nk nl na b">like-article</code>:当有人喜欢一篇文章时触发</li><li id="110f" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><code class="fe nj nk nl na b">publish-article</code>:发表一篇新的博客文章</li></ul><p id="c0a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是CDK模式的力量。我们可以用10行代码创建一个REST API:</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="49e8" class="ne lp it na b gy nf ng l nh ni">rest_api_blog = aws_apigateway.LambdaRestApi(<br/>    self,<br/>    'sls-blog-rest-api-gateway',<br/>    handler=lambda_blog,  # Previously declared Lambda function<br/>    deploy_options=aws_apigateway.StageOptions(<br/>        stage_name='api',<br/>        throttling_rate_limit=lambda_param_max_concurrency,<br/>        logging_level=aws_apigateway.MethodLoggingLevel('INFO'),<br/>    ),<br/>)</span></pre><p id="c9c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个很好的小事情是Lambda内存被用作最新文章的缓存。我们在Lambda处理函数之外加载缓存容器。即使在调用结束后，它仍保留在内存中，可供后续请求使用。在这里了解更多关于<a class="ae kz" href="https://dashbird.io/blog/leveraging-lambda-cache-for-serverless-cost-efficiency/?utm_source=dashbird-blog&amp;utm_medium=article&amp;utm_campaign=aws-cdk&amp;utm_content=tutorial-serverless-website" rel="noopener ugc nofollow" target="_blank">如何使用Lambda作为缓存机制</a>。</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="28a3" class="ne lp it na b gy nf ng l nh ni">MAX_CACHE_AGE: int = 120  # In seconds<br/>CACHE_LATEST_ARTICLES: Dict[str, Union[int, list]] = {<br/>    'last_update': time.time(),<br/>    'articles': [],<br/>}</span></pre><p id="f410" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<a class="ae kz" href="https://www.alexdebrie.com/posts/dynamodb-single-table/" rel="noopener ugc nofollow" target="_blank">单表设计</a>，以<a class="ae kz" href="https://aws.amazon.com/blogs/aws/amazon-dynamodb-on-demand-no-capacity-planning-and-pay-per-request-pricing/" rel="noopener ugc nofollow" target="_blank">按需模式</a>将所有数据存储在DynamoDB (DDB)中。该网站通过设置一个<code class="fe nj nk nl na b">time-to-live</code>属性，只显示几天后被DDB 自动删除的最新博客文章和条目。</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="7692" class="ne lp it na b gy nf ng l nh ni">ddb_attr_time_to_live = 'time-to-live'<br/>ddb_param_max_parallel_streams = 5</span><span id="8ced" class="ne lp it na b gy nw ng l nh ni">ddb_table_blog = aws_dynamodb.Table(<br/>    self,<br/>    'sls-blog-dynamo-table',<br/>    partition_key=aws_dynamodb.Attribute(<br/>        name='id',<br/>        type=aws_dynamodb.AttributeType.STRING,<br/>    ),<br/>    billing_mode=aws_dynamodb.BillingMode.PAY_PER_REQUEST,<br/>    point_in_time_recovery=True,<br/>    removal_policy=core.RemovalPolicy.DESTROY,<br/>    time_to_live_attribute=self.ddb_attr_time_to_live,<br/>    stream=aws_dynamodb.StreamViewType.NEW_AND_OLD_IMAGES,<br/>)</span></pre><p id="6652" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">DDB表格还有一个<a class="ae kz" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html" rel="noopener ugc nofollow" target="_blank"> GSI(全球二级索引)</a>，可以更容易地检索网站上按日期排序的文章:</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="3299" class="ne lp it na b gy nf ng l nh ni">self.ddb_table_blog.add_global_secondary_index(<br/>    index_name='latest-blogs',<br/>    partition_key=aws_dynamodb.Attribute(<br/>        name='item-type',<br/>        type=aws_dynamodb.AttributeType.STRING,<br/>    ),<br/>    sort_key=aws_dynamodb.Attribute(<br/>        name='publish-timestamp',<br/>        type=aws_dynamodb.AttributeType.NUMBER,<br/>    ),<br/>    projection_type=aws_dynamodb.ProjectionType.ALL,<br/>)</span></pre><p id="cd8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对DDB项目的修改生成由第二λ函数处理的流。这些流然后被重新打包，并被发送到一个Kinesis消防水带流处理器。</p><p id="9fd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">DDB不提供SQL数据库所提供的灵活性，例如，许多人选择了<a class="ae kz" href="https://aws.amazon.com/rds/aurora/serverless/" rel="noopener ugc nofollow" target="_blank"> Aurora无服务器</a>。虽然极光是一个伟大的服务，就个人而言，我更喜欢DDB的简单和可靠的，一致的性能。但是有时我们确实需要运行分析查询，那些带有聚合和即时过滤器的查询。为此，我们将使用Athena(在下一个堆栈中会有更多)。</p><h1 id="5505" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">堆栈3:分析查询</h1><p id="d959" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">Kinesis Firehose流负责批处理在DDB插入/修改的数据，将它们转换为Apache Parquet格式并存储在专用的S3桶中。在S3，我们用AWS Glue(用于声明我们的数据模式)和Athena(用于查询数据)创建了一个数据湖。</p><p id="52e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">雅典娜极其强大。我们可以<a class="ae kz" href="https://docs.aws.amazon.com/athena/latest/ug/select.html" rel="noopener ugc nofollow" target="_blank">使用SQL SELECT </a>语句(<a class="ae kz" href="https://docs.aws.amazon.com/athena/latest/ug/other-notable-limitations.html" rel="noopener ugc nofollow" target="_blank">带有一些限制</a>)来查询万亿字节的数据并按需付费(每扫描一GB数据0.005美元)。使用Parquet不仅可以提高查询速度，还可以通过最小化Athena为每个查询扫描的数据量来降低成本。</p><p id="35a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在DynamoDB中不可能或昂贵/缓慢的查询，如聚合和连接，在Athena中是快速和廉价的。这两种服务以一种完美的方式相互结合，因此您的应用程序具有优化的事务存储和灵活的分析查询功能。</p><p id="103f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用Athena查询所有已发表的文章，并与likes和HTTP元数据(源IP地址、国家、设备类型等)进行交叉引用。即使文章已经在DynamoDB TTL(生存时间)到期，也可以在数据湖中继续使用。</p><p id="96a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">比如哪些国家最喜欢的文章？在AWS控制台中，我们会看到类似这样的内容:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/be4af81598df25b4e620b01a4b0a01ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SHzfsSwT-JhuxaVV.png"/></div></div></figure><p id="fe7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也可以使用<a class="ae kz" href="https://docs.aws.amazon.com/athena/latest/APIReference/API_StartQueryExecution.html" rel="noopener ugc nofollow" target="_blank"> Athena API </a>或<a class="ae kz" href="https://aws.amazon.com/getting-started/tools-sdks/" rel="noopener ugc nofollow" target="_blank">AWS SDK</a>(例如<a class="ae kz" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/athena.html#Athena.Client.start_query_execution" rel="noopener ugc nofollow" target="_blank"> Python的boto3 </a>)以编程方式执行查询，以便将这些数据集成到我们需要的任何地方。</p><p id="3d87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Athena也支持连接。下面是一个结合文章和HTTP元数据来分析特定国家读者中最受欢迎的作者的示例:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/3f8f76593750a863305515fd5c0c5286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y3YfKnNQDdxJ_84G.png"/></div></div></figure><h1 id="204d" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">部署</h1><p id="7e14" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">CDK可以一次部署一个堆栈。因为我们有三个，所以有必要在运行<code class="fe nj nk nl na b">cdk deploy</code>命令时指定哪一个。我们通过将堆栈ID作为CLI参数传入来实现这一点。例如，以下命令将部署SlsBlogApiStack (id: <code class="fe nj nk nl na b">sls-blog-api</code>):</p><pre class="ms mt mu mv gt mz na nb nc aw nd bi"><span id="11af" class="ne lp it na b gy nf ng l nh ni">cdk deploy sls-blog-api</span></pre><p id="af05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于所有的栈都涉及某种类型的许可授予，CDK在部署这些资源之前要求确认。你可以查看请求的权限，并在合适的时候点击<code class="fe nj nk nl na b">y</code>。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/5b23c9a364e64f9619d6c49fe4f5cefe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8liliGuHQ-uf__p5qx3RA.png"/></div></div></figure><h1 id="bb3e" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">包扎</h1><p id="aa2e" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">我们已经介绍了如何构建CDK应用程序，以及如何通过一个简单的<code class="fe nj nk nl na b">cdk deploy</code>命令添加大量AWS资源进行部署。如果你是CDK的新手——正如本文前面所建议的——强烈建议遵循AWS <a class="ae kz" href="https://cdkworkshop.com/" rel="noopener ugc nofollow" target="_blank"> CDK研讨会</a>和<a class="ae kz" href="https://docs.aws.amazon.com/cdk/latest/guide/home.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="bac1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://sls.dashbird.io/newsletter-sign-up?utm_source=dashbird-blog&amp;utm_medium=article&amp;utm_campaign=aws-cdk&amp;utm_content=tutorial-serverless-website" rel="noopener ugc nofollow" target="_blank">也请关注未来的出版物</a>，因为<a class="ae kz" href="https://dashbird.io/?utm_source=dashbird-blog&amp;utm_medium=article&amp;utm_campaign=aws-cdk&amp;utm_content=tutorial-serverless-website" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>正在发布其他示例和教程，以利用CDK或其他的基础自动化功能来充分利用AWS无服务器服务。</p></div></div>    
</body>
</html>