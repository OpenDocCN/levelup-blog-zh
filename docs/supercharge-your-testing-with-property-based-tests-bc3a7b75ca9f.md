# 用基于属性的测试增强你的测试

> 原文：<https://levelup.gitconnected.com/supercharge-your-testing-with-property-based-tests-bc3a7b75ca9f>

![](img/dd43b498f00dd1ef904fb4513d66c35f.png)

夏洛特·科内比尔在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

单元测试对于您预期的情况非常有用。不幸的是，错误往往会出现在你没有发现的地方。基于属性的测试有助于弥合这一差距。它不是让你手工制作每个测试输入，而是用大量精心制作的随机输入轰炸你的代码库。

作为一个专业的软件开发人员，在职业生涯的某个阶段不遇到测试几乎是不可能的。我们大多数人都知道在开发周期的早期进行测试的价值。传统的单元测试越来越受欢迎，因为它们通常写起来很快，执行起来也很快，并且提供了快速的反馈循环。我们中的许多人花了相当多的时间来讨论单元测试的各个方面，例如何时编写单元测试，编写多少单元测试，代码覆盖率的水平，等等。

然而，在本文中，我们将着眼于编写测试的不同方式，以便一个测试覆盖许多不同的输入，而不是单一的输入。为此，我们非常依赖随机化来生成我们想要的输入。对于代码示例，为了简洁起见，我们将使用 F#语言，并利用 FsCheck 库和 Xunit 进行测试。这不应该阻止你继续阅读，因为 FsCheck 在 C#中也非常有用。

# 单元测试

一个经典的单元测试由三个 A 组成:Arrange，Act，Assert。我们安排组件并准备输入。我们通过调用我们希望用输入测试的逻辑来行动，最后，我们检查我们关于输出的断言是否成立。为此，我们通常准备各种输入及其匹配的输出，并调用逻辑进行测试。这被称为测试套件。有时，如果设置是相同的，我们可以通过将输入的多种组合及其匹配的输出附加到同一个单元测试来参数化测试。

让我们看一个简单的例子，在这个例子中，我们想测试一个函数的实现，这个函数的参数取绝对值。该函数返回任意正数的标识以及任意负数的正对应项。我们还假设我们想要测试这个函数。

所以我们写了三个测试用例，一个用于正数，一个用于负数，一个用于数字零。代码覆盖率看起来很好，我们已经测试了正面和负面的输入，还有什么需要做的吗？精明的读者或有经验的开发人员可能会想，边界情况怎么样？在这种情况下，号码是 2147483648。我们的实现将如何处理这种情况，这种行为是有意的吗？

这里的要点是，事先想出会导致代码行为不当的输入可能相当困难，另一方面，手动编写覆盖整个输入范围的单元测试也可能很麻烦，并且需要很长时间来执行。如果有一个中间地带，可以从广泛的测试中得到最好的结果，快速的执行和简单的单元测试就好了。这是基于属性的测试试图覆盖的中间地带。

# 基于属性的测试

在基于属性的测试中，我们不是指定每个输入和输出，而是指定一个应该适用于被测试函数的关系。这可能是在给函数的输入和它的输出之间，或者如果对某个函数调用两次应该是幂等的，或者甚至可能反转第一次调用的结果。你可以挑选相当多的东西来选择。为了简单起见，我们将选择以下属性来测试上面的实现。

*   无论 x 的值是多少，abs x 的结果必须总是大于或等于 0。数学上写成 abs x ≥ 0
*   对于任意一个负数 x，当把 abs x 加进去时，结果应该是 0。数学上写成:对于 x < 0: x + abs x = 0

在下面的代码中，使用 FsCheck 及其 Xunit 集成可以很容易地编写覆盖这些属性的随机的基于属性的测试。

首先要注意的是，我们现在使用属性，而不是编写事实属性。第二件要注意的事情是，我们的函数不再没有参数，并且不再将 unit 作为返回类型。相反，它们接受我们期望传递给被测试函数的输入，并且返回类型是一个布尔值，表示我们想要测试的属性对于特定的输入是否成立。当 FsCheck 看到这样的代码时，它会在生成器库中查找，并开始输出这种类型的随机输入。对于每个输入，它将检查属性是否成立。FsCheck 使用了一个任意的概念，来生成随机值。Arbitraries 由一个生成器和一个收缩器组成，前者负责生成随机输入，后者负责在测试中发现破坏属性的输入后，将随机输入收缩到尽可能简单的程度。FsCheck 附带了许多内置的助手类型。IntWithMinMax，确保 int。MinValue 和 int。包括 MaxValue，NegativeInt 将只返回负整数。DoNotShrink 类型确保收缩程序不会运行。

运行检查后，您很可能会看到以下错误或类似的错误。

```
Test Name: abs x >= 0
Test Outcome: Failed
Result Message: 
FsCheck.Xunit.PropertyFailedException : 
Falsifiable, after 67 tests (0 shrinks) (StdGen (167901972, 296833629)):
Original:
DoNotShrink (IntWithMinMax -2147483648)
```

该错误告诉您的是，在生成 67 个随机输入(FsCheck 将默认为 100 个随机输入)后，它偶然发现了一个值为-2，147，483，648 的输入，其中绝对值不是正的。这当然是由于两个的[补码的老问题。](https://en.wikipedia.org/wiki/Two%27s_complement)

这正是在 property based 上使用一点额外的时间将使您洞察到您可能忽略的输入的情况，并且将不得不禁止和更改前提条件，或者接受您的函数返回一些超出您通常预期的内容。但至少它不再隐藏在无知的面纱后面。

# 锁定输入:浑水摸鱼

当处理随机测试并且您有一个失败的基于属性的测试时，不能保证您在下一次运行您的测试时会再次看到这个错误的输入。幸运的是，FsCheck 会告诉您它用来生成错误输入的种子。这就是 StdGen (167901972，296833629)行在输出中的含义。您可以使用这些信息来重现该问题。例如，您可以设置一个经典的 Xunit 测试，强制 FsCheck 使用随机数发生器的原始种子。这允许您一遍又一遍地重放错误的输入，直到您找到并修复错误。

这可能一开始看起来有点矫枉过正，因为 FsCheck 已经告诉了您错误的数字。然而对于更复杂的输入。手动复制可能会困难很多，然后这个重放机制才真正大放异彩。

# 设计基于属性的测试

当涉及到派生良好的基于属性的测试时，从领域逻辑的角度考虑通常是值得的。在许多领域中，存在相互抵消的操作。让我们假设我们运行一个小型交易所，有一个单一的订单簿，其中有出价和报价。简单地说，这种交换的匹配引擎简单到近乎荒谬。只有当收到的订单与另一方的最佳订单完全匹配时，出价和报价才会匹配。此外，订单优先级仅由价格决定，没有二次订购。代码的编写也没有考虑到效率，在正确性方面存在各种问题，比如处理两个使用相同 id 的订单。

我们可以推导出我们想要为这个订单簿保留的几个属性

*   当订单簿为空时，取消订单会导致订单簿为空。
*   使用相同 id 下订单和取消订单会导致订单簿为空
*   在订单簿中下订单，然后一个相等且相反的订单导致一个空订单簿。
*   将订单添加到空订单簿会将其作为最佳出价或要价放在订单簿中。

让我们先来看看示例代码。订单被定义为具有一方、一个数量、一个价格和一个唯一 id 的类型。动作表示我们希望对订单簿执行的操作。在这种情况下，我们只能下单和取消订单。订单簿有各种方法来构造空订单簿，获得最佳出价或要价，并检查它是否为空。最后，它有 perform 方法，该方法将执行订单簿的操作。

每个基于属性的检查都接受 Order.t 类型的参数，FsCheck 知道如何生成它，因为这是一个 F#记录类型。如果您想要生成通用对象，比如具有可变字段的类的实例，一般来说，您需要做更多的工作。我们将在本文的稍后部分讨论这个问题。在我们的每个测试中，我们还试图根据域对象上的操作来指定属性，以增加可读性。

# 通过建立套利来驯服随机性

在某些情况下，您可能必须指定如何构建所需类型的对象。如果您碰巧使用了已经在 C#中被定义为类或结构的[值对象](https://codeburst.io/value-objects-and-how-to-appreciate-them-19711c74e3cb)，这一点尤其正确。这就是套利概念发挥作用的地方。让我们假设您有一个非常简单的表示货币对象的类。虽然 FsCheck 可以生成随机字符串并将它们作为参数传递给 Currency 构造函数，但这些字符串是随机的，例如" ' \\X{}|X46s "，这很可能不是货币中的预期值。但是，您可以任意设置并让 FsCheck 使用它。让我们来看看实现这一点的代码片段。

为了使用您自己的任意性，您必须将任意字段设置为任意生成器类型的数组。这些类有带签名单元-> Arb 的静态方法。当基于属性的测试遇到其中一种类型时，它将知道在哪里查找。第二件事是定义实际的任意。

正如开始提到的，任意对象由两个不同的部分组成，一个生成器和一个收缩器。在这里，我们想要使用来自原始任意的生成器，所以我们提取它并在这里施展我们的魔法。为此，我们利用两个事实

1.  我们知道可以从中采样的有效值的数量是有限的。
2.  FsCheck 已经知道如何生成随机正整数。

现在，我们首先定义一个有效货币的数组，然后我们限制这个随机整数，使它总是落入我们的有效值数组的有效索引中。然后，我们从数组中选取该值，并将其传递给我们的构造函数，这将产生一个生成器，为我们提供随机的货币对象，其中包含来自有效货币范围的数据。最后，我们从这个生成器中创建一个没有收缩器的任意对象。

Gen 模块还具有许多其他特性，例如过滤值、从提供的生成器中选择许多元素等。但是关于生成器，要认识到的最重要的事情之一是它们可以很好地组合。这是一个非常强大的概念，因为如果你或其他人已经为你的新类的组件写了仲裁，你可以很容易地为它生成仲裁。例如，如果您想构建只包含正金额和有效货币的随机金额对象，您可以使用下面的代码来实现。

请注意，基于属性的测试只依赖于 AmountArb 类型的存在。另外，请注意 AmountArb 和 CurrencyArb 是两种不同的类型。您不需要将所有的仲裁都作为同一个类中的方法。在构建随机金额时，我们在生成器上对小数使用过滤操作符，以确保我们只获得正的随机值，我们获得一个任意货币的实例，并从中提取生成器。最后，我们通过使用 Gen.map2 方法将两个生成器结合起来。这需要一个知道如何组合两个生成器的输出的函数，我们所要做的就是将参数传递给我们的 Amount 构造函数。这给了我们一个知道如何生成 Amount 对象的方法。

# 基于属性的验收测试

基于属性的测试可能派上用场的另一个地方是，当您需要对您正在编写的新代码进行某种验收测试时。假设您已经编写了一段非常简单的代码，您知道它是正确的，但是不幸的是对于生产来说它不够快。所以你决定试试运气，写一个更快版本的算法，可能会稍微复杂一点。在这种情况下，您可以编写一个基于属性的测试，其中必须满足的属性是，对于任何输入，缓慢且简单的算法的结果必须与更快且更复杂的算法的结果相匹配。然后你把随机输入的数量提高到足以让你有信心继续下去。如果一切都通过了，你应该有一个强烈的信念，你的更快的算法表现得和它的更慢的对手一样好。

现在假设你的代码中有一个黑盒，你需要写一个替换。这可能是某处服务的端点，也可能是链接到您的程序的 DLL，其中的源代码已经丢失，等等。这里，您想要测试的属性是，对于随机输入，您的实现与未知的参考实现产生相同的结果。如果服务是外部的，您可能很想确保每次运行测试时，您不会通过远程调用来 DDoS 它。

# 使用属性进行测试时的其他注意事项

基于属性的测试是有用的，但没有灵丹妙药。对于不习惯进行基于属性的测试的维护代码库的其他开发人员来说，它们可能稍微难以阅读。当你决定实现你自己的任意性并限制随机数发生器可能取的值时，你可能会因为过于严格而遗漏重要的情况，就像编写单元测试一样。基于属性的测试运行起来也比单元测试慢，默认情况下，它们生成 100 个随机输入并测试它们。如果您有许多基于属性的测试，或者您为其中的一些测试增加了随机输入，那么您使用 NCrunch 这样的并发测试工具的体验可能会降低。因为你在处理随机性，这也意味着两个测试运行完全相同是非常不可能的。您可能有一次运行通过，然后一次运行失败。如果第二次运行确定了一个实际问题，那么一切都很好。您应该为这种情况编写一个特定的单元测试，然后解决这个问题。然而，如果是因为你的一个套利行为产生了远离预期输入的值，那么识别和修复这个问题可能会更加困难。这是因为您首先必须识别产生意外值的任意值，并将其包装在过滤机制中。虽然这确实是可能的，但这仍然比简单地改变单元测试中定义的常量值要多得多。

# 结论

基于属性的测试是一个非常有用但经常被忽视的工具。从专业的角度来看，我已经多次看到，在对代码库中有问题的部分引入基于属性的测试之后，它非常快地揭示了有时很微妙的问题，并使代码库的这一部分从通常的嫌疑人之一提升到最后要查看的地方之一。然而，这确实需要一些时间来适应，我希望这篇文章有助于激发您的兴趣，并克服开始基于属性的测试的最初障碍。要了解更多信息， [FsCheck 文档](https://fscheck.github.io/FsCheck/)非常值得一看。本文主要使用了 F#中的代码示例，但是在 C#中也可以使用 FsCheck。如果您想看一篇关于 C#中 FsCheck 用法的文章，请随时告诉我。