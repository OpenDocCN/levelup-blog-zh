<html>
<head>
<title>The Javascript UNTIL loop.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript直到循环。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-javascript-until-loop-68c350d7f5b0?source=collection_archive---------17-----------------------#2021-02-01">https://levelup.gitconnected.com/the-javascript-until-loop-68c350d7f5b0?source=collection_archive---------17-----------------------#2021-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9452" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何有效地使用递归？</h2></div><p id="c95d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都知道。Javascript很棒。<br/>直到不是。<br/>超级好用。<br/>直到不是。在JS中，你可以做任何你想做的事情。从DOM操作到客户机服务器架构。从机器学习到物联网。javascript真的能解决所有问题，对吗？</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="15a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这是一个居高临下的介绍，但我真的觉得Javascript(或Typescript)是未来。也就是说，这种语言及其框架并不是没有问题。我想向你提交一个我最喜欢的编程迷因，以帕特里克·斯达和蝠鲼为特色。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi li"><img src="../Images/dd8c0b5bfdac9cbc4f458054838c7094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*OcOy6jPLlT2QxkPqegwoCA.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">帕特里克星和蝠鲼，争论0整数，0字符串和空数组的区别。</figcaption></figure><p id="6992" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将它插入控制台，我们发现显示的内容是正确的。但我不是来说JS坏话的。我写这篇文章的目的是提出，我们面对的编程语言的(一些)问题实际上不是语言本身的问题，而是我们作为程序员如何处理手头的任务。</p><h2 id="0a56" class="lu lv iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">回车:递归。</h2><p id="e737" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">作为一个Rubyist爱好者，学习Javascript有它的曲线。有些东西我更喜欢Ruby，有些东西在Javascript中更有意义。其中一个例子是JS <code class="fe ms mt mu mv b">for</code>循环，更具体地说是<code class="fe ms mt mu mv b">for…of</code>循环。</p><p id="60be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我发现<code class="fe ms mt mu mv b">for…of</code>环时，就好像世界对我隐藏了起来。“这无疑是人类创新的顶峰”我想。能够用这么少的语法迭代一个数组是一个奇迹。</p><p id="cd2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，JS，像几乎所有其他通用语言一样，有一个<code class="fe ms mt mu mv b">while</code>循环，只要给定的表达式为真，它就会做一些事情(或者如果你不小心，就会使你的计算机崩溃)。</p><p id="983b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果一个普通的<code class="fe ms mt mu mv b">for</code>循环在一个数据集合上迭代<code class="fe ms mt mu mv b">x</code>次(或者等于集合长度的次数),并且<code class="fe ms mt mu mv b">while</code>循环一直继续下去，只要还有剩余的东西<code class="fe ms mt mu mv b">true</code> …我能告诉Javascript做一些事情<code class="fe ms mt mu mv b">UNTIL</code>某事为真吗？</p><p id="cfa6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着我继续学习JS，这个问题越来越困扰我。理论上，我可以操纵上述迭代器中的一个以这种方式运行，但是这个函数最终几乎总是比我认为必要的更复杂。后来有一天，在一次代码会议上，我在谷歌上搜索一些与问题陈述无关的内容，我看到了递归的使用，一切都很顺利。</p><p id="24c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我相信很多读到这里的人都熟悉递归的概念，但是为了我自己的内心平静，我还是要给它下一个定义。</p><blockquote class="mx"><p id="1e08" class="my mz iq bd na nb nc nd ne nf ng la dk translated">递归被定义为递归过程的重复应用。(“某事正在被重复”的长形式。)</p></blockquote><p id="299b" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated"><em class="mw">“好吧，这太棒了，但这对我有什么帮助？”</em></p><p id="c09d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个沙盒例子。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/6efc8ce7b0732af01d5910afebcbe0a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8P3aZemr47VGXT7YJzyeMQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">返回阶乘的函数。</figcaption></figure><p id="e51c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这区区六行代码将返回给函数的任意数字的阶乘。这个函数是一个常见的沙盒问题，有许多不同的方法来解决它，但是通过实现递归，这个函数可以尽可能的短。我们来分解一下。</p><p id="636c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">举个例子，假设我们将<code class="fe ms mt mu mv b">8</code>插入到函数中。在第一行，该函数检查<code class="fe ms mt mu mv b">n</code> ( <code class="fe ms mt mu mv b">8</code>)是否小于或等于<code class="fe ms mt mu mv b">1</code>。既然不是，我们继续，<code class="fe ms mt mu mv b">return</code>就是<code class="fe ms mt mu mv b">n</code>乘以<code class="fe ms mt mu mv b">n-1</code>的乘积的值。因为递归，我们可以用期望的数字<code class="fe ms mt mu mv b">n</code>调用这个函数一次，它会循环通过，递减<code class="fe ms mt mu mv b">1</code> <code class="fe ms mt mu mv b">UNTIL</code> <code class="fe ms mt mu mv b">n</code>等于或小于<code class="fe ms mt mu mv b">1</code>。这需要理解很多东西，尤其是如果你不熟悉递归的话。下面是这个函数的运行情况:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/51552f3f5de9bc5e91faa39f55380b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*zyG_19KjOYpOXjOjgZejxA.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">阶乘函数在起作用。</figcaption></figure><p id="2183" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(作为参考，阶乘是一个数乘以每一个小于它的数的乘积，大于0。)</p><p id="7db2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数获取数字<code class="fe ms mt mu mv b">8</code>，将其乘以<code class="fe ms mt mu mv b">7</code>，乘以<code class="fe ms mt mu mv b">6</code>，然后乘以<code class="fe ms mt mu mv b">5</code> …等等。一直到<code class="fe ms mt mu mv b">1</code>，全部6行代码。如果没有递归，这将是不负责任的复杂。</p><p id="1f6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">递归和一个<code class="fe ms mt mu mv b">if</code>语句解决了我对Javascript拥有一个until循环的渴望，尽管这是不必要的。</p><p id="3a54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是说实话，这个例子太深奥了，很难理解递归到底有多棒。来看一个实际使用。</p><h2 id="a95e" class="lu lv iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated"><a class="ae ns" href="https://github.com/jackismoe/blackjack" rel="noopener ugc nofollow" target="_blank">反应杰克</a></h2><p id="a08d" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">最近，我建立了一个黑杰克模拟器。在二十一点的游戏中，每个玩家包括发牌者最初会得到两张扑克牌。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nt"><img src="../Images/df0f8edf9fb61b1918b2af4b9fb0904e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4SY16t4Zm-_Dh09rgJbunw.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">二十一点中发两张牌的功能</figcaption></figure><p id="64cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ms mt mu mv b">dealFirstTwo()</code>函数中，变量<code class="fe ms mt mu mv b">index</code>将在<code class="fe ms mt mu mv b">1</code>和(初始)<code class="fe ms mt mu mv b">52</code>之间创建一个随机数。它将在我创建的名为<code class="fe ms mt mu mv b">wholeDeck</code>的对象数组中找到一个<code class="fe ms mt mu mv b">card</code>，该数组包含所有52张扑克牌，它们在数组中的索引对应于<code class="fe ms mt mu mv b">index</code>变量。然后，它会将找到的<code class="fe ms mt mu mv b">card</code>对象的属性<code class="fe ms mt mu mv b">dealt</code>设置为<code class="fe ms mt mu mv b">true</code>。<code class="fe ms mt mu mv b">sortDeck()</code>函数将变量<code class="fe ms mt mu mv b">sortedDeck</code>设置为等于<code class="fe ms mt mu mv b">wholeDeck</code>数组中的所有对象，这些对象的<code class="fe ms mt mu mv b">dealt</code>属性等于<code class="fe ms mt mu mv b">false</code>，这在第一遍中是除了第一张<code class="fe ms mt mu mv b">card</code>之外的所有牌。然后，该函数将把找到的<code class="fe ms mt mu mv b">card</code>推入作为参数传递给该函数的<code class="fe ms mt mu mv b">hand</code>(或者是<code class="fe ms mt mu mv b">playerHand</code>或者是<code class="fe ms mt mu mv b">dealerHand</code>，两者最初都是空数组)。最后，该函数检查作为参数传入的<code class="fe ms mt mu mv b">hand</code>的长度，如果长度不等于或大于<code class="fe ms mt mu mv b">2</code>，它将重复该函数。</p><p id="2045" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">TL；给我一个随机数，根据这个数在一副牌中找到一张牌，告诉这张牌已经发了，告诉这副牌已经发了，告诉玩家这张牌属于它，如果玩家手里没有两张牌，给它另一张牌。</em></p><p id="e388" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用这个函数两次，分别将<code class="fe ms mt mu mv b">playerHand</code>和<code class="fe ms mt mu mv b">dealerHand</code>作为参数传递给函数，我们可以有效地给一个玩家和一个庄家发两张牌(理论上，可以根据需要发给很多玩家)。</p><p id="631c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个例子，我的21点模拟器中的另一个处理玩家初始回合的函数也使用了递归。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nu"><img src="../Images/d65ebcc3ce273d085796f8cdf1fdbdfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mBrp-Ep0zwL_98FDCnydw.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">处理21点中的玩家回合</figcaption></figure><p id="0070" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数有点长，但是实现了相同的想法。一个玩家要么破产，要么选择留下，继续给这个玩家一张牌。<br/>这里我们有一个<code class="fe ms mt mu mv b">if…else</code>语句，另一个<code class="fe ms mt mu mv b"> if…else</code>语句嵌套在初始的<code class="fe ms mt mu mv b">else</code>分支内。</p><p id="1b69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们一行一行地看到:</p><p id="356a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe ms mt mu mv b">playerTotal</code>(一个设置为给定<code class="fe ms mt mu mv b">hand</code>中所有牌值总和的变量)大于<code class="fe ms mt mu mv b">21</code>，告诉玩家‘你已经被抓了’，展示隐藏的庄家牌，然后<code class="fe ms mt mu mv b">seeWhoWon()</code>。如果<code class="fe ms mt mu mv b">playerTotal</code>不大于<code class="fe ms mt mu mv b">21</code>，发送一个确认窗口告诉玩家他们的<code class="fe ms mt mu mv b">total</code>，并询问玩家是否想要另一个<code class="fe ms mt mu mv b">card</code>(这将返回一个布尔值)。如果玩家要<code class="fe ms mt mu mv b">hit</code>，<code class="fe ms mt mu mv b">dealOne()</code>函数发一张牌(这个函数和上面的函数<code class="fe ms mt mu mv b">dealFirstTwo()</code>一样，没有递归<code class="fe ms mt mu mv b">if</code>语句)。<code class="fe ms mt mu mv b">playerTotal</code>将被更新，<code class="fe ms mt mu mv b">showTertiaryPlayerCards()</code>将在屏幕上显示已发牌的<code class="fe ms mt mu mv b">card</code>，500毫秒后，该功能将重复。如果玩家不想玩<code class="fe ms mt mu mv b">hit</code>，我们就把这个回合交给庄家，这是一个类似的功能，但对我非常简单的“人工智能”来说，有一些更多的规范。</p><p id="f9f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">TL；检查一下玩家是否被终结了。如果没有，问他们是否想要一张卡。如果他们这样做，给他们一个，并重复。如果他们不这样做，就轮到经销商了。如果他们失败了，庄家就没有机会了，因为庄家自动赢了。</em></p><p id="4d8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这已经为一些人澄清了递归的概念，如果没有，也许它能够向你展示这个概念背后的效用。<br/>干杯！</p></div></div>    
</body>
</html>