<html>
<head>
<title>Solving The Two-Sum Problem in Javascript, Three Ways.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Javascript解决二和问题，三种方法。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solving-the-two-sum-problem-in-javascript-three-ways-4d43067fcfc7?source=collection_archive---------0-----------------------#2020-02-03">https://levelup.gitconnected.com/solving-the-two-sum-problem-in-javascript-three-ways-4d43067fcfc7?source=collection_archive---------0-----------------------#2020-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ff3daea1ebd0d056801cb1c0ff3b92e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ww_kGxT_HRoNzbDGEZ03Yw.png"/></div></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h2 id="cd91" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">这个Github repo包含我为所有三个解决方案模型完成的代码。</h2></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="950b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">什么是二和问题？</p><blockquote class="lx"><p id="943c" class="ly lz iq bd ma mb mc md me mf mg lw dk translated">给定一个整数数组和一个目标数，返回加起来等于目标数的两个整数</p></blockquote><figure class="mi mj mk ml mm jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/59f076831ac915dac8d75b8aff042f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*E7Wk4TgNPZaswlccsIp2Fw.jpeg"/></div></figure><h2 id="8669" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">备注:</strong></h2><p id="1263" class="pw-post-body-paragraph lc ld iq le b lf mn lh li lj mo ll lm ko mp lo lp ks mq lr ls kw mr lu lv lw ij bi translated"><em class="ms">期望的结果可以以几种不同的形式返回——我见过查询要么询问</em> <a class="ae lb" href="https://www.mathsisfun.com/definitions/addend.html" rel="noopener ugc nofollow" target="_blank"> <em class="ms">加数</em> </a> <em class="ms">的</em> <a class="ae lb" href="https://en.wikipedia.org/wiki/Array_data_structure" rel="noopener ugc nofollow" target="_blank"> <em class="ms">索引</em> </a> <em class="ms">(也就是它们在数组中的位置)，要么询问加数本身。</em></p><p id="340a" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated"><em class="ms">此外，有些挑战的结构是这样的，只有一对数字加起来才是总数。</em></p><p id="bd3b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated"><em class="ms">在我的解中，我将返回</em> <strong class="le ir"> <em class="ms">所有离散成功的加数对</em> </strong> <em class="ms">。</em></p><p id="ad7b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated"><em class="ms">我将简要地说明调整我的解决方案以返回一个</em> <strong class="le ir"> <em class="ms">单加数对</em> </strong> <em class="ms">或</em> <strong class="le ir"> <em class="ms">数组索引而不是加数本身的方法。</em> </strong></p><p id="9b0f" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我将使用<strong class="le ir">数组【2，3，4，3，6，7】</strong>和<strong class="le ir">和整数6 </strong>来测试所有的解决方案。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="779b" class="mt kg iq bd kh mu mv mw kk mx my mz kn na nb nc kr nd ne nf kv ng nh ni kz nj bi translated">1:蛮力</h1><p id="e0f0" class="pw-post-body-paragraph lc ld iq le b lf mn lh li lj mo ll lm ko mp lo lp ks mq lr ls kw mr lu lv lw ij bi translated">对于我的第一个解决方案，我没有优先考虑优雅或性能，只是试图破解一个可行的解决方案。一旦我有了一些可用的原材料，并且对寻找我想要的数字的机制有了初步的了解，那么我就可以用我的解决方案来解决时间复杂度等问题。</p><p id="2465" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">因为我知道我可能需要找到多个正确的数字组合，所以我从一个空数组开始，并计划将我成功的数字组合传递给它，然后返回数字组合的数组。</p><p id="2195" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">如果在挑战开始时确定每个sum + array组合只能有一个成功的解，我可以跳过这一步，一旦找到就返回正确的加数。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="50b8" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">首先，我需要找到成功的组合。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ce37" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我首先创建两个循环，允许我遍历数组中的每个数字组合。现在我可以测试组合，看看它们中是否有任何一个加起来达到<strong class="le ir"> <em class="ms">总和</em> </strong>。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="de77" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">如果是这样，我想把它们保存在我的容器数组中，我会在结束循环后返回这个数组。</p><p id="3ae2" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">如果我想要的是<strong class="le ir"> <em class="ms">索引</em> </strong>而不是<strong class="le ir"> <em class="ms">数字元素</em> </strong>本身，我可以将<strong class="le ir"><em class="ms">x</em></strong>&amp;<strong class="le ir"><em class="ms">y</em></strong>推送到<strong class="le ir"> <em class="ms"> nums </em> </strong>数组中。</p><p id="f71a" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">当在控制台中运行时，该函数返回:</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b3e5" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">✔️这个函数查找并返回[2，4]和[3，3]。</p><p id="d7dc" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">✖️:每个人还会多次退货。不是我们想要的。</p><p id="e028" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我可以尝试在推入新的数字组合之前检查nums数组，但是我使用的嵌套数组格式使这变得很麻烦。</p><p id="9283" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated"><em class="ms">注意:检查当前元素的nums.flat(Infinite)是完全合理的，但是我选择了一个计算开销稍小的选项。</em></p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="154b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我添加了一个额外的数组<strong class="le ir"> <em class="ms"> prevNums </em> </strong>用于存储找到的数字，现在可以在将一个数字推入<strong class="le ir"> <em class="ms"> nums </em> </strong>之前检查是否已经找到添加的&amp;数字。只有当<strong class="le ir"> <em class="ms"> nums </em> </strong>不为空时，我才会这样做。</p><p id="1c81" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">这个回报是什么？</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="eafd" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">太好了！这正是我想要的结果。🌟</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="5bb3" class="mt kg iq bd kh mu mv mw kk mx my mz kn na nb nc kr nd ne nf kv ng nh ni kz nj bi translated">2:二分搜索法</h1><p id="91d8" class="pw-post-body-paragraph lc ld iq le b lf mn lh li lj mo ll lm ko mp lo lp ks mq lr ls kw mr lu lv lw ij bi translated">好了，我有了第一层。我可以在一个数组中找到给定总和的组合，并以清晰、可读、无冗余的格式返回它们。</p><p id="f10b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">但是，如果我的数组不是<strong class="le ir">【2，3，4，3，6，7】</strong>，而是一个上千个数的数组呢？甚至可能上万？基于我的第一个解决方案模型，我将不得不迭代无数的数字组合，即使我的总和仍然只有<strong class="le ir"> 6 </strong>。</p><p id="b88c" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">这是对计算能量的巨大浪费。</p><p id="e71b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">在这里，我不打算深入探讨<a class="ae lb" href="https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/" rel="noopener ugc nofollow" target="_blank">时间复杂度</a>的概念，但是我想找到一个比我最初的暴力模型更好的解决方案，因为需要更少的计算。</p><p id="cb4f" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">为了做到这一点，我将使用一个<a class="ae lb" href="https://www.computerhope.com/jargon/b/binary-search.htm" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>。</p><p id="b673" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我将编写一个帮助函数来执行二分搜索法本身，然后第二个函数将利用它来找到给定总和的正确加数。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5882" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我将把四个<a class="ae lb" href="https://www.javascripttutorial.net/es6/javascript-default-parameters/" rel="noopener ugc nofollow" target="_blank">参数</a>传递给<strong class="le ir"> <em class="ms">二进制搜索</em> </strong>助手函数:</p><ul class=""><li id="9305" class="nq nr iq le b lf lg lj lk ko ns ks nt kw nu lw nv nw nx ny bi translated"><strong class="le ir"> <em class="ms">数组</em> </strong> : <strong class="le ir"> <em class="ms"> </em> </strong>这是我们一直在迭代的同一个数组。然而，传递给这个函数的任何数组都需要从低到高排序，这样这个函数才能工作！</li><li id="4c51" class="nq nr iq le b lf nz lj oa ko ob ks oc kw od lw nv nw nx ny bi translated"><strong class="le ir"> <em class="ms">目标</em> </strong>:这是我们要寻找的数字——当应用于<strong class="le ir"> <em class="ms">二加和</em> </strong>解时，这将是一对中的第二个加数<strong class="le ir"><em class="ms"/></strong>。</li><li id="9700" class="nq nr iq le b lf nz lj oa ko ob ks oc kw od lw nv nw nx ny bi translated"><strong class="le ir"> <em class="ms">开始</em> </strong>:我们开始迭代的索引。</li><li id="54df" class="nq nr iq le b lf nz lj oa ko ob ks oc kw od lw nv nw nx ny bi translated"><strong class="le ir"> <em class="ms"> end </em> </strong>:我们停止迭代的索引。</li></ul><p id="ea7d" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">首先，我想找到数组的中间。如果它包含偶数个元素，我需要向下取整。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="889f" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我正在使用</p><blockquote class="lx"><p id="d0d6" class="ly lz iq bd ma mb mc md me mf mg lw dk translated"><strong class="ak"><em class="oe">(start+(end—start)/2)</em></strong></p></blockquote><p id="8fb7" class="pw-post-body-paragraph lc ld iq le b lf of lh li lj og ll lm ko oh lo lp ks oi lr ls kw oj lu lv lw ij bi translated">获得中点的方法，以避免一些潜在的边缘情况错误，如<a class="ae lb" href="https://www.geeksforgeeks.org/start-end-start2-preferrable-method-calculating-middle-array-start-end2/" rel="noopener ugc nofollow" target="_blank">此处</a>所述。</p><p id="7b96" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我想把中点向下舍入到最接近的整数。我可以用</p><blockquote class="lx"><p id="0271" class="ly lz iq bd ma mb mc md me mf mg lw dk translated"><strong class="ak"><em class="oe">math . floor(start+(end—start)/2)</em></strong></p></blockquote><p id="2548" class="pw-post-body-paragraph lc ld iq le b lf of lh li lj og ll lm ko oh lo lp ks oi lr ls kw oj lu lv lw ij bi translated">来处理我的舍入，但是<a class="ae lb" href="http://rocha.la/JavaScript-bitwise-operators-in-practice" rel="noopener ugc nofollow" target="_blank">位</a>操作符<strong class="le ir"> <em class="ms"> ~~ </em> </strong>可以更快地<a class="ae lb" href="// https://blog.blakesimpson.co.uk/page.php?id=58&amp;title=fastest-alternative-to-math-floor-in-javascript" rel="noopener ugc nofollow" target="_blank">完成舍入到最近的整数的相同工作。</a></p><p id="7625" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">因为我将在这个函数中测试几种不同的情况，所以我将使用一个<a class="ae lb" href="https://www.w3schools.com/js/js_switch.asp" rel="noopener ugc nofollow" target="_blank"> switch语句</a>而不是一个<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else" rel="noopener ugc nofollow" target="_blank"> if/else语句</a>。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2024" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">因为我试图让这种方法更有效，所以我从几个时间复杂度成本相对较低的案例开始。</p><p id="ac58" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我会检查以下情况:</p><ul class=""><li id="a97f" class="nq nr iq le b lf lg lj lk ko ns ks nt kw nu lw nv nw nx ny bi translated">1:第一个数字是目标数字。</li><li id="7e6a" class="nq nr iq le b lf nz lj oa ko ob ks oc kw od lw nv nw nx ny bi translated">2:中间的数字是目标数字。</li><li id="2c8b" class="nq nr iq le b lf nz lj oa ko ob ks oc kw od lw nv nw nx ny bi translated">3:最后一个数字是目标数字。</li><li id="13e1" class="nq nr iq le b lf nz lj oa ko ob ks oc kw od lw nv nw nx ny bi translated">4:我要迭代的数组或数组段为空。</li></ul><p id="f9e9" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">如果这些情况都不成立，我可以继续迭代。</p><p id="2c2f" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">为此，我将再添加两个案例:</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9c05" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">如果中间数大于目标数，我知道我们的目标数介于<strong class="le ir"> <em class="ms">阵【开始】</em> </strong>和<strong class="le ir"> <em class="ms">阵【中点】</em> </strong>之间。因此，我<a class="ae lb" href="https://www.geeksforgeeks.org/recursion/" rel="noopener ugc nofollow" target="_blank">递归地</a>在一组新的数字上调用我们的<strong class="le ir"> <em class="ms"> binarySearch </em> </strong>函数，这将只是<strong class="le ir"> <em class="ms">数组【开始】</em> </strong>和<strong class="le ir"> <em class="ms">数组【中点】</em> </strong>之间的元素。</p><p id="1420" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">此外，由于我们已经检查了<strong class="le ir"> <em class="ms"> array[start] </em> </strong>和<strong class="le ir"><em class="ms">array[midpoint]</em></strong>是否与我们在初始情况下的目标数相匹配，我们可以从列表中排除这些元素，只留下在<strong class="le ir"><em class="ms">array[start+1]</em></strong>和<strong class="le ir"><em class="ms">array[midpoint-1]</em></strong>之间的元素。</p><p id="fe10" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">这将找到一个新的起点、终点和中点，并对现在减半的元素集合重复该函数。</p><p id="0afe" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">最后一种情况是如果中间数小于目标数。在这种情况下，我们在<strong class="le ir"> <em class="ms">【中点+1】</em></strong><strong class="le ir"><em class="ms">数组【end-1】</em></strong>之间的元素集合上递归调用<strong class="le ir"> <em class="ms"> binarySearch </em> </strong>。</p><p id="d132" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">其逻辑与前一种情况类似——如果目标数大于排序数组的中点，我们可以确信它不会在前半部分，并且可以跳过对它们的迭代，只查看数组的后半部分(减去中点和结尾，我们已经检查过匹配)。</p><p id="1347" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">使用这种递归方法，我们可以通过重复地将数组一分为二来找到数组中想要的数字，从而执行<a class="ae lb" href="https://stackoverflow.com/questions/8185079/how-to-calculate-binary-search-complexity" rel="noopener ugc nofollow" target="_blank">比我们每次想要查看数组是否包含单个元素时遍历整个数组要少得多的计算</a>。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e355" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">最后，我添加了一个return语句，允许这个函数在所需的值不存在时返回false。</p><p id="1f02" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">如果该函数按预期工作，它将重复执行，直到找到并返回所需的元素，或者如果该元素不在给定的数组中，则返回false。因此，<strong class="le ir"> <em class="ms">二进制搜索</em> </strong>函数的<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Return_values" rel="noopener ugc nofollow" target="_blank">返回值</a>要么是<strong class="le ir">想要的元素</strong>(如果它存在)要么是<strong class="le ir">假的</strong>。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="57a4" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">太好了！现在我们有了工作助手方法🌟</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="8fbe" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">但是，我们如何将它应用到我们的两和问题中呢？</p><p id="326c" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我们知道，为了使用二分搜索法，我们需要从一个排序的数组开始，所以我们将从排序初始数组开始。</p><p id="9af7" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">然后，我们可以通过创建两个空数组来建立与前面相同的基本结构:一个用于存储包含成功的加数组合的嵌套数组，另一个用于存储可访问的顶层组合中的元素，以供以后检查。</p><p id="a069" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我们需要找到所有这些元素的组合，将它们存储在我们的<strong class="le ir"> <em class="ms"> nums </em> </strong>数组中，然后像上次一样，在最后返回该数组。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="cd30" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">然而，这一次，我们不会创建嵌套循环来迭代。</p><p id="088a" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">这一次，我们只遍历数组一次。</p><p id="a0f0" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">对于每个元素，值<strong class="le ir"> <em class="ms">加数</em> </strong>将被分配给等于<strong class="le ir"> <em class="ms">总和</em> </strong>减去该元素的数。</p><p id="7b43" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">所以，对于<strong class="le ir"> <em class="ms"> 6 </em> </strong>和<strong class="le ir"> <em class="ms"> 2 </em> </strong>的一个元素的和，加数就是整数<strong class="le ir"> <em class="ms"> 4 </em> </strong>。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="51d9" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">这给了我们一个目标整数，这正是我们的<strong class="le ir"> <em class="ms"> binarySearch </em> </strong>函数所需要的。</p><p id="638a" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">所以这一次，我们将使用<strong class="le ir"> <em class="ms">二进制搜索</em> </strong>助手函数来为我们完成这项工作。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4ab3" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">这样，我们不用嵌套迭代器，而是找到任何给定组合中的第二个数字，然后使用更有效的二分搜索法方法来查看该数字是否在数组中的任何位置。</p><p id="55bc" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">正如我们之前所做的，我们可以使用<strong class="le ir"> <em class="ms"> prevNum </em> </strong>数组作为一个工具来存储和检查之前找到的解决方案，所以我们不会返回多余的组合。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c9cc" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">太好了！这也返回了我们想要的结果🌟</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="ccba" class="mt kg iq bd kh mu mv mw kk mx my mz kn na nb nc kr nd ne nf kv ng nh ni kz nj bi translated">3:哈希</h1><p id="e233" class="pw-post-body-paragraph lc ld iq le b lf mn lh li lj mo ll lm ko mp lo lp ks mq lr ls kw mr lu lv lw ij bi translated">使用二分搜索法使我们的最后一个解决方案比强力嵌套循环解决方案更有效，但是还有可能改进更多吗？</p><p id="a1eb" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">还有另一个工具可以帮助我们有效地检查我们想要的加数是否存在于我们的数组中:一个<a class="ae lb" href="https://medium.com/javascript-in-plain-english/algorithm-in-javascript-hash-table-7b0464d2b81b" rel="noopener">散列表</a>。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8e0b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">这一次，除了我们的空<strong class="le ir"> <em class="ms"> nums </em> </strong>数组之外，我们从一个空的<a class="ae lb" href="https://javascript.info/object" rel="noopener ugc nofollow" target="_blank">对象</a>、<strong class="le ir"> <em class="ms">存储哈希</em> </strong>开始。</p><p id="635d" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">就像我们之前做的一样，我们想要遍历我们的数组，并找到<strong class="le ir"> <em class="ms"> sum </em> </strong>减去每个元素的余数。然后，我们想看看那个余数是否存在于<strong class="le ir"> <em class="ms">数组</em> </strong>中。如果是这样，我们将把余数和元素都推入到<strong class="le ir"> <em class="ms"> nums </em> </strong>数组中，我们最终将在循环结束后返回这个数组。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1240" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我们可以通过从sum中减去当前元素来找到所需的加数，但是如果不使用另一个嵌套循环或我们的二分搜索法函数，我们如何知道它是否存在于该区域中呢？</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ee66" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">让我们开始使用<strong class="le ir"> <em class="ms">存储哈希</em> </strong>。</p><p id="8e21" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">随着每一次迭代，我们将添加一个新的<a class="ae lb" href="https://stackoverflow.com/questions/25955749/what-is-a-key-value-pair" rel="noopener ugc nofollow" target="_blank">键-值对</a>到<strong class="le ir"> <em class="ms"> storageHash </em> </strong>:一个<strong class="le ir"> <em class="ms">数组【I】</em></strong>(<strong class="le ir"><em class="ms">元素)</em> </strong>的<strong class="le ir"> <em class="ms">键</em>和一个<strong class="le ir"> <em class="ms"> i </em> </strong>的<strong class="le ir"> <em class="ms">值</em></strong></strong></p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4bf6" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">现在，当我们发现一个新的加数，并想检查它是否存在于我们的数组中时，我们可以在<strong class="le ir"> <em class="ms"> storageHash </em> </strong>中查找那个键。这是一个很好的操作，因为它只需要检查<a class="ae lb" href="https://stackoverflow.com/questions/697918/what-does-o1-access-time-mean/697935" rel="noopener ugc nofollow" target="_blank">内存</a>中的一个特定位置，而不需要遍历连接元素的集合。</p><p id="97fa" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">如果key存在于<strong class="le ir"> <em class="ms"> storageHash </em> </strong>中，那么我们知道number也存在于<strong class="le ir"> <em class="ms">数组</em> </strong>中。</p><p id="7e93" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">因此，我们可以安全地将我们已经对照<strong class="le ir"> <em class="ms"> storageHash </em> </strong>检查过的加数与我们当前的数组元素结合起来，并将它们添加到我们的<strong class="le ir"> <em class="ms"> nums </em> </strong>数组中，以便以后返回。</p><p id="1905" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">让我们在<a class="ae lb" href="https://developers.google.com/web/tools/chrome-devtools/console/javascript" rel="noopener ugc nofollow" target="_blank">浏览器控制台</a>中测试一下:</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="55ca" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">太好了！这给出了我们想要的结果。🌟</p><p id="750d" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">我们现在可以使用哈希表直接查找每个潜在的加数，而不是遍历数组元素的每个可能的组合，或者甚至为每个元素找到所需的加数并在数组中搜索它(即使使用像二分搜索法这样相对高效的方法)。</p><p id="903b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">这种方法也很好，因为它不需要对初始数组进行排序，也不需要从最终数组中去除多余的正确组合。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="af77" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">就是这样！希望这些解决方案可以帮助您解决寻找两个数组元素相加得到一个给定和的挑战。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/534a4cdd9b845dc345d63613f1e9f10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*yg19jmYKWpyaANFLEbRP5Q.gif"/></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="cdca" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ko ln lo lp ks lq lr ls kw lt lu lv lw ij bi translated">如果你想阅读更多关于解决这个问题的各种方法及其各自的好处，我真的很喜欢这篇文章 ( <strong class="le ir">警告:自动pdf下载！</strong>)。</p></div></div>    
</body>
</html>