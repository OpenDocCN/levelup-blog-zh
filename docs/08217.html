<html>
<head>
<title>How to pre-load objects for your Hapi route handlers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为哈比神路线处理程序预加载对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/hapi-using-pre-route-functions-for-fun-and-profit-ccc14158cf0f?source=collection_archive---------12-----------------------#2021-04-11">https://levelup.gitconnected.com/hapi-using-pre-route-functions-for-fun-and-profit-ccc14158cf0f?source=collection_archive---------12-----------------------#2021-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5702d60e914fe521b203e6415e5bcf13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QH4pHxBJOn5WBRq5wK4jeQ.png"/></div></div></figure><div class=""/><p id="a0d7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者，如何使用哈比神预路由处理程序</p><h2 id="c3fe" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">问题是</h2><p id="8ae5" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">随着我在最新的项目中加入更多的方法，我意识到浪费的精力越来越多。</p><p id="2a3d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在每个处理项目的端点中，我们必须获取项目。这也意味着每个端点还必须检查用户是否有权访问该项目。当我开始添加属于事物的事物时，我们必须检查拥有的所有权链，这开始变得乏味。</p><p id="0dfb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我开始想——Express有中间件，我想知道哈比神有什么？肯定有什么东西，所以我可以做一次工作，并把它存储在请求对象中。</p><p id="e528" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lx" href="https://hapi.dev/api/" rel="noopener ugc nofollow" target="_blank">到API文档！</a></p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/9644faaef3014741c80a4d84fc587b14.png" data-original-src="https://miro.medium.com/v2/1*XBBGLU6lkm8g0PPcPlN0vQ.gif"/></div></figure><h2 id="d3f4" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">解决方法</h2><h2 id="afcb" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated"><a class="ae lx" href="https://hapi.dev/api/?v=20.1.2#-routeoptionsvalidateparams" rel="noopener ugc nofollow" target="_blank">验证</a></h2><p id="ff52" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这些开始看起来很有希望——毕竟，我们正在验证请求参数。</p><p id="a38c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不幸的是，它们没有帮助——验证不能添加到请求上下文中，所以验证函数将获取项目，然后该函数必须再次获取项目。(或者我们开始做一些缓存——可能，但过于复杂。)</p><h2 id="4cd1" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated"><a class="ae lx" href="https://hapi.dev/api/?v=20.1.2#plugins" rel="noopener ugc nofollow" target="_blank">插件</a></h2><p id="7449" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">接下来，我看了看插件。不过，对我来说，它们并不太合适。</p><p id="272e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">插件是在整个服务器上注册的，而不是一个单独的路由。但是这带来了一个问题——您如何知道哪些请求必须有参数，哪些没有？没有它，您仍然需要检查端点函数，这不是我想要的。</p><h2 id="f59f" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated"><a class="ae lx" href="https://hapi.dev/api/?v=20.1.2#-routeoptionspre" rel="noopener ugc nofollow" target="_blank">预路由功能</a></h2><p id="a034" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这些看起来更有希望。它们在<a class="ae lx" href="https://hapi.dev/tutorials/auth/?lang=en_US" rel="noopener ugc nofollow" target="_blank">认证</a>之后运行，所以你已经得到了用户凭证。它们可以添加到请求上下文中——它们返回的值进入<a class="ae lx" href="https://hapi.dev/api/?v=20.1.2#-requestpre" rel="noopener ugc nofollow" target="_blank">到</a> <code class="fe md me mf mg b"><a class="ae lx" href="https://hapi.dev/api/?v=20.1.2#-requestpre" rel="noopener ugc nofollow" target="_blank">request.pre</a></code> <a class="ae lx" href="https://hapi.dev/api/?v=20.1.2#-requestpre" rel="noopener ugc nofollow" target="_blank">对象</a>。您可以将它们添加到单独的路线中。</p><p id="7cf2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看来我们有赢家了！</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/280971406f593212776a06a43d06b138.png" data-original-src="https://miro.medium.com/v2/1*DPxfB54RUPZNBA94Kr9RFQ.gif"/></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="0c96" class="mo la je bd lb mp mq mr le ms mt mu lh mv mw mx lk my mz na ln nb nc nd lq ne bi translated">尝试一下</h1><p id="8293" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我们需要一些东西来开始。让我们使用模板和验证来扩展<a class="ae lx" href="https://www.solarwinter.net/hapi-vision-and-joi/" rel="noopener ugc nofollow" target="_blank">上的帖子中的人员服务器。</a></p><p id="6a6d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还将在不使用预路由功能的情况下进行第一次尝试。这让我们检查基本流程是否工作，因为我们以前没有使用过它们，我们可以看到它对代码有什么样的影响。</p><p id="999d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有一个路由，<code class="fe md me mf mg b">/people</code>，用来获取我们存储的所有人的列表。让我们添加一个新的路线来获得个人。会很好的休息。</p><h2 id="f720" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">试验</h2><p id="2237" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">首先——像往常一样——我们添加了一个测试。</p><pre class="ly lz ma mb gt nf mg ng nh aw ni bi"><span id="0b66" class="kz la je mg b gy nj nk l nl nm">.   it("can get an individual person", async () =&gt; {<br/>        const res = await server.inject({<br/>            method: "get",<br/>            url: "/people/1"<br/>        });<br/>        expect(res.statusCode).to.equal(200);<br/>        expect(res.payload).to.not.be.null;<br/>    });</span></pre><p id="883f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然会失败，因为服务器还不知道这条路由。</p><h2 id="4a26" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">模板</h2><p id="c11c" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">接下来，我们将添加将要使用的模板。我们保持它真正的基础——这不是让东西看起来漂亮，只是测试一个概念。</p><pre class="ly lz ma mb gt nf mg ng nh aw ni bi"><span id="921a" class="kz la je mg b gy nj nk l nl nm">&lt;html&gt;<br/>	&lt;head&gt;<br/>		&lt;title&gt;Purple People Eaters&lt;/title&gt;<br/>	&lt;/head&gt;<br/>	&lt;body&gt;<br/>        &lt;p&gt;&lt;%= person.name %&gt; - &lt;%= person.age %&gt;&lt;/p&gt;<br/>		&lt;a href="/people"&gt;Go back to people&lt;/a&gt;<br/>	&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h2 id="edbb" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">密码</h2><p id="1a1c" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">现在我们开始添加实际的代码。我们需要做的第一件事是扩展路由表:</p><pre class="ly lz ma mb gt nf mg ng nh aw ni bi"><span id="4f40" class="kz la je mg b gy nj nk l nl nm">export const peopleRoutes: ServerRoute[] = [<br/>    { method: "GET", path: "/people", handler: showPeople },<br/>    { method: "GET", path: "/people/{personId}", handler: showPerson },<br/>    { method: "GET", path: "/people/add", handler: addPersonGet },<br/>    { method: "POST", path: "/people/add", handler: addPersonPost }  <br/>];</span></pre><p id="d973" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后是处理函数。因为我们在这个项目中不处理认证，所以它已经相当简单了。</p><pre class="ly lz ma mb gt nf mg ng nh aw ni bi"><span id="ff51" class="kz la je mg b gy nj nk l nl nm">async function showPerson(request: Request, h: ResponseToolkit): Promise&lt;ResponseObject&gt; {<br/>    const person = people.find(person =&gt;<br/>        person.id == parseInt(request.params.personId)<br/>    );<br/>    return h.view("person", { person: person });<br/>}</span></pre><p id="073a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我们在这里跳过了错误检查，以便启动并运行一些东西。而且很管用！</p><pre class="ly lz ma mb gt nf mg ng nh aw ni bi"><span id="23bc" class="kz la je mg b gy nj nk l nl nm">server handles people - positive tests<br/>    ✓ can see existing people<br/>    ✓ can show 'add person' page<br/>    ✓ can add a person and they show in the list<br/>    ✓ can get an individual person</span></pre><h2 id="6bf1" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">使用pre</h2><p id="f6fb" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">第一件事是检查预路由处理程序所需的函数签名。它看起来非常类似于标准的请求处理程序，但是具有不同的返回类型。</p><p id="a1f8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是有意义的——请求处理程序返回HTTP响应，而预路由处理程序可能返回对象。</p><p id="d63b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它需要是健壮的——这是检查传入数据正确性的函数——所以我们添加了通常在HTTP路由中的所有错误检查。我们的设计是要么返回一个有效的对象，要么抛出一个异常，所以我们把返回类型设为<code class="fe md me mf mg b">Person</code>。</p><pre class="ly lz ma mb gt nf mg ng nh aw ni bi"><span id="d4b1" class="kz la je mg b gy nj nk l nl nm">async function checkPerson(request: Request, h: ResponseToolkit): Promise&lt;Person&gt; {<br/>    // Did the user actually give us a person ID?<br/>    if (!request.params.personId) {<br/>        throw Boom.badRequest("No personId found");<br/>    }<br/><br/>    try {<br/>        const person = people.find(person =&gt; person.id == parseInt(request.params.personId));<br/>        if (!person) {<br/>              throw Boom.notFound("Person not found");<br/>        }<br/>        return person;<br/>    } catch (err) {<br/>        console.error("Error", err, "finding person");<br/>        throw Boom.badImplementation("Error finding person");<br/>    }<br/>}<br/>const checkPersonPre = { method: checkPerson, assign: "person" };</span></pre><p id="151c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要更改路由表来添加新选项:</p><pre class="ly lz ma mb gt nf mg ng nh aw ni bi"><span id="1c0b" class="kz la je mg b gy nj nk l nl nm">{ method: "GET", path: "/people/{personId}", handler: showPerson, options: { pre: [checkPersonPre] } },</span></pre><p id="3a7c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后更新<code class="fe md me mf mg b">showPerson</code>功能:</p><pre class="ly lz ma mb gt nf mg ng nh aw ni bi"><span id="ca21" class="kz la je mg b gy nj nk l nl nm">async function showPerson(request: Request, h: ResponseToolkit): Promise&lt;ResponseObject&gt; {<br/>    return h.view("person", { person: request.pre.person });<br/>}</span></pre><p id="23a3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">甚至在我们的玩具项目中，我们的HTTP处理程序现在看起来干净多了。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="b130" class="mo la je bd lb mp mq mr le ms mt mu lh mv mw mx lk my mz na ln nb nc nd lq ne bi translated">在实际项目中的使用</h1><p id="94fa" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">举一个我正在开发的项目的例子，你可以看到它带来了更大的不同。</p><p id="21c8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在改变之前，每条路线都必须:</p><ul class=""><li id="9431" class="nn no je kd b ke kf ki kj km np kq nq ku nr ky ns nt nu nv bi translated">获取站点，检查是否允许用户引用站点</li><li id="a104" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated">获取事件，检查它是否连接到该站点</li><li id="6d46" class="nn no je kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated">处理丢失/错误的值</li></ul><p id="6730" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大概是这样的:</p><pre class="ly lz ma mb gt nf mg ng nh aw ni bi"><span id="e632" class="kz la je mg b gy nj nk l nl nm">async function deleteEventPost(request: Request, h: ResponseToolkit): Promise&lt;ResponseObject&gt; {<br/>    try {<br/>        if (!request.params.siteId) {<br/>            throw Boom.badRequest("No site ID");<br/>        }<br/>        if (!request.params.eventId) {<br/>            throw Boom.badRequest("No event ID");<br/>        }<br/><br/>        // We don’t actually want the site or event, we just <br/>        // want to confirm ownership.<br/>        const site = await getSite(request.auth.credentials.id, request.params.siteId);<br/>        if (!site) {<br/>            throw Boom.notFound();<br/>        }<br/>        const event = await getEvent(site.id, request.params.eventId);<br/>        if (!event) {<br/>            throw Boom.notFound();<br/>        }<br/><br/>        await deleteEvent(event.id);<br/>        return h.redirect(`/sites/${site.id}/events`);<br/>    } catch (err) {<br/>        console.error("Error", err);<br/>        throw Boom.badImplementation("error deleting event");<br/>    }<br/>}</span></pre><p id="bd0b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在添加了预路由处理程序之后，它精简了很多:</p><pre class="ly lz ma mb gt nf mg ng nh aw ni bi"><span id="0d7c" class="kz la je mg b gy nj nk l nl nm">async function deleteEventPost(request: Request, h: ResponseToolkit): Promise&lt;ResponseObject&gt; {<br/>    try {<br/>        await deleteEvent(request.pre.event.id);<br/>        return h.redirect(`/sites/${request.pre.site.id}/events`);<br/>    } catch (err) {<br/>        console.error("Error", err);<br/>        throw Boom.badImplementation("error deleting event");<br/>    }<br/>}</span></pre><p id="0671" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对几乎每一个功能都重复这一点，你就会明白为什么这是一个成功！</p><p id="fe07" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有工作都在一个地方完成——实际的视图功能可以假设数据在那里并且是有效的，因为如果不是这样，它们就不会运行，并且它们可以继续做它们实际应该做的事情。</p><h1 id="f630" class="mo la je bd lb mp ob mr le ms oc mu lh mv od mx lk my oe na ln nb of nd lq ne bi translated">结束</h1><p id="e714" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">嗯，就是这样。如果有帮助，请告诉我。像往常一样，帖子中的代码可以在<a class="ae lx" href="https://github.com/arafel/hapi-route-pre" rel="noopener ugc nofollow" target="_blank">我的Github repo </a>中找到。</p></div></div>    
</body>
</html>