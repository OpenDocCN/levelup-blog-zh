<html>
<head>
<title>7 Algorithms to Know Before Your Next System Design Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一次系统设计面试前需要了解的7种算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-algorithms-to-know-before-your-next-system-design-interview-d1de2f374ffa?source=collection_archive---------0-----------------------#2022-12-20">https://levelup.gitconnected.com/7-algorithms-to-know-before-your-next-system-design-interview-d1de2f374ffa?source=collection_archive---------0-----------------------#2022-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="552e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让你的下一次系统设计面试有一个好的开始。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d22d1358529de222ddc85c17dd46c25e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGI3WyrS8_axVkeXx1JM9w.png"/></div></div></figure><p id="9f28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本帖中，我们将讨论七个系统设计概念，它们可以用来解决与分布式系统相关的设计问题。由于这些概念可以应用于所有类型的分布式系统，它们在系统设计面试中变得非常方便。</p><p id="a9bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们将要讨论的概念列表:</p><ol class=""><li id="9dbe" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">Merkle树</li><li id="1152" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">一致散列法</li><li id="03e6" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">读取修复</li><li id="d9f8" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">八卦协议</li><li id="ab86" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">布隆过滤器</li><li id="13cc" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">心跳</li><li id="d42d" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">CAP和PACELC定理</li></ol><p id="f27c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始吧。</p><h1 id="332c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">1.Merkle树</h1><p id="c6ee" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">用于识别服务器之间的数据不一致。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/60e39c3ece90522cc6636b8b1bf206ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/0*zrmNIzTcyPjPjni_.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Merkle树</figcaption></figure><h2 id="1e2a" class="mt lm iq bd ln mu mv dn lr mw mx dp lv jy my mz lz kc na nb md kg nc nd mh ne bi translated">背景</h2><p id="0ef3" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">分布式系统在不同的服务器上维护多个数据副本(称为副本),以实现容错和更高的可用性。为了保持所有副本服务器之间的数据同步，系统需要一种有效的机制来比较两个副本之间的数据。在分布式环境中，我们如何快速比较驻留在两个不同副本上的一系列数据的两个副本，并准确找出哪些部分不同？</p><h2 id="b433" class="mt lm iq bd ln mu mv dn lr mw mx dp lv jy my mz lz kc na nb md kg nc nd mh ne bi translated">定义</h2><p id="a400" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">副本可以包含大量数据。天真地分割整个范围来计算校验和进行比较是不太可行的；要传输的数据实在太多了。相反，我们可以使用<strong class="jp ir"> Merkle树</strong>来比较范围的副本。</p><h2 id="97b3" class="mt lm iq bd ln mu mv dn lr mw mx dp lv jy my mz lz kc na nb md kg nc nd mh ne bi translated">解决办法</h2><p id="ca43" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">一棵<a class="ae nf" href="https://designgurus.org/path-player?courseid=grokking-the-advanced-system-design-interview&amp;unit=grokking-the-advanced-system-design-interview_1626009840592_0Unit" rel="noopener ugc nofollow" target="_blank"> Merkle树</a>是一棵二进制散列树，其中每个内部节点是它的两个孩子的散列，每个叶子节点是原始数据的一部分的散列。比较Merkle树在概念上很简单:</p><ol class=""><li id="f54c" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">比较两棵树的根哈希。</li><li id="5392" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">如果相等，停止。</li><li id="1259" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">在左右孩子身上递归。</li></ol><p id="c39b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终，这意味着复制品确切地知道范围的哪些部分是不同的，但是交换的数据量被最小化。Merkle树的主要优点是可以独立检查树的每个分支，而不需要节点下载整个树或整个数据集。因此，Merkle树最大限度地减少了同步所需传输的数据量，并减少了磁盘读取次数。</p><p id="3f76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Merkle树的缺点是，当一个节点加入或离开时，许多键范围可能会改变，此时需要重新计算树。</p><h2 id="16e8" class="mt lm iq bd ln mu mv dn lr mw mx dp lv jy my mz lz kc na nb md kg nc nd mh ne bi translated">例子</h2><p id="f80f" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">为了反熵和解决后台冲突，亚马逊的<strong class="jp ir">发电机</strong>使用Merkle树。</p><p id="5ca0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">详情:<a class="ae nf" href="https://lnkd.in/gZpt67uU" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/gZpt67uU</a></p><h1 id="037e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">2.一致散列法</h1><p id="ac71" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">分布式系统使用一致的散列法在服务器之间分发数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/754da2a52fadffc247bb1f0adecf9468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RoKa0_6i6f92e3ki.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">一致散列环</figcaption></figure><p id="fe0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一致散列有助于两件事:</p><ol class=""><li id="dc89" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">它将数据映射到物理服务器。每当系统想要读取或写入数据时，一致散列告诉我们哪个服务器保存数据。</li><li id="49cc" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">它确保在添加或删除服务器时，只有一小部分键会移动。</li></ol><p id="f678" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多详情:<a class="ae nf" href="https://lnkd.in/dJQKjN6i" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dJQKjN6i</a></p><h1 id="95ff" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">3.读取修复</h1><p id="791c" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">当跨多台服务器复制数据时，读取修复用于将最新版本的数据推送到具有旧版本的服务器。</p><p id="25df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在读取操作期间修复陈旧数据，因为此时，我们可以从多个服务器读取数据，以比较和查找具有陈旧数据的服务器。</p><p id="c451" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">详情:<a class="ae nf" href="https://lnkd.in/g6kCVgvr" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/g6kCVgvr</a></p><h1 id="80b8" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">4.八卦协议</h1><p id="5618" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">用于在服务器之间高效共享状态信息。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/b4fa4de1b3fc832116a68c9f9bfa8c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/0*RsSDnQ_QYNbP4559.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">八卦协议(designgurus.org)</figcaption></figure><p id="8dc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每台服务器都会跟踪集群中其他服务器的状态信息，并每秒钟与一台随机服务器分享这些信息。通过这种方式，最终，每台服务器都可以了解集群中所有其他节点的状态。</p><p id="0297" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">详情:<a class="ae nf" href="https://bit.ly/3D2w14j" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3D2w14j</a></p><h1 id="b07e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">5.布隆过滤器</h1><p id="a066" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">布隆过滤器数据结构告知元素<strong class="jp ir">是否可能在集合中，或者肯定不在</strong>中。唯一可能的错误是误报，即搜索不存在的元素可能会给出不正确的答案。随着滤波器中元件的增加，误差率增加。空的布隆过滤器是全部设置为0的<code class="fe ni nj nk nl b">m</code>位的位阵列。还有<code class="fe ni nj nk nl b">k</code>个不同的散列函数，每个函数将一个集合元素映射到一个<code class="fe ni nj nk nl b">m</code>位位置。</p><ul class=""><li id="9469" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk nm ld le lf bi translated">要添加一个元素，将其提供给哈希函数以获得<code class="fe ni nj nk nl b">k</code>位的位置，并将这些位置的位设置为1。</li><li id="8e52" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk nm ld le lf bi translated">为了测试一个元素是否在集合中，将它提供给哈希函数以获得<code class="fe ni nj nk nl b">k</code>位的位置。</li><li id="00d0" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk nm ld le lf bi translated">如果这些位置的任何位为0，则该元素是集合中的<strong class="jp ir">而不是</strong>。</li><li id="6db0" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk nm ld le lf bi translated">如果都是1，那么元素<strong class="jp ir">可能是集合中的</strong>。</li></ul><p id="bb8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个布隆过滤器，有三个元素<code class="fe ni nj nk nl b">P</code>、<code class="fe ni nj nk nl b">Q</code>和<code class="fe ni nj nk nl b">R</code>。它由20位组成，使用三个哈希函数。彩色箭头指向集合元素映射到的位。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5b9d74a2af87c249976d17936bd5ed8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/0*s2m1tvBKqRJR14ci.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">由20位组成的布隆过滤器。</figcaption></figure><p id="c0e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由20位组成的布隆过滤器。</p><ul class=""><li id="cc9b" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk nm ld le lf bi translated">元素<code class="fe ni nj nk nl b">X</code>肯定不在集合中，因为它散列到一个包含0的位位置。</li><li id="f188" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk nm ld le lf bi translated">对于固定的错误率，添加新元素和测试成员资格都是恒定时间的操作，并且具有用于“n”个元素的空间的过滤器需要<strong class="jp ir"> <em class="no"> O </em> </strong> (n)个空间。</li></ul><p id="b017" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">详情:【https://bit.ly/3TbSAsR T4】</p><h1 id="6dc3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">6.心跳</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/be1f3bef9701d9f290e2beadee483af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WEPyk2eMg1sY130y.png"/></div></div></figure><p id="520d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于广播服务器的健康状态。</p><h2 id="de79" class="mt lm iq bd ln mu mv dn lr mw mx dp lv jy my mz lz kc na nb md kg nc nd mh ne bi translated">背景</h2><p id="6b1f" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">在分布式环境中，数据(或工作)分布在服务器之间。这种设置要求服务器知道系统中还有哪些服务器，以便有效地路由请求。此外，服务器应该能够判断其他服务器是否启动并运行。在分散式环境中，每当请求到达服务器时，服务器应该能够决定哪个服务器负责处理该请求。这样，及时检测服务器故障至关重要，使系统能够采取纠正措施，将数据(或工作)移动到另一台健康的服务器，并阻止环境进一步恶化。</p><h2 id="e526" class="mt lm iq bd ln mu mv dn lr mw mx dp lv jy my mz lz kc na nb md kg nc nd mh ne bi translated">定义</h2><p id="e40e" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">在分布式环境中，每台服务器都会定期向中央监控服务器或系统中的其他服务器发送心跳消息，以表明它仍在运行。</p><h2 id="deaf" class="mt lm iq bd ln mu mv dn lr mw mx dp lv jy my mz lz kc na nb md kg nc nd mh ne bi translated">解决办法</h2><p id="0bb2" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">心跳是分布式系统中检测故障的机制之一。如果有中央服务器，所有服务器都会定期向其发送心跳消息。如果没有中心服务器，所有服务器随机选择一组服务器，每隔几秒钟向它们发送一次心跳消息。这样，如果有一段时间没有从服务器接收到心跳消息，系统可以怀疑服务器可能已经崩溃。如果在配置的超时期限内没有心跳，系统可以断定服务器不再活动，并停止向其发送请求，并开始处理其替代品。</p><h2 id="68a0" class="mt lm iq bd ln mu mv dn lr mw mx dp lv jy my mz lz kc na nb md kg nc nd mh ne bi translated">例子</h2><p id="622c" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated"><strong class="jp ir">谷歌文件系统(GFS) </strong>和<strong class="jp ir"> HDFS </strong>使用心跳与系统中的服务器相互通信，以给出指令和收集状态。</p><p id="9392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">详情:<a class="ae nf" href="https://bit.ly/3eFnT04" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3eFnT04</a></p><h1 id="9431" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">7.CAP和PACELC定理</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/b581f7f31571ace51d85b511869a2850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pbZSyfhO8sGpC1KP.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">CAP和PACELC定理</figcaption></figure><p id="5278" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这两个定理的帮助下，分布式系统可以在一致性、可用性、分区容忍度和延迟之间选择一个好的平衡。<br/> <br/>详情:<a class="ae nf" href="https://lnkd.in/dTFksWj9" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dTFksWj9</a></p><h1 id="877e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="cebb" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">➡实践这些系统设计概念来使自己与众不同！</p><p id="74d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">➡在“<a class="ae nf" href="https://www.designgurus.io/course/grokking-the-system-design-interview" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">探索系统设计面试</strong></a><strong class="jp ir">”</strong>和<strong class="jp ir"/><a class="ae nf" href="https://www.designgurus.io/course/grokking-the-advanced-system-design-interview" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">探索高级系统设计面试</strong> </a>中了解了更多关于这些方法的信息</p><p id="e0e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">➡在Linkedin上关注我，了解系统设计和编码面试的技巧。</p><p id="1e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阅读更多关于系统设计和编码的访谈:</p><div class="nq nr gp gr ns nt"><a href="https://designgurus.org/blog/dont-just-leetcode" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">不要只是LeetCode请遵循编码模式</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">编码面试越来越难通过了。为了准备编码面试，你需要几周甚至几个月的时间…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">designgurus.org</p></div></div><div class="oc l"><div class="od l oe of og oc oh kv nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/system-design-interview-survival-guide-2023-preparation-strategies-and-practical-tips-ba9314e6b9e3"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">系统设计面试生存指南(2023):准备策略和实用技巧</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">2023年系统设计面试剧本。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oc l"><div class="oi l oe of og oc oh kv nt"/></div></div></a></div></div></div>    
</body>
</html>