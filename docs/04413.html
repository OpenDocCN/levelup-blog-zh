<html>
<head>
<title>Rust Adventures: Rust projects management, understanding packages, Crates and modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust Adventures: Rust项目管理，了解包装、板条箱和模块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rust-adventures-rust-projects-management-understanding-packages-crates-and-modules-b3bcde2eb1c?source=collection_archive---------5-----------------------#2020-06-25">https://levelup.gitconnected.com/rust-adventures-rust-projects-management-understanding-packages-crates-and-modules-b3bcde2eb1c?source=collection_archive---------5-----------------------#2020-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2b8403b5c6e11f4e2e3c65f63808d0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W8KBrJgmsIlYtn24AhHfSQ.jpeg"/></div></div></figure><blockquote class="kb kc kd"><p id="4316" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“设计糟糕的代码通常需要更多的代码来做同样的事情，这通常是因为代码在几个地方做了同样的事情。”<br/> ― <strong class="kh iu">马丁·福勒</strong></p></blockquote><p id="f4ec" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">嗨，伙计们！我把学习<a class="ae lg" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>作为2020年的目标。</p><p id="db2f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">今天我们将讨论Rust项目的结构以及如何组织你的代码。虽然货物工作空间也在这个等式中，但为了简单起见，我们不讨论它。</p><h1 id="a8fc" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">介绍</h1><p id="a1e5" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">当我们写小程序时，很容易在我们的大脑中跟踪整个功能。要做简单的演算或练习一些算法，你可以只用一个源代码文件做任何事情，问题是当你需要添加更多的功能时。</p><p id="66ae" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">在普通的软件项目中，你需要写更多的东西。源代码的数量将会急剧增加，你不可能记住你头脑中的所有东西。因此，你需要以一种有意义的方式组织一切。</p><p id="c463" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">这个组织必须封装实现，以向编译器和程序员显示一切在哪里，以及它是如何组织的。</p><h1 id="c97a" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Rust代码管理</h1><p id="64ef" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">Rust解决这个问题的方法是在一个<a class="ae lg" href="https://en.wikipedia.org/wiki/Modular_programming" rel="noopener ugc nofollow" target="_blank">模块化系统</a>中创建4个层次结构:</p><ol class=""><li id="1ac7" class="mk ml it kh b ki kj km kn ld mm le mn lf mo lc mp mq mr ms bi translated"><strong class="kh iu">包装</strong>:一个货物功能，可以让你建造、测试和共享板条箱。可以考虑这个项目。</li><li id="1cfc" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc mp mq mr ms bi translated"><strong class="kh iu"> Crates </strong>:它是一个模块树，可以生成可执行文件或库</li><li id="9dda" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc mp mq mr ms bi translated"><strong class="kh iu">模块和用途</strong>:它负责你的源代码的范围，让你组织你的功能的隐私</li><li id="8e22" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc mp mq mr ms bi translated"><strong class="kh iu">路径</strong>:这是一个命名系统，你用它来命名结构、函数或模块。</li></ol><p id="72dc" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">让我们看看他们每一个人。</p><p id="e7a6" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated"><strong class="kh iu">套餐</strong></p><p id="90b2" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">一个包是一组板条箱，甚至只有一个，提供一些功能，它必须包含一个“Cargo.toml”文件来描述如何构建和编译这些板条箱。</p><p id="396a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">该包可能包含0个或1个库板条箱，但可能包含许多二进制板条箱。作为最后一个细节，它必须至少有一个板条箱。</p><p id="e77c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated"><strong class="kh iu">板条箱</strong></p><p id="e608" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">一个板条箱可以有两种类型:二进制或库。这个包将有一个根目录，它是Rust编译器启动的源文件，并使它成为根模块。</p><p id="97bc" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">让我们用Cargo创建两个简单的程序，以便使用命令<code class="fe my mz na nb b">cargo new binary-example</code>更好地理解它的工作原理。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/53e5551b234a8e1195115a9cbbd81f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8umGcV9ftKddtapDaPZO9A.png"/></div></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/80bde73e57ed5d15a9e435b9abdc8a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*_jpStO2qnVEqHlVgVelI2Q.png"/></div></figure><p id="37a5" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">Cargo需要一个“src”文件夹，所以默认情况下它会创建这个文件夹，里面会包含所有的源代码,“main.rs”文件是一个板条箱，在这里是一个二进制和根板条箱。按照惯例，Cargo希望使用这个名称的文件是一个二进制板条箱。</p><p id="e8c4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在我们稍微改变一下，使用命令<code class="fe my mz na nb b">cargo new library-example --lib</code>。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/1a649c5b44254eb107f5fd3918b9e3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*joAGb7wzVP8KhPzw8sXspw.png"/></div></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4c7d71d8ab0481991d910a845b071038.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*9rGmR1RA0oUJG9ds1zv12Q.png"/></div></figure><p id="b48f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">和以前一样，我们有相同的“src”文件夹，但是现在源文件变成了lib.rs。在<code class="fe my mz na nb b">cargo new</code>命令中的“lib”参数表示我们想要一个库作为我们的根箱，默认情况下,“lib.rs”是预期的。库的名称与包的名称相同，这就是为什么每个包中必须有零个或一个库的原因。</p><p id="c1a4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">尽管没有直接执行此操作的命令，但我们可以创建一个包含二进制文件和库文件的包:</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ed8a1fc0c6d90589913b0c404bf322c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*C8ZLzON_Oraz-cAwr-ObHw.png"/></div></figure><p id="04e6" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">他们两个都会有包的名字。即使我们只限于这一个库箱，也可以有更多的二进制，但它必须在“src/bin”中。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b276cae2d0a7c1ce1af3b35cbe7da800.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*zJv2b1lFA_KghpUEoUCH8g.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/89a191c0887d238e4c94df0248a09ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*c2kGVopDtsSwKxi0dv2Ghw.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/7da7dbc1e6ace9d2541206186dc7460c.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*190SAzIMCb0vrhA-8yxPHA.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e7e57a6033175a2ecff23ff0528e07d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*LEndp85G8MYwRK4EPxMKQg.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi np"><img src="../Images/db0325879735dab0f351970c8c07853f.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*8qmzLwYlw_GM3SEANxn9-g.png"/></div></figure><p id="b499" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">正如你所看到的,“src/bin”中的每个rust文件都创建了一个可执行文件以及“main.rs ”,但是lib.rs创建了一个“rlib”文件，表示一个Rust库。</p><p id="2202" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">板条箱帮助我们封装防止冲突的功能。让我们找一个板条箱<a class="ae lg" href="https://crates.io/crates/log" rel="noopener ugc nofollow" target="_blank">日志</a>库，它有一个特性叫做<a class="ae lg" href="https://docs.rs/log/0.4.8/log/trait.Log.html" rel="noopener ugc nofollow" target="_blank">日志</a>，我们可以在我们的板条箱内使用这个特性，甚至创建一个同名的新板条箱，因为它们都在不同的板条箱中，所以不会有任何冲突。发生这种情况是因为机箱的功能在它自己的范围内被命名。</p><h1 id="aa64" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">模块</h1><p id="27de" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">模块可以将你的机箱组织成具有可读性和可重用性的功能组，它还可以控制可见性的范围，决定什么是公共的或私有的，因为每个模块都有一个范围。</p><p id="45db" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">让我们模拟一个联系人列表:</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/cbf13b285a58c68d7c83b4204d4199a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*tVIQk_kkW5tv30gsyl2cAQ.png"/></div></figure><p id="be07" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">我们可以用<code class="fe my mz na nb b">mod</code>关键字定义一个模块。一个模块内部可以有其他的模块来创建某种层次结构，比如一棵树，因为我们可以说“email”是“contact_list”的子模块,“contact _ list”是“email”的父模块,“手机”也是如此。</p><p id="5d91" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">但现在，我们可以更好地组织我们的代码，如果这是一个向联系人发送电子邮件的功能，我们知道我们必须将它放在“电子邮件”模块中，因此我们的代码在组织和可重用性方面有所提高。</p><h1 id="cd90" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">小路</h1><p id="da7c" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">Path是在模块中查找项并将其带到当前范围的方法。它有两种形式:</p><ul class=""><li id="11ba" class="mk ml it kh b ki kj km kn ld mm le mn lf mo lc nr mq mr ms bi translated"><strong class="kh iu">绝对</strong>:从根机箱开始，如果是外部的我们就用它的名字，如果不是可以用<code class="fe my mz na nb b">crate</code>关键字来表示实际的机箱。</li><li id="e623" class="mk ml it kh b ki mt km mu ld mv le mw lf mx lc nr mq mr ms bi translated"><strong class="kh iu">相对</strong>:从当前模块<code class="fe my mz na nb b">self</code>、<code class="fe my mz na nb b">super</code>或当前模块内的任意标识符开始</li></ul><p id="1924" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">路径的标识符由<code class="fe my mz na nb b">::</code>分隔。让我们在例子中演示如何使用这个语法调用<code class="fe my mz na nb b">send_email</code>函数。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/94fa9c66e37d4e4703122ec371bd8560.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*oJfMm1F2tekH7Vz4_2fRQA.png"/></div></figure><p id="ef1b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">如你所见，这是一个问题，我们使用了绝对和相对路径，但是电子邮件部分警告我们一个编译错误。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/4519c09d50b573a2c662c2689a2d1e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*AZItm1CxJEUzdQrgnSQg8A.png"/></div></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/02ccd969cb0583c30d2ba9a5dfb8a64e.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*SAZQjXRws_v_43MlhCkSvw.png"/></div></figure><p id="777e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">Rust抱怨电子邮件模块是私有的。记得我们说过，模块定义了可见性的范围，默认情况下一切都是私有的。因此，要改变这一点，我们不仅需要使模块，而且需要使我们想要使用的函数对公众可见，如果我们只改变模块，它不会工作，因为函数仍然是私有的，只能在<code class="fe my mz na nb b">email</code>模块中使用。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f5e95b197b44b65b3b1a9f9aa9297544.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*sAgbr4NntEyQPnNu8Ckaaw.png"/></div></figure><p id="df63" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">所以让我们改变它的可见性:</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/1305ed8c98093dbb00e37d740016e74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*WnKrgY4DPt2Ws4GL17CZnA.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/070f15027e2e335858c838e8a24df010.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*sO6wnaY5_TehQNXWbk1lgA.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5e5315c354a14c2641aec8a059e46abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*Pb_N-NluigTVJpu-l6gYlA.png"/></div></figure><p id="7fd7" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在我们的编译器没有抱怨。</p><p id="fd72" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">还有其他使用路径的方法，例如，如果我们想从一个联系人那里获得默认签名，这个联系人是<code class="fe my mz na nb b">contact_list</code>模块中的一个项目，我们应该使用<code class="fe my mz na nb b">super</code>关键字来访问它。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/48baf588a3bf368fec1e951acd4f098e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*PQf6_OUiwPOvUuJkJrP2_w.png"/></div></figure><h1 id="4793" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">将模块纳入范围</h1><p id="b6b1" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">我们刚刚展示了如何在作用域之外使用模块，但是如果你必须写下调用函数所需的所有内容，这将是令人厌烦的，并且会使你的代码可读性更差。</p><p id="7702" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">所以为了解决这个问题，有了<code class="fe my mz na nb b">use</code>关键字，用它你可以把你想要的模块带入你正在工作的范围。语法类似于我们已经做的，你只需要把用法放在模块体内部的路径前面。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/096ac8c8509ee0d768b62695de3508b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*pVsDG2fFPoptc22FrzMxsw.png"/></div></figure><p id="d5e1" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在我们可以在“email”模块中的任何地方使用<code class="fe my mz na nb b">get_default_signature()</code>方法。我们甚至可以在这里使用<code class="fe my mz na nb b">super</code>。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/30a3d40ddd90b9d4240a99c35ba69925.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*g6VyhjC71AJv9wuowxfehQ.png"/></div></figure><p id="1524" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">如果你想导入一个模块，它是另一个模块的子模块，你必须表达路径直到它。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/713de2f57aaab75fca1703245e731d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*dmy2p_vcvVlJP7EmWnKANw.png"/></div></figure><p id="fa2a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">我们甚至可以用<code class="fe my mz na nb b">as</code>命令给<code class="fe my mz na nb b">use</code>命名，当你有来自不同模块的多个项目，但是有相同的名称时，这很有用。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/fb199c6602b2e04684e4146b43a5ed9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*pC2Emz2HtFXRsrbP8bqTeQ.png"/></div></figure><h1 id="4c51" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">重新导出模块</h1><p id="8ec0" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">当我们使用path将一个模块引入作用域时，我们为它创建一个私有名称，我们可以用<code class="fe my mz na nb b">pub use</code>关键字为其他模块导出这个名称。</p><p id="e505" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">这将允许我们以一种更简洁的方式来表达目标模块的一种不太常见的用法，这样其他程序员就能理解您所期望的具体变化。</p><h1 id="3325" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">在不同的文件中组织模块</h1><p id="32c7" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">到目前为止，我们只创建了一个有多个模块的源代码，但这不是一个项目应该如何创建。在现实世界的软件中，你有不同的源代码组织在文件夹中，这些文件夹以一种更有组织的方式封装了你的功能。</p><p id="cdeb" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">Rust有办法将模块放在一个单独的文件中。为此，让我们稍微修改一下代码，将模块分开。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c544427957f4915ee4fb7a5aff03ac5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*FJt_PSVPzYMP4POca2ZokA.png"/></div></figure><p id="10ec" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">我们从“lib.rs”中删除了这些模块，并将它们放在一个单独的文件中。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/98675ae2d6929db758b2e2a3e7839986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*FFvLh5-L0PHkQn8aJqSz1g.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/cb4555c5ca0c5a1d9936c4dff16de643.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*DzLA2ej9Tc7p73htvgLwIA.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/9b41f72e19f4cc1b4d13b9ff150c3e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*-BBgORREzFxcISSShuzDgA.png"/></div></figure><p id="361f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在让我们尝试在“lib.rs”中调用它们，首先让我们用<code class="fe my mz na nb b">mod</code>关键字将它们纳入范围。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/2040d22705a52ecb33a119d76bddcee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*8JuFgJMhi-kM-DfemZr8cg.png"/></div></figure><p id="285a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在<code class="fe my mz na nb b">test</code>方法将调用它们所有的方法。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/1a944157b397e3c920871a96eacc4cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1uUW-cdSxWxrpzgHEfYLxg.png"/></div></div></figure><p id="e6e4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">这里似乎有些不对劲…正如你所看到的，要调用这个方法，我们必须重复两次模块名。发生这种情况是因为Rust自动使用文件名作为模块名，所以每个文件本身就是一个模块，所以这些文件中的<code class="fe my mz na nb b">mod</code>声明不再需要。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/b0ebb7827943999a783b64f823630914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*NwZjAkU-eT4C02f8SvCsFw.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/0f1c62aafaaf1f2e2d4555644f0d4a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*KP3TFfm05o4-zgnquZ9GIQ.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi om"><img src="../Images/571b4116c4793d8ca13cd223553a1363.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*saiJnmFNQ63-e1p6fWuZ0A.png"/></div></figure><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/21568117be4ee807be7e359a11ca365e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lL8lij0nTmB43P_lbRqd1Q.png"/></div></div></figure><p id="352b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在更好了，但可能会更好。所有东西都在同一个文件夹中，文件很少，这不是一个大问题，但是当你的项目增长到数百个文件时，如果没有一个适当的组织，就很难找到任何东西。因此，现在我们将把所有内容放在一个名为“联系人”的文件夹中</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b78b8f56f74008504101efb820032d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*3Id2lKyo2sAu-Z8qC62_nA.png"/></div></figure><p id="a4e6" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">您应该注意到“mod.rs”文件，它的目的是声明我们将要导出的模块。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi op"><img src="../Images/924df9e2844ff8bf83b81bcf32a47c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*_lz_JSqXVXQVecYj2LLw3A.png"/></div></figure><p id="2111" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">为了调用它们中的每一个，我们必须将模块<code class="fe my mz na nb b">contact</code>引入范围并利用我们想要的路径。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/cd496e36ec953327fb0895d270071f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UM8LZJdaJLdXI5_UIxHHnA.png"/></div></div></figure><p id="b4bf" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在我们的代码以和以前一样的方式工作，甚至更有组织性。我们可以使用Glob操作符“*”来导入contact中的所有模块。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi or"><img src="../Images/6484435a0fe52368c1c12e0458173c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*hapEP2D_n2csMnE3uC0Qmg.png"/></div></figure><p id="a30a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">在这个例子中没有区别，但是在其他项目中，您可能会将一些不需要的东西纳入范围，所以要小心使用。</p><h1 id="9220" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">外部板条箱</h1><p id="6ca1" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">最后，我们将讨论外部板条箱。你还记得我们用木箱做例子吗？为了在我们的代码中引入它，我们必须修改我们的“Cargo.toml”文件，从<a class="ae lg" href="https://crates.io/" rel="noopener ugc nofollow" target="_blank"> crate.io </a>下载并编译它。姑且把它当做一种依赖吧。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi os"><img src="../Images/84a3e42225a43dcf5d0ab61cd0743212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hvtf8OF2N1bpIAsPU-duxg.png"/></div></div></figure><p id="4f1a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">当我们编译项目时，它会带来日志库和它声明的所有依赖项。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ot"><img src="../Images/17ccecf23fd17133e4bc6407d3e146a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5afwCZiWMTlWT0GRS1n2Rw.png"/></div></div></figure><p id="e00f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">现在我们将能够在我们的代码中使用它，但是我们不能从板条箱开始创建路径，因为我们正在访问一个外部板条箱，所以我们只需要调用我们声明的目标板条箱的名称，在这个例子中是<code class="fe my mz na nb b">log</code>。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/efc063e10b55dceb430b8551be7aa93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*LCDtkPsJAAXqCGlLRTO50g.png"/></div></figure><h1 id="9009" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="1325" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp ld mh ks kt le mi kw kx lf mj la lb lc im bi translated">组织你的代码，使其清晰易读是每一个成功软件的关键概念。Rust为我们提供了一个非常高效和富有表现力的模块系统来管理我们的项目，并创造了一些易于维护和开发的东西。</p><p id="12d3" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">所以还是做各种项目，练锈吧！和你们一起旅行很有趣！</p><p id="07cb" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">下次见！</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="e758" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">如果你喜欢我的作品，请支持！♥</p><p id="3520" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">要了解claps是如何工作的，点击<a class="ae lg" href="https://help.medium.com/hc/en-us/articles/115011350967-Claps" rel="noopener">这里</a>。</p><p id="c4ff" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc im bi translated">要联系我:</p><div class="pc pd gp gr pe pf"><a href="https://profile.codersrank.io/user/victorinno" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">victorinno的CodersRank简介</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">这是什么？这代表了你目前的经历。它通过分析您连接的存储库进行计算。由…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">profile.codersrank.io</p></div></div><div class="po l"><div class="pp l pq pr ps po pt jz pf"/></div></div></a></div></div></div>    
</body>
</html>