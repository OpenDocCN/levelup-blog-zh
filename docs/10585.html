<html>
<head>
<title>Start Implementing Your Own Typescript Class Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始实现你自己的类型脚本类装饰器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/start-implementing-your-own-typescript-class-decorators-84a49f560dea?source=collection_archive---------4-----------------------#2021-12-23">https://levelup.gitconnected.com/start-implementing-your-own-typescript-class-decorators-84a49f560dea?source=collection_archive---------4-----------------------#2021-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9c6f0403907a0210343e6ff1caf8f8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2alD5jlp7tfo9aAtTYqPAQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">类装饰者</figcaption></figure><h2 id="4126" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是室内设计师？</h2><p id="ee09" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">它是一种结构设计模式，通过将这些对象放在包含行为的特殊包装器对象中(<a class="ae lt" href="https://refactoring.guru/design-patterns/decorator" rel="noopener ugc nofollow" target="_blank">引用</a>)，可以将新的行为附加到这些对象上。</p><p id="04b2" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><strong class="la ir"> Typescript类装饰器定义:</strong> <em class="lz">类装饰器应用于类的构造函数，可用于观察、修改或替换类定义。(</em> <a class="ae lt" href="https://www.typescriptlang.org/docs/handbook/decorators.html#class-decorators" rel="noopener ugc nofollow" target="_blank"> <em class="lz">参考</em> </a> <em class="lz"> ) </em></p><h2 id="991c" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">幕后是怎么回事？</h2><p id="c10d" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">你的类装饰器实际上是一个简单的函数<strong class="la ir">在运行时作为函数<strong class="la ir">被调用</strong>，它得到<em class="lz">一个参数</em>，那就是<strong class="la ir">类</strong>的构造函数。如果<em class="lz">类装饰器</em>返回一些东西，它将被用作类的构造器。这些事情听起来可能令人困惑，但在看了一些代码之后，就会一目了然了。</strong></p><h1 id="1e8d" class="ma kd iq bd ke mb mc md kh me mf mg kk mh mi mj ko mk ml mm ks mn mo mp kw mq bi translated">设置</h1><p id="3119" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">为了运行Typescript代码，我们需要使用Typescript编译器来编译它们。</p><p id="59a3" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我们需要一个<code class="fe mr ms mt mu b">tsconfig.json</code>文件:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">tsconfig.json</figcaption></figure><p id="02c4" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我们必须启用<code class="fe mr ms mt mu b">experimentalDecorators</code>。还有，目标不能少于<code class="fe mr ms mt mu b">ES5</code>。</p><p id="5b6c" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">如果您不想使用<code class="fe mr ms mt mu b">tsconfig</code>文件，您可以直接传递这些选项:</p><pre class="mv mw mx my gt nb mu nc nd aw ne bi"><span id="1332" class="kc kd iq mu b gy nf ng l nh ni">tsc --experimentalDecorators // If you installed tsc globaly<br/>npx tsc --experimentalDecorators // If you installed tsc in your current directory</span></pre><p id="438f" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">现在，通过在当前目录下运行<code class="fe mr ms mt mu b">tsc</code>，类型脚本文件将被编译成Javascript文件，我们可以使用Node运行它们。(<a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/start-writing-your-own-typescript-method-decorators-c921cdc3d1c1">参考</a>)</p><h1 id="031e" class="ma kd iq bd ke mb mc md kh me mf mg kk mh mi mj ko mk ml mm ks mn mo mp kw mq bi translated">定义一个类装饰器</h1><p id="4ca6" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">我们想要创建的第一个类装饰器只是在控制台上记录一条消息，告诉我们它正在运行。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">简单的类装饰器</figcaption></figure><p id="9c7c" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">现在，如果我编译并运行这段代码，我会在控制台上看到:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/b20987b17df2eaa05255bc750c0ade4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1U7_vZJObXq44qr0vnkKw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">运行代码的结果</figcaption></figure><p id="a33d" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">这里的类装饰器是一个函数，它将类的<em class="lz">构造函数</em>作为它的参数，并在控制台上简单地记录一些东西。我们可以看到<strong class="la ir">在</strong>运行类的构造函数之前，它运行<em class="lz">类装饰器</em>。</p><p id="0cd2" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">让我们看一个例子，我们可以在装饰器中传递我们的构造函数:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">尝试在类装饰器中覆盖类的构造函数</figcaption></figure><p id="1afa" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">为了从<em class="lz">类装饰器</em>对类的构造函数做一些改变，我们必须返回一个类，这个类是<strong class="la ir">对</strong>基类的扩展。</p><p id="f9b6" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">Typescript编译器强迫我们这样做(返回一个扩展基类的类)。</p><p id="92b9" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><strong class="la ir">为什么编译器强迫我们这样做？因为否则我们返回的类型与基类不兼容。</strong></p><p id="99a9" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">如果发生了什么还不清楚，你应该记得类实际上是函数(你可以在这里找到很多有用的注释)。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">类别与功能</figcaption></figure><p id="ddb6" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">现在我们知道了这一点，把类装饰器看作一个高阶函数。这在某种程度上类似于<a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/start-writing-your-own-typescript-method-decorators-c921cdc3d1c1">方法装饰器</a>的实现。</p><p id="c60a" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">如果我们想在所有的类上使用一个类装饰器呢？通过使用Typescript泛型，这是可能的。看一下这个例子:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">具有泛型类的类装饰器</figcaption></figure><p id="190b" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我们可以在所有的类上使用这个类装饰器。</p><pre class="mv mw mx my gt nb mu nc nd aw ne bi"><span id="569d" class="kc kd iq mu b gy nf ng l nh ni">&lt;T extends { new (...args: any[]): {} }&gt;</span></pre><p id="de1b" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">这是泛型的定义，如果你想知道为什么它扩展了<code class="fe mr ms mt mu b">{ new (...args: any[]): {}</code>，你应该知道我们期望一个构造函数，这就是我们如何告诉编译器检查它。</p><p id="6db0" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">这里的<code class="fe mr ms mt mu b">T</code>是泛型类，我们可以通过在第4行扩展它来返回新的构造函数。</p><p id="ea3f" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">在第5行和第6行，我们向类添加了两个时间戳成员。现在这个装饰器包装的每个类都有两个时间戳<code class="fe mr ms mt mu b">created_at</code>和<code class="fe mr ms mt mu b">updated_at</code>。</p><p id="7a39" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">让我们在控制台上看看结果:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/670f3260825647a1e1ae768294a92b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SP0IKIunc_BSoeexalIqvg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">时间戳装饰器</figcaption></figure><p id="6d65" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">正如我们看到的，类有两个额外的成员<code class="fe mr ms mt mu b">updated_at</code>和<code class="fe mr ms mt mu b">created_at</code></p><p id="d98e" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><strong class="la ir">我们能访问这两个额外的属性吗？</strong></p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/07c65e84c1b80b8e133424645331c568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jg09ueD7SBMZkSyEbYuQfg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">调用装饰者添加的附加属性</figcaption></figure><blockquote class="nm"><p id="873b" class="nn no iq bd np nq nr ns nt nu nv ls dk translated"><code class="fe mr ms mt mu b"><em class="nw">The Decorator does not change the Typescript Type</em></code></p></blockquote><p id="8385" class="pw-post-body-paragraph ky kz iq la b lb nx ld le lf ny lh li kl nz lk ll kp oa ln lo kt ob lq lr ls ij bi translated">访问该属性的唯一方法是告诉编译器忽略该行。如果以时间戳为例，我们通常希望将它们传递给ORM或ODM，以便在数据库中保存记录或文档，因此即使我们不直接调用它们，也不会有任何问题。这些属性将在对象中传递。</p><p id="a264" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">官方TS文档中提到的另一个真正有用的装饰器是<strong class="la ir">密封装饰器</strong>。</p><h1 id="ddb9" class="ma kd iq bd ke mb mc md kh me mf mg kk mh mi mj ko mk ml mm ks mn mo mp kw mq bi translated">密封装饰器</h1><p id="4e0b" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">当我们密封一个类时，我们希望防止更多的功能和属性被添加或删除。让我们看看实际情况:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">密封装饰器</figcaption></figure><p id="78f1" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我们密封了构造器和它的原型。如果我们试图这样改变构造函数(我们必须忽略编译器才能做到这一点):</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">改变原型</figcaption></figure><p id="6f83" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">这将导致一个类型错误:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/29253dd5cfc1a16656cd97bf5c309e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*Wp71zaQwZhHLN5xH7GEKAQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更改类原型的结果</figcaption></figure><p id="bb76" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">如果我们不使用<code class="fe mr ms mt mu b">@sealed</code>装饰器，结果将会是这样:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1323c148776ef9f45bcd20c920435ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*W1rsl1_0TqEAAgXj2cDpNA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">调用没有密封装饰器的<code class="fe mr ms mt mu b"><strong class="bd ke">getHeight</strong></code></figcaption></figure><h1 id="d2e1" class="ma kd iq bd ke mb mc md kh me mf mg kk mh mi mj ko mk ml mm ks mn mo mp kw mq bi translated">结论</h1><p id="525f" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">类装饰器只是一个在运行时运行的函数，它可以改变类的行为。使用类装饰器和包装其他类在某些情况下可能有点棘手，如果你想给它们添加一些功能的话，因为装饰器不会改变typescript类型。</p><p id="dfbe" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">decorator在<a class="ae lt" href="https://angular.io" rel="noopener ugc nofollow" target="_blank"> Angular </a>和<a class="ae lt" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>中被广泛使用，因为这两个框架都使用OOP范例，你可以看看它们的文档和decorator的实现。</p></div></div>    
</body>
</html>