<html>
<head>
<title>On-Demand Request Logging in Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flask中的按需请求记录</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/on-demand-request-logging-in-flask-a082cb99f2a?source=collection_archive---------22-----------------------#2020-06-05">https://levelup.gitconnected.com/on-demand-request-logging-in-flask-a082cb99f2a?source=collection_archive---------22-----------------------#2020-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c8a13cbde1a771acb67e4147f0ace019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTSU4tKdH7D5HQEDLo_3Cg.png"/></div></div></figure><p id="d5b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于2020年6月5日</em><a class="ae kx" href="https://preslav.me/2020/06/05/on-demand-request-logging-in-flask/" rel="noopener ugc nofollow" target="_blank"><em class="kw">https://preslav . me</em></a><em class="kw">。</em></p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="4014" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打印出适量的生产日志是一种艺术，有时甚至接近黑魔法的领域。从我构建软件的经验来看，大多数开发人员要么记录太多，要么根本不记录任何东西。没有足够的信息会使寻找bug变得更加困难。另一方面，太多的日志跟踪会妨碍代码的可读性，并且不一定会使一个人的职责变得更容易。</p><p id="ae47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，每个人想要的是<strong class="ka ir">按需登录</strong>。大多数编程环境已经通过单独记录错误来部分解决这个问题。然而，错误的行为并不总是会导致错误。另外，错误日志很少包含导致错误的特定执行上下文。</p><h1 id="5595" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基本请求跟踪</h1><p id="b492" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果能够手动打开日志记录，那就太好了，而且只是在某些情况下。在web应用的上下文中，<em class="kw">某些情况</em> == <em class="kw">某些请求</em>。对于标准的类似Flask的Python Web应用程序，这实际上非常容易实现。</p><p id="1f56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我会用Flask，因为它最容易演示。这个想法应该相对容易在其他框架中重用。</p><p id="84e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">比方说，我们想在每次使用某个URL参数调用Flask API时写一个日志(姑且称之为<code class="fe mi mj mk ml b">trace_id</code>)。可以做的最简单的事情是添加一个<code class="fe mi mj mk ml b">@before_request</code>拦截器:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="6b5b" class="mu lg iq ml b gy mv mw l mx my">app = Flask(__name__)</span><span id="60cb" class="mu lg iq ml b gy mz mw l mx my"><a class="ae kx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.before_request<br/>def request_tracer():<br/>    if "trace_id" in request.args:<br/>        # DO something, like log the request args, body, etc<br/>        # Make sure to include the trace_id as well, so you can<br/>        # search for it in the logs</span></pre><p id="560e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数将在每次请求前被调用。如果您现在将<code class="fe mi mj mk ml b">trace_id=[RANDOM_ID_THAT_YOU_CAN_TRACE]</code>添加到您想要手动测试的请求中，或者添加到另一个服务所使用的请求中，那么您应该能够很容易地在日志中搜索到<code class="fe mi mj mk ml b">RANDOM_ID_THAT_YOU_CAN_TRACE</code>。最好的部分是，打开或关闭它是一个使用/不使用URL参数的问题。</p><p id="475f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，上面的例子相当幼稚。这对任何人都没有多大用处，因为大多数错误发生在调用链的更深处。让我们举下面的例子:</p><h1 id="5f54" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">稍微高级一点的请求跟踪器</h1><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="ee03" class="mu lg iq ml b gy mv mw l mx my">app = Flask(__name__)</span><span id="c6b9" class="mu lg iq ml b gy mz mw l mx my"><a class="ae kx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/")<br/>def index():<br/>    name = request.args.get("name")<br/>  name = layer1(name)<br/>    return f"Hello, {name}"</span><span id="1675" class="mu lg iq ml b gy mz mw l mx my">def layer1(name: str):<br/>    return layer2(name)</span><span id="e2cd" class="mu lg iq ml b gy mz mw l mx my">def layer2(name: str):<br/>    return name.upper()</span></pre><p id="de7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的API处理程序调用另一个函数，该函数返回另一个函数的结果。典型的生产应用程序要复杂得多，到处都是循环和条件逻辑。嵌套调用链的问题是，要一直进行条件跟踪，需要将它添加到每个函数中。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="fbd5" class="mu lg iq ml b gy mv mw l mx my">if "trace_id" in request.args:<br/>    # log trace_id, inputs and outputs</span></pre><p id="3991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是非常不切实际的，会降低代码的可读性。</p><h1 id="847d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">自定义跟踪装饰器</h1><p id="a704" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">我能想到的最不显眼的选择是创建一个定制的装饰器。我们不会不修改我们的代码，但是在每个函数上有一个装饰器不会直接影响代码的可读性。这是我们上面的小应用程序的样子:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="2cb9" class="mu lg iq ml b gy mv mw l mx my">app = Flask(__name__)</span><span id="ee31" class="mu lg iq ml b gy mz mw l mx my">tracer = Tracer()</span><span id="8907" class="mu lg iq ml b gy mz mw l mx my"><a class="ae kx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/")<br/>def index():<br/>    name = request.args.get("name")<br/>  # pass the tracer_id to the first function in your call chain<br/>  name = layer1(name, trace_id=request.args.get('trace_id'))<br/>    return f"Hello, {name}"</span><span id="c06d" class="mu lg iq ml b gy mz mw l mx my"><a class="ae kx" href="http://twitter.com/tracer" rel="noopener ugc nofollow" target="_blank">@tracer</a>.trace<br/>def layer1(name: str):<br/>    return layer2(name)</span><span id="3b64" class="mu lg iq ml b gy mz mw l mx my"><a class="ae kx" href="http://twitter.com/tracer" rel="noopener ugc nofollow" target="_blank">@tracer</a>.trace<br/>def layer2(name: str):<br/>    return name.upper()</span></pre><p id="b0d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是跟踪装饰器的一个可能的实现:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4242" class="mu lg iq ml b gy mv mw l mx my">class Tracer:<br/>    def __init__(self) -&gt; None:<br/>        self.current_trace_id = None</span><span id="06a0" class="mu lg iq ml b gy mz mw l mx my">def trace(self, f):<br/>        <a class="ae kx" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(f)<br/>        def wrapper(*args, **kwargs):<br/>            trace_id = kwargs.pop("trace_id", None)<br/>            if trace_id:<br/>                if self.current_trace_id:<br/>                    # Do you really want to raise an error?<br/>                    # Perhaps, logging the concurrent access and<br/>                    # silently moving on is better.<br/>                    raise Exception("Concurrent tracing requests are not allowed!")</span><span id="e096" class="mu lg iq ml b gy mz mw l mx my">                # "open" a new request<br/>                self.current_trace_id = trace_id<br/>                print(f"Tracing ID: {self.current_trace_id} - </span><span id="e991" class="mu lg iq ml b gy mz mw l mx my">               function call: {__name__}.{f.__name__} - Arguments: {args}")<br/>                res = f(*args, **kwargs)</span><span id="caf0" class="mu lg iq ml b gy mz mw l mx my">                # "close" the request, by simply clearing its state<br/>                self.current_trace_id = None<br/>                return res<br/>            elif self.current_trace_id:<br/>                print(f"Tracing ID: {self.current_trace_id} - function call: {__name__}.{f.__name__} - Arguments: {args}")<br/>                return f(*args, **kwargs)<br/>            else:<br/>                return f(*args, **kwargs)</span><span id="317f" class="mu lg iq ml b gy mz mw l mx my">return wrapper</span></pre><p id="18cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住我的方法的明显局限性。<code class="fe mi mj mk ml b">tracer</code>实例是全局的。将状态存储在全局变量中通常不是一个好主意，但是在某些情况下，您别无选择。</p><p id="3bd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在WSGI应用程序中，全局范围通常意味着每个进程的<em class="kw">全局。传统上，WSGI服务器会产生一定数量的Python进程，并在它们之间处理传入的请求。单个请求将作为单个流程的一部分端到端运行。如果是这种情况，那么由于进程隔离，我们的小装饰器会做得非常好。当线程或<code class="fe mi mj mk ml b">async-await</code>开始发挥作用时，将装饰器的范围限定为手边的特定请求将变得很重要。</em></p><p id="b2d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Flask的情况下，可以使用它的<a class="ae kx" href="https://flask.palletsprojects.com/en/1.1.x/reqcontext/" rel="noopener ugc nofollow" target="_blank">请求范围</a>，这将确保并发请求不会覆盖当前正在运行的请求的<code class="fe mi mj mk ml b">trace_id</code>值。当然，使用特定于库的构造会使代码更难测试。它还需要对装饰器进行修改，以防您切换您选择的Web框架(幸运的是，大多数框架都内置了相同的请求范围概念)。</p><p id="2f06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到最后，就没那么重要了。Python的精神之一是编写简单的代码来完成大部分工作，而不是沉迷于让事情变得超级通用。如果我的方法对你的情况不起作用，很容易适应。</p><p id="703d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的灵感不是来自Python社区，而是来自于Elixir的Phoenix框架。在其最新版本中，Phoenix附带了一个现成的LiveDashboard，这对于在生产中运行Elixir应用程序非常有帮助。在许多很酷的特性中，仪表板有一个请求记录器，它几乎可以完成我上面描述的功能。</p></div></div>    
</body>
</html>