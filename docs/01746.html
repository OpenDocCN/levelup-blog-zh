<html>
<head>
<title>TypeORM Testing with Docker + GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker + GitHub动作进行类型测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typeorm-testing-with-docker-github-actions-6dc8a5dbe913?source=collection_archive---------4-----------------------#2020-01-27">https://levelup.gitconnected.com/typeorm-testing-with-docker-github-actions-6dc8a5dbe913?source=collection_archive---------4-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d8ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用TypeORM/TypeScript/GraphQL API进行单元、集成和E2E测试(2020年2月1日更新)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0435f04df54f651593c03eb6c43f6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVgQxtoIA6KzmIke-FFrOQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/man-wearing-black-and-white-stripe-shirt-looking-at-white-printer-papers-on-the-wall-212286/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@startup-stock-photos?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">创业股票照片</a></figcaption></figure><h2 id="426e" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="2797" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">弄清楚如何为ORM编写自动化测试可能非常困难。解决这个问题有许多不同的方法，很难找到好的解释。这篇文章是关于我开发ORM测试、策略以及如何让它们与GitHub actions (CI)一起工作的经验。我使用的是<a class="ae ky" href="https://typeorm.io/#/" rel="noopener ugc nofollow" target="_blank">类型的ORM </a>，但是本文中的思想应该适用于其他ORM实现。</p><p id="d9ba" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我使用TypeORM已经一年多了，我在一个大型商业应用程序上使用过它，我将在2020年再次使用它，使用一个我正在开发的名为<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter" rel="noopener ugc nofollow" target="_blank"> BrainStrike </a>的<a class="ae ky" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">node . js</a><a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">TypeScript</a>/<a class="ae ky" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank">Apollo graph QL</a>初学者工具包。我想用我相信的技术堆栈做一个“涅槃”项目，一些组件相对较新，所以我必须深入研究几种技术。BrainStrike在GitHub上，这是一个相对简单的教育项目。当它准备好的时候，我将会分享更多。</p><p id="f6ce" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">作为一名web开发人员，拥有一个开发现代应用程序的工作方法总是好的，并且保持您的工具是最新的也是很重要的…栈决策是非常重要的。我是GraphQL和TypeScript的忠实粉丝，所以这是显而易见的选择，我选择TypeORM作为数据库连接，因为它功能丰富，对TypeScript有很好的支持。</p><p id="c963" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我对这个项目有几个目标:</p><ol class=""><li id="0d0c" class="mt mu it lx b ly mo mb mp li mv lm mw lq mx mn my mz na nb bi translated">使用所有现代组件开发一个<strong class="lx iu">全栈</strong>示例。服务器API +客户端。</li><li id="533e" class="mt mu it lx b ly nc mb nd li ne lm nf lq ng mn my mz na nb bi translated">让<strong class="lx iu">完全定型</strong>，绝对最少使用类似<code class="fe nh ni nj nk b">any</code>型的逃生舱口。</li><li id="1925" class="mt mu it lx b ly nc mb nd li ne lm nf lq ng mn my mz na nb bi translated">工作，<strong class="lx iu">实用端到端式安全</strong>。GraphQL + TypeScript都是类型化语言，都适合代码生成。</li><li id="1900" class="mt mu it lx b ly nc mb nd li ne lm nf lq ng mn my mz na nb bi translated">它应该有一个<strong class="lx iu">伟大的开发者体验</strong>。TypeORM建模和GraphQL API提供了一个非常好的DX。我打算从开发工具包中学到更多。(完成后，我会评估体验的质量，但我已经学到了很多关于什么可行，什么不可行的知识)。</li><li id="1f26" class="mt mu it lx b ly nc mb nd li ne lm nf lq ng mn my mz na nb bi translated">客户端和服务器的<strong class="lx iu">单元、集成和端到端测试</strong>(用TypeScript编写)的工作示例。</li></ol><p id="4633" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">今天我将写下最后一个目标。<strong class="lx iu">测试</strong>。</p><p id="6a06" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">所有项目都有不同的需求，我不认为为每个项目部署这种堆栈是明智的，您应该根据您可用的开发资源进行考虑，例如，时间、现金流、团队组成等。我从事企业应用软件的工作。我想在一个堆栈上实践，这个堆栈可以在生产中被团队使用好几年。</p><p id="f71d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">本文假设您已经有了一个包含Node.js和TypeORM的项目，如果您还没有的话，您可能需要安装<a class="ae ky" href="https://www.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker </a>并获得一个免费的<a class="ae ky" href="https://www.github.com" rel="noopener ugc nofollow" target="_blank"> GitHub </a>帐户。我的例子是用打字稿写的。</p><h2 id="bda1" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是ORM？，什么是TypeORM？我为什么要用它？</h2><p id="db0a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated"><a class="ae ky" href="https://typeorm.io/#/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>是JavaScript和TypeScript的对象/关系映射工具。ORM(对象/关系映射)是一种用于与数据库交互的抽象，TypeORM真正的优点是它支持现代JavaScript特性，并且具有类型脚本的类型安全性。</p><p id="5633" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我在过去10年中参与的大多数项目都没有使用过ORM。因为传统的ORM解决方案已经失宠，我已经习惯于推出自己的映射解决方案。</p><p id="2798" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我在90年代/21世纪初使用过ORM。他们以接口臃肿、抽象漏洞和性能不佳而闻名。我过去吃过苦头，所以我对使用TypeORM仍然有些恐惧。软件行业充斥着不兑现的承诺，但是对于数据库建模来说，事情已经有了巨大的改善。</p><p id="58eb" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这仍然是一个复杂的问题，你必须坚持使用关系结构，但是这里的意图是让我的手脏起来，并使用现代框架找到边缘案例。我降低了对ORM的期望。</p><p id="06b6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果您必须使用JavaScript/TypeScript与数据库进行交互，尤其是在您开始一个新项目时，您应该考虑TypeORM。如果您需要特定于数据库的特殊功能，或者需要与现有解决方案集成，将会面临一些挑战，如果您希望获得领先的性能，您可能需要迁移您的数据库或编写自己的查询构建器，但是TypeORM生成的查询相对来说得到了很好的优化和改进。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/7ccfc128ae9896b24e8651c5e724ae8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ka2cOJ0y5O2yIVIz1C5N1w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">GitHub Actions + TypeORM + Docker</figcaption></figure><h2 id="f14c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是测试？，单元测试、集成测试和E2E测试之间有什么区别——我们为什么要这么做/为什么要这么做？</h2><p id="4d5e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">自动化测试是一个很大的话题，超出了本文的范围，但是我想简单介绍一下这个话题，这样你就知道为什么它很重要了。</p><p id="92c6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">单元测试被设计用来自动测试一个单独的代码单元。通常，你提供一些输入，并测试你是否得到正确的输出。考虑一下，如果你和一个团队一起工作，有人修改了一些东西，在一个特定的单元中引入了一个bug。您的构建系统可以被配置为防止代码在错误报告中被提交并带有适当的反馈。</p><p id="3aa0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">集成测试顾名思义——它们涉及测试各种集成单元的交互，而不是孤立地单独测试。</p><p id="f20c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">E2E测试有时被称为功能测试，或者浏览器测试，或者UI测试，或者冒烟测试(是的，有这么多不同的术语真烦人)。E2E测试被定义为测试系统的完整功能。它们运行速度较慢，通常模拟真实的用户交互，所以在浏览器应用程序的情况下，这涉及到模拟用户四处点击并与应用程序交互。这里我们正在测试一个GraphQL API。</p><p id="2b64" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我曾在很少甚至没有自动化测试的公司工作过，这非常具有挑战性。在过去的十年中，由于敏捷方法，测试变得更加重要。</p><p id="60b2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这是开发人员的一个挫败点。我曾经遇到过敏捷“教练”来到遗留系统，这些遗留系统被技术债务所克服，将测试作为一个口号来提倡(因为它在宣言中)，假装他们已经通过建议解决了问题，然后继续忽略自动化测试并优先考虑面向客户的特性，因为这让利益相关者高兴，忽视开发人员的快乐并加重技术债务…这种策略将不可避免地回来咬你，但他们仍然可以责怪开发人员，毕竟，他们确实提倡测试！</p><p id="1a0b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我对痴迷于敏捷的管理者保持警惕，如果他们没有评估他们管理的系统的话。软件必须同样敏捷——好的领导者很难找到，如果他们只是简单地推动宣言，那是另一个危险信号。这意味着责任将被转嫁给开发商。当一个经理蔑视开发人员时，这很能说明问题。这是糟糕的领导，老板在这个千年里是一个过时的概念。领导者应该有测试的技术策略，在过程中提供帮助，并为自动化测试和QA测试(如果可能的话)分配时间。</p><p id="713a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果你试图在一个现有的系统中添加测试，这可能是非常具有挑战性的，因为这个系统可能是在没有考虑测试的情况下仓促/拙劣地开发的，使得有效的测试几乎不可能。</p><p id="aa0c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">测试应该是你最初设计考虑的一部分，而不是事后的想法。我已经了解到，所有代码提交中覆盖范围发生变化的地方都应该有适当的测试，因为带着测试思想编写的代码与不带测试思想的代码是不同的。</p><p id="135e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当您知道代码必须通过测试时，您倾向于创建更合适的抽象，尤其是如果您必须编写它们的话。如果开发人员/经理只是试图在没有测试的情况下获得一个特性，它几乎肯定会成为一个有着复合技术债务的老鼠窝。</p><p id="7a10" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">考虑单元测试。单元是最小的可测试软件组件。为了使一个单元可测试，它不仅要小，而且要对它的依赖关系进行特殊的考虑，你可能需要将一个依赖关系注入到一个单元中来单独测试它。你的依赖性适合测试吗？如果是老模块，无法正常测试怎么办？</p><p id="93c3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">集成和E2E测试需要考虑环境。您也许能够为您的本地机器编写一个好的集成测试，但是这个测试能够被部署到另一个环境中吗？它能在环境矩阵中旋转吗？如果你不得不嘲笑一些东西，它有多复杂呢？依赖关系必须模仿哪些依赖关系？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/66b02c89ca8186ab96876f7476736bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*nkuZut7uyrz4Dcti97JvlQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">测试金字塔</figcaption></figure><p id="b950" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">单元测试、集成测试和e2e/冒烟测试通常被称为测试金字塔。单元测试在最底层(嗯，从技术上来说，但是我已经用TypeScript表示静态检查作为第一测试层)，然后是集成，最后是E2E，单元测试被认为是最便宜/最快/价值最高的，随着你在金字塔上向上移动，事情变得越来越昂贵(和慢)。</p><p id="4911" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">有一些关于你应该有多少覆盖率的争论，有些人说50%，有些人说80%，少数人说100%。我属于100%阵营，我自己离那个目标很远，但我总是努力达到100%，因为它鼓励深思熟虑的开发，从99%达到100%可能非常具有挑战性，但通过增加最后1%可以学到很多东西。这在生产中通常是不可实现的，因为事情进展得太快了，但这是值得努力的，我会鼓励backlog任务尽可能地提高覆盖率。</p><p id="f54c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">考虑一个初学者工具包，您希望建立一些模式，使其更容易构建。没有经过测试的初学者工具包将是一场噩梦。测试应该<strong class="lx iu">而不是</strong>稍后添加。</p><h2 id="08a3" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">好的，那么ORM测试呢？</h2><p id="2a66" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">到目前为止，您可能已经开始思考如何为使用ORM的系统实现测试了。这不是小事，因为本质上一个ORM可以有许多复杂的基本分类法，很难分离。我能够相对容易地找出如何对我的数据源模型进行单元测试，但是当我进行集成测试时，事情变得非常棘手。</p><p id="18b1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">主要的问题是模仿和存根，一起测试几个ORM单元经常涉及到建立几个依赖关系，其中很多依赖于连接和数据库自检。考虑模式同步或迁移之类的事情，以测试您是否会遇到困难。如果你想模仿这些(特别是用TypeScript ),你将会写一大堆不合理的模仿代码，而且会频繁地破坏<strong class="lx iu"/>。</p><p id="65a5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">您不希望进行难以管理的单元测试，因为它们不会提高生产率。它们会对你的开发工作产生有害的影响。我曾经参与过单元测试很差的项目，它们必须重写，修复单元测试比编写模块花费的时间还要长。</p><p id="2725" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">像许多人一样，在接近这个主题时，我谷歌了短语“<strong class="lx iu">如何在不触及数据库的情况下单元测试TypeORM】”。我得到了最受欢迎的结果:2017年的一期GitHub仍然有效，我读了整本书。这是一个有趣的讨论，但它花了一段时间才能看到任何一种关于实际方法的共识，更不用说“正确”的方法了。</strong></p><p id="203e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">有一些建议；您可以尝试模仿一切(噩梦般的，太多的代码)，其他用户主张使用运行在内存中的SQL lite连接，这非常快，但这种方法的问题是它仅限于SQL lite特性。我选择的数据库是Postgres，我使用了时间戳列，但是SQL Lite不支持时间戳。</p><p id="73ce" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">值得庆幸的是，到2019年底，一种流行的方法开始出现，它有点反直觉，因为它确实涉及到访问数据库——一个专用的测试数据库。我对这种技术做了一些研究，我知道大波士顿地区的几家科技公司已经成功部署了这种技术。</p><p id="0968" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">好的，我们有一个方法，但是最好的方法是什么呢？这必须合并到您的构建过程中，因为您希望pull请求能够运行测试。您可以有一个专用的服务器实例来测试某个地方，并且您可以编写您的测试连接来连接到那个地方。我想要一些更容易管理的东西，一些可以存在于我的Git存储库中的东西。</p><p id="f8c4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我意识到，对于我的用例，我可以使用一个<a class="ae ky" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>容器很容易地建立一个测试数据库并销毁它。我只需要在Git中编写一个<code class="fe nh ni nj nk b">docker-compose.yml</code>文件，然后在执行测试之前连接一个CI工作流来启动Docker。我不得不再次决定用什么来做CI。</p><p id="999c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我认为这是一个尝试GitHub动作的好时机。GitHub动作对于初学者工具包来说是很棒的，因为如果有人将资源库分支到GitHub中，他们会立即得到相同的测试。</p><p id="08aa" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">既然我们已经介绍了我们的基本原理并决定了我们的方法，那么让我们进入本质吧！</p><h2 id="ac2c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Docker撰写</h2><p id="56c9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Docker是一种旋转集装箱的工具。我已经创建了一个<code class="fe nh ni nj nk b"><a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/blob/master/server/docker-compose.yml" rel="noopener ugc nofollow" target="_blank">docker-compose.yml</a></code>文件，用于下载Postgres和Postgres管理图像，并且我正在使用一个bash脚本来生成多个包含相关用户信息的表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server" rel="noopener ugc nofollow" target="_blank">服务器</a> /docker-compose.yml</figcaption></figure><p id="ab5d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">注意这个docker-compose文件使用了环境变量，它还引用了一个启动脚本来生成两个数据库，<code class="fe nh ni nj nk b">brainstrike</code>和<code class="fe nh ni nj nk b">brainstrike_test</code>。你实际上并不需要PgAdmin，但我发现它在本地开发时很有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server" rel="noopener ugc nofollow" target="_blank">服务器</a>/<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/pg-init-scripts" rel="noopener ugc nofollow" target="_blank">pg-init-scripts</a>/create-multiple-PostgreSQL-databases . sh</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server" rel="noopener ugc nofollow" target="_blank">服务器</a> /.env.example(用自己的信息更新)</figcaption></figure><p id="e65a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果你已经安装了Docker，你可以用命令<code class="fe nh ni nj nk b">docker-compose up -d</code>来启动这个容器，d代表“分离”,意思是它在后台运行。</p><h1 id="b1b8" class="np la it bd lb nq nr ns le nt nu nv lh jz nw ka ll kc nx kd lp kf ny kg lt nz bi translated"><strong class="ak">单元测试示例</strong></h1><p id="4265" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在我们进入一个TypeORM单元测试的例子之前，让我们看一下我的入口文件，看看我是如何建立连接和测试连接的。这个文件中有一些东西，但实际上它是一系列用于启动服务器的函数，或者在测试的情况下，启动测试服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter" rel="noopener ugc nofollow" target="_blank">brain strike-typescript-starter</a>/<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server" rel="noopener ugc nofollow" target="_blank">server</a>/<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src" rel="noopener ugc nofollow" target="_blank">src</a>/index . ts</figcaption></figure><p id="c1c7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我有这些非常简单的<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/blob/master/server/src/entity/Card.ts" rel="noopener ugc nofollow" target="_blank">卡</a>和<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/blob/master/server/src/entity/Category.ts" rel="noopener ugc nofollow" target="_blank">类别</a>类型的实体，在本文中我将只关注<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/blob/master/server/src/entity/Card.ts" rel="noopener ugc nofollow" target="_blank">卡</a>。下面是一个名为<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/blob/master/server/src/datasources/card.ts" rel="noopener ugc nofollow" target="_blank"> CardAPI </a>的Apollo数据源，在其构造函数中接受一个<code class="fe nh ni nj nk b">repos</code>对象。仓库是一个<a class="ae ky" href="https://github.com/typeorm/typeorm/blob/master/docs/repository-api.md" rel="noopener ugc nofollow" target="_blank">类型的仓库</a>的容器。我将模仿这个<code class="fe nh ni nj nk b">repos</code>对象，并将其注入到卡单元测试中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">CardAPI数据源<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server" rel="noopener ugc nofollow" target="_blank">服务器</a> / <a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src" rel="noopener ugc nofollow" target="_blank"> src </a> / <a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src/datasources" rel="noopener ugc nofollow" target="_blank">数据源</a> /card.ts</figcaption></figure><p id="4134" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我选择不对单个数据源存储库使用测试数据库连接，因为模仿<code class="fe nh ni nj nk b">repos</code>对象相对容易，最好是隔离测试单元——它们不会在集成或E2E环境中运行。</p><p id="057b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果您查看<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src/datasources/__tests__" rel="noopener ugc nofollow" target="_blank"> __tests__ </a>文件夹，我们可以找到卡数据源的<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/blob/master/server/src/datasources/__tests__/card.ts" rel="noopener ugc nofollow" target="_blank">第一个单元测试</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">CardAPI单元测试<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server" rel="noopener ugc nofollow" target="_blank">服务器</a> / <a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src" rel="noopener ugc nofollow" target="_blank"> src </a> / <a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src/datasources" rel="noopener ugc nofollow" target="_blank">数据源</a>/<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src/datasources/__tests__" rel="noopener ugc nofollow" target="_blank">_ _测试__ </a> /card.ts</figcaption></figure><p id="a4a3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">很简单，但是对于<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/blob/master/server/src/__tests__/integration.ts" rel="noopener ugc nofollow" target="_blank">集成</a>和<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/blob/master/server/src/__tests__/e2e.ts" rel="noopener ugc nofollow" target="_blank"> E2E </a>测试，我们将使用测试数据库连接。</p><p id="67d1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我使用jest globalSetup文件(通过jest.config.js配置)，这允许我清除测试数据库并重新运行同步和迁移:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter" rel="noopener ugc nofollow" target="_blank">brain strike-typescript-starter</a>/<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server" rel="noopener ugc nofollow" target="_blank">服务器</a>/<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src" rel="noopener ugc nofollow" target="_blank">src</a>/jest . global setup . ts</figcaption></figure><h2 id="3c73" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">集成测试示例</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">brain strike Server<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server" rel="noopener ugc nofollow" target="_blank">Server</a>/<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src" rel="noopener ugc nofollow" target="_blank">src</a>/<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src/__tests__" rel="noopener ugc nofollow" target="_blank">_ _ tests _ _</a>/integration . ts</figcaption></figure><h2 id="aea2" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">E2E(端到端)测试示例</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">brain strike Server<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server" rel="noopener ugc nofollow" target="_blank">Server</a>/<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src" rel="noopener ugc nofollow" target="_blank">src</a>/<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/server/src/__tests__" rel="noopener ugc nofollow" target="_blank">_ _ tests _ _</a>/e2e . ts</figcaption></figure><p id="3cc3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这些测试的重要之处在于它们使用了我们的测试数据库连接。</p><h2 id="3f8b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">GitHub操作配置项</h2><p id="cbfe" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">下一个重要部分是设置我们的<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/blob/master/.github/workflows/nodejs-server-test.yml" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>来启动CI环境，这只是一个在<a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/.github/workflows" rel="noopener ugc nofollow" target="_blank"> GitHub动作工作流文件夹</a>中的YAML文件，注意它是如何从secrets对象中提取我们的环境变量的。这些是通过GitHub中“Secrets”下的“settings”选项卡配置的(见下一个截图)…我知道我在这里为我们的Docker和Node步骤杜平了一些代码，它们使用相同的env变量。不幸的是，GitHub actions还不支持像锚和别名这样的YAML特性，否则我会把它们放在同一个锚中。</p><p id="6b11" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">BrainStrike <a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter" rel="noopener ugc nofollow" target="_blank">仓库</a>有一个monorepo结构，所以服务器和客户端有单独的文件夹，并有相应的动作。注意服务器测试如何有一个<code class="fe nh ni nj nk b">on&gt;push&gt;paths</code>配置，这意味着这个工作流在被触发之前监视服务器文件夹的推送。</p><p id="bfe5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">该代码还为Node 10.x和Node 12.x建立了一个测试矩阵，这些测试将同时运行，如果其中一个失败，整个测试将失败。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/.github" rel="noopener ugc nofollow" target="_blank">。github </a> / <a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter/tree/master/.github/workflows" rel="noopener ugc nofollow" target="_blank">工作流</a> /nodejs-server-test.yml</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/3e8626f5e65efa888c66a5c1581bd791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2k4XxHRtJKsDGea1Rt0how.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">配置GitHub机密</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0b76f9ae772acc80d32641e468ea7f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAubc11ORyARmBO1JZw-LA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">服务器操作触发的输出</figcaption></figure><h2 id="d464" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论+后续步骤</h2><p id="163e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">现在你有了，用TypeORM和GitHub动作完成自动化测试的一种方法！</p><p id="5f78" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">接下来你需要完成你的单元测试(这只是一个完整测试套件的部分例子)，如果你的Docker容器很大，你需要构建更多的容器，那么构建起来会很慢，而且每次测试都会把容器吹走，你可能需要考虑如何缓存Docker来加快构建速度。</p><p id="119e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">您可能还想考虑将您的整个应用程序放入Docker compose，因为使用像<a class="ae ky" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>这样的服务可以更容易地部署/测试整个容器。</p><p id="1921" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我希望这篇文章能帮助你——祝你的项目好运！</p><h2 id="c5e6" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">资源</h2><p id="3b87" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated"><a class="ae ky" href="https://github.com/seandearnaley/brainstrike-typescript-starter" rel="noopener ugc nofollow" target="_blank">brain strike</a>/<a class="ae ky" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">node . js</a>/<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">TypeScript</a>/<a class="ae ky" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank">Apollo</a>/<a class="ae ky" href="https://typeorm.io/#/" rel="noopener ugc nofollow" target="_blank">typesorm</a></p><p id="29db" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><a class="ae ky" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a> / <a class="ae ky" href="https://www.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker </a></p></div></div>    
</body>
</html>