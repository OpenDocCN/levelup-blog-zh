<html>
<head>
<title>How to Build a Vision-Based Smart Sudoku Solver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建基于视觉的智能数独求解器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-smart-vision-based-sudoku-solver-ffbee2875cda?source=collection_archive---------17-----------------------#2021-01-12">https://levelup.gitconnected.com/how-to-build-a-smart-vision-based-sudoku-solver-ffbee2875cda?source=collection_archive---------17-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3351" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用人工智能的力量来检测、识别和解决数独难题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e9ec76789f9a253569bd6cb21d257d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gWeEKCmcynj6lqdi59groQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4389372" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>的Gerd Altmann 提供</figcaption></figure><p id="7c1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">我</span>喜欢解数独。嗯，<em class="me">不是</em>真的，但为了一个相当<em class="me">戏剧性的</em>背景故事，让我们现在离题。</p><p id="9703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一天，我被一个特别难的难题难住了，于是我想到要做一个数独解算器，虽然不是普通的解算器，而是一个试图从照片中识别、提取和解答数独的解算器！</p><p id="d1b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不必要的复杂化是我的专长。</p><p id="cfd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当时我正在研究<a class="ae ky" href="https://en.wikipedia.org/wiki/Computer_vision#:~:text=Computer%20vision%20is%20an%20interdisciplinary,human%20visual%20system%20can%20do." rel="noopener ugc nofollow" target="_blank">计算机视觉</a>和<a class="ae ky" href="https://www.investopedia.com/terms/d/deep-learning.asp#:~:text=Deep%20learning%20is%20an%20AI,is%20both%20unstructured%20and%20unlabeled." rel="noopener ugc nofollow" target="_blank">深度学习</a>，我认为这将是一次有趣的尝试，可以测试我的技能，并在过程中学习更多。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="d08a" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">让我们开始吧</h1><p id="b352" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">兴奋之余，我搓着手，掰着指关节，启动我信赖的HP，下载下面的图片成为“<em class="me">豚鼠”</em>，打开<a class="ae ky" href="https://www.jetbrains.com/pycharm/" rel="noopener ugc nofollow" target="_blank"> PyCharm </a> <strong class="lb iu">、</strong>，一头扎了进去。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d70a0d9b47d99691da9d1e51b5da33c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/0*nroUoL86qF4r03Sj"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</figcaption></figure><blockquote class="nk nl nm"><p id="6b42" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated">在灰度模式下加载图像，因为我们并不真正关心这里的颜色。</p><p id="eefa" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated">从现在开始我们就叫这个小家伙“testimg”吧。</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="8206" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">图像处理</h1><h2 id="dcc4" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">步骤1:模糊和阈值处理</h2><p id="3785" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">第一步是对图像进行阈值处理。在设定阈值以减少噪声和/或细节之前，最好对图像进行模糊处理。模糊<strong class="lb iu"> </strong>的意思是<em class="me">顾名思义</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a2b986f910603c658f03b115793187a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*_gb9nPqSUCmZdMqT.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">高斯模糊。来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/Gaussian_blur" rel="noopener ugc nofollow" target="_blank">维基共享资源</a></figcaption></figure><p id="f536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://www.digitizationguidelines.gov/term.php?term=thresholding#:~:text=Note%3A-,Term%3A%20Thresholding,be%20applied%20to%20color%20images." rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">阈值处理</strong> </a> <strong class="lb iu"> </strong>是将灰度图像转换为纯黑白图像的过程。灰度图像中的每个像素都有一个范围从<strong class="lb iu"> 0(黑色)</strong>到<strong class="lb iu"> 255(白色)的值。基于某个阈值，任何像素值小于该阈值的像素将被设为0，任何像素值大于该阈值的像素将被设为255。</strong></p><blockquote class="od"><p id="5a0d" class="oe of it bd og oh oi oj ok ol om lu dk translated">“世界不是黑就是白，没有中间地带”——阈值。</p></blockquote><p id="34a8" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated"><a class="ae ky" href="https://www.tutorialspoint.com/opencv/opencv_simple_threshold.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">简单阈值处理</strong> </a>基本上是阈值保持不变的地方。下面是我们在简单阈值处理后的<strong class="lb iu">测试</strong>:</p><p id="6ebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">请忽略下面错误的窗口名</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/94f4694f10a9450cc469d2e48cf54139.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/0*G9mB0PgfiscEMFpG"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</figcaption></figure><blockquote class="nk nl nm"><p id="0990" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated">一点都不好。</p></blockquote><p id="ad9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，可能是什么原因？</p><p id="2cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是，由于图像不同部分的光照可能存在差异，恒定的阈值不会消除这种差异。</p><p id="7343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自适应阈值来拯救。</p><blockquote class="od"><p id="aa5c" class="oe of it bd og oh oi oj ok ol om lu dk translated">“如你所愿改变照明，我将适应”——自适应阈值</p></blockquote><p id="ea9f" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated"><a class="ae ky" href="https://www.tutorialspoint.com/opencv/opencv_adaptive_threshold.htm#:~:text=Adaptive%20thresholding%20is%20the%20method,()%20of%20the%20Imgproc%20class." rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">自适应阈值处理</strong> </a> <strong class="lb iu"> </strong>顾名思义使用某种函数根据邻域像素改变阈值的值。其中两个函数是<a class="ae ky" href="https://www.tutorialspoint.com/opencv/opencv_adaptive_threshold.htm#:~:text=Adaptive%20thresholding%20is%20the%20method,()%20of%20the%20Imgproc%20class." rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">表示</strong> </a> <strong class="lb iu"> </strong>和<a class="ae ky" href="https://www.sciencedirect.com/science/article/pii/0167865588900323" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">高斯</strong> </a> <strong class="lb iu">。</strong></p><div class="kj kk kl km gt ab cb"><figure class="ot kn ou ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/3f24a96b3103195845946c7b754e4df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*SkbBEyKMaqTP-bdMM5EhAw.png"/></div></figure><figure class="ot kn oz ov ow ox oy paragraph-image"><img src="../Images/4ad53ee91db8cfd1c0f34ee64a5126f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*GFyOTS6Gk-VRGESKo7thkw.png"/><figcaption class="ku kv gj gh gi kw kx bd b be z dk pa di pb pc translated">自适应高斯与自适应均值阈值</figcaption></figure></div><h2 id="87f4" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">第二步:反转和扩张</h2><p id="2175" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated"><a class="ae ky" href="https://www.mathworks.com/help/supportpkg/raspberrypi/examples/image-inversion.html#:~:text=Black%20and%20white%20image%20inversion,areas%20are%20mapped%20to%20light.&amp;text=An%20inverted%20black%20and%20white,negative%20of%20the%20original%20image." rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">反转</strong> </a> <strong class="lb iu"> </strong>顾名思义就是将所有黑色像素转换为白色，白色像素转换为黑色。<a class="ae ky" href="http://matlab.izmiran.ru/help/toolbox/images/morph2.html#:~:text=Dilation%20adds%20pixels%20to%20the,used%20to%20process%20the%20image." rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">膨胀</strong> </a> <strong class="lb iu"> </strong>简单来说就是通过添加像素的排序来加厚边界的一种方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/35022eb4b5a0206a6e096307f6fe94d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/0*wzPErpfiYmmoGFfA"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="pe">正常与扩张图像</em></figcaption></figure><p id="a93d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成<strong class="lb iu">步骤1和2 </strong>后，我摆弄了几组不同的<strong class="lb iu">模糊、阈值、</strong>和<strong class="lb iu">膨胀</strong>以及<strong class="lb iu">反转</strong>:</p><div class="kj kk kl km gt ab cb"><figure class="ot kn pf ov ow ox oy paragraph-image"><img src="../Images/6dfa6b13ffa4938573d0938e8a9f990d.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*DEOjrFkhoK42xLP9uH4yxw.png"/></figure><figure class="ot kn pg ov ow ox oy paragraph-image"><img src="../Images/f8ab9e9843128c8bdcb6ba38a083958f.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*R9O_4UIPJ4PwNTxgpiAcwQ.png"/></figure></div><div class="ab cb"><figure class="ot kn ph ov ow ox oy paragraph-image"><img src="../Images/19bd1f8c2b12b475f2c945d7d67a448e.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*79YVhfDCQ7rppA2fQgYO4g.png"/></figure><figure class="ot kn pi ov ow ox oy paragraph-image"><img src="../Images/2a7a8a9de2916ec5cdc5eba772b8c23b.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*0wE4bURXWAWJnm-DxiQmSg.png"/><figcaption class="ku kv gj gh gi kw kx bd b be z dk pa di pb pc translated">不同组合的结果。(图片由作者提供)</figcaption></figure></div><p id="d51f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后选定了下面的组合。<strong class="lb iu">原因</strong>是边界线和数字又粗又实。我们不担心内盒线，因为它们是不必要的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/cb53cdc8b243d7d9677dec162e253067.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/0*ONr37tQjHvSlEnuo"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">最终的组合。(图片由作者提供)</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="6aa6" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">网格提取</h1><h2 id="d7e4" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">步骤1:检测网格</h2><p id="0351" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们来谈谈斑点，不，不是你想的那种。嗯，这种也有点类似于传统的那种。</p><p id="fbd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> BLOB </strong>代表<a class="ae ky" href="https://en.wikipedia.org/wiki/Binary_large_object" rel="noopener ugc nofollow" target="_blank">二进制大对象</a>，指的是二进制图像中一组相连的像素。这里有一个例子可以更好地说明这个意思。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/e6d9bb72dc610d7dc10c336cc4f8ea37.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/0*75to8ObYYTGHTAUg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">红色圆圈代表黑色斑点。(图片来自<a class="ae ky" href="https://commons.wikimedia.org/wiki/Main_Page" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>)</figcaption></figure><p id="b03f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看下图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/47ff95985b726567424861396c4df977.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/0*GCioAqD35yb1vdVB"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</figcaption></figure><p id="5d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意到什么了吗？</p><blockquote class="od"><p id="10f6" class="oe of it bd og oh oi oj ok ol om lu dk translated">外部网格是一团白色像素！</p></blockquote><p id="7556" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">很容易看出，外部网格包围的区域相当大，事实上是最大的。</p><p id="364f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们所要做的就是找到最大的斑点，这将是我们的董事会！</p><p id="a263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何找到最大的斑点？<em class="me">——</em>答案是洪水填充。</p><p id="ccbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Flood_fill" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">洪水填充</strong>基本上就是从某个点(<em class="me">种子点)</em>开始，对相同像素值的所有连接点进行着色的算法</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/da9bc2956dfe57b4063d8393cc6ec597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/0*bYdHx077UKaPlZO3"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们开始用绿色填充较大形状内部的白色点，正如你所看到的，整个形状都是绿色的。(图片由<a class="ae ky" href="https://commons.wikimedia.org/wiki/Main_Page" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>提供)</figcaption></figure><p id="bb4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在用洪水填充，我们可以隔离斑点，从而分离出最大的斑点，这就是我们的网格。所以我们所要做的就是用黑色填充所有的斑点，除了最大的那个。</p><div class="kj kk kl km gt ab cb"><figure class="ot kn pn ov ow ox oy paragraph-image"><img src="../Images/886775396cc133a6eb5c141a8739b7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*xCLrNG_NFrlyhaVqvgXseg.png"/></figure><figure class="ot kn po ov ow ox oy paragraph-image"><img src="../Images/cabd31bef41f5019e173e110ce2cbbe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*zgmIVsuK-YurcZ90P7zgbw.png"/><figcaption class="ku kv gj gh gi kw kx bd b be z dk pp di pq pc translated">洪水填充正在进行中(左)和已完成(右)。(图片由作者提供)</figcaption></figure></div><p id="47c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">瞧！我们成功隔离了外层网格。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/3d793cc5900b1214e49616107f327db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/0*fQ5AFzkfQ-cP-DDe"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</figcaption></figure><blockquote class="od"><p id="f21f" class="oe of it bd og oh ps pt pu pv pw lu dk translated">记得扩张吗？请允许我介绍他的死敌糜烂。</p></blockquote><p id="9e8d" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated"><strong class="lb iu">侵蚀</strong>是通过移除像素来细化边界的过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/456e3494bf14ec59a7604e2b70ba43cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/0*x1RRsnMBN1ZlPLVx"/></div></figure><blockquote class="nk nl nm"><p id="0547" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated">这么说吧，如果右边是原图，那么左边的图就被侵蚀了。</p></blockquote><p id="acce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们侵蚀网格一点，以撤销我们之前应用的膨胀。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/57642a3276277a076a4729c6b24c94e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/0*6HJzPfPfjxemjkXJ"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</figcaption></figure><h2 id="f57f" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">第二步:寻找边界线</h2><p id="37ab" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">让我们从找到所有的线开始。我们可以使用<a class="ae ky" href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghlines/py_houghlines.html" rel="noopener ugc nofollow" target="_blank">霍夫线变换</a>来实现。</p><p id="3cad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数学并不那么简单，所以我们只能说这是一种识别图像中直线的技术。点击阅读更多关于这个<a class="ae ky" href="https://tomaszkacmajor.pl/index.php/2017/06/05/hough-lines-transform-explained/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="6fb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦所有的线都找到了，下一步就是找到极端或边界线。这是简单而优雅的逻辑。</p><ul class=""><li id="f83e" class="py pz it lb b lc ld lf lg li qa lm qb lq qc lu qd qe qf qg bi translated">斜率几乎为0 <strong class="lb iu">(几乎水平)</strong>的离顶部最近的线将是上边缘。</li><li id="8d02" class="py pz it lb b lc qh lf qi li qj lm qk lq ql lu qd qe qf qg bi translated">斜率几乎为0 <strong class="lb iu">(几乎水平)</strong>的离底部最近的线是下边缘。</li><li id="63fa" class="py pz it lb b lc qh lf qi li qj lm qk lq ql lu qd qe qf qg bi translated">从左边算起斜率几乎为无穷大的最近的线<strong class="lb iu">(几乎垂直)</strong>将是左边缘。</li><li id="cda3" class="py pz it lb b lc qh lf qi li qj lm qk lq ql lu qd qe qf qg bi translated">从右边开始斜率几乎为无穷大的最近的线<strong class="lb iu">(几乎垂直)</strong>将是右边。</li></ul><p id="60f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">出奇的简单直观不是吗？</em></p><div class="kj kk kl km gt ab cb"><figure class="ot kn qm ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/b36d632d4bacc6da9e76febea4e92a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*YQF6T8zDM4LnDd4N_kCJqw.png"/></div></figure><figure class="ot kn qn ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/e54c9ce1dd18a550fe6684afbf7b7e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*5WDtOeCAilK8LsHuCHvwQA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk qo di qp pc translated">找到所有的线(左)，然后只选择边界线(右)。(图片由作者提供)</figcaption></figure></div><h2 id="f17c" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">第三步:寻找边界点。</h2><p id="f479" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">一旦找到线，我们就可以很容易地找到与一些线性代数的交点——使用<strong class="lb iu">行列式。</strong> <a class="ae ky" href="https://iq.opengenus.org/2d-line-intersection/" rel="noopener ugc nofollow" target="_blank">下面是怎么做的</a>。</p><p id="ae81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，不容易。事实上，我不得不做了相当多的阅读，即使在那时也很难实现这一部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qq"><img src="../Images/43a5a0b043c540e7bcf0b7ce16e92ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/0*yKROquvWfqr-A7y7"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在原始图像上绘制的边界线和点。(图片由作者提供)</figcaption></figure><h2 id="12e0" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">第四步:修正视角，裁剪掉网格。</h2><p id="fe60" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">现在，我们需要裁剪掉这一部分，并<em class="me">【校正】</em>透视。你可以看到图像的顶部看起来比底部离我们更远。</p><p id="71ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.pyimagesearch.com/2014/05/05/building-pokedex-python-opencv-perspective-warping-step-5-6/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">扭曲视角</strong> </a>。利用透视变换矩阵或单应矩阵来执行变换是校正透视的一种方式。</p><blockquote class="od"><p id="a76d" class="oe of it bd og oh oi oj ok ol om lu dk translated">简单来说，它<em class="pe">修正</em>视角。</p></blockquote><figure class="qs qt qu qv qw kn gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/de8abf6ad85c1fbf5a50e5c17da3f391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*HsWN1liNjGr3C-lW"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">扭曲视角。(图片来自<a class="ae ky" href="https://commons.wikimedia.org/wiki/Main_Page" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>)</figcaption></figure><p id="cffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">校正透视后，下面是图像的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qx"><img src="../Images/dddc8579fa0915252a4dfb428a5164b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/0*LkTBUYpzaot-5KQ8"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="922f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">咻！我们终于找到了坐标。</em></p><h2 id="5f86" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">步骤5:一些图像处理</h2><p id="d136" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">现在是一些有趣的阈值和反转。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qy"><img src="../Images/dc4e82edfde63560dbb49d59cd2c19f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/0*1qLSRVEYbX4s3zef"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</figcaption></figure><h2 id="7b1d" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">第六步:细胞提取</h2><p id="875c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">现在该拿把刀了，因为我们要把这个坏小子切成81块。</p><p id="b3fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">* <em class="me">恶魔般的微笑*和*急切地磨刀* </em></p><p id="7313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是其中一个被切碎的细胞的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qz"><img src="../Images/136441a5582330ac24fdf3d374325f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/0*gjwehGlFB478uL4s"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</figcaption></figure><p id="ac0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确实很寒酸。</p><h2 id="f860" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">第七步:细胞清洁</h2><p id="2518" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们需要去掉背景中那些肮脏的白色斑点，但是怎么做呢？</p><p id="7a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">*头脑风暴努力* </em></p><p id="63f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得之前的洪水填充吗？</p><blockquote class="od"><p id="1aac" class="oe of it bd og oh oi oj ok ol om lu dk translated">如果我们用黑色填充所有的白色外层点，那么我们可以去掉那些难看的白色斑块！</p></blockquote><p id="994a" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated"><em class="me">嗯，猜不到。</em></p><p id="3f45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果白色斑块从内层开始，那么我们就有问题了。</p><p id="ce2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">*随着挫败感的加剧而挠头* </em></p><p id="8ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我终于想出了(<em class="me">不那么</em>)绝妙的解决方案:</p><blockquote class="od"><p id="e644" class="oe of it bd og oh oi oj ok ol om lu dk translated">从最后2层或3层进行整体填充，而不仅仅是外层。</p></blockquote><p id="ff8a" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">既然它奏效了，我决定坚持下去。</p><h2 id="114c" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">第八步:将数字放在图像的中心</h2><p id="4b9d" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">于是我找到了数字的<strong class="lb iu">包围盒</strong>，通过循环移动像素使图像居中。</p><p id="6e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">那么如何找到包围盒呢？</em></p><ul class=""><li id="9b14" class="py pz it lb b lc ld lf lg li qa lm qb lq qc lu qd qe qf qg bi translated">从图像的中心开始，向四个方向移动。</li><li id="311f" class="py pz it lb b lc qh lf qi li qj lm qk lq ql lu qd qe qf qg bi translated">当我们碰到一个没有任何白色像素的行或列时，这意味着我们到达了数字的末尾！</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ra"><img src="../Images/f6b704aebcf6bd49ecaec453cf6d79a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/0*i3umUBsfx6sF03K8"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在广阔的黑暗中孤独的坚定者。(图片作者提供)</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="fc78" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">数字识别</h1><p id="c9b8" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们得到了网格，我们可以继续识别81个单元格中的数字，对吗？</p><p id="1436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">不对，有问题。</em></p><blockquote class="od"><p id="bcdc" class="oe of it bd og oh oi oj ok ol om lu dk translated">如果单元格是空的呢？我们如何事先识别空细胞？</p></blockquote><p id="6b0d" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated"><em class="me"> *头脑风暴加剧* </em></p><p id="9aa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me"> *别说了，想简单点* </em></p><p id="3f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看下面一个空单元格的图片:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rb"><img src="../Images/8500ec54e1ab3425bdfa683786dd9692.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/0*unMd-m6l0vCaloM5"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</figcaption></figure><p id="ad57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有什么想法吗？</p><p id="b98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意到什么了吗？</p><blockquote class="od"><p id="6df6" class="oe of it bd og oh oi oj ok ol om lu dk translated">空单元格根本没有任何白色像素。</p></blockquote><p id="5f2d" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">因此，我们所要做的就是对所有像素的像素值求和，并检查它是否小于某个阈值。</p><p id="0817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阈值的原因是可能会有剩余的白色斑块。我将阈值设置为5个白色像素(<em class="me">为了安全起见)。</em></p><h2 id="4f57" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">现在让我们继续辨认<strong class="ak">和</strong>。</h2><p id="15c6" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">时间召唤<a class="ae ky" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">张量流</strong> </a> <strong class="lb iu"> </strong>和<a class="ae ky" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Sklearn </strong> </a> <strong class="lb iu">。</strong>我首先在<a class="ae ky" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST手写数字数据集</a>上构建并训练了一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" rel="noopener ugc nofollow" target="_blank">卷积神经网络(CNN) </a> <strong class="lb iu"> </strong>。</p><p id="b73e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> MNIST </strong>数据集是由70，000个28X28像素的手写数字图像组成的数据集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rc"><img src="../Images/84ab8597e766de03ca07b4f4639fa1af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/0*lVGkSq8A9OS7_s0a.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">MNIST数据集。(图片来自<a class="ae ky" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fcommons.wikimedia.org%2Fwiki%2FFile%3AMnistExamples.png&amp;psig=AOvVaw2JMoJkww20Myz5OYjYGxKK&amp;ust=1610542284303000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCPiX5tm3lu4CFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>)</figcaption></figure><h2 id="0ac2" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">神经网络</h2><p id="daad" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在我们讲一个CNN <strong class="lb iu"> </strong>是什么之前，我们先讲一个<a class="ae ky" href="https://www.investopedia.com/terms/n/neuralnetwork.asp#:~:text=Neural%20networks%20are%20a%20series,fraud%20detection%20and%20risk%20assessment." rel="noopener ugc nofollow" target="_blank">神经网络</a> <strong class="lb iu"> </strong>是什么:</p><blockquote class="od"><p id="cd43" class="oe of it bd og oh oi oj ok ol om lu dk translated"><strong class="ak">神经网络</strong>从非常高的抽象层次来说，是一种算法，或者说是一系列试图模仿大脑的算法。</p></blockquote><p id="a26d" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">它由多层<em class="me">节点</em>或<em class="me">神经元组成。这些神经元要么激活，要么不激活。一层中的每个神经元都与另一层中的每个神经元相连。随着层的堆积和每层神经元数量的增加，连接的数量呈指数增长<em class="me">。</em></em></p><blockquote class="od"><p id="cc83" class="oe of it bd og oh oi oj ok ol om lu dk translated">举例来说，仅用5层和每层32个神经元，我们将得到3，35，54，432个可能的连接！</p></blockquote><p id="77ba" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">让我们不要进入数学领域，因为它相当复杂，涉及许多微积分、线性代数和统计学。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rd"><img src="../Images/a19e6799a68feaec12c78507df8326fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/0*aoddg_b8SwKSx9xm.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个例证。(图片由<a class="ae ky" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fcommons.wikimedia.org%2Fwiki%2FFile%3AMultilayer_Neural_Network.png&amp;psig=AOvVaw20TPkJC-JzJaptors9wAKx&amp;ust=1610542370582000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCJC32IO4lu4CFQAAAAAdAAAAABAU" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>提供)</figcaption></figure><blockquote class="nk nl nm"><p id="1812" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated">当心，这些机器一天比一天聪明。</p><p id="c925" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated">嗯，事实上不，他们不是。只是很多抽象。在核心，他们所能做的就是玩0和1。</p></blockquote><p id="bb47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，<strong class="lb iu"> CNN </strong>是一类特殊的神经网络<strong class="lb iu">T5，主要用于计算机视觉。</strong></p><blockquote class="od"><p id="b81e" class="oe of it bd og oh oi oj ok ol om lu dk translated"><em class="pe"> CNN旨在用通俗的语言模仿人类的视觉。</em></p></blockquote><figure class="qs qt qu qv qw kn gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/41d950bb25a8729aa80bc0535720f5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*2za-notdawWzGvH5"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个CNN。(图片来自<a class="ae ky" href="https://commons.wikimedia.org/wiki/Main_Page" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>)</figcaption></figure><p id="f660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">因此，CNN基本上是一个添加了一堆额外层的神经网络。</em></p><p id="242d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解神经网络是如何工作的，我会推荐观看3B1B的这些令人惊叹的视频。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="re rf l"/></div></figure><h2 id="b42a" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">一个KNN</h2><p id="6e3e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">接下来，我转向一个可靠的简单的<a class="ae ky" href="https://searchenterpriseai.techtarget.com/definition/machine-learning-ML#:~:text=Machine%20learning%20(ML)%20is%20a,to%20predict%20new%20output%20values." rel="noopener ugc nofollow" target="_blank">机器学习</a>算法，叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank"> K近邻分类器</a>。</p><blockquote class="od"><p id="c840" class="oe of it bd og oh oi oj ok ol om lu dk translated">“告诉我谁是你的邻居，我会告诉你你是谁”——KNN</p></blockquote><figure class="qs qt qu qv qw kn gh gi paragraph-image"><div class="gh gi rg"><img src="../Images/a59cc56e2f66595e0a28b5380795337f.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/0*gTa_QoQWXJwaVy2l"/></div></figure><p id="70d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> K最近邻居:</strong>顾名思义，通俗地说，KNN分类器使用与邻居的距离来确定特定实体属于哪个类。</p><blockquote class="od"><p id="6822" class="oe of it bd og oh oi oj ok ol om lu dk translated">当我们训练KNN <strong class="ak"> </strong>进行数字识别时，我们基本上是在创造一个<strong class="ak"> 10维空间</strong>并在上面绘图。</p></blockquote><p id="50a9" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">试着想象一下。</p><p id="d059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管两者在MNIST数据集上都获得了大约97%的准确率，但KNN在测试中表现更好。</p><p id="0d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定在一个变量中实现和代码，以控制应用程序使用哪一个。</p><p id="9cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me"> TADA！</em> </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rh"><img src="../Images/c8493c96250a09d0285646b7ea774b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/0*4SC3qFLJ8I3MZYCJ"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</figcaption></figure><p id="8673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="0a95" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">解开谜题。</h1><p id="a807" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">现在剩下要做的就是解开这个谜题。一种叫做回溯的技术可以用来轻松地实现一个解决方案。</p><p id="fe1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/backtracking-introduction/#:~:text=Backtracking%20is%20an%20algorithmic%2Dtechnique,reaching%20any%20level%20of%20the" rel="noopener ugc nofollow" target="_blank"/></p><p id="6427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决数独，我们可以这样做:</p><ol class=""><li id="2c08" class="py pz it lb b lc ld lf lg li qa lm qb lq qc lu ri qe qf qg bi translated">找一个空的位置。</li><li id="793a" class="py pz it lb b lc qh lf qi li qj lm qk lq ql lu ri qe qf qg bi translated">在不违反行、列或内部框属性的情况下，找到所有可以插入该插槽的数字。</li><li id="d4ab" class="py pz it lb b lc qh lf qi li qj lm qk lq ql lu ri qe qf qg bi translated">尝试每一个数字并递归。如果这些数字中至少有一个是成功的，那么我们已经找到了一个解决方案，否则没有解决方案。</li></ol><p id="4391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是解决方案屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rj"><img src="../Images/2d6577b81379de64f3fbcb625f5d6743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/0*G_U9lBuRoAfb7DtC"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="10a9" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">图形用户界面</h1><p id="b7a5" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">一直以来，我都在用截图展示这个过程的不同步骤。如果你想知道我是从哪里得到它们的——从我使用<a class="ae ky" href="https://docs.python.org/3/library/tkinter.html" rel="noopener ugc nofollow" target="_blank"> Tkinter </a>为应用程序构建的UI。</p><h2 id="bee7" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated"><strong class="ak">主界面:</strong></h2><p id="a51a" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">所有的框架相互堆叠，每当要显示任何一个框架时，使用<a class="ae ky" href="https://www.kite.com/python/docs/tkinter.Frame.tkraise" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Tkraise </strong> </a> <strong class="lb iu"> </strong>来升起该框架。</p><p id="dce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一个画面:</strong>第一个画面是显示主画面，也是加载图像后的画面。</p><div class="kj kk kl km gt ab cb"><figure class="ot kn rk ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/7ed43b8b2942c39bba8dc77060126aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*CtUg_n-9XXTvui5qgR66rA.png"/></div></figure><figure class="ot kn rl ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/b9e26774648c3cbcd9d24de306708b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*7lzI1fiyMX3rLLgVmmSCxQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk rm di rn pc translated">主屏幕和加载图像后的屏幕。(图片由作者提供)</figcaption></figure></div><h2 id="34fe" class="nq mn it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated"><strong class="ak">第二帧:</strong></h2><p id="e68c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">第二帧显示图像从初始图像开始直到识别和求解所经历的所有阶段。几个阶段:</p><div class="kj kk kl km gt ab cb"><figure class="ot kn ro ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/797282e1c10bb9315ae0c8896d957309.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*eN13F5dwPpcQ3s8a_xYFzg.png"/></div></figure><figure class="ot kn rp ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/e72410aa1d7efd4974fa7f2f429d3512.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*F9f6hue4hbo9_8HMJKub2g.png"/></div></figure><figure class="ot kn rq ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/3d6fc769430e03be7aaa4717a85fe414.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*_LZZPjWbygs56Zj7G36P_w.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk rr di rs pc translated">(图片由作者提供)</figcaption></figure></div><p id="8541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第三帧:</strong>第三帧显示识别的数独网格。在这里，用户可以更改任何错误识别的条目，并单击显示解决方案来查看解决方案。</p><p id="9cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为应用程序不是100%准确的，任何人工智能模型也不可能做到这一点！</p><div class="kj kk kl km gt ab cb"><figure class="ot kn rt ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/14173407a1257e84a8db25b681d4cf41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*XJ4ZmFZLbSFcDZB22MNEuQ.png"/></div></figure><figure class="ot kn ru ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/ad9ba7c8b609df75a092f4b27a6cde80.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*API_9-hf7W3sA9Y31T8X6A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk rm di rn pc translated">解数独前后。(图片由作者提供)</figcaption></figure></div></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="0e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">砍！我们完了。总的来说，这个项目很有趣，但也很耗时——我花了大约十天时间，每天花7到8个小时来完成这个项目。大约70个小时的努力，有趣的是GUI比AI花了更多的时间。</p><blockquote class="od"><p id="c595" class="oe of it bd og oh oi oj ok ol om lu dk translated">“所以大约70个小时的努力，有趣的是，GUI比AI部分花了更多的时间。”</p></blockquote><p id="bf93" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">我没有深入到每一步，也没有粘贴代码片段，因为如果我这样做的话会太长太无聊。我只是想说明应用程序的整体逻辑和流程。</p><p id="8043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个项目是托管在我的<strong class="lb iu"> Github </strong>的<a class="ae ky" href="https://github.com/neeru1207/AI_Sudoku" rel="noopener ugc nofollow" target="_blank"> neeru1207/AI_Sudoku </a>上。所以，如果你想尝试一下，并有可能改进它，请随意去做。</p><p id="e1af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个项目在Github上获得了相当多的关注，到目前为止已经获得了超过750颗星星！关于这个项目的另一个有趣的事实是，在2020年2月初的一天，它在Github趋势上排名第一。</p><blockquote class="od"><p id="ae91" class="oe of it bd og oh oi oj ok ol om lu dk translated">2020年2月初的某一天，它<!-- -->在Github上排名第一。</p></blockquote><p id="a760" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">这篇文章加上我已经写了一个非常详细的自述文件，并且整个代码库都有很好的注释，所以你理解代码应该没有任何问题。</p><p id="11e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，希望您喜欢这篇文章！如果你喜欢这个，你可能也会喜欢，</p><div class="rv rw gp gr rx ry"><a href="https://medium.com/analytics-vidhya/skeletonization-in-python-using-opencv-b7fa16867331" rel="noopener follow" target="_blank"><div class="rz ab fo"><div class="sa ab sb cl cj sc"><h2 class="bd iu gy z fp sd fr fs se fu fw is bi translated">使用OpenCV在Python中进行骨架化</h2><div class="sf l"><h3 class="bd b gy z fp sd fr fs se fu fw dk translated">让我以一个(不太)有趣的笑话开始。</h3></div><div class="sg l"><p class="bd b dl z fp sd fr fs se fu fw dk translated">medium.com</p></div></div><div class="sh l"><div class="si l sj sk sl sh sm ks ry"/></div></div></a></div><div class="rv rw gp gr rx ry"><a href="https://medium.com/datadriveninvestor/how-i-landed-a-summer-internship-at-flipkart-df6e509a5751" rel="noopener follow" target="_blank"><div class="rz ab fo"><div class="sa ab sb cl cj sc"><h2 class="bd iu gy z fp sd fr fs se fu fw is bi translated">我是如何在Flipkart得到一份暑期实习的。</h2><div class="sf l"><h3 class="bd b gy z fp sd fr fs se fu fw dk translated">我是在NITK大学攻读CSE生物技术的四年级本科生。我最近完成了在Flipkart的暑期实习…</h3></div><div class="sg l"><p class="bd b dl z fp sd fr fs se fu fw dk translated">medium.com</p></div></div><div class="sh l"><div class="sn l sj sk sl sh sm ks ry"/></div></div></a></div><div class="rv rw gp gr rx ry"><a rel="noopener  ugc nofollow" target="_blank" href="/a-tricky-and-interesting-linked-list-problem-2330d9086102"><div class="rz ab fo"><div class="sa ab sb cl cj sc"><h2 class="bd iu gy z fp sd fr fs se fu fw is bi translated">一个棘手且相当有趣的链表问题</h2><div class="sf l"><h3 class="bd b gy z fp sd fr fs se fu fw dk translated">在最后一轮编码面试中，我被要求解决这个问题</h3></div><div class="sg l"><p class="bd b dl z fp sd fr fs se fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="sh l"><div class="so l sj sk sl sh sm ks ry"/></div></div></a></div></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="caad" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak"> <em class="pe">有用资源</em> </strong></h1><blockquote class="nk nl nm"><p id="7416" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated"><a class="ae ky" href="https://towardsdatascience.com/understanding-neural-networks-19020b758230" rel="noopener" target="_blank"> <em class="it">理解神经网络</em> </a></p><p id="fa12" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated"><a class="ae ky" href="https://towardsdatascience.com/machine-learning-basics-with-the-k-nearest-neighbors-algorithm-6a6e71d01761" rel="noopener" target="_blank"> <em class="it">机器学习基础知识与K近邻算法</em> </a></p><p id="553a" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated"><a class="ae ky" href="http://aishack.in/" rel="noopener ugc nofollow" target="_blank"> <em class="it">艾窝棚</em> </a></p><p id="2449" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated"><a class="ae ky" href="https://pythonprogramming.net/tkinter-depth-tutorial-making-actual-program/" rel="noopener ugc nofollow" target="_blank"><em class="it">YouTube上的send ex</em></a></p><p id="0e23" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated">OpenCV   <em class="it">中的<a class="ae ky" href="http://aishack.in/tutorials/sudoku-grabber-opencv-plot/" rel="noopener ugc nofollow" target="_blank"> <em class="it">数独抓取器是</em>真的<em class="it">帮我解决了网格提取部分的教程。对于网格提取部分，我遵循了本教程中列出的相同步骤。</em></a></em></p><p id="cb13" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated"><a class="ae ky" href="https://wiki.python.org/moin/TkInter" rel="noopener ugc nofollow" target="_blank">T31】Tkinter—Python WikiT33】</a></p><p id="d461" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated"><a class="ae ky" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html" rel="noopener ugc nofollow" target="_blank"> <em class="it"> OpenCV-Python教程</em> </a></p><p id="4883" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/backtracking-introduction/" rel="noopener ugc nofollow" target="_blank"> <em class="it">回溯|简介— GeeksforGeeks </em> </a></p><p id="e81f" class="kz la me lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/sudoku-backtracking-7/" rel="noopener ugc nofollow" target="_blank"> <em class="it">数独|回溯-7 — GeeksforGeeks </em> </a></p></blockquote></div></div>    
</body>
</html>