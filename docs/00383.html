<html>
<head>
<title>Writing a Custom TypeScript AST Transformer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写自定义类型脚本AST转换器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-a-custom-typescript-ast-transformer-731e2b0b66e6?source=collection_archive---------1-----------------------#2019-01-30">https://levelup.gitconnected.com/writing-a-custom-typescript-ast-transformer-731e2b0b66e6?source=collection_archive---------1-----------------------#2019-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="479c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="b41c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我的第一篇博文中，我想介绍一下我最近使用TypeScript的<a class="ae lj" href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API" rel="noopener ugc nofollow" target="_blank">编译器API </a>解决的一个问题。我敢肯定，如果没有各种博客和StackOverflow答案的帮助，我将无法获得一些东西，因此，不写下我对一套强大但记录不多的工具的学习是非常自私的。</p><h1 id="8fab" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">涉及的主题</h1><p id="72b5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">TypeScript编译器API基础(解析器术语、转换器API、分层架构)、ASTs、访问者模式、代码生成。</p><h1 id="0f7b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">先决条件</h1><p id="c236" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">@ <a class="ae lj" href="https://medium.com/@vaidehijoshi" rel="noopener"> Vaidehi Joshi </a>有一篇<a class="ae lj" href="https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff" rel="noopener">关于ASTs的很棒的文章</a>，如果你不熟悉这个概念，我建议你读一下。她的basecs 系列很精彩，你应该去看看。</p><h1 id="c95b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我正在解决的问题</h1><p id="39cc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们在Avero 使用GraphQL，并且一直想在解析器周围添加一些类型安全。我遇到了graphqlgen，它解决了我在模型概念上遇到的很多问题。在这篇博文中，我不想深入探讨这个话题，但我希望将来能写一些深入GQL的东西。<em class="lk"> tldr </em>是模型代表了你的查询解析器的返回值(可能与你的GQL模式不同)，在graphqlgen中，你使用某种配置(YAML或带有类型声明的TypeScript文件)将这些模型与接口相关联。</p><p id="8f03" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在工作中，我们运行<a class="ae lj" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>微服务，GQL主要为我们的UI消费者提供一个良好的扇出层。我们已经发布了与我们的<a class="ae lj" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank"> proto </a>契约相匹配的TypeScript接口，我想在graphqlgen中使用这些类型作为我们的<em class="lk">模型</em>，但是由于<a class="ae lj" href="https://github.com/prisma/graphqlgen/issues/282" rel="noopener ugc nofollow" target="_blank">类型导出支持</a>以及我们的TypeScript接口发布方式(大量命名空间，大量引用)而遇到了一些问题。</p><p id="261a" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">像任何优秀的开源公民一样，我的第一个方法是利用graphqlgen repo中已经完成的工作，并尝试添加一个有意义的贡献。为了进行类型自省，graphqlgen使用<a class="ae lj" href="https://github.com/babel/babel/tree/master/packages/babel-parser" rel="noopener ugc nofollow" target="_blank"> @babel/parser </a>来读取TypeScript(在我的例子中)文件，并收集关于接口名称和声明(接口的字段)的信息。</p><p id="fef5" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">任何时候我想用ASTs做任何事情，我都会立即拉起astexplorer.net的<a class="ae lj" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank">开始玩。这个工具允许我们探索由许多不同的解析器生成的ast，包括@babel/parser和TypeScript编译器解析器。它为我们提供了一个很好的方式来可视化我们将要使用的数据结构，并让您熟悉给定解析器的AST节点的<em class="lk">类型</em>。</a></p><p id="08bc" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">让我们来看一个使用babel-parser的示例输入文件和相应的AST:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="78cc" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">我们AST的根(节点类型为<strong class="kn ir">的程序</strong>)在它的主体中有两个语句，一个<strong class="kn ir"> ImportDeclaration </strong>和一个<strong class="kn ir"> ExportNamedDeclaration </strong>。</p><p id="d473" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">首先查看我们的<strong class="kn ir"> ImportDeclaration </strong>，我们对两个属性感兴趣:<strong class="kn ir"> source </strong>和<strong class="kn ir">说明符</strong>。这些节点只包含关于源文本的信息。比如源值是<em class="lk"> my_company_protos </em>。这没有给我任何关于这是一个相对文件路径还是引用一个外部模块的信息，所以这是我必须使用解析器方法解决的一个问题。</p><p id="6e60" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">同样，在我们的<strong class="kn ir"> ExportNamedDeclaration </strong>中，我们得到了关于源文本的基本信息。名称空间使这种结构变得复杂，它可以任意嵌套，这增加了越来越多的<strong class="kn ir">qualified type identifier</strong>。如果我们继续走这条路，这将是我们需要解决的另一个尴尬局面。</p><p id="d8aa" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">我甚至还没有从导入中解析类型呢！假设解析器和AST(根据设计)受限于其源文本中的信息，我们需要解析任何导入的文件，以便在最终的AST中获得这些信息。但是那些进口货可能有他们自己的进口货！</p><p id="b61d" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在没有大量代码的情况下，解析器在解决我们的问题时似乎非常有限，所以让我们后退一步，再次思考这个问题。</p><p id="bbad" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">我们不想处理导入，我们不想关心文件结构。我们希望能够解析<em class="lk"> protos.user.User </em>的所有属性，并内联它们，而不是依赖于导入。我们如何获得这种类型的信息来开始构建这个文件呢？</p><h1 id="3b40" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">TypeScript的类型检查器简介</h1><p id="ec82" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">既然我们已经决定一个解析器不足以收集导入接口的类型信息，那么让我们回顾一下TypeScript <a class="ae lj" href="https://github.com/Microsoft/TypeScript/wiki/Architectural-Overview#overview-of-the-compilation-process" rel="noopener ugc nofollow" target="_blank">编译过程</a>是如何工作的，看看我们是否可以推断出下一步应该在哪里查找。</p><p id="cf9d" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这里有一个部分非常突出:</p><blockquote class="lx ly lz"><p id="b333" class="kl km lk kn b ko ll kq kr ks lm ku kv ma ln ky kz mb lo lc ld mc lp lg lh li ij bi translated">从程序实例中可以创建类型检查器。TypeChecker是TypeScript类型系统的核心。它负责计算不同文件中符号之间的关系，为符号指定类型，并生成任何语义诊断(即错误)。</p><p id="5166" class="kl km lk kn b ko ll kq kr ks lm ku kv ma ln ky kz mb lo lc ld mc lp lg lh li ij bi translated">类型检查器要做的第一件事是将来自不同源文件的所有符号合并到单个视图中，并通过“合并”任何公共符号(例如，跨多个文件的命名空间)来构建单个符号表。</p><p id="bacc" class="kl km lk kn b ko ll kq kr ks lm ku kv ma ln ky kz mb lo lc ld mc lp lg lh li ij bi translated">初始化初始状态后，类型检查器就可以回答任何关于程序的问题了。此类“问题”可能是:</p><p id="0048" class="kl km lk kn b ko ll kq kr ks lm ku kv ma ln ky kz mb lo lc ld mc lp lg lh li ij bi translated">这个节点的符号是什么？</p><p id="6f3a" class="kl km lk kn b ko ll kq kr ks lm ku kv ma ln ky kz mb lo lc ld mc lp lg lh li ij bi translated">这个符号是什么类型的？</p><p id="4aed" class="kl km lk kn b ko ll kq kr ks lm ku kv ma ln ky kz mb lo lc ld mc lp lg lh li ij bi translated">AST的这一部分有哪些可见符号？</p><p id="d72b" class="kl km lk kn b ko ll kq kr ks lm ku kv ma ln ky kz mb lo lc ld mc lp lg lh li ij bi translated">函数声明有哪些可用的签名？</p><p id="532c" class="kl km lk kn b ko ll kq kr ks lm ku kv ma ln ky kz mb lo lc ld mc lp lg lh li ij bi translated">文件应该报告哪些错误？</p></blockquote><p id="b25d" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><strong class="kn ir">类型检查器</strong>听起来正是我们需要的！我们希望访问底层的符号表和API，这样我们就可以回答前两个问题:<em class="lk">这个节点的符号是什么？而这个符号</em>是什么类型的？它甚至提到了处理合并公共符号，因此它解决了我们前面谈到的名称空间问题！</p><p id="4922" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">那么，我们如何得到这个API呢？</p><p id="d955" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这个是我能在网上找到的少数例子之一，但它足以让我们开始。我们可以看到，checker可以从我们的<strong class="kn ir">程序</strong>实例的方法中访问。查看该示例中的用法，我们可以看到诸如<em class="lk">checker . getsymbolatlocation</em>和<em class="lk">checker . gettypeofsymbolatlocation</em>之类的方法，这似乎至少是我们所需要的一些变体。</p><p id="9510" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">让我们开始写程序吧。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="06aa" class="mi jo iq me b gy mj mk l ml mm">ts-node ./src/ts-alias.ts</span><span id="7081" class="mi jo iq me b gy mn mk l ml mm">prints<br/>ImportDeclaration<br/>TypeAliasDeclaration<br/>EndOfFileToken</span></pre><p id="813e" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">我们关心的是这里的类型别名声明，所以让我们更新我们的代码来关注它。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f118" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">TypeScript为每个对应的节点类型提供了一个类型保护，因此我们可以通过利用这里的类型保护将节点缩小到适当的类型。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/bdedf4405252d177883601ba080d5fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FKBbkLcLMc8Up9-x"/></div></div></figure><p id="886b" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">现在我们有了节点，我们想回到前面提到的两个问题:<em class="lk">这个节点的符号是什么？这个符号是什么类型的？</em></p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7d12" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">因此，我们通过与<strong class="kn ir">类型检查器</strong>的符号表交互，获得了类型别名接口声明的名称。我们还有一段路要走，但这是<em class="lk">内省</em>方面事情的一个很好的起点。</p><p id="6f62" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">让我们想想<em class="lk">一代</em>。</p><h1 id="83ef" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">转换API</h1><p id="a189" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们在前面展示了我们的目标…给定一个类型脚本文件，解析、自省并创建一个新的类型脚本文件。<em class="lk"> AST - &gt; AST </em>的函数签名在编程中非常常见，以至于TypeScript团队发布了一个<a class="ae lj" href="https://github.com/Microsoft/TypeScript/pull/13940" rel="noopener ugc nofollow" target="_blank">自定义转换API </a>来创建自己的API！</p><p id="72fe" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在我们深入研究最初的问题之前，让我们编写一个极其简单的定制转换器。感谢<a class="ae lj" href="https://43081j.com/" rel="noopener ugc nofollow" target="_blank">詹姆斯·加巴特</a>给我<a class="ae lj" href="https://43081j.com/2018/08/creating-a-typescript-transform" rel="noopener ugc nofollow" target="_blank">样板</a>开始。</p><p id="85f4" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">我们的第一个基本转换器将把数字文字转换成字符串文字。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="5fd2" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这里要担心的最重要的接口是<strong class="kn ir"> Visitor </strong>和VisitorResult:</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="38bf" class="mi jo iq me b gy mj mk l ml mm">type Visitor = (node: Node) =&gt; VisitResult&lt;Node&gt;;<br/>type VisitResult&lt;T extends Node&gt; = T | T[] | undefined;</span></pre><p id="94de" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">作为定制转换器的作者，我们的目标是编写这个<strong class="kn ir"> Visitor </strong>。我们递归地访问AST中的每个节点，并返回VisitResult，它可能是一个、多个或零个AST节点。我们可以针对特定的节点进行修改，而不去管其他的节点。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="9fd0" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><a class="ae lj" href="https://astexplorer.net/#/gist/8ebf7b4e7cfb4fdc9b8e8d6a739b4042/2590ce4e50e7e0198a108d454e1c4b9622b05509" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个带标签的AST，显示了我们将要使用的节点。</p><p id="3b68" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">我们的访问者需要处理两种主要情况:</p><ol class=""><li id="cdee" class="mv mw iq kn b ko ll ks lm kw mx la my le mz li na nb nc nd bi translated">用<strong class="kn ir">接口声明</strong>替换<strong class="kn ir">类型类声明</strong></li><li id="fd6f" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">将<strong class="kn ir">类型引用</strong>解析为<strong class="kn ir">类型文字</strong></li></ol><h1 id="5af2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解决办法</h1><p id="3dea" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是使用最小CLI的访问者代码的样子:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3396" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">我对我的解决方案的结果非常满意。它展示了良好的抽象、智能编译器设计、优秀的开发人员工具(VSCode autocomplete、AST explorer等)以及从其他聪明人的经验中获得一些外包的力量。完全更新的源代码可以在这里找到<a class="ae lj" href="https://github.com/ksaldana1/ts-alias-transformer" rel="noopener ugc nofollow" target="_blank">。我不确定这对我的狭窄用例之外的任何人有多大用处，但我主要是想展示TypeScript编译器工具链的强大功能，以及记录我对一个我以前没有真正解决的独特问题的思考过程。</a></p><p id="5f91" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">希望这对任何试图做类似事情的人有所帮助。如果您被诸如AST、编译器和转换这样的主题吓住了，我希望我给了您足够的样板文件和其他资源的链接。这里的代码是我坐下来长时间学习后的最终输出。用Github private repos我的第一次尝试，包括所有45个<em class="lk">//@ ts——忽略</em>和<em class="lk">！</em>断言在一份150行的文件中，可以隐藏耻辱的阴影。</p><h1 id="80ef" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">帮助我的资源</h1><div class="nj nk gp gr nl nm"><a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">Microsoft/TypeScript</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">TypeScript是JavaScript的超集，它通过编译来清理JavaScript输出。-微软/TypeScript</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa mt nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://43081j.com/2018/08/creating-a-typescript-transform" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">创建TypeScript转换器</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">去年，TypeScript合并了一个非常酷的Pull请求，它基本上公开了编译器API需要的部分…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">43081j.com</p></div></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://blog.scottlogic.com/2017/05/02/typescript-compiler-api-revisited.html" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">重新审视类型脚本编译器API</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">两年前，我写过关于TypeScript编译器API的文章。那项调查，以及围绕那篇博文的讨论…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">blog.scottlogic.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa mt nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://astexplorer.net" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">AST浏览器</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">在线AST浏览器。</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">astexplorer.net</p></div></div></div></a></div></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><figure class="lq lr ls lt gt lu gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi oj"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure></div></div>    
</body>
</html>