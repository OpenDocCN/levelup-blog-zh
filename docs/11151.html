<html>
<head>
<title>Memory Management In .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中的内存管理。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/memory-management-in-net-740b03d01e24?source=collection_archive---------0-----------------------#2022-02-21">https://levelup.gitconnected.com/memory-management-in-net-740b03d01e24?source=collection_archive---------0-----------------------#2022-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="cc8c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">回归基础</h2><div class=""/><div class=""><h2 id="1dd7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">中关于内存管理的所有内容。NET和重要的相关主题。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ea4d89a02baa77e70f72c1f52c3aacaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_NzEHJEqOPWpe0V7ZZDhQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">内存管理。网</strong>。由<a class="ae li" href="https://unsplash.com/@unarchive?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰瑞米·贝赞格</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><h1 id="975c" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="279e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这篇文章是关于<strong class="mc jd">中的内存管理。NET </strong>框架以及与之相关的一些重要主题和概念。</p><h2 id="7675" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">议程</h2><p id="3019" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这些是我们将在本文中涉及的主题。</p><p id="ebe8" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">👉栈存储器</p><p id="d98c" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">👉堆内存</p><p id="7dd9" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">👉变量分配</p><p id="91f4" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">👉系统呢。字符串？</p><p id="c6eb" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">👉装箱和拆箱</p><p id="f79b" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">👉碎片帐集</p><p id="8d82" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">堆内存类型<br/>【垃圾是什么？<br/>▎性能指标<br/>▎小对象堆(SOH)内存生成<br/>▎大对象堆(LOH)呢？垃圾收集触发<br/>垃圾收集过程</p><p id="119c" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">👉处置并最终确定</p><p id="5b38" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">托管和非托管<br/>内存泄漏<br/>终结进程<br/>终结器实现<br/>释放和终结模式</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><div class="nn no gp gr np nq"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd jd gy z fp nv fr fs nw fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe lb nq"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/bc844ea838cbcbb62477dcb38f43265b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-KSAc3wH61I5EEPmIQdiw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">堆栈内存</strong>。由<a class="ae li" href="https://unsplash.com/@eklektikum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Iva rajo VI</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="a996" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">栈存储器</h1><p id="0a71" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">堆栈内存被分配到计算机的RAM中。它用于静态内存分配。</p><p id="7e44" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">堆栈存储器的优点是:</p><ul class=""><li id="99a5" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv ol om on oo bi translated">分配的变量直接存储在内存中。</li><li id="392b" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">程序编译时就完成了分配。</li><li id="3a9a" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">对这个存储器的访问非常快。</li></ul><p id="ed79" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">堆栈上的分配以<strong class="mc jd">后进先出(LIFO) </strong>的方式保留，这意味着最近保留的块总是下一个要释放的块。这就是堆栈内存被用来跟踪嵌套函数调用的原因。</p><p id="0a8b" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">假设我们有下面这段简单的代码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="41f2" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">假设注释实际上代表了一些要执行的代码，当我们开始调用<code class="fe ow ox oy oz b">Function1</code>时，这就是将要发生的事情。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/e6acc8266d8112c5460b2f815cc8fd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Jja1Y6K0YYmCaN83zk8YbQ.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">嵌套函数调用</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="2714" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">如您所见，在每个函数开始时，都会创建一个堆栈帧，直到函数完全执行后，这个堆栈帧才会被释放。当一个子函数被调用时，一个子框架被创建等等，…</p><p id="2935" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这里值得一提的是，线程之间不共享堆栈内存。换句话说，对于每个线程，分配一个不与任何其他线程共享的新堆栈内存。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/f380ac157bd94cb4fcb578f34395bfaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXEisOLxtwqHT0fxAJ3EHA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">堆内存</strong>。照片由<a class="ae li" href="https://unsplash.com/@egnaro?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">里克·梅森</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><h1 id="6fee" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">堆内存</h1><p id="c785" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">堆内存被分配到计算机的RAM中。它用于动态内存分配。</p><p id="2072" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">堆上的分配是在运行时完成的，可以随机访问。</p><p id="ae9c" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">访问堆内存有点慢，但是堆的大小只受虚拟内存大小的限制。</p><p id="b035" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">堆内存分为两部分:</p><ul class=""><li id="6a9e" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv ol om on oo bi translated">小对象堆</li><li id="0a59" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">大型对象堆(LOH)</li></ul><p id="d4c9" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">关于这一点的更多细节将在本文后面介绍。</p><p id="716b" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这里值得一提的是，堆内存是在线程之间共享的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/8ba55cc6f3a5887906d7378d8219e13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXQkrJYrFol-TnspoPHYhQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">变量分配</strong>。照片由<a class="ae li" href="https://unsplash.com/@harrisonbroadbent?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">哈里森·布罗德本特</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="6920" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">变量分配</h1><p id="e7cb" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><strong class="mc jd">中使用的任何变量。NET </strong>会是两种类型之一；<strong class="mc jd">值</strong>型或<strong class="mc jd">参考</strong>型。</p><p id="e507" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated"><strong class="mc jd">值</strong>类型是原始数据类型，如Byte、SByte、Int16、Int32、Int64、UInt16、UInt32、UInt64、Single、Double、Boolean、Char、Decimal、IntPtr、UIntPtr和Structs。</p><p id="7e32" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">引用类型是开发者定义的其他类型，包括类、接口、委托、字符串和对象。</p><p id="0ef0" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，你可能会问:</p><blockquote class="pd pe pf"><p id="8071" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">这些变量存储在哪里？它们是否存储在堆栈存储器中？它们存储在堆内存中吗？</p></blockquote><p id="1af2" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这个问题的答案是:</p><ul class=""><li id="f5a3" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv ol om on oo bi translated">一个<strong class="mc jd">引用</strong>类型对象被存储在<strong class="mc jd">堆</strong>内存中，并且对它的引用被存储在<strong class="mc jd">栈</strong>内存中。</li><li id="ef9a" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">一个<strong class="mc jd">值</strong>类型对象总是存储在<strong class="mc jd">堆栈</strong>内存中，除非它被定义在一个类的第一级上。在这种情况下，它被存储在<strong class="mc jd">堆</strong>存储器中。</li></ul><p id="9dc4" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">你不相信我？让我展示给你看。</p><p id="f5c6" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">假设我们定义了以下两个类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="f33a" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，假设我们有这个简单的应用程序代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="2c08" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在这里，我们将逐个检查所有的情况，看看什么将被分配到堆内存中。为此，我们将使用Rider memory tracer向我们显示堆内存分配，并监视调用之间发生的变化。</p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="c040" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">第一步是检查何时定义一个<code class="fe ow ox oy oz b">int</code>，就像我们在第6行所做的那样。因此，我们在第6行和第10行添加了一个断点。当我们到达第6行的断点时，在执行该行之前，我们刷新了Rider上的堆内存跟踪器。然后我们点击continue，这样调试器就可以在第10行找到断点。然后，我们再次刷新了Rider上的堆内存跟踪器，以查看差异。</p><p id="7847" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这就是不同之处:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/f3013c98d22122e9b2edfbfd76497abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1XxaI7SDLoaky802k7pMg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">存储在堆栈中的值类型</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="1148" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">看，没有东西被分配到堆内存中。</p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="2cc7" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，让我们检查一下什么时候定义一个类的实例，它的第一级没有定义任何值类型。此外，它有一个方法，我们将值类型定义为该方法的本地成员。</p><p id="7edd" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">因此，对第10行和第15行的断点重复相同的步骤，我们将得到以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/7d2905fb60025ce9dc894c078bc352c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3_5mr9mUfF6OUgSz7rqUug.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">堆中存储的引用类型</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="c937" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">看，我们只有一个新的条目被分配到类本身的实例的堆内存中。然而，我们没有为方法<code class="fe ow ox oy oz b">F1</code>中定义的变量<code class="fe ow ox oy oz b">int id</code>分配任何内存到堆内存中。</p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="d8db" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，让我们检查一下什么时候定义一个类的实例，它的第一级定义了值类型。</p><p id="123f" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">因此，在第15行和第17行的断点处重复相同的步骤，我们将得到以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/13050c1435baa6227da40e8407e14e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_IzqH4Zq9yNE04y-JbaOzg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">存储在堆中的Class First Citizen值类型</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="1b35" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">看，我们只有一个新的条目被分配到类本身的实例的堆内存中。然而，当我们检查堆内存中的这个条目时，我们会发现它还包含了<code class="fe ow ox oy oz b">int Id</code>类成员。</p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="7c6c" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">因此，简单总结一下:</p><ul class=""><li id="e785" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv ol om on oo bi translated">引用类型总是存储在堆内存中，并引用堆栈内存。</li><li id="e062" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">如果一个值类型被定义到一个函数中，它将被存储到堆栈内存中。</li><li id="7641" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">如果值类型被定义为类的第一个成员(在类的第一层)，它将被存储到堆内存中。</li></ul></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="a529" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">如果你有兴趣看一段解释这个话题的视频，我真的推荐你去看<a class="ps pt ep" href="https://medium.com/u/a5fdd7e51866?source=post_page-----740b03d01e24--------------------------------" rel="noopener" target="_blank">尼克·查帕斯</a>的视频。我在准备这篇文章时偶然发现了它，我非常喜欢他简化整个事情的方式。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pu ov l"/></div></figure><p id="dc6b" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">感谢<a class="ps pt ep" href="https://medium.com/u/a5fdd7e51866?source=post_page-----740b03d01e24--------------------------------" rel="noopener" target="_blank">尼克·查普萨斯</a>带来这个精彩的视频🙂</p><p id="4a36" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这里值得一提的是，我已经发表了一篇关于在<strong class="mc jd">中向方法传递参数的不同方式的文章。NET C# </strong></p><p id="7498" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">了解这个话题也很重要。所以，如果有兴趣的话，可以看一下文章<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/passing-parameters-to-a-net-c-method-388badb7c095?sk=b5c21b7c4a8aca9a150ba64b5ba17825"> <strong class="mc jd">将参数传递给一个. NET C#方法</strong> </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/a3a842432fd6231bcc5ef941b8b665e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEqW_sTiV3QwJOHYZbIQaA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">系统呢。字符串？</strong>照片由<a class="ae li" href="https://unsplash.com/@amir_v_ali?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> amirali mirhashemian </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="b3fa" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">系统呢。字符串？</h1><p id="a610" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">作为一个<strong class="mc jd">。NET </strong>开发者，你可能听说过<code class="fe ow ox oy oz b">System.String</code>的性质。它在某种程度上是独一无二的，这种独一无二也带来了一些异常。</p><p id="4fa9" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在处理<code class="fe ow ox oy oz b">System.String</code>的时候，你需要记住它不仅仅是一个引用类型，它是一个特殊的类型。理解这一点肯定会影响您在应用程序中处理字符串的方式。</p><p id="ce87" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">关于这一点，我已经写了一篇非常详细的文章。我真的建议你读一读。如果你有兴趣，可以阅读文章<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/how-string-in-net-c-works-f1d69bfa30f5?sk=0f35a41a04bb4e508fd6dac17bd70ddf"> <strong class="mc jd">如何串进来。NET C#作品</strong> </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/d6cee890e0a01924e11dca493d99b2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jE74dYpbu_yQ0lc3gSy3HQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">装箱拆箱。</strong>照片由<a class="ae li" href="https://unsplash.com/@kelli_mcclintock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯利·麦克林托克</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><h1 id="0503" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">装箱和拆箱</h1><p id="b5e5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果你是一个<strong class="mc jd">。NET </strong>开发者，很可能你以前听说过<strong class="mc jd">装箱</strong>和<strong class="mc jd">拆箱</strong>。</p><p id="fad4" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">让我向您展示一个简单的代码示例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="85c5" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在第1行，我们定义了一个<code class="fe ow ox oy oz b">int</code>。在第2行，我们定义了一个新的<code class="fe ow ox oy oz b">Object</code>变量，并将其设置为我们在第1行定义的相同的<code class="fe ow ox oy oz b">int</code>。</p><p id="4e93" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">幕后发生的是<code class="fe ow ox oy oz b">int</code>变量被包装成一个对象，存储到堆内存中。这就是我们所说的<strong class="mc jd">拳击</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/ee9f26f9c9627514d8a930f303172d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YfkItSYoXIq4sXLvwT52Cw.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">装箱拆箱</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="5ab1" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在第3行，我们将<code class="fe ow ox oy oz b">Object</code>变量转换回<code class="fe ow ox oy oz b">int</code>。因此，对象被展开回到<code class="fe ow ox oy oz b">int</code>。这就是我们所说的<strong class="mc jd">拆箱</strong>。</p><p id="21d5" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，你可能会问:</p><blockquote class="pd pe pf"><p id="30f3" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">我们为什么要做这种事？是不是很奇怪？</p></blockquote><p id="b325" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">实际上不是。有时装箱和解箱会在你不知道的情况下发生，这是由于某些<strong class="mc jd">的设计。NET </strong>内置的函数和模块。</p><p id="cdca" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">让我给你看一些有趣的东西。假设你正在实现一个简单的函数，它接受任何类型的对象作为参数，并做一些基本的事情，比如在这个对象上调用<code class="fe ow ox oy oz b">.ToString()</code>。</p><p id="f60b" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">你可能认为这是一个很好的方法:</p><pre class="ks kt ku kv gt px oz py pz aw qa bi"><span id="919f" class="mw lk it oz b gy qb qc l qd qe">public static void Func(object param)<br/>{<br/>    param.ToString();<br/>}</span></pre><p id="5c51" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">它会工作并完成这个任务，但是如果你调用这个函数并传入一个<code class="fe ow ox oy oz b">int</code>或者一些结构，它也会触发<strong class="mc jd">装箱</strong>。</p><p id="a72f" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">想知道如何解决这个问题吗？让我展示给你看。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="2ce9" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">调用这些方法的方式如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="ea24" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">内存分析如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/dae173391166505a544f343f0e3e5735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mhsHdVq2iGF1Z7RSh3NXtg.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">装箱拆箱。</strong>图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="323d" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">看，这实际上是使用泛型的好处之一。然而，这并不总是一个简单的选择…</p><p id="c09f" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在我们的例子中，使用泛型很容易编写相同的函数，因为它只涉及一个参数。然而，如果它是关于无限数量的参数，这些参数可能有不同的类型呢？</p><p id="1af9" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">让我们检查一下<strong class="mc jd">中<code class="fe ow ox oy oz b">String.Format</code>的实现。网</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/86bee0d2b3747c73aaab1fd992af1343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBgev-KHsHQIsKNYeGPyUw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">弦。格式</strong>来自<a class="ae li" href="https://referencesource.microsoft.com/#mscorlib/system/string.cs,c07c3772222caaff" rel="noopener ugc nofollow" target="_blank">微软</a></figcaption></figure><p id="03e3" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">您注意到预期的参数了吗？它们可以是任何数量和任何类型的。因此，如果我们试图使用泛型来实现这个方法，我们将会失败。</p><p id="8411" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">所以，在这种情况下，我们无法避免<strong class="mc jd">拳</strong>。</p><p id="8507" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">此外，有趣的是，当你做这样的事情时:</p><pre class="ks kt ku kv gt px oz py pz aw qa bi"><span id="d13c" class="mw lk it oz b gy qb qc l qd qe">int id = 1;<br/>return $"The generated id equals {id}";</span></pre><p id="6b94" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">你实际上是在做<strong class="mc jd">装箱</strong>，因为这最终会使用<code class="fe ow ox oy oz b">String.Format</code>方法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/348932c2b422a38f3dc66b31e35713f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CMc7UZfSROMlYWnHtkT9A.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">垃圾收集。</strong>照片由<a class="ae li" href="https://unsplash.com/@zibik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> zibik </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="e8f8" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">碎片帐集</h1><p id="1273" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在像C和C++这样的语言中，开发人员负责清理分配的对象，这是一种开销，此外还有丢失一些分配的对象的风险，最终会导致内存泄漏。</p><p id="957e" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在<strong class="mc jd">中。网</strong>，就不同了。<strong class="mc jd">。NET框架接管了将对象分配到堆中的任务，并代表您管理对象分配。</strong></p><p id="9ce6" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">作为一个<strong class="mc jd">。NET </strong>开发者，你需要做的就是定义你的变量和<strong class="mc jd">。NET </strong>将负责创建、初始化对象，并将对象放在正确的内存中。</p><p id="24a0" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">再者，<strong class="mc jd">。NET </strong>跟踪你的对象，并知道什么时候不再需要某个对象，以便可以释放它。</p><p id="8b3d" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">所以，现在你可能会问:</p><blockquote class="pd pe pf"><p id="9f3c" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">什么是垃圾收集？</p></blockquote><p id="e9a1" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在回答这个问题之前，让我告诉你在跳到垃圾收集之前你首先需要了解的一些重要的事情。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="6b28" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">堆内存类型</h2><p id="d55e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们之前说过，堆内存分为两部分；<strong class="mc jd">小对象堆(SOH) </strong>和<strong class="mc jd">大对象堆(LOH) </strong>。</p><p id="0eb5" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated"><strong class="mc jd">小对象堆</strong> ( <strong class="mc jd"> SOH </strong>)保存大小小于<strong class="mc jd"> 85K </strong>的已分配对象。</p><p id="99db" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated"><strong class="mc jd">大对象堆</strong> ( <strong class="mc jd"> LOH </strong>)保存着大于<strong class="mc jd"> 85K </strong>大小的已分配对象。</p><p id="da0b" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated"><strong class="mc jd"> SOH </strong>和<strong class="mc jd"> LOH </strong>与<strong class="mc jd">不同。NET框架管理它们。请记住这一点，我们稍后将回到这一点。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="ae2c" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">什么是垃圾？</h2><p id="1956" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">单词<strong class="mc jd">垃圾</strong>指的是已经分配的不再使用的对象，这些对象可以被<strong class="mc jd">公共语言运行时(CLR) </strong>从内存中完全移除和释放。</p><p id="4a39" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，你可能会问:</p><blockquote class="pd pe pf"><p id="f75d" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">CLR如何知道一个对象是否是垃圾？</p></blockquote><p id="6c72" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">答案很简单，就是检查对象是否被一个<strong class="mc jd">根</strong>直接或间接引用。</p><p id="73eb" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">我知道你可能会问:</p><blockquote class="pd pe pf"><p id="ad6b" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">还有什么是<strong class="mc jd">根</strong>？</p></blockquote><p id="e70a" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">根可以是下列之一:</p><ul class=""><li id="58fe" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv ol om on oo bi translated">堆栈内存中的引用。</li><li id="f232" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">全局对象。</li><li id="91a9" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">静态对象。</li></ul><p id="66ef" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">当我们说一个对象被一个根直接<strong class="mc jd"/>引用时，这意味着这个对象被上面描述的一个根类型引用。</p><p id="ab04" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">另一方面，当我们说一个对象被根对象间接引用时，这意味着该对象被堆中已经被根对象直接或间接引用的另一个对象引用。</p><p id="f000" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这意味着对象之间可能有一系列引用，除非系列中的第一个对象被根直接引用，否则整个系列都被视为垃圾。</p><p id="d637" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">CLR所做的是维护一个更新的根对象图，以便在CLR需要检查某个对象是否是根对象时使用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qh"><img src="../Images/505e7a5935e03aff1bf6f84b617cad1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5Nn3t_h92ntyzIzDCl5qg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">扎根与垃圾。</strong>图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="5564" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">因此，现在CLR拥有了决定一个对象是否是垃圾所需的所有信息，对吗？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="8069" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">绩效指标</h2><p id="bf57" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在我们知道了CLR如何决定某个对象是否是垃圾。然而，我们需要记住分配到堆中的对象数量。</p><p id="f5d8" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在某个时刻，可能已经有大量的对象被分配到堆中。因此，如果每次需要为新对象分配一些内存时，CLR只检查所有这些对象，这会对整体性能产生不良影响。</p><p id="2192" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这就是为什么CLR在分析和处理内存分配时需要遵循另一种方法。</p><p id="a48f" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">微软的天才们想出了一个应对这一挑战的好主意。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="8d5a" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">小对象堆(SOH)内存代</h2><p id="a4ca" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">微软的天才们决定将SOH分成三部分，这样CLR一次只能分析和处理一部分。</p><p id="94ad" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这意味着CLR每次能够处理较少数量的对象，而不是处理大量的对象。</p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="fdec" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，你可能会问:</p><blockquote class="pd pe pf"><p id="d24c" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">这三部分是根据什么决定的？</p></blockquote><p id="2d83" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这是一个好问题。这三个部分背后的思想是基于被分配到SOH中的对象的性质。</p><p id="fbe1" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">简单地说，新对象释放的速度比旧对象快，旧对象可能被全局或静态根引用。</p><p id="41b3" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">基于这个概念，CLR将SOH分为三个部分，我们称之为<strong class="mc jd">代</strong>。</p><p id="f349" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这意味着SOH分为:</p><ul class=""><li id="e859" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv ol om on oo bi translated"><strong class="mc jd">第0代</strong>:在这里分配的对象比第1代和第2代中的对象更容易被释放。</li><li id="2d61" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated"><strong class="mc jd">第1代</strong>:这里分配的对象往往比第2代中的对象释放得更快。</li><li id="8907" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">第二代:这里分配的对象倾向于停留更长的时间。</li></ul></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="c709" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，你可能会问:</p><blockquote class="pd pe pf"><p id="ff22" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">三代都一样大吗？</p></blockquote><p id="1ce1" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">答案是否定的。</p><p id="e7eb" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这三代的大小由CLR在运行时根据分配给每代的对象数量决定。</p><p id="1921" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">换句话说，CLR在运行时调整这三代的大小，目的是基于对象分配的历史获得最佳性能。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="934c" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">大对象堆(LOH)怎么办？</h2><p id="35dd" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">CLR以不同的方式管理LOH中的对象分配。它不是分成几部分或几代。</p><p id="9792" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">实际上，人们称LOH为第3代<strong class="mc jd">只是为了遵循相同的命名惯例，但在现实世界中，它并不遵循与SOH相同的过程。</strong></p><p id="97a1" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">LOH没有被压缩，因为正如我们之前所说的，分配到LOH中的对象是大型对象，将这些大型对象复制到未使用的对象上需要很长时间。这会对整个演出产生不良影响。</p><p id="ec87" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这就是为什么LOH跟踪所有空闲和已用的内存位置和空间，并试图将新对象分配到由收集的对象留下的最合适大小的空闲槽中。</p><p id="0846" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在你可能会问:</p><blockquote class="pd pe pf"><p id="a83c" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">如果没有合适大小的空闲槽来分配新对象，该怎么办？</p></blockquote><p id="919b" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">简而言之就是<strong class="mc jd">碎片化</strong>。</p><p id="41fa" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">LOH需要不时地进行碎片化，以压缩已分配对象之间的空闲空间，以便有更多大小合适的可用槽来分配新对象。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="a737" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">垃圾收集触发器</h2><p id="bbc0" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在我们知道了什么是垃圾，以及CLR如何决定将哪些对象标记为垃圾。</p><p id="3833" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在你可能会问:</p><blockquote class="pd pe pf"><p id="ae40" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">CLR什么时候开始释放垃圾？</p></blockquote><p id="919e" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在SOH中，对于三代中的每一代，CLR设置一个阈值，以便当达到该阈值时，CLR触发这一代和所有更年轻一代的收集机制。</p><p id="32fb" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">换句话说:</p><ul class=""><li id="78dd" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv ol om on oo bi translated">当达到第0代的阈值时，将触发第0代的收集。</li><li id="22c4" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">当达到第1代的阈值时，将触发第1代和第0代的收集。</li><li id="8932" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">当达到第2代的阈值时，将触发第2代、第1代和第0代的收集。</li></ul></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="a827" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在你可能会问:</p><blockquote class="pd pe pf"><p id="aacb" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">LOH呢？</p></blockquote><p id="2182" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">实际上，我现在需要告诉你一些事情。LOH是第二代SOH的一部分。</p><p id="44f5" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">因此，每当触发第2代收集时，就会触发LOH收集。但是，您需要记住，收集过程并不那么简单，算法也很复杂，很难用几行代码来概括。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="770b" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">垃圾收集过程</h2><p id="bcc7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">简单回顾一下，到目前为止，您已经了解了以下内容:</p><ul class=""><li id="024e" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv ol om on oo bi translated">我们有四代人(第0代、第1代、第2代和第3代)</li><li id="c272" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">每一代都有一个由CLR设置和调整的阈值。</li><li id="00af" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">当达到层代阈值时，触发该层代的收集过程，然后触发更年轻层代的收集。</li></ul><p id="ff6d" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，让我们继续讨论收集过程的更多细节。</p><p id="dc61" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">当某个层代的收集进程被触发时，分配给该层代的对象被分析和处理如下:</p><ol class=""><li id="7157" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv qi om on oo bi translated">使用CLR已经建立的图来发现和标记根对象。我们把这些天体称为<strong class="mc jd"> <em class="pg">幸存下来的</em> </strong>天体。</li><li id="6048" class="og oh it mc b md op mg oq mj or mn os mr ot mv qi om on oo bi translated">其他对象现在被标记为无根并准备收集。</li><li id="2158" class="og oh it mc b md op mg oq mj or mn os mr ot mv qi om on oo bi translated">收集过程如前所述开始(对SOH进行复制和覆盖，对LOH进行适当大小的替换)。</li><li id="5227" class="og oh it mc b md op mg oq mj or mn os mr ot mv qi om on oo bi translated">幸存的对象被提升到更高的一级。</li></ol><p id="6fd7" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这里有一个循序渐进的gif来帮助你可视化垃圾收集过程。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qj"><img src="../Images/2c6e408cf3924bafbadc5223e5d871b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dwgGr4vLbA144KNuaygSzw.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">垃圾收集。</strong>图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="6b5f" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">希望这能让你更容易理解。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="45ca" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">关于<strong class="ak">垃圾收集</strong>的重要说明</h2><ol class=""><li id="c0c9" class="og oh it mc b md me mg mh mj qk mn ql mr qm mv qi om on oo bi translated">当<strong class="mc jd">垃圾收集</strong>进程开始时，它会暂停所有其他的事情。这就是为什么过度触发<strong class="mc jd">垃圾收集</strong>进程会对整个系统的性能产生不良影响。</li><li id="6b7f" class="og oh it mc b md op mg oq mj or mn os mr ot mv qi om on oo bi translated"><strong class="mc jd">垃圾收集</strong>过程可以通过调用<code class="fe ow ox oy oz b">System.GC.Collect()</code>方法手动触发。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qn"><img src="../Images/6876780f163d746f7e7eed9741be1fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zgh8nQFE-SfMewNIk1JWog.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">处置并最终确定。</strong>由<a class="ae li" href="https://unsplash.com/@roberto_sorin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Roberto Sorin </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="3609" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">处置并最终确定</h1><p id="0b2c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果你做过<strong class="mc jd">。NET </strong>开发者有一段时间，很可能你听说过<strong class="mc jd"> Dispose </strong>和<strong class="mc jd"> Finalize </strong>以及与实现它们相关的设计模式。</p><p id="caf7" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">然而，在进入细节之前，我更喜欢讨论一些与这个主题相关的重要基础知识。</p><p id="c6a0" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">所以，还是一步步来吧。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="7300" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">托管和非托管</h2><p id="a868" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在<strong class="mc jd">中。NET </strong> world我们有两种类型的资源和代码；<strong class="mc jd">托管</strong>和<strong class="mc jd">非托管</strong>。</p><p id="d883" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">简单来说，<strong class="mc jd">管理的</strong>代码就是由<strong class="mc jd">编译和维护的代码。NET </strong>框架。在这种情况下，代码被编译成通用语言<strong class="mc jd">微软中间语言(MSIL) </strong>，然后由<strong class="mc jd">运行。NET </strong>框架。这就给出了<strong class="mc jd">。NET框架完全控制代码、执行、内存分配、异常检查等等。</strong></p><p id="c1b8" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">另一方面，非托管代码是在<strong class="mc jd">边界之外编译和维护的代码。NET </strong>框架。在这种情况下，代码被写成另一种外语，编译成机器语言，由操作系统直接执行。这就是为什么会有<strong class="mc jd">。NET框架对代码、执行和内存分配都没有控制权。非托管代码的例子有文件流、数据连接等</strong></p><p id="7539" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">因此，如果你的<strong class="mc jd">。NET系统处理一些非托管代码。NET框架不能帮助你管理由非托管代码完成的内存分配。这个不如<strong class="mc jd">。NET框架需要知道如何在需要的时候释放这些资源。</strong></strong></p><p id="1ae6" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">因此，从<strong class="mc jd">开始。NET框架不知道如何在需要的时候释放这些资源。NET框架决定将这一责任委托给开发人员，因为他应该是意识到这一点的人。</strong></p><p id="1883" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，你可能会问:</p><blockquote class="pd pe pf"><p id="f9d1" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">开发人员如何干预管理这些非托管资源？</p></blockquote><p id="c4ff" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这个问题的简单答案是通过<strong class="mc jd"> <em class="pg">实现一个终结器</em> </strong>。</p><p id="5e65" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">但是，要理解这种说法的含义，请进入下一节。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="fa85" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">内存泄漏</h2><p id="ee8f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">你还记得我们讨论过的<strong class="mc jd">垃圾收集</strong>过程吗？实际上，为了关注GC过程本身，还有一些细节我没有提到。但是现在，这是正确的时间。</p><p id="a7e9" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">当CLR将一个对象标记为非根对象并准备好被收集时，此时CLR不知道该对象是否正在使用任何非托管资源。</p><p id="765b" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这是一个大问题，因为这意味着对象可能正在使用非托管资源，如果这些资源没有被正确地释放，就会出现内存泄漏。这里的内存泄漏是指，尽管实际上并不需要内存分配，但是这些内存分配将与整个系统的寿命一样长。</p><p id="80c9" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">此外，每当创建和收集相同类型的对象时，如果没有适当地释放所包含的非托管资源，这种内存泄漏可能会随着时间的推移变得越来越大。</p><p id="f335" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，你可能会问:</p><blockquote class="pd pe pf"><p id="3074" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">那么如何告诉CLR一个对象使用了一些非托管资源呢？</p></blockquote><p id="c096" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">开发商和<strong class="mc jd">之间有协议。双方都应该致力于的. NET </strong>框架。</p><p id="478e" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这个协议就是，每当开发人员实现一个对象的<strong class="mc jd">终结器</strong>时，CLR应该将这个对象标记为使用非托管资源。</p><p id="0845" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，下一个问题是:</p><blockquote class="pd pe pf"><p id="8731" class="ma mb pg mc b md nh kd mf mg ni kg mi ph nj ml mm pi nk mp mq pj nl mt mu mv im bi translated">然后呢？这个<strong class="mc jd">终结器</strong>会在什么时候以及如何被CLR使用？</p></blockquote><p id="7743" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">同样，为了回答这个问题，让我们继续下一节。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="86bd" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">定稿过程</h2><p id="96b2" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在你可能想知道如何实现一个<strong class="mc jd">终结器</strong>。我现在要问你的是等一会儿，我很快会给你看这个。</p><p id="66a7" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，让我们假设您知道如何实现一个<strong class="mc jd">终结器</strong>，并且您已经为您的一些系统对象实现了它。</p><p id="25db" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，回到<strong class="mc jd">垃圾收集</strong>过程。当一个对象被分配到堆中时，CLR检查这个对象是否实现了一个<strong class="mc jd">终结器</strong>。</p><p id="10e9" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">如果没有，就像我们在前面几节中解释的那样，没有什么特别的事情发生。</p><p id="d172" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">然而，如果对象实现了一个<strong class="mc jd">终结器</strong>，CLR会在一个由CLR维护的特殊数据结构中添加对这个对象的引用。这种数据结构被称为<strong class="mc jd">完成队列</strong>。</p><p id="c360" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">然后，当一个对象准备好被收集时，CLR检查这个对象是否被引用到<strong class="mc jd">完成队列</strong>中。</p><p id="9983" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">如果没有，就像我们在前面几节中解释的那样，没有什么特别的事情发生。</p><p id="b2e4" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">然而，如果对象被引用到<strong class="mc jd">完成队列</strong>中，CLR从<strong class="mc jd">完成队列</strong>中移除该引用，并在CLR维护的另一个特殊数据结构中创建对同一对象的新引用。这种数据结构被称为<strong class="mc jd">可访问队列</strong>。</p><p id="0671" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">到目前为止，该对象还没有被收集，因为CLR知道应该在收集该对象之前调用该对象上的一个<strong class="mc jd">终结器</strong>。</p><p id="7293" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated"><strong class="mc jd">可访问队列</strong>由一个单独的运行时线程维护。如果队列为空，线程会休眠，直到新的条目被添加到队列中，然后线程开始调用所有对象的<strong class="mc jd">终结器</strong>到<strong class="mc jd">可访问队列</strong>。</p><p id="0ff9" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这就是为什么总是建议不要试图依赖于调用<strong class="mc jd">终结器</strong>的时间，因为它是一个不确定的过程。</p><p id="7f58" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">一旦<strong class="mc jd">终结器</strong>被调用，对<strong class="mc jd">可访问队列</strong>中对象的引用被移除，但是对象仍然没有被收集。</p><p id="596a" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">然后，当再次触发<strong class="mc jd">垃圾收集</strong>进程时，CLR现在确定该对象已准备好进行收集，因为它既不是根对象，也没有被<strong class="mc jd">完成队列</strong>引用，也没有被<strong class="mc jd">可访问队列</strong>引用。</p><p id="6537" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这就是为什么我们知道，当一个对象实现了一个<strong class="mc jd">终结器</strong>时，它会在多一个<strong class="mc jd">垃圾收集</strong>周期中存活更长时间。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qo"><img src="../Images/e2c067ee1e96afb146cf8e020bf99876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QAKOtpvV4NCkxg6A_1X9Yw.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">最终确定和可访问队列。</strong>图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="f1ef" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">终结器实现</h2><p id="fc42" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在<strong class="mc jd">中。NET C# </strong>，我们可以通过定义一个<strong class="mc jd">析构函数</strong>来实现<strong class="mc jd">终结器</strong>，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="8ece" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">或者通过覆盖<code class="fe ow ox oy oz b">Finalize</code>方法，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="1f2f" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">但是，这是应该遵循的最佳实践吗？</p><p id="43bf" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">不，当实现一个<strong class="mc jd">终结器</strong>时，有一个设计模式可以遵循。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="b473" class="mw lk it bd lh mx my dn lo mz na dp ls mj nb nc lu mn nd ne lw mr nf ng ly iz bi translated">处理并最终确定设计模式</h2><p id="efef" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在深入设计模式的细节之前，让我告诉你更多关于<strong class="mc jd"> Dispose </strong>和<strong class="mc jd"> Finalize </strong>方法的信息。</p><p id="1c4f" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">主要是两者都负责清除非托管资源。主要区别在于<strong class="mc jd"> Dispose </strong>方法是由开发人员显式调用的，而<strong class="mc jd"> Finalize </strong>方法是由CLR以不确定的方式调用的，正如我们在前面的章节中所解释的。</p><p id="8784" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">他们之间还有其他的不同，但这些是目前最重要的。</p><p id="1849" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，让我们检查<strong class="mc jd">处置和定型模式</strong>的实现。</p><p id="22a0" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">假设我有下面的<code class="fe ow ox oy oz b">MyClass</code>类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="8007" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">如你所见，在我们的类中，我们正在创建一个已经实现了<code class="fe ow ox oy oz b">IDisposable</code>接口的<code class="fe ow ox oy oz b">System.Timers.Timer</code>类的实例。这是一个指示器，我们需要在释放我们的<code class="fe ow ox oy oz b">MyClass</code>对象之前调用这个计时器的<code class="fe ow ox oy oz b">Dispose</code>方法。</p><p id="23c7" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">因此，按照<a class="ae li" href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd">微软</strong> </a>推荐的<strong class="mc jd">处置定型模式</strong>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="c06d" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">我们在这里可以注意到:</p><ul class=""><li id="54a4" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv ol om on oo bi translated">我们定义了私有字段<code class="fe ow ox oy oz b">m_IsDisposed</code>,用于检查对象之前是否已经被释放。</li><li id="4f60" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">我们定义了<code class="fe ow ox oy oz b">protected virtual void Dispose(bool disposing)</code>来集中清理逻辑。</li><li id="3758" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">如果传入的参数是<code class="fe ow ox oy oz b">true</code>，这意味着它正在被<code class="fe ow ox oy oz b">Dispose</code>方法调用。在这种情况下，一切都被清理。</li><li id="d092" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">如果不是，这意味着它正在被<code class="fe ow ox oy oz b">Finalize</code>方法调用。在这种情况下，只清理非托管资源。</li><li id="ecde" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">请记住，在调用托管资源的<code class="fe ow ox oy oz b">Dispose</code>方法之前，检查托管资源是否还没有<code class="fe ow ox oy oz b">null</code>是一个最佳实践。</li><li id="13e8" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">在<code class="fe ow ox oy oz b">public void Dispose()</code>方法中，我们调用<code class="fe ow ox oy oz b">GC.SuppressFinalize(this);</code>来告诉CLR跳过调用这个对象的Finalize方法，因为我们已经在释放的时候处理了非托管资源。</li></ul><p id="51fa" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，假设我们有如下继承自<code class="fe ow ox oy oz b">MyClass</code>的<code class="fe ow ox oy oz b">MyChildClass</code>类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="38f9" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在，我们需要实现<strong class="mc jd">处置定型模式</strong>如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="349d" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这里我们应该注意的是:</p><ul class=""><li id="c1b2" class="og oh it mc b md nh mg ni mj oi mn oj mr ok mv ol om on oo bi translated">我们没有再次实现<code class="fe ow ox oy oz b">public void Dispose()</code>方法。</li><li id="80e9" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">我们否决了<code class="fe ow ox oy oz b">protected virtual void Dispose(bool disposing)</code>方法。</li><li id="a65a" class="og oh it mc b md op mg oq mj or mn os mr ot mv ol om on oo bi translated">我们在<code class="fe ow ox oy oz b">protected override void Dispose(bool disposing)</code>方法的末尾调用了<code class="fe ow ox oy oz b">base.Dispose(disposing);</code>。</li></ul></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="31df" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这里值得一提的是，实现<strong class="mc jd">终结器</strong>并不是你应该经常做的事情。正如我们之前所说的，当CLR识别出一个对象实现了一个<strong class="mc jd">终结器</strong>时，这将把该对象的生命周期延长到又一个<strong class="mc jd">垃圾收集</strong>周期。</p><p id="207f" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">因此，只有当对象使用非托管资源时，才实现一个<strong class="mc jd">终结器</strong>。</p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="cda1" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi qp translated"><span class="l qq qr qs bm qt qu qv qw qx di"> B </span> onus:阅读<code class="fe ow ox oy oz b">System.Runtime.InteropServices.SafeHandle</code>以及如何使用它来代替<strong class="mc jd">终结器</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qy"><img src="../Images/61a5192bbcc3771ab212b1782cb2a13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lfY7al_tPn5peif1.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">最后的想法。</strong>照片由<a class="ae li" href="https://unsplash.com/@peterampazzo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Pietro Rampazzo </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="cce5" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">最后的想法</h1><p id="0c79" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在本文中，我们已经在<strong class="mc jd">中介绍了内存分配。NET </strong>框架以及与之相关的一些重要话题。</p><p id="9686" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">我鼓励你做自己的研究，阅读更多关于这个话题的内容。正如你所看到的，有很多细节，这就是为什么在一篇文章中涵盖所有细节并不容易。</p><p id="d4e3" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">另外，我以前发表过一篇关于递归及其对记忆的影响的文章。也许你想检查一下。如果你有兴趣，你可以阅读文章<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/curse-of-recursion-in-net-c-b017271ddbe6?sk=e1a1f74d42d80a82d433d5be37bc15ac">中的<strong class="mc jd">递归的诅咒。NET C# </strong> </a>。</p><p id="1f72" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">最后，我希望你喜欢读这篇文章，就像我喜欢写它一样。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/78f04d6e1f16ed292040eb7288ddb8dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5YN8Pjm1B274JbRj.png"/></div></div></figure><h1 id="fbab" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="8a38" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果您还不是<strong class="mc jd">中介</strong>的会员，您可以使用<a class="ae li" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="mc jd">我的推荐链接</strong> </a>，这样我可以从<strong class="mc jd">中介</strong>那里获得您的一部分费用，您无需支付任何额外费用。订阅<a class="ae li" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"> <strong class="mc jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/702b299eb46884d1bfd6387fae565e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dDr8QabPdxWu45Ku.png"/></div></div></figure><h1 id="71d9" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">其他资源</h1><p id="cef1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这些是你可能会发现有用的其他资源。</p><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/datetime-best-practices-in-net-c-4c2679fcc9e0"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd jd gy z fp nv fr fs nw fu fw jc bi translated">中的日期时间最佳实践。NET C#</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">在中使用DateTime时要遵循的最佳实践。NET C#</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nz l"><div class="qz l ob oc od nz oe lb nq"/></div></div></a></div><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/prototype-design-pattern-in-net-c-67db46c3d28f"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd jd gy z fp nv fr fs nw fu fw jc bi translated">中的原型设计模式。NET C#</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">中了解原型设计模式。NET C#</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nz l"><div class="ra l ob oc od nz oe lb nq"/></div></div></a></div><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/protecting-public-methods-from-illogical-calls-in-net-c-91fcbb8bee33"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd jd gy z fp nv fr fs nw fu fw jc bi translated">保护公共方法免受不合逻辑的调用。NET C#</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">包含代码示例和解释的完整指南。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nz l"><div class="rb l ob oc od nz oe lb nq"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure></div></div>    
</body>
</html>