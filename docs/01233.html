<html>
<head>
<title>A Java Parallel Server Through the Ages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个千古流传的Java并行服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-java-parallel-server-through-the-ages-78432df3bdc4?source=collection_archive---------5-----------------------#2019-12-02">https://levelup.gitconnected.com/a-java-parallel-server-through-the-ages-78432df3bdc4?source=collection_archive---------5-----------------------#2019-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="538f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从线程到线程池再到未来再到CompletableFuture</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9a8edfacf27d1da7e1222c1ca070fc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UAgeREoY2erIQ-QtdIK6Bw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">ID 111231236 BawegPhotos | Dreamstime.com</figcaption></figure><p id="39b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注:</strong>本文改编自我的书<a class="ae lr" href="https://www.fcpbook.org" rel="noopener ugc nofollow" target="_blank"> <em class="ls">函数式与并发编程:核心概念与特性</em> </a>，由<a class="ae lr" href="https://www.informit.com/store/functional-and-concurrent-programming-core-concepts-9780137466573" rel="noopener ugc nofollow" target="_blank"> Addison-Wesley </a>出版。具体参见第26章<em class="ls">函数式并发编程</em>。</p><h1 id="0124" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">背景</h1><p id="9b2f" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">用Java编写了一个服务器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6dbd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">服务器接受一个传入的连接(第4行)，从一个套接字读取一个请求(第5行)，执行三个任务(第6–8行)，汇总这些任务的结果(第9行)并回复客户端(第10行)。</p><p id="d986" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个服务器完全是顺序的:一次处理一个请求，并且每个请求都是顺序处理的。本页的主题是此服务器的并行化，使用不同的编程风格。</p><h1 id="8a8d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">用传统的方法创建线程</h1><p id="c452" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">通过为每个请求创建和启动一个新线程，可以并行处理独立的请求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="9a26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请求处理代码被移到一个单独的方法中。对于每个传入的连接，都会创建一个线程并开始执行该方法。(注意，这个方法是由多个线程进入的，如果请求不是独立的，需要小心对共享数据的并发访问；这不是本帖的重点。)</p><p id="3f5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个请求的处理仍然是顺序的，但是可以并行处理多个请求。我们还改进了服务器的健壮性:如果在处理请求时出错，相应的线程会终止，但其他请求(当前的和未来的)仍然可以被处理。</p><h1 id="3f6b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用线程池</h1><p id="4ca2" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">先前方法的一个缺点是它可能会创建大量线程。这是不希望的，因为线程创建(和拆除)是有成本的，并且太多线程同时运行会影响服务器的性能。相反，<em class="ls">线程池</em>可用于限制线程数量<em class="ls">和</em>重用现有线程来处理请求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="630e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对代码所需的修改是最小的；特别是，方法<code class="fe ms mt mu mv b">handleRequest</code>根本没有改变。所有的改变就是用<code class="fe ms mt mu mv b">exec.execute(() -&gt; handleRequest(socket))</code>代替<code class="fe ms mt mu mv b">new Thread(() -&gt; handleRequest(socket)).start()</code>。这里，<code class="fe ms mt mu mv b">exec</code>被选作16个工作线程的池。然后，服务器可以并行处理多达16个请求。额外的请求将在<code class="fe ms mt mu mv b">ExecutorService</code>中排队，并在完成之前的任务后被工作线程获得。线程池可以根据使用的服务和硬件进行定制:最小和最大线程数、线程终止前的空闲时间、队列大小和类型(FIFO、优先级)等。考虑到使用线程池是多么容易，没有理由坚持按需创建线程的风格。本文剩余的所有代码都将使用线程池。</p><h1 id="dd59" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">在请求中添加并发性</h1><p id="3b6a" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在前面的实现中，请求是并行处理的，但是每个请求是在一个线程中顺序处理的。假设请求任务<code class="fe ms mt mu mv b">A</code>、<code class="fe ms mt mu mv b">B</code>和<code class="fe ms mt mu mv b">C</code>是独立且耗时的。为了提高性能，可以在每个请求中并行处理它们。这可以通过在请求处理线程中创建三个线程来完成，即<em class="ls"> fork </em>阶段，然后等待它们完成结果聚合，即<em class="ls"> join </em>阶段。这种<em class="ls"> fork/join </em>模式(有时也称为<em class="ls"> scatter/gather </em>)也可以使用线程池来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0aff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">方法<code class="fe ms mt mu mv b">serve</code>不变。在方法<code class="fe ms mt mu mv b">handleRequest</code>中，对<code class="fe ms mt mu mv b">taskA</code>、<code class="fe ms mt mu mv b">taskB</code>和<code class="fe ms mt mu mv b">taskC</code>的调用是由线程池中的工作线程并行执行的。方法<code class="fe ms mt mu mv b">submit</code>返回一个类型为<code class="fe ms mt mu mv b">Future</code>的对象，该对象可用于检索每个任务的输出。方法<code class="fe ms mt mu mv b">Future.get</code>阻塞调用线程，直到任务完成。然后，它返回任务产生的值，或者在任务失败时抛出异常。对<code class="fe ms mt mu mv b">get</code>的三次调用共同实现了<em class="ls"> fork-join </em>的<em class="ls"> join </em>部分(对<code class="fe ms mt mu mv b">submit</code>的调用实现了<em class="ls"> fork </em>部分)。我们现在有了一个服务器，可以并行处理请求<em class="ls">和请求的</em>部分，所有这些都在同一个线程池中。</p><h1 id="67be" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">最小化阻塞</h1><p id="b2e2" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">上面的代码使用池中的一个工作线程来等待其他工作线程的结果(通过调用<code class="fe ms mt mu mv b">get</code>)。这是不希望的，至少有两个原因:</p><ul class=""><li id="a5f7" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated"><em class="ls">工作线程利用不足</em>:假设一个线程池有6个工作线程，2个请求几乎同时到达。假设每个任务<code class="fe ms mt mu mv b">A</code>、<code class="fe ms mt mu mv b">B</code>和<code class="fe ms mt mu mv b">C</code>用1秒钟完成，其他计算时间可以忽略不计。我们希望这6个工作人员并行处理所有6个任务(一个请求中的<code class="fe ms mt mu mv b">A1</code>、<code class="fe ms mt mu mv b">B1</code>和<code class="fe ms mt mu mv b">C1</code>，另一个请求中的<code class="fe ms mt mu mv b">A2</code>、<code class="fe ms mt mu mv b">B2</code>和<code class="fe ms mt mu mv b">C2</code>，并在1秒钟后完成这两个请求。相反，每个请求可能需要2秒钟才能完成，因为2个工作线程被阻塞调用<code class="fe ms mt mu mv b">get</code>，而只有4个工作线程可用于运行6个<code class="fe ms mt mu mv b">A/B/C</code>任务。在更复杂的场景中，甚至可能会出现<em class="ls">死锁</em>的情况，所有工作线程都在相互等待。</li><li id="8c88" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated"><em class="ls">性能</em>:阻塞需要暂停和唤醒线程，这需要运行时开销。特别是，上下文切换往往会导致缓存未命中，可能会对性能产生严重影响。</li></ul><p id="67cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于这些原因，最新的趋势是尽量减少线程阻塞。其思想是，在所有三个任务完成之后，线程可以调度<code class="fe ms mt mu mv b">dataA</code>、<code class="fe ms mt mu mv b">dataB</code>和<code class="fe ms mt mu mv b">dataC</code>的聚合，而不是等待数据。</p><p id="400f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">服务器的非阻塞版本可以编写如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8661" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个实现中，任务通过稍微不同的机制提交到线程池，以便获得类型为<code class="fe ms mt mu mv b">CompletableFuture</code>而不是<code class="fe ms mt mu mv b">Future</code>的值。Java 8中引入了这种更丰富的未来形式。</p><p id="d593" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">方法<code class="fe ms mt mu mv b">thenApply/thenApplyAsync</code>实现了一种形式的<em class="ls">映射</em>:给定一个<code class="fe ms mt mu mv b">T</code>类型的未来和一个从<code class="fe ms mt mu mv b">T</code>到<code class="fe ms mt mu mv b">U</code>的函数，它们产生一个<code class="fe ms mt mu mv b">U</code>类型的未来(有时称为原始未来的<em class="ls">延续</em>)。当类型<code class="fe ms mt mu mv b">T</code>的值变得可用时(即，当原始future完成时)，函数的计算可以开始。当该函数终止时，产生一个类型为<code class="fe ms mt mu mv b">U</code>的值，并完成第二个未来。函数是运行在与原来的线程相同的线程中，还是运行在池中的新线程中，由后缀<code class="fe ms mt mu mv b">Async</code>控制。在服务器的情况下:</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="caeb" class="no lu iq mv b gy np nq l nr ns">var dataA = request.thenApplyAsync(Process::taskA);</span></pre><p id="43fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">获取一个<code class="fe ms mt mu mv b">CompletableFuture&lt;Request&gt;</code>(将在从套接字读取请求时完成)并调度对<code class="fe ms mt mu mv b">taskA</code>的调用以产生一个<code class="fe ms mt mu mv b">CompletableFuture&lt;Adata&gt;</code>(将在构建请求<em class="ls">并对其应用</em>函数<code class="fe ms mt mu mv b">taskA</code>后完成)。该调用是非阻塞的，此时不会调用<code class="fe ms mt mu mv b">taskA</code>。通过使用<code class="fe ms mt mu mv b">thenApplyAsync</code>，我们确保三个线程将并行运行<code class="fe ms mt mu mv b">taskA</code>、<code class="fe ms mt mu mv b">taskB</code>和<code class="fe ms mt mu mv b">taskC</code>。(更准确地说，所有三个任务将被并发提交给线程池。只有当池中有足够的线程运行它们时，它们才会并行运行。)</p><p id="149b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">聚合多个期货稍微复杂一点。给定一个<code class="fe ms mt mu mv b">T</code>类型的未来和一个从<code class="fe ms mt mu mv b">T</code>到 <code class="fe ms mt mu mv b"><em class="ls">U</em></code>类型的<em class="ls">未来的函数，方法<code class="fe ms mt mu mv b">thenCompose</code>通过将该函数应用于第一个未来产生的值来产生一个<code class="fe ms mt mu mv b">U</code>类型的未来。注意，使用<code class="fe ms mt mu mv b">thenApply</code>将会产生一个</em> <code class="fe ms mt mu mv b"><em class="ls">U</em></code>类型的<em class="ls">未来。方法<code class="fe ms mt mu mv b">thenCompose</code>在函数式语言中通常被称为<code class="fe ms mt mu mv b">flatMap</code>(它将未来的未来简化为简单的未来)。</em></p><p id="a991" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">变量<code class="fe ms mt mu mv b">response</code>的类型为<code class="fe ms mt mu mv b">CompletableFuture&lt;Response&gt;</code>，方法<code class="fe ms mt mu mv b">thenAccept</code>用于调度回调以将响应写入套接字。(<code class="fe ms mt mu mv b">thenApply</code>和<code class="fe ms mt mu mv b">thenAccept</code>的区别在于<code class="fe ms mt mu mv b">thenAccept</code>接受<code class="fe ms mt mu mv b">void</code>类型的函数，产生一个没有有用值的未来。)</p><p id="33f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">方法<code class="fe ms mt mu mv b">thenApply</code>、<code class="fe ms mt mu mv b">thenCompose</code>、<code class="fe ms mt mu mv b">thenAccept</code>、...仅在潜在未来成功时执行任务。方法<code class="fe ms mt mu mv b">onComplete</code>更通用，可用于调度无论未来正常终止还是异常终止都将运行的代码。在通话中:</p><pre class="kg kh ki kj gt nk mv nl nm aw nn bi"><span id="44c1" class="no lu iq mv b gy np nq l nr ns">reply.whenComplete((v, e) -&gt; ...);</span></pre><p id="562d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果成功，变量<code class="fe ms mt mu mv b">v</code>将包含未来产生的值，如果失败，变量<code class="fe ms mt mu mv b">e</code>将包含异常(其中一个<code class="fe ms mt mu mv b">v</code>或<code class="fe ms mt mu mv b">e</code>将为空)。这里使用方法<code class="fe ms mt mu mv b">onComplete</code>来关闭套接字(无论请求是否被成功处理)并记录异常(如果有的话)。</p><p id="c983" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，方法<code class="fe ms mt mu mv b">handleRequest</code>只调度回调和延续。它本身不执行任何请求处理，也不进行任何阻塞调用。因此，它可以由接受线程(快速)运行，而不需要创建异步任务。方法<code class="fe ms mt mu mv b">serve</code>因此被简化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="4d15" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">Scala中的同一个服务器</h1><p id="f3e6" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">这种非阻塞编程风格在Scala中比在Java中看起来更好:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="90df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Scala代码看起来更好的主要原因是由于<code class="fe ms mt mu mv b">for/yield</code>循环结构，这里使用它将三个未来聚合成一个。(Scala代码的其他优势包括:模式匹配、η转换和<code class="fe ms mt mu mv b">Future.failed</code>方法。)循环<code class="fe ms mt mu mv b">for/yield</code>实际上被编译成对<code class="fe ms mt mu mv b">map</code>和<code class="fe ms mt mu mv b">flatMap</code>的调用，与Java版本非常相似。代码可以写成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="8ad1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">三个任务以上？</h1><p id="9269" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在服务器示例中，需要将三个期货的结果聚合成一个期货。这一步的Scala代码看起来比Java代码好，但是两者都不能很好地推广到更多的任务(在for循环中嵌套调用50个<code class="fe ms mt mu mv b">thenCompose</code>或50个<code class="fe ms mt mu mv b">-&gt;</code>是不切实际的)。一个更通用的方法是将一个未来列表组合成一个列表的未来，然后使用<code class="fe ms mt mu mv b">thenApply/map</code>将任何需要的聚合应用到这个列表。</p><p id="d58b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">具体来说，问题是将类型为<code class="fe ms mt mu mv b">List&lt;CompletableFuture&lt;T&gt;&gt;</code>的值转换为类型为<code class="fe ms mt mu mv b">CompletableFuture&lt;List&lt;T&gt;&gt;</code>的值。在Scala中，方法<code class="fe ms mt mu mv b">Future.sequence</code>就是这样做的。然而，在Java中，没有实现这种转换的标准库方法。使用方法<code class="fe ms mt mu mv b">thenCombine</code>可以很容易地实现它，该方法从类型<code class="fe ms mt mu mv b">T</code>的未来、类型<code class="fe ms mt mu mv b">U</code>的未来和从<code class="fe ms mt mu mv b">(T,U)</code>到<code class="fe ms mt mu mv b">V</code>的函数产生类型<code class="fe ms mt mu mv b">V</code>的未来:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3057" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种实现是非阻塞的，不涉及任何额外的线程。</p><h1 id="d257" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">用承诺自己去做</h1><p id="8967" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在某些情况下，<code class="fe ms mt mu mv b">thenApply</code>、<code class="fe ms mt mu mv b">thenCompose</code>、<code class="fe ms mt mu mv b">thenAccept</code>、<code class="fe ms mt mu mv b">thenCombine</code>的组合...是不够的，需要从零开始创造新的未来。未来可以在没有值的情况下被创建，并在稍后被赋予一个值，通常来自不同的线程。这种期货通常被称为承诺。例如，<code class="fe ms mt mu mv b">thenApply</code>方法可以实现为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="6796" class="lt lu iq bd lv lw oa ly lz ma ob mc md jw oc jx mf jz od ka mh kc oe kd mj mk bi translated">结束语</h1><p id="a3f7" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">这篇文章中的代码使用(并滥用)了Java 10的<code class="fe ms mt mu mv b">var</code>构造，试图不被各种未来类型的Java ( <code class="fe ms mt mu mv b">Future</code>、<code class="fe ms mt mu mv b">FutureTask</code>、<code class="fe ms mt mu mv b">CompletableFuture</code>和<code class="fe ms mt mu mv b">CompletionStage</code>)分散注意力。这也使得Java代码更接近Scala实现。此外，大多数方法都假定抛出<code class="fe ms mt mu mv b">UncheckedIOException</code>而不是<code class="fe ms mt mu mv b">IOException</code>，因为<code class="fe ms mt mu mv b">supplyAsync</code>、<code class="fe ms mt mu mv b">thenApply</code>、<code class="fe ms mt mu mv b">thenAccept</code>、...无法抛出检查过的异常，并且在lambdas中使用<code class="fe ms mt mu mv b">try/catch</code>块会使代码更难执行。</p><p id="8c50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种编程风格依赖于对高阶方法的非阻塞调用，如期货上的<em class="ls"> map </em>和<em class="ls"> flatMap </em>，有时被称为<em class="ls">函数式并发编程</em>。与其他“功能”方面一样，这种编程风格在Scala中比在Java中更好。Java函数接口臃肿(<code class="fe ms mt mu mv b">CompletableFuture</code>有60个公共方法，相比之下Scala的<code class="fe ms mt mu mv b">Future</code>有23个方法)，部分原因是Java仍然需要处理原语类型和<code class="fe ms mt mu mv b">void</code>方法(Java的类型<code class="fe ms mt mu mv b">Function</code>、<code class="fe ms mt mu mv b">Consumer</code>、<code class="fe ms mt mu mv b">UnaryOperator</code>、<code class="fe ms mt mu mv b">IntFunction</code>、<code class="fe ms mt mu mv b">ToIntFunction</code>、<code class="fe ms mt mu mv b">DoubleFunction</code>、<code class="fe ms mt mu mv b">IntToDoubleFunction</code>、<code class="fe ms mt mu mv b">DoubleToIntFunction</code>、<code class="fe ms mt mu mv b">Predicate</code>、<code class="fe ms mt mu mv b">IntPredicate</code>、<code class="fe ms mt mu mv b">DoublePredicate</code>、<code class="fe ms mt mu mv b">IntBinaryOperator</code>、<code class="fe ms mt mu mv b">IntConsumer</code>等)。都对应Scala中的<code class="fe ms mt mu mv b">Function1</code>)。</p><p id="a01d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们还应该提到，通过使用Java的<code class="fe ms mt mu mv b">ForkJoinPool</code>，也可以在不阻塞线程的情况下实现<code class="fe ms mt mu mv b">fork/join</code>模式，这是在Java 7中添加的。在实践中，<code class="fe ms mt mu mv b">ForkJoinPool</code>往往不实用，而<code class="fe ms mt mu mv b">CompletableFuture</code>风格更受欢迎，即使它需要一些时间来适应。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="5b78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">关键词:</strong> Java，线程，线程池，未来，函数式并发编程。</p></div></div>    
</body>
</html>