<html>
<head>
<title>Flexibility is an overlooked benefit of object-oriented programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">灵活性是面向对象编程的一个被忽视的优点</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flexibility-is-an-overlooked-benefit-of-object-oriented-programming-d25a48bc3b03?source=collection_archive---------14-----------------------#2020-08-05">https://levelup.gitconnected.com/flexibility-is-an-overlooked-benefit-of-object-oriented-programming-d25a48bc3b03?source=collection_archive---------14-----------------------#2020-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e9b498f96632618c2e271762e6c706ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wgnJ9A61f_Ru2ibR"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@hngstrm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨利&amp;公司</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b693" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使许多杰出的程序员表达了他们对面向对象编程(OOP)的幻灭，它仍然是占主导地位的编程范例。</p><p id="b4f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为，尽管有缺陷和误用，OOP提供了强大的功能和灵活性。明智地使用对象而不是原始数据类型可以极大地简化编程任务，并提高最终程序的可重用性。</p><p id="bf97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然在当今使用最多的OOP语言之一Java中，<code class="fe le lf lg lh b">String</code>绝对不是一个原语数据类型，而是一个引用类型，但它在几乎每个Java程序中的广泛使用和Java编译器的特殊处理使它感觉像一个原语。</p><p id="be89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于我们在这里讨论的目的，我们不妨将<code class="fe le lf lg lh b">String</code>视为一个原语，与<code class="fe le lf lg lh b">int</code>、<code class="fe le lf lg lh b">boolean</code>或<code class="fe le lf lg lh b">char</code>几乎没有什么不同(私有数组<code class="fe le lf lg lh b">char</code>保存了组成<code class="fe le lf lg lh b">String</code>文本的字符和/或代理)。</p><p id="3a45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OOP最现实的例子之一是工资程序，其中有<code class="fe le lf lg lh b">Person</code>、<code class="fe le lf lg lh b">Employee</code>和<code class="fe le lf lg lh b">Manager</code>类。然后<code class="fe le lf lg lh b">Employee</code>伸出<code class="fe le lf lg lh b">Person</code>，并且<code class="fe le lf lg lh b">Manager</code>伸出<code class="fe le lf lg lh b">Employee</code>。这确实感觉像一个玩具例子，不是吗？请和我在一起。</p><p id="c9a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个活着的人有家庭住址。至少在一个更好的世界里，每个想要房子的人都是如此，不管他们有没有工作。</p><p id="6884" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">雇员有家庭住址和工作地址。也许应该在<code class="fe le lf lg lh b">Person</code>中定义家庭地址，在<code class="fe le lf lg lh b">Employee</code>中定义工作地址。</p><p id="90d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如何表示这些地址呢？最明显的方法似乎是定义一系列私有的<code class="fe le lf lg lh b">int</code>和<code class="fe le lf lg lh b">String</code>字段。</p><p id="6a13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">长话短说，让我们假设您有一些东西(比如Lombok)可以接受<code class="fe le lf lg lh b">@Getter</code>和<code class="fe le lf lg lh b">@Setter</code>注释，并为您编写合适的getters和setters。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="a388" class="lq lr it lh b gy ls lt l lu lv">public class Person {</span><span id="abdd" class="lq lr it lh b gy lw lt l lu lv">    // TODO: Name fields with getters and setters</span><span id="ba18" class="lq lr it lh b gy lw lt l lu lv">    // TODO: SSN field with getter and setter</span><span id="e7c8" class="lq lr it lh b gy lw lt l lu lv">    @Getter @Setter private int homeHouseNumber;</span><span id="7f4a" class="lq lr it lh b gy lw lt l lu lv">    @Getter @Setter private String homeStreetName;</span><span id="0634" class="lq lr it lh b gy lw lt l lu lv">    @Getter @Setter private int homeApartmentNumber;<br/>                    // May be -1 if not applicable</span><span id="b81a" class="lq lr it lh b gy lw lt l lu lv">    @Getter @Setter private String homeCity;</span><span id="63c8" class="lq lr it lh b gy lw lt l lu lv">    @Getter @Setter private char homeStateAbbrev = new char[2];</span><span id="877b" class="lq lr it lh b gy lw lt l lu lv">    @Getter @Setter private int homeZIPCode;</span><span id="95b0" class="lq lr it lh b gy lw lt l lu lv">    // TODO: Other necessary fields with getters and setters</span><span id="f1be" class="lq lr it lh b gy lw lt l lu lv">    // TODO: Constructor</span><span id="5f98" class="lq lr it lh b gy lw lt l lu lv">}</span></pre><p id="253b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，在<code class="fe le lf lg lh b">Employee</code>中，我们将雇员的工作地址字段，以及相关的getter和setter，或者getter和setter注释。</p><p id="402e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于1的注释意味着公寓号不适用于该地址，这似乎是一个有用的注释，但它太容易被忽略了。你团队中的其他人可能会认为0表示公寓号不适用，甚至你可能会搞混或完全忘记。</p><p id="0f6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这整个东西非常脆弱。假设我们正在为密歇根州的一家公司做这件事，这家公司有一些住在加拿大的加拿大雇员。至少有一个字段具有不同的验证要求。</p><p id="3be1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，一个在底特律工作但住在温莎的雇员可能有一个邮政编码为N8N 0A3的家庭地址。我不知道那实际上是否对应于一个住宅区，但它不符合<code class="fe le lf lg lh b">homeZIPCode</code>字段，反正它是名不副实的。</p><p id="3803" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许我们应该把<code class="fe le lf lg lh b">homeZIPCode</code>改成<code class="fe le lf lg lh b">String</code>类型，并重新命名为<code class="fe le lf lg lh b">homePostalCode</code>。但是如果我们为邮政编码编写任何验证，对<code class="fe le lf lg lh b">String</code>的更改将会破坏这种验证。</p><p id="11ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须重写邮政编码验证，并添加加拿大邮政编码验证。但是……这听起来是不是开始违反单一责任原则了?“S”来自某个著名的首字母缩写词？</p><p id="d117" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在任何情况下，<code class="fe le lf lg lh b">Employee</code>类从一开始就应该只有一个职责:收集雇员的信息。邮政编码验证属于邮寄地址类，或者邮政编码类。</p><p id="b738" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果我们同时在<code class="fe le lf lg lh b">Person</code>和<code class="fe le lf lg lh b">Employee</code>中编写邮政编码和加拿大邮政编码验证，我们就复制了应该只存在于一个地方的行。那是“代码复制”，不是什么好事。</p><p id="31e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最明显的答案应该是，如果我们在Java开发工具包(JDK)或可信的第三方库中找不到什么，我们需要编写一个单独的类来保存邮件地址。</p><p id="d7d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在<code class="fe le lf lg lh b">Person</code>中这样做:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="8240" class="lq lr it lh b gy ls lt l lu lv">    private MailingAddress addressHome = null;</span><span id="dfb8" class="lq lr it lh b gy lw lt l lu lv">    public MailingAddress getHomeAddress() {<br/>        return this.addressHome;<br/>    }</span><span id="a56a" class="lq lr it lh b gy lw lt l lu lv">    public void setHomeAddress(MailingAddress address) {<br/>        this.addressHome = address;<br/>    }</span></pre><p id="b842" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和<code class="fe le lf lg lh b">Employee</code>中工作地址类似的东西。对我来说，为单个字段编写getters和setters并不像是一项艰巨的任务。并且您的集成开发环境，即使没有Lombok，也可能为您处理getters和setters。</p><p id="f755" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许应该对<code class="fe le lf lg lh b">Person</code>和<code class="fe le lf lg lh b">Employee</code>中的地址进行一些验证，这是特定于那些类的，比如家庭地址与工作地址不同。</p><p id="c860" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是更一般的验证，比如确保门牌号不是负数，这类事情属于<code class="fe le lf lg lh b">MailingAddress</code>。</p><p id="2982" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们关于<code class="fe le lf lg lh b">Person</code>和<code class="fe le lf lg lh b">Employee</code>的工作中，我们可能不需要知道<code class="fe le lf lg lh b">MailingAddress</code>的细节。</p><p id="acef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许在测试类中，我们可能需要构造一个适当的<code class="fe le lf lg lh b">MailingAddress</code>实例，但是就编写setter而言，我们也许可以依靠调用者来提供一个适当构造的<code class="fe le lf lg lh b">MailingAddress</code>实例。</p><p id="4800" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将<code class="fe le lf lg lh b">MailingAddress</code>分离到一个单独的类中，我们不仅在这个项目中，而且在我们可能需要处理邮件地址的任何其他项目中都可以重用它。</p><p id="8ac7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">面向对象设计当然有可能被冲昏头脑，为了对象本身而创建对象。一个明显的迹象是，当一个项目有接口或抽象类，每个只有一个实现类，没有人能给出一个好的理由。</p><p id="dd02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在邮寄地址的例子中，创建一个抽象类来表示邮政编码可能是有意义的。为公寓号码创建一个抽象类几乎肯定是多余的。</p><p id="cb28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对相反问题的主要诊断，一个接口和抽象类太少的项目，我认为，是对原语和<code class="fe le lf lg lh b">String</code>值的过度依赖。</p><p id="a434" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你的项目不是这样，我不会担心接口和抽象类太少。如果需要，一个设计良好的类可以很容易地被重构来实现一个接口或扩展一个抽象类。</p><p id="5196" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JDK，一个很好的例子就是<code class="fe le lf lg lh b">String</code>级。据我所知，<code class="fe le lf lg lh b">String</code>的最初版本没有实现任何接口，是<code class="fe le lf lg lh b">Object</code>的直接子类。</p><p id="696f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但由于Java 1.4至少到Java 8，<code class="fe le lf lg lh b">String</code>实现了三种不同的接口:<code class="fe le lf lg lh b">CharSequence</code>、<code class="fe le lf lg lh b">Comparable&lt;String&gt;</code>和<code class="fe le lf lg lh b">Serializable</code>。其中的第一个，<code class="fe le lf lg lh b">CharSequence</code>，是最近的，也是一个最好的例子，说明了一个设计良好的类是如何足够灵活地将它的一些单元推广到一个接口或抽象类。</p><p id="b98a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上<code class="fe le lf lg lh b">String</code>设计得非常好，以至于许多程序员甚至在手头有更具体的类可用的情况下也使用它。</p><p id="4ca5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许OOP的问题不在于它是一个有缺陷的想法，而在于它经常被误用。如果应用得好，OOP是非常灵活的。</p></div></div>    
</body>
</html>