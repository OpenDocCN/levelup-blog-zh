<html>
<head>
<title>How to Create a Logging Operation in a Multi-Threaded Environment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在多线程环境中创建日志记录操作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-logging-operation-in-a-multi-threaded-environment-7d1de9788433?source=collection_archive---------16-----------------------#2020-01-28">https://levelup.gitconnected.com/how-to-create-a-logging-operation-in-a-multi-threaded-environment-7d1de9788433?source=collection_archive---------16-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2d5663bbc6d3a01dc259c86f5e072c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MZGtCld4kocec6To"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">原载于</em><a class="ae kg" href="https://edward-huang.com/scala/cats/programming/functional-programming/2020/01/27/how-to-create-a-logging-operation-in-a-multi-threaded-environment/" rel="noopener ugc nofollow" target="_blank"><em class="kf">https://edward-huang.com</em></a><em class="kf">。</em></figcaption></figure><p id="137c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">假设您正在编写如下计算斐波纳契数列的函数，并添加一个打印语句用于调试:</p><p id="8cb2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，运行以下函数:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="32e7" class="lo lp it lk b gy lq lr l ls lt">def fib(n:Int) : Int = {<br/>  if(n == 0 || n ==1) {<br/>    println(s"base case : $n")<br/>    n<br/>  }<br/>  else {<br/>    println(s"add fib(n-1) + fib(n-2) $n")<br/>    fib(n-1) + fib(n-2)<br/>  }<br/>}</span></pre><p id="1065" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在同步执行多个功能的情况下，它工作得很好:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="254a" class="lo lp it lk b gy lq lr l ls lt">fib(5)<br/><br/><em class="lu">// interpreter<br/></em>add fib(n-1) + fib(n-2) 5<br/>add fib(n-1) + fib(n-2) 4<br/>add fib(n-1) + fib(n-2) 3<br/>add fib(n-1) + fib(n-2) 2<br/>base case : 1<br/>base case : 0<br/>base case : 1<br/>add fib(n-1) + fib(n-2) 2<br/>base case : 1<br/>base case : 0<br/>add fib(n-1) + fib(n-2) 3<br/>add fib(n-1) + fib(n-2) 2<br/>base case : 1<br/>base case : 0<br/>base case : 1<br/>fib: (n: Int)Int<br/>res0: Int = 5</span></pre><p id="391c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然而，如果函数是以异步方式包装的，就很难区分哪个日志与哪个步骤相关联。在这种情况下，我们如何以异步方式调试操作呢？</p><h1 id="807a" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">编写数据类型来拯救</h1><p id="8b57" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">Cats有一个writer数据类型类，它可以通过将底层结果值附加到日志语句来帮助您，以便您可以异步理解日志语句。</p><p id="2f49" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在Cats中，Writer数据类型定义为:<code class="fe mx my mz lk b">Writer[L, V]</code>。</p><p id="658c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">l是你想要的测井类型集合<a class="ae kg" href="https://typelevel.org/cats/typeclasses/monoid.html" rel="noopener ugc nofollow" target="_blank">幺半群</a>；在这种情况下，我们可以将L设为一个<code class="fe mx my mz lk b">Vector[String]</code>。</p><p id="0fb6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">V是函数运算的结果类型——在这种情况下，我们可以将V设置为<code class="fe mx my mz lk b">Int</code>,因为我们从斐波那契数列中返回一个整数类型。</p><h1 id="c548" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">初始化</h1><p id="4370" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">一旦您创建了定义中的<code class="fe mx my mz lk b">L</code>和<code class="fe mx my mz lk b">V</code>，您就可以创建您的Writer数据类型，如下所示:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e260" class="lo lp it lk b gy lq lr l ls lt">import cats.data.Writer<br/>import cats.implicits._<br/><br/>Writer(Vector("log1", "log2"), 0)</span></pre><p id="a4b4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">或者</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6100" class="lo lp it lk b gy lq lr l ls lt">import cats.data.Writer<br/>import cats.implicits._<br/><br/>0.writer(Vector("log1", "log2"))</span></pre><p id="def3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果你看到了repl，或者结果，你会意识到它不是<code class="fe mx my mz lk b">Writer[L, V]</code>，而是返回一个<code class="fe mx my mz lk b">WrtierT[Id, L, V]</code>。是因为猫用类型别名从<code class="fe mx my mz lk b">WriterT</code>派生出<code class="fe mx my mz lk b">Writer</code>的值。在这篇文章中，我们将讨论如何使用Writer。所以可以忽略细节，把类型<code class="fe mx my mz lk b">WriterT[Id, L, V]</code>当成<code class="fe mx my mz lk b">Writer[L, V]</code>。</p><h1 id="b9f8" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">有记录值但没有结果</h1><p id="e0e3" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">如果有日志但没有结果，我们可以使用<code class="fe mx my mz lk b">tell</code>:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="c5b4" class="lo lp it lk b gy lq lr l ls lt">Vector("msg1", "msg2").tell()</span></pre><p id="4b24" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们还可以使用<code class="fe mx my mz lk b">run</code>同时提取输出和日志:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8905" class="lo lp it lk b gy lq lr l ls lt">val writer = Writer(Vector("something"), 0)<br/>val (log, result) = writer.run</span></pre><h1 id="ef56" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">提取结果值和日志类型</h1><p id="37e1" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">提取结果并用<code class="fe mx my mz lk b">value</code>和<code class="fe mx my mz lk b">written</code>分别记录:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="b7b9" class="lo lp it lk b gy lq lr l ls lt">val a = Writer(Vector("msg1"),0)<br/>val log = a.written<br/>val result = a.value<br/><br/>println(s"log: $log result: $result")<br/><em class="lu">// log: Vector(msg1) result: 0</em></span></pre><h1 id="a0e9" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">创作和改造作家</h1><p id="e2a0" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">由于Writer是一个<a class="ae kg" href="https://typelevel.org/cats/typeclasses/monad.html" rel="noopener ugc nofollow" target="_blank">单子</a>，你可以用<code class="fe mx my mz lk b">map</code>和<code class="fe mx my mz lk b">flatmap</code>对Writer做一个操作。</p><p id="1036" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe mx my mz lk b">flatMap</code>将日志类型和来自源编写器的结果类型以及排序函数的结果结合在一起。</p><p id="3fc7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">因此，一个好的做法是放置一个具有高效的附加和连接方法的日志类型，例如Vector:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e8ca" class="lo lp it lk b gy lq lr l ls lt">val res = for {<br/>    a &lt;- Writer(Vector("a"), 1)<br/>    _ &lt;- Vector("c").tell<br/>    b &lt;- 3.writer(Vector("3", "b"))<br/>  } yield {<br/>    println(s"a $a") <em class="lu">// 1<br/></em>    println(s"b $b") <em class="lu">// 3<br/></em>    a + b <em class="lu">// 4<br/></em>  }<br/><br/>println(res) <em class="lu">//WriterT((Vector(a, c, 3, b),4))</em></span></pre><p id="309b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">请注意，<code class="fe mx my mz lk b">tell</code>方法将保留原编写器，并将“c”附加到源编写器，即“a”。</p><p id="1bbd" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">Writer的结果是基于<code class="fe mx my mz lk b">yield</code>函数之后的计算结果。例如，如果在<code class="fe mx my mz lk b">yield</code>之后没有加法，只有<code class="fe mx my mz lk b">a</code>，则最终结果将是<code class="fe mx my mz lk b">WriterT((Vector(a,c,3,b),1))</code>。</p><h1 id="6c22" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">转型作家</h1><p id="7b78" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">我们可以使用<code class="fe mx my mz lk b">mapWritten</code>将日志类型改为全大写:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2bc0" class="lo lp it lk b gy lq lr l ls lt"><em class="lu">// .. take example from previous res example<br/></em>val upperCaseLog = res.mapWritten(previousLog =&gt; previousLog.map(_.toUpperCase))<br/>  println(upperCaseLog) <br/>  <em class="lu">// WriterT((Vector(A, C, 3, B),4))</em></span></pre><p id="fc91" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您也可以通过使用<code class="fe mx my mz lk b">mapBoth</code>来转换这两种类型:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6ec1" class="lo lp it lk b gy lq lr l ls lt">val newWriterValueAndLog = res.mapBoth{ (log,res) =&gt;<br/>    (log :+ "appending z", res+12)<br/>  }<br/>println(newWriterValueAndLog)<br/><br/>WriterT((Vector(a, c, 3, b, appending z),16))</span></pre><p id="5c21" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">使用<code class="fe mx my mz lk b">swap</code>交换日志类型和结果:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="f257" class="lo lp it lk b gy lq lr l ls lt">val swappedWriter = res.swap<br/>println(swappedWriter)<br/><em class="lu">// WriterT((4,Vector(a, c, 3, b)))</em></span></pre><p id="c510" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">最后但同样重要的是，使用<code class="fe mx my mz lk b">reset</code>重置Writer中的日志值:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="afed" class="lo lp it lk b gy lq lr l ls lt">val resetWriter = res.reset<br/>println(resetWriter)<br/><br/><em class="lu">// WriterT((Vector(),4))</em></span></pre><h1 id="ea07" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">作家在行动</h1><p id="3a66" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">至此，您已经了解了什么是Writer，现在让我们重构代码，将Writer融入其中:</p><p id="cb19" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">首先，让我们添加一个超时函数来设置异步环境。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="1fe0" class="lo lp it lk b gy lq lr l ls lt">def timeout[A](body: =&gt; A):A = try {<br/>    body<br/>  } finally Thread.sleep(100)</span></pre><p id="640a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，我们从Writer中设置LogFib的类型别名:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="b4fe" class="lo lp it lk b gy lq lr l ls lt">type LogFib[A] = Writer[Vector[String], A]</span></pre><p id="b11e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们改变Fib函数来返回一个<code class="fe mx my mz lk b">LogFib[Int]</code>:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="628d" class="lo lp it lk b gy lq lr l ls lt">def fib(n:Int): LogFib[Int] = {<br/>    timeout(<br/>      if(n == 0 || n ==1) {<br/>        n.writer(Vector(s"base case : $n"))<br/>      }<br/>      else {<br/>        for {<br/>          _ &lt;- Vector(s"add fib(n-1) + fib(n-2) $n").tell<br/>          fib1 &lt;- fib(n-1)<br/>          fib2 &lt;- fib(n-2)<br/>        } yield fib1 + fib2<br/>      }<br/>    )<br/>  }</span></pre><p id="5331" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后你可以这样运行它:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="0230" class="lo lp it lk b gy lq lr l ls lt">import scala.concurrent.duration._<br/>  implicit val ec :ExecutionContext = scala.concurrent.ExecutionContext.Implicits.global<br/>  val fibRes = Await.result(Future.sequence(Vector(<br/>    Future(fib(5)),<br/>    Future(fib(4)),<br/>    Future(fib(3))<br/>  ))<br/>  , Duration.Inf)<br/><br/><br/>  fibRes.toList.map(w =&gt; {<br/>    val (logging, endResult) = w.run<br/>    println(s"logging $logging endResult $endResult")<br/>  })</span></pre><h1 id="bc42" class="lv lp it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">外卖食品</h1><ul class=""><li id="ad33" class="na nb it kj b kk ms ko mt ks nc kw nd la ne le nf ng nh ni bi translated">编写器数据类型对于多线程环境中的日志记录操作非常有用</li><li id="5d71" class="na nb it kj b kk nj ko nk ks nl kw nm la nn le nf ng nh ni bi translated">编写器日志与结果相关联。因此，这是记录多线程计算顺序的一个极好的方法。</li></ul><p id="1cc4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">所有的例子信息都在<a class="ae kg" href="https://github.com/edwardGunawan/Blog-Tutorial/tree/master/ScalaTutorial/catsWriterType" rel="noopener ugc nofollow" target="_blank"> Github </a>中</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="8612" class="lv lp it bd lw lx nv lz ma mb nw md me mf nx mh mi mj ny ml mm mn nz mp mq mr bi translated">喜欢这篇文章？</h1><p id="26da" class="pw-post-body-paragraph kh ki it kj b kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le im bi translated">注册我的<a class="ae kg" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank">时事通讯</a>每周获取此内容！</p></div></div>    
</body>
</html>