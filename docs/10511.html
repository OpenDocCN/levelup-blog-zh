<html>
<head>
<title>Optimizing Performance Using React.memo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React.memo优化性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimizing-performance-using-react-memo-cc7d954de309?source=collection_archive---------3-----------------------#2021-12-16">https://levelup.gitconnected.com/optimizing-performance-using-react-memo-cc7d954de309?source=collection_archive---------3-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2a3bed2ac1a457b01e9095132def7ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKCRYzrnFkLivh_f8FtLfA.jpeg"/></div></div></figure><p id="439d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React.memo是React库中的高阶组件。高阶组件将另一个组件作为参数，并返回该组件的修改版本。</p><p id="dce3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在实践中，React.memo会记住一个组件，如果它的属性不变，它就不会重新呈现。当在组件上使用时，它会对每当其父级重新呈现时收到的属性进行简单的比较。让我们来看看我创建的一个演示。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/7939fbdf90ab0420c37de6dfb96ad6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*-HGEhCkQqytAncpEPQ_oGQ.gif"/></div></figure><p id="d5f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此演示的报告可在此处找到:</p><div class="le lf gp gr lg lh"><a href="https://github.com/jonathanbrierre/react.memo-demo" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">GitHub-jonathanbrierre/react . memo-demo</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jz lh"/></div></div></a></div><p id="1ba1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有两个组件:</p><h2 id="8a61" class="lw lx it bd ly lz ma dn mb mc md dp me km mf mg mh kq mi mj mk ku ml mm mn mo bi translated">App.jsx</h2><pre class="la lb lc ld gt mp mq mr ms aw mt bi"><span id="3600" class="lw lx it mq b gy mu mv l mw mx">function App() {<br/> const [count, setCount] = useState(0)<br/> const [childColor, setChildColor] = useState('#fffaaa')</span><span id="9f69" class="lw lx it mq b gy my mv l mw mx"> const generateRandomColor = () =&gt; {<br/>    setChildColor( '#' + Math.floor(Math.random()*16777215).toString(16));<br/>  }</span><span id="613a" class="lw lx it mq b gy my mv l mw mx"> return (<br/>    &lt;div className="App"&gt;<br/>      &lt;div className="demo-container"&gt;<br/>        &lt;button <br/>           onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}<br/>         &gt;<br/>          I have been clicked {count} times!<br/>        &lt;/button&gt;<br/>        &lt;button onClick={generateRandomColor}&gt;<br/>          Change Color<br/>        &lt;/button&gt;<br/>        &lt;Child color={childColor} /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h2 id="a95e" class="lw lx it bd ly lz ma dn mb mc md dp me km mf mg mh kq mi mj mk ku ml mm mn mo bi translated">Child.jsx</h2><pre class="la lb lc ld gt mp mq mr ms aw mt bi"><span id="b21b" class="lw lx it mq b gy mu mv l mw mx">const Child = (props) =&gt; {<br/> console.log('I was rendered')<br/> return (<br/>  &lt;div<br/>    className='child' <br/>    style={{backgroundColor: props.color}}<br/>  &gt;<br/>   I am the child component<br/>  &lt;/div&gt;<br/>  )<br/>}</span><span id="d5ef" class="lw lx it mq b gy my mv l mw mx">export default Child;</span></pre><p id="08d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你不熟悉这里如何设置状态，请参考我在React.js中关于<code class="fe mz na nb mq b">useState</code>钩子的博文。</p><div class="le lf gp gr lg lh"><a href="https://betterprogramming.pub/get-to-know-the-usestate-hook-in-react-js-d87797cb5a7" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">了解React.js中的UseState钩子</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">因为功能组件很牛逼</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">better编程. pub</p></div></div><div class="lq l"><div class="nc l ls lt lu lq lv jz lh"/></div></div></a></div><p id="3a78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一般来说，在React中，每当一个父组件重新渲染时，<strong class="kd iu">其子组件也会重新渲染</strong>。我们可以看到，每当我单击父组件中的两个按钮之一来更改父组件的状态时，都会触发子组件的控制台日志语句。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/195e6fbd25703ea0bf6ee5e4071bc6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*iFeRK116WS0jl0j8cfBJgw.gif"/></div></figure><p id="cffb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">理想情况下，当单击第一个按钮时，我们不希望这里的子组件重新呈现。该按钮仅更新仅影响其组件的状态。然而，我们仍然希望在单击<code class="fe mz na nb mq b">Change Color</code>按钮时重新呈现我们的子组件。当我们点击<code class="fe mz na nb mq b">Change Color</code>时，我们更新父组件的状态，并将更新后的状态作为道具传递给子组件。我们如何完成这种优化？</p><h1 id="4fd3" class="nd lx it bd ly ne nf ng mb nh ni nj me nk nl nm mh nn no np mk nq nr ns mn nt bi translated">我们用React.memo！</h1><p id="d11f" class="pw-post-body-paragraph kb kc it kd b ke nu kg kh ki nv kk kl km nw ko kp kq nx ks kt ku ny kw kx ky im bi translated">这个功能超级好用。在我的子组件文件的顶部，我将像这样导入它:</p><pre class="la lb lc ld gt mp mq mr ms aw mt bi"><span id="1089" class="lw lx it mq b gy mu mv l mw mx">import { memo } from ‘react’;</span></pre><p id="0819" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我从文件中导出子组件时，我调用memo函数，将Child作为参数。</p><pre class="la lb lc ld gt mp mq mr ms aw mt bi"><span id="a9b2" class="lw lx it mq b gy mu mv l mw mx">export default memo(Child);</span></pre><p id="16a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经记住了我们的子组件，让我们看看我们是否已经去掉了那些多余的重新呈现器！</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/1f77c66b3478a27aa48f9ebf64fc1302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*YWCVel2_DxE5rx1s9U9P8Q.gif"/></div></figure><p id="1250" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，当我们现在单击第一个按钮来增加其计数时，子组件不再呈现。当我们改变颜色并将改变后的颜色作为道具传递给子组件时，由于使用了React.memo，子组件会重新渲染。</p><p id="7df2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意事项:</strong></p><p id="b715" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您不喜欢React.memo的基本浅层比较，您可以向该函数传递第二个参数。这个参数将是一个函数，用来比较你想要的道具。</p><p id="6d23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React.memo是一个高阶组件，针对功能组件进行了优化。为了有效地防止类组件的过度重新呈现，PureComponents是最好的选择！</p><p id="fe8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要了解更多关于PureComponents的内容，请点击这里查看我的博文！</p><div class="le lf gp gr lg lh"><a href="https://medium.com/@jonathanbrierre/optimizing-ui-performance-with-react-purecomponent-and-shallow-comparison-a10cc3073e78" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">用React优化UI性能。纯组件和浅层比较</h2><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="nz l ls lt lu lq lv jz lh"/></div></div></a></div><p id="6147" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，React.memo最适合用于没有经常改变的道具的子组件。如果一个组件的属性经常变化，就不值得记住它。</p><p id="7eae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望您喜欢您的高性能React应用程序！</p></div></div>    
</body>
</html>