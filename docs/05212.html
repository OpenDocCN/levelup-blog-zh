<html>
<head>
<title>State Management in Flutter using Provider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用提供者的颤振状态管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/state-management-in-flutter-using-provider-1dc2a8e9f2b1?source=collection_archive---------1-----------------------#2020-08-12">https://levelup.gitconnected.com/state-management-in-flutter-using-provider-1dc2a8e9f2b1?source=collection_archive---------1-----------------------#2020-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9c9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在颤振中使用MVVM</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e87a654aad7a050aad35715bd6878ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hCT04XsVuDGm_l75"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">罗伯特·蒂曼在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4057" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主要来自科特林的背景，我发现一开始很难理解flutter。这主要是因为Flutter遵循声明式编程风格，而Kotlin遵循命令式编程风格。</p><blockquote class="lf lg lh"><p id="6a41" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">声明式编程关注的是程序应该完成什么，而不是如何完成。</p></blockquote><p id="a99a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这个原因，我们在flutter中编程的方式变得非常不同。我举个例子。在Kotlin中，如果我们必须更新TextView的文本，那么我们可以很容易地调用setText方法。</p><pre class="kp kq kr ks gt lm ln lo lp aw lq bi"><span id="e556" class="lr ls it ln b gy lt lu l lv lw">textView.<em class="li">text </em>= "New text"</span></pre><p id="2f06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在Flutter中更新文本是完全不同的，因为它不允许我们更新文本字段的文本。我们可以做的是，通过调用StatefulWidget中的setState，用更新后的文本值重新构建组件。</p><pre class="kp kq kr ks gt lm ln lo lp aw lq bi"><span id="974f" class="lr ls it ln b gy lt lu l lv lw">setState(() {<br/>  newText = "New text";<br/>});</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="4ba8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您也来自Kotlin后台，我想您应该非常熟悉MVVM架构和livedata，其中一个简单的代码用于从viewmodel获取和显示数据，同时管理不同的状态，如下所示:</p><pre class="kp kq kr ks gt lm ln lo lp aw lq bi"><span id="3cd7" class="lr ls it ln b gy lt lu l lv lw">private fun observeSkuListResponse() {<br/>    homeViewModel.skuListResponse.observe(this, <em class="li">Observer </em><strong class="ln iu">{<br/>        </strong>when (<strong class="ln iu">it</strong>.status) {<br/>            Status.LOADING -&gt; {<br/>                binding.loadingLayout.<em class="li">visibility </em>= View.<em class="li">VISIBLE</em><br/>            }<br/>            Status.SUCCESS -&gt; {<br/>                binding.loadingLayout.<em class="li">visibility </em>= View.<em class="li">GONE<br/>                // perform other operation</em></span><span id="bc56" class="lr ls it ln b gy me lu l lv lw"><strong class="ln iu">            </strong>}<br/>            Status.ERROR -&gt; {<br/>               binding.loadingLayout.<em class="li">visibility </em>= View.<em class="li">GONE<br/>               </em>binding.errorLayout.<em class="li">visibility </em>= View.<em class="li">VISIBLE</em></span><span id="47a1" class="lr ls it ln b gy me lu l lv lw">            }<br/>        }<br/>    <strong class="ln iu">}</strong>)<br/>}</span></pre><p id="dc73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码非常简单:如果你的状态是加载状态，那么你只显示加载屏幕。如果您的响应状态为完成，则隐藏加载屏幕并显示数据。如果您的响应有错误，那么您将隐藏所有其他视图并显示错误消息。</p><p id="e8e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于flutter没有可见性消失或可见的概念，所以我们必须直接传递我们想要在屏幕上显示的视图，并重新绘制组件。为了获得状态，我们将使用provider。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="7678" class="lr ls it bd mf mg mh dn mi mj mk dp ml kb mm mn mo kf mp mq mr kj ms mt mu mv bi translated">提供商简介</h2><p id="c3aa" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">Provider用于flutter中的状态管理。它由3个部分组成</p><ul class=""><li id="ec93" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">更改通知程序</li><li id="fea3" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">更改通知程序提供程序</li><li id="cea0" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">消费者</li></ul><p id="4b26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">变更通知</strong>对于MVVM建筑来说，就像viewmodel对于Kotlin一样。它是管理屏幕状态的中心点。如果它内部的状态发生了变化，那么它会通知框架重新构建屏幕。</p><p id="ca5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> ChangeNotifierProvider </strong>在视图中提供了一个ChangeNotifier的实例。</p><p id="211f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Consumer </strong>是一个允许我们使用ChangeNotifier的小部件。</p><blockquote class="lf lg lh"><p id="86a3" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">将您的消费者放在需要访问变更通知程序的代码上面。这是因为当有一些变化时，它会重建它的派生窗口小部件，而你不想每次有一些变化时都要重建整个屏幕。</p></blockquote><p id="032e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们进入代码。</p><h2 id="7f3d" class="lr ls it bd mf mg mh dn mi mj mk dp ml kb mm mn mo kf mp mq mr kj ms mt mu mv bi translated">视图模型</h2><p id="1bb5" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">这里我创建了一个函数fetchSkuList()，它从_homeRepo中获取SKU，然后在skuListUseCase中设置值。最后，它通过调用<strong class="js iu"> notifyListener() </strong>来通知数据的变化。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2d73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，Response是一个负责向UI传达数据状态的类，即加载、完成或错误。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0db3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些状态由ResponseState表示，ResponseState是一个枚举，包括:</p><pre class="kp kq kr ks gt lm ln lo lp aw lq bi"><span id="5a10" class="lr ls it ln b gy lt lu l lv lw">enum ResponseState{<br/>  LOADING,<br/>  COMPLETE,<br/>  ERROR<br/>}</span></pre><h2 id="fcd9" class="lr ls it bd mf mg mh dn mi mj mk dp ml kb mm mn mo kf mp mq mr kj ms mt mu mv bi translated">用户界面屏幕</h2><p id="2139" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">在我的主屏幕中，首先，我已经获取了initState中的数据。然后在构建方法中，我将<strong class="js iu"> ChangeNotifierProvider </strong>和<strong class="js iu"> Consumer </strong>放在Appbar的正下方，因为我希望当数据状态改变时，屏幕的其余部分也相应地更新。添加消费者后，switch语句检查当前状态:加载、出错或完成，并相应地更新UI。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d25e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LoadingScreen和ErrorScreen是显示进度条和文本消息的简单屏幕。</p><p id="5ae0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">加载屏幕</strong></p><pre class="kp kq kr ks gt lm ln lo lp aw lq bi"><span id="0c0c" class="lr ls it ln b gy lt lu l lv lw">import 'package:flutter/material.dart';<br/><br/>class LoadingScreen extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Center(<br/>        child: Container(<br/>      child: Column(<br/>        mainAxisAlignment: MainAxisAlignment.center,<br/>        children: [<br/>          CircularProgressIndicator(),<br/>          SizedBox(<br/>            height: 8,<br/>          ),<br/>          Text(<br/>            'Loading...',<br/>            style: TextStyle(fontFamily: 'Roboto'),<br/>          )<br/>        ],<br/>      ),<br/>    ));<br/>  }<br/>}</span></pre><p id="2723" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">错误屏幕</strong></p><pre class="kp kq kr ks gt lm ln lo lp aw lq bi"><span id="8ef6" class="lr ls it ln b gy lt lu l lv lw">import 'package:flutter/material.dart';<br/><br/>class ErrorScreen extends StatelessWidget {<br/>  final String msg;<br/><br/>  ErrorScreen(this.msg);<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Center(<br/>        child: Container(<br/>            child: Text(<br/>      '$msg',<br/>      style: TextStyle(fontFamily: 'Roboto'),<br/>    )));<br/>  }<br/>}</span></pre><p id="b157" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样:使用provider管理状态的最简单方法。</p><p id="bc21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看我的github repo了解更多细节。</p><div class="nr ns gp gr nt nu"><a href="https://github.com/RumiRajbhandari/CleanArchFlutter" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">RumiRajbhandari/cleanarchfutter</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">在GitHub上创建一个帐户，为RumiRajbhandari/cleanarchfutter的开发做出贡献。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="oe l of og oh od oi ky nu"/></div></div></a></div><p id="066e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这篇文章，别忘了鼓掌并留下评论。:)</p></div></div>    
</body>
</html>