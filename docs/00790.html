<html>
<head>
<title>Understanding JavaScript Execution Context and How It Relates to Scope and the `this` Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript执行上下文及其与范围和“this”上下文的关系</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-javascript-fundamentals-scope-context-execution-context-9fe8673b3164?source=collection_archive---------0-----------------------#2019-07-30">https://levelup.gitconnected.com/learn-javascript-fundamentals-scope-context-execution-context-9fe8673b3164?source=collection_archive---------0-----------------------#2019-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84d00e7a6f7dc4062346cc4072d762ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sMQUPCBHDHKAeaLZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Starks Don Pablo 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4c2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，你写一些代码，它被JavaScript引擎解释。要了解幕后发生的事情，您需要了解一些基础知识。在本文中，我们将关注范围、上下文和执行上下文之间的区别。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="b481" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">范围</strong></h1><blockquote class="mg mh mi"><p id="ab1a" class="kd ke mj kf b kg kh ki kj kk kl km kn mk kp kq kr ml kt ku kv mm kx ky kz la ij bi translated">由于本文是<em class="iq">学习JavaScript基础知识</em>系列的一部分，如果您想了解更多关于作用域的类型或者如何使用它，可以通过本文末尾的链接查看该系列的其余部分。</p></blockquote><p id="6b8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单来说，范围与变量的<strong class="kf ir">可见性密切相关。混淆范围和上下文是很常见的，但实际上它们是完全不同的。通过作用域，您可以控制变量</strong>的<strong class="kf ir">可访问性。在全局作用域中创建的变量可以从任何作用域中访问，而局部变量可以在创建它们的函数中访问。</strong></p><h1 id="a090" class="li lj iq bd lk ll mn ln lo lp mo lr ls lt mp lv lw lx mq lz ma mb mr md me mf bi translated"><strong class="ak">语境</strong></h1><p id="7d1c" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">上下文只是“<code class="fe mx my mz na b">this</code>”<strong class="kf ir">、</strong>的值，<em class="mj">执行上下文</em>的属性，这将在本文后面的<strong class="kf ir">中解释。它也指函数/方法所属的对象。</strong></p><p id="af1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mx my mz na b">this</code>的值因调用函数的方式而异。在全局范围内，<code class="fe mx my mz na b">this</code>的值始终是<a class="ae kc" href="https://medium.com/swlh/javascript-fundamentals-global-scope-71ba5e48dbae" rel="noopener">窗口的</a>对象。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="719a" class="nj lj iq na b gy nk nl l nm nn">console.log(this); // window</span></pre><p id="7158" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果函数是方法，<code class="fe mx my mz na b">this</code>的值就是该方法所属的对象。当然，<code class="fe mx my mz na b">this</code>这个关键词不是那么容易理解的。在这篇文章中，我不会深入讨论关键字<code class="fe mx my mz na b">this</code>如何工作的细节，只是强调它与范围、上下文、执行上下文的关系。理解<code class="fe mx my mz na b">this</code>如何工作是JavaScript中最困难也是最重要的主题之一。幸运的是，有大量的资源。如果你不熟悉，我建议你去看看。</p><ul class=""><li id="b5ab" class="no np iq kf b kg kh kk kl ko nq ks nr kw ns la nt nu nv nw bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank"> MDN </a></li><li id="eba4" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la nt nu nv nw bi translated"><a class="ae kc" href="https://javascript.info/object-methods" rel="noopener ugc nofollow" target="_blank"> Javascript.info </a></li><li id="f90a" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la nt nu nv nw bi translated"><a class="ae kc" href="https://www.thecodingdelight.com/javascript-this/" rel="noopener ugc nofollow" target="_blank">掌握JavaScript这个关键字</a></li></ul><p id="b612" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mx my mz na b">this</code>关键字的含义取决于调用函数的方式和位置，而不是声明函数的位置。每次从不同的执行上下文调用一个函数时，它的含义都会发生变化。为什么是执行上下文？因为<code class="fe mx my mz na b">this</code>关键字实际上是对<em class="mj">函数当前执行上下文的引用。</em></p><h1 id="589d" class="li lj iq bd lk ll mn ln lo lp mo lr ls lt mp lv lw lx mq lz ma mb mr md me mf bi translated"><strong class="ak">执行上下文</strong></h1><p id="4c48" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">为了理解JavaScript代码如何运行，您需要知道执行上下文。首先，它是一个<strong class="kf ir"> <em class="mj">抽象</em> </strong> <em class="mj">概念</em>，代表JavaScript运行的<em class="mj">环境</em>。执行上下文中发生的事情基本上是两件事。第一步是逐行解析代码，第二步是将变量和函数存储到内存中。简单来说，它有两种类型:</p><ul class=""><li id="0f7e" class="no np iq kf b kg kh kk kl ko nq ks nr kw ns la nt nu nv nw bi translated">全局执行上下文</li><li id="c9ee" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la nt nu nv nw bi translated">本地执行上下文</li></ul><p id="7663" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">全局执行上下文是你写JavaScript代码时创建的第一个东西。这是默认的上下文。</p><p id="c63f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">本地执行上下文</strong>是在你调用一个函数(没有定义函数)的时候创建的。</p><p id="ab16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它是一个抽象的概念，所以我准备用一个图像来支持它。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/17693214a4921d1ba21aa5a3c1185c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CuL8xsqLb1GhpuHgmDKk0A.png"/></div></div></figure><p id="2e5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们浏览一下图像。当JS引擎开始读取您的代码时，它会创建全局执行上下文。它开始逐行解析，并把你的变量添加到内存中，也称为全局变量环境。</p><p id="7c56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您定义了这样一个函数:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="cb59" class="nj lj iq na b gy nk nl l nm nn">function adding(num) {<br/>  let number=num+2;<br/>  return number;<br/>}</span></pre><p id="caba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你调用这个函数</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="be7b" class="nj lj iq na b gy nk nl l nm nn">adding(3);</span></pre><p id="8ab5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当引擎进行解析时，如果它需要执行函数，就会创建一个新的本地执行上下文。在那个执行上下文中，解析发生，并且<code class="fe mx my mz na b"><strong class="kf ir">number</strong></code> <strong class="kf ir"> </strong>变量被添加到本地存储器，然后解析继续。此后，引擎返回到先前的执行上下文。</p><p id="95d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mx my mz na b">return</code> <em class="mj"> </em>关键字可以退出本地执行上下文，并在之前的执行上下文中继续解析。图像中的箭头代表了这个循环。每次调用函数时，这种情况都会再次发生。每个函数调用都会导致不同的本地执行上下文。</p><p id="f94b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单总结一下:</p><ol class=""><li id="ec87" class="no np iq kf b kg kh kk kl ko nq ks nr kw ns la od nu nv nw bi translated">首先创建全局执行上下文。</li><li id="3f1e" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated">每当调用、调用或执行一个函数时，都会创建一个新的本地执行上下文。</li><li id="c009" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated">JavaScript引擎开始在全局执行上下文中解析代码。</li><li id="cc53" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated">当引擎遇到函数调用时，它进入本地执行上下文并在那里继续解析。</li><li id="03e7" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated">当它处理函数执行时，它从本地执行上下文中退出，返回到前一个上下文。</li></ol><p id="395b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这给我们带来了另一个重要的概念。引擎如何知道进入或退出哪个执行上下文？答案是<strong class="kf ir"> <em class="mj">调用栈</em> </strong>。</p><p id="b9db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用堆栈是JavaScript引擎跟踪执行上下文的一种机制，执行上下文是进入、退出还是返回。堆栈的底部是全局执行上下文。如果一个函数被调用，我们有一个新的本地执行上下文，这个上下文被推到调用栈的顶部。一旦完成，它就会被弹出。我用一个图像来解释一下:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/2e22694dd238d8ce2267b7698083513c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcTk7Ev0gp_H3Krup6G1EA.png"/></div></div></figure><p id="b664" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是怎么回事？</p><ol class=""><li id="3d22" class="no np iq kf b kg kh kk kl ko nq ks nr kw ns la od nu nv nw bi translated">引擎开始解析，全局执行上下文被自动推送到调用堆栈。</li><li id="2d13" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated">被调用时，局部执行上下文被推到全局执行上下文的顶部。执行完<code class="fe mx my mz na b">Function1</code>后，引擎会继续解析。</li><li id="70f2" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated">在<code class="fe mx my mz na b">Function1</code>中，一个新的执行上下文被创建并被推到调用堆栈的顶部。执行<code class="fe mx my mz na b">Function2</code>后，它从调用栈中弹出。</li><li id="18a2" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated"><code class="fe mx my mz na b">Function1</code>执行完毕后弹出。</li><li id="a2a8" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated">最后，它返回到全局执行上下文。引擎继续解析并执行所有代码。</li></ol><h1 id="aebc" class="li lj iq bd lk ll mn ln lo lp mo lr ls lt mp lv lw lx mq lz ma mb mr md me mf bi translated"><strong class="ak">执行上下文的阶段</strong></h1><p id="2c40" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">在整篇文章中，您可能想知道执行上下文是如何创建的。尽管是抽象的，但它是一个过程，引擎遵循该过程中的一些步骤。</p><p id="31f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上它有两个阶段:</p><ol class=""><li id="5511" class="no np iq kf b kg kh kk kl ko nq ks nr kw ns la od nu nv nw bi translated">创建阶段</li><li id="291e" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated">执行阶段</li></ol><p id="14e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="mj">创建阶段</em>，引擎首先创建<em class="mj">激活对象</em>或<em class="mj">变量对象</em>。这个对象由变量、参数和函数声明组成。在这个阶段，它们被赋予<code class="fe mx my mz na b">undefined</code>的值。</p><p id="fe1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">arguments属性也是一个具有length属性的对象(类似数组的对象),传递给函数调用的所有参数都存储在该对象中。</p><p id="915c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，引擎创建范围链。每个执行上下文都知道它的范围。它有一个对其外部范围的引用，一直到全局范围，引擎从当前范围到全局范围搜索变量(如果存在或不存在)。这叫做作用域链。作用域链是一个对象列表，由它自己的变量对象和它的父变量对象组成。</p><p id="64c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，确定<code class="fe mx my mz na b">this</code>的值。在全局上下文中，它的值是<code class="fe mx my mz na b">window</code> / <code class="fe mx my mz na b">global</code>对象，而在每个函数调用中，它的值可能不同。</p><p id="7412" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="mj">执行阶段</em>，变量被赋值，引擎执行代码。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="fa61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想阅读更多关于JavaScript基础的内容，请阅读学习JavaScript基础系列。</p><ol class=""><li id="fe1e" class="no np iq kf b kg kh kk kl ko nq ks nr kw ns la od nu nv nw bi translated"><a class="ae kc" href="https://medium.com/swlh/javascript-fundamentals-global-scope-71ba5e48dbae" rel="noopener">全局范围</a></li><li id="e7cc" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated"><a class="ae kc" href="https://medium.com/@smeyradvrn/javascript-fundamentals-local-scope-5841690ea6aa" rel="noopener">局部范围</a></li><li id="74cc" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la od nu nv nw bi translated"><a class="ae kc" href="https://medium.com/@smeyradvrn/learn-javascript-fundamentals-scope-context-execution-context-9fe8673b3164" rel="noopener">范围、上下文、执行上下文</a></li></ol><p id="5c1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编码快乐！！！</p></div></div>    
</body>
</html>