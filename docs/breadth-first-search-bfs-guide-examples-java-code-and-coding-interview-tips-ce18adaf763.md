# 广度优先搜索(BFS)指南—示例、Java 代码和编码面试技巧

> 原文：<https://levelup.gitconnected.com/breadth-first-search-bfs-guide-examples-java-code-and-coding-interview-tips-ce18adaf763>

广度优先搜索，或称 BFS，是我对编码面试必须知道的算法之一。本文将介绍什么是 BFS，向您展示如何用 Java 编写 BFS，并浏览一些 BFS 的编码面试技巧。有关如何在各种输入上运行算法的示例以及 Java 代码的逐行解释，请参阅我的 3 部分视频系列:

如果这篇文章有帮助，请考虑[订阅我的 YouTube 频道](http://bit.ly/sub2rahul)或者[在媒体](https://medium.com/@rahulsabnis19)上关注我以获得更多类似的内容！

![](img/a6a50bd4e6d548680cf2381916b8b13f.png)

# BFS 解释道

为了清楚起见，我将在本文中交替使用顶点和节点这两个术语。它们的意思是一样的。顶点通过边相互连接，形成一个类似图形的结构。

广度优先搜索是一种算法，允许您在未加权的图中找到一个顶点和另一个顶点之间的最短路径。未加权意味着从图中的任何一个节点到另一个节点的成本与任何其他节点对的成本相同。如果我们有一个带权的图，BFS 仍然可以用来寻找从一个顶点到另一个顶点是否存在路径。

BFS 的工作方式如下:

1.  检查起始节点是否是我们的目的地。如果是这样，我们已经找到了一条路。如果不是，继续第 2 步，其中 n 等于 1。n 等于到我们所看到的起始节点的距离。
2.  检查距离起始节点 n 远的所有节点。如果我们在这个集合中找到了目的地，我们就找到了一条路径。如果没有，将这些节点标记为已访问(以确保我们不会重新访问这些节点)，并在距离起始节点 n+1 的未访问节点上重复步骤 2。如果不再存在未访问的节点，请继续执行步骤 3。
3.  图中的起始节点和目的节点之间没有路径。

BFS 的时间复杂度为 O(|V| + |E|)。|V|是顶点集的基数，或者换句话说，是顶点的数量。|E|是边集的基数，或者换句话说，是边的数量。这是因为在最坏的情况下，BFS 会要求你访问每一个顶点和每一条边。

# BFS Java 代码

下面是如何用 Java 实现 BFS:

# 编码访谈中的 BFS

什么时候应该考虑在面试中使用 BFS:

1.  您需要在任何类似图形的结构中找到从一个顶点到另一个顶点的路径(尤其是那些离起始节点更近的)。还要注意，图形可以有多种形式(例如，树是一种类似图形的结构，因为它们由边连接的顶点组成)。
2.  你需要在任何未加权的图中找到从一个顶点到另一个顶点的最短路径。

当您不应该考虑使用 BFS 时:

1.  你需要找到一个在你的图形深处的节点(它和起始节点之间的距离很大)。

这些只是需要考虑的一些重要情况，但是除此之外，了解其他图搜索算法也很重要。其中包括深度优先搜索(DFS)，Djikstra 的算法，等等。当您了解 BFS 的替代方案时，您可以更好地决定哪一个适合手头的问题。

![](img/25e072ee408f593f661a878953a0210b.png)

我的 BFS 算法指南到此结束。我希望你发现这个故事内容丰富！请与你认为可能从中受益的朋友分享！如果你喜欢这个帖子/视频，请随意留下掌声/喜欢，并关注/订阅我的[媒体](https://medium.com/@rahulsabnis19)和 [YouTube 账户](http://bit.ly/sub2rahul)以获得更多类似的内容。此外，当我发布新内容时，请在 [Twitter](https://twitter.com/sabnis_rahul) 和 [Instagram](https://www.instagram.com/sabnis_rahul/) 上关注我。我希望在下一集看到你们！