<html>
<head>
<title>A Complete Guide to Laravel Sail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拉勒维尔帆船完全指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/you-dont-need-laravel-sail-e66b2dd8cffa?source=collection_archive---------5-----------------------#2021-01-07">https://levelup.gitconnected.com/you-dont-need-laravel-sail-e66b2dd8cffa?source=collection_archive---------5-----------------------#2021-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d996" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它是什么，它是如何工作的，如何扩展它，以及为什么你可能根本不需要它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/19145d3d68158ca258bda21ae8db0301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fBlycx3OCz_CIYSP.png"/></div></div></figure><blockquote class="ku kv kw"><p id="c613" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">⚠️ <strong class="la iu">这个内容已经过时了。</strong>这是在Laravel Sail首次发布后几天写的，从那以后Sail收到了一些更新，毫无疑问还会有更多更新。<strong class="la iu">请</strong> <a class="ae lu" href="https://tech.osteel.me/posts/you-dont-need-laravel-sail" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">访问我的博客</strong> </a> <strong class="la iu">获取最新版本</strong>，这是本指南最初发表的地方。谢谢你。</p></blockquote><blockquote class="lv"><p id="5541" class="lw lx it bd ly lz ma mb mc md me lt dk translated"><em class="mf">杜鲁门继续驾驶着他失事的帆船驶向无限后退的地平线。一切都很平静，直到我们看到船头突然撞上一堵巨大的蓝色墙壁，把杜鲁门撞倒在地。杜鲁门恢复过来，爬上甲板来到船头。在他头顶的海面上隐约可见一幅巨大的旋风图。他驶向的天空只不过是一幅画中的背景。</em></p><p id="3f27" class="lw lx it bd ly lz mg mh mi mj mk lt dk translated"><em class="mf">——安德鲁·m·尼科尔，</em> <a class="ae lu" href="http://www.dailyscript.com/scripts/the-truman-show_shooting.html" rel="noopener ugc nofollow" target="_blank"> <em class="mf">《楚门的世界》</em> </a></p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="f508" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">2020年12月8日，Taylor Otwell宣布推出基于Docker的开发环境Laravel Sail，并对Laravel的文档进行了大规模修改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8d91" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">该公告在整个社区引起了一阵兴奋，因为许多人认为新环境是最终进入Docker的一种方式；但它也留下了一些困惑，因为Sail引入了一种与其前辈截然不同的开发方法，并不是成为Docker专家的准确指南。</p><p id="df4f" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">这个帖子是关于对Laravel Sail的期望，它是如何工作的，以及如何充分利用它；这也是对开发人员的一种恳求，要求他们脱离it，支持他们自己的定制解决方案。</p><p id="f68b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">但是在我们到达那里之前，我们需要看一看甲板下面，从什么是帆的高层次解释开始。</p><h1 id="2166" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">什么是拉勒维尔帆？</h1><p id="02a3" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">Sail是Laravel的最新开发环境。这是一个长长的列表中的最新成员，一方面是官方解决方案，如<a class="ae lu" href="https://laravel.com/docs/homestead" rel="noopener ugc nofollow" target="_blank"> Homestead </a>和<a class="ae lu" href="https://laravel.com/docs/valet" rel="noopener ugc nofollow" target="_blank"> Valet </a>，另一方面是社区努力，如<a class="ae lu" href="https://laragon.org" rel="noopener ugc nofollow" target="_blank"> Laragon </a>、<a class="ae lu" href="http://laradock.io" rel="noopener ugc nofollow" target="_blank"> Laradock </a>、<a class="ae lu" href="https://github.com/tighten/takeout" rel="noopener ugc nofollow" target="_blank">外卖</a>和<a class="ae lu" href="https://vessel.shippingdocker.com/" rel="noopener ugc nofollow" target="_blank">船只</a>(根据<a class="ae lu" href="https://github.com/laravel/sail#inspiration" rel="noopener ugc nofollow" target="_blank"> GitHub知识库</a>，Sail很大程度上是受后者的启发)。</p><p id="7753" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">Laravel Sail基于<a class="ae lu" href="https://www.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker </a>，这是一种利用<a class="ae lu" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">容器</a>从本质上打包应用程序的技术，因此它们可以在任何操作系统上快速轻松地运行。</p><p id="5347" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">Sail的未来似乎是光明的，因为Laravel文档已经将它描述为在本地安装和运行Laravel项目的首选方式，这是Homestead和Valet占据多年的一个地方。</p><h1 id="9b3c" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">它和它的前辈相比怎么样？</h1><p id="c34a" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">作为补充，Homestead是一个<a class="ae lu" href="https://www.vagrantup.com" rel="noopener ugc nofollow" target="_blank">流浪者</a>盒子(一个虚拟机),预装了大多数Laravel应用程序需要的一切，包括像PHP、MySQL和web服务器(Nginx)这样的基本组件，但也有像PostgreSQL、Redis或Memcached这样不常用的技术。</p><p id="06ba" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">另一方面，Valet是一个面向macOS的轻量级环境，专注于性能，依赖于PHP的本地安装而不是虚拟机，旨在与其他服务一起使用，如<a class="ae lu" href="https://dbngin.com" rel="noopener ugc nofollow" target="_blank"> DBngin </a>或外卖，以管理其他依赖关系，如数据库。</p><p id="2a16" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">虽然宅地和代客看起来很不一样，但它们促进了当地发展的相同的一般方法，这也是大多数前述解决方案所共有的:它们试图成为Laravel项目的通用环境，并在一个屋檐下管理它们。</p><p id="f39c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">Sail的方法与众不同，因为开发环境的描述包含在代码库的其余部分中。该项目没有依赖开发人员机器上的第三方解决方案，而是附带了一组指令，供Docker选择和构建相应的环境。</p><p id="fb34" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">该应用程序自带电池，只要安装了Docker，无论开发者的操作系统是什么，只需要一个命令就可以启动其开发环境。它还引入了为应用程序定制开发环境的概念，在我看来，这是Laravel Sail的真正亮点。</p><p id="8c3e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">虽然这种方法与传统的解决方案有很大的不同，但Sail仍然在它所附带的工具方面与传统的解决方案有一些相似之处，其中一些是必不可少的，另一些则不是。</p><p id="b8ed" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">让我们回顾一下最重要的方法以及它们的实现方式。</p><h1 id="2b8d" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">它是如何工作的？</h1><p id="c713" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">从现在开始，跟随Laravel的全新安装会更容易，尽管我提到的文件附带了到<a class="ae lu" href="https://github.com/laravel/sail" rel="noopener ugc nofollow" target="_blank">官方GitHub库</a>的链接。如果你有一点点时间，现在就去遵循你的操作系统的<a class="ae lu" href="https://laravel.com/docs/installation#your-first-laravel-project" rel="noopener ugc nofollow" target="_blank">指令，完成后再回来这里。</a></p><p id="5e75" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">虽然Sail允许我们在创建新的Laravel应用程序时选择感兴趣的服务，但默认情况下，它由三个主要组件组成:PHP、MySQL和Redis。根据<a class="ae lu" href="https://laravel.com/docs/sail#introduction" rel="noopener ugc nofollow" target="_blank">文档</a>，整个设置围绕着两个文件:<code class="fe nu nv nw nx b"><a class="ae lu" href="https://github.com/laravel/sail/blob/1.x/stubs/docker-compose.stub" rel="noopener ugc nofollow" target="_blank">docker-compose.yml</a></code>(在全新安装后，您将在项目的根目录下找到)和<code class="fe nu nv nw nx b"><a class="ae lu" href="https://github.com/laravel/sail/blob/1.x/bin/sail" rel="noopener ugc nofollow" target="_blank">sail</a></code>脚本(在<code class="fe nu nv nw nx b">vendor/bin</code>下找到)。</p><h1 id="4371" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><code class="fe nu nv nw nx b">docker-compose.yml</code>文件</h1><p id="c4ca" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">如前所述，Laravel Sail基于Docker，这是一种利用容器的技术。根据经验，每个容器应该只运行一个进程；粗略地说，这意味着每个容器应该只运行一个软件。如果我们将这个规则应用到上面的设置中，我们将需要一个容器用于PHP，另一个用于MySQL，第三个用于Redis。</p><p id="416b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">这些容器组成了你的应用程序，它们需要被<em class="kz">编排</em>才能正常工作。有几种方法可以做到这一点，但Laravel Sail依靠<a class="ae lu" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>来完成这项工作，这是最简单、最常用的本地设置解决方案。</p><p id="ef19" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">Docker Compose希望我们以YAML格式在一个<code class="fe nu nv nw nx b">docker-compose.yml</code>文件中描述应用程序的各个组件。如果你打开项目根目录下的那个，你会在顶部看到一个<code class="fe nu nv nw nx b">version</code>参数，在它下面有一个<code class="fe nu nv nw nx b">services</code>部分，包含一个组件列表，包括我们刚刚提到的:<code class="fe nu nv nw nx b">laravel.test</code>、<code class="fe nu nv nw nx b">mysql</code>和<code class="fe nu nv nw nx b">redis</code>。</p><p id="3638" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我将首先描述<code class="fe nu nv nw nx b">mysql</code>和<code class="fe nu nv nw nx b">redis</code>服务，因为它们比<code class="fe nu nv nw nx b">laravel.test</code>简单；然后，我将简要地介绍一下其他较小的，也是默认情况下新安装的。</p><h2 id="a84b" class="ny my it bd mz nz oa dn nd ob oc dp nh ms od oe nj mt of og nl mu oh oi nn oj bi translated"><code class="fe nu nv nw nx b">mysql</code>服务</h2><p id="2705" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">顾名思义，<code class="fe nu nv nw nx b">mysql</code>服务处理MySQL数据库:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="2a01" class="ny my it nx b gy oo op l oq or">mysql:<br/>    image: 'mysql:8.0'<br/>    ports:<br/>        - '${FORWARD_DB_PORT:-3306}:3306'<br/>    environment:<br/>        MYSQL_ROOT_PASSWORD: '${DB_PASSWORD}'<br/>        MYSQL_DATABASE: '${DB_DATABASE}'<br/>        MYSQL_USER: '${DB_USERNAME}'<br/>        MYSQL_PASSWORD: '${DB_PASSWORD}'<br/>        MYSQL_ALLOW_EMPTY_PASSWORD: 'yes'<br/>    volumes:<br/>        - 'sailmysql:/var/lib/mysql'<br/>    networks:<br/>        - sail<br/>    healthcheck:<br/>        test: ["CMD", "mysqladmin", "ping"]</span></pre><p id="64a8" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">image</code>参数指示哪个<em class="kz">图像</em>应该用于该容器。理解图像和容器的区别的一个简单方法是借用面向对象编程的概念:图像类似于一个类，容器类似于该类的一个实例。</p><p id="e79e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">这里，我们指定我们想要使用<code class="fe nu nv nw nx b">mysql</code>图像的标签<code class="fe nu nv nw nx b">8.0</code>，对应于MySQL版本8.0。默认情况下，图像从最大的图像注册中心下载。看看MySQL的页面——大多数图片都附有简单的文档，解释如何使用它。</p><p id="0f51" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">ports</code>键允许我们按照<code class="fe nu nv nw nx b">local:container</code>格式将本地端口映射到集装箱端口。在上面的代码片段中，<code class="fe nu nv nw nx b">FORWARD_DB_PORT</code>环境变量的值(如果该值为空，则为<code class="fe nu nv nw nx b">3306</code>)被映射到容器的<code class="fe nu nv nw nx b">3306</code>端口。这主要用于将第三方软件连接到数据库，如<a class="ae lu" href="https://www.mysql.com/products/workbench/" rel="noopener ugc nofollow" target="_blank"> MySQL Workbench </a>或<a class="ae lu" href="https://sequel-ace.com/" rel="noopener ugc nofollow" target="_blank">Sequel Ace</a>；没有它，该设置也可以工作。</p><p id="fa9c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">environments</code>用于定义容器的环境变量。在这里，它们中的大多数接收现有环境变量的值，这些值是从项目根目录下的<code class="fe nu nv nw nx b">.env</code>文件中加载的—<code class="fe nu nv nw nx b">docker-compose.yml</code>自动检测并导入这个文件的内容。例如，在<code class="fe nu nv nw nx b">MYSQL_ROOT_PASSWORD: '${DB_PASSWORD}'</code>行中，容器的<code class="fe nu nv nw nx b">MYSQL_ROOT_PASSWORD</code>环境变量将从<code class="fe nu nv nw nx b">.env</code>文件中接收<code class="fe nu nv nw nx b">DB_PASSWORD</code>的值。</p><p id="adff" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">volumes</code>是将容器的一些文件或文件夹声明为<em class="kz">卷</em>，要么通过将特定的本地文件或文件夹映射到它们，要么通过让Docker处理它。</p><p id="ce8a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">这里定义了一个Docker管理的卷:<code class="fe nu nv nw nx b">sailmysql</code>。这种类型的卷必须在单独的<code class="fe nu nv nw nx b">volumes</code>部分声明，与<code class="fe nu nv nw nx b">services</code>处于同一级别。我们可以在<code class="fe nu nv nw nx b">docker-compose.yml</code>文件的底部找到它:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="ebf0" class="ny my it nx b gy oo op l oq or">volumes:<br/>    sailmysql:<br/>        driver: local<br/>    sailredis:<br/>        driver: local<br/>    sailmeilisearch:<br/>        driver: local</span></pre><p id="6713" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">sailmysql</code>卷被映射到容器的<code class="fe nu nv nw nx b">/var/lib/mysql</code>文件夹，这是MySQL数据存储的地方。这个卷确保了即使在容器被销毁时数据也是持久的，当我们运行<code class="fe nu nv nw nx b">sail down</code>命令时就是这种情况。</p><p id="636d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">networks</code>部分允许我们指定容器应该在哪个内部网络上可用。这里，所有服务都连接到同一个<code class="fe nu nv nw nx b">sail</code>网络，该网络也在<code class="fe nu nv nw nx b">docker-compose.yml</code>的底部定义，在<code class="fe nu nv nw nx b">volumes</code>网络上方的<code class="fe nu nv nw nx b">networks</code>部分:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="896d" class="ny my it nx b gy oo op l oq or">networks:<br/>    sail:<br/>        driver: bridge</span></pre><p id="f25a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">最后，<code class="fe nu nv nw nx b">healthcheck</code>是一种指示服务准备好需要满足哪些条件的方式，而不是仅仅从<em class="kz">开始</em>。我很快会回到这个话题。</p><h2 id="6e46" class="ny my it bd mz nz oa dn nd ob oc dp nh ms od oe nj mt of og nl mu oh oi nn oj bi translated"><code class="fe nu nv nw nx b">redis</code>服务</h2><p id="ae87" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated"><code class="fe nu nv nw nx b">redis</code>服务与<code class="fe nu nv nw nx b">mysql</code>服务非常相似:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="8269" class="ny my it nx b gy oo op l oq or">redis:<br/>    image: 'redis:alpine'<br/>    ports:<br/>        - '${FORWARD_REDIS_PORT:-6379}:6379'<br/>    volumes:<br/>        - 'sailredis:/data'<br/>    networks:<br/>        - sail<br/>    healthcheck:<br/>        test: ["CMD", "redis-cli", "ping"]</span></pre><p id="c291" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们为Redis ( <a class="ae lu" href="https://alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> Alpine是一个轻量级的Linux发行版【</a>)拉出<a class="ae lu" href="https://hub.docker.com/_/redis" rel="noopener ugc nofollow" target="_blank">官方镜像</a>的<code class="fe nu nv nw nx b">alpine</code>标签，并定义转发哪个端口；然后，我们声明一个卷来使数据持久化，将容器连接到<code class="fe nu nv nw nx b">sail</code>网络，并定义要执行的检查，以便认为服务就绪。</p><h2 id="6edc" class="ny my it bd mz nz oa dn nd ob oc dp nh ms od oe nj mt of og nl mu oh oi nn oj bi translated"><code class="fe nu nv nw nx b">laravel.test</code>服务</h2><p id="1b96" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated"><code class="fe nu nv nw nx b">laravel.test</code>服务更加复杂:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="22ad" class="ny my it nx b gy oo op l oq or">laravel.test:<br/>    build:<br/>        context: ./vendor/laravel/sail/runtimes/8.0<br/>        dockerfile: Dockerfile<br/>        args:<br/>            WWWGROUP: '${WWWGROUP}'<br/>    image: sail-8.0/app<br/>    ports:<br/>        - '${APP_PORT:-80}:80'<br/>    environment:<br/>        WWWUSER: '${WWWUSER}'<br/>        LARAVEL_SAIL: 1<br/>    volumes:<br/>        - '.:/var/www/html'<br/>    networks:<br/>        - sail<br/>    depends_on:<br/>        - mysql<br/>        - redis<br/>        - selenium</span></pre><p id="ec3a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">对于初学者来说，这个名字有点混乱，但是这个服务就是处理PHP的服务(即服务于Laravel应用程序的服务)。</p><p id="2d02" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">接下来，它有一个我们以前没见过的<code class="fe nu nv nw nx b">build</code>键，指向<code class="fe nu nv nw nx b">vendor/laravel/sail/runtimes/8.0</code>文件夹下的<code class="fe nu nv nw nx b"><a class="ae lu" href="https://github.com/laravel/sail/blob/1.x/runtimes/8.0/Dockerfile" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code>。</p><p id="6427" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfiles </a>是包含构建图像指令的文本文档。Laravel团队没有直接从Docker Hub中提取和使用现有的图像，而是选择在Docker文件中描述他们自己的图像。第一次运行<code class="fe nu nv nw nx b">sail up</code>命令时，我们构建了这个映像并基于它创建了一个容器。</p><p id="a2c6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">打开docker文件，看看第一行:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="cd09" class="ny my it nx b gy oo op l oq or">FROM ubuntu:20.04</span></pre><p id="0be9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">这意味着<code class="fe nu nv nw nx b"><a class="ae lu" href="https://hub.docker.com/_/ubuntu" rel="noopener ugc nofollow" target="_blank">ubuntu</a></code> <a class="ae lu" href="https://hub.docker.com/_/ubuntu" rel="noopener ugc nofollow" target="_blank">图像</a>的标签<code class="fe nu nv nw nx b">20.04</code>被用作自定义图像的起点；文件的其余部分本质上是一个构建它的指令列表，安装标准Laravel应用程序需要的所有东西。这包括PHP、各种扩展和其他包，如Git或Supervisor，以及Composer。</p><p id="f007" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">文件的结尾也值得快速解释一下:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="abe1" class="ny my it nx b gy oo op l oq or">COPY start-container /usr/local/bin/start-container<br/>COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf<br/>COPY php.ini /etc/php/8.0/cli/conf.d/99-sail.ini<br/>RUN chmod +x /usr/local/bin/start-container</span><span id="de4a" class="ny my it nx b gy os op l oq or">EXPOSE 8000</span><span id="f84d" class="ny my it nx b gy os op l oq or">ENTRYPOINT [ "start-container" ]</span></pre><p id="666a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们可以看到一堆本地文件被复制到容器中:</p><ul class=""><li id="d6d7" class="ot ou it la b lb lc le lf ms ov mt ow mu ox lt oy oz pa pb bi translated"><code class="fe nu nv nw nx b"><a class="ae lu" href="https://github.com/laravel/sail/blob/1.x/runtimes/8.0/php.ini" rel="noopener ugc nofollow" target="_blank">php.ini</a></code>文件是PHP的一些定制配置；</li><li id="f249" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated"><code class="fe nu nv nw nx b"><a class="ae lu" href="https://github.com/laravel/sail/blob/1.x/runtimes/8.0/supervisord.conf" rel="noopener ugc nofollow" target="_blank">supervisord.conf</a></code>文件是<a class="ae lu" href="http://supervisord.org/" rel="noopener ugc nofollow" target="_blank">主管</a>的配置文件，这里的进程管理器负责启动PHP进程；</li><li id="26fc" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated"><code class="fe nu nv nw nx b"><a class="ae lu" href="https://github.com/laravel/sail/blob/1.x/runtimes/8.0/start-container" rel="noopener ugc nofollow" target="_blank">start-container</a></code>文件是一个Bash脚本，它将在容器每次启动时做一些事情，因为它被定义为容器的<a class="ae lu" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank">入口点</a>。我们可以看到它是由<code class="fe nu nv nw nx b">RUN chmod +x</code>指令执行的；</li><li id="3efa" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated">最后，<code class="fe nu nv nw nx b">EXPOSE 8000</code>不做任何事情，除了通知读者这个容器在运行时监听指定的端口(这实际上在这里似乎是错误的，因为应用程序是在端口80而不是8000上服务的)。</li></ul><p id="acda" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">这个Other文件中还发生了其他事情，但以上是它的要点。请注意，这一个属于PHP 8.0，但Laravel Sail也附带了一个<a class="ae lu" href="https://github.com/laravel/sail/blob/1.x/runtimes/7.4/Dockerfile" rel="noopener ugc nofollow" target="_blank"> 7.4版本</a>，您可以改为从<code class="fe nu nv nw nx b">docker-compose.yml</code>中的<code class="fe nu nv nw nx b">laravel.test</code>服务指向。</p><p id="35ac" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">该服务还有一个<code class="fe nu nv nw nx b">depends_on</code>部分，包含其容器应该在Laravel应用程序之前准备好的服务列表。因为后者引用了MySQL、Redis和Selenium，所以它们的应该首先启动并准备好，以避免连接错误。</p><p id="d513" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">这就是前面描述的健康检查有用的地方:默认情况下<code class="fe nu nv nw nx b">depends_on</code>将等待指定的服务被<em class="kz">启动</em>，这不一定意味着它们已经<em class="kz">就绪</em>。通过指定这些服务在哪些条件下被认为是就绪的，我们确保它们在启动Laravel应用程序之前处于正确的状态。</p><p id="a813" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">其余的设置现在应该很熟悉了，所以我就跳过它们。</p><h2 id="7fb3" class="ny my it bd mz nz oa dn nd ob oc dp nh ms od oe nj mt of og nl mu oh oi nn oj bi translated"><code class="fe nu nv nw nx b">mailhog and selenium </code>meilisearch，服务</h2><p id="861e" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">这些是我前面提到的较小的服务；这里的<a class="ae lu" href="https://laravel.com/docs/sail#meilisearch" rel="noopener ugc nofollow" target="_blank">这里的</a>，这里的<a class="ae lu" href="https://laravel.com/docs/sail#previewing-emails" rel="noopener ugc nofollow" target="_blank">这里的</a>和<a class="ae lu" href="https://laravel.com/docs/sail#laravel-dusk" rel="noopener ugc nofollow" target="_blank">这里的</a>都已经记录下来了。关键是它们的工作方式和其他的一样:它们从Docker Hub中提取现有的图像，并使用它们，只需要最少的配置。</p><h1 id="b6cf" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><code class="fe nu nv nw nx b">sail</code>剧本</h1><p id="7ff1" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">如果您按照<a class="ae lu" href="https://tech.osteel.me/posts/(https://laravel.com/docs/installation#your-first-laravel-project)" rel="noopener ugc nofollow" target="_blank"> Laravel针对您的操作系统的安装说明</a>，您一定在某个时候运行了以下命令:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="06e6" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail up</span></pre><p id="fd75" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们在这里称之为<code class="fe nu nv nw nx b"><a class="ae lu" href="https://github.com/laravel/sail/blob/1.x/bin/sail" rel="noopener ugc nofollow" target="_blank">sail</a></code>的文件是一个Bash脚本，本质上是在冗长的Docker命令之上添加了一个更加用户友好的层。</p><p id="a4b1" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">现在让我们打开它进行更仔细的检查(如果您不熟悉Bash，也不用担心——它非常简单)。</p><p id="5bd2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们可以忽略文件的整个第一部分，而专注于开头如下的大的<code class="fe nu nv nw nx b">if</code>语句:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="369e" class="ny my it nx b gy oo op l oq or">if [ $# -gt 0 ]; then<br/>    # Source the ".env" file so Laravel's environment variables are available...<br/>    if [ -f ./.env ]; then<br/>        source ./.env<br/>    fi<br/>    # ...</span></pre><p id="c628" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">简单地说，<code class="fe nu nv nw nx b">$# -gt 0</code>位翻译成“如果参数的数量大于0”，这意味着每当我们调用带有参数的<code class="fe nu nv nw nx b">sail</code>脚本时，执行将进入那个<code class="fe nu nv nw nx b">if</code>语句。</p><p id="e7dd" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">换句话说，当我们运行<code class="fe nu nv nw nx b">./vendor/bin/sail up</code>命令时，我们用<code class="fe nu nv nw nx b">up</code>参数调用<code class="fe nu nv nw nx b">sail</code>脚本，执行进入大的<code class="fe nu nv nw nx b">if</code>语句，在那里寻找与<code class="fe nu nv nw nx b">up</code>参数匹配的条件。因为没有，所以脚本一直到大<code class="fe nu nv nw nx b">if</code>的结尾，在那种我们可以找到的包罗万象的<code class="fe nu nv nw nx b">else</code>中:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="20d7" class="ny my it nx b gy oo op l oq or"># Pass unknown commands to the "docker-compose" binary...<br/>else<br/>    docker-compose "$@"<br/>fi</span></pre><p id="8061" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">注释已经描述了正在发生的事情——脚本将<code class="fe nu nv nw nx b">up</code>参数传递给<code class="fe nu nv nw nx b">docker-compose</code>二进制文件。换句话说，当我们运行<code class="fe nu nv nw nx b">./vendor/bin/sail up</code>时，我们实际上运行的是<code class="fe nu nv nw nx b">docker-compose up</code>，这是<a class="ae lu" href="https://docs.docker.com/compose/reference/up/" rel="noopener ugc nofollow" target="_blank">标准Docker编写命令</a>，为<code class="fe nu nv nw nx b">docker-compose.yml</code>中列出的服务启动容器。</p><p id="4b79" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">如有必要，该命令首先下载相应的映像，并根据我们前面讨论的Dockerfile构建Laravel映像。</p><p id="372c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">试试看！运行<code class="fe nu nv nw nx b">./vendor/bin/sail up</code>然后<code class="fe nu nv nw nx b">docker-compose up</code>——他们做同样的事情。</p><p id="e76b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">现在让我们看一个更复杂的例子，一个涉及Composer的例子，它是应用程序Dockerfile安装的包之一。但在此之前，让我们以<a class="ae lu" href="https://laravel.com/docs/sail#starting-and-stopping-sail" rel="noopener ugc nofollow" target="_blank">分离模式</a>在后台运行容器:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="79f1" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail up -d</span></pre><p id="f1e8" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">sail</code>脚本允许我们运行Composer命令，例如:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="e3b1" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail composer --version</span></pre><p id="8c4f" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">上面用<code class="fe nu nv nw nx b">composer</code>和<code class="fe nu nv nw nx b">--version</code>作为参数调用了<code class="fe nu nv nw nx b">sail</code>脚本，这意味着执行将再次进入那个大的<code class="fe nu nv nw nx b">if</code>语句。</p><p id="6f0f" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">让我们搜索与Composer相关的条件:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="5986" class="ny my it nx b gy oo op l oq or"># ...<br/># Proxy Composer commands to the "composer" binary on the application container...<br/>elif [ "$1" == "composer" ]; then<br/>    shift 1<br/><br/>    if [ "$EXEC" == "yes" ]; then<br/>        docker-compose exec \<br/>            -u sail \<br/>            "$APP_SERVICE" \<br/>            composer "$@"<br/>    else<br/>        sail_is_not_running<br/>    fi<br/>    # ...</span></pre><p id="3281" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">条件的第一行以<code class="fe nu nv nw nx b">shift</code>开始，这是一个内置的Bash<em class="kz">，它跳过了和它后面的数字一样多的参数。在这种情况下，<code class="fe nu nv nw nx b">shift 1</code>跳过<code class="fe nu nv nw nx b">composer</code>参数，使<code class="fe nu nv nw nx b">--version</code>成为新的第一个参数。然后，该程序确保Sail正在运行，然后执行一个奇怪的命令，该命令分为四行，我将其分解如下:</em></p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="853b" class="ny my it nx b gy oo op l oq or">docker-compose exec \<br/>    -u sail \<br/>    "$APP_SERVICE" \<br/>    composer "$@"</span></pre><p id="877c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">Docker Compose允许我们在已经运行的容器上执行命令。<code class="fe nu nv nw nx b">-u</code>是一个选项，指示我们希望以哪个用户的身份执行命令，<code class="fe nu nv nw nx b">$APP_SERVICE</code>是我们希望在其上运行命令的容器。这里，它的值是<code class="fe nu nv nw nx b">laravel.test</code>，这是服务在<code class="fe nu nv nw nx b">docker-compose.yml</code>中的名称，如前一节所述。它后面是我们在容器中想要运行的命令，即<code class="fe nu nv nw nx b">composer</code>，后面是脚本的所有参数。这些现在只包括<code class="fe nu nv nw nx b">--version</code>，因为我们已经跳过了第一个参数。</p><p id="d1e9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">换句话说，当我们跑步时:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="638a" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail composer --version</span></pre><p id="e91e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">在后台执行的命令如下:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="c55b" class="ny my it nx b gy oo op l oq or">$ docker-compose exec -u sail "laravel.test" composer "--version"</span></pre><p id="823a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">每次都键入这种命令会很麻烦；这就是为什么<code class="fe nu nv nw nx b">sail</code>脚本为它们提供了快捷方式，让用户体验更加流畅。</p><p id="7b9b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">看看大语句中其余较小的<code class="fe nu nv nw nx b">if</code>语句，看看还包括了什么——你会发现大致相同的原则适用于任何地方。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="3a74" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">还有其他一些现成的特性(比如<a class="ae lu" href="https://laravel.com/docs/sail#sharing-your-site" rel="noopener ugc nofollow" target="_blank">公开本地容器</a>，但是我们现在已经介绍了Laravel Sail目前提供的内容。虽然这已经是一个很好的开始，但是它还是有一定的局限性，即使对于一个基本的应用程序来说也是如此。</p><p id="9770" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">好消息是Laravel团队意识到了这一点，并在构建环境时考虑了扩展:</p><blockquote class="lv"><p id="ec70" class="lw lx it bd ly lz mg mh mi mj mk lt dk translated">由于Sail只是一个Docker，你可以自由地定制它的任何东西。</p><p id="bdf3" class="lw lx it bd ly lz mg mh mi mj mk lt dk translated"><em class="mf">–</em><a class="ae lu" href="https://laravel.com/docs/sail#sail-customization" rel="noopener ugc nofollow" target="_blank"><em class="mf">拉里韦尔文档</em> </a></p></blockquote><p id="c05d" class="pw-post-body-paragraph kx ky it la b lb ph ju ld le pi jx lg ms pj lj lk mt pk ln lo mu pl lr ls lt im bi translated">让我们看看这在实践中意味着什么。</p><h1 id="6f8e" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">展开拉勒维尔帆</h1><p id="01d7" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">本节中的代码也可以作为GitHub库随时查阅。</p><p id="7db4" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们将探索三种扩展Laravel Sail的方法，以<a class="ae lu" href="https://www.mongodb.com" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>为借口；但在我们继续之前，让我们确保尽可能多的拿到文件。</p><p id="3457" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们最初唯一可以访问的是<code class="fe nu nv nw nx b"><a class="ae lu" href="https://github.com/laravel/sail/blob/1.x/stubs/docker-compose.stub" rel="noopener ugc nofollow" target="_blank">docker-compose.yml</a></code>文件，但是我们可以使用下面的命令发布更多的资产，这将在项目的根目录下创建一个新的<code class="fe nu nv nw nx b">docker</code>文件夹:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="d959" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail artisan sail:publish</span></pre><p id="2807" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们一会儿会回到这些。目前，让我们试着安装<a class="ae lu" href="https://github.com/jenssegers/laravel-mongodb" rel="noopener ugc nofollow" target="_blank"> Laravel MongoDB </a>包，它将使MongoDB与我们最喜欢的框架一起使用变得容易:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="7328" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail composer require jenssegers/mongodb</span></pre><p id="59a7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">不幸的是，Composer抱怨缺少一些扩展:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="6083" class="ny my it nx b gy oo op l oq or">mongodb/mongodb[dev-master, 1.8.0-RC1, ..., v1.8.x-dev] require ext-mongodb ^1.8.1 -&gt; it is missing from your system. Install or enable PHP's mongodb extension</span></pre><p id="495b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">让我们来解决这个问题！</p><h1 id="66f0" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">安装额外的扩展</h1><p id="2fbb" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">在这篇文章的前面，我们讨论了Sail如何使用Dockerfiles构建符合Laravel对PHP 7.4和PHP 8.0的要求的图像。这些文件是用我们在本节开始时运行的命令发布的——我们添加扩展所需要做的就是编辑它们并重建相应的映像。</p><p id="7067" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">许多扩展都是现成可用的，我们可以使用以下命令列出它们:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="96f8" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail php -m</span></pre><p id="0095" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">MongoDB不是它们的一部分；要添加它，打开<code class="fe nu nv nw nx b">docker/8.0/Dockerfile</code>文件，找到安装各种包的<code class="fe nu nv nw nx b">RUN</code>指令:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="c5c7" class="ny my it nx b gy oo op l oq or">RUN apt-get update \<br/>    &amp;&amp; apt-get install -y gnupg gosu curl ca-certificates zip unzip git supervisor sqlite3 libcap2-bin \<br/>    &amp;&amp; mkdir -p ~/.gnupg \<br/>    &amp;&amp; echo "disable-ipv6" &gt;&gt; ~/.gnupg/dirmngr.conf \<br/>    &amp;&amp; apt-key adv --homedir ~/.gnupg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys E5267A6C \<br/>    &amp;&amp; apt-key adv --homedir ~/.gnupg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C300EE8C \<br/>    &amp;&amp; echo "deb http://ppa.launchpad.net/ondrej/php/ubuntu focal main" &gt; /etc/apt/sources.list.d/ppa_ondrej_php.list \<br/>    &amp;&amp; apt-get update \<br/>    &amp;&amp; apt-get install -y php8.0-cli php8.0-dev \<br/>       php8.0-pgsql php8.0-sqlite3 php8.0-gd \<br/>       php8.0-curl php8.0-memcached \<br/>       php8.0-imap php8.0-mysql php8.0-mbstring \<br/>       php8.0-xml php8.0-zip php8.0-bcmath php8.0-soap \<br/>       php8.0-intl php8.0-readline \<br/>       php8.0-msgpack php8.0-igbinary php8.0-ldap \<br/>       php8.0-redis \<br/>    &amp;&amp; php -r "readfile('http://getcomposer.org/installer');" | php -- --install-dir=/usr/bin/ --filename=composer \<br/>    &amp;&amp; curl -sL https://deb.nodesource.com/setup_15.x | bash - \<br/>    &amp;&amp; apt-get install -y nodejs \<br/>    &amp;&amp; apt-get -y autoremove \<br/>    &amp;&amp; apt-get clean \<br/>    &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/</span></pre><p id="c784" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">很容易识别与PHP扩展相关的块，因为它们都以<code class="fe nu nv nw nx b">php8.0</code>开头。修改列表的末尾，使其看起来像这样:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="f853" class="ny my it nx b gy oo op l oq or">php8.0-redis php8.0-mongodb \</span></pre><p id="6c32" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">你可以在这里看到Ubuntu 20.04可用PHP扩展的细节<a class="ae lu" href="https://packages.ubuntu.com/focal/php/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9f9b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">保存文件并运行以下命令:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="8d08" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail build</span></pre><p id="d82d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">这将遍历<code class="fe nu nv nw nx b">docker-compose.yml</code>文件中列出的所有服务，如果它们发生了变化，将构建相应的映像，包括<code class="fe nu nv nw nx b">laravel.test</code>服务，我们刚刚更新了它的Dockerfile。</p><p id="3945" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">完成后，再次启动容器:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="da4e" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail up -d</span></pre><p id="e6a3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">该命令将检测到对应于<code class="fe nu nv nw nx b">laravel.test</code>服务的映像已经改变，并重新创建容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/a26d0c96f97d3e349bce05bf56fd5cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*UH9L8ssWIx8PXhTU.png"/></div></figure><p id="a9f1" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">就是这样！现在已经安装并启用了PHP的MongoDB扩展。我们只为PHP 8.0镜像做了这件事，但是你可以通过更新<code class="fe nu nv nw nx b">docker/7.4/Dockerfile</code>文件，用<code class="fe nu nv nw nx b">php7.4-mongodb</code>作为扩展名，将同样的过程应用于PHP 7.4。</p><p id="f64c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们现在可以安全地导入Laravel包了:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="d2eb" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail composer require jenssegers/mongodb</span></pre><p id="dfcd" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">接下来:为MongoDB添加Docker服务。</p><h1 id="ce64" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">添加新服务</h1><p id="892c" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">MongoDB本质上是另一个数据库；因此，相应的服务将与MySQL和Redis非常相似。在<a class="ae lu" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>上快速搜索会发现<a class="ae lu" href="https://hub.docker.com/_/mongo" rel="noopener ugc nofollow" target="_blank">有它的官方图片</a>，我们将使用它。</p><p id="5af1" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">它的文档包含一个Docker Compose的示例配置，我们可以根据需要复制和调整它。打开<code class="fe nu nv nw nx b">docker-compose.yml</code>，在其他服务之后，在底部添加以下服务:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="1f83" class="ny my it nx b gy oo op l oq or">mongo:<br/>    image: 'mongo:4.4'<br/>    restart: always<br/>    environment:<br/>        MONGO_INITDB_ROOT_USERNAME: '${DB_USERNAME}'<br/>        MONGO_INITDB_ROOT_PASSWORD: '${DB_PASSWORD}'<br/>        MONGO_INITDB_DATABASE: '${DB_DATABASE}'<br/>    volumes:<br/>        - 'sailmongo:/data/db'<br/>    networks:<br/>        - sail</span></pre><p id="8ef9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我所做的更改如下:首先，我指定了<code class="fe nu nv nw nx b">mongo</code>图像的标签<code class="fe nu nv nw nx b">4.4</code>。如果不指定，Docker Compose将默认提取<code class="fe nu nv nw nx b">latest</code>标记，这不是一个好的做法，因为随着时间的推移，随着新版本的出现，它将引用不同版本的MongoDB。引入突破性的改变可能会导致Docker设置的不稳定性，所以最好瞄准一个特定的版本，尽可能匹配产品版本。</p><p id="1cd2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">然后，我为容器声明了一个<code class="fe nu nv nw nx b">MONGO_INITDB_DATABASE</code>环境变量，以便在启动时创建一个具有相应名称的数据库，并且我将每个环境变量的值与来自<code class="fe nu nv nw nx b">.env</code>文件的值进行匹配(我们稍后将回到这些)。</p><p id="fdd5" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我还添加了一个<code class="fe nu nv nw nx b">volumes</code>部分，将Docker管理的卷挂载到容器的<code class="fe nu nv nw nx b">/data/db</code>文件夹中。这里与MySQL和Redis相同的原理也适用:如果不在本地机器上持久化数据，那么每次MongoDB容器被销毁时，数据都会丢失。换句话说，由于MongoDB数据存储在容器的<code class="fe nu nv nw nx b">/data/db</code>文件夹中，我们使用一个卷在本地持久存储该文件夹。</p><p id="e301" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">由于该卷尚不存在，我们需要在<code class="fe nu nv nw nx b">docker-compose.yml</code>的底部声明它，在其他卷之后:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="4d42" class="ny my it nx b gy oo op l oq or">volumes:<br/>    sailmysql:<br/>        driver: local<br/>    sailredis:<br/>        driver: local<br/>    sailmeilisearch:<br/>        driver: local<br/>    sailmongo:<br/>        driver: local</span></pre><p id="8e49" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">最后，我添加了<code class="fe nu nv nw nx b">networks</code>部分，以确保该服务与其他服务在同一个网络上。</p><p id="4868" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们现在可以按照包的<a class="ae lu" href="https://github.com/jenssegers/laravel-mongodb#configuration" rel="noopener ugc nofollow" target="_blank">指令</a>配置Laravel MongoDB。打开<code class="fe nu nv nw nx b">config/database.php</code>并添加以下数据库连接:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="e9cd" class="ny my it nx b gy oo op l oq or">'mongodb' =&gt; [<br/>    'driver' =&gt; 'mongodb',<br/>    'host' =&gt; env('DB_HOST'),<br/>    'port' =&gt; env('DB_PORT'),<br/>    'database' =&gt; env('DB_DATABASE'),<br/>    'username' =&gt; env('DB_USERNAME'),<br/>    'password' =&gt; env('DB_PASSWORD'),<br/>    'options' =&gt; [<br/>        'database' =&gt; env('DB_AUTHENTICATION_DATABASE', 'admin'),<br/>    ],<br/>],</span></pre><p id="2f60" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">打开项目根目录下的<code class="fe nu nv nw nx b">.env</code>文件，并按如下方式更改数据库值:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="bf95" class="ny my it nx b gy oo op l oq or">DB_CONNECTION=mongodb<br/>DB_HOST=mongo<br/>DB_PORT=27017<br/>DB_DATABASE=laravel_sail<br/>DB_USERNAME=root<br/>DB_PASSWORD=root</span></pre><p id="c5e3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">以上使得MongoDB成为主要的数据库连接；在一个真实的场景中，您可能希望使它成为一个像Redis一样的辅助数据库，但是出于演示的目的，这也可以。</p><p id="ab35" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">DB_HOST</code>是来自<code class="fe nu nv nw nx b">docker-compose.yml</code>的MongoDB服务的名称；在幕后，Docker Compose将服务的名称解析为它所管理的网络上的容器的IP(在我们的例子中，这是在<code class="fe nu nv nw nx b">docker-compose.yml</code>结束时定义的单个<code class="fe nu nv nw nx b">sail</code>网络)。</p><p id="0cd4" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">DB_PORT</code>是MongoDB可用的端口，根据<a class="ae lu" href="https://hub.docker.com/_/mongo" rel="noopener ugc nofollow" target="_blank">图片的描述</a>，默认为<code class="fe nu nv nw nx b">27017</code>。</p><p id="ce40" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们准备好测试了！再次运行以下命令:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="453a" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail up -d</span></pre><p id="e421" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">它将下载MongoDB的映像，创建新的卷并启动新的容器，这也将创建<code class="fe nu nv nw nx b">laravel_sail</code>数据库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/5b644f40908b64aa490e18d331c070ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vxX50XN9-_PKRm-W.png"/></div></div></figure><p id="a5e3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">让我们通过运行Laravel的默认迁移来确保这一点:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="f6ae" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail artisan migrate</span></pre><p id="7080" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们可以通过更新<code class="fe nu nv nw nx b">User</code>模型来进一步推动测试，因此<a class="ae lu" href="https://github.com/jenssegers/laravel-mongodb#extending-the-authenticable-base-model" rel="noopener ugc nofollow" target="_blank">扩展了</a> Laravel MongoDB的<code class="fe nu nv nw nx b">Authenticable</code>模型:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="cea7" class="ny my it nx b gy oo op l oq or">&lt;?php<br/><br/>namespace App\Models;<br/><br/>use Illuminate\Contracts\Auth\MustVerifyEmail;<br/>use Illuminate\Database\Eloquent\Factories\HasFactory;<br/>use Illuminate\Notifications\Notifiable;<br/>use Jenssegers\Mongodb\Auth\User as Authenticatable;<br/><br/>class User extends Authenticatable<br/>{<br/>    // ...</span></pre><p id="4b82" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">使用Tinker尝试创建一个模型:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="95df" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail tinker</span><span id="4dbd" class="ny my it nx b gy os op l oq or">Psy Shell v0.10.5 (PHP 8.0.0 - cli) by Justin Hileman<br/>&gt;&gt;&gt; \App\Models\User::factory()-&gt;create();</span></pre><p id="3248" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">太好了！我们的MongoDB集成是有效的。</p><p id="c913" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们可以使用Tinker和口才与它保持交互，但通常通过第三方软件或通过命令行界面(如<a class="ae lu" href="https://docs.mongodb.com/manual/mongo/" rel="noopener ugc nofollow" target="_blank"> Mongo shell </a>)直接访问数据库是有用的。</p><p id="7e39" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">让我们将后者添加到我们的设置中。</p><h1 id="6dd8" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">自定义<code class="fe nu nv nw nx b">sail</code>命令</h1><p id="1cbf" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">好消息是，只要我们知道召唤它的正确方法，Mongo外壳就已经存在了。下面是一些额外的命令(用粗体突出显示)，用于登录数据库并列出用户(从项目的根目录运行第一个命令):</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="5341" class="ny my it nx b gy oo op l oq or">$ docker-compose exec mongo mongo<br/><br/>MongoDB shell version v4.4.2<br/>connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb<br/>Implicit session: session { "id" : UUID("919072cf-817d-43a6-9ffb-c5e721eeefbc") }<br/>MongoDB server version: 4.4.2<br/>Welcome to the MongoDB shell.<br/>For interactive help, type "help".<br/>For more comprehensive documentation, see<br/>    https://docs.mongodb.com/<br/>Questions? Try the MongoDB Developer Community Forums<br/>    https://community.mongodb.com<br/><strong class="nx iu">&gt; use admin</strong><br/>switched to db admin<br/><strong class="nx iu">&gt; db.auth("root", "root")</strong><br/>1<br/><strong class="nx iu">&gt; use laravel_sail</strong><br/>switched to db laravel_sail<br/><strong class="nx iu">&gt; db.users.find()</strong></span></pre><p id="9233" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">docker-compose exec mongo mongo</code>命令看起来应该很熟悉；在本文的前面，我们看到了<code class="fe nu nv nw nx b">sail</code>脚本在幕后做了什么，主要包括将简单的<code class="fe nu nv nw nx b">sail</code>命令翻译成更复杂的<code class="fe nu nv nw nx b">docker-compose</code>命令。这里，我们告诉<code class="fe nu nv nw nx b">docker-compose</code>二进制文件在<code class="fe nu nv nw nx b">mongo</code>容器上执行<code class="fe nu nv nw nx b">mongo</code>命令。</p><p id="dcc3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">公平地说，这个命令并不太糟糕，我们可以很容易地记住它；但是为了保持一致性，最好有一个更简单的等价的<code class="fe nu nv nw nx b">sail</code>,如下所示:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="8c1e" class="ny my it nx b gy oo op l oq or">$ ./vendor/bin/sail mongo</span></pre><p id="7b0a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">为了实现这一点，我们需要以某种方式完成<code class="fe nu nv nw nx b">sail</code>脚本，但是由于它位于<code class="fe nu nv nw nx b">vendor</code>文件夹中——它是由Composer创建的——我们不能直接更新它。我们需要一种在不修改它的情况下构建它的方法，我总结如下:</p><ol class=""><li id="094e" class="ot ou it la b lb lc le lf ms ov mt ow mu ox lt po oz pa pb bi translated">在项目的根目录下复制一份<code class="fe nu nv nw nx b">sail</code>脚本；</li><li id="c3dd" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt po oz pa pb bi translated">用自定义条件替换其大<code class="fe nu nv nw nx b">if</code>语句的内容；</li><li id="bb2c" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt po oz pa pb bi translated">如果没有一个定制条件与当前参数匹配，那么将它们传递给原始的<code class="fe nu nv nw nx b">sail</code>脚本。</li></ol><p id="9630" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">如果我们仔细看看带有<code class="fe nu nv nw nx b">ls -al</code>的<code class="fe nu nv nw nx b">sail</code>文件，我们可以看到它是一个到<code class="fe nu nv nw nx b">vendor/laravel/sail/bin/sail</code>文件的符号链接:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/1194da91224cce5510ad44f7924e6fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8Ismli0o6tbCfMIa.png"/></div></div></figure><p id="bddf" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">现在让我们将该文件复制到项目的根目录:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="b2c2" class="ny my it nx b gy oo op l oq or">$ cp vendor/laravel/sail/bin/sail .</span></pre><p id="a912" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">打开新副本，将大<code class="fe nu nv nw nx b">if</code>的内容替换为以下内容，其余内容保持不变:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="c4e7" class="ny my it nx b gy oo op l oq or">if [ $# -gt 0 ]; then<br/>    # Source the ".env" file so Laravel's environment variables are available...<br/>    if [ -f ./.env ]; then<br/>        source ./.env<br/>    fi<br/><br/>    # Initiate a Mongo shell terminal session within the "mongo" container...<br/>    if [ "$1" == "mongo" ]; then<br/><br/>        if [ "$EXEC" == "yes" ]; then<br/>            docker-compose exec mongo mongo<br/>        else<br/>            sail_is_not_running<br/>        fi<br/><br/>    # Pass unknown commands to the original "sail" script..<br/>    else<br/>        ./vendor/bin/sail "$@"<br/>    fi<br/>fi</span></pre><p id="4ba2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">在上面的代码中，我们删除了big <code class="fe nu nv nw nx b">if</code>中的所有<code class="fe nu nv nw nx b">if...else</code>条件，并添加了一个我们自己的条件，如果脚本的第一个参数的值是<code class="fe nu nv nw nx b">mongo</code>，它将运行我们之前用来访问Mongo shell的命令。如果不是，执行将命中最后一个<code class="fe nu nv nw nx b">else</code>语句，并调用带有所有参数的原始<code class="fe nu nv nw nx b">sail</code>脚本。</p><p id="44b6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">您现在可以尝试一下——保存文件并运行以下命令:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="ec81" class="ny my it nx b gy oo op l oq or">$ ./sail mongo</span></pre><p id="c975" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">它应该会在您的终端中打开一个Mongo shell会话。</p><p id="544d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">尝试另一个命令，以确保原始的<code class="fe nu nv nw nx b">sail</code>脚本在它应该:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="b12e" class="ny my it nx b gy oo op l oq or">$ ./sail artisan</span></pre><p id="64f2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">应显示Artisan菜单。</p><p id="417d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">就是这样！如果您需要更多的命令，您可以将它们作为新的<code class="fe nu nv nw nx b">if...else</code>条件添加到项目根目录下的<code class="fe nu nv nw nx b">sail</code>脚本副本的大<code class="fe nu nv nw nx b">if</code>中。</p><p id="bfe0" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">它以完全相同的方式工作，除了您现在需要运行<code class="fe nu nv nw nx b">./sail</code>而不是<code class="fe nu nv nw nx b">./vendor/bin/sail</code>(或者更新您的Bash别名，如果您按照<a class="ae lu" href="https://laravel.com/docs/sail#configuring-a-bash-alias" rel="noopener ugc nofollow" target="_blank">文档</a>中的建议创建了一个的话)。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="47d2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">作为Docker设置的一部分，我们现在运行一个MongoDB的全功能实例，与Laravel Sail很好地集成在一起。但是MongoDB在这里只是一个例子——几乎任何你想使用的技术都可以做到这一点。</p><p id="adc9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">快去<a class="ae lu" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank">看看</a>！大多数主要演员都有Docker图像(官方或社区维护的)，并有易于遵循的说明。在大多数情况下，您将在几分钟内拥有一个运行该软件的本地实例。</p><p id="ed73" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们可能还可以做更多的事情来定制Laravel Sail，但是上面描述的三种方法应该已经帮了你很大的忙了。</p><p id="35de" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">在这个阶段，您可能会认为Laravel的新环境有很多优点，甚至比您最初想象的还要多。然而，本文的重点是避免使用它…</p><p id="4e4f" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">那么，我该怎么做呢？</p><blockquote class="ku kv kw"><p id="cb71" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">为什么不用外卖？</strong></p><p id="9975" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在阅读本节时，您可能会想到，像<a class="ae lu" href="https://tech.osteel.me/posts/you-dont-need-laravel-sail" rel="noopener ugc nofollow" target="_blank">外卖</a>这样的现有解决方案会立即支持MongoDB。虽然将Sail与其他技术结合使用是<a class="ae lu" href="https://mattstauffer.com/blog/how-to-use-takeout-to-add-new-services-to-laravel-sail-and-save-ram/" rel="noopener ugc nofollow" target="_blank">可能的</a>并且会弥补它目前的一些限制，但是依赖外卖会重新引入对第三方的依赖。我们希望团队中的每个人都在他们的机器上安装和配置外卖，而不仅仅是使用Docker。</p><p id="0db1" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Sail为整个开发环境由作为代码库一部分的单个<code class="fe nu nv nw nx b">docker-compose.yml</code>文件处理开辟了道路。我的观点是，如果我们走这条路，我们应该一直拥抱它，让Docker成为唯一的第三方依赖。</p><p id="064b" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这并不是说外卖没有任何用处；避免一些我们将在本文后面讨论的性能问题是很有意义的。</p></blockquote><h1 id="3f4c" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">拉沃尔·赛欧到底怎么了？</h1><p id="bc32" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">如果您已经走了这么远，您可能会想知道Laravel Sail有什么问题，现在已经清楚我们可以把它推进多远了。</p><p id="5153" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">让我现在就告诉你:一旦你知道并理解了我在前面几节中解释的所有内容，你就不再需要Laravel Sail了。</p><p id="39e4" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">没错——你可以带着这些知识离开。</p><p id="c675" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">但在我详细阐述之前，让我们回顾一下Sail的一些实际痛点，尽管我预计Laravel团队会尽快解决其中的大部分问题。</p><p id="ee87" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">第一个是关于定制的<code class="fe nu nv nw nx b">sail</code>命令:虽然可以像前面演示的那样扩展<code class="fe nu nv nw nx b">sail</code>脚本，但是这个过程有点难看，也有点粗糙。Sail的维护者可以通过一个显式的Bash扩展点来解决这个问题，允许用户添加他们自己的快捷方式，或者通过发布<code class="fe nu nv nw nx b">sail</code>脚本和其他文件来解决。</p><p id="8a32" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">其次，Laravel应用程序由PHP的开发服务器提供服务。我不会在这里讲太多细节，但是正如之前提到的<a class="ae lu" href="http://supervisord.org/" rel="noopener ugc nofollow" target="_blank"> Supervisor </a>管理<code class="fe nu nv nw nx b">laravel.test</code>容器中的PHP进程；<a class="ae lu" href="https://github.com/laravel/sail/blob/1.x/runtimes/8.0/supervisord.conf#L5" rel="noopener ugc nofollow" target="_blank">这一行</a>是Supervisor运行<code class="fe nu nv nw nx b">php artisan serve</code>命令的地方，它在幕后启动PHP的开发服务器。</p><p id="d601" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">这里的要点是，环境没有使用适当的网络服务器(如Nginx)，这意味着我们不能轻松地拥有本地域名，也不能将HTTPS带到设置中。这对于快速原型开发来说可能没问题，但是更复杂的开发很可能需要这些。</p><p id="21c0" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">第三个问题是我在尝试克隆和运行本文的<a class="ae lu" href="https://github.com/osteel/laravel-sail-extended" rel="noopener ugc nofollow" target="_blank">库</a>的一个新实例进行测试时注意到的。虽然基于Sail创建一个新的Laravel项目的过程运行良好，但我找不到安装和运行现有项目的正确说明。</p><p id="8a55" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">您不能运行<code class="fe nu nv nw nx b">./vendor/bin/sail up</code>，因为<code class="fe nu nv nw nx b">vendor</code>文件夹尚不存在。要创建这个文件夹，您需要运行<code class="fe nu nv nw nx b">composer install</code>；但是如果您的项目依赖于Docker映像上的依赖项，而不是本地机器上的依赖项，<code class="fe nu nv nw nx b">composer install</code>就不会工作。你可以转而运行<code class="fe nu nv nw nx b">composer install --ignore-platform-reqs</code>，但那感觉不对。应该有一种方法来安装和运行现有项目，而不依赖于本地Composer实例和笨重的命令。</p><p id="830b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">最后一个问题属于单独的类别，因为它与Docker整体相关，而不是Laravel Sail具体相关。在走上码头工人之路之前，它应该被仔细考虑，并且值得拥有自己的一部分。</p><h1 id="8f6b" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">船舱里的鲸鱼</h1><p id="46bf" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">迄今为止，对话中似乎没有提到的一个主要警告与性能有关。虽然这不应该影响Linux用户，但如果你在你的系统上运行Docker Desktop，你很可能会经历很长的加载时间，尤其是在macOS上(似乎在Windows上使用<a class="ae lu" href="https://docs.docker.com/docker-for-windows/wsl/" rel="noopener ugc nofollow" target="_blank"> WSL 2 </a>可以缓解缓慢)。</p><p id="94d7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">你现在就可以看到:如果你正在使用Docker桌面并且Sail正在运行，尝试加载<a class="ae lu" href="http://localhost" rel="noopener ugc nofollow" target="_blank"> Laravel欢迎页面</a>——你可能会注意到延迟。</p><p id="0b97" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我不会在这里做太多的详细介绍，但是原因主要来自主机的底层文件系统，它在挂载的本地目录周围不能很好地执行。正如我们所看到的，这就是Laravel Sail在Laravel应用程序的容器中获取应用程序源代码的方式，因此速度很慢。</p><p id="f3a9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">这就是像外卖这样的方法有意义的地方，因为他们不是从Docker容器运行PHP，而是希望开发人员在他们的本地机器上运行它(例如通过<a class="ae lu" href="https://laravel.com/docs/valet" rel="noopener ugc nofollow" target="_blank"> Valet </a>)，同时提供像MySQL或MongoDB这样的服务实例，从而在不牺牲性能的情况下提供便利。但在我看来，从你选择通过Docker容器运行PHP的那一刻起(就像Sail那样)，外卖的附加值就降低了。</p><p id="2461" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">有减轻这些性能问题的策略，但是Laravel文档中没有提到它们，更不用说性能可能是一个问题的事实了，这让我感到惊讶。</p><p id="27aa" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">也就是说，您可能对现有的性能已经足够满意了；就我而言，多年来我一直对它很满意，尽管我在macOS上使用Docker Desktop。底线是，在将您的整个设置迁移到一个在容器中运行PHP的解决方案之前，应该仔细考虑这一方面，无论是Laravel Sail还是其他什么。</p><p id="58ab" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">但是，一旦您做出了决定，无论其他问题最终是否得到解决，本文的主要思想都是一样的。</p><h1 id="7950" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">你不需要拉弗尔帆</h1><p id="c867" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">如果您正在考虑使用Laravel Sail作为您的开发环境来构建任何实质性的东西，迟早您将不得不扩展它。你会发现自己在docker文件中摸索，最终写出自己的文件；不得不向<code class="fe nu nv nw nx b">docker-compose.yml</code>添加一些服务；可能还会加入一些定制的Bash命令。</p><p id="1b90" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">一旦你到了那里，有一个问题你应该问自己:</p><blockquote class="lv"><p id="3cd7" class="lw lx it bd ly lz mg mh mi mj mk lt dk translated"><em class="mf">是什么阻止了我构建自己的系统？</em></p></blockquote><p id="ce7c" class="pw-post-body-paragraph kx ky it la b lb ph ju ld le pi jx lg ms pj lj lk mt pk ln lo mu pl lr ls lt im bi translated">答案是<em class="kz">没事</em>。一旦你对扩展Laravel Sail感到满意，你就已经具备了构建自己的环境所需的知识。</p><p id="3b53" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">想想看:<code class="fe nu nv nw nx b">docker-compose.yml</code>文件并不特定于Laravel Sail，这就是Docker Compose的工作方式。Docker文件也是如此——它们是标准的Docker文件。巴什层？这就是全部内容——一些Bash代码，如您所见，并不复杂。</p><p id="4687" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">那么为什么要人为的把自己约束在赛欧的约束之内呢？</p><p id="0dce" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">而且更重要的是:为什么要把自己限制在Laravel的上下文中使用Docker？</p><p id="e467" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">您的应用程序可能一开始就是一个整体，但也不总是如此。也许你有一个独立的前端，你使用Laravel作为API层。在这种情况下，您可能希望您的开发环境同时管理它们；同时运行它们，以便它们像在临时环境或生产环境中一样相互交互。</p><p id="fd66" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">如果你的整个应用程序是一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Monorepo" rel="noopener ugc nofollow" target="_blank"> monorepo </a>，你的Docker配置和Bash脚本可以在项目的根目录下，你可以将你的前端和后端应用程序放在单独的子文件夹中，例如在一个<code class="fe nu nv nw nx b">src</code>文件夹下。</p><p id="0953" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">相应的树视图如下所示:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="87aa" class="ny my it nx b gy oo op l oq or">my-app/<br/>├── bash-script<br/>├── docker-compose.yml<br/>└── src/<br/>    ├── backend/<br/>    │   └── Dockerfile<br/>    └── frontend/<br/>        └── Dockerfile</span></pre><p id="c0b1" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">docker-compose.yml</code>文件将声明两个服务——一个用于后端，一个用于前端——都指向各自的docker文件。</p><p id="6faf" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">如果后端和前端位于不同的存储库中，您可以创建第三个存储库，专门包含您的Docker开发环境。只需<em class="kz"> git-ignore </em> the <code class="fe nu nv nw nx b">src</code> folder并完成您的Bash脚本，以便它将两个应用程序存储库都拉入其中，使用您通常手动运行的相同命令。</p><p id="5d69" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">即使您的项目是一个Laravel monolith，这种结构也比将开发相关的文件与其余的源代码混合在一起要干净得多。此外，如果您的应用程序变得更大，并且除了Laravel之外还需要其他组件，那么您已经可以很好地支持它们。</p><p id="da88" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">一旦你努力理解Laravel Sail并对其进行扩展，就没有什么能阻止你构建自己的开发环境，<em class="kz">不管Laravel是否是等式的一部分</em>。没错，你可以为任何东西构建定制的基于Docker的环境。</p><p id="fd5f" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">如果Laravel是堆栈的一部分，如果您还不习惯编写自己的docker文件，没有什么可以阻止您重用Sail的docker文件；毕竟，它们已经针对Laravel进行了优化。同样，如果有帮助的话，你可以从Sail的<code class="fe nu nv nw nx b">docker-compose.yml</code>文件中获得灵感。</p><h1 id="3560" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">结论</h1><p id="079c" class="pw-post-body-paragraph kx ky it la b lb np ju ld le nq jx lg ms nr lj lk mt ns ln lo mu nt lr ls lt im bi translated">不要误解我的意思:Laravel Sail有很多优势，我很高兴看到这样一个成熟的演员推动Docker在本地开发中的应用。</p><p id="2ead" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">我们热爱我们的框架，因为它们提供了指导方针，以一种我们知道是有效的和经过战斗考验的方式来实现预期的结果，并且很自然地，它们也寻求提供允许它们的用户在其上构建的环境。但是Sail顺便告诉我们的一件事是，这已经不再是框架任务的一部分了。</p><p id="47b8" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">就像楚门的帆船帮助他克服对大海的恐惧，并把他带到他生活的人工世界的边缘，赛欧揭示了拉勒维尔的范围和逃离它们的方法。</p><p id="a9f4" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">你可能会觉得Sail已经足够满足你今天的需求，或者你还没有准备好走自己的路。那很好。但是Laravel总是受到其整体性的限制，随着您作为开发人员的成长，总有一天您的Laravel应用程序将只是一个更大系统的一个组件，对于它来说，Sail已经不够了。最终，你的小帆船会撞上一幅画的背景。</p><p id="9313" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">如果你想进一步探索这个问题，但又觉得需要更多的指导，我已经发表了关于这个主题的系列文章，应该可以让你开始。它不需要事先了解Docker，涵盖了web服务器、HTTPS、域名和许多其他东西。它没有所有的答案，但会带你到一个你可以找到自己的地方。</p><p id="8487" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated">接下来你做什么完全取决于你自己；只要知道外面有整个世界在等着你。</p><blockquote class="lv"><p id="5a2a" class="lw lx it bd ly lz mg mh mi mj mk lt dk translated"><em class="mf">楚门犹豫了。也许他终究无法坚持到底。镜头慢慢拉近杜鲁门的脸。</em></p><p id="a8b7" class="lw lx it bd ly lz mg mh mi mj mk lt dk translated">楚门:<em class="mf">“万一我见不到你——下午好，晚上好，晚安。”</em></p><p id="9389" class="lw lx it bd ly lz mg mh mi mj mk lt dk translated">他走进门，然后就不见了。</p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="d71e" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg ms li lj lk mt lm ln lo mu lq lr ls lt im bi translated"><em class="kz">本故事原载于</em><a class="ae lu" href="https://tech.osteel.me/posts/you-dont-need-laravel-sail" rel="noopener ugc nofollow" target="_blank"><em class="kz">tech . osteel . me</em></a><em class="kz">。</em></p><h1 id="a419" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">资源</h1><ul class=""><li id="a800" class="ot ou it la b lb np le nq ms pq mt pr mu ps lt oy oz pa pb bi translated"><a class="ae lu" href="https://laravel.com/docs/sail" rel="noopener ugc nofollow" target="_blank"> Laravel Sail文档</a></li><li id="c27d" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated"><a class="ae lu" href="https://github.com/laravel/sail" rel="noopener ugc nofollow" target="_blank"> Laravel帆库</a></li><li id="449b" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated"><a class="ae lu" href="https://github.com/osteel/laravel-sail-extended" rel="noopener ugc nofollow" target="_blank">本文的知识库</a></li><li id="ed05" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated"><a class="ae lu" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank">码头工人中心</a></li><li id="eb65" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated"><a class="ae lu" href="https://docs.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker文档</a></li><li id="c140" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated"><a class="ae lu" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank">Docker撰写概述</a></li><li id="2ee4" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated"><a class="ae lu" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">docker文件参考</a></li><li id="4233" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated"><a class="ae lu" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">什么是容器？</a></li><li id="ef06" class="ot ou it la b lb pc le pd ms pe mt pf mu pg lt oy oz pa pb bi translated"><a class="ae lu" href="https://tech.osteel.me/posts/docker-for-local-web-development-introduction-why-should-you-care" rel="noopener ugc nofollow" target="_blank"> Docker for local web开发系列</a></li></ul></div></div>    
</body>
</html>