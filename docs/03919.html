<html>
<head>
<title>Basic Python Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本Python数据结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basic-python-data-structures-1797aede5f6f?source=collection_archive---------32-----------------------#2020-06-01">https://levelup.gitconnected.com/basic-python-data-structures-1797aede5f6f?source=collection_archive---------32-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/583eb4aa5830d78b1dc7289b2cb84032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jKk_1A98uFqVzvZt"/></div></div></figure><p id="127d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大家好！在本文中，我将写一些可以在Python中找到的基本数据结构，以及一些实际的例子。</p><p id="3754" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据结构简单而有效。掌握这些技能对于成为优秀Python程序员至关重要。</p><p id="ad1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将讨论其中的两个:元组和列表。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f738" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">元组</h1><p id="6159" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">元组是不可变的，并且具有固定的大小。它们可以保存任何类型的值。</p><p id="84e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="feca" class="ms lh it mo b gy mt mu l mv mw">tup = 4,5,6<br/>print(tup);</span><span id="8e42" class="ms lh it mo b gy mx mu l mv mw"># (4,5,6)</span></pre><p id="520c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当创建更复杂的元组时，我们通常<strong class="kd iu">使用括号</strong>。在以下示例中，我们正在创建一个元组:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e197" class="ms lh it mo b gy mt mu l mv mw">nested_tup = (1,2,3), (7,8)<br/>print(nested_tup)</span><span id="af81" class="ms lh it mo b gy mx mu l mv mw"># ((1, 2, 3), (7, 8))</span></pre><p id="e38f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以<strong class="kd iu">将</strong>任何序列/迭代器转换成一个元组，调用<strong class="kd iu"> <em class="my"> tuple </em> </strong> <em class="my"> : </em></p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ccb884c944351b9e0ac62aa6fc2529a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*JB1CFrWcNP0Q6JfCziVlig.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">将字符串转换为元组</figcaption></figure><p id="99ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为一个元组是不可变的，所以你不能给一个元素赋值。将发生一个<em class="my">类型错误</em>。</p><p id="b00d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果一个元素是一个可变的对象，你可以改变它(例如，一个列表作为一个元组的元素):</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="090e" class="ms lh it mo b gy mt mu l mv mw">tup = tuple(['bar', [1,3], True])<br/>tup[1].append(5)<br/>print(tup)</span><span id="4361" class="ms lh it mo b gy mx mu l mv mw"># ('bar', [1, 3, 5], True)</span></pre><p id="be84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还可以<strong class="kd iu">连接元组</strong>，以及使用<strong class="kd iu">乘数符号</strong>(后者的行为是不复制值，只复制它们的引用):</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c61e" class="ms lh it mo b gy mt mu l mv mw">tup = (4, 'test', True) + (5,0)<br/>print(tup)</span><span id="0898" class="ms lh it mo b gy mx mu l mv mw"># (4, 'test', True, 5, 0)</span><span id="0d26" class="ms lh it mo b gy mx mu l mv mw">tup = ('foo', 'bar') * 4<br/>print(tup)</span><span id="46d4" class="ms lh it mo b gy mx mu l mv mw"># ('foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'bar')</span></pre><h1 id="434d" class="lg lh it bd li lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md bi translated">解包元组</h1><p id="cfc8" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Python可以使用一种非常直接的方法来<strong class="kd iu">解包元组:</strong></p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/6093b7fd66621e38e42ae1e28de6eb01.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*QPoATenvBUVuPVHYfdlydg.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">解包元组</figcaption></figure><p id="0aa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用这个Python功能，在变量之间交换值变得更加容易。在其他语言中，您可以编写类似如下的内容:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="0a7d" class="ms lh it mo b gy mt mu l mv mw">temp = a <br/>a = b<br/>b = temp</span></pre><p id="d3ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你必须有一个临时变量来保存第一个值。但是在Python中，你可以写这样的东西:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="181c" class="ms lh it mo b gy mt mu l mv mw">a, b = 1, 2<br/>a, b = b, a</span></pre><p id="905d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很整洁，对吧？</p><p id="c83d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解包最常见的事情之一是能够<strong class="kd iu">丢弃一个元组的一些元素</strong>并重用它的另一部分。举例来说，这样做效果更好:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="038e" class="ms lh it mo b gy mt mu l mv mw">values = 1,2,3,4,5,6<br/>a, b, *rest = values<br/>print(a)<br/>print(b)<br/>print(rest)</span><span id="b981" class="ms lh it mo b gy mx mu l mv mw"># 1<br/># 2<br/># [3, 4, 5, 6]</span></pre><p id="b6eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以用任何你喜欢的变量名来代替名字' rest '。你甚至可以使用下划线。</p><h1 id="6929" class="lg lh it bd li lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md bi translated">元组方法</h1><p id="e63a" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">因为元组不能被修改，所以它只有几个方法。一个特别有趣的是<strong class="kd iu">方法count </strong>，它计算一个给定值在元组中出现的次数:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7b75" class="ms lh it mo b gy mt mu l mv mw">a = (1,2,2,2,3,4,5,2)<br/>print(a.count(2))</span><span id="e2a6" class="ms lh it mo b gy mx mu l mv mw">#4</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f97c" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">列表</h1><p id="c3c7" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">与元组相反，列表可以有一个<strong class="kd iu">可变大小，并且它的内容可以就地修改</strong>。列表可以使用方括号或名为list的函数来创建。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4c00" class="ms lh it mo b gy mt mu l mv mw">a_list = [1,2,3,None,'foo']</span><span id="82aa" class="ms lh it mo b gy mx mu l mv mw">tup = ('foo', 'bar', 'baz')<br/>b_list = list(tup)<br/>print(b_list)</span><span id="905a" class="ms lh it mo b gy mx mu l mv mw"># ['foo', 'bar', 'baz']</span></pre><h1 id="b967" class="lg lh it bd li lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md bi translated">添加和删除列表中的元素</h1><p id="65f6" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">我们可以使用<strong class="kd iu"> append </strong>(在列表末尾添加一个值)或<strong class="kd iu"> insert </strong>(在给定位置插入一个值)在列表中插入元素:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="63d3" class="ms lh it mo b gy mt mu l mv mw">a_list = [1,2,3,None,'foo']<br/>a_list.append('test')<br/>print(a_list)<br/># [1, 2, 3, None, 'foo', 'test']</span><span id="7292" class="ms lh it mo b gy mx mu l mv mw">a_list.insert(2, 'value') #index where the value will be inserted<br/>print(a_list)<br/># [1, 2, 'value', 3, None, 'foo', 'test']</span></pre><p id="29b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">方法<strong class="kd iu"> <em class="my"> insert </em>比<em class="my"> append </em>消耗更多内存</strong>，因为Python需要在插入值后重新排列所有索引。另一方面，<em class="my"> append </em>没有这个开销(第一个有O(n)的大O，而最后一个有O(1)的大O，这意味着后者快得多)。</p><p id="0579" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要删除一个值，我们用<em class="my"> </em> <strong class="kd iu"> <em class="my">弹出</em> </strong>和<strong class="kd iu"> <em class="my">删除</em> </strong>:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b0e0" class="ms lh it mo b gy mt mu l mv mw">a_list = [1,'bar',3,None,'foo']<br/>a_list.pop(2)<br/>print(a_list)<br/># [1, 'bar', None, 'foo']</span><span id="37b3" class="ms lh it mo b gy mx mu l mv mw">a_list.remove('bar')<br/>print(a_list)<br/># [1, None, 'foo']</span></pre><p id="d829" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与之前的方式相同，<strong class="kd iu"> <em class="my">删除</em>比<em class="my">弹出</em> </strong>效率低，原因与上一段解释的一样。</p><h1 id="927d" class="lg lh it bd li lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md bi translated">连接列表</h1><p id="1548" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">我们可以使用<strong class="kd iu">加号</strong>将一个列表添加到另一个列表:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="04bd" class="ms lh it mo b gy mt mu l mv mw">a = [1,2,3]<br/>b = ['foo', 'bar']<br/>c = a + b<br/>print(c)</span><span id="c79c" class="ms lh it mo b gy mx mu l mv mw"># [1, 2, 3, 'foo', 'bar']</span></pre><p id="ca0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以使用<strong class="kd iu"> <em class="my">扩展</em> </strong>的方法来连接几个元素:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="aa09" class="ms lh it mo b gy mt mu l mv mw">a = [1,2,3]<br/>a.extend(['foo', 'bar'])</span><span id="40c3" class="ms lh it mo b gy mx mu l mv mw">print(a)</span><span id="2afd" class="ms lh it mo b gy mx mu l mv mw"># [1, 2, 3, 'foo', 'bar']</span></pre><p id="85a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<strong class="kd iu"> extend比加号</strong>更有效，因为Python不需要创建新的列表和复制对象。</p><h1 id="1489" class="lg lh it bd li lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md bi translated">排序值</h1><p id="3f65" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">使用列表，您还可以通过调用<em class="my">排序</em>函数来<strong class="kd iu">就地对值进行排序</strong>:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="2bcb" class="ms lh it mo b gy mt mu l mv mw">a = [1,3,6,3,7,6,8]<br/>a.sort()<br/>print(a)</span><span id="0a08" class="ms lh it mo b gy mx mu l mv mw"># [1, 3, 3, 6, 6, 7, 8]</span></pre><p id="22ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过sort，你也可以使用它的选项，给一个包含一个值的键，作为我们排序列表的第二种方式。</p><p id="773b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，假设我们想要按照<strong class="kd iu">元素的长度</strong>对给定的字符串列表进行排序:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="2973" class="ms lh it mo b gy mt mu l mv mw">a = ['saw', 'small', 'He', 'foxes', 'six']<br/>a.sort(key=len)<br/>print(a)</span><span id="72d9" class="ms lh it mo b gy mx mu l mv mw"># ['He', 'saw', 'six', 'small', 'foxes']</span></pre><p id="23c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，这里有比看上去更多的东西，你可以找到更多关于<em class="my">分类</em> <a class="ae nk" href="https://docs.python.org/3/howto/sorting.html" rel="noopener ugc nofollow" target="_blank">的信息，点击这里</a>。</p><h1 id="1a17" class="lg lh it bd li lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md bi translated">分割列表</h1><p id="10f5" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">可以使用带冒号的方括号来分割列表。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="02bf" class="ms lh it mo b gy mt mu l mv mw">a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']<br/>print(a[1:5])</span><span id="d55e" class="ms lh it mo b gy mx mu l mv mw"># ['b', 'c', 'd', 'e']</span></pre><p id="aea4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了演示上面的代码是如何工作的，我们有一张图:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f8f300d80f1cae012b589487157b6d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*c5Zulvg98UjCcuTW5SlOGA.png"/></div></figure><p id="354f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，<strong class="kd iu">第一位是包含性的，第二位是排他性的</strong>。</p><p id="624a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们省略切片上的第一个或最后一个数字，<strong class="kd iu">它将从开始处开始(或在最后一个元素处结束)</strong>:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="f21a" class="ms lh it mo b gy mt mu l mv mw">a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']<br/>print(a[:5])<br/># ['a', 'b', 'c', 'd', 'e']</span><span id="4f37" class="ms lh it mo b gy mx mu l mv mw">print(a[2:])<br/># ['c', 'd', 'e', 'f', 'g', 'h']</span></pre><p id="0d8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也可以使用切片将值添加到列表中<strong class="kd iu">:</strong></p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="f310" class="ms lh it mo b gy mt mu l mv mw">a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']<br/>a[3:4] = [6, 3]<br/>print(a)</span><span id="e45b" class="ms lh it mo b gy mx mu l mv mw"># ['a', 'b', 'c', 6, 3, 'e', 'f', 'g', 'h']</span></pre><p id="4bc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在[3:4]中有一个值(在本例中是字母“d”)，我们用[6，3]替换这个值:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/2b42ac832e1b7d2675c6952de819105f.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*ey36r0b3a5gVbpFanMyKuw.png"/></div></figure><p id="8299" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Python中，还可以使用<strong class="kd iu">负索引</strong>，这有时会让我们的生活变得更简单:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3d91" class="ms lh it mo b gy mt mu l mv mw">a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']<br/>print(a[-6:-2])</span><span id="51c4" class="ms lh it mo b gy mx mu l mv mw"># ['c', 'd', 'e', 'f']</span></pre><p id="f9f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了更清楚起见，我将再次使用一个图像:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/861f72eceb51c7ba262addd2f14dd9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*o08_BLUElLXu0N7k9QND1Q.png"/></div></figure><p id="b8ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你开始更多地使用负数，你就会习惯了。</p><p id="ac7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，还可以添加另一个冒号(和一个值)来表示<strong class="kd iu">步骤</strong>。这样做，有可能按一定的间隔获得元素:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9c1e" class="ms lh it mo b gy mt mu l mv mw">a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']<br/>print(a[::2])</span><span id="5cb3" class="ms lh it mo b gy mx mu l mv mw"># ['a', 'c', 'e', 'g']</span></pre><p id="03b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用一个步骤的一个聪明的方法是<strong class="kd iu">反转一个列表</strong>传递-1作为一个值:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="d4b2" class="ms lh it mo b gy mt mu l mv mw">a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']<br/>print(a[::-1])</span><span id="6cde" class="ms lh it mo b gy mx mu l mv mw"># [['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="2c16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望你们喜欢这次阅读。在下一篇文章中，我将讨论序列和其他数据结构的有用函数，比如字典和列表理解。那里见！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><div class="mj mk ml mm gt no"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">编写面试问题</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">技术开发</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jz no"/></div></div></a></div></div></div>    
</body>
</html>