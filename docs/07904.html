<html>
<head>
<title>Caching node modules and Cypress installation in an azure devops pipeline.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">azure devops管道中的缓存节点模块和Cypress安装。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/caching-node-modules-and-cypress-installation-in-an-azure-devops-pipeline-3f7a2e07960b?source=collection_archive---------5-----------------------#2021-03-20">https://levelup.gitconnected.com/caching-node-modules-and-cypress-installation-in-an-azure-devops-pipeline-3f7a2e07960b?source=collection_archive---------5-----------------------#2021-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/537c9510e59e41fd0edc43d8954e7edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exUitFzuIauwj4j-scG9Uw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自<a class="ae kf" href="https://burst.shopify.com/digital-downloads?utm_campaign=photo_credit&amp;utm_content=High+Res+Digital+Photography+Flatlay+Picture+%E2%80%94+Free+Images&amp;utm_medium=referral&amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">的<a class="ae kf" href="https://burst.shopify.com/@shopifypartners?utm_campaign=photo_credit&amp;utm_content=High+Res+Digital+Photography+Flatlay+Picture+%E2%80%94+Free+Images&amp;utm_medium=referral&amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank"> Shopify合作伙伴</a>拍摄的照片</a></figcaption></figure><p id="1ea5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我有一个后端对前端的应用程序，我是用Visual Studio搭建的。后端是ASP.NET核心web API，前端是有棱角的。在angular应用程序中，我有Cypress端到端测试，我想将其作为构建管道的一部分运行。实现目标需要几样东西。例如，我需要在构建代理上安装Cypress二进制文件。我还需要启动angular应用程序，以便再次运行测试。安装Cypress二进制文件是一个漫长的过程，加上其他步骤，整个构建可能需要很长时间才能完成。经过几次试错，我终于得到了运行Cypress测试和缓存二进制文件的构建。请记住，如果保存和恢复缓存数据所需的时间比直接下载和安装数据所需的时间少得多，缓存就有意义。</p><p id="b771" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我展示了为我工作的管道的当前配置:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="37d2" class="ln lo it lj b gy lp lq l lr ls"># Starter pipeline<br/># Start with a minimal pipeline that you can customize to build and deploy your code.<br/># Add steps that build, run tests, deploy, and more:<br/># https://aka.ms/yaml<br/><br/>trigger:<br/>  - master<br/><br/>pool:<br/>  vmImage: "ubuntu-latest"<br/><br/>variables:<br/>  buildConfiguration: "Release"<br/>  spaDir: "AzurePipelineRestoreAndSaveCacheEx/ClientApp"<br/>  cyCacheDir: "/home/vsts/.cache/Cypress"<br/>  npmCacheDir: "/home/vsts/.npm"<br/><br/>steps:<br/>  - task: NodeTool@0<br/>    inputs:<br/>      versionSpec: "12.19"<br/>    displayName: "Install Node.js"<br/><br/>  - task: Cache@2<br/>    inputs:<br/>      key: 'npm_v1 | "$(Agent.OS)" | $(spaDir)/package-lock.json'<br/>      path: $(npmCacheDir)<br/>      cacheHitVar: NPM_CACHE_RESTORED<br/>    displayName: "Cache ~/.npm directory"<br/><br/>  - task: Cache@2<br/>    inputs:<br/>      key: 'cy_v1 | "$(Agent.OS)" | $(spaDir)/package-lock.json'<br/>      path: $(cyCacheDir)<br/>      cacheHitVar: CYPRESS_CACHE_RESTORED<br/>    displayName: "Cache Cypress binary"<br/><br/>  - script: |<br/>      CYPRESS_INSTALL_BINARY=0 npm ci<br/>    displayName: Install dependencies (skip Cypress install)<br/>    workingDirectory: "$(spaDir)"<br/>    condition: eq(variables.CYPRESS_CACHE_RESTORED, 'true')<br/><br/>  - script: |<br/>      npm ci<br/>    displayName: Install dependencies (include Cypress install)<br/>    workingDirectory: "$(spaDir)"<br/>    condition: eq(variables.CYPRESS_CACHE_RESTORED, 'false')<br/><br/>  - task: CmdLine@2<br/>    inputs:<br/>      script: "npm test"<br/>      workingDirectory: "$(spaDir)"<br/>    displayName: "Run cypress test"<br/><br/>  - task: PublishTestResults@2<br/>    inputs:<br/>      testResultsFormat: "JUnit"<br/>      testResultsFiles: "**/test-output-*.xml"<br/>    displayName: "Publish test results"<br/><br/>  - task: DotNetCoreCLI@2<br/>    displayName: "Publish web app"<br/>    inputs:<br/>      command: "publish"<br/>      projects: "**/*.csproj"<br/>      publishWebProjects: true<br/>      zipAfterPublish: true<br/>      arguments: "--output $(build.artifactstagingdirectory)"<br/><br/>  - task: PublishBuildArtifacts@1<br/>    inputs:<br/>      pathToPublish: $(Build.ArtifactStagingDirectory)</span></pre><p id="d3fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我想提一下构建代理。如上面的配置所示，我使用的是基于ubuntu的构建代理。起初，我使用基于windows的代理；然而，构建花了很长时间才完成。仅仅通过切换到ubuntu代理，我就获得了构建时间的显著减少。 </p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="63d2" class="ln lo it lj b gy lp lq l lr ls">pool: vmImage: "ubuntu-latest"</span></pre><p id="a267" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我要指出的是<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops" rel="noopener ugc nofollow" target="_blank">缓存</a>任务，我用它来缓存Cypress和。npm目录。例如，下面配置的任务缓存全局。npm目录:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2ce3" class="ln lo it lj b gy lp lq l lr ls">- task: Cache@2<br/>    inputs:<br/>      key: 'npm_v1 | "$(Agent.OS)" | $(spaDir)/package-lock.json'<br/>      path: $(npmCacheDir)<br/>      cacheHitVar: NPM_CACHE_RESTORED<br/>    displayName: "Cache ~/.npm directory"</span></pre><p id="3b6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的配置中，我指定了一个由字符串“npm_v1”、操作系统的名称和package-lock.json文件的MD5散列组成的密钥。当任务运行时，它将使用这个键在缓存中查找数据。如果命中，该任务会将数据恢复到path参数中指定的文件夹。如果未命中，在构建结束时，该任务会将path目录下的数据保存到缓存中。因为密钥由package-lock.json的md5散列组成，所以只要文件的内容保持不变并且操作系统保持不变，使用密钥在缓存中的后续查找数据就会导致缓存命中。你可能想知道我使用的常量字符串‘NPM _ v1’。这是为了当我想放弃现有的缓存。</p><blockquote class="lu lv lw"><p id="edd3" class="kg kh lt ki b kj kk kl km kn ko kp kq lx ks kt ku ly kw kx ky lz la lb lc ld im bi translated"><em class="it">目前不支持清除缓存。但是，您可以向现有的缓存键添加一个字符串文字(如</em> <code class="fe ma mb mc lj b"><em class="it">version2</em></code> <em class="it">)来更改该键，以避免对现有缓存的任何命中</em></p><p id="2ce6" class="kg kh lt ki b kj kk kl km kn ko kp kq lx ks kt ku ly kw kx ky lz la lb lc ld im bi translated"><em class="it">管道缓存</em></p></blockquote><p id="76be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据我的理解，Cypress安装将二进制文件都放在node_modules/下。bin以及全局系统缓存。在linux上，Cypress文件在~/文件夹下。默认为cache/Cypress。这个目录可以通过设置环境变量CYPRESS_CACHE_FOLDER来配置。欲了解更多信息，请查看<a class="ae kf" href="https://docs.cypress.io/guides/getting-started/installing-cypress.html#Binary-cache" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="9827" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据npm数据是否存在于缓存中，构建执行下面两个任务之一。这两个任务都运行<code class="fe ma mb mc lj b">npm ci </code>来安装依赖项。但是，有一个任务会跳过Cypress安装，以防缓存命中。缓存cypress二进制文件时，缓存任务将结果设置为变量CYPRESS_CACHED_RESTORED。因此，我使用condition并检查这个变量来确定文件是否存在于缓存中，并跳过cypress安装，因为缓存任务会将文件恢复到正确的位置。</p><p id="38fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能想知道为什么我总是不检查缓存就运行。这是因为npm查看共享缓存目录，该目录包含所有下载的节点模块的缓存版本。对于linux，该目录是/home/vsts/。我在前面的任务中缓存的mpm。因此，即使我运行<code class="fe ma mb mc lj b"> npm ci</code>，我也能获得缓存的好处，因为npm首先检查共享缓存目录中是否已经存在该包，以避免进行不必要的网络调用。对于在CI环境中运行，使用<code class="fe ma mb mc lj b">npm ci i</code>是优于<code class="fe ma mb mc lj b">npm install </code>的方式，因为前者将通过删除节点模块目录来进行全新安装。这也解释了为什么我需要缓存Cypress缓存目录和共享npm目录。这是因为cypress安装将文件放在node_modules/下。但是我不缓存node_modules目录，只缓存共享的npm目录。</p><blockquote class="lu lv lw"><p id="6be8" class="kg kh lt ki b kj kk kl km kn ko kp kq lx ks kt ku ly kw kx ky lz la lb lc ld im bi translated"><em class="it">node . js项目中启用缓存的方式有多种，但推荐的方式是缓存npm的</em> <a class="ae kf" href="https://docs.npmjs.com/misc/config#cache" rel="noopener ugc nofollow" target="_blank"> <em class="it">共享缓存目录</em> </a> <em class="it">。该目录由npm管理，包含所有下载模块的缓存版本。在安装过程中，npm首先(默认情况下)检查此目录中的模块，这些模块可以减少或消除对公共npm注册表或私有注册表的网络调用。</em></p><p id="751e" class="kg kh lt ki b kj kk kl km kn ko kp kq lx ks kt ku ly kw kx ky lz la lb lc ld im bi translated"><a class="ae kf" href="http://There%20are%20different%20ways%20to%20enable%20caching%20in%20a%20Node.js%20project,%20but%20the%20recommended%20way%20is%20to%20cache%20npm's%20shared%20cache%20directory.%20This%20directory%20is%20managed%20by%20npm%20and%20contains%20a%20cached%20version%20of%20all%20downloaded%20modules.%20During%20install,%20npm%20checks%20this%20directory%20first%20(by%20default)%20for%20modules%20which%20can%20reduce%20or%20eliminate%20network%20calls%20to%20the%20public%20npm%20registry%20or%20to%20a%20private%20registry." rel="noopener ugc nofollow" target="_blank"> <em class="it">管道缓存</em> </a></p></blockquote><p id="de71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个缓存任务都有一个在构建结束时运行的post作业，以便在必要时检查和更新缓存。例如，在缓存未命中的情况下，post作业会检查路径目录下的文件并将其存储到缓存中。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/40cd6eb7e43ae1bd5973d387343bfaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_yRtiYpFfFR_hGpRIIzAQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">缓存未命中</figcaption></figure><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/77eb7be8e0bf11e2ecae3f16b62bb538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7KWXipgfcMid3F3GB02whQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作业后缓存—将数据保存到缓存中以供下次运行</figcaption></figure><p id="2956" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在准备好所有节点模块和cypress二进制文件之后，下一个任务是启动本地服务器来运行Cypress测试。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6ca0" class="ln lo it lj b gy lp lq l lr ls">- task: CmdLine@2<br/>    inputs:<br/>      script: "npm test"<br/>      workingDirectory: "$(spaDir)"<br/>    displayName: "Run cypress test"</span></pre><p id="aa1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码片段中，脚本“npm test”指的是package.json中的以下脚本</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="94f3" class="ln lo it lj b gy lp lq l lr ls">"scripts": {<br/>    "ng": "ng",<br/>    "start": "ng serve",<br/>    "build": "ng build",<br/>    "cy": "npx cypress run",<br/>    "build:ssr": "ng run AzurePipelineRestoreAndSaveCacheEx:server:dev",<br/>    "test": "start-server-and-test start http-get://localhost:4200 cy",<br/>    "lint": "ng lint",<br/>    "e2e": "ng e2e"<br/>  },</span></pre><p id="c009" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，在上面的配置中，我使用<a class="ae kf" href="https://www.npmjs.com/package/start-server-and-test" rel="noopener ugc nofollow" target="_blank"> start-server-and-test </a>模块在本地主机上启动和服务angular应用程序，然后运行Cypress测试。<code class="fe ma mb mc lj b">cy</code>命令引用<code class="fe ma mb mc lj b">npx cypress run</code>，开始命令引用<code class="fe ma mb mc lj b">ng serve</code>。</p><p id="4231" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试完成后，cypress以junit格式输出测试结果。为此，我需要在cypress.json文件中有以下配置。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="34f2" class="ln lo it lj b gy lp lq l lr ls">{<br/>  "chromeWebSecurity": false,<br/>  "baseUrl": "http://localhost:4200",<br/>  "reporter": "junit",<br/>  "reporterOptions": {<br/>    "mochaFile": "tests/test-output-[hash].xml",<br/>    "toConsole": true,<br/>    "attachments": true<br/>  }<br/>}</span></pre><p id="f3fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我运行了前端应用程序的测试，最后两个任务基本上是构建和发布ASP.NET核心应用程序。其中一部分包括再次构建angular应用程序，但这一次是在prod模式下，按照。csproj文件。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4c0a" class="ln lo it lj b gy lp lq l lr ls">&lt;Target Name="PublishRunWebpack" AfterTargets="ComputeFilesToPublish"&gt;<br/>    &lt;!-- As part of publishing, ensure the JS resources are freshly built in production mode --&gt;<br/>    &lt;Exec WorkingDirectory="$(SpaRoot)" Command="npm run build -- --prod" /&gt;<br/>    &lt;Exec WorkingDirectory="$(SpaRoot)" Command="npm run build:ssr -- --prod" Condition=" '$(BuildServerSideRenderer)' == 'true' " /&gt;</span></pre><p id="491b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于这是一个示例项目，我没有太多的节点包。保存和恢复缓存所需的时间与直接下载和安装软件包所需的时间几乎相同。但是，如果您的项目很大并且有很多包，您可能会从缓存中受益。</p><p id="7472" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在此链接查看示例项目:<a class="ae kf" href="https://dev.azure.com/taithienbo/_git/PipelineCachingEx." rel="noopener ugc nofollow" target="_blank">https://dev.azure.com/taithienbo/_git/PipelineCachingEx.</a></p><h1 id="1d4b" class="mf lo it bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">参考</h1><p id="447c" class="pw-post-body-paragraph kg kh it ki b kj nc kl km kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated"><a class="ae kf" href="https://docs.cypress.io/guides/getting-started/installing-cypress.html#Install-binary" rel="noopener ugc nofollow" target="_blank">安装Cypress二进制文件</a></p><p id="be26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> Azure devops管道缓存</a></p><p id="3aae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.cypress.io/guides/continuous-integration/introduction.html#Setting-up-CI" rel="noopener ugc nofollow" target="_blank"> Cypress设置CI </a>和<a class="ae kf" href="https://docs.cypress.io/guides/getting-started/installing-cypress.html#Binary-cache" rel="noopener ugc nofollow" target="_blank"> Cypress二进制缓存</a></p><p id="f1f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.cypress.io/guides/continuous-integration/introduction.html#Boot-your-server" rel="noopener ugc nofollow" target="_blank">Cypress CI boot-your-server</a><a class="ae kf" href="https://www.npmjs.com/package/start-server-and-test" rel="noopener ugc nofollow" target="_blank">Start-server-and-test模块</a></p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="61fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lt">原载于2021年3月20日https://www.taithienbo.com</em><em class="lt">的</em> <a class="ae kf" href="https://www.taithienbo.com/caching-node-modules-and-cypress-installation-in-an-azure-devops-pipeline/" rel="noopener ugc nofollow" target="_blank"> <em class="lt">。</em></a></p></div></div>    
</body>
</html>