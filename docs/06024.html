<html>
<head>
<title>Create a Throttling System for Any Application with no more than 100 lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用不超过100行代码为任何应用程序创建一个节流系统</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-throttling-system-for-any-application-with-no-more-than-100-lines-of-code-ac5b2b6d86d8?source=collection_archive---------19-----------------------#2020-10-19">https://levelup.gitconnected.com/creating-a-throttling-system-for-any-application-with-no-more-than-100-lines-of-code-ac5b2b6d86d8?source=collection_archive---------19-----------------------#2020-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bf86eb7a139f88af6f40cdf1d0059ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XX1bkKlvZI_M5FSD.png"/></div></div></figure><p id="5992" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">应用程序通常设计有一个节流机制。有时，我们希望限制请求的数量，以提高应用程序的安全性和性能。有时，您的应用程序无法响应超过一定数量的连接。例如，如果您尽可能快地从队列中轮询消息，并且没有限制连接数，您的应用程序将很快耗尽其连接傻瓜并面临拒绝服务错误。在这种情况下，拥有一种限制同时处理的应用程序数量的机制将有助于提高应用程序的性能。</p><p id="55a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我想分享我们如何用FS2并发原语队列创建一个节流机制。</p><p id="9b2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们开始之前，我想让你想象一个应用程序，它将不断地从上游轮询元素。然后，我们通过提供资源可以同时操作的最大缓冲区大小，利用<a class="ae kz" href="https://fs2.io/guide.html" rel="noopener ugc nofollow" target="_blank"> FS2 </a>来处理节流/背压。当内部队列已满时，在某些任务完成之前，它不会将消息排入队列。</p><p id="76ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，应用程序的用户可以这样使用它:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="5b43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，当最大大小超过100时，它将停止轮询元素，直到内部队列有一些空间。</p><p id="ba3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建该文件的过程分为两个部分:</p><ul class=""><li id="4167" class="lg lh it kd b ke kf ki kj km li kq lj ku lk ky ll lm ln lo bi translated">消费者是一种通过不断将值排入内部队列来订阅上游的类。</li><li id="92d8" class="lg lh it kd b ke lp ki lq km lr kq ls ku lt ky ll lm ln lo bi translated">Subscriber是一个类型类，它将包装消费者，从内部队列中取出数据块并处理该值。</li></ul><p id="461b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据应用程序的用例，我们可以封装订户部分或消费者部分。在本文中，它将是消费者。这意味着用户可以指定他们的函数想要从哪个上游轮询，并且他们可以从订阅者那里访问结果。最后一篇文章封装了订户部分。</p><h1 id="d8e5" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">消费者</h1><p id="325c" class="pw-post-body-paragraph kb kc it kd b ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky im bi translated">消费者将订阅上游。因此，我们想要一个这样的函数:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="ba6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该函数接收来自<code class="fe mx my mz na b">upstream</code>和<code class="fe mx my mz na b">enqueue</code>的任何值，并将该值发送到内部队列。</p><p id="a00d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们创建初始订阅方法。我们需要通过让我们的调用者初始化内部队列并将它们注入到<code class="fe mx my mz na b">Consumer</code>实例中来创建<code class="fe mx my mz na b">Consumer</code>类型类的实例。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="4779" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦上游站点向消费者发送消息，我们将使用NoneTerminatedQueue来终止队列。消费者可以告诉订户停止该流。</p><p id="8d65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这听起来像资源获取吗？</p><p id="f00a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你是对的！本质上，我们希望获得一个资源，并希望保证在获得资源的情况下运行一些清理操作。因此，我们将为<code class="fe mx my mz na b">subscribe</code>创建资源助手方法:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="e418" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将把来自<code class="fe mx my mz na b">upStream</code>和<code class="fe mx my mz na b">enqueue1</code>的值放到我们的内部队列中。然后，我们将<code class="fe mx my mz na b">compile.drain</code>并排出来自<code class="fe mx my mz na b">upStream</code>的所有输入。如果所有的信息都被耗尽或者在计算过程中出现任何错误，资源将通过<code class="fe mx my mz na b">enqueue1</code> a <code class="fe mx my mz na b">None</code>清理到我们的内部队列(订户)。然后订户停止其流。</p><p id="912c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们所说的<code class="fe mx my mz na b">Consumer</code>:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="6454" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mx my mz na b">start</code>这里将开始一个<code class="fe mx my mz na b">fiber</code>。如果你没有放入一个<code class="fe mx my mz na b">start</code>，那么整个过程将是连续的，这意味着它将所有的值入队，然后出列。如果我们的内部队列满了，它就会挂在那里。因此，拥有<code class="fe mx my mz na b">start</code>将在另一个IO线程中执行<code class="fe mx my mz na b">subscribe</code>。</p><h1 id="0e95" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">订户</h1><p id="21b6" class="pw-post-body-paragraph kb kc it kd b ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky im bi translated">我们希望<code class="fe mx my mz na b">Subscriber</code>到<em class="nb">的轮询重复</em>并返回一个<code class="fe mx my mz na b">Stream[F, A]</code>给调用者。</p><p id="db4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们可以创建一个具有will <code class="fe mx my mz na b">pollRepeat</code>的类型类:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="06c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与<code class="fe mx my mz na b">Consumer</code>类似，我们需要创建一个<code class="fe mx my mz na b">Subscriber</code>的实例，将最大队列大小和上游作为参数:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="5abd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要订阅上游，将订阅者发送到另一个线程，并实例化订阅者。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="99f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用调用者提供的<code class="fe mx my mz na b">maxBufferSize</code>创建<code class="fe mx my mz na b">boundedNoneTerminated</code>内部队列。然后，我们在<code class="fe mx my mz na b">Consumer</code>类型类的帮助下制作我们的<code class="fe mx my mz na b">Consumer</code>，并订阅上行，开始另一个光纤。我们返回队列，这样我们就可以用<code class="fe mx my mz na b">Subscriber</code>实例连接它。</p><p id="7fcc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，当我们创建<code class="fe mx my mz na b">consumer</code>时，我们可以将消费者与<code class="fe mx my mz na b">Subscriber</code>联系起来。像这样:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="718e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是使用订户实例并将其用作应用程序中任何节流机制的程序:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="9352" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您需要在结束时呼叫<code class="fe mx my mz na b">unsafeRunSync</code>:</p><pre class="la lb lc ld gt nc na nd ne aw nf bi"><span id="e3f3" class="ng lv it na b gy nh ni l nj nk">subscriberExample.unsafeRunSync</span></pre><h1 id="c35a" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="a1b5" class="pw-post-body-paragraph kb kc it kd b ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky im bi translated">添加节流机制可能很有挑战性，尤其是如果您需要在并发环境中这样做的话。幸运的是，在FS2的帮助下，在任何应用程序上构建节流机制只需几行代码。</p><p id="1cb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建了<code class="fe mx my mz na b">Consumer</code>类型的类来订阅任何源。然后，我们用<code class="fe mx my mz na b">Subscriber</code>以并发的方式不断地<code class="fe mx my mz na b">enqueue</code>和<code class="fe mx my mz na b">dequeue</code>。我们可以保证在通过资源获取停止流之前清理队列数据。</p><p id="7866" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对学习更多关于FS2、Scala或函数式编程的知识有所帮助。如果有任何可能导致错误的地方，请随时指出来，这样我也可以向你学习。</p><p id="94b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有源代码都在<a class="ae kz" href="https://github.com/edwardGunawan/Blog-Tutorial/tree/master/ScalaTutorial/fs2/src/main/scala/Subscriber" rel="noopener ugc nofollow" target="_blank"> GitHub </a>里。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="ef79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯中的</strong><a class="ae kz" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"/></a><strong class="kd iu">以获得关于科技职业的文章、有趣的链接和内容的通知！</strong></p><p id="d37e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以关注我，也可以在<a class="ae kz" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上关注我，以获得更多类似的帖子。</p><p id="c9a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nb">原载于</em><a class="ae kz" href="https://edward-huang.com/fs2/functional-programming/stream-processing/scala/programming/2020/10/11/create-a-throttling-system-for-any-application-with-no-more-than-100-lines-of-code/" rel="noopener ugc nofollow" target="_blank"><em class="nb">https://edward-huang.com</em></a><em class="nb">。</em></p></div></div>    
</body>
</html>