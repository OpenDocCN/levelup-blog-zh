<html>
<head>
<title>Event-Driven Architectures in Software Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件设计中的事件驱动架构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/event-driven-architectures-in-software-design-757d92b85df5?source=collection_archive---------2-----------------------#2021-09-17">https://levelup.gitconnected.com/event-driven-architectures-in-software-design-757d92b85df5?source=collection_archive---------2-----------------------#2021-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/381e836406f02ad642a2c7b9327fbfcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*tXbDnelqjfTFWPcPjqZupQ.jpeg"/></div></figure><p id="3c88" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">随着现代应用程序必须处理的数据量不断增加，需要新的更复杂的系统架构。</p><p id="f4a6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">近年来最闪亮的宝石之一是事件驱动架构。</p><p id="1b68" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这种模式帮助脸书、谷歌、LinkedIn和其他巨头克服了他们特有的一系列问题，同时也帮助快速成长的小公司保持势头，成为成功的组织。</p><p id="c331" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那么…交易是什么？</p><p id="5f0e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">事件驱动架构(或EDA)是一种软件设计风格，其理念是服务之间的通信必须通过发送和响应“事件”来完成。</p><p id="ecfa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这些事件通常被定义为系统中某处的状态变化，这些变化被公开给其他可能感兴趣的服务，而不是直接与它们通信。</p><p id="5497" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以任何在线商店的简单客户订单为例。</p><p id="1cea" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在请求驱动的架构中(简单请求/响应设置的别称)，在线购买可能如下图所示:</p><figure class="kw kx ky kz gt ju gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/823aee26a27f2eb9d62922290d2a10bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*C_3eiR2np4yiyAvowjcF1g.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">本·斯托福德的《设计事件驱动系统》中的图表</figcaption></figure><p id="65f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里我们有一个web服务器，它将用户的订单提交给订单服务，然后</p><ol class=""><li id="e759" class="le lf it jz b ka kb ke kf ki lg km lh kq li ku lj lk ll lm bi translated">订单服务向运输服务发送一个<code class="fe ln lo lp lq b">shipOrder()</code>请求。</li><li id="8531" class="le lf it jz b ka lr ke ls ki lt km lu kq lv ku lj lk ll lm bi translated">运输服务需要客户的信息，所以它向客户服务请求信息。</li><li id="14dc" class="le lf it jz b ka lr ke ls ki lt km lu kq lv ku lj lk ll lm bi translated">然后，当信息返回时，运输服务可以完成处理。</li></ol><p id="b0cc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这听起来像是合乎逻辑的第一步，但是随着系统的增长，这些类型的服务会变得非常复杂，尤其是在添加更多交互时。</p><p id="e320" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们可能希望添加订单分析组件，我们可能希望有一个实时欺诈检测组件，或者一个单独的库存管理系统，我们可能需要处理客户的请求，但这是不可能的，直到某些信息通过一个阶段，如运输服务。各种各样的复杂情况都会出现。</p><p id="34ae" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在事件驱动的体系结构中，前面的事务如下所示:</p><figure class="kw kx ky kz gt ju gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/834469fdbd171f2aa844ea37d1558dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*tIUiNAK2L9Gxm4dQH1A5_A.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">编辑图，摘自Ben Stopford的《设计事件驱动系统》</figcaption></figure><p id="f39d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个过于简单的示例中，有一个微小的变化，即Orders服务决定传达订单创建的方式。</p><p id="0dff" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里，它不是直接向运输服务发送请求，而是向所有正在收听的人发送一个“Order Created”事件，通知他们刚刚发生了什么。</p><p id="7ad2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这种微小的差异是EDA的一个重要优势。您不再需要交互，甚至不需要知道您自己的子域之外的服务的存在，这带来了很多可能性。</p><p id="ed50" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">推出新服务</strong></p><p id="6d39" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">考虑添加一个新服务的情况，该服务需要知道订单是何时创建的，以便进行一些额外的处理，比如实时分析订单的数据，以将其显示在产品团队仪表板上。</p><p id="92f5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在请求/响应世界中，您需要修改Orders服务来发送对新服务的<code class="fe ln lo lp lq b">shipOrder()</code>调用，但是在EDA世界中，新服务只需要订阅Order Created事件，其他人不需要知道或更改任何事情。</p><p id="858a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">很酷吧。</p><p id="3c5f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在最后一个例子中，我已经介绍了很多概念，所以在接下来的章节中，我们将对组件、考虑事项、模式以及是否适合EDA进行分析。</p><h1 id="3dee" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">在事件驱动的架构中，哪些组件是必不可少的？</h1><p id="f2df" class="pw-post-body-paragraph jx jy it jz b ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku im bi translated"><strong class="jz iu">服务</strong></p><p id="ef9d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了能够设计EDA，您的系统需要以松散耦合的服务来构建。要么你现在就开始构建它们，要么从一个整体开始慢慢迁移。它可能是一个SOA或者一个<a class="ae na" href="https://medium.com/geekculture/brief-introduction-to-microservices-b99a91c77c72" rel="noopener">微服务架构</a>。关键是需要跨不同服务的通信。</p><p id="1bef" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">通信</strong></p><p id="14de" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通信媒介也很重要，你需要一个可以承载事件数据的消息系统，最好是像<a class="ae na" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>这样的消息队列系统或者像<a class="ae na" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>这样的流媒体平台。</p><p id="c267" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是仅有的两个主要组件。之后，您的系统的需求将会有很大的变化，您可能需要也可能不需要其他组件，如数据存储、分析、APMs等。</p><p id="1911" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">也就是说，在如此复杂的系统中，您可能需要良好的监控和设计良好的数据网格。如果你不怕麻烦走这条路，它肯定是值得的，如果不是一个实际的要求。</p><h1 id="5299" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">设计EDA时需要考虑什么？</h1><p id="9a1f" class="pw-post-body-paragraph jx jy it jz b ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku im bi translated">如果你发现自己在设计一个事件驱动的架构，在你从头开始构建它之前，你可能不会坐在那里画画。很有可能你会(或者已经)在一段时间内进化它。</p><p id="1451" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">设计考虑更多的是您需要记住的一组持续的原则和模式，并且将根据您的增长和期望的规模而变化。</p><p id="ef94" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">设置它的时间点也很重要。如果你刚刚起步，设计一些东西来处理脸书的交通是没有意义的。</p><p id="2900" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">开始的时候，保持简单，但要留有成长的空间。决定您想要遵循的模式，并遵循这些指导原则构建您的服务。</p><p id="ad81" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">也就是说，有一些常见的模式你可能想看看</p><p id="b83d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">领域驱动设计</strong></p><p id="d5bd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">顾名思义，这种思想就是软件开发是围绕一个特定的领域进行的，该领域有特定的规则和过程。有明确的界限，与其他域的通信通过触发到“外部”的事件发生。这允许其他域根据其他地方发生的事情进行监听和更新，而不需要将系统中分离的部分连接在一起。</p><p id="d875" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">事件采购</strong></p><p id="654d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这种方法在业务实体(或对象)经历变化时存储其状态。每当发生变更事件时，我们都会将其存储为事务的一部分。这允许我们根据发生在物体上的事件来重建物体的状态。</p><p id="28fe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">建立一个像Kafka这样的流媒体平台，事件可以永久存储，这使得原子地执行这些操作变得更加容易。</p><p id="54af" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">事件采购示例可以是我们的客户订单场景。我们可以存储每次状态改变后创建、验证、处理、发货和完成的订单。</p><p id="bd53" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">命令查询责任分离(CQRS) </strong></p><p id="626a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这可能是设计事件驱动架构时要遵循的理想模式。读取和写入职责是分离的，允许服务读取特定的数据存储(或构建自己的本地缓存)，而数据所有者负责写入数据。这种模式可能很复杂，只有在真正需要的时候才应该使用，但是让模型来读，让其他人来写的想法创造了一个解决问题的机会的世界。</p><h1 id="5a8e" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">埃达是你的吗？复杂性与规模</h1><p id="2822" class="pw-post-body-paragraph jx jy it jz b ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku im bi translated">我们可能都听说过有人设计了复杂的微服务或无服务器架构，使用多种编程语言和框架，而他们只需要一个包含几项服务的网站。</p><p id="8e4c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">像软件工程中的任何其他模式或工具一样，EDA并不适合所有场景。你需要衡量你从中获得了什么，以及你是否真的需要它。</p><p id="fbcf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这种范式下，小软件系统成为大系统的自然路径实际上是从一个(或一个小集合)只做基础工作的单块应用开始。</p><p id="1bbc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">随着更多功能的增加，您可以开始构建服务(或微服务)来满足这些需求。在某个时候，您将到达通信成为一种约束的门槛，您可能需要重新设计您的服务来通过事件进行通信。这是你想开始考虑复杂模式的时候，但是等到你看到需要的时候。</p><p id="ecac" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您甚至可以使用轻量级解决方案，如消息队列，在提交完整的流媒体服务之前传递消息。</p><p id="c961" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">关键是，你需要在复杂性和规模之间保持平衡。您希望为规模做好准备，但在没有充分理由的情况下，不要让您的工程师过早地陷入痛苦。</p><h1 id="2796" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">有什么工具可以帮助你</h1><p id="5b02" class="pw-post-body-paragraph jx jy it jz b ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku im bi translated">我最喜欢的两个在事件驱动架构中实现通信的工具是RabbitMQ(用于轻量级消息队列)和Kafka(用于大量分布式流)。</p><p id="7ee0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">两者各有利弊。作为一般指导，我会使用RabbitMQ进行消息传递，以取代一些RPC场景，或者实现一个轻量级EDA。如果您以正确的方式设置它，RabbitMQ可以在您需要更重的解决方案之前带您走很长的路。</p><p id="a61a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你的需求更加复杂和详细，那么卡夫卡可能是你的最佳选择。现在，你可以使用像Confluent或Cloudkarafka这样的云服务，这使得你只需点击几下鼠标就可以更容易地建立Kafka集群并开始测试。</p><p id="adc8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里最重要的部分是选择符合你需求的东西。其他任何事情都是麻烦而不是有益的。</p><h1 id="2175" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">那么，最后是什么样子的呢？</h1><p id="742f" class="pw-post-body-paragraph jx jy it jz b ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku im bi translated">EDAs可以像你想要的那样复杂，但是原理是一样的。您传递关于发生了什么的事件，并让其他服务决定它们是否感兴趣。</p><p id="1967" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是我们在后台下网上订单的例子。下图显示了不同的服务如何与流媒体平台上的事件进行交互(在本例中为Kafka)。</p><figure class="kw kx ky kz gt ju gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/5700a0cdb9a2c14a092d7dc5a5601b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*UxLXAZqogLKvzWQPkyJI8Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">本·斯托福德的《设计事件驱动系统》中的图表</figcaption></figure><p id="f123" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意订单服务是如何做三件事的，</p><ul class=""><li id="a296" class="le lf it jz b ka kb ke kf ki lg km lh kq li ku nb lk ll lm bi translated">它接收订单并发送订单创建事件。</li><li id="957e" class="le lf it jz b ka lr ke ls ki lt km lu kq lv ku nb lk ll lm bi translated">它侦听订单验证事件。</li><li id="5fe2" class="le lf it jz b ka lr ke ls ki lt km lu kq lv ku nb lk ll lm bi translated">一旦更新了自己的数据存储，它就会通过GET显示订单的状态。</li></ul><p id="630a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">其他的对它来说都不重要。有欺诈组件、库存组件、订单验证组件和电子邮件服务……所有这些组件都独立工作以履行其职责，当它们这样做时，它们只是遵循模式并发送适当的事件。</p><p id="b109" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">另一个好处是，所有这些服务都可以独立扩展。如果一些服务比其他服务更忙，更多的权力可以交给他们。与此同时，他们一次只处理流中的一个项目(形象地说，更有可能你已经将它并行化了)，所以处理是非常高效的，因为他们像流水线一样不断地执行任务。</p><h1 id="41f8" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">结论</h1><p id="ede4" class="pw-post-body-paragraph jx jy it jz b ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku im bi translated">软件工程充满了非常酷的挑战，创新总是在拐角处。似乎每天人们都在创造非常酷的东西，想出解决问题的新方法。</p><p id="1ef2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">困难的是仔细看看，并决定什么是手头工作的最佳工具。从最好的编程语言，到最好的云托管、框架或系统架构。</p><p id="dde2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当选择复杂的事件驱动架构时，会有很多乐趣，但也有很多挑战需要克服。我们必须关注基础，学习软件模式以避免常见错误。</p><p id="a083" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个层面上，糟糕的设计决策会让你付出代价，而且很难撤销。预先做大量的思考将帮助你更好地理解你想要达到的目标，并决定你想要如何构建你的组件。</p><p id="f273" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">关注这个行业正在做什么，问很多问题，和已经解决了你面临的一些问题的人聚在一起。这可能是设计复杂系统的最佳方法。</p><p id="600b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">快乐设计！</p></div></div>    
</body>
</html>