<html>
<head>
<title>S.O.L.I.D Principles explained in Python with examples.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">南用Python解释O.L.I.D原则，并举例说明。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/s-o-l-i-d-principles-explained-in-python-with-examples-83b2b43bdcde?source=collection_archive---------5-----------------------#2021-02-22">https://levelup.gitconnected.com/s-o-l-i-d-principles-explained-in-python-with-examples-83b2b43bdcde?source=collection_archive---------5-----------------------#2021-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2734" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SOLID是面向对象语言中为软件开发创建的一组设计原则的助记缩写。<strong class="js iu"> SOLID </strong>中的原则旨在培养软件开发人员更简单、更健壮和可更新的代码。每一个实心字母对应一个发展原则:</p><p id="9438" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果实现得当，它会让你的代码更具<strong class="js iu">扩展性、逻辑性和可读性。</strong></p><p id="e7fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了理解<strong class="js iu">坚实的</strong>原理，你必须清楚地知道接口的使用。</p><p id="2c2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将尝试用最简单的方式解释Python中的<strong class="js iu">坚实的</strong>原理，以便初学者容易理解。将提供的例子应用于Python是非常容易的。</p><p id="5f94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们一个接一个地检查每个原则:</p><h1 id="89f0" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><span class="l lm ln lo bm lp lq lr ls lt di"> 1。</span>单一责任原则</h1><p id="3f5a" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">单一责任原则要求一个类只能有一项工作。因此，如果一个类有不止一个责任，它就成了耦合的。对一项责任的更改会导致对另一项责任的修改。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/ec8d313ba5ea040cbd361dfa89d2aaeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*cgIth8fwgIGVcU76YJKqcg.png"/></div></figure><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="499a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有一个用户类，负责用户属性和用户数据库管理。如果应用程序发生影响数据库管理功能的变化。使用用户属性的类必须被修改和重新编译以补偿新的变化。这就像多米诺骨牌效应，触摸一张牌会影响其他所有的牌。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/aac9b5204429a5da2b4d045b9ab5ccae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*5V7-R7t5h2ujtxNn6YBbXQ.png"/></div></figure><p id="9d3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们简单地拆分了这个类，我们创建了另一个类来处理将用户存储到数据库的任务:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决这一困境的常见方法是应用<a class="ae mj" href="https://kennison.name/files/zopestore/uploads/python/DesignPatternsInPython_ver0.1.pdf" rel="noopener ugc nofollow" target="_blank">外观模式</a>。关于立面图案的介绍，您可以<a class="ae mj" href="https://medium.com/@andreaspoyias/design-patterns-a-quick-guide-to-facade-pattern-16e3d2f1bfb6" rel="noopener">阅读更多</a>。用户类将是用户数据库管理和用户属性管理的门面。</p><h1 id="e608" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><span class="l lm ln lo bm lp lq lr ls lt di"> 2。</span>开闭原理</h1><p id="ea57" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">软件实体(类、模块、函数)应该对扩展开放，而不是修改。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/62e612cd6ac445e02096d47374d39c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8P1-xeih046vTmC-fVXIQ.jpeg"/></div></div></figure><p id="e672" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们假设你有一个商店，你用这个类给你喜欢的顾客打八折:当你决定给VIP顾客打双倍的八折。您可以像这样修改该类:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7e57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不，这不符合OCP原则。OCP教禁止这样做。如果我们想给不同类型的客户一个新的百分比折扣，你会看到一个新的逻辑将被添加。为了使它遵循OCP原则，我们将添加一个新的类来扩展折扣。在这个新类中，我们将实现它的新行为:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="d1b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你决定给超级VIP客户打八折，应该是这样的:</p><blockquote class="mp"><p id="207b" class="mq mr it bd ms mt mu mv mw mx my kn dk translated">没有修改的扩展。</p></blockquote><figure class="na nb nc nd ne me gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ae3cb531b22903770e1b6eac3d612727.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*9cxknUm5GIyd1t62qy6HOA.png"/></div></figure><h1 id="cbf2" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><span class="l lm ln lo bm lp lq lr ls lt di"> 3。</span>利斯科夫替代原理</h1><p id="56c5" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">Liskov Subtitution原则背后的主要思想是，对于任何类，客户端都应该能够不加区分地使用它的任何子类型，甚至不会注意到，因此不会损害运行时的预期行为。这意味着客户端是完全隔离的，不知道类层次结构的变化。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nf"><img src="../Images/6beedbfa055da7677cc270ef10ff0137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oKOS1298SaUjoW7YNpwEnw.png"/></div></div></figure><p id="f8ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ng">更正式地:<br/>设q(x)是关于t类型的x的对象的一个可证明的性质，那么q(y)对于S类型的对象y应该是可证明的，其中S是t的子类型</em></p><p id="beb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单来说，意味着一个对象或类的子类、子类或专门化必须适合其父类或超类。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="fb07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LSP的注释LSP是一个好的面向对象软件设计的基础，因为它强调了它的一个核心特征——多态性。它是关于创建正确的层次结构，以便从基类派生的类相对于它们接口上的方法沿着父类是多态的。有趣的是注意到这个原则与前一个原则的关系——如果我们试图用一个不兼容的新类来扩展一个类，它将失败，与客户端的契约将被破坏，结果这样的扩展将是不可能的(或者，为了使之成为可能，我们将不得不破坏原则的另一端，并修改客户端中应该关闭以进行修改的代码，这是完全不希望的和不可接受的)。</p><p id="7152" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">按照LSP建议的方式仔细考虑新类有助于我们正确地扩展层次结构。我们可以说LSP对OCP有贡献。</p><h1 id="59d8" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><span class="l lm ln lo bm lp lq lr ls lt di"> 4。</span>界面偏析原理</h1><p id="3cf1" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">不应该强迫特定于客户端的细粒度接口依赖于它们不使用的接口。这个原则处理实现大接口的缺点。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/1ae3c17f10801aaca914751b81bbdc94.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*4F4faKqXtTH87DyKWZOIrQ.jpeg"/></div></figure><p id="1640" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了完整地说明这一点，我们将举一个经典的例子，因为它非常重要而且容易理解。经典的例子</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2a72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个好的技巧是，在我们的业务逻辑中，如果需要，一个类可以实现几个接口。所以我们可以为接口之间的所有公共方法提供一个单一的实现。分离的接口也将迫使我们更多地从客户的角度考虑我们的代码，这反过来将导致松散耦合和易于测试。因此，我们不仅让我们的代码对客户更好，也让我们自己更容易理解、测试和实现。</p><h1 id="f57f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><span class="l lm ln lo bm lp lq lr ls lt di"> 5。</span>依赖反转原理</h1><p id="240b" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">依赖应该是抽象的，而不是具体的。高级模块不应该依赖于低级模块。低级和高级类应该依赖于相同的抽象。抽象不应该依赖于细节。细节应该依赖于抽象。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4d28b6cbdb0b803c009b582612d9c608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*pLf1DdkblANJDBdR6yURkg.png"/></div></figure><p id="3bd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在软件开发中，我们的应用程序将主要由模块组成。当这种情况发生时，我们必须通过使用依赖注入来解决问题。高级组件依赖于低级组件来运行。要创建特定的行为，可以使用继承或接口等技术。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="12a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以了解更多信息:</p><p id="1497" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mj" href="https://www.researchgate.net/publication/323935872_SOLID_Python_SOLID_principles_applied_to_a_dynamic_programming_language" rel="noopener ugc nofollow" target="_blank">实心蟒蛇</a></p><p id="f66b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mj" href="https://www.amazon.com/Clean-Code-Python-Refactor-legacy/dp/1788835832" rel="noopener ugc nofollow" target="_blank">清理Python中的代码</a></p></div></div>    
</body>
</html>