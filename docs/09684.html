<html>
<head>
<title>Creating New Enemy Types: The Porcupine Blowfish Part 3 — Firing Projectiles in Perfect Rotation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创造新的敌人类型:豪猪河豚第3部分-发射弹丸在完美的旋转</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-new-enemy-types-the-porcupine-blowfish-part-3-firing-projectiles-in-perfect-rotation-e1a1755093b4?source=collection_archive---------15-----------------------#2021-09-01">https://levelup.gitconnected.com/creating-new-enemy-types-the-porcupine-blowfish-part-3-firing-projectiles-in-perfect-rotation-e1a1755093b4?source=collection_archive---------15-----------------------#2021-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d42e8b527137ec5eee16bc75b16c82fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*slRT9OdGRlzOJqEWK8Ev0A.gif"/></div></div></figure><div class=""/><p id="78bd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章是个人的胜利。我心中有一个明确的目标，我不会把任何后备计划作为最终结果。我这篇文章的<strong class="kd jf">目标</strong>，是让敌人河豚发射一个<strong class="kd jf">随机</strong>数量的棘<strong class="kd jf">弹丸</strong>，同时给它们<strong class="kd jf">等距旋转轴</strong>围绕<strong class="kd jf"> 360度</strong>，这取决于<strong class="kd jf">发射了多少弹丸</strong>。我们开始吧！</p><p id="fcf8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最初，我只是想做一个从<em class="kz">中心点</em>向<em class="kz">各个方向</em>发射的<em class="kz">散布射击</em>武器。<strong class="kd jf">计划C </strong>是制作一个由空的父对象组成的预置，它将包含<em class="kz">预先旋转的</em>投射体预置。一旦父对象被实例化，射弹就会向各自的方向射出。我很高兴我最终没有选择这个方向，但是如果它对你的目标有用…那就去做吧！<strong class="kd jf">方案B </strong>是将物体实例化为围绕点的<em class="kz">圆，然后让它们<em class="kz">面朝外</em>远离点<em class="kz">(开火的敌人)</em>。我在搜索游戏教程以到达目的地时发现了这个解决方案。虽然这可能对我的目的有用，但我知道这不是我的初衷，如果做不到这一点，我个人就会放弃我最初的想法。让我们来看看我用<strong class="kd jf">计划A </strong>实际做了什么！</em></p><p id="ed98" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我开始创建一个新的<em class="kz">河豚刺</em>抛射体，并把它作为精灵资产带入Unity。我给的是一个<strong class="kd jf"> PolygonCollider2D </strong>和一个共享弹丸<strong class="kd jf">脚本</strong> <em class="kz"> (tusk) </em>，才做成一个预置。<em class="kz"> </em>因为我正在使用一个共享的抛射体脚本，所以我在<em class="kz">检查器</em>中给脊椎分配一个<strong class="kd jf">抛射体ID </strong>的<strong class="kd jf"> 2 </strong>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi la"><img src="../Images/db35d3591d28ff45ac0e652cfef93a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9ihp2mGgupGVrktXN6kmA.png"/></div></div></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="dd49" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我需要做的第一件事是整理我在<strong class="kd jf">长牙脚本</strong>中的基本<em class="kz">动作</em>。河豚脊椎将沿<strong class="kd jf">向上</strong>移动，并且在实例化的每个脊椎的旋转改变后，该方向将保持为<em class="kz">向前</em>的方向。我还设置了一个边界，如果它以任何方向离开游戏视图，我就摧毁它。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lm"><img src="../Images/60844d2525fcad3aae798092fe2a1464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TledEnde3ZtCI4afS813Iw.png"/></div></div></figure><p id="3d4f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在现在的<strong class="kd jf">敌人等级</strong>中，为散布射击增加了两个变量。一个用来存储<strong class="kd jf">预置</strong> <em class="kz">游戏对象</em>，另一个<strong class="kd jf">整数</strong>值用来存储一个空的<strong class="kd jf">数组</strong>来表示我想要发射多少个预置。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ln"><img src="../Images/48fd29ef2bac1121f886bc565c4675fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zP-5z8d_dRRZGhIX8q9T3Q.png"/></div></div></figure><p id="85ca" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Visual Studio中<strong class="kd jf">保存</strong>后，我可以在inspector中将<strong class="kd jf">预置</strong>分配给敌人<strong class="kd jf">脚本</strong>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lo"><img src="../Images/19dd5d30a8e069fe51a161ff5beee95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0IK-9-gWhWAlhmx_pTsuQ.png"/></div></div></figure><p id="bf14" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到<strong class="kd jf">敌人职业</strong>，我使用void <strong class="kd jf">更新</strong>来原型化这个特性。我正在使用<em class="kz">空格键</em>来触发敌人的火力特征，但是最终敌人会通过<em class="kz">协程</em>自己开火。首先，在射弹实例化之前需要做一些事情。引入一个名为<strong class="kd jf"> randomSpines </strong>的局部变量来保存<strong class="kd jf"> 3 </strong>和<strong class="kd jf"> 8之间的随机值。</strong> <em class="kz">(表头视频在3和53之间)。</em>这个<strong class="kd jf">变量</strong>将代表有多少射弹被实例化。<em class="kz"> </em>空的<strong class="kd jf">数组变量</strong>随后被赋予随机掷骰的<strong class="kd jf">值</strong>。这样我每按一次<em class="kz">空格键</em>键，要发射的弹丸量就会发生变化。</p><p id="c2e9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，循环的<strong class="kd jf">用于遍历数组。我引入了一个局部变量来存储将分配给每个抛射体<em class="kz">(blowfishSpineRotation)</em>的旋转，并为其分配<em class="kz">旋转算法</em>的<strong class="kd jf">值</strong>。我有一个<strong class="kd jf">调试。之后立即记录</strong>消息，这样我可以检查最终输出的数学结果。最后，随着for循环的执行，脊椎被实例化，并且旋转变量被放置在这个2D射击游戏的Z轴中，在一个四元数中。欧拉</strong>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lp"><img src="../Images/32e49e96d8858919f01e41ac5828f29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIMcPK0Oo9lWkaP5irKvYQ.png"/></div></div></figure><p id="5e7f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来分析一下。脊椎索引号只是一个数值，从零开始，代表我想要实例化多少投射物。在这个例子中，我将使用<strong class="kd jf"> 4 </strong>，因此目标将是按顺序将抛射体<em class="kz">向上</em>、<em class="kz">向左</em>、<em class="kz">向下</em>和<em class="kz">向右</em>。由于索引从零开始，方向看起来像这样<em class="kz">(上=索引0，左=索引1，下=索引2，右=索引3) </em>。每个抛射体都需要一个合适的<strong class="kd jf">旋转</strong>，看起来应该是这样的。<em class="kz">(旋转= 0 =向上=索引0，旋转90 =向左=索引1，旋转180 =向下=索引2，旋转270 =向右=索引3)。</em>如果你<strong class="kd jf">将<strong class="kd jf">索引号</strong>除以<strong class="kd jf">数组</strong>的<strong class="kd jf">长度</strong>，你得到的是<strong class="kd jf"> 0 </strong>和<strong class="kd jf"> 1 </strong>之间的<strong class="kd jf">分数</strong>。让我们算一下。指数<strong class="kd jf"> 0 </strong>除以<strong class="kd jf"> 4 </strong> = <strong class="kd jf"> 0 </strong>。太容易了。指数<strong class="kd jf"> 1 </strong>除以<strong class="kd jf"> 4 </strong> = <strong class="kd jf"> 0.25 </strong>。然后<strong class="kd jf"> 2/4 </strong> = <strong class="kd jf"> 0.5 </strong>和<strong class="kd jf"> 3/4 </strong> = <strong class="kd jf"> 0.75 </strong>。你明白这是怎么回事了吗？在我的脑子里，<strong class="kd jf"> 0.25 </strong>和<strong class="kd jf"> 1 </strong>的<strong class="kd jf"> % </strong>就像<strong class="kd jf"> 90度</strong>和<strong class="kd jf"> 360 </strong>一样，现在我只需要把<strong class="kd jf">转换成</strong>。进入下一步，例如将<strong class="kd jf"> 0.25 </strong>乘以<strong class="kd jf"> 100 </strong>，基本上<em class="kz">去掉了小数点</em>，使得当前值<strong class="kd jf">为25 </strong>。然后，<strong class="kd jf"> 25 </strong>为<em class="kz">乘以<strong class="kd jf"> 360 </strong> <em class="kz">(最大旋转度数)</em>，使得<strong class="kd jf">的值为9000</strong>。最后一招是用<strong class="kd jf">9000</strong>除以<strong class="kd jf"> 100 </strong> ( <em class="kz">我知道这看似多余但很管用！)</em>这给了我们<strong class="kd jf"> 90 </strong>的回报！其他旋转以相同的方式工作。2/4 = 0.5 * 100 = 50 * 360 = 18000/100 =旋转180度。3/4 = 0.75 * 100 = 75 * 360 = 27,000 / 100 = 270.</em></strong></p><p id="309b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">重要提示:</strong>我将<strong class="kd jf"> int </strong>值相除，得到一个小于<strong class="kd jf"> 1 </strong>的<strong class="kd jf">分数</strong>返回。如果我不将这个值强制转换为一个<strong class="kd jf">float</strong>T10】((float)spine index)，小数将向下舍入，返回将始终为零。我的<strong class="kd jf">浮点</strong> <em class="kz">旋转变量</em>需要返回一个<strong class="kd jf">匹配浮点</strong> <em class="kz">数据类型</em>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lp"><img src="../Images/86eb50fc1689a5d9e90dc92f092c01c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnAyksz2XhHCWQV3N8p0GQ.png"/></div></div></figure><p id="4348" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">帮我解决这个问题。乘以然后除以100看起来确实有点不必要。我尝试从一个大的数字(360)开始，然后除以数组的长度(本例中为4)。这给了我90的回报率，这是完美的，比我在上面做的更有效率。如果我用<strong class="kd jf">指数</strong>乘以<strong class="kd jf"> 90 </strong>，我就会得到我想要的回报。90 * 0 = 0.90 * 1 = 90.90 * 2 = 180，90 * 3 = 270。不过我注意到，当像标题视频剪辑中那样通过给它喂大量弹丸来进行压力测试时，我在360度旋转的最后15%左右得到了一个空白空间。我试着把所有的值都转换成float，它至少在处理少量的投射时工作得很好。数学似乎是合理的，所以我将不得不进一步分解它，并找出为什么我得到一个错误的大数组长度的返回。现在我仍然使用第一个看起来多余的算法，因为它在高压力下工作得很好。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/e97a84af93b37e7065442d0897dae2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nSatXeYqgDNZ17qW4Jp3w.png"/></div></div></figure><p id="867e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随意帮我完善这个算法。我认为这也不仅仅适用于360度旋转。这是我尽可能用一般的变量名写出的一般想法，希望能展示这里的思考过程。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lr"><img src="../Images/faeff231d8a6eb701acdde3b7dc63799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78S7g15P9lcTH-bb_kaSsg.png"/></div></div></figure><p id="315d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢你和我一起阅读这篇关于抛体对称性的数学冒险。希望下次能见到你！</p></div></div>    
</body>
</html>