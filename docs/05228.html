<html>
<head>
<title>Building Micro Frontend with SSR — Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SSR构建微前端——路由</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-micro-frontend-with-ssr-part-2-routing-d86480de8894?source=collection_archive---------8-----------------------#2020-08-13">https://levelup.gitconnected.com/building-micro-frontend-with-ssr-part-2-routing-d86480de8894?source=collection_archive---------8-----------------------#2020-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5603618d24550a3dbebdfe7a02a36a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m5tYoJ6A7cxtHqdNXT3MjQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">尼克·蒂梅尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1693" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章是第一篇<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-your-first-micro-frontend-with-ssr-in-minutes-95cd57788529">的延续，可以在这里找到第一篇</a>。然而，如果你是一个有经验的开发人员——请放心从这个开始。</p><p id="45df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一部分中，我们将展示如何将一个使用<a class="ae kc" href="https://reactrouter.com/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> React router </a>的应用程序转变为与<a class="ae kc" href="https://github.com/namecheap/ilc" rel="noopener ugc nofollow" target="_blank">同构布局编辑器</a>协同工作的微前端。</p><h1 id="3dea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一点理论…</h1><p id="7542" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">应用微前端架构时，首先需要解决的问题之一是路由。这是因为您不再有一个单独的React/Vue.js/etc应用程序来处理所有的路线转换。现在你有多个应用程序同时在网页上工作，你需要知道哪些应用程序在当前URL的页面上应该是活动的。</p><p id="9d09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<a class="ae kc" href="https://github.com/namecheap/ilc" rel="noopener ugc nofollow" target="_blank">同构布局编辑器</a> (ILC)中，通过使用所谓的“2层路由”方法来解决这个问题。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/554cecbb189dcc4bf16bb4c82efbf774.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*3rPyeHDaEWVlaVnlBwjCgA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">“两层路由”方法</figcaption></figure><p id="e542" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，用户在<code class="fe mj mk ml mm b">/news/latest</code> URL打开了一个页面。它与ILC中配置的<code class="fe mj mk ml mm b">/news/*</code>路由相关，该路由包含关于应该加载到页面上的应用程序和它们需要接收的道具的信息。当我们将应用程序加载并挂载到它的容器DOM节点时——我们还传递了应用程序的路由器在工作期间应该使用的<code class="fe mj mk ml mm b">basePath</code>属性。</p><p id="feb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是理论已经足够了——让我们看看一些真实的代码。</p><h1 id="e508" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">出发点</h1><p id="56ea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们将从样本React应用程序开始，它有3个内部路径:Home、Tic-Tac-Toe游戏和Snake游戏。</p><p id="2615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请去这里抢:<a class="ae kc" href="https://github.com/StyleT/ilc-learning-react/tree/step_2-Router" rel="noopener ugc nofollow" target="_blank">https://github . com/StyleT/ILC-learning-react/tree/step _ 2-Router</a>(需要使用<code class="fe mj mk ml mm b">step_2-Router</code>分支)。在git克隆之后，运行<code class="fe mj mk ml mm b">npm i &amp;&amp; npm start</code>。</p><p id="6c50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者你可以使用<a class="ae kc" href="https://codesandbox.io/s/github/StyleT/ilc-learning-react/tree/step_2-Router" rel="noopener ugc nofollow" target="_blank"> codesandbox.io </a>让它在云中为你运行。我建议使用<a class="ae kc" href="https://codesandbox.io/s/github/StyleT/ilc-learning-react/tree/step_2-Router" rel="noopener ugc nofollow" target="_blank"> codesandbox.io </a>来消除我们前进过程中可能出现的所有本地环境相关问题。</p><p id="9b68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你启动应用程序时——尝试浏览菜单中的链接，禁用JavaScript执行以查看SSR输出，等等…</p><p id="ff9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你刚刚完成了这篇文章的第一部分<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-your-first-micro-frontend-with-ssr-in-minutes-95cd57788529">——看看<code class="fe mj mk ml mm b">master</code>分支和<code class="fe mj mk ml mm b">step_2-Router</code>之间的区别。查看发生了什么变化。</a></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/39dfe4c2bc698fd3c9f2ecc4d4333298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDJeUP9XoHVn0iyGB102Qg.png"/></div></div></figure><h1 id="dabc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使应用程序适应ILC</h1><p id="b53a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了让我们的React应用程序与ILC一起播放，我们需要让它符合<a class="ae kc" href="https://github.com/namecheap/ilc/blob/b4622ee06f6c3e52a045d156ba346eeb90b51237/docs/ilc_app_interface.md" rel="noopener ugc nofollow" target="_blank"> ILC到应用程序接口</a>。幸运的是，这很容易，浏览源代码并解决所有我为你放在那里的<code class="fe mj mk ml mm b">//TODO:</code>注释。</p><p id="3fc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你完成这项工作，重启应用程序并尝试打开<code class="fe mj mk ml mm b">/microfrontend</code>路线。你应该得到<code class="fe mj mk ml mm b">200 OK</code>响应代码&amp;一些SSR标记。</p><blockquote class="mo mp mq"><p id="cb19" class="kd ke mr kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated"><strong class="kf ir">注意</strong>:如果有任何问题—尝试切换到回购中的<code class="fe mj mk ml mm b">step_2-Router_ILC_integrated</code>分支—它已经为您完成了所有更改。</p></blockquote><h1 id="e742" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">配置ILC以处理新应用程序</h1><p id="5ac4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在这一步中，我们将使用我们的公共演示网站和"<a class="ae kc" href="https://github.com/namecheap/ilc/blob/cdf6afaa73c3dd7358036ebb0fae3cf0b0ec391f/docs/develop_at_production.md" rel="noopener ugc nofollow" target="_blank">开发“生产”</a> " ILC功能来完成任务。我们这样做只是为了简单起见。然而，您可以使用本地运行的ILC获得非常相同的结果。</p><p id="d870" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于如何为您的特殊情况确定公共和SSR路径的更多信息—您可以在之前的文章中找到<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-your-first-micro-frontend-with-ssr-in-minutes-95cd57788529#9f88">。</a></p><p id="e07c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们打开<a class="ae kc" href="http://demo.microfrontends.online/nosuchpath" rel="noopener ugc nofollow" target="_blank">demo.microfrontends.online/nosuchpath</a>，通过在浏览器中设置“魔法cookie”——让我们动态更改ILC配置:</p><pre class="mf mg mh mi gt mv mm mw mx aw my bi"><span id="2f82" class="mz lc iq mm b gy na nb l nc nd">var publicPath = 'https://abcde.sse.codesandbox.io/public/';<br/>var ssrPath = 'https://abcde.sse.codesandbox.io/microfrontend';</span><span id="a102" class="mz lc iq mm b gy ne nb l nc nd">var overrideConfig = encodeURIComponent(JSON.stringify({<br/>    apps: {<br/>        '@portal/myapp': {<br/>            spaBundle: publicPath + 'client.js',<br/>            cssBundle: publicPath + 'style.css',<br/>            ssr: {<br/>                src: ssrPath,<br/>                timeout: 10000,<br/>            },<br/>            props: { publicPath },<br/>            kind: 'primary',<br/>        },<br/>    },<br/>    routes: [{<br/>        routeId: 555,<br/>        route: '/nosuchpath/*',<br/>        slots: {<br/>            body: {<br/>                appName: '@portal/myapp'<br/>            }<br/>        }<br/>    }]<br/>}));<br/><br/>document.cookie = `ILC-overrideConfig=${overrideConfig}; path=/;`</span></pre><p id="3c73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码执行后刷新页面。如果你做的一切都正确——你应该能够看到你的应用程序在一个公共的ILC演示网站上运行。</p><blockquote class="mo mp mq"><p id="9811" class="kd ke mr kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated">如果对你不起作用，请确保 <code class="fe mj mk ml mm b"><em class="iq">ssrPath</em></code> <em class="iq">不仅可以从你的机器上访问(使用</em><a class="ae kc" href="https://reqbin.com/" rel="noopener ugc nofollow" target="_blank"><em class="iq">【https://reqbin.com/</em></a><em class="iq">)而且JS/CSS链接确实可以从你的机器上工作。</em></p></blockquote><h1 id="ecf5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">探索结果</h1><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/6625e85a97ded50aff3830e791b85012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oPWUBZ7ugCRgjNAH2VVZmA.png"/></div></div></figure><p id="c227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以通过自己的微前端中相应页面的链接来尝试玩一些井字游戏和贪吃蛇游戏😎</p><p id="d012" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关注“演示新闻app”链接。尽管它是一个普通的<code class="fe mj mk ml mm b">&lt;a&gt;</code>标签，但它不会导致页面重新加载，并能顺利加载另一个应用。这是ILC的特性之一，有助于它与遗留的单片应用程序一起工作。</p><p id="5271" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，尝试禁用JS执行，并再次浏览链接。请注意，所有页面看起来都与启用JS时完全一样(除了您现在不能玩游戏的事实)。</p><h1 id="5730" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="a5f0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在大约半个小时的时间里，我们把最简单的基于反应路由器的应用程序变成了一个微型前端，我希望它对你来说很好很容易。</p><p id="1535" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你开始使用微前端架构时，它是非常复杂的。但是<a class="ae kc" href="https://github.com/namecheap/ilc" rel="noopener ugc nofollow" target="_blank">同构布局编辑器</a>提供的适当工具链可以简化很多事情。</p><p id="4c4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢这篇文章——给它一个掌声—“星”我们的<a class="ae kc" href="https://github.com/namecheap/ilc" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。希望在本系列的下一集中能再次见到你，我们将会探索元标签处理、状态水合以及微前端开发的其他更高级的方面。</p></div></div>    
</body>
</html>