<html>
<head>
<title>Implement A Third-Person Camera just like Mario Odyssey In Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现第三人称摄像机，就像《马里奥奥德赛》中的Unity一样</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implement-a-third-person-camera-just-like-mario-odyssey-in-unity-e21744911733?source=collection_archive---------1-----------------------#2021-01-24">https://levelup.gitconnected.com/implement-a-third-person-camera-just-like-mario-odyssey-in-unity-e21744911733?source=collection_archive---------1-----------------------#2021-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f79d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将讲述我如何使用unity的Cinemachine和一些额外的代码实现一个像《马里奥奥德赛》中的相机一样移动的第三人称相机。</p><p id="b06f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从第一款带有自由视角相机的3D平台游戏《马里奥64》发布以来，如何设计一个好的相机系统一直是每个开发人员在创作第三人称视角游戏时的问题。</p><div class="kl km kn ko gt ab cb"><figure class="kp kq kr ks kt ku kv paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/bdfcf411f8fbd1eafff2ef6738ec0b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*gsbGRy6LpyOTIEQAXsyQaA.png"/></div></figure><figure class="kp kq lc ks kt ku kv paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/9b0bb51a5e9317d7ea50bfa14cd704bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*AechrbVmGWxI0f1WPPejOw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk lh di li lj translated">马里奥64</figcaption></figure></div></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="702f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几周前，我开始着手我的个人项目，目标是做一个3D游戏。我在环境上工作了一段时间，玩着色器，渲染&amp;尝试了一些随机的想法。经过数周的实验。我觉得是时候在我的游戏中加入第三人称角色控制器了。</p><p id="f942" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我没有使用Unity内置的角色控制器组件，而是选择在资产商店中使用<a class="ae lr" href="https://assetstore.unity.com/packages/tools/physics/kinematic-character-controller-99131" rel="noopener ugc nofollow" target="_blank">运动角色控制器</a>。该插件基本上为我处理任何与碰撞相关的计算。而且，它让我可以通过编程完全控制输入、动画和速度/旋转处理。我将来可以自由地实现任何一种游戏。听起来非常适合程序员！</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ls"><img src="../Images/5f6a3878f13007204e069999a1ac1c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZfUPkAH8jTFgsYpwJEXYg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">我们可以在unity资产商店找到各种各样的角色控制器插件。我更喜欢那些可以给我最大的自由来通过编码定制我的游戏。</figcaption></figure><p id="da3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着示例脚本的正确设置，我现在可以移动我的角色和摄像机了。但是样本脚本中当前的轨道摄像机行为对我来说肯定是不够的。我甚至在unity编辑器中移动后感到有点恶心！</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lt"><img src="../Images/2a661d1f12eebe6206ea0d34ff256030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1X_m_uNKNob52wyaOySJ9A.gif"/></div></div></figure></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="6a2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">晕动病/恶心一直是视频游戏中的一个问题。如果镜头随着角色移动太精确？人们生病了。<br/>动作太慢还是太快？仍然会引起疾病。真正的解决方案可能是坚持使用固定的摄像机。但是如果我们想要一个可以跟随玩家并且可以自由环视的相机呢？为了克服这个问题。我必须用第三人称相机研究其他游戏。</p><p id="32ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用马里奥奥德赛作为我的主要参考。甚至它可能不是所有游戏的完美解决方案。我认为它有一些伟大的想法，我们可以借鉴。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="9587" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">相机行为</h1><p id="8110" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">让我们移动马里奥，分解它的摄像头的所有行为。</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/1058d2d4c8c22da765d1df8965d3234b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*0LWOIwKyFS_Wfm1ajeTmAQ.gif"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">相机将顺利Marios</figcaption></figure><p id="0a10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦马里奥开始奔跑，摄像机就会跟进。下面的运动应该是一个平滑的运动。它使用<a class="ae lr" href="https://en.wikipedia.org/wiki/Linear_interpolation" rel="noopener ugc nofollow" target="_blank">线性插值</a>不断缩小相机和活动玩家之间的距离。</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi my"><img src="../Images/622de274f4f98af93484a9e0aff59eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QqFckdUE2daDWXDSPX57dw.png"/></div></div></figure><p id="bb05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">镜头似乎聚焦在马里奥的头顶。原因可能是因为玩家更容易进行平台化。因为玩家可以更多地关注环境。</p><p id="3a25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看当马里奥表演不同跳跃时会发生什么。</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3a59526ff88161f1f453867258299ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*JRzAqwCNu06JKxRd_pIKsA.gif"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">正常跳跃</figcaption></figure><figure class="kl km kn ko gt kq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ba96e55010d88a4af8b7fb4f4f0bef82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*hvreRG90mqttaMPItLIS8g.gif"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">马里奥表演跳胯时，镜头上移。</figcaption></figure><p id="4698" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里面有什么隐藏的诡计！当执行正常跳跃时，摄像机没有沿着Y轴移动。相机将只沿着XZ平面移动。但是当玩家执行“<strong class="jp ir">臀降跳</strong>”时。就在马里奥跳出视口空间中一个不可见窗口之前，摄像机向上移动。我们得到了另一个规则:“如果玩家要从一个自定义大小的相机窗口移出，相机可以沿Y轴移动”。</p><p id="9c1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上行为尚未完成。如果马里奥双脚着地移动，摄像机也会更新它的Y位置。</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4483b75e2130a1c430f2ad1c89efa140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*GPH7e_irOBIMjX07M1wf8A.gif"/></div></figure><p id="952f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">触发相机更新其Y位置的最后一件事是降落在不同高度的平台上。<a class="ae lr" href="https://www.gamasutra.com/blogs/ItayKeren/20150511/243083/Scroll_Back_The_Theory_and_Practice_of_Cameras_in_SideScrollers.php" rel="noopener ugc nofollow" target="_blank">这篇博文</a>称之为平台抢购。一旦玩家降落在另一个平台上，摄像机将捕捉到玩家的当前位置。</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/7b74e7c9176c7dd014583bcf0be1ebd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*UM4q_N-W_wH5uZKBCWRyvg.gif"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">请注意，当马里奥降落在平台上时，摄像机只更新其Y位置</figcaption></figure><p id="5c91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们总结一下我们发现的所有相机行为。</p><ol class=""><li id="2e44" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated"><strong class="jp ir">焦点在人物的上面</strong></li><li id="fe97" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">将玩家留在相机窗口内。</li><li id="3d5d" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><strong class="jp ir">当玩家降落在不同高度的平台上时，捕捉到角色的位置。</strong></li><li id="97f1" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><strong class="jp ir">如果满足上述所有条件。当玩家在地面上移动时，它只更新摄像机目标的Y位置。</strong></li><li id="9ec7" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated"><strong class="jp ir"> Lerp平滑运动。</strong></li></ol><p id="00b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是安装我们的摄像机。在这里，我使用Unity的Cinemachine作为我的游戏的相机系统的基石。Cinemachine有一些很棒的功能，包括相机混合、碰撞处理、速度阻尼等等。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h2 id="3c3b" class="nn lv iq bd lw no np dn ma nq nr dp me jy ns nt mi kc nu nv mm kg nw nx mq ny bi translated">关于电影院</h2><figure class="kl km kn ko gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nz"><img src="../Images/860c45374deb52765e2faf99dc9c9b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Xpk1WCJCI1yN7xmQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Cinemachine是一套用于操作Unity摄像机的模块。Cinemachine解决了跟踪目标、构图、混合和镜头间剪切的复杂数学和逻辑。它旨在显著减少开发过程中耗时的手动操作和脚本修改。</figcaption></figure></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="44fb" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">安装我们的摄像机</h1><p id="7b01" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">在<strong class="jp ir">CinemachineFreeLookCamera</strong>的帮助下。我们可以得到一个强大的第三人轨道摄像机。调整参数后，我们得到如下结果:</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/32ba6a8daf48ae58d2c37a3e8c51a6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*yPxC93rrx7uCFEue4aKgGg.gif"/></div></figure><p id="c36f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就现在。摄像机将聚焦于cinemachine组件中的<strong class="jp ir">注视/跟随</strong>变换集。这是我的角色控制器的网格变换。</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ob"><img src="../Images/35b6523dbf1792db31018458e43711a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_Xirqt-GqnhfC4JLMaU2A.png"/></div></div></figure><p id="f2b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现类似平台捕捉的行为。而不是跟随角色本身。我们必须遵循一个<strong class="jp ir">幽灵</strong>变换。然后，通过脚本更新它的世界位置。</p><p id="49f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个空变换(重影。我在这里把它命名为<em class="oc"> cameraFollowTarget </em>。拖动这个变换到<strong class="jp ir">看</strong>和<strong class="jp ir">跟随</strong>我们的cinemachine free look相机的属性。</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi od"><img src="../Images/69300c947d55c69a20bd6fc31c28843d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWXlHAnVNXhGXJP_vr7J4A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">用于调试。我使用一个相机模型作为鬼变换的网格。</figcaption></figure><p id="5e38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们在每次调用<strong class="jp ir"> LateUpdate </strong>时更新幻影转换的位置。</p><pre class="kl km kn ko gt oe of og oh aw oi bi"><span id="32c1" class="nn lv iq of b gy oj ok l ol om">LateUpdate()<br/>{<br/>    ghostTransform.position = new <em class="oc">Vector3</em>(CharacterMesh.position.x,    ghostPositionY, CharacterMesh.position.z</span><span id="c4c7" class="nn lv iq of b gy on ok l ol om">}</span></pre><p id="8cbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有在以下情况下<strong class="jp ir">ghostpositionony</strong>变量才会改变:角色试图从视口移出或它满足行为3 &amp;行为4。</p><pre class="kl km kn ko gt oe of og oh aw oi bi"><span id="f7e7" class="nn lv iq of b gy oj ok l ol om">// only invoke when character leaving the ground via jump or fall<br/>void OnLeaveGround()<br/>{<br/>    // update Y for behavior 3<br/>    ghostPositionY = CharacterMesh.position.y;<br/>}</span><span id="0197" class="nn lv iq of b gy on ok l ol om">LateUpdate()<br/>{<br/>    <em class="oc">Vector3</em> characterViewPos = cam.WorldToViewportPoint(CharacterMesh.position + characterVelocity * Time.deltaTime);<br/>    <br/>    // behavior 2<br/>    if (viewPos.y &gt; 0.85f || viewPos.y &lt; 0.3f)<br/>    {<br/>        ghostPositionY = CharacterMesh.position.y;<br/>    }<br/>    // behavior 4<br/>    else if(controller.IsGrounded)<br/>    {<br/>        ghostPositionY = CharacterMesh.position.y;<br/>    }<br/>     <br/>     // Move the ghost<br/>     ghostTransform.position = new <em class="oc">Vector3</em>(CharacterMesh.position.x,    ghostPositionY, CharacterMesh.position.z</span><span id="66e9" class="nn lv iq of b gy on ok l ol om">}</span></pre><p id="d5c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有行为都设置好了。结果如下:</p><figure class="kl km kn ko gt kq gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/77f5fd872aed1800b9a0270a10d07688.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*FFePGa9WGhKvcQJ8KI1w-w.gif"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">幽灵变身的位置变化看起来很突然。</figcaption></figure><p id="6bd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重影变换看起来缺乏流畅的动作。把它抹平。使用矢量3。更新幽灵位置时的SmoothDamp api。</p><pre class="kl km kn ko gt oe of og oh aw oi bi"><span id="d72d" class="nn lv iq of b gy oj ok l ol om">var desiredPosition = new <em class="oc">Vector3</em>(CharacterMesh.position.x, ghostPositionY, CharacterMesh.position.z);</span><span id="41c1" class="nn lv iq of b gy on ok l ol om">ghostTransform.position = Vector3.SmoothDamp(ghostTransform.position, desiredPosition, ref vel, desiredSmoothTime, followSpeed);</span></pre><figure class="kl km kn ko gt kq gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/402418aa6d9102ee3fe707f717b98849.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*-sjT4AxZTRNbHWOMfegiEA.gif"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">重影变换现在跟随平滑地更新它的位置。</figcaption></figure><p id="abe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，脚本将如下所示:</p><pre class="kl km kn ko gt oe of og oh aw oi bi"><span id="086d" class="nn lv iq of b gy oj ok l ol om">private float ghostPositionY;</span><span id="8c9e" class="nn lv iq of b gy on ok l ol om">// only invoke when character leaving the ground via jump or fall<br/>void OnLeaveGround()<br/>{<br/>    // update Y for behavior 3<br/>    ghostPositionY = CharacterMesh.position.y<br/>}</span><span id="b7b1" class="nn lv iq of b gy on ok l ol om">LateUpdate()<br/>{<br/>    <em class="oc">Vector3</em> characterViewPos = cam.WorldToViewportPoint(CharacterMesh.position + characterVelocity * Time.deltaTime);<br/>    <br/>    // behavior 2<br/>    if (viewPos.y &gt; 0.85f || viewPos.y &lt; 0.3f)<br/>    {<br/>        ghostPositionY = CharacterMesh.position.y;<br/>    }<br/>    // behavior 4<br/>    else if(controller.IsGrounded)<br/>    {<br/>        ghostPositionY = CharacterMesh.position.y;<br/>    }</span><span id="03ec" class="nn lv iq of b gy on ok l ol om">    // behavior 5<br/>    var desiredPosition = new <em class="oc">Vector3</em>(CharacterMesh.position.x, ghostPositionY, CharacterMesh.position.z);</span><span id="a9a4" class="nn lv iq of b gy on ok l ol om">    ghostTransform.position = Vector3.SmoothDamp(ghostTransform.position, desiredPosition, ref vel, desiredSmoothTime, followSpeed);</span><span id="ef46" class="nn lv iq of b gy on ok l ol om">}</span></pre><p id="c23d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">行为1可以简单地通过设置<strong class="jp ir"> CharacterMesh </strong>作为我们角色的子对象，并使其位于角色顶部来实现。</p><p id="35fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的一点是:上面的代码是为了显示更新相机位置的时间，而不是完整的代码。因为不同角色控制器有不同的冲突处理api。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="b776" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="5750" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">好吧。要加载很多gif。有很多功能我还没有谈到。像碰撞器碰撞和马里奥在物体后面时的透明度抖动。或者我们可以在过场动画中使用的大量相机混合。但我认为有很多帖子能比我更好地解释这些特性。</p><p id="f535" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将使用当前的设置来测试更多的游戏创意。如果我发现任何有趣的分享，我会写更多。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="ef7b" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">一些参考</h1><p id="30e3" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated"><a class="ae lr" href="https://www.gamasutra.com/blogs/AndreasBuehler/20191111/353709/Third_Person_Camera_View_in_Games__a_record_of_the_most_common_problems_in_modern_games_solutions_taken_from_new_and_retro_games.php" rel="noopener ugc nofollow" target="_blank">游戏中的第三人称视角——记录现代游戏中最常见的问题，从新游戏和复古游戏中获得解决方案</a></p><p id="a163" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lr" href="https://www.gamasutra.com/blogs/ItayKeren/20150511/243083/Scroll_Back_The_Theory_and_Practice_of_Cameras_in_SideScrollers.php" rel="noopener ugc nofollow" target="_blank">回卷:侧卷相机的理论与实践</a></p><p id="f22a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lr" href="https://roystanross.wordpress.com/downloads/" rel="noopener ugc nofollow" target="_blank">超级角色控制器</a></p></div></div>    
</body>
</html>