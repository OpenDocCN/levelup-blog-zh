<html>
<head>
<title>Deploying and scaling Node.js on Google Kubernetes Engine with Continuous Integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过持续集成在Google Kubernetes引擎上部署和扩展Node.js</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dockerizing-deploying-and-scaling-node-js-on-google-kubernetes-engine-with-continuous-integration-f895a98bf6e3?source=collection_archive---------1-----------------------#2019-03-19">https://levelup.gitconnected.com/dockerizing-deploying-and-scaling-node-js-on-google-kubernetes-engine-with-continuous-integration-f895a98bf6e3?source=collection_archive---------1-----------------------#2019-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/59ffda4e50af793aab0a9f760f48c43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dP4hbotjItLH6om1cSFPbA.jpeg"/></div></div></figure><h2 id="c1aa" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">目录</h2><ul class=""><li id="66f4" class="ku kv iq kw b kx ky kz la kh lb kl lc kp ld le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#b767" rel="noopener">简介</a></li><li id="c45c" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#9331" rel="noopener">设置Node.js服务器</a></li><li id="65e2" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#46f7" rel="noopener">建立谷歌云</a></li><li id="23d2" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#4591" rel="noopener"> Dockerize Node.js </a></li><li id="9130" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#3065" rel="noopener">将映像部署到容器注册表</a></li><li id="7c07" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#f4b0" rel="noopener">创建Kubernetes集群</a></li><li id="4c93" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#d2ed" rel="noopener">保留静态IP地址</a></li><li id="3e48" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#290b" rel="noopener">创建Kubernetes服务</a></li><li id="8113" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#8407" rel="noopener"> Kubernetes自动缩放</a></li><li id="cdcb" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#9eb6" rel="noopener">设置谷歌密钥管理服务</a></li><li id="ccee" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/f895a98bf6e3#29be" rel="noopener">设置云构建</a></li></ul><h1 id="b767" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">介绍</h1><p id="67fc" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">这篇文章将介绍如何使用Google Kubernetes引擎(GKE)将Node.js服务器部署在Kubernetes集群上。我们将设置一个Node.js服务器，创建一个docker文件来定义容器配置，创建Kubernetes服务文件来定义我们所需的Kubernetes资源，并设置Google Cloud Build来实现自动持续集成(CI)。我上传了我自己的代码到GitHub <a class="ae lj" href="https://github.com/francescov1/gke-tutorial" rel="noopener ugc nofollow" target="_blank">这里</a>以防你在这个过程中遇到任何问题，所以一定要把它放在手边！</p><p id="315b" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">如果你已经完成了我关于使用谷歌计算引擎dockerizing和部署Node.js的教程，或者你已经有了dockerized Node.js应用，你可以浏览本教程的前几个步骤，因为它们大部分是重复的。</p><p id="12a5" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">如果您有自己想要使用的Node.js应用程序，这也很好，尽管用一个简单的应用程序来完成本教程可能更容易，以避免任何不必要的错误。出于本教程的目的，我将使用我编写的节点样板脚本—<a class="ae lj" href="https://github.com/francescov1/node-boilerplate-script" rel="noopener ugc nofollow" target="_blank">https://github.com/francescov1/node-boilerplate-script</a>。</p><p id="0048" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated"><em class="na">注意:如果你正在使用你自己的Node.js代码，确保它被设置为在</em> <strong class="kw ir"> <em class="na">端口3000 </em> </strong> <em class="na">上运行，因为我将为所有Docker和Google Cloud配置使用该端口。</em></p><h1 id="9331" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">设置Node.js服务器</h1><p id="a549" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">如果您正在使用自己的Node.js应用程序，请跳过这一步。我们将克隆节点样板脚本repo，创建一个新文件夹并运行脚本。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="96cd" class="jy jz iq ng b gy nk nl l nm nn">git clone <a class="ae lj" href="https://github.com/francescov1/node-boilerplate-script.git" rel="noopener ugc nofollow" target="_blank">https://github.com/francescov1/node-boilerplate-script.git</a></span><span id="99f4" class="jy jz iq ng b gy no nl l nm nn">mkdir gke-tutorial<br/>cp node-boilerplate-script/node-init.sh gke-tutorial/<br/>cd gke-tutorial/<br/>bash node-init.sh</span></pre><p id="3abe" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">几分钟后，它应该是完整的。运行<code class="fe np nq nr ng b">npm start</code>并导航到<a class="ae lj" href="http://localhost:3000/api/examples/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/examples/hello</a>，在这里你应该会看到“hello world”。</p><h1 id="46f7" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">设置Google云</h1><p id="8494" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">接下来，我们将设置谷歌云。如果你没有谷歌云账户，请访问https://cloud.google.com/free<a class="ae lj" href="https://cloud.google.com/free/" rel="noopener ugc nofollow" target="_blank">网站</a>了解更多信息，并获得创建账户的指导。注册后，您将获得300美元的免费积分，因此不必担心需要为您在本教程中创建的资源付费。</p><p id="793e" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">在Google Cloud控制台中创建新项目。如果你以前从未这样做过，请参见<a class="ae lj" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/resource-manager/docs/creating-managing-projects</a>。我们将把我们的项目叫做<em class="na"> gke-tutorial </em>。</p><p id="c3bc" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">接下来前往<a class="ae lj" href="https://cloud.google.com/sdk/docs/#install_the_latest_cloud_tools_version_cloudsdk_current_version" rel="noopener ugc nofollow" target="_blank">https://Cloud . Google . com/SDK/docs/# install _ the _ latest _ Cloud _ tools _ version _ Cloud SDK _ current _ version</a>下载Google Cloud CLI(如果您尚未下载)，我们将使用它来部署Kubernetes资源。</p><p id="2aa7" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">一旦安装完毕，运行<code class="fe np nq nr ng b">gcloud init</code>。这将引导您完成对CLI的身份验证和选择项目。</p><h1 id="4591" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">Dockerize Node.js</h1><p id="24dd" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">我们现在可以在部署Node.js服务器之前为它设置Docker。Docker允许我们以一种易于移植和可伸缩的格式来封装我们的应用程序。我不会详细介绍Docker或它的好处，所以如果你有兴趣，可以去看看https://dzone.com/articles/top-10-benefits-of-using-docker。</p><p id="21aa" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我将使用Atom，但也可以随意使用任何其他文本编辑器。创建Dockerfile文件并。在你的文本编辑器中打开工作目录。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c3a5" class="jy jz iq ng b gy nk nl l nm nn">touch Dockerfile .dockerignore</span></pre><p id="f8fb" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">将以下代码添加到您的<em class="na">中。dockerignore </em>:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="62f4" class="jy jz iq ng b gy nk nl l nm nn">node_modules<br/>npm-debug.log</span></pre><p id="c48d" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">上面定义了构建Docker映像时要忽略的文件和文件夹。将以下代码添加到您的<em class="na">docker文件</em>中:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="bf0e" class="jy jz iq ng b gy nk nl l nm nn"># version of node to use<br/>FROM node:8</span><span id="1e05" class="jy jz iq ng b gy no nl l nm nn"># define working directory for docker<br/>WORKDIR /usr/src/app</span><span id="d30c" class="jy jz iq ng b gy no nl l nm nn"># copy all our source code into the working directory<br/>COPY . .</span><span id="801d" class="jy jz iq ng b gy no nl l nm nn"># install npm dependencies and pm2<br/>RUN npm install --only=production &amp;&amp; npm install -g pm2</span><span id="fa4a" class="jy jz iq ng b gy no nl l nm nn"># expose port 3000 for our server to run on<br/>EXPOSE 3000</span><span id="ca9d" class="jy jz iq ng b gy no nl l nm nn"># command to start our server<br/>CMD [ "pm2-runtime", "start", "index.js" ]</span></pre><p id="4817" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">Pm2是一个进程管理器，我们将使用它来启动我们的服务器。它捆绑了大量很酷的功能，如集群和负载平衡。点击这里了解更多信息<a class="ae lj" href="https://pm2.io/runtime" rel="noopener ugc nofollow" target="_blank">https://pm2.io/runtime</a>。<code class="fe np nq nr ng b">CMD [ “pm2-runtime", “start", “index.js" ]</code>行启动我们的Node.js服务器。</p><h1 id="3065" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">将映像部署到容器注册中心</h1><p id="3073" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">我们现在可以将Docker映像部署到Google容器注册中心，在那里它可以被Google Cloud上的其他服务访问。在根目录下运行以下命令:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="2f17" class="jy jz iq ng b gy nk nl l nm nn">gcloud builds submit --tag gcr.io/&lt;project-id&gt;/gke-tutorial-image .</span></pre><p id="66aa" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">如果提示您启用cloudbuild API，请输入yes。</p><h1 id="f4b0" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">创建Kubernetes集群</h1><p id="ddf2" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">我们现在将在Google Cloud中创建一个Kubernetes集群。乍看之下，Kubernetes可能令人望而生畏，因此这里有几篇文章可供查阅，以获得可靠的总体概述:<a class="ae lj" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes概述</a>、<a class="ae lj" href="https://cloud.google.com/kubernetes-engine/docs/concepts/kubernetes-engine-overview" rel="noopener ugc nofollow" target="_blank">Google Cloud中的Kubernetes</a></p><p id="1900" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">在终端中输入以下命令:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="4ef1" class="jy jz iq ng b gy nk nl l nm nn">gcloud container clusters create gke-tutorial-cluster --disk-size 10 --num-nodes 1 --enable-autoscaling --min-nodes 1 --max-nodes 5 --zone us-central1-a</span></pre><p id="f60e" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">这将创建一个名为<em class="na"> gke-tutorial-cluster </em>的Kubernetes集群，磁盘大小为10GB，只有一个节点。它还启用自动缩放，并设置最小和最大节点数。自动缩放功能将在本文后面详细讨论。</p><p id="2795" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">群集将需要几分钟的时间来启动。完成后，前往<a class="ae lj" href="https://console.cloud.google.com/kubernetes/list" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/kubernetes/list</a>查看您刚刚部署的集群。</p><h1 id="d2ed" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">保留静态IP地址</h1><p id="8d4a" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">我们现在将保留一个静态IP地址，用于访问我们的应用程序。输入以下命令:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="f5b0" class="jy jz iq ng b gy nk nl l nm nn">gcloud compute addresses create gke-tutorial-ip</span></pre><p id="ccf1" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">当提示输入区域时，输入<strong class="kw ir"> 1 </strong>(表示全局)并按回车键。</p><h1 id="290b" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">创建Kubernetes服务</h1><p id="20b9" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">接下来，我们需要定义一些Kubernetes服务的规范。我们要做的第一件事是安装Kubernetes CLI (kubectl)。运行:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="3adb" class="jy jz iq ng b gy nk nl l nm nn">gcloud components install kubectl</span></pre><p id="6359" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我们将创建4个文件；<code class="fe np nq nr ng b">ingress.yaml</code>将通过创建HTTP负载平衡器为外部流量创建一个进入我们应用程序的入口，<code class="fe np nq nr ng b">deployment.yaml</code>将为我们的pod和Docker映像提供规范，<code class="fe np nq nr ng b">service.yaml</code>将创建一个节点端口，该端口将从HTTP负载平衡器接收流量并将其发送到我们的Node.js服务器，<code class="fe np nq nr ng b">podscaler.yaml</code>将定义水平pod扩展配置(稍后将再次详细介绍自动扩展)。</p><p id="d45e" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">创建以下文件夹和文件:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="704a" class="jy jz iq ng b gy nk nl l nm nn">mkdir k8s<br/>cd k8s<br/>touch deployment.yaml ingress.yaml service.yaml podscaler.yaml</span></pre><p id="ed84" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在打开<code class="fe np nq nr ng b">deployment.yaml</code>并添加以下代码(确保用您自己的代码替换图像定义中的&lt;项目id &gt;:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="236e" class="jy jz iq ng b gy nk nl l nm nn">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: gke-tutorial-deployment<br/>  namespace: default<br/>  labels:<br/>    app: gke-tutorial-deployment<br/>spec:<br/>  replicas: 1 # number of pods<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: gke-tutorial-deployment<br/>    spec:<br/>      containers:<br/>        - name: gke-tutorial-image<br/>          image: <!-- -->gcr.io/&lt;project-id&gt;/gke-tutorial-image<br/>          imagePullPolicy: Always<br/>          ports:<br/>            - containerPort: 3000<br/>              protocol: TCP</span></pre><p id="fcfb" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">对于<code class="fe np nq nr ng b">service.yaml</code>，输入:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="b231" class="jy jz iq ng b gy nk nl l nm nn">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: gke-tutorial-deployment<br/>spec:<br/>  selector:<br/>    app: gke-tutorial-deployment<br/>  type: NodePort<br/>  ports:<br/>    - protocol: TCP<br/>      port: 3000<br/>      targetPort: 3000</span></pre><p id="c2c6" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">这为我们的Docker容器创建了一个入口。对于<code class="fe np nq nr ng b">ingress.yaml</code>，输入:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="2718" class="jy jz iq ng b gy nk nl l nm nn">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: gke-tutorial-ingress<br/>  annotations:<br/>    kubernetes.io/ingress.global-static-ip-name: "gke-tutorial-ip"<br/>spec:<br/>  backend:<br/>    serviceName: gke-tutorial-deployment<br/>    servicePort: 3000</span></pre><p id="beec" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">这将创建HTTP负载平衡器，并将其指向节点端口服务。最后，为<code class="fe np nq nr ng b">podscaler.yaml</code>输入:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="52fd" class="jy jz iq ng b gy nk nl l nm nn">apiVersion: autoscaling/v2beta1<br/>kind: HorizontalPodAutoscaler<br/>metadata:<br/>  name: gke-tutorial-hpa<br/>  namespace: default<br/>  labels:<br/>    app: gke-tutorial-deployment<br/>spec:<br/>  scaleTargetRef:<br/>    kind: Deployment<br/>    name: gke-tutorial-deployment<br/>    apiVersion: apps/v1beta1<br/>  minReplicas: 1<br/>  maxReplicas: 5<br/>  metrics:<br/>    - type: Resource<br/>      resource:<br/>        name: cpu<br/>        targetAverageUtilization: 80</span></pre><p id="835e" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在，我们可以使用Kubernetes CLI将这些服务部署到我们的Kubernetes集群中。在此之前，我们需要用部署在Google Cloud中的集群配置kubectl。运行:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="ef45" class="jy jz iq ng b gy nk nl l nm nn">gcloud container clusters get-credentials gke-tutorial-cluster --zone us-central1-a</span></pre><p id="dd55" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在运行以下命令来部署服务:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c983" class="jy jz iq ng b gy nk nl l nm nn">kubectl apply -f k8s/</span></pre><p id="3209" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">所有的服务都将部署！如果您在谷歌云控制台(【https://console.cloud.google.com/kubernetes】T4)中导航到Kubernetes引擎，您可以通过单击左侧栏中的<em class="na">服务</em>来查看它，在这里您应该会看到正在创建一个节点端口服务和一个入口服务。在<em class="na">工作负载</em>下，您将看到您的部署。</p><p id="e43b" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">启动并运行一切需要几分钟时间(入口服务通常需要最长时间才能运行)，因此，一旦入口服务的状态从“正在创建入口”变为“正常”，请输入以下命令以获取我们之前创建的外部IP地址:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="eada" class="jy jz iq ng b gy nk nl l nm nn">gcloud compute addresses list</span></pre><p id="1492" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">这是附加到入口服务创建的负载平衡器的地址。在浏览器中输入这个地址，您应该会看到<em class="na"> My Node.js API </em>。</p><p id="fa79" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">恭喜你。我们现在已经在Kubernetes中设置了Node.js服务器。接下来，我们将使用Google Cloud Build实现持续集成(CI)。这将使我们的部署过程自动化，这样每次我们对应用程序进行新的更改时，它们都会自动部署。</p><h1 id="8407" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">Kubernetes自动缩放</h1><p id="ac36" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">在我们继续之前，我将简要概述一下我们配置的自动缩放是如何工作的，因为一开始可能会有点混乱。您可能已经注意到，我们定义了两个自动伸缩配置(创建Kubernetes集群时的自动伸缩标志和<em class="na"> podscaler.yaml </em>服务)。如果你不理解这些术语，请查看我在Kubernetes部分开始时提到的Kubernetes概述文章。</p><p id="3192" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我先来解释一下<em class="na"> podscaler.yaml </em>。这就建立了我们所说的<em class="na">水平机架扩展(HPA) </em>。pod本质上是共享相同硬件的一组紧密耦合的容器。根据可用的资源，每个节点(或机器)可以运行多个pod。如果当前单元被过度利用，HPA将调度更多单元，如果单元未被充分利用，HPA将删除单元，但它不会扩展节点的数量。这些节点只是由Google Cloud控制的虚拟机，因此需要通过Google Cloud进行配置，而不是通过Kubernetes(现在您可以看到集群自动缩放器的作用了)。</p><p id="8dee" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在，如果我们实际上没有向我们的集群分配更多的虚拟机，添加更多的pod不会对我们有太大帮助。这也是我们使用集群自动缩放器(CA)的原因。这个配置是我们在创建集群时定义的，它根据需要自动扩展集群中的节点数量。</p><p id="27b0" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">所以这两个服务一起工作如下:当需要更多的资源时，将会调度额外的pods。一旦计划的pod数量需要更多节点，CA将分配这些额外的节点。pod scaler还将在节点之间移动pod，以最大限度地利用资源并限制所需的节点数量。如果不再需要某个节点，CA会将其从集群中删除。</p><p id="3bb7" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">如果你还是不明白或者想了解更多，可以看看这篇很棒的文章:<a class="ae lj" href="https://medium.com/magalix/kubernetes-autoscaling-101-cluster-autoscaler-horizontal-pod-autoscaler-and-vertical-pod-2a441d9ad231" rel="noopener">https://medium . com/maga lix/kubernetes-auto scaling-101-cluster-auto scaler-horizontal-pod-auto scaler-and-vertical-pod-2a 441d 9 ad 231</a>。</p><h1 id="9eb6" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">设置Google密钥管理服务</h1><p id="ef3b" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">在我们配置云构建之前，我们希望设置谷歌密钥管理服务(KMS)，以便我们可以加密我们存储库中的敏感密钥或值，然后在部署过程中解密它们(查看<a class="ae lj" href="https://cloud.google.com/kms/" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/kms</a>了解更多信息)。</p><p id="95b3" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">进入<a class="ae lj" href="https://console.developers.google.com/apis/library/cloudkms.googleapis.com" rel="noopener ugc nofollow" target="_blank">https://console . developers . Google . com/APIs/library/cloud kms . Google APIs . com</a>，点击<em class="na"> Enable </em>启用API。稍等片刻，然后输入以下命令(如果出现错误，请稍等几分钟，然后重试):</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="d16c" class="jy jz iq ng b gy nk nl l nm nn">gcloud kms keyrings create gke-tutorial-keyring --location global</span></pre><p id="76cd" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">这将创建一个名为<em class="na"> gke-tutorial-keyring </em>的密匙环。密匙环本质上是一组密钥，每个密钥都可以用来加密和解密文件。现在我们创建一个名为<em class="na"> default </em>的键:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c122" class="jy jz iq ng b gy nk nl l nm nn">gcloud kms keys create default --location global --keyring gke-tutorial-keyring --purpose encryption</span></pre><p id="234b" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">最后，我们可以加密我们的<code class="fe np nq nr ng b">.env</code>文件(现在这里没有敏感值，但是如果我们想连接到任何API，我们会在这里存储我们的凭证。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="b31d" class="jy jz iq ng b gy nk nl l nm nn">gcloud kms encrypt --location global \<br/>  --keyring gke-tutorial-keyring --key default \<br/>  --plaintext-file .env \<br/>  --ciphertext-file .env.enc</span></pre><p id="1dd5" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在，您的存储库中应该有一个<code class="fe np nq nr ng b">.env.enc</code>文件。这个文件可以安全地签入版本控制，因为它是加密的(试着打开它，它看起来完全像是胡言乱语)。</p><h1 id="29be" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">设置云构建</h1><p id="4138" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">为了自动化我们的代码部署，我们需要创建一个GitHub存储库。登录你的GitHub(或者创建一个账户)并创建一个空的资源库(随便叫它什么，我的是<em class="na"> gke-tutorial </em>)。复制HTTPS回购链接，然后返回命令行并输入以下命令(确保替换&lt;回购url &gt;):</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="a9a6" class="jy jz iq ng b gy nk nl l nm nn">git init<br/>git add .<br/>git commit -m "Initial commit"<br/>git remote add origin &lt;repo-url&gt;<br/>git push -u origin master</span></pre><p id="43be" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在转到谷歌云控制台的云构建部分(【https://console.cloud.google.com/cloud-build】T4，在左侧菜单栏选择<em class="na">触发器</em>，点击<em class="na">创建触发器</em>。</p><p id="99c7" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">选择<em class="na"> GitHub </em>，点击同意复选框，点击<em class="na">继续</em>。现在应该会提示您登录GitHub帐户。完成后，您将看到一个存储库列表。选择我们刚刚创建的存储库，然后单击<em class="na">继续</em>。在<em class="na">分支(regex) </em>下，输入<em class="na">主</em>，在<em class="na">构建配置</em>下，选择<em class="na">云构建配置文件(yaml或json) </em>。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/b4bdb4aac74566bf31c7323093dc1379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JnWXfgL_UaMHFWxuR55OQ.png"/></div></div></figure><p id="61b4" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我们还将添加一些替代变量，这样，如果我们将来想要更新配置，就不必更改我们的构建文件。在替代变量下，点击<em class="na">添加项目</em> 5次，输入旁边显示的变量。最后，点击<em class="na">创建触发器</em>。</p><p id="dd49" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">最后一步是创建我们的<code class="fe np nq nr ng b">cloudbuild.yaml</code>文件，它将告诉Cloud Build如何构建和部署我们的应用程序。创建文件:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="7f91" class="jy jz iq ng b gy nk nl l nm nn">touch cloudbuild.yaml</span></pre><p id="dcfa" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">并添加以下代码:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="6388" class="jy jz iq ng b gy nk nl l nm nn">steps:<br/>  # decrypt .env<br/>  - name: gcr.io/cloud-builders/gcloud<br/>    id: "Decrypt environment variables"<br/>    args:<br/>      - kms<br/>      - decrypt<br/>      - --ciphertext-file=.env.enc<br/>      - --plaintext-file=.env<br/>      - --location=global<br/>      - --keyring=$_KEYRING<br/>      - --key=$_KEY</span><span id="29ed" class="jy jz iq ng b gy no nl l nm nn">  # pull previous image to speed up docker build<br/>  - name: "gcr.io/cloud-builders/docker"<br/>    id: "Pull"<br/>    entrypoint: "bash"<br/>    args:<br/>      - "-c"<br/>      - |<br/>        docker pull gcr.io/$PROJECT_ID/$_IMAGE:latest || exit 0</span><span id="da5a" class="jy jz iq ng b gy no nl l nm nn">  # build docker image<br/>  - name: "gcr.io/cloud-builders/docker"<br/>    id: "Build"<br/>    args:<br/>      [<br/>        "build",<br/>        "-t",<br/>        "gcr.io/$PROJECT_ID/$_IMAGE:$SHORT_SHA",<br/>        "--cache-from",<br/>        "gcr.io/$PROJECT_ID/$_IMAGE:latest",<br/>        ".",<br/>      ]</span><span id="9623" class="jy jz iq ng b gy no nl l nm nn">  # push image to container registry<br/>  - name: "gcr.io/cloud-builders/docker"<br/>    id: "Push"<br/>    args:<br/>      - "push"<br/>      - "gcr.io/$PROJECT_ID/$_IMAGE:$SHORT_SHA"</span><span id="5698" class="jy jz iq ng b gy no nl l nm nn">  # set image in deployment.yaml<br/>  - name: "gcr.io/cloud-builders/gcloud"<br/>    id: "Set image name"<br/>    entrypoint: /bin/sh<br/>    args:<br/>      - "-c"<br/>      - |<br/>        sed -i "s/image: IMAGE/image: gcr.io\/$PROJECT_ID\/$_IMAGE:$SHORT_SHA/g" k8s/deployment.yaml</span><span id="282d" class="jy jz iq ng b gy no nl l nm nn">  # get kubernetes credentials<br/>  - name: "gcr.io/cloud-builders/gcloud"<br/>    id: "Authenticate kubernetes"<br/>    args:<br/>      [<br/>        "container",<br/>        "clusters",<br/>        "get-credentials",<br/>        "$_CLUSTER",<br/>        "--zone",<br/>        "$_ZONE",<br/>      ]</span><span id="f20f" class="jy jz iq ng b gy no nl l nm nn">  # deploy changes to kubernetes config files<br/>  - name: "gcr.io/cloud-builders/kubectl"<br/>    id: "Deploy"<br/>    args: ["apply", "-f", "k8s/"]</span><span id="155c" class="jy jz iq ng b gy no nl l nm nn">  # add latest tag to new image<br/>  - name: "gcr.io/cloud-builders/gcloud"<br/>    id: "Tag"<br/>    args:<br/>      [<br/>        "container",<br/>        "images",<br/>        "add-tag",<br/>        "gcr.io/$PROJECT_ID/$_IMAGE:$SHORT_SHA",<br/>        gcr.io/$PROJECT_ID/$_IMAGE:latest,<br/>      ]</span></pre><p id="3c68" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">上面的文件中有很多内容，所以让我们遍历定义的每个步骤。在每一步中，<em class="na"> name </em>参数定义了用于运行命令的CLI。gcr.io/cloud-builders/…的名字指的是谷歌预装的软件包(见<a class="ae lj" href="https://cloud.google.com/cloud-build/docs/cloud-builders" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/cloud-build/docs/cloud-builders</a>)。如果您需要在构建期间使用任何其他软件包，您将需要添加一个步骤来安装它们(大多数情况下使用apt-get install)。另一件需要注意的事情是，Google Cloud默认提供的任何变量都可以在变量名前面使用<em class="na"> $ </em>来访问。我们在构建触发器中定义的任何替代变量也必须在变量名前包含一个下划线。可以在这里了解更多:<a class="ae lj" href="https://cloud.google.com/cloud-build/docs/configuring-builds/substitute-variable-values" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/cloud-build/docs/configuring-builds/substitute-variable-values</a>。</p><p id="df91" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">第一步只是使用与我们用来加密我们的<code class="fe np nq nr ng b">.env</code>相反的命令来解密它。执行构建的服务帐户将需要额外的权限，所以在解释完<em class="na"> cloudbuild.yaml </em>之后，我们将添加这些权限。接下来，我们从容器注册表中提取最新的Docker映像。由于Docker映像是按层构建的，因此Docker在构建时可以使用以前映像中未更改的层。这可以大大加快我们的构建速度，尤其是在安装依赖项或进行小的更新时。</p><p id="c728" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">下一步是构建我们的Docker映像并命名它。<em class="na"> SHORT_SHA </em>是我们提交SHA的前7个字符，它将区分我们的每个构建。之后，我们将Docker映像推送到容器注册中心。下一步在我们的<em class="na"> k8s/deployment.yaml </em>文件中搜索字符串“image: IMAGE”，并将其替换为“IMAGE:gcr.io/&lt;项目id &gt; / &lt;图像&gt; : &lt; short-sha &gt;”。这就是我们将如何告诉我们的Kubernetes部署使用我们刚刚推出的新Docker映像。这也意味着我们必须修改我们的<em class="na"> k8s/deployment.yaml </em>文件中的那一行来匹配它。</p><p id="73b9" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在我们配置Kubernetes凭证，就像我们在本文开始时手动做的那样。这将需要另一个许可，我们将在后面添加。接下来，我们部署我们的Kubernetes服务(同样是我们如何手动完成的)，最后我们用标签<em class="na"> latest </em>标记我们刚刚推送的图像，这确保我们可以在下一个构建中正确地提取它。</p><p id="5089" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">让我们进行上面的演练中提到的一些更改(给我们的服务帐户KMS和Kubernetes权限，并填写一个在构建期间要切换的通用映像名称)。</p><p id="ae8c" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">进入控制台(【https://console.cloud.google.com/iam-admin/iam】T2)的IAM部分，找到角色为<em class="na">云构建服务账号</em>的成员。单击该成员旁边的编辑图标，然后单击<em class="na">添加另一个角色</em>。搜索<em class="na"> kms </em>并选择<em class="na">云kms密钥解密器</em>然后搜索<em class="na"> kubernetes </em>并点击<em class="na"> Kubernetes引擎开发者</em>。</p><p id="ea67" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在转到<em class="na"> k8s/deployment.yaml </em>并替换映像名称，以便Cloud Build每次都可以填充它。它现在应该是这样的:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5760" class="jy jz iq ng b gy nk nl l nm nn">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: gke-tutorial-deployment<br/>  namespace: default<br/>  labels:<br/>    app: gke-tutorial-deployment<br/>spec:<br/>  replicas: 1 # number of pods<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: gke-tutorial-deployment<br/>    spec:<br/>      containers:<br/>        - name: gke-tutorial-image<br/>          # this value is replaced during cloud build<br/>          image: IMAGE<br/>          imagePullPolicy: Always<br/>          ports:<br/>            - containerPort: 3000<br/>              protocol: TCP</span></pre><p id="bc26" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我们终于可以尝试新的CI系统了。我们将对我们的代码做一个小的改动，这样我们就可以在部署后看到变化的反映。进入<em class="na"> index.js </em>，将行<code class="fe np nq nr ng b">app.all("*", (req, res) =&gt; res.status(200).send(“My Node.js API"));</code>改为<code class="fe np nq nr ng b">app.all("*", (req, res) =&gt; res.status(200).send("My updated Node.js API”));</code>。</p><p id="ccc4" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在导航到云构建历史(<a class="ae lj" href="https://console.cloud.google.com/cloud-build/builds" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/cloud-build/builds</a>)。这里是您将看到您的构建的地方。保持此页面打开，然后返回到您的命令行并提交我们的新更改:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="9a7f" class="jy jz iq ng b gy nk nl l nm nn">git add .<br/>git commit -m "Cloud build setup"<br/>git push</span></pre><p id="b287" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">在云构建历史页面点击<em class="na">刷新</em>，点击新构建(旁边应该有一个加载图标)。然后，您可以向下滚动并查看构建的日志。如果您的构建失败了，您可以在这里找到导致失败的错误。构建成功后，等待几秒钟，然后在浏览器中输入外部IP地址。您现在应该看到“我的更新的Node.js API”。</p><p id="53d4" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">完成了。🙌请随时让我知道下面的任何反馈或问题，我很乐意帮忙。如果你有任何问题，记得查看GitHub repo。</p></div></div>    
</body>
</html>