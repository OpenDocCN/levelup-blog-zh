<html>
<head>
<title>Realtime charts with JavaFX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaFX的实时图表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/realtime-charts-with-javafx-ed33c46b9c8d?source=collection_archive---------0-----------------------#2019-02-18">https://levelup.gitconnected.com/realtime-charts-with-javafx-ed33c46b9c8d?source=collection_archive---------0-----------------------#2019-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c309" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">用<strong class="jp ir"> JavaFX </strong>开发实时图表非常容易。你只需要知道一些事情。让我们开始吧。</p><h1 id="e0b6" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">引导应用程序</h1><p id="52f7" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi kl translated"><span class="l km kn ko bm kp kq kr ks kt di">首先，我们需要像往常一样创建一个<strong class="jp ir"> JavaFX </strong>应用程序。我们不会在这里使用任何花哨的控制器，因为这将增加教程的复杂性，但你可以很容易地得到这里的概念。</span></p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">显示标题的简单JavaFX应用程序</figcaption></figure><h1 id="1b5c" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">添加图表</h1><p id="7c47" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">接下来，我们将添加轴和图表来显示数据。为了简单起见，我将使用图表本身作为场景。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">沿轴添加折线图</figcaption></figure><p id="777e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在已经创建了两个轴</p><ul class=""><li id="b237" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated"><strong class="jp ir">类别</strong> —该轴可以显示字符串数据</li><li id="3c3a" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir">数字</strong> —该轴可以显示整数、双精度等数字</li></ul><p id="ac91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置轴标签后，我们禁用了轴上的<strong class="jp ir">动画</strong>。如果你愿意，你可以<em class="mw">启用</em>它们。</p><p id="956f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们创建了一个折线图。当然，你不局限于折线图，使用任何你喜欢的。</p><p id="4275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">折线图是针对两种数据类型创建的。X轴和Y轴上的字符串和数字。接下来，我们还有禁用的动画。</p><h1 id="2d5f" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">显示数据的x系列</h1><p id="2e14" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">接下来我们要在图表上显示数据。为此，我们需要一系列。<strong class="jp ir"> XYSeries </strong>支持一个<a class="ae mx" href="https://docs.oracle.com/javase/8/javafx/api/javafx/collections/ObservableList.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">observable list</strong></a><strong class="jp ir"/>作为底层数据结构。它允许监听器监听数据的变化。</p><p id="7c1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，当您向系列中添加一个新的点时，图表会监听该点并在屏幕上绘制该点。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">一个简单的序列，可以将一个字符串作为X轴，将一个数字作为Y轴</figcaption></figure><h1 id="11e4" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">表演时间到了</h1><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">设置并显示场景</figcaption></figure><p id="7088" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将创建一个新的场景，并显示在我们的窗口</p><p id="9e97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你现在跑，它会看起来像以下</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/c9909b46b31e673bae7b48a150fa25b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJjUqprgXaKL9V3y0_lYoQ.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">带有图表的JavaFX应用程序</figcaption></figure><h1 id="2185" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">模拟实时数据</h1><p id="dd0e" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">现在我们想为演示模拟实时数据。基本上，我们会定期将数据放入图表<strong class="jp ir"/>。为此，Java中有许多方法。但是我们将使用一个<a class="ae mx" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">ScheduledExecutorService</strong></a>来有效地处理这些情况。</p><p id="f722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还使用一个<a class="ae mx" href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">简单日期格式</strong> </a>以<em class="mw"> HH:mm:ss </em>格式显示当前时间。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">创建一个调度程序，以固定速率运行每秒更新图表的线程</figcaption></figure><p id="1ac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用Executors类通过单线程轻松设置一个<strong class="jp ir"> ScheduledExecutorService </strong>。</p><p id="9943" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">scheduleAtFixedRate有4个参数</p><pre class="lx ly lz ma gt nf ng nh ni aw nj bi"><span id="53cd" class="nk kv iq ng b gy nl nm l nn no">scheduleAtFixedRate(<a class="ae mx" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html" rel="noopener ugc nofollow" target="_blank">Runnable</a> command,<br/>                    long initialDelay,<br/>                    long period,<br/>                    <a class="ae mx" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html" rel="noopener ugc nofollow" target="_blank">TimeUnit</a> unit)</span></pre><p id="06f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，它每隔一段时间运行一次Runnable命令。</p><p id="8552" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的示例中，我们以每秒0 initialDelay更新图表的速度运行该命令。</p><p id="3692" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个命令，我们使用一个简单的<a class="ae mx" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank"> lambda </a>(它是一个<strong class="jp ir"> Runnable </strong>)来执行。</p><p id="13ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它生成一个0到10之间的随机整数，并把它放到图表中。</p><p id="f936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<a class="ae mx" href="https://docs.oracle.com/javase/8/javafx/api/javafx/application/Platform.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">platform . run la ter</strong></a>方法来更新UI。背后的简单原因是更新JavaFX UI，这需要在JavaFX应用程序线程中完成。runLater将调度运行应用程序线程中传递的可运行的<strong class="jp ir"/>。</p><p id="9282" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只是通过将数据点添加到数据中来将它添加到序列中。然后图表会自我更新以绘制新数据。</p><p id="d95a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您运行该应用程序，它现在可能看起来像这样。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi np"><img src="../Images/7f70a3474276912b4c9a3ddedbd323d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*l3rpIc3RACd8YzJSWV74_w.gif"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">图表很有用耶！:百胜:</figcaption></figure><p id="d56c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到它起作用了，井点也越来越近了:</p><h1 id="f728" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">问题是</h1><p id="c83c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">嗯，这很好地工作，直到一段时间过去，这是大约2或3分钟，现在图表几乎不可能阅读</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/cedc4754c7c7ddc7209b0e91eb342832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-8qBFqwpldCk4L8hNRb5w.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">哦，不，图表不可读:</figcaption></figure><h1 id="88a3" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">解决方案</h1><p id="b049" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">为了防止臃肿的图表，我们需要遵循一个简单的策略。我们只需要从系列的开始删除点。姑且称之为窗口吧。当窗口填满时，它将丢弃旧数据并让新数据进入。</p><pre class="lx ly lz ma gt nf ng nh ni aw nj bi"><span id="ee87" class="nk kv iq ng b gy nl nm l nn no">final int WINDOW_SIZE = 10;</span></pre><p id="02d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先我们定义<strong class="jp ir"> WINDOW_SIZE </strong>为10，s <strong class="jp ir"> o在任何时候图表上的元素都不会超过10个</strong>。</p><pre class="lx ly lz ma gt nf ng nh ni aw nj bi"><span id="2b99" class="nk kv iq ng b gy nl nm l nn no">if (series.getData().size() &gt; WINDOW_SIZE)<br/>    series.getData().remove(0);</span></pre><p id="4783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们将它添加到平台内部的runnable . run la ter。</p><p id="2144" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它做了一件非常简单的事情，如果窗口大小超出，它将删除序列中的第一个元素。请记住保存ObservableList的系列，这样图表就知道如何响应这种删除并相应地更新图表。</p><h1 id="0eb5" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结果呢</h1><p id="ae22" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">经过我们的补救，看起来怎么样。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi np"><img src="../Images/71bc4ac9a50e99cbff020cc349b3c005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tce9aZVtPRTedWHCL54yQw.gif"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">图表现在可以更新而不会膨胀</figcaption></figure><h1 id="7392" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">还有一点</h1><p id="3b8c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">好了，在我们应用了我们的补救措施后，图表工作得很棒，它在给定时间只保留了10个元素(<strong class="jp ir"> WINDOW_SIZE </strong>)，并从列表中删除了旧的元素。</p><p id="b2e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是你试过关闭应用程序吗？不知什么原因还挂着。</p><p id="9f66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种不寻常的悬挂背后的原因是我们的朋友<strong class="jp ir"> ScheduledExecutorService </strong>。即使在应用程序关闭后，它仍试图工作。解决这个问题的方法很简单。我们需要显式关闭executor，这样当我们关闭窗口时，它就可以停止工作。</p><p id="4006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将使用JavaFX中一个名为<strong class="jp ir"> stop </strong>的方法。我们需要<em class="mw">覆盖</em>它，并告诉它关闭executor服务，如下所示。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">也关闭计划的执行者服务</figcaption></figure><p id="48da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">立即尝试停止执行程序服务。</p><p id="8b91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果你勾选了，应用程序将会关闭而不会异常挂起。</p><h1 id="ec9c" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">最终源代码</h1><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">实时图表的完整源代码</figcaption></figure><p id="6565" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者你也可以在这里找到它</p><p id="06b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">GitHub</strong>:<a class="ae mx" href="https://github.com/kasvith/javafxrealtimechartsdemo" rel="noopener ugc nofollow" target="_blank">https://github.com/kasvith/javafxrealtimechartsdemo</a></p><h1 id="1a33" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="bde5" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们创建了一个简单的折线图，并使用一个用于演示的<strong class="jp ir">ScheduledExecutorService</strong>在上面添加实时数据。它可以被你想要的任何东西代替。</p><p id="fb92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们最终得到了一个臃肿的图表，并找到了一个解决方案，使用一个<strong class="jp ir"> WINDOW_SIZE </strong>来限制<strong class="jp ir">图表上的<em class="mw">数据点数</em>。</strong></p><blockquote class="nq nr ns"><p id="a959" class="jn jo mw jp b jq jr js jt ju jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj kk ij bi translated">这个想法很简单，但是很强大。</p></blockquote><p id="eca0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望对某人有帮助:简单_微笑:</p><p id="f263" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你好运！！！。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><figure class="lx ly lz ma gt mb gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi od"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="oe of gp gr og oh"><a href="https://gitconnected.com/learn/java" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">学习Java -最佳Java教程(2019) | gitconnected</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">38大Java教程-免费学习Java。课程由开发者提交并投票，使您能够找到…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">gitconnected.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov nd oh"/></div></div></a></div></div></div>    
</body>
</html>