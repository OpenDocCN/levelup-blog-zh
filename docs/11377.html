<html>
<head>
<title>Firestore Full Text Search At No Extra Cost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firestore全文搜索免费</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/firestore-full-text-search-at-no-extra-cost-ee148856685?source=collection_archive---------2-----------------------#2022-03-12">https://levelup.gitconnected.com/firestore-full-text-search-at-no-extra-cost-ee148856685?source=collection_archive---------2-----------------------#2022-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/27f16dbd714f2d5ab33509e8cc236a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AD6zBUpnf2W221eut7Go4Q.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@markuswinkler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>在<a class="ae kc" href="https://unsplash.com/s/photos/search?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3670" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将介绍一种无需额外服务就能进行全文搜索的方法。您将避免额外的成本，同时使您的用户能够进行实时的部分匹配搜索，并有一些小的限制。最后现场演示。</p><p id="879b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很多时候，你会希望你的用户能够搜索你的数据。firebase推荐的<a class="ae kc" href="https://firebase.google.com/docs/firestore/solutions/search" rel="noopener ugc nofollow" target="_blank">方法</a>是使用像Algolia这样的外部服务。这种解决方案的问题是，您必须处理额外的成本和维护。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="22f2" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">赞成的意见</h1><ol class=""><li id="634b" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated">不需要外部搜索服务。</li><li id="13b2" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">不需要同步数据。</li><li id="8dc5" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">可以使用firebase标准对搜索进行分页。</li><li id="a841" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">适用于任何数据格式。</li><li id="b6e0" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">支持部分搜索中间字符串。</li><li id="398e" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">可以与其他查询结合使用，以构建高级过滤。</li><li id="6234" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">超级快</li></ol><h1 id="1ae2" class="li lj iq bd lk ll mw ln lo lp mx lr ls lt my lv lw lx mz lz ma mb na md me mf bi translated">缺点/限制</h1><p id="ac94" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">让我们继续下去，消除这些限制，这样您就可以看到这个解决方案是否符合您的需求。</p><ol class=""><li id="a01c" class="mg mh iq kf b kg kh kk kl ko ne ks nf kw ng la mn mo mp mq bi translated">所有查询都以默认顺序返回。比如你不能“按价格排序”。潜在的反模式可以用来以期望的顺序返回搜索结果<strong class="kf ir">只有</strong>如果你关心排序。</li><li id="1b43" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">用户必须键入至少3个字符才能注册搜索。</li><li id="f5ba" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">总的可搜索字符串不能超过一个相当合理的限制(建议500，但使用您的最佳判断)。这意味着你不能拥有一篇完整的论文，也不能在里面搜索。这意味着更多的标题，描述等…</li><li id="8046" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">搜索词必须连续。<br/>例如，<code class="fe nh ni nj nk b"><strong class="kf ir">“ere no”</strong></code>将匹配<code class="fe nh ni nj nk b"><strong class="kf ir">“Is there no one else”</strong></code>，但是搜索<code class="fe nh ni nj nk b"><strong class="kf ir">“there one”</strong></code>将不会返回这种实现的命中结果，因为单词是分裂的。</li><li id="5ce6" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">出口成本稍微高一点，这取决于您允许搜索多大的字符串。</li></ol></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="d68e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">添加记录实现</h1><p id="b0f5" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">下面是使用三元模型创建搜索增强记录的实现。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2536" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">trigram命令是这里的魔法。运行此命令会产生以下结果:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="0fa3" class="nv lj iq nk b gy nw nx l ny nz">triGram('Hello World')<br/>['hel', 'ell', 'llo', 'lo ', 'o w', ' wo', 'wor', 'orl', 'rld']</span></pre><p id="070d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您创建的每条记录都将三元模型结果存储为一个对象。要进行搜索查询，需要对搜索字符串运行三元模型，然后确保搜索字符串中的所有三元模型都出现在上面的数组中。例如，对于搜索字符串<code class="fe nh ni nj nk b">worl</code>，生成以下三元模型:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="30eb" class="nv lj iq nk b gy nw nx l ny nz">triGram('worl') =&gt; ['wor', 'orl']</span></pre><p id="f1c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于在上面的三元模型图中找到了<code class="fe nh ni nj nk b">wor </code>和<code class="fe nh ni nj nk b">orl</code>，我们假设这个字符串搜索字符串匹配。然而，这种匹配行为也会导致误报。</p><p id="03db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果您的数据包含<code class="fe nh ni nj nk b">Work Orlando</code>，那么<code class="fe nh ni nj nk b">worl</code>也会匹配，而这不是您想要的。通常用户会改进他们的搜索，所以这一点都不会困扰我。</p><h1 id="4a5a" class="li lj iq bd lk ll mw ln lo lp mx lr ls lt my lv lw lx mz lz ma mb na md me mf bi translated">如何进行搜索</h1><p id="a797" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">既然您已经用搜索元标记了记录，那么您可能想要运行您的第一个查询。我不会在这篇文章中重复分页，因为它太长了。我将在以后的一篇关于数据通用分页的文章中继续讨论这个问题。对于您可以尝试的基本实现，请访问以下网站:</p><p id="826b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://demos.vizure.net/app/demos/search" rel="noopener ugc nofollow" target="_blank">https://demos.vizure.net/app/demos/search</a></p><p id="eb68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的想法非常简单。我们创建当前搜索词的三元模型，将其作为where子句添加到firestore查询中，并获得结果。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="a123" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">常见问题解答</h1><ol class=""><li id="dcc5" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated">为什么不用数组来存储你的三元模型，而不是三元模型的对象呢？<br/> <code class="fe nh ni nj nk b">array-contains</code>只会在数组中寻找一个三元组。目前没有办法<a class="ae kc" href="https://firebase.google.com/docs/firestore/query-data/queries#array_membership" rel="noopener ugc nofollow" target="_blank">查询firestore </a>中包含数组中指定的许多值的记录。<br/> <code class="fe nh ni nj nk b">array-contains</code>也有<a class="ae kc" href="https://firebase.google.com/docs/firestore/query-data/queries#limitations_2" rel="noopener ugc nofollow" target="_blank">的限制</a>使得它不适合这种方法。</li><li id="1769" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">为什么我不能搜索索引数据？<br/>一旦你创建了一个索引(比如按日期排序)，如果你想在那个索引上有其他的where子句，你必须为每个where子句创建一个新的索引。因此，现在用户输入的每个搜索字符串都要求您为每个三元模型生成一个索引。这不是有效的工作流。</li><li id="8bb0" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">搜索长度有什么限制？<br/>fire base中的索引有<a class="ae kc" href="https://firebase.google.com/docs/firestore/query-data/index-overview#indexing_best_practices" rel="noopener ugc nofollow" target="_blank">限制</a>信不信由你。你也不想让你的记录太大，这样下载会消耗太多的带宽。</li><li id="3f4b" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">有序数据的反模式是什么？为了支持按日期顺序检索数据，我们必须构造对象键，以便它们按最新的第一顺序返回。这实际上违背了firestore关键名称的最佳实践。<br/>这样做的副作用是您很可能会限制文档的读/写速度。例如，你可能会开始体验到搜索结果变慢，但我无法量化到底有多慢。对我来说，这可能没问题。</li></ol></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="ba1b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="49d4" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我在这里介绍了一个非常简单的解决方案，您可以用很少的开销将它添加到几乎任何项目中。它让您的用户能够搜索您的任何数据库，而不必担心在您的firestore数据库上添加搜索服务。</p></div></div>    
</body>
</html>