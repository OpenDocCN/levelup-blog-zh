<html>
<head>
<title>Introduction to TypeScript Interfaces — Object Literals and Function Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript接口简介—对象文字和函数类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-typescript-interfaces-object-literals-and-function-types-3eafa3709336?source=collection_archive---------8-----------------------#2020-01-21">https://levelup.gitconnected.com/introduction-to-typescript-interfaces-object-literals-and-function-types-3eafa3709336?source=collection_archive---------8-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f84e665e5d870e0520b9d4f326bb4a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MCZoFJWhKjRMBWkc"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Zoe Ra 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5b3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与普通JavaScript相比，TypeScript的最大优势在于，它通过添加确保程序对象类型安全的功能来扩展JavaScript的特性。它通过检查对象所呈现的值的形状来做到这一点。</p><p id="eae0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检查形状被称为鸭分型或结构分型。接口是在TypeScript中填充角色命名数据类型的一种方式。这对于在TypeScript程序的代码中定义契约非常有用。在上一篇文章中，我们研究了如何定义一个TypeScript接口，并向它添加必需的和可选的属性。在本文中，我们将继续上一篇文章，看看TypeScript接口的其他属性。</p><h1 id="2b7f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">超额财产检查</h1><p id="1eab" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当对象属性被赋给一个由接口指定类型的变量时，它们会得到额外的检查。这也适用于我们作为参数传递给函数的对象文字。例如，下面的代码不会被TypeScript编译器编译，并给我们一个错误:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a471" class="mq lf it mm b gy mr ms l mt mu">interface Person{<br/>  name: string<br/>}</span><span id="4848" class="mq lf it mm b gy mv ms l mt mu">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}`);<br/>}</span><span id="0f15" class="mq lf it mm b gy mv ms l mt mu">greet({ name: 'Joe', foo: 'abc' });</span></pre><p id="e71f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript编译器完成的额外属性检查将拒绝代码，因为我们有一个额外的未在<code class="fe mw mx my mm b">Person</code>接口中定义的<code class="fe mw mx my mm b">foo</code>属性，所以将它添加到参数中的对象会失败，因为TypeScript对对象文字进行了额外的属性检查。将相同的对象文本赋给变量也会失败。例如，如果我们有以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="60c6" class="mq lf it mm b gy mr ms l mt mu">interface Person{<br/>  name: string<br/>}<br/>const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}`);<br/>}<br/>const person: Person = { name: 'Joe', foo: 'abc' };<br/>greet(person);</span></pre><p id="4b8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将得到错误“Type“{ name:string；foo:string；“}”不可赋给类型“Person”。Object literal可能只指定已知的属性，如果我们尝试用TypsScript编译器编译代码或在支持typscript的文本编辑器中查看代码，则为“foo”。然而，我们可以使用类型断言操作符<code class="fe mw mx my mm b">as</code>来指定我们喜欢的对象文字的类型。因此，如果我们确定对象文字的类型是<code class="fe mw mx my mm b">Person</code>，即使它有一个<code class="fe mw mx my mm b">foo</code>属性，我们可以编写下面的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8e47" class="mq lf it mm b gy mr ms l mt mu">interface Person{<br/>  name: string<br/>}<br/>const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}`);<br/>}<br/>const person: Person = { name: 'Joe', foo: 'abc' } as Person;<br/>greet(person);</span></pre><p id="6179" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了上面的代码，TypeScript编译器不会抱怨任何问题。它只是假设对象文字的类型是<code class="fe mw mx my mm b">Person</code>，即使它有一个<code class="fe mw mx my mm b">foo</code>属性。但是，我们确实有一些动态属性，或者可能只是偶尔出现，我们也可以将动态属性添加到我们的TypeScript接口中，如下面的代码所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1303" class="mq lf it mm b gy mr ms l mt mu">interface Person{<br/>  name: string,<br/>  [prop: string]: any<br/>}</span><span id="238a" class="mq lf it mm b gy mv ms l mt mu">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}. ${person.age ? `You're ${person.age} years old.` : ''}`);<br/>}</span><span id="9afc" class="mq lf it mm b gy mv ms l mt mu">const person: Person = { name: 'Jane', age: 20 };<br/>greet(person);</span></pre><p id="5d32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们添加了:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f148" class="mq lf it mm b gy mr ms l mt mu">[prop: string]: any</span></pre><p id="2577" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到我们的<code class="fe mw mx my mm b">Person</code>界面。上面的行意味着类型<code class="fe mw mx my mm b">Person</code>可以有除了<code class="fe mw mx my mm b">name</code>之外的任何其他属性。属性名是一个字符串，这是JavaScript中动态属性名的情况，并且这些动态属性可以采用任何值，因为为动态属性指定了<code class="fe mw mx my mm b">any</code>类型。正如我们所看到的，我们有下面这条线:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ce1e" class="mq lf it mm b gy mr ms l mt mu">const person: Person = { name: 'Jane', age: 20 };</span></pre><p id="60cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中我们的对象文字有<code class="fe mw mx my mm b">age</code>属性，但是在我们的<code class="fe mw mx my mm b">interface</code>定义中没有明确定义。这是因为我们在<code class="fe mw mx my mm b">name</code>属性之后有了动态属性。<code class="fe mw mx my mm b">[prop: string]</code>被称为索引签名。</p><p id="568e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以通过将一个变量赋给另一个变量来绕过对象文字的额外属性检查。例如，如果我们有以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a3e7" class="mq lf it mm b gy mr ms l mt mu">interface Person{<br/>  name: string<br/>}</span><span id="3f37" class="mq lf it mm b gy mv ms l mt mu">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}. ${person.age ? `You're ${person.age} years old.` : ''}`);<br/>}</span><span id="7750" class="mq lf it mm b gy mv ms l mt mu">const person: Person = { name: 'Jane', age: 20 };<br/>greet(person);</span></pre><p id="16d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为额外的属性检查而无法编译和运行，我们可以通过将<code class="fe mw mx my mm b">person</code>常量赋给一个没有指定类型的新变量或常量来解决这个问题，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="896b" class="mq lf it mm b gy mr ms l mt mu">interface Person{<br/>  name: string<br/>}</span><span id="011b" class="mq lf it mm b gy mv ms l mt mu">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}`);<br/>}</span><span id="e9f6" class="mq lf it mm b gy mv ms l mt mu">const person = { name: 'Jane', age: 20 };<br/>greet(person);</span></pre><p id="b718" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">person</code>常量没有指定类型，所以不会运行对象文字的多余属性检查。</p><p id="15cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于简单的对象，比如我们上面提到的对象，建议强制执行超额属性检查。对于更复杂的动态对象，我们可以使用上面概述的方法来绕过检查，让代码运行。但是，请注意，大多数额外的属性错误实际上是我们代码中的拼写错误，所以它们是应该修复的合法错误。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/36fdbbc993e45cbaa85a026c3c5a8af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*waBXStBxOVHgQ9M8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Max Baskakov 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="13a7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">功能类型</h1><p id="9968" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用TypeScript接口，我们还可以通过指定每个参数的数据类型和函数的返回类型来定义函数的签名。这可以防止我们传入具有错误数据类型的参数，或者忘记将参数传入我们的函数调用，并且还可以确保我们的函数总是具有相同的返回类型，并且我们不会返回我们在代码中不期望的内容。</p><p id="5764" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以定义一个接口来指定函数的参数和返回数据类型，以及函数签名，如下面的代码所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b1c1" class="mq lf it mm b gy mr ms l mt mu">interface GreetFn{<br/>  (name: string, age: number): string<br/>}</span><span id="e7fc" class="mq lf it mm b gy mv ms l mt mu">const greet: GreetFn = (name: string, age: number) =&gt; {<br/>  return `Hello, ${name}. You're ${age} years old`;<br/>}</span><span id="260e" class="mq lf it mm b gy mv ms l mt mu">console.log(greet('Jane', 20));</span></pre><p id="28ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有一个函数<code class="fe mw mx my mm b">greet</code>，它遵循在<code class="fe mw mx my mm b">GreetFn</code>接口中冒号左侧定义的函数签名和在接口右侧定义的返回数据类型，因此代码将运行并从最后一行的<code class="fe mw mx my mm b">console.log</code>语句中产生输出。我们应该得到'你好，简。你已经20岁了。如果我们用类型<code class="fe mw mx my mm b">GreetFn</code>指定我们的<code class="fe mw mx my mm b">greet</code>函数，但是我们的函数签名或返回类型偏离了在<code class="fe mw mx my mm b">GreetFn</code>接口中指定的类型，那么我们将会得到错误。例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8c43" class="mq lf it mm b gy mr ms l mt mu">interface GreetFn{<br/>  (name: string, age: number): string<br/>}<br/>const greet: GreetFn = (name: string, age: number, foo: any) =&gt; {<br/>  return `Hello, ${name}. You're ${age} years old`;<br/>}<br/>console.log(greet('Jane', 20));</span></pre><p id="6aee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们会得到错误消息“Type”(name:string，age: number，foo: any) =&gt; string '不可赋给type 'GreetFn '。(2322)“因为我们的参数列表与接口中列出的签名不匹配。同样，如果我们函数的返回类型与我们在接口中定义的不匹配，我们也会得到一个错误。例如，如果我们有以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6daa" class="mq lf it mm b gy mr ms l mt mu">interface GreetFn{<br/>  (name: string, age: number): string<br/>}<br/>const greet: GreetFn = (name: string, age: number) =&gt; {<br/>  return 0;<br/>}<br/>console.log(greet('Jane', 20));</span></pre><p id="2efd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将得到错误“Type”(name:string，age: number) =&gt; number '不能赋给type 'GreetFn '。类型“number”不可赋给类型“string”。这意味着<code class="fe mw mx my mm b">greet</code>函数必须返回一个字符串，因为我们指定了<code class="fe mw mx my mm b">greet</code>函数的类型是<code class="fe mw mx my mm b">GreetFn</code>。</p><p id="8698" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一次检查一个函数参数，因此即使我们在定义函数时没有指定类型，TypeScript编译器也可以通过参数的位置来推断参数类型的位置。例如，即使我们没有明确指定参数的类型，下面的内容仍然有效:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1716" class="mq lf it mm b gy mr ms l mt mu">interface GreetFn{<br/>  (name: string, age: number): string<br/>}<br/>const greet: GreetFn = (name, age) =&gt; {<br/>  return `Hello, ${name}. You're ${age} years old`;<br/>}<br/>console.log(greet('Jane', 20));</span></pre><p id="6e39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们根据我们在下面代码中定义的接口传入错误数据类型的东西，我们会得到一个错误:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ee38" class="mq lf it mm b gy mr ms l mt mu">interface GreetFn{<br/>  (name: string, age: number): string<br/>}<br/>const greet: GreetFn = (name, age) =&gt; {<br/>  return `Hello, ${name}. You're ${age} years old`;<br/>}<br/>console.log(greet('Jane', ''));</span></pre><p id="7f87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们尝试编译上面的代码时，我们会得到错误“类型为“" "”的参数不可赋给类型为“number”的参数”。(2345)".这意味着TypeScript足够聪明，可以根据位置来推断类型。对返回类型也进行类型推断，因此如果我们编写以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="df0a" class="mq lf it mm b gy mr ms l mt mu">interface GreetFn{<br/>  (name: string, age: number): string<br/>}<br/>const greet: GreetFn = (name, age) =&gt; {<br/>  return 0;<br/>}<br/>console.log(greet('Jane', 20));</span></pre><p id="82dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们会得到错误“Type”(name:string，age: number) =&gt; number '不能赋给type 'GreetFn '。类型“number”不可赋给类型“string”。(2322)“所以代码无法编译。</p><p id="e861" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对对象文字进行额外的属性检查非常有用，因为当我们给对象文字赋值或者将它们作为函数的参数传递时，我们很难在代码中添加错误的属性或拼写错误。我们可以通过类型断言或者给一个不同类型或者没有类型的变量赋值来解决这个问题。我们还可以为函数定义接口，以定义函数的预期参数以及它们的预期返回类型。</p></div></div>    
</body>
</html>