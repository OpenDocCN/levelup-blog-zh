<html>
<head>
<title>5 Tips to Write Better React Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更好的React代码的5个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-tips-to-write-better-react-code-a5bca3f9531c?source=collection_archive---------5-----------------------#2020-04-05">https://levelup.gitconnected.com/5-tips-to-write-better-react-code-a5bca3f9531c?source=collection_archive---------5-----------------------#2020-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1a49f9720fe9bcf06be038f3bf3b08eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJ7lR6yrKAcfo31oy-OHMg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@ricaros" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@ricaros</a>拍摄</figcaption></figure><p id="8e21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经使用React一年多了，所以我不是专家，但我已经构建了几个项目，帮助我更好地理解这个库，并注意到一些技巧和模式，使我的代码更加高效。</p><p id="8a70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我想分享一些提示和技巧，它们会立即改进您的React代码。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="cc33" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.破坏道具</h1><p id="6fee" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在JS中析构对象(尤其是道具)可以大大减少代码中的重复。看看下面的例子。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">父组件</figcaption></figure><p id="06b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个CoffeMenu组件，它存储了可用饮料的列表。现在我们想创建另一个能够显示单一饮料的组件。如果没有析构属性，我们的代码将如下所示:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">子组件(无析构)</figcaption></figure><p id="6d3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，它看起来不太好——每次我们想得到道具时，我们都必须重复“道具.咖啡”部分。幸运的是，还有另一种(更干净的)方法。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">子组件(在解构props之后)</figcaption></figure><p id="5963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想给一个子组件传递很多参数，我们也可以直接在构造函数中析构props(或者函数组件参数)。这里有一个例子:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">父组件</figcaption></figure><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">子组件</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="122b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">2.保持导入模块的正确顺序</h1><p id="dfc3" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">有时(特别是在容器组件中——请看第4点),我们需要使用许多不同的模块，我们的组件导入看起来有点乱。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d543" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于导入模块的理想顺序有许多不同的观点。我建议你四处看看，找到一个适合你的。</p><p id="af55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对我来说，我通常按类型对导入进行分组，并按字母顺序排序(这是可选的)。我也倾向于保持以下顺序:</p><ol class=""><li id="9f78" class="mr ms iq kf b kg kh kk kl ko mt ks mu kw mv la mw mx my mz bi translated">标准模块</li><li id="a3ba" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated">第三方模块</li><li id="b3e5" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated">您的代码导入(组件等。)</li><li id="48d5" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated">特定于模块的导入(例如CSS、PNG等。)</li><li id="aed5" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated">仅用于测试的代码</li></ol><p id="358f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种快速重构之后，我们的导入开始看起来干净多了。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="cf3f" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">3.使用片段</h1><p id="118a" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在我们的组件中，我们经常返回多个元素。单个React组件不能返回多个子组件，所以我们通常将它们包装在一个' div '中。有时候这种解决方案真的很成问题。让我们看看这个例子。</p><p id="f8dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想要创建一个表组件，它包含另一个名为Columns的组件。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="90c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的Columns组件包含一些“td”元素。因为我们不能返回多个值，所以我们需要将这些元素包装在一个“div”中。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7432" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果，我们得到一个错误，因为我们不允许在“tr”标签中放入“div”。解决方案是使用“片段”标签，如下所示:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a8a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把‘碎片’当作一个看不见的‘div’。它将元素包装在子组件中，将它们带到父组件中，然后消失。</p><p id="6db7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以使用较短的语法，但是它不支持键和属性。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c8c1" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">4.使用表示和容器组件</h1><p id="f35e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">将应用程序的组件分成表示性(非智能)和容器性(智能)组件是一个好主意。如果你不知道这些是什么:</p><h2 id="1e6d" class="nf lj iq bd lk ng nh dn lo ni nj dp ls ko nk nl lw ks nm nn ma kw no np me nq bi translated">表象成分</h2><ul class=""><li id="d30a" class="mr ms iq kf b kg mg kk mh ko nr ks ns kw nt la nu mx my mz bi translated">主要关注用户界面。他们负责组件的外观。</li><li id="54aa" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la nu mx my mz bi translated">所有数据由props提供。哑组件不应该进行API调用。这是智能元件的工作。</li><li id="a198" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la nu mx my mz bi translated">除了UI包，它们不需要应用依赖。</li><li id="3421" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la nu mx my mz bi translated">它们可以包含状态，但只是为了操作UI本身——它们不应该存储应用程序数据。</li></ul><p id="f62a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哑组件的例子:<em class="nv">加载器，模态，按钮，输入</em>。</p><h2 id="2c12" class="nf lj iq bd lk ng nh dn lo ni nj dp ls ko nk nl lw ks nm nn ma kw no np me nq bi translated">容器组件</h2><ul class=""><li id="43c4" class="mr ms iq kf b kg mg kk mh ko nr ks ns kw nt la nu mx my mz bi translated">他们不关注造型，通常不包括任何造型。</li><li id="0749" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la nu mx my mz bi translated">它们是用来操作数据的。他们可以获取、捕获更改，并传递应用程序数据。</li><li id="cc4f" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la nu mx my mz bi translated">它们负责管理状态、重新渲染组件等。</li><li id="a43e" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la nu mx my mz bi translated">它们可能需要应用依赖、调用冗余、生命周期方法、API、库等。</li></ul><h2 id="4a15" class="nf lj iq bd lk ng nh dn lo ni nj dp ls ko nk nl lw ks nm nn ma kw no np me nq bi translated">使用表示和容器组件的好处</h2><ul class=""><li id="d3f1" class="mr ms iq kf b kg mg kk mh ko nr ks ns kw nt la nu mx my mz bi translated">更好的可读性</li><li id="8110" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la nu mx my mz bi translated">更好的可重用性</li><li id="99d5" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la nu mx my mz bi translated">更容易测试</li></ul><p id="93c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，它符合单一责任原则——一个组件负责外观，另一个组件负责数据。</p><h2 id="e73a" class="nf lj iq bd lk ng nh dn lo ni nj dp ls ko nk nl lw ks nm nn ma kw no np me nq bi translated">例子</h2><p id="ba50" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">让我们看一个简单的例子。这是一个图书列表组件，它从API获取图书数据并显示在列表中。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5523" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个组件的问题是，它负责太多的事情。它获取并呈现数据。它还与一个特定的端点相关联，所以不能使用这个组件来显示ex。某个用户的图书列表，无需重复代码。</p><p id="f621" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们试着将这个组件分成表示组件和容器组件。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">演示书籍列表组件</figcaption></figure><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Contianer图书列表组件</figcaption></figure><p id="4e93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，它看起来好多了。更重要的是，它允许我们在不同数据的许多地方使用书单组件。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="3a2b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">5.使用样式组件</h1><p id="7140" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">React组件的样式一直很成问题。查找拼写错误的类名、维护大型CSS文件、处理兼容性问题有时会很痛苦。</p><p id="4ae6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">样式化组件允许您使用带标签的模板文字在JavaScript中编写CSS。有了它们，您可以动态地设计组件样式，忘记使用类名，并优化CSS性能。</p><p id="4143" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从样式化组件开始，您需要使用NPM将样式化组件库添加到ReactJS项目中:</p><pre class="ml mm mn mo gt nw nx ny nz aw oa bi"><span id="acd4" class="nf lj iq nx b gy ob oc l od oe">npm i styled-components</span></pre><p id="8048" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们创建我们的第一个样式组件。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用样式组件的按钮和网格</figcaption></figure><p id="566f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到下面的结果:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="of mq l"/></div></figure><p id="2428" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是样式化组件如何工作的一个简单例子，但是它们可以做的远不止这些。你可以在他们的官方<a class="ae kc" href="https://styled-components.com/docs" rel="noopener ugc nofollow" target="_blank">文档</a>中读到更多关于风格化组件的内容。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="2611" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读！所以文章到此结束。我希望你学到了新的东西。如果你知道React中的其他技巧和诀窍，请在下面的评论区分享。能听到他们的消息真是太好了！</p></div></div>    
</body>
</html>