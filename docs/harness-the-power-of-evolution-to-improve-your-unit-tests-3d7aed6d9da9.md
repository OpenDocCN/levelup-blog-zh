# 利用进化的力量来改进你的单元测试

> 原文：<https://levelup.gitconnected.com/harness-the-power-of-evolution-to-improve-your-unit-tests-3d7aed6d9da9>

## 突变测试简介

![](img/5f8f8e15aabe77bf88578b3457c9cf5e.png)

[国家癌症研究所](https://unsplash.com/@nci?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

单元测试有什么问题？你可以想写多少就写多少，它们甚至可能通过，但仍然不能证明你的代码如预期的那样工作。或者正如 Dijkstra 所说的:

> 测试显示了缺陷的存在，而不是不存在。埃德格·w·迪杰斯特拉

即使为了显示 bug 的存在，您也需要编写足够多的测试，这样您就可以满怀信心地更改和发布您的代码。

没有足够的*测试会以两种不同的方式表现出来。首先，最终的软件不符合需求，用户没有得到他们所支付的。对需求和代码进行仔细的回顾，可以减少这种风险。除了尽早和经常地向用户展示你的软件。其次，并不是代码的每一行和每一个分支都由测试套件来执行。这可以很容易地用大量可用的代码覆盖工具来衡量，这些工具通常内置于您使用的单元测试运行程序或库中。*

![](img/1913ee5afd9e92a95e0716a7d5996cb7.png)

照片由[粘土堤](https://unsplash.com/@claybanks?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

代码覆盖率(或测试覆盖率)就是给定测试套件运行时代码执行的程度。有[多种方式来衡量](https://www.guru99.com/code-coverage.html#3)这个。一般来说，如果你的项目有 100%的覆盖率，那么你的单元测试会运行所有编写的代码。测试驱动开发的原则绝对有利于实现高覆盖率。如果你必须在相应的代码之前写一个测试*，你几乎可以毫不费力地达到 100%。*

高代码覆盖率可能意味着引入错误的可能性很低。但是继续从你的单元测试中删除所有的断言，你的测试覆盖率将保持不变。现在你有了一个覆盖 100%的测试套件，但是它和根本没有测试一样有用。

> …从你的单元测试中删除所有的断言，你的测试覆盖率仍然会保持不变。

一个足够好的测试套件将确保你的软件的语义稳定性:如果你在代码中引入任何改变其含义的修改，至少一个测试用例应该失败，提醒你语义的变化。当然，这是我们所有人对所有测试套件的期望，但通常来说，这是一个相当大的挑战。

如何创建一个足够好的测试套件？你如何确保不仅仅是*运行*的每一条语句，还要*测试*的每一条语句？这就是突变测试的用武之地。

# 变异一个玩具-例子

![](img/531a88e955355a1905e345364a9b7238.png)

[蒂莫西·戴克斯](https://unsplash.com/@timothycdykes?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

看看下面的 [Python](https://www.python.org/) 片段:

```
def double(number: float) -> float:
    return 2.0*****numberdef test_double() -> None:
    assert double(2.0) == 4.0
```

`double`提供的功能很简单:将任何输入乘以`2`并返回给调用者。当然，测试它也很简单，我们只需要验证函数返回的实际上是输入的两倍。但是验证`4`确实是`2`的替身*就足够好*了吗？毕竟代码有 100%的覆盖率。

如果我们用加法(`+`)代替乘法(`*`)会怎么样？代码将变成:

```
def double(number: float) -> float:
    return 2.0**+**numberdef test_double() -> None:
    assert double(2.0) == 4.0
```

很容易看出，任何数字加上`2`都不会翻倍。但是由于测试中使用的数字，它会通过(`2+2`确实是`4`)，即使代码明显被破解了。这个小测试套件不提供语义稳定性，错误可能会被忽视。我们可以在测试中使用不同的数字，例如`3`和`6`，使其对操作符的变化具有弹性(`2+3`不等于`6`)。

然而，运算符并不是我们在`double`函数中唯一可以破解的东西。我们可以将常数`2.0`替换为其他数字，也可以使用`number`参数。我们可以替换整个函数体来返回一个常数。通过对代码进行“正确的”修改，测试仍然会通过，但是代码会被破坏。即使在这个一行的函数中，至少有四个我们可以改变(破坏)的东西，我们需要几个测试用例来捕捉它们。

# 实践中的突变测试

![](img/dad91656ad04e618d90651bf0efbd092.png)

照片由[福蒂斯·福托普洛斯](https://unsplash.com/@ffstop?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在源代码中一个接一个地引入错误，运行测试，并评估错误是否被测试套件捕获，这就是突变测试的全部内容。每一个添加的错误都被称为一个突变体，当一个或多个测试失败时，它就会被“杀死”。

手动创建这些变更来验证测试套件的稳定性，既麻烦又耗时。这是突变测试工具帮助你的负担。这些工具通常有一组它们可以引入的突变类型。

作为突变测试会话的一部分，工具将遍历其预定义的一组可能的突变，为每个突变找到所有可行的位置，执行突变并运行测试套件。如果一个工具可以处理 10 种不同的突变，并且在代码中，每一种都可以被引入 10 个不同的位置，那么结果就是 100 个突变体和 100 次测试。

## 各种突变体

您或突变测试工具可以引入的代码变更种类取决于您使用的语言及其范式。

可能的突变不胜枚举，但仅举几例:

*   替换算术运算符(如上例所示，其中`*`和`+`被交换)
*   用`true`或`false`替换布尔表达式
*   用另一个值替换常量(通常将`1`或`-1`加到数字上，或者将`"XX"`追加到字符串上，等等)。)
*   替换布尔运算符(`and`到`or`，反之亦然)
*   替换布尔关系(如`<`至`<=`)
*   用`continue`替换`break`
*   反转`if`和`while`条件(如`if condition():`至`if not condition():`
*   隐藏异常
*   删除函数调用和其他语句
*   删除超级通话
*   替换访问修饰符(例如`public`到`private`)

![](img/07631ce288cf2cfba7327c8534e267dd.png)

由 [Ashkan Forouzani](https://unsplash.com/@ashkfor121?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

## 评估结果

最好的变异人是死了的变异人。如果测试套件在引入故障后失败，测试套件会检测到突变体，并且**会杀死**。但是如果测试通过了，而变异体没有被注意到，那么它**存活了**。幸存的突变体是缺失的测试用例或需要改进的测试用例的指示。

极少情况下，突变会导致代码不可编译或导致执行无限循环。(想想用`continue`代替`break`可能的含义。)让部分代码变得无用的变种人**无能**。大多数工具使用超时来处理无限循环，并且通常在统计中分离这些突变体。

有时候，一个突变根本不会改变代码的行为，并且会继续存在。这被称为**等价**突变，是突变测试实际应用的最大障碍之一。等效突变检测是一门独立的科学，并产生了许多白皮书，如标题很好的:[克服等效突变问题:二阶突变的系统文献综述和比较实验](https://madeyski.e-informatyka.pl/download/Madeyski13TSE.pdf)。

突变测试会话的成功由**突变分数**表示，该分数计算为杀死的突变体与产生的突变体的比率。如果所有的突变体都死了，突变分数是 100%，这应该给你足够的信心在你的测试套件。

## 复杂性

你可以看到这是如何迅速失控的。即使是一个中等复杂的软件项目也会有成百上千种可能的变异，每一种变异都会导致测试套件的新执行。

如果您的单元测试需要 30 秒来运行，那么几百个突变就可以将执行时间推到几个小时。甚至没有计算像 C++、C#或 Java 这样的语言的编译时间。许多工具使用各种形式的多重处理来缓解时间问题，将其转化为计算能力的问题。不管怎样，变异测试都很昂贵。

## 工具

许多流行的编程语言都有易于使用的工具，仅举几个例子:

*   Java 的最大缺陷
*   用于 JavaScript、C#和 Scala 的 Stryker
*   Python 的 MutMut
*   [为 C++考虑](https://github.com/mull-project/mull)

以及许多其他人。这些工具有不同程度的成熟度和功能，但是绝对值得尝试一下。你只能赢，让你的单元测试套件更加健壮和全面。

# 摘要

突变测试是白盒测试的一种形式，其中错误(或突变体)被引入到您的代码中，然后针对每个突变体，运行您的测试套件。如果测试失败，变异体就会被“杀死”。如果测试通过，突变体“存活”了下来。杀死的突变体越多，测试套件就越能确保代码的语义稳定性。

虽然这是一个强大的技术，但它是昂贵的。手头问题的规模通常使它成为一个不切实际的工具，即使对于小型软件项目也是如此。单元测试应该能够提供快速廉价的反馈，以秒为单位。

然而，即使您没有在您的开发工作流程中引入突变测试工具，您也一定可以从在构建您的测试时保持语义稳定性的心态中受益。问自己“如果这部分代码改变了，测试会失败吗？”在编写和审查代码时，绝对给了我一个新的视角。

# 其他来源和阅读材料

*   [突变测试，罗伯特·马丁](https://blog.cleancoder.com/uncle-bob/2016/06/10/MutationTesting.html)
*   [软件测试中的变异测试:变异得分&分析示例，Guru99](https://www.guru99.com/mutation-testing.html)
*   [突变测试，GeeksForGeeks](https://www.geeksforgeeks.org/software-testing-mutation-testing/)
*   Softwaretestinghelp.com，⁴ [什么是突变测试:示例教程](https://www.softwaretestinghelp.com/what-is-mutation-testing/)