# 面向对象设计的坚实原则

> 原文：<https://levelup.gitconnected.com/the-solid-principles-of-object-oriented-design-deeae9a626d9>

![](img/a6ac4590f1339f0bd105aac672d681a1.png)

泰勒·拉斯托维奇在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

在面向对象编程中，SOLID 是在设计软件时要牢记的五个基本原则的首字母缩写，以使软件更加灵活、易于理解和维护。

> 坚实原理的理论是由罗伯特·C·马丁也就是鲍勃大叔提出的，坚实的首字母缩略词后来是由迈克尔·费哲提出的。

**坚固**的设计原则是:

1.  单一责任原则
2.  **O** 笔/闭原理
3.  伊斯科夫替代原理
4.  **I** 界面偏析原理
5.  **D** 依赖反转原理

# 单一责任原则

实线中的“S”代表单一责任原则。

> 每个软件模块应该有且只有一个改变的理由。

当你写一个软件模块时，你想确保每个模块只有一个功能。当一个新的功能出现时，它被添加到一个单独的模块中。您希望将您的模块从整个组织的复杂性中分离出来。

*我们什么时候违反了 SRP 原则？*

当你创建一个具有多个功能的类时，这个原则就被打破了。这使得代码冗长、复杂且紧密耦合。

> 把因为同样的原因而改变的东西聚集在一起。把那些因为不同原因而改变的东西分开。

如果你思考这个问题，你会意识到这只是定义内聚和耦合的另一种方式。我们希望增加因相同原因而变化的事物之间的内聚力，我们希望减少因不同原因而变化的事物之间的耦合。

# 开/关原则

实线中的“O”代表开/关原理。

> 软件实体(类、模块、函数等。)应该对扩展开放，但对修改关闭。

*这里开和关是什么？*

*   如果一个模块仍然可以扩展，那么这个模块就被认为是开放的。应该可以扩展一个类，并向派生类中添加新功能。
*   如果一个模块可以使用，但是不能被其他模块修改，那么这个模块就被认为是关闭的。

我们什么时候打破了开闭原则？

当我们需要向现有的类中添加新的特性或新的行为时，在类中添加它本身就违背了这个原则。

# 利斯科夫替代原理

固体中的“L”代表利斯科夫替代原理。

> 程序中的对象应该可以用其子类型的实例替换，而不会改变程序的正确性。

派生类或子类必须可以替换它们的基类或父类。

我们什么时候违反了 LSP 原则？

当子类对象不能代替父类对象时，这个原则就被打破了。

# 界面分离原理

固体中的“I”代表界面分离原理。

> 许多特定于客户端的接口比一个通用接口要好。

我们不应该强迫一个类实现与其无关的接口。一个类应该只实现那些它想要实现其属性/功能的接口。

*我们什么时候违反了 ISP 原则？*

向类中添加不相关的接口属性违反了这一原则。例如，当一个素食者去餐馆要菜单时，提供给他的菜单包括素食和非素食。非素食对他来说无关紧要，这就是 ISP 原则被打破的地方。按照这个原则，只有素菜菜单卡才应该给他。

# 从属倒置原则

实线中的“D”代表依赖倒置原则。

> 一个人应该依靠抽象而不是具体。

1.  根据这个原则，高级代码不应该依赖于低级代码。高级和低级代码都应该依赖于抽象。
2.  同样，抽象不应该依赖于细节，但是细节应该依赖于抽象。

它有助于分离类之间的依赖关系，因此对一个类的修改不需要对另一个类进行修改。

*我们什么时候打破了蘸原则？*

当一个具体的类依赖于另一个类，而不是仅仅依赖于抽象时，这个原则就被打破了。这导致了类之间的紧密耦合。