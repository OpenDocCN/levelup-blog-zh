<html>
<head>
<title>Boost Your Web Application Performance With JavaScript Web Workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript Web Workers提升您的Web应用程序性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/boost-your-web-application-performance-with-javascript-web-workers-dcb050ea24a6?source=collection_archive---------7-----------------------#2021-10-26">https://levelup.gitconnected.com/boost-your-web-application-performance-with-javascript-web-workers-dcb050ea24a6?source=collection_archive---------7-----------------------#2021-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6733" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用web workers进行并行编程，同时执行多个操作。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8202adde5bbc89b3da10e705dbc4f468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUHukGHQehEWW_o_FPCMsg.png"/></div></div></figure><p id="e5d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这篇文章，我将向您介绍web workers，以及如何将它们集成到您的web应用程序中。</p><h1 id="df2b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">网络工作者简介</h1><p id="4059" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">JavaScript web workers允许开发人员执行并行编程，以帮助应用程序获得同时运行多个计算的能力。</p><p id="9987" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些web workers可以在后台线程中运行脚本，后台线程完全独立于主线程。因此，主线程减少了大量的工作量。这种工作负载分离的主要好处是，您可以在一个独立的线程中执行CPU密集型操作，这不会中断或影响主线程的反应性和可用性。当后台线程完成它的任务时，它通过一个事件立即通知主线程结果，这个事件通过普通的JavaScript事件处理来管理。</p><p id="4eb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，这些web worker有一些限制，比如不能访问DOM，不能访问web worker的父页面(创建它的页面)。记住这一点，您现在可以继续学习如何创建web workers。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="1681" class="ln lo iq bd lp lq mr ls lt lu ms lw lx jw mt jx lz jz mu ka mb kc mv kd md me bi translated">验证Web Worker支持</h1><p id="3d2f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">为了更好地控制错误处理和向后兼容性，建议将web worker的代码包含在下面的检查中。这将有助于检测您的浏览器是否支持web workers。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="b134" class="nb lo iq mx b gy nc nd l ne nf">if (window.Worker){<br/>    // Your web worker's code goes here<br/>}</span></pre><p id="07ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在几乎所有的浏览器都支持web workers。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="bb02" class="ln lo iq bd lp lq mr ls lt lu ms lw lx jw mt jx lz jz mu ka mb kc mv kd md me bi translated">创建Web Worker</h1><p id="4282" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您可以通过创建worker的新实例来创建web worker。您必须提供您希望worker执行的脚本的路径，作为它的参数。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6b87" class="nb lo iq mx b gy nc nd l ne nf">const worker = new Worker('./worker-script.js');</span></pre><p id="ca4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，变量<code class="fe ng nh ni mx b">worker</code>变成了一个<code class="fe ng nh ni mx b">Worker</code>实例，它将在<code class="fe ng nh ni mx b">worker-script.js</code>上执行脚本。</p><p id="7ee6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个web worker现在可以借助消息与主线程和其他web worker进行通信。消息可以包含任何可以序列化和不序列化的内容。函数或HTML元素不能在消息中发送。但是，可以发送由数字、字符串、普通对象和普通数组组成的消息。</p><blockquote class="nj nk nl"><p id="6962" class="kr ks nm kt b ku kv jr kw kx ky ju kz nn lb lc ld no lf lg lh np lj lk ll lm ij bi translated">创建web workers将产生真正的操作系统级线程，这些线程将消耗系统资源。如果使用不当，这可能会影响用户整个计算机的性能，而不仅仅是web浏览器。</p></blockquote></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d396" class="ln lo iq bd lp lq mr ls lt lu ms lw lx jw mt jx lz jz mu ka mb kc mv kd md me bi translated">从主线程向工作线程发送消息</h1><p id="d835" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">一旦创建了web worker，就可以使用<code class="fe ng nh ni mx b">postMessage()</code>方法启动它。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e468" class="nb lo iq mx b gy nc nd l ne nf">worker.postMessage(message);</span></pre><p id="ea2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">参考下面的代码片段，了解如何在项目中实现上述内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="22bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以通过实现一个<code class="fe ng nh ni mx b">onmessage()</code>事件处理程序在web worker中捕获这个消息。参考下面的代码片段，了解如何处理该消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="06cb" class="ln lo iq bd lp lq mr ls lt lu ms lw lx jw mt jx lz jz mu ka mb kc mv kd md me bi translated">从工作线程向主线程发送消息</h1><p id="3513" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您可以通过调用worker脚本中的<code class="fe ng nh ni mx b">postMessage()</code>方法从web worker发送消息。参考下面的代码片段，了解如何将响应或消息发送回主线程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a866" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到主线程，您可以将<code class="fe ng nh ni mx b">onmessage()</code>方法绑定到worker对象，以监听从web worker发回的消息。参考下面的代码片段，了解如何倾听员工的回应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><blockquote class="nj nk nl"><p id="18e0" class="kr ks nm kt b ku kv jr kw kx ky ju kz nn lb lc ld no lf lg lh np lj lk ll lm ij bi translated">当消息在主线程和web worker之间传输时，它只是被复制或传输(移动)，而不是共享。</p></blockquote></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="5775" class="ln lo iq bd lp lq mr ls lt lu ms lw lx jw mt jx lz jz mu ka mb kc mv kd md me bi translated">终止Web Worker</h1><p id="e48f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您可以直接从主线程或从工作线程终止web工作线程。在主线程中，您可以通过调用web worker的API的方法<code class="fe ng nh ni mx b">terminate()</code>来终止。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f911" class="nb lo iq mx b gy nc nd l ne nf">worker.terminate();</span></pre><p id="5828" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您还可以使用web worker的<code class="fe ng nh ni mx b">close()</code>方法从worker线程本身终止它。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="658b" class="nb lo iq mx b gy nc nd l ne nf">close();</span></pre><p id="440c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ng nh ni mx b">terminate()</code>被触发时，web worker立即被终止，没有任何机会完成正在进行的或未完成的操作。而且，它没有时间清理。因此，突然终止web worker可能会导致内存泄漏。类似地，当<code class="fe ng nh ni mx b">close()</code>在web worker内部被触发时，事件循环中出现的任何排队任务都被拒绝，web worker的作用域被关闭。</p><blockquote class="nj nk nl"><p id="52a3" class="kr ks nm kt b ku kv jr kw kx ky ju kz nn lb lc ld no lf lg lh np lj lk ll lm ij bi translated">建议负责任地使用web workers，并在它们完成执行任务后停止它们。这有助于为客户端计算机上的其他应用程序释放系统资源。</p></blockquote></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="a4da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太棒了。您已经学习了如何创建web worker、如何在两个线程之间有效地发送消息以及如何响应这些消息的基础知识。我很高兴听到你如何在你自己的项目中使用这些网络工作者。请在评论区告诉我。</p><blockquote class="nj nk nl"><p id="0649" class="kr ks nm kt b ku kv jr kw kx ky ju kz nn lb lc ld no lf lg lh np lj lk ll lm ij bi translated">如果你喜欢读这篇文章，并且学到了一些新的东西，那么请鼓掌，与你的朋友分享，并关注我以获得我即将发布的文章的更新。你可以在<a class="ae ns" href="https://www.linkedin.com/in/tara-prasad-routray-b83027145/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></blockquote></div></div>    
</body>
</html>