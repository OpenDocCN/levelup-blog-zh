<html>
<head>
<title>Breadth First Search (BFS) Algorithm Visually Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广度优先搜索(BFS)算法直观解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/breadth-first-search-bfs-algorithm-visually-explained-8dec1f514a6e?source=collection_archive---------11-----------------------#2020-06-03">https://levelup.gitconnected.com/breadth-first-search-bfs-algorithm-visually-explained-8dec1f514a6e?source=collection_archive---------11-----------------------#2020-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3ffbf2db21fc7c73bac24a11ac2d5373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2raqEuxlLQnit1G_TmNkCA.jpeg"/></div></div></figure><p id="41f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated">宽度优先搜索算法类似于深度优先搜索算法，只是它使用队列而不是堆栈。BFS在技术上与DFS相反，因为BFS算法在回溯探索较浅的节点之前首先探索最深的节点。元素可以入队或出队。队列基于先进先出原则(FIFO)工作，这意味着首先入队的元素将首先出队。BFS是这样工作的:</p><ul class=""><li id="40a7" class="li lj it kd b ke kf ki kj km lk kq ll ku lm ky ln lo lp lq bi translated">选择第一个节点</li><li id="d083" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated">浏览所有未访问的节点，并将它们排队</li><li id="a328" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated">一旦从第一节点访问了所有未访问的相邻节点，就使第二节点出队</li><li id="e58b" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated">移动到下一个排队的节点并重复该过程</li></ul><p id="a3a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看广度优先搜索算法。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lw"><img src="../Images/6c72afb7ca4cd1bf9f857f89843fdbdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cm2p4Fee9nhsGIWYPs-S_w.png"/></div></div></figure><p id="816a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">BFS算法做的第一个操作是选择顶点A作为起点。为什么是顶点A？因为那是我们决定开始的顶点。顶点A被添加到发现列表中，并被设置为当前节点。当前节点用箭头表示。它被标记为已访问，但没有排队。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/edcdd767192b63568a6f4fdc5b58c90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCVEEK_5rxP6jzYOdL8L0g.png"/></div></div></figure><p id="34c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与其相邻的顶点B和G按字母顺序排列。顶点B被添加到发现列表中，随后是顶点g。这两个顶点都被标记为已访问。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/816d4b7a0aa976057addb066a589d141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfmelOiANlmzSilq6H6fYg.png"/></div></div></figure><p id="8154" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于没有额外的、未被发现的相邻节点，顶点a的发现阶段就完成了。由于顶点B首先入队，所以它现在出列并被选为继续遍历的节点。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/305221b6b9406cce3c3217b1801a2085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yX-SXoPk_gv1F5_0wCqZg.png"/></div></div></figure><p id="3477" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该过程重复进行。来自当前节点的所有相邻的、未被访问的顶点被排队。顶点B有一个未被发现的节点:顶点C。顶点C被排队，添加到发现列表，并标记为已访问。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/da186d6cb08038af080e0cbb5b008feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0DcJwhNB8qI8FZZpfmAgA.png"/></div></div></figure><p id="462f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于没有额外的、未被发现的相邻节点，顶点b的发现阶段就完成了。由于顶点G是下一个入队的，所以它现在出列并被选为继续遍历的节点。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/4f053f86eb625d20be254ccb94ed0f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47O9QhF8An6ZMy1xtDhLkg.png"/></div></div></figure><p id="7f52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自顶点G的所有相邻的、未被访问的顶点被排队。顶点G有两个未被发现的节点:顶点E和j。这两个顶点都被排队，添加到发现列表，并标记为已访问。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mf"><img src="../Images/90bb2c9b7486f63679c0211f6d52d9b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCNenEasuREklGcayjLDhw.png"/></div></div></figure><p id="6b2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于没有额外的、未被发现的相邻节点，顶点g的发现阶段就完成了。由于顶点C是下一个入队的，所以它现在出列并被选为继续遍历的节点。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/18661f351237889c9610e071d0b822e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbrHkZNk4oqIIoOz3AV1JA.png"/></div></div></figure><p id="2c04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有额外的、未被发现的相邻节点，因此顶点c的发现阶段就完成了。由于顶点E是下一个入队的，所以它现在出列并被选为继续遍历的节点。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/65759c1e2a1ed32d27934e0fc90a8a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vsc01nu0tXAyWw7VbDhMCw.png"/></div></div></figure><p id="df70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自顶点E的所有相邻的、未被访问的顶点被排队。顶点E有一个未被发现的节点:顶点K。顶点K被排队，添加到发现列表，并被标记为已访问。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/4c78d711bcc953d12ee3e9f769adc19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zaOP1N85cabiM5KRchTTw.png"/></div></div></figure><p id="d4dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有额外的、未被发现的相邻节点，因此这完成了顶点e的发现阶段。因为顶点J是下一个入队的，所以它现在出列并被选择作为继续遍历的节点。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/de832876a668cd4fabe65c8be184f5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lOa4A7XJmNrna-6tnI89EQ.png"/></div></div></figure><p id="90a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自顶点J的所有相邻的、未被访问的顶点被排队。顶点J有两个未被发现的节点:顶点D和f。这两个顶点都被排队，添加到发现列表，并标记为已访问。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/b8f5c8ff0e895d4cd78569139b0f2abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SuCSDGJcgnj6u4WWmnivgQ.png"/></div></div></figure><p id="196e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管该算法已经发现了图中的所有节点，但是直到队列为空时才能完成。从顶点J没有额外的、未被发现的相邻节点；这就完成了顶点j的发现阶段。因为顶点K是下一个入队的，所以它现在出队并被选为继续遍历的节点。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/b148e0783175922c76008c849bc7e22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcFsFFanu2zvdfpy_ycENA.png"/></div></div></figure><p id="4a66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有额外的、未被发现的相邻节点，因此顶点k的发现阶段就完成了。由于顶点D是下一个入队的，所以它现在出列并被选择作为继续遍历的节点。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mf"><img src="../Images/dcbd67ea096b96a0ced619d6b3002d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_HhNztxasmelPMu6dAic_g.png"/></div></div></figure><p id="4ba3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有额外的、未被发现的相邻节点，因此这完成了顶点d的发现阶段。因为顶点F是下一个入队的，所以它现在出列并被选择作为继续遍历的节点。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mk"><img src="../Images/ae71b206602f7f67437145230bf536d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TbOZEih3JChcEjPafr3LKw.png"/></div></div></figure><p id="673a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有额外的、未被发现的相邻节点，因此这完成了顶点f的发现阶段。由于队列是空的，这完成了遍历过程。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="3af9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢你所读的，我的书，<a class="ae mt" href="https://www.amazon.com/Illustrative-Introduction-Algorithms-Dino-Cajic-ebook-dp-B07WG48NV7/dp/B07WG48NV7/ref=mt_kindle?_encoding=UTF8&amp;me=&amp;qid=1586643862" rel="noopener ugc nofollow" target="_blank"><em class="ms"/></a><em class="ms">【算法的说明性介绍】，涵盖了这个算法和更多。</em></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5c77e89e449eaa340fb4dee03fe5f364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xE1mwX4b2qtP20xh.jpeg"/></div></div></figure><p id="f0b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Dino Cajic目前是<a class="ae mt" href="https://www.lsbio.com/" rel="noopener ugc nofollow" target="_blank"> LSBio(寿命生物科学公司)</a>、<a class="ae mt" href="https://absoluteantibody.com/" rel="noopener ugc nofollow" target="_blank">绝对抗体</a>、<a class="ae mt" href="https://www.kerafast.com/" rel="noopener ugc nofollow" target="_blank"> Kerafast </a>、<a class="ae mt" href="https://everestbiotech.com/" rel="noopener ugc nofollow" target="_blank"> Everest BioTech </a>、<a class="ae mt" href="https://www.nordicmubio.com/" rel="noopener ugc nofollow" target="_blank"> Nordic MUbio </a>和<a class="ae mt" href="https://www.exalpha.com/" rel="noopener ugc nofollow" target="_blank"> Exalpha </a>的IT负责人。他还是我的自动系统公司的首席执行官。他有十多年的软件工程经验。他拥有计算机科学学士学位，辅修生物学。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。</p><p id="b9fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在<a class="ae mt" href="https://www.linkedin.com/in/dinocajic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，在<a class="ae mt" href="https://instagram.com/think.dino" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注他，或者<a class="ae mt" href="https://dinocajic.medium.com/subscribe" rel="noopener">订阅他的媒体出版物</a>。</p><p id="733d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">阅读迪诺·卡吉克(以及媒体上成千上万的其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。T9】</p></div></div>    
</body>
</html>