# 带有一个简单隐喻的链表

> 原文：<https://levelup.gitconnected.com/linked-lists-with-one-simple-metaphor-cc243b6c76fd>

## 单向和双向链表的解释和代码示例。

![](img/eaab1fc217e469137cbce7269449fe3b.png)

Vonecia Carswell 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

编程概念非常抽象。所以每次当我学习新的东西时，我都试着把它形象化，为这个概念找到一个视觉隐喻。现在我将和你分享我找到的比喻，来解释我自己，链表的概念。

有兴趣的可以看看我对排序和搜索算法的解释(当然也带比喻)。

[](/basic-sorting-and-searching-algorithms-in-one-metaphor-44bbccc7e4f0) [## 一个隐喻中的基本排序和搜索算法

### 用一个简单的例子解释最常见的排序和搜索算法。

levelup.gitconnected.com](/basic-sorting-and-searching-algorithms-in-one-metaphor-44bbccc7e4f0) 

好的。我们开始吧。

# 单向链表

## 1.暗喻

想象你正在参加一个团体旅游。例如，大约有二十个人，当然还有一个导游。你在一个非常拥挤的广场上。你的向导不想失去你们中的任何人。所以他或她要求你站成一排，把手放在你前面的人的肩膀上。是的，我知道像这样移动有点困难，但现在我们确信我们都在一起，彼此相连。另外，假设导游是这一行的第一个人。没有人在他背后。很简单，因为他想看到每个人，这更像是一个链表。你马上就会同意了。

所以现在我们有了一个完美的链条。我们的向导是队伍的头，我们是队伍的成员。这条线上的每个人都彼此紧密相连。对了，我们只知道站在我们正前方的人。当然，我们知道有人也站在后面，但他或她是谁，我们无法意识到。

正是这种数据结构被称为链表。更正确一点——单链表，因为我们的连接是单向的。现在我们来看看如何用代码实现它。

## 2.密码

在这篇文章中，我使用 Java，但是你可以用任何你喜欢的编程语言写同样的东西，因为原理是一样的。

**创建一个节点**

首先，我们需要创建一个人，抱歉，是一个节点，它代表列表中的一个单项。对于这个项目，我们需要两个参数:一个表示项目的值(对于一个人来说，它可以是一个名字)和一个所谓的指针——向我们显示下一个是什么(或谁)的东西。就像我们放在邻居肩膀上的手，握住他，知道他是谁。

看起来是这样的:

是的，我们在这里看到两个我们讨论过的参数:我们传递给一个节点的值和我们的节点指向的下一个节点。当我们第一次没有真正的链时，它等于 null，因为我们的节点没有指向任何地方。我们会晚点改。

**创建一个链表**

现在我们可以开始构建一个链表本身。你可以假设它由节点组成。

是的，那很容易。这里我们有一个 Node 类型的变量头。它是我们的向导，队伍中的第一个人(物品)。目前，它等于 null，例如空的。但是我们需要知道，在某个地方，我们有这个第一名，作为我们列表的参考点。

**添加节点**

现在让我们假设在一次购物休息后，我们来到广场，看到我们所有的朋友都已经在排队了。我们需要在其中找到自己的位置。我们如何做到这一点？

有三种选择:我们可以成为第一人，例如导游。为什么不呢？或者我们可以去队尾，在队尾排队。或者我们想离朋友近一点，待在中间的某个地方。

用编程的术语来说是什么意思？

如果我们想成为一名向导，这意味着我们现在是队伍的头。头一个变成了第二个，我们指向他。这条线的其余部分不会改变。

如果我们站在队伍的最后，也会发生非常相似的事情。只有最后一个之前谁也没抱过的人现在抱着我们。指向我们。

如果我们决定在中途进行干预，就会发生一点棘手的事情。我们需要打破两个邻居之间的联系，把自己放在那里。现在前一个人指着我们，我们指着下一个。用编程的术语来说，这意味着我们需要改变一个指针并添加另一个指针。

下面是所有三种方法的清单。

注意: *node.next = anotherNode* 意味着我们把一个指针从一个元素指向另一个元素。而 n *ode = node.next* 意味着我们在列表中移动到另一个元素。

**删除节点**

但是，如果我们累了，或者远足太无聊了，我们不想继续呆在那里。我们该走了。但是我们不能就这样把手拿开，甩开握着我们的人的手。即使在我们离开后，我们也需要保留这条链子。

所以我们需要明智地去做。我们需要拉着站在我们后面的人的手，把它们放在站在我们前面的人的肩上。

这是完成这项工作的程序清单。索引是我们在队列中的编号。

**打印链表**

在添加和删除之后，我们想知道链表是什么样子的。所以我添加了一个方法 *toString* 来打印它。

**游乐场**

只是为了好玩，我们可以检查一切正常。

# 双向链表

## 1.暗喻

好的。我们认为像这样移动真的很不舒服:抓住站在你面前的人的肩膀。但是我们不能简单地脱离。你要记得，我们可能会迷路。所以我们决定我们可以握着手。很好，真的舒服多了。

现在我们把一只手给上一个人，另一只手给下一个人。我们变得双重相连。就像双向链表一样。每个元素都指向单链表中的下一项。与此同时——对之前的。

我们如何对此进行编码？

## 2.密码

**创建一个节点**

很好。没什么不同。相同的字符串参数*值*。但是现在有两个指向其他节点的指针:next 和 previous。

**创建一个双向链表**

现在，我们可以创建一个双向链表，在链表的开头有一个变量头。

**添加和删除节点**

在双向链表中添加和删除节点的所有方法都与单向链表非常相似。所以我觉得没必要长篇大论的解释。我们只需要照顾两只手，抱歉，指针而不是一只。

这是所有添加和删除方法的列表。

*ToString* 方法将完全相同，并且 main 函数与 add 和 delete 方法也将显示相同的结果。我觉得我们不需要再看一遍。

现在我们知道了如何实现单向和双向链表。太好了！但是还有几个额外的问题我想说说。

首先，如果一个双向链表看起来和一个单向链表非常相似，我们为什么要把我们的生活复杂化呢？

答案是，尽管有点复杂，但我们有很多优势。我们不需要遍历所有的链表来找到给定链表的前一个节点。我们只是知道它。同样，这意味着我们可以向两边遍历我们的列表:向前和向后。没有必要每次都从头开始。

我之前在代码中没有提到它，但是如果我们不是根据位置而是根据元素本身来寻找某个元素，那么在它之前插入一个新元素或者删除它会变得更加容易:

```
// insert new node before given one
node.previose.next = newNode;
node.previous = newNode;// delete given node
node.previous.next = node.next;
node.next.previous = node.previous;
```

接下来的问题是现实生活中真的有人用这些东西吗？

当然可以。

这些只是少数使用案例:

*   一种教育系统，其中列表项是带有某种信息和任务的页面。当用户通过一个页面时，他前进到另一个页面。
*   一个图像处理程序(比如 Photoshop)。你做了几个步骤的改变，程序会按照你做的顺序记住它们。
*   一种网页浏览器，它会记住您以前访问过的几个网页，并允许您在这些网页之间来回移动。
*   任何支持撤销和重做功能的程序。
*   我最喜欢的:一个音乐播放列表，其中每首歌曲都链接到上一首和下一首，我可以根据自己的口味进行定制。

最后，我想给你一些额外的资源，让你更深入地了解这个主题:

[https://leetcode.com/explore/learn/card/linked-list](https://leetcode.com/explore/learn/card/linked-list/)——一个学习新事物并立即训练它们的伟大网站。对面试准备也有帮助。

[https://dzone . com/articles/20-linked-list-interview-questions-for-Java-progra](https://dzone.com/articles/20-linked-list-interview-questions-for-java-progra)—不同链表问题的列表及解答。

[https://medium . com/techie-delight/linked-list-interview-questions-and-practice-problems-55f 75302d 613](https://medium.com/techie-delight/linked-list-interview-questions-and-practice-problems-55f75302d613)—一个更大的链表问题列表，也有解决方案。

所以不要害怕新的和未知的东西。想象一下。