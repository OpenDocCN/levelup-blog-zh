<html>
<head>
<title>Beginners Guide to Integrating Django and Robotic Operating System (ROS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集成Django和机器人操作系统(ROS)的初学者指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/beginners-guide-to-integrating-django-and-robotic-operating-system-ros-f889f6245929?source=collection_archive---------5-----------------------#2020-04-24">https://levelup.gitconnected.com/beginners-guide-to-integrating-django-and-robotic-operating-system-ros-f889f6245929?source=collection_archive---------5-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0859d424fb75323579fbdba9625d45f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxNvUPZiKAXLq13-6iNtoA.jpeg"/></div></div></figure><div class=""/><p id="d05a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我注意到网上缺乏将基于网络的技术与机器人技术相结合的好教程。可能是因为标准最近才开始建立。可能是机器人社区和全栈软件工程师有些细分。不管怎样，我个人对这两者的交集非常感兴趣，所以今天我将向您展示一个快速教程，介绍如何将ROS数据呈现给web应用程序。</p><p id="fbe2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天的目标是在网络应用程序上实时绘制模拟机器人的位置。你应该在本教程末尾看到的演示可以在<a class="ae kz" href="https://www.youtube.com/watch?v=AwqDSRAxaRU&amp;t=3s" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="44d6" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">先决条件</h1><p id="4cfe" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">首先，本教程假设你使用的是Ubuntu 18.04，我没有在其他操作系统上测试过，也不知道ROS在其他操作系统上的支持程度(如果有的话)。</p><p id="261c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我选择的筹码是django、redis和ROS。如果你没有做过django或ROS的入门，我建议你看看下面的教程和安装指南:</p><ul class=""><li id="29ae" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">【https://docs.djangoproject.com/en/3.0/intro/tutorial01/ T2】号</li><li id="c52d" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">【http://wiki.ros.org/ROS/Tutorials T4】</li></ul><p id="6df1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我用的是ROS 1(旋律)。另外，我使用的是Django的websocket系统，名为Django-Channels，我在下面链接了一些文档。</p><ul class=""><li id="0942" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated"><a class="ae kz" href="https://channels.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://channels.readthedocs.io/en/latest/</a></li></ul><h1 id="5a8a" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">网络服务器</h1><p id="cef9" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><strong class="kd jf">安装</strong></p><p id="8502" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过运行以下命令下载我的django-ros-turtlesim存储库:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="18ee" class="na lb je mw b gy nb nc l nd ne">curl -LOk <a class="ae kz" href="https://github.com/samcrane8/django-ros-turtlesim-server/archive/master.zip" rel="noopener ugc nofollow" target="_blank">https://github.com/samcrane8/django-ros-turtlesim-server/archive/master.zip</a></span></pre><p id="ebf4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后解压缩存储库并运行以下命令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9ab7" class="na lb je mw b gy nb nc l nd ne">cd django-ros-turtlesim-server-master/<br/>python -m venv venv<br/>source venv/bin/activate<br/>pip install -r requirements.txt<br/>python manage.py runserver</span></pre><p id="88b1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">注意</strong>:上面假设你想在虚拟环境中做所有的事情，如果你不想，你只需要运行最后两个命令。</p><p id="583b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在单独的选项卡中，开始运行redis服务器:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c14a" class="na lb je mw b gy nb nc l nd ne">redis-server</span></pre><p id="c2b9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">工作原理</strong></p><p id="626a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个django服务器有两个应用程序设置:网站和django_ros。网站应用程序是主要站点，它依赖django_ros来提供处理机器人的API。</p><p id="d3e3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开django-ROS-turtle sim-server/django _ ROS/routing . py，往里面看看。您将看到以下内容:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="fad0" class="na lb je mw b gy nb nc l nd ne"># chat/routing.py<br/>from django.urls import re_path</span><span id="8839" class="na lb je mw b gy nf nc l nd ne">from django_ros.Robot.RobotConsumer import RobotConsumer</span><span id="5255" class="na lb je mw b gy nf nc l nd ne">websocket_urlpatterns = [<br/>    re_path(r'ws/robot/(?P&lt;room_name&gt;\w+)/$', RobotConsumer),<br/>]</span></pre><p id="be2a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该文件描述了一个机器人应该提交其通信的端点。您会注意到有一个描述端点应该是什么样子的字符串，然后是一个消费者。消费者特定于django-channels，并且是websocket通信的结构。让我们看看这个。</p><p id="63fd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">继续打开django-ROS-turtle sim-server/django _ ROS/Robot/Robot controller . py</p><p id="d740" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，您将看到下面的类:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="89dd" class="na lb je mw b gy nb nc l nd ne">class RobotConsumer(AsyncWebsocketConsumer):</span><span id="834d" class="na lb je mw b gy nf nc l nd ne">async def connect(self):<br/>self.room_name = self.scope[‘url_route’][‘kwargs’][‘room_name’]<br/>self.room_group_name = ‘chat_%s’ % self.room_name</span><span id="81af" class="na lb je mw b gy nf nc l nd ne"># Join room group<br/>await self.channel_layer.group_add(<br/>self.room_group_name,<br/>self.channel_name<br/>)</span><span id="bc4a" class="na lb je mw b gy nf nc l nd ne">await self.accept()</span><span id="2550" class="na lb je mw b gy nf nc l nd ne">async def disconnect(self, close_code):<br/>    # Leave room group<br/>    await self.channel_layer.group_discard(<br/>    self.room_group_name,<br/>    self.channel_name<br/>    )</span><span id="2246" class="na lb je mw b gy nf nc l nd ne"># Receive message from WebSocket<br/>async def receive(self, text_data):<br/>    text_data_json = json.loads(text_data)<br/>     message = text_data_json[‘message’]</span><span id="066f" class="na lb je mw b gy nf nc l nd ne"># Send message to room group</span><span id="4898" class="na lb je mw b gy nf nc l nd ne">await self.channel_layer.group_send(<br/>self.room_group_name,<br/>    {<br/>        ‘type’: ‘topic_message’,<br/>        ‘message’: message<br/>    }<br/>)</span><span id="a7b6" class="na lb je mw b gy nf nc l nd ne"># Receive message from room group</span><span id="00d2" class="na lb je mw b gy nf nc l nd ne">async def topic_message(self, event):</span><span id="721f" class="na lb je mw b gy nf nc l nd ne">message = event[‘message’]<br/># Send message to WebSocket</span><span id="5ac4" class="na lb je mw b gy nf nc l nd ne">await self.send(text_data=json.dumps({<br/>‘message’: message<br/>}))</span></pre><p id="93de" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在这里了解更多关于消费者如何工作的<a class="ae kz" href="https://channels.readthedocs.io/en/latest/tutorial/part_3.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0b0b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">特别是在这个应用程序中，我们使用这个消费者来:</p><ol class=""><li id="2ca0" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky ng mj mk ml bi translated">创建一个供多个客户端通信的通道。</li><li id="9b99" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky ng mj mk ml bi translated">提供名为“主题消息”的消息类型</li><li id="0716" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky ng mj mk ml bi translated">处理接收和向通道显示主题消息。</li></ol><p id="56e5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想看的服务器端的最后一个关键文件是django-ROS-turtle sim-server/django _ ROS/templates/turtle/room . html文件。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="aa0b" class="na lb je mw b gy nb nc l nd ne">&lt;! — chat/templates/chat/room.html →<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;meta charset=”utf-8"/&gt;<br/>&lt;title&gt;Robot Display/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;div id=”chat-log” cols=”100" rows=”20"&gt;&lt;/div&gt;&lt;br&gt;<br/>&lt;input id=”chat-message-input” type=”text” size=”100"&gt;&lt;br&gt;<br/>&lt;canvas id=”myCanvas” height=”500" width=”500" style=”border: 1px solid black”&gt;&lt;/canvas&gt;<br/>{{ room_name|json_script:”room-name” }}<br/>&lt;script&gt;<br/>const roomName = JSON.parse(document.getElementById(‘room-name’).textContent);<br/>const canvas = document.getElementById(“myCanvas”);<br/>const ctx = canvas.getContext(“2d”);<br/>const chatSocket = new WebSocket(<br/>‘ws://’<br/>+ window.location.host<br/>+ ‘/ws/robot/’<br/>+ roomName<br/>+ ‘/’<br/>);<br/>chatSocket.onmessage = function(e) {<br/>const data = JSON.parse(e.data);<br/>// Store the current transformation matrix<br/>ctx.save();<br/>// Use the identity matrix while clearing the canvas<br/>ctx.setTransform(1, 0, 0, 1, 0, 0);<br/>ctx.clearRect(0, 0, canvas.width, canvas.height);<br/>// Restore the transform<br/>ctx.restore();<br/>ctx.save();<br/>ctx.translate(data.message.x * 25,canvas.height — data.message.y * 25)<br/>ctx.rotate(0.5*Math.PI — data.message.theta)<br/>ctx.beginPath();<br/>ctx.moveTo(0, 0);<br/>ctx.lineTo(-10, 10);<br/>ctx.lineTo(10, 10);<br/>ctx.closePath();<br/>ctx.stroke();<br/>ctx.restore();<br/>document.querySelector(‘#chat-log’).innerHTML = (JSON.stringify(data.message) + ‘\n’);</span><span id="0664" class="na lb je mw b gy nf nc l nd ne">};<br/>chatSocket.onclose = function(e) {<br/>console.error(‘Chat socket closed unexpectedly’);<br/>};<br/>document.querySelector(‘#chat-message-input’).focus();<br/>document.querySelector(‘#chat-message-input’).onkeyup = function(e) {<br/>if (e.keyCode === 13) { // enter, return<br/>document.querySelector(‘#chat-message-submit’).click();<br/>}<br/>};<br/>document.querySelector(‘#chat-message-submit’).onclick = function(e) {<br/>const messageInputDom = document.querySelector(‘#chat-message-input’);<br/>const message = messageInputDom.value;<br/>chatSocket.send(JSON.stringify({<br/>‘message’: message<br/>}));<br/>messageInputDom.value = ‘’;<br/>};<br/>&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d0b9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个文件的作用是创建一个画布，模拟海龟的一个小头像将在上面移动。看一下websocket代码:我们连接到我之前提到的同一个端点，只是接收数据来移动我们的虚拟角色。</p><p id="2dba" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然您已经看了服务器，让我们看一下另一面:客户机。</p><h1 id="ebe6" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">客户</h1><p id="260b" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><strong class="kd jf">安装</strong></p><p id="ca90" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，你应该有ROS melodic设置以及柳絮工作空间设置。请参考我在本文开头链接的教程。</p><p id="d822" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您需要安装django-ros-turtlesim-client:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c309" class="na lb je mw b gy nb nc l nd ne">cd ~/catkin_ws/src/<br/>curl -LOk <a class="ae kz" href="https://github.com/samcrane8/django-ros-turtlesim-client/archive/master.zip" rel="noopener ugc nofollow" target="_blank">https://github.com/samcrane8/django-ros-turtlesim-client/archive/master.zip</a></span></pre><p id="3804" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">继续解压缩存储库。</p><p id="cab5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦你理解了ROS的基础知识，这里的代码就非常简单了。首先看一下<code class="fe nh ni nj mw b">run.launch</code>文件:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f268" class="na lb je mw b gy nb nc l nd ne">&lt;launch&gt;<br/>  &lt;node pkg="turtlesim" name="sim" type="turtlesim_node"/&gt;<br/>  &lt;node pkg="django_turtle" name="djang_turt" type="djangoChannelsRosClient.py"/&gt;<br/>&lt;/launch&gt;</span></pre><p id="7438" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两个节点正在运行:首先是turtlebot模拟器，然后是我们的django_turtle包。模拟器实际上创建了主题和逻辑来移动海龟，而django_turtle是turtlebot的pose主题的订阅者，turtle bot转过身来将数据推送到websocket连接。您可以在这里看到处理这部分代码的逻辑:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9bf3" class="na lb je mw b gy nb nc l nd ne">ws = websocket.WebSocket()<br/>ws.connect("ws://localhost:8000/ws/robot/guy/")<br/><br/><br/>def callback(data):<br/>    global ws<br/>    rospy.loginfo(rospy.get_caller_id() + 'x: %s', data.x)<br/>    position = {<br/>        'x': data.x,<br/>        'y': data.y,<br/>        'theta': data.theta<br/>    }<br/>    message = json.dumps({ 'message' : position })<br/>    ws.send('%s' % message)<br/><br/><br/>def listener():<br/><br/>    # In ROS, nodes are uniquely named. If two nodes with the same<br/>    # name are launched, the previous one is kicked off. The<br/>    # anonymous=True flag means that rospy will choose a unique<br/>    # name for our 'listener' node so that multiple listeners can<br/>    # run simultaneously.<br/>    rospy.init_node('robotDispatcher', anonymous=True)<br/>    rospy.Subscriber('turtle1/pose', Pose, callback)<br/><br/>    # spin() simply keeps python from exiting until this node is stopped<br/>    rospy.spin()<br/><br/><br/>if __name__ == '__main__':<br/>    listener()</span></pre><p id="8d8c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在顶部看到正在创建的websocket连接，并注意到该连接指向“guy”机器人。这只是这个机器人的默认行为，在一个更复杂的例子中，你可以让机器人知道自己的ID，并可以启动独特的“房间”来传递数据。</p><p id="e218" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回调函数实际上被传递给listener函数中定义的rospy订阅者:它只是这个节点每次从<code class="fe nh ni nj mw b">/turtle1/pose</code>主题接收数据时发生的函数。请注意，我们正在传递机器人的x，y和θ。当它到达我之前展示的模板文件时，这些数据就被用来绘制javascript画布。</p><p id="4309" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">构建</strong></p><p id="fb86" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要构建该程序，您需要运行以下命令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2039" class="na lb je mw b gy nb nc l nd ne">cd ~/catkin_ws<br/>catkin_make</span></pre><p id="ac99" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果构建没有错误，那么您就可以运行这个程序了。</p><h1 id="bbc1" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">运行程序</h1><p id="813a" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">运行本教程需要四个终端选项卡。您可以在这里观看我如何运行程序<a class="ae kz" href="https://www.youtube.com/watch?v=AwqDSRAxaRU" rel="noopener ugc nofollow" target="_blank">，或者您可以执行以下操作:</a></p><ol class=""><li id="3599" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky ng mj mk ml bi translated">运行rosnodes。运行以下脚本:</li></ol><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="5831" class="na lb je mw b gy nb nc l nd ne">source ~/catkin_ws/devel/setup.bash //a setup script for catkin<br/>cd <!-- -->~/catkin_ws/src/django-ros-turtlesim-client<br/>roslaunch django-ros-turtlesim-client run.launch</span></pre><p id="ff33" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.运行redis服务器:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2f00" class="na lb je mw b gy nb nc l nd ne">redis-server</span></pre><p id="b943" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.运行django服务器(从django github项目的根目录):</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="61f9" class="na lb je mw b gy nb nc l nd ne">cd django-ros-turtlesim-server<br/>python manage.py runserver</span></pre><p id="8153" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.最后，您需要运行turtlesim teleop命令来控制海龟。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6adc" class="na lb je mw b gy nb nc l nd ne">source ~/catkin_ws/devel/setup.bash<br/>rosrun turtlesim turtle_teleop_key</span></pre><p id="54a5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用箭头键在屏幕上移动机器人时，保持第四个终端(teleop终端)高亮显示。你会在蓝屏上看到乌龟在移动。</p><p id="2fca" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您需要打开一个网络浏览器，并转到<code class="fe nh ni nj mw b"><a class="ae kz" href="http://localhost:8000/ros/robot/room/guy/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000</a>/ros/robot/room/guy/</code></p><p id="967e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将向您展示我们从django服务器上看到的html文件的呈现。它看起来像下面这样:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/308b14effacd4e9d8868252fd658092f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPQlK10dbSWqiq1rrxVVQg.png"/></div></div></figure><h1 id="f400" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="4bfe" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">今天，我们学习了如何向web应用程序实时显示机器人数据。这个想法有很多不同的方向，从跟踪机器人送货到管理搜索和救援无人机。我相信，随着机器人成为我们生活中更重要的一部分，应用程序的数量只会增加。</p></div></div>    
</body>
</html>