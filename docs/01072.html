<html>
<head>
<title>How to use __dunder__ methods to refine your data model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用__dunder__方法来优化您的数据模型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-dunder-methods-to-refine-data-model-c58ee41102e9?source=collection_archive---------2-----------------------#2019-11-04">https://levelup.gitconnected.com/using-dunder-methods-to-refine-data-model-c58ee41102e9?source=collection_archive---------2-----------------------#2019-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6000b5b3ae5ec05b76d09cbf4513e7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFC5V_gPQ5u4_e6IybuDnA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">我们决定叫醒所有人。波兰，2019。私图。</figcaption></figure><div class=""/><div class=""><h2 id="4530" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">通过使用<em class="kx">四元数</em>理解__init__和其他特殊的Python函数</h2></div><h1 id="11f2" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">介绍</h1><p id="b233" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">几乎每个使用过Python的人都会遇到至少一种所谓的Python <em class="mm">魔法</em>方法。Dunder 方法是Python的特殊函数，允许用户<strong class="ls jj">挂钩到</strong>一些正在执行的特定动作。大概最常遇到的就是<code class="fe mn mo mp mq b">__init__</code>法了。当从一个类实例化一个新对象时调用它，通过覆盖它，我们可以获得对该过程的控制。</p><p id="70c4" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">然而，这篇文章<strong class="ls jj">不会</strong>带你浏览这些的<a class="ae mw" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank">完整列表</a>。</p><p id="0357" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">相反，我们将通过讲述一个简短的<em class="mm">故事</em>来展示如何有效地使用这个伟大的Python特性。我们将使用<em class="mm">四元数</em>作为例子来解释创建我们的<strong class="ls jj">数据模型</strong>的过程，这对于其他开发人员来说很容易处理，尤其是那些对高等代数不太感兴趣的人。最重要的是，我们将解释<strong class="ls jj">决策过程</strong>,并论证为什么<strong class="ls jj">甚至费神也是有意义的。</strong></p><h1 id="8ac3" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">简单对象</h1><p id="a7a2" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">一个<a class="ae mw" href="https://en.wikipedia.org/wiki/Quaternion" rel="noopener ugc nofollow" target="_blank">四元数</a>是一个代数概念，常用于描述<em class="mm">旋转</em>，广泛应用于3D建模和游戏中。从概念上讲，四元数可以被认为是复数体的延伸，有三个虚部，而不是一个。根据应用的不同，它们也可以理解为三维向量或四维对象或标量向量对的商。</p><figure class="my mz na nb gt iv gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/58fdad118f51f413111594b87f690447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*y3tItzD7QBwKj7lBqAZrlA.png"/></div></figure><p id="c990" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">好吧，但是我们怎么编码呢？</p><h1 id="e82a" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">实例化</h1><p id="a9ce" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">从编程的角度来看，我们不需要如此深入地关注数学。在这个阶段，我们只需要知道一个四元数是由<em class="mm">四个实数</em>定义的。</p><h2 id="08dd" class="nc kz ji bd la nd ne dn le nf ng dp li lz nh ni lk md nj nk lm mh nl nm lo nn bi translated">__init__</h2><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="db08" class="nc kz ji mq b gy ns nt l nu nv">class Quaternion:<br/>    def __init__(self, w, x, y, z):<br/>        self.w = w<br/>        self.x = x<br/>        self.y = y<br/>        self.z = z</span></pre><p id="5e3c" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">我们将我们的数学“存在”建模为一个对象，我们有了第一个邓德方法。这段代码所做的就是告诉Python:“看，当你创建一个新的类<em class="mm">四元数</em>的对象时，我需要你提供四个数字来实例化它。因为每个四元数都是不同的，所以将<code class="fe mn mo mp mq b">w</code>、<code class="fe mn mo mp mq b">x</code>、<code class="fe mn mo mp mq b">y</code>和<code class="fe mn mo mp mq b">z</code>定义为对象属性而不是类属性是有意义的。</p><h1 id="8032" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">表现</h1><p id="4bea" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们创建第一个四元数。</p><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="1ae8" class="nc kz ji mq b gy ns nt l nu nv">&gt;&gt;&gt; q1 = Quaternion(1, 2, 3, 4)<br/>&gt;&gt;&gt; q1<br/>&lt;__main__.Quaternion at 0x7f4210f483c8&gt;</span></pre><p id="0fc8" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated"><code class="fe mn mo mp mq b">&gt;&gt;&gt; q1 &lt;__main__.Quaternion at 0x7f4210f483c8&gt;</code></p><p id="c506" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">我们的四元数是一个对象，但它看起来很丑。默认情况下，我们看到的是该对象在内存中的地址，但是这个描述没有告诉我们任何我们感兴趣的属性。</p><h2 id="fb9d" class="nc kz ji bd la nd ne dn le nf ng dp li lz nh ni lk md nj nk lm mh nl nm lo nn bi translated">__repr__，__str__</h2><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="c50a" class="nc kz ji mq b gy ns nt l nu nv">def __repr__(self):<br/>    return "Quaternion({}, {}, {}, {})".format(<br/>        self.w, self.x, self.y, self.z)<br/><br/>def __str__(self):<br/>    return "Q = {:.2f} + {:.2f}i + {:.2f}j + {:.2f}k".format(<br/>        self.w, self.x, self.y, self.z)</span></pre><p id="b557" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">这里，我们又定义了两个方法。这个<code class="fe mn mo mp mq b">__repr__</code>方法是对象的一个“官方”表示，这里用这个质量表示<code class="fe mn mo mp mq b">eval(repr(obj)) == obj</code>。</p><p id="47bf" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">很好。<code class="fe mn mo mp mq b">__repr__</code>方法返回一个足够描述性的字符串。然而，我们可以通过<code class="fe mn mo mp mq b">__str__</code>进一步提高我们的代表性。输出如下所示:</p><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="6cb9" class="nc kz ji mq b gy ns nt l nu nv">&gt;&gt;&gt; q1            # calls q1.__repr__<br/>Quaternion(1, 2, 3, 4)</span><span id="d328" class="nc kz ji mq b gy nw nt l nu nv">&gt;&gt;&gt; print(q1)     # calls q1.__str__<br/>Q = 1.00 + 2.00i + 3.00j + 4.00k</span></pre><h1 id="5bf1" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">执行代数运算</h1><p id="a696" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这一点上，你可能想知道为什么不使用<em class="mm">列表</em>或<em class="mm">字典</em>？这当然是更少的代码，我们可以很容易地看到元素。</p><p id="116f" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">嗯，我们确实需要比“一袋数字”更多的东西。有两个主要的反对理由:</p><ol class=""><li id="5c0f" class="nx ny ji ls b lt mr lw ms lz nz md oa mh ob ml oc od oe of bi translated">我们不想<strong class="ls jj">依赖惯例</strong>。<code class="fe mn mo mp mq b">w</code>是不是总要被命名为“w”并作为第一个自变量？万一有人弄坏了呢？</li><li id="f851" class="nx ny ji ls b lt og lw oh lz oi md oj mh ok ml oc od oe of bi translated">我们定义这个对象来<strong class="ls jj">反映它被设计来表示的数学属性。</strong></li></ol><p id="c5b0" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">很艰难，对吧？除了1。，四元数是<em class="mm">加法</em>。试着把字典或者列表加在一起…会产生<code class="fe mn mo mp mq b">TypeError</code>，而另一个会扩展元素的数量，从而打破我们的定义。还有一个办法。</p><h1 id="9871" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">添加</h1><h2 id="b18e" class="nc kz ji bd la nd ne dn le nf ng dp li lz nh ni lk md nj nk lm mh nl nm lo nn bi translated">__添加_ _</h2><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="f89e" class="nc kz ji mq b gy ns nt l nu nv">def __add__(self, other):<br/>    w = self.w + other.w<br/>    x = self.x + other.x<br/>    y = self.y + other.y<br/>    z = self.z + other.z<br/>    return Quaternion(w, x, y, z)</span></pre><p id="f22e" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">我们找到了。我们刚刚覆盖了<code class="fe mn mo mp mq b">+</code>操作符，定义了四元数的加法。</p><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="c573" class="nc kz ji mq b gy ns nt l nu nv">&gt;&gt;&gt; q1 = Quaternion(1, 2, 3, 4)<br/>&gt;&gt;&gt; q2 = Quaternion(0, 1, 3, 5)<br/>&gt;&gt;&gt; q1 + q2<br/>Quaternion(1, 3, 6, 9)</span></pre><h1 id="4fef" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">减法</h1><h2 id="06ac" class="nc kz ji bd la nd ne dn le nf ng dp li lz nh ni lk md nj nk lm mh nl nm lo nn bi translated">__sub__</h2><p id="ac92" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">同样，我们也可以做减法。这一次我们将用一行代码来完成它。</p><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="89bc" class="nc kz ji mq b gy ns nt l nu nv">def __sub__(self, other):<br/>    return Quaternion(*list(map(lambda i, j: i - j,<br/>        self.__dict__.values(), other.__dict__.values())))</span></pre><p id="2cf7" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">虽然这是不必要的，但它也展示了另一个方便的dunder方法。<code class="fe mn mo mp mq b">__dict__</code>方法收集一个对象的所有属性，并将它们作为一个字典返回。</p><h1 id="fb0d" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">增加</h1><p id="158d" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果你还觉得操作的overriding很无聊，现在是时候找乐子了。</p><h2 id="2dcb" class="nc kz ji bd la nd ne dn le nf ng dp li lz nh ni lk md nj nk lm mh nl nm lo nn bi translated">__matmul__</h2><p id="a00d" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">最简单的是<em class="mm">点积</em>。用<code class="fe mn mo mp mq b">@</code>表示，从Python 3.5开始，它调用<code class="fe mn mo mp mq b">__matmul__</code>方法，对于四元数，它被定义为简单的元素级乘法。</p><p id="d2eb" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">尽管“普通”乘法更难。首先，代数区分了四元数乘以四元数乘法。其次，乘法是<strong class="ls jj">不可换的</strong>，意思是说<code class="fe mn mo mp mq b">q1 * q2 != q2 * q1</code>。</p><h2 id="6928" class="nc kz ji bd la nd ne dn le nf ng dp li lz nh ni lk md nj nk lm mh nl nm lo nn bi translated">__mul__</h2><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="5cb4" class="nc kz ji mq b gy ns nt l nu nv">def __mul__(self, other):<br/>    if isinstance(other, Quaternion):<br/>        w = self.w * other.w - self.x * other.x \<br/>          - self.y * other.y - self.z * other.z<br/>        x = self.w * other.x + self.x * other.w \<br/>          + self.y * other.z - self.z * other.y<br/>        y = self.w * other.y + self.y * other.w \<br/>          + self.z * other.x - self.x * other.z<br/>        z = self.w * other.z + self.z * other.w \<br/>          + self.x * other.y - self.y * other.x<br/>        return Quaternion(w, x, y, z)<br/>    elif isinstance(other, (int, float)):<br/>        return Quaternion(*[other*i for i inself.__dict__.values()])<br/>    else:<br/>        raise TypeError("Operation undefined.")</span></pre><p id="5633" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">这里，如果<code class="fe mn mo mp mq b">other</code>是一个四元数，我们计算所谓的哈密尔顿积，返回一个新的对象。如果<code class="fe mn mo mp mq b">other</code>是一个标量(一个数字)，我们用这个数字乘以四元数的每个坐标。最后，任何其他东西都会引发异常。</p><p id="fa5e" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">如前所述，四元数的乘法是不可交换的。然而，这只是在四元数相乘的时候。根据目前的定义，如果我们执行<code class="fe mn mo mp mq b">2 * q1</code>，我们将得到一个错误。要解决这个问题，我们可以使用<code class="fe mn mo mp mq b">__rmul__</code>，它涵盖了我们的案例:</p><h2 id="f6c8" class="nc kz ji bd la nd ne dn le nf ng dp li lz nh ni lk md nj nk lm mh nl nm lo nn bi translated">__rmul__</h2><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="3ef1" class="nc kz ji mq b gy ns nt l nu nv">def __rmul__(self, other):<br/>    if isinstance(other, (int, float)):<br/>        return self.__mul__(other)<br/>    else:<br/>        raise TypeError("Operation undefined.")</span></pre><p id="c04a" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">现在，我们可以将一个四元数乘以两边的标量，而四元数<em class="mm">可以按照严格定义的顺序乘以另一个四元数</em>。</p><h1 id="0f41" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">平等</h1><p id="4ee0" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将跳过<em class="mm">部分</em>，因为它遵循相同的模式。取而代之的是另一个好奇心:平等。</p><p id="433e" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">两个四元数其实相等是什么意思？是当所有成分成对相等时，还是当两个物体代表相同的真理时？</p><p id="2739" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">我们可以使用这些定义中的任何一个……然而，我们<strong class="ls jj">问自己这个问题的事实证明了重写一个方法是正确的。</strong></p><h2 id="bd39" class="nc kz ji bd la nd ne dn le nf ng dp li lz nh ni lk md nj nk lm mh nl nm lo nn bi translated">__eq__</h2><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="6af1" class="nc kz ji mq b gy ns nt l nu nv">def __eq__(self, other):<br/>    r = list(map(lambda i, j: abs(i) == abs(j), <br/>        self.__dict__.values(), other.__dict__.values()))<br/>    return sum(r) == len(r)</span></pre><p id="845f" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">这里我们将<code class="fe mn mo mp mq b">==</code>定义为所有坐标的绝对值必须匹配的情况。</p><h1 id="5084" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">其他操作</h1><p id="464f" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Python定义了一个可以被覆盖的操作符列表。然而，并不是每一个数学运算都在邓德方法中得到体现。在这些情况下，最好坚持“正常”的方法，因为其他符号的使用会违反直觉。</p><p id="a066" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">例如:</p><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="da90" class="nc kz ji mq b gy ns nt l nu nv">from math import sqrt<br/><br/><br/>def norm(self):<br/>    return sqrt(sum([i**2 for i in self.__dict__.values()))<br/><br/>def conjugate(self):<br/>    x, y, z = -self.x, -self.y, -self.z<br/>    return Quaterion(self.w, x, y, z)<br/><br/>def normalize(self):<br/>    norm = self.norm()<br/>    return Quaternion(*[i / norm for in self.__dict__.values()])<br/><br/>def inverse(self):<br/>    qconj = self.conjugate()<br/>    norm  = self.norm()<br/>    return Quaternion(*[i / norm for i in qconj.__dict__.values()])</span></pre><h1 id="badd" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">覆盖还是重载？</h1><p id="a10b" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这篇文章中，我们小心翼翼地注意我们的语言。我们“改写”了一些邓德方法，理由很充分。然而，我们没有对操作符执行任何<em class="mm">重载</em>。严格意义上的运算符重载在Python中是不存在的。一个方法只能有一个接口，尽管Python允许可变数量的参数。</p><p id="296d" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">你还记得我们如何实例化我们的对象吗？我们使用四个数字<code class="fe mn mo mp mq b">w</code>、<code class="fe mn mo mp mq b">x</code>、<code class="fe mn mo mp mq b">y</code>和<code class="fe mn mo mp mq b">z</code>作为参数。然而，在处理四元数时，通常从<em class="mm">偏航、俯仰</em>和<em class="mm">滚转</em>T21角度导出四元数，这些角度与<a class="ae mw" href="https://en.wikipedia.org/wiki/Euler_angles" rel="noopener ugc nofollow" target="_blank">欧拉角</a>密切相关。</p><p id="a314" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">问题来了，我们如何通过编程来实现它们？我们扩展我们的<code class="fe mn mo mp mq b">__init__</code>方法的接口来接受七个数字吗？是不是最好让其中一些可选？如果是，那么我们如何保证对象的完整性呢？就代码质量而言，我们需要付出什么代价？</p><p id="aff2" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">说到四元数，我们确实有机会实现一些<em class="mm">接近重载</em>的东西，让我们的代码更加整洁。</p><h1 id="12ca" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">Pythonic式的“重载”</h1><p id="72a2" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">因为所有的操作，正如我们看到的，都涉及到<code class="fe mn mo mp mq b">w, z, y, z</code>变量，所以在我们的类中添加更多的属性是没有意义的。然而，我们必须做的是选择<em class="mm">绕过</em>构造函数的接口，用<code class="fe mn mo mp mq b">yaw</code>、<code class="fe mn mo mp mq b">pitch</code>和<code class="fe mn mo mp mq b">roll</code>将它们转换成<code class="fe mn mo mp mq b">(w, x, y, z)</code>并实例化一个新的对象。</p><p id="dd26" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">首先，让我们创建重新计算方法:</p><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="4ec1" class="nc kz ji mq b gy ns nt l nu nv">from math import sin, cos<br/><br/><br/>def _ypr_to_coords(yaw, pitch, roll):<br/>    y = 0.5 * yaw<br/>    p = 0.5 * pitch<br/>    r = 0.5 * roll<br/>    <br/>    w = cos(y) * cos(p) * cos(r) + sin(y) * sin(p) * sin(r)<br/>    x = cos(y) * cos(p) * sin(r) - sin(y) * sin(p) * cos(r)<br/>    y = sin(y) * cos(p) * sin(r) + cos(y) * sin(p) * cos(r)<br/>    z = sin(y) * cos(p) * cos(r) - cos(y) * sin(p) * sin(r)<br/>    return w, z, y, z</span></pre><p id="926c" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">该方法是<em class="mm">受保护的</em>，因为它是类的“内部”方法。它也不对对象执行任何操作。它只重新计算角度，返回坐标。</p><p id="8e72" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">接下来，我们将它作为第二张脸的一部分。</p><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="bb23" class="nc kz ji mq b gy ns nt l nu nv">class Quaternion:<br/>    def __init__(self, w, x, y, z):<br/>        self.w = w<br/>        self.x = x<br/>        self.y = y<br/>        self.z = z<br/><br/>    @classmethod<br/>    def create_from_ypr(cls, yaw, pitch, roll):<br/>        r = cls._ypr_to_coords(yaw, pitch, roll)<br/>        return cls(*r)</span></pre><p id="977a" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">在不影响<code class="fe mn mo mp mq b">__init__</code>或属性的情况下，我们现在有了另一种方法来实例化我们的四元数。使用<code class="fe mn mo mp mq b">@classmethod</code> decorator，我们将<code class="fe mn mo mp mq b">create_from_ypr(...)</code>方法指定为类方法，而不是对象方法。当在一个类上调用时，它重新计算我们的坐标并返回类本身(通过以前的<code class="fe mn mo mp mq b">__init__</code>),输入必要的参数。</p><p id="5f2d" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">这个技巧允许我们忠于我们的定义，但是增加了更多的灵活性。我们甚至可以用这种方法来定义特殊种类的对象:</p><pre class="my mz na nb gt no mq np nq aw nr bi"><span id="538b" class="nc kz ji mq b gy ns nt l nu nv">class Quaternion:<br/>    ...<br/><br/>    @classmethod<br/>    def create_identity(cls):<br/>        return cls(1, 0, 0, 0)</span><span id="c456" class="nc kz ji mq b gy nw nt l nu nv">&gt;&gt;&gt; q0 = Quaternion.create_identity()<br/>&gt;&gt;&gt; print(q0)<br/>Q = 1.00 + 0.00i + 0.00j + 0.00k</span></pre><h1 id="6cfe" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">结论</h1><p id="c8d7" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这篇文章中，我们介绍了一种使用Python的一些特殊特性的模式，称为dunder方法。我们已经给出了如何利用这些方法来建模抽象代数对象(即四元数)的例子。我们还清楚地区分了<em class="mm">重写</em>和<em class="mm">重载</em>，并展示了如何实现后者来帮助我们处理对象。</p><p id="7b95" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">想看更多方法，看一看这个<a class="ae mw" href="https://gist.github.com/OlegZero13/8e2ca12e67ffd9b4bf020cc1a9b4f215#file-quaternion-py" rel="noopener ugc nofollow" target="_blank">要诀</a>。如果有什么需要改进的地方，请在下面的评论中反馈！谢谢；)</p><h1 id="48e0" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">还会有更多…</h1><p id="f1b4" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我计划把文章带到下一个层次，并提供简短的视频教程。</p><p id="b613" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">如果您想了解关于视频和未来文章的更新，<strong class="ls jj">订阅我的</strong> <a class="ae mw" href="https://landing.mailerlite.com/webforms/landing/j5y2q1" rel="noopener ugc nofollow" target="_blank"> <strong class="ls jj">简讯</strong> </a> <strong class="ls jj">。你也可以通过填写<a class="ae mw" href="https://forms.gle/bNpf9aqZJGLgaU589" rel="noopener ugc nofollow" target="_blank">表格</a>让我知道你的期望。回头见！</strong></p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="fcfb" class="pw-post-body-paragraph lq lr ji ls b lt mr kj lv lw ms km ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated"><em class="mm">原载于</em><a class="ae mw" href="https://zerowithdot.com/dunder_methods_and_quaternions/" rel="noopener ugc nofollow" target="_blank"><em class="mm">https://zerowithdot.com</em></a><em class="mm">。</em></p></div></div>    
</body>
</html>