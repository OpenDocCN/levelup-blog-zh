<html>
<head>
<title>What Principles Senior Developers Use For Resilient Software?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级开发人员对弹性软件使用什么原则？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-object-oriented-tips-sandi-metz-uses-for-better-software-design-1c5393c7698d?source=collection_archive---------14-----------------------#2021-03-15">https://levelup.gitconnected.com/3-object-oriented-tips-sandi-metz-uses-for-better-software-design-1c5393c7698d?source=collection_archive---------14-----------------------#2021-03-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="b5b4" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">Sandi Metz关于面向对象设计的三大开发经验</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/fc1eda389bebffb6deadd3bf9e770ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fBkxL1a-QqmTiQbR"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.pexels.com/@divinetechygirl?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜·莫里洛</a>从<a class="ae kz" href="https://www.pexels.com/photo/group-of-women-sitting-on-chairs-1181625/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</figcaption></figure><p id="1f13" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你需要添加另一个条件。有很多条件的复杂代码。你再加一个假设，然后继续前进。但是问题依然存在。</p><p id="3321" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那是怎么发生的？最后是怎么得到这么复杂的代码的？</p><p id="db34" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我知道简单的解决方法。我选择容易的道路。过了一会儿，我看到了一个更简单的解决方案，但是代码已经投入生产。没有人，但是没有人接触生产代码。</p><p id="fa3c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你如何防止这种情况？桑迪梅茨有我们应该遵循的伟大原则。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f6cc" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">避免简单—变得简单</h1><p id="befa" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">争取松散耦合的代码。<code class="fe na nb nc nd b">Product</code>不应该知道<code class="fe na nb nc nd b">Price</code>的存在。尽可能减少类依赖。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="8640" class="ni me iu nd b gz nj nk l nl nm">class Product {<br/>...<br/> Product() {</span><span id="03ea" class="ni me iu nd b gz nn nk l nl nm">  ... new Price(20.0d).getPrice() ...</span><span id="acda" class="ni me iu nd b gz nn nk l nl nm"> }<br/>...<br/>}</span></pre><p id="7f13" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">避免在对象内部实例化对象。增加依赖性、不必要的复杂性，并导致灵活性降低。</p><p id="3bb6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当<code class="fe na nb nc nd b">Price</code>发生变化的时候，<code class="fe na nb nc nd b">Product</code>也会发生变化。违反了面向对象编程的开放/封闭原则。违规导致代码发臭。</p><p id="5d2d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个实现中，你不能使用不同的<code class="fe na nb nc nd b">Price</code>类型。我们再加上<code class="fe na nb nc nd b">PromotionPrice</code>，或者<code class="fe na nb nc nd b">SeasonalPrice</code>。你知道必须改变<code class="fe na nb nc nd b">Product</code>类来适应新的价格类型。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="a3ed" class="ni me iu nd b gz nj nk l nl nm">class Product {<br/>...<br/> Product(Price price) {</span><span id="6c51" class="ni me iu nd b gz nn nk l nl nm">  ... price.getPrice() ...</span><span id="a305" class="ni me iu nd b gz nn nk l nl nm">}<br/>...<br/>}</span></pre><p id="40ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相反，将<code class="fe na nb nc nd b">Price</code>作为参数传递，然后使用它。这个类将为价格的子集工作，不需要任何改变。</p><p id="7f5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">添加一个新的<code class="fe na nb nc nd b">Price</code>子类将与该设计无缝配合。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="4d87" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">看看代码中的条件。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="e6d1" class="ni me iu nd b gz nj nk l nl nm">if(condition1)<br/>{ <br/> behaviorMethod1();<br/>}<br/>else { <br/> behaviorMethod2();<br/>}</span></pre><p id="97cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将方法移入类中。适当的时候注射。注入减少了执行，使代码可读，并且更容易测试。易于测试的代码也很容易被你理解。</p><blockquote class="no np nq"><p id="b0e2" class="la lb nr lc b ld le jv lf lg lh jy li ns lk ll lm nt lo lp lq nu ls lt lu lv in bi translated">简单是可靠的先决条件</p></blockquote></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="af5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">容易意味着近。避免轻易接近。喜欢简单的。</p><p id="6ed5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">容易是熟悉的。做熟悉的事情导致没有进步。</p><p id="eb58" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">容易也意味着近。接近我们的能力。作为程序员，我们不喜欢有些东西遥不可及。我们是聪明人。</p><p id="eb9b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">轻松是相对的。对我来说容易，对你来说不容易。比起简单的方法，更喜欢简单的方法。不要拿现有的代码，因为很容易。重构，让它更简单。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="3ef3" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">什么都不是</h1><p id="fb8d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">让我们看看下面的例子。你想得到一个数字账户名。如果数字帐户为空，则返回丢失的消息。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="0b14" class="ni me iu nd b gz nj nk l nl nm">DigitalAccount digitalAccount = fetchDigitalAccount(id);</span><span id="4a70" class="ni me iu nd b gz nn nk l nl nm">if(digitalAccount == null)<br/>{ <br/> return "Missing digital account"; <br/>}<br/>else { <br/> return digitalAccount.getName();<br/>}</span></pre><p id="1283" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">糟糕的解决方案。您应该探索多态解决方案。子类比条件更能揭示意图。</p><blockquote class="no np nq"><p id="813b" class="la lb nr lc b ld le jv lf lg lh jy li ns lk ll lm nt lo lp lq nu ls lt lu lv in bi translated">条件滋生。—桑迪·梅茨</p></blockquote><p id="9764" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">时间流逝，条件倍增。在前面的代码中添加一个额外的条件会增加难度。很难改变，因为它在你的代码库中成倍增加。</p><p id="4bab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Null是某种东西。有时候。有时候就是这样，没什么。</p><p id="c774" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以之前的代码为例。Null是某物，它是一个丢失的帐户。</p><p id="0be2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">丢失的帐户没有名称，因此行为可能会改变。做好准备。使用空对象模式。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="9548" class="ni me iu nd b gz nj nk l nl nm">class MissingAccount extends Account {<br/> @Override<br/> protected String getName() {<br/>  return "Missing account!";<br/> }<br/>}</span></pre><p id="469d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从帐户创建一个缺失的帐户子类。当获取名称时，返回丢失的帐户。</p><p id="993f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我有意延长了<code class="fe na nb nc nd b">Account</code>。DigitalAccount是一个子类，继承它会导致错误的继承。下一节将详细介绍错误的继承。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="37de" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">不要滥用继承</h1><p id="5e74" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">错误的继承无处不在。我做错了，你也做错了。让我们纠正这一点。</p><p id="8267" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">调查现有的继承。不要盲目地扩展类。看看超类，看看你继承了什么。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="acc0" class="ni me iu nd b gz nj nk l nl nm">// wrong inheritance<br/>class Product {</span><span id="2d6f" class="ni me iu nd b gz nn nk l nl nm"> // reasonable for all products<br/> getPrice() {...}</span><span id="4610" class="ni me iu nd b gz nn nk l nl nm"> // reasonable for tangible products<br/> getCostOfShipping() {...}<br/> getWeight() {...}</span><span id="8e85" class="ni me iu nd b gz nn nk l nl nm">}</span><span id="b01e" class="ni me iu nd b gz nn nk l nl nm">class DigitalProduct extends Product {<br/> // reasonable for all products<br/> getPrice() {...}</span><span id="b392" class="ni me iu nd b gz nn nk l nl nm"> // not reasonable for digital products<br/> getCostOfShipping() {...}<br/> getWeight() {...} <br/>}</span><span id="6f6c" class="ni me iu nd b gz nn nk l nl nm">class PhysicalProduct extends Product  { <br/> // all the inherited methods are reasonable<br/>}</span></pre><p id="caff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">子类在某些情况下，从超类中提取特定的行为。将通用逻辑提取到更通用的类中。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="3a9a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">超类应该是抽象的。不应该存在它的任何实例。多个子类应该实现超类。</p><p id="866e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">只有一个子类扩展超类是错的。根据定义，一个抽象类应该至少有两个子类。如果不是，就把所有东西放在一个类中。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="0b6a" class="ni me iu nd b gz nj nk l nl nm">// correct approach; right inheritance</span><span id="3ce2" class="ni me iu nd b gz nn nk l nl nm">abstract class Product {</span><span id="8d00" class="ni me iu nd b gz nn nk l nl nm"> // reasonable for all products<br/> getPrice() {...}</span><span id="beb6" class="ni me iu nd b gz nn nk l nl nm">}</span><span id="58e1" class="ni me iu nd b gz nn nk l nl nm">class ElectronicBook extends Product { <br/>}</span><span id="9b3b" class="ni me iu nd b gz nn nk l nl nm">class PrintedBook extends Product  { <br/> getCostOfShipping() {...}<br/> getWeight() {...}<br/>}</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="22de" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="a7c4" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">你应该从这篇文章中得到什么？</p><p id="b2ef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">学会简单。不要选择简单的解决方案。它们会适得其反。从长远来看，它们会适得其反。</p><p id="11c4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意null。Null可以是某些东西。有时候就是这样。空。</p><p id="4164" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不要滥用继承。了解关于超类的更多信息。如果需要，实现您自己的。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4bb0" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">资源</h1><p id="ef32" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated"><a class="ae kz" href="https://www.youtube.com/watch?v=OMPfEXIlTVE&amp;ab_channel=Confreaks" rel="noopener ugc nofollow" target="_blank">空是说话的东西</a></p><p id="27d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Ruby — Sandi Metz中实用的面向对象设计</p><h1 id="aae7" class="md me iu bd mf mg nv mi mj mk nw mm mn ka nx kb mp kd ny ke mr kg nz kh mt mu bi translated">继续阅读相关文章</h1><div class="oa ob gq gs oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/13-quotes-every-great-developer-should-know-70a972596a05"><div class="oe ab fp"><div class="of ab og cl cj oh"><h2 class="bd iv gz z fq oi fs ft oj fv fx it bi translated">每个伟大的开发人员都应该知道的13条名言</h2><div class="ok l"><h3 class="bd b gz z fq oi fs ft oj fv fx dk translated">你应该知道和思考的13条开发者名言</h3></div><div class="ol l"><p class="bd b dl z fq oi fs ft oj fv fx dk translated">levelup.gitconnected.com</p></div></div><div class="om l"><div class="on l oo op oq om or kt od"/></div></div></a></div><div class="oa ob gq gs oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/i-found-the-best-gilded-rose-kata-solution-a896ffd8f7ac"><div class="oe ab fp"><div class="of ab og cl cj oh"><h2 class="bd iv gz z fq oi fs ft oj fv fx it bi translated">我找到了最好的镀金玫瑰形解决方案</h2><div class="ok l"><h3 class="bd b gz z fq oi fs ft oj fv fx dk translated">通过桑迪梅斯解决镀金玫瑰形</h3></div><div class="ol l"><p class="bd b dl z fq oi fs ft oj fv fx dk translated">levelup.gitconnected.com</p></div></div><div class="om l"><div class="os l oo op oq om or kt od"/></div></div></a></div></div></div>    
</body>
</html>