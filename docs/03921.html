<html>
<head>
<title>How to Solve a Maze using BFS in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中使用BFS解决迷宫</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solve-a-maze-with-python-e9f0580979a1?source=collection_archive---------0-----------------------#2020-06-02">https://levelup.gitconnected.com/solve-a-maze-with-python-e9f0580979a1?source=collection_archive---------0-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dcd9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">广度优先搜索算法</h2></div><p id="1c69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">《反恐精英》里机器人是怎么找到你的，《吃豆人》里怪物是怎么找到你的？</p><p id="5a2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将解释如何在迷宫中找到一条路。代码附有可视化算法的动画。</p><h2 id="439f" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">设置一个迷宫</h2><p id="62b9" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们的迷宫将是一个矩阵，0代表空间，1代表墙壁。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3a73" class="le lf it mf b gy mo mp l mq mr">a = [<br/>    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],<br/>    [1, 0, 1, 0, 1, 0, 0, 0, 0, 1],<br/>    [1, 0, 1, 0, 1, 0, 0, 0, 0, 1],<br/>    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1],<br/>    [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],<br/>    [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],<br/>    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],<br/>    [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],<br/>    [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],<br/>    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],<br/>]</span></pre><p id="62d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还设置了起点和终点:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="c25b" class="le lf it mf b gy mo mp l mq mr">start = 1, 1<br/>end = 2, 5</span></pre><p id="47d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，我们有一个如图所示的迷宫:</p><figure class="mg mh mi mj gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/85d1f1007784ba6db3f41e01f0cda399.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*MUj3K93fEUSEA5VMbGuXKQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">迷宫的起点和终点</figcaption></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="155d" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">该算法</h2><p id="efeb" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">解决这个迷宫的算法如下:</p><ul class=""><li id="2325" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated">我们创建一个具有相同大小的零的矩阵</li><li id="fe83" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">把一个<code class="fe mc md me mf b">1</code>放到起点</li><li id="487b" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">在<code class="fe mc md me mf b">1</code>周围到处都是我们放的<code class="fe mc md me mf b">2</code>，如果没有墙的话</li><li id="164d" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">在<code class="fe mc md me mf b">2</code>周围的每个地方，如果没有墙，我们就放<code class="fe mc md me mf b">3</code></li><li id="0030" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">诸如此类…</li><li id="acfa" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">一旦我们在终点输入一个数字，我们就停下来。这个数字实际上是最小路径长度</li></ul></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="42c0" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">创建矩阵</h2><p id="7c9c" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">这既简单又直接。也许有功能，像<code class="fe mc md me mf b">zeros</code>之类的，但我只知道NumPy有一个。因此，我们手动创建一个矩阵并设置起点:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="cad9" class="le lf it mf b gy mo mp l mq mr">m = []<br/><strong class="mf iu">for </strong>i <strong class="mf iu">in </strong>range(len(a)):<br/>    m.append([])<br/>    <strong class="mf iu">for </strong>j <strong class="mf iu">in </strong>range(len(a[i])):<br/>        m[-1].append(0)<br/>i,j = start<br/>m[i][j] = 1</span></pre><p id="b0a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了这个矩阵:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="b625" class="le lf it mf b gy mo mp l mq mr">0  0  0  0  0  0  0  0  0  0  <br/>0 <strong class="mf iu"> 1</strong>  0  0  0  0  0  0  0  0  <br/>0  0  0  0  0  0  0  0  0  0  <br/>0  0  0  0  0  0  0  0  0  0  <br/>0  0  0  0  0  0  0  0  0  0  <br/>0  0  0  0  0  0  0  0  0  0  <br/>0  0  0  0  0  0  0  0  0  0  <br/>0  0  0  0  0  0  0  0  0  0  <br/>0  0  0  0  0  0  0  0  0  0  <br/>0  0  0  0  0  0  0  0  0  0</span></pre></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="151f" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">迈步</h2><p id="8eb2" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在我们只为一个步骤创建一个函数:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="f3e0" class="le lf it mf b gy mo mp l mq mr"><strong class="mf iu">def </strong>make_step(k):<br/>  <strong class="mf iu">for </strong>i <strong class="mf iu">in </strong>range(len(m)):<br/>    <strong class="mf iu">for </strong>j <strong class="mf iu">in </strong>range(len(m[i])):<br/>      <strong class="mf iu">if </strong>m[i][j] == k:<br/>        <strong class="mf iu">if </strong>i&gt;0 <strong class="mf iu">and </strong>m[i-1][j] == 0 <strong class="mf iu">and </strong>a[i-1][j] == 0:<br/>          m[i-1][j] = k + 1<br/>        <strong class="mf iu">if </strong>j&gt;0 <strong class="mf iu">and </strong>m[i][j-1] == 0 <strong class="mf iu">and </strong>a[i][j-1] == 0:<br/>          m[i][j-1] = k + 1<br/>        <strong class="mf iu">if </strong>i&lt;len(m)-1 <strong class="mf iu">and </strong>m[i+1][j] == 0 <strong class="mf iu">and </strong>a[i+1][j] == 0:<br/>          m[i+1][j] = k + 1<br/>        <strong class="mf iu">if </strong>j&lt;len(m[i])-1 <strong class="mf iu">and </strong>m[i][j+1] == 0 <strong class="mf iu">and </strong>a[i][j+1] == 0:<br/>           m[i][j+1] = k + 1</span></pre><p id="f077" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数将步骤号<code class="fe mc md me mf b">k</code>作为参数。它的功能非常简单:</p><ul class=""><li id="e6a4" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated">用双for循环扫描矩阵。</li><li id="6d09" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">如果我们找到与步骤号<code class="fe mc md me mf b">k</code>对应的数字，查看周围的单元格，并检查是否:<br/> 1。还没有号码<br/> 2。没有墙<br/>并将<code class="fe mc md me mf b">k+1</code>设置到该单元格。</li></ul><p id="d32b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，如果我们运行这个函数8次:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3a31" class="le lf it mf b gy mo mp l mq mr">make_step(1)<br/>make_step(2)<br/>make_step(3)<br/>make_step(4)<br/>make_step(5)<br/>make_step(6)<br/>make_step(7)<br/>make_step(8)</span></pre><p id="a2d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将得到下面的矩阵:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="7ff1" class="le lf it mf b gy mo mp l mq mr">0  0  0  0  0  0  0  0  0  0  <br/>0  1  0  0  0  0  0  0  0  0  <br/>0  2  0  0  0  0  0  0  0  0  <br/>0  3  0  0  0  0  0  0  0  0  <br/>0  4  0  0  0  0  0  0  0  0  <br/>0  5  0  9  0  0  0  0  0  0  <br/>0  6  7  8  9  0  0  0  0  0  <br/>0  7  0  9  0  0  0  0  0  0  <br/>0  8  0  0  0  0  0  0  0  0  <br/>0  0  0  0  0  0  0  0  0  0</span></pre><p id="9586" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与这张图片相对应:</p><figure class="mg mh mi mj gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/4bb97c15d2925e4d9c5f65cf4067b755.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*2Z6nWVX_orML5wNUvuhO2Q.gif"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">前8步</figcaption></figure><p id="a06f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们继续这样做，直到我们的终点被填满:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="4871" class="le lf it mf b gy mo mp l mq mr">k = 0<br/><strong class="mf iu">while </strong>m[end[0]][end[1]] == 0:<br/>    k += 1<br/>    make_step(k)</span></pre><p id="f878" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在得到了这个矩阵:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d8b5" class="le lf it mf b gy mo mp l mq mr">0  0  0  0  0  0  0  0  0  0  <br/>0  1  0  13 0  0  22 21 20 0  <br/>0  2  0  12 0  22 21 20 19 0  <br/>0  3  0  11 0  0  0  0  18 0  <br/>0  4  0  10 11 12 13 0  17 0  <br/>0  5  0  9  10 11 12 0  16 0  <br/>0  6  7  8  9  10 11 0  15 0  <br/>0  7  0  9  10 11 12 13 14 0  <br/>0  8  0  10 11 12 13 14 15 0  <br/>0  0  0  0  0  0  0  0  0  0</span></pre><p id="c20d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这张图片是:</p><figure class="mg mh mi mj gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/81628049452e4eeac2fc295dcb9ac9e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*uc1ohrEekc9JKa2ThbYo4w.gif"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">找到重点</figcaption></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="7631" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">路径是什么？</h2><p id="6c4a" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在我们需要根据这个矩阵找到最短路径。</p><p id="5d4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是按如下方式完成的:</p><ul class=""><li id="9fb5" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated">转到终点，比如说，那里的数字是<code class="fe mc md me mf b">k</code></li><li id="2934" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">找到一个值为<code class="fe mc md me mf b">k-1</code>的相邻单元，到那里，将<code class="fe mc md me mf b">k</code>减1</li><li id="dffc" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">重复上一步，直到到达起点，即<code class="fe mc md me mf b">k=1</code></li></ul><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="c0bc" class="le lf it mf b gy mo mp l mq mr">i, j = end<br/>k = m[i][j]<br/>the_path = [(i,j)]<br/><strong class="mf iu">while </strong>k &gt; 1:<br/>  <strong class="mf iu">if </strong>i &gt; 0 <strong class="mf iu">and </strong>m[i - 1][j] == k-1:<br/>    i, j = i-1, j<br/>    the_path.append((i, j))<br/>    k-=1<br/>  <strong class="mf iu">elif </strong>j &gt; 0 <strong class="mf iu">and </strong>m[i][j - 1] == k-1:<br/>    i, j = i, j-1<br/>    the_path.append((i, j))<br/>    k-=1<br/>  <strong class="mf iu">elif </strong>i &lt; len(m) - 1 <strong class="mf iu">and </strong>m[i + 1][j] == k-1:<br/>    i, j = i+1, j<br/>    the_path.append((i, j))<br/>    k-=1<br/>  <strong class="mf iu">elif </strong>j &lt; len(m[i]) - 1 <strong class="mf iu">and </strong>m[i][j + 1] == k-1:<br/>    i, j = i, j+1<br/>    the_path.append((i, j))<br/>    k -= 1</span></pre><p id="cb3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们的路径包含坐标:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="d169" class="le lf it mf b gy mo mp l mq mr">[(2, 5), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8), (6, 8), (7, 8), (7, 7), (7, 6), (6, 6), (6, 5), (6, 4), (6, 3), (6, 2), (6, 1), (5, 1), (4, 1), (3, 1), (2, 1), (1, 1)]</span></pre><p id="b806" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是它的样子:</p><figure class="mg mh mi mj gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/c93d058f13b06c2dd3f55494ec8390bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*WDjapA_S9118FXh33hwl7w.gif"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">结果呢</figcaption></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="9009" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">更长的迷宫</h2><p id="bbd1" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在让我们在其他迷宫中尝试这个算法。</p><p id="cd12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们稍微改变一个迷宫:</p><figure class="mg mh mi mj gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b3e1cec861aa20bcfe85e93d964e0f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*lTkuAIJsS1uWaJlheRkIrA.gif"/></div></figure><p id="c787" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后让它变长:</p><figure class="mg mh mi mj gt mt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/131a0e3cf51a2fa6c1c32e5507e56db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*6zpQUTfi4lvItYQIfD2o-A.gif"/></div></figure><p id="0017" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢它！</p><p id="6d46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想像上面的图片一样可视化，安装<code class="fe mc md me mf b">Pillow</code>库并继续:</p><figure class="mg mh mi mj gt mt"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="16c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不打算分享完整的代码，所以它很脏。我们的想法是将算法可视化，而不是展示如何去做:)</p><p id="0fe7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢这篇文章，也看看这个:</p><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/an-animated-guide-to-implementing-dfs-in-python-to-find-a-path-1e939b7b8599"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">Python中深度优先搜索路径的动画指南</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">深度优先搜索教程。递归算法介绍。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op mu ob"/></div></div></a></div></div></div>    
</body>
</html>