<html>
<head>
<title>JavaScript Clean Code — More About Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码——关于类的更多信息</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-more-about-classes-7553ae9db3f2?source=collection_archive---------12-----------------------#2020-03-13">https://levelup.gitconnected.com/javascript-clean-code-more-about-classes-7553ae9db3f2?source=collection_archive---------12-----------------------#2020-03-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/476240751d17e3e79f66583014fbc8b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qLN1qf3opzB9zamm"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Jonas Svidras 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6edd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的类是语言原型继承特性之上的语法糖。然而，就编写干净的代码而言，这些原则仍然适用，因为它们与基于类的语言中的类具有相同的结构。</p><p id="a553" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何以一种简洁且可维护的方式编写JavaScript类。</p><p id="dfb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将看看如何组织变化和使用类语法，而不是使用构造函数。</p><h1 id="63dd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">组织变革</h1><p id="098d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们在组织课程时，必须为课程的变更做好准备。这意味着我们应该使它们可扩展，而不是不断修改代码来获得我们想要的功能。</p><p id="c6c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的方法应该简单。简单的方法更容易测试，我们不必对它们做太多的修改。</p><p id="9eb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该遵循开放/封闭原则，即一段代码应该对扩展开放，但对修改关闭。</p><p id="9653" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这适用于类，就像另一段代码一样。</p><p id="1b27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有下面的<code class="fe mh mi mj mk b">Rectangle</code>类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4ebd" class="mt lf it mk b gy mu mv l mw mx">class Rectangle {<br/>  constructor(length, width) {<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="14df" class="mt lf it mk b gy my mv l mw mx">  get area() {<br/>    return this.length * this.width;<br/>  }<br/>}</span></pre><p id="67d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以很容易地添加一个getter方法来计算矩形的周长，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2656" class="mt lf it mk b gy mu mv l mw mx">class Rectangle {<br/>  constructor(length, width) {<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="1e89" class="mt lf it mk b gy my mv l mw mx">  get area() {<br/>    return this.length * this.width;<br/>  }</span><span id="b072" class="mt lf it mk b gy my mv l mw mx">  get perimeter() {<br/>    return 2 * (this.length + this.width);<br/>  }<br/>}</span></pre><p id="0dc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如我们所见，我们不必修改现有代码来添加计算周长的方法。我们只需添加<code class="fe mh mi mj mk b">perimeter</code> getter方法就可以了。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/b5fe8bf70665a020bc96607889259032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mY1i7kKZm7SlXsAo"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yancy Min </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="3c91" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用类语法而不是构造函数</h1><p id="3a39" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">是时候转到类语法而不是使用构造函数了。</p><p id="99ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用下面的继承例子来看为什么:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b22b" class="mt lf it mk b gy mu mv l mw mx">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>}</span><span id="cd5e" class="mt lf it mk b gy my mv l mw mx">function Employee(name, age, employeeCode) {<br/>  Person.call(this, name, age);<br/>  Employee.prototype.constructor = Person;<br/>  this.employeeCode = employeeCode;<br/>}</span></pre><p id="608d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们必须创建<code class="fe mh mi mj mk b">Person</code>构造函数，然后制作<code class="fe mh mi mj mk b">Employee</code>的原型<code class="fe mh mi mj mk b">Person</code>并设置所有继承的属性，我们必须首先编写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2e8e" class="mt lf it mk b gy mu mv l mw mx">Person.call(this, name, age);</span></pre><p id="c20c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设置所有实例变量，并且:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e0fb" class="mt lf it mk b gy mu mv l mw mx">Employee.prototype.constructor = Person;</span></pre><p id="a405" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<code class="fe mh mi mj mk b">Employee</code>的原型构造器设置为<code class="fe mh mi mj mk b">Person</code>。我们很容易漏掉这两行中的任何一行，并且<code class="fe mh mi mj mk b">Employee</code>构造函数不会继承<code class="fe mh mi mj mk b">Person</code>构造函数。</p><p id="db9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们如下创建一个<code class="fe mh mi mj mk b">Employee</code>实例:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ade5" class="mt lf it mk b gy mu mv l mw mx">const employee = new Employee('Joe', 20, 'waiter');</span></pre><p id="e11a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们应该在<code class="fe mh mi mj mk b">__proto__</code>属性下看到类似下面的内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f725" class="mt lf it mk b gy mu mv l mw mx">constructor: <em class="na">ƒ Person(name, age)</em></span></pre><p id="8d4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们正确地将<code class="fe mh mi mj mk b">Employee</code>实例的原型设置为<code class="fe mh mi mj mk b">Person</code>构造函数。</p><p id="19c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了类语法，我们只需要使用<code class="fe mh mi mj mk b">extends</code>关键字来继承一个类。我们可以将上面的代码重写如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c68c" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>}</span><span id="dff2" class="mt lf it mk b gy my mv l mw mx">class Employee extends Person{<br/>  constructor(name, age, employeeCode) {<br/>    super(name, age);<br/>    this.employeeCode = employeeCode;<br/>  }<br/>}</span></pre><p id="d7a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么当我们创建如下相同的<code class="fe mh mi mj mk b">Employee</code>实例时:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1325" class="mt lf it mk b gy mu mv l mw mx">const employee = new Employee('Joe', 20, 'waiter');</span></pre><p id="2d15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们应该在<code class="fe mh mi mj mk b">__proto__</code>属性下看到如下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9b9b" class="mt lf it mk b gy mu mv l mw mx">constructor: <em class="na">class Employee</em></span></pre><p id="3157" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，除了<code class="fe mh mi mj mk b">function</code>和<code class="fe mh mi mj mk b">class</code>的不同之外，两个<code class="fe mh mi mj mk b">console.log</code>输出是相同的，但是它们是相同的，因为类与构造函数是相同的。</p><p id="c4e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我们不必使用<code class="fe mh mi mj mk b">call</code>或<code class="fe mh mi mj mk b">this</code>，手动设置超类的变量。</p><p id="1c75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript解释器会告诉我们是否忘记调用<code class="fe mh mi mj mk b">super</code>或使用<code class="fe mh mi mj mk b">extends</code>关键字。</p><p id="59fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在没有回到旧的构造函数语法，因为它很不方便。</p><h1 id="2275" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="f68f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们设计班级时，我们应该为改变而组织。这意味着我们应该拥有对扩展开放但对修改关闭的代码。</p><p id="440a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这降低了弄乱现有代码的风险，这也是为什么允许我们通过添加新代码来不断进行更改的原因。</p><p id="692c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，是时候讨论创建构造函数的类语法了。用旧的构造函数很难继承，而类语法使一切变得容易得多。</p></div></div>    
</body>
</html>