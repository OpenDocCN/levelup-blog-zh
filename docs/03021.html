<html>
<head>
<title>Comparing and Sorting in Elm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Elm中的比较和排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/comparing-and-sorting-in-elm-ec7a432df2dc?source=collection_archive---------8-----------------------#2020-04-15">https://levelup.gitconnected.com/comparing-and-sorting-in-elm-ec7a432df2dc?source=collection_archive---------8-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fd7e006b622f97788f1e6834a1301c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkGxtLvydscwUZb6lJlW-A.png"/></div></div></figure><p id="2553" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇短文中，我们将看看如何在Elm中对值进行比较和排序，目标是使用多种标准对记录进行排序。它假设您熟悉Elm的语法，并且基于Elm版本<code class="fe kz la lb lc b">0.19.1</code>。它还会链接到一点Haskell，但是你不需要了解任何Haskell来理解这篇文章，所以可以随意忽略。</p><h1 id="bdef" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><code class="fe kz la lb lc b">comparable</code>约束型变量</h1><p id="7913" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">Elm中有几个<a class="ae mg" href="https://guide.elm-lang.org/types/reading_types.html#constrained-type-variables" rel="noopener ugc nofollow" target="_blank">约束类型变量</a>，而<code class="fe kz la lb lc b">comparable</code>就是其中之一。这意味着(在撰写本文时)一个名为<code class="fe kz la lb lc b">comparable</code>的类型变量只能用<code class="fe kz la lb lc b">Int</code>、<code class="fe kz la lb lc b">Float</code>、<code class="fe kz la lb lc b">Char</code>、<code class="fe kz la lb lc b">String</code>和<code class="fe kz la lb lc b">comparable</code>值的列表/元组来“填充”。当你第一次遇到约束类型变量的时候，你会感到有点困惑，因为没有什么可以真正地将它们与常规类型变量区分开来，你只需要知道它们的存在。关于这一点已经有很多讨论，如果你有兴趣深入一点，还有一个<a class="ae mg" href="https://github.com/elm/compiler/issues/1039" rel="noopener ugc nofollow" target="_blank">元问题</a>跟踪类型系统扩展。</p><p id="bee6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">遇到这种限制的一个常见地方是内置的<code class="fe kz la lb lc b">Set</code>和<code class="fe kz la lb lc b">Dict</code>类型。<code class="fe kz la lb lc b">Set</code>中的元素必须是<code class="fe kz la lb lc b">comparable</code>，而<code class="fe kz la lb lc b">Dict</code>中的键必须是<code class="fe kz la lb lc b">comparable</code>。编译器给出了一些关于如何处理这个问题的建议，还有一些自定义的<a class="ae mg" href="https://package.elm-lang.org" rel="noopener ugc nofollow" target="_blank"> Elm包</a>可以处理任何类型，各有利弊。</p><h1 id="aff4" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">排序列表</h1><p id="ca54" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated"><a class="ae mg" href="https://package.elm-lang.org/packages/elm/core/latest/List" rel="noopener ugc nofollow" target="_blank">列表模块</a>有三个<a class="ae mg" href="https://package.elm-lang.org/packages/elm/core/latest/List#sort" rel="noopener ugc nofollow" target="_blank">排序功能</a>:</p><ul class=""><li id="972c" class="mh mi it kd b ke kf ki kj km mj kq mk ku ml ky mm mn mo mp bi translated"><code class="fe kz la lb lc b">sort : List comparable -&gt; List comparable</code>如果列表中的所有元素都是上面提到的<code class="fe kz la lb lc b">comparable</code>类型之一，您可以使用这个非常方便的函数。</li><li id="8c59" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated"><code class="fe kz la lb lc b">sortBy : (a -&gt; comparable) -&gt; List a -&gt; List a</code>如果你能把一个列表的所有元素映射到上面提到的<code class="fe kz la lb lc b">comparable</code>类型之一，你应该使用这个函数。如果您想按记录字段<code class="fe kz la lb lc b">comparable</code>排序，这尤其方便</li><li id="15da" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated"><code class="fe kz la lb lc b">sortWith : (a -&gt; a -&gt; Order) -&gt; List a -&gt; List a</code>这是最灵活的，通过采用一个函数来完全控制排序，该函数接受两个任意类型的列表元素并返回一个<code class="fe kz la lb lc b">Order</code>。这是我们最终将使用的函数，使用多个标准对记录进行排序。</li></ul><p id="14c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mg" href="https://package.elm-lang.org/packages/elm/core/latest/Basics#Order" rel="noopener ugc nofollow" target="_blank"> Order </a>表示两个值的相对排序，如果你曾经在Haskell中遇到过<a class="ae mg" href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" rel="noopener ugc nofollow" target="_blank"> Ordering </a>，它的作用是一样的。与在一些传统/主流语言中使用整数相比，我个人更喜欢这种类型的明确性。要从两个<code class="fe kz la lb lc b">comparable</code>中得到一个<code class="fe kz la lb lc b">Order</code>，你可以调用<code class="fe kz la lb lc b"><a class="ae mg" href="https://package.elm-lang.org/packages/elm/core/latest/Basics#compare" rel="noopener ugc nofollow" target="_blank">Basics.compare</a></code> <a class="ae mg" href="https://package.elm-lang.org/packages/elm/core/latest/Basics#compare" rel="noopener ugc nofollow" target="_blank">函数</a></p><p id="1bab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mv">快速说明一下，对于感兴趣的人来说，</em> <code class="fe kz la lb lc b"><em class="mv">Order</em></code> <em class="mv"> / </em> <code class="fe kz la lb lc b"><em class="mv">Ordering</em></code> <em class="mv">是幺半群，</em> <code class="fe kz la lb lc b"><em class="mv">Eq</em></code> <em class="mv">是同一性的变体。这在按多个字段排序时非常方便，我们将在后面看到。</em></p><h1 id="7133" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">按多个字段对记录进行排序</h1><p id="ec48" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">要按多个字段对记录列表进行排序，我们将从一个虚构的记录声明开始:</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="970c" class="ne le it lc b gy nf ng l nh ni">import Date exposing (Date)<br/><br/>type alias Person =<br/>    { name : String<br/>    , dateOfBirth : Date<br/>    }</span></pre><p id="18af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">Date</code>类型来自于便捷的<code class="fe kz la lb lc b"><a class="ae mg" href="https://package.elm-lang.org/packages/justinmimbs/date/latest" rel="noopener ugc nofollow" target="_blank">justinmimbs/date</a></code> <a class="ae mg" href="https://package.elm-lang.org/packages/justinmimbs/date/latest" rel="noopener ugc nofollow" target="_blank">模块</a>，该模块也具有以下功能:</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="6a59" class="ne le it lc b gy nf ng l nh ni">compare : Date -&gt; Date -&gt; Order</span></pre><p id="aa90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，它的签名与第一个参数<code class="fe kz la lb lc b">List.sortWith</code>相匹配。要安装软件包，只需运行<code class="fe kz la lb lc b">elm install justinmimbs/date</code>。</p><p id="ff5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在比较和排序<code class="fe kz la lb lc b"><a class="ae mg" href="https://package.elm-lang.org/packages/NoRedInk/elm-compare/latest" rel="noopener ugc nofollow" target="_blank">NoRedInk/elm-compare</a></code>时，我们还将使用另一个非常方便的包。要安装它，只需运行<code class="fe kz la lb lc b">elm install NoRedInk/elm-compare</code>。关于<code class="fe kz la lb lc b">Compare</code>模块首先要知道的是<code class="fe kz la lb lc b">Comparator</code>类型别名:</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="0bcf" class="ne le it lc b gy nf ng l nh ni">type alias Comparator a =<br/>    a -&gt; a -&gt; Order</span></pre><p id="094e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个类型为作为<code class="fe kz la lb lc b">List.sortWith</code>第一个参数的函数起了别名，模块的其余部分包含了<code class="fe kz la lb lc b">Comparator</code>方便的组合子。</p><p id="0335" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这两个额外的模块，让我们创建一个函数，按照出生日期对一个<code class="fe kz la lb lc b">List Person</code>进行排序(最年轻的排在最前面)，如果两个日期相同，那么按照他们名字的字母顺序排序。<code class="fe kz la lb lc b">name</code>字段是一个<code class="fe kz la lb lc b">String</code>，它是一个<code class="fe kz la lb lc b">comparable</code>，但是为了使用<code class="fe kz la lb lc b">Compare</code>模块中的功能，我们需要一个<code class="fe kz la lb lc b">Comparator</code>。<code class="fe kz la lb lc b"><a class="ae mg" href="https://package.elm-lang.org/packages/NoRedInk/elm-compare/latest/Compare#by" rel="noopener ugc nofollow" target="_blank">Compare.by</a></code> <a class="ae mg" href="https://package.elm-lang.org/packages/NoRedInk/elm-compare/latest/Compare#by" rel="noopener ugc nofollow" target="_blank">功能</a>带签名:</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="2c5c" class="ne le it lc b gy nf ng l nh ni">by : (a -&gt; comparable) -&gt; Comparator a</span></pre><p id="7a58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅仅是:</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="f5b9" class="ne le it lc b gy nf ng l nh ni">import Compare exposing (Comparator)</span><span id="5bd8" class="ne le it lc b gy nj ng l nh ni">nameComparator : Comparator Person<br/>nameComparator =<br/>    Compare.by .name</span></pre><p id="2b27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将创建一个按日期排序的<code class="fe kz la lb lc b">Comparator Person</code>(首先是最近的日期):</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="8b63" class="ne le it lc b gy nf ng l nh ni">dateOfBirthComparator : Comparator Person<br/>dateOfBirthComparator =<br/>    Compare.compose .dateOfBirth Date.compare |&gt; Compare.reverse</span></pre><p id="c9d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是事情变得更有趣的地方。<code class="fe kz la lb lc b">Compare.compose</code>函数有一个签名:</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="4ac5" class="ne le it lc b gy nf ng l nh ni">compose : (a -&gt; b) -&gt; Comparator b -&gt; Comparator a</span></pre><p id="9ca3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你是第一次看到类似的东西，这个签名看起来会很奇怪。你可能会想，<em class="mv">等等</em>如果我给它一个从<code class="fe kz la lb lc b">a -&gt; b</code>开始的函数，我们怎么能从<code class="fe kz la lb lc b">Comparator b</code>开始，到<code class="fe kz la lb lc b">Comparator a</code>结束。理解它的关键是记住一个<code class="fe kz la lb lc b">Comparator</code>是一个函数的别名。用我们正在处理的类型替换类型变量会有所帮助:</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="b949" class="ne le it lc b gy nf ng l nh ni">compose : (Person -&gt; Date) -&gt; Comparator Date -&gt; Comparator Person</span></pre><p id="dcd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后展开<code class="fe kz la lb lc b">Comparator</code>类型别名来查看所涉及的函数类型:</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="13b4" class="ne le it lc b gy nf ng l nh ni">compose :<br/>    (Person -&gt; Date)<br/>    -&gt; (Date -&gt; Date -&gt; Order)<br/>    -&gt; (Person -&gt; Person -&gt; Order)</span></pre><p id="de1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">换句话说，如果您给compose函数一个从<code class="fe kz la lb lc b">Person</code>到<code class="fe kz la lb lc b">Date</code>的方法和一个比较日期的方法，那么它返回一个可以比较人的函数。为了比较人，它将首先调用映射一个<code class="fe kz la lb lc b">Person</code>到一个<code class="fe kz la lb lc b">Date</code>(在每个<code class="fe kz la lb lc b">Person</code>)的函数，然后使用提供的比较函数比较这些日期。</p><p id="59dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mv">先不说这个，学榆树之前学过一点Haskell这个名字</em> <code class="fe kz la lb lc b"><em class="mv">compose</em></code> <em class="mv">让我有点摸不着头脑。在Haskell中</em> <code class="fe kz la lb lc b"><em class="mv">compose</em></code> <em class="mv">函数是</em> <code class="fe kz la lb lc b"><em class="mv">Contravariant</em></code> <em class="mv"> typeclass上的一个函数，而</em> <code class="fe kz la lb lc b"><em class="mv">Contravariant</em></code> <em class="mv">确实有一个</em> <code class="fe kz la lb lc b"><a class="ae mg" href="https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#t:Comparison" rel="noopener ugc nofollow" target="_blank"><em class="mv">Comparison</em></a></code> <a class="ae mg" href="https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#t:Comparison" rel="noopener ugc nofollow" target="_blank"> <em class="mv">实例</em> </a> <em class="mv">。换句话说，如果你熟悉逆变函子，你可能会发现我们一直使用的</em> <code class="fe kz la lb lc b"><em class="mv">Comparator</em></code> <em class="mv">类型别名就是一个例子。</em></p><p id="5c76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，<code class="fe kz la lb lc b">Date.compare</code>函数按照从最早到最晚的顺序对日期进行排序，但是我们可以使用带有签名的<code class="fe kz la lb lc b">Compare.reverse</code>:</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="50c3" class="ne le it lc b gy nf ng l nh ni">reverse : Comparator a -&gt; Comparator a</span></pre><p id="4414" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就把我们的<code class="fe kz la lb lc b">Comparator</code>取反了。这个函数的好处在于，我们不需要仅仅为了反转<code class="fe kz la lb lc b">List</code>而对<code class="fe kz la lb lc b">List</code>进行排序，关键的是，当按多个标准排序时，我们可以反转一个特定的<code class="fe kz la lb lc b">Comparator</code></p><p id="01c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在是时候制定一个考虑到前两者的<code class="fe kz la lb lc b">Comparator</code>了。</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="662a" class="ne le it lc b gy nf ng l nh ni">personComparator : Comparator Person<br/>personComparator =<br/>    Compare.concat [ dateOfBirthComparator, nameComparator ]</span></pre><p id="5b2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这使用了<code class="fe kz la lb lc b">Compare.concat</code>来制作一个<code class="fe kz la lb lc b">Comparator Person</code>，它首先基于<code class="fe kz la lb lc b">dateOfBirthComparator</code>来比较人，如果它产生了<code class="fe kz la lb lc b">Eq</code>的<code class="fe kz la lb lc b">Order</code>，它就使用<code class="fe kz la lb lc b">nameComparator</code>，这正是我们想要的！换句话说,<code class="fe kz la lb lc b">Compare.concat</code>将按顺序尝试列表中的每个<code class="fe kz la lb lc b">Comparator</code>,直到找到第一个不相等的结果，或者到达列表的末尾并认为它们相等。</p><p id="0914" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mv">关于</em> <code class="fe kz la lb lc b"><em class="mv">Comparator</em></code> <em class="mv">的一个快速提示作为一个幺半群，我将使用Haskell类型，这样我可以链接到文档。这就是</em> <code class="fe kz la lb lc b"><em class="mv">Ordering</em></code> <em class="mv">是幺半群因而</em> <code class="fe kz la lb lc b"><em class="mv">Comparison</em></code> <em class="mv">是幺半群派上用场的地方，</em> <code class="fe kz la lb lc b"><em class="mv">mconcat</em></code> <em class="mv">上的</em> <a class="ae mg" href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Contravariant.html#g:4" rel="noopener ugc nofollow" target="_blank"> <em class="mv">幺半群实例对于</em> </a> <code class="fe kz la lb lc b"><a class="ae mg" href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Contravariant.html#g:4" rel="noopener ugc nofollow" target="_blank"><em class="mv">Comparsion</em></a></code> <em class="mv">的作用与</em> <code class="fe kz la lb lc b"><em class="mv">Compose.concat</em></code> <em class="mv">函数相同，这也是为什么</em> <code class="fe kz la lb lc b"><em class="mv">mempty</em></code> <em class="mv">(或恒等式)可以是</em> <code class="fe kz la lb lc b"><em class="mv">Eq</em></code> <em class="mv">的变体。在Haskell Wiki </em>的幺半群部分有一个 <a class="ae mg" href="https://wiki.haskell.org/Monoid#So_what.3F" rel="noopener ugc nofollow" target="_blank">喊出</a> <em class="mv">到此</em></p><p id="b284" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在剩下要做的就是创建一个对人员列表进行排序的函数:</p><pre class="mw mx my mz gt na lc nb nc aw nd bi"><span id="714f" class="ne le it lc b gy nf ng l nh ni">sortPeople : List Person -&gt; List Person<br/>sortPeople =<br/>    List.sortWith personComparator</span></pre><p id="aed6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们只需要将我们的<code class="fe kz la lb lc b">personComparator</code>传递给<code class="fe kz la lb lc b">List.sortWith</code>就可以了。</p><h1 id="97c7" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">包扎</h1><p id="6dce" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">希望这对于如何在Elm中进行比较和排序有所启发。有了<code class="fe kz la lb lc b">Compare</code>模块，您可以构建复杂的定制排序，以优雅和可组合的方式与<code class="fe kz la lb lc b">List</code>一起使用。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="d7b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mv">最初发表于</em><a class="ae mg" href="https://stacktracehq.com/blog/comparing-and-sorting-in-elm/" rel="noopener ugc nofollow" target="_blank">T5【https://stacktracehq.com】</a><em class="mv">。</em></p></div></div>    
</body>
</html>