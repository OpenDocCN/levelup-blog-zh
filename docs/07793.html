<html>
<head>
<title>How to log the request body in a Spring Boot application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Spring Boot应用程序中记录请求正文</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-log-the-request-body-in-a-spring-boot-application-10083b70c66?source=collection_archive---------2-----------------------#2021-03-11">https://levelup.gitconnected.com/how-to-log-the-request-body-in-a-spring-boot-application-10083b70c66?source=collection_archive---------2-----------------------#2021-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/30bc3b3493612527c780568ffa3fcae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E1nVWkNiwwjBeTyO"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9abd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您构建一个Spring Boot应用程序时，出于审计的目的，您很可能希望记录对应用程序发出的每个<code class="fe le lf lg lh b">POST</code>和<code class="fe le lf lg lh b">PUT</code>请求的请求体。最好的方法是创建一个<code class="fe le lf lg lh b">Filter</code>，并通过过滤器链注册它。它将负责读取请求体并将其记录到标准输出中。</p><p id="e2ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是在我们开始实现它之前，我们先来分析一下<code class="fe le lf lg lh b">ServletRequest</code>是如何处理的:</p><p id="9a4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们谈论用Java处理内容时——在我们的例子中是请求体，一切都用流来表示。我们可以从一个<code class="fe le lf lg lh b">InputStream</code>读取内容，并向一个<code class="fe le lf lg lh b">OutputStream</code>写入内容。当您的应用程序收到请求时，会在后台创建一个<code class="fe le lf lg lh b">InputStream</code>,然后被读取，内容被Jackson反序列化为特定的类型。当您的应用程序发送响应时，响应的数据被写入到一个<code class="fe le lf lg lh b">OutputStream</code>中，然后由某个较低级别的实体处理，该实体通过网络将内容发送到客户端。</p><p id="9351" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们只对阅读那些内容感兴趣。我们可以创建一个新的过滤器<code class="fe le lf lg lh b">LogRequestFilter</code>，它将读取请求的<code class="fe le lf lg lh b">InputStream</code>，并记录请求的<code class="fe le lf lg lh b">String</code>表示。</p><p id="733f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这显示在下面的代码中——使用方法<code class="fe le lf lg lh b">logPostOrPutRequestBody</code>我们能够从<code class="fe le lf lg lh b">HttpServletRequest</code>中读取<code class="fe le lf lg lh b">InputStream</code>并将其记录到标准输出中。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="417d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用注册的过滤器运行应用程序，然后向任何注册的端点发出一个<code class="fe le lf lg lh b">POST</code>或<code class="fe le lf lg lh b">PUT</code>请求，您将能够在标准输出中看到记录的请求体。</p><p id="faba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，返回的响应是<code class="fe le lf lg lh b">5xx — Internal Server Error</code>，如果您研究应用程序的标准输出，您会注意到以下异常:</p><pre class="li lj lk ll gt lo lh lp lq aw lr bi"><span id="426d" class="ls lt it lh b gy lu lv l lw lx"><strong class="lh iu">DefaultHandlerExceptionResolver</strong> : Resolved [org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing</span></pre><p id="edaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您熟悉读取<code class="fe le lf lg lh b">InputStream</code>的工作方式，您可能知道这个问题的答案——在过滤器被处理后，请求的输入流将被重新读取，然后内容将被<code class="fe le lf lg lh b">Jackson</code>解析。</p><p id="f4c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，一个输入流只能被读取一次。</p><p id="5104" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么在第二次尝试读取输入流时，我们会看到请求主体丢失的错误。</p><p id="2824" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要一种不同的方法来解决这个问题，为此，我们需要更深入地了解<code class="fe le lf lg lh b">HttpServletRequest</code>是如何运作的。</p><h2 id="0b33" class="ls lt it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">HttpServletRequest</h2><p id="31a1" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">从<code class="fe le lf lg lh b">ServletRequest</code>中读取包含请求体的InputStream。如果你深入研究<code class="fe le lf lg lh b">ServletRequest</code>类，你会注意到它有两个方法:</p><pre class="li lj lk ll gt lo lh lp lq aw lr bi"><span id="b08d" class="ls lt it lh b gy lu lv l lw lx">getReader()</span><span id="4f4c" class="ls lt it lh b gy mu lv l lw lx">getInputStream()</span></pre><p id="ec89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，每当Jackson需要读取和反序列化主体时，就会在ServletRequest对象上调用<code class="fe le lf lg lh b">getInputStream</code>。</p><p id="2964" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于这个原因，我们需要找到一种方法将包装了 <code class="fe le lf lg lh b">ServletRequest</code>的<em class="mv">传递给过滤器链，过滤器链将能够读取当前的输入流，缓存它，并将主体记录到标准输出中，然后在每次调用<code class="fe le lf lg lh b">getInputStream</code>时，从主体的缓存字节中返回一个新的<code class="fe le lf lg lh b">InputStream</code>。</em></p><p id="89ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过创建一个扩展<code class="fe le lf lg lh b">HttpServletRequestWrapper</code>的自定义类来实现，如下面的代码片段所示:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="38a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个新类中，我们确保从请求中读取输入流(在构造函数中这样做也可以)，将其存储在一个局部变量中，并覆盖<code class="fe le lf lg lh b">getReader()</code>和<code class="fe le lf lg lh b">getInputStream()</code>。</p><p id="42e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理想情况下，getReader应该返回一个您的<code class="fe le lf lg lh b">getInputStream(</code>实现的Reader，如下所示:</p><pre class="li lj lk ll gt lo lh lp lq aw lr bi"><span id="fede" class="ls lt it lh b gy lu lv l lw lx">return new BufferedReader(new InputStreamReader(getInputStream()));</span></pre><p id="863c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一步是提供您自己的必须返回一个<code class="fe le lf lg lh b">ServletInputStream</code>的<code class="fe le lf lg lh b"> getInputStream()</code>实现。您可以创建一个自定义类来扩展<code class="fe le lf lg lh b">ServletInputStream</code>并覆盖所有这些方法，或者直接在<code class="fe le lf lg lh b">getInputStream()</code>方法中返回一个匿名类。</p><p id="5acb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，我们采用第二种方法，首先从缓存的内容构建一个InputStream:</p><pre class="li lj lk ll gt lo lh lp lq aw lr bi"><span id="6322" class="ls lt it lh b gy lu lv l lw lx">final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bodyInStringFormat.getBytes());</span></pre><p id="5602" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后返回知道如何读取该流的新实例<code class="fe le lf lg lh b">ServletInputStream</code>。</p><p id="8600" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最终确定了<code class="fe le lf lg lh b">CustomHttpRequestWrapper</code>类之后，我们对<code class="fe le lf lg lh b">LogRequestFilter</code>做了一个快速重构，以使用那个包装器并沿着过滤器链转发它。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="f68b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一次，当您向应用程序发出<code class="fe le lf lg lh b">POST</code>或<code class="fe le lf lg lh b">PUT</code>请求时，您应该不会看到任何错误。此外，请求正文将记录在标准输出中。</p><p id="cc20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢你阅读这篇文章，希望你觉得有用。</p><p id="af8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保重！</p></div></div>    
</body>
</html>