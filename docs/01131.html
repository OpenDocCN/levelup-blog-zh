<html>
<head>
<title>GraphQL Observability with Go Using Open-source Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用开源工具实现GraphQL的可观察性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-observability-with-go-using-open-source-tools-4caaf8f13237?source=collection_archive---------2-----------------------#2019-11-13">https://levelup.gitconnected.com/graphql-observability-with-go-using-open-source-tools-4caaf8f13237?source=collection_archive---------2-----------------------#2019-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/de8936f90d59e8f4adcf8ffb5041e847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSWnhD1Nxx1WZKaAdsC3Qw.png"/></div></div></figure><p id="8297" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我和我的团队正在IBM Watson Media用Golang开发一个GraphQL API。由于GraphQL是独立于传输的，并且大多数传统的监控解决方案依赖于特定于传输的特征(如HTTP状态代码和方法)，因此它们并不完全适合监控这种用例。因此，我使用开源工具寻找开箱即用的解决方案，但没有找到任何解决方案，所以我决定为我们自己构建一个堆栈。本文将涵盖整个堆栈，而不仅仅是监控。</p><p id="a566" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<a class="ae kz" href="https://github.com/graph-gophers/graphql-go" rel="noopener ugc nofollow" target="_blank">graph-gophers/graphql-go</a>作为graph QL服务器，使用<a class="ae kz" href="https://github.com/graph-gophers/dataloader" rel="noopener ugc nofollow" target="_blank">graph-gophers/data loader</a>作为我们的核心数据获取组件(以解决N+1问题)。两者都有对OpenTracing的现成支持，所以让我们从它开始。</p><h1 id="5a78" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">OpenTracing</h1><p id="4ce5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们所要做的就是初始化一个OpenTracing tracer(我选择了Jaeger)并在Dataloader中启用OpenTracing(默认情况下在GraphQL服务器中启用)。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/59d416b7e3db079f9b4ae3c53beaabbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mh0QypGv_yBoI_S5geGFg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">为OpenTracing初始化Jaeger和数据加载器</figcaption></figure><p id="fd73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GraphQL服务器和数据加载器现在都在报告跟踪。虽然没有它解析器仍然可以工作，但是我们为它们的每个方法添加了<code class="fe mm mn mo mp b">context.Context</code>参数。GraphQL服务器通过<code class="fe mm mn mo mp b">context.Context</code>传播OpenTracing spans，因此如果解析器不接受它作为参数，它的子树不会在跟踪中显示为一个单独的span。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/530e7de03068f26a2bda58bb90c7f8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSWHPle1MPsvmCSgtdW8OA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">具有上下文的Location.name的解析方法。上下文参数，即使它不使用它</figcaption></figure><p id="60fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给定的Jaeger环境已经启动并运行，执行以下GraphQL查询:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/dd991a4d615ad521f8268f127304d584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kEOrbGKgbJUZyotNKzFEyg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">所有服务器的查询id和位置</figcaption></figure><p id="d257" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">检查耶格用户界面，我们发现如下痕迹。GraphQL服务器记录精确的GraphQL查询(在根区域作为<code class="fe mm mn mo mp b">graphql.query</code>标签)以及每个解析的字段(接受<code class="fe mm mn mo mp b">context.Context</code>参数)。Dataloader记录每个数据加载请求以及批处理请求的执行。两个<code class="fe mm mn mo mp b">Server.location</code>解析器都调用了<code class="fe mm mn mo mp b">Dataloader.load</code>，但只有第二个执行了一个<code class="fe mm mn mo mp b">Dataloader.batch</code>。在<code class="fe mm mn mo mp b">load</code>和<code class="fe mm mn mo mp b">batch</code>之间有一个<em class="mq"> 10ms </em>的间隙，这很好地展示了Dataloader的Golang实现是如何工作的。在第一次<code class="fe mm mn mo mp b">load</code>请求时，一个<em class="mq"> 10ms </em>定时器启动。在此期间，每个后续的<code class="fe mm mn mo mp b">load</code>请求将被附加到第一个请求上。定时器到期后，收集的请求作为一个<em class="mq">批处理</em>查询执行。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/e75930e9aed24f16b177670c659531b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGT4qPzwx3q_r0E84yGW1Q.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">在Jaeger UI上跟踪成功的GraphQL查询</figcaption></figure><h1 id="ae95" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">将HTTP响应链接到OpenTracing</h1><p id="1ae7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们的大多数客户在遇到我们系统中的错误时都会开罚单。如果问题是永久性的，我们很容易找到根本原因，但如果是暂时性的，就很难找到了(仅持续5-10分钟)。</p><p id="b330" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的跟踪已经非常有用了，所以让我们开始在此基础上构建。假设周一早上有一张bug票等着我，是关于周末发生的一个临时错误。我有两天的跟踪和日志，我可以缩小范围找到根本原因，但我不想为此浪费时间。我希望立即看到确切的跟踪和相应的日志，而不要浪费任何时间去寻找它们。</p><p id="7f25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Jaeger UI的上图中，跟踪ID显示为标题<em class="mq"> 3cb8ca2 </em>。如果出现错误，我们应该将其作为HTTP响应头返回，并显示在ui上。如果客户提供了跟踪ID，那么通过这种方式为我们的bug单找到相应的跟踪是很容易的。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/bfeaaaccf70b8e157c130dd0c5f8eb0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eT8fJGZDiFViC6E19FJc_g.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">traceHeader HTTP中间件在HTTP响应头中返回跟踪ID</figcaption></figure><h1 id="afee" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">链接错误日志</h1><p id="683a" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">大多数时候，我首先读取日志，而不是检查请求的跟踪。我们有一个<code class="fe mm mn mo mp b">Logger</code>类型，可以在代码中传递，并提供一致的日志格式。我用一个<code class="fe mm mn mo mp b">TracedError</code>方法对它进行了扩展，该方法记录了所提供的错误消息，并标记了所提供的<code class="fe mm mn mo mp b">context.Context</code>的跟踪ID。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/c7ee271a42f48d0ec1cfe1c30ac3efa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRIBcBkqNt3vkuXSegh-sw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">一致的错误日志记录，包括上下文的跟踪ID</figcaption></figure><p id="79dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在很容易找到给定请求的日志及其踪迹。在没有显式日志语句的情况下记录所有解析器错误也非常有用。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/ee1b4bb01d21fae757bff01205dba7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JfU2DGcgiQOGXo9GyECw0w.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">Server.location字段的解析程序返回错误，但不记录它</figcaption></figure><p id="a79b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GraphQL服务器的默认跟踪器是我们已经使用的OpenTracing tracer，但是我们可以用任何符合<code class="fe mm mn mo mp b">Tracer</code>接口的东西来替换它。它必须既有<code class="fe mm mn mo mp b">TraceQuery</code>又有<code class="fe mm mn mo mp b">TraceField</code>方法(它有一堆参数，所以我截掉了我们不需要的)。<code class="fe mm mn mo mp b">TraceQuery</code>将在GraphQL查询开始时被调用，并且必须返回一个回调函数，该函数将在查询结束时被调用(将查询执行期间发生的所有错误作为参数)。<code class="fe mm mn mo mp b">TraceField</code>是相同的，但是它将被查询的每个GraphQL字段调用。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/503d1c287c50b8646546ef09965e7bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owP-F4k3tiLx71InPcjpoA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">GraphQL服务器接受任何作为实现tracer接口的跟踪器的东西</figcaption></figure><p id="bd18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此我实现了<code class="fe mm mn mo mp b">LoggingTracer</code>。在每个查询开始时，返回回调函数<code class="fe mm mn mo mp b">logErrors</code>,在出现所有错误的查询结束时调用该函数。它按错误消息聚合日志，以避免在多个解析器中出现相同错误时泛滥，并调用日志消息，包括跟踪id。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/e0553ad1293ade757c95e9a8def8eb4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjK7peASiNwW2qU8HQBtjQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">LoggingTracer使用跟踪ID在查询执行结束时聚合并记录错误</figcaption></figure><h1 id="8b37" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">支持多个跟踪器</h1><p id="dcb7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在，我们可以使用默认的<code class="fe mm mn mo mp b">OpenTracing</code>跟踪器或我们的<code class="fe mm mn mo mp b">LoggingTracer</code>，但不能同时使用两者(任何数量的跟踪器都可以传递给GraphQL服务器，但它只会按顺序使用最后一个)。让我们实施<code class="fe mm mn mo mp b">ChainingTracer</code>救援吧！</p><p id="7b69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mm mn mo mp b">TraceQuery</code>和<code class="fe mm mn mo mp b">TraceField</code>都要依次调用被传递的tracer的对应方法，将前一个tracer返回的<code class="fe mm mn mo mp b">context.Context</code>传递给下一个tracer。它还应该返回一个回调函数，该函数按照提供的顺序调用链式跟踪器的回调函数。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/c87d0514f49b1f624445d16cbd89449e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNxkRll6LN6PkXPUlOfyww.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">ChainingTracer可以链接提供的跟踪器(TraceField方法类似于TraceQuery)</figcaption></figure><p id="4bb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在可以同时使用<code class="fe mm mn mo mp b">OpenTracingTracer</code>和<code class="fe mm mn mo mp b">LoggingTracer</code>:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/350e6876c3978929bd51d97affee996a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PeKrtfIp4AsdFTk_zFfLvQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">链接OpenTracingTracer和LoggingTracer</figcaption></figure><p id="35ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们回顾一下目前我们所掌握的情况。每个HTTP响应都返回一个<code class="fe mm mn mo mp b">trace</code>头，它具有给定请求的跟踪ID的值:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/f887adf7e6d89ad154a7a3c9c2eb73c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8rg1xHMS47-4CrDF8LFMA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">跟踪2b6bfdcc6e856c0b的响应跟踪标头示例</figcaption></figure><p id="ab3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Jaeger UI上可以很容易地找到<em class="mq"> 2b6bfdcc6e856c0b </em>的相应踪迹。如果发生解析器错误，则显示解析器错误(聚合在请求范围中，并单独显示在解析器范围的<code class="fe mm mn mo mp b">graphql.error</code>标记中):</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/42e5165d59b0717d5141fa81c99ef45f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SeV8nAOLCvVBLkdDhZ10lQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">Jaeger UI中跟踪到2b6bfdc有解析器错误</figcaption></figure><p id="b9e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也可以很容易地找到<em class="mq"> 2b6bfdcc6e856c0b </em>的日志；</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/76eee2dd571895cf53f52866ac4f1698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKNycz0Uby8DHHibyO6nng.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">聚集<em class="mu"> 2b6bfdcc6e856c0b </em>的错误，并记录跟踪ID</figcaption></figure><h1 id="3881" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">监视</h1><p id="0a2a" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我开始抱怨传统的监控工具不能很好地用于GraphQL，但是我们实现了除监控之外的所有东西。这是有原因的。我认为整个堆栈对许多人来说都是有价值的，我们将在现有的基础上建立监控。我们将使用tracers、<a class="ae kz" href="https://opencensus.io" rel="noopener ugc nofollow" target="_blank"> OpenCensus </a>和<a class="ae kz" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>作为核心构件。</p><p id="4bbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">OpenCensus提供了一种声明性的方法来构建指标(或OpenCensus中所谓的视图)。每个视图的工作流程如下:</p><ol class=""><li id="8b69" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">定义所需的标签。指标可以缩小到标记值(例如:在下面的例子中，我们可以查看每个客户的每个GraphQL字段的指标)。这些标签最终将成为Prometheus标签，它建议不要使用任何基数大/取值范围不受限制的标签(每个标签组合都会在Prometheus中创建一个新系列)。我们使用GraphQL字段和客户id，这似乎是一个完美的反例。我们的模式实际上非常紧凑，我们的客户范围有限(它不是一个注册后任何人都可以使用的公共API)，并且我们对这些详细的监控场景有很短的数据保留期。</li><li id="339e" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">定义一个度量单位。度量代表可以度量的东西(字面上可以是任何东西)。在下面的例子中，我们测量一个字段的错误计数。计数没有单位，因此，我们将其定义为<em class="mq">无量纲</em>(即:对于时间，我们给<em class="mq">毫秒</em>单位)。</li><li id="209f" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">使用标签、度量和聚合函数定义视图。下面我们定义了一个视图，它使用我们的标签和度量来表示每个客户的字段错误计数。通过<em class="mq"> Count </em>方法聚合测量值(即:对于延迟，我们将使用<em class="mq"> Distribution </em>方法，该方法将测量值公开为预定义存储桶中的分布)。</li><li id="6b26" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">注册曝光视图。</li></ol><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/d6837ef6172a0eae172ea8f34bb36420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVDb-HlYTYtJy2rBaFwLJQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">定义OpenCensus标签、字段、视图，并注册它们以公开</figcaption></figure><p id="6049" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们必须用数据填充这些视图(实际上是它们的度量)，因此我们实现了另一个tracer: <code class="fe mm mn mo mp b">AnalyticsTracer</code>。<code class="fe mm mn mo mp b">TraceQuery</code>方法使用<code class="fe mm mn mo mp b">QueryAnalyser</code>，而<code class="fe mm mn mo mp b">TraceField</code>方法使用<code class="fe mm mn mo mp b">FieldAnalyser</code>来记录测量值。<code class="fe mm mn mo mp b">AnalyticsTracer</code>的唯一职责是初始化<code class="fe mm mn mo mp b">Analysers</code>(记录解析器的开始时间，存储被分析的查询/字段的相关属性)并将它们的<code class="fe mm mn mo mp b">recordMeasurements</code>注册为结束回调函数。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/9f7c460aff330f1c378088f8356f6711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhf-aa02EMvI6-5r0HQVCQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">AnalyticsTracer初始化QueryAnalyser和FieldAnalyser以记录测量值(TraceQuery方法类似于TraceField)</figcaption></figure><p id="7a38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由<code class="fe mm mn mo mp b">QueryAnalyser</code>和<code class="fe mm mn mo mp b">FieldAnalyser</code>实际测量相关数据并通过定义的OpenCensus测量记录它们。让我们回顾一下<code class="fe mm mn mo mp b">FieldAnalyser</code>的实现(<code class="fe mm mn mo mp b">QueryAnalyser</code>也差不多):</p><ol class=""><li id="bef8" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">解析的<em class="mq"> GraphQL </em> <em class="mq">类型</em>和<em class="mq">字段</em>存储为结构字段，以及字段解析器的<em class="mq">客户ID </em>和<em class="mq">开始时间</em>。</li><li id="5881" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><em class="mq">记录测量值</em>在现场分解器结束时调用get。自省查询以__开始。我们跳过这些记录，因为它们对我们的目的不感兴趣。</li><li id="8b6e" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">构建测量值(解析器持续时间、计数和错误计数)并使用适当的标签进行记录。</li></ol><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/d1ea89c920706ff55b1423a0d1eab73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qe57YkmlZEC3RZA8ym_k2A.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">FieldAnalyser记录给定类型的测量值</figcaption></figure><p id="7fd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">OpenCensus视图现在已经定义并填充了测量值，但是我们需要一个具体的监控解决方案来暴露它们，我选择了Prometheus。我们这样初始化它:</p><ol class=""><li id="6db5" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">使用默认的Prometheus注册表创建一个新的OpenCensus视图导出器。Go process的内部度量(即:打开文件描述符的数量，<em class="mq"> goroutines </em>)已经注册到默认注册表中，因此我发现继续使用它比创建一个新的更方便。</li><li id="1f6e" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">为视图曝光注册创建的导出器。现在每个视图都通过<em class="mq">视图注册。寄存器</em>将通过这个曝光。</li><li id="c606" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">注册默认OpenCensus服务器视图。这些是普通的HTTP指标(即:延迟、HTTP方法、状态代码)。</li><li id="3556" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">在<em class="mq"> /metrics </em> HTTP端点下公开导出器。Prometheus服务器将收集此端点的度量。</li></ol><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/8b9717c246792fee6ea02a221863f539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NacpvhPfS5-AVtv4jG9bhQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">从prometheus注册表创建度量导出器，并将其作为HTTP处理程序附加到/metrics</figcaption></figure><p id="586b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在转到流程内部，普通的HTTP和GraphQL特定的指标在<em class="mq"> /metrics </em>处公开，并准备好被抓取！我还制作了一些精美的Grafana仪表盘，这是其中的一部分，它使用了<em class="mq"> FieldAnalyser </em>的测量值:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/626db1dc7c3efc442b8eb8dfdab5302d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CuDeXSUrjc6ORUgs17HZuQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">使用FieldAnalyser测量值的Grafana仪表板</figcaption></figure><h1 id="954f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="67c8" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">GraphQL只有几年的历史，可能没有适合所有事情的工具。我认为大部分基本构件都已经存在，因此我们应该开始为这种令人惊叹的语言构建堆栈。</p><p id="e025" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有问题吗？请在评论中告诉我！如果你喜欢这篇文章，请考虑分享它。</p><h2 id="52f4" class="nk lb it bd lc nl nm dn lg nn no dp lk km np nq lo kq nr ns ls ku nt nu lw nv bi translated">编辑:</h2><p id="eb15" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">你可以在这里找到示例源代码:<a class="ae kz" href="https://github.com/IBM/graphql-observability-example" rel="noopener ugc nofollow" target="_blank">https://github.com/IBM/graphql-observability-example</a>。</p></div></div>    
</body>
</html>