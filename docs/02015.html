<html>
<head>
<title>How worker threads boosted my Node application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工作线程如何提升我的节点应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-worker-threads-boosted-my-node-application-9ff23abb8927?source=collection_archive---------6-----------------------#2020-02-12">https://levelup.gitconnected.com/how-worker-threads-boosted-my-node-application-9ff23abb8927?source=collection_archive---------6-----------------------#2020-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e384" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> worker_threads </strong>模块用Node.js <strong class="js iu"> v10.x LTS </strong>发布，用<strong class="js iu"> v13.x </strong>稳定。它支持在<strong class="js iu"> parallel </strong>中使用执行Javascript的线程(注意，并行性和并发性是相近但不同的概念)<em class="ko">。</em>当操作需要消耗<strong class="js iu"> CPU </strong>时非常有用。</p><p id="6735" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的应用程序中，我用动态参数为每个请求生成动态脚本。为了生成脚本，我正在运行一个npm命令，带有<a class="ae kp" href="https://nodejs.org/api/child_process.html#child_process_child_process_execsync_command_options" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">execSync</strong></a><strong class="js iu"/>命令<strong class="js iu">。</strong>我无法使用async <a class="ae kp" href="https://nodejs.org/api/child_process.html#child_process_child_process_execsync_command_options" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> exec </strong> </a>命令，因为该命令需要遵循创建动态脚本的顺序。</p><p id="ca7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我展示一下变化之前的情况:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/7932a8902dada44a02ce331c674d3596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDLHHeM8jcrL8juHreSQnw.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">draw.io</figcaption></figure><p id="843c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每当一个请求从其他微服务(AWS Lambda，Node.js)到达我们这边时，上面的过程就会发生。整个过程是同步的，直到第三步，只有上传是异步的。所以最后一步不是线程拦截器。</p><p id="5b99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每分钟对生成器服务的传入请求量约为30。这意味着对于即时生成过程，单个过程应该最多在2秒内完成，但我的过程大约是5-6秒。因此，应用程序会锁定主线程，直到活动操作结束。这有时会将传入的生成过程延迟1分钟。</p><p id="7631" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，在<strong class="js iu">工作线程</strong>实现之后有什么变化呢？</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lg"><img src="../Images/20fa84dd76a31e0fc1bb51b8b62c1f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ly5Sr8apeluKe5v6Z8mh5w.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">draw.io</figcaption></figure><p id="322b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在代码中，工作线程的示例如下所示。</p><p id="ed1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lh li lj lk b">index.js</code>文件中:</p><pre class="kr ks kt ku gt ll lk lm ln aw lo bi"><span id="3af6" class="lp lq it lk b gy lr ls l lt lu">// index.js<br/>const { Worker } = require('worker_threads');</span><span id="0bc2" class="lp lq it lk b gy lv ls l lt lu">const workerData = {                <br/>  write: { fileName: 'write.txt', filePath: './' },<br/>  read: { fileName: 'read.json', filePath: './' },<br/>  hash: Math.random(),            <br/>};</span><span id="d8f9" class="lp lq it lk b gy lv ls l lt lu">new Worker('./worker.js', { workerData });</span></pre><p id="bdc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的<code class="fe lh li lj lk b">worker.js</code>文件中:</p><pre class="kr ks kt ku gt ll lk lm ln aw lo bi"><span id="766a" class="lp lq it lk b gy lr ls l lt lu">// worker.js<br/>const { readFileSync, appendFileSync, unlinkSync, existsSync } = require('fs');<br/>const { resolve } = require('path');<br/>const { workerData: { read, write, hash } } = require('worker_threads');</span><span id="11d9" class="lp lq it lk b gy lv ls l lt lu">console.log('Process triggered.');<br/>console.time('Execution time');</span><span id="f5dc" class="lp lq it lk b gy lv ls l lt lu">/**<br/> * @return {Promise}<br/> */<br/>const sleep = async function () {<br/>    return new Promise(resolve =&gt; {<br/>        setTimeout(resolve, Math.floor(Math.random() * 5000) + 999);<br/>    });<br/>};</span><span id="ef69" class="lp lq it lk b gy lv ls l lt lu">(async () =&gt; {<br/>    // Act like process takes time<br/>    await sleep();</span><span id="5b4b" class="lp lq it lk b gy lv ls l lt lu">    const writePath = resolve(write.filePath, write.fileName + '-' + hash);<br/>    const readPath = resolve(read.filePath, read.fileName);<br/>    const json = JSON.parse(readFileSync(readPath).toString('utf-8'));</span><span id="e08b" class="lp lq it lk b gy lv ls l lt lu">    // Remove the file before writing<br/>    if (existsSync(writePath)) {<br/>        unlinkSync(writePath);<br/>    }</span><span id="ac31" class="lp lq it lk b gy lv ls l lt lu">    json.forEach(item =&gt; {<br/>        appendFileSync(writePath, JSON.stringify(item) + '\n\n\n');<br/>    });</span><span id="376c" class="lp lq it lk b gy lv ls l lt lu">    console.log('Process end.');<br/>    console.timeEnd('Execution time');<br/>})();</span></pre><p id="a66d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了上面的实现，应用程序的主线程不再忙于生成过程。每个进程都是独立的，不会成为传入进程的阻塞程序。这极大地减少了生成过程中的延迟，但是CPU的使用保持不变，因为工人也消耗了大量的CPU。 </p><p id="71b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为它使生成速度更快，它还为我提供了其他好处:</p><ul class=""><li id="fdfc" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated"><strong class="js iu"> <em class="ko">读写文件的过程快了很多</em> </strong>🚀</li></ul><p id="146f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为主线程总是很忙，所以传入的读/写请求被延迟，直到它可以在执行队列中找到一个空位置。但是现在，它马上就发生了。</p><ul class=""><li id="6e7d" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated"><strong class="js iu"> <em class="ko">反应时间急剧下降</em> </strong>📉</li></ul><p id="bed7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于通过express提供的静态文件，应用程序的响应时间大约为3-5秒，有时需要10秒钟才能被缓存。我花了很长时间才意识到那里发生了什么。用<strong class="js iu"> express </strong>服务静态文件真的很快，除非你有一个消耗CPU和非常繁忙的线程消耗的系统。静态文件由节点的<a class="ae kp" href="https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="ko">readFile</em></strong></a>功能提供。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi mf"><img src="../Images/a906d658cbaa654daf2260ad7e224328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IoADRqU6j4oYdn1-Dbm7A.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">来自dynatrace的指标</figcaption></figure><p id="21ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">指标显示响应时间在16:00之后减少了(在部署新版本之后)。现在，大约是<strong class="js iu">100-200毫秒</strong>，这是完美的。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="bb07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我喜欢实现<strong class="js iu"> worker_threads </strong>并看到完美的结果🕺.</p><p id="8190" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我创建了一个示例应用程序来模拟它在代码上的样子。</p><div class="mn mo gp gr mp mq"><a href="https://github.com/tugayilik/node-worker-threads" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">tugayilik/节点-工作线程</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">节点的worker_threads模块的示例。为tugayilik/node-worker-threads开发做出贡献，创建一个…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne la mq"/></div></div></a></div><p id="6df4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望你读的时候喜欢！✊</p><blockquote class="nf ng nh"><p id="4f65" class="jq jr ko js b jt ju jv jw jx jy jz ka ni kc kd ke nj kg kh ki nk kk kl km kn im bi translated">请随时在linkedin上联系我。</p></blockquote></div></div>    
</body>
</html>