<html>
<head>
<title>Limit Unbound Concurrency in Go (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">限制Go中的无限制并发性(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/limit-unbound-concurrency-in-go-part-1-72f7cedf2e61?source=collection_archive---------8-----------------------#2021-12-27">https://levelup.gitconnected.com/limit-unbound-concurrency-in-go-part-1-72f7cedf2e61?source=collection_archive---------8-----------------------#2021-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e986" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Go中实现一个端口扫描器，并解释一些并发概念</h2></div><p id="02ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<strong class="kk iu">端口扫描器</strong>被设计用来探测一个<a class="ae le" href="https://en.wikipedia.org/wiki/Server_(computing)" rel="noopener ugc nofollow" target="_blank">服务器</a>或<a class="ae le" href="https://en.wikipedia.org/wiki/Host_(network)" rel="noopener ugc nofollow" target="_blank">主机</a>是否打开<a class="ae le" href="https://en.wikipedia.org/wiki/TCP_and_UDP_port" rel="noopener ugc nofollow" target="_blank">端口</a>。在这篇文章中，我们将在Go中实现一个端口扫描器，同时解释一些并发概念。</p><p id="fcad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢看相关视频，我强烈推荐你看这个视频。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">Johnny Boursiquot和Aaron Schlesinger——Go中的自由并发</figcaption></figure><h1 id="ef6e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">概述</h1><ul class=""><li id="a709" class="mi mj it kk b kl mk ko ml kr mm kv mn kz mo ld mp mq mr ms bi translated">最简单的形式</li><li id="4152" class="mi mj it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">顺序请求</li><li id="6404" class="mi mj it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">并发——错误的方式！</li><li id="b221" class="mi mj it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">同步并发</li><li id="577f" class="mi mj it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">工作池并发</li></ul><h2 id="b29d" class="my lr it bd ls mz na dn lw nb nc dp ma kr nd ne mc kv nf ng me kz nh ni mg nj bi translated">1.最简单的形式</h2><p id="2ade" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">出于演示目的，让我们首先只扫描一个端口。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nn ll l"/></div></figure><p id="fe29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe no np nq nr b">Dial</code>函数连接到端口5000上的一个可能的服务器。如果服务器不可用，它将返回一个错误并退出。但是，如果服务器可用，它将打印端口号并结束。</p><p id="b5fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Go中，拨号功能是连接到服务器的内置功能。它采用网络类型(TCP，UDP。etc)和一个字符串地址<code class="fe no np nq nr b">host:port</code>并返回一个<code class="fe no np nq nr b">net.Conn</code>。</p><p id="69cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只扫描一个端口超级简单。现在让我们添加更多的端口来处理。</p><h2 id="1907" class="my lr it bd ls mz na dn lw nb nc dp ma kr nd ne mc kv nf ng me kz nh ni mg nj bi translated">2.顺序请求</h2><p id="cdba" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">循环迭代非常适合以顺序形式处理许多端口。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nn ll l"/></div></figure><p id="79fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们使用<code class="fe no np nq nr b">for</code>关键字按顺序逐一迭代5300到5500的端口范围。</p><p id="6850" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上是我们的基本顺序端口扫描器，我们将在下面的部分中将其与并行端口扫描器进行比较。</p><h2 id="0446" class="my lr it bd ls mz na dn lw nb nc dp ma kr nd ne mc kv nf ng me kz nh ni mg nj bi translated">3.并发——错误的方式！</h2><p id="505f" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">有时候我们会写出很臭的代码，尤其是如果我们是初学程序员的话。下面的代码是一个常见的错误，需要我们注意。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nn ll l"/></div></figure><p id="1f86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主goroutine将快速退出，而不会等待派生的子go routine完成。正确的方法应该是使用某种同步机制来确保所有的goroutine在主go routine退出之前完成。</p><p id="e859" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在下一部分演示这一点。</p><h2 id="1d61" class="my lr it bd ls mz na dn lw nb nc dp ma kr nd ne mc kv nf ng me kz nh ni mg nj bi translated">4.同步并发</h2><p id="0e90" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">在这个版本的代码中，我们做了一些代码重构。首先，<code class="fe no np nq nr b">flag</code>是解析命令行参数。其次，一些论证验证是为了保证它们的正确性。最后但同样重要的是，<code class="fe no np nq nr b">WaitGroup</code>是一个内置的并发原语，允许我们等待几个goroutines完成。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nn ll l"/></div></figure><p id="4a44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键的一点是函数<code class="fe no np nq nr b">Add</code>应该在主goroutine中调用，而不是在子goroutine中。这是围棋初学者常犯的另一个错误。</p><p id="9875" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，它看起来像一个完美的扫描仪，但它不是！</p><p id="39d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让程序扫描许多端口可能会触发“打开的文件太多”错误。该错误意味着操作系统已达到最大“打开文件”限制，不允许其他正在运行的应用程序打开更多文件。</p><p id="721e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们需要限制我们产生的goroutines的数量，并限制我们可以拥有的无限并发性。</p><p id="36de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一节中，我们将使用工人池模式来实现它。</p><h2 id="78d4" class="my lr it bd ls mz na dn lw nb nc dp ma kr nd ne mc kv nf ng me kz nh ni mg nj bi translated">5.工作池并发</h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/655c2fc67f3ab05f4202c3433c343d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*m-SaTN32CJM28ZooFWafOg.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">Goroutine工人池模式</figcaption></figure><p id="1526" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个版本中，我们再次重构了代码。</p><h2 id="f6e5" class="my lr it bd ls mz na dn lw nb nc dp ma kr nd ne mc kv nf ng me kz nh ni mg nj bi translated">信号</h2><p id="d0ce" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">为了在退出之前优雅地关闭程序并打印结果，我们需要在单独的goroutine中监听信号。Go的<strong class="kk iu">信号</strong>通知通过在通道上发送<code class="fe no np nq nr b">os.Signal</code>值来工作。</p><p id="2fc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法<code class="fe no np nq nr b">signal.Notify</code>注册给定的通道来接收指定信号的通知。<code class="fe no np nq nr b">SIGINT</code>和<code class="fe no np nq nr b">SIGTERM</code>是特定的操作信号，当用户中断(如Ctrl+C)或系统终止进程时，Go运行时将发送给进程。</p><h2 id="0a51" class="my lr it bd ls mz na dn lw nb nc dp ma kr nd ne mc kv nf ng me kz nh ni mg nj bi translated">两个频道</h2><p id="6dc3" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">在本节中，我们使用一个缓冲通道和一个非缓冲通道。</p><p id="50f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe no np nq nr b">portsChan</code>是一个大小为<code class="fe no np nq nr b">numWorkers</code>的缓冲通道。它用于对要扫描的端口进行排队。worker goroutines将从该通道读取并扫描端口。当worker goroutines完成时，它们会将结果发送回<code class="fe no np nq nr b">resultsChan</code>通道。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nn ll l"/></div></figure><h1 id="c9c3" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="d9ef" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">在这篇文章中，我们从头开始构建了一个生产就绪的端口扫描器。最重要的是我们在Go中实现了一个有界并发。</p><p id="6cbc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢这篇文章😃。</p></div></div>    
</body>
</html>