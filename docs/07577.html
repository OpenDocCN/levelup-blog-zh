<html>
<head>
<title>Develop These Few Habits to Become an Outstanding Software Engineer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">养成这几个习惯，成为一名优秀的软件工程师</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/develop-these-few-habits-to-become-an-outstanding-software-engineer-8117a155af77?source=collection_archive---------11-----------------------#2021-02-24">https://levelup.gitconnected.com/develop-these-few-habits-to-become-an-outstanding-software-engineer-8117a155af77?source=collection_archive---------11-----------------------#2021-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a1b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你所需要的只是纪律。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58e95f62eb03b02f7ab08e594460feed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GFK9WRxZGZK8DZFT"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@brucemars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁斯·马斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="73f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的十年里，我和大约一百名软件工程师一起工作过。都是各有各的优缺点。</p><p id="7663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和我一起工作的软件工程师中，大约有一半是拥有良好软技能的技术人员。然而，从我的角度来看，他们中只有少数人是杰出的工程师，因为他们有效地应用了其他工程师部分或完全忽视的几种极其有用的方法。</p><p id="c201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">杰出的软件工程师经常使用这些方法，这已经成为一种习惯。做以下3件事的习惯:</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2bc3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">执行权衡分析</h1><p id="32b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">软件工程是一个庞大而复杂的话题，所以通常几乎每个问题都有几种解决方法。例如，在C#中至少有<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/5-ways-to-clone-an-object-in-c-d1374ec28efa"> 5种方法来克隆一个对象</a>或<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/5-ways-to-implement-repository-pattern-in-c-e12565e4d4a2"> 5种方法来实现一个存储库模式</a>。</p><p id="0a6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然为数不多的可用方法中的每一种都可以解决一个编码问题，但您不应该只是随机选择一种或最奇特的一种。您应该执行权衡分析，因为这是为给定问题找到最佳解决方案的唯一可靠方法。</p><p id="c9f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这在实践中是如何工作的。</p><p id="2f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您创建了两个简单的类，其中包含一些逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您面临着下一个任务——让这两个类一起工作，因为报告应该在创建后立即发送。在开始编写代码之前，您应该在这里收集完成该任务的不同方法，并进行权衡分析。</p><p id="ff4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">权衡分析是写下解决问题的所有方法并指出每种方法的利弊的过程。</p><p id="707f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">权衡分析可能是这样的:</p><p id="6530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。</strong>使用new关键字在<code class="fe nb nc nd ne b">GenerateReport</code>方法的末尾创建一个<code class="fe nb nc nd ne b">ReportSender</code>类的实例，并调用<code class="fe nb nc nd ne b">Send</code>方法。</p><p id="a2a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优点:最简单的方法，需要最少的时间来实现。</p><p id="bad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点:两个类将紧密耦合，因为<code class="fe nb nc nd ne b">new</code>关键字是粘合剂。类<code class="fe nb nc nd ne b">GenerateReport</code>不能与<code class="fe nb nc nd ne b">ReportSender.</code>分开重用，<code class="fe nb nc nd ne b">GenerateReport</code>也不能单独进行单元测试。</p><p id="1950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。</strong>使用依赖注入技术将<code class="fe nb nc nd ne b">ReportSender</code>类的接口注入到<code class="fe nb nc nd ne b">GenerateReport</code>类的构造函数中，并在<code class="fe nb nc nd ne b">Generate</code>方法的末尾调用<code class="fe nb nc nd ne b">Send</code>方法。</p><p id="a61e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优点:两个类是松散耦合的。这两个类都可以单独测试。</p><p id="d2b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点:如果应用程序除了<code class="fe nb nc nd ne b">ReportSender</code>类之外还有几十个类，这些类需要在报表创建后对其进行处理，该怎么办？<code class="fe nb nc nd ne b">GenerateReport</code>的逻辑会被一堆通知各利益方的责任污染。</p><p id="9aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。</strong>使用观察者设计模式。<code class="fe nb nc nd ne b">GenerateReport</code>类应该定义一个事件<code class="fe nb nc nd ne b">ReportGenerationCompleted</code>，每个感兴趣的对象都可以订阅该事件并做出适当的反应。</p><p id="203d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优点:订阅者列表可以在运行时更改。此外，这两个类是松散耦合的，因为<code class="fe nb nc nd ne b">GenerateReport</code>甚至不需要知道<code class="fe nb nc nd ne b">ReportSender</code>类或其接口的存在。</p><p id="b855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点:需要记得及时退订，避免内存泄露。</p><p id="154f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4。</strong>使用中介设计模式…</p><p id="32a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 5。</strong>使用事件聚合器设计模式…</p><p id="ba94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在确定了所有方法的利弊后，毫不犹豫地选择唯一的一种方法会容易得多。</p><p id="9335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定期的权衡分析会让你成为一个非常自信和有经验的软件工程师，因为这种方法需要你从不同的角度来看待问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="45ae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">考虑性能</h1><p id="01ce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">代码不仅应该工作，还应该工作得很快。这是客户在提供验收标准时可能不会告诉团队的事情，但这绝对不意味着代码运行的任何毫秒或秒数都是可以接受的。</p><p id="c8dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码通常很慢，原因如下:</p><ul class=""><li id="957a" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">选择了不适当的数据结构或算法来解决任务。</li><li id="a821" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">代码经常“修改”不可变的数据类型，所以会导致大量的分配。</li><li id="620d" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">应用程序从数据库中获取小块数据，而不是一次获取大块数据，因此性能会受到影响，因为对数据库的每次调用都是开销很大的操作。</li></ul><p id="edc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在完成编码后立即问自己，大量的性能问题可能永远不会出现在测试或生产环境中:</p><blockquote class="nt"><p id="1527" class="nu nv it bd nw nx ny nz oa ob oc lu dk translated">我的代码处理大型数据集的速度有多快？</p></blockquote><p id="7c9b" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">通常程序员使用本地数据库进行开发。本地数据库模式对应于测试或生产数据库。但是，本地的数据量可能会更少，因为在测试或生产环境中，大量数据是由许多活动用户生成的。这意味着你的代码可以一直在本地快速运行，即使是非常低效的算法。</p><p id="2bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您已经实现了检查用户是否有权访问任何内容的逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="71a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第12行的代码对于多用户可以很快工作，但是对于数百万用户，性能会差很多，因为列表数据结构只支持线性搜索。如果多次调用<code class="fe nb nc nd ne b">HasAccess</code>方法，情况会变得更糟，因为复杂度将是<strong class="lb iu"> O(n ) </strong>。</p><p id="5696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，一个解决方案是使用一个HashSet数据结构，在固定时间内执行搜索。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c9d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不要浪费时间为一个永远不会超过100个条目的集合实现一个高效的算法，因为没有人会看到性能差异。明智地管理你的时间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b7a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">编码前进行深入分析</h1><p id="c7c3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个程序员在开始写代码之前，往往需要分析很多东西。分析越全面，编写代码就越容易，代码也就越可靠。编码本身是容易的，分析是困难的。</p><p id="5a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分析阶段可以分为三个主要部分:</p><h2 id="bc75" class="oi md it bd me oj ok dn mi ol om dp mm li on oo mo lm op oq mq lq or os ms ot bi translated">分析需求</h2><p id="5463" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您应该确保票证中陈述的业务要求对您有意义。还要考虑它们的完整性，如果您觉得描述中缺少一些边缘案例，请与您的业务分析师或产品负责人交谈。</p><h2 id="8219" class="oi md it bd me oj ok dn mi ol om dp mm li on oo mo lm op oq mq lq or os ms ot bi translated">分析设计</h2><p id="739c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这个阶段，您应该决定接口、设计模式和计划功能的集成点。功能越大，在这个阶段犯错误的代价就越高。权衡分析在这里很有帮助，因为通常在设计阶段有几个选项可用，而不仅仅是一个。</p><h2 id="577f" class="oi md it bd me oj ok dn mi ol om dp mm li on oo mo lm op oq mq lq or os ms ot bi translated">分析影响区域</h2><p id="145a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对现有代码的任何更改都会破坏其他功能。这些被称为回归问题。优秀的工程师通常遵循如何通过执行影响区域的分析来最小化回归问题风险的策略。我已经在我的另一篇文章中描述了这一点:</p><div class="ou ov gp gr ow ox"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div><p id="6037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，您应该找到您将要修改的类的输出依赖项(其他类)。任何传出依赖项的行为都会受到您的更改的影响。在收集了输出依赖项之后，您应该理解它们所指的是系统的什么功能。然后将功能列表传递给QA工程师，以便他们可以对应用程序中所有可能受影响的位置执行回归测试。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="10c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="5dbd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你需要尽快完成一项任务，遵循这三种方法可能并不容易，因为它们非常耗时。但是永远要把长远放在心上。在你的日常工作中经常应用这些方法，一定会让你成为一个更强大、更有价值的软件工程师。只要养成这三个习惯，你就会受益匪浅。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="658f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">感谢阅读！你可能也想看我的其他文章:</strong></p><div class="ou ov gp gr ow ox"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-design-reusable-software-components-213e05119796"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">开发人员编写可重用代码的两个简单技巧</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">加快发展应遵循的两个基本原则</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl ks ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-avoid-the-headache-with-non-deterministic-bugs-in-software-e24457f05c9b"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">如何避免软件中令人头痛的非确定性错误</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">再现性:有时</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pg l"><div class="pn l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>