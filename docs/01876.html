<html>
<head>
<title>React Refs for Function Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对功能组件的引用做出反应</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-refs-for-function-components-44f1a5a2332a?source=collection_archive---------2-----------------------#2020-02-04">https://levelup.gitconnected.com/react-refs-for-function-components-44f1a5a2332a?source=collection_archive---------2-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/607d5da03ff3a2bca008a05b1d774854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8d-4wYLN9wwiEsLAA_5yg.jpeg"/></div></div></figure><p id="ee10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React组件表示DOM标签，这些标签组成了由<code class="fe kz la lb lc b">render</code>方法返回的UI的特定部分。对于希望在常规React生命周期之外与DOM节点交互的情况，我们可以使用refs。</p><p id="201f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我们将通过演示<code class="fe kz la lb lc b">useRef</code>和<code class="fe kz la lb lc b">createRef</code>的不同之处来回顾一个简短的例子，在这个例子中，我们需要动态地引用功能子组件中的DOM节点。</p><div class="ld le gp gr lf lg"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">编写面试问题</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">技术开发</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu jz lg"/></div></div></a></div><h1 id="f379" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated"><code class="fe kz la lb lc b">Create the ref object using useRef</code></h1><blockquote class="mt mu mv"><p id="9c2d" class="kb kc mw kd b ke kf kg kh ki kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ky im bi translated"><code class="fe kz la lb lc b"><em class="it">useRef</em></code> <em class="it">返回一个可变ref对象，其</em> <code class="fe kz la lb lc b"><em class="it">.current</em></code> <em class="it">属性初始化为传递的参数(</em> <code class="fe kz la lb lc b"><em class="it">initialValue</em></code> <em class="it">)。返回的对象将在组件的整个生存期内保持不变。—反应文件</em></p></blockquote><p id="2fa5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们声明一个父子关系，其中列表组件呈现一些不确定数量的行:</p><pre class="na nb nc nd gt ne lc nf ng aw nh bi"><span id="0476" class="ni lw it lc b gy nj nk l nl nm">// Parent: Feed<br/>// Child: FancyRow <br/>function Feed({ edges }: FeedProps): React.Element&lt;'div'&gt; {<br/>  const parentRef = useRef&lt;HTMLDivElement&gt;();<br/>  return (<br/>    &lt;div className={styles[‘feed’]}&gt;<br/>      &lt;h4 className={styles[‘feed__item-title’]}&gt;<br/>         List Container<br/>      &lt;/h4&gt;<br/>      {edges.map((edge, i) =&gt; (<br/>      &lt;<strong class="lc iu">FancyRow</strong> key={i} /&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="29ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React在制作列表时对待<code class="fe kz la lb lc b">ref</code>属性类似于对待<code class="fe kz la lb lc b">key</code>道具。在函数组件上声明<code class="fe kz la lb lc b">ref</code>属性会在控制台中触发错误。</p><pre class="na nb nc nd gt ne lc nf ng aw nh bi"><span id="ec73" class="ni lw it lc b gy nj nk l nl nm">/* Error, ref will be undefined */<br/>{edges.map((edge, i) =&gt; (<br/>   &lt;<strong class="lc iu">FancyRow</strong> <strong class="lc iu">ref</strong>={parentRef} key={i} /&gt;<br/>))}</span></pre><p id="ef6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了理解为什么会发生这种情况，回想一下React类是创建实例来保存对象状态的对象。</p><p id="8f0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，功能组件没有实例。当函数组件被重新渲染时，<code class="fe kz la lb lc b">refObject</code>将失去对DOM的引用，并且未定义。</p><h1 id="a6ca" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">备用道具</h1><p id="2692" class="pw-post-body-paragraph kb kc it kd b ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky im bi translated">我们可以通过从父级声明一个替代属性来从子级引用我们的DOM，如下所示:</p><pre class="na nb nc nd gt ne lc nf ng aw nh bi"><span id="48fc" class="ni lw it lc b gy nj nk l nl nm">// Parent<br/>{edges.map((edge, i) =&gt; (<br/>   &lt;<strong class="lc iu">FeedRow</strong> <strong class="lc iu">parentRef</strong>={parentRef} key={i} /&gt;<br/>))}</span><span id="bec3" class="ni lw it lc b gy ns nk l nl nm">// Child <br/>function <strong class="lc iu">FeedRow</strong>(props: RowProps): React.Element&lt;’div’&gt;{<br/> return (<br/>    &lt;div <strong class="lc iu">ref</strong>={<strong class="lc iu">props.parentRef</strong>} className={styles[‘feed__item’]} &gt;<br/>       &lt;div className={styles[‘feed__item-meta’]}&gt;<br/>         &lt;button&gt;Container Button&lt;/button&gt;<br/>       &lt;/div&gt;<br/>    &lt;/div&gt;<br/> );<br/>};</span></pre><p id="e935" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者，根据文档，我们可以使用<code class="fe kz la lb lc b">forwardRef</code>将引用直接“转发”到子组件。我们可以使用regular <code class="fe kz la lb lc b">ref</code>属性，并从作为regular <code class="fe kz la lb lc b">props.</code>包装在<code class="fe kz la lb lc b">forwardRef</code>中的组件中获取对其中一个子组件的引用</p><pre class="na nb nc nd gt ne lc nf ng aw nh bi"><span id="c376" class="ni lw it lc b gy nj nk l nl nm">// Parent<br/>{edges.map((edge, i) =&gt; (<br/>   &lt;<strong class="lc iu">FancyRow</strong> r<strong class="lc iu">ef</strong>={parentRef} key={i} /&gt;<br/>))}</span><span id="86a6" class="ni lw it lc b gy ns nk l nl nm">const FancyRow = React.<strong class="lc iu">forwardRef</strong>((props, ref) =&gt; <br/> &lt;FeedRow <br/>   key={props.edge} <br/>   <strong class="lc iu">parentRef</strong>={ref} <br/>   {…props} <br/> /&gt;</span><span id="a206" class="ni lw it lc b gy ns nk l nl nm">// Child <br/>function FeedRow(props: RowProps): React.Element&lt;’div’&gt;{<br/> return (<br/>    &lt;div ref={<strong class="lc iu">props.parentRef</strong>} className={styles[‘feed__item’]} &gt;<br/>       &lt;div className={styles[‘feed__item-meta’]}&gt;<br/>         &lt;button&gt;Container Button&lt;/button&gt;<br/>       &lt;/div&gt;<br/>    &lt;/div&gt;<br/> );<br/>};</span></pre><p id="262b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止，我们有一个行容器列表。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/31da58592b44277fddbb9870e1ac3073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBnncnE4ExQP4sF28WNAow.png"/></div></div></figure><p id="b9ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们进一步看看<code class="fe kz la lb lc b">useRef </code>钩子是如何引用从子进程呈现的DOM的。这里，我们从父节点创建一个点击处理程序，并将其作为常规道具传递给子节点。</p><pre class="na nb nc nd gt ne lc nf ng aw nh bi"><span id="5e89" class="ni lw it lc b gy nj nk l nl nm">function Feed({ edges }: Props): ReactNode {<br/> const <strong class="lc iu">parentRef</strong> = React.useRef();</span><span id="7cf8" class="ni lw it lc b gy ns nk l nl nm">const <strong class="lc iu">onClick</strong> = () =&gt; {<br/>   if (<strong class="lc iu">parentRef</strong>.<strong class="lc iu">current</strong>) {<br/>    <strong class="lc iu">parentRef.current.style.border = ‘5px dashed red’;</strong><br/>   }<br/> };</span><span id="6a2c" class="ni lw it lc b gy ns nk l nl nm">return (<br/>   &lt;div className={styles[‘feed’]}&gt;<br/>    &lt;h4 className={styles[‘feed__item-title’]}&gt;List Container&lt;/h4&gt;<br/>    {edges.map((edge, i) =&gt; (<br/>      &lt;FancyRow<br/>       ref={parentRef}<br/>       key={i}<br/>       parentOnClick={<strong class="lc iu">onClick</strong>}<br/>       edge={edge}/&gt;))}<br/>    &lt;/div&gt;<br/> );<br/>}</span></pre><p id="1a47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还想更新<code class="fe kz la lb lc b">FeedRow</code>并从props中附加我们的click处理程序作为按钮的事件处理程序。</p><pre class="na nb nc nd gt ne lc nf ng aw nh bi"><span id="6b77" class="ni lw it lc b gy nj nk l nl nm">const FeedRow = (props): React.Element&lt;’div’&gt; =&gt; {<br/> return (<br/>  &lt;div ref={props.parentRef} className={styles[‘feed__item’]} &gt;<br/>   &lt;div className={styles[‘feed__item-meta’]}&gt;<br/><strong class="lc iu">     &lt;button onClick={() =&gt; props.parentOnClick()}&gt;</strong><br/>       Container Button<br/>     &lt;/button&gt;<br/>   &lt;/div&gt;<br/>  &lt;/div&gt;<br/> );<br/>};</span></pre><p id="e475" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们单击列表中的任何按钮，只有最终的容器会呈现红色虚线边框。正如文档所述，由返回的对象将在组件的整个生存期内保持不变。我们对<code class="fe kz la lb lc b">FeedRow</code>的DOM节点的引用是在Feed的生命周期中设置一次<strong class="kd iu"><em class="mw"/></strong>来呈现其子元素。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/e901f4afef08d6eeda1eebbade275dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtWXpSrlqSRsjfD-tq4c4w.png"/></div></div></figure><h1 id="a816" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated"><code class="fe kz la lb lc b">Create the ref object using createRef</code></h1><p id="d25a" class="pw-post-body-paragraph kb kc it kd b ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky im bi translated">与<code class="fe kz la lb lc b">useRef</code>不同的是，<code class="fe kz la lb lc b">createRef</code>不会将引用实例保存到子对象的DOM中，并且<em class="mw">总是会</em>创建一个新的引用。</p><p id="d367" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在基于数据动态呈现子元素的应用程序中，我们希望在初始呈现时为每个子元素分配新的ref对象。我们可以在当地的<code class="fe kz la lb lc b">Feed</code>州存储一个参考列表</p><pre class="na nb nc nd gt ne lc nf ng aw nh bi"><span id="b39e" class="ni lw it lc b gy nj nk l nl nm">const [elements] = <strong class="lc iu">useState</strong>&lt;Array&lt;HTMLDivElement&gt;&gt;(<br/>    Array(edges.length)<br/>    .fill(0)<br/>    .map(() =&gt; React.createRefuseState&lt;Array&lt;?HTMLDivElement&gt;&gt;())<br/>);</span></pre><p id="aebe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重新访问我们的顶级父组件，在映射数据时，我们向引用数组传递一个索引值。</p><pre class="na nb nc nd gt ne lc nf ng aw nh bi"><span id="bdd9" class="ni lw it lc b gy nj nk l nl nm">// Parent</span><span id="d200" class="ni lw it lc b gy ns nk l nl nm">const onClick = (rowIndex: number): void =&gt; {<br/>    if (elements[rowIndex]) {<br/>      elements[rowIndex].current.style.border = '5px dashed red';<br/>    }<br/>};<br/>...<br/>{edges.map((edge, <strong class="lc iu">i</strong>) =&gt; (<br/>    &lt;FancyRow<br/>       rowIndex={i}<br/><strong class="lc iu">       ref={elements[i]}</strong><br/>       key={i}<br/>       parentOnClick={onClick}<br/>       edge={edge}&gt;<br/>    &lt;/FancyRow&gt;))}</span></pre><p id="cc6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过将index prop从子组件作为参数传递给click handler函数，我们可以获得正确的DOM引用:</p><pre class="na nb nc nd gt ne lc nf ng aw nh bi"><span id="beef" class="ni lw it lc b gy nj nk l nl nm">const FeedRow = (props): Element&lt;’div’&gt; =&gt; {</span><span id="0e16" class="ni lw it lc b gy ns nk l nl nm"> return (<br/>    &lt;div ref={props.parentRef} className={styles[‘feed__item’]} &gt;<br/>      &lt;div className={styles[‘feed__item-meta’]}&gt;<br/>       &lt;button onClick={() =&gt;                  <br/>           props.parentOnClick(props.rowIndex)}&gt;<br/>          Container Button&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;);<br/>};</span></pre><p id="98b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在你知道了。使用这种模式动态地将refs分配给子节点，以便引用它们的DOM节点。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/e982367e5691a8506084dcfa78659716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqgTfoVNYSG1ErH6fDi6fw.png"/></div></div></figure><p id="9c5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！</p><h2 id="4d5b" class="ni lw it bd lx nv nw dn mb nx ny dp mf km nz oa mj kq ob oc mn ku od oe mr of bi translated">来源</h2><div class="ld le gp gr lf lg"><a href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">转发参考-反应</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">引用转发是一种通过组件将引用自动传递给其子组件的技术。这是…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">reactjs.org</p></div></div><div class="lp l"><div class="og l lr ls lt lp lu jz lg"/></div></div></a></div><div class="ld le gp gr lf lg"><a href="https://www.robinwieruch.de/react-function-component#react-function-component-lifecycle" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">反应功能部件- RWieruch</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">React功能组件-也称为React功能组件-是编写现代React的现状…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">www.robinwieruch.de</p></div></div><div class="lp l"><div class="oh l lr ls lt lp lu jz lg"/></div></div></a></div><div class="ld le gp gr lf lg"><a href="https://reactenlightenment.com/basic-react-components/6.4.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">6.4引用组件实例</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">当一个组件被渲染时，一个React组件实例从传递的配置选项中被创建。一个人可以…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">reactenlightenment.com</p></div></div></div></a></div><div class="ld le gp gr lf lg"><a href="https://zhenyong.github.io/react/docs/more-about-refs.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">对组件的引用|反应</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">在GitHub上编辑构建完组件后，您可能会发现自己想要“伸出手”并调用…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">zhenyong.github.io</p></div></div></div></a></div></div></div>    
</body>
</html>