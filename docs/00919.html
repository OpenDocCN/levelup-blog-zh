<html>
<head>
<title>Hunting memory leaks in a server side rendered React application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在服务器端渲染的React应用程序中寻找内存泄漏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/hunting-memory-leaks-in-server-side-rendered-react-application-311c6306d552?source=collection_archive---------1-----------------------#2019-09-17">https://levelup.gitconnected.com/hunting-memory-leaks-in-server-side-rendered-react-application-311c6306d552?source=collection_archive---------1-----------------------#2019-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d899" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您在React应用程序中使用服务器端呈现(SSR ),那么您肯定有时会遇到一些问题。即使你选择像Next.js这样有大公司支持的工具，当你遇到问题时，总会有特定的情况。</p><h1 id="db58" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">TL；dr；</h1><ol class=""><li id="2ce5" class="lm ln it js b jt lo jx lp kb lq kf lr kj ls kn lt lu lv lw bi translated">做你的编译只是用巴别塔针对NodeJS环境</li><li id="0ae0" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated">使用度量标准，例如Prometheus with Grafana，来确定是否发生了任何内存泄漏</li><li id="e074" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated">如果出现问题，使用<code class="fe mc md me mf b">kill -USR1 PID</code>开始检查正在运行的NodeJS进程</li><li id="6e4b" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated">就在开始使用Chromes DevTools进行分析之后</li><li id="6c31" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated">我们的内存泄漏是由<em class="mg">重选</em>和<em class="mg">样式组件使用不当引起的，</em>两个问题都是使用<em class="mg"> </em> Chrome DevTools发现的</li></ol><h1 id="9e2d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">背景</h1><p id="0315" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我们正在处理一个环境，在这个环境中，我们应该在NodeJS服务器端渲染应用程序(称之为Renderer)的一个pod上每秒处理5次渲染。使用我们的渲染器的26个pod，它每分钟发出7800个请求。</p><p id="a8fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的例子中，当我完成一个大的整体应用程序(称之为APP)的重构时，出现了内存泄漏，这个应用程序也包括我们的渲染器，并在生产中对它进行了测试，比如请求加载。</p><p id="077f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重构包括构建流程更新、过时库的升级，以及将一些包从应用中分离出来。</p><p id="3909" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mg">当我使用</em> <strong class="js iu"> <em class="mg">库</em> </strong> <em class="mg">时，我指的是npm包/库，当我使用</em> <strong class="js iu"> <em class="mg">包</em> </strong> <em class="mg">时，我指的是monorepo中的包/库。</em></p><h2 id="620f" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">为什么要重构？</h2><p id="61f5" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">该应用程序使用了一个yarn workspaces设置，这往往是一个monorepo设置，但问题是该应用程序的包有如此深的耦合，实际上它是一个整体。作为蛋糕上的樱桃，有很多过时的库，所以开始重构已经足够了。</p><h1 id="c3e7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">我们的旧渲染器</h1><p id="fb86" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我们的NodeJS应用程序— Renderer是用Typescript编写的。这就是为什么<strong class="js iu">有</strong>一个Webpack + Babel设置来生成针对节点和浏览器环境的包。</p><p id="7925" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着在创建包之后，我们最终会有两个代码库。一个包括NodeJS服务器的代码和服务器端呈现的客户端应用程序的代码。第二个仅包括加载到浏览器中的客户端应用程序的代码。</p><p id="22dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客户端React应用程序是在ASP.NET编写的一个更大的应用程序(称之为包装应用程序)的一部分，因此服务器端呈现的代码由包装应用程序处理。此外，我们的渲染器仅用于渲染特定的React组件，而不是整个应用程序。因为这个原因，我们<strong class="js iu">使用<code class="fe mc md me mf b">react-dom/server</code>的<code class="fe mc md me mf b">renderToString()</code>和<code class="fe mc md me mf b">react-apollo</code>的<code class="fe mc md me mf b">getDataFromTree()</code>。我还提到，对于支持服务器端渲染的代码分割，我们使用了<code class="fe mc md me mf b">react-loadable</code>。</strong></p><h1 id="e9be" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">监控工具</h1><p id="c11a" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">除了以下工具，我们没有任何用于内存泄漏检测的工具。</p><p id="57d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的渲染器中，我们使用<strong class="js iu"> Prometheus </strong>来收集监控数据，使用<strong class="js iu"> Grafana </strong>来可视化它们。此外，还有记录到<strong class="js iu"> Elasticsearch </strong>和由<strong class="js iu"> Kibana </strong>可视化。</p><p id="b174" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在<strong class="js iu"> Grafana </strong>的帮助下注意到了内存泄漏，其中<strong class="js iu"> </strong>我们可视化了以下指标:</p><ul class=""><li id="f0e1" class="lm ln it js b jt ju jx jy kb mw kf mx kj my kn mz lu lv lw bi translated">垃圾收集器暂停(nodejs_gc_pause_seconds_total)</li><li id="486a" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">垃圾收集器每秒运行次数(nodejs_gc_runs_total)</li><li id="ff3a" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">垃圾收集器回收的字节数(nodejs _ GC _ recreated _ bytes _ total)</li><li id="9014" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">堆大小(节点堆大小总计字节)</li><li id="bb6b" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">旧的和新的堆空间大小—(节点_堆_空间_大小_总字节数)</li><li id="6bee" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">大对象堆空间大小—(nodejs _ heap _ space _ size _ total _ bytes)</li><li id="fa3f" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">外部存储器使用(nodejs_external_memory_bytes)</li><li id="36b2" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">进程驻留内存使用量(进程驻留内存字节)</li><li id="32f1" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">cpu使用率(进程_ cpu _秒数_总数)</li><li id="126d" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">活动请求总数(nodejs_active_requests_total)</li><li id="6a0f" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">活动处理程序总数(nodejs_active_handles_total)</li><li id="a3f8" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">事件循环滞后持续时间(nodejs_eventloop_lag_seconds)</li></ul></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="06af" class="ko kp it bd kq kr nh kt ku kv ni kx ky kz nj lb lc ld nk lf lg lh nl lj lk ll bi translated">NodeJS应用程序中什么会导致内存泄漏？</h1><h2 id="6120" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">全局变量</h2><p id="4234" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">它们会一直留在内存中，直到应用程序停止。这就是为什么在它们中设置大量数据是危险的。</p><h2 id="c6a0" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">多重引用</h2><p id="87d1" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">这也是很危险的，因为你最终会有很多对同一个对象的引用，而这些引用不能被垃圾收集，并且会增加你的堆的大小。</p><h2 id="b51e" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">关闭</h2><p id="0d72" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">它也有类似的问题，比如多重引用。您正在使用闭包来保存一些对象上的引用，以便以后使用。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="cf2c" class="ko kp it bd kq kr nh kt ku kv ni kx ky kz nj lb lc ld nk lf lg lh nl lj lk ll bi translated">意识到</h1><div class="nm nn no np gt ab cb"><figure class="nq nr ns nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><img src="../Images/ec55d0617033a1388fdd56b9e4794514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*0ZaSp-Th_PGfb4o6R0zaag.png"/></div></figure><figure class="nq nr od nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><img src="../Images/d03f832ab37d3073201cf2c72044e058.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*htq_erXxmwb55qRAJ0OCOA.png"/></div></figure></div><figure class="nm nn no np gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi oe"><img src="../Images/59dc274fc30eb804eeb163b325519cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dvtm7d63HZ7DXaPcZLDrlQ.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">绿色:新的堆空间大小；黄色:旧堆空间大小；</figcaption></figure><div class="nm nn no np gt ab cb"><figure class="nq nr oj nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><img src="../Images/2ccfcab7129224b1c0e2a3ca9d2ce365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*ygGTwILm6NBqIVuayGOidg.png"/></div></figure><figure class="nq nr ok nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><img src="../Images/5475740d9fe49ce713ea57d199c6fb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*bYmN_OJJSkrT1e8NepAyKA.png"/></div></figure></div><figure class="nm nn no np gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi ol"><img src="../Images/b4e80f8ec535504de696728e176c252b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3RaW0KFTvC_iH5zbaifFQ.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">renderToString()持续时间的95%</figcaption></figure><p id="4b39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切都很好，直到重构的应用程序用类似生产的请求负载进行了测试。</p><p id="7c03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您在上面的图表中看到的，过了一会儿，大对象堆被填满了，因此应用程序重新启动。NodeJS应用程序的内存限制是1,4 GB。只不过<strong class="js iu"> <em class="mg"> renderToString() </em> </strong>方法持续时间从<strong class="js iu"> <em class="mg"> react-dom/server </em> </strong>从几十/几百ms增加到几秒。此外，GC运行/秒增加，通常Scavange低于5次/秒。</p><p id="da3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">认识到这一点后，我们开始思考可能的解决方案。过去，我们在库升级后会面临类似的问题，所以这是一个起点。不幸的是，当时没有空间来解决这些问题，所以我们只是降级那些库。</p><p id="6c0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了库升级，我们还增加了一些新的库，并开始在一些场景中使用React Context API。</p><p id="804d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是获得升级的重要软件包列表:</p><ul class=""><li id="815f" class="lm ln it js b jt ju jx jy kb mw kf mx kj my kn mz lu lv lw bi translated">graphql</li><li id="7289" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">反应-阿波罗</li><li id="199d" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">阿波罗客户端</li><li id="94f7" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">阿波罗缓存内存</li><li id="88de" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">样式组件</li><li id="3af0" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">反应</li><li id="1ced" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">nodejs</li><li id="58a9" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">网络包</li><li id="9310" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">巴别塔</li><li id="b56f" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated">以打字打的文件</li></ul><p id="c3fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，我们添加了<a class="ae om" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">重新选择</strong> </a> <strong class="js iu"> </strong>来记忆<a class="ae om" href="https://www.apollographql.com/docs/react/api/react-apollo/#graphqlquery-configcomponent" rel="noopener ugc nofollow" target="_blank"><em class="mg">graph QL()</em></a><em class="mg"/>HOC。Reselect是一个通用的记忆库，所以它似乎是一个不错的选择，因为每当组件树中更高的某个组件被重新渲染时，<a class="ae om" href="https://www.apollographql.com/docs/react/api/react-apollo/#graphqlquery-configcomponent" rel="noopener ugc nofollow" target="_blank"><em class="mg">grapqhl()</em></a>HOC会返回一个新的对props的引用，所以即使使用<em class="mg"> React。我们无法消除不必要的重新渲染。</em></p><p id="97bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对了，这个问题用reselect与<a class="ae om" href="https://github.com/apollographql/react-apollo" rel="noopener ugc nofollow" target="_blank"> react-apollo </a>之间也出现了reselect的github问题<a class="ae om" href="https://github.com/reduxjs/reselect/issues/334" rel="noopener ugc nofollow" target="_blank">https://github.com/reduxjs/reselect/issues/334问题</a>。</p><p id="a4f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在有趣的部分:)</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="8412" class="ko kp it bd kq kr nh kt ku kv ni kx ky kz nj lb lc ld nk lf lg lh nl lj lk ll bi translated">如何发现内存泄漏？</h1><h2 id="4b03" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">1.模拟请求负载</h2><p id="a8de" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">作为开始，我用<em class="mg">t shark</em>(<a class="ae om" href="https://www.wireshark.org/docs/man-pages/tshark.html" rel="noopener ugc nofollow" target="_blank">https://www.wireshark.org/docs/man-pages/tshark.html</a>)从生产服务器收集了一些网络流量，并将其保存为CSV友好格式(逗号分隔值)。</p><p id="96c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mc md me mf b">tshark -T fields -E separator=,</code></p><blockquote class="on oo op"><p id="e139" class="jq jr mg js b jt ju jv jw jx jy jz ka oq kc kd ke or kg kh ki os kk kl km kn im bi translated">TShark是一个网络协议分析器。它允许您从实时网络中捕获数据包数据。</p></blockquote><p id="9515" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">稍加编辑后，我在<em class="mg"> tshark.csv </em>中得到如下格式:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="ba4d" class="mk kp it mf b gy ox oy l oz pa">http.request.uri,http.accept_language<br/>/our/specific/url,en-GB<br/>/our/other/specific/url,it-IT</span></pre><p id="eec2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我获得了在我们的测试环境中模拟类似生产的请求负载的所有数据。为此，我使用了<em class="mg">超级基准测试器</em>(<a class="ae om" href="https://github.com/aliostad/SuperBenchmarker" rel="noopener ugc nofollow" target="_blank">https://github.com/aliostad/SuperBenchmarker</a>)。</p><p id="352c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">超级基准标记的设置使用了<em class="mg"> sbtemplate.txt </em>文件:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="d354" class="mk kp it mf b gy ox oy l oz pa">Accept-Language: {{{http.accept_language}}}</span></pre><p id="387e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一个命令是:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="ba8b" class="mk kp it mf b gy ox oy l oz pa">sb -u "https://our-test-url-adress.tst{{{http.request.uri}}}" -c 50 -t sbtemplate.txt -f tshark1.csv -U -n 10000000 -y 10</span></pre><p id="dd83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，我在地址<a class="ae om" href="https://our-test-url-adress.tst{{{http.request.uri}}}" rel="noopener ugc nofollow" target="_blank"><em class="mg">https://our-test-URL-adress . tst { { { http . request . uri } } }</em></a><em class="mg"/>上启动了50个并发请求10000000次，其中<em class="mg"> {{{http.request.uri}}} </em>表示来自我们的<em class="mg"> tshark.csv </em>的第一列，第二列用于发送<em class="mg"/></p><h2 id="f170" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">2.删除Webpack</h2><p id="ebea" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">Webpack 在生产模式下做什么？捆绑模块并缩减代码。如果我喜欢有用的数据，这不是一个选项。这就是为什么我只能用<em class="mg">巴别塔</em>进行编译。</p><p id="f694" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在此期间，我面临三个问题:</p><p id="4ef4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Yarn工作空间monorepo中的符号链接</strong></p><p id="1c57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在不同的包被编译后，模块导入到我们的符号链接包中，并保持不变。</p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="2718" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些路径指向我们未编译的代码库(在<em class="mg"> node_modules </em>中的符号链接)，因为webpack加载器加载了这些文件并从它们创建了一个包，所以不需要做任何进一步的设置。</p><p id="5eb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想用“最简单”的方式解决这个问题，所以我创建了一个简单的babel插件，它根据输入数据将导入模块的路径更改为绝对路径。</p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="d988" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">导入图像</strong></p><p id="3080" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然<em class="mg"> Webpack </em>有用于导入图像或从中创建base64格式的加载器，但不幸的是我们的默认babel设置什么也没有。有几个巴别塔插件可以帮助你，但是我已经在创建插件了，所以我又创建了一个。这会根据输入数据将图像导入更改为值为空字符串的常量，在本例中为扩展名:</p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="548c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">导入<em class="mg">。graphql </em>文件</strong></p><p id="dd85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我面临的最后一个问题是导入<em class="mg"> graphql </em>文件。我认为我已经创建了足够多的巴别塔插件，所以我简单地使用了<em class="mg">graph QL-import-node</em>(<a class="ae om" href="https://www.npmjs.com/package/graphql-import-node" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/graphql-import-node</a>)库。</p><p id="c703" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">定稿</strong></p><p id="7809" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了编译，我使用<em class="mg">@ babel/CLI</em>(<a class="ae om" href="https://www.npmjs.com/package/@babel/cli" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/@babel/cli</a>)在<em class="mg"> package.json </em>中创建了一些脚本。</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="a45c" class="mk kp it mf b gy ox oy l oz pa">rimraf babel-build/myPackage &amp;&amp; babel ./packages/myPackage --out-dir ./babel-build/myPackage --config-file ./babel.js --copy-files</span></pre><p id="28f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mc md me mf b">--copy-files</code>参数用于复制所有未编译的文件(如<em class="mg">)。json </em>等。)<a class="ae om" href="https://babeljs.io/docs/en/babel-cli#copy-files" rel="noopener ugc nofollow" target="_blank">https://babeljs.io/docs/en/babel-cli#copy-files</a>。</p><p id="7745" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我就可以启动服务器了:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="ebc6" class="mk kp it mf b gy ox oy l oz pa">node babel-build/myPackage</span></pre><h2 id="32c3" class="mk kp it bd kq ml mm dn ku mn mo dp ky kb mp mq lc kf mr ms lg kj mt mu lk mv bi translated">3.谷歌chrome开发工具</h2><p id="341c" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我们的环境在Kubernetes上，所以我为命令行(bash)准备了一些方便的别名。</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="0dfb" class="mk kp it mf b gy ox oy l oz pa">kube ()<br/>{<br/>  if [ "$1" == "cc" ]<br/>  then<br/>      kubectl config current-context "${@:2}"<br/>  elif [ "$1" == "gc" ]<br/>  then<br/>      kubectl config get-contexts "${@:2}"<br/>  elif [ "$1" == "uc" ]<br/>  then<br/>      kubectl config use-context "${@:2}"<br/>  elif [ "$1" == "sn" ]<br/>  then<br/>      kubectl config set-context --current --namespace="${@:2}"<br/>  elif [ "$1" == "pf" ]<br/>  then<br/>      kubectl port-forward "$2" 9229 9229<br/>  elif [ "$1" == "bash" ]<br/>  then<br/>      kubectl exec -i -t "$2" -- ash<br/>  elif [ "$1" == "gp" ]<br/>  then<br/>      kubectl get pods -o wide | grep "${@:2}"<br/>  else<br/>      kubectl "${@:1}"<br/>  fi<br/>}</span></pre><p id="ab56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mg">你可以注意到，在</em> <code class="fe mc md me mf b"><em class="mg">bash</em></code> <em class="mg">别名中我们使用的是</em> <code class="fe mc md me mf b"><em class="mg">ash</em></code> <em class="mg">，其原因是主Docker镜像是建立在Alpine Linux之上的。</em></p><p id="78a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mc md me mf b">kube</code> bash函数是<em class="mg"> kubectl的别名。</em>如果在任何一个<em class="mg"> if子句</em>中没有匹配，它将使用给定的参数执行<em class="mg"> kubectl </em>。</p><p id="b86d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么用法是:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="d1bb" class="mk kp it mf b gy ox oy l oz pa">kube cc|gc|uc|sn|pf|bash|gp [...args]</span></pre><p id="2121" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如何检查正在运行的NodeJS进程</strong></p><p id="8d13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我不想改变Docker映像，也不想重启Kubernetes中的任何pod，所以我能做的就是连接到一个特定的pod，找到我正在运行的节点进程的PID，并向它发送一个信号。<em class="mg">在我们的例子中，PID是1。</em></p><p id="d58d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用以下方式列出我的pod:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="2511" class="mk kp it mf b gy ox oy l oz pa">kube gp myPodsName</span></pre><p id="a9ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我有了自己的pod名称，比如说<code class="fe mc md me mf b">mySpecificPodName</code>，所以我可以连接到它:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="8b5c" class="mk kp it mf b gy ox oy l oz pa">kube bash <!-- -->mySpecificPodName</span></pre><p id="5dca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我终于可以施展魔法了:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="9bd8" class="mk kp it mf b gy ox oy l oz pa">kill -s SIGUSR1 1</span></pre><p id="85aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我做了什么？</strong></p><p id="8016" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从文档<a class="ae om" href="https://nodejs.org/en/docs/guides/debugging-getting-started/" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/en/docs/guides/debugging-getting-started/</a></p><blockquote class="on oo op"><p id="985a" class="jq jr mg js b jt ju jv jw jx jy jz ka oq kc kd ke or kg kh ki os kk kl km kn im bi translated">如果Node.js收到一个<code class="fe mc md me mf b">SIGUSR1</code>信号，它也将开始监听调试消息。(<code class="fe mc md me mf b">SIGUSR1</code>在Windows上不可用。)在Node.js 7和更早版本中，这将激活遗留调试器API。在Node.js 8及更高版本中，它将激活检查器API。</p></blockquote><p id="77a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，对于类似Unix的环境，我可以做到以下几点:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="91bf" class="mk kp it mf b gy ox oy l oz pa">kill -s SIGUSR1 PID<br/># or<br/>kill -USR1 PID</span></pre><p id="1f91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于Windows用户，您需要在新的命令行中使用以下命令启动另一个进程:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="4168" class="mk kp it mf b gy ox oy l oz pa">node -e "process._debugProcess(PID)"</span></pre><p id="195e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这两种环境中，这将向NodeJS进程发出信号，开始检查。</p><p id="28b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如何将开发工具连接到正在运行的NodeJS进程</strong></p><p id="ccc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前，我有一个正在运行的NodeJS进程，它处于inspect模式。接下来呢？</p><p id="a89f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从NodeJS文档中，我知道在inspect模式下，NodeJS进程监听端口<strong class="js iu"> 9229 </strong>上的调试客户端。因此，我需要使用以下命令将该端口转发到我的本地计算机:</p><pre class="nm nn no np gt ot mf ou ov aw ow bi"><span id="36f2" class="mk kp it mf b gy ox oy l oz pa">kube pf <!-- -->mySpecificPodName</span></pre><p id="f8f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我可以在本地机器上打开我的Chrome并输入<code class="fe mc md me mf b">chrome://inspect</code>:</p><figure class="nm nn no np gt nr gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/f45690b2e0e74a0cf06dc19049480d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*GwSnv3x5yY15I3r3rNW5Og.png"/></div></figure><p id="01b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在此页面上，我需要单击以打开节点的专用DecTools:</p><figure class="nm nn no np gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi pe"><img src="../Images/4c1e8a850a9e7e320007276b5ba1c758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6tgHa_i-IwIX8AKLlQxvw.png"/></div></div></figure><p id="0e55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我的DevTools for NodeJS应该会打开。</p><figure class="nm nn no np gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi pf"><img src="../Images/e8f4f6892b3bdbe88c138f2d45311b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0J460aYvXZNBicoVm4Smg.png"/></div></div></figure><p id="fc5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我已经拥有了检测内存泄漏所需的一切。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="ab80" class="ko kp it bd kq kr nh kt ku kv ni kx ky kz nj lb lc ld nk lf lg lh nl lj lk ll bi translated">我们内存泄漏的原因是什么？</h1><p id="74c7" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">T2将引用保存在一个全局变量中，所以我移除了整个库。这个漏洞是由时间线上<em class="mg">内存</em>标签下的<em class="mg">分配工具发现的。<em class="mg">很遗憾，我没有保存个人资料。</em></em></p><figure class="nm nn no np gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi pg"><img src="../Images/037121cc10ee8e70086b0a7a4f3d7fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgF-eUq1IjDnGZ9h3QdZow.png"/></div></div></figure><p id="d721" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论如何，我们遇到的最大问题是<strong class="js iu">风格的组件v5 </strong> <em class="mg">(撰写本文时是beta 8)</em>。<em class="mg">当时我还不知道是styled-components使用不良导致的，而不是包本身。</em></p><p id="8fee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">大对象堆</strong>增加了很多，所以我在时间线上使用了<em class="mg">分配工具。</em>使用这种仪器，我得到了以下结果:</p><figure class="nm nn no np gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi ph"><img src="../Images/62d80c7ac60498f30219f3b5e24f809f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_L6UrPC2frJPkcWHAB0tw.png"/></div></div></figure><p id="cab2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">展开<em class="mg">样式表</em>后，我明确知道它连接到了<strong class="js iu">样式组件</strong>。</p><figure class="nm nn no np gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi pi"><img src="../Images/1adcad026c4a5674ab677d163d1eecb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7DQCJ140E5hr8U1-a93IA.png"/></div></div></figure><p id="5d73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以看到问题是由于<strong class="js iu"> <em class="mg"> Uint32Array </em> </strong>使用的一个<strong class="js iu"> <em class="mg"> ArrayBuffer </em> </strong>分配内存过多造成的。所以我钻研了<em class="mg">样式组件</em>源代码，找到了<em class="mg">组大小的代码。</em>它位于<em class="mg">styled-components/src/sheet/grouped tag . js中，</em>具体在<em class="mg"/><strong class="js iu"><em class="mg">insert rules</em></strong><em class="mg"/>方法<em class="mg"/><strong class="js iu"><em class="mg">defaultgrouped tag</em><em class="mg"/>类<em class="mg">中。</em></strong></p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="f4ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重要的部分如下:</p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="3fe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们可以看到<strong class="js iu">uint 32阵列的用法。</strong>如果您正在从旧的<strong class="js iu">uint 32阵列</strong>设置新的<strong class="js iu">uint 32阵列</strong>，内部<strong class="js iu">阵列缓冲器</strong>在它们之间共享。<em class="mg">你可以在</em><a class="ae om" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set#Parameters" rel="noopener ugc nofollow" target="_blank"><em class="mg">MDN web docs</em></a><em class="mg">上找到这个信息。</em></p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pj pc l"/></div></figure><p id="3317" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为这是导致问题的原因，因为在SSR期间多次调用了<em class="mg"> insertRule() </em>方法，所以在高请求负载下，它会非常快地分配所有内存。</p><p id="c4c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我提出了以下解决方案:</p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="7690" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在这里所做的神奇之处在于，我将元素从<em class="mg"> groupSizes </em>复制到一个新的空数组中，因此原始类型化数组中的内部<em class="mg"> ArrayBuffer </em>不再共享。太好了，我可以继续用高请求负载测试我的解决方案。</p><p id="9eee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，这还不够。在<strong class="js iu">大对象空间</strong>中高分配的问题消失了，但是<strong class="js iu">进程RSS </strong>(常驻集大小)和<strong class="js iu">外部存储器</strong>的使用开始增加。为了揭示原因，我使用了CPU profiler:</p><figure class="nm nn no np gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi pk"><img src="../Images/ba6b969512606f0bd04300d7ae0026b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KYzlLk_VSn-Nd19_E_Hqeg.png"/></div></div></figure><p id="5e66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我记录了应用程序启动时的CPU配置文件。我们可以看到在<em class="mg"> ServerStyleSheet内部调用了<em class="mg"> toString </em>方法。_emitSheetCSS </em>耗时3.4毫秒完成。</p><figure class="nm nn no np gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi pl"><img src="../Images/faefa71ffe47b9b690b16a2497aa82a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dt0NmDyIpDvOrePP1oxZ8g.png"/></div></div></figure><p id="b42d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">过了一会儿(可能15分钟)在生产负载下，我注意到同样的方法用了1.97秒。在分离舱死亡前大约6秒钟。搞什么鬼？！</p><figure class="nm nn no np gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi pm"><img src="../Images/48ced242be9b02859112ccef398e85dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zfGIaJXYKaw9umQPl7RPQ.png"/></div></div></figure><p id="d7da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我再次挖掘源代码。在文件<em class="mg">styled-components/src/sheet/groupid allocator . js</em>中，我发现他们正在创建<strong class="js iu">全局变量</strong> <em class="mg"> groupIDRegister </em>和<em class="mg"> reverseRegister: </em></p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="b549" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们在源代码中也有这些变量的复位功能:</p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="995f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是这个函数只在测试工具中使用。这意味着在最后一个包中它被弹出，所以我们不能使用它。</p><p id="4cfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能认为这可以通过在公共API中重新导出该函数来轻松解决，或者在<em class="mg"> ServerStyleSheet </em>类中使用它来重置这些全局变量，但是这一步只会导致另一个问题。</p><p id="7a92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象一下，你有一个全局变量，在每次SSR之后，你将重置这个变量。除非有并发请求，否则这不是问题。</p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pn pc l"/></div></figure><p id="5d05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于并发请求，当另一个请求使用这些全局变量时，您可以重置这些全局变量。在这种情况下，您只是生成了部分样式，所以您最终在浏览器中没有样式。</p><p id="9edb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可能的解决方案是为每个请求确保这些变量的一个新实例。您可以通过用类包装这些变量并在SSR完成后重置它们来实现这一点。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="25ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在理论解决方案之后，我创建了两个Github问题，以真正了解发生了什么并寻求帮助:</p><ul class=""><li id="324c" class="lm ln it js b jt ju jx jy kb mw kf mx kj my kn mz lu lv lw bi translated"><a class="ae om" href="https://github.com/styled-components/styled-components/issues/2753" rel="noopener ugc nofollow" target="_blank">https://github . com/styled-components/styled-components/issues/2753</a></li><li id="1ac9" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn mz lu lv lw bi translated"><a class="ae om" href="https://github.com/styled-components/styled-components/issues/2754" rel="noopener ugc nofollow" target="_blank">https://github . com/styled-components/styled-components/issues/2754</a></li></ul><p id="e333" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我得到的回答指出，问题可能出在我们的代码中，尤其是动态创建样式化组件的时候。在下一次迭代中，我和我的队友深入我们的代码来检测这些用例。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="d26c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在从版本3.2.3迁移到版本5 beta 8的过程中，我们的团队成员将<strong class="js iu"> css </strong>组件添加到了样式化组件内部使用的几乎每个回调中。</p><p id="d0b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像下面这样:</p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="a91c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为<em class="mg"> styled-components </em>文档中的以下句子:</p><blockquote class="on oo op"><p id="3a7c" class="jq jr mg js b jt ju jv jw jx jy jz ka oq kc kd ke or kg kh ki os kk kl km kn im bi translated">如果您将样式规则作为一个部分来编写，请确保使用css帮助器。</p></blockquote><p id="1bb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，我们忽略了这个指令与新的<strong class="js iu">关键帧</strong> API的联系。哎呀:)。</p><p id="fbe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还发现，在某些地方，我们在React组件的渲染中动态创建样式化的组件，如下所示:</p><figure class="nm nn no np gt nr"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="6152" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，所以在我们修改了样式组件的用法并降级到稳定版本(v4)后，所有的问题都消失了。</p><figure class="nm nn no np gt nr gh gi paragraph-image"><div class="gh gi po"><img src="../Images/77c7a2f98f134977a64a8b7661e599ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*-JxlyFqt_dEr9p3F.jpg"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><a class="ae om" href="https://imgflip.com/i/3bjm5c" rel="noopener ugc nofollow" target="_blank">https://imgflip.com/i/3bjm5c</a></figcaption></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="4d42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常感谢你的阅读！</p></div></div>    
</body>
</html>