<html>
<head>
<title>RxJava: Connecting network calls made easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJava:轻松连接网络呼叫</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rxjava-connecting-network-calls-made-easy-d7b406c9bc66?source=collection_archive---------0-----------------------#2019-06-27">https://levelup.gitconnected.com/rxjava-connecting-network-calls-made-easy-d7b406c9bc66?source=collection_archive---------0-----------------------#2019-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/462bceb17f2059dcbe9fba2c8ae51d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8b77GxYVyk9Hd4oDtsNbw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约翰·巴克利在<a class="ae kf" href="https://unsplash.com/photos/l090uFWoPaI" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的图片</figcaption></figure><p id="4d62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我在<a class="ae kf" href="https://medium.com/@elye.project/rxjava-2-making-threading-easy-in-android-in-kotlin-603d8342d6c" rel="noopener">之前的博客</a>中提到的，RxJava让线程化变得简单。让我再分享一个RxJava的好处——连接网络也容易多了。</p><p id="7e88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是3个场景。</p><h1 id="0eef" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">1.依赖于另一个的网络调用:平面图</h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/cde6b4868f79c1eb29e9b6a2aea2221e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h51wC6f9-Lysn09LUCpOZA.png"/></div></div></figure><p id="bd78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在各种情况下，您都需要如图所示的链接。例如，从URL获取站点，然后使用URL执行另一个获取，然后获取访问令牌，并将其提供给第二个网络获取，等等。</p><p id="e477" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用接线员呼叫<code class="fe mh mi mj mk b">flatMap</code></p><pre class="md me mf mg gt ml mk mm mn aw mo bi"><span id="e6bb" class="mp lf it mk b gy mq mr l ms mt">val disposable = firstNetworkCall()<br/>    .<strong class="mk iu">flatMap{ </strong>secondNetworkCall(<strong class="mk iu">it</strong>) <strong class="mk iu">}<br/>    </strong>.subscribeOn(Schedulers.io())<br/>    .observeOn(AndroidSchedulers.mainThread())<br/><strong class="mk iu">    </strong>.subscribe <strong class="mk iu">{ </strong>it -&gt; <em class="mu">doSomethingWithResonse</em>($it) <strong class="mk iu">}</strong></span></pre><h1 id="95e9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">2.将网络呼叫连接到同一个观察者:合并</h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/1378f906d0267ae07999726633d9f38f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1kaUAzQKPEIUPXWDZXVyQ.png"/></div></div></figure><p id="3e24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们从两个互不依赖的网络中获取数据，但是希望将结果提供给同一个观察者。</p><p id="7845" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用接线员呼叫<code class="fe mh mi mj mk b">mergeWith</code></p><pre class="md me mf mg gt ml mk mm mn aw mo bi"><span id="3a58" class="mp lf it mk b gy mq mr l ms mt">val disposable = firstNetworkCall()<br/>    .<strong class="mk iu">mergeWith</strong>(secondNetworkCall())<br/>    .subscribeOn(Schedulers.io())<br/>    .observeOn(AndroidSchedulers.mainThread())<br/>    .subscribe <strong class="mk iu">{ </strong>it -&gt; <em class="mu">doSomethingWithIndividualResponse</em>($it) <strong class="mk iu">}</strong></span></pre><p id="037e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，将会观察到来自<code class="fe mh mi mj mk b">firstNetworkCall</code>的数据，然后是接下来要观察的<code class="fe mh mi mj mk b">secondNetworkCall</code>数据。两者都由同一个观察者观察。</p><h1 id="fc53" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">3.将网络调用结果组合在一起</h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/4224bdb765d82ce22057713d2dab8665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IS0nyKrPQssTePZzQXSV9g.png"/></div></div></figure><p id="1c51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，我们不想将单个结果发送给观察者，而是想在发送之前将它们组合起来。当我们不需要担心观察者端的等待和同步时，这将非常有用。</p><p id="09b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">zipWith</code>来实现这一点</p><pre class="md me mf mg gt ml mk mm mn aw mo bi"><span id="7765" class="mp lf it mk b gy mq mr l ms mt">val disposable = firstNetworkCall()<br/>    .<strong class="mk iu">zipWith</strong>(secondNetworkCall(), <br/>        <strong class="mk iu">BiFunction</strong>{ <br/>          firstResonse: ResponseOneType, <br/>          secondResponse: ResponseTwoType -&gt; <br/>          <em class="mu">combineResult</em>(firstResponse, secondResponse) })<br/>    .subscribeOn(Schedulers.io())<br/>    .observeOn(AndroidSchedulers.mainThread())<br/>    .subscribe { it -&gt; <em class="mu">doSomethingWithCombinedResponse</em>($it) }</span></pre><p id="3777" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe mh mi mj mk b">mergeWith</code>非常相似，<code class="fe mh mi mj mk b">zipWith</code>函数也采用链路第一可观测值和第二可观测值。在订阅时，它首先获得<code class="fe mh mi mj mk b">firstResponse</code>，然后是<code class="fe mh mi mj mk b">secondResponse</code>。之后，<code class="fe mh mi mj mk b">BiFunction</code>用于收集两个结果，然后您可以在将结果传递给观察者之前合并结果(例如函数<code class="fe mh mi mj mk b">combineResult</code>)。</p><h1 id="830e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不错，但还不理想…</h1><p id="9e56" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">有了<code class="fe mh mi mj mk b">flatMap</code>、<code class="fe mh mi mj mk b">mergeWith</code>和<code class="fe mh mi mj mk b">zipWith</code>，我们现在可以在将网络调用发送给使用它的observer函数之前轻松地将它们链接起来。</p><p id="cef9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这太棒了。但是有一个缺点——它们仍然是按顺序进行的。例如，如果<code class="fe mh mi mj mk b">firstNetworkCall</code>花费了5秒，而<code class="fe mh mi mj mk b">secondNetworkCall</code>花费了5秒，那么在到达观察者之前，总过程是10秒。</p><p id="580c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于场景1，这是有意义的，因为一个依赖于另一个。但是对于场景2和3，两个网络调用应该能够被并行调用。</p><p id="2e83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看以下内容，了解如何让它们并行运行:</p><div class="nc nd gp gr ne nf"><a href="https://medium.com/@elye.project/rxjava-2-parallel-multiple-network-call-made-easy-1e1f14163eef" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">RxJava 2:简化并行多网络调用</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">在RxJava中做多个网络调用时，我们是否知道它们是并行运行的？我们如何让他们磨合…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt jz nf"/></div></div></a></div></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="5e5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望这篇帖子对你有帮助。你可以在这里查看我其他有趣的话题。</p><p id="a5ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关注我关于<a class="ae kf" href="https://medium.com/@elye.project" rel="noopener"><em class="mu"/></a><em class="mu"/><a class="ae kf" href="https://twitter.com/elye_project" rel="noopener ugc nofollow" target="_blank"><em class="mu">Twitter</em></a><em class="mu"/><a class="ae kf" href="https://www.facebook.com/elyeproj/" rel="noopener ugc nofollow" target="_blank"><em class="mu">脸书</em> </a>或<a class="ae kf" href="https://www.reddit.com/user/ElyeProj" rel="noopener ugc nofollow" target="_blank"> <em class="mu"> Reddit </em> </a>关于Android、Kotlin等相关话题的小技巧和学习。~Elye~</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><div class="md me mf mg gt nf"><a href="https://gitconnected.com/learn/java" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">学习Java -最佳Java教程(2019) | gitconnected</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">41大Java教程-免费学习Java。课程由开发者提交并投票，使您能够找到…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">gitconnected.com</p></div></div><div class="no l"><div class="ob l nq nr ns no nt jz nf"/></div></div></a></div></div></div>    
</body>
</html>