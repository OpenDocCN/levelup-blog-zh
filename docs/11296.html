<html>
<head>
<title>All you need to know about using MongoDB in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于在Python中使用MongoDB，您需要知道的是</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/all-you-need-to-know-about-using-mongodb-in-python-caa077c9a20f?source=collection_archive---------4-----------------------#2022-03-06">https://levelup.gitconnected.com/all-you-need-to-know-about-using-mongodb-in-python-caa077c9a20f?source=collection_archive---------4-----------------------#2022-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b017" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Python中MongoDB的常见用例</h2></div><p id="143f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将讨论如何在Python中使用MongoDB。如果你还不了解MongoDB或者想更新一下，你可以查看<a class="ae le" href="https://lynn-kwong.medium.com/learn-the-essentials-and-get-started-with-mongodb-8380026642d5" rel="noopener">的这篇介绍性文章</a>和<a class="ae le" href="https://medium.com/codex/learn-powerful-mongodb-aggregation-pipelines-from-practical-examples-efead98f08" rel="noopener">的这篇聚合文章</a>来快速了解MongoDB。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/8d20a2432febab43c5a1578982c3c04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRT4dyelcObU_bzO-dupWg.jpeg"/></div></div></figure><p id="701a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们能够在MongoDB中创建文档之前，我们需要有一个可用的MongoDB服务器。您可以使用由<a class="ae le" href="https://medium.com/codex/how-to-use-mongodb-atlas-to-manage-your-server-and-data-d97a6e7663c5" rel="noopener"> MongoDB Atlas </a>托管的服务器，这是推荐用于生产用途的，或者在您的计算机上安装MongoDB。但是，出于学习目的，建议使用Docker为MongoDB启动一个容器。这样，您可以始终使用MongoDB的最新版本，并且可以有更灵活的设置。一旦您知道如何使用MongoDB，您只需要更改凭证来访问您的生产MongoDB服务器。</p><p id="347d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为MongoDB启动Docker容器的命令是:</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="a510" class="lw lx it ls b gy ly lz l ma mb">$ docker network create mongo-net</span><span id="78aa" class="lw lx it ls b gy mc lz l ma mb">$ docker run --detach --network mongo-net --name mongo-server \<br/>    --env MONGO_INITDB_ROOT_USERNAME=admin \<br/>    --env MONGO_INITDB_ROOT_PASSWORD=pass \<br/>    --env MONGO_INITDB_ROOT_DATABASE=admin \<br/>    --volume mongo-data:/data/db \<br/>    --publish 27017:27017 \<br/>    mongo:5.0.6</span></pre><p id="b246" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们需要安装在Python中使用MongoDB的包。建议<a class="ae le" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener">创建一个虚拟环境</a>并在那里安装软件包，这样他们就不会搞乱系统库。为简单起见，我们将使用<a class="ae le" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener"> <em class="md"> conda </em> </a>来创建虚拟环境。我们需要安装<a class="ae le" href="https://pymongo.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"><em class="md">py mongo</em></strong></a>，这是一个包含使用MongoDB的工具的库，是从Python使用MongoDB的推荐方式。此外，我们将安装<a class="ae le" href="https://ipython.org/" rel="noopener ugc nofollow" target="_blank"> iPython </a>，以便更方便地交互式运行Python代码。</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="6bf3" class="lw lx it ls b gy ly lz l ma mb">(base) $ <strong class="ls iu">conda create --name mongodb python=3.10</strong><br/>(base) $ <strong class="ls iu">conda activate mongodb</strong><br/>(mongodb) $ <strong class="ls iu">pip install -U pymongo[srv] ipython</strong><br/>(mongodb) $ <strong class="ls iu">ipython</strong></span></pre><p id="0289" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，如果我们为MongoDB使用一个<a class="ae le" href="https://docs.mongodb.com/manual/reference/connection-string/#std-label-connections-dns-seedlist" rel="noopener ugc nofollow" target="_blank"> SRV URI </a>，比如MongoDB Atlas提供的，我们需要为<code class="fe me mf mg ls b">dnspython</code>安装<code class="fe me mf mg ls b">[srv]</code>依赖项。</p><p id="640b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在一切都准备好了，我们可以开始用Python处理MongoDB了。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="b978" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该做的第一件事是创建一个MongoClient并连接到MongoDB服务器。可以复制下面的Python代码，直接在iPython内部运行。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fe66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">建议使用MongoDB URI格式来指定主机、端口和认证，可以方便地与<code class="fe me mf mg ls b"><a class="ae le" href="https://lynn-kwong.medium.com/learn-the-essentials-and-get-started-with-mongodb-8380026642d5" rel="noopener">mongosh</a></code>或<a class="ae le" href="https://medium.com/codex/how-to-use-mongodb-with-graphical-ides-420597ede80e" rel="noopener">MongoDB ide</a>共享。</p><p id="995e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在生产中，我们不应该将认证指定为普通字符串，而应该通过环境变量来指定它们，最好使用<a class="ae le" href="https://lynn-kwong.medium.com/how-to-use-pydantic-to-read-environment-variables-and-secret-files-in-python-8a6b8c56381c" rel="noopener"> pydantic </a>，这是一个强大而通用的Python库，可以非常方便地处理环境变量和秘密。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="60cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在MongoDB中，我们不需要显式地创建数据库或集合。您只需要访问它们，它们将在文档首次插入集合时创建。通过这种方式，MongoDB中的数据库和集合被称为是<em class="md">延迟创建的</em>。</p><p id="6a45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们得到一个将在这篇文章中使用的数据库和集合。如果您已经阅读了MongoDB系列文章(可以在本文末尾找到),那么您应该已经有了一个<code class="fe me mf mg ls b">products</code>数据库和一个<code class="fe me mf mg ls b">laptops</code>集合。为了避免以后出现重复的关键问题，我们将分别把数据库命名为<code class="fe me mf mg ls b">products2</code>和集合命名为<code class="fe me mf mg ls b">laptops2</code>。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a986" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用属性样式来访问数据库和集合。如果数据库和集合名称不是有效的Python标识符，比如<code class="fe me mf mg ls b">my-products</code>，那么可以用字典样式访问它们，比如<code class="fe me mf mg ls b">db = mongo_client["my-products"]</code>。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="4b3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在进入更高级的聚合管道之前，让我们执行一些基本的CRUD操作来插入/读取/更新/删除一些文档。</p><h2 id="8f22" class="lw lx it bd mq mr ms dn mt mu mv dp mw kr mx my mz kv na nb nc kz nd ne nf ng bi translated"><strong class="ak">创建文档</strong></h2><p id="03cc" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">我们可以用<code class="fe me mf mg ls b">insert_one()</code>方法创建单个文档，用<code class="fe me mf mg ls b">insert_many()</code>方法创建多个文档。如果你对<code class="fe me mf mg ls b"><a class="ae le" href="https://lynn-kwong.medium.com/learn-the-essentials-and-get-started-with-mongodb-8380026642d5" rel="noopener">mongosh</a></code>中的CRUD操作有所了解，你只需要在所有字段名上加上引号，并将JavaScript中的<strong class="kk iu"> camelCase </strong>方法改为Python中的<strong class="kk iu"> snake_case </strong>。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3cd3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，如果您第二次运行以上命令，将会出现重复的键错误。如果我们需要更新一些文档，我们需要使用<code class="fe me mf mg ls b">update_one()</code>或<code class="fe me mf mg ls b">update_many()</code>。特别是对于<code class="fe me mf mg ls b">insert_many()</code>，当重复错误发生时，所有剩余的文件将被忽略。如果您只想跳过重复的并继续插入新的，您可以指定<code class="fe me mf mg ls b">ordered=False</code>选项，尽管有<code class="fe me mf mg ls b">BulkWriteError</code>。您可以将<code class="fe me mf mg ls b">insert_many()</code>放在<code class="fe me mf mg ls b">try/except</code>块中，更优雅地处理这种情况:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="38d7" class="lw lx it bd mq mr ms dn mt mu mv dp mw kr mx my mz kv na nb nc kz nd ne nf ng bi translated"><strong class="ak">阅读文件</strong></h2><p id="e0b7" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">现在让我们来阅读刚刚插入的文档。我们可以使用<code class="fe me mf mg ls b">find_one()</code>来查找第一个匹配的文档，或者使用<code class="fe me mf mg ls b">find()</code>来返回一个光标，这个光标可以用来遍历所有的匹配结果。您可以将过滤文档(包含过滤键/值对的字典)传递给<code class="fe me mf mg ls b">find_one()</code>或<code class="fe me mf mg ls b">find()</code>。如果没有指定过滤文档，所有文档都将被视为匹配。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c35f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的要点是:</p><ul class=""><li id="bc3e" class="nm nn it kk b kl km ko kp kr no kv np kz nq ld nr ns nt nu bi translated">指定一个空字典<code class="fe me mf mg ls b">{}</code>与不指定任何内容是一样的，这将查找集合中的所有文档，而<code class="fe me mf mg ls b">find_one()</code>将只返回第一个文档。</li><li id="591f" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated">默认情况下，将返回匹配文档的所有字段。如果只是想返回一些特定的字段，可以在过滤文档后指定一个投影文档。在投影文档中，关键字是匹配文档中的字段，值为1或0，表示是否应该输出相应的字段。</li><li id="6a57" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated"><code class="fe me mf mg ls b">find()</code>的工作原理与<code class="fe me mf mg ls b">find_one()</code>相同。唯一的区别是返回的是光标，而不是单个文档。我们可以像使用生成器一样使用结果光标，并遍历结果。</li><li id="3c9b" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated">过滤文档是包含过滤键/值对的字典。键是匹配文档的字段，值是过滤的逻辑。如果我们想要通过默认的等号运算符进行筛选，我们可以直接指定我们想要筛选的值。但是，如果我们想要通过其他操作符进行过滤，我们需要使用类似于<code class="fe me mf mg ls b">{"price": {"$lt": 10000}}</code>的嵌套文档来指定条件。运算符应该以美元符号为前缀。这里的<code class="fe me mf mg ls b">lt</code>是指<strong class="kk iu"> l </strong> ess <strong class="kk iu"> t </strong>韩。如果您想了解更多关于MongoDB的过滤和投影文档，请查看<a class="ae le" href="https://lynn-kwong.medium.com/learn-the-essentials-and-get-started-with-mongodb-8380026642d5" rel="noopener">这篇基本的</a>和<a class="ae le" href="https://medium.com/codex/learn-advanced-mongodb-queries-for-nested-documents-using-elemmatch-from-practical-examples-ec432efc2c0f" rel="noopener">这篇高级的</a>文章。</li></ul></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="de14" class="lw lx it bd mq mr ms dn mt mu mv dp mw kr mx my mz kv na nb nc kz nd ne nf ng bi translated"><strong class="ak">更新文档</strong></h2><p id="c335" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">让我们将笔记本电脑1到5的数量以及笔记本电脑2和3的内存更新为16GB。对于这些操作，我们可以分别使用<code class="fe me mf mg ls b">update_one()</code>和<code class="fe me mf mg ls b">update_many()</code>方法:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a08c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的要点是:</p><ul class=""><li id="b7db" class="nm nn it kk b kl km ko kp kr no kv np kz nq ld nr ns nt nu bi translated"><code class="fe me mf mg ls b">update_one()</code>和<code class="fe me mf mg ls b">update_many()</code>的第一个参数是过滤文件，与<code class="fe me mf mg ls b">find_one()</code>和<code class="fe me mf mg ls b">find()</code>的参数相同。特别是，我们使用<code class="fe me mf mg ls b">"$in"</code>操作符来检查一个值是否在数组中。</li><li id="5ccb" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated"><code class="fe me mf mg ls b">"$set"</code>操作符用于为字段设置新值。<code class="fe me mf mg ls b">"$set"</code>接受一个包含一组要更新的键/值对的字典。如果您想插入一个集合中没有的新文档，您可以将整个新文档指定为<code class="fe me mf mg ls b">"$set"</code>的值，并将<code class="fe me mf mg ls b">upsert</code>选项设置为<code class="fe me mf mg ls b">True</code>:</li></ul><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="3e31" class="nm nn it kk b kl km ko kp kr no kv np kz nq ld nr ns nt nu bi translated">我们可以用点符号为嵌套文档中的字段设置一个新值。注意<code class="fe me mf mg ls b">attributes</code>是一个文档数组，我们可以通过从0开始的位置索引来访问它们。这里我们想更新数组第二个文档的内存，因此字段名是<code class="fe me mf mg ls b">"attributes.1.attribute_value"</code>。但是，我们不能像上面显示的那样在投影文档中使用位置索引。否则，它们将被用作字段名，输出中不会显示任何内容，因为我们没有名称为0、1、2等的字段。你可以自己试一试。</li></ul></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="2690" class="lw lx it bd mq mr ms dn mt mu mv dp mw kr mx my mz kv na nb nc kz nd ne nf ng bi translated"><strong class="ak">删除文件</strong></h2><p id="05a4" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">同样，我们可以用<code class="fe me mf mg ls b">delete_one()</code>方法删除一个文档，用<code class="fe me mf mg ls b">delete_many()</code>删除多个文档。这两个方法也接受一个过滤文档作为第一个参数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="6efb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面我们已经介绍了Python中MongoDB的基本CRUD操作。然而，MongoDB不仅仅是一个NoSQL文档数据库。我们可以使用聚合管道对集合中的文档执行复杂的分析。一个常见的任务是对结果进行分组，并获得每组的总数据或平均数据。您甚至可以在分组前过滤、转换或清理数据。</p><p id="3d56" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">聚合管道由一个或多个按顺序处理文档的阶段组成。每个阶段对输入文档执行一些操作，并将处理过的文档传递给下一个阶段。例如，第一个阶段可以根据一些条件过滤文档，第二个阶段可以对过滤的文档进行分组并进行一些聚合，第三个阶段可以输出结果。</p><p id="7174" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们开始用Python编写MongoDB聚合管道之前，让我们将更多的文档插入到<code class="fe me mf mg ls b">laptops</code>集合中，并有更多的数据可以使用。请运行以下命令，并将存储在<a class="ae le" href="https://gist.github.com/lynnkwong/942310f2c65b672bb22a87cbf3f75de2" rel="noopener ugc nofollow" target="_blank">这个JSON文件</a>中的所有文档插入到<code class="fe me mf mg ls b">laptops</code>集合中:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="717f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe me mf mg ls b">laptops</code>集合的<code class="fe me mf mg ls b">aggregate()</code>方法来执行聚合。此方法接受按顺序执行的阶段列表。前一阶段返回的文档作为输入传递给下一阶段。现在，让我们编写一个简单的聚合管道来计算每个品牌的可用笔记本电脑数量:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="70be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">各阶段注意事项:</p><ul class=""><li id="3792" class="nm nn it kk b kl km ko kp kr no kv np kz nq ld nr ns nt nu bi translated"><code class="fe me mf mg ls b">$match</code>阶段过滤输入文档，只将符合指定条件的文档传递给下一个管道阶段。在本例中，我们筛选出不再可用的笔记本电脑。</li><li id="72a8" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated"><code class="fe me mf mg ls b">$group</code>阶段根据<code class="fe me mf mg ls b">_id</code>的指定字段对输入文档进行分组，并计算每个组的聚合结果。在本例中，我们按品牌对笔记本电脑进行分组，并计算每个品牌的笔记本电脑总数。</li><li id="2cc9" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated"><code class="fe me mf mg ls b">$sort</code>阶段按照指定的字段以定义的顺序对输入文档进行排序。请注意，<code class="fe me mf mg ls b">$sort</code>阶段的输入文档是前一个<code class="fe me mf mg ls b">$group</code>阶段返回的文档，而不是原始文档。因此，在<code class="fe me mf mg ls b">$group</code>阶段创建的<code class="fe me mf mg ls b">total</code>字段可以被<code class="fe me mf mg ls b">$sort</code>阶段访问。</li></ul><p id="a3f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想学习更多关于MongoDB中聚合管道的知识，强烈推荐你查看<a class="ae le" href="https://medium.com/codex/learn-powerful-mongodb-aggregation-pipelines-from-practical-examples-efead98f08" rel="noopener">这篇文章</a>，其中有更多的例子和更详细的关于聚合管道的公共阶段的介绍。对于用JavaScript为<code class="fe me mf mg ls b">mongosh</code>编写的例子，你只需要给所有的字段名和操作符加上引号，它们就可以直接在Python中运行了。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="2b0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们简要介绍了如何在Python中使用MongoDB。如果你已经在<code class="fe me mf mg ls b">mongosh</code>或者Compass中使用过MongoDB，那么在Python中使用应该会非常简单。在<code class="fe me mf mg ls b">mongosh</code> /Compass和Python中，查询和管道的语法几乎相同。通常，您只需要将字段名和操作符放在引号中，并将camelCase方法改为相应的snake_case方法。如果你想在<code class="fe me mf mg ls b">mongosh</code>中了解更多关于MongoDB的知识，它是通用的，并不局限于特定的编程语言，请查看下面的相关文章。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="a54e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相关文章:</p><ul class=""><li id="4c6a" class="nm nn it kk b kl km ko kp kr no kv np kz nq ld nr ns nt nu bi translated"><a class="ae le" href="https://lynn-kwong.medium.com/learn-the-essentials-and-get-started-with-mongodb-8380026642d5?source=your_stories_page----------------------------------------" rel="noopener">学习基础知识并开始使用MongoDB </a></li><li id="8536" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated"><a class="ae le" href="https://lynn-kwong.medium.com/learn-powerful-mongodb-aggregation-pipelines-from-practical-examples-efead98f08?source=your_stories_page----------------------------------------" rel="noopener">从实际例子中学习强大的MongoDB聚合管道</a></li></ul></div></div>    
</body>
</html>