# 什么是一般责任分配软件模式？

> 原文：<https://levelup.gitconnected.com/what-are-general-responsibility-assignment-software-patterns-6ad9635a44da>

## 低耦合、高内聚和其他七个重要的解释规则

![](img/5114309ff3b5e4c0d60beeee5c725297.png)

路易斯·金特罗在 [Unsplash](https://unsplash.com/s/photos/hand?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

编程中有很多有用的缩写词。并不是每一种都像固体或干燥一样具有超级明星的地位，但不太为人所知的仍然非常有用。GRASP 有助于为类和对象分配职责。如果你关心写干净的代码，这些绝对值得知道。

## 1.信息专家

我应该在哪里添加新的功能或方法？这是开发人员每天问自己的最常见的问题之一。它通常是不平凡的，会引起很多头痛。

信息专家模式指出，我们应该寻找完成任务所需的信息。最了解它们的地方是放置该功能的最佳候选地。这样的类是为它准备的最好的，并且需要最少的修改来实现。

在下面的例子中，列表的内部结构(标题和内容)泄露了。正在使用它的属性并将它们转换成 HTML。这样的操作应该放在`Listing`里面。它已经有了所有需要的数据。

“告诉不要问”是一个规则，它规定对数据进行操作的方法应该与数据本身在同一个位置。这种方法与 GRASP 的信息专家非常相似。

## 2.创造者

创建新对象可能是一项非常棘手的工作。它可能包含多个步骤，并需要不同的依赖项。这是正确的地方吗？我们应该直接创建一个新对象还是使用工厂？造物主应该帮助我们做出这样的决定。

根据 Creator，应该满足一个或多个规则，以便类`Foo`可以创建类`Bar`的新实例:

1.  `Foo`聚集`Bar`类型的对象
2.  `Foo`拥有初始化`Bar`所需的所有信息
3.  `Foo`紧密使用`Bar`的实例
4.  `Foo`记录一个类的实例`Bar`

工厂方法和抽象工厂是强烈支持这种方法的设计模式。

## 3.控制器

这条规则规定，应该有一个与应用程序的业务逻辑分离的地方负责处理请求。它控制应用程序中会发生什么，并知道如何处理给定的用例。控制器本身不应该做任何其他事情，也没有业务逻辑。更确切地说，它是一种将工作委托给应用程序的适当部分的服务。

如果我们没有一个作为应用程序接口的控制器，就很容易产生许多不必要的依赖。我们可能会以纠缠不清的代码和大量的依赖关系而告终。

模型-视图-控制器是一个众所周知的架构模式。MVC 中的控制器处理请求，并使用模型来处理业务逻辑。这可以被认为是 GRASP 控制器的一个具体用例。

## 4.低耦合

低耦合和高内聚是每个设计良好的系统的目标。这些很容易成为流行词汇，值得花点时间思考每个术语背后的想法。

每个软件系统在其模块和类之间都有关系和依赖。耦合是对软件组件如何相互依赖的一种度量。有不同类型的耦合。它可以基于发送的数据、触发操作或共享逻辑等属性。

当应用程序的各个部分知道彼此的实现细节时，就会发生紧密耦合。当系统的一部分改变时，其他部分也必须修改才能正常工作。低耦合基于抽象，使我们的系统更加模块化。不相关的事物不应该互相依赖。

静态代码分析可以成为耦合测量的有用工具。

## 5.高内聚力

内聚性是我们的模块或类如何专注于单一职责的指示器。低内聚的软件具有非常广泛的任务范围。低内聚性软件的元素可以被转移到单独的单元，而不改变它的其他部分。具有许多不相关的实用方法的助手类是低内聚的典型例子。

`Utils`凝聚力很低。每个操作都不相互链接，并且对不同的数据进行操作。

![](img/4ccd8d6cce034acc64af72a809bc1ee2.png)

要多努力才能分？—[劳尔·巴里奥斯](https://unsplash.com/@lookscanshoot?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/forging?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

另一方面，高内聚的类需要很大的努力才能分成更小的类。此外，这些更小的类变得紧密耦合。

同时变化的元素应该放在一起，因为这表明它们是紧密相关的。

耦合和内聚是非常相关的术语。

## 6.间接

对象之间不应该有不必要的相互了解。我们希望减少应用程序某些部分之间的关系/耦合是一个常见的原因。间接模式引入了一个处理通信的中介。

观察者、外观、桥、中介或适配器是利用间接方法的设计模式。根据使用案例和需求，我们可以使应用程序的各个部分更加独立。MVC 模式中的控制器也是使用间接方法的一个例子。它将视图与模型分开。

应该谨慎使用这种模式，因为我们可能会以巧合的复杂性而告终。

## 7.多态性

多态性是面向对象编程的一个非常强大的特性。如果我们想用不同的行为表示相关的类，我们应该使用多态性。因此，客户可以使用抽象，而不是特定的具体实现，我们可以摆脱不必要的 ifology。

## 8.纯粹捏造

如果我们的应用程序的某个部分似乎有太多的职责，那么它可能会被转移到一个单独的服务中。此类服务不代表我们领域的任何特定责任。这些助手类对保持我们的代码更加整洁非常有帮助。

这种方法的一个例子是将发票保存到数据库中。`Invoice`是一个存放所有发票数据和操作的地方。对于与存储数据相关的逻辑，它也是一个很好的候选对象。

凭直觉，我们知道这是不对的。连接数据库和使用 SQL 会使我们的类过于复杂。我们可以很容易地将这个操作转移到一个单独的服务中，该服务将只处理这个职责。

## 9.受保护的变化

每个软件应用程序都在不断变化。这是软件的本质，而不是坏事。结果往往与我们的计划相差甚远。我们在开发过程中发现新的需求和期望，并需要调整我们的应用程序行为。

面向对象编程的特征之一是封装。实现细节应该对客户端隐藏。如果应用程序某个部分的内部表示或行为发生变化，其公共接口应该保持不变。我们应该让客户看不到逻辑和将来可能改变的部分。

有些规则对你来说可能很明显。说明你是一个扎实的开发者，不自觉的跟着他们走。对你有好处。尽管如此，知道他们的名字也是好的。

## 资源:

*   “应用 UML 和模式:面向对象分析和设计以及统一过程的介绍”，Craig Larman
*   [https://martinfowler.com/bliki/TellDontAsk.html](https://martinfowler.com/bliki/TellDontAsk.html)
*   [https://blog.ndepend.com/lack-of-cohesion-methods/](https://blog.ndepend.com/lack-of-cohesion-methods/)