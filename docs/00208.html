<html>
<head>
<title>Overview of Proxy Servers, CORS, and How We Use Them in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代理服务器概述，CORS，以及我们如何在React中使用它们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/overview-of-proxy-server-and-how-we-use-them-in-react-bf67c062b929?source=collection_archive---------0-----------------------#2018-09-10">https://levelup.gitconnected.com/overview-of-proxy-server-and-how-we-use-them-in-react-bf67c062b929?source=collection_archive---------0-----------------------#2018-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c1f68dce3f0535df4204b8eb34a758e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-4RqDC6zFrpAG31ayDDOg.png"/></div></div></figure><p id="66fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个话题一直是过去<a class="ae kw" href="https://github.com/facebook/create-react-app/issues?utf8=%E2%9C%93&amp;q=proxy+requests" rel="noopener ugc nofollow" target="_blank">几</a>年<a class="ae kw" href="https://stackoverflow.com/search?q=%5Bcreate-react-app%5D+proxy" rel="noopener ugc nofollow" target="_blank">年</a>几次讨论的焦点。而且，我在这里又要说一遍了。然而，我的方法将与我遇到的大多数其他文章略有不同。除了关注<em class="kx">如何</em>之外，我还将关注这个问题的<em class="kx">为什么</em>部分——这通常被认为是可以理解的。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="1acc" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">什么是代理？</h2><p id="9c86" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">一般来说，<em class="kx">代理</em>是一个服务器或服务，它可以根据配置在我们的通信中引入额外的层来混淆或修改内容。</p><p id="e4a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个非常简单的例子就是代理我们的IP地址，同时发送访问YouTube视频的请求，这些视频目前在您的国家<em class="kx">不可用</em>。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="f10d" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">为什么我们需要代理？</h2><p id="1530" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">在web开发的背景下</a>，我们使用代理的主要目的是避免CORS(跨源资源共享)“问题”，这是因为浏览器执行同源策略来保护用户免受XSS和其他几种类型的攻击。</p><p id="2ac7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，这意味着浏览器出于安全原因，会限制来自与托管UI不同的<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin" rel="noopener ugc nofollow" target="_blank"><em class="kx"/></a>的请求，从而防止攻击者通过广告或插件向我们的应用程序中注入代码来窃取我们的凭据或其他敏感信息。</p><p id="8c89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是来自<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> MDN </a>的一张图片，它解释了一个支持CORS的网页执行什么请求。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/18a5d75cc3afc965c0216ab082f3a17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnTTrWj5tn6VCQJHk9PHKQ.png"/></div></div></figure><p id="b4a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是服务器如何知道请求是否来自同一个<em class="kx">源</em>呢？以<strong class="ka ir">请求头</strong>的形式。浏览器附加一个名为<code class="fe mi mj mk ml b">origin</code> <em class="kx">、</em>的请求头，用于跨源请求<em class="kx">、</em>以表示请求来自哪个<code class="fe mi mj mk ml b">origin</code>。然后，服务器有权通过提供由浏览器解析的特定的<strong class="ka ir">响应头</strong>来允许或拒绝这些<em class="kx">源</em>。</p><p id="b722" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，当我们加载Google的主页时，它向不同的<em class="kx">源</em>发出几个请求。跨来源请求的示例如下所示:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/540fc2676b21bffc2faf4195c3428fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3vtkJReUa1a-ITb5je2oA.png"/></div></div></figure><p id="9996" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在响应中，我们接收到了<code class="fe mi mj mk ml b">access-control-allow-*</code>报头，这使得这两个<em class="kx">起点</em>之间能够进行跨起点通信。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/e11e4de1454bde503f656b0b4429c9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aziuqp5m6obqYqsaK_LiAg.png"/></div></div></figure><p id="2ab5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk ml b">access-control-allow-*</code>头具有各种职责，服务器可以通过这些头定义认证机制、可接受的头值和允许的HTTP方法类型。</p><p id="34ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于缺少了<code class="fe mi mj mk ml b">access-control-allow-origin</code>头，我们的请求虽然成功，但会被浏览器阻止，我们将无法访问请求的响应。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="849c" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">代理服务器是如何出现的？</h2><p id="8769" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">到目前为止，我们只讨论了一个服务器向另一个服务器发出请求的例子。对于上面的例子，<code class="fe mi mj mk ml b">notifications</code>服务器被列入白名单，以便在<code class="fe mi mj mk ml b">google.com</code>联系<code class="fe mi mj mk ml b">play</code>服务器。但是，通过将<code class="fe mi mj mk ml b">access-control-allow-origin</code>设置为<code class="fe mi mj mk ml b">*</code>来将所有<em class="kx">源</em>列入白名单是不合理的，除非它是公共服务器。在开发过程中，另一个常见的模式是在<code class="fe mi mj mk ml b">localhost:$port</code>运行我们的UI应用程序，但是为了方便API调用而加入白名单<code class="fe mi mj mk ml b">localhost</code>是一个反模式，应该避免。</p><p id="7e06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，我们应该使用代理服务器来处理浏览器施加的限制。在这种情况下，代理服务器负责处理我们的请求、响应，并进行必要的修改以促进跨源通信。为了理解代理服务器的一些内部工作方式，让我们看一下非常著名的NodeJS代理库<a class="ae kw" href="https://github.com/nodejitsu/node-http-proxy" rel="noopener ugc nofollow" target="_blank"> node-http-proxy </a>。</p><p id="e93f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从很高的层面来看，当使用node-http-proxy的应用程序发出请求时，会执行两个步骤，如本文档摘录所示:</p><blockquote class="mo mp mq"><p id="0d52" class="jy jz kx ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">当一个请求被代理时，它遵循两个不同的管道(这里有<a class="ae kw" href="https://github.com/nodejitsu/node-http-proxy/blob/a3fe02d651d05d02d0ced377c22ae8345a2435a4/lib/http-proxy/passes" rel="noopener ugc nofollow" target="_blank"/>)，这两个管道将转换应用到<code class="fe mi mj mk ml b"><em class="iq">req</em></code>和<code class="fe mi mj mk ml b"><em class="iq">res</em></code>对象。第一个管道(传入)负责创建和操作将客户端连接到目标的流。第二个管道(传出)负责创建和操作从目标向客户机返回数据的流。</p></blockquote><p id="1cd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更深入的调查显示，正在发出的请求被捕获，并基于所提供的配置被覆盖/修改<a class="ae kw" href="https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L100" rel="noopener ugc nofollow" target="_blank">，这里是</a>。请求路径到代理路径的修改可以在<a class="ae kw" href="https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L78-L104" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="04f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似地，响应被捕获和修改的主要是<a class="ae kw" href="https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L85" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="5357" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">create-react-app如何处理代理</h2><p id="4a8f" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">既然我们对为什么需要代理服务器以及它们在内部如何工作有了基本的了解，现在我们可以继续了解React应用程序如何使用代理服务器。让我们看看在React应用程序中处理HTTP请求的几种最常见的方法。</p><p id="ea78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在检查下面的用例之前，使用<code class="fe mi mj mk ml b">create-react-app</code>创建一个新的应用程序，它使用<code class="fe mi mj mk ml b">webpack-dev-server</code>来启动我们的开发服务器。<code class="fe mi mj mk ml b">webpack-dev-server</code>可选地接受一个具有必要结构的代理对象，如这里的<a class="ae kw" href="https://github.com/facebook/create-react-app/blob/next/packages/react-scripts/scripts/start.js#L101-L120" rel="noopener ugc nofollow" target="_blank">所定义的</a>。让我们分解这些步骤，进一步分析使用<code class="fe mi mj mk ml b">create-react-app</code>的React应用程序如何处理请求代理。</p><pre class="me mf mg mh gt mu ml mv mw aw mx bi"><span id="d051" class="lf lg iq ml b gy my mz l na nb">const proxySetting = require(paths.appPackageJson).proxy;</span></pre><p id="c903" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，它从<code class="fe mi mj mk ml b">package.json</code>文件中提取代理配置。</p><pre class="me mf mg mh gt mu ml mv mw aw mx bi"><span id="96a1" class="lf lg iq ml b gy my mz l na nb">const proxyConfig = prepareProxy(proxySetting, paths.appPublic);</span></pre><p id="8481" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，<code class="fe mi mj mk ml b"><a class="ae kw" href="https://github.com/facebook/create-react-app/blob/next/packages/react-dev-utils/WebpackDevServerUtils.js#L266-L385" rel="noopener ugc nofollow" target="_blank">prepareProxy</a></code>方法通过将上一步中提取的<code class="fe mi mj mk ml b">proxySettings</code>与一些基于执行环境的有效缺省值相结合，准备必要的代理配置。现在生成的代理配置将最终传递给<code class="fe mi mj mk ml b">node-http-proxy</code>，由<code class="fe mi mj mk ml b">webpack-dev-server</code>用来代理请求。</p><pre class="me mf mg mh gt mu ml mv mw aw mx bi"><span id="3023" class="lf lg iq ml b gy my mz l na nb">const serverConfig = createDevServerConfig(<br/>    proxyConfig,<br/>    urls.lanUrlForConfig<br/>);</span></pre><p id="6371" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是使用<code class="fe mi mj mk ml b">proxyConfig</code>创建<code class="fe mi mj mk ml b">webpack</code>服务器配置。</p><pre class="me mf mg mh gt mu ml mv mw aw mx bi"><span id="9d7e" class="lf lg iq ml b gy my mz l na nb">const devServer = new WebpackDevServer(compiler, serverConfig);</span></pre><p id="a6b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，使用<code class="fe mi mj mk ml b">serverConfig</code>和<code class="fe mi mj mk ml b">compiler</code>设置<code class="fe mi mj mk ml b">devServer</code>。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="b2d4" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">常见使用案例</h2><p id="48f6" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在下面的例子中，我们将研究在react应用程序中代理请求的不同方式。</p><p id="ff02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1。使用fetch </strong></p><p id="5b79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了使用<code class="fe mi mj mk ml b">create-react-app</code> CLI创建的新应用，我们可以直接进入编码:</p><p id="9c0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有代理，请求将被<code class="fe mi mj mk ml b">google.com</code>服务器拒绝，我们会在控制台上看到拒绝记录。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/b51d82ac6c21084f7da97cca7bff5e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGte3zwygEb9tISXRQP_2Q.png"/></div></div></figure><p id="d969" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，当我们将<code class="fe mi mj mk ml b">proxy</code>条目添加到<code class="fe mi mj mk ml b">package.json</code>条目时，请求被成功代理，我们可以加载服务器返回的信息。在这种情况下，它是一个blob，所以我们需要一些额外的处理来提取文本。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4bd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新的组件:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2f88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将结果记录到UI中，如下所示:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/d4ab32604c704a6f96321fe76bd66081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6FhIvf1stHXxWxD94fnnA.png"/></div></div></figure><p id="b250" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。对不同路径使用自定义目标</strong></p><p id="7d26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于不是所有的请求都到达同一个服务器，我们可以在我们的<code class="fe mi mj mk ml b">package.json</code>文件中为每个<code class="fe mi mj mk ml b">path</code>定义<code class="fe mi mj mk ml b">paths</code>和<code class="fe mi mj mk ml b">target</code>:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6138" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的组件中，在发出请求时，会应用此配置，并将我们的请求发送到相应的服务器:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b1c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe mi mj mk ml b">blob</code>和<code class="fe mi mj mk ml b">.json()</code>方法的<code class="fe mi mj mk ml b">async</code>性质，响应是无序的，如下所示:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/d274730afbe8142c00c8f68fc044418f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IH12s6hRARon9cnzoyRx1g.png"/></div></div></figure><p id="0117" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的一件奇怪的事情是，我们在<code class="fe mi mj mk ml b">package.json</code>文件中使用了<code class="fe mi mj mk ml b">changeOrigin</code>标志。该标志将主机头的<em class="kx">来源</em>更改为目标URL，从而实现成功连接。这里还有其他类似的有用选项<a class="ae kw" href="https://github.com/nodejitsu/node-http-proxy#options" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="64ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。使用axios </strong></p><p id="d133" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的应用程序使用<code class="fe mi mj mk ml b">axios</code>而不是<code class="fe mi mj mk ml b">fetch</code>来发出<code class="fe mi mj mk ml b">http</code>请求，那么设置代理与我们到目前为止所做的没有什么不同。</p><p id="1a4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加另一条路径，使用<code class="fe mi mj mk ml b">axios</code>从<code class="fe mi mj mk ml b">typicode</code>获得<code class="fe mi mj mk ml b">posts</code>。在继续更新<code class="fe mi mj mk ml b">package.json</code>文件之前，使用<code class="fe mi mj mk ml b">npm</code>或<code class="fe mi mj mk ml b">yarn</code>安装<code class="fe mi mj mk ml b">axios</code>，如下所示:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0b13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在可以更新组件，以使用<code class="fe mi mj mk ml b">axios</code>发出请求:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="52a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mi mj mk ml b">axios</code>的好处是我们现在可以轻松地向我们的<code class="fe mi mj mk ml b">http</code>请求添加额外的选项和特性。其中一个特性是使用拦截器来拦截每个应用程序的请求和响应，而不是每个请求。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="4dfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面例子的完整代码可以在<a class="ae kw" href="https://github.com/40x/proxy" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="10a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">如果你喜欢这个博客，一定要为它鼓掌，</em> <a class="ae kw" href="https://medium.com/@kashyap.mukkamala" rel="noopener"> <em class="kx">阅读更多</em> </a> <em class="kx">或者关注我的</em><a class="ae kw" href="https://www.linkedin.com/in/kashyap-mukkamala/" rel="noopener ugc nofollow" target="_blank"><em class="kx">LinkedIn</em></a><em class="kx">。</em></p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><figure class="me mf mg mh gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nh"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure><div class="ni nj gp gr nk nl"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">前45名React教程。课程由开发人员提交并投票，使您能够找到最佳反应…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">gitconnected.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz jw nl"/></div></div></a></div></div></div>    
</body>
</html>