<html>
<head>
<title>A better way than “ldflags” to add a build version to your Go binaries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比“ldflags”更好的向Go二进制文件添加构建版本的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-better-way-than-ldflags-to-add-a-build-version-to-your-go-binaries-2258ce419d2d?source=collection_archive---------6-----------------------#2022-01-18">https://levelup.gitconnected.com/a-better-way-than-ldflags-to-add-a-build-version-to-your-go-binaries-2258ce419d2d?source=collection_archive---------6-----------------------#2022-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/93e13a74d2787dff9b82eee1b1f3f9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VkU-U9uVkO52zua6ugR7Q.jpeg"/></div></div></figure><p id="7821" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像许多使用Go的人一样，<a class="ae kz" href="https://www.linkedin.com/in/andrew-hayes-belfast/" rel="noopener ugc nofollow" target="_blank">我</a>使用“ldflags”将版本号添加到我的二进制文件中。它工作得很好，每次构建二进制文件时，它都会从“git describe”中取出版本，并将该版本添加到二进制文件的变量中。然后，当测试和发现一个错误时，我会知道我在哪个版本的二进制文件中发现了它，一切正常。直到我决定优化我的文档，它停止工作。更糟糕的是，我没有注意到它不再工作了，当一个bug被发现时，我不知道它是在哪个版本上被发现的。</p><h1 id="caa4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">优化Dockerfile文件时,“ldflags”是如何停止工作的？</h1><p id="39dc" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在最初的开发过程中，我让一些Make targets在本地测试和构建Go文件。然后，当我为项目创建容器时，我只是从docker文件中调用这些相同的Make目标。它工作得很好，所以它保持了一段时间。直到我对docker构建花费的时间比我想要的稍长感到恼火，所以我决定进行优化。为此，我从docker文件中取出Make目标，并将每个步骤添加为“运行”命令，这样docker可以缓存步骤并节省时间。然而，这是我的毁灭。当在docker文件中执行“go build”步骤时，我愚蠢地完全忘记了包括“ldflags”部分。最初的Make目标是这样的:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7237" class="mm lb it mi b gy mn mo l mp mq">go build -v -ldflags="-X 'main.version=`git describe --tags --abbre<br/>v=0`'" -o ./bin/my_binary</span></pre><p id="5f89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Dockerfile文件中的新命令很简单:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="25f7" class="mm lb it mi b gy mn mo l mp mq">go build -v -o ./bin/my_binary</span></pre><p id="4a48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两者之间的差异有两点需要注意。首先，“main.version”变量不再用“git describe”中的版本填充。第二，Dockerfile文件中的命令是完全有效的，运行时不会出现问题，没有任何迹象表明第一个问题正在发生。</p><h1 id="ffad" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">解决方案:使用go:generate和go:embed！</h1><p id="6cf9" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">go:generate和go:embed是go工具链中相对较新的工具。<a class="ae kz" href="https://go.dev/blog/generate" rel="noopener ugc nofollow" target="_blank"> go:generate </a>是一种在构建期间在代码中运行命令的方式，因此您可以在需要时生成代码等。<a class="ae kz" href="https://pkg.go.dev/embed#pkg-overview" rel="noopener ugc nofollow" target="_blank"> go:embed </a>是一种在go二进制文件中嵌入外部文件的方法。如果我们把这两者结合起来，我们就有了解决问题的方法！</p><p id="2605" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您还没有看到旧的“ldflags”技术的大量其他文章，它看起来像下面这样。你有你的go文件:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="74dd" class="mm lb it mi b gy mn mo l mp mq">package main<br/>import (<br/>    "fmt"<br/>)</span><span id="d726" class="mm lb it mi b gy mr mo l mp mq">var version = ""</span><span id="52ca" class="mm lb it mi b gy mr mo l mp mq">func main() {<br/>    fmt.Println("build version: ", version)<br/>}</span></pre><p id="2980" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在构建时包含“ldflags”参数来设置“version”变量。示例:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="915d" class="mm lb it mi b gy mn mo l mp mq">go build -v -ldflags="-X 'main.version=`git describe --tags --abbre<br/>v=0`'"</span></pre><p id="020a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本例中，它将把“version”变量设置为“git describe”的输出。然而，正如我在上面所描述的，没有任何东西可以确保您已经完成了这一点，并且在没有“ldflags”参数和“version”变量将保持设置为空字符串的情况下，它将非常愉快地构建。</p><p id="5fb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更好的方法是使用go:generate和go:embed！首先，我们需要将git describe命令移动到一个bash脚本中(我将我的脚本命名为get_version.sh):</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1b41" class="mm lb it mi b gy mn mo l mp mq">#!/bin/bash<br/>git describe --tags --abbrev=0 &gt; version.txt</span></pre><p id="0cbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这会将版本写入名为“version.txt”的文件中。我们还可以将“version.txt”添加到。gitignore文件，这样它就永远不会被签入。</p><p id="854c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后更新go文件以包含go:generate和go:embed:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0cc8" class="mm lb it mi b gy mn mo l mp mq">package main</span><span id="c6f3" class="mm lb it mi b gy mr mo l mp mq">import (<br/>  "fmt"</span><span id="d38c" class="mm lb it mi b gy mr mo l mp mq">  _ "embed"<br/>)</span><span id="3930" class="mm lb it mi b gy mr mo l mp mq">//go:generate bash get_version.sh<br/>//go:embed version.txt<br/>var version string</span><span id="e7cc" class="mm lb it mi b gy mr mo l mp mq">func main() {<br/>  fmt.Println("build version: ", version)<br/>}</span></pre><p id="adb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要构建它，您只需运行:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="15ea" class="mm lb it mi b gy mn mo l mp mq">go generate<br/>go build -v</span></pre><p id="0e79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将生成“version.txt”文件并将其嵌入到二进制文件中。在这一点上，它与“ldflags”技术非常相似。然而，使用这种新技术，如果您不小心省略了“go generate”步骤，它将会失败。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="cb21" class="mm lb it mi b gy mn mo l mp mq">$ go build<br/>main.go:10:12: pattern version.txt: no matching files found</span></pre><p id="51be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像Go的类型安全一样，编译器会帮助你捕捉你可能错过的愚蠢错误。</p></div></div>    
</body>
</html>