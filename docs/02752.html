<html>
<head>
<title>The Simple Six HTTP methods: ELI15 Edition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的六种HTTP方法:ELI15版</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-simple-six-http-methods-eli15-edition-53f336b1ebd?source=collection_archive---------13-----------------------#2020-04-02">https://levelup.gitconnected.com/the-simple-six-http-methods-eli15-edition-53f336b1ebd?source=collection_archive---------13-----------------------#2020-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h2 id="ba11" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">前言:</h2><p id="aef7" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">这些是基本的HTTP方法。从技术上讲，互联网工程任务组(IETF)标准<a class="ae ll" href="https://tools.ietf.org/html/rfc7231#section-4" rel="noopener ugc nofollow" target="_blank"> RFC 7231，section 4: Request methods </a>定义了八种方法(GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE ),而<a class="ae ll" href="https://tools.ietf.org/html/rfc5789#section-2" rel="noopener ugc nofollow" target="_blank"> RFC 5789，section 2: Patch method </a>定义了第九种方法(Patch ),但是本文只涉及最基本的六种方法，没有配置请求头之类的特殊内容。好的。</p><p id="a150" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">在我们深入了解每种方法的细节之前，这里有一个比较它们的表格:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/799e7091b3cf989b012496a099c84a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*e2nPkOb5pZoRfDIOFLIveA.png"/></div></figure><p id="4069" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">重要概念:</p><p id="1fa2" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">Body —我们希望发送到服务器的数据。</p><p id="e673" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">安全—如果方法导致只读操作，则该方法是安全的。在调用一个安全的方法后，有问题的数据不会被修改。</p><p id="6cf8" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">幂等的—如果一个方法可以被重复调用而没有副作用，那么这个方法就是幂等的。副作用只在服务器端考虑。例如，DELETE方法是幂等的，因为无论我们发出多少次删除请求，我们都只能删除一次资源，但POST方法不是幂等的，如果我们再次发出POST请求，我们将创建另一个资源。</p><p id="87c4" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">POST方法不是等幂的:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="1db6" class="ju jv iq ma b gy me mf l mg mh"> POST /add_status -&gt; Adds a status Change on Server side<br/> POST /add_status -&gt; Adds a 2nd status Change on Server side<br/> POST /add_status -&gt; Adds a 3rd status Change on Server side</span></pre><p id="ff60" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">删除方法是幂等的:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="8525" class="ju jv iq ma b gy me mf l mg mh">DELETE /delete?:id -&gt; Returns 200 Change on Server side<br/>DELETE /delete?:id -&gt; Returns 404 No Change on Server side<br/>DELETE /delete?:id -&gt; Returns 404 No Change on Server side</span></pre><p id="b660" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">所有安全的方法都被认为是等幂的，但并不是所有的等幂方法都被认为是安全的。记住哪些方法是幂等的很重要。“为什么？”你会问，考虑这样一种情况，我们向服务器发送一个请求，在服务器有机会向客户端发送响应之前，客户端和服务器之间的连接被关闭，如果方法是幂等的，我们就可以重新发送请求，而不用担心意外的影响，如创建重复的帖子或推文。</p><p id="9b23" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">下面的例子是使用<a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>制作的。如果我们使用另一个HTTP客户端包，如<a class="ae ll" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>，请求的配置会有所不同</p><p id="fa3a" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">现在让我们进入细节。</p><h1 id="ecb3" class="mi jv iq bd jw mj mk ml jz mm mn mo kc mp mq mr kg ms mt mu kk mv mw mx ko my bi translated">得到</h1><p id="86bc" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">当我们想要获取远程服务器上的资源时，使用Get。用Fetch发出GET请求非常简单。我们需要提供的唯一信息是我们资源的URL。它是这样叫的:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="42d1" class="ju jv iq ma b gy me mf l mg mh">fetch(‘http://example.com/movies.json')<br/>.then((response) =&gt; {<br/>return response.json();<br/>})<br/>.then((data) =&gt; {<br/>//Do Something with response data<br/>console.log(data);<br/>});</span></pre><h1 id="1e94" class="mi jv iq bd jw mj mk ml jz mm mn mo kc mp mq mr kg ms mt mu kk mv mw mx ko my bi translated">邮政</h1><p id="54ea" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">当我们想要创建资源条目时，会发送一个POST请求。在这个方法中，我们必须提供资源所在的URL以及我们想要添加到服务器的数据。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="1e46" class="ju jv iq ma b gy me mf l mg mh">const data = { username: 'example' };<br/>fetch('https://example.com/profile', {<br/>  method: 'POST',<br/>  body: JSON.stringify(data),<br/>})<br/>.then((response) =&gt; response.json())<br/>.then((data) =&gt; {<br/>//Do Something with response data<br/>  console.log('Success:', data);<br/>})<br/>.catch((error) =&gt; {<br/>  console.error('Error:', error);<br/>});</span></pre><h1 id="039d" class="mi jv iq bd jw mj mk ml jz mm mn mo kc mp mq mr kg ms mt mu kk mv mw mx ko my bi translated">修补</h1><p id="3155" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">当我们想要修改资源时，就使用补丁。它是这样发送的:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="b6d5" class="ju jv iq ma b gy me mf l mg mh">const data = { username: 'example' };<br/>fetch(‘https://example.com/profile/id, {<br/>method: ‘PATCH’,<br/>body: <!-- -->data<br/>})<br/>.then((response) =&gt; response.json())<br/>.then((result) =&gt; {<br/>console.log(‘Success:’, result);<br/>});</span></pre><p id="aa3f" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">假设我们有一个场景，其中我们有一个具有以下属性的资源:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="b7d6" class="ju jv iq ma b gy me mf l mg mh">{<br/>“hasCar”: true,<br/>“hasHelicopter”: true,<br/>“numberOfDogs”: 10,<br/>}</span></pre><p id="6edb" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">我们希望使用一个补丁请求来用这些数据更新资源:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="fe9f" class="ju jv iq ma b gy me mf l mg mh">{<br/>“numberOfDogs”: 12,<br/>“numberOfCats”: 1,<br/>}</span></pre><p id="a072" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">该请求的结果将是:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="a583" class="ju jv iq ma b gy me mf l mg mh">{<br/>“hasCar”: true,<br/>“hasHelicopter”: true,<br/>“numberOfDogs”: 12,<br/>“numberOfCats”: 1,<br/>}</span></pre><p id="c861" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">请注意，该资源不仅更新了“numberOfDogs”属性，它现在还有一个“numberOfCats”属性。</p><p id="2be1" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">在不存在的资源上发送修补请求将会失败，并且不会创建任何资源。</p><h1 id="6399" class="mi jv iq bd jw mj mk ml jz mm mn mo kc mp mq mr kg ms mt mu kk mv mw mx ko my bi translated">放</h1><p id="611d" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">当我们想要完全替换一个资源时，我们发送一个PUT请求。看跌期权将如下发送:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="c070" class="ju jv iq ma b gy me mf l mg mh">// Example of a PUT method<br/>const data = { username: 'example' };<br/>fetch(“https://example.com/profile/id”, {<br/>method: ‘PUT’,<br/>body: <!-- -->data<br/>})<br/>.then((response) =&gt; response.json())<br/>.then((result) =&gt; {<br/>console.log(‘Success:’, result);<br/>})</span></pre><p id="b903" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">PUT是PATCH的大锤版。发送PUT请求会用请求中发送的正文覆盖以前的资源，而发送PATCH请求只会更新现有的资源。补丁不能删除资源，放可以。例如，假设我们有一个位于服务器数据库中的资源，它具有以下属性:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="b54a" class="ju jv iq ma b gy me mf l mg mh">{<br/>“hasCar”: true,<br/>“hasHelicopter”: true,<br/>“numberOfDogs”: 12,<br/>}</span></pre><p id="d616" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">然后，我们决定在PUT请求的主体中发送数据:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="ef4b" class="ju jv iq ma b gy me mf l mg mh">{<br/>“numberOfCats”: 1,<br/>}</span></pre><p id="957f" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">这样，资源将只有一个名为“numberOfCats”的属性，其整数值为1。</p><p id="d7a5" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">对不存在的资源发送PUT请求将创建具有这些属性的资源</p><h1 id="e4a4" class="mi jv iq bd jw mj mk ml jz mm mn mo kc mp mq mr kg ms mt mu kk mv mw mx ko my bi translated">删除</h1><p id="d4c4" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">当您想要删除资源时，可以使用DELETE。了解此方法将删除整个资源，而不仅仅是特定资源的属性，这一点很重要。删除请求可以这样发送:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="3002" class="ju jv iq ma b gy me mf l mg mh">const data = { username: 'example' };<br/>fetch(‘https://example.com/profile/id, {<br/>method: ‘DELETE’,<br/>body: <!-- -->data<br/>})<br/>.then((response) =&gt; response.json())<br/>.then((result) =&gt; {<br/>console.log(‘Success:’, result);<br/>})</span></pre><h1 id="63d9" class="mi jv iq bd jw mj mk ml jz mm mn mo kc mp mq mr kg ms mt mu kk mv mw mx ko my bi translated">选择</h1><p id="42fd" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">选项请求通常用作预检请求，用于查看服务器支持哪些方法。预检请求由浏览器自动发送，在大多数情况下，我们不需要手动发出这些请求。通常，浏览器发送的选项请求如下所示:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="8ecc" class="ju jv iq ma b gy me mf l mg mh">OPTIONS /resource/:id<br/>Access-Control-Request-Method: DELETE<br/>Access-Control-Request-Headers: origin, x-requested-with<br/>Origin: <a class="ae ll" href="https://foo.bar.org" rel="noopener ugc nofollow" target="_blank">https://foo.bar.org</a></span></pre><p id="bebf" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">浏览器基本上是在说“嘿，服务器，我将尝试删除/resource/:id上的一个资源。我从<a class="ae ll" href="https://foo.bar.org" rel="noopener ugc nofollow" target="_blank">https://foo.bar.org</a>发出这个请求，并且我发送这个带有来源和x-requested-with标题的请求”</p><p id="bbac" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">假设服务器端一切正常，服务器将做出如下响应:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="d4d4" class="ju jv iq ma b gy me mf l mg mh">HTTP/1.1 204 No Content<br/>Connection: keep-alive<br/>Access-Control-Allow-Origin: <a class="ae ll" href="https://foo.bar.org" rel="noopener ugc nofollow" target="_blank">https://foo.bar.org</a><br/>Access-Control-Allow-Methods: POST, GET, OPTIONS, DELETE<br/>Access-Control-Max-Age: 86400</span></pre><p id="92f9" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">在这个响应中，服务器说“嘿，浏览器，我收到了你来自https://foo.bar.org<a class="ae ll" href="https://foo.bar.org" rel="noopener ugc nofollow" target="_blank">的请求。我支持的方法有POST、GET、OPTIONS和DELETE。您可以将此响应缓存24小时，这样您只需每24小时打一次电话。”</a></p><h1 id="f338" class="mi jv iq bd jw mj mk ml jz mm mn mo kc mp mq mr kg ms mt mu kk mv mw mx ko my bi translated">结论</h1><p id="1648" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">好了，这是所有的基础知识。感谢您的阅读！！</p><p id="83a8" class="pw-post-body-paragraph kq kr iq ks b kt lm kv kw kx ln kz la kd lo lc ld kh lp lf lg kl lq li lj lk ij bi translated">如果您有任何问题、建议或其他任何事情，请随时发表评论！你可以在我的<a class="ae ll" href="https://zachcodes.com/" rel="noopener ugc nofollow" target="_blank">网站</a>了解更多关于我的信息</p></div></div>    
</body>
</html>