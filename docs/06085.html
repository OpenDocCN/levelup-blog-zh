<html>
<head>
<title>How to use React Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React上下文</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-react-context-bb4d0b8a63ee?source=collection_archive---------1-----------------------#2020-10-25">https://levelup.gitconnected.com/how-to-use-react-context-bb4d0b8a63ee?source=collection_archive---------1-----------------------#2020-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/83424b1b1c7d9ff14fce54d72193a2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1inm-f7ne5dabiezG1ICxA.jpeg"/></div></div></figure><p id="05cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React Context是React v16.3.0 中引入的强大特性<a class="ae kw" href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" rel="noopener ugc nofollow" target="_blank">。它允许您从组件的呈现方法中的当前上下文(例如，父级)中访问值，通常您只能访问其本地状态和属性。这为组件之间共享值创建了一个非常灵活的系统。在本文中，我们将介绍如何使用React上下文创建共享状态，以及如何在子组件中使用该状态。</a></p><p id="99fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文假设您熟悉React的基础知识，比如JSX、组件、状态和道具。如果你还不熟悉这些概念，我建议你先阅读<a class="ae kw" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank">官方React文档</a>。</p><h1 id="c4ee" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是反应上下文？</h1><p id="d1bf" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">React Context是一个新特性，它允许您在组件之间共享数据。它在概念上类似于React的<code class="fe ma mb mc md b">useState()</code>钩子，但是它允许你一次跨多个组件共享数据。使用上下文API最常见的用例是在一个或多个子组件之间共享状态。让我们看一个例子:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ba8e" class="mm ky iq md b gy mn mo l mp mq">import React from 'react'</span><span id="cb83" class="mm ky iq md b gy mr mo l mp mq">const ParentComponent = () =&gt; {<br/>    const [counter, setCounter] = React.useState(0)</span><span id="b2fe" class="mm ky iq md b gy mr mo l mp mq">    return (<br/>        &lt;ChildComponent<br/>            counter={counter}<br/>            onIncrement={() =&gt; setCounter(counter + 1)}<br/>        /&gt;<br/>    )<br/>}</span><span id="351c" class="mm ky iq md b gy mr mo l mp mq">const ChildComponent = ({ counter, onIncrement }) =&gt; {<br/>    return (<br/>        &lt;div&gt;<br/>            {counter}<br/>            &lt;button onClick={onIncrement}&gt;increment&lt;/button&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="b06c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们有一个<code class="fe ma mb mc md b">&lt;ParentComponent&gt;</code>，它用初始值<code class="fe ma mb mc md b">0</code>设置自己的本地状态。该组件正在呈现一个<code class="fe ma mb mc md b">&lt;ChildComponent /&gt;</code>，它正在接收当前的<code class="fe ma mb mc md b">counter</code>状态作为道具。它还会在单击increment按钮时更新父级的计数器状态。</p><p id="f560" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对于简单的情况非常有效，但是如果我们想要在组件之间共享更多的状态，这可能会很快失控。组件开始变得越来越耦合，这使得它们更难维护和推理。我们可以做得更好！</p><p id="08d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用React上下文API在两个组件之间共享计数器状态，而不是将<code class="fe ma mb mc md b">counter</code>属性传递给<code class="fe ma mb mc md b">ChildComponent</code>。方法如下:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="fc99" class="mm ky iq md b gy mn mo l mp mq">import React from 'react'</span><span id="ad9c" class="mm ky iq md b gy mr mo l mp mq">const CounterContext = React.createContext(0)</span><span id="53c7" class="mm ky iq md b gy mr mo l mp mq">const ParentComponent = () =&gt; {<br/>    const [counter, setCounter] = React.useState(0)</span><span id="e87a" class="mm ky iq md b gy mr mo l mp mq">    const increment = () =&gt; setCounter(counter + 1)</span><span id="10c3" class="mm ky iq md b gy mr mo l mp mq">    return (<br/>        &lt;CounterContext.Provider value={{ counter, increment }}&gt;<br/>            &lt;ChildComponent /&gt;<br/>        &lt;/CounterContext.Provider&gt;<br/>    )<br/>}</span><span id="43de" class="mm ky iq md b gy mr mo l mp mq">const ChildComponent = () =&gt; {<br/>    const { counter, increment } = React.useContext(CounterContext)</span><span id="c72c" class="mm ky iq md b gy mr mo l mp mq">    return (<br/>        &lt;div&gt;<br/>            {counter}<br/>            &lt;button onClick={() =&gt; increment()}&gt;increment&lt;/button&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="5a16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">ChildComponent</code>现在从上下文中消耗计数器状态和增量动作，而不是接收它们作为道具。这允许我们避免将<code class="fe ma mb mc md b">ChildComponent</code>耦合到<code class="fe ma mb mc md b">ParentComponent</code>。</p><h1 id="63e9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">这和<code class="fe ma mb mc md b">useState()</code>有什么区别？</h1><p id="fc82" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">上下文API和<code class="fe ma mb mc md b">useState()</code>最大的区别是上下文API允许你一次在多个组件之间共享状态。<code class="fe ma mb mc md b">useState()</code>挂钩的范围仅限于单个组件。</p><p id="44eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个区别是，上下文API可以用来共享任何类型的数据，而不仅仅是状态。比如像函数。我们甚至可以使用上下文来共享整个Redux存储(但请不要这样做)。</p><h1 id="6027" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">上下文API是如何工作的？</h1><p id="2993" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><code class="fe ma mb mc md b">Context</code>对象是一种特殊类型的React对象，可用于创建和共享数据。它有两个组成部分:<code class="fe ma mb mc md b">Provider</code>和<code class="fe ma mb mc md b">Consumer</code>。提供者用于创建新的上下文对象，而使用者用于访问这些上下文中的值。</p><p id="bc45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上下文API允许您为多个消费者提供一个提供者。例如:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c931" class="mm ky iq md b gy mn mo l mp mq">import React from 'react'</span><span id="578c" class="mm ky iq md b gy mr mo l mp mq">const CounterContext = React.createContext(0)</span><span id="5dcc" class="mm ky iq md b gy mr mo l mp mq">const ParentComponent = () =&gt; {<br/>    const [counter, setCounter] = React.useState(0)</span><span id="2f7d" class="mm ky iq md b gy mr mo l mp mq">    const increment = () =&gt; setCounter(counter + 1)</span><span id="8aeb" class="mm ky iq md b gy mr mo l mp mq">    return (<br/>        &lt;CounterContext.Provider value={{ counter, increment }}&gt;<br/>            &lt;DisplayCounterComponent /&gt;<br/>            &lt;IncrementCounterComponent /&gt;<br/>        &lt;/CounterContext.Provider&gt;<br/>    )<br/>}</span><span id="33a2" class="mm ky iq md b gy mr mo l mp mq">const DisplayCounterComponent = () =&gt; {<br/>    const { increment } = React.useContext(CounterContext)</span><span id="7278" class="mm ky iq md b gy mr mo l mp mq">    return &lt;div&gt;{counter}&lt;/div&gt;<br/>}</span><span id="d804" class="mm ky iq md b gy mr mo l mp mq">const IncrementCounterComponent = () =&gt; {<br/>    const { increment } = React.useContext(CounterContext)</span><span id="8679" class="mm ky iq md b gy mr mo l mp mq">    return (<br/>        &lt;div&gt;<br/>            &lt;button onClick={() =&gt; increment()}&gt;increment&lt;/button&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="f712" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们使用<code class="fe ma mb mc md b">CounterContext</code>提供者在多个组件之间共享上下文。<code class="fe ma mb mc md b">DisplayCounterComponent</code>正在检索<code class="fe ma mb mc md b">counter</code>状态并显示它的值，而<code class="fe ma mb mc md b">IncrementCounterComponent</code>正在从上下文中检索<code class="fe ma mb mc md b">increment</code>动作。</p><h1 id="14db" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建自定义上下文提供程序</h1><p id="61e5" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在前面的例子中，我们直接使用了<code class="fe ma mb mc md b">CounterContext.Provider</code>。但是我们可以创建自己的<code class="fe ma mb mc md b">CounterProvider</code>组件，这将使重用上下文逻辑变得更加容易。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="3da7" class="mm ky iq md b gy mn mo l mp mq">import React from 'react'</span><span id="fd2b" class="mm ky iq md b gy mr mo l mp mq">const CounterContext = React.createContext(0)</span><span id="7682" class="mm ky iq md b gy mr mo l mp mq">const CounterProvider = ({ children, initialCount = 0 }) =&gt; {<br/>    const [counter, setCounter] = React.useState(initialCount)</span><span id="0978" class="mm ky iq md b gy mr mo l mp mq">    const increment = () =&gt; setCounter(counter + 1)</span><span id="9b76" class="mm ky iq md b gy mr mo l mp mq">    return (<br/>        &lt;CounterContext.Provider value={{ counter, increment }}&gt;<br/>            {children}<br/>        &lt;/CounterContext.Provider&gt;<br/>    )<br/>}</span></pre><p id="795b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">CounterProvider</code>组件从父组件接收一个初始计数，用来创建上下文的初始状态。它还接收了一个<code class="fe ma mb mc md b">children</code> prop，我们将通过它来呈现任何子组件。</p><p id="ea62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看如何在我们的应用程序中使用<code class="fe ma mb mc md b">CounterProvider</code>。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="9966" class="mm ky iq md b gy mn mo l mp mq">import React from 'react'</span><span id="f58b" class="mm ky iq md b gy mr mo l mp mq">const ParentComponent = () =&gt; {<br/>    return (<br/>        &lt;CounterProvider initialCount={0}&gt;<br/>            &lt;ChildComponent /&gt;<br/>        &lt;/CounterProvider&gt;<br/>    )<br/>}</span><span id="0197" class="mm ky iq md b gy mr mo l mp mq">const ChildComponent = () =&gt; {<br/>    const { counter, increment } = React.useContext(CounterContext)</span><span id="7ff4" class="mm ky iq md b gy mr mo l mp mq">    return (<br/>        &lt;div&gt;<br/>            {counter}<br/>            &lt;button onClick={() =&gt; increment()}&gt;increment&lt;/button&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="f0a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">useContext</code>钩子仍然用于在任何子组件中检索我们的计数器上下文。但是我们可以为此创建一个定制的<code class="fe ma mb mc md b">useCounterContext</code>钩子，以获得更好的可重用性。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="4075" class="mm ky iq md b gy mn mo l mp mq">const useCounterContext = () =&gt; React.useContext(CounterContext)</span></pre><p id="abe1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以在组件内部使用<code class="fe ma mb mc md b">useCounterContext</code>而不是<code class="fe ma mb mc md b">useContext</code>。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2a6a" class="mm ky iq md b gy mn mo l mp mq">const ChildComponent = () =&gt; {<br/>    const { counter, increment } = useCounterContext()</span><span id="ca8b" class="mm ky iq md b gy mr mo l mp mq">    return (<br/>        &lt;div&gt;<br/>            {counter}<br/>            &lt;button onClick={() =&gt; increment()}&gt;increment&lt;/button&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><h1 id="ff13" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结束语</h1><p id="0547" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">上下文API是在多个组件之间创建共享状态的强大工具。这是避免将组件耦合在一起的好方法，这使得它们更容易测试和维护。</p><p id="f6ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>也有一篇关于上下文API的文章。如果有兴趣了解更多，值得一看。</p></div></div>    
</body>
</html>