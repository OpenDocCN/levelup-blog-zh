# 成为一名优秀的程序员是一种选择

> 原文：<https://levelup.gitconnected.com/being-a-good-programmer-is-a-choice-424d3d20e9b>

## 程序员身上令人钦佩的品质，以及如何获得这些品质

![](img/367e5ffc859f96bea3536cbef9a1e17e.png)

阿尔弗雷德·阿劳什在 [Unsplash](https://unsplash.com/s/photos/admiration?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

在一个完美的世界里，我们可以按照这些看似合理的标准生活，就好像它们不仅仅是理想。在现实生活中的工作场所，通常不是每个人都这样。

有些程序员拥有令人钦佩的特质，而其他人则没有。我说的不是智商或天赋；有许多我不愿与之共事的杰出人士。我说的是不需要天才也能做的事情。

每天，你都在做出影响每个人的选择，不管你是否意识到。

# 选择谦逊而不是傲慢

“答应我，你永远不会变成他”，多年前，一位工作密友对我说。她指的是行为令人不快的 10x 程序员。我几乎很高兴我们渐行渐远，因为她从来没有看到我几乎变成那样。他的可取之处在于，他几乎在每个话题上都是正确的——而且他确实关心他的团队——他只是更关心做他认为正确的事情*。*

谦逊对于程序员来说可能很难。我们倾向于生活在自己的头脑中，因此，那些同样的头脑可能会在我们自己的底部找到出路。抛开玩笑和成见，我们工作的本质为傲慢设置了许多陷阱。

我们常常为自己的成就以及实现这些成就所涉及的技术复杂性和逻辑性感到自豪。我们喜欢准确性，非常厌恶错误——因为我们非常清楚错误会带来多大的痛苦。因此，我们保留憎恨糟糕代码的权利，这当然总是别人的。

我们不仅要理解机器，还要通过教机器按照我们想要的方式运转来谋生。在一个如此依赖科技的世界里，行使这样的权力是很诱人的。我们不能让它冲昏头脑。

我们还必须从工作中去除情绪，以支持逻辑和最佳业务成果，而不是个人或主观意见。我意识到这里的矛盾:我们几乎必须是机器人才能成为优秀的程序员，但同时也是优秀人类的程序员需要有情商。

# 选择好奇而不是冷漠

> 问问题的人是一时的傻瓜，不问问题的人是一辈子的傻瓜。——孔子

一个总是问问题的程序员是一个想了解一切的人。问一个可能一半团队成员已经知道答案的问题需要勇气——因为对于另一半团队来说，他们太害羞而不敢冒显得不了解的风险，他们正在做一件大好事。

如果一个好奇的程序员不知道某样东西是如何工作的，他是不会满意的。当然，不可能什么都知道，尤其是在你已经不知所措的情况下，但多了解一些会有助于缓解不知所措的感觉。

当阅读代码时，理解它是如何工作的是很重要的，但是如果你不做任何改变的话，通常不需要太详细。

当编辑、编写或调试代码时，故意忽略可能会在您的报告中表现为代码质量问题。一些“每天”的贡献者是:

*   决定使用代码，这是唯一可行的方法，但是不知道为什么其他的尝试都不可行。
*   修复 bug 的症状，但没有找到更深层次的根源。
*   使用 API 调用时，不了解传递给它的参数或返回的值(尽管糟糕的文档或缺乏示例可能是原因)
*   使用复制和粘贴，却对它的实际作用知之甚少。从你的产品中已有的代码中构建模式比从“网上某处”构建模式更合理，但是有时你的产品中已有的代码并不是最好的例子。

记住，如果我们 100%的时间都不好奇也没关系，但是你必须从某个地方开始。

# 选择慷慨而不是吝啬

我们大多数程序员都知道时间是我们能给予的最有价值的东西。钱？我们总是可以利用更多的时间，但是时间……我们再也回不来了。给我们一年时间，我们就能造出一些特别的东西。我们可以给某人 20 分钟的时间，让他们完成整整三天的工作。

我们中的许多人都遇到过一个或多个同事，你知道他们对某个现有的特性有着深奥的知识，而你却找不到任何关于这个特性的东西。现在你的任务是重访那个地区，当你问起时，他们守口如瓶。

也许是关于工作安全感的偏执。也许就像“我花了几个星期才学会这个，所以我不会放弃它”一样琐碎。也许他们认为学习“艰难的方式”是最好的方式。如果是因为他们很忙…嗯，每个人都一样。

如果他们可以通过与同事分享公司的知识产权来为你节省*时间*，他们应该有义务这样做；他们不应该囤积。同一家公司的开发人员不应该把彼此当成竞争对手；我们应该不断提高自己和同事的水平。

# 选择责任而不是恐惧

一个成熟程序员的标志是愿意承担责任。这是一个暗示后果的可怕的词，没有人喜欢潜在问题总是可以追溯到他们身上的想法。

一些程序员想通过以极快的速度编写代码成为公司的明星，却常常意识不到他们身后留下的破坏。如果工程部门的 CI 基础设施、代码审查或代码质量标准不足，这种情况尤其糟糕。如果在*你的*机器上能用就很容易否定了吧？

从不断地破坏构建或者破坏测试，到编写零测试覆盖的错误代码，有时只要程序员不断地交付特性，他们就可以逃脱。偶尔破坏一个构建或者测试失败并不是一种罪过……但是如果你习惯于这样，并且依赖他人来清理你的烂摊子，你就是在*对你的团队犯罪*(双关语)。

如果你不知道如何修理你弄坏的东西怎么办？寻求帮助——如果需要的话，结对计划——你可能会从中受益。关于责任，没有什么说你必须自己做所有的事情；这只能说明你承认了。

是什么造就了摇滚明星？规则和秩序，做正确的事情？绝对不会。相反，努力成为超级明星，你的团队会感激你的。什么是超级明星？他们像摇滚明星一样受人爱戴，他们以身作则，富有感染力。

# 选择彻底而不是不彻底

> TODO:在媒体上发布之前完成此部分。

看到我做了什么吗？在发表的文章里看起来不太对吧？我们也不喜欢在产品代码中看到它。

不同地区对“完成”的定义可能不同。在拉取请求级别，在故事级别，或者作为一个整体在特性级别。对于程序员来说，在你的团队中清晰地定义并一致地实践 Done，对你的 repo 的整体代码质量是有好处的。

未完成工作的例子:

*   编写只考虑快乐路径用例的代码，然后调用它 done。
*   修改依赖于状态的代码或操作序列，而不考虑它会如何影响其他用例。
*   编写不容易手动测试的代码，但不编写任何测试来确保它按预期工作。
*   假设其他人将要测试您编写的代码的每一个可能的逻辑分支，而没有看到测试计划或编写测试。

完成清单定义的非详尽示例:

*   代码正在本地编译和运行。
*   需求和用例所指定的代码功能。
*   单元测试被添加/更新并通过。
*   代码可以在所有支持的平台上运行。
*   代码正在编译，测试正在 CI 上传递。
*   代码的下游依赖者仍然在构建它并通过测试。
*   代码被清理(格式化、死代码等。)
*   代码经过了同行评审。
*   更新了 UI 测试自动化——如果适用的话。
*   构建自动化得到了更新—如果适用的话。
*   功能是独立验证的，即不是由其作者验证的。

我希望这是常识，但你会感到惊讶；如果一个团队没有[一个好的过程](/effective-practices-for-code-reviews-and-merging-7ccb4f9964f0)，开发人员在提交到主/主线/主干之前仅仅通过第一个要点是很常见的。

给“完成”下一个好的定义的一个障碍是让你的团队就最低限度是什么达成一致。

# 最后的想法

其中一半可以帮助你更好地编程；另一半将使程序员成为一个更好的合作者。

如果你有好奇心、细心和责任心，技能就会到来。负责、慷慨和谦逊会让你从那些只寻求提高技术能力的人中脱颖而出。