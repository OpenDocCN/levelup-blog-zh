<html>
<head>
<title>Learning JavaScript by Implementing Lodash Methods — Objects and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现Lodash方法学习JavaScript对象和函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-javascript-by-implementing-lodash-methods-objects-and-functions-b2b200996ae?source=collection_archive---------16-----------------------#2020-04-28">https://levelup.gitconnected.com/learning-javascript-by-implementing-lodash-methods-objects-and-functions-b2b200996ae?source=collection_archive---------16-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/23d3d362a95afcd685dbf8e9d5eaec43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m2cdSWkW3yMBqKPU"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·克洛德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="49be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lodash是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，现在JavaScript标准库正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="7ca3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些Lodash对象和函数方法，我们可以用自己的普通JavaScript实现来替换它们。</p><h1 id="8823" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mc md me mf b">unary</code></h1><p id="4363" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">Lodash <code class="fe mc md me mf b">unary</code>方法返回一个只用一个参数调用原始函数的函数。</p><p id="39a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以创建自己的函数，该函数返回一个调用原始函数的函数，如下所示:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="a1cb" class="mt lf it mf b gy mu mv l mw mx">const unary = (fn) =&gt; (val) =&gt; fn(val);</span></pre><p id="4663" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有自己的<code class="fe mc md me mf b">unary</code>函数，它接受一个返回<code class="fe mc md me mf b">(val) =&gt; fn(val)</code>的函数，这个函数只接受一个参数，然后用那个参数调用<code class="fe mc md me mf b">fn</code>。</p><p id="abd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以这样称呼它:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="654d" class="mt lf it mf b gy mu mv l mw mx">const result = ['6', '8', '10'].map(unary(parseInt));</span></pre><p id="60da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="bffa" class="mt lf it mf b gy mu mv l mw mx">[<br/>  6,<br/>  8,<br/>  10<br/>]</span></pre><p id="ba84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为<code class="fe mc md me mf b">result</code>的值。</p><h1 id="8e05" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包</h1><p id="3c26" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">Lodash <code class="fe mc md me mf b">wrap</code>方法采用一个<code class="fe mc md me mf b">wrapper</code>函数和另一个函数<code class="fe mc md me mf b">fn</code>，我们希望使用<code class="fe mc md me mf b">wrapper</code>作为第一个参数来调用这个函数。</p><p id="5a5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回一个函数，将值<code class="fe mc md me mf b">val</code>作为参数，并调用第二个参数中的函数，将包装器作为第一个参数，将<code class="fe mc md me mf b">val</code>作为第二个参数。</p><p id="0994" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以实现自己的<code class="fe mc md me mf b">wrap</code>函数，如下所示:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="eb7a" class="mt lf it mf b gy mu mv l mw mx">const wrap = (wrapper, fn) =&gt; (val) =&gt; fn(wrapper, val)</span></pre><p id="51d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mc md me mf b">wrap</code>函数取<code class="fe mc md me mf b">wrapper</code>和<code class="fe mc md me mf b">fn</code>，这两个是函数。然后我们返回一个函数，它接受一个参数，这个参数是<code class="fe mc md me mf b">val</code>，然后用<code class="fe mc md me mf b">wrapper</code>和<code class="fe mc md me mf b">val</code>调用<code class="fe mc md me mf b">fn</code>。</p><p id="4afb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以如下调用它，将Lodash <code class="fe mc md me mf b">_.escape</code>方法作为第一个参数，并使用我们自己的函数将文本包装在p标签周围，如下所示:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="664b" class="mt lf it mf b gy mu mv l mw mx">const p = wrap(_.escape, (func, text) =&gt; `&lt;p&gt;${func(text)}&lt;/p&gt;`);</span></pre><p id="790f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mc md me mf b">escape</code>方法对文本进行了转义，我们自己的函数包装了<code class="fe mc md me mf b">func(text)</code>，其中<code class="fe mc md me mf b">func</code>是<code class="fe mc md me mf b">escape</code>方法，因为它是第一个参数，<code class="fe mc md me mf b">text</code>是我们将传递给返回的<code class="fe mc md me mf b">p</code>函数的文本。</p><p id="4972" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以如下调用<code class="fe mc md me mf b">p</code>:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="c95a" class="mt lf it mf b gy mu mv l mw mx">const result = p('foo bar');</span></pre><p id="17fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe mc md me mf b">result</code>是<code class="fe mc md me mf b">&lt;p&gt;foo bar&lt;/p&gt;</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/eb483ba5b25dfb3fb3655bc2e45a855b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2tOT_1BmeQN2o1Mh"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@rachelhisko?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷切尔·希斯科</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c90b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mc md me mf b">forIn</code></h1><p id="787c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">Lodash <code class="fe mc md me mf b">forIn</code>方法遍历对象的自有和继承的可枚举字符串键控属性，并对每个属性运行一个<code class="fe mc md me mf b">iteratee</code>函数。</p><p id="e43b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">iteratee</code>是一个带<code class="fe mc md me mf b">value</code>、<code class="fe mc md me mf b">key</code>和<code class="fe mc md me mf b">object</code>参数的函数，我们可以通过显式返回<code class="fe mc md me mf b">false</code>来停止循环</p><p id="cd50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下实现自己的<code class="fe mc md me mf b">forIn</code>功能:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="3c12" class="mt lf it mf b gy mu mv l mw mx">const forIn = (object, iteratee) =&gt; {<br/>  for (const key in object) {<br/>    const result = iteratee(object[key], key, object);<br/>    if (result === false) {<br/>      break;<br/>    }<br/>  }<br/>}</span></pre><p id="7543" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有接受一个<code class="fe mc md me mf b">object</code>和一个<code class="fe mc md me mf b">iteratee</code>函数的<code class="fe mc md me mf b">forIn</code>函数。</p><p id="b21e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在函数内部，我们使用了<code class="fe mc md me mf b">for...in</code>循环来遍历<code class="fe mc md me mf b">object</code>的所有可枚举own和可枚举string键。</p><p id="3524" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在循环内部，我们用值调用<code class="fe mc md me mf b">iteratee</code>函数，这个值是通过使用<code class="fe mc md me mf b">object[key]</code>、<code class="fe mc md me mf b">key</code>本身和<code class="fe mc md me mf b">object</code>得到的。我们将<code class="fe mc md me mf b">iteratee</code>的返回值赋给<code class="fe mc md me mf b">result</code>。</p><p id="7d08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么如果<code class="fe mc md me mf b">result</code>是<code class="fe mc md me mf b">false</code>，那么我们就打破循环。否则，它将继续运行。</p><p id="3120" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以如下调用我们的<code class="fe mc md me mf b">forIn</code>函数:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="45f1" class="mt lf it mf b gy mu mv l mw mx">function Foo() {<br/>  this.a = 1;<br/>  this.b = 2;<br/>}</span><span id="98e6" class="mt lf it mf b gy mz mv l mw mx">Foo.prototype.c = 3;</span><span id="c582" class="mt lf it mf b gy mz mv l mw mx">forIn(new Foo(), (value, key) =&gt; console.log(key));</span></pre><p id="399a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个<code class="fe mc md me mf b">Foo</code>构造函数，它有两个自己的属性<code class="fe mc md me mf b">a</code>和<code class="fe mc md me mf b">b</code>。它还有一个额外的继承属性<code class="fe mc md me mf b">c</code>。</p><p id="c614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用一个<code class="fe mc md me mf b">Foo</code>实例调用<code class="fe mc md me mf b">forIn</code>，并传入一个记录了<code class="fe mc md me mf b">Foo</code>实例的键的回调函数。</p><p id="b7bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们应该看到控制台日志输出中记录的<code class="fe mc md me mf b">a</code>、<code class="fe mc md me mf b">b</code>和<code class="fe mc md me mf b">c</code>。</p><h1 id="f8e2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="f1a1" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">unary</code>和<code class="fe mc md me mf b">wrap</code> Lodash方法都返回一个接受一些参数的函数，并调用作为参数从返回的函数传入的原始函数。</p><p id="22c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lodash的<code class="fe mc md me mf b">forIn</code>方法类似于<code class="fe mc md me mf b">for...in</code>循环，只是我们可以用我们的<code class="fe mc md me mf b">iteratee</code>函数返回<code class="fe mc md me mf b">false</code>来中断循环。在每次迭代中运行<code class="fe mc md me mf b">iteratee</code>，直到它返回<code class="fe mc md me mf b">false</code>。</p></div></div>    
</body>
</html>