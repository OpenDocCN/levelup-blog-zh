<html>
<head>
<title>TypeScript: advanced and esoteric</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿:高级而深奥</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-advanced-and-esoteric-d88560f51767?source=collection_archive---------1-----------------------#2022-10-23">https://levelup.gitconnected.com/typescript-advanced-and-esoteric-d88560f51767?source=collection_archive---------1-----------------------#2022-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ce1e1c261c1af0185f2b99a901641b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YPPssdSpb4Al5Hef.jpg"/></div></div></figure><p id="091b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将探索使TypeScript更具动态性的鲜为人知的特性。</p><p id="a358" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一部分将介绍依赖泛型来创建新类型的动态类型，这些新类型可能看起来非常不同，这取决于它们接收的类型参数。这一部分将包括属性访问器、条件、推断和递归类型，它属于“高级”类别。</p><p id="e4e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第二个“深奥”的部分，我们将使用这些类型来实现数字文字的加减逻辑。没有JavaScript，只有类型。如果您已经知道如何使用上述高级类型，请直接跳到该部分。</p><h2 id="8f34" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">属性访问器</h2><p id="f53b" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">当我们使用描述具有嵌套结构的对象的类型时，我们可以使用属性访问器语法来基于父类型的属性和子属性派生新类型。考虑这样一种类型，它表示一个API响应，在其<code class="fe lu lv lw lx b">data</code>属性中包含一个用户列表:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="5ab7" class="mg kx iq lx b be mh mi l mj mk">type ApiResponse = {<br/>  data: Array&lt;{<br/>    firstName: string<br/>    lastName: string<br/>    age: number<br/>  }&gt;<br/>  meta: {<br/>    page: number<br/>    count: number   <br/>  } <br/>}</span></pre><p id="6a3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用属性访问器语法来创建一个新的类型，通过访问<code class="fe lu lv lw lx b">data</code>属性来表示用户列表:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="f6d0" class="mg kx iq lx b be mh mi l mj mk">type UserList = ApiResponse["data"]<br/><br/>// is equal to<br/>// =&gt; type UserList = Array&lt;{ firstName: string, lastName: string, age: number }&gt;</span></pre><p id="f4d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更进一步，我们可以使用数组访问器语法并为单个用户创建一个类型:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="f178" class="mg kx iq lx b be mh mi l mj mk">type User = UserList[number]<br/><br/>// is equal to<br/>// type User = { firstName: string, lastName: string, age: number }</span></pre><p id="c3cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是使用属性访问器的一种非常常见的方式，但是当我们将属性访问器与泛型类型结合起来时，事情就变得更有趣了。当我们将泛型的类型参数限制为特定的类型集时，我们可以使用属性访问器语法来访问属于该类型集的类型的属性。例如，我们可以将类型参数限制为<code class="fe lu lv lw lx b">any[]</code>(包括所有数组类型)，并访问任何数组上可用的属性。在下面的例子中，我们访问了<code class="fe lu lv lw lx b">length</code>属性，该属性创建了一个与<code class="fe lu lv lw lx b">X</code>数组中的元素数量相等的数字文本类型:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="b029" class="mg kx iq lx b be mh mi l mj mk">type Length&lt;X extends any[]&gt; = X["length"]<br/><br/>type Result1 = Length&lt;[]&gt;         //  =&gt; 0<br/>type Result2 = Length&lt;[1, 2, 3]&gt;  // =&gt; 3</span></pre><p id="e769" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这种类型<code class="fe lu lv lw lx b">Length</code>在实际应用中并不十分有用，但是在本文后面我们讨论TypeScript的更深奥的用法时，它会派上用场。不过现在，我们可以用它来演示两个有趣的想法。</p><p id="805c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个是关键字<code class="fe lu lv lw lx b">extends</code>的使用。它的确切含义是<code class="fe lu lv lw lx b">extends</code>左侧的一个类型集合包含在右侧的一个类型集合中。在实践中，这些超类型/子类型关系会变得非常复杂，很难解释，因此根据上下文，我们可以将它们理解为“继承自”、“等于”，甚至“看起来有点像”的关系。通过本文中的例子，我们将看到<code class="fe lu lv lw lx b">extends</code>的不同用法。</p><p id="6592" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，我们可以得出TS类型的语法和模仿其功能的JavaScript函数的语法之间的相似性:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="8e8a" class="mg kx iq lx b be mh mi l mj mk">// a type<br/>type Length&lt;X extends any[]&gt; = X["length"]<br/><br/>// a function<br/>const length = (array: any[]) =&gt; array.length</span></pre><p id="39a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意不同类型的标记如何映射到JS函数的标记:</p><ul class=""><li id="8f0b" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">类型名→函数名</li><li id="c3f9" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">类型参数→函数参数</li><li id="259f" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">类型参数限制→函数参数类型</li><li id="fee0" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">类型定义→函数体</li></ul><p id="492e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住这种映射是有用的，因为它会使理解更复杂的类型变得更容易。</p><h2 id="8c20" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">条件类型</h2><p id="fd4e" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">条件类型允许我们在类型定义中引入if/else逻辑，并使它们更加动态。在TypeScript中，我们总是使用三元语法来定义条件语句。它们以使用<code class="fe lu lv lw lx b">SomeType extends SomeOtherType</code>符号的条件本身开始，后面是该条件的true和false分支。</p><p id="08ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个非常基本的条件类型，它将根据收到的类型参数创建<code class="fe lu lv lw lx b">true</code>或<code class="fe lu lv lw lx b">false</code>文字类型:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="3e54" class="mg kx iq lx b be mh mi l mj mk">type IsOne&lt;X&gt; = X extends 1 ? true : false<br/><br/>type Result1 = IsOne&lt;1&gt;      // =&gt; true<br/>type Result2 = IsOne&lt;2&gt;      // =&gt; false<br/>type Result2 = IsOne&lt;"1"&gt;    // =&gt; false</span></pre><p id="3e1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也可以嵌套多个三元运算符来描述更复杂的条件。在下面的示例中，我们定义了一个提取某些数组类型的项目类型的类型:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="13f6" class="mg kx iq lx b be mh mi l mj mk">type ItemType&lt;A&gt; = A extends Array&lt;number&gt;<br/>  ? number<br/>  : A extends Array&lt;string&gt;<br/>  ? string<br/>  : A extends Array&lt;boolean&gt;<br/>  ? boolean<br/>  : unknown<br/><br/>type Result1 = ItemType&lt;Array&lt;number&gt;&gt;  // =&gt; number<br/>type Result2 = ItemType&lt;Array&lt;string&gt;&gt;  // =&gt; string<br/>type Result3 = ItemType&lt;Array&lt;{}&gt;&gt;      // =&gt; unknown</span></pre><p id="383a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lx b">ItemType</code>的这个实现只支持数字、字符串和布尔数组，否则将默认为<code class="fe lu lv lw lx b">unknown</code>类型。我们可以包含更多的嵌套三元运算符来支持其他类型，但这很快就变得不切实际了。有一种更好、更健壮的方法来实现这个逻辑，但是为了理解它，我们需要先了解类型推断。</p><h2 id="468e" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">类型推断</h2><p id="b281" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">条件类型本身是有用的，但是当与关键字<code class="fe lu lv lw lx b">infer</code>一起使用时，它们变得特别强大。这个关键字让我们在我们的<code class="fe lu lv lw lx b">extends</code>约束中定义一个变量，所以我们可以稍后从类型定义中引用或返回这个变量。</p><p id="3a46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让它发挥作用，我们将重新定义我们的<code class="fe lu lv lw lx b">ItemType</code>，使其变得通用并支持任何类型的数组:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="9b84" class="mg kx iq lx b be mh mi l mj mk">type ItemType&lt;A&gt; = A extends Array&lt;infer I&gt; ? I : unknown<br/><br/>type Result1 = ItemType&lt;number[]&gt;      // =&gt; number<br/>type Result2 = ItemType&lt;string[]&gt;      // =&gt; string</span></pre><p id="bd3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们对<code class="fe lu lv lw lx b">extends</code>使用了类似的逻辑，只是我们没有为数组指定确切的项目类型，而是让TypeScript计算出来并保存在<code class="fe lu lv lw lx b">I</code>类型变量中，然后我们可以返回它。</p><p id="ecb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">条件类型和<code class="fe lu lv lw lx b">infer</code>关键字的组合出现在TS附带的许多实用程序类型中。一个这样的类型是<code class="fe lu lv lw lx b">Awaited</code>，它“解开”一个承诺，并返回该承诺将解析的值的类型。考虑到不同种类的承诺，<code class="fe lu lv lw lx b">Awaited</code>的具体实现更加复杂，但简化版与我们的<code class="fe lu lv lw lx b">ItemType</code>非常相似:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="271e" class="mg kx iq lx b be mh mi l mj mk">type Unwrap&lt;T&gt; = T extends Promise&lt;infer I&gt; ? I : never<br/><br/>type Result = Unwrap&lt;Promise&lt;{ status: number }&gt;&gt;  // =&gt; { status: number }</span></pre><p id="779d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TS自带的另一个有趣类型是<code class="fe lu lv lw lx b">ReturnType</code>。这个函数将函数类型表达式作为参数，并从该函数的返回类型创建一个类型:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="d780" class="mg kx iq lx b be mh mi l mj mk">type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = <br/>  T extends (...args: any) =&gt; infer R <br/>    ? R <br/>    : any<br/><br/>type Result = ReturnType&lt;(s: string) =&gt; number&gt;  // =&gt; number</span></pre><p id="1712" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个实现中，我们两次依赖于关键字<code class="fe lu lv lw lx b">extends</code>。左边的一个确保只有函数类型可以传入，右边的一个定义了条件。该条件将<code class="fe lu lv lw lx b">T</code>参数与函数签名进行匹配，丢弃其参数类型，只保留返回类型<code class="fe lu lv lw lx b">R</code>。</p><h2 id="ad2b" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">递归类型</h2><p id="441d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">递归类型是一种在其定义中引用自身的类型。递归类型有许多应用，但最常见的应用之一是替代循环。TypeScript没有专门的关键字来进行循环，但是我们可以通过使用递归来重复执行一些逻辑，从而绕过这个限制。</p><p id="e77a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了看到递归的作用，我们将再次参考<code class="fe lu lv lw lx b">ItemType</code>，只是这一次我们将使用N维数组(数组的数组):</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="8d1f" class="mg kx iq lx b be mh mi l mj mk">type ItemType&lt;A&gt; = A extends Array&lt;infer I&gt;<br/>  ? ItemType&lt;I&gt;<br/>  : A<br/><br/>type Result1 = ItemType&lt;number[]&gt;      // =&gt; number<br/>type Result2 = ItemType&lt;number[][][]&gt;  // =&gt; number</span></pre><p id="daa5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里需要注意的重要一点是，我们在定义中引用了<code class="fe lu lv lw lx b">ItemType</code>。这允许我们通过“剥离”数组层并将结果传递回<code class="fe lu lv lw lx b">ItemType</code>来检查数组项类型是否是数组本身。只有当我们到达内部项目类型时，条件才变为假，我们才退出循环。</p><h2 id="166b" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">变得深奥</h2><p id="0741" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">既然我们已经讨论了所有这些类型，让我们看看它们的实际应用。通常，我会提倡用现实生活中的例子来练习，但不是在这种情况下。这些类型派上用场的用例并不常见，需要长时间的讨论来理解每个用例的上下文，这将不可避免地将注意力从重要的东西上转移开。所以我们不去真实世界，而是去有趣和深奥的地方。</p><p id="2dc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将实现<code class="fe lu lv lw lx b">Add</code>和<code class="fe lu lv lw lx b">Sub</code>类型，这两种类型各有两个数字参数，并对它们进行加减运算。这些类型根本没有任何实际用途，但它们会给我们提供大量机会，以创造性的方式实践我们所学的知识。</p><p id="6a23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">加法</strong></p><p id="f7ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先构建<code class="fe lu lv lw lx b">Add</code>类型，它应该是这样工作的:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="7522" class="mg kx iq lx b be mh mi l mj mk">type Add&lt;A extends number, B extends number&gt; = // to be defined<br/><br/>type Result = Add&lt;3, 2&gt;   // =&gt; 5</span></pre><p id="dc29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们遇到的第一个问题是，TypeScript不能对数字文字做太多事情(也不能对其他基本类型做太多事情)。TypeScript并不是为这种方式而设计的，承认它的局限性很重要。然而，如果我们看看数组类型，我们会发现我们可以使用一个spread操作符，这个简单的事实给了我们很多控制。</p><p id="48b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用spread操作符，我们可以进行相当多的转换——我们可以连接数组，获取数组的第一个和最后一个元素，以及追加、预先考虑和删除单个元素。正如您可能已经猜到的，我们将使用数组来绕过我们提到的数值的限制。</p><p id="1a71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现我们的<code class="fe lu lv lw lx b">Add</code>类型，我们将遵循以下步骤:</p><ol class=""><li id="2d8b" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mz mr ms mt bi translated">将数值转换为大小相等的元组</li><li id="4796" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mz mr ms mt bi translated">将得到的数组连接成一个新数组</li><li id="164b" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mz mr ms mt bi translated">获取这个数组的长度，它等于数值的总和</li></ol><p id="ba6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是这个算法的一个可视化表示:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fceeb95fce564512ac91ca6611ef1b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FBbpMjp6krxVMLdU.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">使用数组加法</figcaption></figure><p id="1c42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从将数字文字转换成元组开始。在JavaScript中有多种方法可以做到这一点，但是考虑到TS的限制和缺乏适当的循环，我们必须使用递归来达到预期的结果。我们一会儿将讨论类型实现，但首先，让我们来看一段模拟我们将要实现的逻辑的JavaScript代码:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="85b7" class="mg kx iq lx b be mh mi l mj mk">const toTuple = (n: number, arr: any[] = []) =&gt; {<br/>  if (arr.length === n) {<br/>    return arr<br/>  } else {<br/>    const newTuple = [...arr, 0]<br/>    return toTuple(n, newTuple)<br/>  }<br/>}<br/><br/>toTuple(3)    // =&gt; [0, 0, 0]</span></pre><p id="5983" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们从一个空数组开始，不断向其中追加新的项，并递归地调用函数，直到获得数组中预期的项数。这里任意使用值<code class="fe lu lv lw lx b">0</code>,因为我们不关心数组项的值，而只关心它们的总数。</p><p id="4b43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经理解了逻辑应该如何工作，我们可以创建我们的<code class="fe lu lv lw lx b">ToTuple</code>类型(同时利用我们之前创建的<code class="fe lu lv lw lx b">Length</code>类型):</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="c10e" class="mg kx iq lx b be mh mi l mj mk">type ToTuple&lt;N extends number, T extends any[] = []&gt; =<br/>  Length&lt;T&gt; extends N<br/>    ? T<br/>    : ToTuple&lt;N, [...T, 0]&gt;</span></pre><p id="681d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要一种连接两个元组的方法。这可以通过将两个元组扩展成一个新的元组来容易地实现:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="cb73" class="mg kx iq lx b be mh mi l mj mk">type Concat&lt;A extends any[], B extends any[]&gt; = [...A, ...B]</span></pre><p id="7dd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，为了得到总和，我们需要得到结果元组的长度。我们已经有了可以做到这一点的类型，所以我们只需要把所有的部分放在一起:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="3cc0" class="mg kx iq lx b be mh mi l mj mk">type Add&lt;A extends number, B extends number&gt; = Length&lt;<br/>  Concat&lt;ToTuple&lt;A&gt;, ToTuple&lt;B&gt;&gt;<br/>&gt;<br/><br/>type Result1 = Add&lt;1, 1&gt;    // =&gt; 2<br/>type Result2 = Add&lt;2, 5&gt;    // =&gt; 7</span></pre><p id="89b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">减法</strong></p><p id="1c58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lx b">Sub</code>类型的签名如下:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="4a7d" class="mg kx iq lx b be mh mi l mj mk">type Sub&lt;A extends number, B extends number&gt; = // to be defined<br/><br/>type Result = Sub&lt;6, 2&gt;   // =&gt; 4</span></pre><p id="3495" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这种类型，我们也要依赖数组，但是逻辑会有所不同。为了从数组<code class="fe lu lv lw lx b">A</code>中减去数组<code class="fe lu lv lw lx b">B</code>，我们将:</p><ol class=""><li id="bf8e" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mz mr ms mt bi translated">如果是，推断剩余部分</li><li id="9621" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mz mr ms mt bi translated">获取余数的长度</li></ol><p id="001f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个直观的表示:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d099e6d1afece44121903a517fcf6462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OCu8VmvW-TURxbr3.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">使用数组的减法</figcaption></figure><p id="e78f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以重用前一个示例中的<code class="fe lu lv lw lx b">ToTuple</code>和<code class="fe lu lv lw lx b">Length</code>类型，因此得到的类型如下所示:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="472b" class="mg kx iq lx b be mh mi l mj mk">type Sub&lt;A extends number, B extends number&gt; = <br/>  ToTuple&lt;A&gt; extends [...ToTuple&lt;B&gt;, ...infer U]<br/>    ? Length&lt;U&gt;<br/>    : unknown<br/><br/>type Result1 = Sub&lt;5, 2&gt;  // =&gt; 3<br/>type Result2 = Sub&lt;3, 3&gt;  // =&gt; 0<br/>type Result3 = Sub&lt;2, 5&gt;  // =&gt; unknown</span></pre><p id="ef86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，前两种情况如预期的那样工作，但是如果数组<code class="fe lu lv lw lx b">B</code>大于数组<code class="fe lu lv lw lx b">A</code>，就会出现问题。根据减法的基本性质(<code class="fe lu lv lw lx b">2 - 5 = -(5 - 2)</code>)，这个问题的解决方案是<code class="fe lu lv lw lx b">A</code>和<code class="fe lu lv lw lx b">B</code>交换位置，将结果的符号改为负数:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="8dfa" class="mg kx iq lx b be mh mi l mj mk">type Sub&lt;A extends number, B extends number&gt; = <br/>  ToTuple&lt;A&gt; extends [...ToTuple&lt;B&gt;, ...infer U]<br/>    ? Length&lt;U&gt;<br/>    : Negative&lt;Sub&lt;B, A&gt;&gt;</span></pre><p id="2c1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还没有<code class="fe lu lv lw lx b">Negative</code>类型，我们来定义一下。首先，我们可以使用字符串插值轻松地附加一个减号:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="1e4b" class="mg kx iq lx b be mh mi l mj mk">type Negative&lt;N extends number&gt; = `-${N}`<br/>type Result = Negative&lt;5&gt; // =&gt; "-5"</span></pre><p id="593f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果，我们得到一个字符串文字类型，为了将它转换成一个数字，我们将使用TypeScript &gt;= 4.8中的一个新特性，它允许我们在条件类型中对<code class="fe lu lv lw lx b">infer</code>类型变量使用<code class="fe lu lv lw lx b">extends</code>约束:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="bd13" class="mg kx iq lx b be mh mi l mj mk">type ToNumber&lt;T&gt; = T extends `${infer N extends number}` <br/>  ? N <br/>  : never<br/><br/>type Negative&lt;N extends number&gt; = ToNumber&lt;`-${N}`&gt;<br/><br/>type Result = Negative&lt;5&gt;  // =&gt; -5</span></pre><p id="6bd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这非常强大，因为我们现在可以检查我们的类型<code class="fe lu lv lw lx b">T</code> <em class="ne">是否看起来像</em>一个字符串，其中<em class="ne">的内容看起来像</em>一个数字，甚至可以推断并返回该数字。</p><p id="3652" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这些，我们可以确认我们所有的测试用例都如预期的那样工作:</p><pre class="ly lz ma mb gt mc lx md bn me mf bi"><span id="1d4a" class="mg kx iq lx b be mh mi l mj mk">type Sub&lt;A extends number, B extends number&gt; = <br/>  ToTuple&lt;A&gt; extends [...ToTuple&lt;B&gt;, ...infer U]<br/>    ? Length&lt;U&gt;<br/>    : Negative&lt;Sub&lt;B, A&gt;&gt;<br/><br/>type Result1 = Sub&lt;5, 2&gt;  // =&gt; 3<br/>type Result2 = Sub&lt;3, 3&gt;  // =&gt; 0<br/>type Result3 = Sub&lt;2, 5&gt;  // =&gt; -3</span></pre><p id="2451" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经实现了<code class="fe lu lv lw lx b">Add</code>和<code class="fe lu lv lw lx b">Sub</code>类型，重要的是要承认，除了没有实际用途，它们也有一些缺陷。其中之一与计算复杂性有关——对于递归类型，TypeScript编译器的最大调用堆栈深度为1000，因此任何超过这个深度的数字都不起作用。另一个原因是我们的类型都不能处理负数，因为我们不能创建负长度的元组。</p><p id="dccb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">话虽如此，健壮的生产就绪型实现并不是我们的目标。相反，我们开始以创造性的方式实践我们所学的不同类型，而不会被具体用例的细枝末节分散注意力。</p><h2 id="03a6" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结论</h2><p id="d667" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">尽管如今TypeScript被广泛采用，但这种语言所提供的许多强大功能仍然相对不为人知。这些功能包括属性访问器，以及条件类型、推断类型和递归类型。诚然，这些类型的存在是为了解决我们不经常面临的非常具体的问题，但无论如何，在你的武器库中拥有它们是很重要的，以便有机会使用它们。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="adcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ne">原载于</em><a class="ae nm" href="https://konstantinlebedev.com/typescript-advanced-esoteric/" rel="noopener ugc nofollow" target="_blank"><em class="ne">https://konstantinlebedev.com</em></a><em class="ne">。</em></p></div></div>    
</body>
</html>