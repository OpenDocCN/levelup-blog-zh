<html>
<head>
<title>JavaScript pattern — the “singleton file”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript模式——“单例文件”</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-pattern-the-singleton-file-349d28eb98bd?source=collection_archive---------20-----------------------#2021-10-11">https://levelup.gitconnected.com/javascript-pattern-the-singleton-file-349d28eb98bd?source=collection_archive---------20-----------------------#2021-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b078a5b60cd176473208b68c222333b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OPn_CkXDm-TgXCHOwdHuuw@2x.jpeg"/></div></div></figure><p id="48f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">前几天，我偶然发现了我过去遇到的一些问题的解决方法。</p><p id="f26b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想这对于已经从事JavaScript工作一段时间的人来说可能是显而易见的，但是因为我花了一段时间才明白，所以我想我应该试着让其他人不要等待，即使只是一次。它也会让你们其他人开怀大笑。</p><p id="56c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不知道这种模式的正式名称是什么，所以我称它为“单例文件”——你可以在任何地方导入它，但它只创建一个所有东西最终都会使用的单个对象。</p><h2 id="1eeb" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">问题是</h2><p id="087f" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我遇到的问题是日志之类的服务，这些服务需要在大多数模块启动之前可用。起初，我尝试用一个<code class="fe lx ly lz ma b">initLogging</code>函数来做这件事，类似于大多数服务。然而，当系统启动并且所有模块都被导入时，一些模块代码在日志设置完成之前就已经运行了。</p><h2 id="d460" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">解决方案</h2><p id="f28c" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这个解决方案并没有那么巧妙，但是它工作得很好(至少对我来说):您将实际的日志记录器“对象”作为模块的一个导出。</p><h2 id="16c9" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">定义日志模块</h2><p id="3933" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我的大部分东西都使用温斯顿记录系统。我喜欢seri log/结构化日志的外观，但是现在开始工作太麻烦了。我目前使用的日志模块看起来有点像下面的代码。警告—有点长。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="c1f8" class="kz la it ma b gy mj mk l ml mm">import { createLogger, transports, format } from 'winston';<br/><br/>// Allow the logging level to be controlled at start time<br/>let level = process.env.LOG_LEVEL;<br/>if (process.env.NODE_ENV !== "test") {<br/>  console.info(`Logging at ${level} level.`)<br/>}<br/><br/>// This is the format for lines to be printed to console. The format varies<br/>// depending on the environment.<br/>const consoleLineFormat = format.printf(({ level, message, label, timestamp }) =&gt; {<br/>  if (process.env.NODE_ENV === "production") {<br/>    return `[${label}] ${level}: ${message}`;<br/>  } else {<br/>    return `${timestamp} [${label}] ${level}: ${message}`;<br/>  }<br/>});<br/><br/>let consoleFormat;<br/>if (process.env.NODE_ENV === "production") {<br/>  // Heroku captures info like timestamp anyway, don't duplicate it.<br/>  consoleFormat = format.combine(<br/>    format.splat(),<br/>    consoleLineFormat<br/>  );<br/>} else {<br/>  // Put more information in the dev logs<br/>  consoleFormat = format.combine(<br/>    format.splat(),<br/>    format.colorize(),<br/>    format.timestamp(),<br/>    consoleLineFormat<br/>  );<br/>}<br/><br/>// For file logs, use JSON<br/>const fileFormat = format.combine(<br/>  format.splat(),<br/>  format.json(),<br/>  format.timestamp()<br/>)<br/><br/>// Create the base logger; everything else comes from this.<br/>// We always log to console; exceptions are always logged, regardless<br/>// of the level that's set.<br/>const base_logger = createLogger({<br/>                              level: 'info',<br/>                              transports: [<br/>                                new transports.Console({ level: level, format: consoleFormat })<br/>                              ],<br/>                              exceptionHandlers: [<br/>                                new transports.Console({ format: consoleFormat })<br/>                              ]<br/>                            });<br/><br/>// For development, also log to files. No point in that for Heroku.<br/>if (process.env.NODE_ENV === "development") {<br/>  base_logger<br/>    .add(new transports.File({ filename: 'combined.log', level: 'debug', format: fileFormat }))<br/>    .add(new transports.File({ filename: 'errors.log', level: 'error', format: fileFormat }));<br/>}<br/><br/>// 'parentLogger' is exported to the other modules. They use the 'child'<br/>// function to create a local logger, tagged with the module name.<br/>export const parentLogger = Object();<br/>type childOptions = {<br/>  module: string;<br/>}<br/>parentLogger.child = function(opts: childOptions) {<br/>  return base_logger.child({ label: opts.module });<br/>}</span></pre><p id="7990" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很抱歉我写了这么长时间——我确实试着去掉了一些，但所有这些都是有原因的，我认为它可能对人们有用。</p><h2 id="caf1" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">使用日志模块</h2><p id="1fd6" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">幸运的是，实际使用起来很简单。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="e023" class="kz la it ma b gy mj mk l ml mm">import { parentLogger } from "./logger";<br/>const logger = parentLogger.child({ module: "events" })</span></pre><p id="ed33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样。现在本地代码简单地使用<code class="fe lx ly lz ma b">logger.info</code>，或者你想要的任何级别。每个模块里都是<code class="fe lx ly lz ma b">logger</code>，所以我不用记住其他名字。</p><h2 id="86c6" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">为什么有效</h2><p id="2774" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">老实说，我没有详细调查过这个。我猜想这是因为Node不让模块开始运行，直到它们正在导入的模块已经完成了初始运行——否则使用依赖项将是一场噩梦。如果有人确切知道，或知道不同的，请让我知道。</p><p id="24a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样。希望对某人有所帮助！</p><p id="1fc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哦——如果你想知道的话，这张图片与故事完全无关。找不到合适的岗位形象，就用“可爱的小狗”代替了。</p></div></div>    
</body>
</html>