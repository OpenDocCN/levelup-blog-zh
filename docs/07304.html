<html>
<head>
<title>The Blackbook Project (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Blackbook项目(第三部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-blackbook-project-part-3-3bfd4dc72f53?source=collection_archive---------17-----------------------#2021-02-07">https://levelup.gitconnected.com/the-blackbook-project-part-3-3bfd4dc72f53?source=collection_archive---------17-----------------------#2021-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f1df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">身份验证与授权</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25cfa71e61742e6bda91551f5df78722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBCeqOciHbxrS3e7n9gtPQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/darkmoonart_de-1664300/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3040862" rel="noopener ugc nofollow" target="_blank"> DarkmoonArt_de </a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3040862" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="18ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从我上次写这个项目已经有一段时间了。我的Kubernetes服务器崩溃了，我不得不重新设置它。这一次，我坚持使用一个预先准备好的解决方案，如<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/exposing-your-home-server-to-the-big-bad-internet-5cb2878e8a17">将您的家庭服务器暴露在恶劣的互联网</a>中所述的<a class="ae ky" href="https://microk8s.io/" rel="noopener ugc nofollow" target="_blank"> MicroK8s </a>。入口直接连接到互联网，SSL通过<a class="ae ky" href="https://www.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> Cloudflare </a>处理。此外，卷声明是直接磁盘访问，因为MicroK8s是一个单节点集群。新的Kubernetes描述文件仍然在我的GitHub库<a class="ae ky" href="https://github.com/rkamradt/blackbook-deploy" rel="noopener ugc nofollow" target="_blank"> blackbook-deploy </a>中。</p><p id="9d08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本系列的第2部分结束了，我们让后端服务器简单地返回被破解的JWT，前端将它显示为基本文本。很难看。JWT的大部分土地都不会被使用。但是有一个函数，<code class="fe lv lw lx ly b">claims.sub</code>将用于索引到一个<a class="ae ky" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>数据库中，以返回一个用户记录。该值是用户的电子邮件地址，并将成为该系统的用户标识符。</p><p id="ee16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的read profile服务将返回一个包含用户所有基本信息的用户记录，并且只对该用户可用。端点似乎会被错误地命名为“用户”。我选择用户是因为可能还有一类管理用户可以获得所有用户，或者除了他们自己以外的用户。但那将是以后的事。目前，它将只返回登录者的信息。</p><p id="4c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是授权的一个重要特征。一旦您通过登录屏幕发送凭证进行了身份验证，系统就知道您是谁，以及您有什么角色。目前，只有一个角色，即用户角色。但是我们仍然需要防止那个用户看到其他人的隐私数据。由于我们不能为每个用户分配一个角色，所以我们将根据用户id进行区分，用户id是从您进行身份验证(登录)时返回的JWT中获得的。</p><p id="da7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把这些数据存储在MongoDB中一个名为users的集合中。要让MongoDB在我们的系统中运行，我们可以遵循我的文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-kubernetes-cron-jobs-to-periodically-read-the-news-8b3b4513f8b7">如何使用Kubernetes Cron Jobs定期阅读新闻</a>中概述的过程。如果您一直关注我的Blackbook系列，那么您应该已经有了一个名为<code class="fe lv lw lx ly b">blackbook</code>的Kubernetes名称空间。如果没有，您应该现在创建一个，因为所有内容都将放在该名称空间中。在Kubernetes主机上将目录更改为blackbook-deploy，创建一个名为<code class="fe lv lw lx ly b">namespace.yaml</code>的文件，并输入以下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3107" class="md me it ly b gy mf mg l mh mi">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  labels:<br/>    name: blackbook<br/>  name: blackbook</span></pre><p id="cb4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你可以创建它:<code class="fe lv lw lx ly b">kubectl create -f namespace.yaml</code>。</p><p id="acde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以为MongoDB创建一个秘密。我不打算将它添加到脚本中，因为其中会有一个密码，所以我只打算从命令行运行它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4fb2" class="md me it ly b gy mf mg l mh mi">kubectl create secret generic mongo-secret -n blackbook \<br/>    --from-literal=username=mongo \<br/>    --from-literal=password=ognom</span></pre><p id="4613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然使用更好的密码。</p><p id="72cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为MongoDB设置一些存储。在我的Kubernetes主机上，我在<code class="fe lv lw lx ly b">/disk</code>安装了一个4tb的硬盘。因此，通过创建一个名为<code class="fe lv lw lx ly b">pv.yaml</code>的文件并添加以下内容，在该驱动器上创建一个<code class="fe lv lw lx ly b">PersistentVolume</code>:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="25f3" class="md me it ly b gy mf mg l mh mi">apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>  name: task-pv-volume<br/>  labels:<br/>    type: local<br/>spec:<br/>  capacity:<br/>    storage: 100Gi<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  hostPath:<br/>    path: "/disk"</span></pre><p id="8b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用命令<code class="fe lv lw lx ly b">kubectl create -f pv.yaml</code>创建它。注意<code class="fe lv lw lx ly b">PersistentVolume</code>不属于名称空间，在我的例子中，它已经存在，所以响应说它没有改变。请注意，存储空间仅设置为100，如果您愿意，可以将其设置为磁盘的最大大小。</p><p id="4e3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以使用<code class="fe lv lw lx ly b">PersistentVolumeClaim</code>在卷上创建一个声明。这将占用单个应用程序使用的<code class="fe lv lw lx ly b">PersistentVolume</code>的一部分，在本例中是MongoDB。创建一个名为<code class="fe lv lw lx ly b">pvc.yaml</code>的文件，并添加以下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c80c" class="md me it ly b gy mf mg l mh mi">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: task-pv-claim<br/>spec:<br/>  accessModes:<br/>    - ReadWriteMany<br/>  volumeMode: Filesystem<br/>  resources:<br/>    requests:<br/>      storage: 100Gi</span></pre><p id="1238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该索赔将占用整个<code class="fe lv lw lx ly b">PersistentVolume</code>。它还允许多个pod访问该声明，尽管这对于我们正在做的事情可能是不必要的。从<code class="fe lv lw lx ly b">kubectl create -n blackbook -f pvc.yaml</code>开始索赔。</p><p id="bb0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以启动并运行我们的MongoDB了。我将只使用一个副本，尽管设置三个或更多节点相对简单。要创建单个节点，创建一个名为mongodb.yaml的文件，并输入以下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bff5" class="md me it ly b gy mf mg l mh mi">apiVersion: apps/v1<br/>kind: StatefulSet<br/>metadata:<br/>  name: mongodb<br/>spec:<br/>  serviceName: "mongodb"<br/>  replicas: 1 <br/>  selector:<br/>    matchLabels:<br/>      app: mongodb<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mongodb<br/>        selector: mongodb<br/>    spec:<br/>      containers:<br/>      - name: mongodb<br/>        image: mongo:4.0.8<br/>        env:<br/>          - name: MONGO_INITDB_ROOT_USERNAME<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: mongo-secret<br/>                key: username<br/>          - name: MONGO_INITDB_ROOT_PASSWORD<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: mongo-secret<br/>                key: password<br/>        volumeMounts:<br/>        - name: mongodb-data<br/>          mountPath: /data/db<br/>      volumes:<br/>      - name: mongodb-data<br/>        persistentVolumeClaim:<br/>          claimName: task-pv-claim <br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mongodb<br/>  labels:<br/>    name: mongodb<br/>spec:<br/>  ports:<br/>  - port: 27017<br/>    targetPort: 27017<br/>  clusterIP: None<br/>  selector:<br/>    app: mongodb</span></pre><p id="73d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意一些事情，我们将MongoDB作为一个服务来启动。这有时被称为无头服务，因为没有一个单一的IP地址来平衡这些pods的负载。每个pod都有自己的IP地址。在您需要多个副本的情况下，可以这样做，您使用DSN名称<code class="fe lv lw lx ly b">mongodb-0</code>连接到主机，在本例中是零，因为只有一个副本，它从零开始计数。但是因为副本的命名是一致的，所以只要知道有多少副本在运行，就可以很容易地推断出名称。</p><p id="d42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个值得注意的事情是，<code class="fe lv lw lx ly b">PersistentVolumeClaim</code>被挂载为一个卷，该卷被挂载在MongoDB通常保存其数据的<code class="fe lv lw lx ly b">/data/db</code>处。最后，您可以看到如何使用秘密<code class="fe lv lw lx ly b">mongo-secret</code>来填充初始化root用户/密码的环境变量。</p><h2 id="5201" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">读取简档服务</h2><p id="be65" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">接下来，我们将修改read profile服务以连接到数据库并读取<code class="fe lv lw lx ly b">users</code>集合。将目录切换到<code class="fe lv lw lx ly b">blackbook-read-profile</code>库所在的位置。用这个命令<code class="fe lv lw lx ly b">npm install -s mongodb</code>将MongoDB客户机添加到依赖项列表中。然后我们就可以开始给<code class="fe lv lw lx ly b">server.js</code>添加一些代码了。首先，我们可以添加MongoDB客户端的导入和一些常量:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="eb5c" class="md me it ly b gy mf mg l mh mi">const MongoClient = require('mongodb').MongoClient<br/>const MONGO_USER = process.env.MONGO_USER<br/>const MONGO_PASS = process.env.MONGO_PASS<br/>const MONGO_SERVER = process.env.MONGO_SERVER || 'mongodb-0'<br/>const MONGO_PORT = process.env.MONGO_PORT || 27017</span><span id="f115" class="md me it ly b gy nf mg l mh mi">const dbName = 'blackbook'<br/>const mongourl = `mongodb://${MONGO_USER}:${MONGO_PASS}@${MONGO_SERVER}:${MONGO_PORT}`;<br/>const client = new MongoClient(mongourl, {<br/>  useUnifiedTopology: true<br/>})</span></pre><p id="1899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们稍后将从<code class="fe lv lw lx ly b">mongo-secret</code>中直接在描述符中设置这些环境变量。接下来，我们希望根据JWT中的<code class="fe lv lw lx ly b">claims.sub</code>读入用户数据，我们假设已经读入了用户数据。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e2e3" class="md me it ly b gy mf mg l mh mi">async function getUser(req, res, next) {<br/>  const client = new MongoClient(mongourl, {<br/>    useUnifiedTopology: true<br/>  })</span><span id="f9fb" class="md me it ly b gy nf mg l mh mi">  try {<br/>    const email = req.jwt.claims.sub<br/>    if(!email) {<br/>      console.log('no user in request')<br/>      return next()<br/>    }<br/>    console.log(`Connecting to ${MONGO_SERVER}`)<br/>    await client.connect()<br/>    console.log('Connected correctly to server')</span><span id="6c2d" class="md me it ly b gy nf mg l mh mi">    const db = client.db(dbName)<br/>    const query = { user: email };<br/>    var user = await db.collection('users').findOne(query);<br/>    if(!user) {<br/>      user = {<br/>        user: email,<br/>        firstName: '',<br/>        lastName: '',<br/>        privateData: 'sample private data'<br/>      }<br/>      const r = await db.collection('users').insertOne(user, {<br/>          w: 'majority',<br/>          wtimeout: 10000,<br/>          serializeFunctions: true,<br/>          forceServerObjectId: true<br/>        }<br/>      )<br/>    }</span><span id="4ea2" class="md me it ly b gy nf mg l mh mi">    res.json(user)<br/>  } catch (err) {<br/>    client.close()<br/>    console.log(err.stack)<br/>  }</span><span id="51d2" class="md me it ly b gy nf mg l mh mi">  console.log('Closing mongoDB connection')<br/>  client.close()<br/>  console.log('Ending')<br/>}</span></pre><p id="91ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为每个请求打开和关闭连接，这可能是个坏主意，但我会把解决这个问题留给学生做练习，哈哈。否则，这是一个非常简单的实现，几乎直接来自MongoDB示例页面。</p><p id="be16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它已经假设请求中的JWT是可用的，这是由<code class="fe lv lw lx ly b">authenticationRequired</code>方法完成的。如果没有完成，它将只返回文本“没有用户请求”。我永远也到不了那里，然而，<code class="fe lv lw lx ly b">authenticationRequired</code>方法应该抛出一个错误，并向前端客户端返回一个<code class="fe lv lw lx ly b">401</code> <code class="fe lv lw lx ly b">Unauthorized</code>错误。为了将所有这些联系在一起，<code class="fe lv lw lx ly b">/users</code>路径应该是这样的:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e8e5" class="md me it ly b gy mf mg l mh mi">app.get('/users', authenticationRequired, getUser)</span></pre><p id="aafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以使用提供的脚本构建新的后端:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f8d4" class="md me it ly b gy mf mg l mh mi">./buildbook</span></pre><p id="fdd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个docker图像并把它放在DockerHub上。</p><p id="cfea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进行部署，我们需要一个新的描述符文件。在blackbook-deploy存储库中切换到您的Kubernetes主机并编辑<code class="fe lv lw lx ly b">blackbookreadprofileservice.yaml</code>。用这个填进去:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="08e4" class="md me it ly b gy mf mg l mh mi">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: blackbookreadprofile-deployment<br/>  labels:<br/>    app: blackbookreadprofile<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: blackbookreadprofile<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: blackbookreadprofile<br/>    spec:<br/>      containers:<br/>      - name: blackbookreadprofile<br/>        image: docker.io/rlkamradt/blackbook-read-profile:latest<br/>        ports:<br/>        - containerPort: 3000<br/>        env:<br/>          - name: MONGO_USER<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: mongo-secret<br/>                key: username<br/>          - name: MONGO_PASS<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: mongo-secret<br/>                key: password<br/>          - name: MONGO_SERVER<br/>            value: mongodb-0<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: blackbookreadprofile-service<br/>spec:<br/>  type: ClusterIP<br/>  selector:<br/>    app: blackbookreadprofile<br/>  ports:<br/>  - port: 8080<br/>    targetPort: 3000</span></pre><p id="c977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了新的MongoDB环境变量之外，这就像我们完成第2部分时的情况一样。可以用<code class="fe lv lw lx ly b">kubectl apply -n blackbook -f blackbookreadprofileservice.yaml</code>启动。你可以用Postman来试试。您必须获得一个访问令牌，Postman应该能够指导您完成这个过程(我在以前的文章中描述过)。一旦你有了，点击网址，看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/55c781c9433ccb91db8800d40ec9d540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-lvBtv5Q25zUJLy8g54yA.png"/></div></div></figure><p id="43f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这是我第一次登录，它用一些默认数据创建了一个新记录。如果您仍然运行blackbook web应用程序，您也可以从那里运行它，它会稍微好看一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/34ead6a78db5af157ede1d6582bf9edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9d_slqWo_-l8A1T4eY1cg.png"/></div></div></figure><p id="3e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我打开了开发者的窗口，这样你就可以看到<code class="fe lv lw lx ly b">/users</code>的请求。</p><p id="d112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列的下一篇文章中，我将格式化前端以很好地显示数据，并允许您进行编辑。谢谢你坚持到最后，我希望你学到了一些东西。</p><p id="3c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub存储库提到:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/rkamradt/blackbook/tree/v0.2" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">rkamradt/blackbook</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">脸书，但是有21点和妓女。通过在…上创建帐户，为rkamradt/blackbook开发做出贡献</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ks nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://github.com/rkamradt/blackbook-read-profile/tree/v0.2" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">rkamradt/black book-read-profile</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">Blackbook的阅读服务。通过在…上创建帐户，为rkamradt/black book-read-profile开发做出贡献</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz ks nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://github.com/rkamradt/blackbook-deploy/tree/v0.2" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">rkamradt/black book-部署</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">将所有blackbook代码部署到Kubernetes的脚本。为rkamradt/blackbook-deploy开发做出贡献，创建一个…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz ks nl"/></div></div></a></div><p id="0928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提到的其他文章:</p><div class="ni nj gp gr nk nl"><a href="https://medium.com/swlh/the-blackbook-project-part-1-d93e1c16d1de" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">Blackbook项目第1部分</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">构建现实世界中基于React的应用程序</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="oc l nw nx ny nu nz ks nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://rlkamradt.medium.com/the-blackbook-project-part-ii-d39301e3d98c" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">Blackbook项目第二部分</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">添加后端来收集不知情用户的数据</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">rlkamradt.medium.com</p></div></div><div class="nu l"><div class="od l nw nx ny nu nz ks nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a rel="noopener  ugc nofollow" target="_blank" href="/exposing-your-home-server-to-the-big-bad-internet-5cb2878e8a17"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">将您的家庭服务器暴露在恶劣的互联网环境中</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">如何不陷入困境</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nu l"><div class="oe l nw nx ny nu nz ks nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-use-kubernetes-cron-jobs-to-periodically-read-the-news-8b3b4513f8b7"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">如何使用Kubernetes Cron Jobs定期阅读新闻</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">阅读新闻的微服务。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nu l"><div class="of l nw nx ny nu nz ks nl"/></div></div></a></div></div></div>    
</body>
</html>