<html>
<head>
<title>Get a Taste of Concurrency in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">体验Go中的并发性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/get-a-taste-of-concurrency-in-go-625e4301810f?source=collection_archive---------0-----------------------#2019-08-12">https://levelup.gitconnected.com/get-a-taste-of-concurrency-in-go-625e4301810f?source=collection_archive---------0-----------------------#2019-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e2d312f29675412a82449036183aabfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujvU431Mvkj2EOiXYWQLpw.jpeg"/></div></div></figure><p id="c076" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2006年，英特尔发布了首款双核CPU。不久之后，一种能够从多核中获益的语言(<a class="ae kw" href="https://golang.org/doc/faq" rel="noopener ugc nofollow" target="_blank"> Go </a>)诞生了。</p><h1 id="bbfa" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h1><p id="ecb6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">并发性是指以任意不确定的顺序执行一组指令，并且仍然能够产生与顺序执行功能相同的程序输出。</p><p id="34ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在现代程序中，指令的同时执行随处可见。例如，我们可以在服务于多个web请求的web服务器中看到它，或者在我们的IDE中编译代码，同时仍然能够编辑它。这个术语经常与<em class="ma">排比</em>混淆。</p><p id="54a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设你有一个三明治和一杯奶昔，你需要在3分钟内吃完。你可以做两件事:</p><p id="0fa5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">选择1: </strong> <br/> 1。要么咬一口三明治，咀嚼。<br/> 2。喝一口奶昔，喝一口。<br/> 3。重复这个过程，直到你在3分钟内完成。</p><p id="8ac8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">选择二:</strong> <br/> 1。你可以把整个三明治放进嘴里，喝光奶昔。<br/> 2。试着把它们一起吞下去。<br/> 3。等到你在3分钟内完成这两个问题。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/757ca42fafcb30dbac0a35a8b8edc914.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*qNjM5VafViMp2Uawbqrtpg.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">我的饮食超能力</figcaption></figure><p id="6fc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">选择1是并发，选择2是并行。并发是“同时进行”，并行是“同时执行”。你可以根据时间、地点和朋友之间的距离来选择任何一种方式，以充分利用每一种方式。😛</p><blockquote class="mk ml mm"><p id="36d7" class="jy jz ma ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">两个功能可能能够同时运行，但它们可能不是<em class="iq">并行</em>。并行执行意味着同时评估两个或更多独立的指令，这只有在有多个内核可用于运行这些指令的情况下才有可能。并发是指同时处理许多事情。并行意味着同时做那些事情。</p></blockquote><p id="c523" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">并发不是并行，但它确实启用了并行。如果你有一个处理器，你的代码不能是并行的，但是可以是并发的。如果有多个处理器可用，Go可以并行运行你的并发代码。</strong></p><h1 id="8475" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">可视化1，并行和并发</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/3ed9bcfe4d82ce910f877f5a432e2fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*-aYVt9tPWMSu_M8k8jl9Cw.jpeg"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><em class="mr">并行性和并发性</em></figcaption></figure><p id="13a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解并发性，我们将首先看到一个以<em class="ma">序列</em>运行指令集的程序。让我们考虑一个简单的程序，它通过调用一个网站的主页来检查这个网站是否已经打开。</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><em class="mr">向每个链接发出http GET请求时循环的一段字符串</em></figcaption></figure><ol class=""><li id="ae6b" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">在第9行，我们声明了一个字符串的<a class="ae kw" href="https://blog.golang.org/slices" rel="noopener ugc nofollow" target="_blank">切片</a>(比如说<em class="ma">数组</em>)</li><li id="4fdd" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">在第16行，我们声明了一个<a class="ae kw" href="https://tour.golang.org/moretypes/16" rel="noopener ugc nofollow" target="_blank">范围</a>来循环遍历字符串切片，并为切片中的每个元素(即链接)调用<code class="fe ni nj nk nl b">checkLink</code>函数。</li><li id="2645" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">在第22行，<code class="fe ni nj nk nl b">checkLink</code>函数向链接发出<code class="fe ni nj nk nl b">GET</code>请求，<strong class="ka ir">等待响应返回</strong>，然后记录成功或错误响应。</li></ol><h1 id="18ae" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">输出:</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/b1941abca4317dd22256f1ad12874832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fXS6LmQ0IMiW9fiZh9FalQ.gif"/></div></div></figure><p id="3612" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如在输出中观察到的那样，在调用每个链接后都有明显的延迟。对于每个请求，我们等待请求返回响应。在每个<code class="fe ni nj nk nl b">fetch</code>之间没有其他<em class="ma">执行路径</em>可以执行。这使得它成为一个<em class="ma">顺序</em>程序。</p><h1 id="d7bd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">可视化2，程序流程</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/ae6c05049a93b8338464a5dbc638013a.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*9irgN0gXqX-h_Q7o1OTKXw.jpeg"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">程序流程</figcaption></figure><blockquote class="mk ml mm"><p id="abb9" class="jy jz ma ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">一段代码的<strong class="ka ir"> <em class="iq">执行路径</em> </strong>称为<strong class="ka ir"> <em class="iq">例程</em> </strong>。在围棋中，它们被称为goroutines。每个Go程序都至少有一个goroutine，这是程序开始执行的主要函数。</p></blockquote><p id="27aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">等待的时间阻碍了我们的日常工作继续进行。这是对我们拥有的多核资源的浪费。让我们使用goroutine来解决这个问题。</p><h1 id="0e17" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">戈罗廷</h1><p id="6e7d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Go中的goroutine为我们的程序提供了一条新的执行路径。这些可以认为类似于类似于<strong class="ka ir"> C# </strong>和<strong class="ka ir"> Java </strong>这样的语言中的线程(它们其实是不同的但是我们在这里画一些图)。goroutine对系统的影响更小。由于较大的堆栈大小，一个线程消耗1MB的内存，而一个goroutine开始时只有其中的一小部分(2KB ),因为它的堆栈是可调整大小的。</p><blockquote class="mk ml mm"><p id="8fe0" class="jy jz ma ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">可以把goroutines想象成应用级线程。正如操作系统在硬件内核上切换操作系统线程一样，goroutines也在每个分配的操作系统线程上进行上下文切换。</p></blockquote><p id="4077" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用以下方法获得程序可用的CPU内核数量:</p><pre class="mc md me mf gt no nl np nq aw nr bi"><span id="96cb" class="ns ky iq nl b gy nt nu l nv nw">    // NumCPU returns the number of logical<br/>    // CPUs usable by the current process.<br/>    fmt.Println(runtime.NumCPU())</span></pre><p id="c794" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Goroutines没有返回唯一的标识符、名称或数据结构，它们只是匿名的工人。如果有兴趣，经验丰富的地鼠可以在这里阅读。</p><h1 id="a37f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用Goroutine</h1><p id="69b1" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一个新的程序可以通过使用关键字<code class="fe ni nj nk nl b">go</code>后接一个函数调用来启动。参数在主goroutine中计算，但函数在新的goroutine中执行。</p><pre class="mc md me mf gt no nl np nq aw nr bi"><span id="a2dd" class="ns ky iq nl b gy nt nu l nv nw">for _, link := range links {<br/>    go checkLink(link)<br/>}</span></pre><p id="782b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每个<code class="fe ni nj nk nl b">checkLink</code>函数在新的goroutine(执行路径)中执行，并且<em class="ma">主goroutine </em>未被<strong class="ka ir">阻塞</strong></p><h2 id="0f1a" class="ns ky iq bd kz nx ny dn ld nz oa dp lh kj ob oc ll kn od oe lp kr of og lt oh bi translated">输出:</h2><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/c683734c9ec2d01d3f59214a6c742737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*d4FD7jmVXIbtGcjybJD4ag.gif"/></div></div></figure><p id="03e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，控制台上没有记录任何内容。主goroutine为每个链接触发新的go routine，但它不等待它们完成。<br/>由于在触发goroutines的循环之后没有要执行的东西，程序退出。</p><h1 id="1133" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">视觉3，多个Goroutines同时运行</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/6c28e35011ce191da6a12dd88add8db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*1qta0jvXZNHD31bTQG46oQ.jpeg"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><em class="mr">多个goroutines同时运行</em></figcaption></figure><p id="83f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这在下面的代码中显而易见:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="c8ee" class="ns ky iq bd kz nx ny dn ld nz oa dp lh kj ob oc ll kn od oe lp kr of og lt oh bi translated"><strong class="ak">输出</strong>:</h2><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/02636eb242ac1643f72dfc900b142f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*428jGbRiyvD6Wyc3XW-e3g.gif"/></div></div></figure><blockquote class="mk ml mm"><p id="0ac0" class="jy jz ma ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">生成更多的goroutines不一定会提高程序的性能，因为它们可能不会同时执行。我们将在这篇文章的结尾了解它。</p></blockquote><p id="aef4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要一种方法在不同的goroutine之间进行通信(在本例中，通知主go routine它们的执行情况)并同步它们的任务。为了让一个goroutine向另一个goroutine发布消息，我们需要一个<em class="ma">管道</em>。在一端，goroutine可以发布消息，而在另一端，另一个goroutine可以使用我们所知的<strong class="ka ir">通道</strong>进行监听。</p><h1 id="b121" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">频道</h1><p id="a647" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">通道就是这些管道，不同的例程可以通过它们在不同的goroutines之间发送和接收某种类型的值。</p><h1 id="28f1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">视觉4，多个Goroutines通信</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/4f4e8485c4f50af75540131d2b48d84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*dvo22GtamWi-ERbTv461gg.jpeg"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><em class="mr">多个goroutines借助通道进行通信</em></figcaption></figure><p id="8af3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">引自golang官方巡演:</p><blockquote class="mk ml mm"><p id="8a8f" class="jy jz ma ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated"><a class="ae kw" href="https://tour.golang.org/concurrency/2" rel="noopener ugc nofollow" target="_blank">通道</a>是一个类型化的管道，通过它你可以用通道操作符<code class="fe ni nj nk nl b">&lt;-</code>发送和接收值。</p></blockquote><p id="a06f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要声明一个通道，我们使用:</p><pre class="mc md me mf gt no nl np nq aw nr bi"><span id="279a" class="ns ky iq nl b gy nt nu l nv nw">c := make(chan int)<br/><br/>go func() {<br/>    c &lt;- 42 // Send data to channel<br/>}()<br/><br/>fmt.Println(&lt;-c) // Receive data from channel</span></pre><p id="b210" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://play.golang.org/p/SHr3lpX4so" rel="noopener ugc nofollow" target="_blank">在这里播放</a></p><ol class=""><li id="0214" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">在通道<code class="fe ni nj nk nl b">c</code>中，我们可以发送和接收整数值。<strong class="ka ir">注</strong>:数据按箭头方向流动</li><li id="1be9" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">一旦一个例程向通道发送一些东西，代码执行例程就会被阻塞(默认情况下)，直到发送给通道的值在<strong class="ka ir">同一时间</strong>被另一端接收。</li><li id="c675" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">所谓“同一时间”，我们是指当数据在通道上发送时，通道预期接收的例程应该准备好同时接收。<a class="ae kw" href="https://play.golang.org/p/wBq5C2K9lsR" rel="noopener ugc nofollow" target="_blank">参见此处的</a>，我们不能在同一个goroutine中发送和接收，因为要发送到一个通道，接收端将在不同的时间激活。这时代码执行到达接收通道的语句(<code class="fe ni nj nk nl b">&lt;-c</code>)。</li><li id="4fab" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">如果没有接收者，例程将永远阻塞，并最终导致Go中的致命错误。你可以试试<a class="ae kw" href="https://play.golang.org/p/XPgsj2xS0F" rel="noopener ugc nofollow" target="_blank">这里</a></li></ol><p id="6f01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将<code class="fe ni nj nk nl b">goroutines</code>和<code class="fe ni nj nk nl b">channels</code>应用到我们的程序中。</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="e22f" class="ns ky iq bd kz nx ny dn ld nz oa dp lh kj ob oc ll kn od oe lp kr of og lt oh bi translated">输出:</h2><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/0e895c690bec3812ab5db9cbac3dd971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*klku8V7WTPLYU_Tu7Z_M5Q.gif"/></div></div></figure><blockquote class="mk ml mm"><p id="847e" class="jy jz ma ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">注意:输出将根据互联网速度和<a class="ae kw" href="https://golang.org/doc/faq#number_cpus" rel="noopener ugc nofollow" target="_blank"> GOMAXPROCS </a>的数量而变化，GOMAXPROCS 是可以一次执行的goroutines的数量。</p></blockquote><p id="e6ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用传统的<code class="fe ni nj nk nl b">for loop</code>的熟悉语法从通道接收，或者使用Golang的<code class="fe ni nj nk nl b">range</code>循环。</p><pre class="mc md me mf gt no nl np nq aw nr bi"><span id="51a3" class="ns ky iq nl b gy nt nu l nv nw">for index := 0; index &lt; len(links); index++ {<br/>    fmt.Println(&lt;-c)<br/>}</span></pre><p id="5003" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传统的循环是阻塞的，因为它不能完成迭代，直到它从任何通道接收到一些东西。</p><p id="4186" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，来自Go的范围循环重复地从通道接收值，直到它被关闭。</p><pre class="mc md me mf gt no nl np nq aw nr bi"><span id="d797" class="ns ky iq nl b gy nt nu l nv nw">for msg := range c {<br/>    fmt.Println(msg)<br/>}</span></pre><p id="5bb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:要走出范围循环，我们应该始终关闭发送通道，否则它将永远等待。</p><p id="7bbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是最终的代码:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b5dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">产生比OS线程实际数量更多的goroutines可能会降低程序的速度。在某些情况下，编写并发程序显然是有益的。记得你的三明治和奶昔吗？当你赌上你的饮食超能力时，遵循第二种情况可能是个好主意，但当你第一次和你喜欢的人约会时，可能就不是了。😛</p><p id="2e31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要深入了解Go并发，可以看下面的视频:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="om mt l"/></div></figure><h1 id="55c1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">总结</h1><p id="5a35" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">通过了解你的程序将要处理的工作类型，我们可以做出明智的决定。对于CPU繁重的工作(比如一个非常大的<code class="fe ni nj nk nl b">for</code>循环或者计算一个相当大的数字的斐波纳契数)，线程永远不会空闲。在这种情况下，在多个操作系统/硬件线程上并行运行goroutines将产生性能提升。</p><p id="f813" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的goroutines多于可用的OS/硬件线程，那么在每个线程上打开和关闭goroutines将会产生延迟成本。更多的例行程序将不得不等待。</p><p id="90c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于IO繁重的工作(如访问文件系统或进行网络调用)，线程必须等待操作系统完成任务。在这种情况下，OS/硬件将变得空闲，而其他goroutines将有机会执行。因此，没有并行执行的并发性将在这里受益。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/4fe4f1aa2a84096ff4d4658fc116e056.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*4dQBmRsoiuYPe7qH-TA1TA.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">你做得很好😇</figcaption></figure><p id="3890" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">感谢你坚持到现在。重要的事情，比如渠道之间的沟通机制的类型，围绕它的一些设计模式，以及一个真实世界的例子，都留待单独讨论。你可以说出你的疑问，或者在我的推特上打个招呼。请考虑一些反馈或分享文章给那些可能从中受益的人。</strong></p></div><div class="ab cl oo op hu oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ij ik il im in"><div class="mc md me mf gt ov"><a href="https://gitconnected.com/learn/golang" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">学习围棋-最佳围棋教程(2019) | gitconnected</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">Go是一种静态类型的命令式编译语言。然而，与许多编译编程语言不同，Go是…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">gitconnected.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj jw ov"/></div></div></a></div></div></div>    
</body>
</html>