<html>
<head>
<title>ASP.NET Core Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心安全</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asp-net-core-security-ece7c675d3d4?source=collection_archive---------7-----------------------#2022-02-07">https://levelup.gitconnected.com/asp-net-core-security-ece7c675d3d4?source=collection_archive---------7-----------------------#2022-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a3ecf6ba5f272789909dc1c4d2b2ba3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAIjuvBx6bshKUh43DDgGQ.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">斯科特·韦伯在<a class="ae jg" href="https://unsplash.com/s/photos/security?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="958a" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">如何保护公共API？</h2></div><p id="8686" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ASP。NET Core是一个流行的框架。主要优势包括跨平台执行、高性能、内置<a class="ae jg" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>和模块化HTTP请求管道等特性。</p><h1 id="f56f" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">挑战</h1><p id="252c" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">ASP。NET Core为许多身份验证提供者提供支持，以通过众多身份验证工作流来保护应用程序。然而，在许多情况下，我们必须提供一个依赖于匿名访问的未认证API的web应用程序/站点。</p><p id="2caa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们在数据库中有一个产品列表，我们想在网页上显示这些产品。我们可以编写一个API来提供产品列表，并让前端(网站)通过API检索该列表，并将它们显示在我们的公共产品网页上。</p><p id="6b64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果不应用安全级别，这样的体系结构可能是一个容易被利用的安全漏洞。</p><h1 id="1a4d" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">ASP中可用的安全控件。网</h1><p id="298b" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">ASP。NET Core为常见漏洞提供了解决方案，包括:</p><ul class=""><li id="3ea0" class="mr ms jj la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">跨站点脚本</li><li id="c131" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">SQL注入，</li><li id="71c2" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">跨站点请求伪造(CSRF)</li><li id="e29d" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">打开重定向</li></ul><h1 id="bf60" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">更进一步</h1><p id="ddb3" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">作为开发人员，我们还应该保护我们的应用程序免受其他常见攻击媒介的影响，包括:</p><ul class=""><li id="a3e7" class="mr ms jj la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">分布式拒绝服务</li><li id="f927" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">拒绝服务</li><li id="489d" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">批量数据出口</li><li id="1072" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">探测响应</li><li id="786d" class="mr ms jj la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">擦</li></ul><h1 id="0f19" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">使用基于IP的请求限制操作过滤器</h1><p id="7967" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们可以限制客户端在指定时间内的请求数量，以防止恶意bot攻击。我在ASP.NET核心中创建了一个基于IP的请求限制操作过滤器。请注意，多个客户端可能位于一个IP地址之后，因此我们可能希望满足我们的限制，或者将IP地址与其他请求数据相结合，以使请求更加独特。</p><p id="2dab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使用过滤器，我们只需要在控制器动作之上添加ActionAttribute。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="db5f" class="no lv jj nk b gy np nq l nr ns">[HttpGet()]  <br/>[ValidateReferrer]  <br/>[RequestLimit("Test-Action", NoOfRequest = 5, Seconds = 10)]  <br/>public async Task&lt;ActionResult&gt; GetAsync(CancellationToken ct)  <br/>{  <br/>   // code here  <br/>}</span></pre><p id="d70b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是过滤器的实现，</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="c3c2" class="no lv jj nk b gy np nq l nr ns">namespace Security.Api.Filters<br/>{<br/>    using System;<br/>    using System.Net;<br/>    using Microsoft.AspNetCore.Mvc;<br/>    using Microsoft.AspNetCore.Mvc.Filters;<br/>    using Microsoft.Extensions.Caching.Memory;<br/><br/>    [AttributeUsage(AttributeTargets.Method)]<br/>    public class RequestAttribute :ActionFilterAttribute<br/>    {<br/>        public RequestAttribute(string name)<br/>        {<br/>            Name = name;<br/>        }<br/>        public string Name<br/>        {<br/>            get;<br/>        }<br/>        public intNoOfRequest<br/>        {<br/>            get;<br/>            set;<br/>        } = 1;<br/>        public int Seconds<br/>        {<br/>            get;<br/>            set;<br/>        } = 1;<br/>        private static MemoryCachememoryCache<br/>        {<br/>            get;<br/>        } = new MemoryCache(new MemoryCacheOptions());<br/>        public override void OnActionExecuting(ActionExecutingContext context)<br/>        {<br/>varipAddress = context.HttpContext.Request.HttpContext.Connection.RemoteIpAddress;<br/>varmemoryCacheKey = $ "{Name}-{ipAddress}";<br/>memoryCache.TryGetValue(memoryCacheKey, out intprevReqCount);<br/>            if (prevReqCount&gt;= NoOfRequest)<br/>            {<br/>context.Result = new ContentResult<br/>                {<br/>                    Content = $ "Request is exceeded. Try again in seconds.",<br/>                };<br/>context.HttpContext.Response.StatusCode = (int)HttpStatusCode.TooManyRequests;<br/>            }<br/>            else<br/>            {<br/>varcacheEntryOptions = new MemoryCacheEntryOptions().SetAbsoluteExpiration(TimeSpan.FromSeconds(Seconds));<br/>memoryCache.Set(memoryCacheKey, (prevReqCount + 1), cacheEntryOptions);<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="4ff5" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">添加推荐人检查操作过滤器</h1><p id="51f0" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了防止API被滥用，并针对跨站点请求伪造(CSRF)攻击提供额外的保护，对发送到服务器的每个REST API请求的请求Referer头执行安全检查。</p><p id="ab7d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将验证API请求来自何处。t还可以防止来自POSTMAN、REST Client等工具的访问。</p><p id="9655" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们只需要在控制器动作之上添加ActionAttribute。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="d298" class="no lv jj nk b gy np nq l nr ns">[HttpGet()]  <br/>[ValidateReferrer]  <br/>public async Task&lt;ActionResult&gt; GetAsync(CancellationToken ct)  <br/>{  <br/>   // code here  <br/>}</span></pre><p id="74fc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是过滤器的实现。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="1441" class="no lv jj nk b gy np nq l nr ns">namespace Security.Api.Filters<br/>{<br/>    using Microsoft.AspNetCore.Http;<br/>    using Microsoft.AspNetCore.Mvc;<br/>    using Microsoft.AspNetCore.Mvc.Filters;<br/>    using Microsoft.Extensions.Configuration;<br/>    using System;<br/>    using System.Linq;<br/>    using System.Net;<br/><br/>    [AttributeUsage(AttributeTargets.Method)]<br/>    public sealed class ValidateAttribute :ActionFilterAttribute<br/>    {<br/>        private IConfiguration _configuration;<br/><br/>        public ValidateAttribute() { }<br/><br/>        public override void OnActionExecuting(ActionExecutingContext context)<br/>        {<br/>            _configuration = (IConfiguration)context.HttpContext.RequestServices.GetService(typeof(IConfiguration));<br/>base.OnActionExecuting(context);<br/>            if (!IsValidRequest(context.HttpContext.Request))<br/>            {<br/>context.Result = new ContentResult<br/>                {<br/>                    Content = $ "Invalid header"<br/>                };<br/>context.HttpContext.Response.StatusCode = (int)HttpStatusCode.ExpectationFailed;<br/>            }<br/>        }<br/><br/>        private bool IsValidRequest(HttpRequest request)<br/>        {<br/>            string referrerURL = "";<br/>            if (request.Headers.ContainsKey("Referer"))<br/>            {<br/>referrerURL = request.Headers["Referer"];<br/>            }<br/>            if (string.IsNullOrWhiteSpace(referrerURL)) return false;<br/><br/>           //Allows to check customer list<br/>varUrls = _configuration.GetSection("CorsOrigin").Get&lt;string[]&gt;()?.Select(url =&gt; new Uri(url).Authority).ToList();<br/><br/>            //add current host for swagger calls    <br/>var host = request.Host.Value;<br/>Urls.Add(host);<br/>            bool isValidClient = Urlsl.Contains(new Uri(referrerURL).Authority);<br/>            // comapre with base uri<br/>            return isValidClient;<br/>        }<br/>    }<br/>}</span></pre><h1 id="1c3e" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">添加DoS攻击中间件</h1><p id="4bb9" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果我们配置了autoscale，DoS攻击会淹没我们的API，使它们无法响应和/或变得昂贵。有不同的方法可以通过请求节流来避免这个问题。这里有一个选项，使用中间件来限制来自特定客户端IP地址的请求数量。</p><p id="3c07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是DosAttackMiddleware.cs的代码</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="5c7a" class="no lv jj nk b gy np nq l nr ns">namespace Security.Api.Middlewares<br/>{<br/>    using Microsoft.AspNetCore.Http;<br/>    using System.Collections.Generic;<br/>    using System.Linq;<br/>    using System.Net;<br/>    using System.Threading.Tasks;<br/>    using System.Timers;<br/>    public sealed class DosAttackMiddleware<br/>    {<br/><br/>        private static IDictionary _IpAdresses = new Dictionary();<br/>        private static Stack _Banded = new Stack();<br/>        private static Timer _Timer = CreateTimer();<br/>        private static Timer _BannedTimer = CreateBanningTimer();<br/><br/>        private<br/>        const int BANNED_REQUESTS = 10;<br/>        private<br/>        const int REDUCTION_INTERVAL = 1000;<br/>        private<br/>        const int RELEASE_INTERVAL = 3 * 60 * 1000; // 3 minutes    <br/>        private RequestDelegate _next;<br/>        public DosAttackMiddleware(RequestDelegate next)<br/>        {<br/>            _next = next;<br/>        }<br/>        public async Task InvokeAsync(HttpContexthttpContext)<br/>        {<br/>            string ip = httpContext.Connection.RemoteIpAddress.ToString();<br/>            if (_Banned.Contains(ip))<br/>            {<br/>httpContext.Response.StatusCode = (int)HttpStatusCode.Forbidden;<br/>            }<br/>CheckIpAddress(ip);<br/>            await _next(httpContext);<br/>        }<br/><br/>        private static void CheckIpAddress(string ip)<br/>        {<br/>            if (!_IpAdresses.ContainsKey(ip))<br/>            {<br/>                _IpAdresses[ip] = 1;<br/>            }<br/>            else if (_IpAdresses[ip] == BANNED_REQUESTS)<br/>            {<br/>                _Banned.Push(ip);<br/>                _IpAdresses.Remove(ip);<br/>            }<br/>            else<br/>            {<br/>                _IpAdresses[ip]++;<br/>            }<br/>        }<br/><br/>        private static Timer CreateTimer()<br/>        {<br/>            Timer timer = GetTimer(REDUCTION_INTERVAL);<br/>timer.Elapsed += new ElapsedEventHandler(TimerElapsed);<br/>            return timer;<br/>        }<br/><br/>        private static Timer CreateTimer()<br/>        {<br/>            Timer timer = GetTimer(RELEASE_INTERVAL);<br/>timer.Elapsed += delegate {<br/>                if (_Banned.Any()) _Banned.Pop();<br/>            };<br/>            return timer;<br/>        }<br/><br/><br/>        private static Timer GetTimer(int interval)<br/>        {<br/>            Timer timer = new Timer();<br/>timer.Interval = interval;<br/>timer.Start();<br/>            return timer;<br/>        }<br/><br/>        private static TimerElapsed(object sender, ElapsedEventArgs e)<br/>        {<br/>            foreach (string key in _IpAdresses.Keys.ToList())<br/>            {<br/>                _IpAdresses[key]--;<br/>                if (_IpAdresses[key] == 0) _IpAdresses.Remove(key);<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="b2c9" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">结论</h1><p id="8507" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">未经授权的API很容易被滥用。我们应该通过添加额外的代码来防止明确的攻击媒介。希望这篇文章能让这些限制更容易实施，同时让这些攻击者的日子更难过。</p></div></div>    
</body>
</html>