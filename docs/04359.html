<html>
<head>
<title>Text Extraction from a Table Image, using PyTesseract and OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTesseract和OpenCV从表格图像中提取文本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/text-extraction-from-a-table-image-using-pytesseract-and-opencv-3342870691ae?source=collection_archive---------0-----------------------#2020-06-23">https://levelup.gitconnected.com/text-extraction-from-a-table-image-using-pytesseract-and-opencv-3342870691ae?source=collection_archive---------0-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="185b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将表格图像转换为Python对象</h2></div><p id="1705" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从图像中提取文本可能会很累，尤其是当你有很多要提取的时候。一个众所周知的文本提取库是<a class="ae lb" href="https://pypi.org/project/pytesseract/" rel="noopener ugc nofollow" target="_blank">pytesserac</a>，一种光学字符识别(OCR)。该库将为您提供给定图像的文本。</p><p id="8f1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">pytesserac真的很有用，我第一次知道pytesserac时，我直接用它来检测一些短文本，结果令人满意。然后，我用它来检测表格中的文本，但算法无法执行。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/481201cd9db134d3fb7560229596b2eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dT1J_5GOaiwldPU1A2uCtg.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">图一。直接使用PyTesseract检测表格中的文本</figcaption></figure><p id="119b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图1描述了文本检测结果，绿色方框包围了检测到的单词。你可能会意识到，大多数文本不能被算法检测到，尤其是数字。对我来说，这些数字是数据的要素，给了我家乡当地政府每天新冠肺炎病例的价值。那么，如何提取这些信息呢？</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4833" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">入门指南</h1><p id="5cb2" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">当编写一个算法时，我总是试着像人类一样教算法。这样，我可以很容易地将这个想法转化为更详细的算法。</p><p id="eca5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您阅读表格时，您可能首先注意到的是单元格。可以使用边框(线条)将一个单元格与另一个单元格分隔开，边框可以是垂直的，也可以是水平的。识别单元格后，继续读取其中的信息。转换成算法，你可以把这个过程分成三个过程，分别是<strong class="kh ir">细胞检测</strong>、<strong class="kh ir">感兴趣区域(ROI)选择</strong>和<strong class="kh ir">文本提取</strong>。</p><p id="a21a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在执行每个任务之前，让我们加载如下所示的图像</p><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="cc17" class="nb ma iq mx b gy nc nd l ne nf">import cv2 as cv<br/>import numpy as np</span><span id="55b4" class="nb ma iq mx b gy ng nd l ne nf">filename = 'filename.png'</span><span id="bf47" class="nb ma iq mx b gy ng nd l ne nf">img = cv.imread(cv.samples.findFile(filename))<br/>cImage = np.copy(img) #image to draw lines</span><span id="97cb" class="nb ma iq mx b gy ng nd l ne nf">cv.imshow("image", img) #name the window as "image"<br/>cv.waitKey(0)<br/>cv.destroyWindow("image") #close the window</span></pre><h2 id="dc4a" class="nb ma iq bd mb nh ni dn mf nj nk dp mj ko nl nm ml ks nn no mn kw np nq mp nr bi translated">想跳过文章看完整代码？</h2><p id="3259" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">代码如下:<a class="ae lb" href="https://github.com/fazlurnu/Text-Extraction-Table-Image" rel="noopener ugc nofollow" target="_blank">文本-提取-表格-图像</a></p><h1 id="9fd8" class="lz ma iq bd mb mc ns me mf mg nt mi mj jw nu jx ml jz nv ka mn kc nw kd mp mq bi translated">细胞检测</h1><p id="f8d7" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">从查找表格中的水平线和垂直线开始可能是最容易的。检测直线的方法有很多，但我感兴趣的一种方法是使用Hough Line Transform，这是一个OpenCV库。有关模式详情，请访问此<a class="ae lb" href="https://docs.opencv.org/master/d9/db0/tutorial_hough_lines.html" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="d3c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在应用霍夫线变换之前，有多个预处理要做。第一个是把你的图像转换成灰度图像，如果你有一个RGB图像的话。这个灰度图像对于下一步<a class="ae lb" href="https://docs.opencv.org/trunk/da/d22/tutorial_py_canny.html" rel="noopener ugc nofollow" target="_blank"> Canny边缘检测</a>很重要。</p><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="21ac" class="nb ma iq mx b gy nc nd l ne nf">gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)<br/>cv.imshow("gray", gray)<br/>cv.waitKey(0)<br/>cv.destroyWindow("gray")</span><span id="8548" class="nb ma iq mx b gy ng nd l ne nf">canny = cv.Canny(gray, 50, 150)<br/>cv.imshow("canny", canny)<br/>cv.waitKey(0)<br/>cv.destroyWindow("canny")</span></pre><p id="6907" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图左图显示的是灰度图像，而右图显示的是Canny图像。</p><div class="ld le lf lg gt ab cb"><figure class="nx lh ny nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><img src="../Images/11e03de2883d719b498dc4f004ac1393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*xBJGq9JPSWFcqEwJ6R3qsw.png"/></div></figure><figure class="nx lh ny nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><img src="../Images/75f7ea668626376252dcd172cade8ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*3uBnbBXJ4fOl8U8avTvQlA.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk od di oe of translated">图二。灰度和Canny图像</figcaption></figure></div><h2 id="df77" class="nb ma iq bd mb nh ni dn mf nj nk dp mj ko nl nm ml ks nn no mn kw np nq mp nr bi translated">霍夫线变换</h2><p id="7641" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在OpenCV中，这种算法有两种，分别是标准的Hough直线变换和概率Hough直线变换。标准的会给你线方程，所以你不知道线的起点和终点。而概率线变换会给你一列线，其中一列线是起点和终点的坐标。就我的目的而言，概率方法更可取。</p><div class="ld le lf lg gt ab cb"><figure class="nx lh og nz oa ob oc paragraph-image"><img src="../Images/a043de12b058b1f96c12afb90a32e2fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*Na8dKSijrIFAUEDULc0vHw.png"/></figure><figure class="nx lh oh nz oa ob oc paragraph-image"><img src="../Images/36b5e48160629d11e7ea5f6377710800.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*TmOCNzQCXhzN-UaUjjpHLQ.png"/><figcaption class="lo lp gj gh gi lq lr bd b be z dk od di oe of translated">图3。霍夫线变换结果示例(来源:OpenCV)</figcaption></figure></div><p id="d9c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于HoughLinesP函数，有几个输入参数:</p><ol class=""><li id="b998" class="oi oj iq kh b ki kj kl km ko ok ks ol kw om la on oo op oq bi translated"><strong class="kh ir">图像</strong> — 8位、单通道二进制源图像。图像可以通过函数进行修改。</li><li id="c949" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated"><strong class="kh ir"> rho </strong> —累加器的距离分辨率，单位为像素。</li><li id="534e" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated"><strong class="kh ir">θ</strong>—累加器的角度分辨率，单位为弧度。</li><li id="a8d1" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated"><strong class="kh ir">阈值</strong> —累加器阈值参数。只有那些获得足够票数的行才被返回</li><li id="1b4c" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated"><strong class="kh ir">线</strong> —线的输出向量。此处设置为无，值保存到linesP</li><li id="b886" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated"><strong class="kh ir">最小线路长度</strong> —最小线路长度。短于该长度的线段将被拒绝。</li><li id="24c0" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated"><strong class="kh ir"> maxLineGap </strong> —同一条线上的点之间连接它们的最大允许间隙。</li></ol><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="6f64" class="nb ma iq mx b gy nc nd l ne nf"># <!-- -->cv.HoughLinesP<!-- -->(image, rho, theta, threshold[, lines[, minLineLength[, maxLineGap]]]) → lines</span><span id="2800" class="nb ma iq mx b gy ng nd l ne nf">rho = 1<br/>theta = np.pi/180<br/>threshold = 50<br/>minLinLength = 350<br/>maxLineGap = 6</span><span id="4b97" class="nb ma iq mx b gy ng nd l ne nf">linesP = cv.HoughLinesP(canny, rho , theta, threshold, None, minLinLength, maxLineGap)</span></pre><p id="91fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了区分水平线和垂直线，我定义了一个函数，并根据函数返回值添加了一个列表</p><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="0566" class="nb ma iq mx b gy nc nd l ne nf">def is_vertical(line):<br/>    return line[0]==line[2]</span><span id="590c" class="nb ma iq mx b gy ng nd l ne nf">def is_horizontal(line):<br/>    return line[1]==line[3]</span><span id="2095" class="nb ma iq mx b gy ng nd l ne nf">horizontal_lines = []<br/>vertical_lines = []<br/>    <br/>if linesP is not None:<br/>    for i in range(0, len(linesP)):<br/>        l = linesP[i][0]</span><span id="f6b3" class="nb ma iq mx b gy ng nd l ne nf">        if (is_vertical(l)):<br/>            vertical_lines.append(l)<br/>                <br/>        elif (is_horizontal(l)):<br/>            horizontal_lines.append(l)</span><span id="236d" class="nb ma iq mx b gy ng nd l ne nf">for i, line in enumerate(horizontal_lines):<br/>    cv.line(cImage, (line[0], line[1]), (line[2], line[3]), (0,255,0), 3, cv.LINE_AA)<br/>                      <br/>for i, line in enumerate(vertical_lines):<br/>    cv.line(cImage, (line[0], line[1]), (line[2], line[3]), (0,0,255), 3, cv.LINE_AA)<br/>            <br/>cv.imshow("with_line", cImage)<br/>cv.waitKey(0)<br/>cv.destroyWindow("with_line") #close the window</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/1630574faa2aac2254690dd0f1051737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vutA7lFjsm-svTTL7gwceg.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">图4。霍夫线变换结果-无重叠过滤器</figcaption></figure><h2 id="a62d" class="nb ma iq bd mb nh ni dn mf nj nk dp mj ko nl nm ml ks nn no mn kw np nq mp nr bi translated">重叠过滤器</h2><p id="b4bb" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">检测到的线如上图所示。但是，霍夫线变换结果中有一些重叠的线。较粗的线条由多个位置相同、长度不同的线条组成。为了消除这条重叠线，我定义了一个重叠过滤器。</p><p id="9239" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初，基于排序索引对线进行排序，y₁用于水平线，x₁用于垂直线。如果下面的线分开的距离小于一定的距离，那么我们就认为它与前面的线是同一条线。这可能有点像“肮脏的工作”，但它的工作。</p><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="7f8a" class="nb ma iq mx b gy nc nd l ne nf">def overlapping_filter(lines, sorting_index):<br/>    filtered_lines = []<br/>    <br/>    lines = sorted(lines, key=lambda lines: lines[sorting_index])<br/>    separation = 5</span><span id="dd06" class="nb ma iq mx b gy ng nd l ne nf">    for i in range(len(lines)):<br/>            l_curr = lines[i]<br/>            if(i&gt;0):<br/>                l_prev = lines[i-1]<br/>                if ( (l_curr[sorting_index] - l_prev[sorting_index]) &gt; separation):<br/>                    filtered_lines.append(l_curr)<br/>            else:<br/>                filtered_lines.append(l_curr)<br/>                <br/>    return filtered_lines</span></pre><p id="9f87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现重叠滤镜并在图像上添加文本，现在代码应该如下所示:</p><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="cb64" class="nb ma iq mx b gy nc nd l ne nf">horizontal_lines = []<br/>vertical_lines = []<br/>    <br/>if linesP is not None:<br/>    for i in range(0, len(linesP)):<br/>        l = linesP[i][0]</span><span id="0362" class="nb ma iq mx b gy ng nd l ne nf">        if (is_vertical(l)): <br/>            vertical_lines.append(l)<br/>                <br/>        elif (is_horizontal(l)):<br/>            horizontal_lines.append(l)</span><span id="ccb1" class="nb ma iq mx b gy ng nd l ne nf">    horizontal_lines = overlapping_filter(horizontal_lines, 1)<br/>    vertical_lines = overlapping_filter(vertical_lines, 0)</span><span id="20c6" class="nb ma iq mx b gy ng nd l ne nf">for i, line in enumerate(horizontal_lines):<br/>    cv.line(cImage, (line[0], line[1]), (line[2], line[3]), (0,255,0), 3, cv.LINE_AA)<br/>    cv.putText(cImage, str(i) + "h", (line[0] + 5, line[1]), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv.LINE_AA)                      </span><span id="d213" class="nb ma iq mx b gy ng nd l ne nf">for i, line in enumerate(vertical_lines):<br/>    cv.line(cImage, (line[0], line[1]), (line[2], line[3]), (0,0,255), 3, cv.LINE_AA)<br/>    cv.putText(cImage, str(i) + "v", (line[0], line[1] + 5), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv.LINE_AA)</span><span id="c401" class="nb ma iq mx b gy ng nd l ne nf">            <br/>cv.imshow("with_line", cImage)<br/>cv.waitKey(0)<br/>cv.destroyWindow("with_line") #close the window</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/b71e71bb3bab7825f0f746c59833a5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3YvBU0rgeV0C4spr0Tqow.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">图5。霍夫线变换结果—带重叠过滤器</figcaption></figure><p id="010e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这个精炼的代码，您将不会有重叠的行。此外，您将在图像中写入水平线和垂直线的索引。这个索引将对下一个任务，ROI选择有用</p><h1 id="8248" class="lz ma iq bd mb mc ns me mf mg nt mi mj jw nu jx ml jz nv ka mn kc nw kd mp mq bi translated">ROI选择</h1><p id="01b1" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">首先，我们需要定义列数和行数。在我的例子中，我只对第214行和所有列的数据感兴趣。对于列，我定义了一个名为keywords的列表，将它用作字典关键字。</p><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="03ac" class="nb ma iq mx b gy nc nd l ne nf">## set keywords<br/>keywords = ['no', 'kabupaten', 'kb_otg', 'kl_otg', 'sm_otg', 'ks_otg', 'not_cvd_otg',<br/>            'kb_odp', 'kl_odp', 'sm_odp', 'ks_odp', 'not_cvd_odp', 'death_odp',<br/>            'kb_pdp', 'kl_pdp', 'sm_pdp', 'ks_pdp', 'not_cvd_pdp', 'death_pdp',<br/>            'positif', 'sembuh', 'meninggal']<br/>    <br/>dict_kabupaten = {}<br/>    for keyword in keywords:<br/>        dict_kabupaten[keyword] = []<br/>        <br/>## set counter for image indexing<br/>counter = 0<br/>    <br/>## set line index<br/>first_line_index = 1<br/>last_line_index = 14</span></pre><p id="ee85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，为了选择ROI，我定义了一个函数，该函数将图像、水平线和垂直线作为输入，并将线索引作为边界。这个函数返回裁剪后的图像，以及它在图像全局坐标中的位置和大小</p><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="3368" class="nb ma iq mx b gy nc nd l ne nf">def get_cropped_image(image, x, y, w, h):<br/>    cropped_image = image[ y:y+h , x:x+w ]<br/>    return cropped_image</span><span id="b10c" class="nb ma iq mx b gy ng nd l ne nf">def get_ROI(image, horizontal, vertical, left_line_index, right_line_index, top_line_index, bottom_line_index, offset=4):<br/>    x1 = vertical[left_line_index][2] + offset<br/>    y1 = horizontal[top_line_index][3] + offset<br/>    x2 = vertical[right_line_index][2] - offset<br/>    y2 = horizontal[bottom_line_index][3] - offset<br/>    <br/>    w = x2 - x1<br/>    h = y2 - y1<br/>    <br/>    cropped_image = get_cropped_image(image, x1, y1, w, h)<br/>    <br/>    return cropped_image, (x1, y1, w, h)</span></pre><p id="be5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">裁剪后的图像将用于下一个任务，即文本提取。第二个返回的参数将用于绘制ROI的边界框</p><h2 id="709b" class="nb ma iq bd mb nh ni dn mf nj nk dp mj ko nl nm ml ks nn no mn kw np nq mp nr bi translated">文本提取</h2><p id="69ad" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">现在，我们已经定义了ROI函数。我们可以开始提取结果。我们可以通过遍历单元格来读取列中的所有数据。列数由关键字的长度给出，而行数是定义的。</p><p id="796a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们定义一个绘制文本和包围框的函数，以及另一个提取文本的函数。</p><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="3e69" class="nb ma iq mx b gy nc nd l ne nf">import pytesseract<br/>pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe'</span><span id="b20a" class="nb ma iq mx b gy ng nd l ne nf">def draw_text(src, x, y, w, h, text):<br/>    cFrame = np.copy(src)<br/>    cv.rectangle(cFrame, (x, y), (x+w, y+h), (255, 0, 0), 2)<br/>    cv.putText(cFrame, "text: " + text, (50, 50), cv.FONT_HERSHEY_SIMPLEX, 2, (0, 0, 0), 5, cv.LINE_AA)<br/>    <br/>    return cFrame</span><span id="4930" class="nb ma iq mx b gy ng nd l ne nf">def detect(cropped_frame, is_number = False):<br/>    if (is_number):<br/>        text = pytesseract.image_to_string(cropped_frame,<br/>                                           config ='-c tessedit_char_whitelist=0123456789 --psm 10 --oem 2')<br/>    else:<br/>        text = pytesseract.image_to_string(cropped_frame, config='--psm 10')        <br/>        <br/>    return text</span></pre><p id="e16f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更好的效果，把图像转换成黑白的，让我们开始迭代吧！</p><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="4268" class="nb ma iq mx b gy nc nd l ne nf">counter = 0</span><span id="6098" class="nb ma iq mx b gy ng nd l ne nf">print("Start detecting text...")<br/>(thresh, bw) = cv.threshold(gray, 100, 255, cv.THRESH_BINARY)</span><span id="aeb7" class="nb ma iq mx b gy ng nd l ne nf">for i in range(first_line_index, last_line_index):<br/>    for j, keyword in enumerate(keywords):<br/>        counter += 1<br/>            <br/>        left_line_index = j<br/>        right_line_index = j+1<br/>        top_line_index = i<br/>        bottom_line_index = i+1<br/>            <br/>        cropped_image, (x,y,w,h) = get_ROI(bw, horizontal, vertical, left_line_index, right_line_index, top_line_index, bottom_line_index)<br/>            <br/>        if (keywords[j]=='kabupaten'):<br/>           text = detect(cropped_image)<br/>           dict_kabupaten[keyword].append(text)<br/>         <br/>        else:<br/>            text = detect(cropped_image, is_number=True)<br/>            dict_kabupaten[keyword].append(text)</span><span id="4a91" class="nb ma iq mx b gy ng nd l ne nf">        image_with_text = draw_text(img, x, y, w, h, text)</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8a30" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">充当故障检修员</h1><p id="d893" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">这是文本提取的结果！我只选择了最后三列，因为它给了一些文本一个奇怪的结果，其余的很好，所以我不显示它。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ow"><img src="../Images/a581c43e3e53d4fd9fed3e5e7f5f3ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Dc70ufYO3-47uirEIeABcw.gif"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">图6。检测到的文本—版本1</figcaption></figure><p id="feab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能意识到有些数字被检测为随机文本，39个数据中有5个是随机文本。这是由于最后三列与其余各列不同。背景是黑色的，而文字是白色的。不知何故，它会影响文本提取的性能。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/61c1ec4c765995d518d1ede99bdc46ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyJoqMqhZmK6x69wCb4TBg.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">图7。二进制映象</figcaption></figure><p id="cba0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，让我们颠倒最后三列。</p><pre class="ld le lf lg gt mw mx my mz aw na bi"><span id="ac50" class="nb ma iq mx b gy nc nd l ne nf">def invert_area(image, x, y, w, h, display=False):<br/>    ones = np.copy(image)<br/>    ones = 1<br/>    <br/>    image[ y:y+h , x:x+w ] = ones*255 - image[ y:y+h , x:x+w ] <br/>    <br/>    if (display): <br/>        cv.imshow("inverted", image)<br/>        cv.waitKey(0)<br/>        cv.destroyAllWindows()<br/>    return image</span><span id="94db" class="nb ma iq mx b gy ng nd l ne nf">left_line_index = 17<br/>right_line_index = 20<br/>top_line_index = 0<br/>bottom_line_index = -1<br/>    <br/>cropped_image, (x, y, w, h) = get_ROI(img, horizontal, vertical, left_line_index, right_line_index, top_line_index, bottom_line_index)</span><span id="5537" class="nb ma iq mx b gy ng nd l ne nf">gray = get_grayscale(img)<br/>bw = get_binary(gray)<br/>bw = invert_area(bw, x, y, w, h, display=True)</span></pre><p id="e33f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果如下所示。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/d800de020f1ec590e9f6bfb8897bc0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmB8ZWDgTf7rnPhEp1_-sQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">图8。处理过的二进制图像</figcaption></figure><h1 id="2d7d" class="lz ma iq bd mb mc ns me mf mg nt mi mj jw nu jx ml jz nv ka mn kc nw kd mp mq bi translated">瞧啊。结果呢</h1><p id="b7c3" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">反转图像后，重做步骤，这里是最终结果！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ow"><img src="../Images/dbdceb43ddb4712058004be1936ae6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NoThvv-IYATLTb9-GHvb0Q.gif"/></div></div></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ow"><img src="../Images/764dc2cf25a086f64e22811dda40b688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pgVgIfhIxo6Qk8USjudoJw.gif"/></div></div></figure><p id="ffd2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在你的算法成功检测到文本后，现在你可以把它保存到Python对象中，比如字典或列表。一些区域名称(在“Kabupaten/Kota”中)不能被精确地检测到，因为它不包括在Tesseract训练数据中。然而，这不应该是一个问题，因为可以精确地检测区域的索引。此外，此文本提取可能无法检测其他字体的文本，具体取决于所使用的字体。如果出现误判，比如“5”被检测为“8”，可以做一个图像处理，比如<a class="ae lb" href="https://docs.opencv.org/3.4/db/df6/tutorial_erosion_dilatation.html" rel="noopener ugc nofollow" target="_blank">腐蚀、扩张</a>。</p><p id="1bba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的代码远非完美，如果你发现一些错误或改进的机会，给我写一个评论！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="ca35" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这项工作是一次惊人的短暂旅程。我很兴奋能够完成我的第一个图像处理项目！期待下一个项目:D</p></div></div>    
</body>
</html>