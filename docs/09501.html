<html>
<head>
<title>Python “hidden” gems: __slots__</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python“隐藏”的宝石:__slots__</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-hidden-gems-slots-4bf1be368e36?source=collection_archive---------10-----------------------#2021-08-16">https://levelup.gitconnected.com/python-hidden-gems-slots-4bf1be368e36?source=collection_archive---------10-----------------------#2021-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eb1a577099b6cecb2f5fcd41ee707d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2Ffgs0YGae9Yb7z6CV9qQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Python有很多宝石！(图片由作者提供)</figcaption></figure><h1 id="60b1" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">介绍</h1><p id="c0ab" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">当我还是一个年轻的开发人员时，我经常坐在我的电脑前，随意挑选一些python官方文档文章(我现在还在做，但是频率降低了)。这个活动是出于好奇——那里有我不知道的东西，因为通常情况下，在你的日常工作中，你多年都不会看到一些特定于语言的结构。</p><p id="ce8e" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这也是给初级开发人员和潜在开发人员的一个提示——阅读官方文档，这是最全面的学习资源之一，根据我的经验——经常被忽略，这很奇怪，就像人类忽略明显解决方案的一般趋势一样。也许你听过这句名言:<strong class="lf iu"> RTFM </strong>，意思是:<strong class="lf iu">读他妈的手册。</strong>我必须承认，python和许多框架(Django，FastAPI)的官方文档质量非常好，而且都在那里，你只需要花些时间去熟悉它。</p><p id="4399" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我现在就不说了。下面介绍一下<code class="fe mg mh mi mj b">__slots__</code>。</p><h1 id="dc60" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">__插槽_ _</h1><p id="b6bb" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我不知道你怎么想，但是当我学习python的时候，我对所有这些以<code class="fe mg mh mi mj b">__</code>开头的特殊Python方法感到不知所措，其中一些非常明显:<code class="fe mg mh mi mj b">__repr__, __str__, __dict__, __setattr__, __delattr__, __getattr__</code>等等。关于python编程的大部分课程已经涵盖了基本的一些，但是还有一些是非常特定的用法，并且经常被遗忘，比如<code class="fe mg mh mi mj b">__slots__</code>(至少这是我的经验，如果你有不同的经验，请在评论部分分享)。那么什么是<code class="fe mg mh mi mj b">__slots__</code>？</p><p id="bb11" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">官方文件可以在这里找到<a class="ae mk" href="https://docs.python.org/3/reference/datamodel.html#slots" rel="noopener ugc nofollow" target="_blank">。此外，如果你从未阅读过<code class="fe mg mh mi mj b">datamodel</code>文档页面——请阅读，稍后你会感谢我的。现在的定义是:</a></p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="8099" class="mt kg it mj b gy mu mv l mw mx"><em class="my">__slots__</em> allow us to explicitly declare data members (like properties) and deny the creation of <em class="my">__dict__</em> and <em class="my">__weakref__</em> (unless explicitly declared in <em class="my">__slots__</em> or available in a parent.)</span></pre><p id="1608" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">和优势:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="ef68" class="mt kg it mj b gy mu mv l mw mx">The space saved over using <em class="my">__dict__</em> can be significant. Attribute lookup speed can be significantly improved as well.</span></pre><p id="b7ac" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">现在，让我们看一个真实的例子:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7ec3" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这两个实现之间的唯一区别是<code class="fe mg mh mi mj b">__slots__</code>类属性。</p><p id="534d" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">现在使用<code class="fe mg mh mi mj b">Point</code>，您可以:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="d5b4" class="mt kg it mj b gy mu mv l mw mx">p = Point(x=10.1, y=20.2, z=30.3)<br/>p.name = "To the moon"</span></pre><p id="f11c" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">使用<code class="fe mg mh mi mj b">SlotPoint</code>，您将获得:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="5048" class="mt kg it mj b gy mu mv l mw mx">sp = SlotPoint(x=10.1, y=20.2, z=30.3)<br/>sp.name = "To the moon"<br/># AttributeError: 'SlotPoint' object has no attribute 'name'</span></pre><p id="81b4" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">你可以想想，像一个带<code class="fe mg mh mi mj b">__slots__</code>的对象本质上是静态的，你不能扩展它，你有一套固定的属性。</p><p id="1228" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">现在让我们检查一下我们的python堆。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f55a" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">输出将是:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="d28f" class="mt kg it mj b gy mu mv l mw mx">Partition of a set of 2585566 objects. Total size = 126243057 bytes.<br/> Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)<br/>     0 500000  19 52000000  41  52000000  41 dict of __main__.Point<br/>     1 1500078  58 36001872  29  88001872  70 float<br/>     2 500000  19 24000000  19 112001872  89 __main__.Point<br/>     3    301   0  4223856   3 116225728  92 list<br/>     4  27401   1  2501396   2 118727124  94 str<br/>     ...</span></pre><p id="3382" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">对于定义了<code class="fe mg mh mi mj b">__slots__</code>的点:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7003" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">输出将是:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="842f" class="mt kg it mj b gy mu mv l mw mx">Partition of a set of 2085569 objects. Total size = 78243173 bytes.<br/> Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)<br/>     0 1500078  72 36001872  46  36001872  46 float<br/>     1 500000  24 28000000  36  64001872  82 __main__.SlotPoint<br/>     2    302   0  4223976   5  68225848  87 list<br/>     3  27401   1  2501406   3  70727254  90 str<br/>     4  18744   1  1333496   2  72060750  92 tuple<br/>     ...</span></pre><p id="e848" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在这两种情况下，我都创建了50万个点，如您所见，对于没有使用<code class="fe mg mh mi mj b">__slots__</code>的点，我们总共使用了2 585 566个对象和126 243 057个字节的总大小，对于<code class="fe mg mh mi mj b">__slots__</code>点，我们使用了2 085 569个对象和78 243 173个字节。如您所见，我们确实使用了较少的资源。此外，如果您自己运行代码，您会发现在第二个示例中创建0.5百万个点要快得多。</p><p id="4b1e" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">现在，让我们运行实验，比较两种情况下对象属性的访问时间。</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="fae7" class="mt kg it mj b gy mu mv l mw mx">p1 = Point(x=10.1, y=20.2, z=30.3)<br/>sp1 = SlotPoint(x=10.1, y=20.2, z=30.3)</span><span id="5e03" class="mt kg it mj b gy nb mv l mw mx">def test_attr_get(obj):<br/>    def inner_attr_get():<br/>        obj.x<br/>    return inner_attr_get</span><span id="cf63" class="mt kg it mj b gy nb mv l mw mx">no_slots_repeat = timeit.repeat(test_attr_get(p1))<br/>slots_repeat = timeit.repeat(test_attr_get(sp1))</span><span id="f4a1" class="mt kg it mj b gy nb mv l mw mx">def avg(l):<br/>    return sum(l) / len(l)</span><span id="916e" class="mt kg it mj b gy nb mv l mw mx">print(f"NO SLOTS: {avg(no_slots_repeat)}")<br/>print(f"SLOTS: {avg(slots_repeat)}")</span></pre><p id="2fa1" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">如果你运行上面的代码，你会得到这样的结果:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="72c7" class="mt kg it mj b gy mu mv l mw mx">NO SLOTS: 0.04596721079942654<br/>SLOTS: 0.047078945599787404</span></pre><p id="d9de" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">看起来对于简单的point类来说，只访问属性并没有太大的好处，但是让我们稍微修改一下测试方法:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="9313" class="mt kg it mj b gy mu mv l mw mx">def test_attr_get(obj):<br/>    def inner_attr_get():<br/>        obj.x = 90.75<br/>    return inner_attr_get</span></pre><p id="ea7f" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">现在输出将是:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="6ee9" class="mt kg it mj b gy mu mv l mw mx">NO SLOTS: 0.05043860499972652<br/>SLOTS: 0.049037123199741475</span></pre><p id="dbdb" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在这种情况下——仅属性分配，插槽通常在我的PC上快3–5%左右。</p><p id="9306" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">现在，让我们运行类似于<code class="fe mg mh mi mj b">full_test</code>的对象实例创建和一些简单的逻辑:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="b83e" class="mt kg it mj b gy mu mv l mw mx">def full_test(point_class):<br/>    def inner_full_test():<br/>        p1 = point_class(x=10.1, y=20.2, z=30.3)<br/>        p2 = point_class(x=15.5, y=16.8, z=1.3)<br/>        distance = calculate_distance(p1, p2)<br/>        return distance<br/>    return inner_full_test</span><span id="8dd0" class="mt kg it mj b gy nb mv l mw mx">no_slots_repeat = timeit.repeat(full_test(Point))<br/>slots_repeat = timeit.repeat(full_test(SlotPoint))</span><span id="4c5a" class="mt kg it mj b gy nb mv l mw mx"># copy avg method from above example;</span><span id="1783" class="mt kg it mj b gy nb mv l mw mx">print(f"NO SLOTS: {avg(no_slots_repeat)}")<br/>print(f"SLOTS: {avg(slots_repeat)}")</span></pre><p id="50b3" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在这种情况下，输出如下所示:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="34c8" class="mt kg it mj b gy mu mv l mw mx">NO SLOTS: 0.7609337183999741<br/>SLOTS: 0.71700722400019</span></pre><p id="b118" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在这种情况下，<code class="fe mg mh mi mj b">timeit</code>模块的输出明显不同，我认为这足以证明带有<code class="fe mg mh mi mj b">__slots__</code>的对象比标准对象表现得快一点，但是您需要知道在哪里、何时以及如何使用它们。</p><h1 id="08b4" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">摘要</h1><p id="b02d" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">好处:</p><ul class=""><li id="cd02" class="nc nd it lf b lg mb lk mc lo ne ls nf lw ng ma nh ni nj nk bi translated"><code class="fe mg mh mi mj b">__slots__</code>会减少你的内存占用。</li><li id="dde0" class="nc nd it lf b lg nl lk nm lo nn ls no lw np ma nh ni nj nk bi translated">在某些情况下，代码执行起来会更快。</li><li id="c321" class="nc nd it lf b lg nl lk nm lo nn ls no lw np ma nh ni nj nk bi translated">在你知道你使用了大量对象(数百万甚至更多)并且你知道对象不需要动态的地方使用<code class="fe mg mh mi mj b">__slots__</code>。</li><li id="8706" class="nc nd it lf b lg nl lk nm lo nn ls no lw np ma nh ni nj nk bi translated">在大多数“正常”情况下，你永远也不会需要它，但知道这一点很好。</li></ul><p id="05d9" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">感谢阅读。现在，您可以在需要时使用<code class="fe mg mh mi mj b">__slots__</code>节省能源和树木。</p></div></div>    
</body>
</html>