<html>
<head>
<title>Maximum AND of Two Elements in an Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数组中两个元素的最大和</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/maximum-and-of-two-elements-in-an-array-14967206c90c?source=collection_archive---------23-----------------------#2021-02-15">https://levelup.gitconnected.com/maximum-and-of-two-elements-in-an-array-14967206c90c?source=collection_archive---------23-----------------------#2021-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5a7211954a204966c402ac6ed8a861e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZB1NGiU7qoH0oGJp"/></div></div></figure><div class=""/></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="4111" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">位操作和按位运算符是编程面试中最难的问题。这篇文章讨论了一个有趣的位操作问题。这个问题是Salesforce问的。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="1cd2" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">问题:</h1><p id="8bbb" class="pw-post-body-paragraph ki kj je kk b kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb mj ld le lf im bi translated">给定一个数组，找出数组中任意一对元素生成的最大值和最小值。</p><p id="6727" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">示例:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="094d" class="mt li je mp b gy mu mv l mw mx">Input : arr[] = {4, 8, 12, 16} <br/>Output : Maximum AND value = 8 </span><span id="7d7e" class="mt li je mp b gy my mv l mw mx">Input : arr[] = {4, 8, 16, 2} <br/>Output : Maximum AND value = 0</span></pre><p id="f2d9" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">(回想一下<code class="fe mz na nb mp b">&amp;</code>是C++中的按位AND运算符)。</p><h1 id="dcdb" class="lh li je bd lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma ng mc md me bi translated">解决方案1:天真的方法</h1><p id="db5d" class="pw-post-body-paragraph ki kj je kk b kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb mj ld le lf im bi translated">回忆逻辑AND运算符的真值表</p><blockquote class="nh ni nj"><p id="6a57" class="ki kj lg kk b kl km kn ko kp kq kr ks nk ku kv kw nl ky kz la nm lc ld le lf im bi translated">当且仅当两位都是1时，两位的AND才是1</p></blockquote><p id="a529" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">整数上的逻辑AND运算符(C++中的<code class="fe mz na nb mp b">&amp;</code>运算符)按位运算——它对两个数的每一对对应位执行AND运算。</p><p id="7bda" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">让我们来看一个例子。考虑两个8位整数:<code class="fe mz na nb mp b">8 = 00001000</code>和<code class="fe mz na nb mp b">12 = 00001100</code>。两个整数的<em class="lg">最高有效位</em> <em class="lg"> (MSB) </em>都是零。因此，两者的和的MSB也为零。延伸到其他位，我们得到<code class="fe mz na nb mp b">8 &amp; 12 = 8</code>。</p><p id="e45e" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">计算数组中最大值和的朴素算法很简单——只需迭代数组中的每一对元素，更新运行的最大值和目前找到的值，就可以用不到10行C++代码编写。下面是naive算法的实现:简单的双循环使这个算法的复杂度为O(n)，其中n是数组中元素的个数。</p><p id="4a93" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">您应该能够在几分钟内编写出这个简单的实现。当然，我们可以做得比这好得多，只要有一点点洞察力和一点点操作。</p><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="7f92" class="lh li je bd lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma ng mc md me bi translated">解决方案2:使用std::list</h1><p id="0482" class="pw-post-body-paragraph ki kj je kk b kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb mj ld le lf im bi translated">通过查看从<em class="lg">最高有效位(MSB) </em>到<em class="lg">最低有效位(LSB) </em>的各个位，您可以更好地了解问题。在任一位为1的数字出现在最终解中的机会更大(即作为AND运算符的参数)，而具有很多0位的数字出现的机会很小。举个例子就能说明这一点。让我们用三个4位数的二进制数:</p><ol class=""><li id="514b" class="np nq je kk b kl km kp kq kt nr kx ns lb nt lf nu nv nw nx bi translated"><code class="fe mz na nb mp b">4 = 0100</code></li><li id="3e47" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf nu nv nw nx bi translated"><code class="fe mz na nb mp b">9 = 1001</code></li><li id="64d9" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf nu nv nw nx bi translated"><code class="fe mz na nb mp b">13 = 1101</code></li></ol><p id="10a7" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这些数字的<em class="lg">最高有效位</em>分别是<code class="fe mz na nb mp b">0</code>、<code class="fe mz na nb mp b">1</code>、<code class="fe mz na nb mp b">1</code>。给定这些msb，<em class="lg">数字4有可能出现在最终解中吗？</em>。原来这三个数中最大的和是<code class="fe mz na nb mp b">9 &amp; 13 = 9</code>。试着用4作为AND的参数，你会得到一个更小的数字！(<code class="fe mz na nb mp b">4 &amp; 9 = 0</code>，<code class="fe mz na nb mp b">4 &amp; 13 = 4</code>)。请注意，数字4在最高有效位有一个零！</p><p id="6502" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们可以将这一观察总结为两条规则:</p><ol class=""><li id="329e" class="np nq je kk b kl km kp kq kt nr kx ns lb nt lf nu nv nw nx bi translated">如果有两个或两个以上的数字的MSB为1，则该解的MSB为1。我们可以忽略所有MSB为零的数字</li><li id="5140" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf nu nv nw nx bi translated">相反，只要MSB为1的数字少于两个，则该解的MSB为0。我们必须考虑所有可能的解决方案。</li></ol><p id="4772" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这导致以下更有效的算法:</p><ol class=""><li id="9708" class="np nq je kk b kl km kp kq kt nr kx ns lb nt lf nu nv nw nx bi translated">将所有数字保存在一个<code class="fe mz na nb mp b">std::list</code>中</li><li id="caa5" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf nu nv nw nx bi translated">对于每个数字中的每个位置(从MSB开始)，以该位置的一位计数该数字。</li><li id="3892" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf nu nv nw nx bi translated">如果<code class="fe mz na nb mp b">count</code>为2或更大，则从列表中删除该位置有0位的所有数字。</li><li id="a9c8" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf nu nv nw nx bi translated">如果<code class="fe mz na nb mp b">count</code>小于2，则保留列表中的所有数字。</li></ol><p id="421b" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">返回最终列表中数字的AND，只要列表有两个元素。</p><p id="e6c7" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">下面是该算法的C++实现:</p><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b069" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">该算法对整个数组迭代一次。它还对每个数字中的每个比特位置迭代一次。在每一次迭代中，它都执行恒定量的工作。因此，算法的运行时间是O(mn)，其中m是一个数的位数，n是数组元素的总数。给定m &lt;&lt; n (in our case, m = 32), the runtime is O(n).</p><p id="3d62" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">Unfortunately, this algorithm maintains an extra O(n) memory in form of a std::list. It turns out that we can solve this problem with constant space with <em class="lg">位操作！</em></p><h1 id="7895" class="lh li je bd lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma ng mc md me bi translated">解决方案3:使用位操作</h1><p id="4376" class="pw-post-body-paragraph ki kj je kk b kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb mj ld le lf im bi translated">为了节省空间，我们仍然迭代从MSB到LSB的所有数字。然而，很少有额外的观察帮助我们消除列表:</p><ol class=""><li id="39ee" class="np nq je kk b kl km kp kq kt nr kx ns lb nt lf nu nv nw nx bi translated">让我们假设我们算出结果的MSB是1(即至少有两个数字的一个位设置在MSB)。<em class="lg">这一个MSB可以存储在一个整数变量中。我们将一个结果的所有位累加到一个整数变量中，并在最后返回这个变量。</em></li><li id="9ee6" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf nu nv nw nx bi translated">对于下一位，我们检查(a)是否至少有两个数字与MSB上的<em class="lg">结果</em>变量匹配，以及(b)是否有一个数字位于第二个最高有效位。</li></ol><p id="e996" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种情况下，我们将第二个最高有效位也设置为1，以此类推！</p><p id="9da4" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">使用有效的位操作可以在恒定的空间和时间<em class="lg">中完成上述两种检查:</em></p><ul class=""><li id="676e" class="np nq je kk b kl km kp kq kt nr kx ns lb nt lf od nv nw nx bi translated">对于位置<em class="lg"> i，</em>将结果的第I位设置为1: <code class="fe mz na nb mp b">pattern = result | (1 &lt;&lt; i)</code>。</li><li id="78d3" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf od nv nw nx bi translated">并将得到的数字与数组中的数字n进行比较，并将两个结果进行比较:<code class="fe mz na nb mp b">(pattern &amp; n) == pattern</code>。</li></ul><p id="4a7c" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">下面的清单显示了MaxAnd的有效实现，使用O(n)空间和O(n)时间。实现中还使用了<em class="lg">函数模板</em>，可以专门用于不同的整数类型，如<code class="fe mz na nb mp b">int32_t, int64_t</code>等。</p><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="f5ad" class="lh li je bd lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma ng mc md me bi translated">测试</h1><p id="3a93" class="pw-post-body-paragraph ki kj je kk b kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb mj ld le lf im bi translated">让我们使用GUnit测试来测试一些常见和不常见的输入数组:</p><ol class=""><li id="9c31" class="np nq je kk b kl km kp kq kt nr kx ns lb nt lf nu nv nw nx bi translated">空数组</li><li id="b9c2" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf nu nv nw nx bi translated">单元素阵列</li><li id="d09b" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf nu nv nw nx bi translated">任意两个元素的最大和为零的数组</li><li id="833e" class="np nq je kk b kl ny kp nz kt oa kx ob lb oc lf nu nv nw nx bi translated">任意两个元素的最大和不为零的数组</li></ol><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="9086" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><em class="lg">原载于2021年2月15日https://cppcodingzen.com</em><a class="ae oe" href="https://cppcodingzen.com/?p=2859" rel="noopener ugc nofollow" target="_blank"><em class="lg"/></a><em class="lg">。</em></p></div></div>    
</body>
</html>