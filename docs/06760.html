<html>
<head>
<title>Asynchronous boundaries in Monix Task</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Monix任务中的异步边界</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-boundary-in-monix-task-900995ba8a28?source=collection_archive---------8-----------------------#2020-12-28">https://levelup.gitconnected.com/asynchronous-boundary-in-monix-task-900995ba8a28?source=collection_archive---------8-----------------------#2020-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="199e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近一直在玩<a class="ae kl" href="https://monix.io/" rel="noopener ugc nofollow" target="_blank"> Monix </a>。在本文中，我将关注<a class="ae kl" href="https://monix.io/docs/current/eval/task.html" rel="noopener ugc nofollow" target="_blank"> Monix Task </a>，尤其是线程如何切换Monix Task的方法。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/cd7c200539cb69302f27ca5a96833404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2j1RVz0kwo8ZEOrYxdaFA.jpeg"/></div></div></figure><h1 id="eaff" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Monix任务</h1><p id="1ff3" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Monix Task在Monix中实现，Monix是一个异步和反应式编程Scala和Scala.js库。</p><blockquote class="mb mc md"><p id="54ef" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">Task是一种数据类型，用于控制可能的惰性和异步计算，有助于控制副作用，避免不确定性和回调地狱。</p></blockquote><p id="c880" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Monix还提供了流数据类型和用于管理并发性的纯功能实用程序，如monix-reactive、monix-catnap和monix-tail。</p><p id="0c55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前最新的主要版本是<a class="ae kl" href="https://monix.io/blog/2020/11/07/monix-v3.3.0.html" rel="noopener ugc nofollow" target="_blank"> 3.3.0 </a>，2020年11月发布。</p><h1 id="0058" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">异步边界</h1><p id="a05a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">异步边界是线程之间的上下文切换。为了实现高效的异步编程，我们必须引入一个带有适当线程池的异步边界。比如异步边界应该引入一个无界线程池用于阻塞执行，就像<a class="ae kl" href="https://gist.github.com/djspiewak/46b543800958cf61af6efa8e072bfd5c" rel="noopener ugc nofollow" target="_blank"> Daniel的文档</a>和<a class="ae kl" href="https://monix.io/docs/current/best-practices/blocking.html" rel="noopener ugc nofollow" target="_blank"> Monix的文档</a>说的那样。</p><p id="9b16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Monix Task有引入异步边界的有用方法。</p><h1 id="6771" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Monix任务中的异步边界</h1><p id="4849" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在，让我们看看如何在Monix Task中引入异步边界。</p><p id="a5be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">调度器</strong></p><p id="c0e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当<em class="me">任务</em>运行时，需要<a class="ae kl" href="https://monix.io/docs/current/execution/scheduler.html" rel="noopener ugc nofollow" target="_blank"> <em class="me">调度器</em> </a>。这种关系类似于<em class="me">执行上下文</em>和<em class="me">未来</em>之间的关系。但是，<em class="me"> ExecutionContext </em>不仅在<em class="me"> Future </em>运行时需要，在<em class="me"> Future </em>被定义以及<em class="me"> Future </em>的几乎所有方法被调用时也需要。</p><p id="c0bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="me">调度器</em>是<em class="me">执行上下文的子类。</em>所以，<em class="me">调度器</em>有一个线程池，比如<em class="me"> CachedThreadPool </em>，<em class="me"> ForkJoinPool </em>等。调度器<em class="me">伴随对象</em>提供了为每个线程池创建<em class="me">调度器</em>对象的有用方法。下面的代码是使用这些方法定义<em class="me">调度器</em>对象的例子。你也可以像<em class="me"> </em> <a class="ae kl" href="https://monix.io/docs/current/execution/scheduler.html#builders-on-the-jvm" rel="noopener ugc nofollow" target="_blank">这个链接</a>一样指定<em class="me"> ExecutionModel </em>和<em class="me"> ReportFailure </em>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我没有详细解释<em class="me">调度器</em><em class="me">，但是调度器</em>也是对<em class="me"> Java的ScheduledExecutorService </em>的替代。</p><blockquote class="mb mc md"><p id="d576" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">Monix <code class="fe mk ml mm mn b">Scheduler</code>的灵感来自<a class="ae kl" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>，是一个增强的Scala <a class="ae kl" href="https://monix.io/docs/current/execution/scheduler.html#scala.concurrent.ExecutionContext" rel="noopener ugc nofollow" target="_blank"> ExecutionContext </a>，也是Java的<a class="ae kl" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html" rel="noopener ugc nofollow" target="_blank">scheduled executorservice</a>的替代品，同时也是Javascript的<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout" rel="noopener ugc nofollow" target="_blank"> setTimeout </a>的替代品。</p></blockquote><p id="19dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务转移</strong></p><p id="8a32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是切换线程池的基本方法，也就是说，引入一个异步边界。</p><p id="f462" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有参数，计算将转移到默认线程池。有了参数中的<em class="me">调度器</em>，计算转移到<em class="me">调度器</em>拥有的线程池。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3f9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="me">任务</em>的异步方法大多在方法内部调用<code class="fe mk ml mm mn b">shift</code>方法。</p><h2 id="fad4" class="mo kz iq bd la mp mq dn le mr ms dp li jy mt mu lm kc mv mw lq kg mx my lu mz bi translated">用Monix的异步方法进行线程转移</h2><p id="f632" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们来看看Monix的每个异步方法的线程移位。</p><p id="5476" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码是一个简单的程序，它在一个<em class="me">任务</em>上下文中执行三个任务。在生产中，应该进行错误处理，而不是调用<code class="fe mk ml mm mn b">runSyncUnsafe</code>方法。</p><p id="8229" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，这三个任务在主线程上执行，因为没有引入任何异步边界。另一方面，<em class="me"> Future </em>总是引入一个带有线程池的异步边界。这会导致不必要的上下文切换开销。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><ul class=""><li id="e21a" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated"><strong class="jp ir">执行异步</strong></li></ul><p id="f3c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="me"> </em> <code class="fe mk ml mm mn b">executeAsync</code>方法引入了一个带有默认线程池的异步边界，这个线程池是<code class="fe mk ml mm mn b">runSyncUnsafe</code>方法在执行之前使用的。在下面的代码中可以看到，<em class="me"> </em> <code class="fe mk ml mm mn b">shift</code> <em class="me"> </em>方法在这个方法中被称为<em class="me">。</em></p><pre class="kn ko kp kq gt nj mn nk nl aw nm bi"><span id="412c" class="mo kz iq mn b gy nn no l np nq">final def executeAsync: Task[A] =<br/>  Task.shift.flatMap(_ =&gt; this)</span></pre><p id="d545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且，调用<em class="me"> </em> <code class="fe mk ml mm mn b">executeAsync</code> <em class="me"> </em>和下面代码调用<code class="fe mk ml mm mn b">evalAsync</code> <em class="me"> </em>是一样的。</p><pre class="kn ko kp kq gt nj mn nk nl aw nm bi"><span id="f9d9" class="mo kz iq mn b gy nn no l np nq">Task.evalAsync(a) &lt;-&gt; Task.eval(a).executeAsync</span></pre><p id="6b36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码使用的是<code class="fe mk ml mm mn b">executeAsync</code> <em class="me"> </em>方法。<em class="me"> </em> <code class="fe mk ml mm mn b">heavyTask</code> <em class="me"> </em>方法<em class="me"> </em>运行在默认线程池，而不是主线程上。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><ul class=""><li id="ecbb" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated"><strong class="jp ir">异步边界</strong></li></ul><p id="1be0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mk ml mm mn b">asyncBoundary</code>方法在执行后引入了一个异步边界。正如您在下面的代码中看到的,<code class="fe mk ml mm mn b">asyncBoundary</code>方法可以指定一个<em class="me">调度程序。</em></p><pre class="kn ko kp kq gt nj mn nk nl aw nm bi"><span id="6412" class="mo kz iq mn b gy nn no l np nq">final def asyncBoundary: Task[A] =<br/>  flatMap(a =&gt; Task.<em class="me">shift</em>.map(_ =&gt; a))</span><span id="471b" class="mo kz iq mn b gy nr no l np nq">final def asyncBoundary(s: Scheduler): Task[A] =<br/>  flatMap(a =&gt; Task.<em class="me">shift</em>(s).map(_ =&gt; a))</span></pre><p id="b485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码使用的是<code class="fe mk ml mm mn b">asyncBoundary</code> <em class="me"> </em>方法。<em class="me"> </em> <code class="fe mk ml mm mn b">heavyTask</code> <em class="me"> </em>函数<em class="me"> </em>是在<code class="fe mk ml mm mn b">asyncBoundary</code> <em class="me"> </em>方法占用的线程池中运行的，而不是主线程，因为<code class="fe mk ml mm mn b">asyncBoundary</code>方法是在此方法之前调用的。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a089" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你在上面的<code class="fe mk ml mm mn b">executeAsync</code>和<code class="fe mk ml mm mn b">asyncBoundary</code>方法中看到的这些代码，在引入异步边界之后，后续任务在同一个线程池上运行。这可能会导致线程池的意外使用。例如，在上面的代码中，<code class="fe mk ml mm mn b">lightTask</code> <em class="me"> </em>函数应该运行在默认的线程池上，而不是用于阻塞的线程池。在这种情况下，线程池应该切换回默认的线程池。</p><p id="47fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的代码中，通过调用<code class="fe mk ml mm mn b">shift</code> <em class="me"> </em>和<em class="me"> </em> <code class="fe mk ml mm mn b">asyncBoundary</code> <em class="me"> </em>方法，线程池被切换回默认线程池。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><ul class=""><li id="7614" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated"><strong class="jp ir">执行</strong></li></ul><p id="9364" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果<code class="fe mk ml mm mn b">forceAsync</code> <em class="me"> </em>参数设置为true，则<code class="fe mk ml mm mn b">executeOn</code> <em class="me"> </em>方法可以指定计算运行的线程池。</p><pre class="kn ko kp kq gt nj mn nk nl aw nm bi"><span id="8bf7" class="mo kz iq mn b gy nn no l np nq">final def executeOn(s: Scheduler, forceAsync: Boolean = true): Task[A] =<br/>  <em class="me">TaskExecuteOn</em>(this, s, forceAsync)</span></pre><p id="62db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从3.0版本开始，线程池变成了在<code class="fe mk ml mm mn b">executeOn</code> <em class="me"> </em>方法<em class="me"> </em>被调用后，<code class="fe mk ml mm mn b">runSyncUnsafe</code>方法取的默认线程池。它防止我们导致线程池的非预期使用。</p><div class="ns nt gp gr nu nv"><a href="https://github.com/monix/monix/pull/670" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">通过alexandru Pull Request # 670 monix/monix，任务在分叉和异步边界方面变得更加智能</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">变化摘要:并行收集结果或创建竞争条件的任务操作现在分叉了…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kw nv"/></div></div></a></div><p id="9714" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码使用的是<code class="fe mk ml mm mn b">executeOn</code> <em class="me"> </em>方法。<em class="me"> </em> <code class="fe mk ml mm mn b">heavyTask</code> <em class="me"> </em>函数<em class="me"> </em>是在线程池上运行进行阻塞的，那么<code class="fe mk ml mm mn b">lightTask</code>函数是在默认的线程池上运行这个方法之后。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="6cda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更深入地了解使用<code class="fe mk ml mm mn b">forceAsync</code>参数方法的行为，我编写了下面的代码。</p><ol class=""><li id="8c0e" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk ok ng nh ni bi translated">将executeOn和forceAsync设置为true的Task.eval</li></ol><p id="585b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该任务正在线程池上运行，用于阻塞<code class="fe mk ml mm mn b">executeOn</code> <em class="me"> </em>方法指定的线程。任务完成后，线程池会迅速恢复到默认线程池。</p><p id="f55a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="me"> 2。</em>将executeOn和forceAsync设置为false的Task.eval</p><p id="ea53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该任务和后续任务正在主线程上运行。</p><p id="fa48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="me"> 3。</em>将executeOn和forceAsync设置为true的Task.evalAsync</p><p id="28e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该任务正在线程池上运行，用于阻塞<code class="fe mk ml mm mn b">executeOn</code> <em class="me"> </em>方法指定的线程。任务完成后，线程池会迅速恢复到默认线程池。</p><p id="c39d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="me"> 4。</em>将executeOn和forceAsync设置为false的Task.evalAsync</p><p id="8ee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该任务和后续任务正在线程池上运行，用于阻塞<code class="fe mk ml mm mn b">executeOn</code>方法的执行。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><ul class=""><li id="62f5" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated"><strong class="jp ir"> parMap2 </strong></li></ul><p id="8e17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为最后一个方法，我们来看看<em class="me"> </em> <code class="fe mk ml mm mn b">parMap2</code> <em class="me"> </em>方法的线程移位。建议使用<code class="fe mk ml mm mn b">parMap2</code> <em class="me"> </em>方法并行执行两个任务。这种方法也适用于错误处理和取消。</p><blockquote class="mb mc md"><p id="ef35" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">如果其中一个任务失败，那么所有其他任务都将被取消，最终结果将是失败。</p></blockquote><p id="3aa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的代码中，<code class="fe mk ml mm mn b">parMap2</code> <em class="me"> </em>方法需要两个任务。每个任务并行运行，内部任务运行在指定的线程池上。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="6fe6" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="8535" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Monix Task有有用的异步方法，但是每个行为都是不同的。所以我们必须分别使用这些方法。</p><p id="dbc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>