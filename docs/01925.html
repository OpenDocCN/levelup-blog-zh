<html>
<head>
<title>You’re Not My (Data) Type: An Intro to TypeScript — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不是我的(数据)类型:TypeScript介绍—第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/youre-not-my-data-type-an-intro-to-typescript-part-2-b2001f9e2225?source=collection_archive---------11-----------------------#2020-02-06">https://levelup.gitconnected.com/youre-not-my-data-type-an-intro-to-typescript-part-2-b2001f9e2225?source=collection_archive---------11-----------------------#2020-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6231" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">注意:这是我之前写的</em> <a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/youre-not-my-data-type-an-intro-to-typescript-38dab9cdc90a"> <em class="kl">的延续。如果你是TypeScript的新手，我强烈建议你从第一篇博客开始，然后再看下面的内容。</em></a></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/e4b36b252c144180687de9a2d14c75b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7QwRdAxb9Q8wejjQJiFJsQ.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">TypeScript是JavaScript的超集。</figcaption></figure><p id="6453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们已经讨论了基本数据类型和数据结构的基本赋值，我们可以继续讨论TypeScript提供的一些更非传统的特性。</p><h1 id="55aa" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">TypeScript中的新类型</h1><p id="6c62" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">由于TypeScript是JavaScript的超集，它可以访问JavaScript中所有可用的数据类型。然而，我们还必须记住，因为TypeScript是一个编译成JavaScript的工具，所以TypeScript可以访问新类型。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">预定义和类型推断的TypeScript对象。</figcaption></figure><h2 id="ec00" class="mi le iq bd lf mj mk dn lj ml mm dp ln jy mn mo lr kc mp mq lv kg mr ms lz mt bi translated">元组和联合类型</h2><p id="3691" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">我们要看的第一种类型是一个<strong class="jp ir">元组</strong>。元组是一个固定长度的数组，在每个槽中都有预先确定的类型。在上面的对象中，我们已经定义了<code class="fe mu mv mw mx b">player</code>对象的<code class="fe mu mv mw mx b">team</code>属性是一个tuple——一个包含一个字符串和一个数字<strong class="jp ir">的数组。</strong>下面是一个错误的例子，如果元组被错误地赋值，我们会得到这个错误。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi my"><img src="../Images/9da01e940e36f5f2b5df6a2d1905d46a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6njXYkuzHlN5Zgg6OWcS2Q.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">元组的类型分配不正确</figcaption></figure><p id="e93a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们遇到了TypeScript的类型推断问题——记住TypeScript可以为您推断类型。这是在上面的类型推断对象上的VSCode突出显示中弹出的内容。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mz"><img src="../Images/3708ca02156fd7469ac633fb1da2f100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1nUZPEAZfwq4nvIQ6U6KqQ.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">联合类型的类型推理</figcaption></figure><p id="fb99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在编写元组时，我们声明了数组<code class="fe mu mv mw mx b">team:[string, number]</code>中的类型，但是TypeScript以不同的方式进行了推断。这就是所谓的<strong class="jp ir">联合</strong>型。当一个变量可以有多种类型时，我们列出可以用“|”分隔的类型。在这种情况下，TypeScript推断我们的元组实际上是一个数组，其中可以有字符串<strong class="jp ir">或</strong>数字。请记住，在使用元组时，您必须声明元组，而不是依赖类型推断。</p><h2 id="311c" class="mi le iq bd lf mj mk dn lj ml mm dp ln jy mn mo lr kc mp mq lv kg mr ms lz mt bi translated">枚举类型</h2><p id="ad4d" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">枚举类型是给一组数值命名的一种方式。在上面的例子中，我们创建了一个名为<code class="fe mu mv mw mx b">FieldPosition</code>的枚举，并为玩家可用的四种位置类型分配了名称。我们通过调用<code class="fe mu mv mw mx b">FieldPosition.GOALIE</code>将<code class="fe mu mv mw mx b">“GOALIE”</code>值赋给鲍勃。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi na"><img src="../Images/2a11d588962f0c33bf630304920a5105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CooilN5eN65VuuitnYxsdw.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">枚举类型的赋值</figcaption></figure><p id="c554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为<code class="fe mu mv mw mx b">"GOALIE"</code>是数组中的第一项，所以它是数值0的名称，这也解释了为什么我们将类型预定义为<code class="fe mu mv mw mx b">Number</code>。枚举从0开始，很像数组，但是如果我们定义起始数字，后面的每个数值将按顺序排列。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nb"><img src="../Images/62a5fa22e54dc7146dfe850826a1f5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0sluhpdGi-f5UdUDc8hdJg.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">为第一个枚举类型分配一个新数字。</figcaption></figure><h2 id="f6ef" class="mi le iq bd lf mj mk dn lj ml mm dp ln jy mn mo lr kc mp mq lv kg mr ms lz mt bi translated">任何类型</h2><p id="422c" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated"><code class="fe mu mv mw mx b">any</code>类型是不言自明的——当我们不知道我们的变量应该或将要是什么类型时，就使用它。应该尽可能少地使用<code class="fe mu mv mw mx b">any</code>类型，因为它计划不周，而且与TypeScript的目的有些背道而驰。一个好的替代方法是依靠类型推断。</p><p id="7a33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们在<code class="fe mu mv mw mx b">player</code>上的<code class="fe mu mv mw mx b">active</code>属性被赋予了一个any类型，所以我们放了一个字符串来表示他是<code class="fe mu mv mw mx b">‘injured’</code>。然而，在我们的类型推断版本中，我们放了一个布尔值<code class="fe mu mv mw mx b">false</code>，它看起来更直观，并且通过锁定类型可以更好地计划。</p><h2 id="7441" class="mi le iq bd lf mj mk dn lj ml mm dp ln jy mn mo lr kc mp mq lv kg mr ms lz mt bi translated">文字类型和类型别名</h2><p id="92c5" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在TypeScript中，我们还可以将我们的类型限制为特定的值。<strong class="jp ir">文字</strong>类型有点像JavaScript中的<code class="fe mu mv mw mx b">const</code>关键字，锁定了变量的值。然而，使用<strong class="jp ir"> Union </strong>类型，我们可以将我们的类型限制为几个选择，而不是只有一个值。让我们用它来替换上面例子中的枚举类型。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nc"><img src="../Images/f0bda310d5b25a0c074f2080a8dae3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jj-XQgwWtEI5LFkv1OVM0Q.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">对position属性使用文本类型</figcaption></figure><p id="79be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的position属性只能是字符串<code class="fe mu mv mw mx b">‘GOALIE’|’STRIKER’|’MIDFIELD’|’DEFENDER’</code>中的一个。因为我们明确声明了类型的值，所以我们不能利用类型推断。然而，我们可以将我们的文字类型存储在类型别名中，这样如果需要的话，我们可以在其他地方重用它。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nd"><img src="../Images/2188a307941c8744a06e44d85d16016e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*muLReSCrzTK5WpLw1bb19g.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">使用类型别名定义文本类型。</figcaption></figure><p id="c3bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们使用别名<code class="fe mu mv mw mx b">FieldPosition</code>来存储使用关键字<code class="fe mu mv mw mx b">type</code>的类型。现在，无论我们在哪里赋值<code class="fe mu mv mw mx b">FieldPosition</code>，我们都被限制在四个字符串值。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ne"><img src="../Images/367d1db6c09c2b1dbfa18b417a3ceac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cgujSaSFq5iFFIts47LQiA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">FieldPosition别名的类型分配错误</figcaption></figure><p id="4860" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里要注意两件重要的事情:你可以使用任何带有类型别名或文字类型的类型或值。我只是在这里使用了字符串。例如，我们可以创建一个带有<code class="fe mu mv mw mx b">type JerseyNumber = number</code>或<code class="fe mu mv mw mx b">typeJerseyNumber = number | string</code>的球衣号码类型，这取决于我们想要的类型。类型别名最常用于联合或元组类型。</p><p id="34b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类型别名对于建立变量非常有用，但是它们不应该用于对象。记住类型别名就是别名。如果我们想对对象做任何改变，我们也必须<a class="ae km" href="https://blog.fullstacktraining.com/typescript-interfaces-vs-types/" rel="noopener ugc nofollow" target="_blank">改变类型</a>。为了使我们的对象更加灵活，我们使用接口。</p><h1 id="5942" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">接口</h1><p id="93b9" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">除了一些例外，接口就像一个预先声明的对象。接口可以通过添加“？”来获取可选参数。使用接口的类不限于接口参数，只要所有必需的参数都存在。接口也可以像类一样互相扩展。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">用类实现接口</figcaption></figure><p id="fdd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面，我已经将我们的player对象重构为一个接口。我用我们的界面创建了一个新的播放器，但是TypeScript抛出了一个错误。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e4ca3ce218601e41a1f6891c1ffb8254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*wShHh5fJgZP-soHq12JbnQ.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">对象缺少接口中所需的值</figcaption></figure><p id="4612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mu mv mw mx b">Player1</code>有一个<code class="fe mu mv mw mx b">name</code>和<code class="fe mu mv mw mx b">jerseyNumber</code>，但是它没有一个<code class="fe mu mv mw mx b">age</code>。由于<code class="fe mu mv mw mx b">age</code>是<strong class="jp ir">而不是</strong>可选参数，TypeScript抛出一个错误。</p><p id="d500" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们来看看<code class="fe mu mv mw mx b">Player</code>的类声明。在构造函数中，我们在所有变量参数之前调用<code class="fe mu mv mw mx b">public</code>,使它们可以在类外访问，所有的参数都带有“？”是可选的。注意，我们没有得到任何关于<code class="fe mu mv mw mx b">active</code>的错误，但是我们得到了一个关于<code class="fe mu mv mw mx b">jerseyNumber</code>的错误。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/1f82cb914d5bf59af3cd0f618cdd49b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*0hNcORaeGhKJuLvQ5Av_xg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">用PlayerConfig实现类播放器</figcaption></figure><p id="4c13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为我们<strong class="jp ir">需要在我们的类构造函数中声明参数。</strong>我们的类总是可以添加更多的属性，只要每个类实例<strong class="jp ir">都有接口中定义的名称和年龄。Bob没有错误，因为我们已经考虑了我们的类构造函数中的附加内容。Dan也是有效的，因为它满足了我们原始接口的需求。</strong></p><p id="6b8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这是一个糟糕的计划。我们应该改变或扩展我们的接口来考虑所有这些属性。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3260e5e8073ef97ab8844763a44fefb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*7d7WMvtfdUabWzPErH3PCA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">具有接口的类的最终实现</figcaption></figure><h1 id="ff16" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">功能类型</h1><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="fda6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后要看的是函数类型。我们可以通过将类型放在参数后面的冒号后面来为函数的返回值分配类型。如果我们看看上面的第一个<code class="fe mu mv mw mx b">add</code>函数，我们知道它是不正确的，因为该函数应该总是返回一个数字。<strong class="jp ir"> TypeScript也知道，因为它可以对函数使用类型推断。</strong></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b504ef5c9537d07a31f1332507901b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*zP0p9ynmkP3tjD3y_AgACA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">推断返回类型错误的TypeScript</figcaption></figure><p id="51ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们已经声明返回值需要是一个字符串，所以它在函数的返回部分显示了一个错误。但是，最好是简单地声明一个数字类型，或者让Typescript推断类型。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/51f3fa79d83a9cdb0ef3a0a0c71862f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*ue_H77udRCnrTfHkFhP6xA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">add函数上的类型推理</figcaption></figure><p id="1311" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个函数有一个<code class="fe mu mv mw mx b">void</code>类型。因为函数<strong class="jp ir">不返回任何东西，</strong>的返回值不存在。然而，为了避免错误和更好地理解我们的代码，我们标记void，因为Javascript中的函数如果没有指定，将总是返回undefined。</p><h1 id="1a45" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">资源</h1><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/youre-not-my-data-type-an-intro-to-typescript-38dab9cdc90a"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">你不是我的(数据)类型:TypeScript简介</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">如果您以前曾经使用或编写过API，您会知道正确使用它的一个重要部分是理解…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob kx nn"/></div></div></a></div><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="oc mh l"/></div></figure><div class="nk nl gp gr nm nn"><a href="https://www.typescriptlang.org/docs/home.html" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">已经熟悉TypeScript了？</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">编辑描述</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.typescriptlang.org</p></div></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://medium.com/javascript-in-plain-english/typescript-with-node-and-express-js-why-when-and-how-eb6bc73edd5d" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">如何(以及为什么)将Typescript用于Node和Express。</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">为什么要在大型项目中使用Typescript。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="od l ny nz oa nw ob kx nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://www.typescriptlang.org/docs/handbook/functions.html" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">过载#</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">函数是JavaScript中任何应用程序的基本构件。它们是你建立一层层…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.typescriptlang.org</p></div></div></div></a></div></div></div>    
</body>
</html>