<html>
<head>
<title>What are RxJS Schedulers?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是RxJS调度程序？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-are-rxjs-schedulers-919f5e53438f?source=collection_archive---------4-----------------------#2020-02-02">https://levelup.gitconnected.com/what-are-rxjs-schedulers-919f5e53438f?source=collection_archive---------4-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6a418c2958cec6c3ec765cee7adb9645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z3GrCwB1BvO9ND0S"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@emmamatthews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾玛·马修斯数字内容制作</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="39a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调度程序是控制何时开始订阅以及何时传递通知的实体。它有3个组成部分:</p><ul class=""><li id="68b2" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">数据结构—它知道如何根据优先级或其他标准存储和排列任务。</li><li id="de88" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">执行上下文—表示任务执行的位置和时间。它可以是立即的，也可以推迟到以后。</li><li id="11d9" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">虚拟时钟——任务相对于调度器上的<code class="fe ls lt lu lv b">now()</code> getter方法指示的时间运行。</li></ul><h1 id="f55a" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">定义调度程序</h1><p id="5d9c" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们可以定义一个基本的调度程序如下:</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="4420" class="nh lx it lv b gy ni nj l nk nl">import { of, asyncScheduler } from "rxjs";<br/>import { observeOn } from "rxjs/operators";</span><span id="d867" class="nh lx it lv b gy nm nj l nk nl">of(1, 2, 3)<br/>  .pipe(observeOn(asyncScheduler))<br/>  .subscribe(val =&gt; console.log(val));</span></pre><p id="d5f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码通过使用<code class="fe ls lt lu lv b">asyncScheduler</code>将我们的同步可观察对象转化为异步可观察对象。</p><p id="5d12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们比较下面同步示例的输出，我们会注意到不同之处:</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="0924" class="nh lx it lv b gy ni nj l nk nl">import { of, asyncScheduler } from "rxjs";<br/>import { observeOn } from "rxjs/operators";</span><span id="8ed5" class="nh lx it lv b gy nm nj l nk nl">const observable = of(1, 2, 3);</span><span id="d668" class="nh lx it lv b gy nm nj l nk nl">console.log("before sync subscribe");<br/>observable.subscribe({<br/>  next(x) {<br/>    console.log(`got sync value ${x}`);<br/>  },<br/>  error(err) {<br/>    console.error(`something wrong occurred: ${err}`);<br/>  },<br/>  complete() {<br/>    console.log("done");<br/>  }<br/>});<br/>console.log("after sync subscribe");</span></pre><p id="8249" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">异步示例:</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="49e1" class="nh lx it lv b gy ni nj l nk nl">import { of, asyncScheduler } from "rxjs";<br/>import { observeOn } from "rxjs/operators";</span><span id="5436" class="nh lx it lv b gy nm nj l nk nl">const observable = of(1, 2, 3);</span><span id="a090" class="nh lx it lv b gy nm nj l nk nl">console.log("before async subscribe");<br/>observable.pipe(observeOn(asyncScheduler)).subscribe({<br/>  next(x) {<br/>    console.log(`got async value ${x}`);<br/>  },<br/>  error(err) {<br/>    console.error(`something wrong occurred: ${err}`);<br/>  },<br/>  complete() {<br/>    console.log("done");<br/>  }<br/>});<br/>console.log("after async subscribe");</span></pre><p id="d704" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到同步示例输出:</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="30cc" class="nh lx it lv b gy ni nj l nk nl">before sync subscribe<br/>got sync value 1<br/>got sync value 2<br/>got sync value 3<br/>done<br/>after sync subscribe</span></pre><p id="e870" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">带有<code class="fe ls lt lu lv b">asyncScheduler</code>的异步示例得到如下输出:</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="54cd" class="nh lx it lv b gy ni nj l nk nl">before async subscribe<br/>after async subscribe<br/>got async value 1<br/>got async value 2<br/>got async value 3<br/>done</span></pre><p id="5d6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，<code class="fe ls lt lu lv b">asyncScheduler</code>将可观察对象的执行推迟到同步代码运行之后。</p><p id="3697" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ls lt lu lv b">async</code>调度程序通过<code class="fe ls lt lu lv b">setTimeout</code>或<code class="fe ls lt lu lv b">setInterval</code>进行操作。即使延迟为零，它仍然在<code class="fe ls lt lu lv b">setTimeout</code>或<code class="fe ls lt lu lv b">setInterval</code>上运行。它将在下一次事件循环迭代中运行。</p><p id="602d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ls lt lu lv b">asyncScheduler</code>有一个<code class="fe ls lt lu lv b">schedule()</code>方法，它接受一个delay参数，这个参数指的是相对于调度程序自己的内部时钟的时间量。内部时钟与实际时钟时间没有任何关系。临时操作是由调度程序的时钟决定的，而不是真正的时钟。</p><p id="b5f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于测试很有用，因为我们可以很容易地在任务异步运行时伪造测试时间。</p><h1 id="2335" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">调度程序类型</h1><p id="994a" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">除了<code class="fe ls lt lu lv b">asyncScheduler</code>，RxJS中还有其他类型的调度程序:</p><ul class=""><li id="a048" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">null</code> —同步递归传递通知。对于常数时间或尾递归运算很有用</li><li id="30d1" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">queueScheduler</code> —当前事件帧中队列上的调度。对迭代有用。</li><li id="3569" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">asapScheduler</code> —微任务队列中的时间表，与用于承诺的时间表相同</li><li id="13cb" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">asyncScheduler</code> —用于基于时间的操作。工作安排在<code class="fe ls lt lu lv b">setInterval</code></li><li id="a665" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">animationFrameScheduler</code> —安排任务在下一次浏览器内容重绘之前运行。它可以用来平滑浏览器动画</li></ul><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/dea3729415be4d11722e308d173d28e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nj51xY-QB5AoBvKg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@bajkorenata?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Renáta-Adrienn </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="916b" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">使用调度程序</h1><p id="7857" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">以下函数采用调度程序参数:</p><ul class=""><li id="d3e4" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">bindCallback</code></li><li id="747e" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">bindNodeCallback</code></li><li id="3dc8" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">combineLatest</code></li><li id="60c0" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">concat</code></li><li id="6975" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">empty</code></li><li id="6ac7" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">from</code></li><li id="df65" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">fromPromise</code></li><li id="8fca" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">interval</code></li><li id="dc8b" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">merge</code></li><li id="d742" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">of</code></li><li id="c8fe" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">range</code></li><li id="87da" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">throw</code></li><li id="c59a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe ls lt lu lv b">timer</code></li></ul><p id="dfb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经在使用调度程序，但没有明确指定它。RxJS将通过找到一个引入最少并发量的调度器来选择一个默认调度器并完成工作。</p><p id="15a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，对于定时操作，使用<code class="fe ls lt lu lv b">async</code>，对于发出有限数量消息的简单操作，使用<code class="fe ls lt lu lv b">null</code>或<code class="fe ls lt lu lv b">undefined</code>。</p><p id="affd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些操作符还带有调度程序参数。包括<code class="fe ls lt lu lv b">bufferTime</code>、<code class="fe ls lt lu lv b">debounceTime</code>、<code class="fe ls lt lu lv b">delay</code>、<code class="fe ls lt lu lv b">auditTime</code>、<code class="fe ls lt lu lv b">sampleTime</code>、<code class="fe ls lt lu lv b">throttleTime</code>、<code class="fe ls lt lu lv b">timeInterval</code>、<code class="fe ls lt lu lv b">timeout</code>、<code class="fe ls lt lu lv b">timeoutWith</code>、<code class="fe ls lt lu lv b">windowTime</code>等与时间相关的。</p><p id="4725" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他实例操作符如<code class="fe ls lt lu lv b">cache</code>、<code class="fe ls lt lu lv b">combineLatest</code>、<code class="fe ls lt lu lv b">concat</code>、<code class="fe ls lt lu lv b">expand</code>、<code class="fe ls lt lu lv b">merge</code>、<code class="fe ls lt lu lv b">publishReplay</code>、<code class="fe ls lt lu lv b">startWith</code>也采用调度器参数。</p><p id="8a60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用调度程序，我们可以控制Observables何时发出数据。有不同种类的调度器，RxJS会根据创建最少并发性的原则来自动选择。</p><p id="fd59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调度程序根据自己的时钟运行任务。与现实世界的时钟无关。</p><p id="38f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">许多运营商允许我们设置一个调度程序来满足我们的需求。</p></div></div>    
</body>
</html>