<html>
<head>
<title>Node.js Tips — Request URLs, Parsing Request Bodies, Upload Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—请求URL、解析请求正文、上传文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-tips-request-urls-parsing-request-bodies-upload-9caaa7f8446e?source=collection_archive---------15-----------------------#2020-07-16">https://levelup.gitconnected.com/node-js-tips-request-urls-parsing-request-bodies-upload-9caaa7f8446e?source=collection_archive---------15-----------------------#2020-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/27a29e9be550135518ac0307d84281c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NTMcCG6C8X65K4n0"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@1875patricia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">王巍</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9471" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="4077" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从请求中获取路径</h1><p id="240b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过使用<code class="fe mh mi mj mk b">request.url</code>解析请求URL来从请求中获取路径。</p><p id="b61a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c94a" class="mt lf it mk b gy mu mv l mw mx">const http = require("http");<br/>const url = require("url");</span><span id="5920" class="mt lf it mk b gy my mv l mw mx">const onRequest = (request, response) =&gt; {<br/>  const pathname = url.parse(request.url).pathname;<br/>  console.log(pathname);<br/>  response.writeHead(200, { "Content-Type": "text/plain" });<br/>  response.write("hello");<br/>  response.end();<br/>}</span><span id="3ae7" class="mt lf it mk b gy my mv l mw mx">http.createServer(onRequest).listen(8888);</span></pre><p id="e82b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所要做的就是获取<code class="fe mh mi mj mk b">request.url</code>属性来获取URL。</p><p id="f239" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以用<code class="fe mh mi mj mk b">url</code>模块解析它。</p><p id="dff2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以用<code class="fe mh mi mj mk b">pathname</code>来获得相对路径。</p><h1 id="0c29" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将相对路径转换为绝对路径</h1><p id="faf0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过使用<code class="fe mh mi mj mk b">path</code>模块的<code class="fe mh mi mj mk b">resolve</code>方法将相对路径转换为绝对路径。</p><p id="d816" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="981a" class="mt lf it mk b gy mu mv l mw mx">const resolve = require('path').resolve<br/>const absPath = resolve('../../foo/bar.txt');</span></pre><p id="a65f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用相对路径调用<code class="fe mh mi mj mk b">resolve</code>来返回文件的绝对路径。</p><h1 id="38b0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">获取以字节为单位的字符串长度</h1><p id="0f9c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过使用<code class="fe mh mi mj mk b">Buffer.byteLength</code>方法获得以字节为单位的字符串长度。</p><p id="e620" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b467" class="mt lf it mk b gy mu mv l mw mx">const byteLength = Buffer.byteLength(string, 'utf8');</span></pre><p id="2ab1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们传入一个<code class="fe mh mi mj mk b">string</code>到<code class="fe mh mi mj mk b">Buffer.byteLength</code>来获得字符串的字节长度。</p><h1 id="afb9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">获取从Express中的表单传递的数据</h1><p id="5d11" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要从Express中的表单获得数据，我们可以使用<code class="fe mh mi mj mk b">body-parser</code>包来完成。</p><p id="92b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后为了得到解析的结果，我们可以从<code class="fe mh mi mj mk b">req.body</code>属性中得到它。</p><p id="5e77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0463" class="mt lf it mk b gy mu mv l mw mx">const bodyParser = require('body-parser');<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="8181" class="mt lf it mk b gy my mv l mw mx">app.post('/game', (req, res) =&gt; {<br/>  res.render('game', { ...req.body });<br/>});</span></pre><p id="69de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用<code class="fe mh mi mj mk b">app.post</code>来创建一个POST route，它通过<code class="fe mh mi mj mk b">req.body</code>获取请求体，因为我们调用了<code class="fe mh mi mj mk b">bodyParser.urlencoded</code>来解析URL编码的有效负载。</p><p id="ca69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">extended</code>设置为<code class="fe mh mi mj mk b">true</code>让<code class="fe mh mi mj mk b">body-parser</code>接受表单数据中类似JSON的数据，包括嵌套对象。</p><p id="d1f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这个选项，我们不必像传统的HTML表单发送那样发送键值对。</p><h1 id="9c40" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在同一个端口上运行多个Express应用</h1><p id="2846" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">app.use</code>合并多个Express应用程序，并在同一个端口上运行它们。</p><p id="35e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f0e3" class="mt lf it mk b gy mu mv l mw mx">app<br/>  .use('/app1', require('./app1').app)<br/>  .use('/app2', require('./app2').app)<br/>  .listen(8080);</span></pre><p id="52de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要求<code class="fe mh mi mj mk b">app1</code>和<code class="fe mh mi mj mk b">app2</code>在一个应用程序中使用他们的路线。</p><p id="2dd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mh mi mj mk b">listen</code>来监听端口8080中的请求。</p><h1 id="9e58" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用NodeJs子进程改变工作目录</h1><p id="1bcb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">cwd</code>选项改变工作目录。</p><p id="c43e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bc9a" class="mt lf it mk b gy mu mv l mw mx">const exec = require('child_process').exec;</span><span id="cf03" class="mt lf it mk b gy my mv l mw mx">exec('pwd', {<br/>  cwd: '/foo/bar/baz'<br/>}, (error, stdout, stderr) =&gt; {<br/>  // work with result<br/>});</span></pre><p id="9a5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用一个带有<code class="fe mh mi mj mk b">cwd</code>属性的对象调用<code class="fe mh mi mj mk b">exec</code>来设置当前的工作目录。</p><p id="3a64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们在回调中得到结果。</p><h1 id="101b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用AWS SDK for Node.js将二进制文件上传到S3</h1><p id="ef44" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">通过使用AWS包，我们可以使用Node.js AWS SDK将二进制文件上传到S3。</p><p id="c2bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="33f6" class="mt lf it mk b gy mu mv l mw mx">const AWS = require('aws-sdk');<br/>const fs = require('fs');</span><span id="a5c2" class="mt lf it mk b gy my mv l mw mx">AWS.config.update({ accessKeyId: 'key', secretAccessKey: 'secret' });</span><span id="332c" class="mt lf it mk b gy my mv l mw mx">const fileStream = fs.createReadStream('zipped.tgz');</span><span id="c869" class="mt lf it mk b gy my mv l mw mx">fileStream.on('error', (err) =&gt; {<br/>  if (err) { <br/>    console.log(err); <br/>  }<br/>});  </span><span id="c8ea" class="mt lf it mk b gy my mv l mw mx">fileStream.on('open', () =&gt; {<br/>  const s3 = new AWS.S3();<br/>  s3.putObject({<br/>    Bucket: 'bucket',<br/>    Key: 'zipped.tgz',<br/>    Body: fileStream<br/>  }, (err) =&gt; {<br/>    if (err) { <br/>     throw err; <br/>    }<br/>  });<br/>});</span></pre><p id="36dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj mk b">aws-sdk</code>包。</p><p id="0a5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们向<code class="fe mh mi mj mk b">AWS.config.update</code>认证。</p><p id="456a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mh mi mj mk b">createReadStream</code>从文件中创建一个读取流。</p><p id="8b9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过给<code class="fe mh mi mj mk b">'open'</code>事件附加一个监听器来监听打开的文件。</p><p id="67b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们创建一个<code class="fe mh mi mj mk b">AWS.S3</code>实例。</p><p id="fb4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用<code class="fe mh mi mj mk b">putObject</code>来上传文件。</p><p id="cd86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Bucket</code>是桶名。</p><p id="32db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Key</code>是文件的路径。</p><p id="42ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Body</code>是我们创建的文件的读取流。</p><p id="f6fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还监听<code class="fe mh mi mj mk b">error</code>事件，以防遇到任何错误。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/76e7e87f539ccb7212977c02242f151e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7jx7L3e4q0AsLaM4"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Robina Weermeijer 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="8d8f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="1644" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们使用<code class="fe mh mi mj mk b">http</code>模块来监听请求，我们可以用<code class="fe mh mi mj mk b">request.url</code>属性获得请求的路径。</p><p id="76dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要将相对路径转换成绝对路径，我们可以使用<code class="fe mh mi mj mk b">path</code>模块的<code class="fe mh mi mj mk b">resolve</code>方法。</p><p id="2f00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过创建一个读取流并调用<code class="fe mh mi mj mk b">putObject</code>来用S3上传文件。</p><p id="2f9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">exec</code>设置当前工作目录。</p></div></div>    
</body>
</html>