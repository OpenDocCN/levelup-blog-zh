<html>
<head>
<title>JavaScript Mistakes — Spaces and Useless Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript错误——空格和无用代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-mistakes-spaces-and-useless-code-82a5445e7f1b?source=collection_archive---------20-----------------------#2020-04-09">https://levelup.gitconnected.com/javascript-mistakes-spaces-and-useless-code-82a5445e7f1b?source=collection_archive---------20-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/dc26426d3a8dfe556f7e2fcfe542fc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hzJM4IqkMe39rp7q"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c6b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="bb96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们看看如何消除可能破坏代码的无用字符。</p><h1 id="0188" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不规则空白字符</h1><p id="0997" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有些空格字符并不是在所有地方都被认为是空格。因此，我们可能会遇到意外的令牌错误。</p><p id="3c29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它在现代浏览器中没有显示，这使得代码很难正确可视化。</p><p id="6a9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">行分隔符在JSON中也是无效字符，会导致更多的解析错误。</p><p id="fb5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不规则字符的完整列表是这里的<a class="ae kf" href="https://eslint.org/docs/rules/no-irregular-whitespace" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="da79" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">字符类语法中具有多个码位的字符</h1><p id="aa13" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">字符串中不允许有多个码位的字符，如<code class="fe mh mi mj mk b">U+2747</code>。我们应该在字符串中使用由单个代码点组成的字符，如常规的字母数字字符和标点符号。</p><h1 id="1727" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将全局对象属性作为函数调用</h1><p id="820c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">像<code class="fe mh mi mj mk b">Math</code>、<code class="fe mh mi mj mk b">JSON</code>和<code class="fe mh mi mj mk b">Reflect</code>这样的一些全局对象属性不应该被称为函数，因为只有它们的方法应该被调用，而属性应该被访问。</p><p id="e513" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下内容无效:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="07bd" class="mt lf it mk b gy mu mv l mw mx">let math = Math();<br/>let json = JSON();</span></pre><p id="414b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用上述对象的正确方法是访问它们的属性:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6d72" class="mt lf it mk b gy mu mv l mw mx">let pi = <!-- -->Math.PI;<br/>let obj = JSON.parse('{}');</span></pre><h1 id="84e9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">直接使用Object.prototypes内置</h1><p id="7a9a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">来自<code class="fe mh mi mj mk b">Object.prototype</code>的一些方法，如<code class="fe mh mi mj mk b">hasOwnProperty</code>、<code class="fe mh mi mj mk b">isPrototypeOf</code>和<code class="fe mh mi mj mk b">propertyIsEnumerable</code>，并不意味着被实例直接调用。</p><p id="3983" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下是不正确的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ea09" class="mt lf it mk b gy mu mv l mw mx">let bar = {};<br/>let foo = {};<br/>const hasBarProperty = foo.hasOwnProperty("bar");<br/>const isPrototypeOfBar = foo.isPrototypeOf(bar);<br/>const barIsEnumerable = foo.propertyIsEnumerable("bar");</span></pre><p id="950b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们的名称如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2414" class="mt lf it mk b gy mu mv l mw mx">let bar = {};<br/>let foo = {};<br/>const hasBarProperty = Object.prototype.hasOwnProperty.call(foo, "bar");<br/>const isPrototypeOfBar = Object.prototype.isPrototypeOf.call(foo, bar);<br/>const barIsEnumerable = Object.prototype.propertyIsEnumerable(foo, "bar");</span></pre><h1 id="23e9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正则表达式中的额外空格</h1><p id="99ee" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">多重空白难以阅读。很难判断正则表达式中有多少空格。因此，我们应该使用单个空格，然后指定我们想要匹配的空格的数量。</p><p id="4b87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c229" class="mt lf it mk b gy mu mv l mw mx">const re = /a   b/;</span></pre><p id="926b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f94e" class="mt lf it mk b gy mu mv l mw mx">const re = /a {3}b/;</span></pre><h1 id="804a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从Setters返回值</h1><p id="3683" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Setters的返回值被忽略，即使它在那里。因此，返回值在setter内部是没有用的。这也为错误创造了更多的机会。</p><p id="7332" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这适用于<code class="fe mh mi mj mk b">Object.create</code>、<code class="fe mh mi mj mk b">Objecr.defineProperty</code>、<code class="fe mh mi mj mk b">Object.defineProperties</code>和<code class="fe mh mi mj mk b">Reflect.defineProperty</code>中的对象文字、类声明和表达式以及属性描述符。</p><p id="a196" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们应该在下面的代码中返回值:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="eee4" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>  set firstName(value) {<br/>    this._firstName = value;<br/>    return value;<br/>  }<br/>}</span></pre><p id="011e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6319" class="mt lf it mk b gy mu mv l mw mx">const person = {<br/>  set firstName(value) {<br/>    this._firstName = value;<br/>    return value;  <br/>  }<br/>}</span></pre><p id="6898" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="079e" class="mt lf it mk b gy mu mv l mw mx">const Person = class {<br/>  set firstName(value) {<br/>    this._firstName = value;<br/>    return value;<br/>  }<br/>}</span></pre><p id="e48f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9c94" class="mt lf it mk b gy mu mv l mw mx">let person = {};<br/>Object.defineProperty(person, "firstName", {<br/>  set(value) {<br/>    this._firstName = value;<br/>    return false;<br/>  }<br/>});</span></pre><p id="5899" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该从上面的例子中删除<code class="fe mh mi mj mk b">return</code>语句，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a6a9" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>  set firstName(value) {<br/>    this._firstName = value;<br/>  }<br/>}</span></pre><p id="5e0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b738" class="mt lf it mk b gy mu mv l mw mx">const person = {<br/>  set firstName(value) {<br/>    this._firstName = value;<br/>  }<br/>}</span></pre><p id="78d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e055" class="mt lf it mk b gy mu mv l mw mx">const Person = class {<br/>  set firstName(value) {<br/>    this._firstName = value;<br/>  }<br/>}</span></pre><p id="86d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b9e7" class="mt lf it mk b gy mu mv l mw mx">let person = {};<br/>Object.defineProperty(person, "firstName", {<br/>  set(value) {<br/>    this._firstName = value;<br/>    return false;<br/>  }<br/>});</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/5750ba24cdcf569d665032febd186f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BR2W-WGm8w9_AE6A"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安德鲁·查尼在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="27a9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">稀疏阵列</h1><p id="6219" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript中允许数组中有空槽。只包含逗号的数组文本是有效的。然而，它们可能会让开发人员感到困惑。</p><p id="ee16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，开发人员可能会对以下数组感到困惑:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="50a4" class="mt lf it mk b gy mu mv l mw mx">const items = [, ];<br/>const strs = ["foo", , "bars"];</span></pre><p id="f80b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c1a7" class="mt lf it mk b gy mu mv l mw mx">const items = [];<br/>const strs = ["foo", "bars", ];</span></pre><p id="a864" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以有尾随逗号。</p><h1 id="d1c4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">常规字符串中的模板文字占位符语法</h1><p id="40df" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">常规字符串不应该有模板文字占位符，因为它们在常规字符串中不起作用，而且很容易被开发人员误认为是模板字符串。</p><p id="2e94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下可能是错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d897" class="mt lf it mk b gy mu mv l mw mx">"Hello ${name}!";<br/>'Hello ${name}!';<br/>"Sum: ${1 + 2}";</span></pre><p id="62dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7fcb" class="mt lf it mk b gy mu mv l mw mx">`Hello ${name}!`;<br/>`Sum: ${1 + 2}`;</span></pre><h1 id="2b92" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="5663" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有许多字符不应该出现在JavaScript代码中，尽管有些字符是允许的。代码中不应该出现不规则的空白字符。由多个代码点组成的字符不应该出现在JavaScript字符串中。</p><p id="75ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不应该直接调用全局对象。只有它们的属性才应该被访问。</p><p id="7a22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正则表达式字符串和文字中有多余的空格，所以不应该包含它们。还有，setters中的返回值是没有用的，所以不应该添加。</p><p id="7c8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript数组中允许有多个连续的逗号，但是它们会让开发人员感到困惑，所以应该避免使用。</p></div></div>    
</body>
</html>