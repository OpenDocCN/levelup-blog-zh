<html>
<head>
<title>Debugging AWS Lambda Functions with AWS X-Ray</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用AWS X射线调试AWS Lambda函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/debugging-aws-lambda-functions-with-aws-x-ray-ad4dce87a797?source=collection_archive---------0-----------------------#2021-01-18">https://levelup.gitconnected.com/debugging-aws-lambda-functions-with-aws-x-ray-ad4dce87a797?source=collection_archive---------0-----------------------#2021-01-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="is it gq gs iu iv gi gj paragraph-image"><div class="ab gv cl iw"><img src="../Images/8f6c2e18bdb045507091c65f79f2af79.png" data-original-src="https://miro.medium.com/v2/format:webp/1*rU4_FJL9_UEcSLtZpJr0Cg.jpeg"/></div><figcaption class="iz ja gk gi gj jb jc bd b be z dk translated">作者图片</figcaption></figure><div class=""/><p id="4b3f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">AWS X-Ray是一种收集分布式应用程序中正在进行的工作的数据的方法，用于识别性能问题和执行错误。</p><p id="3dfc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当执行错误发生在模糊案例中时，X射线可以通过提供每次执行的综合跟踪来帮助识别这些案例。这在分布式、事件驱动或无服务器应用程序中是非常宝贵的。</p><p id="b3af" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">AWS X射线集成了</p><ul class=""><li id="4b98" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">亚马逊弹性计算云(亚马逊EC2)；</li><li id="b7f3" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">亚马逊弹性容器服务(亚马逊ECS)；</li><li id="410c" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">弹性负载平衡；</li><li id="9eda" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">亚马逊API网关；</li><li id="8695" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">AWS Lambda而且，</li><li id="5f16" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">AWS弹性豆茎。</li></ul><p id="3233" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">此外，AWS X-Ray SDK可以捕获元数据并请求</p><ul class=""><li id="3738" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">MySQL和PostgreSQL数据库(自托管、亚马逊RDS、亚马逊Aurora)；</li><li id="a028" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">亚马逊DynamoDB</li><li id="3952" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">亚马逊简单队列服务；而且，</li><li id="ace1" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">亚马逊简单通知服务。</li></ul><p id="dbf8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">SDK可用于Java、Go、Node.js、Python、Ruby和。网络语言。</p><p id="0514" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当使用AWS Lambda时，我们唯一能看到的是当我们的Lambda函数运行时，在我们的CloudWatch日志中写了什么。然而，当我们看不到API Gateway、Lambda和其他函数或服务之间发生了什么时，解决函数的问题可能是一个挑战。通过用X射线检测Lambda函数及其相关服务，我们提高了用函数解决问题的能力。</p><p id="cae5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">本文将讨论如何使用AWS X射线跟踪Lambda函数。使用Python作为Lambda函数语言，可以在GitHub上获得本示例中使用的文件。</p><h2 id="7c2b" class="lo lp jf bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">我们简单的Lambda函数</h2><p id="8c6a" class="pw-post-body-paragraph kc kd jf ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz in bi translated">为了说明我们将如何启用X射线跟踪，我将使用一个无服务器应用程序模型(SAM)应用程序，它具有HTTP API网关、Step函数和几个Lambda函数。</p><p id="5865" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">该模板构建了这种架构:</p><figure class="mm mn mo mp gu iv gi gj paragraph-image"><div class="ab gv cl iw"><img src="../Images/615044c199567462f555f744139a22fd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*95EBAdCCvOSQkEq1uJrwzQ.png"/></div><figcaption class="iz ja gk gi gj jb jc bd b be z dk translated">示例架构</figcaption></figure><p id="d946" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">到API网关的连接启动状态机，状态机反过来执行Lambda函数。这是异步执行。焦点在于实现X射线，尽管同样的方法也可以用于同步状态机。</p><blockquote class="mq mr ms"><p id="95a8" class="kc kd mt ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz in bi translated">当API Gateway启动异步状态机时，返回给用户的输出是状态机执行细节。对于同步状态机，我们必须等到执行完成后才能将数据返回给用户。对于长时间运行的工作流，延迟用户响应可能会导致用户怀疑请求会失败。</p></blockquote><p id="b87e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在我们的状态机和函数执行之后，我们必须查看API网关日志、状态机执行日志和每个Lambda函数的日志。这可能很耗时，而且容易出错。例如，在部署SAM模板并执行</p><p id="324b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe mx my mz na b">curl -X POST api-endpoint</code></p><p id="d2de" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们有一个用于API网关、状态机和每个Lambda函数的CloudWatch日志文件。如果状态机不执行，我们必须查看状态机日志文件，然后查看一个或多个Lambda函数日志。</p><p id="f99d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果应用程序成功执行，但花费的时间比预期的长，那么找出执行延迟的唯一方法就是向Lambda函数添加多个日志语句，然后检查每个日志文件。有更好的方法。</p><h2 id="e7a6" class="lo lp jf bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">添加X射线</h2><p id="7982" class="pw-post-body-paragraph kc kd jf ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz in bi translated">为每个应用程序组件启用X射线使我们能够获得每个应用程序执行的完整视图。我们可以看到每个组件的调用和处理时间，以及过程中是否有错误或执行失败。</p><p id="62a1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">要在我们的应用中启用X射线，我们必须:</p><ul class=""><li id="d4d3" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">在模板中添加对API网关的跟踪；</li><li id="972c" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">向模板中的步骤函数添加跟踪；</li><li id="98ec" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">向模板中的每个Lambda函数添加跟踪；</li><li id="d3c7" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">调整授予AWS X射线访问权限的IAM角色；</li><li id="f08d" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">将AWS X-Ray SDK包含到Lambda部署包中；而且，</li><li id="6d06" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">重新部署模板。</li></ul><p id="012f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">(为了方便示例，使用了不同的模板文件。)</p><p id="aad9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">要在API网关REST API上启用跟踪，只需添加</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="6828" class="lo lp jf na b gz nf ng l nh ni">TracingEnabled: true</span></pre><p id="686a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">到SAM模板中的API网关定义。</p><p id="b3e8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">示例GitHub项目使用HTTP API，它不支持TracingEnabled指令。因此，如果您使用HTTP API网关，那么与X射线的集成目前是不可用的。</p><p id="2be6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在状态机上，启用跟踪将如下所示:</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="397d" class="lo lp jf na b gz nf ng l nh ni">StateMachine:<br/>    Type: AWS::Serverless::StateMachine<br/>    Properties:<br/>      Type: STANDARD<br/>      Logging:<br/>        Destinations:<br/>         - CloudWatchLogsLogGroup:<br/>             LogGroupArn: !GetAtt StateMachineLogGroup.Arn<br/>        Level: ALL<br/>      DefinitionUri: statemachine/asl.json<br/>      Role: !GetAtt StateMachineExecutionRole.Arn<br/>      Tracing:<br/>        Enabled: true<br/>      DefinitionSubstitutions:<br/>        SelectPairFunctionArn: !GetAtt SelectPair.Arn<br/>        VerifyPairFunctionArn: !GetAtt VerifyPair.Arn<br/>        SavePairFunctionArn: !GetAtt SavePair.Arn<br/>        NotifyPairFunctionArn: !GetAtt NotifyPair.Arn</span></pre><p id="1ea5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在Lambda函数中，我们的云信息资源是</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="9eae" class="lo lp jf na b gz nf ng l nh ni">SelectPair:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      CodeUri: functions/poc-select-pair/<br/>      Handler: app.lambda_handler<br/>      Runtime: python3.7<br/>      Role: !GetAtt LambdaExecutionRole.Arn<br/>      Tracing: Active</span></pre><p id="50ef" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">AWS有几个AWS管理的IAM政策，允许访问X射线。您可以为Lambda、状态机和API网关角色选择其中之一，或者创建自己的角色来为服务提供最小特权。必须更新组件的IAM角色，以包括适当的X射线IAM策略。</p><p id="956b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有两种方法可以将AWS X-Ray SDK包含到Lambda函数部署包中。第一个是将SDK包含到每个Lambda函数中，这增加了每个部署包的大小，并导致SDK的多个副本被上传。第二种，也是首选的，是使用Lambda层，在调用每个Lambda函数时将SDK包含到其中。(有关Lambda层的更多信息，请参见<!-- -->文档</p><p id="2a46" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">通过在模板中添加Lambda层，我们可以将该层添加到每个Lambda函数中(如果需要，可以有选择地添加)。我们甚至不需要对Lambda函数做任何修改，就可以让X-Ray提供关于其操作的细节。添加层就像在模板中定义它一样简单:</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="d934" class="lo lp jf na b gz nf ng l nh ni">xray:<br/>    Type: AWS::Serverless::LayerVersion<br/>    Properties:<br/>      LayerName: aws-xray-sdk<br/>      Description: Dependencies for the blank sample app.<br/>      ContentUri: aws_xray_sdk/.<br/>      CompatibleRuntimes:<br/>        - python3.7<br/>        - python3.8</span></pre><p id="8f3d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后调整Lambda函数以包含该层。</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="f494" class="lo lp jf na b gz nf ng l nh ni">SelectPair:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      CodeUri: functions/poc-select-pair/<br/>      Handler: app.lambda_handler<br/>      Runtime: python3.7<br/>      Role: !GetAtt LambdaExecutionRole.Arn<br/>      Tracing: Active<br/>      Layers:<br/>        - !Ref xray</span></pre><p id="b442" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">请注意函数定义中的跟踪和层声明。这些命令指示Lambda用函数加载命名层，并启用X射线跟踪。</p><blockquote class="mq mr ms"><p id="949b" class="kc kd mt ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz in bi translated">这里的记录了如何正确构建图层。如果您希望在许多项目中使用同一个图层，最好是单独创建它，然后简单地使用图层ARN将其包含在函数中。</p></blockquote><p id="59df" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一旦我们部署了支持X射线的更改，我们就可以对端点执行curl命令，然后在AWS X射线控制台中查看结果。</p><p id="aee2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在AWS X射线控制台中，我们可以看到状态机的源图。</p><figure class="mm mn mo mp gu iv gi gj paragraph-image"><div class="ab gv cl iw"><img src="../Images/bb4db5fd563182262ae47c1c34ab8f93.png" data-original-src="https://miro.medium.com/v2/format:webp/1*XhGMoKCpay57Ikh9ytR2dg.jpeg"/></div><figcaption class="iz ja gk gi gj jb jc bd b be z dk translated">x射线源图</figcaption></figure><p id="7a32" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这个视图向我们展示了成功执行的每个步骤，因为它们周围都有一个绿色的环。阻止执行的代码错误，显示为红色或黄色圆圈。如果您有许多要跟踪的执行，根据执行的执行状态，可能会有绿色、黄色和红色的混合。如果我们从状态机的角度看，我们会看到</p><figure class="mm mn mo mp gu iv gi gj paragraph-image"><div class="ab gv cl iw"><img src="../Images/d4ccfe8f7aa25c441fa614fbb19e2fc9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*YbErDQhVkiG8Hlv-NsKNFg.png"/></div><figcaption class="iz ja gk gi gj jb jc bd b be z dk translated">状态机视图</figcaption></figure><p id="7f60" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以看到状态机成功执行。然而，这并不意味着没有发生错误。例如，如果状态机决定采取一个Lambda功能状态代码为200的动作，并对状态代码为500的动作采取不同的动作，则选择将成功完成，并在状态机中显示“绿色”,除非收到不同的状态代码。</p><p id="2a72" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">时间轴视图也很有趣。</p><figure class="mm mn mo mp gu iv gi gj paragraph-image"><div class="ab gv cl iw"><img src="../Images/d72ffc1696f3751d9baf2f04def238bc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*x0n4wP0DCsrUSjqoDX5UeA.jpeg"/></div><figcaption class="iz ja gk gi gj jb jc bd b be z dk translated">x射线时间线视图</figcaption></figure><p id="5f8e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在这个视图中，我们可以看到函数初始化和执行需要多长时间。因为我们已经为X射线跟踪配置了状态机和所有Lambda函数，所以显示了整个序列。</p><h2 id="a8b1" class="lo lp jf bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">潜得更深</h2><p id="47e0" class="pw-post-body-paragraph kc kd jf ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz in bi translated">到目前为止，我们还没有对基于Python的Lambda函数进行任何修改，以便在AWS X-Ray中显示一些数据。这是pos-select-pair/app.py函数，我们将在本文的下一部分使用它。</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="a10e" class="lo lp jf na b gz nf ng l nh ni">import json<br/>import random<br/><br/>def lambda_handler(event, context):<br/><br/>    friends = [<br/>        "Pei Pacetti", "Sung Spears", <br/>        "Ashlee Alderson", "Aimee Acker",<br/>        "Keneth Koehler", "Joseph Julio", <br/>        "Vida Vickrey", "Isaac Iannuzzi",<br/>        "Janey Jeske", "Oralia Ostendorf"<br/>    ]<br/><br/>    print("start")<br/>    first = choose(Friends=friends, Chosen=None)<br/>    second = choose(Friends=friends, Chosen=first)<br/><br/>    return {"statusCode": 200, "body": {"first": first, "second": second}}<br/><br/>def choose(**kwargs):<br/>    friends = kwargs.get('Friends', None)<br/>    chosen = kwargs.get('Chosen', None)<br/><br/>    # Select a random number from 0 to size of list<br/><br/>    random.seed()<br/>    while True:<br/>        number = random.randint(0, len(friends))<br/>        print(f"number = {number}/{len(friends)} friend = {friends[number]}")<br/><br/>        if chosen != friends[number]:<br/>            return friends[number]</span></pre><p id="6e84" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">没有任何进一步的努力来调整代码，我们可以开始问这样的问题“时间都花在哪里了？”、“如何才能降低开销？”、“怎么才能加快功能？”等。</p><p id="2f79" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有时，我们可能需要更多地了解在一个更大的函数中正在发生的事情。这是通过将SDK直接导入Lambda函数并与xray_recorder交互以将函数划分为段和子段来实现的，因此我们可以使用注释和元数据在跟踪中提供额外的细节。</p><p id="d0b1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">将X射线与Lambda一起使用时，X射线会自动为lambda_handler创建一个段。<em class="mt">段</em>包含关于用于执行应用程序逻辑的计算资源的信息，比如资源名称、请求细节和完成的工作。</p><p id="8c9b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><em class="mt"> Subsegments </em>允许我们进一步分解细节，以包含关于到其他资源(如数据库、HTTP APIs和其他AWS服务)的下游连接的信息。子段提供了更细粒度的计时信息和应用程序为完成原始请求而进行的下游调用的详细信息。</p><p id="2c82" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在更大的函数中，我们可能有兴趣了解特定部分是如何执行的。我们对这些代码块使用子段。这使得我们的函数看起来像:</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="fd8d" class="lo lp jf na b gz nf ng l nh ni">segment = xray_recorder.begin_subsegment('choose-1')<br/>first = choose(Friends=friends, Chosen=None)<br/>xray_recorder.end_segment()<br/><br/>segment = xray_recorder.begin_subsegment('choose-2')<br/>second = choose(Friends=friends, Chosen=first)<br/>xray_recorder.end_segment()</span></pre><p id="2a13" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">使用这种方法，我们可以很容易地看到特定的代码是如何在我们的函数中工作的。我们还可以检测函数，而不必实现增强/子段关系。通过在每个函数上使用@xray_recorder装饰器，我们可以获得这些函数的单独跟踪信息。</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="30f6" class="lo lp jf na b gz nf ng l nh ni">import json<br/>import random<br/>from aws_xray_sdk.core import xray_recorder<br/><br/>def lambda_handler(event, context):<br/><br/>    friends = [<br/>        "Pei Pacetti", "Sung Spears", <br/>        "Ashlee Alderson", "Aimee Acker",<br/>        "Keneth Koehler", "Joseph Julio", <br/>        "Vida Vickrey", "Isaac Iannuzzi",<br/>        "Janey Jeske", "Oralia Ostendorf"<br/>    ]<br/>    <br/>    print("start")<br/>    first = choose(Friends=friends, Chosen=None)<br/>    second = choose(Friends=friends, Chosen=first)<br/><br/>    return {"statusCode": 200, "body": {"first": first, "second": second}}<br/><br/><br/>@xray_recorder.capture("choose")<br/>def choose(**kwargs):<br/>    friends = kwargs.get('Friends', None)<br/>    chosen = kwargs.get('Chosen', None)<br/><br/>    # Select a random number from 0 to size of list<br/><br/>    random.seed()<br/>    while True:<br/>        number = random.randint(0, len(friends))<br/>        print(f"number = {number}/{len(friends)} friend = {friends[number]}")<br/><br/>        if chosen != friends[number]:<br/>            return friends[number]</span></pre><p id="d9b8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因为X-Ray自动为Lambda函数创建根段，所以除了导入X-Ray SDK之外，我们不需要做任何额外的更改。</p><p id="6558" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当我们查看X射线控制台时，我们可以看到我们的<em class="mt">选择</em>功能已经被执行了两次，这是正确的，我们可以看到它在时间线中的什么位置被执行以及执行了多长时间。这是手动创建上述分段和子分段的替代方法，由于X射线和Lambda之间的紧密集成，Lambda函数不经常需要手动创建分段和子分段。</p><p id="d81e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">AWS X-Ray SDK文档中提供了关于这些特定功能的更多信息。</p><h2 id="6c45" class="lo lp jf bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">使用PyTest实现</h2><p id="d4c8" class="pw-post-body-paragraph kc kd jf ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz in bi translated">如果您使用PyTest对您的函数执行单元测试，您可能会注意到测试失败:</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="e9dc" class="lo lp jf na b gz nf ng l nh ni">$ pytest -v<br/>====================================== test session starts =======================================<br/>platform linux -- Python 3.7.3, pytest-6.2.1, py-1.10.0, pluggy-0.13.1 -- /usr/bin/python3<br/>cachedir: .pytest_cache<br/>rootdir: /home/pi/code/aws-xray-sample<br/>plugins: apiritif-0.9.5<br/>collected 1 item                                                                                 <br/><br/>tests/test_select.py::test_select FAILED                                                   [100%]<br/><br/>============================================ FAILURES ============================================<br/>__________________________________________ test_select ___________________________________________<br/><br/>    def test_select():<br/>    <br/>&gt;       data = app.lambda_handler({}, "")<br/><br/>tests/test_select.py:6: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>functions/poc_select_pair/app.py:14: in lambda_handler<br/>    first = choose(Friends=friends, Chosen=None)<br/>/usr/local/lib/python3.7/dist-packages/aws_xray_sdk/core/models/subsegment.py:58: in __call__<br/>    meta_processor=None,<br/>/usr/local/lib/python3.7/dist-packages/aws_xray_sdk/core/recorder.py:428: in record_subsegment<br/>    subsegment = self.begin_subsegment(name, namespace)<br/>/usr/local/lib/python3.7/dist-packages/aws_xray_sdk/core/recorder.py:292: in begin_subsegment<br/>    segment = self.current_segment()<br/>/usr/local/lib/python3.7/dist-packages/aws_xray_sdk/core/recorder.py:270: in current_segment<br/>    entity = self.get_trace_entity()<br/>/usr/local/lib/python3.7/dist-packages/aws_xray_sdk/core/recorder.py:390: in get_trace_entity<br/>    return self.context.get_trace_entity()<br/>/usr/local/lib/python3.7/dist-packages/aws_xray_sdk/core/context.py:99: in get_trace_entity<br/>    return self.handle_context_missing()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aws_xray_sdk.core.context.Context object at 0xb2f23250&gt;<br/><br/>    def handle_context_missing(self):<br/>        """<br/>        Called whenever there is no trace entity to access or mutate.<br/>        """<br/>        if self.context_missing == 'RUNTIME_ERROR':<br/>            log.error(MISSING_SEGMENT_MSG)<br/>&gt;           raise SegmentNotFoundException(MISSING_SEGMENT_MSG)<br/>E           aws_xray_sdk.core.exceptions.exceptions.SegmentNotFoundException: cannot find the current segment/subsegment, please make sure you have a segment open<br/><br/>/usr/local/lib/python3.7/dist-packages/aws_xray_sdk/core/context.py:124: SegmentNotFoundException<br/>-------------------------------------- Captured stdout call --------------------------------------<br/>start<br/>--------------------------------------- Captured log call ----------------------------------------<br/>ERROR    aws_xray_sdk.core.context:context.py:123 cannot find the current segment/subsegment, please make sure you have a segment open<br/>==================================== short test summary info =====================================<br/>FAILED tests/test_select.py::test_select - aws_xray_sdk.core.exceptions.exceptions.SegmentNotFo...<br/>======================================= 1 failed in 5.56s ========================================<br/>$</span></pre><p id="2fdf" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">从所有这些信息中，我们只关心一行:</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="10cd" class="lo lp jf na b gz nf ng l nh ni">ERROR    aws_xray_sdk.core.context:context.py:123 cannot find the current segment/subsegment, please make sure you have a segment open</span></pre><p id="b155" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">出现这个错误是因为我们构建了在AWS Lambda环境中执行的代码，而X-Ray为处理程序创建了根段。但是，当使用Pytest运行代码时，没有顶级段。</p><p id="3d7a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以通过调整我们的测试脚本来导入X-Ray SDK并创建顶部片段来解决这个问题。</p><pre class="mm mn mo mp gu nb na nc nd aw ne bi"><span id="9060" class="lo lp jf na b gz nf ng l nh ni">from functions.poc_select_pair import app<br/>import datetime<br/>from aws_xray_sdk.core import xray_recorder<br/><br/>def test_select():<br/><br/>    # Start a segment<br/>    segment = xray_recorder.begin_segment('test-select-pair')<br/>    data = app.lambda_handler({}, "")<br/>    # End a segment<br/>    xray_recorder.end_segment()<br/><br/>    assert "statusCode" in data<br/><br/>    assert data["statusCode"] == 200</span></pre><p id="7526" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">添加<code class="fe mx my mz na b">segment = xray_recorder.begin_segment('test-select-pair')</code>行是我们成功执行测试所需要做的全部工作，或者至少是因为其他原因而失败。</p><h2 id="1249" class="lo lp jf bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">结论</h2><p id="ff43" class="pw-post-body-paragraph kc kd jf ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz in bi translated">不需要太多额外的努力，我们就可以提供关于单个Lambda函数或一组函数的执行的额外工具，就像这里看到的那样。查看一个Lambda函数，如poc-save-db/app.py，我们可以看到代码中没有任何内容专门引用AWS X-Ray。这意味着您可以轻松地用现有的Lambda函数实现X射线，而无需修改代码。</p><p id="c78f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果要实现额外的跟踪元素，比如注释和元数据，可能需要内置逻辑来处理没有为函数启用跟踪的情况。</p><p id="a3ab" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这里的例子有些做作，但是在查看X射线数据时，我们可以看到Lambda的大部分时间都花在了调用函数上。</p><blockquote class="mq mr ms"><p id="a37f" class="kc kd mt ke b kf kg kh ki kj kk kl km mu ko kp kq mv ks kt ku mw kw kx ky kz in bi translated">小心不要把Lambda函数做得太小。</p></blockquote><p id="4f79" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">由此得出的一个结论是，如果函数太小，最好将函数合并到相关代码中，以减少执行任务的开销。在本例中，准备函数花费了340 ms，执行时间为2 ms。</p><p id="b19a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">整个状态机的总执行时间是1秒多一点，但是如果在一个大的状态机中有许多小函数，调用函数的时间比执行函数的时间多，那么整体性能就不会令人满意。</p><p id="e6a6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果没有AWS X-Ray提供的洞察力，我们可能会疑惑为什么执行功能和完成工作需要这么长时间。在本例中，最好将几个较小的函数组合起来，以减少总的调用时间。这可能会使组合函数变得复杂，但有时稍微复杂一点可能会比Lambda函数和状态机的性能更好。</p><h2 id="476c" class="lo lp jf bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">参考</h2><p id="d908" class="pw-post-body-paragraph kc kd jf ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz in bi translated"><a class="ae nj" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank">AWSλ</a></p><p id="92d3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><a class="ae nj" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html" rel="noopener ugc nofollow" target="_blank"> AWS Lambda图层</a></p><p id="dc92" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><a class="ae nj" href="https://aws.amazon.com/step-functions/?step-functions.sort-by=item.additionalFields.postDateTime&amp;step-functions.sort-order=desc" rel="noopener ugc nofollow" target="_blank"> AWS步进功能</a></p><p id="dca8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><a class="ae nj" href="https://aws.amazon.com/xray/" rel="noopener ugc nofollow" target="_blank"> AWS X射线</a></p><p id="fc60" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><a class="ae nj" href="https://aws.amazon.com/blogs/compute/using-lambda-layers-to-simplify-your-development-process/" rel="noopener ugc nofollow" target="_blank">建立λ层</a></p><p id="705a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><a class="ae nj" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank">无服务器应用模型</a></p><h2 id="e2d3" class="lo lp jf bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">关于作者</h2><p id="f7a6" class="pw-post-body-paragraph kc kd jf ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz in bi translated">Chris是一名高度熟练的信息技术、AWS云、培训和安全专家，他在云、安全、培训和流程工程方面处于领先地位，能够简化和交付高质量的产品。他是七本书的合著者，在技术、管理和信息安全出版物上发表了70多篇文章和书籍章节。他丰富的技术、信息安全和培训经验使他成为帮助公司应对技术挑战的关键资源。Chris是AWS社区构建者计划的成员。</p><h2 id="88b8" class="lo lp jf bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">版权</h2><p id="34a0" class="pw-post-body-paragraph kc kd jf ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz in bi translated">本文版权2021，Chris Hare。</p></div></div>    
</body>
</html>