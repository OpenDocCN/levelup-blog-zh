<html>
<head>
<title>How To Randomly Split Up Elements From a Stream of Data By Percentage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何按百分比随机分割数据流中的元素</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-randomly-split-up-elements-from-a-stream-of-data-by-percentage-81434d040e50?source=collection_archive---------13-----------------------#2020-03-11">https://levelup.gitconnected.com/how-to-randomly-split-up-elements-from-a-stream-of-data-by-percentage-81434d040e50?source=collection_archive---------13-----------------------#2020-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e430dcfdc4ce208595f48adf8413eea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W7oTHOUTUQoxX9sQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="kc">最初发表于</em><a class="ae kd" href="https://edward-huang.com/scala/algorithm/software-development/programming/tech/2020/03/10/how-to-randomly-split-up-an-elements-from-a-stream-of-data-in-percentage/" rel="noopener ugc nofollow" target="_blank"><em class="kc">【https://edward-huang.com】</em></a><em class="kc">。</em></figcaption></figure><p id="c246" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">几周前，我被分配到一个需要创建规则引擎的项目中。规则引擎具有一个功能，即用户能够创建一个配置来分配特定的规则，以获得输入有效负载的百分比。例如，用户可以指定规则A接收20%的有效负载，规则B接收40%的有效负载，规则C接收40%的有效负载。</p><p id="a614" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">你已经在很多A/B测试框架中看到过。您将系统配置为接收40%的用户流量来呈现文本A，而接收60%的用户流量来呈现文本b。</p><p id="775b" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">您还看到了在“智能”负载平衡分配算法中发生的情况，您可以自动将20%配置给服务器A，30%配置给服务器B，50%配置给服务器c。</p><p id="dbfa" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在不知道即将到来的数据量的情况下，这些A/B测试框架和负载平衡器如何分配特性？</p><p id="d3c2" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这篇文章中，我想分享一下我是如何解决这个问题的，我希望我的回答也能让其他遇到同样问题的人受益。</p><p id="3e2b" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">首先，我搜索了所有关于流算法的相关文章。然而，那些流算法最终具有大量统计分析且实现起来非常复杂。</p><p id="c76e" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">传入的有效载荷不需要精确。它需要在每次分配中得到一个估计的百分比数。所以，经过研究，我总结了两个解决方案。</p><h1 id="3010" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">掷骰子</h1><p id="c4da" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">掷骰子解决方案是基于随机生成器来选择哪个部分来分配来自流的元素。</p><p id="d768" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">想象一下，如果你有70-30的机会把进来的元素分配给A或b。</p><p id="8146" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当你收到进来的元素时掷骰子。如果骰子数在1到4.2之间，将值赋给a。如果骰子数在4.3到6之间，将值赋给b。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="b23d" class="mo ld iq mk b gy mp mq l mr ms">import scala.util.Random<br/><br/>var A = 0 <em class="mt">// 20%<br/></em>var B = 0 <em class="mt">// 30%<br/></em>var C = 0 <em class="mt">// 50%<br/></em><br/><br/><br/>(1 to 100000).foreach{ _ =&gt;<br/>  val random = new Random().nextInt(100)<br/>  if(random &lt; 20) {<br/>    A += 1<br/>  } else if(random &gt;= 20 &amp;&amp; random &lt;50) {<br/>    B += 1<br/>  } else {<br/>    C += 1<br/>  }<br/>}<br/><br/>println(s"${A}  ${B} ${C}")</span></pre><p id="c8c3" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这种方法的优点之一是易于实现。</p><p id="00e8" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">接收元素时运行随机生成器。如果结果在0到60之间，分配给a。如果结果在70到99之间，分配给b。</p><p id="70a4" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果你反复运行上面的函数，你会发现粗略估计的数量是20–30–50。</p><p id="fe85" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">但是，如果应用程序没有大量数据要消耗，使用随机生成器来拆分元素可能会导致A和b的数据消耗不成比例。</p><p id="b73a" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果只有100个传入数据，使用掷骰子可能会导致20%的数据传到A，80%的数据传到b。</p><p id="b31e" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">由于赋值是估计的，我们可以从<a class="ae kd" href="https://en.wikipedia.org/wiki/Law_of_large_numbers" rel="noopener ugc nofollow" target="_blank">大数定律</a>中确定该算法接近精确。</p><h1 id="deb2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">缓冲溶液</h1><p id="6b43" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">另一种解决方案是使用缓存来存放传入的元素，直到它达到一个固定的数目。当缓存达到固定数量时，根据百分比将数据集分配到A和B中。</p><p id="4924" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我称之为缓冲解决方案——它就像缓冲一样，在将所有字节刷新到输出流之前，它会一直等待，直到达到传入的字节数，然后一次性将它们全部赋值。</p><p id="4433" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">想象一下上面的例子，你需要分配70%的流量给A，30%给b。</p><p id="9a12" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">使用缓冲区解决方案，您可以创建一个存储1000个传入数据流的缓存。一旦缓存达到1000个传入数据，将该传入数据的70%分配给A，30%分配给b。然后，通过让缓存数据通过来清除。在缓存中检索接下来的1000个数据。</p><p id="d2f2" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">该解决方案解决了掷骰子解决方案的问题，其中数据可能分布不均匀。然而，缓冲解决方案更难实现和维护。您需要在系统中引入缓存功能，并在以后维护状态。由于系统中涉及额外的IO，系统的性能也可能受到影响。</p><p id="b49d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这两个方案是我在网上无数次调研，看了一些白皮书后提出的方案。然而，当它偏离期望状态时，可以通过创建更精确的概率来优化该解决方案。</p><p id="fec6" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果您有任何其他建议的解决方案或如何解决这个问题，请在下面分享您的解决方案。</p><h1 id="fa6d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">来源</h1><p id="8f44" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated"><a class="ae kd" href="https://stackoverflow.com/questions/57482822/randomly-split-up-elements-from-a-stream-of-data-without-knowing-the-total-numbe" rel="noopener ugc nofollow" target="_blank">JavaScript——在不知道元素总数的情况下从数据流中随机拆分元素——堆栈溢出</a></p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="b934" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="kg ir">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯，每周都会收到关于科技职业的文章、有趣的链接和内容。</strong></p><p id="0e13" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">你可以关注我，也可以在<a class="ae kd" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上关注我，以获得更多类似的帖子。</p></div></div>    
</body>
</html>