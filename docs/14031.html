<html>
<head>
<title>Vuejs 3: Migrating from Options to Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vuejs 3:从选项迁移到组合API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vuejs-3-migrating-from-options-to-composition-api-e8a765e57b8d?source=collection_archive---------0-----------------------#2022-10-26">https://levelup.gitconnected.com/vuejs-3-migrating-from-options-to-composition-api-e8a765e57b8d?source=collection_archive---------0-----------------------#2022-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="be8d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">轻松切换到组合API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/47491c8e86f223b580888ddfc970fbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nB3t8AU7PPuBUFcy"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jupp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳森·肯珀</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组合API是在Vue 3中引入的，是在Vuejs 3中开发应用程序的新推荐模式。我们仍然可以一起使用选项和组合API，享受这两种模式的美妙之处。</p><p id="4f57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用Vuejs已经有一段时间了，那么你很有可能熟悉Options API。options API是用于组织和编码Vuejs 2应用程序的默认标准模式。</p><p id="03f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引入Composition API是为了解决options API带来的一些限制。它还解决了mixin(Options API的主要逻辑重用机制)的缺点。</p><p id="7813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Composition API的一些显著优势包括:</p><ul class=""><li id="5091" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">更小的线束尺寸和更高的性能。</li><li id="ec33" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">更容易重用组件逻辑。</li><li id="88eb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">改进的类型脚本支持。</li><li id="e65e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">更容易的应用维护。</li></ul><p id="1a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下从Options API到新的Composition API的变化。</p><h2 id="3a5a" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">选项API &amp;组合API结构</strong></h2><p id="e94a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">选项和组合API逻辑结构的图示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/9d7726a570c7da5d52be65a0eb8ee893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QpBrPVr7sTsIY_ocShru1g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自lenguajejs.com</figcaption></figure><p id="dbf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在本文中讨论部分内容包括:</p><ul class=""><li id="4254" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">组件设置方法。</li><li id="9a60" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">道具(定义&amp;传球道具)。</li><li id="ea82" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">事件(声明和发出事件)。</li><li id="5522" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模板参照(访问子元件属性)。</li><li id="fc14" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">反应性(参考和反应性原料药)。</li><li id="5cab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">生命周期挂钩(选项/组合)</li></ul><h2 id="5dec" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">组合API设置方法</strong></h2><p id="ad35" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">组合API逻辑是在设置函数中编写的。这是我们所有组件的逻辑所在之处。</p><p id="9eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">组件基础知识</strong></p><p id="8dea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件使得分离应用程序逻辑、UI关注点变得更加容易，同时保持应用程序的可重用性。在Vue 2中，我们必须在使用它们之前导入并注册组件，如下所示。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2f7d" class="mj mk it nj b gy nn no l np nq">&lt;script&gt;<br/>import { defineAsyncComponent} from "vue";</span><span id="be0d" class="mj mk it nj b gy nr no l np nq">//import footer component<br/>const Footer = defineAsyncComponent(() =&gt;<br/>  import(/*webpackChunkName: "Footer"*/ "@/components/Footer")<br/>);</span><span id="81fc" class="mj mk it nj b gy nr no l np nq">export default {<br/>  name: "App",<br/>  components: {<br/>  //Register the component here    <br/>  Footer,<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="356f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vue 3引入了全局和自动组件导入。我们只需要导入组件，Vue就会自动为我们注册组件。类似地，您可以将组件声明为<strong class="lb iu"> <em class="ns">全局</em> </strong>以在整个应用程序中重用它们，而无需默认导入。</p><p id="9e5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">全局组件注册</strong></p><p id="5a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过导入并注入到<code class="fe nt nu nv nj b">main.js</code>的应用入口文件中来注册全局组件，如下图所示。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="f4e3" class="mj mk it nj b gy nn no l np nq">import GlobalComponent from '@/components/GlobalComponent'</span><span id="b6c7" class="mj mk it nj b gy nr no l np nq">const app = createApp({})</span><span id="e31c" class="mj mk it nj b gy nr no l np nq">app.component('global-component-name', GlobalComponent)</span></pre><p id="feb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在应用程序的任何地方使用<code class="fe nt nu nv nj b">global-component-name</code>。Vuejs 3修正了API引入的限制选项，同时使我们的组件结构变得简单、清晰、易于理解。</p><h2 id="0940" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">组合API中的反应性</h2><p id="2fb3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在任何消耗和处理数据的应用程序中，状态反应都是非常重要的。在组合API中，我们有两个主要的API函数(<code class="fe nt nu nv nj b">refs</code>和<code class="fe nt nu nv nj b">reactive</code>)用于处理状态反应。虽然它们有所不同，但由于reactive的一些限制，我们还是广泛推荐使用<code class="fe nt nu nv nj b">refs</code>。</p><p id="cfba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">无功</strong></p><p id="5503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应式API函数可用于创建对象、数组和集合类型(如集合和映射)的反应式状态。若要声明反应状态，请将对象或数组作为参数传递给反应函数。我们还可以使用模板语法将反应状态变量呈现给DOM。</p><p id="b4a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要访问反应状态，您需要一个对状态的引用，如下所示。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0184" class="mj mk it nj b gy nn no l np nq">&lt;script setup lang="ts"&gt;<br/>import { reactive } from 'vue'</span><span id="0350" class="mj mk it nj b gy nr no l np nq">//declaring reactive state<br/>const state = reactive({ version: `Vuejs 2`})</span><span id="1b78" class="mj mk it nj b gy nr no l np nq">//accessing reactive state<br/>state.version</span><span id="4c4d" class="mj mk it nj b gy nr no l np nq">//updating reactive state<br/>state.version=`Vuejs 3`</span><span id="eb23" class="mj mk it nj b gy nr no l np nq">&lt;/script&gt;</span><span id="a56a" class="mj mk it nj b gy nr no l np nq">&lt;template&gt;<br/>//rendering state to DOM<br/> &lt;p&gt;{{state.version}}&lt;/p&gt;<br/>&lt;/template&gt;</span></pre><p id="aa42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe nt nu nv nj b">reactive</code> API功能强大，但它也有一些局限性:</p><ul class=""><li id="434b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">当我们通过调用<code class="fe nt nu nv nj b">reactive</code> API函数更新反应状态时，反应状态连接丢失。我们必须始终保持对反应对象的同一个参照。</li><li id="331e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">反应式API不支持字符串、布尔和整数等基本类型。Reactive只能用于声明数组、对象和集合类型。</li></ul><p id="a26c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">Ref</strong>T24】vue js 3 Ref API函数也可以用来声明反应状态。ref函数中传递的状态参数被包装在一个对象中，可以使用<code class="fe nt nu nv nj b">.value</code>属性访问它的值。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7854" class="mj mk it nj b gy nn no l np nq">&lt;script setup lang="ts"&gt;<br/>import { ref} from 'vue'</span><span id="5658" class="mj mk it nj b gy nr no l np nq">//declaring ref state<br/>const state = refs(false)</span><span id="3a14" class="mj mk it nj b gy nr no l np nq">//accessing ref state<br/>state.value</span><span id="d92b" class="mj mk it nj b gy nr no l np nq">//updating ref state<br/>state.value= true;</span><span id="cb41" class="mj mk it nj b gy nr no l np nq">&lt;/script&gt;</span><span id="adab" class="mj mk it nj b gy nr no l np nq">&lt;template&gt;<br/>//rendering state to DOM<br/> &lt;p&gt;{{state}}&lt;/p&gt;<br/>&lt;/template&gt;</span></pre><h2 id="ab3b" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">生命周期挂钩</strong></h2><p id="c036" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Vuejs 3引入了脚本设置功能。这消除了创建生命周期挂钩的需要。引入了一些组件生命周期挂钩来取代Options API中的挂钩。见下文。</p><p id="70cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nj b">beforeCreate</code>和<code class="fe nt nu nv nj b">created</code>都被设置函数本身取代，我们不需要像使用选项API那样声明它们。您需要从vue导入生命周期挂钩，以便在我们的应用程序中使用它们。</p><p id="2bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">组合API生命周期挂钩的选项</strong></p><p id="2863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命名生命周期挂钩从选项到组合API的变化。</p><p id="08fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nj b">beforeMount</code>-&gt;-<code class="fe nt nu nv nj b">onBeforeMount</code></p><p id="2c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nj b">beforeDestroy</code>-&gt;-<code class="fe nt nu nv nj b">onBeforeUnmount</code></p><p id="d288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nj b">beforeUpdate</code>-&gt;-<code class="fe nt nu nv nj b">onBeforeUpdate</code></p><p id="d614" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nj b">mounted</code> &gt; <code class="fe nt nu nv nj b">onMounted</code></p><p id="fd12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nj b">updated</code>-&gt;-<code class="fe nt nu nv nj b">onUpdated</code></p><p id="c42d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nj b">destroyed</code>-&gt;-<code class="fe nt nu nv nj b">onUnmounted</code></p><h2 id="b385" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">道具和道具定义</strong></h2><p id="5891" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Props允许我们将数据从父组件传递到子组件。虽然我们可以根据需要传递尽可能多的道具数据，但是我们需要小心防止我们的组件被过多的道具所膨胀(道具钻取)。</p><p id="a0c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Composition API中声明道具有点不一样。我们需要使用<strong class="lb iu"> <em class="ns"> defineProps </em> </strong>宏在我们的子组件中注册道具。</p><p id="88f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将道具从父组件传递到子组件，请如下所示传递它们。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="766b" class="mj mk it nj b gy nn no l np nq">&lt;script setup lang="ts"&gt;<br/>import { ref } from 'vue';<br/>import { forums } from '@/config/forums';</span><span id="6e3e" class="mj mk it nj b gy nr no l np nq">import ForumList from '@/components/ForumList.vue';</span><span id="42be" class="mj mk it nj b gy nr no l np nq">&lt;/script&gt;</span><span id="0f89" class="mj mk it nj b gy nr no l np nq">&lt;template&gt;<br/> &lt;article&gt;<br/>  &lt;ForumList v-for="forum in forums" :key="forum.id" :text="forum.content" :bg-image="forum.bg-image" /&gt;<br/> &lt;/article&gt;<br/>&lt;/template&gt;</span></pre><p id="0be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在子组件上，您可以使用<strong class="lb iu"> <em class="ns">定义道具</em> </strong>注册道具，如下所示。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="e6de" class="mj mk it nj b gy nn no l np nq">defineProps({<br/> text: {<br/>  type: String,<br/>  required: true,<br/> },<br/> bgImage: {<br/>  type: String,<br/>  required: true,<br/> },<br/>});</span></pre><p id="0b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者更好的是，我们可以使用<code class="fe nt nu nv nj b">withDefaults</code>宏，它允许我们在基于类型的声明中用默认的props值来声明props</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="38df" class="mj mk it nj b gy nn no l np nq"><br/>withDefaults(<br/>defineProps&lt;{<br/> text: string,<br/> bgImage: string,<br/> }&gt;(),<br/> {<br/>//Declare default values here<br/>text: `Vuejs is awesome`,<br/>}<br/>)</span></pre><h2 id="89b4" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">发射事件</strong></h2><p id="85f0" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">使用Vuejs开发应用程序时，发出事件是非常重要的。它允许我们将动作、方法和属性从子组件传递到父组件。为了在组合API中发出事件，我们使用了<strong class="lb iu"> <em class="ns"> $emit </em> </strong>宏。</p><p id="d84a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">声明发射</strong></p><p id="1aa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了声明发出的事件，我们在子组件脚本设置函数中使用了<code class="fe nt nu nv nj b">defineEmits</code>宏。<code class="fe nt nu nv nj b">defineEmits</code>宏接受一个包含要发出的事件的字符串数组的参数。我们可以在子组件中发出和注册发出的事件，如下所示。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="1174" class="mj mk it nj b gy nn no l np nq">&lt;script setup lang="ts"&gt;</span><span id="7196" class="mj mk it nj b gy nr no l np nq">defineEmits(['close']);</span><span id="0e93" class="mj mk it nj b gy nr no l np nq">&lt;/script&gt;</span><span id="eb6b" class="mj mk it nj b gy nr no l np nq">&lt;template&gt;<br/>&lt;div&gt;<br/>     &lt;button <a class="ae ky" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>="$emit(`close`)"&gt;Cancel&lt;/button&gt;<br/> &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="4984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在父组件中，我们可以监听<code class="fe nt nu nv nj b">close</code>发出的事件，并传递一个方法来处理它。你可以使用<code class="fe nt nu nv nj b">v-on:</code>指令或者使用简写<code class="fe nt nu nv nj b">@name-of-emitted-event</code>。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="9be8" class="mj mk it nj b gy nn no l np nq">&lt;script setup lang="ts"&gt;<br/>import { ref } from 'vue';<br/>import Cancel from '@/components/Cancel.vue';<br/><br/>const cancelPopup = ref(false);</span><span id="fccf" class="mj mk it nj b gy nr no l np nq">&lt;/script&gt;</span><span id="9772" class="mj mk it nj b gy nr no l np nq">&lt;template&gt;<br/>  &lt;div&gt;<br/>   &lt;Cancel <a class="ae ky" href="http://twitter.com/close" rel="noopener ugc nofollow" target="_blank">@close</a>="cancelPopup = true" /&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><h2 id="0edf" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">模板参考</strong></h2><p id="0fe8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Options API中的模板引用使得访问子组件中的方法成为可能。默认情况下，使用Options API或Composition API且没有<strong class="lb iu"> <em class="ns"> &lt;脚本设置&gt; </em> </strong>的Vuejs组件是打开的。由于Vue 2组件的默认开放特性，模板引用使得访问组件属性成为可能。</p><p id="01fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Composition API引入了一种使用<code class="fe nt nu nv nj b">defineExpose</code>宏来公开组件属性的新方法。传递给defineExpose宏的组件属性将是开放的，父组件可以通过模板引用访问这些属性。</p><p id="de67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们希望从子组件中公开<code class="fe nt nu nv nj b">updateBlog</code>方法。请记住，您可以公开任意多的属性，用逗号分隔它们，如下所示。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="72f7" class="mj mk it nj b gy nn no l np nq">defineExpose({ updateBlog, updateDate});</span></pre><p id="0402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">访问暴露的组件属性</strong></p><p id="64b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了访问公开的属性，父组件将使用子组件的模板引用。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="433e" class="mj mk it nj b gy nn no l np nq">&lt;script setup lang="ts"&gt;<br/>import EditBlog from '@/components/EditBlog.vue'</span><span id="23e0" class="mj mk it nj b gy nr no l np nq">import { ref } from 'vue';<br/><br/>const settings = ref();</span><span id="3e23" class="mj mk it nj b gy nr no l np nq">function update() {<br/>  settings.value.updateBlog();<br/><br/>}<br/>&lt;/script&gt;</span><span id="696a" class="mj mk it nj b gy nr no l np nq">&lt;Template&gt;<br/>&lt;div&gt;<br/>&lt;EditBlog<br/>     ref="settings"<br/>     class="mb-4"<br/>/&gt;<br/>&lt;/div&gt;<br/>&lt;/Template&gt;</span></pre><p id="14d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看Vuejs官方文档，了解更多相关信息。</p><h2 id="ae01" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">最终想法</strong></h2><p id="6f0c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">接触过Vuejs 3中的组合API之后，这些是我从默认选项API模式到组合API的显著变化。Vue发生了很大的变化，随着应用程序性能的普遍提高，它变得越来越好。</p><p id="441f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样重要的是要注意，组合API是选项API的替代，两者可以一起使用。Vuejs 3中的选项API支持仍将继续得到支持，不会被取消，因为它仍在维护中。</p><p id="cdcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你使用Composition API的体验如何？到目前为止，你注意到了哪些变化？</p><p id="1885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">偶尔，我会发一封独家邮件，里面有我发现的有用的和与技术写作相关的技巧、文章、应用程序、书籍和想法👇。</p><p id="21be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://artisanal-thinker-2556.ck.page/6e2ba71172" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="ns">加入像你一样想提高写作技巧的人。</em> </strong> </a></p><h2 id="baee" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">更读</strong></h2><div class="nw nx gp gr ny nz"><a href="https://betterprogramming.pub/programming-motivation-how-to-keep-the-coding-dream-alive-97fc56a560ca" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">如何激励自己每天坚持编码</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">在构建编程生涯的充满挑战的旅程中保持专注和坚持</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">better编程. pub</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>