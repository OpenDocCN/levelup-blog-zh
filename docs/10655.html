<html>
<head>
<title>Best OAuth Security Practices for Single Page Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单页应用程序的最佳OAuth安全实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/best-oauth-security-practices-for-single-page-applications-2bb6b44d2890?source=collection_archive---------1-----------------------#2021-12-30">https://levelup.gitconnected.com/best-oauth-security-practices-for-single-page-applications-2bb6b44d2890?source=collection_archive---------1-----------------------#2021-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="50e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们如何在单页面应用程序(SPA)中保证OAuth流的安全？在本文中，让我们了解在开发单页面应用程序(SPA)时可能存在的潜在威胁，以及在SPA中实现OAuth 2.0的最佳安全实践。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/45b69ef47ed63ef346cc93bda9698a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*meHsOI3remnO3OredBbljQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@euwars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法扎德·纳兹菲</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="1ea0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">spa的共同特征OAuth视角下的spa</h1><p id="d9c0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先，让我们看看在水疗中心做OAuth时的共同特征。</p><ul class=""><li id="5455" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">公共客户端<br/> SPA在浏览器中运行，而浏览器并不是存储证书信息(如客户端机密)的好地方。如果你把你的客户端密码或API密匙放入Javascript应用程序，任何人都可以点击查看源代码并看到你的密匙。因此，OAuth将SPA视为公共客户。</li><li id="d134" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">存储API不安全/不灵活<br/>即使SPA可以接收凭据信息，SPA也没有合适的方法来存储它。当存储访问令牌或刷新令牌时，这也是SPA的一个问题。Javascript代码可以访问的任何地方都存在潜在的跨站点脚本(XSS)漏洞。SPA只能访问几个存储API，即Cookie、LocalStorage和SessionStorage。如果您的Javascript代码可以访问这些，那么攻击者也有可能访问这些。</li><li id="a6ef" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">令牌生命周期通常较短<br/>由于浏览器环境的上述风险，OAuth服务器通常对SPA有更严格的策略，如更短的令牌生命周期，刷新令牌可能被禁用或只能使用一次。因此，用户必须不时地再次进行身份验证，有几种方法可以减少这种情况，比如使用隐藏的iframe，向授权服务器发送请求<code class="fe mw mx my mz b">prompt=none</code>来检查用户的会话。然而，随着浏览器最近的变化，这些变通办法不再有效。我们将在本文的后面对此进行研究。</li></ul><h1 id="488b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">SPA的授权代码流</h1><p id="7ec2" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">由于上述问题，最好的方法是将令牌管理完全置于Javascript之外，通过使用带有后端组件的PKCE的<strong class="js iu">授权代码流。看看我之前的一篇文章，为什么我们不应该使用隐式流，为什么推荐PKCE:<a class="ae le" href="https://truongnmt.medium.com/from-the-implicit-flow-to-pkce-oauth-2-0-for-spa-and-mobile-apps-df4343938053" rel="noopener">从隐式流到PKCE — OAuth 2.0用于SPA和移动应用</a></strong></p><p id="783b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是该解决方案的概述:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/8bfb4c7c184ec29b3661b12123ddf711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXrhpkBPk6ptfaQqt3waQg.png"/></div></div></figure><p id="d850" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在步骤2中，SPA生成code_verifier和code_challenge，创建它的方法是选择一种单向散列方法，例如SHA256，散列一个纯文本，并得到一个散列字符串。</p><pre class="kp kq kr ks gt nb mz nc nd aw ne bi"><span id="2e6f" class="nf lg it mz b gy ng nh l ni nj">code_challenge_method(code_verifier) = code_challenge</span><span id="29ad" class="nf lg it mz b gy nk nh l ni nj"># which equivalent to</span><span id="6629" class="nf lg it mz b gy nk nh l ni nj">hash_method(plain_text) = hash</span></pre><p id="add5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们准备构建授权码请求，请求看起来像这样:</p><pre class="kp kq kr ks gt nb mz nc nd aw ne bi"><span id="9c9e" class="nf lg it mz b gy ng nh l ni nj">GET https://authz-server.com/oauth/authorize?<br/>  response_type=code&amp;<br/>  client_id=CLIENT_ID&amp;<br/>  redirect_uri=REDIRECT_URI&amp;<br/>  scope="openid public_profile email user_friends"<br/>  state=XXXXXXXX&amp;<br/>  code_challenge=XXXXXXXXXX&amp;<br/>  code_challenge_method=S256</span></pre><p id="f8b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，用户被重定向到授权服务器，登录并批准(同意)请求。然后，OAuth服务器生成授权代码，并在回调中将它发送给SPA。</p><pre class="kp kq kr ks gt nb mz nc nd aw ne bi"><span id="d8dd" class="nf lg it mz b gy ng nh l ni nj">GET https://spa.example.com/redirect?<br/>  code=AUTHZ_CODE&amp;<br/>  state=XXXXXXXX</span></pre><p id="6f87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SPA验证与步骤3中发送的状态相匹配的状态。然后SPA将授权码和code_verifier转发到后端。从那里，它将发出一个反向信道请求来交换令牌。</p><pre class="kp kq kr ks gt nb mz nc nd aw ne bi"><span id="dfcf" class="nf lg it mz b gy ng nh l ni nj">POST https://authz-server.com/oauth/token?<br/>  grant_type=authorization_code&amp;<br/>  code=AUTHZ_CODE&amp;<br/>  redirect_uri=REDIRECT_URI&amp;<br/>  code_verifier=CODE_VERIFIER&amp;<br/>  client_id=CLIENT_ID</span></pre><p id="4a56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，授权服务器将验证授权码、客户端ID，重定向URI，并使用步骤3中接收的code_challenge和code_challenge_method重新计算code_verifier。</p><pre class="kp kq kr ks gt nb mz nc nd aw ne bi"><span id="b60b" class="nf lg it mz b gy ng nh l ni nj">code_challenge_method(code_verifier) == code_challenge?</span></pre><p id="e771" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，假设一切都有效，授权服务器将返回访问令牌和id令牌(因为我们包含了作用域openid)。根据授权服务器的策略，它可能会也可能不会返回刷新令牌。</p><pre class="kp kq kr ks gt nb mz nc nd aw ne bi"><span id="58d7" class="nf lg it mz b gy ng nh l ni nj">HTTP/1.1 200 OK<br/>{<br/>  "access_token": ACCESS_TOKEN,<br/>  "token_type": "Bearer",<br/>  "expires_in": 7200,<br/>  "id_token": "eyJ.xxxxxxxxxx"<br/>}</span></pre><p id="7ba4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后后端安全地保存这些信息，可能保存在数据库中。然后，在步骤13中，用加密的仅HTTP的、安全的、相同站点的cookies来设置会话，并且不向前端传递任何令牌。</p><p id="1e6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">稍后，当SPA想要访问资源服务器或任何内部API中的信息时，它用cookies调用后端，并让后端发送带有访问令牌的请求(从步骤16到步骤19)。</p><h1 id="fb5a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">iFrame / Popup /重定向？</h1><p id="2d16" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">OpenID Connect协议支持授权请求上的<code class="fe mw mx my mz b">prompt=none</code>参数，该参数允许应用程序指示授权服务器不得显示任何用户交互(如身份验证、同意或MFA)。这意味着如果用户已经在授权服务器中进行了身份验证，并且已经同意了应用程序，那么返回的结果将没有任何用户界面页面。</p><p id="3a72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将<code class="fe mw mx my mz b">prompt=none</code>与一个隐藏的iframe相结合，SPA可以尝试在不重定向的情况下登录。这种模式意味着应用程序不需要整个页面重定向来让用户登录，从而提高了性能和用户体验——用户访问网页并已经登录。然而，当第三方cookies被阻止时，iframe中的<code class="fe mw mx my mz b">prompt=none</code>不再是一个选项，应用程序必须访问顶级框架中的登录页面才能获得授权代码。此外，我们都知道，在SPA中，我们希望尽可能避免全页面刷新。那么，我们应该如何在步骤3中进行设计，以便不丢失任何应用程序的状态和上下文呢？有两种方法可以完成登录:</p><ol class=""><li id="b271" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn nl mo mp mq bi translated">整页重定向</li><li id="a6d4" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn nl mo mp mq bi translated">弹出窗口</li></ol><p id="8805" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于全页面重定向方法，在首次加载SPA时，将用户重定向到授权服务器。用户的浏览器将访问登录页面，显示包含用户会话的cookies，然后使用授权代码重定向回应用程序。重定向确实会导致SPA被加载两次。遵循缓存spa的最佳实践，这样应用程序就不会被完整下载两次。考虑在应用程序中有一个预加载序列，在应用程序完全解包并执行JavaScript有效负载之前，检查登录会话并重定向到登录页面。</p><p id="a841" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果整个页面重定向的用户体验(UX)对应用程序不起作用，可以考虑使用弹出窗口来处理身份验证。当弹出窗口在认证之后完成重定向到应用程序时，在步骤5中接收授权码，并且流程继续。此外，浏览器正在减少对弹出窗口的支持，因此它们可能不是最可靠的选择。在创建弹出窗口之前，用户可能需要与SPA进行交互，以满足浏览器要求。</p><blockquote class="nm nn no"><p id="c2c1" class="jq jr np js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">苹果<a class="ae le" href="https://webkit.org/blog/8311/intelligent-tracking-prevention-2-0/" rel="noopener ugc nofollow" target="_blank">描述了一个弹出方法</a>作为一个临时的兼容性修复，让原始窗口访问第三方cookies。虽然苹果可能会在未来取消这种权限转让，但这不会影响这里的指导。这里，弹出窗口被用作登录页面的第一方导航，以便找到会话并提供授权码。这应该会持续到未来。</p></blockquote><h1 id="6d91" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">利益</h1><p id="2d66" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先，推荐解决方案中的后端可能已经存在于您的系统中，它可能是:</p><ul class=""><li id="d9a4" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">作为后端对前端范例中的后端组件</li><li id="219c" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">API网关或反向代理</li></ul><p id="f56f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过在后端实现安全敏感的功能，我们可以允许一个更安全的OAuth流，它是机密客户端中的OAuth。这对于刷新令牌有很大的好处，因为主流浏览器正在逐渐阻止第三方cookies。我们将在另一篇文章中对此进行更深入的探讨。</p><p id="6d7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个好处是SPA开发人员(通常是前端开发人员)不必关心OAuth/OIDC的实现。假设我们有10个SPA应用程序，如果我们在SPA中实现OAuth/OIDC，我们必须实现10次，这并不是说每个应用程序可能有不同的技术堆栈，我们必须考虑选择一个库，研究如何实现它，等等。如果我们把实现留给后端，最好的情况是我们只需要做一次。实现可以由后端开发人员来处理，他们应该对OAuth有很深的理解，并负责实现和维护。通过这样做，我们可以分离关注点，前端/后端团队可以专注于他们的工作。</p><h1 id="a5d3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么不向SPA返还代币</h1><p id="200a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当我们在步骤10中获得令牌时，为什么我们不将令牌返回给SPA？好了，现在来谈谈选择是否将代币返还给SPA以及如何存储代币的利弊。</p><p id="ef58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们在开头所说，浏览器中没有安全存储API，浏览器中最大的风险之一是跨站脚本攻击(XSS)。无论您将令牌存储在哪里，您自己的Javascript代码也可以被攻击者访问。</p><p id="2708" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Javascript应用程序存储数据有三种主要方式:</p><ul class=""><li id="32d4" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">本地存储</li><li id="2fa7" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">会话存储</li><li id="1bad" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">饼干</li></ul><p id="246e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LocalStorage是纯Javascript，很方便。它允许您存储跨会话持续的数据，即使浏览器关闭，它也将持续存在。SessionStorage是一个非常类似的API，只是存储在那里的数据只有在窗口打开时才会持久，因此命名为Session。Cookies，技术上我们可以用Javascript想存多久就存多久。但是最初cookies是用来让浏览器在每次请求时自动将它发送到后端的。它不是为应用程序存储而设计的。</p><p id="db2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有3种存储API都有相同的缺点，容易受到XSS攻击。这意味着攻击者可以在您的应用程序中运行看起来像合法代码的代码。如果我们在SPA中存储令牌，他们可以利用这一点来窃取用户的访问令牌。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/38428f11aa83507b76be31d2de6ea23a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jkOgu13N76iJ1q2X.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Cookies vs本地存储vs会话存储由FreeCodeCamp提供</figcaption></figure><p id="cf52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">防范XSS病毒的最佳方法之一是制定强有力的内容安全策略。这告诉浏览器允许从哪些域加载Javascript。但是，在当今许多应用程序开发人员依赖如此多的第三方Javascript代码的情况下，创建足够强大的内容安全策略可能是一项挑战。也许甚至CSS库也需要从某处加载JS代码来制作精美的动画。此外，您可以使用弹出其他库的分析、广告或错误报告服务。这意味着您可能并不总是确定Javascript代码加载的源代码。其中一个库有XSS漏洞，你的应用也有XSS漏洞。最后，即使您是最强的CSP，并且没有在您的应用程序中加载任何外部Javascript，用户也可能会自己加载。也许他们被骗粘贴一个JS代码到开发者控制台(像脸书unfriend探测器脚本…)，或者安装了一个恶意的浏览器扩展插件…最终用户的数据也会被窃取。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/4910346e952bdccf8753b7d1f35d8107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6eCbj81Fsvyx2PCt.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">社交网络上持续的XSS攻击——亚历山大·兹拉特科夫</figcaption></figure><p id="928b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种选择是将令牌存储在服务工作者中。Service Worker是您的浏览器在后台运行的脚本，与主网页完全分离。因此跨站点脚本漏洞无法访问存储在服务工作器中的令牌。一个例子是<a class="ae le" href="https://firebase.google.com/docs/auth/web/service-worker-sessions" rel="noopener ugc nofollow" target="_blank"> Firebase </a>或<a class="ae le" href="https://auth0.com/blog/secure-browser-storage-the-facts/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>，它们使用这种方法进行会话管理并刷新访问令牌。然而，这种方法的缺点是构建起来有点复杂，而且在IE11中不工作😱！此外，您的Javascript代码实际上不能再自己制作API，它必须调用服务人员来发送请求并获得响应，然后将它交给您的Javascript代码。所以你可能需要稍微修改一下你的代码。</p><p id="04f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住这些，考虑一下利弊(方便)和缺点(安全XSS漏洞，浏览器兼容)。另一个选择是不存储令牌，将它们保存在内存中，如上图中的步骤15。通过将cookie设置为加密的HTTP-only，安全的，相同的站点，Javascript代码不能接触这些cookie，所以XSS不用担心。然而，在每个页面完全重新加载时，用户必须重定向到后端(步骤16)，提供cookies并获取令牌或会话信息，并将其保存在内存中。因此，作为安全性的折衷，当页面加载时，我们首先有一个额外的请求。</p><h1 id="bbe1" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">安全问题</h1><p id="043b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">通过使用授权代码流和后端组件的PKCE仍然不能使你的SPA完全安全。当SPA向后端发出请求以获取令牌/会话信息时，如果您有一个CSRF漏洞，所有希望都将落空。</p><p id="0a75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以SPA仍然需要防范XSS和CSRF。好消息是水疗中心无论如何都需要这么做。至少SPA开发人员不必太关心OAuth 2.0的复杂性和棘手性。</p><h1 id="6c0c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">对于不带后端的SPA</h1><p id="ccf5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果我们有一个部署在静态web主机/CDN中的纯SPA，这意味着没有后端，我们必须在会话存储或本地存储中存储令牌。请确保您了解在前通道中存储令牌的所有潜在威胁，并遵循以下建议:</p><ul class=""><li id="554b" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">对PKCE使用授权代码流</li><li id="0525" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">授权服务器支持刷新令牌轮换或<br/>发送方限制的刷新令牌</li><li id="73e5" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">考虑使用服务人员</li></ul><h1 id="1894" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="71a0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">浏览器仍然不是存储敏感信息的好地方，所以SPA的OAuth很难。了解潜在威胁以及安全性和用户体验之间的平衡非常重要。本文总结了在为SPA执行OAuth 2.0时推荐的方法。</p><p id="eb9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，由于浏览器最近的变化，各大浏览器都在阻止第三方cookies，以保护用户的隐私。有几点需要考虑。我们将在下一篇文章中对此进行更深入的探讨。敬请关注:D</p><h1 id="c193" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">参考</h1><ul class=""><li id="f314" class="mi mj it js b jt md jx me kb nv kf nw kj nx kn mn mo mp mq bi translated">用于基于浏览器的应用的OAuth 2.0(ietf.org)</li><li id="2be4" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">【aaronparecki.com】单页应用</li><li id="e038" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae le" href="https://curity.io/resources/learn/spa-best-practices" rel="noopener ugc nofollow" target="_blank">最佳实践—单页应用OAuth</a>(curity . io)</li><li id="6f3d" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi"><a class="ae le" href="https://speakerdeck.com/d_endo/30fen-deopenid-connectwan-quan-nili-jie-sitatoyan-eruyouninarumian-qiang-hui?slide=115" rel="noopener ugc nofollow" target="_blank">30分でOpenID Connect完全に理解したと言えるようになる勉強会</a> (</li><li id="6354" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">用于spa的安全OAuth 2.0/OpenID连接后端 (Hans Zandbelt)</li><li id="9e93" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae le" href="https://www.udemy.com/course/oauth-2-simplified/" rel="noopener ugc nofollow" target="_blank">OAuth 2.0的螺母和螺栓</a>(aaronparecki.com)</li><li id="f2b0" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae le" href="https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-third-party-cookies-spas" rel="noopener ugc nofollow" target="_blank">在Safari和其他浏览器中处理第三方cookies被屏蔽的ITP</a>(docs.microsoft.com)</li></ul></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="750e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="np">感谢您阅读本文！如果你有任何问题，请留言。如果你觉得这篇文章有帮助，请按住鼓掌按钮，让其他人也能发现。请务必在下面注册我的时事通讯，或者在Medium上关注我，以获得更多类似的文章。</em> ☝️👏 😄</p></div></div>    
</body>
</html>