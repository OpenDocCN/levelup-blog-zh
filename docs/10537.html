<html>
<head>
<title>How to structure your Go applications AKA staying sane with Go projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建你的围棋应用程序，也就是在围棋项目中保持理智</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/structuring-your-go-applications-aka-staying-sane-with-go-projects-7d5bb38ff6af?source=collection_archive---------4-----------------------#2021-12-19">https://levelup.gitconnected.com/structuring-your-go-applications-aka-staying-sane-with-go-projects-7d5bb38ff6af?source=collection_archive---------4-----------------------#2021-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c4edcac0537da8db96eeea870bad19d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QfIpUbZ_C4J6OpDAc8XGwA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">演职员表:【https://unsplash.com/photos/TPixIUNcQ7I T2】</figcaption></figure><div class=""/><div class=""><h2 id="c2b3" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">因为我们都看到了“一步到位”的项目，没人敢靠近</h2></div><p id="bcdf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如所有的知识一样，在适当的时候肯定会有更好的方法，但在大约三年的职业和个人任务写作之后，这里是<em class="lu">对我起作用的</em>。当然<em class="lu">起作用</em>是主观的，所以我说<em class="lu">起作用</em>是指我进入一个6个月前的仓库，并且仍然设法找到我周围的路。我想这也算是“可维护”吧？😃</p><h1 id="7be5" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">解决方案的来源</h1><p id="f3b4" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果你在谷歌上搜索Go项目布局，你很可能已经看到了这个库:</p><div class="is it gp gr iu ms"><a href="https://github.com/golang-standards/project-layout" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd jk gy z fp mx fr fs my fu fw ji bi translated">GitHub-golang-标准/项目-布局:标准Go项目布局</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">翻译:这是Go应用程序项目的基本布局。这不是核心Go定义的官方标准…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ja ms"/></div></div></a></div><p id="d163" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个很好的起点，因为了解这些标准有助于导航更受欢迎的Go代码库，如<a class="ae jg" href="https://github.com/kubernetes/kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>或<a class="ae jg" href="https://github.com/hashicorp/terraform" rel="noopener ugc nofollow" target="_blank"> Terraforms </a>，但继续到<code class="fe nh ni nj nk b">README.md</code>，您会发现:</p><blockquote class="nl nm nn"><p id="b7b0" class="ky kz lu la b lb lc kk ld le lf kn lg no li lj lk np lm ln lo nq lq lr ls lt im bi translated">是<code class="fe nh ni nj nk b">not an official standard defined by the core Go dev team</code>；然而，它是Go生态系统中一组常见的历史和新兴项目布局模式</p></blockquote><p id="b6b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我看来，这只是对已有内容的简单汇总。虽然它有助于传播对通用模式的认识(这最终会成为<em class="lu">惯用的</em>)，但是存储库并没有宣称它是<strong class="la jk"><em class="lu"/></strong>最好的/唯一的做事方式。</p><p id="559c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">于是，我开始了寻找适合我的结构的旅程。接下来的文章将对此进行更深入的探讨。</p><h1 id="bc78" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">解决方案的前提</h1><p id="ceaf" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">有许多考虑代码库的模型。取决于许多事情，如组织惯例、语言限制和业务领域，了解一些心智模型通常是有用的，以便能够看出什么可行，什么不可行。根据应用程序的目标类型，大多数都大致遵循与模型-视图-视图模型(MVVM)或模型-视图-控制器(MVC)模式相似的架构原则。</p><p id="efdb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些通用模型通常定义3层。一层访问实际数据(想想DAOs)，另一层执行计算处理(控制器/视图模型/后端)，最后一层公开接口/视图(APIs视图/前端)。</p><p id="f0af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我意外地发现了一个与Go兼容的模型:</p><div class="is it gp gr iu ms"><a href="https://www.goodreads.com/en/book/show/51109185" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd jk gy z fp mx fr fs my fu fw ji bi translated">扶正软件</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">没有星级，因为它将被视为“方法”的评级，而不是书本身(这不是如何GR是…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">www.goodreads.com</p></div></div><div class="nb l"><div class="nr l nd ne nf nb ng ja ms"/></div></div></a></div><p id="0d2e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ju val lwy所著的《扶正软件》一书提出了一个模型，该模型的基础是<a class="ae jg" href="https://www.informit.com/articles/article.aspx?p=2995357&amp;seqNum=2" rel="noopener ugc nofollow" target="_blank"><em class="lu"/></a>(书中提出的一种模式)。非常适合需要跟上不断变化的需求的现代商业应用。该模型将组件分为五类:</p><ol class=""><li id="2c82" class="ns nt jj la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated"><strong class="la jk">实用程序</strong> —水平有用的组件。日志和认证机制是潜在实用组件的一些例子。<em class="lu">潜在的</em>因为它取决于您的日志和认证组件的确切范围</li><li id="e6ed" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><strong class="la jk">资源访问器</strong> —负责数据检索的组件。想想文件系统数据检索、从外部服务获取数据的API和DAOs。</li><li id="9225" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><strong class="la jk">引擎</strong> —负责将业务逻辑封装到不应该经常改变的基本处理单元中的组件。想象一下将一个<code class="fe nh ni nj nk b">*.docx</code>文件解析成不同的部分(与将同一文件解析成表单中的字段相比[区别在于，与业务定义的表单相比，<code class="fe nh ni nj nk b">.docx</code>格式不太可能改变])</li><li id="6ca2" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><strong class="la jk">管理者</strong> —负责协调引擎组件以产生与交付价值更直接相关的结果的组件。在前面解析一个<code class="fe nh ni nj nk b">*.docx</code>文件的例子中，管理器将是提取各种解析部分并把它们放入业务定义的表单中的组件。</li><li id="ba07" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><strong class="la jk">客户端</strong> —消费数据或在用户界面的情况下呈现数据的组件。通常是客户或其他系统使用数据的系统前端</li></ol><p id="0405" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就控制流而言，实用组件可以在任何地方使用。对于其余组件，只有当组件A比组件B高一级或与组件B同级时，才能从组件A调用组件B。这意味着引擎组件应仅调用资源访问器，管理器组件应仅调用其他管理器或引擎组件。</p><p id="9a99" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在这里发现的有用区别是MVC中的控制器概念进一步分裂为引擎和管理器类型的组件，前者处理不经常改变的更一般的计算，而后者处理通常与业务相关并且可以预期经常改变的数据的合成/协调(因此<em class="lu">易失性驱动的分解</em>)。</p><p id="ab1e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着代码的增长和组织的成熟，这种差异也很容易使通用引擎类型的代码作为库被提取，而管理器类型的代码作为服务被提取。</p><p id="5f09" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与任何类型的抽象一样，会有一些漏洞，但总的来说，我发现这种模型非常适合Go。</p><h1 id="dca7" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">Golang标准项目布局中的有用部分</h1><p id="96f5" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我已经尝试了这个存储库中几乎所有的目录结构，以寻找做事的“最佳方式”。不出所料，从来没有一个<em class="lu">最好的</em>，但是有一个结构我觉得对于我的环境来说已经足够好了<em class="lu">——CLI工具、glue服务和中等规模的类似SaaS的项目的开发。假设客户端/前端位于独立的存储库中，这是理所应当的。</em></p><p id="1919" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我相对于项目根的结构:</p><pre class="og oh oi oj gt ok nk ol om aw on bi"><span id="3e67" class="oo lw jj nk b gy op oq l or os">/repo-root<br/>  /bin<br/>  /cmd<br/>  /configs<br/>  /deployments<br/>  /docs<br/>  /internal<br/>  /pkg<br/>  /tests<br/>  Dockerfile<br/>  Makefile<br/>  main.go<br/>  go.mod<br/>  go.sum</span></pre><p id="7c0f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b"><strong class="la jk">/bin</strong></code>。这包含二进制文件，并且应该包含一个简单的<code class="fe nh ni nj nk b">.gitignore</code>文件，用于除自身之外的所有内容</p><p id="344f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b"><strong class="la jk">/cmd</strong></code>。它包含命令包装器——cobra/ur fave/others——并包含反映命令结构本身的子目录结构。例如，如果您能够运行<code class="fe nh ni nj nk b">app get templates</code>，那么Go文件的相关目录结构应该是:</p><pre class="og oh oi oj gt ok nk ol om aw on bi"><span id="a137" class="oo lw jj nk b gy op oq l or os">/repo-root<br/>  /cmd<br/>    /app<br/>      /get<br/>        /templates<br/>          command.go<br/>        command.go<br/>      command.go<br/>    command.go<br/>  main.go</span></pre><p id="05ee" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的结构应该可以让你在开发的时候运行<code class="fe nh ni nj nk b">go run . get templates</code>。</p><p id="1c1a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b"><strong class="la jk">/configs</strong></code>。这包含与应用程序构建过程相关的静态配置。我发现这仅适用于在引入<code class="fe nh ni nj nk b">go:embed</code>和<code class="fe nh ni nj nk b">go:generate</code>之前为CLI项目提供构建时配置。我相信可以通过切换到<code class="fe nh ni nj nk b">go:embed</code>并使用本地嵌入来废除这个目录。</p><p id="7fbe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b"><strong class="la jk">/deployments</strong></code>。其中包含与部署相关的文件，比如Ansible playbooks、Docker Compose manifests、Kuberntes manifest/kutomizations或Helm charts。同样有争议的是，特别是对于Helm，图表也可以在根级别<code class="fe nh ni nj nk b">/charts</code>中，通过在根级别添加一个<code class="fe nh ni nj nk b">Chart.yaml</code>来简化存储库到Helm存储库的发布。</p><p id="504e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b"><strong class="la jk">/docs</strong></code>。我希望你记录你的代码。将您的文档放在这个目录中使您能够设置GitHub/GitLab页面从这个目录创建一个静态站点，而不是您的<code class="fe nh ni nj nk b">README.md</code>或者更糟的是一个单独的文档分支。如果您将文档存储在单独的存储库中，则不需要(这对于使用Gitbook等外部工具很有用，这些工具提供了WYSWYG编辑器来管理您的文档，但也可以同步回Git存储库)</p><p id="e695" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b"><strong class="la jk">/internal</strong></code>。这包含了严格在代码库中内部使用的Go代码。请注意，有一个严格的标准，即此目录中的Go代码不能被另一个存储库中的Go代码引用，因此不要放置包含从另一个服务引用可能有用的<code class="fe nh ni nj nk b">type</code>的代码(例如，当使用gRPC时，消费者通常使用来自提供者存储库的Protobuf定义——不要将您的Protobuf代码生成的文件放在这里，否则消费者将无法引用它们)</p><p id="4835" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b"><strong class="la jk">/pkg</strong></code>。它包含可以在内部使用的Go代码，但是其他存储库也应该能够作为依赖项引用这些代码。如果你在gRPC上使用Protobufs，这是你可以放置你的<code class="fe nh ni nj nk b">protoc</code>编码类型定义的地方。</p><p id="1196" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b"><strong class="la jk">/tests</strong></code>。这不包含测试。测试应该总是自包含在使用<code class="fe nh ni nj nk b">*_test.go</code>符号的包中。相反，该目录包含测试可能需要集中引用的数据。这与最初的<code class="fe nh ni nj nk b">/test</code>有所不同，主要是因为我喜欢运行<code class="fe nh ni nj nk b">make test</code>来运行我的测试，根据您的偏好或组织惯例，可以随意坚持使用<code class="fe nh ni nj nk b">/test</code>。</p><h2 id="a875" class="oo lw jj bd lx ot ou dn mb ov ow dp mf lh ox oy mh ll oz pa mj lp pb pc ml pd bi translated">文件上的其他注释</h2><ol class=""><li id="4c76" class="ns nt jj la b lb mn le mo lh pe ll pf lp pg lt nx ny nz oa bi translated"><code class="fe nh ni nj nk b">/scripts</code>目录不存在，因为我将脚本放入了<code class="fe nh ni nj nk b">Makefile</code>中，并在docker文件中使用了<code class="fe nh ni nj nk b">make</code>，这并不是常见的做法，因为从那时起，您将需要安装<code class="fe nh ni nj nk b">make</code>。通过将构建映像与最终映像分开的多阶段Docker构建，在我看来这不是太大的问题，并且它通过只有一个中央脚本文件而简化了事情。</li><li id="a1c8" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">也可以将<code class="fe nh ni nj nk b">main.go</code>放在<code class="fe nh ni nj nk b">/cmd</code>目录中，但是我发现在大多数情况下，作为一般的经验法则，将它放在根目录中会更好，因为对于缺乏约定知识的初学者来说，这样更直观，但是仅仅通过文件名就可以将它识别为入口点。另外，如果你正在开发一个库，<code class="fe nh ni nj nk b">main.go</code>必须在根目录中，否则你的用户将不得不在他们的<code class="fe nh ni nj nk b">import</code>语句中引用子目录。</li></ol><h1 id="3961" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">将心智模型付诸实施</h1><p id="19ac" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">冒着听起来太简单的风险，适合我的结构是:</p><ol class=""><li id="5453" class="ns nt jj la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated"><strong class="la jk">实用程序和资源访问器组件进入</strong> <code class="fe nh ni nj nk b"><strong class="la jk">/pkg</strong></code> <strong class="la jk">。</strong>当扩展到需要中央数据检索机制时，将它们提取到它们自己的存储库中。</li><li id="ab82" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><strong class="la jk">发动机部件进入</strong> <code class="fe nh ni nj nk b"><strong class="la jk">/internal</strong></code> <strong class="la jk">。</strong>当扩展到多个服务必须使用相同的引擎组件时，将这些组件提取到它们自己的存储库中。</li><li id="d497" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><strong class="la jk">非面向客户的管理器组件进入</strong> <code class="fe nh ni nj nk b"><strong class="la jk">/internal</strong></code> <strong class="la jk">。</strong>这些组件应该相对特定于正在开发的服务。</li><li id="1fb2" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><strong class="la jk">面向客户的经理组件进入</strong> <code class="fe nh ni nj nk b"><strong class="la jk">/cmd</strong></code>。这些应该是也可以被视为视图的代码，或者是高度特定于您的服务的代码，除非通过OpenAPI/AsyncAPI或SDK之类的文档，否则不应该共享。</li></ol><p id="8596" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我还遵循一些增强组件对变更的弹性的规则(新特性/变更请求应该导致尽可能少的变更):</p><ol class=""><li id="4878" class="ns nt jj la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated"><strong class="la jk">在每一层实现依赖注入</strong>。这意味着，如果ResourceAccessor组件需要MySQL连接，面向客户端的管理器组件必须启动连接实例，并通过所有组件向下传递，直到它到达ResourceAccessor。这也有助于测试，因为它允许在每一级使用模拟来验证行为。</li><li id="9e51" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><strong class="la jk">所有引擎组件都实现为</strong> <code class="fe nh ni nj nk b"><strong class="la jk">interface</strong></code> <strong class="la jk"> s </strong>。这意味着所有引擎组件都将导出一个<code class="fe nh ni nj nk b">interface</code>及其实现。这在<em class="lu">可处置性</em>(我认为这是任何组件最重要的属性)方面对<strong class="la jk">有很大的帮助，它使开发人员能够在不修改现有实现的情况下重写实现，然后能够通过用新的实现替换以前的实现来对其运行相同的测试。这也使Go中的性能基准测试变得容易。</strong></li></ol><p id="3c90" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过执行上述操作:</p><ol class=""><li id="16e4" class="ns nt jj la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">当业务增长时，添加是在现有代码的基础上单独完成的，只需对管理器组件进行最小的修改来添加引擎组件调用</li><li id="2b49" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">当业务需求改变时，修改很大程度上被封装到管理器组件中</li><li id="785c" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">当上下文知识丢失时，任何组件类型的重写都可以很容易地完成，因为使用了<code class="fe nh ni nj nk b">interface</code>类型</li><li id="a0a2" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">升级核心依赖项时，更改大多封装到引擎和资源访问器组件中</li></ol><h1 id="9bce" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">工具和流程</h1><p id="f7e7" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">除了代码的结构之外，我发现工具在交流开发中常用的东西方面大有帮助，并且可以帮助理解代码库</p><p id="f107" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就我个人而言，我使用我的<code class="fe nh ni nj nk b">Makefile</code>来做这件事，但是如上所述，你也可以将脚本放在相对于项目根目录的<code class="fe nh ni nj nk b">/scripts</code>目录中。对我来说，<code class="fe nh ni nj nk b">Makefile</code>有一个好处，它是一个工具，可以在大多数机器上开箱即用，几乎在任何地方都一样。</p><p id="1b45" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用一个<code class="fe nh ni nj nk b">Makefile</code>还可以让其他开发人员(也就是6个多月后的你)能够在一个文件中了解所有的开发过程。</p><p id="b523" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的一个项目中，一个典型的<code class="fe nh ni nj nk b">Makefile</code>将会有如下内容，它可以让开发人员轻松地运行与存储库相关的任务(我知道，Make并不打算成为一个任务运行器，但是嘿，它确实有效，并且现在已经成为Go项目中的一个惯例):</p><pre class="og oh oi oj gt ok nk ol om aw on bi"><span id="4cce" class="oo lw jj nk b gy op oq l or os">deps: # install dependencies<br/>data: # runs go generate and/or other things like protoc<br/>build: # builds the Go binary<br/>image: # builds the Docker image<br/>lint: # runs go vet or other similar tools<br/>test: # runs tests<br/>package: # packages the service/app<br/>publish: # publishes the service/app</span></pre><h1 id="314a" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">结束了</h1><p id="55d9" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">希望这在某种程度上有所帮助——下次见！</p><p id="66d9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你已经读到这里，请考虑给一些👏鼓励我继续创作这样的作品。去吧，祝你有美好的一天！</p></div></div>    
</body>
</html>