<html>
<head>
<title>Getting Fast Realtime Leaderboards With Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redis快速获取实时排行榜</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-fast-realtime-leaderboards-with-redis-792e1393c43c?source=collection_archive---------4-----------------------#2022-11-29">https://levelup.gitconnected.com/getting-fast-realtime-leaderboards-with-redis-792e1393c43c?source=collection_archive---------4-----------------------#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/4a7e3695cccb8d9b9c2678f815172993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lX0acnhsU7D3t-UKlTVH-g.jpeg"/></div></div></figure><div class=""/><p id="7e6f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">排行榜无处不在</strong>，观众喜欢看到自己的排名靠前。但是你知道他们更喜欢什么吗，<strong class="ka jc">实时排行榜！</strong></p><p id="5a20" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，<strong class="ka jc">排行榜是一个很难解决的问题，尤其是让它们实时化。</strong>所以在这篇文章中，让我们看看如何使用我们的Redis来实现超快的实时排行榜。</p><h1 id="81f4" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">为什么选择Redis实时排行榜？</strong></h1><p id="2ce5" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">排行榜从根本上来说是一个排序问题，而<a class="ae lz" href="http://redis.io" rel="noopener ugc nofollow" target="_blank"> Redis </a>提供了经过实战检验的<strong class="ka jc">排序集</strong>数据结构，可用于构建实时排行榜。</p><h1 id="4ecc" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">排序集确定，还有什么？</strong></h1><p id="768e" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="http://redis.io" rel="noopener ugc nofollow" target="_blank"> Redis的</a>建立在单线程架构上，这允许score upsert请求被顺序处理。这意味着排行榜将保持一致。</p><p id="9f22" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">性能提升:对于大多数操作，排序后的集合得到O(log(n))，其中n是集合中的成员数。</p><p id="3228" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redis的持久性选项允许您保留数据备份，因此在任何停机的情况下，您都不会丢失所有数据。</p><h1 id="e373" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">解决方案概述:</strong></h1><p id="f351" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">虽然实时排序集可能会解决您的分数排序问题，但您可能会发现自己面临一些常见的问题，如:</p><ol class=""><li id="36d6" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">如果我希望我的排行榜中有用户名和头像，该怎么办？</li><li id="0091" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">如果我的排名逻辑基于多个因素，比如SQL多列order by，该怎么办？</li></ol><p id="48a1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为你只能在一个排序的集合行中保存分数和成员标识符，所以你可以从其他地方解析用户名、头像等数据。理想情况下，如果您使用用户id作为成员字符串，这应该很容易，这将允许您从系统中解析任何与用户相关的内容。</p><p id="045a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于像排序这样的多列SQL，您需要从您的分数中加减权重来实现这种行为。</p><p id="a2fc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">示例:级别(最高优先级)、分数(第二高)</em></p><p id="48bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">分数- &gt;等级* 10e5 +分数(假设分数限制为3位数，等级为100) </em></p><p id="1166" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更多关于这个的细节<a class="ae lz" href="https://www.dr-josiah.com/2013/10/multi-column-sql-like-sorting-in-redis.html" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="b843" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">所以一般的流程可能是这样的:</strong></p><ol class=""><li id="a66c" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">对于每次提交，获得分数并将其作为成员字符串添加到针对用户id的排序集中。</li><li id="caec" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">对于每个排行榜获取请求，从排行榜获取前N名成员id，并根据前N名用户id从您的用户档案数据存储中解析其余详细信息。</li><li id="c91a" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">确保在您的<a class="ae lz" href="http://redis.io" rel="noopener ugc nofollow" target="_blank"> Redis </a>部署中设置好<a class="ae lz" href="https://redis.io/docs/management/persistence/" rel="noopener ugc nofollow" target="_blank">持久性策略</a>。</li></ol><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/8a62cf280d5f3d3f63694c64b0faf48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kKV43qpJGknF00hBA1ZOA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">排行榜数据流</figcaption></figure><p id="6cc6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">重要命令:</strong></p><p id="1989" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1: <a class="ae lz" href="https://redis.io/commands/zadd/" rel="noopener ugc nofollow" target="_blank"> ZADD </a>:将所有具有指定分数的指定成员添加到排序后的集合中</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/229b5d0cd2a8d41488312a7ff192ed49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*Nz1HsPaA0MpCkjHf1Y2M4Q.png"/></div></figure><p id="e5a5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2: <a class="ae lz" href="https://redis.io/commands/zcard/" rel="noopener ugc nofollow" target="_blank"> ZCARD </a>:返回存储在<code class="fe mz na nb nc b">key</code>的排序集的排序集基数(元素数)。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/537668bf4669085e1abd150caab64a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*u0FD0WkFJiPzjzXsFu54Kg.png"/></div></figure><p id="d638" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3: <a class="ae lz" href="https://redis.io/commands/zrevrange/" rel="noopener ugc nofollow" target="_blank"> ZREVRANGE </a>:返回存储在<code class="fe mz na nb nc b">key</code>的排序集合中指定范围的元素。这些元素被认为是从最高分到最低分排序的。降序字典顺序用于得分相等的元素。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/84267dad53801a3f29a08c280483d6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*xI_lC9ziNw1pqFve8L_Knw.png"/></div></figure><p id="cd61" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4: <a class="ae lz" href="http://Returns the rank of member in the sorted set stored at key, with the scores ordered from high to low. The rank (or index) is 0-based, which means that the member with the highest score has rank 0." rel="noopener ugc nofollow" target="_blank"> ZREVRANK </a>:返回<code class="fe mz na nb nc b">member</code>在<code class="fe mz na nb nc b">key</code>存储的排序集合中的排名，得分从高到低排序。排名(或指数)以0为基础，这意味着得分最高的成员拥有排名<code class="fe mz na nb nc b">0</code>。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/15ddf369a111929a6d445746c2ea304f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*-s2QqEIpyzbgiAmxlkYIfg.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">注意:Redis使用从0开始的索引，因此这意味着user_2位于第1级。</figcaption></figure><p id="b9d5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">节点JS编码:</strong></p><pre class="mq mr ms mt gt ng nc nh bn ni nj bi"><span id="a390" class="nk kx jb nc b be nl nm l nn no">//Package used : "ioredis": "^5.2.4"<br/>export const upsertScore = async ({score, username, timetaken}, {redis} ) =&gt; {<br/>    //Giving Highest Priority to Score, inflating it's value to have less impact of time taken.<br/>    //Here we are prioritising score desc and tike taken asc.<br/>    const modifiedScore = score * 100 - Math.floor(timetaken/10);<br/>    return  redis.zadd(KEY, modifiedScore, username);<br/>}<br/><br/>export const getRankUser = async ({ key, username }, { redis }) =&gt; {<br/>    const rank = await redis.zrevrank(key, username);<br/>    if(rank &gt;= 0) return rank + 1;<br/>};<br/><br/>export const getRanks = async ({ key, startIndex, endIndex }, { redis }) =&gt; {<br/>    return redis.zrevrange([key, startIndex, endIndex, "WITHSCORES"]);<br/>};<br/><br/>export const totalCount = async ({ key }, { redis }) =&gt; {<br/>    return redis.zcard(key);<br/>};<br/><br/>export const getLeaderBoard = async ({ page, perPage, username }, { redis }) =&gt; {<br/>    const startIndex = perPage * (page - 1);<br/>    const endIndex = (perPage * page) - 1;<br/>    const [ranks, count, userRank] = await Promise.all([<br/>        getRanks({ key: KEY, startIndex, endIndex }, { redis }),<br/>        totalCount({ key: KEY }, { redis }),<br/>        getRankUser({ key: KEY, username }, { redis })<br/>    ]);<br/>    return {<br/>        ranks: ranks,<br/>        count: count,<br/>        userRank: userRank<br/>    }<br/>}</span></pre><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">演示应用的视频。</figcaption></figure><h1 id="f185" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">资源:</h1><ol class=""><li id="899d" class="ma mb jb ka b kb lu kf lv kj nr kn ns kr nt kv mf mg mh mi bi translated"><a class="ae lz" href="https://github.com/gaurav1999/redis_leaderboard_demo_app" rel="noopener ugc nofollow" target="_blank">演示app源代码</a></li><li id="8c49" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae lz" href="https://redis.io/docs/data-types/sorted-sets/" rel="noopener ugc nofollow" target="_blank"> Redis文档</a></li></ol></div></div>    
</body>
</html>