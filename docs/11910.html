<html>
<head>
<title>React state meets Typescript’s Union type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React状态符合Typescript的联合类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-state-meets-typescripts-union-type-7071f9451c61?source=collection_archive---------5-----------------------#2022-04-27">https://levelup.gitconnected.com/react-state-meets-typescripts-union-type-7071f9451c61?source=collection_archive---------5-----------------------#2022-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="52c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">充分利用Typescript最被低估的特性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/110dd604035cfa69894836400c23d6cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J223fQjZ3z5yvg-O.jpg"/></div></div></figure><p id="bc1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您不熟悉它，联合类型是我们用来描述“几种不同类型之一”的值的基本类型脚本工具。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="2c25" class="ls lt iq lo b gy lu lv l lw lx">type CarOrBus = Bus | Car</span></pre><p id="68e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实证明，这个工具对于反应状态有一些特别有用的应用。<strong class="kt ir">知道如何以及何时使用联合类型来描述你的组件状态将使你写更少的代码，更少的错误。</strong>那么我的确切意思是什么？</p><p id="758d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们先来看看我们正在构建的电影应用程序中搜索组件的一些示例源代码。在任何给定的时间点，该组件应该是:</p><ol class=""><li id="5475" class="ly lz iq kt b ku kv kx ky la ma le mb li mc lm md me mf mg bi translated">⏳装载-显示装载指示器</li><li id="7827" class="ly lz iq kt b ku mh kx mi la mj le mk li ml lm md me mf mg bi translated">✅完成-显示搜索结果</li><li id="6bf5" class="ly lz iq kt b ku mh kx mi la mj le mk li ml lm md me mf mg bi translated">🚨错误-显示搜索错误</li></ol><p id="b486" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一下代码。👇</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="315a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当用户在之前遇到错误后返回成功的搜索结果时会发生什么？</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="4bae" class="ls lt iq lo b gy lu lv l lw lx">{searchResults &amp;&amp; &lt;MovieList movies={searchResults} /&gt;}</span><span id="876c" class="ls lt iq lo b gy mo lv l lw lx">{isLoading &amp;&amp; &lt;LoadingIndicator /&gt;}</span><span id="d2b2" class="ls lt iq lo b gy mo lv l lw lx">{error &amp;&amp; &lt;ErrorMessageUI message={error.message} /&gt;}</span></pre><p id="14f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的应用程序在这里可能会遇到很多不好的视图状态。你可以在错误信息上方显示加载信息，也可以在错误信息上方显示搜索结果。从技术上讲，你可以同时展示这三个元素。<strong class="kt ir">我们如何确保一次只显示这些视图状态中的一个？</strong></p><p id="bafa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一种方法是改变我们的渲染逻辑，强制一次只渲染其中一个元素。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="890b" class="ls lt iq lo b gy lu lv l lw lx">let content: <em class="mp">ReactElement</em> = null</span><span id="dac1" class="ls lt iq lo b gy mo lv l lw lx"><strong class="lo ir">if</strong> (errorMessage) {<br/>  content = &lt;<em class="mp">MovieList</em> <em class="mp">movies</em>={searchResults} /&gt;<br/>} <strong class="lo ir">else if</strong> (isLoading) {<br/>  content = &lt;<em class="mp">LoadingIndicator</em> /&gt;<br/>} <strong class="lo ir">else if</strong> (searchResults != null) {<br/>  content = &lt;<em class="mp">ErrorMessageUI</em> <em class="mp">message</em>={error.message} <em class="mp">onClose</em>={() =&gt;   setError(undefined)} /&gt;<br/>}</span><span id="7a08" class="ls lt iq lo b gy mo lv l lw lx">return (<br/>  &lt;div&gt;<br/>    &lt;input<br/>      <em class="mp">value</em>={searchTerm}<br/>      <em class="mp">onChange</em>={<em class="mp">e</em> =&gt; setSearchTerm(<em class="mp">e</em>.target.value)}<br/>    /&gt;<br/>    {content}<br/>  &lt;/div&gt;<br/>)</span></pre><p id="7f81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然添加这种呈现逻辑可以保证我们一次只显示这些元素中的一个，但是它也有自己的问题。这个逻辑为我们的状态变量提供了一个严格的层次结构，当我们在<code class="fe mq mr ms lo b">useEffect</code>钩子中更新状态设置逻辑时，我们必须牢记这一点。我们本质上是把“什么时候显示”的逻辑分成两个独立的部分，相信我——这很快就会让人毛骨悚然。此外，我们失去了很多可读性。</p><p id="f833" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么还有什么选择呢？如果我们尽可能简单地保持渲染逻辑，而是小心地更新我们的<code class="fe mq mr ms lo b">useEffect</code>钩子以确保⏳装载，✅完成，和🚨错误视图状态是互斥的。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="5e23" class="ls lt iq lo b gy lu lv l lw lx">useEffect(() =&gt; {</span><span id="98ec" class="ls lt iq lo b gy mo lv l lw lx">  // 1. Loading state<br/>  setIsLoading(true)<br/>  setError(undefined)<br/>  setSearchResults(undefined)</span><span id="437b" class="ls lt iq lo b gy mo lv l lw lx">  searchForMovies(searchTerm).then(data =&gt; {</span><span id="341a" class="ls lt iq lo b gy mo lv l lw lx">    // Success results state<br/>    setSearchResults(data)<br/>    setError(undefined)<br/>    setIsLoading(false)<br/>  })<br/>  .catch((error: Error) =&gt; {</span><span id="cefc" class="ls lt iq lo b gy mo lv l lw lx">    // Error state<br/>    setError(error)<br/>    setSearchResults(undefined)<br/>    setIsLoading(false)<br/>  })<br/>}, [searchTerm])</span></pre><p id="490f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们走吧。现在我们显式地设置所有那些同时影响视图状态的状态值。通过查看这里的代码，我们可以手动验证所有这些状态值的组合将为我们提供有效的视图状态。</p><p id="0ac2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mp">但是</em>对于一堆总是同时变化的状态值来说，这是一大堆样板文件。在我们的应用程序中有网络请求的地方添加这一点会很麻烦。</p><p id="7db3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧，如果他们都在同一时间改变，为什么我们不把他们放在一个单一的状态？💡</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="d46a" class="ls lt iq lo b gy lu lv l lw lx">type <strong class="lo ir">ViewState</strong> = {<br/>  loading: boolean,<br/>  error?: Error,<br/>  searchResults?: Movie[],<br/>}</span><span id="368b" class="ls lt iq lo b gy mo lv l lw lx">const [viewState, setViewState] = useState&lt;<strong class="lo ir">ViewState</strong>&gt;({ loading: true })</span></pre><p id="6bc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是所有这些看起来的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">状态为带有可选键的字典</figcaption></figure><p id="5434" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，这是一个进步，更容易阅读！此外，由于视图状态的整体被封装在这个<code class="fe mq mr ms lo b">ViewState</code>类型中，我们可以省略想要“取消设置”的键，这很方便。</p><p id="8c7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以这要干净得多，但是我们仍然在自己的校对中随心所欲，如果我们不小心，我们仍然可以用无效的值组合来更新我们的视图状态。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="6376" class="ls lt iq lo b gy lu lv l lw lx">setViewState({ isLoading: false, searchResults: movies })</span><span id="d5bf" class="ls lt iq lo b gy mo lv l lw lx">// 👆 Bad view state, should not be loading and showing results<br/>// at the same time</span></pre><p id="6b2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们可以利用typescript编译器向我们的typescript <code class="fe mq mr ms lo b">ViewState</code>类型添加约束，并防止我们设置无效的视图状态组合，会怎么样？？</p><h2 id="8a7a" class="ls lt iq bd mx my mz dn na nb nc dp nd la ne nf ng le nh ni nj li nk nl nm nn bi translated"><strong class="ak">输入联合类型</strong></h2><p id="da2a" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">所以我前面提到过，联合类型允许我们定义一个“几种不同类型之一”的类型。</p><p id="b670" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个非常简单的例子来说明我们如何定义类型<code class="fe mq mr ms lo b">string</code>或<code class="fe mq mr ms lo b">undefined</code>。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="5bb5" class="ls lt iq lo b gy lu lv l lw lx">let a: <strong class="lo ir">string | undefined</strong> = undefined</span></pre><p id="2622" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是不仅仅是像<code class="fe mq mr ms lo b">string</code>和<code class="fe mq mr ms lo b">number</code>这样的基本类型，你可以从任何其他类型创建一个联合类型:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="bedb" class="ls lt iq lo b gy lu lv l lw lx">type Foo = { a: string } | { b: string }</span><span id="7e14" class="ls lt iq lo b gy mo lv l lw lx">declare function acceptFoo(foo: Foo): void;</span><span id="026d" class="ls lt iq lo b gy mo lv l lw lx">acceptFoo({ a: '' }) ✅ </span><span id="ad15" class="ls lt iq lo b gy mo lv l lw lx">acceptFoo({ b: '' }) ✅</span></pre><p id="f773" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，我们如何使用联合类型来更具体地了解我们的3种不同组合(⏳, ✅ ,🚨)我们的<code class="fe mq mr ms lo b">ViewState</code>属性？让我们回到上一个例子中的3个<code class="fe mq mr ms lo b">setState</code>调用，并为它们创建单独的类型。然后我们可以用一个联合类型将它们组合起来。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="31f5" class="ls lt iq lo b gy lu lv l lw lx">type <em class="mp">ViewState</em> = (</span><span id="6cbb" class="ls lt iq lo b gy mo lv l lw lx"><em class="mp">  // </em>⏳ '<em class="mp">Loading'</em> <em class="mp">state<br/>  { loading: true, searchResults?: undefined, error?: undefined } |</em></span><span id="e66a" class="ls lt iq lo b gy mo lv l lw lx">  // ✅ '<em class="mp">Done'</em> <em class="mp">state<br/></em>  { loading: false, searchResults: Movie[], error?: undefined } |</span><span id="8e37" class="ls lt iq lo b gy mo lv l lw lx"><em class="mp">  // </em>🚨 '<em class="mp">Error'</em> <em class="mp">state<br/></em>  { loading: false, searchResults?: undefined, error: Error }<br/>)</span></pre><p id="ecb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的新<code class="fe mq mr ms lo b">ViewState</code>定义现在说我们的<code class="fe mq mr ms lo b">viewState</code>变量必须匹配这些特定类型之一。看看现在会发生什么，当我们像以前一样试图用无效的属性组合调用<code class="fe mq mr ms lo b">setViewState</code>时:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="0679" class="ls lt iq lo b gy lu lv l lw lx">// 👇 Attempting to set bad view state 👇</span><span id="6059" class="ls lt iq lo b gy mo lv l lw lx">setViewState({ loading: true, error: error })</span><span id="4538" class="ls lt iq lo b gy mo lv l lw lx">// ❌ TS Error: Type 'true' is not assignable to type 'false'</span></pre><p id="d964" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的<code class="fe mq mr ms lo b">setViewState</code>函数需要一个类型为<code class="fe mq mr ms lo b">ViewState</code>的参数——我们新的联合类型。我们传递的对象文字的类型<code class="fe mq mr ms lo b">{ loading: true, error: Error }</code>与联合类型的任何成员都不匹配，所以<strong class="kt ir"> Typescript引发了一个错误，并阻止我们编写会使我们进入那些糟糕的视图状态的代码！</strong></p><p id="aea0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">非常漂亮——我们成功地防止了组件状态的错误，让TypeScript而不是我们的用户来捕捉这些潜在的错误！但是我们可以做更多的事情。</p><h2 id="82f2" class="ls lt iq bd mx my mz dn na nb nc dp nd la ne nf ng le nh ni nj li nk nl nm nn bi translated">类型缩小👉 👈</h2><p id="c586" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">为了说明下一个Typescript特性，让我们介绍另一个产品需求。我们需要向我们的<code class="fe mq mr ms lo b">LoadingIndicator</code>组件传递一个<code class="fe mq mr ms lo b">loadingSince</code>属性，以显示搜索已经加载了多长时间。下面是该组件的更新函数签名:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="04ed" class="ls lt iq lo b gy lu lv l lw lx">declare function <em class="mp">LoadingIndicator(<br/>  props: { loadingSince: Date }<br/>): JSX.Element</em></span></pre><p id="2ab3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，让我们将<code class="fe mq mr ms lo b">loadingSince</code>属性添加到我们的<code class="fe mq mr ms lo b">ViewState</code>类型中。但是，嗯——我们真的只需要当我们在⏳加载状态。那么，如果我们只把那个键添加到⏳在我们的联合中加载状态类型？</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="4e0a" class="ls lt iq lo b gy lu lv l lw lx">type <em class="mp">ViewState</em> = (</span><span id="ce8d" class="ls lt iq lo b gy mo lv l lw lx"><em class="mp">  // </em>⏳ '<em class="mp">Loading'</em> <em class="mp">state<br/>  {<br/>    loading: true,<br/>    searchResults?: undefined,<br/>    error?: undefined,<br/>    </em><strong class="lo ir">loadingSince?: Date</strong><br/>  <em class="mp">} |</em></span><span id="8d45" class="ls lt iq lo b gy mo lv l lw lx">  // ✅ '<em class="mp">Done'</em> <em class="mp">state<br/></em>  { loading: false, searchResults: Movie[], error?: undefined } |</span><span id="6c35" class="ls lt iq lo b gy mo lv l lw lx"><em class="mp">  // </em>🚨 '<em class="mp">Error'</em> <em class="mp">state<br/></em>  { loading: false, searchResults?: undefined, error: Error }<br/>)</span></pre><p id="6ec3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们又遇到了一个打字错误。怎么回事？</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="bd29" class="ls lt iq lo b gy lu lv l lw lx">{viewState.loading &amp;&amp; viewState.loadingSince != null &amp;&amp; (<br/>  &lt;<em class="mp">LoadingIndicator loadingSince={</em>viewState.loadingSince<em class="mp">} </em>/&gt;<br/>  👆 ❌ Property 'loadingSince' does not exist on type 'ViewState'<br/>)}</span></pre><p id="0723" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Typescript似乎根本不认为这个属性<code class="fe mq mr ms lo b">loadingSince</code>存在于我们的变量<code class="fe mq mr ms lo b">viewState</code>上。为什么？</p><p id="dcab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经告诉Typescript，<code class="fe mq mr ms lo b">loadingSince</code>属性只存在于我们的联合类型的一个成员上。假设typescript编译器不知道我们的<code class="fe mq mr ms lo b">viewState</code>变量是否匹配我们的⏳装载，✅成功或🚨错误类型，Typescript只能让我们访问保证存在于该类型上的属性，这些属性存在于联合中的每个类型上。</p><p id="3455" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么我们如何访问union类型的单个成员的属性呢？</p><p id="c408" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们所要做的就是告诉Typescript哪个特定的联合成员类型(⏳、✅或🚨)我们正在处理。我们可以通过编写“缩小”类型的条件代码路径(控制流)来做到这一点。下面是一些简单的例子来说明“类型收缩”在Typescript中是如何工作的。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="a1c0" class="ls lt iq lo b gy lu lv l lw lx">function multiplyByTwo(<em class="mp">value</em>: <em class="mp">number</em> | <em class="mp">undefined</em>) {<br/>  if (<em class="mp">value</em> != null) {<br/>    // ️️❗️ <em class="mp">value</em> has been narrowed to type `number` here<br/>    return <em class="mp">value</em> * 2.0 <br/>  } else {<br/>    // ❗️ <em class="mp">value</em> has been narrowed to type `<em class="mp">undefined</em>` here<br/>    return null<br/>  }<br/>}</span><span id="7f09" class="ls lt iq lo b gy mo lv l lw lx">function callFunctionIfPossible(<em class="mp">func</em>: (() =&gt; void) | <em class="mp">undefined</em>) {<br/>  return <em class="mp">func</em> &amp;&amp; (<br/>    // ❗️ <em class="mp">value</em> has been narrowed to type `() =&gt; void` here<br/>    <em class="mp">func()</em><br/>  )<br/>}</span></pre><p id="91c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们如何缩小自定义类型的列表，就像我们的例子中的<code class="fe mq mr ms lo b">ViewState</code> union？</p><p id="8ea5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有许多不同的方法可以做到这一点，但是在我们的例子中，我建议最好的选择是通过在一个共享键下给类型成员一个唯一的标识符来区分它们。那会是什么样子？</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="1fe5" class="ls lt iq lo b gy lu lv l lw lx">type <em class="mp">ViewState</em> = (<br/>  <em class="mp">// </em>⏳ '<em class="mp">Loading'</em> <em class="mp">state<br/>  </em>{ <strong class="lo ir">status</strong>: 'loading', loadingSince: Date } |</span><span id="4abe" class="ls lt iq lo b gy mo lv l lw lx">  // ✅ '<em class="mp">Done'</em> <em class="mp">state</em><br/>  { <strong class="lo ir">status</strong>: 'done', searchResults: Movie[] } |</span><span id="2b02" class="ls lt iq lo b gy mo lv l lw lx"><em class="mp">  // </em>🚨 '<em class="mp">Error'</em> <em class="mp">state</em><br/>  { <strong class="lo ir">status</strong>: 'error', error: Error }<br/>)</span></pre><p id="d90a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里需要注意一些其他的变化:</p><ol class=""><li id="97aa" class="ly lz iq kt b ku kv kx ky la ma le mb li mc lm md me mf mg bi translated">我们从视图状态的类型定义中去掉了所有不必要的键。例如，我们不再需要添加<code class="fe mq mr ms lo b">error?: undefined</code>到✅的‘完成’状态。只要我们计划在访问键之前缩小类型，我们就不需要在我们的标识符“status”之外有任何共享键。</li><li id="e8a7" class="ly lz iq kt b ku mh kx mi la mj le mk li ml lm md me mf mg bi translated">“正在加载”属性已从所有状态中删除，因为“状态”字段使其变得多余。这在下一个代码示例中更有意义。</li></ol><p id="d59b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们想要访问这些属性，我们只需确保通过事先检查状态字段来缩小类型。这也很好，因为<code class="fe mq mr ms lo b">status</code>字段也作为类型的标签，使代码更具可读性。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="ce41" class="ls lt iq lo b gy lu lv l lw lx">{viewState.status === 'loading' &amp;&amp; (<br/>  ❗️ viewState type narrowed to ⏳ <em class="mp">Loading</em> <em class="mp">state here</em><br/>  &lt;Loading loadingSince={viewState.loadingSince} /&gt;<br/>)}</span><span id="69db" class="ls lt iq lo b gy mo lv l lw lx">{viewState.status === <em class="mp">'done'</em> &amp;&amp; (<br/>  ❗️ viewState type narrowed to ✅ <em class="mp">Done</em> <em class="mp">state here<br/>  </em>&lt;<em class="mp">MovieList</em> <em class="mp">movies</em>={viewState.searchResults} /&gt;<br/>)}</span><span id="950e" class="ls lt iq lo b gy mo lv l lw lx">{viewState.status === <em class="mp">'error'</em> &amp;&amp; (<br/>  ❗️ viewState type narrowed to 🚨 <em class="mp">Error</em> <em class="mp">state here</em><br/>  &lt;<em class="mp">ErrorMessageUI</em> <em class="mp">error</em>={viewState.error} /&gt;<br/>)}</span></pre><p id="9974" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能已经注意到，在缩小类型后，我们不再需要检查<code class="fe mq mr ms lo b">viewState.searchResults</code>和<code class="fe mq mr ms lo b">viewState.error</code>上的<code class="fe mq mr ms lo b">null</code>。这可以为我们节省许多不必要的检查，当我们在union类型的给定成员上有许多关联值时尤其有用！🎉</p><p id="3429" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是它的整体外观:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">状态为联合类型，带有用于类型缩小的标识键</figcaption></figure><p id="8406" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于Typescript联合，还有很多需要探索的地方。实际上你会注意到很多库使用了联合类型和类型收缩，包括<a class="ae nt" href="https://github.com/async-library/react-async" rel="noopener ugc nofollow" target="_blank"> react-async </a>和<a class="ae nt" href="https://github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank"> redux </a>。</p><p id="b980" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前就这些。希望这有所帮助！👋</p></div></div>    
</body>
</html>