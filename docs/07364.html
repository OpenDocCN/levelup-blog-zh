<html>
<head>
<title>SQL Server: Column Encryption Using Asymmetric Keys</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL Server:使用非对称密钥的列加密</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sql-server-column-encryption-using-asymmetric-keys-fa9ea1bd69ea?source=collection_archive---------6-----------------------#2021-02-12">https://levelup.gitconnected.com/sql-server-column-encryption-using-asymmetric-keys-fa9ea1bd69ea?source=collection_archive---------6-----------------------#2021-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2076" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SQL Server可以使用对称密钥来加密列，但是这种方法安全性较低。在本文中，我们展示了如何使用非对称密钥在SQL Server中实现列加密，并保护用户的关键核心隐私数据列。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5263883de95228505f5474075769f3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KHD38mw5dxBuUUol"/></div></div></figure><h1 id="078f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">不对称加密过程</h1><p id="bdbc" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">与对称加密不同，非对称加密使用不同的密钥进行加密和解密。用于加密的密钥称为公钥，用于解密的密钥称为私钥。不对称加密提供了更好的安全性。下图显示了不对称加密过程:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/5d3fa7e77d5547fe1885176589068fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tbhTrUZNn8AsLjNY.png"/></div></div></figure><p id="3549" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不对称加密过程如下:</p><ol class=""><li id="8342" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">数据接收者首先创建私钥和公钥，然后将公钥发送给数据发送者(图中未显示)。</li><li id="cae7" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">数据发送方使用公钥将明文加密成密文。</li><li id="1041" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">发送方通过网络将密文发送给接收方。</li><li id="e082" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">接收方接收密文，并使用私钥解密数据以获得最终的明文数据。</li></ol><p id="9ddc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在非对称加密过程中，私钥不通过网络传递。因此，私钥不会被窃取，提供了更高的安全性。</p><h1 id="297e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实现非对称密钥列加密</h1><p id="6efb" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">下一节详细描述了如何使用非对称加密在SQL Server中实现列加密。</p><p id="bdd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SQL Server 2005或更高版本通过使用对称密钥和非对称密钥来支持列加密。以下部分解释了使用非对称密钥加密手机号码的具体实现步骤和过程。</p><h1 id="5cf0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建测试数据库</h1><p id="2c8e" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">创建一个名为<code class="fe ms mt mu mv b">TestDatabase</code>的专用测试数据库。</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="6baf" class="na lb it mv b gy nb nc l nd ne">-- Step 1 ¨C Create MSSQL sample database<br/>USE master<br/>GO<br/>IF DB_ID('TestDatabase') IS NOT NULL<br/>    DROP DATABASE [TestDatabase]<br/>GO</span><span id="7701" class="na lb it mv b gy nf nc l nd ne">CREATE DATABASE [TestDatabase];<br/>GO</span></pre><h1 id="c8cf" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建一个测试表</h1><p id="c944" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在<code class="fe ms mt mu mv b">TestDatabase</code>中，创建一个名为EmployeeInfo的专用测试表</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="d319" class="na lb it mv b gy nb nc l nd ne">-- Step 2 ¨C Create Test Table, Initialize data &amp; verify<br/>USE [TestDatabase]<br/>GO<br/>IF OBJECT_ID('dbo.<!-- -->EmployeeInfo<!-- -->', 'U') IS NOT NULL<br/>    DROP TABLE dbo.<!-- -->EmployeeInfo</span><span id="f62a" class="na lb it mv b gy nf nc l nd ne">CREATE TABLE dbo.<!-- -->EmployeeInfo<br/>(<br/>Employee<!-- -->Id     INT IDENTITY(10000,1)   NOT NULL PRIMARY KEY,<br/>Employee<!-- -->Name   VARCHAR(100)            NOT NULL,<br/>Employee<!-- -->Phone  CHAR(11)                NOT NULL<br/>);</span><span id="3d34" class="na lb it mv b gy nf nc l nd ne">-- Initialize Table<br/>INSERT INTO dbo.<!-- -->EmployeeInfo<br/>VALUES ('Batman','13402872514')<br/>,('Superman','13880674722')<br/>,('Flash','13487759293')<br/>GO</span><span id="90be" class="na lb it mv b gy nf nc l nd ne">-- Verify data<br/>SELECT * <br/>FROM dbo.<!-- -->EmployeeInfo<br/>GO</span></pre><p id="534e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在原始数据中，用户电话号码以明文形式存储，这意味着任何有权访问表数据的人都可以获得电话号码，如下所示:</p><h1 id="6051" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建实例级主密钥</h1><p id="4591" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在SQL Server数据库中的实例级别创建主密钥(在Master数据库下使用CREATE MASTER KEY语句):</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="c7c2" class="na lb it mv b gy nb nc l nd ne">-- Step 3 ¨C Create SQL Server Service Master Key<br/>USE master;<br/>GO<br/>IF NOT EXISTS(<br/>    SELECT *<br/>    FROM sys.symmetric_keys<br/>    WHERE name = '##MS_ServiceMasterKey##')<br/>BEGIN<br/>    CREATE MASTER KEY ENCRYPTION BY <br/>    PASSWORD = 'MSSQLSerivceMasterKey'<br/>END;<br/>GO</span></pre><h1 id="fd0a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建数据库级主密钥</h1><p id="ab75" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在用户数据库中的TestDatabase下，创建主密钥:</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="63f0" class="na lb it mv b gy nb nc l nd ne">-- Step 4 ¨C Create MSSQL Database level master key<br/>USE [TestDatabase]<br/>GO<br/>IF NOT EXISTS (SELECT * <br/>                FROM sys.symmetric_keys <br/>                WHERE name LIKE '%MS_DatabaseMasterKey%')<br/>BEGIN        <br/>    CREATE MASTER KEY ENCRYPTION BY PASSWORD =   'TestDatabaseMasterKey@3*';<br/>END<br/>GO</span></pre><h1 id="8845" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建非对称密钥</h1><p id="3ee7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在用户数据库下，创建非对称密钥并用密码加密它们:</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="c0c2" class="na lb it mv b gy nb nc l nd ne">-- Step 5 ¨C Create MSSQL Symmetric Key<br/>USE [TestDatabase]<br/>GO<br/>IF NOT EXISTS (SELECT * <br/>                FROM sys.asymmetric_keys <br/>                WHERE name = 'AsymKey_TestDatabase')<br/>BEGIN<br/>    CREATE ASYMMETRIC KEY AsymKey_TestDatabase<br/>    WITH ALGORITHM = <!-- -->RSA_2048<br/>    ENCRYPTION BY PASSWORD = 'Password4@Asy'<br/>    ;<br/>END<br/>GO</span></pre><h1 id="41e1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">查看非对称密钥</h1><p id="2c62" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">您可以使用以下查询语句来查看非对称密钥:</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="3a0f" class="na lb it mv b gy nb nc l nd ne">USE [TestDatabase]<br/>GO</span><span id="0321" class="na lb it mv b gy nf nc l nd ne">SELECT *<br/>FROM  sys.asymmetric_keys</span></pre><p id="d0f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/7a04334fd5973ca45f74748da97607c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQFEQ0D2h2bUBp3Gb_DL8g.png"/></div></div></figure><h1 id="c724" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">修改表格结构</h1><p id="be32" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">接下来，我们需要修改稳定结构并添加一个varbinary(max)类型的新列，用于存储加密的电话号码密文(假设我们将新列命名为“EncryptedEmployeePhone”)。</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="7d23" class="na lb it mv b gy nb nc l nd ne">-- Step 6 ¨C Change your table structure<br/>USE [TestDatabase]<br/>GO <br/>ALTER TABLE EmployeeInfo <br/>ADD EncryptedEmployeePhone varbinary(MAX) NULL<br/>GO</span></pre><h1 id="a129" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">初始化新列中的数据</h1><p id="5ea3" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">添加新列后，我们将表的EmployeePhone列中的存档数据加密为密文，并将其存储在新列EncryptedEmployeePhone中。为此，我们使用EncryptByAsymKey函数来加密EmployeePhone列，如以下语句所示:</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="023b" class="na lb it mv b gy nb nc l nd ne">-- Step 7 ¨C init the encrypted data into the newly column<br/>USE [TestDatabase]<br/>GO</span><span id="21a3" class="na lb it mv b gy nf nc l nd ne">UPDATE E<br/>SET EncryptedEmployeePhone= ENCRYPTBYASYMKEY(ASYMKEY_ID('AsymKey_TestDatabase'), EmployeePhone)<br/>FROM dbo.EmployeeInfo AS E;<br/>GO</span><span id="8c29" class="na lb it mv b gy nf nc l nd ne">-- Double-check the encrypted data of the new column<br/>SELECT * FROM dbo.EmployeeInfo</span></pre><p id="a8d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，表中<code class="fe ms mt mu mv b">EncryptedEmployeePhone</code>列的数据在使用非对称密钥加密后，变成了<code class="fe ms mt mu mv b">EmployeePhone</code>列的密文数据。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/95c93eac9ff1d8f9fe64c48fedc3aad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*2v-PxXB14Z7aw6mmtfC6_w.png"/></div></figure><h1 id="c694" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">查看加密数据</h1><p id="42d4" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">将电话号码加密成密文后，我们需要使用DecryptByAsymKey函数将其解密成明文。让我们看看能否成功解密EncryptedEmployeePhone字段。</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="5835" class="na lb it mv b gy nb nc l nd ne">-- Step 8 ¨C Reading the SQL Server encrypted data<br/>USE [TestDatabase]<br/>GO</span><span id="ed55" class="na lb it mv b gy nf nc l nd ne">-- Now, it is time to list the original phone number, encrypted phone number, and decrypted phone number.<br/>SELECT <br/>    *,<br/>    DecryptedEmployeePhone = CONVERT(CHAR(11), DECRYPTBYASYMKEY(ASYMKEY_ID('AsymKey_TestDatabase'), EncryptedEmployeePhone, N'Password4@Asy'))<br/>FROM dbo.<!-- -->Employee<!-- -->Info;<br/>GO</span></pre><p id="cff0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该查询语句显示了以下结果，其中EmployeePhone列和DecryptedEmployeePhone列中的数据相同，表明加密和解密成功。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ni"><img src="../Images/f7e93dfc22c8ac219e28f38dcc71b02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kg2gg2v3rPmeQWA4oParg.png"/></div></div></figure><h1 id="6668" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">添加新数据</h1><p id="4d72" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">既然加密和解密后归档的数据是相同的，让我们看看如果添加新数据会发生什么:</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="6f5b" class="na lb it mv b gy nb nc l nd ne">-- Step 9 ¨C What if we add a new record to the table.<br/>USE [<!-- -->TestDatabase<!-- -->]<br/>GO</span><span id="8782" class="na lb it mv b gy nf nc l nd ne">-- Performs the update of the record<br/>INSERT INTO dbo.<!-- -->EmployeeInfo<!-- -->(<!-- -->Employee<!-- -->Name, <!-- -->Employee<!-- -->Phone, Encrypted<!-- -->Employee<!-- -->Phone)<br/>VALUES ('WonderWomen', '13880975623', ENCRYPTBYASYMKEY( ASYMKEY_ID('<!-- -->AsymKey_TestDatabase<!-- -->'), '13880975623'));  <br/>GO</span></pre><h1 id="9f00" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">更新电话号码</h1><p id="9a33" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">现在，我们尝试更新用户电话号码:</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="3f81" class="na lb it mv b gy nb nc l nd ne">-- Step 10 ¨C So, what if we update the phone number<br/>USE [<!-- -->TestDatabase<!-- -->]<br/>GO</span><span id="21c3" class="na lb it mv b gy nf nc l nd ne">-- Performs the update of the record<br/>UPDATE E<br/>SET EncryptedEmployeePhone = ENCRYPTBYASYMKEY( ASYMKEY_ID('AsymKey_<!-- -->TestDatabase<!-- -->'), '13880971234')<br/>FROM dbo.EmployeeInfo AS E<br/>WHERE CONVERT(CHAR(11), DECRYPTBYASYMKEY(ASYMKEY_ID('AsymKey_<!-- -->TestDatabase<!-- -->'), EncryptedEmployeePhone, N'Password4@Asy')) = '13880975623'<br/>GO</span></pre><h1 id="32be" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">删除电话号码明文列</h1><p id="af3c" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">假设一切按预期进行，我们可以删除明文电话号码列“EmployeePhone”:</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="e201" class="na lb it mv b gy nb nc l nd ne">-- Step 11 ¨C Remove old column<br/>USE [TestDatabase]<br/>GO <br/>ALTER TABLE EmployeeInfo<br/>DROP COLUMN EmployeePhone;<br/>GO</span><span id="ab83" class="na lb it mv b gy nf nc l nd ne">SELECT <br/>    *,<br/>    DecryptedEmployeePhone = CONVERT(CHAR(11), DECRYPTBYASYMKEY(ASYMKEY_ID('AsymKey_TestDatabase'), EncryptedEmployeePhone, N'Password4@Asy'))<br/>FROM dbo.EmployeeInfo<br/>GO</span></pre><p id="8f34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/db4d4aa92cf8f80742aff72e9ec0fb61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*Y7UUNlRq4j59vr0lB4alZQ.png"/></div></figure><p id="6491" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">存档的数据、新添加的数据、更新的数据，一切都按预期进行。理论上，这篇文章可以到此为止。然而，还有两个问题。新创建的用户可以访问表数据吗？如果没有，我们如何授予新用户对表数据的访问权限？</p><h1 id="b95b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">添加新用户</h1><p id="3e08" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">假设我们添加了一个名为EncryptedDbUser的新用户:</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="1fcf" class="na lb it mv b gy nb nc l nd ne">-- Step 12 ¨C Create a new user and access the encrypted data<br/>USE [TestDatabase]<br/>GO <br/>CREATE LOGIN EncryptedDbUser<br/>WITH PASSWORD=N'EncryptedDbo@3*', CHECK_POLICY = OFF;<br/>GO</span><span id="7ec3" class="na lb it mv b gy nf nc l nd ne">CREATE USER EncryptedDbUser FOR LOGIN EncryptedDbUser;</span><span id="a60e" class="na lb it mv b gy nf nc l nd ne">GRANT SELECT ON OBJECT::dbo.EmployeeInfo TO EncryptedDbUser;<br/>GO</span></pre><h1 id="a1f3" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">作为新用户查询数据</h1><p id="4d45" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们使用新创建的用户并在SSMS打开一个新的连接来查询数据:</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="b73b" class="na lb it mv b gy nb nc l nd ne">-- Step 13 ¨C OPEN a new connection query window using the new user and query data <br/>USE [TestDatabase]<br/>GO</span><span id="bebd" class="na lb it mv b gy nf nc l nd ne">SELECT<br/>*,<br/>DecryptedEmployeePhone = CONVERT(CHAR(11), DECRYPTBYASYMKEY(ASYMKEY_ID('AsymKey_TestDatabase'), EncryptedEmployeePhone, N'Password4@Asy'))<br/>FROM dbo.EmployeeInfo<br/>GO</span></pre><p id="c0c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此新用户无法成功解密EncryptedEmployeePhone。DecryptedEmployeePhone字段的解密值为空。这意味着新用户无法明文查看用户电话号码，防止未知用户获取此类核心数据。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nk"><img src="../Images/3d6e54aa42b31b4b154ddd559dcc4cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4C6FYgzrwnm4CnVzZLFkA.png"/></div></div></figure><h1 id="2475" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">向新用户授予权限</h1><p id="00ed" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">新添加的用户无权查看加密列。要授予新添加的用户查看加密列中数据的权限，我们可以使用以下语句:</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="4c87" class="na lb it mv b gy nb nc l nd ne">--Step 14 ¨C Grant permissions to <!-- -->EncryptedDbUser<br/>USE [TestDatabase]<br/>GO</span><span id="cea3" class="na lb it mv b gy nf nc l nd ne">GRANT VIEW DEFINITION ON <br/>    ASYMMETRIC KEY::[AsymKey_TestDatabase] TO [<!-- -->EncryptedDbUser<!-- -->];<br/>GO<br/>GRANT CONTROL ON <br/>    ASYMMETRIC KEY::[AsymKey_TestDatabase] TO [<!-- -->EncryptedDbUser<!-- -->];<br/>GO</span></pre><h1 id="1c35" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">作为新用户再次查询数据</h1><p id="31a7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">授予所需的权限后，如果新用户运行“以新用户身份查询数据”一节中的查询语句，则该用户可以获得加密列中的明文数据。</p><pre class="kp kq kr ks gt mw mv mx my aw mz bi"><span id="464c" class="na lb it mv b gy nb nc l nd ne">-- Step 13 ¨C OPEN a new connection query window using the new user and query data <br/>USE [TestDatabase]<br/>GO</span><span id="6fc2" class="na lb it mv b gy nf nc l nd ne">SELECT<br/>*,<br/>DecryptedEmployeePhone = CONVERT(CHAR(11), DECRYPTBYASYMKEY(ASYMKEY_ID('AsymKey_TestDatabase'), EncryptedEmployeePhone, N'Password4@Asy'))<br/>FROM dbo.EmployeeInfo<br/>GO</span></pre><p id="82ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个查询的结果如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/efeaa43891f3e920829c0ead10090c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*CggkF4pTciNkJirnmIVdBw.png"/></div></figure><h1 id="b1dc" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="8585" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我希望我能够展示非对称加密是如何工作的，以及SQL Server是如何通过使用非对称密钥保护用户核心数据来实现列加密的。</p></div></div>    
</body>
</html>