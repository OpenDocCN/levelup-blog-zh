# 我重写了这 10 多行 JavaScript 代码，团队领导称赞这些代码非常优雅

> 原文：<https://levelup.gitconnected.com/i-re-wrote-these-10-single-lines-of-javascript-code-the-team-lead-praised-the-code-for-being-668ade4fea71>

![](img/6b3a6ef8ed1507f0ba55b850afa7ffe9.png)

这不是一个阶段，妈妈。

我是团队领导，我称赞代码。/s

这篇文章是对 Zard-x 在 Medium 上写的名为“[的博客文章的回应，但绝不是挖苦，我写了这 10+行 JavaScript 代码；团队领导称赞代码优雅](https://javascript.plainenglish.io/i-wrote-these-10-single-lines-of-javascript-code-the-team-lead-praised-the-code-for-being-elegant-6a9c471a9613)。

一行程序确实是很酷的挑战，而且制作起来非常有趣。我曾经花了很多时间在 codewars.com 的[和 codingame.com 的](http://codewars.com/)和[这两个网站上，这两个网站促进了小的编码挑战，挑战你写短代码或快速写代码的能力。](http://codingame.com/)

虽然 code golf 可以作为一种有趣的工程实践，但他们的经验应该很少在现实世界中使用——即使在现实世界中使用，工程经理也绝不应该鼓励开发人员在代码库中使用这种类型的代码。当你在一个协作的环境中，写好代码应该是优先考虑的事情。这意味着代码是可读的，可维护的，运行可靠的。

> *Code golf 是一种娱乐性的计算机编程竞赛，参赛者努力获得解决某个问题的最短源代码。*
> 
> —维基百科，代码高尔夫

# 阵列重复数据消除

## 原始源代码

我并不反对通过实例化和传播一个集合来从数组中删除重复项的常见技巧，但是由于索引数组的次数太多，这样做的性能会很差。

## 重写的源代码

在由 1-100 之间的 1，000，000 个随机生成的数字组成的数组中，原始源代码的执行速度只有重写版本的 12%。因为我们在第二个函数中使用了 map，所以我们只需要在数组上迭代一次，这样检查是否已经看到了一个元素就需要 O(1)时间。

代码消除了“技巧”，取而代之的是哈希映射等众所周知的概念，这可能会减少其他开发人员对您代码的查询。代码也有很好命名的变量，用函数名`removeDuplicateStrings`定义函数正在做的动作，而不是像`uniqueArr`这样模棱两可的名字，它也没有使用过度缩写的单词，使代码更容易被非英语母语的人理解。

请注意，该函数没有记录。过多的文档有时可能是一件坏事。如果您的变量名命名良好，您可能会发现您的注释是多余的，这是一件好事！如果发生这种情况，高兴地放弃他们，并运送它！

如果我们绝对坚持使用 spread 操作符和集合，或者我们希望在不编写臃肿的功能的情况下删除不完全是字符串的值的重复，我们需要做的就是记录我们的代码，并确保我们的变量命名良好。

# 从 URL 获取参数并将它们转换为对象

## 原始源代码

如果这段代码有问题，当你发现这就是你要做的函数时，你会有多兴奋？可能性不大。更不用说用字符串重新构建 JSON 对象是您希望尽可能避免的事情，在这种情况下，这很容易。

## 重写的源代码

在为这个函数重写的代码中，我们使用了方便的本地 JavaScript URL API，它自动为我们调用 URLSearchParams 对象的一个实例，然后我们简单地对结果对象使用`Object#fromEntries`函数！这使我们不必通过混合和混淆字符串来手动构造 JSON 对象。

注意，我们已经为这个函数提供了一个注释！尽管我已经在函数名`getURLParameters`中包含了函数处理哪个**类型**参数的规范，但不一定清楚结果对象会是什么格式。

# 检查对象是否为空

## 原始源代码

当检查对象是否为空时，使用 ownKeys 或 Object.keys 都不是很有效。

## 重写的源代码

这种重写的代码是一种古老的方法，人类已经通过了时间的考验！重写的源代码比原来的方法执行速度快 20 倍，而且这只是针对一个对象的两个属性。性能提升来自于您不再需要创建数组、复制值和索引键。你看到一个键，你已经逃离了功能！

我们迭代对象的键的原因可能不是很明显，所以我们在这里留了一个简短的注释，以确保其他开发人员知道发生了什么。

# 反转绳子

## 原始源代码

在这种情况下，我们没有一个坏的开始！我们*可以*使用 for 循环在短字符串上获得 80%的性能提升，如果我们经常反转一些粗字符串，我们可能会考虑实现该方法，但在轻量级字符串上进行奇数反转的情况下，我们可能会更好地利用该功能。

## 重写的源代码

将链接的方法拆分成多行是我的个人偏好，因为它允许我扫描函数路径而不是跳过它们，但是如果有人要求我改变它，我不会大惊小怪。

为了好玩，这里有一个更高性能的版本。

# 生成随机十六进制

## 原始源代码

再说一次，开局不错！我特别喜欢我们直接引用非 alpha 颜色支持的最大十六进制值！稍微清理一下，我们就可以营业了！

## 重写的源代码

在这个例子中，我所做的唯一主要改变是将`padEnd`改为`padStart`。这个函数的工作方式是生成一个随机的 24 位整数，然后用它的十六进制格式表示。

我们能得到的最小值是 0 `0x000000`，最大值是 16777215`0xFFFFFF`。

假设我们的`randomValue`最终是 255。我们的`hexValue`将会是`ff`，如果我们填充了结尾，我们的返回值将会是`#ff0000`，反之，如果我们填充了开头，返回值将会是`#0000ff`。如果我们将这两个值都转换回整数，`#ff0000`将实际表示值 16，711，680，而`#0000ff`将表示 255。这意味着如果我们填充的是结尾而不是开头，我们实际上会得到错误的值。

除此之外，使用第一种方法，通过填充结尾而不是开头，`#0000ff`实际上不可能生成。这意味着有大量不可能生成的缺失值。具体来说，`0x000001`和`0x100000`之间的每个值。我们的函数中有 1，048，576 个缺失值，但也有利于所有以 0 结尾的值，有些值比其他值多。例如，`#100000`将是来自`0x1`、`0x10`、`0x100`、`0x1000`、`0x10000`的结果，当然还有`0x100000`。

# 结论

这花了比预期更长的时间，所以我会在晚些时候发布这篇博客的第二部分。我从重构这段代码中获得了很多乐趣。你会做些不同的事情吗？在[中](https://medium.com/@ridafkih/i-re-wrote-these-10-single-lines-of-javascript-code-the-team-lead-praised-the-code-for-being-668ade4fea71)或 [dev.to](https://dev.to/rida/i-re-wrote-these-10-single-lines-of-javascript-code-the-team-lead-praised-the-code-for-being-elegant-ec) 发表评论！我认为这对每个人来说都是一个很好的学习机会，我很重视所有的反馈！

想看更多我的东西吗？你可以看看我的[个人网站](https://rida.dev/)。如果你想开始一段对话，请随意发微博给我。