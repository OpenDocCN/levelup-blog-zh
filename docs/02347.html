<html>
<head>
<title>React: useEffect Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应:使用简化的效果</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-useeffect-simplified-8166fa71ea08?source=collection_archive---------8-----------------------#2020-03-07">https://levelup.gitconnected.com/react-useeffect-simplified-8166fa71ea08?source=collection_archive---------8-----------------------#2020-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="17fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">功能生命周期和可变观察</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/558230ad0b8f838dde8ae0356c959fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_qzHkzHRoYF3xjIJ"/></div></div></figure><p id="8d96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">得出了<a class="ae lq" href="https://medium.com/javascript-in-plain-english/functional-components-are-better-d6a889175b67" rel="noopener">功能组件更好</a>的结论后，让我们明确一点:钩子使得函数像类一样功能齐全。钩子以一种逐渐被接受的方式运送货物。</p><p id="6a02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你需要生命周期回调时，你可以使用useEffect。</p><p id="9b03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前缀“use”是React钩子的约定。这个想法是，这个钩子将允许我们分享“副作用”。</p><p id="d6bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在函数式编程中，纯函数是只接收参数并返回值的函数。在函数本身之外引起变化——或者依赖非参数输入——被称为伴随<em class="lr">副作用</em>。</p><p id="2257" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，也许不是合伙，但是总的想法是纯函数对于它们的IO和依赖关系是清楚的，并且有助于保持代码可理解。</p><p id="e6eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是有时候，你<em class="lr">需要</em>副作用。</p><p id="5234" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">useEffect的基本目的是允许React的渲染引擎到达我们的函数内部并启动一些动作，以产生一些效果。</p><p id="0b88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用Effect有四个基本功能:</p><ul class=""><li id="1861" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">当组件呈现时做一些事情</li><li id="e53c" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">当组件呈现时做一些事情——但只是第一次</li><li id="80b0" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">当一个特定的变量更新时做一些事情</li><li id="3b45" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">当组件卸载时执行一些操作，例如清理</li></ul><p id="8467" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这四个都是通过相同的语法实现的:导入useEffect，然后用一个函数作为第一个参数来调用它。如果它返回一个函数，它就清除副作用。如果有第二个参数，它是一个数组，指定要观察哪些变量来触发效果—如果数组为空，则仅在初始渲染时调用该函数。</p><p id="eb9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像这样:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="f0c1" class="ml mm it mh b gy mn mo l mp mq">import React, { useEffect } from “react”;<br/>useEffect(() =&gt; { <br/>  /* do work */<br/>  /*optional cleanup */ return () =&gt; {} <br/>)}, /*optional*/ [/*0-N array members])</span></pre><p id="bdc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以盯着它看一会儿。它包含了类生命周期钩子给我们的一切，没有混淆didMount、willMount和isThinkingAboutMounting。</p><h1 id="2876" class="mr mm it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">在初始渲染时运行一次</h1><p id="acf9" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">假设您想在组件第一次呈现时运行一些东西。在本例中，我们将开始一个时间间隔—它可以是服务订阅或诸如此类的内容。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="da05" class="ml mm it mh b gy mn mo l mp mq">useEffect(() =&gt; {<br/>  setInterval(function(){<br/>    console.info("Another second has slipped into the past.");    <br/>    // This code contains a flaw! See the clean-up version below<br/> },1000);<br/>}, []);</span></pre><p id="6aad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，上面的代码并不复杂，但是它包含了useEffect动物中最神秘的部分:作为第二个参数的空数组。</p><p id="e685" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这告诉效果只在第一次渲染时运行它<em class="lr">。如果第二个参数根本不存在，那么react将在每次渲染时调用效果。也就是说，即使在滚动输入或与输入交互并检测到需要部分渲染时。</em></p><h1 id="8e28" class="mr mm it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">打扫</h1><p id="6888" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">正如评论中提到的:这个效果需要清理。想象一下，如果用户离开组件，然后返回。间隔可以很容易地仍然活着，你可以产生大量的他们。这可不好。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="2477" class="ml mm it mh b gy mn mo l mp mq">useEffect(() =&gt; {<br/>  const interval = setInterval(function(){<br/>    console.info("Another second has slipped into the past.");    <br/> },1000);<br/> return () =&gt; {<br/>   clearInterval(interval);<br/> }<br/>}, []);</span></pre><p id="0164" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">叹气。有时候，在一个程序员的生活中，事情就这样走到了一起，在一个美好的时刻，简单和有用的东西对齐了。看上面就是其中之一。</p><p id="f617" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">多亏了JavaScript的词法作用域和useEffect语法，我们可以在一个地方定义一切:时间、内容和清理。</p><h1 id="9cc1" class="mr mm it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">瞄准(观察)一个变量</h1><p id="bc2d" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">现在，我们可能只想在某个值被更新时执行我们的效果。比方说，每当功能组件的属性发生变化时，我们都希望执行一个操作。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="4ca3" class="ml mm it mh b gy mn mo l mp mq">const MyComponent = (props) =&gt; {<br/>  useEffect(() =&gt; {<br/>    console.info("OK, it was updated: " + props.anImportantVar);<br/>  }, [props.anImportantVar]);<br/>}</span></pre><p id="da94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，这是一个相当强大的反应性安排，被压缩到一个小语法中。您可以从中获得一些非常强大的基于事件的组件行为。</p><p id="d910" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以将此视为一种挂钩到反应式引擎并导致您需要的任何额外行为的方式。(当然，直接修改属性值除外。)</p><p id="ce81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结合<a class="ae lq" href="https://medium.com/javascript-in-plain-english/react-dead-simple-component-communication-4582c0cb18c1" rel="noopener">功能道具</a>你可以连接一些非常干净和强大的组件间反应行为。</p><p id="51a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相同的变量监视可以应用于通过useState钩子管理的状态。</p><p id="1285" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用变量监视特性时，请记住，您需要包含函数使用的所有变量<em class="lr">，否则它可能会对过时的值进行操作。</em></p></div></div>    
</body>
</html>