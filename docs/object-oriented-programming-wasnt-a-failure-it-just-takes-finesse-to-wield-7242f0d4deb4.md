# 面向对象编程并没有失败；只是需要技巧来运用

> 原文：<https://levelup.gitconnected.com/object-oriented-programming-wasnt-a-failure-it-just-takes-finesse-to-wield-7242f0d4deb4>

## 这种技巧不是偶然发现的

![](img/d7cb14a07790e61b1c228648ff2ea7d5.png)

截图由作者提供

大约 10 年前，我的一个同事曾经说过 Javascript 将会超越软件开发行业。服务器、应用程序、3D 游戏，都将由 Javascript 编写。我当时对这个想法嗤之以鼻，被我职业生涯早期被教导的骄傲蒙蔽了双眼，即 Web 开发人员与计算机程序员不同。事实证明，他没有错，但我确实错了。Javascript 赢得了它不太可能的位置(考虑到它的根源)，导致我们的行业发生了不可否认的重大转变——它是否会变得更好取决于你，但我认为对于我们所有直接或间接受益于它的人来说,*是*。

与这一成功并行的是，虽然更为古老，但函数式编程在最近几年变得炙手可热。它的一些支持者可能认为面向对象编程不是作为一种范例失败了，就是在软件工程中制造了比它所解决的更多的问题——并且许多支持这种观点的个人论点是相当有效的。不难承认，函数式编程的优点在这么长时间后仍然适用，尤其是在 OOP 未能实现的地方。

这两个以上的运动结合在一起，正在重新挑战我们思考编程语言的方式，以及它们支持或完全围绕其构建的范例。请注意，我使用了*运动*这个词，而不是*趋势*，因为虽然目前是趋势，但现在发生的变化才是标准。

对于大多数人来说，我是一个面向对象的程序员，但是我不会站在哪一边，因为这不应该是一场*我们对他们*的辩论；所有的工具都有它们的用途，你可以在当前的环境下使用最适合你的工具——只要你不是那种“我有一把锤子，一切都是钉子”的类型。不管你站在围栏的哪一边，OOP 仍然会存在很多年，并且可以成为一个伟大的生产力的工具——如果你能做好的话——但是我们大多数人不能。

> ..在为你的产品构建自动化基础设施时，有时你并不真的想去考虑 OOP 和对象…

大约 20 年前，我的大学 C++课程导师曾说过，如果你能以他所教的水平学习 C++，你可以用任何语言编程，因为没有语言比这更难。我不是他是否正确的权威，但是 10 多种语言之后，我没有证明他是错的。

在许多人眼里，C++是面向对象编程语言的缩影。当然，可能仍然有一些 Objective-C 纯粹主义者会说 Objective-C 是更好的 OO 方法，因为它只在大约 30 个关键字的 ANSI C 语言中添加了 6 个关键字，同时借鉴了 Smalltalk。问问合适的 C 程序员，他们会说你可以用 structs 来做 OOP。

OOP 语言有很多种，但是基于 C 的语言是我能说的最聪明的。如果你想用 Perl 来做，请自便。我只能简单地谈谈具有良好 OOP 支持的解释语言，比如 Python 和 Ruby，但是除了一些例外，这些语言更适合我作为工具来编写函数驱动的脚本。例如，在为你的产品构建自动化基础设施时，有时你并不真的想去想 OOP 和对象；你只是想要可重用的函数来完成工作。

纯 OOP 语言，比如 Java，在很多方面都很好，并且带来了很多好处，但是总有一些东西阻止我热爱 Java。我永远不会给它与我所尊敬的 C#同样的赞美，因为它的语法和作为一门现代语言的成熟。如果你全力投入 OOP，像这样的语言是很棒的。相反，一些语言(如 Dart)的追随者可能会强调对 OOP 和 FP 的支持，允许您选择哪种范式适合手头的任务。

> ..实现接口而不是关注继承。

后来，斯威夫特进来了。同样，你可以用它做函数式和面向对象的编程，但是他们真的在推动面向协议的编程，起初我认为“太好了，另一个[咒骂]范例”。事实证明，如果我理解正确的话，这确实是 OO 程序员应该一直在实践的——实现接口而不是专注于继承。

这位同事(他看到了 Javascript 的出现)曾经告诉我“为了代码重用而继承是邪恶的”，以及“新的关键字是邪恶的”，还有其他我当时认为极端的观点。我从未真正理解他的意思，直到一年后我学会了如何在日常工作中应用坚实的原则和 MVC。它改变了我的一切。

> ..这几乎发生在每一个有过重大贡献的面向对象程序员身上。

在学习 SOLID 和 MVC 之前，你只是像平常一样，日复一日地从事你的编程生涯。有时你会看到类或整个项目变得不可维护，有些部分简直是一场噩梦，但是你永远看不到全局，看不到所有的点。当然，你可以重构一些类，做一些事后看来有点不同的事情，但是你不能指出所有的多重问题是如何与方法和架构从一开始就注定失败的事实相关联的。

这太常见了。我可以想象，几乎每一个参与过大型项目的面向对象程序员都会遇到这种情况。如果你现在知道了 SOLID，但在你开始 OOP 的时候不知道，那么你就知道我在说什么了。

> ..几乎所有的反模式一开始看起来都足够无辜。

这是怎么发生的？好吧，当你把一个强大而危险的工具给一个没有经过正确训练的人使用时，他们一定会造成附带伤害。您可以学习编程语言的所有规则，但是对于普通人来说，这些规则不足以编写出优秀的、持久的可维护代码。

这一点，以及后果在编写代码时并不总是显而易见的事实；几乎所有的反模式一开始看起来都足够无辜。如果你不知道要注意什么，我想你可以说 OOP 是一个反模式的推动者。问题不在于容易出错，而是在你试图维护代码之前，你不知道代码出错了。

这是为什么呢？因为与工程的其他学科(可能受到物理世界法则的约束)不同，软件工程是非常开放的，几乎没有限制——没有什么是非法的，除了语法错误和……非法字符:)，但你甚至可以绕过它。

> ..2020 年使用现代语言的 OO 程序员仍然在重复几十年前犯的同样的错误。

真的是编程语言或范式的错吗？也许吧，但这也是人类的问题。让我们随心所欲地建造，我们就能制造混乱。有趣的是，每个人都独立地陷入同样的困境，而避免常见错误所需的深谋远虑和谨慎必须被教会。

所以从技术上来说，固体和其他模式已经存在了大约 20 年。然而，2020 年使用现代语言的 OO 程序员仍然在重复几十年前犯的同样的错误。这可能是因为许多适用于大多数 OOP 语言的伟大概念并没有作为 OOP 的标准来教授。我们教人们更多如何构建*工作*代码，不知何故如何构建*持久*代码仍然是个秘密——尽管一切都是众所周知的。

有没有你想分享的原则或模式改变了你对 OOP 的看法，或者让你成为一个更好的程序员？你认为每个 OO 程序员都应该知道什么？请在评论区分享。