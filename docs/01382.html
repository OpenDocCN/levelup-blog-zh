<html>
<head>
<title>How to Set Up a Back End Project Using TypeScript and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用TypeScript和Node.js设置后端项目</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-set-up-a-back-end-project-using-typescript-and-node-js-c245fc09e0a2?source=collection_archive---------9-----------------------#2019-12-19">https://levelup.gitconnected.com/how-to-set-up-a-back-end-project-using-typescript-and-node-js-c245fc09e0a2?source=collection_archive---------9-----------------------#2019-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/becdd5985a76b7770d36e46cc5e1904a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qayvzPLEmHImiCWd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@sashafreemind?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨莎·弗里明德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="187f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用TypeScript构建一个后端应用启动器，将其编译为JavaScript(ES2019)，并将其部署到Heroku。</p><p id="8409" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用:</p><ul class=""><li id="61c8" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">Node.js 12</li><li id="1343" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">express:node . js的Web框架</li></ul><p id="3f64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">源代码:<a class="ae kf" href="https://github.com/d-dmytro/my-typescript-app" rel="noopener ugc nofollow" target="_blank">d-dmy tro/my-typescript-app</a></p><p id="3e1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们为项目创建一个文件夹:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a5eb" class="mb mc it lx b gy md me l mf mg">mkdir my-typescript-app<br/>cd my-typescript-app</span></pre><p id="8caa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行<code class="fe mh mi mj lx b">npm init</code>在这个文件夹中创建package.json文件。我已经为选项选择了默认值。</p><p id="5906" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们安装TypeScript和Node.js的类型作为开发依赖项。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="f200" class="mb mc it lx b gy md me l mf mg">npm i -D typescript @types/node@12</span></pre><p id="6d8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我安装了Node.js 12的类型，因为这是我在这个项目中使用的版本。如果您使用的是不同的版本，请将“12”替换为您的版本号(例如<code class="fe mh mi mj lx b">@types/node@13</code>)。</p><p id="ba69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将源文件(TS文件)存储在“src”文件夹中。所以，让我们来创造它。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="0caa" class="mb mc it lx b gy md me l mf mg">mkdir src</span></pre><p id="22b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们应该配置TypeScript编译器，以便它根据我们的需要编译我们的代码。</p><p id="00fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在项目的根目录下创建tsconfig.json文件，复制并粘贴以下代码:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4789" class="mb mc it lx b gy md me l mf mg">{<br/>  "compilerOptions": {<br/>    "target": "es2019",<br/>    "module": "commonjs",<br/>    "moduleResolution": "node",<br/>    "outDir": "dist",<br/>    "strict": true,<br/>    "esModuleInterop": true<br/>  },<br/>  "include": ["src/**/*"]<br/>}</span></pre><p id="d53a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj lx b">target</code>选项来设置ECMAScript的版本，我们希望我们的类型脚本代码被编译到这个版本中。我选择“es2019”是因为Node.js 12支持它。你可以在<a class="ae kf" href="https://node.green" rel="noopener ugc nofollow" target="_blank"> https://node.green </a>网站上查看Node.js各版本支持什么。</p><p id="defb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj lx b">module</code>选项告诉TypeScript编译器在编译的文件中应该使用哪个模块系统。Node.js使用了CommonJS模块系统，所以我把“module”选项设置为“commonjs”。</p><p id="997a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj lx b">moduleResolution</code>选项告诉编译器如何解析模块。我将该选项设置为“node ”,因为我们使用的是Node.js。因此，当编译器看到导入语句时，它会像Node一样解析导入。</p><p id="0cd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj lx b">outDir</code>选项告诉编译器在哪里存储输出。我想把它存储在相对于我们项目根目录的“dist”文件夹中。</p><p id="2eed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe mh mi mj lx b">strict</code>选项设置为“true ”,以便启用严格的类型检查。这个选项使编码变得有点困难，但是我们编写的代码变得更加安全。您很快就会习惯这个选项，它肯定会提高代码库的质量。</p><p id="acc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj lx b">esModuleInterop</code>选项支持TypeScript的模块(es模块)和CommonJS模块之间的互操作性。之前，我们不得不使用一种变通方法，使用<code class="fe mh mi mj lx b">import * as express from ‘express’</code>语法将CommonJS模块导入到一个变量中。启用此选项后，我们可以导入CommonJS模块，就像我们在es项目中所做的一样:<code class="fe mh mi mj lx b">import express from ‘express’</code>。</p><p id="4190" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们使用<code class="fe mh mi mj lx b">include</code>选项列出我们想要编译的文件。这个选项允许我们使用类似glob的模式来指定文件。值“src/* */<em class="mk">* *</em>表示“src”文件夹中的任何子文件夹和任何TypeScript文件。您可以在这里阅读有关此选项和其他包含/排除文件的方法的更多信息:<a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#examples" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/ts config-JSON . html # examples</a></p><p id="c042" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在“src”文件夹中创建“index.ts”文件，复制并粘贴以下代码:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6d52" class="mb mc it lx b gy md me l mf mg">import express from 'express';<br/><br/>const port = 3000;<br/>const app = express();<br/><br/>app.get('/', (_req, res) =&gt; {<br/>  res.end('Hello World!');<br/>});<br/><br/>app.listen(port, (err: Error) =&gt; {<br/>  if (err) throw err;<br/>  console.log(`Ready on port ${port}`);<br/>});</span></pre><p id="be72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此代码在端口3000上启动express应用程序。你可以在<a class="ae kf" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>访问它</p><p id="6abf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们安装express:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="f940" class="mb mc it lx b gy md me l mf mg">npm i -S express</span></pre><p id="dc60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Express不包含类型定义，所以我们将从第三方类型存储库中安装它们，名为DefinitelyTyped:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1b78" class="mb mc it lx b gy md me l mf mg">npm i -D @types/express</span></pre><p id="5695" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们运行TypeScript编译器来编译我们的应用程序。为此，将“构建”脚本添加到“package.json”中。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a95e" class="mb mc it lx b gy md me l mf mg">"scripts": {<br/>  "build": "tsc"<br/>}</span></pre><p id="b62d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们运行脚本:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4f84" class="mb mc it lx b gy md me l mf mg">npm run build</span></pre><p id="602c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">npm将运行编译器二进制文件(tsc)。编译器读取我们的“tsconfig.json”并编译我们的应用程序。</p><p id="ced7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将“start”脚本添加到“package.json”来运行编译后的应用程序。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="ac33" class="mb mc it lx b gy md me l mf mg">"scripts": {<br/>  "start": "NODE_ENV=production node dist/index.js"<br/>}</span></pre><p id="5c5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以启动应用程序了:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="7fc4" class="mb mc it lx b gy md me l mf mg">npm start</span></pre><p id="f264" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>的浏览器中访问它</p><p id="32b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在目前的设置下，每次我们编辑代码时，我们都必须手动编译并重启应用程序。</p><p id="ecee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就开发者体验而言，这不是我们所期望的。因此，让我们在开发过程中自动执行编译和重启任务。</p><p id="0757" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在“监视”模式下运行TypeScript编译器。它将观察我们的源文件的变化，并在我们保存它们时重新编译它们。</p><p id="5493" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用Nodemon运行编译后的“dist/index.js ”,而不是直接使用Node。Nodemon也会监视我们的文件的变化。当我们保存一个文件时，它将重新启动我们的脚本。</p><p id="75c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在“监视”模式下运行编译器，我们使用以下命令:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2565" class="mb mc it lx b gy md me l mf mg">npx tsc -w</span></pre><p id="b759" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们安装Nodemon:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c90e" class="mb mc it lx b gy md me l mf mg">npm i -D nodemon</span></pre><p id="1ebe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用Nodemon运行我们的应用程序:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="21db" class="mb mc it lx b gy md me l mf mg">npx nodemon dist/index.js</span></pre><p id="b513" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，Nodemon监视当前文件夹中的所有文件。我们不希望它监视所有文件，因为“src”文件夹是由编译器监视的，如果我们将文件保存在“src”文件夹中，Nodemon将重新启动应用程序，编译器将编译文件并触摸“dist”文件夹，Nodemon将再次重新启动应用程序。所以，我们会有一次不必要的重启。</p><p id="63c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，我们应该使用Nodemon的"-w "选项来告诉它应该监视哪些文件。让我们使用这个选项让Nodemon只监视“dist”文件夹。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="3644" class="mb mc it lx b gy md me l mf mg">npx nodemon -w dist dist/index.js</span></pre><p id="a15f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，为了达到我们想要的开发体验，我们应该一起运行编译器和Nodemon。为了做到这一点，我们可以使用名为“并发”的NPM包。</p><p id="71e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们安装它:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="9855" class="mb mc it lx b gy md me l mf mg">npm i -D concurrently</span></pre><p id="564b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并发接受多个命令，一起运行它们并管理它们的进程。</p><p id="37bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们一起运行tsc和nodemon:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a1ec" class="mb mc it lx b gy md me l mf mg">npx concurrently -k -n COMPILER,NODEMON -c gray,blue "tsc -w" "nodemon -w dist dist/index.js"</span></pre><p id="ea4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“-k”选项告诉并发地杀死它启动的所有进程，如果其中一个进程死亡的话。</p><p id="7a1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“-n”选项标记我们启动的进程的输出。</p><p id="c561" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“-c”选项设置每个进程输出的颜色。</p><p id="2d75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">打开" src/index.ts "，把" Hello World！"字符串到其他东西，并在浏览器中重新加载应用程序的标签。您应该会立即看到新的字符串。</p><p id="b9b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们将命令添加到“package.json”中的“dev”脚本中:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="37e9" class="mb mc it lx b gy md me l mf mg">"scripts": {<br/>  "dev": "concurrently -k -n COMPILER,NODEMON -c gray,blue \"tsc -w\" \"nodemon -w dist dist/index.js\""<br/>}</span></pre><p id="8a09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就这样，你得到了一个简单的web应用后端项目，你可以用它来开发你的web应用的API。</p><h1 id="ac7e" class="ml mc it bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">添加HTML模板</h1><p id="b7ca" class="pw-post-body-paragraph kg kh it ki b kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">我们将为我们的视图使用<a class="ae kf" href="https://www.npmjs.com/package/ejs" rel="noopener ugc nofollow" target="_blank"> ejs </a>模板引擎。</p><p id="915c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们安装ejs:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="9c27" class="mb mc it lx b gy md me l mf mg">npm i -S ejs</span></pre><p id="128e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将HTML模板存储在“视图”文件夹中(这是Express应用程序的默认设置):</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4189" class="mb mc it lx b gy md me l mf mg">mkdir views</span></pre><p id="e8d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建索引视图:“views/index.ejs”</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="cd2e" class="mb mc it lx b gy md me l mf mg">&lt;h1&gt;&lt;%= greeting %&gt;&lt;/h1&gt;</span></pre><p id="5e88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们在索引路由上渲染一下(" src/index.ts "):</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="cf61" class="mb mc it lx b gy md me l mf mg">// Tell Express to use ejs to render views.<br/>app.set('view engine', 'ejs');<br/><br/>app.get('/', (\_req, res) =&gt; {<br/>  res.render('index', {<br/>    greeting: 'Hello World!'<br/>  });<br/>});</span></pre><h1 id="304f" class="ml mc it bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">部署到Heroku</h1><p id="86d0" class="pw-post-body-paragraph kg kh it ki b kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">首先，你要有一个Heroku账号和Heroku CLI。请看一下如何在他们的网站上安装Heroku CLI:<a class="ae kf" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank">https://devcenter.heroku.com/articles/heroku-cli</a></p><p id="0561" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要将应用程序部署到Heroku，我们应该将代码添加到git repo中。</p><p id="4a61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在应用程序的文件夹中，让我们运行:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4975" class="mb mc it lx b gy md me l mf mg">git init</span></pre><p id="0520" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们加上这个”。gitignore "文件来避免在回购中提交我们不需要的东西:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c065" class="mb mc it lx b gy md me l mf mg">dist<br/>node_modules<br/>npm-debug.log<br/>.DS_Store</span></pre><p id="5af5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将Heroku的“引擎”设置添加到“package.json”中:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1673" class="mb mc it lx b gy md me l mf mg">"engines": {<br/>  "node": "12.x"<br/>}</span></pre><p id="81ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Heroku使用“PORT”env变量告诉我们的应用程序应该监听哪个端口。让我们打开“src/index.ts ”,将定义端口号的那一行改为:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="655a" class="mb mc it lx b gy md me l mf mg">const port = parseInt(process.env.PORT, 10) || 3000;</span></pre><p id="a8c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们提交代码:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="ca65" class="mb mc it lx b gy md me l mf mg">git add .<br/>git commit -m "Starter code"</span></pre><p id="6fbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">登录Heroku:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6822" class="mb mc it lx b gy md me l mf mg">heroku login</span></pre><p id="6e50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Heroku创建应用程序:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="3c7e" class="mb mc it lx b gy md me l mf mg">heroku create</span></pre><p id="d89e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将在您的heroku帐户中创建应用程序，并将名为“Heroku”的git遥控器添加到我们的repo中。当我们将一些东西推送到这个遥控器时，Heroku将部署应用程序。那么，让我们部署我们的应用程序:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2aea" class="mb mc it lx b gy md me l mf mg">git push heroku master</span></pre><p id="a249" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行<code class="fe mh mi mj lx b">heroku open</code>在浏览器中打开您的应用程序。</p><p id="4099" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请在这里找到更多关于将Node.js应用程序部署到Heroku的信息:<a class="ae kf" href="https://devcenter.heroku.com/articles/deploying-nodejs" rel="noopener ugc nofollow" target="_blank">https://devcenter.heroku.com/articles/deploying-nodejs</a></p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="5f70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mk">原载于</em><a class="ae kf" href="https://dd.engineering/blog/how-to-set-up-a-back-end-project-using-typescript-and-node-js" rel="noopener ugc nofollow" target="_blank"><em class="mk">https://DD . engineering</em></a><em class="mk">。</em></p></div></div>    
</body>
</html>