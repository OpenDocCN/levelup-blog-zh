<html>
<head>
<title>Organizing Projects Into a MonoRepo with Gradle Build Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Gradle构建管理将项目组织成一个MonoRepo</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/organizing-projects-into-a-monorepo-with-gradle-build-management-53b499cdb21f?source=collection_archive---------1-----------------------#2021-07-02">https://levelup.gitconnected.com/organizing-projects-into-a-monorepo-with-gradle-build-management-53b499cdb21f?source=collection_archive---------1-----------------------#2021-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1509" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">促进跨多个团队和项目的可见性和标准化！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eda392eef4844ed0cc99b39591eafc9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*79CJOl625gvpE4ck"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从<a class="ae ky" href="https://images.unsplash.com/photo-1611047606025-a74bfb5eeb30?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1778&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="77f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> C </span>将项目组合成一个单一的<strong class="lb iu">单一存储库</strong>已经成为软件工程中的一个新兴趋势，这对开发人员的工作流程有着广泛的好处。当您听到术语MonoRepo时，您可能会想到具有高度耦合服务的可怕的整体架构——但这与MonoRepo毫无关系！整体存储库是一种将多个项目整合到单个代码库中的方法，以便为任何参与团队共享依赖关系和标准化项目工作流。</p><p id="3c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论MonoRepo的一些特征和权衡，并展示一个真实的例子。我们还将介绍使用Gradle标准化构建过程背后的思考过程。最后，你可能会发现MonoRepo非常适合你自己的项目！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b4cd" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">单回购结构</h1><p id="d6b6" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">一个完整的存储库不需要遵守任何严格的标准。在很大程度上，如何组织他们的项目完全取决于你自己的开发团队。MonoRepo的一个主要优点是，您不必在将不同的项目加载到您的IDE中、筛选多个合并请求(MR)位置之间转换，或者拥有负责共享依赖项的独立项目。相反，一切都在一个地方，以增加组织和便利！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f5986c0d22e5f15341a9b01621b3c259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k5HQzsQgvuNXqSrc.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://engineering.brigad.co/react-native-monorepos-code-sharing-f6c08172b417" rel="noopener ugc nofollow" target="_blank"> Brigad工程博客</a>。</figcaption></figure><h2 id="8b8c" class="nj mm it bd mn nk nl dn mr nm nn dp mv li no np mx lm nq nr mz lq ns nt nb nu bi translated">一个简单的打字稿例子</h2><p id="71c7" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">让我们从一个由两个基于TypeScript的项目组成的MonoRepo示例开始。您可以使用<a class="ae ky" href="https://lerna.js.org/#getting-started" rel="noopener ugc nofollow" target="_blank"> Lerna </a>或<a class="ae ky" href="https://classic.yarnpkg.com/en/docs/workspaces/" rel="noopener ugc nofollow" target="_blank"> yarn工作空间</a>来创建MonoRepo结构，并根据它们之间的依赖关系对包进行符号链接。从头开始设置你自己的MonoRepo将需要额外的计划来链接你的依赖项，所以上面的工具可能更适合你。这是一个用Lerna和yarn制作的MonoRepo示例:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="8c26" class="nj mm it nw b gy oa ob l oc od">&lt;Your Awesome Team Name&gt;<br/>├── package.json<br/>├── packages<br/>│   ├── app-web/<br/>│   │   ├── package.json<br/>│   │   ├── src/<br/>│   │   │   └── index.ts<br/>│   │   │   └── tsconfig.json<br/>│   │   ├── test/<br/>│   │   │   └── test.spec.ts<br/>│   │   │   └── tsconfig.json<br/>│   │   ├── tsconfig.build.json<br/>│   │   └── tsconfig.json<br/>│   ├── app-ios/<br/>│   │   ├── package.json<br/>│   │   ├── src/<br/>│   │   │   └── index.ts<br/>│   │   │   └── tsconfig.json<br/>│   │   ├── test/<br/>│   │   │   └── test.spec.ts<br/>│   │   │   └── tsconfig.json<br/>│   │   ├── tsconfig.build.json<br/>│   │   └── tsconfig.json<br/>├── tsconfig.build.json<br/>└── tsconfig.json</span></pre><p id="f977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有在<code class="fe oe of og nw b">app-web</code>和<code class="fe oe of og nw b">app-ios</code>中使用的服务，您可以将这两个包链接到一个<code class="fe oe of og nw b">dependencies</code>包中，以获得额外的模块化。您不仅合并了项目，而且还标准化了结构，以便您的团队成员可以更容易地在包之间转换。</p><h2 id="423b" class="nj mm it bd mn nk nl dn mr nm nn dp mv li no np mx lm nq nr mz lq ns nt nb nu bi translated">真实世界的例子</h2><p id="19d7" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">MonoRepos正在整个科技领域获得牵引力，甚至在谷歌和脸书等大型科技公司也是如此。事实上，谷歌的MonoRepos可以包含数百万行代码的万亿字节数据。我在一个专注于用户帐户和服务端点的团队中工作，我们的技术堆栈由多个在Go中编写的微服务和几个Angular项目组成。下面是我们使用的一般基础设施:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="3df4" class="nj mm it nw b gy oa ob l oc od">Mobile Services<br/>├── &lt;project_name&gt;/<br/>│   └── &lt;service_name&gt;/<br/>│       ├── cmd/<br/>│       │   └── main.go<br/>│       ├── internal/<br/>│       │   ├── config/<br/>│       │   │   └── settings.go<br/>│       │   │   └── settings_test.go<br/>│       │   ├── endpoints/<br/>│       │   │   └── endpoints.go<br/>│       │   │   └── endpoints_test.go<br/>│       │   ├── service/<br/>│       │   │   └── service.go<br/>│       │   │   └── service_test.go<br/>│       │   └── transport/<br/>│       │       ├── grpc/<br/>│       │       └── http/<br/>│       ├── .gitlab-ci.yml<br/>│       ├── build.gradle.kts<br/>│       ├── Dockerfile<br/>│       ├── gradle.properties<br/>│       ├── settings.gradle.kts<br/>│       └── &lt;service_name&gt;.proto<br/>├── infra/<br/>├── setup/<br/>│   ├── gradle.rb<br/>│   └── README.md<br/>├── shared/<br/>│   └── golang/<br/>│       └── &lt;library_name&gt;/<br/>├── tools/<br/>│   └── plugins/<br/>│       └── &lt;PluginName&gt;/<br/>├── .gitignore<br/>├── .gitlab-ci.yml<br/>├── .golangci.yml<br/>├── go.mod<br/>├── go.sum<br/>└── README.md</span></pre><p id="8fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种结构允许我们的团队拥有由多个服务组成的更大的项目。我们不包括Angular项目的指南，因为那些已经标准化了。相反，我们对每个基于Go的服务都有一个可复制的结构，它由<code class="fe oe of og nw b">cmd</code>中的主要源代码和<code class="fe oe of og nw b">config</code>中的版本控制组成。我们还使用<a class="ae ky" href="https://github.com/go-kit/kit" rel="noopener ugc nofollow" target="_blank"> go-kit </a>来帮助构建每个微服务，并将<code class="fe oe of og nw b">http</code>功能添加到传输层。</p><p id="6913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个MonoRepo设计还有很多可以提高我们团队总体生产力的地方。我们有一个<code class="fe oe of og nw b">setup</code>文件夹，其中包含一个Gradle公式来安装我们想要的特定版本，此外还有一个<code class="fe oe of og nw b">README.md</code>用于开发人员入职。还有共享的Go库，甚至还有一个包含我们用Kotlin编写的自定义Gradle插件的<code class="fe oe of og nw b">tools</code>文件夹。例如，我们有插件来标准化跨项目的Go <code class="fe oe of og nw b">build</code>、<code class="fe oe of og nw b">test</code>和<code class="fe oe of og nw b">lint</code>任务。说到Gradle，我们已经在每个服务中整合了一个构建脚本来自动化我们的构建和任务系统，但是在下一节中会有更多的介绍。</p><p id="0922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们为CI/CD准备了顶级git配置文件，如<code class="fe oe of og nw b">.gitignore</code>和<code class="fe oe of og nw b">.gitlab-ci.yml</code>。根级别也有用于版本控制的<code class="fe oe of og nw b">go.mod</code>和<code class="fe oe of og nw b">go.sum</code>以及用于一般回购文档的顶级<code class="fe oe of og nw b">README.md</code>。一切都是可见的，可以很容易地转移到一个简化的开发人员工作流程中！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="deaa" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">Gradle构建管理+ Kotlin DSL</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/92abc0cff6bfa9dc93759329c3f91daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zS8jzkWgXbVPlcX7.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.lordcodes.com/assets/img/articles/kotlin-gradle.png" rel="noopener ugc nofollow" target="_blank"> LordCodes博客</a></figcaption></figure><p id="f8f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在管理构建和部署过程时，一个基本的解决方案包括在shell脚本中运行连续的命令，或者将构建逻辑封装到服务本身中。然而，shell脚本正在变得过时，因为它们变得越来越难以扩展和维护——尤其是在项目相互依赖的情况下。Gradle是一个灵活的构建管理工具，它极大地提高了标准化项目构建过程的能力。</p><blockquote class="oi oj ok"><p id="5b7c" class="kz la ol lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated">例如，假设您有一个包含框架和语言组合的MonoRepo。您不必记住每个工具的客户端命令，而是可以在每个项目中创建一个Gradle任务。这样，您可以转换到任何项目，并简单地运行<code class="fe oe of og nw b">gradle test</code>来查看该项目当前的代码覆盖率——但是为什么要就此打住呢？您也可以使用Gradle来标准化每个项目是如何构建、链接的，甚至是如何使用Gradle众多插件中的一个来组合多个docker容器。</p></blockquote><p id="d51d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以扩展这一策略，以保持与CI/CD渠道的对等性！理想情况下，无论您的环境如何，您都可以运行gradle test之类的基本任务。如果每个环境都需要特定的配置，您可以很容易地在任务中反映出来。以Docker为例，您可能希望拥有单独的任务<code class="fe oe of og nw b">dockerBuildLocal</code>或<code class="fe oe of og nw b">dockerBuildPipeline</code>，以便进行特定的标记、推送等。封装在每个任务中。</p><p id="3fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几个更好的Gradle插件:</p><ul class=""><li id="1064" class="op oq it lb b lc ld lf lg li or lm os lq ot lu ou ov ow ox bi translated"><a class="ae ky" href="https://github.com/palantir/gradle-docker" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> palantir </strong> </a> —为Docker添加基本的可配置任务，如构建图像、标记、推送、运行容器等。</li><li id="fc73" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><a class="ae ky" href="https://github.com/avast/gradle-docker-compose-plugin" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> avast </strong> </a> —简化<a class="ae ky" href="https://www.docker.com/docker-compose" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>在<a class="ae ky" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>环境中的本地开发和集成测试的使用。</li><li id="1a63" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><a class="ae ky" href="https://github.com/tcawley/gradle-protobuf-plugin" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">gradle-proto buf-plugin</strong></a>—<a class="ae ky" href="http://gradle.org/" rel="noopener ugc nofollow" target="_blank">Gradle</a>插件，用于在您的Gradle项目中使用<a class="ae ky" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank"> Google协议缓冲区</a>。</li><li id="baa1" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><a class="ae ky" href="https://github.com/noamt/rest-gradle-plugin" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">rest-gradle-plugin</strong></a>—一个Gradle插件，提供一个任务基础设施来执行REST请求</li><li id="d193" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><a class="ae ky" href="https://github.com/classmethod/gradle-aws-plugin" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">gradle-aws-plugin</strong></a>—管理S3、EC2、Lambda等AWS资源的Gradle插件。</li></ul><p id="9f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看到更多令人敬畏的Gradle插件，请查看这个Git repo:</p><div class="pd pe gp gr pf pg"><a href="https://github.com/ksoichiro/awesome-gradle" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">ksoichiro/awesome-gradle</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">一个令人敬畏的Gradle插件和资源的精选列表，用于更好的开发工作流自动化。灵感来自…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">github.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ks pg"/></div></div></a></div></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b0a3" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">MonoRepo利弊</h1><p id="e6b2" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">像任何设计模式一样，为了确定某个策略是否适合您的团队，必须考虑一些权衡。首先，确保您的项目和包从一开始就是松散耦合的，这是一个好主意。在MonoRepos的情况下，仍然有缺点，可能太多，以至于无法将您的项目整合到一个单一的代码库中。以下是将MonoRepo整合到您的基础架构中的一些主要利弊:</p><h2 id="6402" class="nj mm it bd mn nk nl dn mr nm nn dp mv li no np mx lm nq nr mz lq ns nt nb nu bi translated"><strong class="ak">优点:</strong></h2><ul class=""><li id="3e44" class="op oq it lb b lc nd lf ne li pv lm pw lq px lu ou ov ow ox bi translated"><strong class="lb iu">更好的可见性和协作</strong>—您团队的所有合并请求都可以在单个项目中找到。此外，您不必为了一个特性变化(如新的API集成)而跨多个位置工作。相反，你可以打开MonoRepo，并留在MonoRepo！</li><li id="69f5" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">单一的可重用代码库</strong>——保持项目间的依赖和模块共享是一个巨大的性能提升。指出代码的味道和识别重复的逻辑会更容易，因为每个项目都在另一个项目的旁边。</li><li id="68a3" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">大规模代码重构</strong>——由于依赖关系在整个代码库中被充分利用，我们可以进行一个单独的更改，并在所有的包中反映这些更改，这再次提高了开发人员的速度。</li></ul><h2 id="e922" class="nj mm it bd mn nk nl dn mr nm nn dp mv li no np mx lm nq nr mz lq ns nt nb nu bi translated"><strong class="ak">缺点:</strong></h2><ul class=""><li id="dd3a" class="op oq it lb b lc nd lf ne li pv lm pw lq px lu ou ov ow ox bi translated"><strong class="lb iu"> CI/CD管道</strong> —如此多的项目和如此大的代码库，很难组织一个有效的管道构建结构。一个最初的解决方案是调整您的版本控制系统(VCS ),只为已经被更改或更新的项目运行CI/CD。</li><li id="8693" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu"> VCS工具挑战</strong>——说到版本控制，对于像Git这样的文件跟踪系统来说，MonoRepo可能是一项艰巨的任务。仔细考虑需要在系统中跟踪什么是很重要的，否则会陷入节点模块的疯狂。</li><li id="3e94" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">访问控制的限制</strong> —你可能不希望每个工程师都能访问每个项目。在这种情况下，如果您想为您的团队维护一个MonoRepo结构，您可能需要更复杂的权限系统。</li></ul><p id="540a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，我认为MonoRepos在适当的情况下具有显著的优势，值得研究。每个团队和组织都是不同的，所以当然要仔细考虑利弊，才能做出最终决定。然而，MonoRepos在统一和标准化项目以提高跨团队的可见性和生产力方面提供了巨大的好处。你对MonoRepos有什么看法？</p></div></div>    
</body>
</html>