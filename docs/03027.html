<html>
<head>
<title>Creating Sequelize Associations with the Sequelize CLI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用序列CLI创建序列关联</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-sequelize-associations-with-the-sequelize-cli-tool-d83caa902233?source=collection_archive---------1-----------------------#2020-04-16">https://levelup.gitconnected.com/creating-sequelize-associations-with-the-sequelize-cli-tool-d83caa902233?source=collection_archive---------1-----------------------#2020-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/021463944331716371fec71e4ce6afef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fygqfizATFjt6ALek2W1jg.png"/></div></div></figure><p id="2fcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Sequelize 是一个流行的、易于使用的JavaScript对象关系映射(ORM)工具，可用于SQL数据库。使用Sequelize CLI 开始一个新项目相当简单，但是要真正利用Sequelize的功能，您需要定义模型之间的关系。</p><p id="6d1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本演练中，我们将建立一个Sequelize项目来为特定用户分配任务。我们将使用关联来定义这种关系，然后探索基于这些关联查询数据库的方法。</p><p id="4d03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从在一个新的项目文件夹中安装Postgres、Sequelize和<a class="ae kw" href="https://github.com/sequelize/cli" rel="noopener ugc nofollow" target="_blank"> Sequelize CLI </a>开始:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b993" class="lg lh iq lc b gy li lj l lk ll">mkdir sequelize-associations<br/>cd sequelize-associations<br/>npm init -y<br/>npm install sequelize pg<br/>npm install --save-dev sequelize-cli</span></pre><p id="cd95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们初始化一个Sequelize项目，然后在代码编辑器中打开整个目录:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2112" class="lg lh iq lc b gy li lj l lk ll">npx sequelize-cli init<br/>code .</span></pre><blockquote class="lm ln lo"><p id="2f80" class="jy jz lp ka b kb kc kd ke kf kg kh ki lq kk kl km lr ko kp kq ls ks kt ku kv ij bi translated">要了解有关以下任何顺序化CLI命令的更多信息，请参见:<br/> <a class="ae kw" href="https://medium.com/@brunopgalvao/getting-started-with-sequelize-cli-c33c797f05c6" rel="noopener"> <strong class="ka ir">顺序化CLI入门</strong> </a></p></blockquote><p id="e426" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们配置我们的Sequelize项目来使用Postgres。在<code class="fe lt lu lv lc b">/config</code>目录中找到<code class="fe lt lu lv lc b">config.json</code>,并用以下代码替换那里的内容:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3ded" class="lg lh iq lc b gy li lj l lk ll">{<br/>  "development": {<br/>    "database": "sequelize_associations_development",<br/>    "host": "127.0.0.1",<br/>    "dialect": "postgres"<br/>  },<br/>  "test": {<br/>    "database": "sequelize_associations_test",<br/>    "host": "127.0.0.1",<br/>    "dialect": "postgres"<br/>  },<br/>  "production": {<br/>    "database": "sequelize_associations_production",<br/>    "host": "127.0.0.1",<br/>    "dialect": "postgres"<br/>  }<br/>}</span></pre><p id="82cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">酷，现在我们可以告诉Sequelize创建数据库:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3166" class="lg lh iq lc b gy li lj l lk ll">npx sequelize-cli db:create</span></pre><p id="0e1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们将从命令行创建一个<code class="fe lt lu lv lc b">User</code>模型:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="8b6c" class="lg lh iq lc b gy li lj l lk ll">npx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string,password:string</span></pre><p id="fd28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe lt lu lv lc b">model:generate</code>会自动创建一个模型文件和一个带有我们指定属性的迁移。您可以在项目目录中找到这些文件，但是现在没有必要更改它们。(稍后，我们将编辑模型文件来定义我们的关联。)</p><p id="c06d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将执行迁移，在数据库中创建<code class="fe lt lu lv lc b">Users</code>表:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="7932" class="lg lh iq lc b gy li lj l lk ll">npx sequelize-cli db:migrate</span></pre><p id="9e46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建一个种子文件:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6c40" class="lg lh iq lc b gy li lj l lk ll">npx sequelize-cli seed:generate --name user</span></pre><p id="46ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将在<code class="fe lt lu lv lc b">/seeders</code>中看到一个新文件。在该文件中，粘贴以下代码以创建一个“John Doe”演示用户:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="0cb4" class="lg lh iq lc b gy li lj l lk ll">module.exports = {<br/>  up: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkInsert('Users', [{<br/>        firstName: 'John',<br/>        lastName: 'Doe',<br/>        email: 'demo@demo.com',<br/>        password: '$321!pass!123$',<br/>        createdAt: new Date(),<br/>        updatedAt: new Date()<br/>      }], {});<br/>  },</span><span id="b544" class="lg lh iq lc b gy lw lj l lk ll">down: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkDelete('Users', null, {});<br/>  }<br/>};</span></pre><p id="41e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们保存了种子文件，让我们执行它:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="ea7f" class="lg lh iq lc b gy li lj l lk ll">npx sequelize-cli db:seed:all</span></pre><p id="4da7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进入<code class="fe lt lu lv lc b">psql</code>并查询数据库，查看<code class="fe lt lu lv lc b">Users</code>表:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="c917" class="lg lh iq lc b gy li lj l lk ll">psql sequelize_associations_development<br/>SELECT * FROM "Users";</span></pre><h1 id="682d" class="lx lh iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">定义关联</h1><p id="9502" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">太好了！我们有一个工作模型，但我们的无名氏似乎有点无聊。让我们通过创建一个<code class="fe lt lu lv lc b">Task</code>模型来给John一些事情做:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4988" class="lg lh iq lc b gy li lj l lk ll">npx sequelize-cli model:generate --name Task --attributes title:string,userId:integer</span></pre><p id="7acc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如上面的<code class="fe lt lu lv lc b">User</code>模型一样，这个Sequelize CLI命令将基于我们指定的属性创建一个模型文件和一个迁移。但是这一次，我们需要编辑两者，以便将我们的模型连接在一起。</p><p id="f05a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，在项目目录的<code class="fe lt lu lv lc b">/models</code>子目录中找到<code class="fe lt lu lv lc b">task.js</code>。这是任务的顺序模型，你会看到<code class="fe lt lu lv lc b">sequelize.define()</code>方法将<code class="fe lt lu lv lc b">title</code>和<code class="fe lt lu lv lc b">userId</code>设置为属性，就像我们上面指定的一样。</p><p id="19fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那下面，你会看到<code class="fe lt lu lv lc b">Task.associate</code>。它目前是空的，但这是我们将每个任务与一个<code class="fe lt lu lv lc b">userId</code>绑定的地方。编辑您的文件，如下所示:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6659" class="lg lh iq lc b gy li lj l lk ll">module.exports = (sequelize, DataTypes) =&gt; {<br/>  const Task = sequelize.define('Task', {<br/>    title: DataTypes.STRING,<br/>    userId: DataTypes.INTEGER<br/>  }, {});<br/>  Task.associate = function(models) {<br/>    // associations can be defined here<br/>    Task.belongsTo(models.User, {<br/>      foreignKey: 'userId',<br/>      onDelete: 'CASCADE'<br/>    })<br/>  };<br/>  return Task;<br/>};</span></pre><p id="f004" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些变化有什么作用？<code class="fe lt lu lv lc b">Task.belongsTo()</code> <a class="ae kw" href="https://sequelize.org/master/class/lib/model.js~Model.html#static-method-belongsTo" rel="noopener ugc nofollow" target="_blank">与<code class="fe lt lu lv lc b">User</code>模型建立了一个“隶属”关系</a>，这意味着每个任务将与一个特定的用户相关联。</p><p id="ed8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过将<code class="fe lt lu lv lc b">userId</code>设置为“外键”，这意味着它引用了另一个模型中的一个键。在我们的模型中，任务必须属于一个用户，因此<code class="fe lt lu lv lc b">userId</code>将对应于特定<code class="fe lt lu lv lc b">User</code>条目中的<code class="fe lt lu lv lc b">id</code>。(<code class="fe lt lu lv lc b">onDelete: 'CASCADE'</code>配置我们的模型，以便如果用户被删除，用户的任务也将被删除。)</p><p id="4dee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要改变我们的<code class="fe lt lu lv lc b">User</code>模型，以反映这种关系的另一面。找到<code class="fe lt lu lv lc b">user.js</code>并更改<code class="fe lt lu lv lc b">User.associate</code>下的部分，使您的文件如下所示:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5b36" class="lg lh iq lc b gy li lj l lk ll">module.exports = (sequelize, DataTypes) =&gt; {<br/>  const User = sequelize.define('User', {<br/>    firstName: DataTypes.STRING,<br/>    lastName: DataTypes.STRING,<br/>    password: DataTypes.STRING,<br/>    email: DataTypes.STRING<br/>  }, {});<br/>  User.associate = function(models) {<br/>    // associations can be defined here<br/>    User.hasMany(models.Task, {<br/>      foreignKey: 'userId',<br/>    })<br/>  };<br/>  return User;<br/>};</span></pre><p id="7406" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个模型，我们已经建立了一个“多”关系，这意味着一个用户可以有多个任务。在<code class="fe lt lu lv lc b">.hasMany()</code>方法中，<code class="fe lt lu lv lc b">foreignKey</code>选项被设置为<em class="lp"> other </em>表上的键的名称。换句话说，当任务上的<code class="fe lt lu lv lc b">userId</code>与用户的<code class="fe lt lu lv lc b">id</code>相同时，我们就有了匹配。</p><p id="fbaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要再做一个更改来在数据库中设置我们的关系。在您项目的<code class="fe lt lu lv lc b">/migrations</code>文件夹中，您应该会看到一个文件名以<code class="fe lt lu lv lc b">create-task.js</code>结尾的文件。更改标记为<code class="fe lt lu lv lc b">userId</code>的对象，使您的文件看起来像下面的代码:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2fd7" class="lg lh iq lc b gy li lj l lk ll">module.exports = {<br/>  up: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.createTable('Tasks', {<br/>      id: {<br/>        allowNull: false,<br/>        autoIncrement: true,<br/>        primaryKey: true,<br/>        type: Sequelize.INTEGER<br/>      },<br/>      title: {<br/>        type: Sequelize.STRING<br/>      },<br/>      userId: {<br/>        type: Sequelize.INTEGER,<br/>        onDelete: 'CASCADE',<br/>        references: {<br/>          model: 'Users',<br/>          key: 'id',<br/>          as: 'userId',<br/>        }<br/>      },<br/>      createdAt: {<br/>        allowNull: false,<br/>        type: Sequelize.DATE<br/>      },<br/>      updatedAt: {<br/>        allowNull: false,<br/>        type: Sequelize.DATE<br/>      }<br/>    });<br/>  },<br/>  down: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.dropTable('Tasks');<br/>  }<br/>};</span></pre><p id="5ebe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lt lu lv lc b">references</code>部分将在我们的数据库中建立<code class="fe lt lu lv lc b">Tasks</code>表，以反映我们上面描述的相同关系。现在我们可以运行我们的迁移了:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5b8b" class="lg lh iq lc b gy li lj l lk ll">npx sequelize-cli db:migrate</span></pre><p id="28e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的John Doe已经准备好接受任务，但是John仍然没有分配任何实际任务。让我们创建一个任务种子文件:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="51f2" class="lg lh iq lc b gy li lj l lk ll">npx sequelize-cli seed:generate --name task</span></pre><p id="f11e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">找到新生成的种子文件并粘贴到以下内容中以创建任务:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3231" class="lg lh iq lc b gy li lj l lk ll">module.exports = {<br/>  up: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkInsert('Tasks', [{<br/>      title: 'Build an app',<br/>      userId: 1,<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    }], {});<br/>  },</span><span id="824e" class="lg lh iq lc b gy lw lj l lk ll">  down: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkDelete('Tasks', null, {});<br/>  }<br/>};</span></pre><p id="6412" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将把<code class="fe lt lu lv lc b">userId</code>设置为<code class="fe lt lu lv lc b">1</code>,这样任务将属于我们之前创建的用户。现在我们可以填充数据库。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="7b81" class="lg lh iq lc b gy li lj l lk ll">npx sequelize-cli db:seed:all</span></pre><p id="8139" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试数据库:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2b41" class="lg lh iq lc b gy li lj l lk ll">psql sequelize_associations_development<br/>SELECT * FROM "Users" JOIN "Tasks" ON "Tasks"."userId" = "Users".id;</span></pre><h1 id="448c" class="lx lh iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">通过序列查询</h1><p id="be60" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">现在，我们可以基于这些关联在数据库中查询信息——通过Sequelize，我们可以使用JavaScript来完成，这使得与Node.js应用程序的集成变得很容易。让我们创建一个文件来保存我们的查询:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="141e" class="lg lh iq lc b gy li lj l lk ll">touch query.js</span></pre><p id="790f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下代码粘贴到新文件中:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="79e3" class="lg lh iq lc b gy li lj l lk ll">const { User, Task } = require('./models')<br/>const Sequelize = require('sequelize');<br/>const Op = Sequelize.Op<br/><br/>// Find all users with their associated tasks<br/>// Raw SQL: SELECT * FROM "Users" JOIN "Tasks" ON "Tasks"."userId" = "Users".id;<br/><br/>const findAllWithTasks = async () =&gt; {<br/>    const users = await User.findAll({<br/>        include: [{<br/>            model: Task<br/>        }]<br/>    });<br/>    console.log("All users with their associated tasks:", JSON.stringify(users, null, 4));<br/>}<br/><br/>const run = async () =&gt; {<br/>    await findAllWithTasks()<br/>    await process.exit()<br/>}<br/><br/>run()</span></pre><p id="0485" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的前三行导入了我们的<code class="fe lt lu lv lc b">User</code>和<code class="fe lt lu lv lc b">Task</code>型号，以及Sequelize。之后，我们包含一个查询函数，返回每个<code class="fe lt lu lv lc b">User</code>以及用户的相关任务。</p><p id="2170" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Sequelize的<code class="fe lt lu lv lc b">.findAll()</code>方法接受选项作为JavaScript对象。上面，我们使用了<code class="fe lt lu lv lc b">include</code>选项来<a class="ae kw" href="https://sequelize.org/master/manual/eager-loading.html" rel="noopener ugc nofollow" target="_blank">利用“急切加载”</a>——同时查询来自多个模型的数据。使用这个选项，Sequelize将返回一个JavaScript对象，该对象包含每个<code class="fe lt lu lv lc b">User</code>以及所有相关联的<code class="fe lt lu lv lc b">Task</code>实例作为嵌套对象。</p><p id="2b4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们运行我们的查询文件来看看实际情况:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3ec7" class="lg lh iq lc b gy li lj l lk ll">node query.js</span></pre><p id="d026" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在很明显我们的无名氏有项目要做了！当我们的查询找到一个<code class="fe lt lu lv lc b">Task</code>时，我们可以使用相同的方法来包含<code class="fe lt lu lv lc b">User</code>。将以下代码粘贴到<code class="fe lt lu lv lc b">query.js</code>中:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b6d9" class="lg lh iq lc b gy li lj l lk ll">// Find a task with its associated user<br/>// Raw SQL: SELECT * FROM "Tasks" JOIN "Users" ON "Users"."id" = "Tasks"."userId";<br/><br/>const findTasksWithUser = async () =&gt; {<br/>    const tasks = await Task.findAll({<br/>        include: [{<br/>            model: User<br/>        }]<br/>    });<br/>    console.log("All tasks with their associated user:", JSON.stringify(tasks, null, 4));<br/>}</span></pre><p id="1c3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过添加一行调用<code class="fe lt lu lv lc b">findTasksWithUser()</code>来修改<code class="fe lt lu lv lc b">query.js</code>底部的<code class="fe lt lu lv lc b">const run</code>。现在在Node中再次运行您的文件——每个<code class="fe lt lu lv lc b">Task</code>应该包含它所属的<code class="fe lt lu lv lc b">User</code>的信息。</p><blockquote class="lm ln lo"><p id="c0a0" class="jy jz lp ka b kb kc kd ke kf kg kh ki lq kk kl km lr ko kp kq ls ks kt ku kv ij bi translated">本演练中的查询使用了<code class="fe lt lu lv lc b">.findAll()</code>方法。要了解更多有关其他顺序化查询的信息，请参见:<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/using-the-sequelize-cli-and-querying-4ba8d0ac4314"> <strong class="ka ir">使用顺序化CLI和查询</strong> </a></p></blockquote><p id="3a4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以在<code class="fe lt lu lv lc b">include</code>旁边包含其他选项，以进行更具体的查询。例如，下面我们将使用<code class="fe lt lu lv lc b">where</code>选项仅查找名为John的用户，同时仍然返回每个用户的相关任务:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3ae9" class="lg lh iq lc b gy li lj l lk ll">// Find all users named John with their associated tasks<br/>// Raw SQL: SELECT * FROM "Users" WHERE firstName = "John" JOIN tasks ON "Tasks"."userId" = "Users".id;</span><span id="5e55" class="lg lh iq lc b gy lw lj l lk ll">const findAllJohnsWithTasks = async () =&gt; {<br/>    const users = await User.findAll({<br/>        where: { firstName: "John" },<br/>        include: [{<br/>            model: Task<br/>        }]<br/>    });<br/>    console.log("All users named John with their associated tasks:", JSON.stringify(users, null, 4));<br/>}</span></pre><p id="9db7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将上述内容粘贴到您的<code class="fe lt lu lv lc b">query.js</code>中，并将<code class="fe lt lu lv lc b">const run</code>更改为调用<code class="fe lt lu lv lc b">findAllJohnsWithTasks()</code>进行尝试。</p><p id="4128" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您已经知道如何在Sequelize中使用模型关联，您可以设计您的应用程序来交付您需要的嵌套数据。对于您的下一步，您可能决定使用Faker  或<a class="ae kw" href="https://medium.com/@brunopgalvao/sequelize-cli-and-express-fb3ddefb9786" rel="noopener"> <strong class="ka ir">将您的Sequelize应用程序与Express </strong> </a>集成以创建Node.js服务器，从而<a class="ae kw" href="https://medium.com/@brunopgalvao/getting-started-with-sequelize-cli-using-faker-824b3f4c4cfe" rel="noopener"> <strong class="ka ir">包含更健壮的种子数据！</strong></a></p><blockquote class="lm ln lo"><p id="a83d" class="jy jz lp ka b kb kc kd ke kf kg kh ki lq kk kl km lr ko kp kq ls ks kt ku kv ij bi translated">本文是与纽约市的软件工程师、编辑和作家杰里米·罗斯(Jeremy Rose)合著的。</p></blockquote><h1 id="617a" class="lx lh iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">有关Sequelize CLI的更多信息:</h1><ul class=""><li id="1793" class="mz na iq ka b kb mu kf mv kj nb kn nc kr nd kv ne nf ng nh bi translated">【Sequelize CLI入门</li><li id="d1e5" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><a class="ae kw" href="https://medium.com/@brunopgalvao/using-the-sequelize-cli-and-querying-4ba8d0ac4314" rel="noopener">使用顺序CLI并查询</a></li><li id="2abd" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><a class="ae kw" href="https://medium.com/@brunopgalvao/sequelize-cli-and-express-fb3ddefb9786" rel="noopener">对CLI和Express进行排序</a></li><li id="1994" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><a class="ae kw" href="https://medium.com/@brunopgalvao/getting-started-with-sequelize-cli-using-faker-824b3f4c4cfe" rel="noopener">使用Faker开始使用Sequelize CLI</a></li><li id="e746" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><a class="ae kw" href="https://medium.com/@brunopgalvao/build-an-express-api-with-sequelize-cli-and-express-router-963b6e274561" rel="noopener">用序列命令行界面和快速路由器构建快速API</a></li><li id="bdb7" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">使用序列CLI和单元测试构建Express API！</li></ul><h1 id="4460" class="lx lh iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">资源</h1><ul class=""><li id="1533" class="mz na iq ka b kb mu kf mv kj nb kn nc kr nd kv ne nf ng nh bi translated"><a class="ae kw" href="https://sequelize.org/master/manual/associations.html" rel="noopener ugc nofollow" target="_blank">https://sequelize.org/master/manual/associations.html</a></li><li id="0452" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><a class="ae kw" href="https://sequelize.org/master/manual/querying.html" rel="noopener ugc nofollow" target="_blank">https://sequelize.org/master/manual/querying.html</a></li></ul></div></div>    
</body>
</html>