<html>
<head>
<title>How to handle blockers in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理Node.js中的拦截器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-handle-blockers-in-node-js-1966d0399703?source=collection_archive---------2-----------------------#2022-07-31">https://levelup.gitconnected.com/how-to-handle-blockers-in-node-js-1966d0399703?source=collection_archive---------2-----------------------#2022-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://medium.com/@ayzrian/why-asynchronous-is-a-trend-c9892667e245" rel="noopener">之前的文章</a>中，我们讨论了异步服务器中的阻塞，它们会降低应用程序的性能。现在是时候学习如何处理它们了。让我们开门见山吧。</p><h2 id="71bd" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">什么是阻断器？</h2><p id="fcbb" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">在我们谈论在你的代码中“处理”一个阻塞之前，我们首先需要识别它。<strong class="jp ir">阻塞程序是一种CPU密集型操作，它会让您的主线程长时间处于忙碌状态。</strong></p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/6cce29f109b9233c827a0cfbd67f7dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jL8oaP6my8xrf-5BN9iT3A.png"/></div></div></figure><p id="5e21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们构建一个例子，我将使用<a class="ae kl" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>来实现。Node.js本质上是异步的。我将启动一个简单的HTTP服务器并创建一个“拦截器”。假设我们将需要找到数字的总和达到1000000000。在我的机器上，计算这个数字大约需要1秒钟。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="2aed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用<a class="ae kl" href="https://github.com/wg/wrk" rel="noopener ugc nofollow" target="_blank"> WRK </a>来测量我们服务器的性能。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ly"><img src="../Images/4f55373b2b01a05f35cb5fdb069b2a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQVraGGBpdUbNzqtfC-WOQ.png"/></div></div></figure><p id="b262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，服务器只能处理1 RPS(每秒请求数)，尽管我们使用10个线程将并发性设置为100个连接。发生这种情况是因为主线程正好被阻塞了一秒钟来处理阻塞程序。</p><p id="6eb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但实际上，我们应该考虑这样一个事实，即大多数时候我们对服务器的请求不会包含“繁重”的代码，所以我实现了一个有两个端点的服务器。一个有阻断器，另一个没有。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="78dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试它，我需要在这两个端点之间传播HTTP请求，所以我编写了一个简单的<a class="ae kl" href="https://www.lua.org/" rel="noopener ugc nofollow" target="_blank"> Lua </a>脚本来定制测试的行为。</p><p id="2293" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每第100个请求将发送到阻塞端点，而其余请求将发送到非阻塞端点。因此，我们1%的请求会有一个阻塞，而其余的则没有。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="46c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看结果。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lz"><img src="../Images/49cec3affbec23b12f0c11d8d9e07eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imyb8Dp_PxkGhn5zY-uLBQ.png"/></div></div></figure><p id="11f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，在这样的负载模型下，我们的服务器可以处理67 RPS。还不错，但是我们绝对可以改进。</p><h2 id="2bf8" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">分割</h2><p id="a0d6" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated"><strong class="jp ir">异步代码背后的主要思想是尽可能快地处理小块代码</strong>。因此，一种选择是将一个阻塞程序分成更小的工作块，这样可以在时间上“分散”工作，在这些小块之间，其他请求将由主线程处理。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ma"><img src="../Images/8da32bc418d715953b0c3928ab067d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byGPmEUyLM4VwnfIw9rEwA.png"/></div></div></figure><p id="9189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们修改我们的代码来“一步一步”地计算结果，我们将需要一个方法来允许我们稍后“调度”我们的工作，在Node.js中我们可以使用两个函数<code class="fe mb mc md me b">setTimeout</code>或<code class="fe mb mc md me b">setImmediate</code>。本文就不说这两个函数的区别了。在我的实现中，我使用的是<code class="fe mb mc md me b">setImmediate</code></p><p id="4cb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你现在所看到的，我们以1000000为单位来计算总数，每次我们做一部分工作，我们就把另一部分工作安排在以后。这样，我们就给了其他请求一些时间。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="428d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用WRK再次测试这个解决方案。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lz"><img src="../Images/097ddb6aca62fb3e9f270b9b139fba80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQADuginTXexl0lxI1ChsQ.png"/></div></div></figure><p id="df37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您现在所见，<strong class="jp ir">RPS的平均数量为156.01，比之前的</strong>提高了大约250%。</p><h2 id="6be5" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">卸下</h2><p id="7519" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">除了分区，你也可以卸载你的拦截器到一个单独的线程。我将使用一个工人池模式来实现卸载，<strong class="jp ir">在一个高层次上，这个想法是有一个任务队列和一个工人池，当他们可以的时候，他们处理每个单独的任务</strong>。</p><p id="e50d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们可以获得更好的结果，因为现在我们实际上是在扩展服务器，因为更多的CPU将处理我们的请求。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mf"><img src="../Images/d2896d544cb2e7d8f9d46ec0e692af04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fljVefxN9xdLrNkoJJkvtw.png"/></div></div></figure><p id="0692" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<a class="ae kl" href="https://www.npmjs.com/package/workerpool" rel="noopener ugc nofollow" target="_blank">工人组</a> NPM模块，因为它易于使用且可靠。如您所见，我们创建了一个池，并将最大工作线程数定义为等于8，因为我的电脑有8个内核，定义超过8个内核将是低效的(您可以在我之前的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/why-asynchronous-is-a-trend-c9892667e245">文章</a>中了解原因)。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="d30f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候再次测试服务器了。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ly"><img src="../Images/f3fc86539261774bd0ee29459003e546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLbOQeQDloMF74pto--rvw.png"/></div></div></figure><p id="4c9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这次我们的服务器<strong class="jp ir">能够提供大约464个RPS，比最初提高了大约710%。由于我们将阻塞器卸载到了一个单独的线程上，主线程有了更多的时间来处理I/O密集型任务。</strong></p><p id="8cca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我们克服了异步服务器中单个线程的限制，但让我们看看是否可以将性能提升到一个新的水平。</p><h2 id="e001" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">好处:缓存+卸载</h2><p id="7f50" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">缓存就像是应用性能的伸缩带，<strong class="jp ir">大约80%的性能优化都是通过缓存实现的</strong>。这个想法是保存我们正在进行的复杂计算的结果，以避免多次执行相同的工作。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mg"><img src="../Images/f3aa1a95923bb3b6204ab5dbd86f8348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34CPgAPw_qJqPCt-5I-iZg.png"/></div></div></figure><p id="98d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了展示这种方法，我将在我们的代码中添加一点随机性，以确保它需要计算不同的数字。这样，我们将模拟更多真实世界的情况。我们将为每个请求生成一个介于100000000和1000001000之间的随机N，并计算其总和。</p><p id="ce25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管在我们的代码中，为了简单起见，我们使用了内存缓存。在生产应用程序中，您应该使用分布式缓存(例如<a class="ae kl" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>)，以便您的所有服务器都使用最新的缓存，并且不执行额外的工作。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="77d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看我们的结果。我将测试持续时间增加到了60秒，因为我们需要更多的时间来生成缓存。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ly"><img src="../Images/d11a5b766e4549b275238aa493aaf7bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15WC7XwNbKTvqAIXnYU7QA.png"/></div></div></figure><p id="f2d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，现在我们能够达到平均488 RPS，但这与之前的结果相比并没有显著的提高。随着时间的推移，缓存的结果是可见的，因为缓存有更多的现金命中。</p><h2 id="d02e" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">摘要</h2><p id="e037" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">与任何其他异步服务器一样，Node.js在I/O(输入/输出)方面表现出色，但在CPU密集型操作方面表现糟糕。您应该注意拦截器，因为它们会降低服务器的性能。</p><p id="057b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">卸载比分区提供更好的性能。此外，有时很难将分区应用到您的计算中。除此之外，卸载提供了更好的扩展方式，因为您可能有单独的机器充当工人。</p><p id="2fb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，缓存几乎总是提高服务器性能的好办法。</p><p id="8c0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，您可以在这个<a class="ae kl" href="https://github.com/Ayzrian/blockers-in-node.js" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到用于本文的源代码。</p><p id="4831" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">下一步是什么？</strong></p><p id="912d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在接下来的几篇文章中，我们将与您讨论:</p><ul class=""><li id="b925" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/streams-and-how-they-fit-into-node-js-async-nature-a08723055a67">流以及它们如何适应Node.js的异步特性。</a></li><li id="1c23" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">如何用AWS SQS建立一个可伸缩的工人池？</li></ul></div></div>    
</body>
</html>