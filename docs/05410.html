<html>
<head>
<title>Immutable health check management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不变的健康检查管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/immutable-health-check-management-35c6102d4ccc?source=collection_archive---------12-----------------------#2020-08-25">https://levelup.gitconnected.com/immutable-health-check-management-35c6102d4ccc?source=collection_archive---------12-----------------------#2020-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="283f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您曾经必须监控应用程序、端点或网站，您可能会遇到数百种监控服务，它们可以从N个全球端点执行简单的基于HTTP的检查，然后在达到特定阈值时通知操作员。其中一个广为人知的服务就是<a class="ae kl" href="https://www.pingdom.com/" rel="noopener ugc nofollow" target="_blank"> Pingdom </a> <em class="km">。</em></p><p id="01a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去的一个项目中，该团队的任务是监控一个由多个底层组件组成的应用程序，每个组件都显示在单个端点FQDN之后，其中各种路径实际上由N个底层应用程序提供服务，每个应用程序要么公开自己的运行状况检查，要么只需返回一个200来指示它们已启动。不幸的是，FQDN和后台应用程序不在任何为健康检查端点提供最基本的内部设施的云平台或orchestrator中。更不用说来自N个全球端点。因此，我们不得不利用第三方外部服务；最后变成了Pingdom。默认情况下，使用Pingdom，创建和管理这些“开箱即用”的健康检查监视器的过程最终会是这样的:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/25ffd6aea105a8026977cb4c7df331a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nPNB6J9CdqCEqMtC"/></div></figure><p id="ae41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，如果您曾经不得不使用这样的监控服务，这并没有什么突破性的:</p><ul class=""><li id="1938" class="kv kw iq jp b jq jr ju jv jy kx kc ky kg kz kk la lb lc ld bi translated">用户认证进入监控应用程序</li><li id="ea6f" class="kv kw iq jp b jq le ju lf jy lg kc lh kg li kk la lb lc ld bi translated">用户在GUI中或通过API调用为N个端点手动配置一个或多个“检查”</li><li id="12bb" class="kv kw iq jp b jq le ju lf jy lg kc lh kg li kk la lb lc ld bi translated">监控平台本身存储这些配置，然后将它们分发给所需的全局监控器</li><li id="cd71" class="kv kw iq jp b jq le ju lf jy lg kc lh kg li kk la lb lc ld bi translated">世界各地的监视器执行检查并向平台报告</li><li id="f06e" class="kv kw iq jp b jq le ju lf jy lg kc lh kg li kk la lb lc ld bi translated">如果达到阈值，就会发出警报。</li></ul><p id="e8e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">手动管理潜在的几十个检查，其中许多共享相似的样板特征是没有吸引力的。</p><p id="7968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该应用程序的监控需要能够适应新的应用程序迭代部署到生产环境中，并逐步向用户推出(即canary版本)。团队不希望在每次需要监控变更或需要监控新版本(在不同的环境中)时都必须手动重新配置(或重新添加)N次检查。相反，该团队希望找到一种方法来管理一个“集”或“组”监视器，并同样从模板中生成这些监视器。其次，这些监视器配置的“集合”应该是不可变的。<em class="km">创建一个新的“检查集”,然后在以后停用任何“检查集”配置。</em></p><p id="3d05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，<a class="ae kl" href="https://docs.pingdom.com/api/" rel="noopener ugc nofollow" target="_blank"> Pingdom提供了一个API </a>和“标记”命名监视器配置的能力。通过“标记”,我们最终可以创建我们想要实现的这些“检查集”的物理表示，并生成新的监视器“集”,并在更高的级别上管理它们…例如，可能更像这样:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/bccb4afc1382172da19b7be3ddd2a752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cr_R53TC3WpIgGDX"/></div></figure><h1 id="2abf" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">走向</h1><p id="6bab" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">在与Pingdom的API 进行了一些争论之后，我最终创建了一个小的<a class="ae kl" href="https://github.com/bitsofinfo/pingdom-check-loader" rel="noopener ugc nofollow" target="_blank">实用程序</a>，它将让一个开发人员<a class="ae kl" href="https://github.com/bitsofinfo/pingdom-check-loader/blob/master/checkconfigs.yaml" rel="noopener ugc nofollow" target="_blank">管理一个YAML检查配置文件</a>，允许创建者定义一些默认的检查行为，然后是一个或多个命名的<em class="km">“站点”，</em>，每个站点包含一个FQDN，然后是一个或多个<em class="km">“路径部分”；</em>其中，<em class="km"> "pathPart" </em>被简单地定义为URI的某个部分，它可以包含一个或多个值，每个值都可以覆盖默认设置中定义的<em class="km">"检查行为"</em>。</p><p id="0a25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，操作者定义一个<em class="km">“checks”</em>部分，该部分定义一个或多个命名的<em class="km">“checks”</em>，每个都支持一个“forEach”指令，该指令可以以嵌套的方式用于为给定的<em class="km">“site”+“path parts”</em>创建完整的URI路径，以生成要检查的唯一URIs。每个生成的检查都标记有一个共享的时间戳标识符以及每个<em class="km">“检查”名称、“站点”和“路径部分”的单独标签；</em>通过标签许可管理。</p><p id="dfcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个ultra basic配置文件看起来像这样，它定义了应该检查“my.app.com”站点的3个路径；由此产生了3个不同的Pingdom检查；每个唯一的“监视器”通过继承的设置来定义其行为。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/29574a1570b54d40c5dd7a20fabe16ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AhfRNqsdAExf7X2q"/></div></figure><p id="cdca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哪个(在模拟运行中)模式生成一组检查，这些检查将通过其API推送到Pingdom，如下所示:</p><pre class="ko kp kq kr gt mm mn mo mp aw mq bi"><span id="e408" class="mr lk iq mn b gy ms mt l mu mv">loader.py --checks-config-file config.yaml --dump-generated-checks<br/><br/>2020-08-25 19:05:25,259 - root - DEBUG - generateChecks() initiating run w/ id: 20200825_19052525<br/>2020-08-25 19:05:25,265 - root - DEBUG - Reading sites[mysite]<br/>2020-08-25 19:05:25,266 - root - DEBUG - Reading sites[mysite].checks[v1]<br/>2020-08-25 19:05:25,266 - root - DEBUG - sites[mysite].checks[v1] generated 3 checks.<br/><br/>------------------------------<br/>v1<br/>------------------------------<br/>['NA'] -&gt; https://my.app.com/path1 <br/>    every:15m timeout:10000ms notifyAfter:4 fails, <br/>    priority:high users:['23456'] teams:['12345'] integrations:['88723'] <br/>    again:30 intervals, whenBackUp:True <br/>    tags:['20200825_19052525', 'v1', 'my_app_com', 'priority-high', 'path1']<br/> <br/>['NA'] -&gt; https://my.app.com/path2 <br/>    every:15m timeout:10000ms notifyAfter:4 fails, <br/>    priority:high users:['23456', 'abc'] teams:['12345'] integrations:['88723'] <br/>    again:30 intervals, whenBackUp:True <br/>    tags:['20200825_19052525', 'v1', 'my_app_com', 'priority-high', 'path2']<br/><br/>['NA'] -&gt; https://my.app.com/path3 every:15m timeout:10000ms notifyAfter:4 fails, <br/>    priority:high users:['23456'] teams:['12345'] integrations:['88723'] <br/>    again:30 intervals, whenBackUp:True <br/>    tags:['20200825_19052525', 'v1', 'my_app_com', 'priority-high', 'path3']</span></pre><p id="58d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">..这些检查一旦被推送到Pingdom，就可以通过它们的标签作为一个“集合”来管理，例如:</p><pre class="ko kp kq kr gt mm mn mo mp aw mq bi"><span id="6cf8" class="mr lk iq mn b gy ms mt l mu mv">./loader.py \<br/>    --checks-config-file config.yaml \<br/>    --delete-tag-qualifiers 20200825_19052525 \<br/>    --delete-in-pingdom \<br/>    --pingdom-api-token-file trial.token</span></pre><p id="5585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦定义了配置文件，就可以专门添加新的“站点”,并重新运行以重新生成新的检查集，这些检查集将通过标记机制加载到Pingdom中并作为“集”进行管理:</p><p id="3231" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在的场景看起来更像这样:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/22417b016a07608cf86bda33a4bdb160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZZAL6_27Cmq8sn4t"/></div></figure><h1 id="9429" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">pingdom-检查加载程序</h1><p id="a9c1" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">net-net所开发的东西可以在pingdom-check-loader 的<a class="ae kl" href="https://github.com/bitsofinfo/pingdom-check-loader" rel="noopener ugc nofollow" target="_blank"> Github上获得，它的工作方式与描述的差不多。</a></p><p id="9648" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该实用程序定义了一个简单的CLI，允许您在YAML文件中声明所需的检查配置状态；CLI使用该配置，然后生成一个或多个由该配置驱动的检查。有关配置格式的更多文档和细节，请参见示例<a class="ae kl" href="https://github.com/bitsofinfo/pingdom-check-loader/blob/master/checkconfigs.yaml" rel="noopener ugc nofollow" target="_blank"> checkconfigs.yaml </a>。</p><p id="19a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦生成检查，就可以针对目标Pingdom帐户创建检查。此CLI不支持变更以前定义的检查。支票变化本质上是附加的。您可以生成和制作新支票，并且只能删除旧支票。现有的检查(虽然在Pingdom GUI中是可编辑的)通过这个CLI设计是不可变的。</p><p id="a687" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由该实用程序生成和创建的检查是不可变的；生成的检查被适当地标记，以便通过Pingdom的GUI和API容易地找到。标签是基于CLI调用<code class="fe mw mx my mn b">timestamp</code>和<code class="fe mw mx my mn b">pathParts</code>(参见YAML)自动创建的，因此所有生成的检查都可以作为一个集合来管理。然后，您可以使用这些标记来删除检查(通过这个CLI)，当您的需求发生变化时，这些检查可以被它们的更新的迭代所替换。你可以按照你想要的任何顺序做事；例如，创建一个版本的检查，然后交互并生成第二个迭代；在您的第二次迭代按预期运行之后，您可以使用传递第一次迭代标识符<code class="fe mw mx my mn b">timestamp</code>的<code class="fe mw mx my mn b">--delete-tag-qualifers</code>标志来清理第一次迭代。</p><p id="a523" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【https://github.com/bitsofinfo/pingdom-check-loader T4】</p><p id="249c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一些关于Pingdom API的关键问题需要注意。特别是GUI和API针对多重选择处理区域的方式；没有简单的方法通过UI或API获得用户、团队和集成标识符<em class="km">(您必须在Pingdom的GUI中的HTML源代码中检查和查找</em></p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="6095" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">原载于2020年8月25日http://bitsofinfo.wordpress.com</em><a class="ae kl" href="https://bitsofinfo.wordpress.com/2020/08/25/immutable-health-check-monitor-pingdom/" rel="noopener ugc nofollow" target="_blank"><em class="km"/></a><em class="km">。</em></p></div></div>    
</body>
</html>