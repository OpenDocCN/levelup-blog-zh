<html>
<head>
<title>Node.js Best Practices — Testing and Quality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—测试和质量</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-best-practices-testing-and-quality-e2257fda95b1?source=collection_archive---------11-----------------------#2020-04-21">https://levelup.gitconnected.com/node-js-best-practices-testing-and-quality-e2257fda95b1?source=collection_archive---------11-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/128912b5ebc6fb42376027c140daa1ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xf7fd0_z4rnGpUwj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">本·穆林斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a4e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js是编写应用程序的流行运行时。这些应用程序通常是许多人使用的生产质量应用程序。为了使维护它们变得更容易，我们必须制定一些准则供人们遵循。</p><p id="da24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何测试和维护Node.js代码的质量。</p><h1 id="428a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">至少编写API(组件)测试</h1><p id="7c9b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该一有时间就写测试。测试通过检查现有功能是否仍在工作来防止回归。这样，我们就不必担心我们的代码更改会破坏任何关键功能。</p><p id="428b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为我们的应用程序创建测试很容易。我们可以使用Jest这样的测试框架和Superagent这样的库来测试我们的API。</p><p id="7df8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该确保代码覆盖率高，这样我们就可以用我们的测试来测试大部分代码。</p><p id="da30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过运行以下命令，使用Jest和Supertest轻松地向Express应用程序添加测试:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b6b6" class="mq lf it mm b gy mr ms l mt mu">npm i jest supertest</span></pre><p id="448f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们写下以下内容:</p><p id="46cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">index.js</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c482" class="mq lf it mm b gy mr ms l mt mu">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="39a6" class="mq lf it mm b gy my ms l mt mu">app.get('/', (req, res, next) =&gt; {<br/>  res.json({hello: 'hello'});<br/>});</span><span id="5515" class="mq lf it mm b gy my ms l mt mu">module.exports = app;</span></pre><p id="3cbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">index.test.js</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5a13" class="mq lf it mm b gy mr ms l mt mu">const request = require('supertest');<br/>const app = require('./index');</span><span id="28bd" class="mq lf it mm b gy my ms l mt mu">describe('hello test', () =&gt; {<br/>  it('/ should return hello response', async () =&gt; {<br/>    const res = await request(app)<br/>      .get('/')<br/>    expect(res.statusCode).toEqual(200)<br/>    expect(res.body).toEqual({hello: 'hello'})    <br/>  })<br/>})</span></pre><p id="46d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在代码文件中，我们将<code class="fe mv mw mx mm b">supertest</code>添加到我们的<code class="fe mv mw mx mm b">index.test.js</code>测试文件中。然后，我们通过向<code class="fe mv mw mx mm b">/</code>路由发出请求并检查响应代码和主体来测试我们的路由。</p><p id="34bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">toEqual</code>方法检查深度相等，这样我们可以检查任何值。</p><h1 id="f1ae" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">每个测试名称包含3个部分</h1><p id="899e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">每个测试名称应该包括3个部分，这样阅读测试用例的人就知道测试的是什么。测试名称应该包括正在测试的内容、场景以及预期的结果。</p><h1 id="7dd6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">AAA模式的结构测试</h1><p id="d3c4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">AAA代表安排、行动和断言。测试的第一部分应该为我们的测试设置数据。然后我们实际运行代码，然后断言返回的结果是我们所期望的。</p><p id="bfbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这些类型的测试，我们仅仅通过查看测试就理解了主要代码。</p><h1 id="979c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检测Linter的代码问题</h1><p id="e9a6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该使用代码处理器来检查我们代码的基本质量问题。间距、格式和语法错误都在它的范围内。它还检查常见的反模式，以确保我们的代码没有它们。带有节点插件的Linters也可以检查我们代码的安全问题。</p><p id="38ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有棉绒，很容易忽略它们。因此，我们可能会运行质量很差的代码，并且代码中存在安全漏洞。</p><h1 id="95c6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免全局测试夹具和种子</h1><p id="eefe" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">每个测试都应该有自己的测试夹具和种子，这样它们就可以独立运行，不需要任何其他东西。这很重要，因为我们需要测试不依赖于任何外部事物。它使得测试易于添加和调试。</p><p id="9626" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它减少了很多令人头疼的测试。他们不应该依赖任何外部因素。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1cd1db5cb0459efdc25104dcbcbf4240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mfKHsFKItlbYJL5-"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@anikolleshi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿尼·科勒希</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="13dd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查易受攻击的依赖项</h1><p id="d94b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">npm audit</code>或snyk.io来检查易受攻击的依赖项，以便尽快更新这些包。</p><p id="0432" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这些自动化工具，我们无需自己动手就可以检查易受攻击的包。</p><h1 id="8e3d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">标记测试</h1><p id="45e9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">标记测试让我们可以轻松地搜索它们。我们可以将标签添加到测试名称中，这样我们就可以很容易地找到它们。</p><h1 id="976c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查测试覆盖率</h1><p id="a4cc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">测试覆盖让我们检查测试是否运行了足够多的代码部分。代码覆盖工具突出显示了测试运行了代码的哪些部分，没有运行。然后我们可以看看我们需要运行什么样的代码来增加代码的测试覆盖率。</p><p id="b4fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果测试覆盖率低于某个阈值，我们也可能希望构建失败。</p><h1 id="f087" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查过期的包装</h1><p id="a2ef" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">npm outdated</code>和<code class="fe mv mw mx mm b">npm-check-updates</code>来检查过期的包，以检测过期的包。如果我们有过时的包，我们也可以在CI管道中运行它来防止构建成功。</p><p id="ac43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就不会在应用程序中使用过时的包。</p><h1 id="f40d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="30bf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用节点应用程序添加测试很容易。它让我们不费力地检查回归。当我们划分测试来测试代码的小片段时，添加测试并不费力。对于Jest这样的测试框架和Superagent这样的测试HTTP客户端来说，这尤其容易。</p><p id="1f3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还应该检查易受攻击的软件包，并尽快更新它们。此外，还要检查自己的代码是否存在安全漏洞，并尽快修复。</p></div></div>    
</body>
</html>