<html>
<head>
<title>Do not laugh — A simple AI powered game using TensorFlow.js and Electron</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要笑——一个简单的人工智能驱动的游戏，使用TensorFlow.js和Electron</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/do-not-laugh-a-simple-ai-powered-game-3e22ad0f8166?source=collection_archive---------2-----------------------#2019-09-04">https://levelup.gitconnected.com/do-not-laugh-a-simple-ai-powered-game-3e22ad0f8166?source=collection_archive---------2-----------------------#2019-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0bbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很长一段时间以来，我一直在评估如何利用人工智能技术来平衡数字应用程序的用户体验，甚至实现全新的UI / UX概念。</p><p id="e072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近我偶然发现了几篇 <a class="ae kl" href="https://medium.com/@jsflo.dev/training-a-tensorflow-model-to-recognize-emotions-a20c3bcd6468" rel="noopener">文章</a>，描述了如何训练CNN(卷积神经网络)识别一个人通过面部表情表达的情绪。这听起来像是一个创建用户界面的有趣想法，所以为了测试它，我想出了一个简单的游戏，叫做“不要笑”。</p><p id="ca16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">游戏本身非常简单。它会从YouTube上随机播放一段有趣的视频，你唯一的工作就是:不要笑！<strong class="jp ir">如果人工智能发现你在笑，游戏就结束了。</strong>所以我开始用Vue.js和最近成为我首选的前端框架的Electron创建这个游戏。</p><div class="km kn ko kp gt ab cb"><figure class="kq kr ks kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/72df3ad91244632ef5b4dbf22796c069.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*DBa-vAS4LODBvSCp-NLwaQ.png"/></div></figure><figure class="kq kr ks kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/f2062b05e8e3da5beeb3077627c84c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0BYYv2z4K1KjqhShhf5eRQ.png"/></div></figure><figure class="kq kr ks kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/f047478138ae27562f37d59bce52b619.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*69Q9d311CqjLe1UcWNUPuw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk lh di li lj translated">请原谅漫画书的随意使用</figcaption></figure></div><p id="d93a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在基于HTML5 / JavaScript的应用程序中使用人工智能和机器学习技术是一件相当新的事情，所以我决定在本文中写下我的经验，并与您分享一些最佳实践。如果你对所有的细节不感兴趣，你也可以从这里下载所有的源代码。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="8b79" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">如何给一个Vue.js +电子app添加TensorFlow</h1><p id="2f33" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">如果你以前玩过人工智能或机器学习代码，你可能已经见过一个名为<a class="ae kl" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>的库在运行。TensorFlow是谷歌用于机器学习(ML)的开源人工智能框架，它被广泛用于图像分类等任务——这正是我们的小游戏所需要的。唯一的缺点是，它是一个Python库，只能使用nVidia GPUs进行加速。是的，在做任何与ML相关的事情时，你绝对需要GPU加速。</p><h2 id="8c7e" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">输入TensorFlow.js和WebGL GPU加速</h2><p id="9cf8" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">幸运的是，TensorFlow团队已经将该库移植到JavaScript，并发布了<a class="ae kl" href="https://www.tensorflow.org/js" rel="noopener ugc nofollow" target="_blank"> TensorFlow.js </a> (tfjs)，让我们可以在电子应用程序中使用它。更好的是，他们更进一步，添加了基于WebGL的GPU加速，支持任何现代GPU，不再限制我们使用支持nVidia和CUDA的硬件👋 👋 👋。为此干杯🍺！</p><figure class="km kn ko kp gt kr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/4be4602177cd8709712bc09eaabb1b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*TU80N0PC552ic-LMGcoffA.jpeg"/></div></figure><h2 id="3d40" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">使用face-api.js让事情变得更加简单</h2><p id="3faa" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">在这一点上，我们基本上都设置好了。我们手头有一个强大的库，并且有预训练的模型可用于情绪检测。这意味着我们可以节省时间和麻烦来训练我们自己的模型。</p><p id="1c9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我写一些初始代码时，我发现<a class="nh ni ep" href="https://medium.com/u/ffd42e31db07?source=post_page-----3e22ad0f8166--------------------------------" rel="noopener" target="_blank">文森特·米勒</a>已经创建了一个名为<a class="ae kl" href="https://itnext.io/face-api-js-javascript-api-for-face-recognition-in-the-browser-with-tensorflow-js-bcc2a6c4cf07" rel="noopener ugc nofollow" target="_blank"> face-api.js </a>的高级api，它基于TensorFlow.js构建，包装了所有低级操作，并为人脸识别和情感检测等常见任务提供了一个方便的API。他还在他的<a class="ae kl" href="https://github.com/justadudewhohacks/face-api.js" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上提供了许多示例代码，所以我能够在几分钟内构建我的第一个情感识别器。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="0252" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">将应用程序放在一起</h1><p id="2c69" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">先说整体游戏架构。使用电子意味着我们有一个铬渲染器过程，这将成为我们的游戏用户界面。它会回放视频文件，显示你的直播镜头，当然还会运行游戏逻辑——你笑了，你就输了。</p><p id="43a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，在这种情况下，实际的情绪检测发生在哪里呢？要回答这个问题，你需要记住两件事:</p><ul class=""><li id="735d" class="nj nk iq jp b jq jr ju jv jy nl kc nm kg nn kk no np nq nr bi translated">实时情感检测是一项非常耗费资源的任务。即使是一个好的GPU也可能只能产生大约20-30 FPS的速度。</li><li id="a688" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">在电子渲染器中运行资源密集型任务将导致该渲染器的UI变得无响应。</li></ul><p id="241e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了保持事情顺利进行，我们需要一种方法将繁重的工作转移到一个单独的流程中。幸运的是，Electron可以使用隐藏渲染器做到这一点。因此，我们最终的游戏架构看起来像这样:</p><figure class="km kn ko kp gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/c94caba3f223a7fb41288340839e1a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v43KOE42zfJYJwbUvCGBGA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在隐藏渲染器中运行TensorFlow.js / face-api</figcaption></figure><p id="3d0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个场景中，我们让face-api在一个隐藏的渲染器(“检测工作器”)中运行，不断评估现场摄像机流中的情绪。如果检测到情绪，工作者将向游戏发送带有检测到的情绪的IPC消息。在游戏中，我们可以简单地将这些消息视为事件，并做出相应的反应。</p><h2 id="d236" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">创建新的Vue.js /电子应用程序</h2><p id="5701" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">要创建你的应用样板文件<a class="ae kl" href="https://medium.com/@andreas.schallwig/building-html5-kiosk-applications-with-vue-js-and-electron-c64ac928b59f" rel="noopener">，你可以按照我这里的说明</a>。从“准备好您的环境”一节开始，按照说明操作，直到您可以使用<code class="fe ny nz oa ob b">npm run electron:serve</code>成功运行空白应用程序。</p><p id="9087" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来安装face-api.js:</p><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="e78c" class="mu ls iq ob b gy og oh l oi oj">npm i --save face-api.js</span></pre><h2 id="c17c" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">背景检测工作进程</h2><p id="9938" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">首先，我们创建后台工作进程，它将处理所有的检测工作(又名。“重物提升”)。继续在<code class="fe ny nz oa ob b">public</code>目录下创建一个文件<code class="fe ny nz oa ob b">worker.html</code>:</p><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="bc11" class="mu ls iq ob b gy og oh l oi oj">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="utf-8"&gt;<br/>  &lt;title&gt;Worker&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;video id="cam" autoplay muted playsinline&gt;&lt;/video&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="2f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意这里的<code class="fe ny nz oa ob b">&lt;video&gt;</code>标签。我们将在worker中引用这个元素来从相机流中检索图像数据。</p><p id="486b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来在<code class="fe ny nz oa ob b">src</code>目录中创建<code class="fe ny nz oa ob b">worker.js</code>。这是一个更长的文件，你可以在这里看到完整的版本。我将对其进行分解，并向您解释最重要的部分:</p><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="36ff" class="mu ls iq ob b gy og oh l oi oj">import * as faceapi from 'face-api.js';</span><span id="d560" class="mu ls iq ob b gy ok oh l oi oj">// init detection options<br/>const minConfidenceFace = 0.5;<br/>const faceapiOptions = new faceapi.SsdMobilenetv1Options({ minConfidenceFace });</span></pre><p id="bc9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们包括并配置face-api.js。在内部，face-api.js使用SSD MobileNet v1模型来识别图片中的人脸，因此我们需要提供一个<code class="fe ny nz oa ob b">minConfidenceFace</code>配置参数，该参数将模型配置为识别至少50%置信度的人脸。</p><figure class="km kn ko kp gt kr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/ca8c061e94c10a7635c7a77c3733e0fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*n09RasQiUS42aIPWn94GzQ.jpeg"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">这家伙不是故意笑的！</figcaption></figure><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="8aaf" class="mu ls iq ob b gy og oh l oi oj">// configure face API<br/>faceapi.env.monkeyPatch({<br/>  Canvas: HTMLCanvasElement,<br/>  Image: HTMLImageElement,<br/>  ImageData: ImageData,<br/>  Video: HTMLVideoElement,<br/>  createCanvasElement: () =&gt; document.createElement('canvas'),<br/>  createImageElement: () =&gt; document.createElement('img')<br/>});</span></pre><p id="9902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一部分是为了使face-api.js在电子应用程序中正常工作的一种变通方法。在正常的浏览器环境中，这是不需要的。然而，我们在隐藏的渲染器中启用了<code class="fe ny nz oa ob b">nodeIntegration</code>,这导致TensorFlow.js认为我们在NodeJS环境中。<a class="ae kl" href="https://github.com/justadudewhohacks/face-api.js/issues/157" rel="noopener ugc nofollow" target="_blank">这就是为什么我们需要手动将环境打回浏览器环境</a>。如果你跳过这一步，你会收到一个错误<code class="fe ny nz oa ob b">Uncaught (in promise) TypeError: Illegal constructor at createCanvasElement [...]</code>。</p><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="7596" class="mu ls iq ob b gy og oh l oi oj">let loadNet = async () =&gt; {<br/>  let detectionNet = faceapi.nets.ssdMobilenetv1;<br/>  await detectionNet.load('/data/weights');<br/>  await faceapi.loadFaceExpressionModel('/data/weights');<br/>  return detectionNet;<br/>};</span></pre><p id="d0c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们加载MobileNet V1网络的预训练模型权重以及面部表情模型。因为我想让我的应用程序离线工作，所以我从本地URL <code class="fe ny nz oa ob b">/data/weights</code>加载它们，这个URL会转换成你的项目目录中的<code class="fe ny nz oa ob b">/public/data/weights</code>文件夹。你可以从<a class="ae kl" href="https://github.com/justadudewhohacks/face-api.js/tree/master/weights" rel="noopener ugc nofollow" target="_blank"> Vincent Mühler的GitHub库</a>下载需要的文件。</p><figure class="km kn ko kp gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/28f91efa6eb2c9bdad85d8dbc203622b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebcTzqVYpQCNkC8CcLxySw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">将这些模型和权重文件下载到目标目录</figcaption></figure><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="253a" class="mu ls iq ob b gy og oh l oi oj">let cam;<br/>let initCamera = async (width, height) =&gt; {<br/>  cam = document.getElementById('cam');<br/>  cam.width = width;<br/>  cam.height = height;<br/>  const stream = await navigator.mediaDevices.getUserMedia({<br/>    audio: false,<br/>    video: {<br/>      facingMode: "user",<br/>      width: width,<br/>      height: height<br/>    }<br/>  });<br/>  cam.srcObject = stream;<br/>  return new Promise((resolve) =&gt; {<br/>    cam.onloadedmetadata = () =&gt; {<br/>      resolve(cam);<br/>    };<br/>  });<br/>};</span></pre><p id="c38c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码几乎是从连接到你的计算机的摄像机中获取视频流的标准代码。我们只是为了方便把它包在承诺里。</p><p id="fdda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在一切就绪，我们可以直接继续检测部分。我只是添加了一些方便的方法来将事件消息发送到游戏UI渲染器:</p><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="dd5a" class="mu ls iq ob b gy og oh l oi oj">let onReady = () =&gt; {<br/>  notifyRenderer('ready', {});<br/>};</span><span id="2035" class="mu ls iq ob b gy ok oh l oi oj">let onExpression = (type) =&gt; {<br/>  notifyRenderer('expression', { type: type });<br/>};</span><span id="0001" class="mu ls iq ob b gy ok oh l oi oj">let notifyRenderer = (command, payload) =&gt; {<br/>  ipcRenderer.send('window-message-from-worker', {<br/>    command: command, payload: payload<br/>  });<br/>}</span></pre><p id="f354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ny nz oa ob b">onReady</code>在模型初始化“预热”并准备好检测时触发。此后，每当检测到表达式时，<code class="fe ny nz oa ob b">onExpression</code>将通过IPC将检测到的表达式转发给主进程。</p><p id="645d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是实际检测部分:</p><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="5d7a" class="mu ls iq ob b gy og oh l oi oj">let detectExpressions = async () =&gt; {<br/>  // detect expression<br/>  let result = await faceapi.detectSingleFace(cam, faceapiOptions)<br/>    .withFaceExpressions();<br/>  if(!isReady) {<br/>    isReady = true;<br/>    onReady();<br/>  }<br/>  if(typeof result !== 'undefined') {<br/>    let happiness = 0, anger = 0;<br/>    if(result.expressions.hasOwnProperty('happy')) {<br/>      happiness = result.expressions.happy;<br/>    }<br/>    if(result.expressions.hasOwnProperty('angry')) {<br/>      anger = result.expressions.angry;<br/>    }<br/>    if(happiness &gt; 0.7) {<br/>      onExpression('happy');<br/>    } else if(anger &gt; 0.7) {<br/>      onExpression('angry');<br/>    }<br/>  }<br/>  if(isRunning) {<br/>    detectExpressions();<br/>  }<br/>};</span></pre><p id="b4cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数基本上是一个无限循环，它将首先检测相机图片中的一张脸，然后尝试确定该脸上的面部表情(=情绪)。</p><p id="e4fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ny nz oa ob b">detectSingleFace().withFaceExpression()</code>的结果将返回一个带有<code class="fe ny nz oa ob b">expressions</code>字典的结果对象，包含给定表达式(如“生气”或“高兴”)的概率(0-1)。在我的例子中，我决定将触发<code class="fe ny nz oa ob b">onExpression</code>事件的概率阈值设置为0.7 (70%)。</p><p id="fed6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！我们现在可以使用以下代码运行检测工作器:</p><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="0946" class="mu ls iq ob b gy og oh l oi oj">loadNet()<br/>.then(net   =&gt; { return initCamera(640, 480); })<br/>.then(video =&gt; { detectExpressions(); });</span></pre><h2 id="5f32" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">配置Vue.js以使用隐藏的背景渲染器</h2><p id="d525" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">检测人员就位后，下一步是配置Vue.js和Electron来运行隐藏的渲染器。打开(或创建)应用根目录下的文件<code class="fe ny nz oa ob b">vue.config.js</code>,插入/添加以下配置:</p><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="343d" class="mu ls iq ob b gy og oh l oi oj">module.exports = {<br/>  pages: {<br/>    index: {<br/>      entry: 'src/main.js', //entry for the public page<br/>      template: 'public/index.html', // source template<br/>      filename: 'index.html' // output as dist/*<br/>    },<br/>    worker: {<br/>      entry: 'src/worker.js',<br/>      template: 'public/worker.html',<br/>      filename: 'worker.html'<br/>    }<br/>  },<br/>  devServer: {<br/>    historyApiFallback: {<br/>      rewrites: [<br/>        { from: /\/index/, to: '/index.html' },<br/>        { from: /\/worker/, to: '/worker.html' }<br/>      ]<br/>    }<br/>  }<br/>};</span></pre><p id="bfc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个配置将为工作人员在Vue的WebPack配置中添加第二个入口点，并创建一个别名以使其在开发过程中工作。</p><p id="ec1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后对<code class="fe ny nz oa ob b">background.js</code>做如下修改:</p><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="2541" class="mu ls iq ob b gy og oh l oi oj">import { app, protocol, BrowserWindow, ipcMain } from 'electron'<br/>import {<br/>  createProtocol,<br/>  installVueDevtools<br/>} from 'vue-cli-plugin-electron-builder/lib';</span><span id="2625" class="mu ls iq ob b gy ok oh l oi oj">const isDevelopment = process.env.NODE_ENV !== 'production';</span><span id="6ebb" class="mu ls iq ob b gy ok oh l oi oj">let win;<br/>let workerWin;</span><span id="961f" class="mu ls iq ob b gy ok oh l oi oj">// check if the "App" protocol has already been created<br/>let createdAppProtocol = false;</span><span id="b5aa" class="mu ls iq ob b gy ok oh l oi oj">// Scheme must be registered before the app is ready<br/>protocol.registerSchemesAsPrivileged([{<br/>  scheme: 'app', privileges: {<br/>    secure: true,<br/>    standard: true,<br/>    corsEnabled: true,<br/>    supportFetchAPI: true<br/>  }<br/>}])</span><span id="04c2" class="mu ls iq ob b gy ok oh l oi oj">function createWindow () {</span><span id="f108" class="mu ls iq ob b gy ok oh l oi oj">  // create the game UI window<br/>  win = new BrowserWindow({<br/>    width: 1024, height: 790,<br/>    webPreferences: { nodeIntegration: true }<br/>  });</span><span id="7226" class="mu ls iq ob b gy ok oh l oi oj">  if (process.env.WEBPACK_DEV_SERVER_URL) {<br/>    win.loadURL(process.env.WEBPACK_DEV_SERVER_URL)<br/>  } else {<br/>    win.loadURL('app://./index.html');<br/>  }</span><span id="9660" class="mu ls iq ob b gy ok oh l oi oj">  win.on('closed', () =&gt; {<br/>    // closing the main (visible) window should quit the App<br/>    app.quit();<br/>  });<br/>}</span><span id="5452" class="mu ls iq ob b gy ok oh l oi oj">function createWorker(devPath, prodPath) {</span><span id="9cd5" class="mu ls iq ob b gy ok oh l oi oj">  // create hidden worker window<br/>  workerWin = new BrowserWindow({<br/>    show: false,<br/>    webPreferences: { nodeIntegration: true }<br/>  });</span><span id="6b12" class="mu ls iq ob b gy ok oh l oi oj">  if(process.env.WEBPACK_DEV_SERVER_URL) {<br/>    workerWin.loadURL(process.env.WEBPACK_DEV_SERVER_URL + devPath);<br/>  } else {<br/>    workerWin.loadURL(`app://./${prodPath}`)<br/>  }</span><span id="fe21" class="mu ls iq ob b gy ok oh l oi oj">  workerWin.on('closed', () =&gt; { workerWin = null; });<br/>}</span><span id="f2ed" class="mu ls iq ob b gy ok oh l oi oj">function sendWindowMessage(targetWindow, message, payload) {<br/>  if(typeof targetWindow === 'undefined') {<br/>    console.log('Target window does not exist');<br/>    return;<br/>  }</span><span id="8a1d" class="mu ls iq ob b gy ok oh l oi oj">  targetWindow.webContents.send(message, payload);<br/>}</span><span id="84b1" class="mu ls iq ob b gy ok oh l oi oj">[...]</span><span id="f6c2" class="mu ls iq ob b gy ok oh l oi oj">app.on('ready', async () =&gt; {<br/>  if (isDevelopment &amp;&amp; !process.env.IS_TEST) {<br/>    // Install Vue Devtools<br/>    try {<br/>      await installVueDevtools()<br/>    } catch (e) {<br/>      console.error('Vue Devtools failed to install:', e.toString())<br/>    }<br/>  }</span><span id="29b6" class="mu ls iq ob b gy ok oh l oi oj">  if(!createdAppProtocol) {<br/>    createProtocol('app');<br/>    createdAppProtocol = true;<br/>  }</span><span id="7427" class="mu ls iq ob b gy ok oh l oi oj">  // create the main application window<br/>  createWindow();</span><span id="636a" class="mu ls iq ob b gy ok oh l oi oj">  // create the background worker window<br/>  createWorker('worker', 'worker.html');</span><span id="8e54" class="mu ls iq ob b gy ok oh l oi oj">  // setup message channels<br/>  ipcMain.on('window-message-from-worker', (event, arg) =&gt; {<br/>    sendWindowMessage(win, 'message-from-worker', arg);<br/>  });<br/>})</span><span id="4dba" class="mu ls iq ob b gy ok oh l oi oj">[...]</span></pre><p id="7fc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看我在这里所做的更改和添加。最明显的是第二个窗口<code class="fe ny nz oa ob b">workerWin</code>，它将是我们隐藏的渲染器。为了使事情更易于管理，我创建了函数<code class="fe ny nz oa ob b">createWorker</code>，它是默认函数<code class="fe ny nz oa ob b">createWindow</code>的镜像，只是满足隐藏工作者的特定需求。</p><p id="4073" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我修改了<code class="fe ny nz oa ob b">app</code>协议，以启用CORS和对<code class="fe ny nz oa ob b">fetch</code> API的支持。这是允许从本地<code class="fe ny nz oa ob b">/public</code>文件夹加载模型权重所必需的。</p><p id="7335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我为<code class="fe ny nz oa ob b">window-message-from-worker</code>通道添加了一个IPC监听器，通过<code class="fe ny nz oa ob b">sendWindowMessage</code>方法将来自检测工作者的消息转发给游戏。</p><h2 id="93a2" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">添加游戏用户界面</h2><p id="d6ea" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">我不会过多地讨论如何构建HTML / CSS，而是集中讨论如何接收和处理来自检测人员的“情绪”消息。提醒一下，所有代码都可以在我的GitHub库上找到，供您查看。</p><figure class="km kn ko kp gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/1cedc1539addc366df9d7efebaaba7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMkOS5w4C34yMBGYp6cJpw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">我又输给了猫队🐱</figcaption></figure><p id="44d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看一下<code class="fe ny nz oa ob b">src/views/Play.vue</code>里面的这部分源码:</p><pre class="km kn ko kp gt oc ob od oe aw of bi"><span id="8953" class="mu ls iq ob b gy og oh l oi oj">this.$electron.ipcRenderer.on('message-from-worker', (ev, data) =&gt; {</span><span id="678c" class="mu ls iq ob b gy ok oh l oi oj">  if(typeof data.command === 'undefined') {<br/>    console.error('IPC message is missing command string');<br/>    return;<br/>  }</span><span id="f493" class="mu ls iq ob b gy ok oh l oi oj">  if(data.command == 'expression') {<br/>    if(data.payload.type == 'happy') {<br/>      this.onLaugh();<br/>      return;<br/>    }</span><span id="e01e" class="mu ls iq ob b gy ok oh l oi oj">    if(data.payload.type == 'angry') {<br/>      this.onAngry();<br/>      return;<br/>    }<br/>  }</span><span id="ef62" class="mu ls iq ob b gy ok oh l oi oj">});</span></pre><p id="d498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们开始监听通过<code class="fe ny nz oa ob b">message-from-worker</code>通道传入的IPC消息。如果消息包含一个<code class="fe ny nz oa ob b">expression</code>命令，我们触发一个与消息相关的游戏事件。在我的游戏中，<code class="fe ny nz oa ob b">onLaugh</code>会包含当你被抓到大笑时的逻辑，<code class="fe ny nz oa ob b">onAngry</code>会在游戏结束后重新开始游戏。</p><figure class="km kn ko kp gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/76adc3ceddf730ec53b91250730305a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dz_chGVHQyz_ispEqtZ37Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">通过做一个愤怒的表情来重新开始游戏😠</figcaption></figure><p id="81f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！如果你对已经完成的项目感兴趣，请从我的GitHub页面下载。你可以随意修改它或者把它作为你自己游戏的基础——我很乐意看到你想出的所有酷的东西！</p><p id="05ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">非常感谢您的阅读！</strong></p></div></div>    
</body>
</html>