<html>
<head>
<title>8 Awesome Vue Development Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">8个很棒的Vue开发技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/8-awesome-vue-development-tips-661b7631aa47?source=collection_archive---------6-----------------------#2022-12-08">https://levelup.gitconnected.com/8-awesome-vue-development-tips-661b7631aa47?source=collection_archive---------6-----------------------#2022-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a4927ed39f516dcfd586b4fccb4d5313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55bk-BB038oEpjRaJ-WyqA.jpeg"/></div></div></figure><h2 id="8b73" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">1.路由参数解耦</h2><p id="77fc" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">一般来说，使用组件中的路由参数，大多数人会这样做。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="f995" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    methods: {<br/>        getParamsId() {<br/>            return this.$route.params.id<br/>        }<br/>    }<br/>}</span></pre><p id="92c6" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">在组件中使用<code class="fe mi mj mk lu b">$route</code>会导致与其对应的路由高度耦合，从而通过将组件限制在某些URL上来限制组件的灵活性。</p><p id="86db" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">正确的方法是通过<code class="fe mi mj mk lu b">props</code>将其解耦</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="e0c0" class="ly jz iq lu b be lz ma l mb mc">const router = new VueRouter({<br/>    routes: [{<br/>        path:  /user/:id ,<br/>        component: User,<br/>        props: true<br/>    }]<br/>})</span></pre><p id="5520" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">将路由的props属性设置为true后，可以通过props在组件内接收params参数。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="bef4" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    props: [ id ],<br/>    methods: {<br/>        getParamsId() {<br/>            return this.id<br/>        }<br/>    }<br/>}</span></pre><p id="51c5" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">也可以通过功能模式返还道具。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="9e93" class="ly jz iq lu b be lz ma l mb mc">const router = new VueRouter({<br/>    routes: [{<br/>        path:  /user/:id ,<br/>        component: User,<br/>        props: (route) =&gt; ({<br/>            id: route.query.id<br/>        })<br/>    }]<br/>})</span></pre><h2 id="806a" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">2.功能成分</h2><p id="dc85" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">功能组件是无状态的，它不能被实例化，并且没有任何生命周期或方法。创建功能组件也很简单，只需在模板中添加功能声明。它通常适用于仅依赖于外部数据变化的组件，并且由于其重量轻，渲染性能得到提高。</p><p id="4403" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">组件需要的一切都通过上下文参数传递。它是一个上下文对象，具体属性见文档。这里的props是一个包含所有绑定属性的对象。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="14e5" class="ly jz iq lu b be lz ma l mb mc">&lt;template functional&gt;<br/>    &lt;div class="list"&gt;<br/>        &lt;div class="item" v-for="item in props.list" :key="item.id" @click="props.itemClick(item)"&gt;<br/>            &lt;p&gt;{{item.title}}&lt;/p&gt;<br/>            &lt;p&gt;{{item.content}}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="2aa4" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">父组件使用</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="fd22" class="ly jz iq lu b be lz ma l mb mc">&lt;template&gt;<br/>    &lt;div&gt;<br/>        &lt;List :list="list" :itemClick="item =&gt; (currentItem = item)" /&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><pre class="ml lt lu lv bn lw lx bi"><span id="ee3a" class="ly jz iq lu b be lz ma l mb mc">import List from  @/components/List.vue<br/>export default {<br/>    components: {<br/>        List<br/>    },<br/>    data() {<br/>        return {<br/>            list: [{<br/>                title:  title ,<br/>                content:  content<br/>            }],<br/>            currentItem:<br/>        }<br/>    }<br/>}</span></pre><h2 id="7db5" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">3.样式范围</h2><p id="a9f4" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">在开发中修改第三方组件样式是很常见的，但是由于作用域属性的样式隔离，可能有必要移除作用域或开始另一种样式。这些实践有副作用(组件样式污染，缺乏优雅)，样式渗透在css预处理器中使用以生效。</p><p id="df66" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">我们可以用<code class="fe mi mj mk lu b">&gt;&gt;&gt;</code>或者<code class="fe mi mj mk lu b">/deep/</code>来解决这个问题:</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="065d" class="ly jz iq lu b be lz ma l mb mc">&lt;style scoped&gt;<br/>Outer layer &gt;&gt;&gt; .el-checkbox {<br/>  display: block;<br/>  font-size: 26px;<br/><br/>  .el-checkbox__label {<br/>    font-size: 16px;<br/>  }<br/>}<br/>&lt;/style&gt;</span></pre><pre class="ml lt lu lv bn lw lx bi"><span id="f465" class="ly jz iq lu b be lz ma l mb mc">&lt;style scoped&gt;<br/>/deep/ .el-checkbox {<br/>  display: block;<br/>  font-size: 26px;<br/><br/>  .el-checkbox__label {<br/>    font-size: 16px;<br/>  }<br/>}<br/>&lt;/style&gt;</span></pre><h2 id="79d6" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">4.手表的高级使用</h2><p id="9855" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">当listener属性改变时会触发watch，有时我们希望在组件创建后立即执行watch。</p><p id="2040" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">可能想到的方法是在创建生命周期中调用它一次，但这并不是一种优雅的编写方式，所以也许我们可以像这样使用它。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="0e06" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    data() {<br/>        return {<br/>            name:  Joe<br/>        }<br/>    },<br/>    watch: {<br/>        name: {<br/>            handler:  sayName ,<br/>            immediate: true<br/>        }<br/>    },<br/>    methods: {<br/>        sayName() {<br/>            console.log(this.name)<br/>        }<br/>    }<br/>}</span></pre><p id="4676" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated"><strong class="kw ir">深度倾听</strong></p><p id="4514" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">当监听一个对象时，当对象内部的属性被改变时，手表不能被触发，所以我们可以为它设置深度监听</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="6296" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    data: {<br/>        studen: {<br/>            name:  Joe ,<br/>            skill: {<br/>                run: {<br/>                    speed:  fast<br/>                }<br/>            }<br/>        }<br/>    },<br/>    watch: {<br/>        studen: {<br/>            handler:  sayName ,<br/>            deep: true<br/>        }<br/>    },<br/>    methods: {<br/>        sayName() {<br/>            console.log(this.studen)<br/>        }<br/>    }<br/>}</span></pre><p id="83fb" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated"><strong class="kw ir">触发监听器执行多个方法</strong></p><p id="e3ee" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">使用数组你可以设置多种形式，包括字符串，函数，对象。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="a84b" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    data: {<br/>        name:  Joe<br/>    },<br/>    watch: {<br/>        name: [<br/>             sayName1 ,<br/>            function(newVal, oldVal) {<br/>                this.sayName2()<br/>            },<br/>            {<br/>                handler:  sayName3 ,<br/>                immaediate: true<br/>            }<br/>        ]<br/>    },<br/>    methods: {<br/>        sayName1() {<br/>            console.log( sayName1==&gt; , this.name)<br/>        },<br/>        sayName2() {<br/>            console.log( sayName2==&gt; , this.name)<br/>        },<br/>        sayName3() {<br/>            console.log( sayName3==&gt; , this.name)<br/>        }<br/>    }<br/>}</span></pre><h2 id="8033" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> 5。手表监听多个变量</strong></h2><p id="1022" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">手表本身无法监听多个变量。然而，我们可以通过返回一个带有计算属性的对象，然后监听该对象来“监听多个变量”。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="44cc" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    data() {<br/>        return {<br/>            msg1:  apple ,<br/>            msg2:  banana<br/>        }<br/>    },<br/>    compouted: {<br/>        msgObj() {<br/>            const { msg1, msg2 } = this<br/>            return {<br/>                msg1,<br/>                msg2<br/>            }<br/>        }<br/>    },<br/>    watch: {<br/>        msgObj: {<br/>            handler(newVal, oldVal) {<br/>                if (newVal.msg1 != oldVal.msg1) {<br/>                    console.log( msg1 is change )<br/>                }<br/>                if (newVal.msg2 != oldVal.msg2) {<br/>                    console.log( msg2 is change )<br/>                }<br/>            },<br/>            deep: true<br/>        }<br/>    }<br/>}</span></pre><h2 id="b2ae" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">6.事件参数$event</h2><p id="8ca2" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated"><code class="fe mi mj mk lu b">$event</code>是事件对象的一个特殊变量，它在某些场景下给了我们更多可用的参数来实现复杂的功能。</p><p id="7fb7" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">本机事件:行为与本机事件中的默认事件对象相同。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="0b90" class="ly jz iq lu b be lz ma l mb mc">&lt;template&gt;<br/>    &lt;div&gt;<br/>        &lt;input type="text" @input="inputHandler( hello , $event)" /&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><pre class="ml lt lu lv bn lw lx bi"><span id="ccea" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    methods: {<br/>        inputHandler(msg, e) {<br/>            console.log(e.target.value)<br/>        }<br/>    }<br/>}</span></pre><p id="6d3d" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">自定义事件:在自定义事件中表示为捕获从子组件抛出的值。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="1cf9" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    methods: {<br/>        customEvent() {<br/>            this.$emit( custom-event ,  some value )<br/>        }<br/>    }<br/>}<br/></span></pre><pre class="ml lt lu lv bn lw lx bi"><span id="1249" class="ly jz iq lu b be lz ma l mb mc">&lt;template&gt;<br/>    &lt;div&gt;<br/>        &lt;my-item v-for="(item, index) in list" @custom-event="customEvent(index, $event)"&gt;<br/>            &lt;/my-list&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><pre class="ml lt lu lv bn lw lx bi"><span id="676e" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    methods: {<br/>        customEvent(index, e) {<br/>            console.log(e) //  some value<br/>        }<br/>    }<br/>}</span></pre><h2 id="fc31" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">7.编程事件侦听器</h2><p id="5a4a" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">例如，在装入页面时定义计时器需要在页面被销毁时清除计时器。这似乎不是问题。但是仔细观察一下，this.timer的唯一目的是能够在beforeDestroy内获取计时器号，否则就没用了。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="6ce9" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    mounted() {<br/>        this.timer = setInterval(() =&gt; {<br/>            console.log(Date.now())<br/>        }, 1000)<br/>    },<br/>    beforeDestroy() {<br/>        clearInterval(this.timer)<br/>    }<br/>}</span></pre><p id="c982" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">如果可能的话，最好只有生命周期挂钩可以访问。这不是一个严重的问题，但可以认为是杂乱。</p><p id="b0ab" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">我们可以通过使用<code class="fe mi mj mk lu b">$on</code>或<code class="fe mi mj mk lu b">$once</code>监听页面生命周期破坏来解决这个问题</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="b8fa" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    mounted() {<br/>        this.creatInterval( hello )<br/>        this.creatInterval( world )<br/>    },<br/>    creatInterval(msg) {<br/>        let timer = setInterval(() =&gt; {<br/>            console.log(msg)<br/>        }, 1000)<br/>        this.$once( hook:beforeDestroy , function() {<br/>            clearInterval(timer)<br/>        })<br/>    }<br/>}</span></pre><p id="b995" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">用这种方法，即使我们同时创建多个定时器，也不影响效果。这是因为它们将在页面被销毁后以编程方式自动清除。</p><h2 id="2522" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">8.倾听组件生命周期</h2><p id="a734" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">通常我们使用$emit来监听组件生命周期，父组件接收事件进行通知。</p><p id="c2bb" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">子组件</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="980c" class="ly jz iq lu b be lz ma l mb mc">export default {<br/>    mounted() {<br/>        this.$emit( listenMounted )<br/>    }<br/>}</span></pre><p id="1c69" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">父组件</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="49f1" class="ly jz iq lu b be lz ma l mb mc">&lt;template&gt;<br/>    &lt;div&gt;<br/>        &lt;List @listenMounted="listenMounted" /&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="e566" class="pw-post-body-paragraph ku kv iq kw b kx md kz la lb me ld le kh mf lg lh kl mg lj lk kp mh lm ln lo ij bi translated">事实上，有一种简单的方法可以使用<a class="ae mm" href="http://twitter.com/hook" rel="noopener ugc nofollow" target="_blank"> @hook </a>来监听组件的生命周期，而不需要在组件内部做任何更改。类似地，创建、更新等。也可以用这个方法。</p><pre class="lp lq lr ls gt lt lu lv bn lw lx bi"><span id="c6c2" class="ly jz iq lu b be lz ma l mb mc">&lt;template&gt;<br/>    &lt;List @hook:mounted="listenMounted" /&gt;<br/>&lt;/template&gt;</span></pre></div></div>    
</body>
</html>