<html>
<head>
<title>AEM: Populate a drop-down with a data source</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AEM:用数据源填充下拉列表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/aem-populate-a-drop-down-with-a-data-source-edafada90cc4?source=collection_archive---------1-----------------------#2020-03-26">https://levelup.gitconnected.com/aem-populate-a-drop-down-with-a-data-source-edafada90cc4?source=collection_archive---------1-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ba5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何创建一个通用的、可重用的数据源系统，为下拉菜单和其他小部件提供数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a65dbd84d71b2db4cf0f728e072dfe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNb_mpw5WJDnHV9bjC6HzQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">CoralUI下拉列表选择使用数据源填充</figcaption></figure><p id="2293" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当创建组件或修改AEM touch ui的其他部分时，有时需要使用包含许多选项的选择小部件。那么我们如何做到这一点，最好的方法是什么，尤其是当我们有很多大列表的时候？</p><h1 id="f875" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">解决方法</h1><h2 id="4b44" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">暂且应急的</h2><p id="00eb" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">这可以用最简单的方法来完成，将每个条目列为JCR中的一个节点，其中每个条目节点包含一个<code class="fe nd ne nf ng b">text</code>(在select小部件中看到的标签)和一个<code class="fe nd ne nf ng b">value</code>(保存在JCR中的实际值)属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/efbba8f011d209e697a9c9f6c180d452.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*bPuz3Sde5-KSmJpZ4Oq7MQ.png"/></div></figure><p id="09f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这对于小列表来说很有效，但是对于大列表来说却不是最有效的方法，尤其是当它们将来会改变的时候！</p><h2 id="159a" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">adobe-推荐</h2><p id="b0e5" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">这将我们带到Granite数据源，正如这里的<a class="ae ni" href="https://helpx.adobe.com/experience-manager/6-4/sites/developing/using/reference-materials/granite-ui/api/jcr_root/libs/granite/ui/docs/server/datasource.html" rel="noopener ugc nofollow" target="_blank">所记录的</a>，它允许我们以编程方式创建可由我们的小部件使用的项目列表。Adobe有一个(有点过时的)教程，它仍然依赖于JSP，但是涵盖了基础知识:你用一个<code class="fe nd ne nf ng b">datasource</code>节点替换<code class="fe nd ne nf ng b">items</code>节点，这调用了一个Java模型。这个模型将每个条目作为一个<code class="fe nd ne nf ng b">ValueMap</code>添加到请求中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a99e01f93fdd3921416af9474e403a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*RpxvDafxhESCyVJ4B9c_MQ.png"/></div></figure><p id="308c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您必须添加许多项目(在JCR中创建100或1000个节点的图像😟).然而，仍然有一些缺点:</p><ul class=""><li id="995c" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">您必须为每个数据源创建一个Java数据源模型。</li><li id="42f9" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">现在，每当您想要更改数据源内容时，都必须部署一个Java包。</li></ul><h2 id="5943" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">我的解决方案</h2><p id="153b" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">想象一下，如果您可以简单地通过在您的<code class="fe nd ne nf ng b">/apps/site</code>节点下添加一个JSON文件来创建一个新的数据源呢？</p><ul class=""><li id="88ba" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">您将拥有每个人都能理解的标准化格式的数据，而不是后端Java类中的一系列<code class="fe nd ne nf ng b">Map.put()</code>行。</li><li id="216d" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">您不再需要部署您的包来更改数据源中的值。</li><li id="c336" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">在后端，您将只有一个易于测试的处理程序。</li></ul><p id="e5d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我提出了一种通用的方法来创建数据源，只依赖一个可以被所有数据源使用的Sling模型。</p><p id="239b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然已经完成了，让我们卷起袖子开始工作吧！😁</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h1 id="1f1c" class="lu lv it bd lw lx of lz ma mb og md me jz oh ka mg kc oi kd mi kf oj kg mk ml bi translated">履行</h1><p id="cbc1" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">首先，我想提几件事:</p><ul class=""><li id="9046" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">我正在使用Lombok的getters、setters和logging</li><li id="15e1" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">不要忘记给你创建的每个包添加一个<code class="fe nd ne nf ng b">package-info.java</code>文件！</li></ul><h2 id="8f97" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">模型</h2><p id="685f" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">让我们从创建吊索模型开始。它所能做的就是接受一个请求，并把它传递给一个服务来完成繁重的工作。我总是喜欢使用界面，所以这里是界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="1669" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以及实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="33d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我选择将我们的模型称为“static ”,因为它从JCR中的静态节点获取数据。然而，本教程中的原则可以很容易地应用于动态数据源，例如，用从REST端点或数据库获取的数据填充下拉列表。</p><p id="3d07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止够简单了吧？现在，让我们创建一个承担重任的服务。</p><h2 id="998e" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">服务</h2><p id="3a77" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">下面是界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="35af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以及实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="0e04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在这里用了大量的注释和Javadoc来尽可能清楚地说明这一点，但是让我们更详细地浏览一下。</p><p id="7e61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个类的作用是:</p><ol class=""><li id="4132" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt om nq nr ns bi translated">将请求作为参数。</li><li id="0f04" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt om nq nr ns bi translated">确定请求的资源。</li><li id="679c" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt om nq nr ns bi translated">通过这个位置，它找到了一个<code class="fe nd ne nf ng b">data.json</code>文件。</li><li id="38c6" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt om nq nr ns bi translated">它以流的形式读取JSON文件。</li><li id="4eeb" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt om nq nr ns bi translated">它将JSON转换成一个值映射列表</li><li id="d077" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt om nq nr ns bi translated">将值映射转换为资源</li><li id="455b" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt om nq nr ns bi translated">将它们添加到名为<code class="fe nd ne nf ng b">com.adobe.granite.ui.components.ds.DataSource</code>的请求属性中。</li></ol><p id="4b6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是这个解决方案真正出彩的地方:因为我们的服务基于请求路径确定从<em class="on">读取哪个JSON文件，所以它可以用于任何数量的源！将这个包部署到您的AEM实例中，准备好之后，现在让我们在JCR中使用JSON创建实际的数据源。</em></p><h2 id="156a" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">数据源</h2><p id="0904" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">数据源将由三个元素组成:</p><ol class=""><li id="b558" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt om nq nr ns bi translated">一个调用我们上面创建的模型的HTL脚本。</li><li id="6c2f" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt om nq nr ns bi translated">一个包含实际文本/值对的<code class="fe nd ne nf ng b">data.json</code>文件。</li><li id="45be" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt om nq nr ns bi translated">包含这两个文件的方便命名的文件夹。</li></ol><p id="df53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能已经从上面的截图中猜到了，我们将列出ISO-3166国家和他们的alpha-2国家代码。</p><p id="2718" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在项目节点(例如:<code class="fe nd ne nf ng b">/apps/mysite/datasources</code>)下创建一个<code class="fe nd ne nf ng b">nt:folder</code>节点，并将其命名为countries。然后在该文件夹中创建一个<code class="fe nd ne nf ng b">countries.html</code>文件。</p><p id="ad2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在放松一下，打开一本冷的剧本，因为这可能是你写过的最简单的HTL剧本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="564d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！现在让我们最后提供我们的数据😃根据<a class="ae ni" href="https://www.iban.com/country-codes" rel="noopener ugc nofollow" target="_blank">这个来源</a>有249个ISO-3166。这些数据太多了，无法包含在教程中，但是你可以在这里找到JSON文件<a class="ae ni" href="https://gist.github.com/theopendle/2340be70054d0dcee5c0224aeb7bc49a" rel="noopener ugc nofollow" target="_blank"/>。一般来说，任何<code class="fe nd ne nf ng b">data.json</code>文件都应该遵循以下格式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="943e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nd ne nf ng b">countries</code>文件夹中创建一个<code class="fe nd ne nf ng b">data.json</code>文件，并将JSON粘贴到其中。</p><h2 id="a3e2" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">下拉选择小部件</h2><p id="5168" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">当然，如果我们想使用我们的数据源，我们需要一个小部件。我将使用一个超级简单的演示组件，它只显示一个<code class="fe nd ne nf ng b">&lt;span&gt;</code>标签，包含我们从组件编辑器对话框的下拉列表中选择的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="7cca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是<code class="fe nd ne nf ng b">cq:dialog</code>结构，在红框中是需要注意的重要部分:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/ae849c5cfcee614f5e53f4f8e81fa8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*Si2PKBxUVZOgDRyFqdf0yQ.png"/></div></figure><p id="a2c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是XML格式的部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="af50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关键元素是<code class="fe nd ne nf ng b">datasource</code>节点，它指向我们在上一节中创建的带有<code class="fe nd ne nf ng b">sling:resourceType</code>属性的数据源文件夹(我的站点名称是<code class="fe nd ne nf ng b">tipi</code>)。</p><p id="a3c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们翻到一页，测试一下！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/f89feebcdae9ab4e52f7c5b8926c190d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iMg1ldPhd6N-e4EGHUBpyw.gif"/></div></div></figure><p id="e1b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我们拥有的，一个允许你创建尽可能多的新数据源的系统，你所要做的就是从现在开始复制粘贴一些JSON😁</p><p id="a2ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想查看另一个可以利用这个数据源系统的小部件，请参见本教程<a class="ae ni" href="https://medium.com/p/c4a03c1eddc5" rel="noopener">。</a></p><p id="028e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这篇教程对你有所帮助，如果你有任何进一步的问题，请不要犹豫，在LinkedIn上发表评论或联系我。你可以在这里找到安装演示组件和数据源<a class="ae ni" href="https://github.com/theopendle/aem-datasource-system/releases/tag/1.0.0" rel="noopener ugc nofollow" target="_blank">的包。</a></p></div></div>    
</body>
</html>