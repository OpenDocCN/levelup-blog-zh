<html>
<head>
<title>Clean code: Android modules and Dependency Injection (feat: Koin)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净的代码:Android模块和依赖注入(专长:Koin)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/android-module-setup-in-3-steps-using-dependency-injection-with-koin-b7920ec8a800?source=collection_archive---------20-----------------------#2020-07-05">https://levelup.gitconnected.com/android-module-setup-in-3-steps-using-dependency-injection-with-koin-b7920ec8a800?source=collection_archive---------20-----------------------#2020-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="44cc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个干净的分离和亲切的协议的故事</h2></div><p id="43e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模块化的应用程序设计对于开发人员的理智、应用程序的可伸缩性和代码质量至关重要。</p><blockquote class="lb lc ld"><p id="7b3f" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">设计是分离、组合、抽象和隐藏的艺术。—鲍伯·马丁叔叔</p></blockquote><p id="c32c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当每个模块可能都需要知道<code class="fe li lj lk ll b">Application</code>类是何时创建的时候，我如何才能享受一个由适当的分离和抽象(使用模块)组成的Android应用程序呢？</p><p id="4704" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="le">(设置模块的几个用例是:初始化分析库，当应用程序语言改变时，观察</em> <code class="fe li lj lk ll b"><em class="le">LocaleLiveData</em></code> <em class="le">以同步建议，或者解包捆绑的数据并插入到本地数据库中。)</em></p><p id="1506" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很棒的问题！为了解释，让我们听听我们的好朋友，<code class="fe li lj lk ll b">Application</code>:</p><p id="42ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="le">快速提示:虽然我们在这里将使用Koin作为我们的DI库，但是下面的设计模式和过程也适用于Dagger 2(以及大多数(如果不是全部的话)其他DI库)。</em></p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><blockquote class="lb lc ld"><p id="7c20" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">嗨，我是<a class="ae lt" href="https://developer.android.com/reference/android/app/Application" rel="noopener ugc nofollow" target="_blank">申请</a>！</p><p id="61f6" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">我住在一个叫<code class="fe li lj lk ll b">app</code>的模块里。我由许多不同的<a class="ae lt" href="https://medium.com/google-developer-experts/modularizing-android-applications-9e2d18f244a0" rel="noopener">模块</a>组成，因为我喜欢<a class="ae lt" href="https://medium.com/mindorks/understanding-clean-code-in-android-ebe42ad89a99" rel="noopener">干净</a>！我让每个模块做自己的事情，我不担心它们的实现细节——老实说，我更关注大局…</p><p id="683d" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">但是模块需要我...尤其是当我第一次被创造的时候。幸运的是，我们已经就如何相互交流达成了一致！<code class="fe li lj lk ll b">base</code>模块称之为:<code class="fe li lj lk ll b">ModuleSetup</code> <code class="fe li lj lk ll b">interface</code>。我需要做的就是向我们的朋友<code class="fe li lj lk ll b"><a class="ae lt" href="https://insert-koin.io/" rel="noopener ugc nofollow" target="_blank">Koin</a></code>请求<code class="fe li lj lk ll b">ModuleSetup</code>的所有实例，并对每个实例调用<code class="fe li lj lk ll b">setup</code>方法！我让单个模块做告诉<code class="fe li lj lk ll b">Koin</code>如何提供这些实现的具体工作。小菜一碟<em class="iq">🍰</em>。</p><p id="3f35" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">我们互不干涉，但仍然保持着非常友好的关系🙂。</p><p id="7a2c" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">鳍状物</p></blockquote></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="4398" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些喜欢列表而不是来自无生命物体的故事的人来说；遵循以下三个简单的步骤来设置您的Android应用程序的模块:</p><ol class=""><li id="b3e4" class="lu lv iq kh b ki kj kl km ko lw ks lx kw ly la lz ma mb mc bi translated">用一个<code class="fe li lj lk ll b">setup(app: Application)</code>方法创建一个共享的<code class="fe li lj lk ll b">ModuleSetup</code>T1</li><li id="5b6b" class="lu lv iq kh b ki md kl me ko mf ks mg kw mh la lz ma mb mc bi translated">提供来自每个模块的<code class="fe li lj lk ll b">ModuleSetup</code>实现，并将它们<code class="fe li lj lk ll b">bind</code>到<code class="fe li lj lk ll b">interface</code></li><li id="ffda" class="lu lv iq kh b ki md kl me ko mf ks mg kw mh la lz ma mb mc bi translated">在<code class="fe li lj lk ll b">Application</code> <code class="fe li lj lk ll b">onCreate</code>中，使用<code class="fe li lj lk ll b">Koin</code>的<code class="fe li lj lk ll b">getAll&lt;ModuleSetup&gt;</code>获取所有实现，并使用<code class="fe li lj lk ll b">Application</code>上下文对每个实现调用<code class="fe li lj lk ll b">setup</code></li></ol><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/86fa0f382803a0346b75068dd7281a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GZ0vjMpVMvyEhhTy"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">照片由<a class="ae lt" href="https://unsplash.com/@blackpoetry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">pix poeties</a>在<a class="ae lt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="193a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于以下解释，了解隐含的应用程序结构将很有帮助:</p><pre class="mj mk ml mm gt my ll mz na aw nb bi"><span id="dfdf" class="nc nd iq ll b gy ne nf l ng nh">-- app<br/>-- modules<br/>   -- base<br/>   -- ...<br/>   -- ...<br/>   -- super-cool</span></pre><p id="bd18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe li lj lk ll b">modules</code>对<code class="fe li lj lk ll b">app</code>一无所知。<code class="fe li lj lk ll b">base</code>模块将包含所有其他模块可用的代码，包括<code class="fe li lj lk ll b">app</code>模块。这是我们放置<code class="fe li lj lk ll b">ModuleSetup</code> <code class="fe li lj lk ll b">interface</code>的地方。</p><h1 id="645d" class="ni nd iq bd nj nk nl nm nn no np nq nr jw ns jx nt jz nu ka nv kc nw kd nx ny bi translated">创建一个<code class="fe li lj lk ll b">ModuleSetup</code> <code class="fe li lj lk ll b">interface</code></h1><p id="18da" class="pw-post-body-paragraph kf kg iq kh b ki nz jr kk kl oa ju kn ko ob kq kr ks oc ku kv kw od ky kz la ij bi translated">我们的应用程序中经常有需要初始化的代码。这意味着我们需要在创建<code class="fe li lj lk ll b">Application</code>类时提供回调的能力。另外，初始化代码通常需要一个<code class="fe li lj lk ll b">Context</code>来运行。</p><p id="cac9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了满足这两个需求，在编写干净代码的同时，我们需要为一个类创建一个契约，该类包含一个将<code class="fe li lj lk ll b">Application</code>上下文作为参数的方法。这将允许<code class="fe li lj lk ll b">Koin</code>的<code class="fe li lj lk ll b">getAll&lt;T&gt;</code>方法返回我们契约的所有实现，因此<code class="fe li lj lk ll b">Application</code>可以相应地与它们交互。这个契约需要对<code class="fe li lj lk ll b">app</code>模块和所有其他模块都可用，所以我们将它放在我们的<code class="fe li lj lk ll b">base</code>模块中。</p><p id="2c17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的合同将是这样的:</p><pre class="mj mk ml mm gt my ll mz na aw nb bi"><span id="2a31" class="nc nd iq ll b gy ne nf l ng nh">package appname.setup</span><span id="d7bd" class="nc nd iq ll b gy oe nf l ng nh">interface <em class="le">ModuleSetup </em>{<br/>    fun setup(app: Application)<br/>}</span></pre><p id="573e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，任何需要在<code class="fe li lj lk ll b">Application</code>创建上设置的模块都可以实现这个<code class="fe li lj lk ll b">interface</code>并为其提供<code class="fe li lj lk ll b">Koin</code>。</p><h1 id="95ca" class="ni nd iq bd nj nk nl nm nn no np nq nr jw ns jx nt jz nu ka nv kc nw kd nx ny bi translated">实现、提供并绑定您的<code class="fe li lj lk ll b">ModuleSetup</code>实现</h1><p id="8bca" class="pw-post-body-paragraph kf kg iq kh b ki nz jr kk kl oa ju kn ko ob kq kr ks oc ku kv kw od ky kz la ij bi translated">于是，<code class="fe li lj lk ll b">base</code>为我们创造了一个<code class="fe li lj lk ll b">interface</code>。让我们在我们的<code class="fe li lj lk ll b">super-cool</code>模块中实现它，并运行一些惊人的初始化代码。</p><pre class="mj mk ml mm gt my ll mz na aw nb bi"><span id="7980" class="nc nd iq ll b gy ne nf l ng nh">package appname.modules.super.cool.setup</span><span id="9502" class="nc nd iq ll b gy oe nf l ng nh">import appname.setup.ModuleSetup<br/>import ...<br/></span><span id="c0fe" class="nc nd iq ll b gy oe nf l ng nh">class ModuleSetupImpl constructor(private val repo: SuperCoolRepository, private val locale: LocaleLiveData) : <em class="le">ModuleSetup </em>{</span><span id="4862" class="nc nd iq ll b gy oe nf l ng nh">    @MainThread<br/>    override fun setup(app: Application) {<br/>     <br/>        // warning: do not run blocking code on the main thread<br/>        locale.observeForever {<br/>            // runs task in background<br/>            repo.syncRecommendations(it.languageTag)<br/>        }</span><span id="3b60" class="nc nd iq ll b gy oe nf l ng nh">    }<br/>}</span></pre><p id="2447" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果需要，我们可以使用<code class="fe li lj lk ll b">Koin</code>将依赖注入到我们的实现中；注意<code class="fe li lj lk ll b">SuperCoolRepository</code>和<code class="fe li lj lk ll b">LocaleLiveData</code>参数。</p><p id="9448" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个设置示例中，我们注入了一个LiveData，其中包含我们的应用程序的区域设置和一个存储库，该存储库将根据区域设置为我们构建一些内容推荐。这种设置允许我们保持我们的内容与用户的语言同步，无论它何时何地发生变化。</p><p id="c665" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们在我们的<code class="fe li lj lk ll b">Koin</code> <a class="ae lt" href="https://doc.insert-koin.io/#/koin-core/modules" rel="noopener ugc nofollow" target="_blank">模块</a>中提供实现。</p><pre class="mj mk ml mm gt my ll mz na aw nb bi"><span id="0451" class="nc nd iq ll b gy ne nf l ng nh">package appname.modules.super.cool.di.modules</span><span id="d095" class="nc nd iq ll b gy oe nf l ng nh">import ...</span><span id="bb29" class="nc nd iq ll b gy oe nf l ng nh">val superCoolModule<em class="le"> </em>= module<em class="le"> </em>{</span><span id="aa06" class="nc nd iq ll b gy oe nf l ng nh">    ...<br/>    single { SuperCoolRepository() }<br/>    single { ModuleSetupImpl(get(), get()) } bind ModuleSetup::class<br/>    ...</span><span id="2d2d" class="nc nd iq ll b gy oe nf l ng nh">}</span></pre><p id="b9b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的关键是<code class="fe li lj lk ll b">Koin</code>的<code class="fe li lj lk ll b"><a class="ae lt" href="https://doc.insert-koin.io/#/koin-core/definitions?id=additional-type-binding" rel="noopener ugc nofollow" target="_blank">bind</a></code>操作符。这允许我们将我们的实现绑定到<code class="fe li lj lk ll b">ModuleSetup</code> <code class="fe li lj lk ll b">interface</code>。现在，我们可以进入最后一步了。</p><h1 id="fcfc" class="ni nd iq bd nj nk nl nm nn no np nq nr jw ns jx nt jz nu ka nv kc nw kd nx ny bi translated">向<code class="fe li lj lk ll b">Koin</code>索要<code class="fe li lj lk ll b">ModuleSetup</code>职业和收益！</h1><p id="dc65" class="pw-post-body-paragraph kf kg iq kh b ki nz jr kk kl oa ju kn ko ob kq kr ks oc ku kv kw od ky kz la ij bi translated">我们已经把所有东西连在一起了！最后要做的事情是向<code class="fe li lj lk ll b">Koin</code>请求所有的<code class="fe li lj lk ll b">ModuleSetup</code>类，并对每个类调用<code class="fe li lj lk ll b">setup</code>方法。</p><pre class="mj mk ml mm gt my ll mz na aw nb bi"><span id="b740" class="nc nd iq ll b gy ne nf l ng nh">class ModularApplication : Application(), <em class="le">KoinComponent </em>{<br/><br/>    override fun onCreate() {<br/>        super.onCreate()<br/><em class="le"><br/>        startKoin </em>{<br/>            <em class="le">androidLogger</em>()<br/>            <em class="le">androidContext</em>(this@ModularApplication)<br/>            modules(<br/>                <em class="le">appModule,<br/>                baseModule,<br/>                …,<br/>                superCoolModule<br/>            </em>)<br/>        }<br/><br/>        // Set up our modules<br/>        getKoin().getAll&lt;<em class="le">ModuleSetup</em>&gt;().<em class="le">forEach </em>{<br/>            it.setup(this)<br/>        }<br/>    }<br/><br/>}</span></pre><p id="3b9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要指出几件事:</p><ol class=""><li id="623e" class="lu lv iq kh b ki kj kl km ko lw ks lx kw ly la lz ma mb mc bi translated">我们照常启动<code class="fe li lj lk ll b">Koin</code>并加载我们的模块，包括<code class="fe li lj lk ll b">superCoolModule</code></li><li id="2d4b" class="lu lv iq kh b ki md kl me ko mf ks mg kw mh la lz ma mb mc bi translated">我们实现了<code class="fe li lj lk ll b">KoinComponent</code> <code class="fe li lj lk ll b">interface</code>以便访问<code class="fe li lj lk ll b">Koin</code></li><li id="2db1" class="lu lv iq kh b ki md kl me ko mf ks mg kw mh la lz ma mb mc bi translated">我们按照<code class="fe li lj lk ll b">KoinComponent</code>提供的<code class="fe li lj lk ll b">getKoin()</code>调用<code class="fe li lj lk ll b">getAll&lt;ModuleSetup&gt;</code>方法(在主线程上调用<em class="le">，以便循环通过并设置各个模块</em></li></ol><p id="cadd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="ab0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="le">在我们离开之前有一个重要的注意事项:当</em> <code class="fe li lj lk ll b"><em class="le">Application</em></code> <em class="le">被创建时，</em> <code class="fe li lj lk ll b"><em class="le">setup</em></code> <em class="le">方法中的所有代码都将在主线程上运行。这意味着我们必须不惜一切代价避免在设置方法中阻塞代码，除非我们首先将工作卸载到后台线程。我们在主线程上运行的阻塞代码越多，应用程序启动的时间就越长。在更极端的情况下，运行阻塞代码(磁盘I/O、网络等。)，会导致app崩溃。</em></p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="819a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经实现了一种方法，将我们的代码分成模块，同时保持在<code class="fe li lj lk ll b">Application</code>创建时运行重要代码的能力，所有这一切只需三个简单的步骤:</p><ol class=""><li id="53b4" class="lu lv iq kh b ki kj kl km ko lw ks lx kw ly la lz ma mb mc bi translated">创建我们的安装合同(<code class="fe li lj lk ll b">interface</code></li><li id="344b" class="lu lv iq kh b ki md kl me ko mf ks mg kw mh la lz ma mb mc bi translated">实现并提供合同的所有实例</li><li id="25e2" class="lu lv iq kh b ki md kl me ko mf ks mg kw mh la lz ma mb mc bi translated">在<code class="fe li lj lk ll b">Application</code>T5检索合同实现并与之交互</li></ol><p id="1188" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，享受你的干净和模块化的Android应用程序吧！</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi of"><img src="../Images/e8e3cae1ce0885aabd3fee417500d2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xddp2JwUuFPKg7dC"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">劳伦·曼克在<a class="ae lt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div></div>    
</body>
</html>