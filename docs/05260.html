<html>
<head>
<title>Reasonable Optional or Either?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合理可选还是非此即彼？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reasonable-optional-or-either-2359e536cf64?source=collection_archive---------8-----------------------#2020-08-15">https://levelup.gitconnected.com/reasonable-optional-or-either-2359e536cf64?source=collection_archive---------8-----------------------#2020-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/275a2fdc42ca16e22804abb5ae0e644f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q7tNtwHkyRleKefc"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c4ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇博客文章以我的基于Java的应用程序中的一个简单问题开始:我已经获得了一个API访问令牌，如果它有效，我想返回相关的API客户机标识，否则不返回标识。瞧，现在已经不是2013年了，我们正是为了这个目的而举办了<code class="fe lb lc ld le b">Optional</code>！所以我们有了一个<code class="fe lb lc ld le b">Optional&lt;Identity&gt; getIdentityForValidToken(Token token)</code>函数，有一段时间，它是好的。</p><p id="92a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后出现了更多的验证规则，并且需要将令牌被拒绝的原因传播给调用者。<code class="fe lb lc ld le b"><strong class="kf ir">Optional</strong></code> <strong class="kf ir">只能在场或缺席而不能解释为什么</strong>。类似的传播原因的需求是很常见的，所以让我们来看看一些可能的解决方案。</p><p id="82ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章的其余部分，我们将研究在不同的上下文和语言中解决类似问题的两种模式，并以我们在Java中能做什么来结束。</p><h1 id="e99d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">例外</h1><p id="560f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">您首先想到的可能是使用异常。异常表示无法检索到请求的值，并且包含原因。在原因确实异常的情况下，这是一个有效的解决方案，而不是因为预期的情况，尤其是因为<a class="ae kc" href="https://stackoverflow.com/q/299068/2032064" rel="noopener ugc nofollow" target="_blank">性能</a>。我承认对于过期的令牌属于哪一类有不同的看法(库确实会在解析或验证失败时抛出异常)，但是为了便于讨论，让我们假设它不是异常的。</p><h1 id="9a6d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">异步处理</h1><p id="6acf" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们的问题已经得到很好解决的一个领域是异步执行，这可能是因为它更加普遍。</p><p id="f719" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，让我们看一个JavaScript <code class="fe lb lc ld le b">Promise</code>。它可以有三种状态:待定、已实现或已拒绝。当构造一个<code class="fe lb lc ld le b">Promise</code>时，你会得到函数引用，这些引用可以使它被满足或者被拒绝:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="105e" class="mq lg iq le b gy mr ms l mt mu">new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; { resolve(‘foo’); }, 300);<br/>});</span></pre><p id="2866" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以用任何类型的理由拒绝A <code class="fe lb lc ld le b">Promise</code>。它还提供了一个带有<code class="fe lb lc ld le b">then()</code>、<code class="fe lb lc ld le b">catch()</code>和<code class="fe lb lc ld le b">finally()</code>方法的方便流畅的接口，可以对任何一种结果状态做出反应，甚至可以将承诺转换为另一种状态。</p><h2 id="efd6" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">Java的未来</h2><p id="27a7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在Java中，我们让<code class="fe lb lc ld le b">CompletableFuture</code>实现了<code class="fe lb lc ld le b">CompletionStage</code>和<code class="fe lb lc ld le b">Future</code>接口。它提供了与<code class="fe lb lc ld le b">Promise</code>相似的功能，只是使用了更复杂的API(从Java 8开始有52个实例方法)。但是使用Java Futures也不是解决我们原始问题的合适方法。它们是为另一个目的而设计的，不适合同步代码。异步函数<a class="ae kc" href="https://blog.softwaremill.com/will-project-loom-obliterate-java-futures-fb1a28508232" rel="noopener ugc nofollow" target="_blank">像病毒一样</a>，不像JavaScript的<code class="fe lb lc ld le b">Promise</code>，它们只能用一个<code class="fe lb lc ld le b">Throwable</code>拒绝，而且，嗯，异步。这不是我们想要的。</p><h1 id="6f38" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">反应流</h1><p id="bf03" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">解决方案常见的另一个领域是反应流。<a class="ae kc" href="http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Single.html" rel="noopener ugc nofollow" target="_blank"> RxJava的单个</a>允许表示一个值或一个被拒绝的状态，并通过进一步的方法调用如<code class="fe lb lc ld le b">map()</code>和<code class="fe lb lc ld le b">flatMap()</code>来处理结果。缺点是，就像<code class="fe lb lc ld le b">CompletableFuture</code>一样，一个错误只能用一个<code class="fe lb lc ld le b">Throwable</code>来表示，如果你还没有使用RxJava，你不希望仅仅为了得到Single而添加它。</p><h1 id="e444" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">多个返回值</h1><p id="975f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Go既没有<code class="fe lb lc ld le b">Optional</code>也没有异常。可以用<a class="ae kc" href="https://stackoverflow.com/questions/30731687/how-do-i-represent-an-optional-string-in-go" rel="noopener ugc nofollow" target="_blank"> nil或指针</a>来表示一个缺失的值，但是当你也需要原因的时候，有一个简单的方法可以让<a class="ae kc" href="https://gobyexample.com/multiple-return-values" rel="noopener ugc nofollow" target="_blank">从一个函数返回多个值</a>。这是一种通常用作异常的<a class="ae kc" href="https://medium.com/@hussachai/error-handling-in-go-a-quick-opinionated-guide-9199dd7c7f76" rel="noopener">替代的模式。按照惯例，值在左边，可能的误差在右边。在使用该值之前，应该检查错误。</a></p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f99c" class="mq lg iq le b gy mr ms l mt mu">func Marshal(v interface{}) ([]byte, error) {<br/>    e := &amp;encodeState{}<br/>    err := e.marshal(v, encOpts{escapeHTML: true})<br/>    if err != nil {<br/>        return nil, err<br/>    }<br/>    return e.Bytes(), nil<br/>}</span></pre><p id="20d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的<a class="ae kc" href="https://golang.org/pkg/builtin/#error" rel="noopener ugc nofollow" target="_blank">错误</a>返回值是一种类型，因此您可以灵活地表示它。在我看来，仍然有改进的空间，例如，因为这只是一个惯例，它使得更难执行或静态检查你的代码(想想IDE抱怨你没有在Java <code class="fe lb lc ld le b">Optional</code>上的<code class="fe lb lc ld le b">get()</code>之前检查<code class="fe lb lc ld le b">isPresent()</code>)。一个被流畅的界面宠坏的人也可能会失望。但是我们越来越接近了。</p><h1 id="82ea" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">非此即彼。</h1><p id="edde" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">除了<code class="fe lb lc ld le b">Option</code>类型，Scala还提供了<code class="fe lb lc ld le b">Either</code>和<code class="fe lb lc ld le b">Try</code>。<code class="fe lb lc ld le b"><a class="ae kc" href="https://www.scala-lang.org/api/2.9.3/scala/util/Try.html" rel="noopener ugc nofollow" target="_blank">Try</a></code>适用于例外情况——失败总是与可抛性联系在一起。所以我们来看<code class="fe lb lc ld le b"><a class="ae kc" href="https://www.scala-lang.org/api/2.9.3/scala/Either.html" rel="noopener ugc nofollow" target="_blank">Either</a></code>代替。</p><p id="14c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Either</code>的实例可以是<code class="fe lb lc ld le b">Left</code>或<code class="fe lb lc ld le b">Right</code>子类的实例，其中<code class="fe lb lc ld le b">Left</code>代表约定的错误状态。这些类型是通用的，所以您可以自由选择Left可以包含什么类型的值。以下是文档中的一个示例:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2f9e" class="mq lg iq le b gy mr ms l mt mu">val l: Either[String, Int] = Left(“flower”)<br/>val r: Either[String, Int] = Right(12)<br/>l.left.map(_.size): Either[Int, Int] // Left(6)<br/>r.left.map(_.size): Either[Int, Int] // Right(12)<br/>l.right.map(_.toDouble): Either[String, Double] // Left(“flower”)<br/>r.right.map(_.toDouble): Either[String, Double] // Right(12.0)</span></pre><p id="c642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，你可以使用<code class="fe lb lc ld le b">Either</code>作为一个<a class="ae kc" href="https://medium.com/free-code-camp/demystifying-the-monad-in-scala-cc716bb6f534" rel="noopener">单子</a>，并通过<code class="fe lb lc ld le b">flatMap()</code>等函数流畅地左右映射。万岁，这似乎是目前为止最好的解决方案:在拒绝原因值上是通用的，并且具有流畅的(一元的)接口。</p><h1 id="cd9f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">其他人</h1><p id="8ce9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了完整起见，我也许应该提到其他语言中Optional的替代品，比如可空类型<a class="ae kc" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types" rel="noopener ugc nofollow" target="_blank"> C# </a>或<a class="ae kc" href="https://kotlinlang.org/docs/reference/null-safety.html" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>。据我所知，它们没有提供任何选项来返回丢失值的原因。</p><h1 id="8180" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">要么用Java</h1><p id="0c41" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在Java中，我们只剩下<a class="ae kc" href="https://stackoverflow.com/q/26162407/2032064" rel="noopener ugc nofollow" target="_blank">库</a>。</p><p id="ebcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.vavr.io/" rel="noopener ugc nofollow" target="_blank"> Vavr </a>和<a class="ae kc" href="https://github.com/functionaljava/functionaljava" rel="noopener ugc nofollow" target="_blank"> Functional Java </a>是一个<code class="fe lb lc ld le b">Either</code>类型的Java函数库。但是，它们包含的内容远不止这些，所以在将它们作为依赖项添加之前，您可能需要更详细地检查它们。</p><p id="469f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://bitbucket.org/atlassian/fugue/src/master/" rel="noopener ugc nofollow" target="_blank">亚特兰蒂斯赋格</a>提供了便利类，比如更聪明的<code class="fe lb lc ld le b">Option</code>、<code class="fe lb lc ld le b">Either</code>和<code class="fe lb lc ld le b">Pair</code>。这里有一个<code class="fe lb lc ld le b">Either</code>用法的例子:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a9fb" class="mq lg iq le b gy mr ms l mt mu">Either&lt;Integer, String&gt; either = Either.right(“value”);<br/>either<br/>    .map(String::toUpperCase)<br/>    .left().map(this::doSomethingWithRejection);<br/>    .getOrNull();</span></pre><p id="618d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">神游是更轻量级的包含其他不错的实用程序，如<a class="ae kc" href="https://docs.atlassian.com/fugue/4.5.1/fugue/apidocs/io/atlassian/fugue/Functions.html#isInstanceOf-java.lang.Class-" rel="noopener ugc nofollow" target="_blank">检查转换为可选的</a>。</p><p id="0862" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我要讲的最后一个也是最简单的选项是<a class="ae kc" href="https://github.com/poetix/ambivalence" rel="noopener ugc nofollow" target="_blank">矛盾心理</a>。它主要提供其<code class="fe lb lc ld le b">Either</code>类型:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="04f8" class="mq lg iq le b gy mr ms l mt mu">Either.ofRight(23);<br/>    .left().flatMap(this::myFunction)<br/>    .join(String::toUpperCase, Object::toString); // string “23”</span></pre><h1 id="1587" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="61d7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">鉴于我经常遇到需要传播一个丢失的值以及它丢失的原因，我很惊讶标准库提供的帮助是如此之少。对于带有未来/承诺的异步执行，这个问题似乎被巧妙地解决了。在同步世界中，Go更接近，但只有Scala提供了合理的内置解决方案和<code class="fe lb lc ld le b">Either</code>。</p><p id="a907" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我更愿意做得更好，例如，我不喜欢<code class="fe lb lc ld le b">Either</code>的惯例，即<code class="fe lb lc ld le b">Left</code>通常代表拒绝——对于不了解惯例的人来说，这违反了<a class="ae kc" href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment" rel="noopener ugc nofollow" target="_blank">最小惊喜</a>原则。除非你自己创造一个更好的解决方案，否则目前Java中最好的解决方案似乎是求助于带有<code class="fe lb lc ld le b">Either</code>的库。我从上面选择的是<a class="ae kc" href="https://bitbucket.org/atlassian/fugue/src/master/" rel="noopener ugc nofollow" target="_blank">亚特兰蒂斯赋格</a>。</p></div></div>    
</body>
</html>