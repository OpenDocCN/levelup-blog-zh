<html>
<head>
<title>OOP and D&amp;D: Encapsulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象和D&amp;D:封装</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/oop-and-d-d-encapsulation-4e7ccbd24319?source=collection_archive---------4-----------------------#2021-04-12">https://levelup.gitconnected.com/oop-and-d-d-encapsulation-4e7ccbd24319?source=collection_archive---------4-----------------------#2021-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa22" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用D&amp;D理解OOP的四个支柱，第四部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0dd094231b13dad5666a2e5a24a38d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CGWNbWACCxkqlHP2JfeTxw.png"/></div></div></figure><p id="0198" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，我们已经讨论了面向对象编程的四个支柱中的三个:继承、抽象和多态。今天，我们将用最后一个支柱:封装来结束这个系列(不，我并没有计划这个系列来建立这个双关语；只是一个幸福的意外)。但是首先，简单回顾一下！</p><h2 id="cb48" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">遗产</h2><p id="988e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如果您还记得，继承是一个具有层次关系的类(父子类)将数据、变量和方法传递给它们的子类的能力。如果<code class="fe ml mm mn mo b">Animal</code>类有一个名为<code class="fe ml mm mn mo b">speak()</code>的方法，那么<code class="fe ml mm mn mo b">Animal</code>的任何子类(比如<code class="fe ml mm mn mo b">Fox</code>)都会继承那个方法。</p><h2 id="1fe7" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">抽象</h2><p id="9b68" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这是开发人员隐藏源代码的能力，只向用户提供使用存储在类和包中的方法和数据所需的细节。这对开发者和用户来说都是好事。开发人员可以保护他们的源代码，用户不需要为自己编写复杂的代码来执行某个功能。如果您曾经使用过Pandas库中的<code class="fe ml mm mn mo b">pd.read_csv()</code>方法将<code class="fe ml mm mn mo b">.csv</code>文件转换成数据帧，那么您已经从抽象的力量中获益匪浅。你不需要知道所有的底层代码和流程。您只需要知道调用什么方法和传递什么参数。同时，熊猫可以保护他们的知识产权。</p><h2 id="02d3" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">多态性</h2><p id="40b1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我必须向Angelo Hulshout大声疾呼，他为我提供了一个更好的多态定义。上一次，我犯了一个错误，说多态性允许类共享相同的名称，但服务于“不同的目的”。虽然这在技术上是可能的，但这是一个糟糕的想法。考虑以下情况:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/b811fbc70ebb5402f487fb1a2163674e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*W3yfbQUXvzHu9rBosN9sxg.png"/></div></figure><p id="e48d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们用<code class="fe ml mm mn mo b">speak()</code>方法创建了<code class="fe ml mm mn mo b">Animal</code>类。<code class="fe ml mm mn mo b">Fox</code>类是<code class="fe ml mm mn mo b">Animal</code>类的子类，因为狐狸是——一种动物。<code class="fe ml mm mn mo b">Fox</code>类将初始化所有处于“饥饿”状态的<code class="fe ml mm mn mo b">Fox</code>对象。然后，我们决定使用方法覆盖来改变<code class="fe ml mm mn mo b">speak()</code>方法的用途(它从父类<code class="fe ml mm mn mo b">Animal</code>继承而来),这样它就可以“喂养”我们的fox并改变饥饿状态。</p><p id="467a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，代码仍然有效，但也非常愚蠢和不合逻辑。为什么不做一个<code class="fe ml mm mn mo b">feed()</code>方法来代替呢？我们本可以提供一个<code class="fe ml mm mn mo b">speak()</code>的实现，让它打印出狐狸特有的声音，但是没有！我们选择不当，现在必须自食其果。</p><p id="3ac1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不管怎样，安吉洛向我指出了这个问题，并提供了一个更好的定义:</p><blockquote class="mr ms mt"><p id="2080" class="kr ks mu kt b ku kv jr kw kx ky ju kz mv lb lc ld mw lf lg lh mx lj lk ll lm ij bi translated">多态性允许相同功能的不同实现。</p></blockquote><p id="3468" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">换句话说，类可以为一个方法提供不同的实现来实现相同的功能。因此，<code class="fe ml mm mn mo b">speak()</code>方法可以在<code class="fe ml mm mn mo b">Animal</code>和<code class="fe ml mm mn mo b">Fox</code>类之间以不同的方式<em class="mu">实现，但是它们仍然提供相同的功能:让对象“说话”。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/62c40031a2ee1d7044774a1dfc8fa604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*r_E3xVR0e4IgskV5Czdeww.png"/></div></figure><p id="d7d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，多态性不仅仅是方法覆盖，比如向上转换/向下转换类和方法重载，但是让我们看看这些就够了。</p><p id="0c60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是时候转向封装了！</p><h1 id="acbe" class="mz lo iq bd lp na nb nc ls nd ne nf lv jw ng jx ly jz nh ka mb kc ni kd me nj bi translated">包装</h1><p id="f39e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">封装是将数据和方法包装在一个单元或类中。这限制了对变量和数据的直接操作，以防止意外修改。让我们来看看龙龟的例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/806c56cd93e63aad5896a9024477be1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*EZC4l8YDi0-uElkU.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0ceb59da06995761822ffbccad7a86e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/0*Nbs-bT2HHJSPjgrB.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/50814ea47633ca64dd3bd57bdcfbf61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/0*NBk_TgDgVc3Vngtv.jpeg"/></div></figure><p id="5d66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以<code class="fe ml mm mn mo b">Sentient</code>是一个抽象的祖先类，<code class="fe ml mm mn mo b">Monster</code>就是从它派生出来的。<code class="fe ml mm mn mo b">Monster</code>也是抽象的，因为它没有为继承的抽象方法<code class="fe ml mm mn mo b">calculate_hit_points()</code>提供实现。<code class="fe ml mm mn mo b">DragonTurtle</code>是<code class="fe ml mm mn mo b">Monster</code>类的子类(因此，是<code class="fe ml mm mn mo b">Sentient</code>的孙类)。它为<code class="fe ml mm mn mo b">calculate_hit_points()</code>提供了一个实现，因此是一个具体的类。</p><p id="8e5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所看到的，<code class="fe ml mm mn mo b">DragonTurtle</code>类还提供了默认的stats来定义实例化的所有龙龟对象。你会注意到在初始化器中，<code class="fe ml mm mn mo b">hit_points</code>是通过调用<code class="fe ml mm mn mo b">calculate_hit_points()</code>方法来初始化的。这使得地下城主(DM)在创建对象后不需要运行该方法。</p><p id="2e24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，我们确实有一个问题。目前，所有的方法、变量及其相关数据都是“公共”的。这意味着任何类(我是说任何类)都可以访问和修改它们。这就是数据的脆弱性。</p><p id="4fd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么我们如何限制访问呢？嗯，我们可以让我们的数据<strong class="kt ir">受到保护</strong>或者<strong class="kt ir">成为私有</strong>。</p><h2 id="c7c6" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">有什么区别？</h2><p id="fa9d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">一般来说，<strong class="kt ir">保护的</strong>方法和数据可以被任何子类访问，也可以被同一个包中的任何类访问。请注意我所说的任何子类都可以访问这些数据。这包括位于不同包中的子类。只要他们在“家谱”中，他们就可以访问这些数据。</p><p id="745c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(再次)一般来说，<strong class="kt ir"> private </strong>方法和数据<strong class="kt ir"> </strong>只能从同一个类内部访问(或者通过Python name mangling，不过现在不用担心这个)。子类不能访问这些数据。</p><blockquote class="mr ms mt"><p id="c374" class="kr ks mu kt b ku kv jr kw kx ky ju kz mv lb lc ld mw lf lg lh mx lj lk ll lm ij bi translated">注意:在Python中，没有只能在对象内部访问的私有实例变量。相反，为了实现相同的目标，通常会实现某些约定。</p></blockquote><p id="fc10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么我们应该选择哪一个呢？嗯，我们在这里的三个类之间有层次关系，但同时，我们不希望任何人改变与变量相关的数据。所以让我们保护我们的方法，保护我们的数据。在Python中，要保护变量和方法，只需在它们前面加一个下划线(例如<code class="fe ml mm mn mo b">self._hit_points</code>)。为了使它们成为私有的，您可以在它们前面加上两个下划线(例如<code class="fe ml mm mn mo b">self.__hit_points</code>)。让我们继续对我们的<code class="fe ml mm mn mo b">Sentient</code>类这样做。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/43d810d30b29d5e7dedfaa3801fe2208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*4cA-O1qYVSpuSxWcHKRd8g.png"/></div></figure><p id="5435" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将对<code class="fe ml mm mn mo b">Monster</code>做同样的事情。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ae45be4438235d14e9abf898159359fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*1yMbv16LMw4obJsp7Ue4PA.png"/></div></figure><p id="d247" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样一来，让我们考虑一下我们的<code class="fe ml mm mn mo b">DragonTurtle</code>类。这是一个能够创建对象的具体类。我们希望用户能够与这些对象进行交互。如果他们能让50只不同的龙龟攻击一艘载满玩家的小型捕鲸船，而玩家却不能访问和检索与他们相关的任何数据，这对DM有什么好处呢？正因为如此，我们公开了“getter”和“setter”方法，这样用户就可以间接地与对象交互。我们将通过为<code class="fe ml mm mn mo b">hit_points</code>创建一个getter和setter方法来用<code class="fe ml mm mn mo b">DragonTurtle</code>类实现这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f363c6c36c5f68e85fe18d68d918b2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*1Z68UgvZSCUA4WNlCTuZ9w.png"/></div></figure><p id="2af6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们的getter方法<code class="fe ml mm mn mo b">get_hp()</code>只是返回私有变量的值。变量和用户/开发者之间的这种额外的距离防止了任何意外的修改。</p><p id="8855" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能想知道为什么我包含了一个设置方法，如果这些是通过方法计算的话。嗯，这更多的是为了DM。假设你的竞选团队中有一个玩家太强了，正在破坏游戏。你想要创造一个具有挑战性的遭遇，但对团队中的其他人来说并非不可能，同时也要积极地确保你能摧毁那个玩家的角色并给战役带来平衡。<code class="fe ml mm mn mo b">set_hp()</code>方法允许更“自制”的方法。</p><p id="b7ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们测试一下这些方法吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/41f8e8be5fb01b4406d5f241e3625d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*MHCc3CKBRqkzcXoe3FinVQ.png"/></div></figure><p id="ca7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的getter和setter都工作得很好！现在在底部，你会注意到我们没有使用getter方法来获取生命值。相反，我们使用Python名称mangling。这是一种绕过getters和setters的方法。如您所见，如果不采取谨慎的步骤，您仍然无法更改这些值(没有人会意外地键入<code class="fe ml mm mn mo b">x._DragonTurtle__hit_points</code>)。</p><h1 id="caf1" class="mz lo iq bd lp na nb nc ls nd ne nf lv jw ng jx ly jz nh ka mb kc ni kd me nj bi translated">摘要</h1><p id="1985" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">封装是一种隐藏变量、数据和方法的方式，可以防止它们被意外修改。虽然Python没有像C++和Java那样创建私有实例变量的传统方法，但还是采用了简单的实践来帮助创建相同的效果。</p><p id="eaf4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">至此，我们结束了对OOP四大支柱的讨论！这四个概念有一定的统一性，因此缺少一个将导致语言基础的崩溃。他们都在共生关系中工作，相互受益。相当了不起！</p></div></div>    
</body>
</html>