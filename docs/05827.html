<html>
<head>
<title>7 type tricks in 7 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7分钟内7次打字技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-type-tricks-in-7-minutes-4ff7bf5198fc?source=collection_archive---------15-----------------------#2020-10-05">https://levelup.gitconnected.com/7-type-tricks-in-7-minutes-4ff7bf5198fc?source=collection_archive---------15-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/403ac72e69b6e28b6c6d6b5ac1f5e19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-78DM2Kv4kXgFg-VPs5efQ.jpeg"/></div></div></figure><h2 id="a677" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph">软件工艺</h2><div class=""/><div class=""><h2 id="ebd5" class="pw-subtitle-paragraph kh jk jb bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">Typescript的类型系统和一个难题</h2></div><p id="e69e" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">Typescript拥有任何主流编程语言中最令人兴奋的类型系统之一。学习起来可能很有挑战性，但是好的类型有如此多的优点，所以值得努力。这篇文章阐明了Typescript中类型的许多基本属性。我答应了七分钟，所以让我们直接进入它。</p><h1 id="44d1" class="lv lw jb bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">对象类型</h1><p id="4215" class="pw-post-body-paragraph kz la jb lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">我们从一个更简单的东西开始:对象。通过列出字段及其类型，我们可以像定义对象一样定义对象类型。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="080f" class="nb lw jb mx b gy nc nd l ne nf">type A = { a: string; b: number };</span><span id="b505" class="nb lw jb mx b gy ng nd l ne nf">type B = { b: string; c: string[] };</span></pre><p id="306e" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">注意，这两个对象都有一个名为<code class="fe nh ni nj mx b">b</code>的字段，但是<code class="fe nh ni nj mx b">b</code>的类型不同。</p><h1 id="edc4" class="lv lw jb bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">交集和并集类型</h1><p id="9e96" class="pw-post-body-paragraph kz la jb lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">当我们引入并集和交集类型时，Typescript的类型系统开始显示。联合意味着某样东西有这样或那样的类型，所以我们只能依靠它们的共同点。交集意味着它既有一种类型又有另一种类型，所以我们可以期望它拥有两者的一切。在Typescript中，它看起来像这样:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="760b" class="nb lw jb mx b gy nc nd l ne nf">type AorB = A | B;<br/>// { b: number | string }</span><span id="36f0" class="nb lw jb mx b gy ng nd l ne nf">type AandB = A &amp; B;<br/>// { a: string; b: never; c: string[] }</span></pre><p id="0105" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">注意，在<code class="fe nh ni nj mx b">AorB</code>的情况下，只有字段<code class="fe nh ni nj mx b">b</code>同时出现在两者中，但是由于它们的类型不同，Typescript下推union操作符。另一个有趣的细节是在交集的情况下<code class="fe nh ni nj mx b">b</code>有类型<code class="fe nh ni nj mx b">never</code>。这意味着<code class="fe nh ni nj mx b">number</code>和<code class="fe nh ni nj mx b">string</code>之间没有交集，所以这种类型永远无法实现——这是真的。</p><h1 id="9a85" class="lv lw jb bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">常量类型</h1><p id="f7e8" class="pw-post-body-paragraph kz la jb lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">Typescript还带来了一些常量类型。我们不仅可以告诉类型检查器表达式的类型，还可以告诉它的值。在本例中，我们有三个不同的变量，其中两个具有常量类型:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1d21" class="nb lw jb mx b gy nc nd l ne nf">let a1: string = "a";</span><span id="7691" class="nb lw jb mx b gy ng nd l ne nf">let a2: "a" = "a";</span><span id="26f0" class="nb lw jb mx b gy ng nd l ne nf">let a3: 5 = 5;</span></pre><p id="e8a6" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">乍一看，常量类型似乎不是很有用，但是结合上面的联合类型，我们可以用它们来模拟具有基本模式匹配的sum类型:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6ea0" class="nb lw jb mx b gy nc nd l ne nf">type tree =<br/>  | { type: "Leaf", value: number }<br/>  | { type: "Node", left: tree, right: tree };<br/>function sum_tree (t: tree): number {<br/>  if (t.type === "Leaf") {<br/>    return t.value;<br/>  } else {<br/>    return sum_tree(t.left) + sum_tree(t.right);<br/>  }<br/>}</span></pre><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/81c529c365a87c9e735572978466eb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHY1rOuZ-hCO98OMWBXzPw.jpeg"/></div></div></figure><h1 id="0a8e" class="lv lw jb bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">环</h1><p id="4ac3" class="pw-post-body-paragraph kz la jb lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">组合常量和联合类型的另一个原因是通过它们进行循环，并使用它们来访问对象中的字段。类型循环关键字是<code class="fe nh ni nj mx b">in</code>，在本例中，我们用它来创建一个类似于<code class="fe nh ni nj mx b">A</code>的类型，但是我们用返回值的函数(称为thunks)来替换字段:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2149" class="nb lw jb mx b gy nc nd l ne nf">type aorb = "a" | "b";</span><span id="36c2" class="nb lw jb mx b gy ng nd l ne nf">type Athunks = {<br/>  [key in aorb]: () =&gt; A[key];<br/>};<br/>// { a: () =&gt; string; b: () =&gt; number }</span></pre><h1 id="1fd0" class="lv lw jb bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">类型运算符</h1><p id="10c1" class="pw-post-body-paragraph kz la jb lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">我们刚刚看到的for循环只明确地适用于<code class="fe nh ni nj mx b">A</code>类型，所以一个程序员想到的自然问题是:我们能推广它吗？我们确实可以。Typescript还附带了一个操作符来获取一个名为<code class="fe nh ni nj mx b">keyof</code>的对象中的字段的并集。此外，允许类型通过使用角度来获取参数。将一种类型转换成另一种类型的类型称为类型运算符。在本例中，我们首先创建一个类型操作符，用于将类型转换为thunk，然后我们创建一个类型操作符，用于thunk化任何对象类型:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ccc1" class="nb lw jb mx b gy nc nd l ne nf">type Akeys = keyof A;<br/>// "a" | "b"</span><span id="c99d" class="nb lw jb mx b gy ng nd l ne nf">type Thunkify&lt;T&gt; = () =&gt; T;</span><span id="4765" class="nb lw jb mx b gy ng nd l ne nf">type ThunkifyObject&lt;T&gt; = {<br/>  [key in keyof T]: Thunkify&lt;T[key]&gt;;<br/>};</span><span id="176e" class="nb lw jb mx b gy ng nd l ne nf">type Athunks2 = ThunkifyObject&lt;A&gt;<br/>// { a: () =&gt; string; b: () =&gt; number }</span></pre><h1 id="f684" class="lv lw jb bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">模式匹配</h1><p id="fd1b" class="pw-post-body-paragraph kz la jb lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">我们已经看到了Typescript的类型系统的一些非常酷的特性，但是现在我们把它增加到11。Typescript不仅在类型中有for-each循环，甚至还有模式匹配。我们可以询问Typescript某样东西是否符合特定的模式，如果符合，则返回一个东西，如果不符合，则返回另一个东西。这个类型操作符检查它的参数类型是否是一个带有<code class="fe nh ni nj mx b">a</code>字段的对象，并从中推断出类型。如果是，它返回推断的类型。否则，它返回never。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2e68" class="nb lw jb mx b gy nc nd l ne nf">type GetA&lt;T&gt; = T extends { a: infer R } ? R : never;</span><span id="a734" class="nb lw jb mx b gy ng nd l ne nf">type Aa = GetA&lt;A&gt;<br/>// string</span><span id="4eab" class="nb lw jb mx b gy ng nd l ne nf">type Ba = GetA&lt;B&gt;<br/>// never</span></pre><h1 id="1721" class="lv lw jb bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">功能类型</h1><p id="3269" class="pw-post-body-paragraph kz la jb lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">我们还没有看到的一种类型是函数类型。函数类型起初看起来相对简单，因为它们有一些参数和一个返回值。但是，直到您了解到在Typescript中，我们可以利用可变参数来对函数进行模式匹配，即使我们不知道它们接受哪个参数，甚至不知道它们接受多少个参数。在本例中，我们发明了一个类型运算符来删除任何函数的第一个参数:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="81eb" class="nb lw jb mx b gy nc nd l ne nf">type foo = (name: string, age: number) =&gt; void;</span><span id="caa0" class="nb lw jb mx b gy ng nd l ne nf">type RemoveFirstArg&lt;T&gt; = <br/>  T extends (head: any, ...rest: infer F) =&gt; infer R<br/>  ? (..._: F) =&gt; R<br/>  : never;</span><span id="1201" class="nb lw jb mx b gy ng nd l ne nf">type f = RemoveFirstArg&lt;foo&gt;;<br/>// f = (age: number) =&gt; void</span></pre><h1 id="47b5" class="lv lw jb bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">锻炼</h1><p id="b984" class="pw-post-body-paragraph kz la jb lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">让我们结合我们所学的一切以一个练习结束。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a6c0" class="nb lw jb mx b gy nc nd l ne nf">type puzzle = {<br/>  foo: {<br/>    bar: {<br/>      desc: string;<br/>      act: (name: string) =&gt; void;<br/>    };<br/>    baz: {<br/>      desc: string;<br/>      act: (name: string, props: { lock: boolean }) =&gt; string[];<br/>    };<br/>  };<br/>};</span></pre><p id="ca94" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们希望类型操作符保留相同的结构，但是移除最内部对象中除了<code class="fe nh ni nj mx b">act</code>函数之外的所有内容。它还应该删除第一个参数。所以对于上面的对象，我们应该得到:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="13d2" class="nb lw jb mx b gy nc nd l ne nf">type result = {<br/>  foo: {<br/>    bar: () =&gt; void;<br/>    baz: (props: { lock: boolean }) =&gt; string[];<br/>  };<br/>};</span></pre><p id="af5c" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">请注意，类型系统中有一个错误导致了此错误:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5305" class="nb lw jb mx b gy nc nd l ne nf">Error: Type cannot be used to index type</span></pre><p id="5b22" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">但是，有一种方法可以绕过它。你能找到它吗？</p><p id="c0c6" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你想要更多的打字稿或更多的软件工艺，你应该看看我的重构书:</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><a href="https://www.manning.com/books/five-lines-of-code"><div class="gh gi nl"><img src="../Images/ac2e56b71c80f26c090280c2ea7d0b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*gVCoNzmp-Ua8ui0NQlEVaw.png"/></div></a></figure></div></div>    
</body>
</html>