<html>
<head>
<title>User-defined Type Guards in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript中用户定义的类型保护</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/user-defined-type-guards-in-typescript-fad639e4944f?source=collection_archive---------8-----------------------#2020-01-08">https://levelup.gitconnected.com/user-defined-type-guards-in-typescript-fad639e4944f?source=collection_archive---------8-----------------------#2020-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="ffb7" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">打字稿指南</h2><div class=""/><div class=""><h2 id="3584" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何使用强大的Typescript功能来改进应用程序中的类型处理</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7179275897ad74f7b9988044549cfd51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8lFmnSX5wr4F70bueTlyw.jpeg"/></div></div></figure><p id="d15b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">类型保护是类型安全代码的关键特性之一。它们允许您缩小条件块中对象的类型。<a class="ae lw" href="https://www.typescriptlang.org/docs/handbook" rel="noopener ugc nofollow" target="_blank">打字稿手册</a>将打字防护描述为:</p><blockquote class="lx ly lz"><p id="5de1" class="la lb ma lc b ld le ka lf lg lh kd li mb lk ll lm mc lo lp lq md ls lt lu lv ij bi translated">执行运行时检查以保证某个范围内的类型的某个表达式</p></blockquote><p id="77cc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">该描述最重要的部分是类型保护实际上是一种运行时检查的形式，这意味着变量在代码执行时是预期的类型。与其使用<code class="fe me mf mg mh b">any</code>关键字来强制TypeScript编译器停止抱怨未知属性，不如使用类型保护更具可读性。它们不会禁用应用程序代码中的类型检查，因此减少了出错的可能性。您的代码运行，您的测试通过。编译器开心，你也开心。</p><p id="9739" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好哇🎉</p><p id="2b60" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">TypeScript带有内置的类型守卫，如<code class="fe me mf mg mh b">typeof</code>、<code class="fe me mf mg mh b">instanceof</code>、<code class="fe me mf mg mh b">in</code>和文字类型守卫。它们非常有用，但是在现代web开发中作用有限。</p><h1 id="f779" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">使用实例of</h1><p id="9c46" class="pw-post-body-paragraph la lb iq lc b ld na ka lf lg nb kd li lj nc ll lm ln nd lp lq lr ne lt lu lv ij bi translated"><code class="fe me mf mg mh b">instanceof</code>可以用来检查一个变量是否是一个给定类的实例。<code class="fe me mf mg mh b">instanceof</code>操作符的右边需要是一个构造函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="32a4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">打印到控制台:</p><pre class="kp kq kr ks gt nh mh ni nj aw nk bi"><span id="9849" class="nl mj iq mh b gy nm nn l no np">woof<br/>meow</span></pre><p id="b48e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">TypeScript编译器以同样的方式处理<code class="fe me mf mg mh b">if-else</code>块。例如，如果不是<code class="fe me mf mg mh b">instanceof</code> <code class="fe me mf mg mh b">Dog</code>，它会将变量类型缩小到<code class="fe me mf mg mh b">Cat</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="9604" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">使用类型of</h1><p id="2ae2" class="pw-post-body-paragraph la lb iq lc b ld na ka lf lg nb kd li lj nc ll lm ln nd lp lq lr ne lt lu lv ij bi translated">当需要区分<code class="fe me mf mg mh b">number</code>、<code class="fe me mf mg mh b">string</code>、<code class="fe me mf mg mh b">boolean</code>、<code class="fe me mf mg mh b">bigint</code>、<code class="fe me mf mg mh b">object</code>、<code class="fe me mf mg mh b">function</code>、<code class="fe me mf mg mh b">symbol</code>、<code class="fe me mf mg mh b">undefined</code>类型时，使用<code class="fe me mf mg mh b">typeof</code>。当试图使用其他字符串常量时，<code class="fe me mf mg mh b">typeof</code>操作符不会出错，但也不会按预期工作，这导致了难以跟踪的错误。这些类型的表达式不会被识别为类型保护。</p><p id="ed57" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">与<code class="fe me mf mg mh b">instanceof</code>不同，<code class="fe me mf mg mh b">typeof</code>可以处理任何类型的变量。在下面的例子中，<code class="fe me mf mg mh b">foo</code>可以被键入为<code class="fe me mf mg mh b">number | string</code>而没有问题。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9464" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这将打印:</p><pre class="kp kq kr ks gt nh mh ni nj aw nk bi"><span id="323b" class="nl mj iq mh b gy nm nn l no np">123<br/>not a number: foo</span></pre><p id="6e12" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">棘手的部分是<code class="fe me mf mg mh b">typeof</code>只执行浅层类型检查。它可以确定一个变量是否是一个通用对象，但不能判断对象的形状。这是行不通的:</p><pre class="kp kq kr ks gt nh mh ni nj aw nk bi"><span id="f36c" class="nl mj iq mh b gy nm nn l no np">if (typeof foo === 'Dog')</span></pre><h1 id="5fe4" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">使用于</h1><p id="61b3" class="pw-post-body-paragraph la lb iq lc b ld na ka lf lg nb kd li lj nc ll lm ln nd lp lq lr ne lt lu lv ij bi translated"><code class="fe me mf mg mh b">in</code>操作符对一个<code class="fe me mf mg mh b">union</code>类型的对象进行安全检查。在这种情况下，<code class="fe me mf mg mh b">if</code>分支缩小到将请求属性作为可选或必需属性的类型，例如:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="9b0a" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">使用文字类型保护</h1><p id="8f8e" class="pw-post-body-paragraph la lb iq lc b ld na ka lf lg nb kd li lj nc ll lm ln nd lp lq lr ne lt lu lv ij bi translated">此外，您可以使用<code class="fe me mf mg mh b">===</code>、<code class="fe me mf mg mh b">==</code>、<code class="fe me mf mg mh b">!==</code>和<code class="fe me mf mg mh b">!=</code>来区分文字值，从而形成简单的类型保护，如下例所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1fcc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这甚至适用于更复杂的例子，比如在联合中使用文字类型。您可以检查共享属性名的值来区分联合，如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="47b1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">TypeScript编译器足够聪明，可以通过<code class="fe me mf mg mh b">== null</code>和<code class="fe me mf mg mh b">!= null</code>检查来排除<code class="fe me mf mg mh b">null</code>和<code class="fe me mf mg mh b">undefined</code>，例如:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="af74" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">用户定义的防护类型</h1><p id="c88f" class="pw-post-body-paragraph la lb iq lc b ld na ka lf lg nb kd li lj nc ll lm ln nd lp lq lr ne lt lu lv ij bi translated">在实际项目中，您可能希望用自定义逻辑声明自己的类型保护，以帮助TypeScript编译器确定类型。您将需要使用您喜欢的任何逻辑来声明一个用作类型保护的函数。此函数— <em class="ma">用户自定义类型守护函数— </em>是一个以<code class="fe me mf mg mh b">event is MouseEvent</code>的形式返回一个<em class="ma">类型谓词</em>来代替返回类型的函数:</p><pre class="kp kq kr ks gt nh mh ni nj aw nk bi"><span id="4a4b" class="nl mj iq mh b gy nm nn l no np">function handle(event: any): event is MouseEvent {<br/>    // body that returns boolean<br/>}</span></pre><p id="1f67" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果函数返回<code class="fe me mf mg mh b">true</code>，TypeScript将在由函数调用保护的任何块中将类型缩小到<code class="fe me mf mg mh b">MouseEvent</code>。换句话说，类型会更具体。<code class="fe me mf mg mh b">event is MouseEvent</code>确保编译器传递给类型保护的<code class="fe me mf mg mh b">event</code>实际上是一个<code class="fe me mf mg mh b">MouseEvent</code>。例如:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a36d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这将打印:</p><pre class="kp kq kr ks gt nh mh ni nj aw nk bi"><span id="a861" class="nl mj iq mh b gy nm nn l no np">woof<br/>don’t know what this is! [[object Object]]</span></pre><p id="3306" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">守卫的函数类型谓词(函数返回类型位置的<code class="fe me mf mg mh b">test is Dog</code>)在编译时用于缩小类型，而函数体在运行时使用。类型谓词和函数必须一致，代码才能工作。</p><p id="190b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">类型守卫函数不一定要用<code class="fe me mf mg mh b">typeof</code>或者<code class="fe me mf mg mh b">instanceof</code>，可以用更复杂的逻辑。例如，这段代码检查对象属性以确定它是否是<code class="fe me mf mg mh b">Dog</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="1254" class="mi mj iq bd mk ml nx mn mo mp ny mr ms kf nz kg mu ki oa kj mw kl ob km my mz bi translated">摘要</h1><p id="2ab1" class="pw-post-body-paragraph la lb iq lc b ld na ka lf lg nb kd li lj nc ll lm ln nd lp lq lr ne lt lu lv ij bi translated">作为TypeScript最被低估的特性之一，类型保护对于缩小类型和满足编译器的要求非常有用。它们有助于确保类型安全，并促进代码更易于推理和维护。</p><p id="b097" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">有内置类型的防护装置，如<code class="fe me mf mg mh b">typeof</code>和<code class="fe me mf mg mh b">instanceof</code>，但它们的用途有限。用户定义的类型保护可以用自定义类型谓词(<code class="fe me mf mg mh b">event is MouseEvent</code>)和所需类型的唯一属性来定义。</p><p id="3414" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">要创建自定义类型保护:</p><ol class=""><li id="6d3f" class="oc od iq lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated">编写一个用谓词类型代替返回类型的函数，例如<code class="fe me mf mg mh b">event is MouseEvent</code></li><li id="13f9" class="oc od iq lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">使用<code class="fe me mf mg mh b">typeof</code>、<code class="fe me mf mg mh b">instanceof</code>或任何其他产生<code class="fe me mf mg mh b">boolean</code>值的函数运算符，实现可以确定作为参数传递的变量类型的逻辑</li></ol><p id="24f1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">使用类型保护和TypeScript编译器的强大功能会使您的应用程序可读性更好，更不容易出错。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="7ee9" class="mi mj iq bd mk ml nx mn mo mp ny mr ms kf nz kg mu ki oa kj mw kl ob km my mz bi translated">参考</h1><ul class=""><li id="7fff" class="oc od iq lc b ld na lg nb lj oq ln or lr os lv ot oi oj ok bi translated">官方<a class="ae lw" href="https://www.typescriptlang.org/docs/handbook" rel="noopener ugc nofollow" target="_blank">打字手册</a>在<a class="ae lw" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank">typescriptlang.org</a></li></ul></div></div>    
</body>
</html>