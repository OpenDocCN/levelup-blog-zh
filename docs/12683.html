<html>
<head>
<title>How to Write Better Performing React Function Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写性能更好的React函数组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-better-performing-react-function-components-8e3216a788ff?source=collection_archive---------2-----------------------#2022-06-30">https://levelup.gitconnected.com/how-to-write-better-performing-react-function-components-8e3216a788ff?source=collection_archive---------2-----------------------#2022-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2615" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">仔细编码可以节省更多的时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/570a92d406f063c588143dd30f364c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1ndjsMHbIzeVOMW0"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">劳塔罗·安德烈亚尼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="bae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将介绍如何编写性能更好的React功能组件。不包括一般意义上的web性能优化，如HTTP请求优化、缓存优化、浏览器优化等。</p><p id="0237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，我们先来谈谈React框架的性能。有许多前端框架，React并不是性能最好的，因为它包括额外的运行时、“优化的”diff算法等等。总的来说，它肯定不如直接操作DOM有高性能，但使用它意味着拥有一个强大的React社区，许多库可以使我们的效率翻倍，并且它更容易维护，也更容易被其他程序员理解。这通常也意味着更容易招募。</p><p id="0461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这并不妨碍你成为一个更好的React用户，今天就开始编码吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3970" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">React.memo()</h1><p id="15e7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数组件使用的<code class="fe mz na nb nc b">React.memo</code>和类组件使用的<code class="fe mz na nb nc b">React.PureComponent</code>效果类似。但是<code class="fe mz na nb nc b">React.memo</code>实际上是一个高阶成分。它支持第二个参数。没通过的时候会浅浅的对比一下前后道具的变化。如果没有变化，可以直接重用上次渲染的结果。</p><p id="274e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React中使用的浅层比较算法将在以下文章中详细介绍:</p><div class="nd ne gp gr nf ng"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-get-a-perfect-deep-equal-in-javascript-b849fe30e54f"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">如何在JavaScript中得到一个完美的深度相等？</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">在反应浅相等的基础上实现几乎完美的深相等。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ks ng"/></div></div></a></div><p id="8235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们传递第二个参数时，就可以得到前后两个道具，然后进行自定义对比。例如，在下面的组件中，我想将一个中心坐标点传递给map子组件，这是一个表示经度和纬度的两位数组:</p><pre class="kj kk kl km gt nv nc nw nx aw ny bi"><span id="ed1b" class="nz md it nc b gy oa ob l oc od">// Parent Component<br/>&lt;Map center={[1, 1]} /&gt;;</span><span id="c293" class="nz md it nc b gy oe ob l oc od">// Map Component<br/>const Map = (props) =&gt; {<br/>  /* render using props */<br/>};</span><span id="e24d" class="nz md it nc b gy oe ob l oc od">export default React.memo(<br/>  Map,<br/>  (prevProps, nextProps) =&gt; prevProps.toString() === nextProps.toString()<br/>);</span></pre><p id="b6c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码，我用<code class="fe mz na nb nc b">Array.prototype.toString()</code>对比了前后的值变化，当然真实的情况可能没有这么简单。</p><p id="3d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我必须把它应用到所有的功能组件上吗？答案是否定的。例如，如果父组件中没有状态变化，并且传递给子组件的props是简单的原始值类型，那么在子组件上使用<code class="fe mz na nb nc b">React.memo</code>会增加不必要的计算。这是因为在这种情况下，父组件被重新渲染，并且使用相同道具的子组件必须被重新渲染。</p><h1 id="2e08" class="mc md it bd me mf of mh mi mj og ml mm jz oh ka mo kc oi kd mq kf oj kg ms mt bi translated">React.useCallback()</h1><p id="1c24" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以传递一个内联回调和一组依赖项。如果依赖关系没有改变，则返回回调的记忆版本。</p><p id="c906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次呈现功能组件时(由状态变化等触发。)，如果我们不使用<code class="fe mz na nb nc b">useCallback</code>，将会创建一个新函数。这也意味着，如果您将此函数传递给另一个子组件，如果不使用memo自定义比较，该子组件将重新呈现。如下例所示:</p><pre class="kj kk kl km gt nv nc nw nx aw ny bi"><span id="91f9" class="nz md it nc b gy oa ob l oc od">// Parent Component<br/>const callback = () =&gt; {<br/>  doSomething(a, b);<br/>};</span><span id="1b26" class="nz md it nc b gy oe ob l oc od">const memoizedCallback = React.useCallback(() =&gt; {<br/>  doSomething(a, b);<br/>}, [a, b]);</span><span id="79a0" class="nz md it nc b gy oe ob l oc od">&lt;Map cb={callback} /&gt;;</span><span id="5501" class="nz md it nc b gy oe ob l oc od">// Map Component<br/>const Map = (props) =&gt; {<br/>  /* render using props */<br/>};</span></pre><p id="98d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面代码中的<code class="fe mz na nb nc b">memoizedCallback</code>只有在<code class="fe mz na nb nc b">a</code>和<code class="fe mz na nb nc b">b</code>改变时才会被重新创建，否则指向同一个引用。这与每次渲染时重新创建的<code class="fe mz na nb nc b">callback</code>不同。</p><h1 id="6924" class="mc md it bd me mf of mh mi mj og ml mm jz oh ka mo kc oi kd mq kf oj kg ms mt bi translated">React.useMemo()</h1><p id="6819" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">React.useMemo</code>可以传递一个“创建”函数和一组依赖项。如果依赖关系没有改变，则返回先前计算的内存值。这避免了每次渲染时的昂贵计算。</p><p id="6b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开头提到的memo例子可以这样缓存坐标:</p><pre class="kj kk kl km gt nv nc nw nx aw ny bi"><span id="97b8" class="nz md it nc b gy oa ob l oc od">// Parent Component<br/>const center = React.useMemo(() =&gt; [a, b], [a, b]);</span><span id="a3a8" class="nz md it nc b gy oe ob l oc od">&lt;Map center={center} /&gt;;</span><span id="8ad4" class="nz md it nc b gy oe ob l oc od">// Map Component<br/>const Map = (props) =&gt; {<br/>  /* render using props */<br/>};</span><span id="b11e" class="nz md it nc b gy oe ob l oc od">export default Map;</span></pre><h1 id="b4a4" class="mc md it bd me mf of mh mi mj og ml mm jz oh ka mo kc oi kd mq kf oj kg ms mt bi translated">结论</h1><p id="a5b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除此之外，还有几个零散的点可以帮到我们，比如用<code class="fe mz na nb nc b">React.Fragment</code>避免多余的元素，用条件渲染代替重返回，用键识别组件元素的变化等等。</p><p id="83dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，优化React功能组件性能的主要思路是:</p><ol class=""><li id="36b3" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">减少每次渲染的计算量，可以通过<code class="fe mz na nb nc b">useMemo</code>、<code class="fe mz na nb nc b">memo</code>等来完成。</li><li id="e875" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">减少重新渲染的次数，可以通过<code class="fe mz na nb nc b">useCallback</code>等完成。</li><li id="4914" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">让React尽可能复用DOM，尽量修改DOM而不是破坏再重新创建。</li></ol><p id="f2b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你觉得这篇文章怎么样？或者我遗漏了哪些优化点(仅供编写React功能组件使用)，请留下您的评论。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oy">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="oy">中会员</em> </a> <em class="oy">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="oy">我的链接</em> </a> <em class="oy">报名，我会得到一点佣金。</em></p><p id="a0f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的支持对我很重要——谢谢。</p><h1 id="5e83" class="mc md it bd me mf of mh mi mj og ml mm jz oh ka mo kc oi kd mq kf oj kg ms mt bi translated">了解更多信息</h1><div class="nd ne gp gr nf ng"><a href="https://blog.devgenius.io/how-to-better-poll-apis-in-react-312bddc604a4" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">如何在React中更好的轮询API？</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">setInterval的替代方案，是一个更好的间隔调用异步方法的解决方案</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">blog.devgenius.io</p></div></div><div class="np l"><div class="oz l nr ns nt np nu ks ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a href="https://betterprogramming.pub/react-18-has-been-released-implement-mini-react-in-400-lines-of-code-837559761758" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">React 18已经发布。用400行代码实现迷你反应</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">React 18中实现异步可中断更新的最小模型！</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">better编程. pub</p></div></div><div class="np l"><div class="pa l nr ns nt np nu ks ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a rel="noopener  ugc nofollow" target="_blank" href="/under-the-hood-react-vs-vue-vs-svelte-cef44d26c0bc"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">引擎盖下:反应vs. Vue vs .苗条</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">前端框架的权衡</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="np l"><div class="pb l nr ns nt np nu ks ng"/></div></div></a></div></div></div>    
</body>
</html>