<html>
<head>
<title>Storing local data with Apollo Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用阿波罗客户端存储本地数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/storing-local-data-with-apollo-client-dffc304efdfc?source=collection_archive---------7-----------------------#2020-10-05">https://levelup.gitconnected.com/storing-local-data-with-apollo-client-dffc304efdfc?source=collection_archive---------7-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b418199fe3006409ad510e3b58168b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*6rhp-fnnsAkOIJKYq9Z6Qw.gif"/></div></figure><p id="b2ce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我已经使用<a class="ae ks" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo Client </a>几年了，但从未尝试过将其作为一种本地状态管理工具。我喜欢这种方法，因为:</p><ul class=""><li id="576b" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">如果您已经使用了GraphQL和Apollo Client，您就可以避免使用像Redux这样的额外的状态管理工具。这减少了JavaScript包的大小和样板代码的数量。</li><li id="7198" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">使用相同的方法来查询数据，无论它来自后端还是本地状态。</li></ul><p id="5820" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最近，我决定试一试，但对它是如何工作的知之甚少，并提出了这样的问题:</p><ul class=""><li id="f5ca" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">使用阿波罗时，当地的州具体存放在哪里？</li><li id="f8b6" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">为什么它和阿波罗缓存混淆了？</li><li id="f036" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">为什么查询语法用于获取数据，而不是变异语法用于更改数据？</li></ul><p id="d383" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">开始时，我发现许多文章使用不推荐使用的本地解析器API来解释这个主题，这只会增加我的困惑。这篇文章是在我试图以正确的方式将地方政府管理工作整合起来的几天后发表的。</p><h1 id="dcf4" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">阿波罗当地状态及其存储方式</h1><p id="94ca" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">Apollo Client是一个状态管理库，使您能够管理本地和服务器数据。谈到本地数据，它并不能使您与存储数据的方式联系起来。您可以决定是使用<code class="fe mk ml mm mn b">localStorage</code>、<code class="fe mk ml mm mn b">indexedDB</code>还是阿波罗提供的存储。唯一明确定义的是如何查询数据:本地和服务器数据都应该使用单一的GraphQL API。换句话说，要获得当地的州数据，你需要使用<code class="fe mk ml mm mn b"><a class="ae ks" href="https://www.apollographql.com/docs/react/data/queries/" rel="noopener ugc nofollow" target="_blank">Query</a></code>。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/5f1008795c6721ee9415a26da13c9328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*NMB_VAff3uIOCpBa28_aYQ.png"/></div></figure><p id="cf1e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">阿波罗为您提供了内置的存储机制，如阿波罗<code class="fe mk ml mm mn b">InMemoryCache</code>和反应变量。<br/>我们将查看并试用两种型号。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="fb73" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将构建一个由<code class="fe mk ml mm mn b">DarkModeToggle</code>控制明暗模式的应用程序。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/65bd0a50c65d4528986861c7aa2b84a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*J1Tnn68BA3Du7Gw4Lnd4eA.gif"/></div></div></figure><p id="3ac8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于暗模式的数据将由阿波罗客户端管理。在实施本地状态管理(即查询和变更本地状态)之前，我们应该:</p><ol class=""><li id="8100" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr nf kz la lb bi translated">使用<a class="ae ks" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank">创建-反应-应用</a>创建反应项目，</li><li id="7cbf" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nf kz la lb bi translated">安装<a class="ae ks" href="https://www.apollographql.com/docs/react/get-started/" rel="noopener ugc nofollow" target="_blank"> graphql和@apollo/client </a>软件包，</li><li id="fbc1" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr nf kz la lb bi translated">初始化<code class="fe mk ml mm mn b">ApolloClient</code>并将<code class="fe mk ml mm mn b">App</code>包裹在<code class="fe mk ml mm mn b"><a class="ae ks" href="https://www.apollographql.com/docs/react/api/react/hooks/#apolloprovider" rel="noopener ugc nofollow" target="_blank">ApolloProvider</a></code>内。</li></ol><pre class="mp mq mr ms gt ng mn nh ni aw nj bi"><span id="c7d7" class="nk li iq mn b gy nl nm l nn no">// index.js</span><span id="f341" class="nk li iq mn b gy np nm l nn no">const client = new ApolloClient({</span><span id="6151" class="nk li iq mn b gy np nm l nn no">  cache: new InMemoryCache(),</span><span id="85cf" class="nk li iq mn b gy np nm l nn no">});</span><span id="04ca" class="nk li iq mn b gy np nm l nn no">render(</span><span id="21e2" class="nk li iq mn b gy np nm l nn no">  &lt;ApolloProvider client={client}&gt;</span><span id="3e4a" class="nk li iq mn b gy np nm l nn no">    &lt;App /&gt;</span><span id="53b0" class="nk li iq mn b gy np nm l nn no">  &lt;/ApolloProvider&gt;,</span><span id="aa9c" class="nk li iq mn b gy np nm l nn no">  document.getElementById("root")</span><span id="aaa2" class="nk li iq mn b gy np nm l nn no">);</span></pre><h1 id="c0dc" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">阿波罗缓存中的本地状态</h1><p id="6807" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">内存缓存是Apollo客户机的主要特性之一。它允许您将查询的数据存储在内存中，以避免在多次需要数据时不必要的网络调用。<code class="fe mk ml mm mn b">InMemoryCache</code>是一个全局对象，可以在浏览器中从<code class="fe mk ml mm mn b">window.__APOLLO_CLIENT__</code>开始检查。</p><p id="5905" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果Apollo <a class="ae ks" href="https://www.apollographql.com/docs/react/api/core/ApolloClient/#FetchPolicy" rel="noopener ugc nofollow" target="_blank">获取策略</a>允许缓存，那么将服务器请求的数据存储在缓存中是秘密进行的。而像黑暗模式这样的本地数据只存在于客户端，应该从客户端在缓存中进行初始化。因此，我们需要自己将它写入缓存。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/cafc2e02fd90e6c9fb876d77464d218f.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*eBSXO9geiK-1DEDgjKbdKQ.jpeg"/></div></figure><p id="5932" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mk ml mm mn b">App</code>组件将使用GraphQL查询读取状态，而<code class="fe mk ml mm mn b">DarkModeToggle</code>组件——Apollo客户端实例将写入新数据。</p><h2 id="33e5" class="nk li iq bd lj nr ns dn ln nt nu dp lr kf nv nw lv kj nx ny lz kn nz oa md ob bi translated">设置它:</h2><p id="0dbc" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated"><strong class="jw ir"> 1。查询数据。</strong>为了获得本地状态值，我们将使用一个简单的GraphQL查询，它只需要一个字段<code class="fe mk ml mm mn b">isDarkMode</code>。我们使用<code class="fe mk ml mm mn b">@client</code>标志告诉Apollo应该搜索本地数据，而不需要发出网络请求。</p><pre class="mp mq mr ms gt ng mn nh ni aw nj bi"><span id="0204" class="nk li iq mn b gy nl nm l nn no">const QUERY = gql`</span><span id="f583" class="nk li iq mn b gy np nm l nn no">  query getDarkMode {</span><span id="dfbd" class="nk li iq mn b gy np nm l nn no">    <strong class="mn ir">isDarkMode @client</strong></span><span id="d6f1" class="nk li iq mn b gy np nm l nn no">  }</span><span id="fa2d" class="nk li iq mn b gy np nm l nn no">`;</span></pre><p id="4832" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">令人惊讶的是，如果我们运行它，它并没有抛出错误，然而，返回值是<code class="fe mk ml mm mn b">undefined</code>,因为在缓存对象中没有定义这样的字段。</p><p id="14bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 2。为了在本地设置初始数据</strong>，我们需要将它写入缓存。借助于<code class="fe mk ml mm mn b">writeQuery</code>方法，在缓存对象上设置初始值。<code class="fe mk ml mm mn b">QUERY</code>在这种情况下与上面写的相同。</p><pre class="mp mq mr ms gt ng mn nh ni aw nj bi"><span id="a4e1" class="nk li iq mn b gy nl nm l nn no"><strong class="mn ir">cache.writeQuery</strong>({</span><span id="3c64" class="nk li iq mn b gy np nm l nn no">  query: QUERY,</span><span id="96f2" class="nk li iq mn b gy np nm l nn no">  data: {</span><span id="2d6e" class="nk li iq mn b gy np nm l nn no">    isDarkMode: true,</span><span id="ecfd" class="nk li iq mn b gy np nm l nn no">  },</span><span id="7603" class="nk li iq mn b gy np nm l nn no">});</span></pre><p id="785b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 3。在GraphQL突变的帮助下改变本地状态</strong>不再是一件事了。它在本地解析器API中可用，但不推荐使用，并被认为是一个不必要的复杂层。新的API提供了使用客户端或缓存实例直接访问和更新本地数据的方法。为了从组件中写入数据，我们使用<code class="fe mk ml mm mn b">client.writeQuery</code>。在下面的代码中，我们使用一个查询从本地状态获取<code class="fe mk ml mm mn b">currentData</code>并将其更改为相反的值。</p><pre class="mp mq mr ms gt ng mn nh ni aw nj bi"><span id="7025" class="nk li iq mn b gy nl nm l nn no">const { data: currentData } = useQuery(QUERY);</span><span id="9e56" class="nk li iq mn b gy np nm l nn no">client.writeQuery({</span><span id="3ebd" class="nk li iq mn b gy np nm l nn no">  query: QUERY,</span><span id="37c6" class="nk li iq mn b gy np nm l nn no">  data: {</span><span id="e437" class="nk li iq mn b gy np nm l nn no">    isDarkMode: !currentData.isDarkMode,</span><span id="6061" class="nk li iq mn b gy np nm l nn no">  },</span><span id="8328" class="nk li iq mn b gy np nm l nn no">});</span></pre><h1 id="512d" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">使用反应变量的局部状态</h1><p id="44e8" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">…还有阿波罗缓存。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1e3d81027335e3b761036b245867488e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*ugdWMULPGR9L5muPBgaTFA.jpeg"/></div></figure><p id="386c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">反应变量是保存、检索和修改数据的容器。就数据存储位置而言，它们不依赖于Apollo缓存。但是，它们没有为您提供查询数据的GraphQL API。因此，反应变量的使用与<code class="fe mk ml mm mn b">InMemoryCache</code>公开的GraphQL接口相耦合。<br/>“为什么不能用全局对象来代替？”你可能会问。当然可以。然而，当反应变量自动触发更新时，我们需要重新获取正在使用的GraphQL查询。</p><h2 id="5269" class="nk li iq bd lj nr ns dn ln nt nu dp lr kf nv nw lv kj nx ny lz kn nz oa md ob bi translated">设置它:</h2><p id="f0b4" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated"><strong class="jw ir"> 1。查询数据</strong>的方式与前面场景中的<a class="ae ks" href="#c0dc" rel="noopener ugc nofollow">完全相同。</a></p><p id="9afa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 2。设置初始数据。</strong>为了让Graphql查询工作，Apollo缓存需要公开它。要将本地状态字段设置到缓存，应使用<code class="fe mk ml mm mn b">typePolicies</code>。这个API允许我们定制字段，无论它们是本地的还是来自后端的。对于每个字段，您可以定义2个功能:<code class="fe mk ml mm mn b">read()</code>和<code class="fe mk ml mm mn b">merge()</code>。第一个在读取缓存时截取数据，即查询数据。第二种是写入数据时，即发生突变时。换句话说，它使我们能够控制当我们请求数据时从缓存返回的数据，以及当我们更改数据时保存到缓存的数据。在我们的场景中，我们需要指定在读取时返回哪个值。首先，它可以是静态的，如下例所示。</p><pre class="mp mq mr ms gt ng mn nh ni aw nj bi"><span id="59a1" class="nk li iq mn b gy nl nm l nn no">// ./cache.js</span><span id="f9fb" class="nk li iq mn b gy np nm l nn no">export const cache = new InMemoryCache({<br/>  typePolicies: {<br/>    Query: {<br/>      fields: {<br/>        isDarkMode: {<br/>          <strong class="mn ir">read() {<br/>            return false;<br/>          },</strong><br/>        },<br/>      },<br/>    },<br/>  },<br/>});</span></pre><p id="5430" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">经过这些变化，当我们查询数据时，它不再是<code class="fe mk ml mm mn b">undefined</code>。我们得到值<code class="fe mk ml mm mn b">false</code>，然而，它将一直是相同的，但是它需要是“反应性的”。<br/>使用<code class="fe mk ml mm mn b">makeVar</code>方法创建一个反应变量。下面我们用初始值<code class="fe mk ml mm mn b">false</code>创建了<code class="fe mk ml mm mn b">isDarkModeVar</code>。</p><pre class="mp mq mr ms gt ng mn nh ni aw nj bi"><span id="340d" class="nk li iq mn b gy nl nm l nn no">// ./localStorage.js</span><span id="2638" class="nk li iq mn b gy np nm l nn no">import { makeVar } from "@apollo/client";                                               </span><span id="c782" class="nk li iq mn b gy np nm l nn no"><strong class="mn ir">export const isDarkModeVar = makeVar(true);</strong></span></pre><p id="b629" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过从<code class="fe mk ml mm mn b">read()</code>函数返回<code class="fe mk ml mm mn b">isDarkModeVar</code>，我们定义了当这个字段被查询时，从<code class="fe mk ml mm mn b">isDarkModeVar</code>中获取它的值。</p><pre class="mp mq mr ms gt ng mn nh ni aw nj bi"><span id="43b0" class="nk li iq mn b gy nl nm l nn no">// ./cache.js</span><span id="e832" class="nk li iq mn b gy np nm l nn no"><strong class="mn ir">import { isDarkModeVar } from "./localStorage";</strong></span><span id="8092" class="nk li iq mn b gy np nm l nn no">export const cache = new InMemoryCache({<br/>  typePolicies: {<br/>    Query: {<br/>      fields: {<br/>        isDarkMode: {<br/>          read() {<br/>            <strong class="mn ir">return isDarkModeVar();</strong><br/>          },<br/>        },<br/>      },<br/>    },<br/>  },<br/>});</span></pre><p id="c9f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 3。变异数据。</strong> <code class="fe mk ml mm mn b">isDarkModeVar</code>可用于app的任何组件。我们通过调用并传递一个新值给<code class="fe mk ml mm mn b">isDarkModeVar</code>方法来改变本地状态数据。这些变化会自动触发缓存更新，并且<code class="fe mk ml mm mn b">useQuery</code>会返回新数据，导致组件使用新的本地状态重新呈现。</p><pre class="mp mq mr ms gt ng mn nh ni aw nj bi"><span id="cb0e" class="nk li iq mn b gy nl nm l nn no">import { isDarkModeVar } from "./localStorage";</span><span id="065f" class="nk li iq mn b gy np nm l nn no">const toggleDarkMode = () =&gt; {</span><span id="734c" class="nk li iq mn b gy np nm l nn no">  const current = isDarkModeVar();</span><span id="711e" class="nk li iq mn b gy np nm l nn no"><strong class="mn ir">  isDarkModeVar(!current); </strong></span><span id="9506" class="nk li iq mn b gy np nm l nn no">};</span><span id="4b09" class="nk li iq mn b gy np nm l nn no">// ...</span><span id="600c" class="nk li iq mn b gy np nm l nn no">&lt;input type="checkbox" onChange={toggleDarkMode} /&gt;</span></pre></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="ae05" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这两种情况下，重新加载页面都会导致数据丢失，因为缓存只保存在当前窗口范围内。Apollo为我们提供了<a class="ae ks" href="https://github.com/apollographql/apollo-cache-persist" rel="noopener ugc nofollow" target="_blank"> apollo-cache-persist </a>库，它通过将数据保存到<code class="fe mk ml mm mn b">window.localStorage</code>来处理这个问题。</p><h1 id="4092" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">总结</h1><p id="e160" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">关键的经验是:</p><ul class=""><li id="05f8" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">如果您已经使用了Graphql和Apollo Client，那么无论数据是来自后端还是本地状态，您都可以从单一的数据查询方法中受益。</li><li id="b390" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">使用Apollo客户机可以在很多地方存储本地状态。<a class="ae ks" href="https://www.apollographql.com/docs/react/local-state/reactive-variables/" rel="noopener ugc nofollow" target="_blank">反应变量API </a>是一个需要最少代码的选项，更容易学习、使用和调试。</li><li id="969e" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">您不需要在客户端实现用于改变本地状态的解析器，因为您需要在服务器端解决改变。不推荐使用解析器API，而应使用Apollo InMemoryCache和/或反应变量。</li></ul><p id="fdf9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我还没有在大规模的网络应用程序上尝试过，但是如果你有，请分享你的经验🙏</p><p id="2558" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另外，你可以在这里找到一个带有反应变量实现<a class="ae ks" href="https://github.com/imeugenia/local-state-mngmt-with-apollo" rel="noopener ugc nofollow" target="_blank">的示例项目。</a></p></div></div>    
</body>
</html>