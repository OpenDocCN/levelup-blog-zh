# 用 Java 优雅地管理对象的 3 个原则

> 原文：<https://levelup.gitconnected.com/3-principles-to-manage-your-objects-elegantly-in-java-bbb56aa51401>

![](img/3d0c5c24fefd0b1331b3c767d971c9db.png)

图片由 Lisa Fotios 提供

学习使用设计模式更有效地管理您的对象

Java 是一种面向对象的编程语言。就像它的定义一样，对象在其中扮演着巨大的角色。因此，学会正确管理对象对于 Java 项目的性能和成功至关重要。在本文中，我总结了 3 个原则和实现方法，以帮助您实现更有效的对象管理。

## 原则 1:控制实例的数量

对象分配可能会消耗大量资源，如果管理不当，很快就会成为瓶颈。最重要的事情之一是确保不要在某些对象上创建过多的实例。不必要的实例会给你的程序带来巨大的时间和空间开销。在这里，我列出了一些避免创建不必要的实例的方法。

1.  **尝试使用静态工厂方法**

首先，我想澄清一下，静态工厂方法与设计模式中的工厂方法无关。什么是静态工厂方法？好吧，假设你的手机快没电了，你需要一个`charger`。通常，我们会写`Charger getMeACharger = new Charger().`然而，你真的想每次给手机充电都换一个新的充电器吗？大概不会。一个更好的主意是从你桌子的抽屉里拿一个充电器，并在那里挑选一个可用的充电器。在 Java 中，你桌子的抽屉就是工厂，挑选可用充电器的动作就是你想要的方法。为了实现这一点，我们必须使方法成为静态的，这样我们就不需要为了得到我们的`charger`而拥有我们工厂的一个实例。在 Java 中，它看起来像这样:

上面是一个静态工厂方法的例子。在这种情况下，我们的`DeskDrawerChargerFactory`是工厂，我们可以从我们的工厂拿实例，而不是做传统的`new`方法。

通过这种方式，我们可以控制对象的总数，如果需要，我们可以调用静态工厂方法来返回一个实例，并基于该实例执行操作。许多现实世界中的应用程序，如 JDBC，强制执行这样的良好实践来限制您的程序可以拥有的数据库连接数。如果允许我们根据需要创建任意数量的数据库连接，那么很有可能数据库会被请求淹没，无法正常响应。当然，还有许多其他的原因让您想使用静态工厂方法。使用这种做法允许您将所需的 instance 子类返回给 user，这是普通构造函数无法做到的；它允许您使用更有意义的名称以获得更好的可读性。例如，假设你想要一个复数类，像`ComplexNumbers.createFromXYCoordinate(double x, double u)`或`ComplexNumbers.createFromPolarCoordinate(double distance, double angle)`这样的方法名似乎比`ComplexNumbers c = new ComplexNumbers(x,y)`更好。

2.**强制非实质性**

这个想法乍听起来很疯狂:如果不允许我们实例化对象，Java 是干什么用的？嗯，有些情况下你确实想要不可实现性。例如，有时您会编写 util 类。这些 util 类不包含状态/属性，因此您可以直接调用它们的静态方法来实现您想要的。有时，如果其他人不小心实例化了这样的 util 类，这可能是一种资源浪费，尤其是对于那些具有大量方法的巨型 util 类。因此，您希望确保人们无法实例化这些类。一种有效的方法是将构造函数设置为私有的。请注意，如果您没有显式实现构造函数，Java 将提供一个默认的构造函数，有时人们可能会偶然调用默认的构造函数。因此，检查您的 util 类，并确保有一个私有构造函数。

3.**注意库中的方法**

这是一个棘手的问题，它严重依赖于您对代码库的了解。然而，这是相当重要的。举个简单的例子:字符串串联`+`。在幕后，`+`操作将创建一个 StringBuilder 操作符，并使用它将我们的字符串连接在一起。考虑以下程序:

在每个循环中，将构造一个 StringBuilder 对象，`str = str + i`将被大致翻译成`StringBuilder builder = new StringBuilder(str); builder.append(i); str = builder.toString();`你看，这样，我们将有 1000 个内部构造的 StringBuilder 对象，这可能不是我们所希望的。相反，请尝试执行以下操作:

创建的 StringBuilder 的数量从 1000 减少到 1，这个数字可能会对您的程序有所帮助。

其他的例子包括`String.matches`法。它会在你每次调用它的时候创建内部对象。假设您的服务器每秒钟运行 10000 次这种方法，如果您能找到替代方法，您的性能会好得多。一种方法是创建一个内部对象的静态等价对象，这样你只需要创建一次这个对象。

## 原则 2:使实例化具有可读性和可伸缩性

我这么说是什么意思？嗯，我的意思是有两件事我们需要注意。

1.  **参数过多的构造器**

第一个是我们应该为那些有许多构造函数参数对象使用构建器模式。

考虑一下，我们正在编写一个汉堡类，它需要一个名为`bun`的组件、一个名为`meat`的组件和一个名为`in-between` 的组件(奶酪、生菜)。此外，我们可以允许我们的客户添加两个额外的`in-between`，这样总共剩下 5 个参数。因为三个是必需的，两个是可选的，传统上我们需要提供三个构造函数:

如你所见，随着参数数量的增长，我们必须编写越来越多的构造函数。设定者有出路。然而，设置器仍然不是那么有效。为了找到更好的解决方案，我们考虑如下的构建器模式:

2.**使用依赖注入**

第二件值得一提的事情是尽可能使用依赖注入。有时，我们会有一个依赖于许多其他对象的类`A`，比如说`B, C, D, E`。虽然我们可以一个接一个地创造它们(`B, C, D, E`)，但事情会很快变得不可收拾。如果`B`也有几个依赖关系，并且它的依赖关系还有进一步的依赖关系呢？在这种情况下，为了实例化一个`A`，我们必须实例化数百个类，我们甚至很难找出依赖路径。当我们试图模仿一些依赖类时，这在测试中尤其困难。

幸运的是，依赖来拯救！在这里，我不会进一步解释依赖，但要提到的是，它是一种机制，允许计算机自动注入你需要的依赖类到适当的地方。有大量的依赖注入库，我会让你通过搜索关键词来发现你最喜欢的。

## 原则 3:检查可能的参考泄漏

是的，你没听错！Java 中确实存在引用泄漏或内存泄漏。虽然 Java 为我们处理了内存管理，但是它不能处理所有的情况。如今，JVM 仍然依赖引用计数作为垃圾收集或内存管理的主要机制。因此，如果我们不小心留下了一个我们不会使用的对象的引用，这将影响我们的程序，甚至会把我们带到熟悉的`stackoverflow`！！！

假设你自己正在实现一个`Queue`类，你像这样写`pop()`方法:

在这种情况下，我们直接返回数组中某个元素的引用，没有像`data_array[index] = null;`那样写一些语句。然后，该数组仍将引用附加到该对象。假设您在一个非常大的数组中执行这个有问题的代码，JVM 将跳过成百上千个应该被垃圾收集的对象！如果我们不能及时发现这一点，记忆很可能很快就会被填满。因此，要时刻注意潜在的引用泄漏，因为它们会对您的程序造成真正的损害。缓存是引用泄漏的一个常见位置。假设您在缓存中存储了 1 个对象，但它从未被命中，并且它可以在缓存中停留很长一段时间，具体取决于您的缓存驱逐算法。由于缓存仍将保留对该对象的引用，因此无法正确清理它。有时候，侦听器、回调甚至操作系统页面交换都会导致引用泄漏！

对抗引用/内存泄漏的一些潜在有用的实践是分析程序的内存以查看是否有任何异常，或者您可以直接进入 JVM，寻找内存信息并进行堆转储(清除内存堆)。

这是我为您总结的三个原则，可以让您更好地控制 Java 程序的性能和资源。没有适合所有情况的完美解决方案，但是请记住这些实践，它们可能会在一些常见的情况下帮助你。快乐学习，快乐编码！