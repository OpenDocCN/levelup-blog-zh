<html>
<head>
<title>Creating A Colliding Object With Vector Physics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用矢量物理创建碰撞物体</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-colliding-object-with-vector-physics-b784bed91505?source=collection_archive---------11-----------------------#2020-07-21">https://levelup.gitconnected.com/creating-a-colliding-object-with-vector-physics-b784bed91505?source=collection_archive---------11-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5384" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将使用基于Java的处理库创建一个基于矢量物理的简单碰撞器。</p><p id="86a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意</strong>:本文假设你已经掌握了Java语法和面向对象编程的基本知识。加工库及其文档均可在<a class="ae kp" href="https://processing.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">此处</strong> </a>获得。</p><h1 id="6a26" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">向量</h1><p id="7b41" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在我们开始之前，我们必须了解什么是向量以及它是如何工作的。一个矢量有两个属性:一个<strong class="js iu">方向</strong>和一个<strong class="js iu">大小</strong>，可以通过画一个从A点到b点的箭头来说明。</p><p id="c766" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能已经猜到了，方向是由箭头指向的地方来表示的。箭头的长度称为它的大小。</p><p id="1608" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果我们有一个长度为5个单位的45度角的顺时针箭头，我们说它的方向是东北方向，大小为5。每个向量使用x和y坐标定义其位置，在3D空间中，我们还有深度元素:z轴。</p><blockquote class="lt lu lv"><p id="84bf" class="jq jr ko js b jt ju jv jw jx jy jz ka lw kc kd ke lx kg kh ki ly kk kl km kn im bi translated">通过矢量，我们可以编程并模拟<strong class="js iu">运动</strong>。</p></blockquote><p id="6258" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对象在屏幕上的位置是从原点(0，0)到其在物理或虚拟空间中的实际位置的向量。速度是另一个向量，告诉对象如何在特定方向上从一个点移动到另一个点，例如“向右移动3个单位，向上移动5个单位”(3，-5)。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/c936f088e3a818bde2f52089981e10ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6sXRdGwzkpsrjRKZ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">位置和速度向量。参见<strong class="bd ks">中的</strong>代码的性质。</figcaption></figure><p id="cdb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运动的算法很简单<strong class="js iu">把位置和速度矢量</strong>加在一起！</p><p id="2a0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在处理过程中，我们有<strong class="js iu"> PVector </strong>数据结构，它有两个浮点属性:x和y。还有可选的z属性用于3D模拟。本质上，它只是存储两个或三个坐标值的一种便捷方式。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="bdd2" class="mu kr it mq b gy mv mw l mx my"><strong class="mq iu">class</strong> PVector {</span><span id="a14e" class="mu kr it mq b gy mz mw l mx my"> <strong class="mq iu">float</strong> x;<br/> <strong class="mq iu">float</strong> y;</span><span id="b92d" class="mu kr it mq b gy mz mw l mx my"> PVector(<strong class="mq iu">float</strong> x, <strong class="mq iu">float</strong> y) {<br/>  <strong class="mq iu">this</strong>.x = x;<br/>  <strong class="mq iu">this</strong>.y = y;<br/> }</span><span id="7bef" class="mu kr it mq b gy mz mw l mx my">}</span></pre><p id="8dfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们想象一下，在屏幕上的(2，5)处有一个物体。我们想以3个单位的速度向右移动。我们可以简单地这样写。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="be2f" class="mu kr it mq b gy mv mw l mx my"><strong class="mq iu">PVector</strong> location = <strong class="mq iu">new</strong> <strong class="mq iu">PVector</strong>(2, 5);<br/><strong class="mq iu">PVector</strong> velocity = <strong class="mq iu">new</strong> <strong class="mq iu">PVector</strong>(3, 0);</span><span id="58f6" class="mu kr it mq b gy mz mw l mx my">location.<strong class="mq iu">add</strong>(velocity); // new location is (5, 5)</span></pre><p id="f9ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">矢量加法只是将两个矢量的x坐标相加，并对y坐标进行同样的操作。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/80391893a116f35e74bdcd4abbfbae73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qdiCCvQu5HtE5NN3.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">向量加法的一个例子。参见<strong class="bd ks">代码的本质</strong>。</figcaption></figure><h1 id="1bce" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">检测碰撞</h1><p id="dddc" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">现在你知道了什么是矢量，运动是如何工作的，我们可以看看如何检测碰撞。毕竟，这篇文章的重点是创建一个碰撞物体。</p><p id="c722" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，一个物体不知道它是否碰撞到了什么东西——即使它触及了我们屏幕的边界。让我们想象一下，我们想把我们的窗口变成一个对撞机。我们如何做到这一点？</p><p id="3cf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们知道我们可以使用位置向量来跟踪物体在屏幕上的位置。屏幕上的任何像素都有一个位置向量。因为从技术上来说，组成窗口的每个像素都是一个对象！</p><p id="d9ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果我们想要获得大小为640×360的窗口右下角的位置向量，我们可以将其表示为(<em class="ko"> 640，360 </em>)。在一个简单的矩形空间中，我们有四种可能发生碰撞的情况。</p><ol class=""><li id="1866" class="na nb it js b jt ju jx jy kb nc kf nd kj ne kn nf ng nh ni bi translated">我们对象的x坐标小于我们窗口的起点。对象在<strong class="js iu"> ( <em class="ko"> x &lt; 0 </em>，<em class="ko"> y </em> ) </strong>。</li><li id="50de" class="na nb it js b jt nj jx nk kb nl kf nm kj nn kn nf ng nh ni bi translated">我们对象的y坐标小于我们窗口的起点。物体在<strong class="js iu"> ( <em class="ko"> x，y &lt; 0 </em> ) </strong>。</li><li id="13d2" class="na nb it js b jt nj jx nk kb nl kf nm kj nn kn nf ng nh ni bi translated">我们对象的x坐标大于我们窗口的宽度。对象在<strong class="js iu"> <em class="ko"> (x &gt; 640，y) </em> </strong>。</li><li id="a063" class="na nb it js b jt nj jx nk kb nl kf nm kj nn kn nf ng nh ni bi translated">我们对象的y坐标大于我们窗口的高度。物体在<strong class="js iu"> <em class="ko"> (x，y &gt; 360) </em> </strong>。</li></ol><blockquote class="lt lu lv"><p id="7bdd" class="jq jr ko js b jt ju jv jw jx jy jz ka lw kc kd ke lx kg kh ki ly kk kl km kn im bi translated">在处理过程中，我们可以分别使用全局变量<strong class="js iu">宽度</strong>和<strong class="js iu">高度</strong>来访问屏幕的宽度和高度。</p></blockquote><p id="5838" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们看如何用代码编写之前，我们需要定义当对象检测到碰撞时发生了什么。为简单起见，我们将模拟一个简单的弹跳球，而不计算真实世界的因素，如重力、摩擦力和加速度。</p><p id="2d4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们可以说，在碰撞时，物体将以均匀的方式弹回。为了实现这一点，我们需要通过将速度向量上相应的轴乘以-1来反转球的运动方向。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="3547" class="mu kr it mq b gy mv mw l mx my"><strong class="mq iu">void</strong> detectCollisions() {</span><span id="8254" class="mu kr it mq b gy mz mw l mx my"> <strong class="mq iu">if</strong> (<strong class="mq iu">location</strong>.x &lt; 0 || <strong class="mq iu">location</strong>.x &gt; <strong class="mq iu">width</strong>) {<br/>  velocity.x = velocity.x * -1; <br/><em class="ko">  // ball now moves in opposite horizontal direction<br/></em> }</span><span id="4d5f" class="mu kr it mq b gy mz mw l mx my"><strong class="mq iu"> if</strong> (<strong class="mq iu">location</strong>.y &lt; 0 || <strong class="mq iu">location</strong>.y &gt; <strong class="mq iu">height</strong>) {<br/>  velocity.y = velocity.y * -1;<br/>  <em class="ko">// ball now moves in opposite vertical direction<br/> </em>}</span><span id="cb74" class="mu kr it mq b gy mz mw l mx my">}</span></pre><p id="7395" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经对向量有了一个概述，并对如何模拟碰撞有了一个想法，我们准备创建真实的东西。</p><h1 id="5f24" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">创建模拟</h1><p id="b6d2" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">让我们来看看我们想要在这个程序中创建的两个主要组件:一个碰撞器和一个移动的物体。</p><p id="e23a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望这比我们迄今为止的想法更酷一点，所以我们将在3D空间中工作。对于我们的碰撞器，我们将使用一个立方体，我们的对象将是一个球体。</p><p id="7722" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">加工有两个主要的内置方法，<strong class="js iu">设置</strong>和<strong class="js iu">绘制。</strong>在<em class="ko"> setup </em>方法中，我们通常初始化我们想要使用的变量。在我们模拟的生命周期中，它将只被调用一次。另一方面，<em class="ko"> draw </em>方法在每一帧都会被调用，因为它会重新绘制整个场景。位置和速度的变化必须发生在<em class="ko">抽屉</em>内。</p><h2 id="1714" class="mu kr it bd ks no np dn kw nq nr dp la kb ns nt le kf nu nv li kj nw nx lm ny bi translated">步骤1:创建碰撞器类</h2><p id="afae" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">首先，我们将把碰撞器放在3D工作空间的中间。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="3aa7" class="mu kr it mq b gy mv mw l mx my"><strong class="mq iu">class</strong> Box {<br/>  <strong class="mq iu">private</strong> <strong class="mq iu">float</strong> _size;<br/>  <br/>  Box(<strong class="mq iu">float</strong> size) {<br/>    _size = size;<br/>  }<br/>  <br/>  <strong class="mq iu">float</strong> getRadius() {<br/>    <strong class="mq iu">return</strong> _size / 2;<br/>  }<br/>  <br/>  <strong class="mq iu">void</strong> drawBox() {<br/>    <strong class="mq iu">translate</strong>(width/2, height/2, _size);<br/>    <strong class="mq iu">rotateY</strong>(QUARTER_PI);<br/>  <br/>    <strong class="mq iu">noFill</strong>();<br/>    <strong class="mq iu">stroke</strong>(255);<br/>    <br/>    <strong class="mq iu">box</strong>(_size);<br/>  }<br/>}</span></pre><p id="30fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们在上面的代码片段中看到的，这里发生了很多事情。盒子有一个名为size的属性，用来定义它有多大。它还有一个<em class="ko"> getRadius </em> getter方法，我们将在碰撞检测中用到它。</p><p id="1bb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个类的主要方法是drawBox。因为我们想把它放在屏幕的中间，所以我们将x轴设为宽度的一半，y轴设为高度的一半。</p><p id="21c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，我们旋转45°，引用全局变量<em class="ko"> QUARTER_PI，</em>在y轴上强调3D效果。这完全是可选的，可以省略。最后，我们用白色(255)轮廓和构造函数中指定的大小绘制一个透明框。</p><h2 id="2ca5" class="mu kr it bd ks no np dn kw nq nr dp la kb ns nt le kf nu nv li kj nw nx lm ny bi translated"><strong class="ak">第二步:创建移动物体</strong></h2><p id="d235" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">“感动”这个词应该足够告诉你了。矢量在这里开始混合。这个类还将处理我们之前看到的冲突检测功能。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="4b3c" class="mu kr it mq b gy mv mw l mx my"><strong class="mq iu">class</strong> Ball {<br/>  <strong class="mq iu">private</strong> <strong class="mq iu">float</strong> _size;<br/>  <strong class="mq iu">private</strong> <strong class="mq iu">PVector</strong> _location;<br/>  <br/>  Ball(<strong class="mq iu">float</strong> size) {<br/>    _size = size;<br/>    _location = <strong class="mq iu">new</strong> <strong class="mq iu">PVector</strong>();<br/>  }<br/>  <br/>  <strong class="mq iu">void</strong> move(<strong class="mq iu">PVector</strong> velocity, <strong class="mq iu">float</strong> colliderSize) {<br/>    _location.<strong class="mq iu">add</strong>(velocity);</span><span id="1f46" class="mu kr it mq b gy mz mw l mx my"><strong class="mq iu">    if</strong> (<strong class="mq iu">checkBounce</strong>(_location.x, colliderSize)) {<br/>      velocity.x = velocity.x * -1;<br/>    }<br/>      <br/>    <strong class="mq iu">if</strong> (<strong class="mq iu">checkBounce</strong>(_location.y, colliderSize)) {<br/>      velocity.y = velocity.y * -1;<br/>    }<br/>    <br/>    <strong class="mq iu">if</strong> (<strong class="mq iu">checkBounce</strong>(_location.z, colliderSize)) {<br/>      velocity.z = velocity.z * -1;<br/>    }<br/>  }<br/>  <br/>  <strong class="mq iu">void</strong> drawBall() {<br/>    <strong class="mq iu">translate</strong>(_location.x, _location.y, _location.z);<br/>    <br/>    <strong class="mq iu">fill</strong>(255);<br/>    <strong class="mq iu">noStroke</strong>();</span><span id="e16c" class="mu kr it mq b gy mz mw l mx my">    <strong class="mq iu">sphere</strong>(_size);<br/>  }<br/>  <br/>  <strong class="mq iu">private</strong> <strong class="mq iu">boolean</strong> checkBounce(<strong class="mq iu">float</strong> coord, <strong class="mq iu">float</strong> colliderSize) {<br/>    <strong class="mq iu">return</strong> <br/>     coord &gt; colliderSize - _size || <br/>     coord &lt; _size - colliderSize;<br/>  }<br/>}</span></pre><p id="4cb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的移动对象有两个属性:大小和位置向量。就像我们的对撞机一样，它需要给自己上色，还要移动。</p><p id="24e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">move方法对我们来说很熟悉，因为它包含了我们已经探索过的理解运动和碰撞的逻辑。请注意，我们这次也在z轴上检查碰撞，因为我们是在3D中。</p><p id="0629" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，在这种情况下，碰撞边界是盒子的面，而不是窗口的尺寸。这里我们还需要记住两个要点，让事情变得简单。</p><ol class=""><li id="08c2" class="na nb it js b jt ju jx jy kb nc kf nd kj ne kn nf ng nh ni bi translated">移动对象是从屏幕中间开始的<em class="ko">。</em></li><li id="7900" class="na nb it js b jt nj jx nk kb nl kf nm kj nn kn nf ng nh ni bi translated">碰撞区域是一个立方体，因此我们可以假设所有轴的半径都相同。这是所示代码中的<em class="ko">碰撞器大小</em>。</li></ol><p id="99af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，碰撞条件是:</p><ul class=""><li id="528b" class="na nb it js b jt ju jx jy kb nc kf nd kj ne kn nz ng nh ni bi translated">球的x/y/z坐标是<strong class="js iu"> <em class="ko">小于</em> </strong>盒子的半径减去球的大小。</li><li id="7b27" class="na nb it js b jt nj jx nk kb nl kf nm kj nn kn nz ng nh ni bi translated">球的x/y/z坐标是<strong class="js iu"> <em class="ko">大于</em> </strong>盒子的半径减去球的大小。</li></ul><h2 id="1506" class="mu kr it bd ks no np dn kw nq nr dp la kb ns nt le kf nu nv li kj nw nx lm ny bi translated">第三步:把所有东西放在一起</h2><p id="2c95" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">现在我们来看看将所有东西联系在一起的代码。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="1c98" class="mu kr it mq b gy mv mw l mx my"><strong class="mq iu">Box</strong> box;<br/><strong class="mq iu">Ball</strong> ball;</span><span id="ef12" class="mu kr it mq b gy mz mw l mx my"><strong class="mq iu">PVector</strong> velocity;</span><span id="005c" class="mu kr it mq b gy mz mw l mx my"><strong class="mq iu">void</strong> <strong class="mq iu">setup</strong>() {<br/>  <strong class="mq iu">size</strong>(600, 600, P3D);</span><span id="6970" class="mu kr it mq b gy mz mw l mx my">  box = <strong class="mq iu">new</strong> <strong class="mq iu">Box</strong>(200);<br/>  ball = <strong class="mq iu">new</strong> <strong class="mq iu">Ball</strong>(20);<br/>  <br/>  velocity = <strong class="mq iu">new</strong> <strong class="mq iu">PVector</strong>(10, 5, 2);<br/>}</span><span id="9a22" class="mu kr it mq b gy mz mw l mx my"><strong class="mq iu">void</strong> <strong class="mq iu">draw</strong>() {<br/>  <strong class="mq iu">background</strong>(0);</span><span id="1796" class="mu kr it mq b gy mz mw l mx my">  <strong class="mq iu">lights</strong>();<br/>  <strong class="mq iu">ambientLight</strong>(255, 0, 0);</span><span id="77d4" class="mu kr it mq b gy mz mw l mx my">  box.<strong class="mq iu">drawBox</strong>();</span><span id="24d5" class="mu kr it mq b gy mz mw l mx my">  ball.<strong class="mq iu">move</strong>(velocity, box.<strong class="mq iu">getRadius</strong>());<br/>  ball.<strong class="mq iu">drawBall</strong>();<br/>}</span></pre><p id="37d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先用一个3D空间来声明屏幕的大小，并初始化我们的碰撞器和移动物体。此外，我们设置一个起始速度矢量。</p><p id="4d95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在每一帧渲染中，我们重新绘制背景和灯光。接下来，我们绘制碰撞器，通过将速度向量添加到球的位置来更新球的位置，并基于碰撞器的半径检查碰撞。最后，我们在球的当前位置绘制球。</p><p id="8b13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终结果应该类似于下面的模拟。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oa"><img src="../Images/d1b3d4f6e77592f39d78f1d5428cd2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lWjDorXMIvN13DySOubbxg.gif"/></div></div></figure><h2 id="a6b8" class="mu kr it bd ks no np dn kw nq nr dp la kb ns nt le kf nu nv li kj nw nx lm ny bi translated"><strong class="ak"> <em class="ob">参考文献</em> </strong></h2><p id="d418" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated"><em class="ko">代码的本质，丹尼尔·希夫曼</em></p></div></div>    
</body>
</html>