<html>
<head>
<title>Django: When REST May Not Be Enough and How a GraphQL Layer Can Help Save You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django:什么时候REST可能还不够，GraphQL层如何帮助你</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/django-when-rest-may-not-be-enough-and-how-a-graphql-layer-can-help-save-you-d9bc58919d1?source=collection_archive---------4-----------------------#2021-04-15">https://levelup.gitconnected.com/django-when-rest-may-not-be-enough-and-how-a-graphql-layer-can-help-save-you-d9bc58919d1?source=collection_archive---------4-----------------------#2021-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="99df" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">简介</strong></h2></div><p id="f789" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将介绍一个成熟的基于REST的API 的维护者面临的常见问题，这个API是使用Django REST框架构建的。然后，我们将继续演示<a class="ae lb" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>如何为这个问题提供解决方案，以及如何通过使用<a class="ae lb" href="https://github.com/PaulGilmartin/graph_wrap" rel="noopener ugc nofollow" target="_blank"> GraphWrap库</a>向Django项目添加两行代码来应用这个解决方案。</p><h2 id="6168" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">该设置</h2><p id="458c" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">页（page的缩写）核桃公司是一家历史悠久的出版公司。他们有一个成熟的基于REST的API，是使用Django REST框架(DRF)构建的。这个API允许消费者获取关于<code class="fe ma mb mc md b">books</code>或<code class="fe ma mb mc md b">authors</code>的信息。这个API有三个主要消费者:核桃树公司网站、核桃树公司Android/OS应用和外部客户端。</p><p id="3171" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">遵循典型的REST范例，API消费者可以通过“列表”<code class="fe ma mb mc md b">/author/</code>端点找到他们有权查看的所有作者的详细信息，并可以通过“细节”<code class="fe ma mb mc md b">/author/id/</code>端点查看特定作者的详细信息。类似的终点被暴露给<code class="fe ma mb mc md b">book</code>。在幕后，这些端点由以下DRF系列产品提供服务:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="3311" class="lc ld iq md b gy mm mn l mo mp">class AuthorSerializer(serializers.ModelSerializer):<br/>    class Meta:<br/>       model = Author<br/>       fields = ['name', 'active', 'profile']<br/>  </span><span id="8995" class="lc ld iq md b gy mq mn l mo mp">class BookSerializer(serializers.ModelSerializer):<br/>    author = serializers.HyperlinkedRelatedField(<br/>          view_name='author-detail', read_only=True)<br/>    class Meta:<br/>        model = Book<br/>        fields = ['author', 'title', 'page_count']</span></pre><h2 id="94f9" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">问题是</h2><p id="86cb" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">该公司网站包括一个网页，用户可以浏览现有的书籍。当一本书被点击时，我们会重定向到一个页面，这个页面会提供关于这本书及其作者的更多信息。为了获取服务于该页面的数据，web客户端调用，例如<code class="fe ma mb mc md b">/book/1/</code>，它将给出如下所示的响应:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="8ed6" class="lc ld iq md b gy mm mn l mo mp">{<br/>  'author': '/author/1/',<br/>  'title': 'Lovely Gardens',<br/>  'page_count': 200,<br/>}</span></pre><p id="f077" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，web客户端在这里没有获得太多关于图书作者的信息。为了获得这些数据，他们需要第二次调用<code class="fe ma mb mc md b">/author/1/</code>。这就是众所周知的<a class="ae lb" href="https://itnext.io/what-is-the-n-1-problem-in-graphql-dd4921cb3c1a" rel="noopener ugc nofollow" target="_blank"> n+1问题</a>。会导致网站效率低下，前端架构过于复杂；这是我们想要避免的！那么我们该如何解决这个问题呢？</p><h2 id="53bf" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">尝试在DRF本土解决问题</h2><p id="46e5" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">满足我们的web客户端的显而易见的解决方案是在我们的<code class="fe ma mb mc md b">/book</code>端点上简单地公开更多的作者字段。我们将向<code class="fe ma mb mc md b">BookSerializer</code>添加一个<code class="fe ma mb mc md b">author_full</code>字段，如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="d7bf" class="lc ld iq md b gy mm mn l mo mp">class BookSerializer(serializers.ModelSerializer):<br/>    author = serializers.HyperlinkedRelatedField(<br/>          view_name='author-detail', read_only=True)<br/>    author_full = AuthorSerializer(source='author_full')</span><span id="9513" class="lc ld iq md b gy mq mn l mo mp">    class Meta:<br/>        model = Book<br/>        fields = ['author', 'author_full', 'title', 'page_count']</span></pre><p id="9b04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们的web客户端请求<code class="fe ma mb mc md b">/book/1/</code>时，它们也会获得作者的完整表示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5d19" class="lc ld iq md b gy mm mn l mo mp">{<br/>  'author': '/author/1/',<br/>  'title': 'Lovely Gardens',<br/>  'page_count': 200,<br/>  'author_full': {<br/>      'name': 'Emilie B.',<br/>      'active': True,<br/>      'profile': '/profile/1/',<br/>   }<br/>}</span></pre><p id="b15c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的web客户端现在可以使用一个GET请求来提供“图书详情”页面。大家都很开心！</p><p id="9052" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二天，我们的应用程序客户端找到我们，抱怨对<code class="fe ma mb mc md b">/book/1/</code>的调用变得更慢，并且返回了应用程序不需要的信息。现在怎么办？</p><p id="510e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在试图满足我们的一个API客户时，我们无意中为我们的其他客户引入了一类全新的问题。不仅如此，通过在<code class="fe ma mb mc md b">/book</code>端点上公开作者字段，我们在API架构中引入了不必要的耦合，我们都知道这会导致什么样的问题。</p><p id="0dd2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始有这种感觉，除非我们开始为每个客户端构建一个API <em class="mr">(当然我们不希望这样)，否则我们会有点停滞不前。</em></p><h2 id="a905" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">GraphQL如何帮助我们</h2><p id="bb2a" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">输入GraphQL: GraphQL被设计成让客户机决定它从服务器接收什么信息，而不是相反。虽然有许多很棒的<a class="ae lb" href="https://docs.graphene-python.org/projects/django/en/latest/" rel="noopener ugc nofollow" target="_blank">包</a>可以从头开始创建Python GraphQL API，但是迁移一个成熟的生产REST API来使用其中一个框架并不那么简单。不仅如此，可能是我们真的爱上了使用Django REST框架进行开发，不想仅仅为了解决这个问题而换一个新的库。</p><h2 id="a4c9" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">通过GraphWrap应用GraphQL层</h2><p id="3376" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated"><a class="ae lb" href="https://github.com/PaulGilmartin/graph_wrap" rel="noopener ugc nofollow" target="_blank"> GraphWrap </a>是一个python库，只需在Django项目中添加两行代码，就可以用<a class="ae lb" href="https://graphql.org/learn/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>接口扩展现有的<a class="ae lb" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank"> Django Rest框架</a> API。这是通过利用<a class="ae lb" href="https://docs.graphene-python.org/projects/django/en/latest/" rel="noopener ugc nofollow" target="_blank"> Graphene-Django </a>在运行时为API中的每个Django REST视图动态构建GraphQL ObjectType来实现的。然后将这些对象类型粘合在一起，形成一个GraphQL模式，它与现有的REST API具有相同的“形状”。请注意，GraphWrap并不是为了构建一个GraphQL模式来替换您现有的REST API，而是扩展它来提供一个额外的<a class="ae lb" href="http://spec.graphql.org/June2018/#sec-Root-Operation-Types" rel="noopener ugc nofollow" target="_blank">完全兼容的</a> GraphQL-queryable接口。</p><p id="b101" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">核桃公司API开发团队决定将GraphWrap添加到他们的项目中。通过安装后</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a379" class="lc ld iq md b gy mm mn l mo mp">pip install graph_wrap</span></pre><p id="ee5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">团队通过将<code class="fe ma mb mc md b">graphql_view</code>添加到他们的<code class="fe ma mb mc md b">urlpatterns</code>中，在他们的API上公开新的<code class="fe ma mb mc md b">/graphql</code>端点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="39a3" class="lc ld iq md b gy mm mn l mo mp">from rest_framework import routers<br/><br/>from graph_wrap.django_rest_framework.graphql_view import graphql_view  <br/><br/><br/>urlpatterns = [<br/>     ...,<br/>     path(r'/graphql/', view=graphql_view), <br/>]</span></pre><p id="004a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这个新的<code class="fe ma mb mc md b">/graphql</code>端点，我们现在可以停止过度暴露<code class="fe ma mb mc md b">author</code>字段，而是像我们最初做的那样简单地将<code class="fe ma mb mc md b">author</code>暴露为一个URL:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2791" class="lc ld iq md b gy mm mn l mo mp">class BookSerializer(serializers.ModelSerializer):<br/>    author = serializers.HyperlinkedRelatedField(<br/>          view_name='author-detail', read_only=True)<br/>    class Meta:<br/>        model = Book<br/>        fields = ['author', 'title', 'page_count']</span></pre><p id="bf51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们的应用程序客户端感到高兴，他们不关心嵌套的作者字段。我们的web客户端对检索嵌套的作者字段感兴趣，然后可以通过查询新的<code class="fe ma mb mc md b">/graphql</code>端点来这样做:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="27ce" class="lc ld iq md b gy mm mn l mo mp">query {<br/>      book(id: 1) {<br/>          title<br/>          author {<br/>              name<br/>              active<br/>          }<br/>      }<br/>  }</span></pre><p id="0562" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将给出如下所示的响应:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="db44" class="lc ld iq md b gy mm mn l mo mp">'data': {<br/>      'title': 'Lovely Gardens',<br/>      'author': {<br/>          'name': 'Emilie B.',<br/>          'active': True,</span><span id="dc67" class="lc ld iq md b gy mq mn l mo mp">       }</span><span id="0d84" class="lc ld iq md b gy mq mn l mo mp">  }</span></pre><p id="6d60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<code class="fe ma mb mc md b">/graphql</code>端点允许每个客户自己决定<em class="mr">他们想要从book端点得到什么信息。我们的web客户端和应用程序客户端现在都很高兴！</em></p><p id="d176" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新的<code class="fe ma mb mc md b">/graphql </code>端点对后端团队最有吸引力的特性(当然除了让前端满意之外！)的一个优点是，由于GraphWrap的以下特性，它几乎不需要额外的维护:</p><ul class=""><li id="5751" class="ms mt iq kh b ki kj kl km ko mu ks mv kw mw la mx my mz na bi translated">GraphQL层构建的动态特性意味着您可以继续开发现有的基于REST的API，并且知道GraphQL模式将自动保持最新。</li><li id="8219" class="ms mt iq kh b ki nb kl nc ko nd ks ne kw nf la mx my mz na bi translated">由于GraphQL层使用的是底层的REST API，所以您可以确信，在您的REST视图和相应的GraphQL类型之间，序列化、身份验证、授权和过滤等重要的事情是一致的。</li></ul><p id="6860" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mr">关于GraphWrap的更多信息，请参见https://github.com/PaulGilmartin/graph_wrap</em><a class="ae lb" href="https://github.com/PaulGilmartin/graph_wrap" rel="noopener ugc nofollow" target="_blank">T3T5】</a></p></div></div>    
</body>
</html>