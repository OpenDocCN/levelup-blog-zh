<html>
<head>
<title>Build a Dog Classifier with React and TensorFlow JS in Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React和TensorFlow JS在几分钟内构建一个狗分类器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-ad-dog-classifier-with-react-and-tensorflow-js-in-minutes-f08e98608a65?source=collection_archive---------1-----------------------#2020-02-14">https://levelup.gitconnected.com/build-ad-dog-classifier-with-react-and-tensorflow-js-in-minutes-f08e98608a65?source=collection_archive---------1-----------------------#2020-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0ed118b13c6541f0800f2ec250e912b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ND0rlrlbL8Fz9lyxIeRiZw.png"/></div></div></figure><p id="ba3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢通过视频学习，请点击这里查看我的Youtube教程:</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="3dd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在这里找到完整的代码:</p><p id="743b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lf" href="https://github.com/jonnyk20/dogscope-react" rel="noopener ugc nofollow" target="_blank">https://github.com/jonnyk20/dogscope-react</a></p><p id="3533" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想象一下玩Pokemon Go，但不是抓Pokemon，而是抓狗…在现实生活中。</p><p id="13d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我在构建<a class="ae lf" href="https://apps.apple.com/us/app/dog-scope/id1469847835" rel="noopener ugc nofollow" target="_blank"> Dog Scope </a>时想到的奇怪想法，尽管这是一个毫无用处的应用程序，但它是我的第一个机器学习项目，它帮助我理解了使用Tensorflow等机器学习工具来识别使用移动设备的物体(和动物)是多么容易。</p><p id="358c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了向您展示它有多简单，请允许我带您了解如何构建类似的东西，一个在React应用程序中使用Tensorflow JS的狗品种分类器。</p><p id="e10c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本教程是为那些至少对React有一点熟悉的人准备的，希望对ES6语法和React钩子也有所了解。</p><p id="efe7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，如果不这样做，虽然您不会太费劲，但是如果您熟悉reducers和有限状态机，您会更好地理解所使用的模式。</p><p id="231f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们开始吧…</p><h1 id="ad61" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">设置</h1><p id="5765" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated"><strong class="kd iu">设置React App </strong> <br/>我们将使用<a class="ae lf" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>快速启动并运行。<br/> <code class="fe mj mk ml mm b">npx create-react-app dog-scope</code></p><p id="c548" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">安装包</strong> <br/>我们需要两个额外的包，一个用于TensorFlow.js，另一个用于我们将用来分类的模型MobileNet。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="da8f" class="mr lh it mm b gy ms mt l mu mv">npm i -S <a class="ae lf" href="http://twitter.com/tensorflow/tfjs" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs</a> <a class="ae lf" href="http://twitter.com/tensorflow" rel="noopener ugc nofollow" target="_blank">@tensorflow</a>-models/mobilenet </span></pre><p id="6ce3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您可以启动react-app以确保它正在工作:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="8c82" class="mr lh it mm b gy ms mt l mu mv">npm run start</span></pre><p id="9431" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">清除样板文件</strong> <br/>我们希望从一个空白的石板开始，首先清除<code class="fe mj mk ml mm b">src/App.js</code>以便它返回一个空的div:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="4553" class="mr lh it mm b gy ms mt l mu mv">import React from ‘react’;<br/>import ‘./App.css’;</span><span id="7941" class="mr lh it mm b gy mw mt l mu mv">const App = () =&gt; {<br/> return &lt;div&gt;&lt;/div&gt;;<br/>}</span><span id="5891" class="mr lh it mm b gy mw mt l mu mv">export default App;</span></pre><p id="38a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至于CSS，我们也想替换它。我这里有一些基本的风格，你可以从它们开始，但是你可以根据自己的喜好随意改变它们。我只建议不要改变<code class="fe mj mk ml mm b">input</code>的风格，稍后我会解释为什么。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="0cfb" class="mr lh it mm b gy ms mt l mu mv">body {<br/> color: white;<br/> background: black;<br/>}</span><span id="09be" class="mr lh it mm b gy mw mt l mu mv">div {<br/> display: flex;<br/> flex-direction: column;<br/> text-align: center;<br/> align-items: center;<br/> padding: 30px;<br/>}</span><span id="622a" class="mr lh it mm b gy mw mt l mu mv">input {<br/> width: 0.1px;<br/> height: 0.1px;<br/> opacity: 0;<br/> overflow: hidden;<br/> position: absolute;<br/> z-index: -1;<br/>}</span><span id="92be" class="mr lh it mm b gy mw mt l mu mv">button,<br/>label,<br/>ul {<br/> width: 300px;<br/> box-sizing: border-box;<br/> border: solid 1px white;<br/> background: black;<br/> color: white;<br/> font-size: 24px;<br/> margin: auto;<br/> padding: 10px;<br/>}</span><span id="8708" class="mr lh it mm b gy mw mt l mu mv">img {<br/> width: 300px;<br/> margin-bottom: 25px;<br/>}</span><span id="31e7" class="mr lh it mm b gy mw mt l mu mv">ul {<br/> list-style: none;<br/> padding: 10px;<br/> margin-bottom: 25px;<br/>}</span></pre><h1 id="00fa" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">布置状态机</strong></h1><p id="a78e" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">这是我们应用程序的流程，由6个状态表示。</p><figure class="kz la lb lc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d46515581d75bf2535ab2ba14ce21bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxJh5SY4GgeXsyF2Qrb54w.png"/></div></div></figure><p id="cde6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个相对简单的流程，但是因为会有特定于特定状态的特定UI，所以我们不想用一堆布尔逻辑来阻塞我们的组件，比如:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="3eee" class="mr lh it mm b gy ms mt l mu mv">const showImage = modelLoaded &amp;&amp; imageUploaded || identificationComplete</span></pre><p id="e2d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们不需要为每个变量UI元素编写这样的表达式，而是要构建一个简单的状态机，它包含描述什么UI是状态的一部分的属性，以及控制一个状态如何转换到另一个状态的规则。让我们在组件上声明我们的状态:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="2bfa" class="mr lh it mm b gy ms mt l mu mv">const stateMachine = {<br/> initial: “initial”,<br/> states: {<br/> initial: { on: { next: “loadingModel”, text: ‘Load Model’ } },<br/> loadingModel: { on: { next: “modelReady”, text: ‘Loading Model’ } },<br/> modelReady: { on: { next: “imageReady”, text: ‘Upload Image’ } },<br/> imageReady: { on: { next: “identifying” }, text: ‘Identify Breed’, showImage: true },<br/> identifying: { on: { next: “complete”, text: ‘Identifying…’} },<br/> complete: { on: { next: “modelReady” }, text: ‘Reset’, showImage: true, showResults: true }<br/> }<br/>};</span></pre><p id="9b4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的状态机有以下内容:</p><ul class=""><li id="c8b3" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated"><strong class="kd iu">陈述:</strong>我们的应用程序可以处于的6个阶段，每个阶段都可以有具体的特征:(例如展示和图像)。我们的应用程序，在任何给定的时刻，只能占据一个状态</li><li id="fba3" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated"><strong class="kd iu">转换:</strong>可以触发我们的应用程序从一种状态转移到另一种状态的事件。谢天谢地，我们简单的应用程序只需要一个事件，“下一个”。每个状态的<code class="fe mj mk ml mm b">on.next</code>值是当应用程序处于该状态时，每当触发“下一个”事件时，应用程序将转换到的状态的名称。</li></ul><p id="6a09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用一个reducer在每次事件触发时返回一个新的状态。对于任何使用过redux的人来说，这看起来非常熟悉。在您的<code class="fe mj mk ml mm b">stateMachine</code>对象的正下方添加以下函数；</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="31a5" class="mr lh it mm b gy ms mt l mu mv">const reducer = (currentState, event) =&gt;<br/> stateMachine.states[currentState].on[event] || stateMachine.initial;</span></pre><p id="2369" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次事件被触发时，它都会经过reducer，导致基于映射确定的规则返回一个新的状态。例如，如果您当前的状态是<code class="fe mj mk ml mm b">loadingModel</code>，并且触发了<code class="fe mj mk ml mm b">next</code>事件，那么将返回(并因此转换到)的状态是<code class="fe mj mk ml mm b">stateMachine.states[‘loadingModel’].on[‘next’]</code>，也就是<code class="fe mj mk ml mm b">modelReady</code>。</p><p id="bf89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将利用React的<code class="fe mj mk ml mm b">useReducer</code>钩子将它连接到我们的组件，所以让我们导入它。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="a2bd" class="mr lh it mm b gy ms mt l mu mv">import React, { useReducer } from “react”;</span></pre><p id="6d73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，在<code class="fe mj mk ml mm b">App</code>组件体内添加该行；</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="fdfc" class="mr lh it mm b gy ms mt l mu mv">const [appState, dispatch] = useReducer(reducer, stateMachine.initial);</span></pre><p id="ea2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mj mk ml mm b">appState</code>将是一个表示当前应用程序状态的字符串，而<code class="fe mj mk ml mm b">dispatch</code>是一个将事件发送到我们的reducer中的函数，目的是触发转换并返回一个新状态。让我们确认一下，但是通过点击按钮触发<code class="fe mj mk ml mm b">next</code>事件来测试一下。在空的<code class="fe mj mk ml mm b">div</code>内，添加以下内容:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="d563" class="mr lh it mm b gy ms mt l mu mv">&lt;button onClick={() =&gt; dispatch(“next”)}&gt;{appState}&lt;/button&gt;</span></pre><p id="ad2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">按钮应该首先显示<code class="fe mj mk ml mm b">initial</code>，当你点击它时，它应该改变到不同的状态，一直到<code class="fe mj mk ml mm b">complete</code>，然后回到<code class="fe mj mk ml mm b">modelReady</code>。</p><p id="cf5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在继续之前，让我们将<code class="fe mj mk ml mm b">next</code>事件保存到一个函数中，以便于参考。将这一行添加到<code class="fe mj mk ml mm b">useReducer</code>调用的正下方。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="eafd" class="mr lh it mm b gy ms mt l mu mv">const next = () =&gt; dispatch(“next”)</span></pre><h1 id="e346" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">添加功能</h1><p id="1d18" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">既然我们的状态已经被恰当地布置好了，我们可以给每个状态添加一些真正的功能了。例如，按钮应该显示不同的文本和不同的行为。将这些信息保存在上面声明的状态机对象中是理想的，但是因为其中一些函数使用了<code class="fe mj mk ml mm b">dispatch</code>，所以我将创建另一个对象来避免循环引用。在我们的函数体中，让我们添加以下对象:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="9fe6" class="mr lh it mm b gy ms mt l mu mv">const buttonProps = {<br/> initial: { text: “Load Model”, action: () =&gt; {} },<br/> loadingModel: { text: “Loading Model…”, action: () =&gt; {} },<br/> modelReady: { text: “Upload Image”, action: () =&gt; {} },<br/> imageReady: { text: “Identify Breed”, action: () =&gt; {} },<br/> identifying: { text: “Identifying…”, action: () =&gt; {} },<br/> complete: { text: “Reset”, action: () =&gt; {} }<br/> };</span></pre><p id="1a43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mj mk ml mm b">text</code>属性只是文本，所以从技术上讲，它们可以放入组件外的<code class="fe mj mk ml mm b">stateMachine</code>对象中，但是为了清楚起见，我在这里添加了它们，以便将按钮相关的属性放在一个地方。</p><p id="c163" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们的按钮可以更改为使用这些动态属性:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="9710" class="mr lh it mm b gy ms mt l mu mv">&lt;button onClick={buttonProps[appState].action}&gt;<br/> {buttonProps[appState].text}<br/>&lt;/button&gt;</span></pre><p id="e3bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你现在点击它，什么都不会改变。我们需要为每个状态添加相关的功能。</p><p id="0131" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> 1。初始</strong> <br/>初始按钮点击应该触发模型加载。所以我们需要:<br/> —调用<code class="fe mj mk ml mm b">next</code>事件转换到<code class="fe mj mk ml mm b">modelLoading</code>状态<br/> —加载模型<br/> —保存到组件状态<br/> —调用‘下一个事件转换到</p><p id="9690" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将需要使用<code class="fe mj mk ml mm b">useState</code>钩子来存储模型，所以首先让我们在文件的顶部导入它。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="d1ce" class="mr lh it mm b gy ms mt l mu mv">import React, { useReducer, useState } from “react”;</span></pre><p id="b6d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先还需要MobileNet来下载模型。在React导入的正下方添加下面一行。这个文件中不需要导入<code class="fe mj mk ml mm b"><a class="ae lf" href="http://twitter.com/tensorflow/tfjs" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs</a></code>。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="f456" class="mr lh it mm b gy ms mt l mu mv">import * as mobilenet from ‘<a class="ae lf" href="http://twitter.com/tensorflow" rel="noopener ugc nofollow" target="_blank">@tensorflow</a>-models/mobilenet’;</span></pre><p id="829d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，在组件主体内部，声明我们将用于存储模型的hook。将它添加到<code class="fe mj mk ml mm b">next</code>函数声明的正下方。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="5d73" class="mr lh it mm b gy ms mt l mu mv">const [model, setModel] = useState(null)</span></pre><p id="02bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们拥有了<code class="fe mj mk ml mm b">load</code>功能所需的一切。下面我们来创建<code class="fe mj mk ml mm b">useState</code>调用。您会注意到函数体的每一行是如何与我们上面概述的4个步骤之一相对应的</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="fc3d" class="mr lh it mm b gy ms mt l mu mv">const load = async () =&gt; {<br/> next()<br/> const mobilenetModel = await mobilenet.load();<br/> setModel(mobilenetModel)<br/> next()<br/>}</span></pre><p id="e8c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">剩下要做的最后一件事是将<code class="fe mj mk ml mm b">load</code>函数添加到<code class="fe mj mk ml mm b">buttonProps</code>中相应的状态对象中。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="f00c" class="mr lh it mm b gy ms mt l mu mv">const buttonProps = {<br/> // …<br/> initial: { text: ‘Load Model’, action: load }<br/> // …<br/>}</span></pre><p id="726d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> 2。loadingModel </strong> <br/>在这个状态下没有任何动作要做，因此没有代码要写！</p><p id="f459" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> 3。这是用户提交国防部图像的阶段。一旦上传，需要发生以下情况:<br/> —提示用户上传图像<br/> —一旦上传，我们将其转换为对象url <br/> —使用所述对象url作为<code class="fe mj mk ml mm b">img</code>文件的<code class="fe mj mk ml mm b">src</code>属性以显示预览<br/> —调用<code class="fe mj mk ml mm b">next</code>以转换到<code class="fe mj mk ml mm b">imageReady</code>状态</strong></p><p id="b13b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这一步，我们需要添加几个UI元素，一个文件输入和一个图像。让我们从输入开始。因为文件输入很难以一种可靠的方式进行样式化，所以我们在这里添加的内容被css隐藏了(这就是为什么你可能不想改变这一部分)。要触发输入，我们只需给它附加一个ref，使用它并在调用我们的<code class="fe mj mk ml mm b">load</code>函数时触发一个<code class="fe mj mk ml mm b">click</code>事件。</p><p id="199f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们回到我们的<code class="fe mj mk ml mm b">React</code>进口，加上<code class="fe mj mk ml mm b">useRef</code>；</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="6c2f" class="mr lh it mm b gy ms mt l mu mv">import React, { useReducer, useState, useRef } from “react”;</span></pre><p id="56ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，在组件主体的顶部附近(在其他钩子下面调用也可以)，声明您的输入ref。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="0b86" class="mr lh it mm b gy ms mt l mu mv">const inputRef = useRef();</span></pre><p id="0d46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们添加输入元素。你可以把它放在<code class="fe mj mk ml mm b">div</code>里面，就在<code class="fe mj mk ml mm b">button</code>的下面。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="8901" class="mr lh it mm b gy ms mt l mu mv">&lt;input type=”file” accept=”image/*” capture=”camera” ref={inputRef}&gt;&lt;/input&gt;</span></pre><p id="f4ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">属性将在移动设备上打开我们的相机。</p><p id="e579" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在编写处理上传文件的函数之前，我们需要一个<br/>钩子来存储我们将从图像创建的文件URL。让我们将以下内容添加到函数体的挂钩中:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="028f" class="mr lh it mm b gy ms mt l mu mv">const [imageUrl, setImageUrl] = useState(null);</span></pre><p id="f13a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们创建<code class="fe mj mk ml mm b">handleUpload</code>函数。上传的文件将是一个数组，但是我们只能处理一个图像，所以我们将提取数组中的第一个项目。将此函数添加到组件主体。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="2448" class="mr lh it mm b gy ms mt l mu mv">const handleUpload = event =&gt; {<br/> const { files } = event.target;<br/> if (files.length &gt; 0) {<br/> const url = URL.createObjectURL(files[0])<br/> setImageUrl(url)<br/> next();<br/> }<br/>}</span></pre><p id="617b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们可以将该函数作为<code class="fe mj mk ml mm b">onChange</code>属性添加到输入中:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="787e" class="mr lh it mm b gy ms mt l mu mv">&lt;input<br/> /// … props we added before<br/> onChange={handleUpload}<br/>/&gt;</span></pre><p id="2d3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mj mk ml mm b">handleUpload</code>由用户提交文件触发，但文件输入提示本身需要打开。因为我们的css，input元素不可见但仍然存在，所以我们可以用它的ref用javascript点击’它；</p><p id="81fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在你的<code class="fe mj mk ml mm b">actionButton</code>对象里。将以下内容添加到<code class="fe mj mk ml mm b">modelReady</code>状态对象中:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="6493" class="mr lh it mm b gy ms mt l mu mv">const actionButton = {<br/> // …<br/> modelReady: {<br/> text: ‘Upload Image’,<br/> action: () =&gt; inputRef.current.click()<br/> }<br/> // …<br/>}</span></pre><p id="81eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一步的最后一部分是显示图像的预览。以便用户可以看到它被正确上传。为此，我们将向我们的jsx添加一个<code class="fe mj mk ml mm b">img</code>元素，并将<code class="fe mj mk ml mm b">src</code>设置为我们保存到状态的<code class="fe mj mk ml mm b">imageUrl</code>。我们还将在分类步骤中使用这个图像，因此我们需要一个ref来方便地访问它。在另一个ref声明下面添加下面一行:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="9c4a" class="mr lh it mm b gy ms mt l mu mv">const imageRef = useRef();</span></pre><p id="5edb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们只想在某些状态下显示此元素。幸运的是，我们可以通过引用之前在<code class="fe mj mk ml mm b">stateMachine</code>状态中定义的<code class="fe mj mk ml mm b">showImage</code>属性来避免布尔汤。</p><p id="935e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过在组件的<code class="fe mj mk ml mm b">return</code>语句上方添加以下内容来轻松访问它；</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="d3ac" class="mr lh it mm b gy ms mt l mu mv">const { showImage = false } = stateMachine.states[appState]</span></pre><p id="e9f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在在<code class="fe mj mk ml mm b">button</code>上方的<code class="fe mj mk ml mm b">div</code>内添加图像:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="25a5" class="mr lh it mm b gy ms mt l mu mv">{ showImage &amp;&amp;<br/> &lt;img<br/> src={imageUrl}<br/> alt=”upload-preview”<br/> ref={imageRef}<br/> /&gt;<br/>}</span></pre><p id="ccd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，您应该能够加载您的应用程序，点击上传图像，然后在完成后看到显示的图像。</p><p id="b6cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步是最重要的部分，实际上也是最容易的。我们终于可以使用一些机器学习魔法了。</p><p id="fec2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> 4。imageReady </strong></p><p id="e944" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们添加一些状态来显示我们的结果。使用其他挂钩将以下内容添加到函数体中:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="9e20" class="mr lh it mm b gy ms mt l mu mv">const [results, setResults] = useState([])</span></pre><p id="2057" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们编写我们的<code class="fe mj mk ml mm b">identify</code>函数:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="52a4" class="mr lh it mm b gy ms mt l mu mv">const identify = async () =&gt; {<br/> next();<br/> const results = await model.classify(imageRef.current);<br/> setResults(results)<br/> next();<br/>}</span></pre><p id="a0b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…并将其添加到我们的<code class="fe mj mk ml mm b">actionButton</code>对象中:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="0ef7" class="mr lh it mm b gy ms mt l mu mv">const actionButton = { <br/> // …<br/> identify: { text: ‘identify’, action: identify }<br/> // …<br/>}</span></pre><p id="9a2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以重新加载应用程序并尝试点击它。从一个简单的<code class="fe mj mk ml mm b">console.log</code>测试中，我们可以看到我们的结果看起来像这样。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="85ad" class="mr lh it mm b gy ms mt l mu mv">[<br/> { className: ‘labrador’, probability: 0.353224 }<br/> { className: ‘corgi’, probability: 0.1242244 }<br/>]</span></pre><p id="fc9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望将每个对象转换成一个用户友好的列表项，所以让我们创建一个函数来完成这个任务。在组件外部，添加以下函数:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="1999" class="mr lh it mm b gy ms mt l mu mv">const formatResult = ({ className, probability}) =&gt; (<br/> &lt;li key={className}&gt;<br/> {`${className}: %${(probability * 100).toFixed(2)}`}<br/> &lt;/li&gt;<br/>)</span></pre><p id="ba97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很好，但是用户看不到任何东西，所以让我们改变它。首先，让我们在获得<code class="fe mj mk ml mm b">showImage</code>的同一行中从<code class="fe mj mk ml mm b">stateMachine</code>中取出<code class="fe mj mk ml mm b">showResults</code>属性:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="da27" class="mr lh it mm b gy ms mt l mu mv">const {<br/> showImage = false,<br/> showResults = false<br/>} = stateMachine.states[appState];</span></pre><p id="edc8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们的组件可以很容易地知道何时显示结果，让我们添加一些jsx来允许它这样做。将此<code class="fe mj mk ml mm b">ul</code>添加到图像正下方。</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="a765" class="mr lh it mm b gy ms mt l mu mv">{ <br/> showResults &amp;&amp; (<br/> &lt;ul&gt;{results.map(formatResult)}&lt;/ul&gt;<br/> )<br/>}</span></pre><p id="ebb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> 5。识别</strong><br/>——在这个阶段不需要任何操作，所以同样没有代码要写</p><p id="06c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> 6。完成</strong> <br/>这是最后一步，也是最简单的一步。这里需要做的只是重置，包括以下内容:<br/> —清除结果<br/> —清除图像url <br/> —调用<code class="fe mj mk ml mm b">next</code>转换到<code class="fe mj mk ml mm b">modelReady</code>(用户将能够上传新图像)<br/>将此函数添加到组件主体:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="c99c" class="mr lh it mm b gy ms mt l mu mv">const reset = () =&gt; {<br/> setResults([])<br/> setImageUrl(null)<br/> next();<br/>}</span></pre><p id="658f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，将最后一个函数添加到<code class="fe mj mk ml mm b">actionButton</code>:</p><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="d233" class="mr lh it mm b gy ms mt l mu mv">const actionButton = { <br/> // …<br/> complete: { text: ‘Reset’, action: reset }<br/> // …<br/>}</span></pre><p id="6929" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你现在应该能够上传照片，分类狗品种，并在屏幕上看到结果，重置，然后上传和分类新的图片。</p><h2 id="4aee" class="mr lh it bd li nl nm dn lm nn no dp lq km np nq lu kq nr ns ly ku nt nu mc nv bi translated">奖励步骤</h2><p id="9354" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">为了保持重点，我在本教程中省略了一些内容，但是您可能需要考虑:</p><ul class=""><li id="7999" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated"><strong class="kd iu">错误处理:</strong>如果模型没有返回结果，或者下载失败会发生什么。</li><li id="768d" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated"><strong class="kd iu">附加状态转换。</strong>能够从任何状态‘重置’到开始将是有用的，而不仅仅是最后一个状态。</li><li id="7fb5" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated"><strong class="kd iu">部署。</strong>在你的电脑上安装一个动物识别应用程序有什么意义？您需要部署它，以便可以在现实世界中使用它。部署，因为我们使用了<code class="fe mj mk ml mm b">create-react-app</code>，有无数种方法可以让你的应用在几分钟内部署完毕。这里有一篇<a class="ae lf" href="https://blog.bitsrc.io/8-react-application-deployment-and-hosting-options-for-2019-ab4d668309fd" rel="noopener ugc nofollow" target="_blank">伟大的文章</a>，作者是<a class="nw nx ep" href="https://medium.com/u/cb0ab32a7733?source=post_page-----f08e98608a65--------------------------------" rel="noopener" target="_blank">wose Lotanna</a>，它走过了其中的8条，所以你可以挑选。</li></ul><p id="1125" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您像我一样选择部署到Heroku，请遵循以下步骤:</p><ul class=""><li id="8420" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated"><a class="ae lf" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank">创建一个Heroku账号</a></li><li id="ae65" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated"><a class="ae lf" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank">安装并登录heroku CLI </a></li><li id="934a" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">在应用程序的目录中运行以下命令:</li></ul><pre class="kz la lb lc gt mn mm mo mp aw mq bi"><span id="65f6" class="mr lh it mm b gy ms mt l mu mv">git init<br/>heroku create -b <a class="ae lf" href="https://github.com/mars/create-react-app-buildpack.git" rel="noopener ugc nofollow" target="_blank">https://github.com/mars/create-react-app-buildpack.git</a><br/>git add .<br/>git commit -m “react-create-app on Heroku”<br/>git push heroku master<br/>heroku open</span></pre><p id="f7cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们正在使用的模型mobilenet不仅可以识别狗的种类，还可以识别大约1000种不同的动物和物体，因此它是图像分类应用程序的一个很好的工具。然而，可能有你想要分类的物体和动物不在列表中。我正在编写一个教程，介绍如何构建和训练定制的机器学习模型，所以请关注我(在这里或者在Youtube或Twitter上)，这样你就可以第一个知道它什么时候准备好了。</p><p id="b031" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同时，如果你有任何问题，请随时联系我。感谢阅读！</p></div></div>    
</body>
</html>