<html>
<head>
<title>Git Internals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git内部</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/git-internals-c219521d9f6?source=collection_archive---------11-----------------------#2021-02-15">https://levelup.gitconnected.com/git-internals-c219521d9f6?source=collection_archive---------11-----------------------#2021-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="69df" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">引擎盖下的Git</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/c0c4c83a92227e09e7e95113512ffcaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bFujY167JrT59mSu"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated"><a class="ae kw" href="https://unsplash.com/@evgenit?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">叶夫根尼·切尔卡斯基</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="ba86" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Git是一个数据库，用于在整个开发阶段存储代码库的快照。虽然开发人员熟悉基本命令，但大多数人都不知道内部工作原理。</p><p id="591e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将是一个关于git如何在内部工作的实践教程。</p><h2 id="3a0d" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">入门指南</h2><p id="7f5d" class="pw-post-body-paragraph kx ky iq kz b la mn jr lc ld mo ju lf lg mp li lj lk mq lm ln lo mr lq lr ls ij bi translated">让我们设置一个本地git存储库。</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="ee6f" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> mkdir git-internals-tutorial ; cd $_ # create a new directory<br/><em class="lt">$</em> git init # create a git repository locally</span></pre><p id="a5ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">git存储库将快照存储在一个<code class="fe nb nc nd mt b">.git</code>文件夹中。我们可以用树命令来可视化文件夹。</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="1941" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> tree .git<br/>.git<br/>├── HEAD<br/>├── config<br/>├── hooks<br/>├── objects<br/>│ ├── info<br/>│ └── pack<br/>└── refs<br/> ├── heads<br/> └── tags</span></pre><h2 id="a182" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">Git散列对象</h2><p id="b17d" class="pw-post-body-paragraph kx ky iq kz b la mn jr lc ld mo ju lf lg mp li lj lk mq lm ln lo mr lq lr ls ij bi translated">git的<em class="lt"> hash-object </em>命令创建要存储在数据库中的文件内容的散列。</p><p id="8357" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设我们有一个文件<em class="lt"> file1.txt </em></p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="f7a3" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$ </em>echo 'hello' &gt; file1.txt<br/><em class="lt">$ </em>cat file1.txt<br/>hello<br/><em class="lt">$ </em>git hash-object file1.txt<br/>ce013625030ba8dba906f756967f9e9ca394464a</span></pre><p id="fbfc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">散列是git数据库中内容的id。对象id仅根据内容计算，与文件名无关。如果我们有另一个文件名不同但内容相同的文件，哈希将是相同的。</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="6eaa" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> echo 'hello' &gt; file2.md<br/><em class="lt">$</em> git hash-object file2.md<br/>ce013625030ba8dba906f756967f9e9ca394464a</span></pre><p id="9389" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里有一种不用显式创建文件就能计算出哈希值的方法。</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="d170" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> echo 'hello' | git hash-object --stdin<br/>ce013625030ba8dba906f756967f9e9ca394464a</span></pre><h2 id="8541" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">将Git Blob对象保存到数据库</h2><p id="6d7c" class="pw-post-body-paragraph kx ky iq kz b la mn jr lc ld mo ju lf lg mp li lj lk mq lm ln lo mr lq lr ls ij bi translated">为了将文件内容写入git数据库，可以将-w标志添加到<em class="lt">散列对象</em>命令中。</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="0732" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> echo 'hello' | git hash-object --stdin -w<br/>ce013625030ba8dba906f756967f9e9ca394464a</span></pre><p id="77f5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将把内容存储在名称为object-id的<strong class="kz ir"> objects </strong>目录下的一个文件中</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="c93a" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> tree .git<br/>.git<br/>├── HEAD<br/>├── config<br/>├── hooks<br/>├── <strong class="mt ir">objects</strong><br/>│   ├── <strong class="mt ir">ce</strong><br/>│   │   └── <strong class="mt ir">013625030ba8dba906f756967f9e9ca394464a</strong><br/>│   ├── info<br/>│   └── pack<br/>└── refs<br/>    ├── heads<br/>    └── tags</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/5b03c07ed705c2eef70d09eecefd2833.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*0jAiyk2rtn3pFIaCqV7P8g.png"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">blob对象</figcaption></figure><p id="0986" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">cat-file命令用于从git对象获取文件内容。它显然充当了<em class="lt">散列对象</em>命令的反向操作。</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="c801" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> git cat-file -p ce013625030ba8dba906f756967f9e9ca394464a<br/>hello</span></pre><p id="a18b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">p标志用于打印对象的内容。类似地，-t标志输出对象的类型。在我们的例子中，它是一个斑点。</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="af7f" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> git cat-file -t ce013625030ba8dba906f756967f9e9ca394464a<br/>blob</span></pre><p id="3b7b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">还有其他类型的git对象，比如树，这将在下一节讨论。</p><h2 id="4bc4" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">创建Git树对象</h2><p id="626c" class="pw-post-body-paragraph kx ky iq kz b la mn jr lc ld mo ju lf lg mp li lj lk mq lm ln lo mr lq lr ls ij bi translated">与blob类似，tree是git中的另一种对象。一棵树能吸住水滴，也能吸住树下的其他树。</p><p id="1ab7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用<em class="lt"> git write-tree </em>命令将索引中的文件添加到树中</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="1856" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$ </em>git add file1.txt # add file1 to the index space in git<br/><em class="lt">$ </em>git write tree # Add file1 to a tree and write it to database<br/>dca98923d43cd634f4359f8a1f897bf585100cfe</span></pre><p id="28e9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这会将带有文件内容的树作为blob写入数据库。git ls-tree可用于查看树上的内容:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e2b2c358d1def149c7987c8175b966d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*NwwkUHM-5T1ORNluyMTHTQ.png"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">blob对象上的树</figcaption></figure><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="2020" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$ </em>git ls-tree dca98923d43cd634f4359f8a1f897bf585100cfe<br/>100644 blob ce013625030ba8dba906f756967f9e9ca394464a file1.txt<br/><em class="lt">$ </em>git cat-file -t dca98923d43cd634f4359f8a1f897bf585100cfe<br/>tree</span></pre><p id="48e6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">树对象也可以在。git文件夹</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="9119" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$ </em>tree .git<br/>.git<br/>├── HEAD<br/>├── config<br/>├── hooks<br/>├── <strong class="mt ir">objects</strong><br/>│   ├── ce<br/>│   │   └── 013625030ba8dba906f756967f9e9ca394464a<br/>│   ├── <strong class="mt ir">dc</strong><br/>│   │   └── <strong class="mt ir">a98923d43cd634f4359f8a1f897bf585100cfe</strong><br/>│   ├── info<br/>│   └── pack<br/>└── refs<br/>    ├── heads<br/>    └── tags</span></pre><h2 id="7bcd" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">让Git提交</h2><p id="06ff" class="pw-post-body-paragraph kx ky iq kz b la mn jr lc ld mo ju lf lg mp li lj lk mq lm ln lo mr lq lr ls ij bi translated">大多数人都熟悉<em class="lt"> git commit </em>命令，该命令对暂存区中的更改进行提交，并更新该提交的分支引用。让我们使用低级API来做同样的事情。</p><p id="f81c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">git中的提交对象有一个树，一个到父提交(如果存在)的链接，以及提交消息和关于作者和提交者的细节等信息。</p><p id="00b9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们从上一节中创建的<em class="lt">DCA 98923d 43 CD 634 f 4359 F8 a1 f 897 BF 585100 cfe</em><em class="lt">树</em>开始。</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="337f" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> git commit-tree dca98923d43cd634f4359f8a1f897bf585100cfe -m "Commit Message" # Creates a commit with the changes in the tree and the messages<br/>1185a9903f20ca3059dcc96662fb05cc219bd654</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ng"><img src="../Images/841d209d2ca23c3d8b024855ea4e0fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yoc7P_cq7nilWNbpshJjw.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">Commit有一条消息并指向一棵树</figcaption></figure><p id="452a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">已创建提交id为<em class="lt">1185 a 9903 f 20 ca 3059 DCC 9662 FB 05 cc 219 BD 654</em>的提交。您可能会看到命令的提交</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="4c0f" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$ </em>git log 1185a9903f20ca3059dcc96662fb05cc219bd654<br/>commit 1185a9903f20ca3059dcc96662fb05cc219bd654<br/>Author: Praveen Mathew &lt;<em class="lt">email@email.com</em>&gt;<br/>Date:   Wed Feb 17 19:18:40 2021 +0530</span><span id="e807" class="lu lv iq mt b gy nh my l mz na">Commit Message</span></pre><p id="762c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们使用低级git APIs在它上面创建另一个提交:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="de35" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$ </em>touch file2.txt</span><span id="dbf6" class="lu lv iq mt b gy nh my l mz na">$ git add file2.txt</span><span id="eb71" class="lu lv iq mt b gy nh my l mz na">$ git write-tree<br/>5d649a7d0557d17655fbdd362b34158a36b0a39d</span><span id="37ae" class="lu lv iq mt b gy nh my l mz na">$ git commit-tree 5d649a7d0557d17655fbdd362b34158a36b0a39d -m "Second Commit Message" -p 1185a9903f20ca3059dcc96662fb05cc219bd654 # <br/>7a4834354b351022ea9ddb818b7b2a889bdbb3cf<br/></span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ni"><img src="../Images/87cfa384021d8d5828d626b072d69986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j28cI9K_NEQNz_eAx862Dw.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">提交也指向父提交</figcaption></figure><p id="e96b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在提交的日志<em class="lt">7a 4834354 b 351022 ea9 DDB 818 b7b 2a 889 bdbb 3c f</em>将显示两个提交</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="d0eb" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$ </em>git log 7a4834354b351022ea9ddb818b7b2a889bdbb3cf --oneline<br/>7a48343 Second Commit Message<br/>1185a99 Commit Message</span></pre><p id="2075" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，如果您注意到HEAD指向的当前分支仍然是默认分支。承诺不会出现在那里。</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="83cb" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$ </em>git log<br/>fatal: your current branch 'main' does not have any commits yet</span></pre><p id="e94a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">除了创建提交，git commit命令还有一件事要做。它还会更新HEAD指向的分支的引用。这是通过命令<em class="lt"> git update-ref </em>完成的</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="328f" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> git update-ref refs/heads/main 7a4834354b351022ea9ddb818b7b2a889bdbb3cf # points main reference to the commit</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nj"><img src="../Images/a51b23af6137a2370835e22d27de2244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppXGtt6A_BNz7094joGX2g.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">引用已更新为指向最新提交</figcaption></figure><p id="2a72" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在主分支指向提交。</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="5cbe" class="lu lv iq mt b gy mx my l mz na"><em class="lt">$</em> git log --oneline<br/>7a48343 (HEAD -&gt; main) Second Commit Message<br/>1185a99 Commit Message<br/>(END)</span></pre><p id="7224" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，我们有一个带有一些提交的分支😀。</p><p id="423c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，git commit命令使用了两个低级命令</p><ol class=""><li id="6c22" class="nk nl iq kz b la lb ld le lg nm lk nn lo no ls np nq nr ns bi translated">提交树</li><li id="d369" class="nk nl iq kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated">更新-参考</li></ol><p id="52ac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是git使用的低级命令的简介。在评论中一定要让我知道你的想法。</p><h1 id="48e2" class="ny lv iq bd lw nz oa ob lz oc od oe mc jw of jx mf jz og ka mi kc oh kd ml oi bi translated">参考文献:</h1><div class="oj ok gp gr ol om"><a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">Git - Git对象</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">Git是一个内容可寻址的文件系统。很好。这是什么意思？这意味着Git的核心是一个简单的…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">git-scm.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kq om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://github.blog/2020-12-17-commits-are-snapshots-not-diffs" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">提交是快照，而不是差异——git hub博客</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">Git以令人困惑著称。用户偶然发现误导他们的术语和措辞…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.blog</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa kq om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://medium.com/mindorks/what-is-git-object-model-6009c271ca66" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">什么是Git对象模型</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">今天的动机</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa kq om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://jwiegley.github.io/git-from-the-bottom-up/1-Repository/4-how-trees-are-made.html" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">树木是如何形成的</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">每个提交都有一棵树，但是树是如何形成的呢？我们知道blobs是通过填充…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">jwiegley.github.io</p></div></div></div></a></div><p id="f5b3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae kw" href="https://github.com/tpn/pdfs/blob/master/Git%20from%20the%20Bottom%20Up.pdf" rel="noopener ugc nofollow" target="_blank">https://github.com/tpn/pdfs</a></p></div></div>    
</body>
</html>