<html>
<head>
<title>Dealing with multiple, massive tables in a single admin - Optimizing Django Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在单个管理优化Django中处理多个大型表第3部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dealing-with-multiple-massive-tables-in-a-single-admin-optimizing-django-part-3-2c4ee2fec142?source=collection_archive---------0-----------------------#2020-08-21">https://levelup.gitconnected.com/dealing-with-multiple-massive-tables-in-a-single-admin-optimizing-django-part-3-2c4ee2fec142?source=collection_archive---------0-----------------------#2020-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7d0d768e613a0f7367d2d2c8d32459af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ii89QKBeSfY5B8hofOU0rA.png"/></div></div></figure><p id="8e7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/speed-up-your-django-admin-by-removing-sql-counts-optimizing-django-part-2-f5e09da667c">在优化Django的上一篇文章</a>中，我们介绍了一种在使用Django admin时减少SQL内存占用的方法，代价是不能在表中显示正确的对象数。然而，即使这样，我们仍然会遇到Django管理变得异常缓慢的情况。在本文中，我将讨论一个导致Django管理变更列表和详细信息页面变得非常慢的场景，是什么原因导致的，以及如何修复它以使其在功能损失最小的情况下绝对可用。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="5fad" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">场景:您希望在用户管理中查看用户的票证。</h1><p id="1236" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">想象一下:你有一个装满票的桌子，你想访问它们并显示一些基本的细节，比如用户的名字。所以你这样做:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4cbc" class="mq lf iq mm b gy mr ms l mt mu">class User(AbstractUser):<br/>    def __str__(self):<br/>        return ' '.join([self.first_name, self.last_name])<br/><br/>class Event(models.Model):<br/>    id = models.UUIDField(default=uuid.uuid4(), primary_key=True)<br/>    event_name = models.TextField(default='')</span><span id="4aba" class="mq lf iq mm b gy mv ms l mt mu">class Ticket(models.Model):<br/>    user = models.ForeignKey(User, on_delete=models.CASCADE)<br/>    event = models.ForeignKey(Event, on_delete=models.CASCADE, null=True)<br/><br/><br/>class UserEventInline(admin.TabularInline):<br/>    model = UserTicket<br/><br/>class UserAdmin(admin.ModelAdmin):<br/>    model = User<br/>    paginator = NoCountPaginator<br/>    inlines = (UserEventInline,)<br/><br/>    exclude = ('user_permissions', 'groups',)<br/><br/>def get_queryset(self, request):<br/>    return super().get_queryset(request).order_by('first_name', 'last_name')</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="5a42" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">让我们从用户管理变更列表开始。</h1><p id="1cea" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">如您所见，我们有一个简单的用户和事件，通过表有一个用户票。它应该是简单的，看起来像这样。</p><div class="mh mi mj mk gt ab cb"><figure class="mw jr mx my mz na nb paragraph-image"><img src="../Images/f9d3b73a4c5ad54d3367a0324c66c353.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*FHHhrDwyddzdEb1c-4gzVQ.png"/></figure><figure class="mw jr nc my mz na nb paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/71864a25c1886450805d4ae504725cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*FFqIjYEsIHnnjM0rfUiaAA.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk nh di ni nj translated">具有相应SQL的管理页面</figcaption></figure></div><p id="6281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SQL已经通过我们的NoCountPaginator得到了改进，我们在前面的优化Django 条目<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/speed-up-your-django-admin-by-removing-sql-counts-optimizing-django-part-2-f5e09da667c">中提到过。然而，关于SQL还有一些我们可以改进的地方。这是什么？</a></p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/113d997380df20de707399a619f76ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*j9UcR6zsAhTwWqvnfdwq_A.png"/></div></figure><p id="2be3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我们是按名字和姓氏排序，但是请注意管理员仍然添加了一个额外的ID排序。</p><p id="ac32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为Django默认的按pk排序的行为。<a class="ae kw" href="https://docs.djangoproject.com/en/3.1/ref/contrib/admin/" rel="noopener ugc nofollow" target="_blank">据网站</a>称，“为了确保结果的确定性排序，如果changelist找不到提供总排序的单个或唯一的一组字段，它会将<code class="fe nl nm nn mm b"><strong class="ka ir">pk</strong></code>添加到排序中”。如果条目具有相同的可识别名称，这是有意义的(在示例中可以看到两个Aaron Acevedo)。然而，如果您公开一些有保证的方法来区分结果(显示管理中的<code class="fe nl nm nn mm b"><strong class="ka ir">pk</strong></code>这样做)，您可以很容易地取消强制排序。</p><h1 id="a145" class="le lf iq bd lg lh no lj lk ll np ln lo lp nq lr ls lt nr lv lw lx ns lz ma mb bi translated">第1部分修复:NoPKChangeList</h1><p id="0eeb" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">对此的代码更改相当简单，尽管代码本身看起来并不是这样。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f0a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码复制自Django的默认ChangeList类，除了<code class="fe nl nm nn mm b">get_ordering</code>方法禁用了额外的pk排序。因此，如果您将它添加到管理员中，SQL将如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8741" class="mq lf iq mm b gy mr ms l mt mu">class UserAdmin(admin.ModelAdmin):<br/>    model = User<br/>    show_full_result_count = False<br/>    inlines = (UserEventInline,)<br/>    paginator = NoCountPaginator<br/><br/>    exclude = ('user_permissions', 'groups',)<br/><br/>    def get_changelist(self, request, **kwargs):<br/>        return NoPkChangeList<br/><br/>    def get_queryset(self, request):<br/>        return super().get_queryset(request).order_by('first_name', 'last_name')</span></pre><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/69a9104dfdf691256ff5db83751f588b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*tvqKdPOsULJXPhhCTMr8Gw.png"/></div></figure><p id="ead2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">时间上的微小差异，但它是那些可能突然爆发而没有警告的事情之一，所以如果你在加载你的变更列表时遇到缓慢，这可能会有所帮助。</p><p id="b55b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，让我们进入详细页面！</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="4837" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第2部分:详细页面！</h1><p id="bc50" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">现在，您可能希望您的用户管理员显示用户拥有的相关用户票证。我们通过Django的内嵌特性做到了这一点，该特性将用户的相关票据放在一个简单的界面中。所以内联看起来像这样:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/bb6812c3fb67cafe2d6559a5a3603be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyhQnn04S3NRAmE-CUM7qA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">简单内联查看门票</figcaption></figure><p id="f8ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果你看一下SQL，你会发现它是<strong class="ka ir">而不是</strong>效率低下。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/505fa36a02cfbe734785152a1256c919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*eEmTrQqNpyGWvnlFF6DfXQ.png"/></div></figure><p id="e7c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有很多疑问。我不会把13个都展示出来，但你会明白的。为什么有这么多疑问？</p><p id="3e08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再看一下内嵌。注意组合框中的文本是如何暗示一个呈现用户票的选择查询的。Django并没有有效地处理这一点，对于内联的每一项，它都会调用一个DB。如您所见，这些数据库调用的速度非常快！</p><p id="35d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我们来说幸运的是，处理这个问题相当简单。让我们看看这个修复，并解释为什么这会减少查询次数。</p><h1 id="a363" class="le lf iq bd lg lh no lj lk ll np ln lo lp nq lr ls lt nr lv lw lx ns lz ma mb bi translated">第2部分修复:</h1><p id="d8ed" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">与我们之前看到的普通UserEventInline不同，我们将对它进行如下改进:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5852" class="mq lf iq mm b gy mr ms l mt mu">class UserEventInline(admin.TabularInline):<br/>    model = UserTicket<br/><br/>    fields = ('user', 'event')<br/>    readonly_fields = ('user', 'event')<br/><br/>    def get_queryset(self, request):<br/>        return super().get_queryset(request).select_related('event')</span></pre><p id="b2e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是怎么回事？</p><p id="868e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，我们在这里做的第一件事是<strong class="ka ir">在queryset </strong>上运行select_related。Select_related将为每个用户票证预加载相关的事件数据。</p><p id="c81e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一件事是<strong class="ka ir">将事件字段设为只读</strong>。您可能已经注意到“事件”列下每个条目的组合框。这意味着一个选择查询，因为在本例中，组合框必须用事件填充。对于少量的事件(我用30个事件填充了我的数据库)，这不是问题。然而，如果有更多的事件，不仅SQL会变得非常昂贵，HTML页面也会变得大得无法加载。为了解决这个问题，我们通过将事件字段设置为只读来删除这个组合框功能。</p><h2 id="e805" class="mq lf iq bd lg nx ny dn lk nz oa dp lo kj ob oc ls kn od oe lw kr of og ma oh bi translated">看看结果:</h2><p id="c30d" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">这是更改后的内联外观:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4d4defa26a62f3fb87feb0c374eedc1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*12Xf1mNU-u0NXQhIZo-FOg.png"/></div></figure><p id="1f21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且查询次数已经显著减少。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/54893e86185579de3a547c8663642fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*zQfklmXyBJ_b1ILRpClRWw.png"/></div></figure><h1 id="005d" class="le lf iq bd lg lh no lj lk ll np ln lo lp nq lr ls lt nr lv lw lx ns lz ma mb bi translated">最后</h1><p id="e429" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">Django admin很容易陷入SQL地狱，这主要是因为它提供了开箱即用的完整默认功能。通过一些调整和技巧，我们能够通过禁用我们不需要的东西来逃离这种死亡螺旋，比如能够更改与我们正在检查的对象相关的项目，以及禁用我们不需要的<code class="fe nl nm nn mm b">pk</code>排序。</p><p id="e58a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一集，我们将讲述一个可能失控的序列化场景，以及我们如何解决它！</p><p id="c427" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想让我在评论中涵盖其他内容，请告诉我！</p></div></div>    
</body>
</html>