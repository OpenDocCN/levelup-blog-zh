<html>
<head>
<title>How to deserialize JSON to custom class objects in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中将JSON反序列化为自定义类对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-deserialize-json-to-custom-class-objects-in-python-d8b92949cd3b?source=collection_archive---------0-----------------------#2021-12-18">https://levelup.gitconnected.com/how-to-deserialize-json-to-custom-class-objects-in-python-d8b92949cd3b?source=collection_archive---------0-----------------------#2021-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8382" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将JSON反序列化为定制类对象只是需要一些小心</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ceafecaf9d085d1e14689acb9e1217ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W7ny_C-OxAmVHTquX7NcWg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">卡罗琳娜·加西亚·塔维森在<a class="ae lb" href="https://unsplash.com/s/photos/paper-origami?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e5ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="#130e" rel="noopener ugc nofollow"> 1。自定义类定义</a> <br/> <a class="ae lb" href="#52ef" rel="noopener ugc nofollow"> 2。json.loads()带object_hook </a> <br/> <a class="ae lb" href="#d8c6" rel="noopener ugc nofollow"> 3。嵌套对象</a> <br/> <a class="ae lb" href="#1b1e" rel="noopener ugc nofollow"> 4。jsonpickle </a> <br/> <a class="ae lb" href="#9f83" rel="noopener ugc nofollow">结论</a></p><p id="3417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是关于<a class="ae lb" href="https://changsin.medium.com/how-to-serialize-a-class-object-to-json-in-python-849697a0cd3#2a21" rel="noopener">如何在Python中把一个类对象序列化为JSON的后续文章</a>以结束Python中序列化和反序列化问题的循环。序列化是将对象转换成字符串或文件，从保存的字符串中获取原始对象是反序列化。如果您了解序列化是如何完成的，那么您就几乎可以逆转反序列化的过程。然而，通常情况下，细节决定成败。让我们先从自定义类的定义开始。</p><h1 id="130e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">1.自定义类别定义</h1><p id="8796" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">为了使插图与前一篇文章相匹配，让我们首先使用同一个简单的标签类</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="ff93" class="mk ld iq mg b gy ml mm l mn mo">class Label:<br/>    def __init__(self, label, x, y, width, height):<br/>        self.label = label<br/>        self.x = x<br/>        self.y = y<br/>        self.width = width<br/>        self.height = height</span></pre><p id="6ca6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用json.dumps()的序列化字符串是:</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="3029" class="mk ld iq mg b gy ml mm l mn mo">{"label": "person", "x": 10, "y": 10, "width": 4, "height": 10}</span></pre><h1 id="52ef" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">2.json.loads()带有object_hook</h1><p id="c346" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">默认的反序列化方法是json.loads()，它将一个字符串作为输入，并输出一个json字典对象。要将dictionary对象转换为自定义类对象，需要编写一个反序列化方法。最简单的方法是向类本身添加一个静态方法。具有serialize (to_json)和deserialize (from_json)方法的整个类应该如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="cf62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了反序列化方法，我们可以调用json.loads方法，并将Label类的新反序列化方法指定为object_hook:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b234" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">loads()方法不是返回一个JSON dictionary对象，而是按照预期生成一个适当的Label对象。</p><h1 id="d8c6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">3.嵌套对象</h1><p id="0d43" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">到目前为止一切顺利。现在，让我们看看在有嵌套对象的更复杂的情况下，您需要做些什么。ImageLabelCollection类包含一个Label对象列表，作为类变量“bboxes”的一部分。下面用序列化方法to_json()复制了类的定义。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2296" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成的json字符串示例如下:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">序列化的ImageLabelCollection对象</figcaption></figure><p id="2036" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将字符串反序列化为类对象，您需要编写一个自定义方法来构造对象。您可以向ImageLabelCollection添加一个静态方法，在该方法中，您可以从加载的JSON字典中构造标签对象，然后将它们作为一个列表分配给类变量bbox。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6a75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个过程有点繁琐，但有一个更好的方法。您可以编写from_json()静态方法，在该方法中您可以处理逐步构造类对象。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d363" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用上面的from_json()方法作为对象挂钩调用json.loads()时，它将在自下而上构建对象时迭代调用该方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="aa6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是这个方法被多次调用，每次都调用dictionary对象的不同部分，所以您必须添加逻辑来处理如何根据类型将dictionary对象转换成适当的类对象。在上面的例子中，我使用某些键的存在作为线索来决定应该调用哪个构造函数。这仍然有点乏味，但比自己编写整个代码的原始解决方案要好。</p><h1 id="1b1e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">4.jsonpickle</h1><p id="a6fd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">最后一种反序列化方法是使用名为jsonpickle的外部库。您可以通过以下方式轻松安装它:</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="c118" class="mk ld iq mg b gy ml mm l mn mo">pip install jsonpickle</span></pre><p id="0d08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用法很简单。调用jsonpickle.encode()进行序列化，调用decode()进行反序列化。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d54e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">序列化的结果与我们最初的JSON字符串略有不同:</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="51a6" class="mk ld iq mg b gy ml mm l mn mo">{"py/object": "__main__.ImageLabelCollection", "version": 1, "type": "bounding-box-labels", "bboxes": {"20210715_111300 16.jpg": [{"py/object": "__main__.Label", "label": "StabilityOff", "x": 1, "y": 1025, "width": 553, "height": 29}, {"py/object": "__main__.Label", "label": "StabilityOn", "x": 1, "y": 964, "width": 563, "height": 30}]}}</span></pre><p id="6948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它添加了一些额外的注释信息，以便以后进行反序列化。</p><h1 id="9f83" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="82bc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">鉴于jsonpickle的简单性，对于一般用途来说，这应该是最容易序列化的方法。然而，由于jsonpickle在JSON字符串中的附加属性，它的局限性在于，您需要使用jsonpickle的decode()方法来取回对象。一般来说，这应该不是问题，但是如果您有一些需要自己处理的自定义对象，您可以使用建议的自定义反序列化方法。整个代码示例在这里共享<a class="ae lb" href="https://github.com/changsin/Medium/blob/main/notebooks/JSON_Deserialization.ipynb" rel="noopener ugc nofollow" target="_blank">。感谢阅读。</a></p></div></div>    
</body>
</html>