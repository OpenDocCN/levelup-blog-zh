# 程序的退化

> 原文：<https://levelup.gitconnected.com/the-programs-regress-c5c8bcaf6f66>

为什么好的软件会变坏？你能做什么来阻止它的退化？

[什么是回归测试？](#0c0b)
[为什么产品会退化](#b113)
[为什么回归测试很难](#fd57)
[回归测试的两种方法](#9a68)
∘ [分阶段方法](#5178)
∘ [选择方法](#89a4)
[回归测试最佳实践](#f470)
[参考文献](#7670)

![](img/387558e487d3b43a2a7c877d02aa9b81.png)

Joshua Hoehne 在 [Unsplash](https://unsplash.com/s/photos/blue-screen?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

软件的生命周期随着产品的发布而结束。如果该软件从此幸福地生活在一起，那将是一个童话般的结局。唉，事实上，产品以这样或那样的方式倒退，需要产品团队将资源集中在一起，要么修复 bug，要么更新特性。本文的目的是找出回归的常见原因以及管理回归测试的有效方法。

# 两只虫子的故事

假设您可以在两种类型的 bug 之间做出选择。一个是可怕的蓝屏死机，正如你在上面看到的。另一种是类似下图的各种网站错误。

![](img/dd61a745f5c638e34c19331f16bec396.png)

由[马库斯·斯皮斯克](https://unsplash.com/@markusspiske?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/web-error-message?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

没有人希望遇到任何类型的错误，但是如果你被迫在两种类型中选择，你会选择哪一种？想一分钟。

你的选择可能与我的不同，但我宁愿选择服务错误，而不是 Windows 错误，因为当操作系统崩溃时，你无能为力，除了重新启动和(希望)再次登录。

现在，如果你是一名开发者，你必须在操作系统错误和网络服务器错误之间做出选择，我认为选择应该是明确的。尽管开发和维护 web 服务器的压力很大，但是调试和修复 web 服务器的错误要比在操作系统上容易得多。为什么？因为 web 服务器开发人员很容易就能访问到导致该错误的代码。另一方面，操作系统代码对于开发者来说是不可及的，除非通过定期的操作系统更新。当选择正确的回归测试策略时，了解这两种类型的错误之间的区别将成为一个重要的点。

# 什么是回归测试？

回归测试的定义是，“重新运行[功能性](https://en.wikipedia.org/wiki/Functional_testing)和[非功能性测试](https://en.wikipedia.org/wiki/Non-functional_testing)，以确保之前开发和测试的软件在变更后仍能运行。”([维基百科](https://en.wikipedia.org/wiki/Regression_testing))这听起来很简单，但这意味着对同一款软件进行相同的测试吗？

我不想表现得很哲学，但是没有什么是一成不变的。想想 Windows 操作系统是如何随着时间的推移从 Windows 3.1、XP、Vista 发展而来的。7、8、10 和 11。现在的 Windows 操作系统与以前的 Windows 有很大不同。

![](img/81cbb2658741531b872919b594d77575.png)

Windows 的演变

测试用例及工具怎么样？你认为他们会随着时间而改变吗？你打赌！随着软件的更新，新的测试必须被添加，原始的测试用例也必须被修改。

# 产品退化的原因

不管是 OS 崩溃还是 web 服务故障，所有的 bug 都是不好的。不幸的事实是，如果运行回归测试，许多错误都是可以避免的。简单地说，回归测试是为了确保所有以前的功能和特性仍然工作而设计的测试。然而，管理和运行回归测试是困难的，至少有四个原因。

首先，也是最重要的，产品发生了变化。所有软件变更。任何复杂的软件都包含一些缺陷，必须修复或修改这些缺陷以满足客户的新需求。或者增加新的功能来吸引新的用户群。唯一不变的软件是过时的。即使软件本身没有改变，它的依赖关系也会更新，这就相当于把地毯(软件)拖到它的脚下。

第二，需求变化。一个程序发布后，会发生很多事情。用户变化的人口统计、预期的市场需求不存在、新法规可能被实施等等。这些变化总是导致重新检查软件的需求。因此，我们需要改变现有测试用例的期望。

![](img/db456f6851ca33a01597b987bbab77a5.png)

在 [Unsplash](https://unsplash.com/s/photos/software?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上由 [Austin Distel](https://unsplash.com/@austindistel?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

第三，数据变化。即使程序本身不处理任何数据库，数据也可以以不同的形式出现。除了数据库数据，用户输入、来自另一个服务的参数、来自设备的传感器数据、文件和流都是程序必须处理的数据形式。根据时间、日期、季节和地点的不同，数据经常会发生巨大的变化。随着数据的改变或迁移，软件以及回归测试也将随之改变。

![](img/f8c18b0e5f1350c4122f4beb1d4c6afd.png)

照片由[马库斯·温克勒](https://unsplash.com/@markuswinkler?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/data?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

第四，硬件的变化。更大的空间、更快的速度、更好的分辨率或新的外形都是升级硬件的不同理由。随着硬件的变化，固件和软件也需要更新，回归测试也在进行中。

![](img/2d53ac4138b22085cc78db7be3566378.png)

照片由 [Christian Wiediger](https://unsplash.com/@christianw?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/s/photos/hardware?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

# 为什么回归测试很难

所有这些变化给回归测试带来了两个问题。首先，测试用例及工具需要不断更新。问题是这些测试用例及工具并不属于个人或团队。除非有一个独立的持续工程团队来维护它们，否则一个特性团队的所有涉众(PM、dev 和 test)都需要参与进来。

第二，无论何时发生任何变化，都应该执行所有的回归测试用例，以确保没有回归。如果测试用例的数量不是很大，并且都是自动化的，那么运行一次完整的测试就不是问题。然而，总的来说，全面测试需要大量的资源和时间投入。

# 回归测试的两种方法

根据团队采用的软件开发生命周期的类型，有两种回归测试的方法。

## 分阶段方法

第一种方法是我称之为“分阶段”的方法，在这种方法中，您在分层的阶段中运行一组测试。典型的 CI/CD 管道有三个阶段:开发、测试和生产。它们对应三种不同的测试环境。回归测试在管道的所有阶段运行。理想的测试结构是一个金字塔，其中单元测试比集成测试和端到端测试多得多。

![](img/0e12b882d76b6af6ca5e3df3a70e3b56.png)

测试金字塔

这个想法是所有的功能问题，包括边缘案例，都包含在单元测试中。这是非常理想的，因为在单元测试中，所有的依赖项都被假定为是“模拟的”,因此它们可以在一个隔离的环境中非常快速和可靠地运行。

在集成测试阶段，只运行集成测试用例，这些用例检查与其他组件的集成。通常，依赖组件是通过 API 调用来调用的。它们的数量可以而且应该更少，因为集成测试是在具有其他依赖项的测试环境中运行的，因此可靠性更低，耗时更长。您不希望在集成测试中检查功能问题。

在最终的端到端测试中，甚至有更大的依赖，如 UI 或接近真实的服务依赖。由于高碎片化和不可靠性，测试用例的数量需要比集成测试更少。

在 CI/CD 管道中，所有的回归测试都是运行的，但是它们是自动运行的，并且是分阶段运行的，因此所需的资源和时间得到了管理。如果它们不是自动化的，而是分阶段的，那么您仍然可以使用相同的分阶段方法。如果在早期阶段(例如，单元测试阶段)发现了任何 bug，那么只运行几个选定的测试，这样您就节省了运行其他测试的时间，这些测试会更加耗时和消耗资源。

## 选择方法

第二种策略是“选择”方法，在这种方法中，您仔细地只选择与代码变更相关的测试用例。显然，如果您知道哪些测试用例是相关的，那么您应该选择选择性方法。问题是你不能总是知道哪些是相关的。要知道哪些是相关的，你需要额外的信息。

一种流行的方法是考虑您之前运行的代码覆盖率信息。代码覆盖率和测试用例之间的关联是基于之前运行的测试的。例如，您可以喜欢一个文件或一个行号所命中的测试用例的数量。然后，如果某一行发生了变化，您可以进行反向查找，找到一组最有可能与引入的代码变化相关的测试用例。

为了优化测试执行，选择方法需要分三步实现。第一步是测试套件最小化，其中重复和重叠的测试用例被删除或合并。第二步是我们刚刚描述的测试用例选择步骤。在最后一步中，您想要对所选择的测试用例进行优先级排序，以便更重要的测试用例能够首先运行。

![](img/afeadade24451e991a0bc76f6752eeb9.png)

你可能会问为什么测试用例优先级排序的最后一步是必要的。仅仅选择测试用例还不够吗，因为重点是针对给定的代码变更运行所有相关的测试用例？你不想错过任何重要的案子，对吧？测试覆盖是重要的，但是如果没有优先级，你可能会在遇到一个关键的 bug 之前浪费时间运行不重要的测试用例。例如，如果代码更改涉及到安装的更改，那么您希望在检查功能问题之前首先运行相关的设置场景。如果您甚至不能安装一个组件，那么运行功能测试或检查文档是没有意义的。

在这两种方法中，选择方法似乎更可取，因为如果您选择了正确的测试用例，您可以显著减少测试执行资源。然而，实际上，这种选择方法并不总是奏效，原因有二。首先，只有当您已经有了现有的测试用例并且有了历史记录，测试用例关联表才能被构建。如果代码变更是全新的，您将没有相关的测试用例，因此您没有测试用例可供选择。第二，虽然您可以基于代码覆盖率、需求、相似性等来构建测试用例相关表。，只有在依赖关系明确的情况下，它才能相对较好地工作。换句话说，如果您的代码变更是在您有测试用例的测试下的一个组件中，您可以选择它们。但是，如果更改发生在依赖关系之一(例如，库、操作系统、驱动程序等)中。)，那么关系不是很清楚，因此不会有任何匹配的测试用例。

由于这些原因，在许多特性团队中，回归测试大部分是由测试专家完成的，他们非常了解领域，并且在测试服务方面有丰富的经验。然而，近年来，有人试图用机器学习来取代人类专家。[2]

# 回归测试最佳实践

最后，这里是管理和运行回归测试的最佳实践。

1.  **为测试用例分配优先级:**在写测试用例的时候，总是要分配一个优先级。当你只有有限的时间时，这样做将允许过滤测试用例，而这恰好是生产团队的大部分时间。划分优先级也有助于在分类时评估 bug 的严重性。
2.  **使用分阶段的方法:**不管你的管道是否是 CI/CD，总是以这样一种方式排列你的测试用例的优先级，最相关和最重要的测试用例首先运行。即使你没有管道，做分阶段的方法也会节省你大量的资源和时间。
3.  **为每一个 bug 创建一个测试用例:**对于发现的每一个 bug，让它成为团队中的习惯和强制规则，创建一个回归测试用例。在每个相关的阶段都这样做。对于一个足够复杂的服务，没有一个产品团队能够拥有完整的测试覆盖，所以在产品中发现的 bug 是不可避免的。重要的是要记住通过为每个 bug 创建回归测试来增加测试覆盖率。

[约翰·班扬的《天路历程》据说是有史以来最重要的基督教小说。它讲述了基督徒走向天堂之城的旅程。然而，他所取得的进步被无数的挫折所破坏，但最终，他到达了目的地。](https://en.wikipedia.org/wiki/The_Pilgrim%27s_Progress)

当然，这篇文章的标题是向著名的天堂发展的故事致敬。但更重要的是，它描绘了一个类似于《天路历程》中基督徒的旅程。如果一个程序要在第一个初始发布生命周期之后继续存在，那么只要它还存在，就需要更新和维护。回归测试是提供重要生命支持的最重要方法之一。

“那些不了解历史的人注定会重复历史。”—乔治·桑塔亚纳

# 参考

[1] [Kush Bhatnagar (2020)，利用机器学习选择回归测试用例](https://medium.com/analytics-vidhya/regression-test-case-selection-using-machine-learning-241ded86f559)。分析 Vidhya。

[2] [潘荣琦等。艾尔。(2021)，使用机器学习的测试用例选择和优先化:系统的文献综述](https://arxiv.org/abs/2106.13891)。arXiv。

[3] [Vipindeep Vangala 等。艾尔。(2009)，使用程序概要和静态执行的测试用例比较和聚类](https://www.microsoft.com/en-us/research/wp-content/uploads/2009/01/Test_Suite_Clustering_MS_paper.pdf)。微软研究院。

[4] [尹等(2011)，补丁如何变成 bug？:对商业和开源操作系统中错误修复的综合特征研究](http://opera.ucsd.edu/paper/fse11.pdf)。

# 分级编码

感谢您成为我们社区的一员！在你离开之前:

*   👏为故事鼓掌，跟着作者走👉
*   📰查看[升级编码出版物](https://levelup.gitconnected.com/?utm_source=pub&utm_medium=post)中的更多内容
*   🔔关注我们:[Twitter](https://twitter.com/gitconnected)|[LinkedIn](https://www.linkedin.com/company/gitconnected)|[时事通讯](https://newsletter.levelup.dev)

🚀👉 [**加入升级达人集体，找到一份惊艳的工作**](https://jobs.levelup.dev/talent/welcome?referral=true)