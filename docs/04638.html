<html>
<head>
<title>How to Create Pages Dynamically in Gatsby Using MDX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用MDX在Gatsby中动态创建页面</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-pages-dynamically-in-gatsby-using-mdx-66faa175944e?source=collection_archive---------8-----------------------#2020-07-07">https://levelup.gitconnected.com/how-to-create-pages-dynamically-in-gatsby-using-mdx-66faa175944e?source=collection_archive---------8-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/59dfed0aed464ea52231b762de97f0c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Tnw4HSaXJaLi8PMK87oPg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@esteejanssens" rel="noopener ugc nofollow" target="_blank">埃斯特扬森斯</a>拍摄的照片</figcaption></figure><p id="2c74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本帖中，我们将探讨如何在Gatsby中使用MDX以编程方式创建页面。</p><h1 id="f4e5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">装置</h1><p id="b912" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要启动并运行，我们需要安装几个插件</p><h2 id="36f2" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">1.MDX相关插件</h2><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="d613" class="mh lf it my b gy nc nd l ne nf">npm i gatsby-plugin-mdx @mdx-js/mdx @mdx-js/react</span></pre><p id="95c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们需要在<code class="fe ng nh ni my b">gatsby-config.js</code>里面配置gatsby-plugin-mdx</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="dfbc" class="mh lf it my b gy nc nd l ne nf">plugins: [<br/>  {<br/>    resolve: 'gatsby-plugin-mdx',<br/>    options: {<br/>      defaultLayouts: {<br/>        default: require.resolve('./src/components/Layout.js'),<br/>      },<br/>    },<br/>  },<br/>];</span></pre><p id="e78d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们需要解析插件<code class="fe ng nh ni my b">gatsby-plugin-mdx</code>,因为我们还想传入options对象，它定义了我们想在MDX文件中使用的布局。</p><p id="7b8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:<code class="fe ng nh ni my b">require.resolve</code>给我们绝对路径名。</p><p id="8bd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们加载的任何MDX文件都将被加载到我们在<code class="fe ng nh ni my b">gatsby-config</code>中定义的Layout.js模板中。</p><p id="594c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经安装了插件，它将在我们在gatsby-config中定义的pages或posts目录中查找mdx文件。</p><h2 id="7b28" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">2.源文件相关插件。</h2><p id="5ad5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了让帖子页进入盖茨比，我们将使用另一个插件<code class="fe ng nh ni my b">gatsby-source-filesystem</code></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="0245" class="mh lf it my b gy nc nd l ne nf">npm i gatsby-source-filesystem</span></pre><p id="5f25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把它们放到数据层，这样我们就可以访问它们了。gatsby源文件系统是使用本地文件作为graphql数据层的一部分的一种方式。</p><p id="436a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦安装完成，我们需要更新gatsby配置来解析源文件系统插件</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="8854" class="mh lf it my b gy nc nd l ne nf">plugins: [<br/>  {<br/>    resolve: 'gatsby-plugin-mdx',<br/>    options: {<br/>      defaultLayouts: {<br/>        default: require.resolve('./src/components/Layout.js'),<br/>      },<br/>    },<br/>  },<br/>  {<br/>    resolve: 'gatsby-source-filesystem',<br/>    options: {<br/>      name: 'posts',<br/>      path: `${__dirname}/content/posts`,<br/>    },<br/>  },<br/>];</span></pre><p id="9895" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，它将加载它在路径<code class="fe ng nh ni my b">/content/posts</code>中找到的任何东西作为数据层的一部分，并且因为我们安装了gatsby MDX插件，它将寻找MDX文件并将这些文件转换成GraphQL节点。</p><h1 id="8bd2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么时候应该使用MDX？</h1><p id="8abb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用MDX的全部原因是因为我们希望在标记生成的页面中添加某种交互性。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="cc32" class="le lf it bd lg lh nq lj lk ll nr ln lo lp ns lr ls lt nt lv lw lx nu lz ma mb bi translated">引导程序</h1><p id="b993" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">既然我们添加了配置来查找系统中的文件并将它们转换成GraphQL节点，我们将需要使用gatsby API <code class="fe ng nh ni my b">createPages</code>通过在<code class="fe ng nh ni my b">gatsby-node.js</code>中配置来以编程方式生成那些post文件作为页面。</p><p id="fdc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">gatsby本身有几个可用的API，可以用来扩展gatsby的工作方式，在这些API中，您可以导出一个与Gatsby寻找的挂钩同名的函数。因此，gatsby将在构建阶段执行这些指令。</p><p id="55ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们想要创建页面，所以我们使用<code class="fe ng nh ni my b">exports.createPages</code>，因为我们要加载数据，所以我们使函数异步。</p><p id="cd20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">gatsby将为我们提供几个实用方法，如actions、graphql helper和reporter(如果您想在控制台中放些东西，可以使用它们，这是Gatsby内部的一种console.log)</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="5d35" class="mh lf it my b gy nc nd l ne nf">// gatsby-node.js<br/>exports.createPages = async ({ actions, graphql, reporter }) =&gt; {<br/>  const result = await graphql(`<br/>    query {<br/>      allMdx {<br/>        nodes {<br/>          frontmatter {<br/>            path<br/>          }<br/>        }<br/>      }<br/>    }<br/>  `);</span><span id="dfa9" class="mh lf it my b gy nv nd l ne nf">  if (result.errors) {<br/>    reporter.panic('failed to create posts ', result.errors);<br/>  }</span><span id="edb3" class="mh lf it my b gy nv nd l ne nf">  const pages = result.data.allMdx.nodes;</span><span id="931f" class="mh lf it my b gy nv nd l ne nf">  pages.forEach(page =&gt; {<br/>    actions.createPage({<br/>      path: page.frontmatter.path,<br/>      component: require.resolve('./src/templates/postTemplate.js'),<br/>      context: {<br/>        pathSlug: page.frontmatter.path,<br/>      },<br/>    });<br/>  });<br/>};</span></pre><p id="5987" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在createPage函数中，我们将使用GraphQL助手通过传递一个GraphQL查询从数据层获取节点，如您在上面的代码片段中所见。</p><p id="dbd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们使用<code class="fe ng nh ni my b">actions.createPage</code>创建页面，遍历这些以数组形式返回的页面，以编程方式生成它们，如下面的截图所示</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/b38e5339f15de2a50f6cf3498d083ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BaIg2JJE7-qWLMLt.png"/></div></div></figure><p id="8945" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ng nh ni my b">actions.createPage</code>接受一个options对象作为参数，它有3个属性:路径、组件和上下文。<br/> <code class="fe ng nh ni my b">Path</code>就是我们在mdx中定义的frontmatter。<br/> <code class="fe ng nh ni my b">Component</code>获取您想要用于这些页面的模板的路径。下面是一个用作页面模板的样本片段。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="2c66" class="mh lf it my b gy nc nd l ne nf">import { graphql } from 'gatsby';<br/>import { MDXRenderer } from 'gatsby-plugin-mdx';<br/>import React from 'react';</span><span id="7e63" class="mh lf it my b gy nv nd l ne nf">import Layout from '../components/Layout';</span><span id="c292" class="mh lf it my b gy nv nd l ne nf">export const query = graphql`<br/>  query($pathSlug: String!) {<br/>    mdx(frontmatter: { path: { eq: $pathSlug } }) {<br/>      frontmatter {<br/>        title<br/>        path<br/>      }<br/>      body<br/>    }<br/>  }<br/>`;</span><span id="aafd" class="mh lf it my b gy nv nd l ne nf">const Post = ({ data: { mdx: post } }) =&gt; {<br/>  const { title } = post.frontmatter;<br/>  const { body } = post;<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Layout&gt;<br/>        &lt;h1&gt;{title}&lt;/h1&gt;<br/>        &lt;MDXRenderer&gt;{body}&lt;/MDXRenderer&gt;<br/>      &lt;/Layout&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="25c8" class="mh lf it my b gy nv nd l ne nf">export default Post;</span></pre><p id="6b9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ng nh ni my b">Context</code>接受一个以pathSlug为属性的对象，这是我们传递给上面查询的值。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="c223" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">添加完上面的内容后，现在我们可以向MDX页面添加交互性，如下所示</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="1b06" class="mh lf it my b gy nc nd l ne nf">---<br/>path: '/blog/hello-world'<br/>date: '2020/01/01'<br/>title: 'Hello World'<br/>summary: 'hello world post'<br/>---</span><span id="7000" class="mh lf it my b gy nv nd l ne nf">import Counter from '../../../src/components/Counter';</span><span id="2d0c" class="mh lf it my b gy nv nd l ne nf">Hello World</span><span id="6102" class="mh lf it my b gy nv nd l ne nf">&lt;Counter /&gt;</span></pre><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/609ce990e72d400a3a80c6cd361dca58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nz1t9895TegImgSK.png"/></div></div></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="fc58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">在这篇文章之后，你可以在这里</strong>  <strong class="ki iu">找到一个starter repo </strong> <a class="ae kf" href="https://github.com/gabroun/gatsby-mdx-starter" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">，它显示了mdx页面的用法</strong></a></p></div></div>    
</body>
</html>