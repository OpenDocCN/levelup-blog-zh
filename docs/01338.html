<html>
<head>
<title>Moving from multiple repositories to a lerna-js mono-repo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从多个存储库转移到一个lerna-js单一存储库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/moving-from-multiple-repositories-to-a-lerna-js-mono-repo-faa97aeee35b?source=collection_archive---------1-----------------------#2019-12-15">https://levelup.gitconnected.com/moving-from-multiple-repositories-to-a-lerna-js-mono-repo-faa97aeee35b?source=collection_archive---------1-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="34b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在深入研究Lerna、Bit和其他单一回购工具之前，想想你在做什么，你在为谁做，为什么做。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c9d4a1d3efa84a4338e77aee606688bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*e_azttoZTG53hk-VAgGPLw.jpeg"/></div></figure><p id="2574" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di">在</span> <a class="ae lv" href="https://en.wikipedia.org/wiki/Revision_control" rel="noopener ugc nofollow" target="_blank">版本控制系统</a>中，一个<strong class="ks iu"> monorepo </strong>(一个<em class="lw">单片库</em>的<a class="ae lv" href="https://en.wikipedia.org/wiki/Syllabic_abbreviation" rel="noopener ugc nofollow" target="_blank">音节缩写</a>)是一个软件开发策略，其中许多项目的代码被存储在同一个<a class="ae lv" href="https://en.wikipedia.org/wiki/Repository_(version_control)" rel="noopener ugc nofollow" target="_blank">库</a>中。将大型代码库分割成单独的独立版本包对于代码共享非常有用。然而，跨许多存储库进行变更是很麻烦的，也很难跟踪，跨存储库的测试变得非常复杂。一些公司已经采用了这种策略，如谷歌、脸书、微软、优步、Airbnb和Twitter。</p><h2 id="6c08" class="lx ly it bd lz ma mb dn mc md me dp mf kz mg mh mi ld mj mk ml lh mm mn mo mp bi translated"><strong class="ak">为什么要使用单边回购？</strong></h2><ul class=""><li id="ad52" class="mq mr it ks b kt ms kw mt kz mu ld mv lh mw ll mx my mz na bi translated"><strong class="ks iu">通过原子提交轻松重构全局特性。</strong>不需要为每个repo做一个pull请求，弄清楚以什么顺序构建您的变更，您只需要做一个原子pull请求，它将包含与您正在处理的特性相关的所有提交。</li><li id="4d5f" class="mq mr it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated"><strong class="ks iu">简化的包发布。</strong>如果你计划在一个依赖于另一个共享代码包的包中实现一个新特性，你可以用一个命令来实现。这个功能需要一些额外的配置，这将在本文的工具回顾部分讨论。目前，有丰富的工具可供选择，包括Lerna和Yarn工作空间。</li><li id="4d08" class="mq mr it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated">简化的依赖关系管理 —在多个项目依赖于第三方依赖关系的多存储库环境中，依赖关系可能会被下载或构建多次。在monorepo中，构建很容易优化，因为引用的依赖项都存在于同一个代码库中。</li><li id="8d15" class="mq mr it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated">在共享包中重用代码，同时保持它们的隔离。Monorepo允许你从其他包中重用你的包，同时保持它们之间的隔离。您可以使用对远程包的引用，并通过单个入口点使用它们。要使用本地版本，您可以使用本地符号链接。这个特性可以通过bash脚本或者引入一些额外的工具来实现，比如Lerna或者Yarn。</li></ul><p id="99fc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有了Lerna，我们现在可以管理所有软件包的单一存储库，其目录结构如下所示:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ed3e" class="lx ly it nh b gy nl nm l nn no">mylerna_repo/<br/>  - node_modules<br/>  - packages<br/>    - client<br/>      package.json<br/>    - server<br/>      package.json<br/>    - docs<br/>      package.json<br/>  lerna.json<br/>  package.json</span></pre><h1 id="495a" class="np ly it bd lz nq nr ns mc nt nu nv mf jz nw ka mi kc nx kd ml kf ny kg mo nz bi translated">工具评论</h1><p id="9641" class="pw-post-body-paragraph kq kr it ks b kt ms ju kv kw mt jx ky kz oa lb lc ld ob lf lg lh oc lj lk ll im bi translated">管理monorepos的工具集在不断增加，目前，很容易迷失在monorepos的各种建筑系统中。通过使用<a class="ae lv" href="https://github.com/despeauxz/codesandbox" rel="noopener ugc nofollow" target="_blank">本报告</a>，您可以随时了解流行的解决方案。但是现在，让我们快速地看一下现在大量使用JavaScript的工具:</p><ul class=""><li id="1427" class="mq mr it ks b kt ku kw kx kz od ld oe lh of ll mx my mz na bi translated"><a class="ae lv" href="https://yarnpkg.com/blog/2017/08/02/introducing-workspaces/" rel="noopener ugc nofollow" target="_blank"> Yarn </a>是一个JavaScript依赖管理工具，通过工作区无提升支持monorepos。</li><li id="5af6" class="mq mr it ks b kt nb kw nc kz nd ld ne lh nf ll mx my mz na bi translated">Lerna 是一个基于Yarn的工具，用于管理包含多个包的JavaScript项目。</li></ul><h1 id="d272" class="np ly it bd lz nq nr ns mc nt nu nv mf jz nw ka mi kc nx kd ml kf ny kg mo nz bi translated"><strong class="ak">纱线</strong></h1><p id="c0f3" class="pw-post-body-paragraph kq kr it ks b kt ms ju kv kw mt jx ky kz oa lb lc ld ob lf lg lh oc lj lk ll im bi translated">Yarn是NPM包的依赖管理器，它最初不是为了支持monorepos而构建的。但是在1.0版本中，<a class="ae lv" href="https://www.toptal.com/front-end" rel="noopener ugc nofollow" target="_blank"> Yarn开发者</a>发布了一个名为<em class="lw"> Workspaces </em>的功能。在发布时，它并不稳定，但是过了一段时间，它就可以用于生产项目了。</p><p id="a7e8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="lw">工作空间</em>基本上是一个包，它有自己的<em class="lw"> package.json </em>并且可以有一些特定的构建规则(例如，如果你在你的项目中使用TypeScript，那么有一个单独的<em class="lw"> tsconfig.json </em>)。).实际上，您可以使用bash在没有Yarn工作空间的情况下进行管理，并拥有完全相同的设置，但是这个工具有助于简化每个包的安装和更新依赖关系的过程。</p><p id="e44e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一眼看去，Yarn及其工作区提供了以下有用的特性:</p><ol class=""><li id="b103" class="mq mr it ks b kt ku kw kx kz od ld oe lh of ll og my mz na bi translated">所有包的根目录中的单个<code class="fe oh oi oj nh b">node_modules</code>文件夹。例如，如果您有<code class="fe oh oi oj nh b">packages/package_a</code>和<code class="fe oh oi oj nh b">packages/package_b</code>——以及它们自己的<code class="fe oh oi oj nh b">package.json</code>——所有的依赖项将只安装在根目录中。这是Yarn和Lerna工作方式的区别之一。</li><li id="5d42" class="mq mr it ks b kt nb kw nc kz nd ld ne lh nf ll og my mz na bi translated">允许本地包开发的依赖符号链接。</li><li id="8bcd" class="mq mr it ks b kt nb kw nc kz nd ld ne lh nf ll og my mz na bi translated">所有依赖项的单一锁定文件。</li><li id="e70b" class="mq mr it ks b kt nb kw nc kz nd ld ne lh nf ll og my mz na bi translated">如果您只想为一个包重新安装依赖项，可以进行集中的依赖项更新。这可以通过使用<code class="fe oh oi oj nh b">-focus</code>旗来完成。</li><li id="ff29" class="mq mr it ks b kt nb kw nc kz nd ld ne lh nf ll og my mz na bi translated">与Lerna整合。您可以轻松地让Yarn处理所有的安装/符号链接，并让Lerna负责发布和版本控制。这是到目前为止最流行的设置，因为它需要更少的努力，并且易于操作。</li></ol><p id="0697" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有用的链接:</p><ul class=""><li id="7787" class="mq mr it ks b kt ku kw kx kz od ld oe lh of ll mx my mz na bi translated"><a class="ae lv" href="https://yarnpkg.com/lang/en/docs/workspaces/" rel="noopener ugc nofollow" target="_blank">纱线工作区</a></li></ul><h1 id="3434" class="np ly it bd lz nq nr ns mc nt nu nv mf jz nw ka mi kc nx kd ml kf ny kg mo nz bi translated">莱尔纳</h1><p id="b229" class="pw-post-body-paragraph kq kr it ks b kt ms ju kv kw mt jx ky kz oa lb lc ld ob lf lg lh oc lj lk ll im bi translated">这个工具在处理语义版本、设置构建工作流、推送包等方面非常有用。Lerna背后的主要思想是，您的项目有一个packages文件夹，其中包含所有独立的代码部分。除了包之外，还有主应用程序，例如，它可以位于src文件夹中。Lerna中几乎所有的操作都遵循一个简单的规则——遍历所有的包，并对它们进行一些操作，例如，增加包的版本，更新所有包的依赖关系，构建所有包，等等。</p><p id="4e45" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用Lerna，您有两种选择来使用您的软件包:</p><ol class=""><li id="b8cb" class="mq mr it ks b kt ku kw kx kz od ld oe lh of ll og my mz na bi translated">而不把他们推到偏远的(NPM)</li><li id="d119" class="mq mr it ks b kt nb kw nc kz nd ld ne lh nf ll og my mz na bi translated">将您的包推送到远程</li></ol><p id="a25e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当使用第一种方法时，您可以对您的包使用本地引用，并且基本上不关心符号链接来解析它们。</p><p id="7f72" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是如果您使用第二种方法，您将被迫从远程导入您的包。(例如，<code class="fe oh oi oj nh b">import { something } from @name/packagename;</code>)，这意味着您将始终获得您的包的远程版本。对于本地开发，您必须在您的文件夹的根目录中创建符号链接，以使bundler解析本地包，而不是使用那些在您的<code class="fe oh oi oj nh b">node_modules/</code>中的包。这就是为什么在启动Webpack或你最喜欢的bundler之前，你必须启动<code class="fe oh oi oj nh b"><a class="ae lv" href="https://lernajs.io/#command-bootstrap" rel="noopener ugc nofollow" target="_blank">lerna bootstrap</a></code>，它会自动链接所有的包。</p><h1 id="14cf" class="np ly it bd lz nq nr ns mc nt nu nv mf jz nw ka mi kc nx kd ml kf ny kg mo nz bi translated">结论</h1><p id="b01c" class="pw-post-body-paragraph kq kr it ks b kt ms ju kv kw mt jx ky kz oa lb lc ld ob lf lg lh oc lj lk ll im bi translated">今天的“mono repo”通常意味着将一个存储库变成一个多包存储库，从这里可以发布多个包。这个存储库是多回购架构的一部分，存在于它的生态系统中。</p><p id="47f8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">像Bit(它是为多回购代码库中的代码共享而构建的)、Lerna和Yarn workspaces这样的工具有助于优化这个工作流，并促进代码共享，以加快开发和简化维护。</p><p id="9823" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">选择正确的工具意味着理解你要构建什么，你为什么要构建它，以及你期望其他人如何使用它。回答这些问题可以帮助你从一开始就做出正确的选择，这将使你以后的生活更加轻松。</p><p id="b3e6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">别忘了:共享代码是关于工具和技术的，也是关于人和交流的。合适的工具可以帮助你分享和交流，但不会取代团队工作和协作。</p><p id="3fcc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感谢您的阅读，请随时与他人分享您的见解和经验！干杯。</p></div></div>    
</body>
</html>