<html>
<head>
<title>Modal Dialog Driven Websites Without JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有JavaScript的模态对话框驱动的网站</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/modal-dialog-driven-websites-without-javascript-16e858615780?source=collection_archive---------2-----------------------#2020-09-11">https://levelup.gitconnected.com/modal-dialog-driven-websites-without-javascript-16e858615780?source=collection_archive---------2-----------------------#2020-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d7f7fb2f26752e93e35165aa80170330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2KMQTuUkoZwpYxSx2delxw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">比下拉菜单好多了</figcaption></figure><p id="f964" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">继续我上一篇文章的主题<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/tabbed-interfaces-without-javascript-661bab1eaec8">，我想介绍如何不用JavaScript就能制作模态对话框。使用以下技术，可以简化网站的主要功能和导航。</a></p><p id="6150" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">再说一次，使用JavaScript的网站——模态对话框、下拉菜单、“汉堡包”风格的移动菜单——在可用性和可访问性方面都是彻头彻尾的失败；尤其是当他们缺乏优雅的退化。</p><p id="9e2c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同样，许多常见的“经典”导航技术——比如下拉菜单——对于有辅助功能需求的用户来说是一个巨大的中指。像NNGroup这样的地方和WCAG这样的基本指南反复告诉我们不要对这些事情使用脚本，即使没有脚本也是有问题的。</p><p id="930e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">CSS3为我们提供了解决这个问题所需的所有工具！通常使用相同甚至更少的代码，以这种方式，非屏幕媒体设备—屏幕阅读器(大声朗读页面的软件)、盲文阅读器、搜索引擎等能够很好地消化页面，就像它只是常规导航一样。</p><p id="6946" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">…它的神奇之处来自一个简单的伪状态。<code class="fe le lf lg lh b">:target</code></p><h1 id="b2a5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">CSS3 <code class="fe le lf lg lh b">:target</code>是什么？</h1><p id="20ce" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">它让我们对当前页面地址的散列部分的当前目标元素进行样式化。当这个散列匹配一个<a> nchor标签上的名字，或者当它匹配页面上具有相同ID的任何元素时，对于所述元素:target为真。</a></p><p id="935a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">后一种用法——针对ID——是我们想要的样式。如果我有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="537c" class="mt lj it lh b gy mu mv l mw mx">&lt;div id="test"&gt;Some Text&lt;/div&gt;</span></pre><p id="e03d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个CSS:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b6fd" class="mt lj it lh b gy mu mv l mw mx">#test:target { color:red; }</span></pre><p id="3f0f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当URI末尾有hash #测试时，DIV中的文本将是红色，否则它将是默认颜色。</p><h1 id="109b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">那么我们如何用它来制作一个模型呢？</h1><p id="0552" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">当元素不是:target时，隐藏它。当它…好吧，展示它。这是您的切换状态，不涉及脚本。</p><h2 id="a01e" class="mt lj it bd lk my mz dn lo na nb dp ls kq nc nd lw ku ne nf ma ky ng nh me ni bi translated">加价</h2><p id="6f43" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">如果我们默认隐藏模态的外部容器，但是当它是<code class="fe le lf lg lh b">:target</code>时，在我们的内容上显示它，结果意味着我们打开模态所需要的是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4dc4" class="mt lj it lh b gy mu mv l mw mx">&lt;a href="#ourModal"&gt;Open Our Modal&lt;/a&gt;</span></pre><p id="6810" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同时关闭它，我们可以把:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f68b" class="mt lj it lh b gy mu mv l mw mx">&lt;a href="#"&gt;Close Modal&lt;/a&gt;</span></pre><p id="76fe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">…在模态内部。通过将hash改为empty，模式关闭。</p><p id="e540" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">经过多次修改，我决定采用这种技术结构:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9758" class="mt lj it lh b gy mu mv l mw mx">&lt;div id="ourModal" class="modal"&gt;<br/>  &lt;a href="#" class="modalClose" hidden aria-hidden="true"&gt;&lt;/a&gt;<br/>  &lt;div&gt;&lt;section&gt;<br/>    &lt;a href="#" class="modalClose" hidden aria-hidden="true"&gt;&lt;/a&gt;<br/>    &lt;h2&gt;Our Modal&lt;/h2&gt;<br/>    &lt;div&gt;<br/>      &lt;p&gt;<br/>        A Sample Modal<br/>      &lt;/p&gt;<br/>    &lt;/div&gt;<br/>  &lt;/section&gt;&lt;/div&gt;<br/>&lt;!-- #ourmodal.modal --&gt;&lt;/form&gt;</span></pre><p id="1f66" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">像往常一样，尽量不要用“无用的类”来嘲笑标记，而是让语义和DOM结构来完成大部分工作。</p><p id="eb96" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">外层DIV的目的很明显，它将我们的“固定”容器设置为全屏。将<code class="fe le lf lg lh b">display:flex;</code>与<code class="fe le lf lg lh b">align-items:center;</code>和<code class="fe le lf lg lh b">justify-content:center;</code>一起使用会使内容居中，但是如果你有使用flex或center的经验，你会知道它会影响滚动。溢出:flex容器上的auto是脆弱的、不可靠的，并且经常完全损坏。因此，我们没有在外部包装器上设置flex，而是在DIV.modal中的第一个DIV标签上设置它。</p><p id="9cec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们有两个a.modalClose .这些get类，因为我们可能在结构上选择它们不一致的地方需要或想要它们。第一个是全屏关闭，这样如果你点击实际内容区域之外，它将关闭模态。第二个是为生成的内容添加一个明显的关闭按钮，以形成一个清晰的视觉点来关闭它，当屏幕太小而没有一个区域围绕实际内容时<section>。</section></p><p id="2812" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这两个锚都被设置为<code class="fe le lf lg lh b">hidden</code>和<code class="fe le lf lg lh b">aria-hidden=”true”</code>，使得非屏幕媒体UA忽略这两个元素。屏幕阅读器(大声朗读页面的软件)、盲文阅读器、搜索引擎等会假装这些锚点不存在。当键盘导航时，他们不会关注它们，他们不会试图阅读它们的内容。它们不存在于任何现代的UA中，除非我们通过用CSS改变它们的显示状态来显示它们。因此，如果我们在样式表&lt;链接&gt;上使用media="screen ",我们可以只为屏幕媒体设备打开它们。</p><p id="430b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="nj"> Side node，99%的时候你看到的&lt;链接&gt;或者&lt;样式&gt;缺少media= " "或者被设置为media="all "，你看到的是web开发中那些讨厌的3i:无知、无能、不称职。这就是为什么在外部样式表中说“screen and”的媒体查询同样是无知的垃圾。但是，在大多数使用案例中，同样的情况也适用于&lt; style &gt;或style= " "。</em></p><p id="f4b8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为DIV在语义上是中性的，并且因为我们隐藏了锚点，所以非屏幕UA(包括search)实际上将上述标记视为:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7cbb" class="mt lj it lh b gy mu mv l mw mx">&lt;h2&gt;Our Modal&lt;/h2&gt;<br/>&lt;p&gt;<br/>  A Sample Modal<br/>&lt;/p&gt;</span></pre><p id="9e58" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">仅此而已。甚至更好的替代导航将让模态链接导航到这些子部分，不需要我们花哨的视觉效果，就像任何其他正常的页面散列链接一样！这些链接甚至会出现在浏览器的历史记录中，所以“后退”也会关闭模态链接，并且/或者引导非视觉用户回到他们点击“模态”链接之前的位置。</p><p id="3ec4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，因为这些section/nav是完全限定的内容部分，所以从结构上来说，您应该以H2作为顶级部分。</p><p id="01f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这太理想了！这解决了页面模式可能产生的所有可访问性问题。</p><p id="4bfb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">记住，<strong class="kh iu"/><em class="nj">(单数)</em>是<strong class="kh iu"/>头<strong class="kh iu"> ing </strong>(单数)整个<strong class="kh iu">场地</strong>上的一切都是。就像一本书或一份报纸上每一副折页上方的标题。H2标记页面主要小节的开始，H3标记H2小节的开始。H4标志着他们前面的H3小节的开始…想猜猜H5和H6是什么意思吗？即使是低HR也意味着话题或版块的变化，<strong class="kh iu">而不是</strong>“在屏幕上划一条线”。</p><p id="24c7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这就是为什么你不愿意跳到深度5，或者用H4开始一个文档，或者其他所有那些创建和维护像tailwind和bootcrap这样的“框架”的白痴、庸医和傻瓜没有资格吹嘘他们写HTML的能力，更不用说为其他人开发工具了！</p><h2 id="5661" class="mt lj it bd lk my mz dn lo na nb dp ls kq nc nd lw ku ne nf ma ky ng nh me ni bi translated"><strong class="ak">其他问题</strong></h2><p id="14f9" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">创建模态的一个问题是，如果存在的话，主体滚动条不能被模态覆盖。当模式打开时，这会导致无意义的滚动条，或者当窗口小于模式内容时，甚至会导致多个混乱的滚动条。</p><p id="d567" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要解决这个问题，最简单的办法是用一个额外的DIV作为我们模态的同类的人造体；但是如上所述，通过溢出滚动:自动；带弯曲的螺钉<em class="nj">(或者反过来？所以增加了一个额外的内部包含DIV来解决这个问题。这样，我们也可以通过flex使我们的布局100%最小高度。</em></p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="44cc" class="mt lj it lh b gy mu mv l mw mx">&lt;div id="fauxBody"&gt;&lt;div id="fauxInner"&gt;<br/>&lt;!-- page Content here --&gt;<br/>&lt;!-- #fauxInner, #fauxBody --&gt;&lt;/div&gt;&lt;/div&gt;</span></pre><p id="693e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意我是如何将结束注释放在实际标签之前的。这避免了某些浏览器引擎中的呈现错误，在这些引擎中，同级元素之间或闭包之间的注释可以被视为内容或触发“双重呈现”错误。虽然在大多数现代浏览器中这不是问题，但这比在结束后发表评论要好得多。</p><p id="a2af" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们也可能希望对主菜单使用相同的模态技术。然而，这只能在媒体查询中完成，因此“通常”它不是模态的。因此，它的标记应该是这样的:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5eaa" class="mt lj it lh b gy mu mv l mw mx">&lt;header id="top"&gt;</span><span id="6870" class="mt lj it lh b gy nk mv l mw mx">  &lt;h1&gt;<br/>    Modal Site Demo<br/>  &lt;/h1&gt;<br/>  <br/>  &lt;div id="mainMenu"&gt;<br/>    &lt;a href="#" class="modalClose" hidden aria-hidden="true"&gt;&lt;/a&gt;<br/>    &lt;div&gt;&lt;nav&gt;<br/>      &lt;a href="#" class="modalClose" hidden aria-hidden="true"&gt;&lt;/a&gt;<br/>      &lt;ul&gt;<br/>        &lt;li&gt;&lt;a href="#submenu"&gt;Sub Menu&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li&gt;&lt;a href="#search"&gt;Search&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li&gt;&lt;a href="#login"&gt;Log In&lt;/a&gt;&lt;/li&gt;<br/>      &lt;/ul&gt;<br/>    &lt;/nav&gt;&lt;/div&gt;<br/>  &lt;!-- #mainMenu --&gt;&lt;/div&gt;<br/>  <br/>  &lt;a href="#mainMenu" class="mainMenuOpen" hidden aria-hidden="true"&gt;&lt;/a&gt;<br/>  <br/> &lt;!-- #top --&gt;&lt;/header&gt;</span></pre><p id="f44f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我将标题的id # top作为“返回顶部”链接的挂钩。外部DIV获得一个ID，这样我们的a.mainMenuOpen就可以指向它。我们使用NAV而不是SECTION，我们可以只使用UL而不是额外的包装DIV，所有模态相关的锚再次得到相同的hidden和aria-hidden="true ",以便屏幕阅读器忽略它们。</p><h2 id="18ec" class="mt lj it bd lk my mz dn lo na nb dp ls kq nc nd lw ku ne nf ma ky ng nh me ni bi translated">风格</h2><p id="bc5e" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">对于我们的屏幕媒体样式表，我们要做的第一件事是重新打开所有的锚，同时我们也可以删除默认的下划线。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4f9a" class="mt lj it lh b gy mu mv l mw mx">.modal .modalClose {<br/> display:inline; /* undo hidden */<br/> text-decoration:none;<br/>}</span></pre><p id="e603" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后我们需要放置所有与模态相关的容器，包括#fauxBody。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="65d2" class="mt lj it lh b gy mu mv l mw mx">.modal,<br/>.modal &gt; .modalClose,<br/>#fauxBody {<br/>  position:absolute;<br/>  top:0;<br/>  left:0;<br/>  width:100%;<br/>  height:100%;<br/>  overflow:auto;<br/>}</span></pre><p id="2931" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通常你会想到使用position:fixed，但这实际上会导致webkit中的滚动和定位问题。我不确定为什么这是一个问题，但由于这些都是BODY的子体，并且都是全屏大小，我们所有的内容都将放在这些容器中，position:absolute可以实现相同的功能！</p><p id="2712" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从那里，我们想击中我们的模态。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b314" class="mt lj it lh b gy mu mv l mw mx">.modal {<br/>  left:-100vw;<br/>  opacity:0;<br/>  padding:1em;<br/>  transition:opacity 0.3s, left 0s 0.3s;<br/>  background:radial-gradient(<br/>    hsla(220, 100%, 100%, 0.8) 20%,<br/>    hsla(220, 100%, 85%, 0.95) 100%<br/>  );<br/>}</span></pre><p id="9602" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为它们是width:100%和overflow:auto，要隐藏它们，我们需要做的就是将它们从屏幕左侧按视口宽度滑动。嘣，他们被藏起来了。<strong class="kh iu">不使用显示:无；或者能见度:隐藏；为了这个！！！</strong>这将阻止搜索引擎寻找内容伪装滥用能够看到这些元素的内容！</p><p id="d56a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个过渡是一个有趣的魔术，因为我们只是延迟了左边的过渡，这样我们的不透明度动画就可以显示出来了。我们消除了延迟:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d53a" class="mt lj it lh b gy mu mv l mw mx">.modal:target {<br/>  left:0;<br/>  opacity:1;<br/>  transition:opacity 0.3s, left 0s;<br/>}</span></pre><p id="6aa6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们展示的时候。有一个大的功能实现。左:0表示显示，不透明度淡入表示外观“漂亮”。</p><p id="ffdc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">带有内部DIV:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ce61" class="mt lj it lh b gy mu mv l mw mx">.modal &gt; div {<br/>  display:flex;<br/>  align-items:center;<br/>  justify-content:center;<br/>  min-height:100%;<br/>}</span></pre><p id="d41e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们只是应用flex来居中我们的部分或导航。然后:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3d95" class="mt lj it lh b gy mu mv l mw mx">.modal &gt; div &gt; section,<br/>.modal &gt; div &gt; nav {<br/>  position:relative;<br/>  overflow:hidden;<br/>  width:100%;<br/>  max-width:24em;<br/>  background:hsl(220, 100%, 95%);<br/>  border:1px solid #0484;<br/>  border-radius:0.5em;<br/>  box-shadow:0 0.25em 1em #0006;<br/>  transform:scale(0);<br/>  transition:transform 0.3s;<br/>}</span></pre><p id="3843" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">得到我们想要的任何样式。我使用了变换:缩放动画，这样当模态成为目标时，它们就会“放大”成焦点。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7d29" class="mt lj it lh b gy mu mv l mw mx">.modal:target &gt; div &gt; section,<br/>.modal:target &gt; div &gt; nav {<br/>  transform:scale(1);<br/>}</span></pre><p id="5ca8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">内在的。模态闭合</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3466" class="mt lj it lh b gy mu mv l mw mx">section .modalClose,<br/>nav .modalClose {<br/>  position:absolute;<br/>  top:0;<br/>  right:0.325em;<br/>  font-size:1.75em;<br/>  color:#C00;<br/>  transition:transform 0.3s;<br/>}</span><span id="07fd" class="mt lj it lh b gy nk mv l mw mx">section .modalClose:after,<br/>nav .modalClose:after {<br/>  content:"\1F5D9";<br/>}</span><span id="8639" class="mt lj it lh b gy nk mv l mw mx">section .modalClose:focus,<br/>section .modalClose:hover,<br/>nav .modalClose:focus,<br/>nav .modalClose:hover {<br/>  transform:scale(1.2);<br/>}</span></pre><p id="e126" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">得到UTF-8抵消X的生成内容，然后我们在我们的H2上空对其进行绝对定位。</p><p id="f3b1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从那里开始，它只是组件的正常样式。</p><p id="0c60" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">主菜单必须进入媒体查询，因此我们必须复制大部分相同的代码。这很糟糕，因为它是在同一件事情上双倍下注，但没有真正的办法解决这个问题。<em class="nj">(如果只有CSS3“空”和一般的兄弟选择器对生成的内容起作用！)</em></p><p id="2801" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，我们可以通过简单地使用生成的内容和边框来制作“汉堡包”。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f6a0" class="mt lj it lh b gy mu mv l mw mx">  .mainMenuOpen {<br/>    display:block;<br/>    padding:0.25em;<br/>    text-decoration:none;<br/>    border-radius:0.5em;<br/>    transition:transform 0.3s;<br/>  }<br/>  <br/>  .mainMenuOpen:focus,<br/>  .mainMenuOpen:hover {<br/>    transform:scale(1.2);<br/>  }<br/>  <br/>  .mainMenuOpen:before,<br/>  .mainMenuOpen:after {<br/>    content:"";<br/>    display:block;<br/>    width:1.75em;<br/>    height:0.325em;<br/>    border:solid #000A;<br/>    border-width:0.325em 0;<br/>  }<br/>  <br/>  .mainMenuOpen:after {<br/>    border-top:none;<br/>  }</span></pre><p id="179c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后我们需要瞄准它。模式关闭可见。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5352" class="mt lj it lh b gy mu mv l mw mx">  #mainMenu .modalClose {<br/>    display:inline; /* undo hidden */<br/>    text-decoration:none;<br/>  }</span></pre><p id="3745" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">与的定位相同。情态的</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5700" class="mt lj it lh b gy mu mv l mw mx">  #mainMenu,<br/>  #mainMenu &gt; .modalClose {<br/>    position:absolute;<br/>    top:0;<br/>    left:0;<br/>    width:100%;<br/>    height:100%;<br/>    overflow:auto;<br/>  }</span><span id="8c90" class="mt lj it lh b gy nk mv l mw mx">  #mainMenu {<br/>    left:-100vw;<br/>    opacity:0;<br/>    padding:1em;<br/>    transition:opacity 0.3s, left 0s 0.3s;<br/>    background:radial-gradient(<br/>      hsla(220, 100%, 100%, 0.8) 20%,<br/>      hsla(220, 100%, 85%, 0.95) 100%<br/>    );<br/>  }</span><span id="2e8b" class="mt lj it lh b gy nk mv l mw mx">  #mainMenu:target {<br/>    left:0;<br/>    opacity:1;<br/>    transition:opacity 0.3s, left 0s;<br/>  }</span></pre><p id="e7e9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">等等，等等，等等。你现在应该明白了。我们可以对菜单做的一件有趣的事情是，代替我们的H2标题，我们可以使用生成的内容添加一个假标题。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5f72" class="mt lj it lh b gy mu mv l mw mx">#mainMenu nav:before {<br/>    content:"Main Menu";<br/>    display:block;<br/>    padding:0.4em 2.8em 0.4em 0.8em;<br/>    font-size:1.25em;<br/>    background:#0482;<br/>    border-bottom:1px solid #0484;<br/>  }</span></pre><p id="4493" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">提供视觉一致性。</p><h1 id="b5a6" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">现场演示</h1><p id="acc1" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">您可以在这里观看现场直播:</p><div class="nl nm gp gr nn no"><a href="https://cutcodedown.com/for_others/medium_articles/modalSite/modalSite.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">没有JavaScript演示的模态网站</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">使用CSS3 :target属性，我们不再需要JavaScript来创建模态对话框。事实上，我们可以增强整个…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">cutcodedown.com</p></div></div></div></a></div><p id="69bf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同我所有的例子目录:<br/><a class="ae ld" href="https://cutcodedown.com/for_others/medium_articles/modalSite/" rel="noopener ugc nofollow" target="_blank">https://cutcodedown . com/for _ others/medium _ articles/modal site/</a></p><p id="6a77" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">是敞开的，容易接触到黏糊糊的东西。我在那里放了一个标记的. txt文件给那些“查看源代码”的人，还有一个完整的. rar文件。</p><p id="8921" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些都被放进了我的一个标准股票模板中，以展示它能做什么。</p><h1 id="283f" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">利弊</h1><p id="e65d" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">和往常一样，我先从问题开始。</p><h2 id="ad57" class="mt lj it bd lk my mz dn lo na nb dp ls kq nc nd lw ku ne nf ma ky ng nh me ni bi translated">不足之处</h2><ol class=""><li id="747d" class="nx ny it kh b ki mg km mh kq nz ku oa ky ob lc oc od oe of bi translated">如果你经常打开和关闭它们，它会填满浏览器历史记录。</li><li id="f7d9" class="nx ny it kh b ki og km oh kq oi ku oj ky ok lc oc od oe of bi translated">为了保持一致性，您应该严格遵循最内层DIV之外的标记。这可以被认为是“脆弱的标记”。</li><li id="c64a" class="nx ny it kh b ki og km oh kq oi ku oj ky ok lc oc od oe of bi translated">CSS中的选择器可能看起来很复杂，尤其是如果你已经接受了选择器减慢“渲染”速度的<strong class="kh iu">秃头谎言</strong>。</li><li id="fd6f" class="nx ny it kh b ki og km oh kq oi ku oj ky ok lc oc od oe of bi translated">您最终会在内容周围添加额外的标记。<em class="nj">请注意，如果你在做最小高度布局，你可能已经有了！</em></li><li id="22c8" class="nx ny it kh b ki og km oh kq oi ku oj ky ok lc oc od oe of bi translated">它依赖于某些传统浏览器中不存在的浏览器功能。尤其是IE可能会有问题。<em class="nj">但是，即使bootstrap在这一点上告诉所有版本的IE去吃屎吧，我们可能在这一点上是安全的。如果真的很重要，不要把CSS发送给IE，让他们处理普通的标记外观！</em></li></ol><h2 id="5c68" class="mt lj it bd lk my mz dn lo na nb dp ls kq nc nd lw ku ne nf ma ky ng nh me ni bi translated">优势</h2><ol class=""><li id="fdd0" class="nx ny it kh b ki mg km mh kq nz ku oa ky ob lc oc od oe of bi translated">语义、隐藏和aria-hidden的使用使页面100%满足可访问性最低要求。事实上，传统的页面导航是以这样一种方式维护的，非屏幕用户甚至不会知道我们为有视力的人提供了所有这些花哨的东西！</li><li id="4381" class="nx ny it kh b ki og km oh kq oi ku oj ky ok lc oc od oe of bi translated">不需要JavaScript。除了消除可访问性的麻烦之外，它还导致触发的动作感觉更平滑和干净。<em class="nj">不像许多JavaScript“框架”那样使用基于定时器的“计算”。为了土地，让CSS来做繁重的工作吧！</em></li><li id="1f0c" class="nx ny it kh b ki og km oh kq oi ku oj ky ok lc oc od oe of bi translated">使用一致的结构可以很容易地将现有的例子复制到新的设计中</li><li id="9acf" class="nx ny it kh b ki og km oh kq oi ku oj ky ok lc oc od oe of bi translated">多余的类保持在最低限度，从而更好地利用缓存模型。记住，说什么东西看起来像<strong class="kh iu">与你的标记无关:</strong>无论是你的标签、id还是类！<strong class="kh iu">说什么东西都是！！！</strong>你在标记中放入的表示越多——即使是作为类——页面就会越慢。<strong class="kh iu"> <em class="nj">这就是为什么via BEM等网站上的slopping类声称能神奇地让页面“更快”或“更好”,是100% A级农场新鲜草原馅饼！</em> </strong></li><li id="2893" class="nx ny it kh b ki og km oh kq oi ku oj ky ok lc oc od oe of bi translated">因为它都是CSS驱动的，所以你可以很容易地随心所欲地切换你的动画。只是玩变换、过渡和定位。</li></ol><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/218cdf5ac50da864a35e6a7e35cba35f.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*w-acXp8TwdjK4HSaRyERew.png"/></div></figure><h1 id="21f2" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">增强？<strong class="ak">增强功能！！！</strong></h1><p id="837d" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">现在，我们已经尽力避免使用JavaScript，但是这并不意味着我们不能或者不应该使用。</p><p id="6eaf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，我们可能不关心它如何填充浏览器历史。你可以把所有的。modalClose anchors说如果前一个散列是空的，但它是同一个页面，则执行<code class="fe le lf lg lh b">window.history.back()</code>而不是让anchor触发。</p><p id="e309" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">很好，<strong class="kh iu">然后</strong>你潜心研究JavaScript。但是<strong class="kh iu">只有</strong>那么。首先在没有JavaScript的情况下尽可能地让它工作。首先关注内容的正常页面加载和正常导航。</p><p id="da56" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="nj">说到JavaScript，要学会保持冷静！</em></p><p id="9541" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae ld" href="https://medium.com/@deathshadow/accessibility-101-good-client-side-javascript-should-enhance-an-already-working-page-not-be-the-bf92741d2310" rel="noopener">正如我在另一篇文章中所说的，高质量的JavaScript应该增强已经工作的页面，<strong class="kh iu">而不是</strong>成为你提供所述功能的唯一方式！</a>至少如果你稍微关心一下可用性、可访问性和简单理智的前端开发的话。这就是为什么像React和Angular这样的框架从如此高的高度上清空了他们的可访问性，你会认为这是汤姆·汉克斯在《他们自己的联盟》中的场景。使用这种脚本的人没有时间去思考当脚本在用户代理中被阻止、不可用甚至不相关时会发生什么。当你这么做的时候，你就有麻烦了。</p><h1 id="3f19" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">麻烦？来自JavaScript？不要这么说！</h1><p id="c35e" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">是的麻烦！一些行业的法律麻烦 …基本上所有的企业都在枪口下；自从碧昂斯和多米诺被拖上法庭。如果有最好的律师的高知名度的大预算的大人物可以在sloar的深处被烤，当一些流着鼻涕的助理DA或救护车追逐者来敲门时，像我们这样的普通shubs和zuul有什么机会？</p><p id="a57a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们不能像20世纪90年代浏览器大战中最糟糕的情况一样，用表示层来不断增加表示层标记。你<strong class="kh iu">必须</strong>使用正确的语义和逻辑文档结构。你<strong class="kh iu">必须</strong>记住关闭图像、关闭脚本、甚至关闭CSS会发生什么。你<strong class="kh iu">必须</strong>记住CSS有媒体目标(屏幕、打印、语音等),如果你在使用&lt;链接&gt;或&lt;样式&gt;或发送到“全部”时没有使用，可能会产生可访问性问题——甚至只是浪费带宽。</p><p id="765f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同样，这也是一场速度竞赛，如果你使用一些巨大的JS框架和半打k的定制脚本来做四到六k的CSS自己就能做的事情，那么在web开发中……/失败/甚至一些客户开始关注像lighthouse这样的工具中的“有意义的绘画”时间，臃肿缓慢的脚本和大规模的“框架”真的会让这些成为泡影。</p><p id="4a93" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">作为网络专业人士，我们需要开始沿着这些思路思考。使用这样的技术不仅可以改善用户体验，还可以避免因未能满足可访问性最低要求而受到指责。</p><h1 id="dd5a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="d05a" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">通过避免使用JavaScript并利用CSS3的特性，我们可以为非屏幕用户制作非常优雅的页面，同时仍然提供所有花哨的屏幕糖果。由于现代浏览器的特性，只需先编写语义，添加几个div，将样式表用于屏幕媒体，然后使用选择器和伪状态来触发行为，这比浪费时间编写脚本来处理这些要简单得多，也有用得多。</p><p id="905a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同样，关注点分离。如果你在不应用屏幕CSS时查看语义导航，这听起来可能很奇怪。模态——至少以这种方式实现——不是行为。这是演示…而演示是CSS的工作！</p></div></div>    
</body>
</html>