<html>
<head>
<title>Chrome Extension Tutorial: Migrating to Manifest V3 from V2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Chrome扩展教程:从V2迁移到清单V3</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/chrome-extension-tutorial-migrating-to-manifest-v3-from-v2-68a39615eae?source=collection_archive---------13-----------------------#2021-02-11">https://levelup.gitconnected.com/chrome-extension-tutorial-migrating-to-manifest-v3-from-v2-68a39615eae?source=collection_archive---------13-----------------------#2021-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5e8e49a362e64055899e78720e2c6868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EQJLQc7N2pfE4e0xeTSsA.jpeg"/></div></div></figure><p id="00ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">本文原载于</em> <a class="ae kx" href="https://blog.shahednasser.com/chrome-extension-tutorial-migrating-to-manifest-v3-from-v2/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">我的个人博客</em> </a> <em class="kw">。</em></p><p id="c6b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2020年11月，Chrome推出了Manifest V3。长期以来，扩展一直使用清单V2，所以这是一个很大的转变，尤其是V3中的新特性。</p><p id="e3ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将看到从清单V2到V3所需的步骤。我将使用以前教程的扩展(<a class="ae kx" href="https://blog.shahednasser.com/chrome-extension-tutorial-replace-images-in-any-website-with-pikachu/" rel="noopener ugc nofollow" target="_blank"> Chrome扩展教程——用皮卡丘</a>替换任何网站中的图像)和一个新的分支。如果你不熟悉它，我们建立了一个chrome扩展，用我们通过API检索的随机皮卡丘图像替换网站中的所有图像。你可以在这里查看存储库<a class="ae kx" href="https://github.com/shahednasser/pikachu-everywhere/tree/manifest-v3" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="74fe" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么要迁移到清单V3？</h1><p id="d7e8" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">正如Chrome的文档所说:</p><blockquote class="mi mj mk"><p id="9ff4" class="jy jz kw ka b kb kc kd ke kf kg kh ki ml kk kl km mm ko kp kq mn ks kt ku kv ij bi translated"><em class="iq">使用MV3的扩展将享受安全性、隐私性和性能的增强；他们也可以使用MV3采用的更现代的开放网络技术，比如服务人员和承诺。</em></p></blockquote></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="b6d0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">对manifest.json的更改</h1><h2 id="dce9" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">更改版本</h2><p id="a874" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">第一个明显的步骤是，您需要更改清单的版本。在manifest.json文件中，将其更改如下:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="cdf4" class="mo lg iq nf b gy nj nk l nl nm">{ <br/>    ..., <br/>    "manifest_version": 3, <br/>    ... <br/>}</span></pre><p id="9b4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您现在尝试将您的扩展添加到chrome中(或者如果它已经存在，则重新加载它)，您将看到不同的错误，这些错误与您仍然需要对manifest.json文件进行的更改有关。</p><h2 id="a1f9" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">主机权限</h2><p id="fc74" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在Manifest V2中，有两种方法可以从扩展中获得API或任何主机的权限:要么在<code class="fe nn no np nf b">permissions</code>数组中，要么在<code class="fe nn no np nf b">optional_permissions</code>数组中。</p><p id="33ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在清单V3中，所有主机权限现在都在一个新数组中用键<code class="fe nn no np nf b">host_permissions</code>分开。不应再将主机权限与其他权限相加。</p><p id="957e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到我们的例子，这是我们的<code class="fe nn no np nf b">permissions</code>阵列:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="6460" class="mo lg iq nf b gy nj nk l nl nm">{ <br/>   ..., <br/>   "permissions":<br/>     [ <br/>       "https://some-random-api.ml/*"<br/>     ],<br/>   ... <br/>}</span></pre><p id="55b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，它应该变成这样:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="754b" class="mo lg iq nf b gy nj nk l nl nm">{ <br/>   ..., <br/>   "host_permissions": [ <br/>      "https://some-random-api.ml/*" <br/>    ],<br/>   ...<br/>}</span></pre><p id="fe06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们只需要将密钥从<code class="fe nn no np nf b">permissions</code>改为<code class="fe nn no np nf b">host_permissions</code>。但是，如果您的扩展在<code class="fe nn no np nf b">permissions</code>中有其他值，那么您应该将它们保留在其中，并将您的主机权限转移到<code class="fe nn no np nf b">host_permissions</code>。</p><h2 id="752f" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">后台脚本</h2><p id="3086" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">Manifest V3用服务工作者替换了后台脚本。我们稍后将讨论如何进行转换，但是首先需要在manifest.json中进行转换。</p><p id="60da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的扩展中，<code class="fe nn no np nf b">background</code>对象目前看起来像这样:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="b8f6" class="mo lg iq nf b gy nj nk l nl nm">{ <br/>   ..., <br/>   "background": {<br/>     "scripts": ["assets/js/background.js"], <br/>     "persistent": false<br/>   },<br/>   ...<br/>}</span></pre><p id="f7c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要做的是将<code class="fe nn no np nf b">scripts</code>数组键改为<code class="fe nn no np nf b">service_worker</code>，现在你应该有一个服务工作者，而不是多个后台页面或脚本。所以，它应该是这样的:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="8390" class="mo lg iq nf b gy nj nk l nl nm">{ <br/>  ..., <br/>  "background": {<br/>    "service_worker": "assets/js/background.js" <br/>  },<br/>  ...<br/>}</span></pre><p id="6aba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们不再需要添加<code class="fe nn no np nf b">persistent</code>了。另外，如果<code class="fe nn no np nf b">background</code>里面有<code class="fe nn no np nf b">page</code>，那也应该改成服务人员。</p><h2 id="2fc5" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">行动</h2><p id="d968" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">以前动作是<code class="fe nn no np nf b">browser_action</code>和<code class="fe nn no np nf b">page_action</code>，现在统一成<code class="fe nn no np nf b">action</code>清单V3。这是因为随着时间的推移，它们变得越来越相似，没有必要将它们分开。</p><p id="2597" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在扩展中不使用它，但这是它应该是什么样子的一个例子:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="40fc" class="mo lg iq nf b gy nj nk l nl nm">{ <br/>   ..., <br/>   "action": {<br/>      //include everything in browser_action <br/>      //include everything in page_action<br/>   },<br/>   ... <br/>}</span></pre><p id="7191" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还需要对代码进行修改，我们稍后会谈到。</p><h2 id="8994" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">内容安全政策</h2><p id="09e5" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">同样，这在我们的扩展中没有使用，但是我们仍然需要检查它。如果您的扩展有一个内容安全策略(CSP)，那么您需要将它从一个字符串(在清单V2中的方式)更改为一个对象(在清单v3中的方式)。</p><p id="cbe0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单V3中的示例应该是这样的:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="74a5" class="mo lg iq nf b gy nj nk l nl nm">{<br/>    ...,<br/>    "content_security_policy": {<br/>  	"extension_pages": "...",<br/> 	 "sandbox": "..."<br/>     },<br/>    ...<br/>}</span></pre><h2 id="dc32" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">网络可访问的资源</h2><p id="75ab" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">您需要在manifest.json中进行的最后一项更改是将<code class="fe nn no np nf b">web_accessible_resources</code>数组更改为一个详细描述所有资源的对象。下面是V3中的一个示例:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="c144" class="mo lg iq nf b gy nj nk l nl nm">{<br/>    ...,<br/>    "web_accessible_resources": {<br/>    	"resources": [<br/>           //the array of resources you had before<br/>        ]<br/>    },<br/>    ...<br/>}</span></pre><p id="2c39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该对象还将在未来版本中支持键<code class="fe nn no np nf b">matches</code>(URL数组)<code class="fe nn no np nf b">extension_ids</code>(键数组)和<code class="fe nn no np nf b">use_dynamic_url</code>(布尔)。</p><h2 id="a717" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">添加扩展</h2><p id="2961" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">现在，如果你在浏览器中打开chrome://extensions并添加或重新加载你的扩展，它将成功地更改为清单V3扩展。然而，在我们的例子中，它会在扩展框中向您显示一个错误按钮，当您单击它时，它会显示“服务人员注册失败”这是因为我们的代码中还有更多工作要做。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="1542" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从后台脚本到服务人员</h1><p id="e526" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">一、什么是服务工作者，和后台脚本有什么区别？</p><p id="d653" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后台脚本在几乎所有的扩展中都是必不可少的。它们允许你做一些动作或者执行代码，而不需要用户打开某个页面或者做一些事情。这可以用来发送通知，管理与内容脚本的通信，等等。后台脚本通常总是在后台运行。</p><p id="4f90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务人员在需要时被处决。与后台脚本不同，它们并不总是在后台运行。在顶层，服务工作者应该注册一些事件的侦听器，以便允许它们在以后被执行。</p><p id="98d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从后台脚本到服务人员的转换取决于您在扩展中的代码。一些扩展可能需要大量的返工，而另一些则不需要这么多。</p><p id="2737" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您需要做的第一步是将以前是后台脚本或页面的文件移动到扩展的根目录。这实际上是为什么在我们的扩展中，我们收到了服务工作者注册失败的错误声明。我们的后台脚本的路径是相对于我们的扩展的根的<code class="fe nn no np nf b">js/assets/background.js</code>。</p><p id="c88d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的情况类似，将您的后台脚本移动到您的扩展的根目录，然后在您的清单中更改<code class="fe nn no np nf b">service_worker</code>的值以反映更改:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="98d6" class="mo lg iq nf b gy nj nk l nl nm">{<br/>    ...,<br/>    "background": {<br/>    	"service_worker": "background.js"<br/>    },<br/>    ...<br/>}</span></pre><p id="16b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果重新加载扩展，服务人员应该可以成功注册。</p><p id="cc59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们看看代码。在我们的扩展中，我们的后台脚本如下所示:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="a87e" class="mo lg iq nf b gy nj nk l nl nm">chrome.runtime.onMessage.addListener(function(message, sender, senderResponse){<br/>  if(message.msg === "image"){<br/>    fetch('https://some-random-api.ml/img/pikachu')<br/>          .then(response =&gt; response.text())<br/>          .then(data =&gt; {<br/>            let dataObj = JSON.parse(data);<br/>            senderResponse({data: dataObj, index: message.index});<br/>          })<br/>          .catch(error =&gt; console.log("error", error))<br/>      return true;  // Will respond asynchronously.<br/>  }<br/>});</span></pre><p id="4ec0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，我们的后台脚本使用<code class="fe nn no np nf b">chrome.runtime.onMessage.addListener</code>监听一条消息，如果这条消息是请求图像，它将向API发送请求，然后将数据返回给我们的内容脚本。</p><p id="ad42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的后台脚本实际上不需要任何额外的改变。背后的原因是，现在作为服务工作者的后台脚本只是注册一个事件监听器，并在事件发生时执行代码，这正是服务工作者应该做的。</p><p id="be82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，并不是所有的扩展都是这样的，因为有不同的用例。以下是您需要在后台脚本中检查和修改的内容:</p><h2 id="4faf" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">全局变量</h2><p id="0b92" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如上所述，以前后台脚本总是在后台运行。意思是如果我有下面的代码:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="72b0" class="mo lg iq nf b gy nj nk l nl nm">let count = 0;<br/><br/>chrome.runtime.onMessage.addListener( (message) =&gt; {<br/>	count++;<br/>    console.log(count);<br/>});</span></pre><p id="439f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当后台脚本收到一条消息，计数就会增加。所以，一开始，它会是0，然后是1，然后是2，等等。</p><p id="93b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在服务行业，这种方法不再适用。服务人员将只在需要时运行，并在完成工作后终止。因此，上面的代码将总是打印在控制台“1”中。</p><p id="f24c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">改变这一点取决于您的用例。在上面的例子中，计数可以在后台脚本和内容脚本之间来回传递，以获得所需的结果。更好的方法是使用Chrome的存储API。</p><p id="d14e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用它，代码看起来会像这样:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="0826" class="mo lg iq nf b gy nj nk l nl nm">chrome.runtime.onMessage.addListener ( (message) =&gt; {<br/>	chrome.storage.local.get(["count"], (result) =&gt; {<br/>        const count = result.count ? result.count++ : 1;<br/>    	chrome.storage.local.set({count});<br/>        console.log(count);<br/>    });<br/>});</span></pre><p id="a29c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，这取决于您的代码，所以请确保根据最适合您的方式进行更改。</p><h2 id="afcf" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">计时器和闹钟</h2><p id="badf" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">计时器在后台脚本中使用没有问题，因为它们总是在后台运行。然而，这对服务人员不起作用。你应该用<a class="ae kx" href="https://developer.chrome.com/docs/extensions/reference/alarms/" rel="noopener ugc nofollow" target="_blank">警报API </a>替换所有计时器。</p><h2 id="af0f" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">访问DOM</h2><p id="0d7e" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">服务人员无权访问windows或DOM。如果你的扩展需要，你可以使用像<a class="ae kx" href="https://github.com/jsdom/jsdom" rel="noopener ugc nofollow" target="_blank"> jsdom </a>这样的库或者使用<a class="ae kx" href="https://developer.chrome.com/docs/extensions/reference/windows#method-create" rel="noopener ugc nofollow" target="_blank"> chrome.windows.create </a>和<a class="ae kx" href="https://developer.chrome.com/docs/extensions/reference/tabs#method-create" rel="noopener ugc nofollow" target="_blank"> chrome.tabs.create </a>。这要看你的使用情况，什么适合你的需求。</p><p id="e207" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的后台脚本记录音频或视频，这也是需要的，因为这在服务人员中是不可能的。</p><h2 id="6c51" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">创建画布</h2><p id="0d40" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果您的后台脚本先前创建了canvas，您仍然可以使用<a class="ae kx" href="https://html.spec.whatwg.org/multipage/canvas.html#the-offscreencanvas-interface" rel="noopener ugc nofollow" target="_blank"> OffscreenCanvas </a> API来创建。你要做的就是把<code class="fe nn no np nf b">document</code>换成<code class="fe nn no np nf b">OffscreenCanvas</code>。</p><p id="11f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果这是您的代码:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="f35d" class="mo lg iq nf b gy nj nk l nl nm">let canvas = document.createElement('canvas');</span></pre><p id="b678" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么你应该把它改成:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="77e6" class="mo lg iq nf b gy nj nk l nl nm">let canvas = new OffscreenCanvas(width, height);</span></pre><h2 id="d351" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">检查你的分机</h2><p id="1df7" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在您完成了需要将您的后台脚本更改为服务人员的更改之后，请在浏览器中重新加载您的扩展以查看它是否正常工作。</p><p id="d58c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，<code class="fe nn no np nf b">background.js</code>除了移动到根之外不需要任何改变。所以，如果你重新加载扩展并进入一个页面，你会发现图片已经被皮卡丘图片成功替换。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/c35e443434125e3a63b2d8222423e598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zSEPuszg17-Gq9Ss.png"/></div></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="97ef" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">动作API</h1><p id="0cb7" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如前所述，<code class="fe nn no np nf b">browser_action</code>和<code class="fe nn no np nf b">page_action</code>现在合并为<code class="fe nn no np nf b">action</code>。同样的道理也应该应用在你的代码中。如果您使用如下所示的<code class="fe nn no np nf b">browserAction</code>或<code class="fe nn no np nf b">pageAction</code>:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="fa6c" class="mo lg iq nf b gy nj nk l nl nm">chrome.browserAction.onClicked.addListener(tab =&gt; { ... }); chrome.pageAction.onClicked.addListener(tab =&gt; { ... });</span></pre><p id="119b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它应该更改为使用新的操作API，如下所示:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="99da" class="mo lg iq nf b gy nj nk l nl nm">chrome.action.onClicked.addListener(tab =&gt; { ... });</span></pre><p id="aa30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，确保用<code class="fe nn no np nf b">action</code>替换所有的<code class="fe nn no np nf b">browserAction</code>和<code class="fe nn no np nf b">pageAction</code>用法。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="8776" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">执行脚本</h1><p id="89f2" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果您的代码使用executeScript的<code class="fe nn no np nf b">code</code>属性执行任意字符串，您有两种方法可以改变它。另外，不要用<code class="fe nn no np nf b">chrome.tabs.executeScript</code>，你需要用<code class="fe nn no np nf b">scripting</code>代替<code class="fe nn no np nf b">tabs</code>，这样它就是<code class="fe nn no np nf b">chrome.scripting.executeScript</code>。</p><h2 id="a081" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">将代码移动到新文件中</h2><p id="edaa" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">您需要将<code class="fe nn no np nf b">code</code>的值移动到一个新文件中，并使用executeScript的<code class="fe nn no np nf b">file</code>属性。</p><p id="9688" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果您的代码如下所示:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="e2f3" class="mo lg iq nf b gy nj nk l nl nm">chrome.tabs.executeScript({<br/>    code: alert("Hello, World!")<br/>});</span></pre><p id="37e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你应该将<code class="fe nn no np nf b">code</code>的值，这里是<code class="fe nn no np nf b">alert("Hello, World!")</code>移动到一个新文件中(姑且称之为<code class="fe nn no np nf b">hello-world.js</code>):</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="ead7" class="mo lg iq nf b gy nj nk l nl nm">alert("Hello, World!");</span></pre><p id="b9d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后将前面的代码更改为以下内容:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="bca2" class="mo lg iq nf b gy nj nk l nl nm">chrome.scripting.executeScript({<br/>    file: 'hello-world.js'<br/>});</span></pre><h2 id="a447" class="mo lg iq bd lh mp mq dn ll mr ms dp lp kj mt mu lt kn mv mw lx kr mx my mb mz bi translated">将代码放在一个函数中</h2><p id="e271" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果您的代码可以放在一个函数中，就像示例代码一样，那么只需将它移动到同一个文件中的一个函数中，然后将<code class="fe nn no np nf b">executeScripts</code>的<code class="fe nn no np nf b">function</code>属性赋给您创建的函数:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="69c4" class="mo lg iq nf b gy nj nk l nl nm">function greeting() {<br/>    alert("Hello, World!");<br/>}<br/><br/>chrome.scripting.executeScript({<br/>    function: greeting<br/>});</span></pre></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="9769" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">附加工作</h1><p id="0b47" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">这里有一个列表，列出了您需要在代码中查找的其他更改和内容:</p><ol class=""><li id="721c" class="nr ns iq ka b kb kc kf kg kj nt kn nu kr nv kv nw nx ny nz bi translated">如果您的扩展使用webRequest API，这通常用于强制安装扩展的企业设置中，您需要用<a class="ae kx" href="https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/" rel="noopener ugc nofollow" target="_blank">declarativeNetRequest</a>API替换它。</li><li id="9f17" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated">如果您在内容脚本中提出任何CORS请求，请确保将它们转移到您的服务人员。</li><li id="503f" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated">不再允许远程承载的代码。您需要找到另一种方法来执行远程托管的代码。Chrome的文档建议要么使用<strong class="ka ir">配置驱动的特性和逻辑</strong>，这意味着您检索一个包含所需配置的JSON文件，并在本地缓存它以备后用；要么使用一个远程服务<strong class="ka ir">将逻辑外部化</strong>，这意味着您必须将您的应用程序逻辑从您的扩展移动到远程web服务。</li><li id="a705" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated">查看<a class="ae kx" href="https://developer.chrome.com/docs/extensions/reference/" rel="noopener ugc nofollow" target="_blank"> API参考</a>以了解您可能正在使用的任何不推荐使用的API或方法。</li></ol></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="ffdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于2021年2月11日https://blog.shahednasser.com</em><em class="kw">的</em> <a class="ae kx" href="https://blog.shahednasser.com/chrome-extension-tutorial-migrating-to-manifest-v3-from-v2/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">。</em></a></p></div></div>    
</body>
</html>