<html>
<head>
<title>“The CSS Universal Selector Is Slow And Should Be Avoided” — Yet Another Lie!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“CSS通用选择器很慢，应该避免”——又一个谎言！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-css-universal-selector-is-slow-and-should-be-avoided-yet-another-lie-eb4d15f4c320?source=collection_archive---------3-----------------------#2020-10-19">https://levelup.gitconnected.com/the-css-universal-selector-is-slow-and-should-be-avoided-yet-another-lie-eb4d15f4c320?source=collection_archive---------3-----------------------#2020-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/53a35d6209b4c401e10d7809783138ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omEs7inj4DmLRZWF1veHqA.png"/></div></div></figure><p id="82b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总的来说，web开发在诚实和理性思考方面存在真正的问题。有很多学究气十足的废话被宣传为良好实践，完全基于制造的“真理”，而这些“真理”不以任何方式、形式或形式基于现实。</p><p id="75c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其中一个赤裸裸的谎言是认为“万能选择器”——一个孤独的星号——缓慢、混乱、难以理解，我甚至看到一些人称之为彻头彻尾的邪恶。坦率地说，真是一派胡言。<em class="kz">事实上，我有更强硬的措辞，但我在努力表现。</em></p><p id="4073" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近把这个加到了我的重置中:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d4a9" class="lj lk it lf b gy ll lm l ln lo">*, *:after, *:before { box-sizing:border-box; }</span></pre><p id="3941" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…因为我总是发现“宽度内填充”模式更有意义，即使它是IE的“错误行为”。<em class="kz">这不是我第一次在某些事情上与W3C意见相左。</em></p><p id="4a2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，几乎立刻就有十几个不同的开发人员失去了他们愤怒的头脑，尖叫着“不要这样使用选择器，它很慢而且令人困惑！”</p><p id="f0b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像其他类似的疯狂荒谬的说法一样，比如“<a class="ae lp" rel="noopener ugc nofollow" target="_blank" href="/css-selectors-combinators-are-slow-classes-are-fast-theyre-lying-to-you-827ff7d15203">标签选择器和组合器很慢，对所有东西都抛出类来代替</a>”我怀疑原因是外行人在把听起来很好的谬论当作真理时常见的那种精神故障。正如我在之前的一篇文章中所写的，<a class="ae lp" href="https://deathshadow.medium.com/stop-turning-avoid-because-or-when-appropriate-into-never-use-the-alternative-fa42e72d02d2" rel="noopener">人们经常把“避免X以防Y”神奇地转化为“永远不要使用X！！!"</a>。</p><p id="9280" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来过一遍它是什么，为什么人们认为它不好，为什么那个思维过程是错误的，然后用一些测试来证明它。</p><h1 id="924b" class="lq lk it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">那么什么是万能选择器呢？</h1><p id="fedf" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">在CSS中，只是用一个星号来表示“全部”。就像您在终端级别使用文件名一样。例如:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="24a7" class="lj lk it lf b gy ll lm l ln lo">* { color:red; }</span></pre><p id="b6e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">会使所有HTML元素变成红色。它也可以用作子选择器:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="a064" class="lj lk it lf b gy ll lm l ln lo">main &gt; * { flex:1 0 auto; }</span></pre><p id="f84a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，<code class="fe ms mt mu lf b">&lt;main&gt;</code>的所有直接子代(<em class="kz">在CSS中的作用是什么)</em>将伸缩增长，而不是伸缩收缩，并自动确定它们的最佳宽度。</p><p id="4d0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就这样，就这样。这就是计算机文件系统中所谓的“通配符”。</p><h1 id="ea97" class="lq lk it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">为什么人们会认为这是错的？</h1><p id="0bc8" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">人们对它的看法似乎是，既然选择器适用于所有元素，那么它适用于所有东西，不管它是否被使用。应用于所有事情<strong class="kd iu">必须更慢</strong>，不是吗？有道理，对吧？</p><h1 id="f416" class="lq lk it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">这个假设有什么问题吗？</h1><p id="b56f" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">另一种方法是在需要的地方明确地陈述它。这涉及到编写更多的代码，经常在所有地方重复自己，并且需要更多的逻辑来说“这个特定的东西需要它”。</p><p id="fdbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">什么更容易？不经过测试就应用于所有东西，或者必须经过比较/测试——反正在CSS应用阶段就要这样做——在逐案的基础上实际确定是否应该应用该值？比较比“总是做”花费更多的时间。</p><p id="f5c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我把这种有缺陷的想法比作人们如何认为从气球或火箭底部出来的空气是推动它前进的东西，而事实上它并没有推动任何实际推进的东西。<em class="kz">被困在里面的膨胀空气向另一个方向推动它前进。</em></p><p id="b92e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也可以用兄弟和子组合子来限制它要寻找的东西。例如，如果我们有一个部分，我们知道H2之后的所有内容都需要顶部填充:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="be42" class="lj lk it lf b gy ll lm l ln lo">h2 ~ * { padding-top:1.5em; }</span></pre><p id="cb33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个简单的直接子赋值，我们已经限制了它的搜索范围，所以它没有理由比在H2之后的所有东西上添加类慢，或者甚至说明可能在那里的标签，因此:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="40ed" class="lj lk it lf b gy ll lm l ln lo">h2 ~ p,<br/>h2 ~ ul,<br/>h2 ~ ol,<br/>h2 ~ table,<br/>h2 ~ footer { padding-top:1.5em; }</span></pre><p id="7f79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">如果有什么不同的话，我们可能会更快</em><strong class="kd iu"><em class="kz"/></strong><em class="kz">因为它的代码更少，规则更少！</em></p><h1 id="38a4" class="lq lk it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">证明一下！</h1><p id="e8d9" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">就像人们常说的，要么拿出来，要么闭嘴。我生成了两个HTML文件，包含5个重复500次的“lorem ipsum”段落。在其中一个示例中，我们将使用通用选择器来重置边距、填充，并将框大小设置为边框。在另一种方法中，我们可以通过名称手动定位所有适当的元素。在这两个例子中，我们将比较<code class="fe ms mt mu lf b">p:nth-of-type</code>和<code class="fe ms mt mu lf b">h1 + *:nth-of-type</code>，这将有助于复杂组合子的“停滞”。</p><p id="d374" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CSS将在标记中内联，以消除握手这一可能的原因；测试将在一个隔离的VPS上运行，我只是为了测试，没有任何其他东西在上面运行；评估将使用谷歌灯塔和Chrome的性能工具来完成。</p><p id="5cd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在这里抓取我的测试文件:<br/><a class="ae lp" href="https://cutcodedown.com/for_others/medium_articles/univeralSelector/" rel="noopener ugc nofollow" target="_blank">https://cutcodedown . com/for _ others/medium _ articles/universal selector/</a></p><p id="0433" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Lighthouse中的两个测试几乎没有区别。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/626ff77bbbadece166a9096e0c2ee061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SIGVXvGtEYneNDUMgXB1Q.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/e03bf9f3c29a7e17cea998216ea74617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ShboWE065MzuCKZ83zpURg.png"/></div></div></figure><p id="b48a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两者之间唯一真正的区别是，每三次测试运行中有两次通用版没有显示阻塞时间，但偶尔会显示0.9秒的LCP，而在每次运行中，“普通”版显示40毫秒的阻塞时间，但其他数字100%一致。鉴于Lighthouse评估中缺乏粒度，这在我认为的误差范围之内。</p><p id="7b8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑到Lighthouse的想法，性能图表让我感到惊讶。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/c76cf47d3db122eb918d5601c9e59166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djuLMiOrArIUidZSvWsdzg.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/fa228beda6e37d0b53c36bbd7539b406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DnIcA3Wqg1wyop3CuwxXJA.png"/></div></div></figure><p id="b71f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">渲染差异很大，在多次运行中，这些值似乎是一致的。通用选择器版本始终比普通版本快40毫秒，这可能与导致普通版本“阻塞”的原因有关。在这种情况下，显而易见，相同布局的通用选择器方法实际上更快。</p><p id="50c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，即使我们把这当成福音，在一个2500段273k的文档上使用复杂的选择器和组合器，差别也只有区区40毫秒。即使把它反过来，这个数字也是如此微不足道，以至于不要紧！</p><p id="4dd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">证明我对索赔的想法…一揽子申请应该比具体案件更快更容易。</p><p id="0c88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了好玩，我添加了第三个测试，使用derpy的“让我们把类扔向一切”方法，只是为了嘲笑那些大嘴巴。我不会在灯塔报告上浪费时间，就说0.8变成了0.9吧。性能图:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/0b020f2192d053906cb43c7d3d883c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NeMX3FyC2lQBqHXObxt9gw.png"/></div></div></figure><p id="fd3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…告诉我们所有我们需要知道的关于童话般的断言的事情，即在任何事情上抛出类都神奇地比仅仅使用选择器和组合子更快、更干净或更好。只是进一步强化了我在上一篇文章中所说的内容！<em class="kz">还有为什么我觉得所有前端框架都是垃圾，BEM之类的东西都是废话。</em></p><p id="d406" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">见鬼，它失败得如此严重，你几乎会认为它是30k多代码或什么的。大提示，如果有人告诉你更多的HTML会让你的页面“更快”或“更容易维护”，他们可能会在风中拍打他们的屁股。</p><h1 id="875e" class="lq lk it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="3cb9" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">我怀疑这些关于通用选择器“邪恶”的说法来自业内的一些“大腕”，他们在背后大谈特谈——<em class="kz">，我可能甚至知道是谁——</em>，每个人都只是盲目地鹦鹉学舌，没有核实，甚至没有认真思考。</p><p id="e2be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有证据支持通用选择器在某种程度上“不好”的说法，所以如果你有一个有意义的使用案例…你知道吗？去使用它吧。</p></div></div>    
</body>
</html>