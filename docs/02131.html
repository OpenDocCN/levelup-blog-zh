<html>
<head>
<title>The Event Loop and Call Stack in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的事件循环和调用堆栈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-event-loop-and-call-stack-in-javascript-b946181b9fbe?source=collection_archive---------10-----------------------#2020-02-20">https://levelup.gitconnected.com/the-event-loop-and-call-stack-in-javascript-b946181b9fbe?source=collection_archive---------10-----------------------#2020-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bf4ff6fa4678fd151611273a015a36c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UzyFFo7eG_WbY7bgj7GlxA.png"/></div></div></figure><p id="fe06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的上一篇文章介绍了Node.js中的包、缓冲区和流之后，我想研究另一个幕后概念。在这篇文章中，我们将介绍JavaScript函数执行的一些方面，包括事件循环和调用堆栈。</p><p id="afb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，重要的是要记住JS是单线程的，只有一个调用栈。但是什么是线呢？嗯，一个进程——或者一个被指定了运行的内存和资源的程序——包含线程。线程是组成进程的更小的任务或指令。这些进程可以是单线程的，也可以是多线程的。</p><p id="c3f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">多线程是指多个线程共享允许并发执行的单个进程的资源。而对于单线程，一次处理一个命令。这两种系统各有利弊，但在这种情况下，我们可以只关注JS利用单线程的事实。</p><p id="034e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经对线程和进程有了一个大致的了解，让我们更深入地了解后函数执行的实质内容！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4dc0" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">堆和调用堆栈</h1><p id="9652" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在我们进入调用堆栈之前，让我们简单地看一下堆。简而言之，堆是动态存储的内存分配。堆的内存分配并不真正遵循任何特定的顺序，内存可以在任何时候被释放。</p><p id="7561" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，调用堆栈遵循特定的顺序。它由堆栈框架组成，每个框架代表一个挂起的子例程调用。堆栈帧是后进先出(LIFO)的。所以当函数被调用时，最近加入堆栈的函数首先被执行，然后从堆栈中移除。</p><p id="ea07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下面的例子中，你可以看到即使<code class="fe mj mk ml mm b">main</code>已经在堆栈中，最后添加到堆栈中的<code class="fe mj mk ml mm b">second</code>函数在<code class="fe mj mk ml mm b">first</code>函数之前执行，最后是<code class="fe mj mk ml mm b">main</code>。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/621e34f98ee058a2b8824e299c20c0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ryPdDzB_jghiVi2e.png"/></div></div></figure><p id="c016" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">堆栈溢出是当一个程序(或一系列程序)试图使用比调用堆栈分配的空间更多的空间时导致的错误。这通常是由递归函数引起的，你会看到错误<code class="fe mj mk ml mm b">Maximum call stack size exceeded</code>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9808" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">浏览器提供的Web APIs和队列</h1><p id="1eef" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">正在执行的一些方法可能属于Web API——由浏览器提供给我们。这样的例子有<code class="fe mj mk ml mm b">setTimeout()</code>、用户发起的事件、DOM事件以及ajax/fetch请求之类的东西。</p><p id="5106" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过Web API执行的代码不会被推送到堆栈上，而是被添加到任务/回调队列中。与调用堆栈的LIFO顺序不同，队列是先进先出的。添加到队列中的第一个项目也是第一个被删除的项目。</p><p id="b572" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这给了我们并发的感觉，并有助于防止阻塞——即使是单线程。</p><p id="625a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然，我们可以更深入地研究堆、调用堆栈和队列，但这应该是掌握事件循环的足够的介绍性材料。我们基本上已经有了所有的球员，现在我们只需要看看他们是如何一起工作的！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3730" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">事件循环</h1><p id="d780" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">TL；dr是事件循环通过检查调用堆栈并以LIFO顺序执行堆栈帧直到调用堆栈为空来处理实现。但是正如我们之前提到的，还有Web API将事情推到任务队列中。这些函数被推迟到队列中，直到堆栈清空，然后队列中的动作被推入堆栈并执行。</p><p id="3313" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">调用堆栈被赋予优先级，并且堆栈中的每个帧在队列中的内容被添加到堆栈之前被处理完成。尽管我们不必等待队列中的任务在被推送到堆栈时运行。这些类型的事件由浏览器处理，并在完成后添加到队列中。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/76c690de2dd2c94d8b0582d0b1770824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BA2YTtumfdaxK-8VMWuDg.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="64c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">综上所述，JavaScript事件循环的任务是维护堆栈和处理代码的执行。事件循环检查调用堆栈，如果调用堆栈为空，则查看队列。如果队列中有任何任务，事件循环将获取第一个任务，并将其推送到堆栈中运行。</p><p id="9955" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我试图保持不同领域的简洁，但如果有一个特定的部分是感兴趣的，我强烈建议更深入地查看它。更好地了解代码运行时后台到底发生了什么不会有什么坏处！</p><p id="33d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还想插入几个月前我第一次研究事件循环时使用的第一批资源之一，那就是菲利普·罗伯茨"<a class="ae mt" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">究竟什么是事件循环？</a>“JSConf EU talk。它包括许多有用的图表和很好的解释。它甚至不到30分钟长，所以我强烈建议检查一下！</p></div></div>    
</body>
</html>