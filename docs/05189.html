<html>
<head>
<title>8 Tips to Master Web Control with Selenium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Selenium掌握Web控件的8个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/8-tips-to-master-web-control-with-selenium-ab120004753a?source=collection_archive---------13-----------------------#2020-08-10">https://levelup.gitconnected.com/8-tips-to-master-web-control-with-selenium-ab120004753a?source=collection_archive---------13-----------------------#2020-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c4e1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">根据这些提示，从零到英雄！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f4bd383cf2b90f03bede1b9205d4ecca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1FQdXZTzejbSbVcz"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@jeroenbosch?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">耶鲁安博世</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="b4ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网页抓取；是善还是恶？嗯，它并不完全属于任何一个阵营。它可用于自动收集随时可用和可访问的数据，或由第三方存储的关于您的数据。另一方面，它可能会被滥用，每小时向服务器发送数千个请求，或者访问付费墙后面的内容。关于网络抓取有一点是肯定的；它确实很有趣！</p><p id="c11f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，数据所有者不喜欢它。一些网站有检测算法，寻找自动机器人和阻止相关的IP地址。避免检测是Web抓取的一部分，但是我在我的提示中并不关注这方面(提示1除外！).使用VPN、使用随机网络驱动程序、使用随机暂停、在屏幕上执行随机点击和使用<code class="fe ls lt lu lv b">action.move_to(element).perform</code>来隐藏你的IP地址，这些都是试图欺骗这些算法的技术。但是我认为如果你需要在你的脚本中使用这些技术，你可能已经越界了。记得让它负责。</p><h1 id="76b9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">1.拒绝访问</h1><p id="e178" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在遇到一个将页面源代码返回为<code class="fe ls lt lu lv b">&lt;html&gt;&lt;head&gt;&lt;title&gt;Access Denied&lt;/title&gt;&lt;/head&gt;</code>的网站之前，我使用selenium进行了多个web应用项目，没有出现任何问题。我发现我们通常可以通过在最初实例化web驱动时添加一个选项来解决这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用户代理已启用</figcaption></figure><p id="1318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户代理选项添加了一个请求头，允许服务器将请求识别为实际用户(而不是机器人)。我现在在我所有的web项目中都包含了这个选项。</p><h1 id="c16a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">2.杀死饼干</h1><p id="7dd8" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当在一个新项目中测试我的selenium命令时，我发现以前的驱动程序实例有时会在系统上徘徊。所以我现在总是在我的超级类建立一个新的驱动时删除所有存储的cookies。</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="cc40" class="mz lx iq lv b gy na nb l nc nd">self.driver.delete_all_cookies()</span></pre><h1 id="7c25" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">3.等等…</h1><p id="eb56" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">有很多方法可以让webdriver等待页面加载。函数<code class="fe ls lt lu lv b">WebDriverWait().until()</code>可以传递一些有用的等待命令，如<code class="fe ls lt lu lv b">presence_of_element_located</code>或<code class="fe ls lt lu lv b">element_to_be_clickable</code>。然而，我不需要在我的用例中使用这些。相反，我做的是在实例化webdriver时插入这行代码:</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="946e" class="mz lx iq lv b gy na nb l nc nd">self.driver.implicitly_wait(10)</span></pre><p id="b54f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果selenium找不到任何DOM搜索，这个<code class="fe ls lt lu lv b">implicitly_wait</code>函数允许驱动程序在设定的时间内继续尝试搜索。最初我以为这个等待函数会像<code class="fe ls lt lu lv b">time.sleep()</code>一样被使用，并被插入到驱动程序遇到麻烦的代码中的任何地方，但实际上它只需要声明一次，然后总是被用于每个DOM搜索。</p><h1 id="8af3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">4.保持整洁</h1><p id="50c3" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在删除cookies之后，我的超类总是包含这个简单的方法:</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="70d5" class="mz lx iq lv b gy na nb l nc nd">def kill(self):<br/>    self.driver.quit()</span></pre><p id="3896" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别是在测试阶段，很容易同时打开多个chrome服务，调用这个方法可以正确关闭它们。</p><h1 id="ed3f" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">5.什么时候。clear()不起作用</h1><p id="9d25" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在填写输入表单时，我们通常需要去掉文本字段中已经存在的默认值。通常我们会使用<code class="fe ls lt lu lv b">.clear()</code>函数来清空字段。但是我最近遇到了一个案例，这个方法不起作用。我一直在开发一个网络应用程序，我的家人可以选择他们在未来一周想吃的饭菜，一旦选择了一个python脚本，就会将所有的食材添加到我们的在线乐购篮子中，以便送货上门。但是当选择每个项目的数量时，<code class="fe ls lt lu lv b">.clear()</code>功能并没有去掉默认值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ffc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过导入<code class="fe ls lt lu lv b">Keys</code>，我们可以通过selenium发送几个非字母数字键输入。这些包括F键，控制，转移，删除，空间，退格，返回，退出以及许多其他键。在这个例子中，我必须点击文本字段并发送<code class="fe ls lt lu lv b">BACKSPACE</code>键。(如果有知情者能给我留言，解释为什么<code class="fe ls lt lu lv b">.clear()</code>在这种情况下不起作用，我会很高兴。据我所知，没有隐藏的<code class="fe ls lt lu lv b">div</code>或任何类似的东西，有一些javascript比动画输入框自动对焦)</p><h1 id="766a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">6.搜索元素</h1><p id="0e6a" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">使用Selenium导航web的基础是搜索DOM来定位页面上的特定元素(比如按钮和文本字段)。为了做到这一点，Selenium为我们提供了几种方法，我在这里列出了我最喜欢的方法:</p><ol class=""><li id="6f04" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">find_element_by_id</code>:如果您正在寻找的元素有一个ID，使用这个函数，因为ID通常是DOM中的一个惟一属性，所以它应该返回您期望的元素。</li><li id="bd5a" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">find_element_by_class_name</code>、<code class="fe ls lt lu lv b">find_element_by_name</code>、<code class="fe ls lt lu lv b">find_element_by_tag_name</code>、<code class="fe ls lt lu lv b">find_element_by_link_text</code>都有助于确定你想要互动的元素。所有这些方法都有两种形式；这里列出的都是返回搜索的第一个实例的<code class="fe ls lt lu lv b">find_element_by</code>，但是所有这些方法都以<code class="fe ls lt lu lv b">find_elements_by</code>的形式出现，返回匹配搜索的元素列表。这两种形式都是有用的工具时，网页抓取。</li><li id="fe1b" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">find_element_by_css_selector</code>:如果元素没有唯一属性，这是一个有用的定位方法。我用它将类名串在一起，以找到正确的元素。例如<code class="fe ls lt lu lv b">button.pull-right.btn.md-btn.ng-isolate-scope</code></li><li id="ef8f" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">find_element_by_xpath</code> : xpath经常被过度使用，我看到很多人使用完整路径(我相信这是因为路径可以直接从chrome中复制，方法是右键单击inspect面板上你想要的元素，然后选择‘复制’&gt;‘复制完整xPath’)。但是如果页面有任何微小的改变，比如在<code class="fe ls lt lu lv b">div</code>中添加一个副标题，就会导致xPath搜索无效。我们应该使用相对路径来避免这个问题。当元素有唯一属性(不是ID或名称)时，我使用这个定位器，例如<code class="fe ls lt lu lv b">find_element_by_xpath(“//a[@data-target=’#modal001']”)</code></li></ol><h1 id="ee76" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">7.执行Javascript</h1><p id="9f6d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">通过允许selenium执行Javascript语句，还有另一个执行DOM搜索和其他操作的选项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用Javascript搜索DOM</figcaption></figure><p id="df1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个方法来自我的美食购物app。它的目的是快速检查我想要添加到购物篮中的商品是否已经存在。在第2行我们使用了方法<code class="fe ls lt lu lv b">execute_script</code>，然后在javascript中我们使用了<code class="fe ls lt lu lv b">return</code>关键字来捕捉搜索的内容。这不是执行搜索的最佳方式，它只是另一条路线的示例。</p><h1 id="d071" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">8.从下拉列表中选择选项</h1><p id="d694" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">有时，您需要能够从下拉菜单中选择正确的值，以便获得一些数据或完成登录。以下是TSB银行登录网上银行的方法。这个例子用代码展示了本文中的所有技巧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/99422d939d23106dde0e60e3d8482fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pl5A1k7GW4n8C8nwOR2-rA.png"/></div></div></figure><ul class=""><li id="824a" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nt nk nl nm bi translated"><code class="fe ls lt lu lv b">__init__()</code>方法(第6–13行)使用用户代理参数、<code class="fe ls lt lu lv b">.implicity_wait()</code>函数和<code class="fe ls lt lu lv b">.delete_all_cookies()</code>函数设置我们的webdriver。</li><li id="b445" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nt nk nl nm bi translated">在我们的<code class="fe ls lt lu lv b">complete_login()</code>方法中，我们首先输入用户名并点击“继续”按钮(第17和18行)</li><li id="c561" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nt nk nl nm bi translated">下一个屏幕加载在我们的webdriver中，但是页面加载时间(和任何重定向)由<code class="fe ls lt lu lv b">implicity_wait</code>函数处理。我们需要在主密码中随机输入3个字符。为了提取所需的3个字符，我们通过<code class="fe ls lt lu lv b">execute_script</code>函数执行DOM搜索(第19行)。变量<code class="fe ls lt lu lv b">memorable</code>保存所有<code class="fe ls lt lu lv b">div</code>的内容，其中包含我们需要的3个随机整数。</li><li id="9808" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nt nk nl nm bi translated">在第21行，我们得到对象的html，并把它们连接成一个大字符串，这样我们只需要执行一次搜索就可以得到整数。在第22行，我们执行正则表达式搜索。<code class="fe ls lt lu lv b">matches</code>变量现在包含了我们需要的整数的字符串表示。</li><li id="f486" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nt nk nl nm bi translated">在第23行，我们将整数转换成登录过程需要的实际字符。在第24行，我们创建了一个字典，它有一个<em class="nu">键</em>作为下拉菜单的字符串ID，有<em class="nu">值</em>作为必需值。</li><li id="9c0c" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nt nk nl nm bi translated">对于字典中的每个条目，我们找到下拉菜单，遍历选项并单击正确的值(第25–30行)。</li><li id="c55a" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nt nk nl nm bi translated">要完成登录，我们单击“提交”按钮(第31行)。</li></ul><p id="f8a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你在这些建议中发现了一些价值，如果有，请在评论中告诉我。</p></div></div>    
</body>
</html>