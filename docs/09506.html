<html>
<head>
<title>More on Go Channels, Parallelism and Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多关于Go通道、并行性和并发性的信息</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/as-a-follow-up-of-basic-parallel-computing-in-go-i-wanted-to-build-a-more-complex-example-where-13978bf84608?source=collection_archive---------15-----------------------#2021-08-16">https://levelup.gitconnected.com/as-a-follow-up-of-basic-parallel-computing-in-go-i-wanted-to-build-a-more-complex-example-where-13978bf84608?source=collection_archive---------15-----------------------#2021-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/ebf3909a79eb951ac4a87b21ce9da0b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*8B9voPrzcT5TiuO-xz4sEQ.png"/></div></figure><p id="a870" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为Go 中<a class="ae ks" href="https://medium.com/@anicolaspp/basic-parallel-computing-in-go-fda50894241c?source=your_stories_page-------------------------------------" rel="noopener">基本并行计算的后续，我想构建一个更复杂的例子，在这个例子中，我们在Go并发编程中使用了更高级的技术。</a></p><p id="066c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们首先创建一个函数<code class="fe kt ku kv kw b">ProduceInts</code>，它在一段时间<code class="fe kt ku kv kw b">t</code>内将随机数据生成到一个通道中。时间<code class="fe kt ku kv kw b">t</code>过去后，它关闭通道，表示不再产生数据。注意<code class="fe kt ku kv kw b">ProduceInts</code>没有阻塞。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="48c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们可以创建两个函数来处理产生的数据(int)。</p><p id="a7f8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下面的代码片段中，我们添加了两个新函数，<code class="fe kt ku kv kw b">CountInts</code>和<code class="fe kt ku kv kw b">Odds</code>。第一个只是创建一个<code class="fe kt ku kv kw b">map</code>来跟踪一个特定的数字已经生成了多少次。第二个函数检查生成的数字是否是奇数，如果检查通过，则打印它。</p><p id="3e96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，这两个新函数都是从一个通道中读取，它们不会阻塞，它们彼此独立运行，并且它们自己的许多实例可能会同时运行(这对可伸缩性很重要)。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="5c87" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们可以在Go 中使用我们在<a class="ae ks" href="https://medium.com/@anicolaspp/basic-parallel-computing-in-go-fda50894241c?source=your_stories_page-------------------------------------" rel="noopener">基本并行计算中创建的<code class="fe kt ku kv kw b">Splitter</code>将来自原始通道(流)的值路由到两个不同的通道，以便<code class="fe kt ku kv kw b">Odds</code>和<code class="fe kt ku kv kw b">CountInts</code>可以读取。</a></p><p id="19fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe kt ku kv kw b">router</code>包中，我们添加了<code class="fe kt ku kv kw b">Splitter</code>的实现以及一些功能，这些功能将允许我们组成通道并控制数据如何流动。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="5cba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们需要把所有事情都联系在一起。</p><p id="6264" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe kt ku kv kw b">main</code>包中，我们基本上开始生成随机整数，但只持续一定的时间(20秒)。</p><p id="ab5c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我们使用<code class="fe kt ku kv kw b">router</code>包来传输<code class="fe kt ku kv kw b">ProduceInts</code>和<code class="fe kt ku kv kw b">Splitter</code>的输出，这又增加了两个输出，这两个输出将作为<code class="fe kt ku kv kw b">CountInts</code>和<code class="fe kt ku kv kw b">Odds</code>的输入。</p><p id="5a26" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们通过做<code class="fe kt ku kv kw b">router.Run()</code>来开始<code class="fe kt ku kv kw b">Splitter</code>。由于不想让程序在所有项目处理完之前结束，我们等到<code class="fe kt ku kv kw b">Splitter</code>不再运行。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="23f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如我们所看到的，在Go中同步流和管道是非常容易的，我们只需要把通道看作队列，我们可以在任何时候从独立的进程中读写。</p><p id="7ffd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="ld">快乐编码。</em> </strong></p></div></div>    
</body>
</html>