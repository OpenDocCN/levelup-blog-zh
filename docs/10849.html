<html>
<head>
<title>TypeScript, Part 3: Working with Custom Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript，第3部分:使用自定义类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-part-3-working-with-custom-types-929ed9a80389?source=collection_archive---------14-----------------------#2022-01-17">https://levelup.gitconnected.com/typescript-part-3-working-with-custom-types-929ed9a80389?source=collection_archive---------14-----------------------#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/79fff1ee82dfe6caa0d7c9ea304aa146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hVBK_P1mbRB24zW0lsY-6A.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@girlwithredhat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">戴红色帽子的女孩</a>在<a class="ae jg" href="https://unsplash.com/s/photos/custom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><blockquote class="kn ko kp"><p id="0523" class="kq kr ks kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">本文是TypeScript系列文章的一部分:</p><p id="555a" class="kq kr ks kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/typescript-part-1-an-introduction-b00ade194c4">打字稿，第一部分:简介</a></p><p id="dba3" class="kq kr ks kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/typescript-part-2-adding-typescript-to-your-application-cabdc7d70cae"> TypeScript，第2部分:将TypeScript添加到您的应用程序中</a></p><p id="16ae" class="kq kr ks kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kt jk">类型脚本，第3部分:使用自定义类型</strong></p></blockquote></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="d5a2" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">将TypeScript与本机类型结合使用虽然很重要，但在任何现代应用程序中，这种做法很快就会令人感到力不从心。这是因为，尽管在JavaScript中，我们可能不会用这些术语来思考它，但我们确实在使用我们自己的类型。</p><p id="c212" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">一个应用程序的用户——及其<code class="fe ls lt lu lv b">first_name</code>、<code class="fe ls lt lu lv b">last_name</code>、<code class="fe ls lt lu lv b">email</code>、<code class="fe ls lt lu lv b">phone</code>——可以被认为是它自己的类型。由<code class="fe ls lt lu lv b">title</code>、<code class="fe ls lt lu lv b">author</code>和<code class="fe ls lt lu lv b">body</code>组成的博客帖子是另一种类型。如果我们能够利用TypeScript的所有优势，并将它们应用于我们最独特的需求，那该有多棒？你也许能明白我的意思——你能！</p><p id="0bec" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">输入自定义类型。自定义类型就像它们听起来的那样。可以创建一个<code class="fe ls lt lu lv b">status</code>类型，它只是一个字符串，但是可以防止您意外地传递另一个应该传递状态的字符串(如<code class="fe ls lt lu lv b">name</code>),并将状态<code class="fe ls lt lu lv b">John</code>呈现给名为John的用户。您可以创建<code class="fe ls lt lu lv b">interfaces</code>，它提供了大量的灵活性，并且是创建React道具类型的标准最佳实践。我最喜欢的TypeScript部分之一——许多第三方库现在都提供类型信息，如果你曾经使用过需要大量、深度嵌套的道具的依赖项，你就会明白为什么这是一件美好的事情。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="5888" class="lw lx jj bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">自定义类型</h1><p id="852a" class="pw-post-body-paragraph kq kr jj kt b ku mu kw kx ky mv la lb lp mw le lf lq mx li lj lr my lm ln lo im bi translated">正如我前面所说的，<strong class="kt jk">自定义类型</strong>是您，开发人员，为您的特定应用程序用例创建的任何类型。通常情况下，它们是对象，允许您将一组特定的键组合在一起，准确地说明应该使用哪些键，哪些键是必需的，哪些键是可选的，以及键值的预期类型。</p><p id="6c95" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">但是，它们不需要成为对象。你真的可以把任何东西变成自定义类型。如果您正在构建一个写博客的应用程序，您可能希望按类型组织帖子。但是你不希望你的用户只能选择任何一种类型——那是自找麻烦，既有T0也有T1。因此，您创建了一个自定义类型:</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="f3a9" class="nh lx jj lv b gy ni nj l nk nl">type Genre = 'JavaScript' | 'Golang' | 'Programming' | 'Business'</span></pre><p id="54b4" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">现在用户可以选择这四个指定的字符串中的任何一个，在任何需要类型<code class="fe ls lt lu lv b">Genre</code>的地方，TypeScript将检查不仅传递了一个字符串，而且传递了四个指定字符串中的一个。</p><h2 id="defc" class="nh lx jj bd ly nm nn dn mc no np dp mg lp nq nr mk lq ns nt mo lr nu nv ms nw bi translated">为什么我们使用自定义类型</h2><p id="b16f" class="pw-post-body-paragraph kq kr jj kt b ku mu kw kx ky mv la lb lp mw le lf lq mx li lj lr my lm ln lo im bi translated">还记得我们之前讨论的为什么我们首先要使用类型吗？它让我们的生活更轻松。我们为自己设置了安全措施，这样我们总是确切地知道<em class="ks">我们应该传递给函数什么，确切地知道函数返回什么，我们可以对变量调用什么方法，变量是否可能是<code class="fe ls lt lu lv b">null</code>或<code class="fe ls lt lu lv b">undefined</code>，等等。</em></p><p id="ef05" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">创建我们自己的自定义类型允许我们在更复杂的层次上完成所有这些。我们可以更精确地实施什么值应该被允许(这也作为未来开发人员的一种文档)，并允许我们对我们特别需要的类型实施保护。如果我们的应用程序中的有效用户必须有字段<code class="fe ls lt lu lv b">first_name</code>、<code class="fe ls lt lu lv b">last_name</code>、<code class="fe ls lt lu lv b">email</code>和<code class="fe ls lt lu lv b">phone</code>，那么我们应该<em class="ks">总是一起检查这些字段的类型，</em>因为有效用户不是一个，而是<em class="ks">所有有效字段</em>。它还允许我们指定一个<code class="fe ls lt lu lv b">User</code>是我们想要传递给一个函数或者从一个函数返回的东西——而不仅仅是任何一个旧的对象。</p><h2 id="78f8" class="nh lx jj bd ly nm nn dn mc no np dp mg lp nq nr mk lq ns nt mo lr nu nv ms nw bi translated">何时使用自定义类型</h2><p id="4a8f" class="pw-post-body-paragraph kq kr jj kt b ku mu kw kx ky mv la lb lp mw le lf lq mx li lj lr my lm ln lo im bi translated">这在某种程度上取决于开发人员的意见和团队的最佳实践。就个人而言，我喜欢在一些情况下创建自定义类型:</p><ol class=""><li id="a997" class="nx ny jj kt b ku kv ky kz lp nz lq oa lr ob lo oc od oe of bi translated">应用程序的一个核心对象(即一个<code class="fe ls lt lu lv b">User</code>、<code class="fe ls lt lu lv b">BlogPost</code>、<code class="fe ls lt lu lv b">Genre</code>)，它将在整个应用程序中传递。只要坚持干的原则，你很快就会感觉到这一点。</li><li id="82b7" class="nx ny jj kt b ku og ky oh lp oi lq oj lr ok lo oc od oe of bi translated">现有类型的一个狭窄子集(即上面的<code class="fe ls lt lu lv b">Genre</code>示例，其中允许有<code class="fe ls lt lu lv b">string</code>类型的一个小子集)。</li><li id="140b" class="nx ny jj kt b ku og ky oh lp oi lq oj lr ok lo oc od oe of bi translated">React props(我们将在后面更全面地探讨这一点)。</li></ol><p id="adb4" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">但是一般来说，你可以问自己一个好问题:“创建和维护这种类型会使这个应用程序的开发和维护变得更容易、更可靠吗，还是会成为一种负担？”</p><h2 id="f865" class="nh lx jj bd ly nm nn dn mc no np dp mg lp nq nr mk lq ns nt mo lr nu nv ms nw bi translated">创建自定义类型</h2><p id="8a4d" class="pw-post-body-paragraph kq kr jj kt b ku mu kw kx ky mv la lb lp mw le lf lq mx li lj lr my lm ln lo im bi translated">创建自定义类型相当简单，您已经在前面看到了语法。<code class="fe ls lt lu lv b">type</code>关键字的作用类似于<code class="fe ls lt lu lv b">let</code>或<code class="fe ls lt lu lv b">const</code>，并将类型名分配给语句的左侧:</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="db80" class="nh lx jj lv b gy ni nj l nk nl">// Note: the ? after the address field means the field is optional // An object that has all valid fields besides this is still a User</span><span id="b026" class="nh lx jj lv b gy ol nj l nk nl">type User = {<br/>  first_name: string;<br/>  last_name: string;<br/>  email: string;<br/>  phone: string;<br/>  address?: string;<br/>  age: number;<br/>  verified: boolean;<br/>}</span><span id="78eb" class="nh lx jj lv b gy ol nj l nk nl">type Title = string;</span></pre><h2 id="7552" class="nh lx jj bd ly nm nn dn mc no np dp mg lp nq nr mk lq ns nt mo lr nu nv ms nw bi translated">类型检查自定义类型</h2><p id="3a9c" class="pw-post-body-paragraph kq kr jj kt b ku mu kw kx ky mv la lb lp mw le lf lq mx li lj lr my lm ln lo im bi translated">对于自定义类型，需要注意的一件重要事情是，您不能使用可用于基本类型的标准类型检查。</p><p id="d9d3" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">要检查一个变量实际上是否是一个字符串，您需要做的就是编写:</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="6564" class="nh lx jj lv b gy ni nj l nk nl">let name = 'Zuma';</span><span id="ce94" class="nh lx jj lv b gy ol nj l nk nl">typeof name === 'string'; // this will evaluate to true</span><span id="b7ca" class="nh lx jj lv b gy ol nj l nk nl">typeof name === 'number'; // this will evaluate to false</span></pre><p id="14f4" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated"><code class="fe ls lt lu lv b">typeof</code>语法适用于基本类型。可以用类似的方式验证数组:</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="a107" class="nh lx jj lv b gy ni nj l nk nl">let pets = ['Zuma', 'Roxy'];</span><span id="bd9d" class="nh lx jj lv b gy ol nj l nk nl">console.log(<!-- -->pets instanceof Array<!-- -->); // this will evaluate to true</span></pre><p id="5ee9" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">对于自定义类型，我们也必须创建自己的类型检查方法。我们使用<strong class="kt jk">类型谓词</strong>来做到这一点。</p><p id="6bfb" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">首先，我们来回顾一下上面的<code class="fe ls lt lu lv b">type User</code>例子。你可能会问自己，为什么我不能只检查<code class="fe ls lt lu lv b">typeof u.first_name === ‘string’ &amp;&amp; u.last_name === ‘string’ &amp;&amp; u.email === ‘string’</code>等等？答案是，可以，但是当你完成所有这些类型检查后，<strong class="kt jk"> <em class="ks"> TypeScript仍然不知道变量</em> </strong> <code class="fe ls lt lu lv b"><strong class="kt jk">u</strong></code> <strong class="kt jk"> <em class="ks">是User类型。</em> </strong>你不会再有更多的信息来继续前进了。当你试图将变量<code class="fe ls lt lu lv b">u</code>传入一个函数时，TypeScript仍然会抛出一个错误，因为它不知道它是什么类型！</p><p id="0f55" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">为了解决这个问题，我们使用了一个称为类型谓词的特定函数。类型谓词的返回类型是<code class="fe ls lt lu lv b">var is type</code>。在我们的例子中，应该是<code class="fe ls lt lu lv b">u is User</code>。我们的函数看起来像这样—</p><pre class="mz na nb nc gt nd lv ne nf aw ng bi"><span id="08a3" class="nh lx jj lv b gy ni nj l nk nl">// We pass type unknown so that we can check a variable of any type</span><span id="8e77" class="nh lx jj lv b gy ol nj l nk nl">function isUser(u: unknown): u is User {</span><span id="33ad" class="nh lx jj lv b gy ol nj l nk nl">  // Assert that the unknown value is of type User, so that we can <br/>  // check the expected fields<br/>  <br/>  const user = u as User;</span><span id="2265" class="nh lx jj lv b gy ol nj l nk nl">  if (!user.first_name || typeof user.first_name !== 'string') {<br/>    return false;<br/>  }</span><span id="1c3a" class="nh lx jj lv b gy ol nj l nk nl">  if (!user.last_name || typeof user.last_name !== 'string') {<br/>    return false;<br/>  }</span><span id="2b69" class="nh lx jj lv b gy ol nj l nk nl">  if (!user.email || typeof user.email !== 'string') {<br/>    return false;<br/>  }</span><span id="93f1" class="nh lx jj lv b gy ol nj l nk nl">  if (!user.phone || typeof user.phone !== 'string') {<br/>    return false;<br/>  }</span><span id="0d68" class="nh lx jj lv b gy ol nj l nk nl">  // We use &amp;&amp; instead of || here because it is an optional field<br/>  if (user.address &amp;&amp; typeof user.address !== 'string') {<br/>    return false;<br/>  }</span><span id="2ec4" class="nh lx jj lv b gy ol nj l nk nl">  if (!user.age || typeof user.age !== 'number') {<br/>    return false;<br/>  }<br/>  <br/>  return true;<br/>}</span></pre><p id="5575" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">使用这个类型谓词，我们现在可以将变量类型缩小到我们特定的定制用户类型。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="c485" class="pw-post-body-paragraph kq kr jj kt b ku kv kw kx ky kz la lb lp ld le lf lq lh li lj lr ll lm ln lo im bi translated">接下来，我们将讨论使用第三方库时的接口和利用类型。</p></div></div>    
</body>
</html>