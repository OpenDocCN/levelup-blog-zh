<html>
<head>
<title>How to Paint Like Piet Mondrian with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python画出皮耶·蒙德里安的样子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-paint-like-piet-mondrian-with-python-fb74d7b5ae2e?source=collection_archive---------9-----------------------#2021-03-28">https://levelup.gitconnected.com/how-to-paint-like-piet-mondrian-with-python-fb74d7b5ae2e?source=collection_archive---------9-----------------------#2021-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="780b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像艺术家一样编程。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/879381c0b71e380f77c19b7e5176cd51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*hUKxG0GVxo8pUo5pdFmFrw.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">彼得·蒙德里安于1935年创作的《C号作品》</figcaption></figure><p id="39c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">皮特·蒙德里安是20世纪最有影响力的艺术家之一。这位荷兰画家以其引人注目的抽象艺术而闻名，是“风格派”运动的创始人，这是一种崇尚经济和象征主义的风格。</p><p id="a8f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">德·斯蒂格尔和蒙德里安通过德国包豪斯获得了国际认可，这是一所以其设计原则而闻名的艺术学校。</p><p id="57a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像<em class="lb">百老汇布吉伍吉</em>和<em class="lb">构图C </em>这样的画是蒙德里安风格的典型例子。他经常使用最小的调色板，并依赖于网格的概念。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/4d792ea82cd3325193b14c9faa7e94b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*Nu5wwTAfVYR4blJrZ9yXTA.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">彼得·蒙德里安创作于1940年至1942年的伦敦</figcaption></figure><p id="47af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">蒙德里安是一位专心致志的艺术家。他会在工作室里花上几个小时一丝不苟地画画，直到他的手指起了水泡，或者累得生病。</p><p id="01c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了Python和一点数学知识，我们可以生成自己的几何抽象艺术。</p><p id="5d64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过观察蒙德里安作品中的一些规则，我们可以创造出无限多的绘画作品。不需要水泡！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/892dda77a0d2fe5435d19c44def6a6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*aPk7gCXJcPt-vhbwnKYzgw.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">计算机生成的皮耶·蒙德里安。2021</figcaption></figure><h1 id="3699" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">用Python绘制图形</h1><p id="3498" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">为了用Python绘画，我们需要安装一个图形库。在这个演示中，我们将使用PyCairo。</p><p id="578c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PyCairo是一个免费的图形库，您可以使用Python代码来绘制图形。希望您的计算机上已经安装了Python 3。</p><p id="7ab6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从命令行安装PyCairo最简单，如下所示:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="f4f4" class="ml le it mh b gy mm mn l mo mp">pip install pycairo</span></pre><p id="8ddb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦安装了这个库，我们就可以在我们的Python程序中使用它。</p><h1 id="c829" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">绘画的规则</h1><p id="2262" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在我们写任何代码之前，我们需要为我们的绘画程序定义一些规则。我们需要把皮耶·蒙德里安的画分解成基本规则。</p><p id="f59e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，蒙德里安只使用像红色、黄色和蓝色这样的原色。这些集中在正方形和长方形。</p><p id="fe6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">连接这些形状的是黑色直线。这些线条从矩形的边缘延伸出来，形成了它们的边框。</p><p id="4c37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">背景画布总是白色的。</p><p id="01b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这些规则，我们可以开始想象生成皮耶·蒙德里安画作的算法:</p><ol class=""><li id="401b" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">从白色画布开始。</li><li id="d807" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">绘制从画布边缘延伸的随机线条。</li><li id="f71e" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">用随机的原色填充一些线条创建的白色矩形。</li></ol><p id="f055" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经有了具体的想法，可以开始写代码了。</p><h1 id="21b1" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">生成艺术</h1><p id="aef7" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">先从导入PyCario开始，画一张白色画布。使用<em class="lb"> import </em>关键字导入Python中的库。我们总是在文件的顶部导入库。</p><p id="2ca5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还需要导入随机库。这是Python的标准配置，所以不需要像我们在PyCairo中那样安装它。</p><p id="aaf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们先画一块500像素宽、500像素高的白色画布。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="c353" class="ml le it mh b gy mm mn l mo mp">import random<br/>import cairo</span><span id="79cc" class="ml le it mh b gy ne mn l mo mp">IMAGE_WIDTH = 500<br/>IMAGE_HEIGHT = 500</span><span id="8bd2" class="ml le it mh b gy ne mn l mo mp">surface = cairo.ImageSurface(cairo.FORMAT_RGB24, IMAGE_WIDTH, IMAGE_HEIGHT)</span><span id="e1ab" class="ml le it mh b gy ne mn l mo mp">ctx = cairo.Context(surface)<br/>ctx.rectangle(0,0,IMAGE_WIDTH,IMAGE_HEIGHT)<br/>ctx.set_source_rgb(1,1,1)<br/>ctx.fill()</span><span id="0c67" class="ml le it mh b gy ne mn l mo mp">surface.write_to_png('painting.png')</span></pre><p id="61a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">皮耶·蒙德里安依赖于网格的概念，我们也一样。通过在网格上构建我们的绘画，我们可以确保一切都像蒙德里安的作品一样排列整齐。</p><p id="c476" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们如何在Python中做到这一点？嗯，我们可以试着用PyCario在画布上画一些随机的线条和矩形，但是那不会给我们想要的结果。</p><p id="d530" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了得到类似蒙德里安绘画的东西，我们将使用瓷砖网格。每个图块将是网格中的一个单元。</p><p id="cc22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过改变这些瓷砖的颜色，我们可以画出线条和矩形。</p><h2 id="34a3" class="ml le it bd lf nf ng dn lj nh ni dp ln kb nj nk lr kf nl nm lv kj nn no lz np bi translated">创建切片</h2><p id="f77f" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们的图块信息将存储在字典中。我们将使用x和y坐标作为每个图块的颜色信息的关键字。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="645c" class="ml le it mh b gy mm mn l mo mp"># mondrian.py</span><span id="419d" class="ml le it mh b gy ne mn l mo mp">import cairo<br/>import random</span><span id="b34f" class="ml le it mh b gy ne mn l mo mp"># the size of the image<br/>IMAGE_WIDTH = 500<br/>IMAGE_HEIGHT = 500</span><span id="6fdb" class="ml le it mh b gy ne mn l mo mp"># the size of the tile grid<br/>MAP_WIDTH = 50<br/>MAP_HEIGHT = 50</span><span id="f204" class="ml le it mh b gy ne mn l mo mp"># the size of each tile<br/>TILE_SIZE = 10</span><span id="5043" class="ml le it mh b gy ne mn l mo mp">MAX_LINES = 15<br/>MIN_LINES = 6<br/>MAX_RECTS = 5<br/>MIN_RECTS = 1</span><span id="64d5" class="ml le it mh b gy ne mn l mo mp">tiles = {}</span><span id="bd9c" class="ml le it mh b gy ne mn l mo mp">#colors (0,white),(1,black),(2,red),(3,yellow)(4,blue)<br/>def generate_tiles():<br/>    # build tile map<br/>    for x in range(MAP_WIDTH):<br/>        for y in range(MAP_HEIGHT):<br/>            # set every tile to white<br/>            tiles[x,y] = 0<br/>    draw_lines()</span></pre><h2 id="1447" class="ml le it bd lf nf ng dn lj nh ni dp ln kb nj nk lr kf nl nm lv kj nn no lz np bi translated">绘制地图</h2><p id="b0ee" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们的每个瓷砖将是一个10x10像素宽的正方形。颜色信息将是一个整数。一旦完成生成，我们将需要一个函数来将瓷砖绘制到画布上。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="42ad" class="ml le it mh b gy mm mn l mo mp">def draw_map():<br/>    # draw tile map using pycairo<br/>    surface = cairo.ImageSurface(cairo.FORMAT_RGB24, IMAGE_WIDTH, IMAGE_HEIGHT)<br/>    ctx = cairo.Context(surface)<br/>    for x in range(MAP_WIDTH):<br/>        for y in range(MAP_HEIGHT):<br/>            size = TILE_SIZE<br/>            ctx.rectangle(x*size,y*size,x+size,y+size)<br/>            if tiles[x,y] == 0:<br/>                ctx.set_source_rgb(1,1,1)<br/>            elif tiles[x,y] == 1:<br/>                ctx.set_source_rgb(0,0,0)<br/>            elif tiles[x,y] == 2:<br/>                ctx.set_source_rgb(1,0,0)<br/>            elif tiles[x,y] == 3:<br/>                ctx.set_source_rgb(1,1,0)<br/>            else:<br/>                ctx.set_source_rgb(0,0,1)</span><span id="efc4" class="ml le it mh b gy ne mn l mo mp">            ctx.fill()</span><span id="d2bf" class="ml le it mh b gy ne mn l mo mp">    surface.write_to_png('mondrian.png')</span></pre><h2 id="e815" class="ml le it bd lf nf ng dn lj nh ni dp ln kb nj nk lr kf nl nm lv kj nn no lz np bi translated">画线</h2><p id="7741" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们需要水平线和垂直线来达到我们想要的效果。我们可以通过沿着网格边缘随机选择像素来做到这一点。</p><p id="7796" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想要一条水平线，我们需要沿着x轴填充网格。对于垂直方向，我们需要y轴。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="9e0c" class="ml le it mh b gy mm mn l mo mp">def draw_lines():<br/>    total_lines = random.randint(MIN_LINES,MAX_LINES)<br/>    print(total_lines)<br/>    for h in range(int(total_lines/2)):<br/>        y = random.randint(0,MAP_HEIGHT)<br/>        for x in range(MAP_WIDTH):<br/>            tiles[x,y] = 1<br/>    for v in range(int(total_lines/2)):<br/>        x = random.randint(0,MAP_WIDTH)<br/>        for y in range(MAP_HEIGHT):<br/>            tiles[x,y] = 1<br/>    fill_rects()</span></pre><h2 id="a5bf" class="ml le it bd lf nf ng dn lj nh ni dp ln kb nj nk lr kf nl nm lv kj nn no lz np bi translated">填充矩形</h2><p id="3af9" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">填充矩形是本教程中最复杂的部分。我们将分两部分处理它。</p><p id="c7a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将处理我们的<strong class="js iu"> fill_rect() </strong>方法。该方法将在地图中搜索白色像素。如果它找到一个，它会用一个随机的原色填充它。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="6a70" class="ml le it mh b gy mm mn l mo mp">def fill_rects():<br/>    total_rects = random.randint(MIN_RECTS,MAX_RECTS)<br/>    max_iters = 5<br/>    for i in range(max_iters):<br/>        for r in range(total_rects):<br/>            x = random.randint(0,MAP_WIDTH-1)<br/>            y = random.randint(0,MAP_HEIGHT-1)<br/>            if tiles[x,y] == 0:<br/>                color = random.randint(2,4)<br/>                flood_recursion(x,y,0,color)</span></pre><h1 id="4316" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用整体填充</h1><p id="3a6f" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">整体填充算法的工作原理类似于任何绘画应用中的“桶”工具。在我们的例子中，它将使用颜色填充由<strong class="js iu"> draw_lines() </strong>方法创建的一些白色方块。</p><p id="5b14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">泛洪递归将从起始像素开始扩散，并将遇到的任何白色像素更改为新的颜色。</p><p id="df17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">flood fill方法是递归的，这意味着它在从一个图块移动到另一个图块时会调用自身。这允许它检查它遇到的每个瓦片的每个邻居。当洪水填充进入地图的边界或黑色瓷砖时，它会停止。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="7414" class="ml le it mh b gy mm mn l mo mp">def flood_recursion(x,y,start_color,update_color):<br/>    width = MAP_WIDTH<br/>    height = MAP_HEIGHT<br/>    if tiles[x,y] != start_color:<br/>        return<br/>    elif tiles[x,y] == update_color:<br/>        return<br/>    else:<br/>        tiles[x,y] = update_color<br/>        neighbors = [(x-1,y),(x+1,y),(x-1,y-1),(x+1,y+1),(x-1,y+1),(x+1,y-1),(x,y-1),(x,y+1)]<br/>        for n in neighbors:<br/>            if 0 &lt;= n[0] &lt;= width-1 and 0 &lt;= n[1] &lt;= height-1:<br/>                flood_recursion(n[0],n[1],start_color,update_color)</span></pre><p id="1d77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着洪水填充的完成，我们有了生成蒙德里安风格绘画所需的一切。</p><p id="1b6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会在下面找到程序的最终版本。</p><h1 id="d225" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">摘要</h1><p id="d694" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我已经加入了一些变量，我们可以利用它们来改变结果。通过改变程序允许的线条和矩形的数量，我们可以很容易地改变最终的结果。</p><p id="e1fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望你已经喜欢上了关于Piet Mondrian的这一课，并在这个过程中学到了一些关于Python的知识。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/3069b409eae9e8f2711e0c3f0cdb4ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*rjvp9RI9TzrEuPZthHoEDw.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">通过改变变量，我们可以改变结果。</figcaption></figure><h1 id="1a31" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">代码</h1><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="668f" class="ml le it mh b gy mm mn l mo mp"># mondrian.py</span><span id="336a" class="ml le it mh b gy ne mn l mo mp">import cairo<br/>import random</span><span id="c0f9" class="ml le it mh b gy ne mn l mo mp"># the size of the image<br/>IMAGE_WIDTH = 500<br/>IMAGE_HEIGHT = 500</span><span id="d7b8" class="ml le it mh b gy ne mn l mo mp"># the size of the tile grid<br/>MAP_WIDTH = 50<br/>MAP_HEIGHT = 50</span><span id="10ba" class="ml le it mh b gy ne mn l mo mp"># the size of each tile<br/>TILE_SIZE = 10</span><span id="a3a0" class="ml le it mh b gy ne mn l mo mp">MAX_LINES = 15<br/>MIN_LINES = 6<br/>MAX_RECTS = 5<br/>MIN_RECTS = 1</span><span id="0169" class="ml le it mh b gy ne mn l mo mp">tiles = {}<br/>#colors (0,white),(1,black),(2,red),(3,yellow)(4,blue)<br/>def generate_tiles():<br/>    # build tile map<br/>    for x in range(MAP_WIDTH):<br/>        for y in range(MAP_HEIGHT):<br/>            # set every tile to white<br/>            tiles[x,y] = 0<br/>    draw_lines()<br/>def draw_lines():<br/>    total_lines = random.randint(MIN_LINES,MAX_LINES)<br/>    # print(total_lines)<br/>    for h in range(int(total_lines/2)):<br/>        y = random.randint(0,MAP_HEIGHT)<br/>        for x in range(MAP_WIDTH):<br/>            tiles[x,y] = 1<br/>    for v in range(int(total_lines/2)):<br/>        x = random.randint(0,MAP_WIDTH)<br/>        for y in range(MAP_HEIGHT):<br/>            tiles[x,y] = 1<br/>    fill_rects()<br/>def fill_rects():<br/>    total_rects = random.randint(MIN_RECTS,MAX_RECTS)<br/>    max_iters = 5<br/>    for i in range(max_iters):<br/>        for r in range(total_rects):<br/>            x = random.randint(0,MAP_WIDTH-1)<br/>            y = random.randint(0,MAP_HEIGHT-1)<br/>            if tiles[x,y] == 0:<br/>                color = random.randint(2,4)<br/>                flood_recursion(x,y,0,color)<br/>def flood_recursion(x,y,start_color,update_color):<br/>    width = MAP_WIDTH<br/>    height = MAP_HEIGHT<br/>    if tiles[x,y] != start_color:<br/>        return<br/>    elif tiles[x,y] == update_color:<br/>        return<br/>    else:<br/>        tiles[x,y] = update_color<br/>        neighbors = [(x-1,y),(x+1,y),(x-1,y-1),(x+1,y+1),(x-1,y+1),(x+1,y-1),(x,y-1),(x,y+1)]<br/>        for n in neighbors:<br/>            if 0 &lt;= n[0] &lt;= width-1 and 0 &lt;= n[1] &lt;= height-1:<br/>                flood_recursion(n[0],n[1],start_color,update_color)<br/>def draw_map():<br/>    # draw tile map using pycairo<br/>    surface = cairo.ImageSurface(cairo.FORMAT_RGB24, IMAGE_WIDTH, IMAGE_HEIGHT)<br/>    ctx = cairo.Context(surface)<br/>    for x in range(MAP_WIDTH):<br/>        for y in range(MAP_HEIGHT):<br/>            size = TILE_SIZE<br/>            ctx.rectangle(x*size,y*size,x+size,y+size)<br/>            if tiles[x,y] == 0:<br/>                ctx.set_source_rgb(1,1,1)<br/>            elif tiles[x,y] == 1:<br/>                ctx.set_source_rgb(0,0,0)<br/>            elif tiles[x,y] == 2:<br/>                ctx.set_source_rgb(1,0,0)<br/>            elif tiles[x,y] == 3:<br/>                ctx.set_source_rgb(1,1,0)<br/>            else:<br/>                ctx.set_source_rgb(0,0,1)</span><span id="e310" class="ml le it mh b gy ne mn l mo mp">            ctx.fill()</span><span id="acf5" class="ml le it mh b gy ne mn l mo mp">    surface.write_to_png('mondrian.png')<br/>generate_tiles()<br/>draw_map()</span></pre></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="9f29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢我的作品，并愿意支持我和媒体上的其他作家，使用<a class="ae nx" href="https://harold-j-petty.medium.com/membership" rel="noopener">这个链接</a>成为会员。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</p></div></div>    
</body>
</html>