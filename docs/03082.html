<html>
<head>
<title>Kotlin Coroutines (Part 2) - Suspended Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin协程(第2部分)——暂停函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kotlin-coroutines-suspended-functions-part-2-8e9044f2959c?source=collection_archive---------8-----------------------#2020-04-18">https://levelup.gitconnected.com/kotlin-coroutines-suspended-functions-part-2-8e9044f2959c?source=collection_archive---------8-----------------------#2020-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c42cf4312238408a17f4cb96f43d2fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wT3f1cDSFLdlf6xW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d4ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本系列的<a class="ae kc" href="https://medium.com/@faizanwar027/kotlin-coroutines-basics-part1-617389b168f8" rel="noopener">第1部分</a>中，我们从较高的层面观察了协程，看到了它们比传统线程更优越的性能。我们还了解了当协程和线程执行长时间运行的任务时会发生什么。既然我们现在已经熟悉了如何启动协程并在没有任何线程分配或内存泄漏的情况下获得异步结果，我们将研究协程为代码增值的另一个方面。</p><p id="ce77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">协程为我们提供了一个机会，通过控制流程并在可用时返回值，为长时间运行的任务编写顺序风格的代码。换句话说，它们<strong class="kf ir">允许暂停代码执行，并在达到预期结果后继续执行</strong>，而无需我们编写任何回调或通知机制。在我们深入了解这是如何发生的之前，让我们快速回忆一下目前在没有协程的Android中异步操作是如何处理的。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h1 id="b700" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Android中没有协程的回调</h1><p id="3327" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">让我们举一个简单的例子，我们在短暂的延迟后执行一个任务。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mk lg l"/></div></figure><p id="3757" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到getUserFromAPI()接受一个字符串值和一个回调对象，以便在结果可用时传回结果。为了模拟长时间运行的操作，我使用了Thread.sleep(1000 ),让当前线程休眠一毫秒。线程唤醒后，它使用我们从主函数传递的字符串创建一个用户对象，并将其返回给主函数。如果上面的println代码没有放在回调函数中，我们的代码就会崩溃，因为它的值还没有初始化。让我们看看如何使用协程挂起函数以更简洁的方式编写相同的代码。</p><h1 id="632f" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">使用挂起的函数来清理代码</h1><p id="ac2f" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">一个<strong class="kf ir">暂停功能</strong>是一个<strong class="kf ir">功能</strong>，可以暂停并在以后恢复。他们可以执行一个长时间运行的操作，并在不阻塞任何线程的情况下等待它完成。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mk lg l"/></div></figure><p id="daa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的是要知道一个挂起的函数只能从协程或另一个挂起的函数中调用。否则会导致编译错误。</p><blockquote class="ml mm mn"><p id="225a" class="kd ke mo kf b kg kh ki kj kk kl km kn mp kp kq kr mq kt ku kv mr kx ky kz la ij bi translated">如您所见，您需要做的就是启动一个协程来卸载主线程。依靠来自协程API的内部线程，所以没有创建新线程的额外开销。按顺序编写代码<strong class="kf ir"/>，即使它是<strong class="kf ir">异步的</strong>，并在调用点使用try/catch块，即使值可以异步产生。</p></blockquote><h1 id="1b32" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">引擎盖下发生了什么</h1><p id="f406" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">我们在这里试图实现的目标之一是不管代码是异步的还是同步的，都有一个一流的延续。正是这个<strong class="kf ir">延续</strong><strong class="kf ir"/>操纵程序调用栈内部的执行流。它可以被描述为围绕程序的<strong class="kf ir">控制状态</strong>的抽象包装器，其中<strong class="kf ir"> </strong>控制程序将如何以及何时进一步执行，以及它的结果将是什么——异常还是值。</p><p id="deda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦一个函数执行完毕，程序就将它从堆栈中取出，并继续执行下一个函数。诀窍在于系统如何知道每个函数执行后返回到哪里。该信息保存在前述的<strong class="kf ir">延续</strong>中。每个延续都包含一些关于调用函数的<strong class="kf ir">上下文</strong>的信息。像局部变量、函数传递的参数、调用它的线程等等。通过使用这些信息，当一个函数结束时，系统可以简单地依靠延续来告诉它需要在哪里。</p><h1 id="8ab9" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">下一步是什么</h1><p id="28ca" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在下一篇文章中，我们将回顾开发人员为使异步编程更加优雅而采用的方法以及他们学到的经验。我们还将学习如何构建更干净、更复杂的机制，这些机制不会阻塞，可以异步或并行工作。在那之前，请继续关注并快乐编码！</p><div class="ms mt gp gr mu mv"><a rel="noopener  ugc nofollow" target="_blank" href="/kotlin-coroutines-async-await-part-3-6108bf6be5c4"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">Kotlin协同程序-异步/等待(第3部分)</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">在上一篇文章中，我们了解了协程提供的暂停函数以及它们给应用程序带来的价值</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj jw mv"/></div></div></a></div></div></div>    
</body>
</html>