<html>
<head>
<title>Decorators and Functions in Python — Handy Python Features (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的装饰器和函数——方便的Python特性(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handy-python-features-e33751ef98a8?source=collection_archive---------2-----------------------#2019-07-04">https://levelup.gitconnected.com/handy-python-features-e33751ef98a8?source=collection_archive---------2-----------------------#2019-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f867" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">__我们如何使用装饰者_ _。巴拉圭</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f51614d73d4c4330118717b9a8984de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*620kGNh0za8XrpRM"/></div></div></figure><p id="50a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python是一种强大的语言，有许多方便的内置特性。装修工就是其中之一。您可能见过Python代码中的装饰器，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">正在使用的装饰器:@staticmethod是一个装饰器</figcaption></figure><p id="6093" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">装饰器是包装其他函数并改变其行为的函数。Python用<a class="ae lw" href="https://www.python.org/dev/peps/pep-0318/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> PEP-0318 </strong> </a>描述装饰者。在讨论decorators是什么以及如何使用它们之前，我们需要了解Python中的函数是什么以及Python处理它们的方式。</p><h1 id="a701" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">功能</h1><p id="8891" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">简单地说，一个函数可以接受参数并使用它们完成工作。例如，上面示例中的<code class="fe mu mv mw mx b">print</code>函数将一个字符串输入作为参数，并将其打印到控制台。也有不接受任何参数的函数。有些函数返回输出，有些不返回。</p><h2 id="70ba" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated">内部函数</h2><p id="6e51" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Python看到关键字<code class="fe mu mv mw mx b">def</code>就定义了一个函数。也允许在函数内部定义函数，如下面的代码所示。这些被称为内部函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">内部函数:print_greeting()函数中的两个内部函数定义</figcaption></figure><p id="c82c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数<code class="fe mu mv mw mx b">print_greeting()</code>有两个内部函数。其中一个在被调用时基于参数<code class="fe mu mv mw mx b">uppercase</code>被调用。</p><h2 id="f2c2" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated">一等品</h2><p id="e364" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">python中的函数被视为一级对象。因此，函数可以作为参数传递给另一个函数，就像字符串、整数或任何其他对象一样。下面的示例演示如何将函数传递给函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">函数是一级对象:print_hi()作为参数传递</figcaption></figure><p id="3be0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数<code class="fe mu mv mw mx b">run_any_function(function)</code> <strong class="kw iu"> </strong>将任意一个函数作为参数并调用它。这里它采用了函数<code class="fe mu mv mw mx b">print_hi()</code>。</p><p id="e8e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数也可以作为输出从函数返回:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">函数是一级对象:get_capable_function()返回一个函数</figcaption></figure><p id="6eca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数<code class="fe mu mv mw mx b">get_capable_function(uppercase)</code> <strong class="kw iu"> </strong>根据参数<code class="fe mu mv mw mx b">uppercase</code>返回一个函数。如果参数为真，则返回函数<code class="fe mu mv mw mx b">print_text_uppercase(text)</code> <strong class="kw iu"> </strong>，其他情况下返回函数<code class="fe mu mv mw mx b">print_text(text)</code> <strong class="kw iu"> </strong>。</p><p id="9133" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了讨论装饰者如何工作的背景。</p><h1 id="a960" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">装修工</h1><p id="dac9" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">装饰器是包装一个函数并改变其行为的函数。这些函数接受一个函数作为参数。它们定义了一个内部函数，可以调用作为参数的函数来改变其行为。内部函数作为输出返回:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">装饰者:print _ hi _ and _ name(name _ only _ function)是一个装饰者</figcaption></figure><p id="26f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的例子展示了一个基本的装饰器。函数<code class="fe mu mv mw mx b">print_hi_and_name(name_only_function)</code> <strong class="kw iu"> </strong>以函数<code class="fe mu mv mw mx b">print_name()</code> <strong class="kw iu"> </strong>为自变量。它由内部函数<code class="fe mu mv mw mx b">add_hi()</code>调用，该函数通过打印“Hi”来改变行为。内部函数被返回，因此函数<code class="fe mu mv mw mx b">print_name</code>可以用装饰函数重新声明。</p><h2 id="078f" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated">@语法</h2><p id="f5c6" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">有一种更简洁的方法可以获得相同的结果，而不是像上面例子中的第12行那样重新声明函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">Decorators : print_name()是用@print_hi_and_name修饰的</figcaption></figure><h2 id="dc45" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated">带参数的函数</h2><p id="05dc" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">函数<code class="fe mu mv mw mx b">print_name()</code> <strong class="kw iu"> </strong>打印硬编码值。假设我们需要将一个名字作为参数传递给那个函数，新函数变成了<code class="fe mu mv mw mx b">print_name(name)</code> <strong class="kw iu"> </strong>现在是<strong class="kw iu">。但是调用它的内部函数不知道该函数所需的参数。还应相应地更改它，否则会产生错误:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">Decorators : print_name(name)用@print_hi_and_name装饰</figcaption></figure><p id="8aaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面示例中的内部函数<code class="fe mu mv mw mx b">add_hi()</code> <strong class="kw iu"> </strong>被修改为<code class="fe mu mv mw mx b">add_hi(name)</code> <strong class="kw iu"> </strong>，这使得它能够接受参数<code class="fe mu mv mw mx b">name</code>，然后该参数可以传递给函数<code class="fe mu mv mw mx b">print_name(name)</code>。</p><p id="94d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以将函数<strong class="kw iu"> </strong> <code class="fe mu mv mw mx b">print_hi_and_name(name_only_function)</code>更改为<code class="fe mu mv mw mx b">print_greeting_and_name(name_only_function, greeting)</code>，这样就可以采用额外的参数<code class="fe mu mv mw mx b">greeting</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">装饰者:用@ print _ greeting _ and _ name(greeting)装饰print_name(name)</figcaption></figure><h2 id="e888" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated">*args和**kwargs形式的参数</h2><p id="ed94" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">假设我们需要修改函数<code class="fe mu mv mw mx b">print_name(name)</code> <strong class="kw iu"> </strong>来在名字前打印一个称呼。修改后的函数将接受一个新的参数<strong class="kw iu"> </strong> <code class="fe mu mv mw mx b">salutation</code>。</p><p id="63b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以前，我们必须修改内部函数来获取修饰函数所需的参数。新的论点也需要同样的东西。这是不被接受的，也不是好的做法。装饰者不应该知道应该传递给被装饰函数的参数。</p><p id="63f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用一个小技巧。窍门是<code class="fe mu mv mw mx b"><strong class="kw iu">*args</strong></code> <strong class="kw iu"> </strong>和<strong class="kw iu"> </strong> <code class="fe mu mv mw mx b"><strong class="kw iu">**kwargs</strong></code> <strong class="kw iu">。</strong>函数<code class="fe mu mv mw mx b">add_greeting(name)</code> <strong class="kw iu"> </strong>可以改成<code class="fe mu mv mw mx b">add_greeting(*args,**kwargs)</code> <strong class="kw iu"> </strong>然后函数<code class="fe mu mv mw mx b">name_only_function(name)</code>可以调用为<code class="fe mu mv mw mx b">name_only_function(*args,**kwargs)</code> <strong class="kw iu"> </strong>如下。我们现在可以将功能<code class="fe mu mv mw mx b">print_name(name)</code> <strong class="kw iu"> </strong>改为<strong class="kw iu"> </strong> <code class="fe mu mv mw mx b">print_name(salutation, name)</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">装饰者:用@ print _ greeting _ and _ name(greeting)装饰print_name(salutation，name)</figcaption></figure><h1 id="210d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">一份申请</h1><p id="24b5" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">像Java这样的语言有访问修饰符，用来控制方法的范围。可以通过使用关键字<code class="fe mu mv mw mx b">private</code>使方法私有。但是Python没有这个概念。</p><p id="bacc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以写一个装饰器，使类中的私有函数不能被外部访问。我们只需要检查私有函数是从类的外部还是内部调用的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">装饰者:@private_function是一个定制的装饰者</figcaption></figure><p id="c58e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">装饰器可用于隔离私有函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">decorator:@ private _ function用于防止私有方法被外部调用</figcaption></figure><p id="7a45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用<code class="fe mu mv mw mx b"><strong class="kw iu">@</strong>private_function</code>修饰的函数只允许在类内部调用。如果从外部调用这些函数，则会引发异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">Decorators:调用私有函数时会引发错误</figcaption></figure><p id="25d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在以下位置找到Git存储库。</p><div class="nk nl gp gr nm nn"><a href="https://github.com/vishwaefor/handy-python-features" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">vishwaefor/handy-python-特性</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">便捷的Python特性。通过在GitHub上创建帐户，为vishwaefor/handy-python-features开发做出贡献。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ks nn"/></div></div></a></div><h1 id="0147" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">延伸阅读……</strong></h1><p id="cc56" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">装修工得心应手。它们也可以和类一起使用。单例模式可以使用decorators来实现。我建议你多读一些关于那个的文章。</p></div></div>    
</body>
</html>