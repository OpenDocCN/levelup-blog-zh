<html>
<head>
<title>Java: Good reasons to add method implementation to interface</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java:向接口添加方法实现的好理由</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-good-reasons-to-add-method-implementation-to-interface-744eb4717d7?source=collection_archive---------4-----------------------#2020-06-26">https://levelup.gitconnected.com/java-good-reasons-to-add-method-implementation-to-interface-744eb4717d7?source=collection_archive---------4-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="08e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过实现接口中定义的方法，创建更干净、更健壮的代码。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/86984d4bbf9cc977da1e9f40fbce5654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3hfFUJtLuU_Thp-D"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dorner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·多纳</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java和其他编程语言中定义的<em class="lv">接口</em>概念背后的思想是定义类必须实现或符合的契约或行为。通过定义一个<em class="lv">接口</em>，服务提供者可以列出一组需求，任何类都应该遵循这些需求来使用所提供的服务。</p><p id="6e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在2014年发布的Java 8之前的Java版本中，<em class="lv">接口</em>允许您定义方法签名和常量，而无需任何实现。符合特定接口的类为声明的方法提供了实际的实现。</p><p id="d137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一个具体的例子，为了能够使用<code class="fe lw lx ly lz b">Arrays</code>类的<code class="fe lw lx ly lz b">sort</code>方法对一组对象进行排序，所有的对象都必须为<code class="fe lw lx ly lz b">Comparable</code>接口提供一个实现</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="47c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在一个数组中存储了一个<code class="fe lw lx ly lz b">Vehicle </code>对象，要使用数组的排序方法，你必须实现这个<code class="fe lw lx ly lz b">Comparable </code>接口并提供实际的代码实现来执行<code class="fe lw lx ly lz b">Vehicle </code>对象的比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="0ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java 8和更高版本不仅仅允许您定义允许的方法签名，还允许您在接口定义中提供一些代码实现。例如，除了在<code class="fe lw lx ly lz b">Comparable </code>接口中定义<code class="fe lw lx ly lz b">compareTo(Object other);</code>声明之外，现在还允许在接口中提供实际的实现。</p><p id="5f2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你为什么需要这么做？为什么不在接口中定义可用操作列表和实现类中的实际实现之间保持严格的分离呢？</p><p id="e624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够在接口定义中提供代码实现可以产生不太复杂、更干净和更健壮的代码。有几种方法可以实现这一点。</p><h1 id="636c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通过静态方法降低复杂性</h1><p id="3d04" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通常情况下，作为服务提供者，当你为了访问某些特定的服务而提供需要符合的接口时，你还需要提供一些方法来提供与你所提供的服务相关的一些实用功能。</p><p id="a6fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循的方法是提供一个接口和另一个包含所需实用函数的实用类。任何需要这些服务的消费对象都需要首先符合接口，然后从附带的实用程序类中访问所需的功能。</p><p id="6f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更干净的方法可能是直接在接口中创建这些实用函数作为静态方法，这样就不再需要实用类了。</p><p id="a5e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java实现的<code class="fe lw lx ly lz b">Path</code>接口和相应的<code class="fe lw lx ly lz b">Paths </code>实用程序类中可以找到一个很好的例子</p><p id="d389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lw lx ly lz b">Path</code>接口代表了一个可以用来在文件系统中定位文件的对象，它由目录和文件名元素的层次序列组成。</p><p id="065e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java 11之前，配套的实用程序类Paths提供了<code class="fe lw lx ly lz b">get </code>方法，可用于从字符串或URI构建文件或目录的路径。</p><p id="786f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，从Java 11开始，这个功能现在是定义为静态方法的路径接口的一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="b23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此不再需要<code class="fe lw lx ly lz b">Paths </code>实用程序类。现在，您可以通过调用path接口的静态<code class="fe lw lx ly lz b">of </code>方法来构建路径</p><p id="4767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">Path.of(“/foo/bar/gus”)</code></p><p id="1d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，当您实现自己的接口时，您不需要为实用程序方法提供单独的伴生类，只需将这些方法作为静态类移动到接口中。这将确保您的代码不那么复杂，并且更加整洁。</p><h1 id="2362" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用默认方法的未来代码</h1><p id="45d2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设您提供了一些定义了接口的服务，几年后，您决定在发布新版本时向接口添加一些新方法。</p><p id="5ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样添加一个新方法会破坏实现您的接口的所有客户端代码，并且该类将不再编译，因为没有新方法的实现。</p><p id="6778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避免这种情况的方法是为任何接口方法提供默认实现。这被称为<em class="lv">接口进化</em>，它确保您能够在不破坏任何现有代码的情况下向您的接口定义添加新方法。</p><p id="741b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，考虑Java中定义的<code class="fe lw lx ly lz b">Iterable </code>接口。在Java 8中，更新了这个接口，并添加了一个新方法<code class="fe lw lx ly lz b">forEach </code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="ece2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样添加一个新方法会导致这个接口的所有实现类都无法编译，并出现编译错误。为了避免这个错误，这个方法被定义为一个默认方法，并且在接口定义代码中提供了一个默认实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h1 id="1cca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><p id="421b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">核心Java第1卷-基础，第11版</p><p id="28b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/14/docs/api/index.html" rel="noopener ugc nofollow" target="_blank"> Java平台版本14 API规范</a></p><h1 id="4d4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="31ca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">利用后Java 8的能力将代码实现添加到接口定义中有助于创建更干净和更健壮的代码。我试图分享一些例子和见解，以支持向接口添加代码实现。感谢您抽出时间阅读我的文章</p></div></div>    
</body>
</html>