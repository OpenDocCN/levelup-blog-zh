<html>
<head>
<title>Useful JavaScript Tips — This, Modules, and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的JavaScript技巧——This、模块和函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/useful-javascript-tips-this-modules-and-functions-c84b37fbac37?source=collection_archive---------25-----------------------#2020-06-23">https://levelup.gitconnected.com/useful-javascript-tips-this-modules-and-functions-c84b37fbac37?source=collection_archive---------25-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6850c6dd21f6476497be2923e5789a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o8fm2o6GpRNX0PUN"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@pafuxu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kouji鹤</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b11a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解一些应该遵循的技巧，以便更快更好地编写JavaScript代码。</p><h1 id="80b0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">返回对象以启用函数链</h1><p id="81e1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在方法中返回对象来链接函数。</p><p id="b623" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="eba4" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  height: 0,<br/>  width: 0,<br/>  setHeight(height) {<br/>    this.height = height;<br/>    return this;<br/>  },<br/>  setWidth(width) {<br/>    this.width = width;<br/>    return this;<br/>  }<br/>}</span></pre><p id="61f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过运行来调用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="77da" class="mq lf it mm b gy mr ms l mt mu">obj.setHeight(100).setWidth(300);</span></pre><p id="7c59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe mv mw mx mm b">obj.height</code>是100，<code class="fe mv mw mx mm b">obj.width</code>是300。</p><p id="529d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们也可以在课堂上这样做。</p><p id="4f4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6788" class="mq lf it mm b gy mr ms l mt mu">class Obj {<br/>  setHeight(height) {<br/>    this.height = height;<br/>    return this;<br/>  }</span><span id="e025" class="mq lf it mm b gy my ms l mt mu">  setWidth(width) {<br/>    this.width = width;<br/>    return this;<br/>  }<br/>}</span></pre><p id="ee62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4545" class="mq lf it mm b gy mr ms l mt mu">new Obj().setHeight(100).setWidth(300)</span></pre><h1 id="063d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">安全字符串串联</h1><p id="1b03" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">concat</code>方法来连接字符串。</p><p id="32a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4b3e" class="mq lf it mm b gy mr ms l mt mu">const one = 1;<br/>const two = 2;<br/>const three = '3';<br/>const result = ''.concat(one, two, three);</span></pre><p id="1ec3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mv mw mx mm b">result</code>是<code class="fe mv mw mx mm b">'123'</code>。</p><h1 id="6edc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">运行不需要的模块</h1><p id="4cfe" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以检查<code class="fe mv mw mx mm b">module.parent</code>属性，看看一个JavaScript文件是否被另一个文件所需要。</p><p id="b3af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dbe2" class="mq lf it mm b gy mr ms l mt mu">if (!module.parent) {<br/>  // run code ...<br/>} else {<br/>  module.exports = app;<br/>}</span></pre><p id="01d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe mv mw mx mm b">module.parent</code>是falsy，那么我们运行<code class="fe mv mw mx mm b">if</code>块中的代码。</p><p id="f87a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们导出模块成员，以便它们可以被需要。</p><h1 id="b5ce" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">向回调函数传递参数</h1><p id="1cec" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们创建一个函数返回包含参数的回调，我们可以将参数传递给回调函数。</p><p id="30ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5df6" class="mq lf it mm b gy mr ms l mt mu">const callback = (a, b) =&gt; {<br/>  return () =&gt; {<br/>    console.log(a + b);<br/>  }<br/>}</span></pre><p id="09c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ab03" class="mq lf it mm b gy mr ms l mt mu">const x = 1, y = 2;<br/>document.getElementById('foo').addEventListener('click', callback(x, y));</span></pre><p id="0408" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用了<code class="fe mv mw mx mm b">callback</code>来返回一个将两个参数相加的函数。</p><p id="68e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们可以在回调中包含这些参数。</p><h1 id="768a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用indexOf来检查是否包含了什么</h1><p id="1e1e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">indexOf</code>方法来检查一个字符串是否有子串。</p><p id="b41d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="af92" class="mq lf it mm b gy mr ms l mt mu">'something'.indexOf('thing') !== -1</span></pre><p id="83f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a6be" class="mq lf it mm b gy mr ms l mt mu">'something'.indexOf('thing') &gt;= 0</span></pre><p id="551f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">indexOf</code>如果没有找到子串，返回-1。</p><p id="8189" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果找到了，则返回子串的第一个索引。</p><p id="32dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以使用<code class="fe mv mw mx mm b">includes</code>方法来做同样的事情:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="914d" class="mq lf it mm b gy mr ms l mt mu">'something'.includes('thing');</span></pre><p id="9803" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果找到子串，则返回<code class="fe mv mw mx mm b">true</code>。</p><p id="f01e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，它会返回<code class="fe mv mw mx mm b">true</code>。</p><p id="1a8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样的方法也在数组中。</p><p id="0075" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="de48" class="mq lf it mm b gy mr ms l mt mu">['foo', 'bar'].indexOf('foo') !== -1</span></pre><p id="d2e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:“</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bbe9" class="mq lf it mm b gy mr ms l mt mu">['foo', 'bar'].indexOf('foo') &gt;= 0</span></pre><p id="625f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7b40" class="mq lf it mm b gy mr ms l mt mu">['foo', 'bar'].includes('foo')</span></pre><h1 id="a57e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">箭头功能</h1><p id="6918" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果函数不需要自己的<code class="fe mv mw mx mm b">this</code>，我们可以使用箭头函数来缩短代码。</p><p id="735f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="18f5" class="mq lf it mm b gy mr ms l mt mu">const squared = arr.map((x) =&gt; x ** 2);</span></pre><p id="03d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个单语句箭头函数的隐式返回。</p><p id="b2b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用它们要短得多。</p><p id="6b67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，<code class="fe mv mw mx mm b">bind</code>、<code class="fe mv mw mx mm b">call</code>或<code class="fe mv mw mx mm b">apply</code>不会与它们一起工作，因为它们没有自己的<code class="fe mv mw mx mm b">this</code>。</p><p id="7203" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不能在其中使用<code class="fe mv mw mx mm b">arguments</code>对象，但这并没有多大损失。</p><h1 id="f900" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">衡量我们代码的性能</h1><p id="8aa0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">console.time</code>和<code class="fe mv mw mx mm b">console.timeEnd</code>来衡量我们代码的性能。</p><p id="0495" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e956" class="mq lf it mm b gy mr ms l mt mu">console.time("populate array");<br/>let arr = Array(100),<br/>    len = arr.length,<br/>    i;<br/><br/>for (i = 0; i &lt; len; i++) {<br/>    arr[i] = new Object();<br/>};<br/>console.timeEnd("populate array");</span></pre><p id="db2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从<code class="fe mv mw mx mm b">console.time</code>开始测量。</p><p id="da23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们运行想要测量性能的代码。</p><p id="2b19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mv mw mx mm b">console.timeEnd</code>停止测量。</p><h1 id="c225" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使参数成为强制性的</h1><p id="ecbb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们在返回默认参数值的函数中抛出错误，我们可以将参数设置为强制参数。</p><p id="2d74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8c63" class="mq lf it mm b gy mr ms l mt mu">const err = ( message ) =&gt; {<br/>  throw new Error( message );<br/>}<br/><br/>const getSum = (a = err('a is required'), b = err('b is not required')) =&gt; a + b</span></pre><p id="548b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在分配默认参数值时调用函数。</p><p id="f6a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果没有通过运行<code class="fe mv mw mx mm b">err</code>函数设置错误，我们可以抛出错误。</p><p id="ec0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">err</code>仅在未设置参数时运行。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/88920a73c3b1f2cc51610fa02cba9a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*03ox11VpPmFq-Jqj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Vincent van Zalinge 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="3e0d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="aa8a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们在对象或类方法中返回<code class="fe mv mw mx mm b">this</code>,我们可以创建可链接的函数。</p><p id="7b56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果我们运行一个在赋值操作符右侧抛出错误的函数，我们可以确保参数被设置。</p></div></div>    
</body>
</html>