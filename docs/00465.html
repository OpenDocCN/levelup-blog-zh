<html>
<head>
<title>Simple bidirectional messaging in Node.js Worker Threads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js工作线程中的简单双向消息传递</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-bidirectional-messaging-in-node-js-worker-threads-7fe41de22e3c?source=collection_archive---------0-----------------------#2019-03-17">https://levelup.gitconnected.com/simple-bidirectional-messaging-in-node-js-worker-threads-7fe41de22e3c?source=collection_archive---------0-----------------------#2019-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c807" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">和你的工人说话，他们也会回嘴。</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi kg"><img src="../Images/31a6075598668f089ce530cfae8d5fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*8tMxKcygI8uCZsFIU2Rj7g.png"/></div></figure><h1 id="ebd5" class="ko kp iq bd kq kr ks kt ku kv kw kx ky jw kz jx la jz lb ka lc kc ld kd le lf bi translated">什么是工作线程？</h1><p id="4122" class="pw-post-body-paragraph lg lh iq li b lj lk jr ll lm ln ju lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">Node.js工作线程允许JavaScript代码的并发执行。如果您熟悉Unix线程模型，您会知道每个进程组都有一个<a class="ae mc" href="https://en.wikipedia.org/wiki/Parent_process#Unix-like_systems" rel="noopener ugc nofollow" target="_blank">父进程和几个</a>子进程。类似的模型用于工作线程，如下所示。</p><h2 id="00b5" class="md kp iq bd kq me mf dn ku mg mh dp ky lp mi mj la lt mk ml lc lx mm mn le mo bi translated">你为什么要用它们？</h2><p id="0269" class="pw-post-body-paragraph lg lh iq li b lj lk jr ll lm ln ju lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">如果您有几个CPU密集型任务需要完成，并且这些任务彼此独立运行，那么线程允许任务并行运行，从而节省时间。(您不需要工作线程来进行I/O处理——node . js非阻塞I/O模型已经很好地处理了这一点。)</p><p id="b2d2" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">例如，我一直在(缓慢地)为<a class="ae mc" href="http://wbec-ridderkerk.nl/html/UCIProtocol.html" rel="noopener ugc nofollow" target="_blank">通用国际象棋接口</a>(又名，UCI)开发一个<a class="ae mc" href="https://hackernoon.com/graphql-subscriptions-using-apollo-2-3eb3184768c4" rel="noopener ugc nofollow" target="_blank"> GraphQL </a> <a class="ae mc" href="https://medium.freecodecamp.org/wrapping-an-streaming-i-o-interface-in-graphql-931650dafd3b" rel="noopener ugc nofollow" target="_blank">包装器</a>。我想做的一件事是把几个象棋引擎放在一起，让它们独立运行。</p><h1 id="9868" class="ko kp iq bd kq kr ks kt ku kv kw kx ky jw kz jx la jz lb ka lc kc ld kd le lf bi translated">创建工作线程</h1><p id="715b" class="pw-post-body-paragraph lg lh iq li b lj lk jr ll lm ln ju lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">真的没什么！所需的只是高于10.5.0的节点版本。Node的10.x版本要求在命令行上传递<code class="fe mu mv mw mx b">--experimental-worker</code>标志，但是我运行的是11.11.0版本，不需要这么做。</p><p id="129c" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">以下是在文档的<a class="ae mc" href="https://nodejs.org/api/worker_threads.html#worker_threads_worker_threads" rel="noopener ugc nofollow" target="_blank">开头给出的工作线程示例:</a></p><pre class="kh ki kj kk gt my mx mz na aw nb bi"><span id="2ac5" class="md kp iq mx b gy nc nd l ne nf">const {<br/>  Worker, isMainThread, parentPort, workerData<br/>} = require('worker_threads');</span><span id="2e1e" class="md kp iq mx b gy ng nd l ne nf">if (isMainThread) {<br/>  module.exports = function parseJSAsync(script) {<br/>    return new Promise((resolve, reject) =&gt; {<br/>      const worker = new Worker(__filename, {<br/>        workerData: script<br/>      });<br/>      worker.on('message', resolve);<br/>      worker.on('error', reject);<br/>      worker.on('exit', (code) =&gt; {<br/>        if (code !== 0)<br/>          reject(new Error(`Worker stopped with exit code ${code}`));<br/>      });<br/>    });<br/>  };<br/>} else {<br/>  const { parse } = require('some-js-parsing-library');<br/>  const script = workerData;<br/>  parentPort.postMessage(parse(script));<br/>}</span></pre><p id="388a" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">不太令人兴奋，还有点神秘。从“worker_threads”导入的内容是:</p><ul class=""><li id="f448" class="nh ni iq li b lj mp lm mq lp nj lt nk lx nl mb nm nn no np bi translated"><strong class="li ir">工人</strong> : a类</li><li id="6264" class="nh ni iq li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated"><strong class="li ir"> isMainThread </strong>:如果这是主进程，则为真，否则为假</li><li id="44d7" class="nh ni iq li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated"><strong class="li ir"> parentPort </strong>:父节点和工作节点之间的通信端口</li><li id="3328" class="nh ni iq li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated"><strong class="li ir"> workerData </strong>:传递给线程的Worker构造函数的数据的克隆。</li></ul><p id="18af" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">这里，主线程导出一个方法，该方法获取一些JavaScript并将其交给工作线程进行处理。如果<strong class="li ir">是主线</strong>是真的，我们知道我们是主线。否则，我们就是工作线程(<strong class="li ir"> else{} </strong> block)，我们解析脚本并使用工作方法<strong class="li ir"> postMessage() </strong>将结果返回给父线程。</p><p id="e433" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">如果这仍然令人困惑，这里有一个<a class="ae mc" href="https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10#9fc1" rel="noopener ugc nofollow" target="_blank">到另一个例子</a>的链接，可能更容易理解。</p><h1 id="0274" class="ko kp iq bd kq kr ks kt ku kv kw kx ky jw kz jx la jz lb ka lc kc ld kd le lf bi translated">与工作线程对话</h1><p id="1dfc" class="pw-post-body-paragraph lg lh iq li b lj lk jr ll lm ln ju lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">到目前为止，worker收到的唯一数据是从构造函数参数发送的<strong class="li ir"> workerData </strong>。在上面的例子中，主线程从worker获得一条消息，这条消息是一些经过解析的JavaScript。</p><p id="da23" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">那是相当<em class="nv">无聊的</em>，尤其是因为工人，一旦它得到它的<strong class="li ir">工人数据</strong>:</p><ul class=""><li id="05e2" class="nh ni iq li b lj mp lm mq lp nj lt nk lx nl mb nm nn no np bi translated">做它的事情，</li><li id="4740" class="nh ni iq li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">将结果发送回主线程，</li><li id="e8e8" class="nh ni iq li b lj nq lm nr lp ns lt nt lx nu mb nm nn no np bi translated">退出。</li></ul><p id="362a" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">对于我计划中的象棋引擎工人来说，只要有游戏要设置，有棋要走，有象棋分析要做，就会有大量的交互(通过UCI)持续进行。我将在以后写这方面的细节，但是这篇文章的标题是“简单”，所以我将举例说明与一个基础工作者的双向交互。一、职工守则:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="447c" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">因此，除了“<strong class="li ir"> exit </strong>”之外，所有这些主要做的就是回显它给出的消息，我一会儿就会谈到这一点。</p><p id="c153" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">创建worker的主线程类似于前面提到的示例，但是不涉及承诺:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0019" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">需要注意的主要问题是，除了通过worker构造函数(即workerData)发送的消息之外，还有几条消息被发送到Worker。那么当我运行这个时会发生什么呢？</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/bfe012e2c0f1878494ee10819a2567fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*QsgKoaWAagVOkwROPvKGbQ.png"/></div></figure><p id="3a77" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">让我们将这些消息行与代码行对应起来:</p><p id="44b0" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><code class="fe mu mv mw mx b">{isMainThread: true}</code>来自index.js的第19行</p><p id="64ba" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><code class="fe mu mv mw mx b">{ incoming: { start: “let’s begin”, isMainThread: false } }</code>:service . js的第14行(工作线程)。</p><pre class="kh ki kj kk gt my mx mz na aw nb bi"><span id="44e7" class="md kp iq mx b gy nc nd l ne nf">{ incoming: { going: 'once' } }<br/>{ incoming: { going: 'twice' } }<br/>{ incoming: { going: 'three times' } }</span></pre><p id="e61b" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">这些都来自service.js的第10行</p><p id="080c" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><code class="fe mu mv mw mx b">{ incoming: ‘sold!’ }</code>是service.js的7号线</p><p id="c598" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><code class="fe mu mv mw mx b">Worker stopped with exit code 0</code>将我们带回index.js，第9行。</p><h2 id="b81a" class="md kp iq bd kq me mf dn ku mg mh dp ky lp mi mj la lt mk ml lc lx mm mn le mo bi translated">退出线程</h2><p id="bcd4" class="pw-post-body-paragraph lg lh iq li b lj lk jr ll lm ln ju lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我添加了从主线程中退出工作线程的功能。当主线程发布“<strong class="li ir"> exit </strong>”消息时，工作线程关闭端口。这在主线程中触发了一个退出事件，并记录了退出状态(第9行)。</p><p id="deba" class="pw-post-body-paragraph lg lh iq li b lj mp jr ll lm mq ju lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">如果您试图在工作人员退出后发布另一条消息，会发生什么情况？index.js的第14行试图做到这一点。请注意，该消息不会出现在控制台输出中。</p><h1 id="7e33" class="ko kp iq bd kq kr ks kt ku kv kw kx ky jw kz jx la jz lb ka lc kc ld kd le lf bi translated">搞定了。</h1><p id="7379" class="pw-post-body-paragraph lg lh iq li b lj lk jr ll lm ln ju lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">工作线程还有很多其他的东西，但这只是“简单”的概括。完整代码可以在<a class="ae mc" href="https://github.com/JeffML/workerthread2/tree/branch1" rel="noopener ugc nofollow" target="_blank"> <strong class="li ir">这里</strong> </a>找到。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><div class="kh ki kj kk gt og"><a href="https://gitconnected.com/learn/node-js" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">学习Node.js -最佳Node.js教程(2019) | gitconnected</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">排名前45的Node.js教程-免费学习Node.js。课程由开发人员提交和投票，使您能够…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">gitconnected.com</p></div></div><div class="op l"><div class="oq l or os ot op ou km og"/></div></div></a></div></div></div>    
</body>
</html>