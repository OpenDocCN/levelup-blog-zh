<html>
<head>
<title>How to Code Tic Tac Toe in Python using Tkinter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Tkinter在Python中编写井字游戏代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-code-tic-tac-toe-in-python-using-tkinter-e7f9ce510bfb?source=collection_archive---------0-----------------------#2021-03-16">https://levelup.gitconnected.com/how-to-code-tic-tac-toe-in-python-using-tkinter-e7f9ce510bfb?source=collection_archive---------0-----------------------#2021-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d819656fff1057d267bfd9c6d28a7241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P6qNOkBPR3SG6qwN.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图片来源:<a class="ae jd" href="https://en.wikipedia.org/wiki/File:Tic_tac_toe.svg" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/File:Tic_tac_toe.svg</a></figcaption></figure><div class=""/><p id="248e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将用一个漂亮的GUI来编写经典的纸笔游戏。我们将用Python对其进行编码，并将Tkinter用于接口。所以让我们开始吧！</p><h1 id="ce49" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">这是什么游戏？</h1><p id="5388" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">井字游戏是一种双人游戏，每位玩家都有一个符号(X或O ),轮流在一个<em class="me"> 3x3格子</em>上标记他们的符号。如果任何玩家在一行、一列或一条对角线上连续3次获得他们的符号，则该玩家获胜。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/c456924a24c8c1be964d69638e03df22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/0*u-yPdVHnYFnS_6ZN.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">样本网格-框中的数字仅供参考。</figcaption></figure><p id="7602" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在这里看到的，我们有一个3x3的网格。每位选手将轮流上场。假设参与人X先选择了盒子1。因此，网格[0][0]的值将为x。玩家O现在将进入下一个位置，如果他选择了盒子5，网格[1][1]的值将为O。这将持续到所有盒子都被填满或出现赢家。让我们看看获胜的条件是什么。</p><h1 id="5f10" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获胜条件</h1><p id="1305" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果任何3个连续的盒子有相同的值(X或O ),那么我们就有一个赢家。因此，我们总共有8个获胜条件——行3个，列3个，对角线2个。</p><h1 id="fe0c" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">行获胜条件</h1><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mk"><img src="../Images/66ad4a83c2ce08b938596e762f5edfdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6DAvgRLHm9ZzoQFx.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">行中标条件- X符号仅供参考</figcaption></figure><p id="b641" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">行获胜条件(X只是举例)</p><p id="5e4a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，条件的框值为:</p><ol class=""><li id="d13e" class="ml mm jg kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">1=2=3，即网格[0][0]=网格[0][1]=网格[0][2]</li><li id="d0cf" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">4=5=6，即网格[1][0]=网格[1][1]=网格[1][2]</li><li id="878f" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">7=8=9，即网格[2][0]=网格[2][1]=网格[2][2]</li></ol><h1 id="8219" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">栏目获奖条件</h1><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/ca9630ec1e536be5628ad56613f5bd4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gG3gOQ1r8_owrPHm.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">列中标条件- X仅供参考</figcaption></figure><p id="4dd9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，获胜条件的方框值为:</p><ol class=""><li id="f2dc" class="ml mm jg kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">1=4=7，即网格[0][0]=网格[1][0]=网格[2][0]</li><li id="0a9d" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">2=5=8，即网格[0][1]=网格[1][1]=网格[2][1]</li><li id="3cfa" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">3=6=9，即网格[0][2]=网格[1][2]=网格[2][2]</li></ol><h1 id="5d35" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对角获胜条件</h1><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b666c51c2e69438aec512160ba4ff0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/0*4Avr2SXxn5eUWfpC.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">对角线获胜条件— X仅供参考</figcaption></figure><p id="66b3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以获胜的条件是:</p><ol class=""><li id="7eae" class="ml mm jg kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">1=5=9，即网格[0][0]=网格[1][1]=网格[2][2]</li><li id="7ece" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">3=5=7，即网格[0][2]=网格[1][1]=网格[2][0]</li></ol><p id="e245" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在我们列出了所有的8个获胜条件。<strong class="kf jh">注意获胜条件的行和列值很重要，因为我们将在代码中使用它们。</strong></p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="63e0" class="lb lc jg bd ld le ni lg lh li nj lk ll lm nk lo lp lq nl ls lt lu nm lw lx ly bi translated">用Python编码</h1><p id="8767" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们将需要编码游戏的下列功能:</p><ol class=""><li id="ef9c" class="ml mm jg kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">游戏界面——一个用户可以玩游戏的窗口</li><li id="a5a1" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">检查赢家——在每一步棋之后，我们都需要检查赢家</li><li id="027c" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">更改值——每次移动后，我们都需要更新用户看到的GUI</li><li id="ae00" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">显示获胜者-显示获胜者的窗口</li><li id="259f" class="ml mm jg kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">退出-一个退出游戏的功能</li></ol><p id="bbe3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要做的第一件事是导入<em class="me"> tkinter </em>库<em class="me">。</em></p><p id="0fc5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们初始化两个重要的变量——count和board。</p><p id="fbe6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="me">计数</em>变量记录已经玩了多少次。每转一次，<em class="me">计数</em>变量增加1。</p><p id="f051" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如在获胜条件中看到的，我们有一个3x3的网格。在编码时，我们将把这个网格转换成一个名为<em class="me"> board </em>的二维数组，有3行3列。</p><pre class="mg mh mi mj gt nn no np nq aw nr bi"><span id="6f82" class="ns lc jg no b gy nt nu l nv nw">from tkinter import *<br/>from tkinter import messagebox<br/>count=0<br/>board=[[‘’,’’,’’,],<br/> [‘’,’’,’’,],<br/> [‘’,’’,’’,]]</span></pre><h1 id="42c3" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">TicTacToeGUI():游戏窗口</h1><p id="94bd" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们需要创建用户界面。为此，我们有一个函数TicTacToeGUI()。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/efe0513dc382487a77e1f68e7916ea78.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/0*JPBmv8S_P0VNFzW3.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">游戏窗口</figcaption></figure><p id="a8b2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有9个方形按钮，它们组合在一起形成一个方形矩阵。在顶部，我们将显示轮到哪个玩家了。第一个玩家是X，所以在顶部显示为<strong class="kf jh">玩家:1(X) </strong>。每走一步，玩家都会改变。所以在一个回合之后，顶部将会有<strong class="kf jh">玩家:2(O) </strong>。每当用户想退出时，我们还提供一个退出按钮。最初，按钮的文本值为空。每当用户点击一个按钮进行播放，按钮的文本就会变成玩家的值(X或O)。</p><p id="0cad" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了进行这种放置，我们将窗口的布局保持为网格的形式。第0行第0列有播放器，第0行第3列有退出按钮。接下来的3行和3列将有游戏按钮。</p><pre class="mg mh mi mj gt nn no np nq aw nr bi"><span id="4886" class="ns lc jg no b gy nt nu l nv nw">def TicTacToeGUI():<br/>    global t<br/>    t=Tk()<br/>    t.title("TIC TAC TOE")<br/>    t.configure(bg="white")  <br/>    #Making the background of the window as white#Displaying the player<br/>    l1=Label(t,text="PLAYER: 1(X)",height=3,font=("COMIC SANS MS",10,"bold"),bg="white")<br/>    l1.grid(row=0,column=0)#Quit button<br/>    exitButton=Button(t,text="Quit",command=Quit,font=("COMIC SANS MS",10,"bold"))<br/>    exitButton.grid(row=0,column=2)#Grid buttons<br/>    b1=Button(t,text="",height=4,width=8,bg="black",activebackground="white",fg="white",font="Times 15 bold",command=lambda: changeVal(b1,0,0))<br/>    b2=Button(t,text="",height=4,width=8,bg="black",activebackground="white",fg="white",font="Times 15 bold",command=lambda: changeVal(b2,0,1))<br/>    b3=Button(t,text="",height=4,width=8,bg="black",activebackground="white",fg="white",font="Times 15 bold",command=lambda: changeVal(b3,0,2))<br/>    b4=Button(t,text="",height=4,width=8,bg="black",activebackground="white",fg="white",font="Times 15 bold",command=lambda: changeVal(b4,1,0))<br/>    b5=Button(t,text="",height=4,width=8,bg="black",activebackground="white",fg="white",font="Times 15 bold",command=lambda: changeVal(b5,1,1))<br/>    b6=Button(t,text="",height=4,width=8,bg="black",activebackground="white",fg="white",font="Times 15 bold",command=lambda: changeVal(b6,1,2))<br/>    b7=Button(t,text="",height=4,width=8,bg="black",activebackground="white",fg="white",font="Times 15 bold",command=lambda: changeVal(b7,2,0))<br/>    b8=Button(t,text="",height=4,width=8,bg="black",activebackground="white",fg="white",font="Times 15 bold",command=lambda: changeVal(b8,2,1))<br/>    b9=Button(t,text="",height=4,width=8,bg="black",activebackground="white",fg="white",font="Times 15 bold",command=lambda: changeVal(b9,2,2))b1.grid(row=2,column=0)<br/>b2.grid(row=2,column=1)<br/>b3.grid(row=2,column=2)b4.grid(row=3,column=0)<br/>b5.grid(row=3,column=1)<br/>b6.grid(row=3,column=2)b7.grid(row=4,column=0)<br/>b8.grid(row=4,column=1)<br/>b9.grid(row=4,column=2)</span></pre><p id="ec54" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，我们有9个按钮b1、b2、b3、b4、b5、b6、b7、b8、b9，窗口<em class="me"> t </em>是网格格式。您可以将按钮编号及其行和列值与我们在上面看到的示例网格中给出的编号相关联。</p><p id="b5f4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按钮的初始文本值为空白，高度为4，宽度为8。背景颜色为黑色，文本为白色。活动背景是白色的，即当我们点击一个按钮时，颜色变成白色。</p><p id="b44b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每点击一个按钮，就会调用一个函数changeVal。对此的陈述是:command=lambda:changeVal()。</p><h1 id="257d" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">changeVal():改变按钮的值并更新面板</h1><p id="e72f" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每当玩家点击按钮时，我们需要改变按钮的文本，并在板上添加玩家的符号。changeVal函数正是这样做的。该函数的参数有<em class="me">按钮、boardValRow、boardValCol </em>对应的按钮变量、按钮所在行的值和按钮所在列的值。</p><pre class="mg mh mi mj gt nn no np nq aw nr bi"><span id="3aa5" class="ns lc jg no b gy nt nu l nv nw">#Changes the value of the button<br/>def changeVal(button,boardValRow,boardValCol):<br/>    global count#Checking if button is available<br/>    if button["text"]=="":<br/>        if count%2==0:<br/>            button["text"]="X"<br/>            l1=Label(t,text="PLAYER: 2(O)",height=3,font=("COMIC <br/>               SANS MS",10,"bold"),bg="white").grid(row=0,column=0)<br/>            board[boardValRow][boardValCol]="X"<br/>        else:<br/>            button["text"]="O"<br/>            l1=Label(t,text="PLAYER: 1(X)",height=3,font=("COMIC<br/>               SANS MS",10,"bold"),bg="white").grid(row=0,column=0)<br/>            board[boardValRow][boardValCol]="O"<br/>        count=count+1<br/>        if count&gt;=5:<br/>            checkWinner()<br/>    else:<br/>        messagebox.showerror("Error","This box already has a value!")</span></pre><p id="336a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在改变按钮的文本之前，我们需要检查按钮是否可用，因为有时用户可能会意外地点击已经播放过的按钮。所以我们首先检查按钮文本值是否为空。如果不是，则显示一个错误。</p><p id="897c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果按钮可用，我们将显示玩家的符号。为了检查轮到哪个玩家，我们使用了<em class="me"> count </em>变量。如上所述，在每一轮之后，我们增加<em class="me">计数</em>变量，每个玩家交替游戏。因此，每当<em class="me">计数</em>为偶数时，将轮到玩家X，每当该值为奇数时，将轮到玩家O。因此，根据玩家的不同，我们改变按钮的文本，然后我们还必须更新下一个轮到哪个玩家。所以每当我们改变一个按钮的值为X，我们显示下一个玩家是O，反之亦然。</p><p id="08b3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始时，我们制作了一个2D阵列<em class="me">板</em>，它是实际板的代表。所以每次回合后，每当我们改变一个按钮的值，我们也改变<em class="me">棋盘</em>数组。我们使用变量boardValRow和boardValCol来访问数组，并将值更改为符号:board[board valrow][board valcol]= symbol。</p><p id="6570" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经完成了必要的更改，我们将count递增1，并调用check winner函数来查看是否有任何获胜者。对于一个赢家来说，一个玩家必须至少玩过3次。由于一名玩家在每轮交替后开始游戏，前4轮没有赢家，所以我们在<em class="me">计数≥5 </em>后调用检查赢家函数。</p><h1 id="25f1" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">checkWinner():检查获胜者</h1><p id="0414" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在这个函数中，我们基本上检查了我们在上面部分(获胜条件)中详细看到的获胜条件的所有棋盘值。我们对这两个符号进行检查。</p><p id="09ba" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">平手条件</strong>:当所有9个位置都被选中，仍然没有获胜者时，将出现平手。所以当变量<em class="me">计数</em>为9时，就会出现平局。</p><p id="01ca" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用函数displayWinner来显示获胜者，或者如果是平局。</p><pre class="mg mh mi mj gt nn no np nq aw nr bi"><span id="33fd" class="ns lc jg no b gy nt nu l nv nw">#Checks for the winner        <br/>def checkWinner():<br/>    global count,board<br/>    if (board[0][0]==board[0][1]==board[0][2]=="X" or board[1]<br/>        [0]==board[1][1]==board[1][2]=="X" or board[2][0]==board[2]<br/>        [1]==board[2][2]=="X" or board[0][0]==board[1][0]==board[2]<br/>        [0]=="X" or board[0][1]==board[1][1]==board[2][1]=="X" or <br/>        board[0][2]==board[1][2]==board[2][2]=="X" or<br/>        board[0][0]==board[1][1]==board[2][2]=="X" or board[0]<br/>        [2]==board[1][1]==board[2][0]=="X"):<br/>            displayWinner("Player X")<br/>    elif (board[0][0]==board[0][1]==board[0][2]=="O" or board[1]<br/>          [0]==board[1][1]==board[1][2]=="O" or board[2][0]     <br/>           ==board[2][1]==board[2][2]=="O" or<br/>          board[0][0]==board[1][0]==board[2][0]=="O" or board[0]  <br/>          [1]==board[1][1]==board[2][1]=="O" or board[0]<br/>          [2]==board[1][2]==board[2][2]=="O" or board[0]<br/>          [0]==board[1][1]==board[2][2]=="O" or board[0]<br/>          [2]==board[1][1]==board[2][0]=="O"):<br/>            displayWinner("Player O")<br/>    elif count==9:<br/>        displayWinner("NONE! IT IS A TIE!")</span></pre><p id="7c25" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="me"> if </em>条件与我们上面看到的条件完全相同，但是如果您愿意，您可以使用<em class="me"> for </em>循环来循环通过电路板。</p><h1 id="c698" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">displayWinner():在新窗口中显示赢家/平局</h1><p id="1cdd" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这个函数有一个winner参数，带有winner符号。我们创建一个新窗口，显示获胜者或平局。</p><p id="660c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个按钮进行，点击后将调用破坏功能，这将破坏游戏窗口和赢家窗口。</p><pre class="mg mh mi mj gt nn no np nq aw nr bi"><span id="2732" class="ns lc jg no b gy nt nu l nv nw">#Displays the winning condition<br/>def displayWinner(winner):<br/>    global t,winnerWindow,ID    <br/>    winnerWindow=Tk()<br/>    winnerWindow.title("Winner Window")<br/>    winnerWindow.configure(bg="Black")<br/>    l1=Label(winnerWindow,text="THE WINNER IS: ",font=("COMIC SANS <br/>    MS",15),bg="Black",fg="White")<br/>    l1.pack()<br/>    l2=Label(winnerWindow,text=winner,font=("COMIC SANS <br/>    MS",15),bg="Black",fg="White")<br/>    l2.pack()<br/>    bproceed=Button(winnerWindow,text="Proceed",font=("COMIC SANS <br/>    MS",10,"bold"),command=destruct)<br/>    bproceed.pack()</span></pre><h1 id="9c5e" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">destruct():破坏游戏和赢家窗口</h1><pre class="mg mh mi mj gt nn no np nq aw nr bi"><span id="0831" class="ns lc jg no b gy nt nu l nv nw">#Destructs the winner window and game window<br/>def destruct():<br/> global t,winnerWindow<br/> t.destroy()<br/> winnerWindow.destroy()</span></pre><h1 id="4659" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Quit():结束游戏</h1><p id="2a24" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在GUI函数中，我们有一个名为<em class="me">的按钮。</em>此功能会破坏游戏窗口，但在此之前会确认用户是否仍想退出。如果用户说是，那么我们破坏游戏。我们使用<em class="me"> messagebox </em>库来显示消息</p><pre class="mg mh mi mj gt nn no np nq aw nr bi"><span id="2a63" class="ns lc jg no b gy nt nu l nv nw">def Quit():<br/> global t <br/> msg=messagebox.askquestion(“Confirm”,”Are you want to Quit? You still have chances!”)<br/> if msg==’yes’:<br/> t.destroy()</span></pre></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="a18d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是游戏的一些截图:</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/90acbb1d5b19f30a013a07e1d55561b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XNTpZcREP7uRIGLk.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">在第一个图像中，轮到X了，因此在顶部显示玩家:1(X)。在第二个图像中，X播放，在第三个图像中，O播放。</figcaption></figure><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/4ae4f277f5d37802783c45ae7c048363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jAcFqFo5K5UyRak4.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">在第一幅图像中，X再次游戏，在第二幅图像中，O游戏，在最后一幅图像中，X游戏并获胜。</figcaption></figure><p id="f4aa" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，获胜者将显示在另一个窗口中。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/51d35747394880f5a36df34b0a8e7de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/0*Uata86zsDYmRP-QJ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Winner窗口</figcaption></figure><p id="bfaf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里查看完整的代码:</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div></div>    
</body>
</html>