<html>
<head>
<title>Hello World!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你好世界！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/hello-world-70a51f449d9f?source=collection_archive---------18-----------------------#2022-06-10">https://levelup.gitconnected.com/hello-world-70a51f449d9f?source=collection_archive---------18-----------------------#2022-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f73d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">程序输出“Hello World！”不使用打印方法</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/b45c36010691bb990cd4199363441563.png" data-original-src="https://miro.medium.com/v2/0*EXwqtb9h7Qv7EnVy"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">照片由<a class="ae kr" href="https://unsplash.com/@lemonvlad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗拉季斯拉夫·克拉平</a>在<a class="ae kr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5a60" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你好世界！我相信这是一个普通的编程初学者第一次尝试用某种编程语言编码时会看到的。</p><p id="7bcf" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因为这也是我在Medium的第一篇文章，我也想说<code class="fe lo lp lq lr b">Hello world!</code>！</p><p id="5b29" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">作为一个C/C++程序员，一个简单的程序如下:</p><pre class="kf kg kh ki gt ls lr lt lu aw lv bi"><span id="6e8a" class="lw lx iq lr b gy ly lz l ma mb">#include &lt;iostream&gt;<br/><br/>int main(int argc, char **argv) { <br/>  std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl; <br/>  return 0;<br/>}</span></pre><p id="74c3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">会提供输出</p><pre class="kf kg kh ki gt ls lr lt lu aw lv bi"><span id="c2f9" class="lw lx iq lr b gy ly lz l ma mb">Hello world!</span></pre><p id="13e8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然而，如果我们只能通过使用上面的示例来产生输出，那就太无聊了，尤其是在C/C++的世界中，我们应该知道代码背后的所有细节。</p><p id="5920" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为此，我们将使用内联汇编语言在裸机版本中编译代码。</p><h2 id="f6a6" class="lw lx iq bd mc md me dn mf mg mh dp mi lb mj mk ml lf mm mn mo lj mp mq mr ms bi translated">内嵌汇编语言</h2><p id="74fe" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">其中一个方法是有如下的<code class="fe lo lp lq lr b">helloworld.c</code></p><pre class="kf kg kh ki gt ls lr lt lu aw lv bi"><span id="629d" class="lw lx iq lr b gy ly lz l ma mb">int main(void) {<br/>  register int    syscall_no  asm("rax") = 1;<br/>  register int    arg1        asm("rdi") = 1;<br/>  register char*  arg2        asm("rsi") = "Hello world!\n";<br/>  register int    arg3        asm("rdx") = 13;<br/>  asm("syscall");<br/>  return 0;<br/>}</span></pre><ul class=""><li id="25ff" class="my mz iq ku b kv kw ky kz lb na lf nb lj nc ln nd ne nf ng bi translated">系统调用号被存入寄存器<code class="fe lo lp lq lr b">rax</code></li><li id="bdf6" class="my mz iq ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">其余的自变量被放入寄存器<code class="fe lo lp lq lr b">rdi</code>、<code class="fe lo lp lq lr b">rsi</code>和<code class="fe lo lp lq lr b">rdx</code></li><li id="a792" class="my mz iq ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">%rdi、%rsi、%rdx、%rcx、%r8和%r9用于将前六个整数或指针参数传递给被调用的函数</li></ul><p id="60c6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">换句话说，上面的代码正在执行</p><pre class="kf kg kh ki gt ls lr lt lu aw lv bi"><span id="508c" class="lw lx iq lr b gy ly lz l ma mb">write(STDOUT_FILENO,<br/>   "Hello world!\n",<br/>   sizeof("Hello world!\n")<br/>);</span></pre><h2 id="d6ff" class="lw lx iq bd mc md me dn mf mg mh dp mi lb mj mk ml lf mm mn mo lj mp mq mr ms bi translated">在Linux x86-x64下运行代码</h2><pre class="kf kg kh ki gt ls lr lt lu aw lv bi"><span id="9a6f" class="lw lx iq lr b gy ly lz l ma mb">$ gcc -o helloworld helloworld.c<br/>$ ./helloworld</span></pre><h2 id="3984" class="lw lx iq bd mc md me dn mf mg mh dp mi lb mj mk ml lf mm mn mo lj mp mq mr ms bi translated">无主程序</h2><p id="5c34" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">为了更有趣，我们将编写没有<code class="fe lo lp lq lr b">main</code>的代码，姑且称之为<code class="fe lo lp lq lr b">nomain</code>程序</p><p id="b423" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">该计划的切入点将是</p><pre class="kf kg kh ki gt ls lr lt lu aw lv bi"><span id="f1eb" class="lw lx iq lr b gy ly lz l ma mb">void nomain() {<br/>  print();<br/>  exit();<br/>}</span></pre><p id="154a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe lo lp lq lr b">print</code>和<code class="fe lo lp lq lr b">exit</code>功能的位置</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b1ce" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">打印功能与刚才描述的示例类似。对于<code class="fe lo lp lq lr b">exit()</code>函数，它正在执行的系统调用</p><pre class="kf kg kh ki gt ls lr lt lu aw lv bi"><span id="785c" class="lw lx iq lr b gy ly lz l ma mb">exit(EXIT_SUCCESS);</span></pre><p id="bf8e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">返回代码为<strong class="ku ir"> 0 </strong>，而<strong class="ku ir"> 60 </strong>是<code class="fe lo lp lq lr b">exit</code>的系统调用号</p><p id="acb1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">要检查返回代码，我们可以键入</p><pre class="kf kg kh ki gt ls lr lt lu aw lv bi"><span id="03d3" class="lw lx iq lr b gy ly lz l ma mb">$ echo $?</span></pre><p id="cc87" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">执行完可执行文件后。</p><h2 id="d0b1" class="lw lx iq bd mc md me dn mf mg mh dp mi lb mj mk ml lf mm mn mo lj mp mq mr ms bi translated">Linux x86-x64下正常代码的运行</h2><pre class="kf kg kh ki gt ls lr lt lu aw lv bi"><span id="d2b3" class="lw lx iq lr b gy ly lz l ma mb">$ gcc -c -fno-builtin helloworld.c<br/>$ ld -static -e nomain -o helloworld helloworld.o<br/>$ ./helloworld</span></pre><ul class=""><li id="2c64" class="my mz iq ku b kv kw ky kz lb na lf nb lj nc ln nd ne nf ng bi translated"><strong class="ku ir"> GCC </strong>已经提供了很多内置函数，通常为了优化的目的，它会用编译器的内部函数来代替C函数。例如，如果在<code class="fe lo lp lq lr b">printf</code>函数中只涉及字符串，它将被替换为<code class="fe lo lp lq lr b">puts</code>函数，以节省格式解释的时间。<code class="fe lo lp lq lr b">exit()</code>函数是<strong class="ku ir"> GCC </strong>的内部函数之一，因此我们必须设置<code class="fe lo lp lq lr b">no-builtin</code>标志来禁用内置函数</li><li id="f241" class="my mz iq ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">然后通过<code class="fe lo lp lq lr b">-e nomain</code>配置入口点</li></ul><p id="8122" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">感谢阅读我的第一篇文章，希望你喜欢阅读！</p></div></div>    
</body>
</html>