<html>
<head>
<title>Customising link behaviour using JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript定制链接行为</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/customising-link-behaviour-using-javascript-37658b35eea0?source=collection_archive---------11-----------------------#2020-10-28">https://levelup.gitconnected.com/customising-link-behaviour-using-javascript-37658b35eea0?source=collection_archive---------11-----------------------#2020-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3dc2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">偏好管理的静态站点方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1925cf6677e851a3767938eeadaca42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uazGGIF-icdA4cqw"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·巴巴利斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="bed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个新窗口中打开链接——或者二十年来最好的一个新标签——一直是一个热点问题。许多作者认为这样做是明智的，目的是“让读者留在你的页面/网站上”，而可用性从业者对他们所认为的恼人的、违反直觉的、忽视用户意愿的行为感到绝望。在<a class="ae ky" href="https://uxdesign.cc/linking-to-a-new-tab-vs-same-tab-f88b495d2187" rel="noopener" target="_blank">链接到新标签与同一个标签</a>、<a class="ae ky" href="https://medium.com/@summertimecoolj" rel="noopener">中，杰西·萨默斯</a>认为:</p><blockquote class="lv lw lx"><p id="6daa" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">如果用户点击一个链接，他们不应该对发生的事情感到惊讶。</p></blockquote><p id="35f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我基本同意。当然也有例外，但是总的来说，web的默认设置总是用链接的目标来替换页面，这种期望应该保持下去。</p><p id="af75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">话虽如此，用户有不同的偏好，因此浏览器通常会提供不同的行为。根据具体情况，Chrome允许我在新的标签页或窗口中打开链接，但这是一个笨拙的操作:右键单击，从上下文菜单中选择选项。如果我们可以在我们网站的所有页面上为用户提供一些简单的自定义行为，会怎么样？</p><h1 id="e9b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">客户端定制</h1><p id="53be" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">真的，我只是在这里建立一个更广泛的话题的讨论。虽然如果你愿意的话，你可以专门关注链接目标的问题，但我想探讨一下静态网站如何实现定制化这个更普遍的问题。</p><p id="6a61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，当面临这样的需求时，动态站点会直接访问数据库:登录的用户可以选择某些设置，他们的选择存储在服务器端，并在每次访问页面时读取，或者可能在第一次登录时读取。</p><p id="e391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这种方法可行——甚至可能有一两个优点——但对于静态站点来说是不可用的。我们需要找到我们的老朋友JavaScript，看看我们可以在客户端的静态页面上添加什么功能。</p><h2 id="39ad" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">静态设置的蓝图</h2><p id="d36b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这里有一个我们可以用来处理静态站点设置的通用方法:</p><ol class=""><li id="eac5" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">创建一个使用JavaScript处理的通用设置表单。不言而喻，该表单是通过<a class="ae ky" href="https://medium.com/remys-blog/progressive-enhancement-bec78a083763" rel="noopener">渐进增强</a>提供的(如链接到)。</li><li id="1f0c" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">在提交时，表单应该通过JavaScript更新<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank"> localStorage </a>中的设置。我目前正在改进我用来在本地存储数据的模式，但是基本方法非常简单，我很快就会谈到。</li><li id="95bd" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">在适当的情况下，使用JavaScript检查localStorage中的设置，并采取相应的措施。在链接示例中，这将涉及到向外部链接添加一个适当的<code class="fe nz oa ob oc b">target</code>属性。</li></ol><p id="b1a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样:非常快速简单。</p><h2 id="e12e" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">利益</h2><ol class=""><li id="023a" class="nl nm it lb b lc mu lf mv li od lm oe lq of lu nq nr ns nt bi translated"><strong class="lb iu">读写设置非常快</strong> —无需往返服务器，一切都通过本地存储</li><li id="a747" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu">读写设置简单</strong>。即使你用这些设置做的事情最终变得稍微复杂一点，与建立一个数据库和编写SQL相比，在localStorage中存储JSON还是轻而易举的。</li><li id="e2d6" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu">没有用户数据被发送到服务器</strong>。就隐私问题而言，偏好的风险相当低，但从更大的角度考虑:这种方法也可以用于更敏感的数据。</li><li id="2073" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu">无需注册</strong>。无论是特定站点注册，还是第三方登录，当数据仅在客户端存储和使用时，用户身份验证都是一个根本不存在的障碍。</li></ol><h2 id="ad75" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">缺点</h2><ol class=""><li id="8741" class="nl nm it lb b lc mu lf mv li od lm oe lq of lu nq nr ns nt bi translated"><strong class="lb iu">持久性</strong>。理论上，本地存储是临时的——如果用户擦除了他们的硬盘，他们就会丢失那些数据。实际上，我认为这并不重要，因为网站的首选项设置值很低，但是如果对其他类型的数据使用相同的技术，您可能需要记住这一点。</li><li id="d2a3" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu">加工速度</strong>。一旦我们从服务器获得了“应用设置”页面，就这样，我们就完成了。客户端处理和应用设置很可能会导致<em class="ly">非常小的</em>延迟，但是首先考虑一下服务器更快的响应所带来的好处几乎肯定会超过延迟。</li></ol><h1 id="8fdc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将这些原则应用于链接打开</h1><p id="49fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">以下是处理“链接打开”首选项设置的一个非常基本的设置。我将允许用户保持默认设置(所有链接都在同一个页面中打开)，或者每次在一个全新的选项卡中打开外部链接，或者为此目的保留同一个选项卡。</p><p id="50ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你愿意，你可以先在我自己的网站上看到这一点；表单下方有一个外部链接，您可以使用它来查看不同的行为。</p><p id="36c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">为了可读性，本文中的代码示例包含了减少代码行长度的最小重写。它们在功能上与实时代码相同，但是您可能想要参考下面链接的实时版本。</em></p><h2 id="1935" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">设置表单的标记</h2><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="ad36" class="mz md it oc b gy ok ol l om on">&lt;form id="settings" method="get" action="<strong class="oc iu">/no-javascript</strong>"&gt;<br/>    &lt;label&gt;<br/>        &lt;input type="radio" name="links" value=""<br/>            checked="checked" /&gt;<br/>        Open all links in the original tab<br/>    &lt;/label&gt;</span><span id="7e88" class="mz md it oc b gy oo ol l om on">    &lt;label&gt;<br/>        &lt;input type="radio" <strong class="oc iu">name="links" value="external"</strong> /&gt;<br/>        Open external links in the same new tab<br/>    &lt;/label&gt;</span><span id="193e" class="mz md it oc b gy oo ol l om on">    &lt;label&gt;<br/>        &lt;input type="radio" name="links" value="_blank" /&gt;<br/>        Open each external link in a separate new tab<br/>    &lt;/label&gt;</span><span id="bf1b" class="mz md it oc b gy oo ol l om on">    &lt;button type="submit"&gt;Save&lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="91cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将表单的动作设置为一个URL ( <code class="fe nz oa ob oc b"><strong class="lb iu">/no-javascript</strong></code>)，理论上，我可以用它来通知读者这个过程需要JavaScript。实际上，如果您使用 JavaScript注入这个标记<em class="ly">，那就没有必要了。用户在收到标记后仍然可以禁用JavaScript(不太可能)，或者错误会导致提交处理程序失败(更有可能)，因此构建一个后备肯定没有坏处。</em></p><p id="f09c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个无线电输入仍然有一个有效的<code class="fe nz oa ob oc b"><strong class="lb iu">name</strong></code>和<code class="fe nz oa ob oc b"><strong class="lb iu">value</strong></code>，即使数据不会以传统方式提交。这有利于我们内心的平静，但是，正如我们马上会看到的，这通常是实现我们最终目标的最简单的方式，即使我们没有使用浏览器提供的默认表单处理机制。如果我们<em class="ly">可以</em>在服务器端提交上做一些合理的事情，这就更加重要了，所以我们不妨养成这个习惯。</p><h2 id="3a7c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">处理设置表单的JavaScript</h2><p id="dc2f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在静态站点上，表单必须在客户端处理。在这种情况下，这意味着处理表单提交以及表单的初始设置以反映当前设置。原代码见<code class="fe nz oa ob oc b"><a class="ae ky" href="https://bobbyjack.me/js/settings-form.js" rel="noopener ugc nofollow" target="_blank">settings-form.js</a></code>。</p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="309b" class="mz md it oc b gy ok ol l om on">var formElement = document.getElementById("settings");</span><span id="d63d" class="mz md it oc b gy oo ol l om on"><em class="ly">// Save form data to localStorage on submission</em> <br/>formElement.addEventListener("submit", function(ev) {<br/>    var sel = "<strong class="oc iu">#settings [name='links']:checked</strong>";<br/>    var node = document.<strong class="oc iu">querySelector</strong>(sel);</span><span id="3e4e" class="mz md it oc b gy oo ol l om on">    settings.data.links = node.getAttribute("value");<br/>    localStorage.setItem("settings", <strong class="oc iu">JSON.stringify(settings)</strong>);</span><span id="ad84" class="mz md it oc b gy oo ol l om on">    window.alert("saved");<br/>    window.location.reload();<br/>    ev.preventDefault();<br/>});</span><span id="4beb" class="mz md it oc b gy oo ol l om on">var sel2 = "input[name='links']";</span><span id="01b2" class="mz md it oc b gy oo ol l om on"><em class="ly">// Ensure form inputs reflect current settings</em><br/>formElement.querySelectorAll(sel2).forEach(function(node) {<br/>    if (settings.data.links == node.getAttribute("value")) {<br/>        node.setAttribute("checked", "checked");<br/>    } else {<br/>        node.removeAttribute("checked");<br/>    }<br/>});</span></pre><p id="f686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe nz oa ob oc b"><strong class="lb iu">querySelector</strong></code>使用CSS选择器，识别当前选中的单选按钮。<code class="fe nz oa ob oc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:checked" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">:checked</strong></a></code>是一个非常方便的伪类。注意这个有限的表单目前只处理<code class="fe nz oa ob oc b"><strong class="lb iu">name='links'</strong></code> <strong class="lb iu"> </strong>输入；对于更复杂的形式，这将进一步推广。</p><p id="0d68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我重用了一种标准技术来将结构化数据存储在localStorage中，并通过<code class="fe nz oa ob oc b"><strong class="lb iu">JSON.stringify()</strong></code>将其转换成JSON。下面介绍<code class="fe nz oa ob oc b"><strong class="lb iu">settings</strong></code>的结构。</p><p id="80bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存设置后，使用<code class="fe nz oa ob oc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Location/reload" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">window.location.reload()</strong></a></code>重新加载页面。这是一种简单廉价的方式，可以确保我们正在查看的页面上的所有链接都按照新的设置进行更新。</p><p id="6723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，当这个脚本被加载时，有一个小的进程开始运行，根据现有的设置值选择适当的单选按钮。</p><p id="3002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码非常接近于能够处理任何通用的“设置”表单；但是，这需要理解为各种类型的设置提供哪种类型的HTML表单输入，这超出了本文的范围。</p><h2 id="0a89" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">应用链接设置的JavaScript</h2><p id="2238" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在有了一种更新设置的方法，它们只需要被执行。当然，这将取决于每个环境的性质，但有一些共性。在URL设置的情况下，这完全是关于目标属性的。原代码见<code class="fe nz oa ob oc b"><a class="ae ky" href="https://bobbyjack.me/js/settings.js" rel="noopener ugc nofollow" target="_blank">settings.js</a></code>。</p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="005c" class="mz md it oc b gy ok ol l om on">var <strong class="oc iu">default_settings</strong> = {<br/>    "version": 1.0,<br/>    "data": {<br/>        "links": ""<br/>    }<br/>};</span><span id="d2a8" class="mz md it oc b gy oo ol l om on">var settings = JSON.parse(localStorage.getItem("settings"))<br/>    || default_settings;</span><span id="f9cd" class="mz md it oc b gy oo ol l om on">if (<strong class="oc iu">settings.data.links</strong>) {<br/>    document.querySelectorAll("a").forEach(function(node) {<br/>        var href = node.getAttribute("href");<br/>        var url = new URL(href, window.location);</span><span id="f3f3" class="mz md it oc b gy oo ol l om on">        if (<strong class="oc iu">window.location.origin</strong> != url.origin) {<br/>            node.setAttribute("target", <strong class="oc iu">settings.data.links</strong>);<br/>        }<br/>    });<br/>}</span></pre><p id="5d92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b"><strong class="lb iu">default_settings</strong></code>结构用于在设置任何设置之前处理初始情况；如果localStorage中没有任何内容，那么就使用它。我目前正在试验这种结构在一般情况下的格式，但是我计划将来使用一个<code class="fe nz oa ob oc b"><strong class="lb iu">version</strong></code>属性，这样如果需要的话，localStorage结构以后可以被“升级”。</p><p id="684b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意(参考原始标记),我对<code class="fe nz oa ob oc b"><strong class="lb iu">settings.data.links</strong></code>使用的值可以直接转化为<code class="fe nz oa ob oc b">target</code>属性的可用值。这避免了任何一种尴尬的“<code class="fe nz oa ob oc b">if (setting == "new_window") { ... } </code>”条件。</p><p id="3b1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用<code class="fe nz oa ob oc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Location/origin" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">window.location.origin</strong></a></code>来确定链接是否是“外部”的。这是一个相当现代的添加，但是大多数浏览器都支持它，并且极大地简化了这个过程。</p><h1 id="74f9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="ee4f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这就是我处理客户端定制的蓝图。当然，使用这种方法有更多的可能性，甚至仅仅考虑一下可以用超链接做什么:</p><ul class=""><li id="140a" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu op nr ns nt bi translated">允许用户选择特定位置的首选站点(可能通过地理定位api 的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API" rel="noopener ugc nofollow" target="_blank">默认)并相应地修改链接目的地(例如nintendo.co.uk对nintendo.com)</a></li><li id="8116" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu op nr ns nt bi translated">如果用户更喜欢下载而不是在浏览器中查看，自动为pdf链接添加一个<code class="fe nz oa ob oc b">download</code>属性</li><li id="bcb9" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu op nr ns nt bi translated">将每个链接的<code class="fe nz oa ob oc b">href</code>直接注入到文档中(使用CSS很好地设计了样式)，这样它们就可见了——如果用户选择格外警惕的话</li></ul><p id="5931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我真的很喜欢在客户端处理网站定制的想法，只要有可能。它很快，很简单，这意味着我们的读者掌握着他们的数据，所以我们的服务器永远不需要担心存储它，它首先更隐私。</p></div></div>    
</body>
</html>