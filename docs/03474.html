<html>
<head>
<title>Hello Elixir!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你好灵丹妙药！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/hello-elixir-c7e49f7624e8?source=collection_archive---------9-----------------------#2020-05-11">https://levelup.gitconnected.com/hello-elixir-c7e49f7624e8?source=collection_archive---------9-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4011" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">介绍市场上最激动人心的后端语言之一。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/2cc007631269090877598becc4b807ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*V6QvwLaN8xN0dVJs"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">伙计，差不多了</figcaption></figure><p id="1fa7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我以前学过一些Ruby，我很喜欢它，这是一种有趣的面向对象的语言，它给出了很棒的错误，读起来像英语，简化了复杂的编程，同时允许了很多灵活性。</p><p id="d59c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/get-started-with-flask-aa0f7b76f235">我后来学习了一些Python </a>，我发现它们的语法与Ruby非常相似，具有易读的语法、强大的功能、<a class="ae lq" href="https://www.quora.com/Which-language-is-faster-Python-or-Ruby" rel="noopener ugc nofollow" target="_blank">比Ruby </a>稍快的速度，以及在<a class="ae lq" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>和<a class="ae lq" href="https://www.youtube.com/watch?v=ng2o98k983k" rel="noopener ugc nofollow" target="_blank">超级棒/简单的网络抓取</a>的“热门”领域中真正有趣的应用。</p><p id="b361" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我终于学会了一种最流行的语言，也是我在前端工作中学会的一种语言的延续，<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/a-pirate-y-intro-to-node-cli-apps-and-yargs-4af9410f034d"> Node.js </a>，它利用C++以连续且格式良好的方式来完成后端任务，以满足您的前端代码，这非常酷，比之前的所有选项都快，非常棒。</p><p id="e91a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是不同的东西呢？</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/dc0e85cbc47973fbba29a460382a0e58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6b11dSvltVxWGW4hFrlOUw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">嗯，长生不老药…</figcaption></figure><p id="b5e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我进入长生不老药有两个原因:</p><ol class=""><li id="90d0" class="md me it kw b kx ky la lb ld mf lh mg ll mh lp mi mj mk ml bi translated">我想学习一种新的语言，我听说Elixir是学习<a class="ae lq" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">“函数式编程</a>”概念的好方法，这是一种范式，其中代码不位于“类”或俱乐部中，在那里数据在人们之间共享，就像一个巨大的盟誓，而是一系列轻量级函数，其中每个函数都有一个输入和一个输出，您的代码将它们链接在一起做特定的工作，而不必挂在一起。就像一个非正式的朋友圈vs一个运动队(而且我不喜欢运动)！</li><li id="b174" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">一个朋友得到了一份灵丹妙药的工作，我申请了一份灵丹妙药的工作，我开始看到更多这样的人:猴子见雇佣，猴子做。</li></ol></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="fbba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elixir的概念化有点令人困惑，尽管在实践中学习起来并不困难，尤其是对于任何有Ruby或Python经验的人来说。难以概念化的原因是仙丹是建立在语言基础上的语言。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/c8dafa282c5e6892a48e1f1fbbcf47fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*C43JJLIWxTDXMp67OJF1VQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">呃……是阿郎？</figcaption></figure><p id="8a17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没错，Elixir实际上是一个将我们的代码传输到Erlang 中的<strong class="kw iu">运行时。这实际上类似于Node.js如何将它的一些操作转换成C++！Erlang本身的故事是疯狂的，Erlang是一种有30多年历史的语言，而Elixir则相对年轻。</strong></p><p id="dbd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">据我所知，这个故事的“悬崖笔记”版本是由<a class="ae lq" href="http://www.ericsson.com/" rel="noopener ugc nofollow" target="_blank">瑞典电信公司爱立信</a>开发的，用于处理大量“并发”或同时发生的请求。</p><p id="b8e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并发是一个完全不同的话题，但是如果你不了解它，我建议你去看看。通常，我们想象计算机的方式是，我们输入一个任务，计算机执行该任务，并返回您所要求的内容(打开网络浏览器，输入一些内容)，但并发意味着同时处理多个任务的能力。当一个人在处理时间敏感的交易时，这变得更加重要，比如在金融领域，在谷歌的广告平台上“竞价”广告，或者在开发该平台的公司的情况下，在电信领域，许多呼叫意味着许多请求。</p><p id="0e79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它本质上是“多线程的”，这意味着虽然可以执行多个任务，但是如果一个任务由于某种原因(例如，API调用)失败了，您的整个系统不会崩溃。这与Node.js相比，Node . js通过使用回调/事件循环来模拟并发性，但它是<em class="mr">单线程的</em> <strong class="kw iu"> <em class="mr"> </em> </strong>，这意味着如果一件事情失败了<strong class="kw iu">所有事情都会失败</strong>，这是对Node最大的批评之一，也是实现称为Deno 的东西的<a class="ae lq" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank">大原因，这是另一篇令人愉快的文章的主题。</a></p><p id="e392" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Erlang曾经是一种非常强大的语言，它被编译成一个名为“BEAM”的“虚拟机”,但是它也是传说中的……很难理解。关于Erlang的更多信息，我建议查看这些文档。</p><p id="2885" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，2014年，一家名为Plataformatec的公司发布了Elixir，目的是为后端web开发创建一种容错并发语言，这种语言利用了Erlang的强大功能，在语法上也不难理解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/4711d6f12782de566ab882c5163986d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*BdGbFXMcygi7zZgZV-NHcg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">这里有一个方便的图表！</figcaption></figure><p id="1985" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我公然从斯蒂芬·格里德那里偷来的好照片，去上他的课吧！无论如何，让我们进入一些代码。</p><p id="1c04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要创建一个新的Elixir项目，您必须在Mac上执行以下命令</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="5a16" class="nb nc it mx b gy nd ne l nf ng">brew install elixir<br/>mix new &lt;your-project-name&gt;</span></pre><p id="600c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将生成一个新项目，就像运行:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="4b0f" class="nb nc it mx b gy nd ne l nf ng">rails s<br/>npx create-react-app <br/>gatsby new</span></pre><p id="1440" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">诸如此类。</p><p id="a900" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到的是一个以您的项目名称命名的文件夹和一个名为<your-project-name>的文件，在我的例子中是“cards”。ex里面的东西看起来像:</your-project-name></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="627a" class="nb nc it mx b gy nd ne l nf ng">Defmodule Cards do<br/>end </span></pre><p id="d1d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很简单。这是一个<em class="mr">模块</em> <strong class="kw iu"> <em class="mr"> </em> </strong>，对于那些使用过Ruby或Typescript的人来说应该很熟悉，这是一个可以在应用程序的任何地方使用的函数或方法的集合。在Elixir中，不像其他语言那样有“类”。除了将一个函数传递给另一个函数之外，不传递任何数据！例如:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="f0e7" class="nb nc it mx b gy nd ne l nf ng">//inside of Cards module</span><span id="051f" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">def</em> <em class="mr">create_deck</em> <em class="mr">do</em></span><span id="aa8e" class="nb nc it mx b gy nh ne l nf ng">  cards = ["Ace", "Two", "Three", "Four", "Five"]</span><span id="8d20" class="nb nc it mx b gy nh ne l nf ng">  suits = ["Hearts", "Diamonds", "Clubs", "Spades"]</span><span id="969e" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">  for</em> suit &lt;- suits, card &lt;- cards <em class="mr">do</em></span><span id="1a63" class="nb nc it mx b gy nh ne l nf ng">    "#{card} of #{suit} "</span><span id="5789" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">  end</em></span><span id="67c1" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">end</em></span></pre><p id="2079" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个<em class="mr">列表的领悟</em> <strong class="kw iu"> <em class="mr"> </em> </strong>虽然有些。你可能只是从其他语言中知道它是一个返回列表的“for-loop”(实际上是一个链表！)的绳子，把牌和花色连在一起。在Erlang中，所有的列表理解都会返回列表，除非你弄乱了它们。相比之下，在JavaScript中，您可能会这样做:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="1ad5" class="nb nc it mx b gy nd ne l nf ng">const createDeck = () =&gt; {</span><span id="bf45" class="nb nc it mx b gy nh ne l nf ng">  cards = ["Ace", "Two", "Three", "Four", "Five"]</span><span id="3cbd" class="nb nc it mx b gy nh ne l nf ng">  suits = ["Hearts", "Diamonds", "Clubs", "Spades"]</span><span id="9a55" class="nb nc it mx b gy nh ne l nf ng">  let finalArray = []</span><span id="57e1" class="nb nc it mx b gy nh ne l nf ng">  cards.forEach(card =&gt; {</span><span id="6dc8" class="nb nc it mx b gy nh ne l nf ng">    suits.forEach(suit =&gt; {</span><span id="ab9c" class="nb nc it mx b gy nh ne l nf ng">      finalArray.push(`${card} of ${suit}`)</span><span id="f4ec" class="nb nc it mx b gy nh ne l nf ng">    })</span><span id="a3bb" class="nb nc it mx b gy nh ne l nf ng">  })</span><span id="3619" class="nb nc it mx b gy nh ne l nf ng">  return finalArray</span><span id="27ce" class="nb nc it mx b gy nh ne l nf ng">}</span></pre><p id="8d73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过比较，看看我们用Elixir节省了多少代码。</p><p id="2618" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Elixir也不会在整个模块中保存变量！你的模块就像一个社会距离悬挂，不同的方法只有在他们有一个关于安全的深入持久的对话时才会出现。</p><p id="f464" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么他们会怎么做呢？他们使用文件系统，例如下面的代码:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="9d27" class="nb nc it mx b gy nd ne l nf ng">//inside the Cards module, assume we've created a deck with the previous function</span><span id="1712" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">def</em> <em class="mr">save</em>(deck, file_name) <em class="mr">do</em></span><span id="47e6" class="nb nc it mx b gy nh ne l nf ng">  binary = :erlang.term_to_binary(deck)</span><span id="4fd2" class="nb nc it mx b gy nh ne l nf ng">  File.write(file_name, binary)</span><span id="949f" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">end</em></span><span id="6e1a" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">def</em> <em class="mr">load</em>(file_name) <em class="mr">do</em></span><span id="cc73" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">  case</em> File.read(file_name) <em class="mr">do</em></span><span id="9d6a" class="nb nc it mx b gy nh ne l nf ng">    {:ok, binary} -&gt;  :erlang.binary_to_term(binary)</span><span id="76d6" class="nb nc it mx b gy nh ne l nf ng">    {:error, <em class="mr">_reason</em>} -&gt; "That file does not exist"</span><span id="27f6" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">  end</em></span><span id="a4f6" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">end</em></span></pre><p id="1071" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哇哦。怪异的权利！但是短而有力！如果我们想保存一副牌以便在函数之间使用，我们可以使用Erlang的强大功能将数据写入一个二进制文件，然后将该文件加载到另一个函数中，并将其转换回我们需要的内容。<em class="mr">这意味着任何函数都可以与整个程序中的任何其他函数进行通信</em>！带上那个React/Redux！</p><p id="9da0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你还会看到一种叫做“模式匹配”<em class="mr"> </em>的东西，这是Elixir最酷的部分之一，在Python中叫做“元组解包”，在JS中叫做“析构”。从核心库“文件”模块导入的函数(记住一切都是模块！)返回一个有两个条目的<a class="ae lq" href="https://en.wikipedia.org/wiki/Tuple" rel="noopener ugc nofollow" target="_blank"> "tuple </a>"，可以通过分配与tuple中条目数量相匹配的变量来解包！这使得访问和处理数据变得非常容易(这在Elixir中也是不可变的，看看吧！)</p><p id="b323" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另请参见“case”语句，在其他一些语言和框架中通常称为“switch/case ”,最近是超级流行的Redux包的一部分。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="6f1f" class="nb nc it mx b gy nd ne l nf ng"><em class="mr">case</em> File.read(file_name) <em class="mr">do</em></span><span id="eb5a" class="nb nc it mx b gy nh ne l nf ng">{:ok, binary} -&gt;  :erlang.binary_to_term(binary)</span><span id="57b2" class="nb nc it mx b gy nh ne l nf ng">{:error, <em class="mr">_reason</em>} -&gt; "That file does not exist"</span></pre><p id="8dee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码说的是如果File.read返回的tuple <em class="mr">的第一个元素</em>被称为“:ok”(在Ruby中是一个“atom”或者“Symbol”)，然后把它变回一些数据，否则如果它被称为“:error”，就给我们一个错误消息！我们实际上不会使用原因，在灵药中，这将给我们一个警告，因为灵药是伟大的，它帮助我们看到我们的错误。但是我们可以用“原因”开头的下划线来解决这个问题，它告诉Elixir我们不会使用它。</p><p id="ed58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相比之下，让我们看看Node中的对等项:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="eb7f" class="nb nc it mx b gy nd ne l nf ng">const fs = require('fs') <br/>//note we didn't actually have to import anything in Elixir!</span><span id="9e28" class="nb nc it mx b gy nh ne l nf ng">const load = (fileName) =&gt; {</span><span id="a4ec" class="nb nc it mx b gy nh ne l nf ng">  try {</span><span id="8c8b" class="nb nc it mx b gy nh ne l nf ng">    const<em class="mr"> dataBuffer </em>=<em class="mr"> fs.readFileSync</em>('fileName')</span><span id="b0ab" class="nb nc it mx b gy nh ne l nf ng">    const<em class="mr"> dataJSON </em>=<em class="mr"> dataBuffer.toString</em>()</span><span id="94b8" class="nb nc it mx b gy nh ne l nf ng"><em class="mr">    return JSON.parse</em>(dataJSON)</span><span id="ab92" class="nb nc it mx b gy nh ne l nf ng">  } catch(error) {</span><span id="dc44" class="nb nc it mx b gy nh ne l nf ng">    throw new Error("The file is not present or could not be read")</span><span id="a785" class="nb nc it mx b gy nh ne l nf ng">  }</span><span id="f826" class="nb nc it mx b gy nh ne l nf ng">}</span></pre><p id="cf45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看看我们要做的所有转变！我们必须写入JSON，这样才能以代码可读的方式解析数据，我们还必须处理异步数据缓冲区或使用回调/async/await来尝试处理事情，每个错误对于我们代码正在做的任何其他事情都可能是灾难性的。Elixir为我们提供了简洁地编写代码和处理有趣任务的简单方法。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ni"><img src="../Images/249fe54d82c5bd1ec87ae38fc2e93c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lJBFBmbwaEE-f6DIf-eDA.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">诋毁</figcaption></figure><p id="ecf3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">汪，这是一个很大的代码和解释！我希望我已经给了你一个为什么要检查灵药的理由和一些背景。</p><p id="b6d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但你知道haz追求什么，不需要解释？我昨天在东河州立公园遇到的这只美丽的大丹犬和这只敏捷的拳师犬。大丹狗怀疑我，但只是因为他太爱他的爸爸了。</p><p id="233e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">继续保持社交距离，丹麦狗。</p><p id="d330" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">白现在来说，</p><p id="f1b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">网络信息中心(Network Information Center)ˌ网路界面卡(Network Interface Card)ˌ全国工业理事会(National Industrial Council)ˌ航行情报中心(Navigation Information Center)</p></div></div>    
</body>
</html>