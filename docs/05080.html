<html>
<head>
<title>SwiftUI: @State vs @StateObject vs @ObservedObject vs @EnvironmentObject</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">swift ui:@ State vs @ State object vs @ observed object vs @ environment object</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/state-vs-stateobject-vs-observedobject-vs-environmentobject-in-swiftui-81e2913d63f9?source=collection_archive---------1-----------------------#2020-08-03">https://levelup.gitconnected.com/state-vs-stateobject-vs-observedobject-vs-environmentobject-in-swiftui-81e2913d63f9?source=collection_archive---------1-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="df68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SwiftUI开发人员需要做出的第一个决定是使用哪个可用的属性包装器来存储数据。尤其是在iOS 14中，可以用SwiftUI编写<a class="ae ko" href="https://developer.apple.com/documentation/swiftui/app" rel="noopener ugc nofollow" target="_blank">整个应用生命周期</a>，以正确的方式存储数据对你的应用运行和行为可预测且无错误至关重要。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/85aa3ad2fd4c5baecae65aec2b6f2130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WS5kiI589bof_B8osgcMXg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">我制作的测试这些不同属性包装器的应用程序</figcaption></figure><p id="98a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">制作SwiftUI应用的挑战在于，从技术上来说，<code class="fe lf lg lh li b">@State</code>、<code class="fe lf lg lh li b">@StateObject</code>、<code class="fe lf lg lh li b">@ObservedObject</code>和<code class="fe lf lg lh li b">@EnvironmentObject</code>这四个应用表面上都能“工作”。你的应用程序将会编译，你甚至可以得到你想要的行为，即使你使用了错误的属性包装器。</p><p id="ee14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果使用不当，您可能会发现当您的数据更新时，您的视图不会更新。或者，数据保存的时间比您预期的要长。或者说，你的数据根本不持久。</p><p id="866b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来分解一下这个故事，从<code class="fe lf lg lh li b">@State</code>开始。</p><h1 id="59ad" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">@州</h1><blockquote class="mh mi mj"><p id="a3bd" class="jq jr mk js b jt ju jv jw jx jy jz ka ml kc kd ke mm kg kh ki mn kk kl km kn im bi translated"><strong class="js iu"> State: </strong>可以读写SwiftUI管理的值的属性包装器类型。</p></blockquote><p id="2b63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是苹果对@State的<a class="ae ko" href="https://developer.apple.com/documentation/swiftui/state" rel="noopener ugc nofollow" target="_blank">定义。但这意味着什么呢？</a></p><p id="ffb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">状态是你的应用程序可以拥有的最简单的事实来源。它被设计为包含简单的值类型，如int、Strings和Bools。它不是为更复杂的引用类型而设计的，例如您自己定义并在应用程序中使用的任何类或结构。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">状态的良好使用与状态的不良使用</figcaption></figure><p id="63e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://developer.apple.com/documentation/swiftui/managing-user-interface-state" rel="noopener ugc nofollow" target="_blank">苹果公司甚至这样说</a>——在将值添加到模型之前<strong class="js iu">使用简单的状态:</strong></p><blockquote class="mh mi mj"><p id="fdea" class="jq jr mk js b jt ju jv jw jx jy jz ka ml kc kd ke mm kg kh ki mn kk kl km kn im bi translated">在您准备对应用程序的数据模型进行更改之前，您可能还会发现这种存储方式非常方便。</p></blockquote><p id="5e1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">@State</code>通过在视图更新时重新计算视图的主体变量来工作。因此，如果您的视图中有一些状态跟踪一个整数，并且您将该整数加1，您的状态将会看到这一点并重新呈现视图。当视图使用此状态时，您将在屏幕上看到更新的数字。</p><p id="ad1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像我之前说的，这和对简单值类型的描述一样有效，比如整数、字符串或布尔。但是，您会发现<strong class="js iu">有可能</strong> <em class="mk">让<code class="fe lf lg lh li b">@State</code>跟踪一个复杂的物体。在整个故事中，我将多次引用以下对象作为示例:</em></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="abad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我就是这样使用它的:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c466" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不会引发任何错误。我所做的是创建一个新的<code class="fe lf lg lh li b">TestObject()</code>副本，并用<code class="fe lf lg lh li b">@State</code>属性包装器标记它，这告诉SwiftUI我希望这个视图能够跟踪它。</p><p id="9637" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你认为当我按照<strong class="js iu">第8行</strong>调用<code class="fe lf lg lh li b">state.num += 1</code>时会发生什么？</p><p id="05eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，我们在输出窗口的第9行<strong class="js iu"/>看到<code class="fe lf lg lh li b">state.num</code>已经增加了1，但是在我们应用程序的视图中<code class="fe lf lg lh li b">state</code>的值没有改变。为什么会这样？</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mq"><img src="../Images/be9adb088e0f1d5b660b86ba8ac0eed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CJ-JYa1wxaMkXswpmfie_A.gif"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">点击增加状态按钮，我们的输出窗口有我们的打印报表，但用户界面没有更新</figcaption></figure><p id="36ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们回到我之前写的东西…</p><blockquote class="mr"><p id="329d" class="ms mt it bd mu mv mw mx my mz na kn dk translated">@State通过在视图更新时重新计算视图的主体变量来工作。</p></blockquote><p id="0c84" class="pw-post-body-paragraph jq jr it js b jt nb jv jw jx nc jz ka kb nd kd ke kf ne kh ki kj nf kl km kn im bi translated">但是，因为我们使用的是复杂的参考类型，所以<code class="fe lf lg lh li b">state</code>本身的值不会改变。虽然<code class="fe lf lg lh li b">state</code>、<code class="fe lf lg lh li b">num</code>的属性已经改变，但是<code class="fe lf lg lh li b">@State</code>属性包装器不知道，因为它只关注变量<code class="fe lf lg lh li b">state</code>，而不是它的任何属性。对SwiftUI来说，因为它只是在看<code class="fe lf lg lh li b">state</code>，所以它不知道<code class="fe lf lg lh li b">num</code>已经改变，所以从不重新渲染视图。</p><p id="fafb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这导致了这样的场景:我们可以在控制台中看到值正在成功更新，但是我们视图中的<code class="fe lf lg lh li b">body</code>变量从未被重新计算过，因此我们看不到UI更新。这也导致我们的<code class="fe lf lg lh li b">onChange</code>方法永远不会被调用，因为它检测<code class="fe lf lg lh li b">body</code>变量渲染之间的变化，如果它从未被渲染，它就永远不会被调用。</p><p id="6bd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，正如我们所看到的，对于最简单的数据来说,<code class="fe lf lg lh li b">@State</code>不是正确的解决方案。思考用途，比如跟踪某个元素是否应该在屏幕上可见，或者突出显示某个特定的行号。对于任何更复杂或与您的业务逻辑相关的内容，请继续阅读…</p><h1 id="3aab" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">@StateObject</h1><p id="9c0c" class="pw-post-body-paragraph jq jr it js b jt ng jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj nk kl km kn im bi translated">iOS 14和Swift UI 2推出时，<a class="ae ko" href="https://developer.apple.com/documentation/swiftui/stateobject" rel="noopener ugc nofollow" target="_blank"> @StateObject是</a> …</p><blockquote class="mh mi mj"><p id="3250" class="jq jr mk js b jt ju jv jw jx jy jz ka ml kc kd ke mm kg kh ki mn kk kl km kn im bi translated">实例化可观察对象的属性包装类型。</p></blockquote><p id="2f46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太棒了，山姆，但什么是“可观察物体”？让我们再次向苹果公司求助:</p><blockquote class="mh mi mj"><p id="3243" class="jq jr mk js b jt ju jv jw jx jy jz ka ml kc kd ke mm kg kh ki mn kk kl km kn im bi translated">一种具有发行者的对象类型，在对象更改之前发出。</p></blockquote><p id="8042" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那是什么意思？让我给你看一个我们的<code class="fe lf lg lh li b">TestObject</code>的例子，但是被重新创建为一个<code class="fe lf lg lh li b">ObservableObject</code>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ff73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有两个主要区别:</p><ol class=""><li id="5216" class="nl nm it js b jt ju jx jy kb nn kf no kj np kn nq nr ns nt bi translated"><code class="fe lf lg lh li b">TestObject</code>现在符合协议<code class="fe lf lg lh li b">ObservableObject</code></li><li id="daa5" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated">我们用属性包装器<code class="fe lf lg lh li b">@Published</code>标记了<code class="fe lf lg lh li b">num</code></li></ol><p id="7520" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总的来说，我们要说的是任何时候<code class="fe lf lg lh li b">num</code>被更新，我们想让我们<code class="fe lf lg lh li b">ObservableObject</code>的任何用户知道他们应该重新渲染视图。</p><p id="59e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们回到我们的示例视图。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3b42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，我只做了一个小改动，在第2行的<strong class="js iu">上，从<code class="fe lf lg lh li b">@State</code>移到了<code class="fe lf lg lh li b">@StateObject</code>。使用<code class="fe lf lg lh li b">@StateObject</code>需要我的对象符合类型<code class="fe lf lg lh li b">ObservableObject</code>，所以好在我们之前已经这么做了。</strong></p><p id="3709" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当我们点击按钮时，我们不仅会看到新的num值被打印到输出窗口，而且还会看到UI更新。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/ca430e971d88629accf6712fc1e74692.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/1*wQn7t0_7wu-cIZi7d63rkg.gif"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">视图正在更新，当我们退出和进入视图时，对象也被重新创建</figcaption></figure><p id="159d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为，通过使用<code class="fe lf lg lh li b">@StateObject</code>，我们让我们的视图知道，每当可观察对象内的任何<code class="fe lf lg lh li b">@Published</code>属性改变时，我们希望视图重新呈现。换句话说，每当我们更新<code class="fe lf lg lh li b">num</code>时，因为那个属性是<code class="fe lf lg lh li b">@Published</code>，它告诉任何正在监听它的视图(<em class="mk">观察</em>它)值已经改变，它应该重新计算它的视图。</p><p id="3277" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不会面临与使用<code class="fe lf lg lh li b">@State</code>相同的问题，因为现在它不只是简单地观察对象本身，而是监听其任何标记的<code class="fe lf lg lh li b">@Published</code>属性的变化。相当酷。</p><p id="36ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe lf lg lh li b">@StateObject</code>要注意的另一件重要事情是对象的生命周期直接与视图相关联。我的意思是，如果你通过<a class="ae ko" href="https://developer.apple.com/documentation/swiftui/navigationlink" rel="noopener ugc nofollow" target="_blank">导航链接</a>进入你的视图，将<code class="fe lf lg lh li b">num</code>设置为3，返回<a class="ae ko" href="https://developer.apple.com/documentation/swiftui/navigationview" rel="noopener ugc nofollow" target="_blank">导航视图</a>，然后再次进入你的视图，那么<code class="fe lf lg lh li b">num</code>将被重置为0。事实上，整个<code class="fe lf lg lh li b">TestObject</code>将从零开始创建。</p><p id="1188" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然重置数据听起来很烦人，但这实际上是我们想要的行为。如果我们需要父视图(即通过NavigationLink移动到您的视图的视图)中的数据，我们应该在父视图中定义<code class="fe lf lg lh li b">@StateObject</code>,而不是子视图。如果我们只需要孩子中的数据，那么在孩子中定义<code class="fe lf lg lh li b">@StateObject</code>。</p><p id="c8e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这种方法，我们可以保证如果视图仍然是活动的，数据不会改变或被丢弃。正如Apple在他们的文档中所说，这是实例化复杂数据类型的正确方法。</p><p id="1523" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们接下来的两个方法是使用我们已经实例化为<code class="fe lf lg lh li b">@StateObject</code>的复杂对象。</p><h1 id="63a2" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">@ObservedObject</h1><p id="0718" class="pw-post-body-paragraph jq jr it js b jt ng jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj nk kl km kn im bi translated">苹果<a class="ae ko" href="https://developer.apple.com/documentation/combine/observableobject" rel="noopener ugc nofollow" target="_blank">将</a>和<code class="fe lf lg lh li b">@ObservedObject</code>描述为:</p><blockquote class="mh mi mj"><p id="86fc" class="jq jr mk js b jt ju jv jw jx jy jz ka ml kc kd ke mm kg kh ki mn kk kl km kn im bi translated">一种属性包装类型，订阅可观察对象，并在可观察对象发生变化时使视图无效。</p></blockquote><p id="f8e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是<em class="mk">几乎和<code class="fe lf lg lh li b">@StateObject</code>一样的</em>，除了它没有提到你的变量的实例化或创建。</p><p id="6f20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那是因为<code class="fe lf lg lh li b">@ObservedObject</code>被用来跟踪一个已经<em class="mk">被</em>创建的对象，可能是用<code class="fe lf lg lh li b">@StateObject</code>创建的。</p><p id="7378" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">@ObservedObject</code>当你想把一个可观察的物体从一个视图传递到另一个视图时使用。您已经在父视图中使用<code class="fe lf lg lh li b">@StateObject</code>实例化了可观察对象，现在您希望子视图能够访问数据。但是，您不想再次重新创建该对象。这不会保留对象中的任何数据。</p><p id="9602" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，您希望将现有的可观察对象向下传递给子对象，这是通过<code class="fe lf lg lh li b">@ObservedObject</code>完成的，通过一个导航链接，如下所示:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d4d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，子视图像这样访问对象:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="602c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，<code class="fe lf lg lh li b">ChildView</code>有一个名为<code class="fe lf lg lh li b">observedObject</code>的属性，它接受类型为<code class="fe lf lg lh li b">TestObject</code>的对象。它被标记为<code class="fe lf lg lh li b">ObservedObject</code>,因为它<strong class="js iu">没有</strong>实例化它(那是为了<code class="fe lf lg lh li b">@StateObject</code>)。相反，它已经被实例化，现在<code class="fe lf lg lh li b">ChildView</code>可以读写父视图正在读写的相同数据。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="6434" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果许多子视图需要访问相同的数据，这种方法会变得非常麻烦。例如，你可能想知道用户在你的应用程序的许多不同视图中的用户名，但是你不想把一个<code class="fe lf lg lh li b">UserDetails</code>模型传递给每一个视图。</p><p id="b968" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回车，<code class="fe lf lg lh li b">@EnvironmentObject</code> …</p><h1 id="8816" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">@环境对象</h1><p id="1d60" class="pw-post-body-paragraph jq jr it js b jt ng jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj nk kl km kn im bi translated"><code class="fe lf lg lh li b">@EnvironmentObject</code>用于那些需要使用<code class="fe lf lg lh li b">ObservableObject</code>但是视图不是直接的父/子对的场景。你可能想在主视图和设置菜单中使用一段数据，但是你不希望(或者需要)中间的每个视图都知道这些数据——那会产生一些混乱的代码。</p><p id="4167" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是苹果推荐的解决方案，从这个<a class="ae ko" href="https://developer.apple.com/videos/play/wwdc2020/10040/" rel="noopener ugc nofollow" target="_blank"> WWDC视频</a>截图可以看出:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oh"><img src="../Images/6b97e3188d19e66efb85a1fe75494c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73FXsONzaMqz_i4cfrRnXg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">苹果公司推荐的许多不同视图中所需数据的处理方法。来源:<a class="ae ko" href="https://developer.apple.com/videos/play/wwdc2020/10040/" rel="noopener ugc nofollow" target="_blank">swift ui-WWDC 2020数据概要</a></figcaption></figure><p id="68fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">他们的<code class="fe lf lg lh li b">ObservableObject</code>是在第一个视图中创建的，当它被改变时，他们想要更深层次的一些视图来了解和响应。</p><p id="bebc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe lf lg lh li b">@EnvironmentObject</code>有两个部分。</p><p id="a06a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，您需要创建一个要使用的对象。创建之后，您需要将它附加到一个视图，以便所有子视图都可以访问它。让我们继续做那件事。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a95b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，在<strong class="js iu">第3行</strong>我创建了对象，然后在<strong class="js iu">第6行，</strong>我把它附加到我的视图中。请注意，我已经在我的主应用程序文件中完成了所有这些。对于希望在整个应用程序中访问的数据，这是一种相当常见的模式。</p><p id="469a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，要在<code class="fe lf lg lh li b">ContentView</code>内的任何视图中使用该对象，您可以这样做:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="191c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这与您使用的<code class="fe lf lg lh li b">@ObservedObject</code>完全一样，只是这次我们希望它在环境中，而不是直接从父节点传递。</p><p id="7f31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">@EnvironmentObject</code>的工作方式是当在视图中被调用时，它从环境中该类型的对象(换句话说，从它上面任何指定了<a class="ae ko" href="https://developer.apple.com/documentation/swiftui/view/environmentobject(_:)" rel="noopener ugc nofollow" target="_blank"> environmentObject </a>的父对象)开始查找，然后让您使用它。这是在运行时完成的，而不是在编译时，所以如果你没有正确设置你的环境对象，你的应用程序在使用它的时候会崩溃。</p><p id="10b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的另一点是<code class="fe lf lg lh li b">@EnvironmentObject</code>寻找该类型的对象。这意味着您不能在同一视图树中使用同一类型定义多个环境对象。</p><p id="7b1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">@EnvironmentObject</code>非常方便，当您的数据被多个邻近视图使用时，它是一个很好的工具。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="c3dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，总而言之:</p><ol class=""><li id="e139" class="nl nm it js b jt ju jx jy kb nn kf no kj np kn nq nr ns nt bi translated">对于非常简单的数据，如Int、Bool或String，使用<strong class="js iu"> @ </strong> <code class="fe lf lg lh li b"><strong class="js iu">State</strong></code>。想想开关是开还是关，或者对话框是开还是关。</li><li id="a8b7" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated">使用<code class="fe lf lg lh li b"><strong class="js iu">@StateObject</strong></code>创建任何比<code class="fe lf lg lh li b">@State</code>更复杂的类型。确保类型符合<code class="fe lf lg lh li b">ObservableObject</code>，并且在您希望视图重新呈现的属性上有<code class="fe lf lg lh li b">@Published</code>包装器，或者您希望从视图中更新。<br/> <em class="mk">在实例化一个模型时，总是使用</em> <code class="fe lf lg lh li b"><em class="mk">@StateObject</em></code> <em class="mk">。</em></li><li id="a852" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated">使用<code class="fe lf lg lh li b"><strong class="js iu">@ObservedObject</strong></code>允许父视图将已经创建的<code class="fe lf lg lh li b">ObservableObject</code>传递给子视图(通过<code class="fe lf lg lh li b">@StateObject</code>)。</li><li id="01d4" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated">使用<code class="fe lf lg lh li b"><strong class="js iu">@EnvironmentObject</strong></code>消耗已经在父视图中创建的<code class="fe lf lg lh li b">ObservableObject</code>，然后通过视图的<code class="fe lf lg lh li b">environmentObject()</code>视图修改器附加。</li></ol></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="2cef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您阅读这个故事。我希望它对您使用SwiftUI有所帮助。和往常一样，如果你有任何问题，请留言，我会尽快回复你。</p></div></div>    
</body>
</html>