<html>
<head>
<title>Move Semantics — Efficient Copy, Better Performance?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移动语义—高效的复制，更好的性能？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/move-semantics-efficient-copy-better-performance-73b3cd854c33?source=collection_archive---------17-----------------------#2020-10-30">https://levelup.gitconnected.com/move-semantics-efficient-copy-better-performance-73b3cd854c33?source=collection_archive---------17-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ju"><img src="../Images/d5f19c430363b15fe4ea22eb330e997b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-S37d3n9XPhAsf0a"/></div></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">照片由<a class="ae kk" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨法尔·萨法罗夫</a>在<a class="ae kk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="433f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">作为一个刚刚接触面向对象编程的C++初学者，我只熟悉三条规则:如果我重新定义了复制构造函数、复制赋值操作符和析构函数(通常是为了资源管理)，不要忘记显式定义它们。然而，随着C++11中移动语义的出现，三的规则扩展到了五的规则，在我必须做的编码量中增加了移动赋值运算符和移动构造函数。除了堆积我的代码，他们还能带来什么？</p><h2 id="cb1f" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">移动语义——一个友好的介绍</h2><p id="2f9f" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">move语义背后的哲学一定是基于“一个人的垃圾是另一个人的宝”(我开玩笑的！).移动语义允许程序员通过交换每个对象资源的地址来重用接近生命周期终点的对象，从而避免了深度复制资源的开销。</p><p id="ac23" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">移动构造函数和移动赋值操作符都接收一个右值引用作为参数。简而言之，右值引用标识了在内存中没有地址的东西，例如赋值表达式右边的值，或者任何即将在内存中被销毁的对象，例如一个<em class="mh">临时</em>对象或者一个到达if生命周期终点的对象。</p><h2 id="d3d4" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">C++中的基准移动语义</h2><p id="3a3f" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">为了真正证明它的性能，我编写了一个模块<code class="fe mi mj mk ml b">TimedEvents</code>，用来计时一个类的每个特殊成员函数完成一项任务需要多长时间。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="5d07" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我还编写了另一个类<code class="fe mi mj mk ml b">RecordSet</code>，来测试该类的5个特殊成员函数的执行时间。分配给他们的任务很简单:读取一个文本文件，并将其中的每个单词加载到它的一个数据成员中，<code class="fe mi mj mk ml b">m_records</code>。只有当<code class="fe mi mj mk ml b">RecordSet</code>类的一个实例将一个文本文件中的所有单词加载到动态分配的字符串数组<code class="fe mi mj mk ml b">m_records</code>中时，它们才成功完成任务。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="503b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后，我只需要写一个程序来测试那些特殊的成员函数。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7fc3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是我运行这个程序的结果:</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/8ee3951e79746b6eec0d521fee50212a.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*vsFtnJeP5aABXY1-zijz3A.png"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">移动语义比复制语义花费的时间少得多</figcaption></figure><p id="73a4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">毫无疑问，move语义的引入可能是C++发展的一小步，但对于内存管理的性能却是一个巨大的飞跃。</p></div></div>    
</body>
</html>