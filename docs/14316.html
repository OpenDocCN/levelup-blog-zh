<html>
<head>
<title>Delegates and Events Part 1: Void Type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">委托和事件第1部分:空类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/delegates-and-events-part-1-void-type-bc46ee93226a?source=collection_archive---------6-----------------------#2022-11-16">https://levelup.gitconnected.com/delegates-and-events-part-1-void-type-bc46ee93226a?source=collection_archive---------6-----------------------#2022-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/01423d02d4cb0abd3a6f79cf4c2bbb22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lfX4FvfXxi8r8j1PLTQ5YQ.gif"/></div></div></figure><div class=""/><p id="65be" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代理和事件有一个强大的组合，当使用Unity的<em class="kz">新输入系统</em>时，它们非常有用。让我们深入研究一下如何声明和使用委托和事件。</p><p id="7ee2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">代表们</strong></p><p id="ef30" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">委托就像保存一个或多个方法的变量。你可以通过使用关键字<em class="kz"> delegate </em>，后跟它的<em class="kz">方法签名</em>来声明一个委托。方法签名是您希望您的委托持有的方法的<em class="kz">类型</em>。这可能是一个带有或不带有<em class="kz">参数</em>的<em class="kz"> void </em>类型方法，甚至是一个<em class="kz"> return </em>类型方法。在为您的委托定义了方法签名之后，您可以声明一个<em class="kz">变量</em>来存储该委托。变量类型<em class="kz">必须与委托的<em class="kz">名称</em>和<em class="kz">方法签名</em>匹配。我们来看两个例子，一个有<em class="kz">参数</em>，一个没有。</em></p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi la"><img src="../Images/51417b88d9aad4dc84f7b4e0056bc0da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvO2V_0bhis13FBGkI0_nw.png"/></div></div></figure><p id="0f4d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些每个都有对应的<em class="kz">方法</em>。这里需要注意的是<em class="kz">匹配</em>方法签名。<em class="kz">更新颜色</em>方法是一个<em class="kz"> void </em>类型的方法，带有一个<em class="kz">参数</em>，该参数带有一个<em class="kz">颜色变量</em>。<em class="kz">任务完成</em>方法也是一个<em class="kz"> void </em>类型的方法，它没有<em class="kz">参数。</em></p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lf"><img src="../Images/498c97d8b9e48717517ba5fbd4da3838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFqcYX1hgfr2ftGizCB47w.png"/></div></div></figure><p id="73d0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我试图将on <em class="kz">颜色变化</em>委托<em class="kz">变量</em>赋给<em class="kz">任务完成</em>方法，我会得到一个<em class="kz">错误</em>，因为方法签名不匹配。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/bf3e00ae8feab239e3b7b416d95a065f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*VyVU3FkgLSLSANM6aWJ6bw.png"/></div></figure><p id="41d5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我从void start运行它，控制台会显示每个方法都被执行了。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lh"><img src="../Images/7eaf5b5b0a9f2efe42534bc1489b2f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgFoEO1fLxAdMUIky5S1UA.png"/></div></div></figure><p id="1466" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为避免错误的最佳实践，您应该在运行<em class="kz">方法</em>之前<em class="kz">空检查</em>委托变量<em class="kz">。</em></p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi li"><img src="../Images/a81aa5073e3dd3849cca033b47a34bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*OFGMueG7EaPRkV6IEnr7Iw.png"/></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="de9c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">组播</strong></p><p id="1d5f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当一个代表使用<em class="kz">多播</em>时，它不会像一个超级法师一样同时施放治疗法术和攻击法术。然而，它以类似的方式运行<em class="kz">多个方法</em>。不是使用<em class="kz">等于</em>符号将委托变量赋给方法，而是使用<strong class="kd jf"> += </strong> <em class="kz">(加/等于)</em>运算符来<em class="kz">将</em>附加方法添加到委托变量。这里，在运行on complete委托之前，我总共添加了三个方法。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/fdf25d85d6c3b2905728f718f48a5cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*ym0D9-PQ6p4QoOIUyWAKLA.png"/></div></figure><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lr"><img src="../Images/cc2abb45dcf888f9357ca341027f0da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yyK49gSt6sL97YpZgDK2Gg.png"/></div></div></figure><p id="dd6b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">控制台显示这三种方法都已运行。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ls"><img src="../Images/11dc2e06d9c2c357b4b9e512f8ef8e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6KQb0nNb31x7qyXDf90_NA.png"/></div></div></figure><p id="f288" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以用<strong class="kd jf"> -= </strong> <em class="kz">(减/等于)</em>操作符从委托变量中移除方法。您不需要按照任何特定的顺序删除它们。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/c74dd9b2c99091384019a6e193947c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*x5hLdyfm6E6Oq2ynCcjIaA.png"/></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="b44b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">事件</strong></p><p id="e122" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事件是使用<em class="kz">通知</em>系统的<em class="kz">专门代表</em>。事件代理允许其他类<em class="kz">订阅</em>和<em class="kz">取消订阅</em>他们的广播。与普通的委托不同，事件有内置的安全性。委托变量可以被其他类调用，其中事件只允许其他类订阅和取消订阅它们的通知。让我们看一个使用带有UI按钮的点击事件的例子。</p><p id="44b2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有三个立方体原语和一个UI按钮，它将在委托管理器类上引发一个事件。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/6295544b469c2bdb16ca3b38ca356434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFPY8et6nF3ZjScpjEqpIQ.png"/></div></div></figure><p id="e02c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">声明委托后，不要使用典型的委托变量，而是使用关键字<em class="kz">事件。</em>确保方法签名与委托签名匹配，然后给事件一个变量名。事件不一定是静态的，但是我将在这个例子中使用一个静态事件。这样所有的功能都是独立的。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/5901775f610bcc29ca00e45d4b26993d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*JFuy9XThhNXjjkttGPSgGg.png"/></div></figure><p id="1ebd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在方法中调用该事件之前，还应该对其进行空检查，以避免错误。事件正在向<em class="kz">订户</em> / <em class="kz">侦听器</em>广播，您需要在引发事件之前检查是否有侦听器。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/ff54dc113e9633eee2ea77487f39381e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*lug8VfaDRs1bdJLhEkilCg.png"/></div></figure><p id="20b6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> UI按钮</em>被按下时会调用上面的<em class="kz"> on click事件</em>方法。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lx"><img src="../Images/ad318cce077ccf4c005169019726f7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVleX_JvVWg3CZIKHrT37Q.png"/></div></div></figure><p id="1403" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当按钮被按下时，我想给立方体分配一个随机的颜色，所以我创建了一个<em class="kz">新颜色</em>类。我需要抓取立方体的<em class="kz">网格渲染器</em>，并分配一个随机颜色。在void start中，<em class="kz"> onClick事件变量</em>通过<em class="kz">委托管理器</em>类被引用。<strong class="kd jf"> += </strong>操作符用于<em class="kz">将<em class="kz">更新颜色</em>方法订阅给<em class="kz">事件</em>。</em></p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/c758fdc132adef1016429222722fb7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtoU5GCKLMpinF-erX9tdw.png"/></div></div></figure><p id="2d4a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">更新颜色</em>方法将<em class="kz">随机值</em>分配给随机颜色<em class="kz">变量</em>。我可以选择在方法中使用一个<em class="kz">局部</em>颜色变量。网格渲染器被检查为空，然后被指定随机颜色。这将在每次按下带有新的随机颜色的UI按钮时触发。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lz"><img src="../Images/28a4f340ba2190da1535dad03f083c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75lSjguuruoYBF29Bf-5cw.png"/></div></div></figure><p id="cb4a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了避免错误，一旦对象不再活动，静态事件的最佳实践是<em class="kz">取消</em>对<em class="kz">监听器</em>的订阅。这可以通过<em class="kz">中的<strong class="kd jf"> -= </strong>操作器关闭</em>来完成。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ma"><img src="../Images/b3c53b930ba1d8a6c8de5b483a135d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIB4og54l5X6FtqHE_gT1g.png"/></div></div></figure><p id="f329" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">新颜色</em>脚本被添加到场景中的所有立方体中。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/f1f36757e4a7a76c6fdde7b3ee4ef6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*AQBLqbDEgSviaYC7cUju3w.png"/></div></figure><p id="38da" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是<em class="kz">点击事件</em>的动作，调用<em class="kz">更新颜色</em>方法。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mb"><img src="../Images/3e2a1c267f5a3ab0c56b212460a2c04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*len59XiQvT-mMtB_qgFjrg.gif"/></div></div></figure><p id="91c4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们创建一个名为<em class="kz">使用重力</em>的新类。使用这个类的对象将需要一个<em class="kz">刚体</em>，并且它需要在脚本中被引用。<em class="kz">使用gravity </em>类<em class="kz">将</em>订阅到<em class="kz">的点击事件变量</em>中，并添加了一个名为<em class="kz"> Fall </em>的方法。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mc"><img src="../Images/e31c84bea1ccf988494623a7ed43901f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmAXrGzpoPV-gfZXkl90BA.png"/></div></div></figure><p id="560d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里在f <em class="kz"> all方法</em>中，<em class="kz">刚体</em>被<em class="kz">零位检测</em>然后<em class="kz">使用重力</em>被设置为<em class="kz">真</em>。还有一个<em class="kz"> on disable </em>方法来<em class="kz">取消</em>对点击事件的订阅。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi md"><img src="../Images/12e8620a328564996b66f5ed5490b33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*ALD7YdK2IDQZNAjIKiOVSQ.png"/></div></figure><p id="6b7e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个<em class="kz">刚体</em>组件被添加到一个立方体中，其中<em class="kz">使用重力</em>被设置为<em class="kz">假</em>。<em class="kz">使用重力</em>脚本也被附加到对象上。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi me"><img src="../Images/a8447420f2931c8e3b6db8c77e241617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*FY_JfqzL7dUZsWlxHHTQZw.png"/></div></figure><p id="bb95" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当按下<em class="kz"> UI按钮</em>时，每个立方体会获得一个新的<em class="kz">颜色</em>，带有<em class="kz">使用重力</em>等级的立方体会从屏幕上掉落。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mf"><img src="../Images/c71fd3af0833b2325e9db77a0febac65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*u-g9_eE5rJJtNunmLKNoKQ.gif"/></div></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="671b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">挑战:<em class="kz">瞬移事件</em> </strong></p><p id="26b5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们做一个挑战，当按下<em class="kz">空格键</em>时，让立方体在给定的<em class="kz">范围</em>内传送到一个<em class="kz">新的随机位置</em>。一个新的<em class="kz">代理</em>在空间按上被创建称为<em class="kz">，并且一个相应的<em class="kz">事件</em>被创建来匹配。</em></p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mg"><img src="../Images/e6e86b37e29c6ca6c6e715ca8df0bc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMUXr5FFJtQCpgq4xc0Meg.png"/></div></div></figure><p id="a550" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个<em class="kz">更新</em>方法正在<em class="kz">代理管理器</em>上运行，并检查用户<em class="kz">输入</em>的空格键。当空格键<em class="kz">被按下</em>时，会引发<em class="kz">按下</em>事件。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mh"><img src="../Images/b21c57161b05b89946b78faee1a735d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sj1_kCugqVsLwbvfAenczg.png"/></div></div></figure><p id="1f4d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像往常一样，<em class="kz"> onSpacePress </em>事件<em class="kz">变量</em>在引发事件前被<em class="kz">空检查</em>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/60ab77f90307acc4361a4e9d45eeff66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*vKL8D6-Iez427iPkNk70ig.png"/></div></figure><p id="4d08" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建了一个名为<em class="kz">传送</em>的新脚本，在void start中，它订阅了<em class="kz"> onSpacePress </em>事件变量。然后，它向事件添加一个<em class="kz">新位置</em>方法。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mj"><img src="../Images/3722cc7c837fecd5b1547e7808f2d238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WgYDvjvXQJ5lNNCyInQa7w.png"/></div></div></figure><p id="4d9a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">新位置</em>方法有一个temp <em class="kz"> Vector3 </em>变量，它用<em class="kz">随机范围</em>分配一个<em class="kz">新位置</em>，然后将对象的<em class="kz">变换</em>的位置分配给新位置。<em class="kz"> On disable </em>处理<em class="kz">从事件中取消</em>订阅。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mk"><img src="../Images/bf6a2e24272c7e2a3f1fd04ab1fda430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-AfO8IhlJz9cihs9ssdHQ.png"/></div></div></figure><p id="6fb5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个立方体都附有<em class="kz">传送</em>脚本。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/fe33cab2db3efc62e06c97746770b103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*Moskvt3HgbSBTqEk8JIHmQ.png"/></div></figure><p id="4e3b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在按下<em class="kz">空格键</em>给每个立方体一个新的随机位置。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/75f6093417f2f3abd71cfbf08da07b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dbK-bIcVtxdIhSkym1Z5hQ.gif"/></div></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="2b23" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的空格键和按钮都发射了。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/01423d02d4cb0abd3a6f79cf4c2bbb22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lfX4FvfXxi8r8j1PLTQ5YQ.gif"/></div></div></figure><p id="fa62" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请下次和我一起深入了解代表和事件，因为还有更多的内容要介绍。感谢阅读！</p></div></div>    
</body>
</html>