<html>
<head>
<title>Avoid accessing class attributes through an instance in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免通过python中的实例访问类属性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/avoid-accessing-class-attributes-through-instance-in-python-9f81304c0634?source=collection_archive---------6-----------------------#2020-12-02">https://levelup.gitconnected.com/avoid-accessing-class-attributes-through-instance-in-python-9f81304c0634?source=collection_archive---------6-----------------------#2020-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7ae0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">虽然您可以使用实例来访问类属性，但是这样做是不安全的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1553b55479059ed974c31f294642dc88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qg3_SyeiR8oOXXcV8T1j6Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">埃里克·麦克林在<a class="ae kv" href="https://unsplash.com/photos/NpQSc0DzvBg" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在python中，类的实例由关键字<strong class="ky ir"> self引用。使用这个关键字，你不仅可以访问所有的实例属性，还可以访问类属性。虽然尝试使用self读取类属性不成问题，但是尝试分配/修改类属性将不起作用。</strong></p><p id="c001" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将使用一个简单的例子来演示这一点，在这个例子中，我们使用一个class属性来分配和跟踪集装箱的序列号。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5292" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们从例子开始</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/d730e25c4ae867c7f6b34aae97b610f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3r-iv39iMUfhitKJLdMhg.png"/></div></div></figure><p id="ed49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们希望所有的集装箱都以序列号1000开始。用于创建该类实例的<strong class="ky ir"> __init__ </strong>方法试图将实例属性<strong class="ky ir"> serial </strong>赋给第7行中的类属性<strong class="ky ir"> next_serial </strong>。这没问题，但是我们在第8行遇到了一个问题，我试图使用实例更新类属性<strong class="ky ir"> next_serial </strong>。让我们看看这在终端中是否有效</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/355a6e3915ae0c79924c272c5e7ba1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYkz__C9HGm0v5RNUaeS-A.png"/></div></div></figure><p id="716e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那没用。两个集装箱都有相同的序列号。但是为什么呢？让我们再来看看我们的类定义</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi gj"><img src="../Images/7e481b81eb8e341f2cb83836cf91e35d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhDr7ljxyM8tjO8BGav5rQ.png"/></div></div></figure><p id="1577" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第8行中，我们试图使用实例修改类属性<strong class="ky ir"> next_serial </strong>，但是这里发生的是我们创建了一个新的实例属性<strong class="ky ir"> next_serial。</strong></p><p id="ba2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们致力于我们的类定义，并尝试解决这个问题</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/6f1d19b49b5a662c81cfb43443c4ac76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chAEXXRJQcLiftFZ5Cdx-w.png"/></div></div></figure><p id="4f2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这次我们使用类名而不是self直接访问类属性next_serial。让我们在终端中再次运行代码</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/7ae36b4ec631a22b0dfa36bbeed3d484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRNuyeIa-7IAQWvDTbyESw.png"/></div></div></figure><p id="1f6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们找到了。现在起作用了！</p><p id="6bb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们清理代码，使它更加明确我们打算访问的类属性</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/a9c7034f030dc5362b8f7657a0dd1e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJ8b3zG4Hbnz7UIaNrovhA.png"/></div></div></figure><h1 id="9ebb" class="lz ma iq bd mb mc mv me mf mg mw mi mj jw mx jx ml jz my ka mn kc mz kd mp mq bi translated">结论</h1><p id="9a01" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">虽然您可以出于读取目的使用实例来访问类属性，但是您不能修改它们。要修改类属性，您需要使用类名访问该属性。此外，使用类名访问类属性使读者更清楚您想要访问哪个属性，因此这有助于项目维护。不小心这个陷阱可能会导致调试失败。</p></div></div>    
</body>
</html>