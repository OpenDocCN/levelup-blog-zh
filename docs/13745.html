<html>
<head>
<title>7 Mistakes That Novice Java Developers Commit!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java开发新手容易犯的7个错误！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-mistakes-that-novice-java-developers-commit-c54eac99cd3?source=collection_archive---------4-----------------------#2022-10-02">https://levelup.gitconnected.com/7-mistakes-that-novice-java-developers-commit-c54eac99cd3?source=collection_archive---------4-----------------------#2022-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="c91d" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">如果你是Java新手，这篇文章将帮助你理解7个容易混淆的概念。</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/62d3e15f0fdfabeb8e14778c27b06d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*wVtb1fwO6hH4T_Ds0sKGTw.jpeg"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Andrea Piacquadio拍摄的照片</figcaption></figure><h1 id="0a2e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> 1。忽略P <em class="ma">按值排序</em>Java的本质</strong></h1><blockquote class="mb"><p id="04b5" class="mc md iq bd me mf mg mh mi mj mk ko dk translated">你看到这里的虫子了吗？</p></blockquote><figure class="mm mn mo mp mq ku gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/fefae3f2fd411b22d38231f524595771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmEnZTkA26T1WrSRasgcHw.png"/></div></div></figure><p id="a4b6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">这里，<em class="js"> person </em>不会为<em class="js"> null </em>，因为Java是<em class="js">传值</em>而不是<em class="js">传引用</em>。那是什么意思？</p><p id="cb9d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">这里有三个部分，实际的person对象是在堆上创建的，然后有一个引用指向堆上的person对象，引用本身有一个表示对象在堆上的位置的值，这里的<em class="js"> bob </em>是一个指向堆上的person对象的引用，作为引用的<em class="js"> bob </em>也有一些表示对象位置的值。(这不是确切的地址)</p><p id="2117" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">所以，</p><p id="d8b2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">当<em class="js"> bob </em>作为参数传递给<em class="js"> makeItNull() </em>方法时，bob引用的值被复制到<em class="js"> bob1 </em>引用，而不是实际的堆对象，当<em class="js"> bob1 </em>被赋值给<em class="js"> null </em>时，<em class="js"> bob1 </em>引用的值变为<em class="js"> null </em>，但原始<em class="js"> bob </em>引用的值不变。</p><blockquote class="mb"><p id="6214" class="mc md iq bd me mf mg mh mi mj mk ko dk translated">当传递原始数据时，JVM复制原始数据类型的值。如果int x=5，那么5本身也会被复制。</p><p id="9f0d" class="mc md iq bd me mf mg mh mi mj mk ko dk translated">当传递对象时，引用的值被复制到另一个变量，而不是实际的对象。</p></blockquote><p id="3d11" class="pw-post-body-paragraph jq jr iq jt b ju my jw jx jy mz ka kb mv na ke kf mw nb ki kj mx nc km kn ko ij bi translated">因此java被认为是<em class="js">按值传递</em>而不是<em class="js">按引用传递。</em></p><p id="fa68" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">在按引用传递的语言中，原来的<em class="js"> bob </em>会变成null。</p><h1 id="daf1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">2.破坏Hashcode-Equals契约</h1><blockquote class="mb"><p id="8810" class="mc md iq bd me mf mg mh mi mj mk ko dk translated">这里缺少什么？</p></blockquote><figure class="mm mn mo mp mq ku gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nd"><img src="../Images/1067028c4512791bbf9322b85219554c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxeSbJCBh5na9kYkifEKDw.png"/></div></div></figure><p id="45fa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">如果不在Person类中覆盖hashcode-equals方法，<strong class="jt ir"> Bob将不会出现在那里</strong>，即使从业务角度来看它们是相同的对象。</p><p id="9f21" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">为什么？</p><p id="9cda" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">HashMap、HashSet和Hashtable使用hashcode和equals方法标识重复键，</p><p id="c65a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">存储对象时，使用<em class="js"> hashcode </em>方法计算散列码整数，如果映射已经包含该散列码，那么equals方法将被调用以检查对象是否真的相同，如果相同，那么值将被替换。</p><p id="0a35" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">类似地，在检索对象时，如果<em class="js"> hashcode() </em>相同，则调用<em class="js"> equals() </em>检查是否是相同的键，如果是，则返回值。</p><p id="23b6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">这里，在存储对象时，由于没有覆盖<em class="js"> hashcode() </em>和<em class="js"> equals() </em>方法，所以将调用对象类的hashcode和equals方法</p><blockquote class="mb"><p id="a0b7" class="mc md iq bd me mf mg mh mi mj mk ko dk translated">Object类的hashcode方法为JVM中的每个新对象返回不同的值。</p><p id="04b1" class="mc md iq bd me mf mg mh mi mj mk ko dk translated">对象类的equal方法引用比较。</p></blockquote><p id="e530" class="pw-post-body-paragraph jq jr iq jt b ju my jw jx jy mz ka kb mv na ke kf mw nb ki kj mx nc km kn ko ij bi translated">所以bob和bob1的hashcode是不同的。<em class="js"> bob1 </em>的哈希将不会出现在地图中。</p><p id="b70b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated"><strong class="jt ir">还记得那个简单的契约:</strong></p><p id="7620" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">如果<em class="js">等于</em>方法在某个类中被覆盖，</p><ol class=""><li id="cff3" class="ne nf iq jt b ju jv jy jz mv ng mw nh mx ni ko nj nk nl nm bi translated">您必须以这样一种方式覆盖<em class="js"> hashcode </em>方法，如果equals方法为两个对象返回true，那么hashcode方法必须为这些对象返回相同的整数。</li><li id="d4f0" class="ne nf iq jt b ju nn jy no mv np mw nq mx nr ko nj nk nl nm bi translated">如果equals方法中的对象不相同，那么它们可能会也可能不会返回相同的hashcode。</li></ol><blockquote class="mb"><p id="8ad2" class="mc md iq bd me mf ns nt nu nv nw ko dk translated">即使您已经覆盖了hashcode-equals，使用可变对象作为键也不是一个好的做法，因为以后如果键被修改，它们将不能被检索，因为hashcode-equals会由于修改而改变结果。</p></blockquote><h1 id="8ec2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln nx lp lq lr ny lt lu lv nz lx ly lz bi translated">3.迭代时修改集合</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nd"><img src="../Images/828ef090c17801f3b1b31ec065b40a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKets0yf4ibuz3cobESJsQ.png"/></div></div></figure><ol class=""><li id="1e5f" class="ne nf iq jt b ju jv jy jz mv ng mw nh mx ni ko nj nk nl nm bi translated">如果在使用快速失败迭代器迭代对象时试图添加或删除对象，将会得到<em class="js">ConcurrentModificationException。</em></li><li id="af4b" class="ne nf iq jt b ju nn jy no mv np mw nq mx nr ko nj nk nl nm bi translated">Fail fast迭代器在原始集合上工作，并使用一个<em class="js"> </em>内部标志<em class="js"> modCount </em>来检查集合中是否有任何结构变化。如果是，则执行失败。</li></ol><h2 id="a06f" class="oa ld iq bd le ob oc dn li od oe dp lm mv of og lq mw oh oi lu mx oj ok ly ol bi translated">解决方案:</h2><ol class=""><li id="6dfd" class="ne nf iq jt b ju om jy on mv oo mw op mx oq ko nj nk nl nm bi translated">您可以使用线程安全的等价集合<em class="js">Java . util . concurrent . copyonwritearraylist</em>或<em class="js">Java . util . concurrent . copyonwritearrayset</em>，迭代器使用原始数组的副本遍历并修改原始数组。</li><li id="9128" class="ne nf iq jt b ju nn jy no mv np mw nq mx nr ko nj nk nl nm bi translated">也可以使用<em class="js"> ConcurrentHashMap </em>，虽然它不使用原始集合的副本来遍历，但是它有一个无故障的快速实现。</li></ol><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nd"><img src="../Images/489748f6ea222a971332400294b8ac8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-z5m6UUqVE8FPIsyRYHew.png"/></div></div></figure><h1 id="265a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">4.不关闭系统资源</h1><ol class=""><li id="bc25" class="ne nf iq jt b ju om jy on mv oo mw op mx oq ko nj nk nl nm bi translated">Java应用程序使用几种类型的资源，如文件、流、套接字和数据库连接。我们需要确保他们获得自由，即使出现错误。</li><li id="0db6" class="ne nf iq jt b ju nn jy no mv np mw nq mx nr ko nj nk nl nm bi translated">由于每个应用程序分配的资源有限，过度使用资源会导致应用程序多次重启，并影响同一环境中的其他应用程序。</li></ol><p id="920f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated"><strong class="jt ir">如何关闭资源？</strong></p><p id="872b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">可以使用Java 7中引入的<em class="js"> finally </em>块或者<em class="js"> try-with-resource </em>块。使用<em class="js"> try-with-resource </em>时，可以声明多个资源，每个资源都必须实现<em class="js"> java.io.AutoCloseable </em>接口，该接口有<em class="js"> close() </em>方法来指定如何关闭资源。在成功完成try块或出现异常后，JVM总是会调用这个方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi or"><img src="../Images/0dcc9c025dcf1f89084a57aabdeb7dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8l3VI5CX2Nh1iVIaRNeUQ.png"/></div></div></figure><h1 id="0067" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">5.修改不可变对象</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi os"><img src="../Images/d1a515895c29b782fd6a84aff63e2a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84-FpK7mf9j2f7xeVAADGA.png"/></div></div></figure><ol class=""><li id="dbfd" class="ne nf iq jt b ju jv jy jz mv ng mw nh mx ni ko nj nk nl nm bi translated">这里<em class="js"> Arrays.asList() </em>给出了一个不可变列表，我们试图在其中添加另一个名称，因此我们将在这里<em class="js">得到<em class="js">UnsupportedOperationException</em>。</em></li><li id="1b1f" class="ne nf iq jt b ju nn jy no mv np mw nq mx nr ko nj nk nl nm bi translated">不可变对象的状态不能改变，也不应该改变。如果它是必需的，那么对象本身就不应该是不可变的。</li></ol><h1 id="fa5f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">6.多线程环境中变量的可见性</h1><blockquote class="mb"><p id="8455" class="mc md iq bd me mf mg mh mi mj mk ko dk translated">你以为MyThread会一直停在这里吗？</p></blockquote><figure class="mm mn mo mp mq ku gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ot"><img src="../Images/8f1f4d605d3e3297bc60f713a2f45b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3i5piBXDVPuVcxORLC9DFA.png"/></div></div></figure><ol class=""><li id="6365" class="ne nf iq jt b ju jv jy jz mv ng mw nh mx ni ko nj nk nl nm bi translated">如果<em class="js"> stop() </em>方法被其他线程执行，那么<em class="js"> stop </em>变量的<em class="js"> true </em>值可能永远不会被MyThread看到，如果它已经缓存了变量的值的话。</li><li id="7e5e" class="ne nf iq jt b ju nn jy no mv np mw nq mx nr ko nj nk nl nm bi translated">如果一个变量被多个线程共享，那么一个线程所做的更改可能会被另一个线程看到，也可能看不到。为什么？</li><li id="5dfb" class="ne nf iq jt b ju nn jy no mv np mw nq mx nr ko nj nk nl nm bi translated">当线程试图修改变量的值时，根据CPU架构，变量的值可以被复制到CPU核心的本地缓存，而不是总是从主存储器读取以提高性能，这对于同时处理它的另一个线程是不可见的。</li></ol><p id="1343" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated"><strong class="jt ir">解决，</strong></p><blockquote class="mb"><p id="826e" class="mc md iq bd me mf mg mh mi mj mk ko dk translated">所以使用一个<em class="ma">易变的</em>修饰符可以确保线程总是看到更新的值。</p></blockquote><figure class="mm mn mo mp mq ku gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ou"><img src="../Images/34c11b0dfe01bbbc030cf7a970f71f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vANy4tvpUkZiD77VYsxZvQ.png"/></div></div></figure><h1 id="fe36" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">7.使用==而不是equals进行对象比较</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ov"><img src="../Images/23ac1bd1d70d34b361afb2d981e6e1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgTlcx63BhcGBzppz75EXQ.png"/></div></div></figure><ol class=""><li id="34e1" class="ne nf iq jt b ju jv jy jz mv ng mw nh mx ni ko nj nk nl nm bi translated">这里<em class="js">，bob </em>和<em class="js"> bobAgain </em>引用了堆中的不同对象，因此引用比较(==)将返回false，否则将执行块。只有两个引用都指向内存中的同一个对象，它才会返回true。</li><li id="82de" class="ne nf iq jt b ju nn jy no mv np mw nq mx nr ko nj nk nl nm bi translated"><em class="js">等于(其他)</em>方法检查对象的实际内容。当然，这取决于你如何重写<em class="js">等于</em>方法。</li></ol><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ow"><img src="../Images/b3f5e7699bf745012cb8a73b71dd06f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92bFf9i3FBzhql6QC0jFfQ.png"/></div></div></figure><blockquote class="mb"><p id="357c" class="mc md iq bd me mf ns nt nu nv nw ko dk translated">枚举在Java中默认是单例的，所以相同枚举的所有引用将指向相同的对象，因此引用比较适用于枚举。</p></blockquote><figure class="mm mn mo mp mq ku gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/f767139813073fdf466c38bda59cd40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*QCJ-wtGF97kgT3vboZZV3w.png"/></div></figure><p id="6584" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">所以在这里，<em class="js"> If </em>块将被执行</p><p id="26c1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">就是这样，如果你喜欢的内容，请跟随！查看我在Java Streams上的另一篇文章！</p><div class="oy oz gp gr pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/8-years-of-java-stream-api-understand-streams-through-8-questions-bd9e5d9d8bc"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">8年Java Stream API，通过8个问题了解Streams！</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">是的，自从Java SE 8发布流API、函数接口、时间API等等以来，已经有8年了…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp kv pb"/></div></div></a></div><p id="7c53" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mv kd ke kf mw kh ki kj mx kl km kn ko ij bi translated">谢谢！</p></div></div>    
</body>
</html>