<html>
<head>
<title>Design Patterns: Proxy Pattern in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:TypeScript中的代理模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-proxy-pattern-in-typescript-b4b66fef3a59?source=collection_archive---------2-----------------------#2022-10-30">https://levelup.gitconnected.com/design-patterns-proxy-pattern-in-typescript-b4b66fef3a59?source=collection_archive---------2-----------------------#2022-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c329" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">代理模式的本质是一个中间件，其主要目的是分离服务提供者和客户。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/084b70ad47e40e14bc816bb10bb85fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TUzoZEztN1NR2VPz"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kylejglenn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯尔·格伦</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎来到TypeScript 系列的<strong class="lb iu">设计模式，该系列介绍了一些使用TypeScript进行web开发时有用的设计模式。</strong></p><div class="lv lw gp gr lx ly"><a href="https://medium.com/frontend-canteen/9-design-patterns-every-engineer-should-know-f2423d36d468" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">每个工程师都应该知道的9种设计模式</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">掌握这9种设计模式，写出更好的代码</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="55b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计模式对于web开发人员来说非常重要，通过掌握它们我们可以写出更好的代码。在本文中，我将使用<strong class="lb iu">类型脚本</strong>来介绍<strong class="lb iu">代理模式。</strong></p><p id="5d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTTP是用于传输超媒体文档的应用层协议。它是为web浏览器和web服务器之间的通信而设计的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/0dbe99449673dfb76a0521e994095a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tu9tJxNILq0DVWzeLqUhrQ.png"/></div></div></figure><p id="6a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发web项目的过程中，您可能需要手动修改请求参数或响应结果。要实现这一点，您可以使用web调试代理工具，如Fiddler或Charles。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/bb3c27ac92aacea31c52f0c16a2d1fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrFHdkiN2RkFo9qfG39Q3w.png"/></div></div></figure><p id="e7dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上图可以看出，使用web调试代理工具后，我们发起的HTTP请求会通过Web代理进行转发和处理。Web代理层的增加使我们能够更好地控制HTTP请求流。</p><p id="2658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解了Web代理的用途之后，我们来介绍一下代理模式的使用场景。在下面的代码中，我们定义了一个包含用于发送HTTP请求的<code class="fe mp mq mr ms b">sendRequest</code>成员方法的<code class="fe mp mq mr ms b">HttpService</code>类。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="98e2" class="mx my it ms b gy mz na l nb nc">class HttpService {<br/>  async sendRequest(method: string, url: string, body?: BodyInit) {<br/>    console.log(`Request info: method -&gt; ${method}, url -&gt; ${url}`);<br/>    return fetch(url, {<br/>      method,<br/>      body,<br/>    }).then((response) =&gt; response.json());<br/>  }<br/>}</span></pre><p id="924f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了<code class="fe mp mq mr ms b">HttpService</code>类，我们可以使用它的实例来获取远程数据。例如，获取<strong class="lb iu"> {JSON}占位符</strong>站点上提供的模拟数据:</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="8780" class="mx my it ms b gy mz na l nb nc">const httpService = new HttpService();</span><span id="4803" class="mx my it ms b gy nd na l nb nc">async function getTodoDetail(todoId: number) {<br/>  return httpService.sendRequest(<br/>    "get",<br/>    `<a class="ae ky" href="https://jsonplaceholder.typicode.com/todos/${todoId}`" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/${todoId}`</a><br/>  );<br/>}</span><span id="1cab" class="mx my it ms b gy nd na l nb nc">(async function main() {<br/>  console.dir(await getTodoDetail(1));<br/>  console.dir(await getTodoDetail(1));<br/>})();</span></pre><p id="3520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用<strong class="lb iu"> httpService </strong>对象来获取第一个todo项的信息。但现在的问题是，如果我们想让<strong class="lb iu"> httpService </strong>对象支持缓存，我们该怎么做？最直接的方法是修改<code class="fe mp mq mr ms b">HttpService</code>类，但是如果使用的是第三方Http服务，这种方法就行不通了。这个问题的另一个解决方案是使用代理模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/fbfcd5d9d15290d93e91005492db8d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfNhj6md_S7B-bbjMSSPoQ.jpeg"/></div></div></figure><p id="766b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，我们添加了一个<strong class="lb iu"> HttpServiceProxy </strong>代理对象，用来代理现有的<strong class="lb iu"> HttpService </strong>对象。接下来，让我们定义<code class="fe mp mq mr ms b">HttpServiceProxy</code>类，我们在其中添加前面描述的缓存功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="47ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在sendRequest方法中，我们使用HTTP请求方法和url地址作为缓存键。每次发送请求时，它会先判断相应的数据是否已经存在于缓存中，如果是，则直接返回。否则，通过<code class="fe mp mq mr ms b">HttpService</code>实例发送请求获取数据，并将返回的数据保存在缓存中。为简单起见，我们不考虑缓存有效期。</p><p id="b89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了<code class="fe mp mq mr ms b">HttpServiceProxy</code>对象，我们就可以用它来请求第一个todo项的信息。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="db19" class="mx my it ms b gy mz na l nb nc">const httpServiceProxy = new HttpServiceProxy();</span><span id="bf1d" class="mx my it ms b gy nd na l nb nc">async function getTodoDetail(todoId: number) {<br/>  return httpServiceProxy.sendRequest(<br/>    "get",<br/>    `<a class="ae ky" href="https://jsonplaceholder.typicode.com/todos/${todoId}`" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/${todoId}`</a><br/>  );<br/>}</span><span id="45b1" class="mx my it ms b gy nd na l nb nc">(async function main() {<br/>  console.dir(await getTodoDetail(1));<br/>  console.dir(await getTodoDetail(1));<br/>})();</span></pre><p id="aa5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述代码成功执行后，控制台将输出以下信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/eba9c05246a8c8e94d3f5058cb6ce002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g45_CTMxkUvegDituZFC4Q.png"/></div></div></figure><p id="d2bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上图可以看出，使用<code class="fe mp mq mr ms b">HttpServiceProxy</code>对象后，缓存功能已经生效。使用同样的想法，我们也可以在浏览器上扩展全局对象的功能。例如，我们扩展了<code class="fe mp mq mr ms b">localStorage</code>对象的功能，以支持设置存储数据的到期时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e2e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mp mq mr ms b">LocalStorageProxy</code>对象，我们可以在将数据保存到<code class="fe mp mq mr ms b">localStorage</code>时设置数据项的到期时间。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="3fb4" class="mx my it ms b gy mz na l nb nc">let storageProxy = new LocalStorageProxy();</span><span id="de82" class="mx my it ms b gy nd na l nb nc">storageProxy.setItem("name", "bytefer", 1000);<br/>console.log(storageProxy.getItem("name"));<br/>setTimeout(() =&gt; {<br/>  console.log(storageProxy.getItem("name"));<br/>}, 1000);</span></pre><p id="e32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，为了实现同样的功能，我们也可以使用一个非常强大的<code class="fe mp mq mr ms b">Proxy</code> API。如果你对这个API感兴趣，推荐你看下面这篇文章。</p><div class="lv lw gp gr lx ly"><a href="https://javascript.plainenglish.io/the-proxy-api-is-so-powerful-that-every-web-developer-should-master-it-9bdc71a4032c" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">代理API如此强大，每个Web开发人员都应该掌握它！</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">80%的Web开发人员不应该知道的代理API的8个主要使用场景！</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mh l"><div class="ni l mj mk ml mh mm ks ly"/></div></div></a></div><p id="7147" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们总结一下代理模式的使用场景:</p><ul class=""><li id="b894" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">当不希望从外部直接访问对象时，请考虑代理模式。</li><li id="bc3e" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">代理模式的本质是一个中间件，其主要目的是分离服务提供者和客户。客户端通过代理间接访问服务提供者，方便对服务提供者进行封装和控制。</li></ul><p id="99ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题，请随时给我留言。后面我会继续介绍其他模式，如果有兴趣可以关注我的<a class="ae ky" href="https://medium.com/@bytefer" rel="noopener">中</a>或者<a class="ae ky" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank">推特</a>。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="bbec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想学习打字稿，那么就不要错过<strong class="lb iu">掌握打字稿</strong>系列。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/frontend-canteen/with-these-articles-you-will-not-be-confused-when-learning-typescript-d96a5c99e229" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">有了30+篇文章，学习TypeScript就不会迷茫了</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">通过生动的动画，让你轻松了解TypeScript的难点和核心知识！不断地…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="oe l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>