<html>
<head>
<title>JavaScript Events Handlers — Keyboard and Load Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件处理程序—键盘和加载事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-events-handlers-keyboard-and-load-events-1b3e46a6b0c3?source=collection_archive---------3-----------------------#2020-01-24">https://levelup.gitconnected.com/javascript-events-handlers-keyboard-and-load-events-1b3e46a6b0c3?source=collection_archive---------3-----------------------#2020-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9fd2ba27b8c4da913fecb976d405914f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gfAq8PW8NhuIMmfe"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@its_lensation?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aryan Dhiman </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="cdd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，事件是应用程序中发生的动作。它们是由各种事情触发的，比如输入、提交表单、调整大小等元素变化，或者应用程序运行时发生的错误等。我们可以分配一个事件处理程序来响应这些事件。</p><p id="c59f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发生在DOM元素上的事件可以通过为相应事件的DOM对象属性分配一个处理程序来处理。在本文中，我们将了解如何使用可编辑输入元素的<code class="fe le lf lg lh b">onkeydown</code>和<code class="fe le lf lg lh b">onkeypress</code>属性，以及任何DOM元素的<code class="fe le lf lg lh b">onload</code>属性。我们还将查看媒体元素的属性<code class="fe le lf lg lh b">onloadeddata</code>，如<code class="fe le lf lg lh b">audio</code>和<code class="fe le lf lg lh b">video</code>。</p><h1 id="1fbd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe le lf lg lh b">onkeydown</code></h1><p id="b709" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以为输入DOM元素的<code class="fe le lf lg lh b">onkeydown</code>属性设置一个事件处理函数来处理<code class="fe le lf lg lh b">keydown</code>事件。当任何键被按下时，不管它们是否产生字符值，都会触发<code class="fe le lf lg lh b">keydown</code>事件。<code class="fe le lf lg lh b">keydown</code>事件提供指示哪个键被按下的代码，而<code class="fe le lf lg lh b">keypress</code>事件提供被输入的字符。比如小写的‘a’会用<code class="fe le lf lg lh b">keydown</code>报告为键码65，但是字符码97会用<code class="fe le lf lg lh b">keypress</code>报告。<code class="fe le lf lg lh b">keypress</code>已被弃用，因此不应在生产代码中使用。</p><p id="1960" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Firefox中，从版本65开始，<code class="fe le lf lg lh b">keydown</code>事件也在IME合成期间被触发，以提高中文、日文和韩文用户的跨浏览器兼容性。我们可以在IME合成期间忽略<code class="fe le lf lg lh b">keydown</code>事件，我们可以检查由<code class="fe le lf lg lh b">keydown</code>事件处理程序提供的<code class="fe le lf lg lh b">event</code>对象的<code class="fe le lf lg lh b">isComposing</code>属性。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2ec6" class="mt lj it lh b gy mu mv l mw mx">const input = document.querySelector('input');</span><span id="2d5a" class="mt lj it lh b gy my mv l mw mx">input.onkeydown =  event =&gt; { <br/>  if (event.isComposing || event.keyCode === 229) {<br/>    return;<br/>  }<br/>};</span></pre><p id="ecfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当我们键入中文、日文或韩文时，<code class="fe le lf lg lh b">isComposing</code>属性的值将是<code class="fe le lf lg lh b">true</code>，而<code class="fe le lf lg lh b">keyCode</code>属性的值将是229。</p><p id="f54a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以用它来记录用户在键盘上按下的键码的值。我们可以先放下面的HTML代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7238" class="mt lj it lh b gy mu mv l mw mx">&lt;input type="text" id="input" required&gt;<br/>&lt;p id="log"&gt;&lt;/p&gt;</span></pre><p id="0b58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在相应的JavaScript代码中，我们可以编写以下代码，通过设置我们的<code class="fe le lf lg lh b">input</code>元素的<code class="fe le lf lg lh b">onkeydown</code>属性，为<code class="fe le lf lg lh b">keydown</code>事件附加事件处理函数。事件处理函数将记录被按下的键的键码。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3647" class="mt lj it lh b gy mu mv l mw mx">const input = document.querySelector('input');<br/>const log = document.getElementById('log');</span><span id="d69e" class="mt lj it lh b gy my mv l mw mx">input.onkeydown =  e =&gt; { <br/> log.textContent += ` ${e.code}`;<br/>};</span></pre><p id="2193" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该得到这样的结果:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="863b" class="mt lj it lh b gy mu mv l mw mx">KeyE KeyR KeyF KeyG KeyT KeyG KeyT KeyG KeyH KeyH KeyF KeyV KeyG KeyB KeyG KeyB</span></pre><p id="c922" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在ID为<code class="fe le lf lg lh b">log</code>的元素中。</p><h1 id="460c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">onkeyup</h1><p id="3312" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">输入元素的<code class="fe le lf lg lh b">onkeyup</code>属性让我们附加一个事件处理函数来处理<code class="fe le lf lg lh b">keyup</code>事件。当用户释放之前按下的键时，触发<code class="fe le lf lg lh b">keyup</code>事件。</p><p id="e441" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">keyup</code>事件提供一个代码，指示哪个键被按下，而<code class="fe le lf lg lh b">keypress</code>事件提供输入的字符。比如小写的‘a’会用<code class="fe le lf lg lh b">keyup</code>报告为键码65，但是字符码97会用<code class="fe le lf lg lh b">keypress</code>报告。</p><p id="7f6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Firefox中，从版本65开始，<code class="fe le lf lg lh b">keyup</code>事件也在IME合成期间被触发，以提高中文、日文和韩文用户的跨浏览器兼容性。我们可以在IME合成期间忽略<code class="fe le lf lg lh b">keyup</code>事件，我们可以检查由<code class="fe le lf lg lh b">keyup</code>事件处理程序提供的<code class="fe le lf lg lh b">event</code>对象的<code class="fe le lf lg lh b">isComposing</code>属性。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7953" class="mt lj it lh b gy mu mv l mw mx">const input = document.querySelector('input');</span><span id="926f" class="mt lj it lh b gy my mv l mw mx">input.onkeyup =  event =&gt; { <br/>  if (event.isComposing || event.keyCode === 229) {<br/>    return;<br/>  }<br/>};</span></pre><p id="c0d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以用它来记录用户在键盘上按下的键码的值。我们可以先放下面的HTML代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="02ac" class="mt lj it lh b gy mu mv l mw mx">&lt;input type="text" id="input" required&gt;<br/>&lt;p id="log"&gt;&lt;/p&gt;</span></pre><p id="56ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在相应的JavaScript代码中，我们可以编写以下代码，通过设置我们的<code class="fe le lf lg lh b">input</code>元素的<code class="fe le lf lg lh b">onkeydown</code>属性，为<code class="fe le lf lg lh b">keydown</code>事件附加事件处理函数。事件处理函数将记录被按下的键的键码。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0290" class="mt lj it lh b gy mu mv l mw mx">const input = document.querySelector('input');<br/>const log = document.getElementById('log');</span><span id="0a7e" class="mt lj it lh b gy my mv l mw mx">input.onkeyup =  e =&gt; { <br/> log.textContent += ` ${e.code}`;<br/>};</span></pre><p id="1d54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该得到这样的结果:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1c9b" class="mt lj it lh b gy mu mv l mw mx">KeyD KeyF KeyG KeyT KeyH KeyG KeyT</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c2dda1c44271e52b1da292ef6a6cef3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*40DT05D70K2CgFI0"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Artem Beliaikin 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="0503" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">装载</h1><p id="db09" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">DOM元素的<code class="fe le lf lg lh b">onload</code>属性允许我们为它设置一个事件处理函数来处理<code class="fe le lf lg lh b">load</code>事件，当加载任何元素时都会触发该事件。它在文档加载过程结束时被触发。当<code class="fe le lf lg lh b">load</code>事件被触发时，文档中的所有对象都应该在DOM中，包括所有图像、脚本、链接和子框架。</p><p id="c896" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有<code class="fe le lf lg lh b">DOMContentLoaded</code>和<code class="fe le lf lg lh b">DOMFrameContentLoaded</code>，它们在页面的DOM被加载后被触发，但不等待其他资源完成加载。</p><p id="4dbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用它在<code class="fe le lf lg lh b">window</code>或<code class="fe le lf lg lh b">img</code>元素加载后运行一些代码，首先编写HTML代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2256" class="mt lj it lh b gy mu mv l mw mx">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Onload&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div&gt;Text&lt;/div&gt;<br/>    &lt;img<br/>      src="<a class="ae kf" href="https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80</a>"<br/>    /&gt;<br/>    &lt;script src="main.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="3231" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以编写相应的JavaScript代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="70fe" class="mt lj it lh b gy mu mv l mw mx">const img = document.querySelector("img");</span><span id="b611" class="mt lj it lh b gy my mv l mw mx">img.onload = () =&gt; {<br/>  console.log("img loaded");<br/>};</span><span id="e6a2" class="mt lj it lh b gy my mv l mw mx">window.onload = () =&gt; {<br/>  console.log("window loaded");<br/>};</span></pre><p id="9856" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该看到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5a7c" class="mt lj it lh b gy mu mv l mw mx">img loaded<br/>window loaded</span></pre><p id="96bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们加载页面时。</p><h1 id="f234" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">onloadeddata</h1><p id="1c50" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当媒体的第一帧完成加载时，触发<code class="fe le lf lg lh b">loadeddata</code>事件。适用于<code class="fe le lf lg lh b">audio</code>、<code class="fe le lf lg lh b">video</code>等媒体元素。为了处理这个事件，我们可以设置媒体元素的<code class="fe le lf lg lh b">onloadeddata</code>属性，在这个事件被触发时运行一个事件处理函数。</p><p id="2924" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们也可以在下面的代码中设置<code class="fe le lf lg lh b">onloadeddata</code>属性。首先，我们为<code class="fe le lf lg lh b">video</code>元素添加HTML代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2a06" class="mt lj it lh b gy mu mv l mw mx">&lt;video src='<a class="ae kf" href="https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4'" rel="noopener ugc nofollow" target="_blank">https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4'</a>&gt;&lt;/video&gt;</span></pre><p id="62b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在相应的JavaScript代码中，我们可以用下面的代码设置一个事件处理函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9f3c" class="mt lj it lh b gy mu mv l mw mx">const video = document.querySelector('video');</span><span id="0df0" class="mt lj it lh b gy my mv l mw mx">video.onloadeddata = () =&gt; {<br/> console.log('video loaded');<br/>}</span></pre><p id="dc7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事件处理函数也有一个<code class="fe le lf lg lh b">event</code>对象作为第一个参数。我们可以像在下面的代码中一样添加一个<code class="fe le lf lg lh b">event</code>参数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a26c" class="mt lj it lh b gy mu mv l mw mx">const video = document.querySelector('video');</span><span id="de0e" class="mt lj it lh b gy my mv l mw mx">video.onloadeddata = (event) =&gt; {<br/> console.log(event);<br/>}</span></pre><p id="f952" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这让我们明白了:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4a76" class="mt lj it lh b gy mu mv l mw mx">bubbles: false<br/>​cancelBubble: false<br/>​cancelable: false<br/>​composed: true<br/>​currentTarget: null<br/>​defaultPrevented: false<br/>​detail: 0<br/>​eventPhase: 0<br/>​explicitOriginalTarget: &lt;html&gt;<br/>​isTrusted: true<br/>​layerX: 0<br/>​layerY: 0<br/>​originalTarget: HTMLDocument <a class="ae kf" href="https://fiddle.jshell.net/_display/" rel="noopener ugc nofollow" target="_blank">https://fiddle.jshell.net/_display/</a><br/>​rangeOffset: 0<br/>​rangeParent: null<br/>​relatedTarget: null<br/>​returnValue: true<br/>​srcElement: HTMLDocument <a class="ae kf" href="https://fiddle.jshell.net/_display/" rel="noopener ugc nofollow" target="_blank">https://fiddle.jshell.net/_display/</a><br/>​target: HTMLDocument <a class="ae kf" href="https://fiddle.jshell.net/_display/" rel="noopener ugc nofollow" target="_blank">https://fiddle.jshell.net/_display/</a><br/>​timeStamp: 1463<br/>​type: "focus"<br/>​view: Window <a class="ae kf" href="https://fiddle.jshell.net/_display/" rel="noopener ugc nofollow" target="_blank">https://fiddle.jshell.net/_display/</a><br/>​which: 0</span></pre><p id="5147" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的输出是<code class="fe le lf lg lh b">Event</code>对象的属性和相应的值。要查看关于<code class="fe le lf lg lh b">Event</code>对象的更多细节，我们可以看看以前的文章。</p><p id="855f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以为输入DOM元素的<code class="fe le lf lg lh b">onkeydown</code>属性设置一个事件处理函数来处理<code class="fe le lf lg lh b">keydown</code>事件。当任何键被按下时，不管它们是否产生字符值，都会触发<code class="fe le lf lg lh b">keydown</code>事件。<code class="fe le lf lg lh b">keydown</code>事件提供了一个指示哪个键被按下的代码。输入元素的<code class="fe le lf lg lh b">onkeyup</code>属性让我们附加一个事件处理函数来处理<code class="fe le lf lg lh b">keyup</code>事件。当用户释放之前按下的键时，触发<code class="fe le lf lg lh b">keyup</code>事件。<code class="fe le lf lg lh b">event</code>对象提供与<code class="fe le lf lg lh b">keydown</code>事件处理程序相同的信息。</p><p id="9ce5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DOM元素的<code class="fe le lf lg lh b">onload</code>属性允许我们为它设置一个事件处理函数来处理<code class="fe le lf lg lh b">load</code>事件，当加载任何元素时都会触发该事件。它在文档加载过程结束时被触发。当触发<code class="fe le lf lg lh b">load</code>事件时，文档中的所有对象都应该在DOM中，包括所有图像、脚本、链接和子框架。</p><p id="1a3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当<code class="fe le lf lg lh b">audio</code>和<code class="fe le lf lg lh b">video</code>等媒体的第一帧加载完成时，触发<code class="fe le lf lg lh b">loadeddata</code>事件。为了处理这个事件，我们可以设置媒体元素的<code class="fe le lf lg lh b">onloadeddata</code>属性，以便在这个事件被触发时运行一个事件处理函数。</p></div></div>    
</body>
</html>