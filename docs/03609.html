<html>
<head>
<title>Decorators in Python: What They Are and How to Use Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的装饰者:他们是什么以及如何使用他们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/decorators-in-python-what-they-are-and-how-to-use-them-e315e68ecb08?source=collection_archive---------23-----------------------#2020-05-18">https://levelup.gitconnected.com/decorators-in-python-what-they-are-and-how-to-use-them-e315e68ecb08?source=collection_archive---------23-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4d0a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">@不仅仅是电子邮件和社交媒体</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f63837f58efca84a25c10d01ae93728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWrJZGQ4HUz8EXy18QgBFQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:Pexels.com的奥列格·马尼</figcaption></figure><h2 id="299c" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是室内设计师？</h2><p id="5a08" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">在Python中，装饰器是一个包装另一个函数的函数。它的目的是为它包装的函数提供额外的功能。</p><p id="3546" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这听起来令人困惑。让我们看一个例子。</p><p id="e26f" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">假设你写了一个将两个数相加的函数。您还在那里放了一个doc字符串，因为您很棒，并且希望帮助任何使用您的函数的人理解它的作用。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0f97" class="kv kw iq mq b gy mu mv l mw mx"><strong class="mq ir">def add(a, b):</strong><br/>    """<br/>    Takes two parameters, a and b, and returns their sum.<br/>    """<br/>    <strong class="mq ir">return</strong> a + b</span></pre><p id="e9b5" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">您运行它，看看它是否能正确地将1和3相加。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="985d" class="kv kw iq mq b gy mu mv l mw mx">add(1, 3)</span><span id="9f98" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]:</strong> 4</span></pre><p id="3c7b" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">是的，所以你决定让我接触<code class="fe mz na nb mq b">add()</code>。我没看过你的代码，想知道你的函数是做什么的。我在上面打<code class="fe mz na nb mq b">help()</code>。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a3fa" class="kv kw iq mq b gy mu mv l mw mx">help(add)</span><span id="5dcc" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]</strong>: Help on function add in module __main__:</span><span id="e495" class="kv kw iq mq b gy my mv l mw mx">       add(a, b)<br/>          Takes two parameters, a and b, and returns their sum.</span></pre><p id="ebb1" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">谢谢你！好的文档对于好的编码是必不可少的。一会儿我将向您展示一个涉及装饰者的有趣用例。</p><h2 id="4aee" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">让我们为你的功能计时</h2><p id="4b36" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">你决定想知道<code class="fe mz na nb mq b">add()</code>跑多快。方便的是，Python在其内置的<code class="fe mz na nb mq b">time</code>库中包含了一个计时器。您需要为您的代码导入它。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="393d" class="kv kw iq mq b gy mu mv l mw mx"><strong class="mq ir">from</strong> time <strong class="mq ir">import</strong> perf_counter</span></pre><p id="007e" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">为了给你的函数<code class="fe mz na nb mq b">add()</code>计时，你可以写这样的代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="bb0b" class="kv kw iq mq b gy mu mv l mw mx">start = perf_counter()<br/>add(1, 3)<br/>end = perf_counter()<br/>print(f'Run time: {(end — start):0.8f} seconds')</span><span id="bfc7" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]:</strong> Run time: 0.00011559 seconds</span></pre><p id="c2a3" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">那相当快。</p><p id="92aa" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">注意<code class="fe mz na nb mq b">start</code>和<code class="fe mz na nb mq b">end</code>环绕<code class="fe mz na nb mq b">add()</code>函数。这种布局使这些语句成为装饰器(也称为包装器)的理想选择。</p><h2 id="393b" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">让我们做一个室内装潢师</h2><p id="8ae3" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们编写一个装饰器，就像任何其他函数一样。函数可以将其他函数作为参数，decorators总是会这样做。对于下面的例子，我将调用这个参数<code class="fe mz na nb mq b">fn</code>来提醒我，我的输入是一个函数。我还将在函数中导入<code class="fe mz na nb mq b">perf_counter</code>,这样，如果我在其他地方使用这个定时器，就不必记得这么做了。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3377" class="kv kw iq mq b gy mu mv l mw mx"><strong class="mq ir">def</strong> <strong class="mq ir">timer(fn):</strong><br/>    """<br/>    This is a decorator that returns the time it takes another    function to run.<br/>    """<br/>    <strong class="mq ir">from</strong> time <strong class="mq ir">import</strong> perf_counter</span><span id="4b99" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">    def inner_func(*args, **kwargs):</strong><br/>        """<br/>        This is the inner function that the timer decorator returns.<br/>        """<br/>        start = perf_counter()<br/>        result = fn(*args, **kwargs)<br/>        end = perf_counter()<br/>        print(f'Run time: {(end — start):0.8f} seconds')<br/> <br/>        <strong class="mq ir">return</strong> result</span><span id="d194" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">    return </strong>inner_func</span></pre><h1 id="f87f" class="nc kw iq bd kx nd ne nf la ng nh ni ld jw nj jx lh jz nk ka ll kc nl kd lp nm bi translated">让我们解开这里发生了什么</h1><h2 id="390e" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结构</h2><p id="26c2" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">装饰者有两层结构。当我们创建一个<code class="fe mz na nb mq b">timer()</code>的实例时，外部函数被调用。当我们准备好执行放入<code class="fe mz na nb mq b">timer()</code>的函数并计时其运行速度时，内部函数将被调用。这听起来可能有点抽象，但一会儿就应该变得更清楚了。</p><h2 id="4982" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">外部功能:<code class="fe mz na nb mq b">timer</code></h2><p id="9209" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">让我们从<code class="fe mz na nb mq b">timer()</code>的输入开始。注意，我去掉了<code class="fe mz na nb mq b">fn</code>的括号，尽管它是一个函数。我为什么要这么做？因为当Python看到函数名后面有括号时，它会调用该函数。我们不想让<code class="fe mz na nb mq b">fn</code>执行，因为它的输出会变成<code class="fe mz na nb mq b">timer()</code>的输入。因此<code class="fe mz na nb mq b">timer(add(1, 3))</code>实际上会是<code class="fe mz na nb mq b">timer(4)</code>，这是完全无用的。我们不想给数字4计时；我们要对<em class="nn">函数</em> <code class="fe mz na nb mq b">add()</code>计时。去掉括号。</p><p id="905c" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">接下来我们导入<code class="fe mz na nb mq b">perf_counter</code>，这样它就可以使用了。</p><h2 id="581d" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">内部函数:inner_func</h2><p id="5f53" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">内部函数做的第一件事是捕获我们想要计时的函数<code class="fe mz na nb mq b">fn</code>的参数。</p><p id="daeb" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">但是我们没有放入<code class="fe mz na nb mq b">fn</code>的参数！它怎么知道它们是什么？</p><p id="4876" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">并没有。我们稍后将把这些参数放入，<em class="nn">在</em>之后，我们称之为<code class="fe mz na nb mq b">timer()</code>。一会儿我将向您展示这是如何工作的。与此同时，我们需要一些东西来代替这些未知的未来参数。我们用<code class="fe mz na nb mq b">*args</code>和<code class="fe mz na nb mq b">**kwargs</code>吧。</p><h2 id="b012" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是<code class="fe mz na nb mq b">*args </code>和**kwargs？</h2><p id="f95a" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">这些是任意数量参数的标准占位符名称，可以附加到我们选择输入到<code class="fe mz na nb mq b">timer()</code>的任何函数。一个星号(<code class="fe mz na nb mq b">*</code>)告诉Python这是一个位置参数。两颗星(<code class="fe mz na nb mq b">**</code>)告诉Python这是一个关键字参数。我不会深入讨论参数类型，因为参数完全是另外一个话题，但是知道<code class="fe mz na nb mq b">*args</code>和<code class="fe mz na nb mq b">**kwargs</code>作为我们选择计时的任何函数的总括就足够了，不管这个函数有多少或什么类型的参数。</p><h2 id="b402" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">inner_func和之前的代码有什么不同？</h2><p id="fea2" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们对计时<code class="fe mz na nb mq b">add(1, 3)</code>的原始代码做了两处修改。首先，我们将函数调用赋给了变量<code class="fe mz na nb mq b">result</code>，这样我们就可以返回它。这很方便，因为除了查看运行时间之外，它还允许我们获得<code class="fe mz na nb mq b">add</code>函数(或者我们选择的任何其他函数)的输出。其次，我们将计时的函数变成了一个通用函数，而不是将代码附加到<code class="fe mz na nb mq b">add()</code>上。</p><h2 id="6606" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">inner_func如何执行</h2><p id="7bd5" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">为了区别于之前的<code class="fe mz na nb mq b">add()</code>代码，让我们假设我们也编写了一个名为<code class="fe mz na nb mq b">multiply().</code>的函数，它将两个数字作为参数，然后将它们相乘并返回它们的乘积。</p><p id="0564" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们已经决定要计时这个新函数。我们需要创建一个使用<code class="fe mz na nb mq b">multiply</code>作为参数的<code class="fe mz na nb mq b">timer()</code>实例，然后将其赋给一个变量。</p><p id="439e" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><code class="fe mz na nb mq b">m = timer(multiply)</code></p><p id="2bda" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">现在我们已经将这个<code class="fe mz na nb mq b">timer()</code>实例存储在变量<code class="fe mz na nb mq b">m</code>中，我们可以输入之前未知的参数。我们可以像这样进行函数调用:</p><p id="f022" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><code class="fe mz na nb mq b">m(2, 3)</code></p><p id="3b6d" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">该函数调用将执行<code class="fe mz na nb mq b">inner_func</code>。事情是这样的:</p><ul class=""><li id="9c28" class="no np iq lt b lu mk lx ml le nq li nr lm ns mj nt nu nv nw bi translated"><code class="fe mz na nb mq b">perf_counter()</code>运行并在<code class="fe mz na nb mq b">start</code>中存储时间</li><li id="ea7b" class="no np iq lt b lu nx lx ny le nz li oa lm ob mj nt nu nv nw bi translated"><code class="fe mz na nb mq b">multiply</code>替换通用<code class="fe mz na nb mq b">fn</code>和2，3替换<code class="fe mz na nb mq b">*args</code>和<code class="fe mz na nb mq b">**kwargs</code>。<code class="fe mz na nb mq b">multiply(2, 3)</code>现在执行。</li><li id="2726" class="no np iq lt b lu nx lx ny le nz li oa lm ob mj nt nu nv nw bi translated"><code class="fe mz na nb mq b">perf_counter()</code>再次运行，并将时间存储在<code class="fe mz na nb mq b">end</code>中</li><li id="31a4" class="no np iq lt b lu nx lx ny le nz li oa lm ob mj nt nu nv nw bi translated">打印开始时间和结束时间之间的差异</li><li id="de16" class="no np iq lt b lu nx lx ny le nz li oa lm ob mj nt nu nv nw bi translated">返回<code class="fe mz na nb mq b">multiply(2, 3)</code>的输出，这样我们就可以看到它和print语句。</li></ul><h2 id="a375" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么这很酷</h2><p id="dc96" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">这种内部和外部函数的双层结构使我们能够将<code class="fe mz na nb mq b">timer</code>附加到像<code class="fe mz na nb mq b">multiply</code>这样的特定函数上，然后任意多次使用这两个函数的组合。我们可以调用<code class="fe mz na nb mq b">m(4, 5)</code>或<code class="fe mz na nb mq b">m(234329, 2343823)</code>或任何其他两个我们想要的数字，每次我们都会得到运行时间的打印输出以及数字的乘积。</p><h2 id="2193" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何运行定时器()</h2><p id="655f" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">因为这是一个嵌套函数，所以它不会给出我们想要的常规函数调用的输出。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c66e" class="kv kw iq mq b gy mu mv l mw mx">timer(add(1,3))</span><span id="46ac" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]: </strong>&lt;function __main__.timer.&lt;locals&gt;.inner_func(*args, **kwargs)&gt;</span></pre><h2 id="926a" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">是时候给装修工打电话了</h2><p id="7d16" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">有两种方法可以叫装修工。传统的方式是这样的:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="37a4" class="kv kw iq mq b gy mu mv l mw mx">add = timer(add)</span><span id="c6dd" class="kv kw iq mq b gy my mv l mw mx">add(1, 3)</span><span id="63a4" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]:</strong> Run time: 0.00000065 seconds<br/>       4</span></pre><p id="ddc8" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">注意变量赋值不是<code class="fe mz na nb mq b">a = timer(add)</code>或<code class="fe mz na nb mq b">some_other_variable = timer(add)</code>。使用装饰器，你总是给你的变量起一个和你正在装饰的函数一样的名字。为什么？以便它看起来与原始函数相同。它将接受与原始函数相同的参数，并执行与原始函数相同的操作——但现在它也将拥有装饰函数的属性。</p><p id="dd71" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">Python有一个更好的方法来做同样的事情。我们可以使用<code class="fe mz na nb mq b">@ </code>符号。</p><p id="1c11" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">首先，您将编写装饰函数。然后你可以在你想要修饰的函数的定义上使用<code class="fe mz na nb mq b">@decorator_function_name</code>把它附加到另一个函数上。确保不要在<code class="fe mz na nb mq b">@</code>和装饰函数名之间留空格，也不要在装饰函数名后面使用任何括号。我重写一下<code class="fe mz na nb mq b">add</code>:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5f1c" class="kv kw iq mq b gy mu mv l mw mx"><strong class="mq ir">@timer</strong><br/><strong class="mq ir">def</strong> add(a, b):<br/>    """<br/>    Takes two parameters, a and b, and returns their sum.<br/>    """<br/>    <strong class="mq ir">return</strong> a + b</span></pre><p id="654f" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">现在我们告诉它把1和3相加:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="52cb" class="kv kw iq mq b gy mu mv l mw mx">add(1, 3)</span><span id="89ed" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]:</strong> Run time: 0.00000063 seconds<br/>       4</span></pre><p id="9163" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">有用！我们得到了运行时间和总和。</p><h2 id="928a" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">让我们再装饰一些</h2><p id="f665" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们可以将<code class="fe mz na nb mq b">timer</code>附加到任何新功能的外部。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9876" class="kv kw iq mq b gy mu mv l mw mx"><strong class="mq ir">@timer</strong><br/><strong class="mq ir">def</strong> add_more(a, b, c, d):<br/>    """ <br/>    Takes four parameters, a, b, c, and d, and returns their sum.<br/>    """<br/>    <strong class="mq ir">return</strong> a + b + c + d<br/></span><span id="cfd3" class="kv kw iq mq b gy my mv l mw mx">add_more(1, 3, 4, 6)</span><span id="e2b2" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]:</strong> Run time: 0.00000081 seconds<br/>       14</span></pre><p id="11cd" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">呜-呼！</p><h2 id="3e45" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一个小问题…</h2><p id="9f1e" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">还记得帮助文档吗？这会表现得很奇怪。</p><p id="c8c5" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><code class="fe mz na nb mq b">@timer</code>通过执行相同的操作修改了原来的<code class="fe mz na nb mq b">add</code>和<code class="fe mz na nb mq b">add_more</code>功能，就像我们重新分配了它们的名称一样，如下所示:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d392" class="kv kw iq mq b gy mu mv l mw mx">add = timer(add)<br/>add_more = timer(add_more)</span></pre><p id="e3f0" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">重新分配函数名会覆盖那些函数，因此我们不再能够访问它们的元数据。下面是我们调用<code class="fe mz na nb mq b">help()</code>时发生的情况。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c9a3" class="kv kw iq mq b gy mu mv l mw mx">help(add)<br/> <br/><strong class="mq ir">[Out]:</strong> Help on function inner_func in module __main__:<br/>       <br/>    inner_func(*args, **kwargs)<br/>        This is the inner function that the timer decorator returns.</span><span id="232f" class="kv kw iq mq b gy my mv l mw mx">help(add_more)</span><span id="3aa2" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]:</strong> Help on function inner_func in module __main__:</span><span id="2772" class="kv kw iq mq b gy my mv l mw mx">     inner_func(*args, **kwargs)<br/>        This is the inner function that the timer decorator returns.</span></pre><p id="fecb" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">啊。调用<code class="fe mz na nb mq b">help()</code>现在给我们提供了<code class="fe mz na nb mq b">timer()</code>内部函数的文档字符串，这显然没有帮助。</p><h2 id="ae18" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">有解决办法吗？</h2><p id="848e" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">为什么是的有。而且很简单。</p><p id="31dc" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">Python的标准库包括<code class="fe mz na nb mq b">functools</code>，它有一个专门的工具，用于保存修饰函数的元数据。它叫做<code class="fe mz na nb mq b">wraps</code>，本身就是一个装饰器。我们可以通过修饰<code class="fe mz na nb mq b">inner_func</code>在<code class="fe mz na nb mq b">timer()</code>的定义里面使用它。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a587" class="kv kw iq mq b gy mu mv l mw mx"><strong class="mq ir">def</strong> <strong class="mq ir">timer(fn):</strong><br/>    """<br/>    This is a decorator that returns the time it takes another function to run.<br/>    """<br/>    <strong class="mq ir">from</strong> time <strong class="mq ir">import</strong> perf_counter<br/>    <strong class="mq ir">from</strong> functools <strong class="mq ir">import</strong> wraps</span><span id="d1f1" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">    @wraps(fn)</strong><br/>    <strong class="mq ir">def inner_func(*args, **kwargs):</strong><br/>        """<br/>        This is the inner function that the timer decorator returns.<br/>        """<br/>        start = perf_counter()<br/>        result = fn(*args, **kwargs)<br/>        end = perf_counter()<br/>        print(f'Run time: {(end — start):0.8f} seconds')<br/> <br/>        <strong class="mq ir">return</strong> result</span><span id="b7d5" class="kv kw iq mq b gy my mv l mw mx">   <strong class="mq ir">return</strong> inner_func</span></pre><p id="501e" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">请注意，<code class="fe mz na nb mq b">wraps()</code>与<code class="fe mz na nb mq b">timer()</code>一样将<code class="fe mz na nb mq b">fn</code>作为参数。不要漏掉那一点，否则它不会起作用。</p><p id="ff89" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">现在我们需要重新定义<code class="fe mz na nb mq b">add()</code>和<code class="fe mz na nb mq b">add_more()</code>函数，使它们的名字指向这个更新的计时器。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9db2" class="kv kw iq mq b gy mu mv l mw mx"><strong class="mq ir">@timer</strong><br/><strong class="mq ir">def add(a, b):</strong><br/>    """<br/>    Takes two parameters, a and b, and returns their sum.<br/>    """<br/>    <strong class="mq ir">return</strong> a + b</span><span id="769e" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">@timer<br/>def add_more(a, b, c, d):</strong><br/>    """<br/>    Takes four parameters, a, b, c, and d, and returns their sum.<br/>    """<br/>    <strong class="mq ir">return</strong> a + b + c + d</span></pre><p id="3f13" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">他们像以前一样工作:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f79e" class="kv kw iq mq b gy mu mv l mw mx">add(1, 3)</span><span id="e427" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]:</strong> Run time: 0.00000078 seconds<br/>       4</span><span id="5bae" class="kv kw iq mq b gy my mv l mw mx"><br/>add_more(1, 3, 4, 6)</span><span id="89e3" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]:</strong> Run time: 0.00000070 seconds<br/>       14<br/></span></pre><p id="f18c" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">但是现在当我们调用<code class="fe mz na nb mq b">help()</code>时，我们得到了我们想要的。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3a5d" class="kv kw iq mq b gy mu mv l mw mx">help(add)</span><span id="69cf" class="kv kw iq mq b gy my mv l mw mx"><strong class="mq ir">[Out]:</strong> Help on function add in module __main__:</span><span id="914e" class="kv kw iq mq b gy my mv l mw mx">       add(a, b)<br/>         Takes two parameters, a and b, and returns their sum.<br/><br/> <br/>help(add_more)<br/><br/><strong class="mq ir">[Out]:</strong> Help on function add_more in module __main__:</span><span id="49c7" class="kv kw iq mq b gy my mv l mw mx">     add_more(a, b, c, d)<br/>       Takes four parameters, a, b, c, and d, and returns their sum. </span></pre><p id="031a" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">耶！！！</p><p id="6cb6" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我鼓励你亲自尝试一下。复制粘贴第二个<code class="fe mz na nb mq b">timer</code>代码，然后写几个函数来装饰它。如果你知道如何写一些简单的递归函数和循环函数，看看它们的相对速度会很有趣。(提示:一个比另一个快很多。)</p><p id="b2ff" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">点击<a class="ae oc" href="https://github.com/LBBL96/Pandas-Web-Scraping-Tutorial/blob/master/Articles/Decorators/WhatsADecorator.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>在<a class="ae oc" href="https://github.com/LBBL96" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上下载我的Jupyter笔记本，里面有这段代码。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="eb1a" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">非常感谢Fred Baptiste博士，他的<a class="ae oc" href="https://www.udemy.com/course/python-3-deep-dive-part-1/" rel="noopener ugc nofollow" target="_blank">“深入Python”</a>帮助我更好地理解了这种语言的内部工作原理。</p></div></div>    
</body>
</html>