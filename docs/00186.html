<html>
<head>
<title>Drupal 8 Core and Symfony Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Drupal 8核心和Symfony组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/drupal-8-core-and-symfony-components-e5272561d304?source=collection_archive---------0-----------------------#2018-08-06">https://levelup.gitconnected.com/drupal-8-core-and-symfony-components-e5272561d304?source=collection_archive---------0-----------------------#2018-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/75a024b47133585d7deccfb8abd12d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h5v088DWMS_VcTv8.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.adcisolutions.com/?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=medium-Drupal-Smf-adciwebsite&amp;utm_term=-&amp;utm_content=medium-Drupal-Symfony" rel="noopener ugc nofollow" target="_blank">由ADCI解决</a></figcaption></figure><p id="c57c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自从<strong class="kf ir"> Drupal 8 </strong>发布以来已经过去了很长时间。Drupal没有仅仅使用面向钩子的范例和过程化编程，而是选择了一种集成流行技术和应用面向对象方法的方式。变更影响了几乎所有的主要部分——从核心功能到模板引擎。</p><p id="808e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<strong class="kf ir"> Symfony组件</strong>添加到Drupal 8对其开发影响最大。Drupal变得比以前更加灵活。开发人员有机会利用现代技术和面向对象的编程风格。</p><p id="5c76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文重点讨论添加Symfony组件导致的公共核心功能的变化。在这里，您可以找到简化的代码示例，帮助您感受“清晰”的Symfony和Drupal 8解决方案之间的差异。对于你们中的一些人来说，这可能是更好地理解Drupal 8内部结构的关键点。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="daa1" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Drupal 8中的Symfony组件</h1><p id="a3ff" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">根据Symfony文档，Drupal 8包含以下组件:</p><ul class=""><li id="2abe" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">类加载器</li><li id="e8b5" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">安慰</li><li id="4c57" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">CssSelector</li><li id="7b7f" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">依赖性注射</li><li id="5021" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">事件调度员</li><li id="a840" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">HttpFoundation</li><li id="99c0" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">HttpKernel</li><li id="b6b9" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">过程</li><li id="18b1" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">按指定路线发送</li><li id="dd38" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">串行器</li><li id="e223" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">翻译</li><li id="70d1" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">验证器</li><li id="1776" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">Yaml</li></ul><p id="da06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你应该明白这并不是一个完整的列表，因为Symfony社区并没有跟踪自Drupal 8发布以来添加到核心中的所有变化。然而，在这里我们可以看到，Drupal核心的几个基础组件。我将讨论DependencyInjection、EventDispatcher和路由。Drupal 8架构中最大的变化与这些组件的集成有关。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/62f18eae1672a8c93f18b0f9a07980e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9spmWiu02rDzvcmO.jpg"/></div></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="cbf7" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Symfony中的依赖注入和服务</h1><p id="c32a" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在解释<strong class="kf ir"> DependencyInjection组件</strong>时，不可能不提服务和服务容器主题。一般来说，服务是由服务容器管理的任何对象。服务容器是每个服务所在的特殊对象。这种方法使服务的使用更加标准化和灵活。额外的好处是，您可以获得一种优化的服务处理方法。如果你从不要求一项服务，它就永远不会被构建。服务只创建一次——每次请求时都返回相同的实例。</p><p id="e806" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在Symfony中有服务容器，您可以很容易地通过它的id获得服务:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b386" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建一个定制服务，您只需要将必要的代码(通常是您希望在应用程序中重用的代码)添加到一个新的类中。下面是这样一个类的例子。它包含了一个从数组中获取随机用户名的方法。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f33b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="nf"> services.yml </em>文件中，您可以指定服务容器如何实例化这个服务类。在这里可以指定大量的参数。如需更多信息，您可以查看<a class="ae kc" href="http://symfony.com/doc/2.8/service_container.html" rel="noopener ugc nofollow" target="_blank">本主题</a>。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7a56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。您的服务具有唯一的密钥，它在服务容器中可用。在你的控制器中使用这个服务怎么样？</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9a06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您可能看到的，使用定制服务和任何现有的服务没有区别。</p><p id="c91e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以讨论DependencyInjection组件本身了。它提供了几个有用的类来操作服务及其依赖项。让我们创建一个额外的服务来演示这个功能。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="67a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ContainerBuilder类允许您将刚刚创建的类注册为服务。可以通过以下方式完成:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3c4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的目标是增加<em class="nf">彩票</em>和<em class="nf">奖品</em>服务之间的依赖关系。定义<em class="nf">奖</em>服务时，<em class="nf">彩票</em>服务还不存在。你需要使用<em class="nf">引用</em>类来告诉容器在初始化时注入<em class="nf">彩票</em>服务。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="cf7b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Drupal中的依赖注入和服务</h1><p id="67f5" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Drupal稍微扩展了这个方案。为了定义服务和附加参数，它使用了几个yml文件。核心服务在<em class="nf"> core.services.yml </em>文件中定义。通过在各自的目录中创建<em class="nf">modulename . services . yml</em>文件，模块可以在容器中注册它们自己的服务。Drupal使用<em class="nf"> ServiceProvider </em>类(<em class="nf">CoreServiceProvider.php</em>文件)来注册核心服务。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8a98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该类包含<em class="nf"> register() </em>方法，在该方法中，您可以从DependencyInjection组件中找到<em class="nf"> ContainerBuilde </em> r类。其他模块应用相同的原则在服务容器中注册它们自己的服务。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="eec0" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Symfony中的事件和调度事件</h1><p id="f9a8" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">调度事件系统由<strong class="kf ir"> EventDispatcher组件</strong>提供。它包括三个部分:</p><ul class=""><li id="aad3" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">Dispatcher —允许您注册新侦听器或订户的主要对象。</li><li id="e0d5" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">Listener或Subscriber —您需要连接到调度程序的对象，以便在调度事件时得到通知。</li><li id="2a5b" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">事件-描述事件的事件类。</li></ul><p id="26a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试着扩展前面的例子。假设您想在随机用户获奖时通知应用程序的其他部分。首先，您需要定义一个dispatcher对象，并将一个侦听器与这个dispatcher连接起来。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="262c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么它是值得的照顾您的自定义事件。在创建第三方库时，或者如果您只是想使整个系统更具解耦性和灵活性时，会经常使用自定义事件。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e47a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，每个监听器都可以通过<em class="nf"> getPrize() </em>方法访问<em class="nf"> Prize </em>对象。在调度过程中，您需要为事件传递一个机器名。因此，<em class="nf">名</em>常量是在类内部定义的。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cc6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<em class="nf"> lottery.complete </em>事件的任何监听器都将获得<em class="nf"> LotteryCompleteEvent </em>对象。</p><p id="7577" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我使用了event listener对象，但是，实际上，用subscriber对象替换它不成问题。侦听器和订阅者之间的主要区别在于订阅者能够将一组订阅事件传递给调度程序。订阅者实现了<em class="nf">EventSubscriberInterface</em>接口。它需要一个名为<em class="nf"> getSubscribedEvents() </em>的静态方法。在此方法中，您应该指定一个事件列表。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="dd64" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Drupal中的事件和调度事件</h1><p id="491d" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">关于调度事件机制，你不会发现在Symfony和Drupal 8中使用它有什么不同。在这里，我们只需要讨论在定制模块中使用这种方法，以及Drupal与调度事件功能相关的可能的未来计划。</p><p id="4c38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要定义事件、调度程序和订户类，您需要执行以下操作:</p><ol class=""><li id="6efd" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la ng mr ms mt bi translated">需要在模块根目录下的<em class="nf"> src/ </em>文件夹下定义<em class="nf">事件</em>类。例如，假设它是<em class="nf"> src/CustomEvent.php </em>。这个类应该扩展EventDispatcher组件的<em class="nf">事件</em>类。</li><li id="2827" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la ng mr ms mt bi translated">您需要将该事件分派到某个地方，这取决于模块操作的逻辑。</li><li id="50fc" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la ng mr ms mt bi translated">在<em class="nf"> src/EventSubscriber </em>目录下，您需要创建一个事件订阅者类—<em class="nf">src/Event Subscriber/customeventsubscriber . PHP</em>。这个类必须实现<em class="nf">EventSubscriberInterface</em>接口。它还必须包含一个名为<em class="nf"> getSubscribedEvents() </em>的静态方法，您需要在其中定义一个订阅事件列表。</li><li id="54cc" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la ng mr ms mt bi translated">在<em class="nf">modulename . services . yml</em>文件中将事件订阅者标记为<em class="nf">‘Event _ Subscriber’</em>。您可以在<a class="ae kc" href="http://symfony.com/doc/current/service_container/tags.html" rel="noopener ugc nofollow" target="_blank"> Symfony文档</a>中找到关于使用标签的必要信息。</li></ol><p id="b02c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是调度一些事件并对它们做出反应所需要做的全部工作。</p><p id="4471" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Events系统可以很好地替代Drupal 8从上一版本继承的hook范式。尽管许多部分已经使用事件进行了返工，Drupal 8仍然使用钩子。有一些尝试是关于用事件代替一些众所周知的钩子。<a class="ae kc" href="https://www.drupal.org/project/hook_event_dispatcher" rel="noopener ugc nofollow" target="_blank">钩子事件分配器</a>模块是这种方法的一个很好的例子。</p><h1 id="1937" class="li lj iq bd lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb nl md me mf bi translated">Symfony中的路由</h1><p id="a40e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">根据<a class="ae kc" href="http://symfony.com/doc/current/components/routing.html" rel="noopener ugc nofollow" target="_blank"> Symfony文档</a>，配置路由系统需要三个主要部分:</p><ul class=""><li id="e6fe" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">RouteCollection包含路径定义</li><li id="7eaa" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">RequestContext —包含请求的必要参数</li><li id="be2f" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">UrlMatcher —执行请求和单个路由之间的映射</li></ul><p id="912e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些都是来自<strong class="kf ir">路由组件</strong>的类。为了更好地理解，我们来看一个简单的例子:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d08a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外一个重要的我没有加到上面列表的是<em class="nf">路由</em>类。它允许您定义一条路线。然后将每条路线添加到<em class="nf"> RouteCollection </em>对象中。这个动作是通过使用<em class="nf"> RouteCollection::add() </em>方法来执行的。</p><p id="c517" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nf"> UrlMatcher::match() </em>方法返回指定路由的可用参数。如果没有这样的路由，将抛出<em class="nf">ResourceNotFoundException</em>。</p><p id="64ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要为某个路由生成url，您需要使用UrlGenerator::generate()方法。您可以将路由变量传递给此方法。例如，如果在路线中有一个通配符占位符，它会很有用。</p><p id="f608" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了使用这种方法来配置路由系统之外，还可以从多个不同的文件中加载路由。这里一切都依赖于<em class="nf"> FileLocator </em>类。您可以使用这个类定义一个路径数组来检查所请求的文件。对于每个找到的文件，加载程序返回一个<em class="nf"> RouteCollection </em>对象。</p><h1 id="d0e2" class="li lj iq bd lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb nl md me mf bi translated">Drupal中的路由</h1><p id="1434" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">一般来说，Drupal 8使用与Symfony相同的机制来处理路由。路由组件取代了Drupal 7中的<em class="nf"> hook_menu() </em>。请注意，路由系统不支持选项卡、操作和上下文链接的创建。因此，之前由<em class="nf"> hook_menu() </em>处理的功能被其他子系统接管。</p><p id="db8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建一些路线，您需要在模块的<em class="nf"> modulename.routing.yml </em>文件中定义它们。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，系统会检查对指定路径的访问权限。如果一切正常，它从控制器调用<em class="nf">MyRoutesController::content()</em>方法。</p><p id="8bdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果需要，您可以在路径参数中为您的路线指定一个通配符(也称为<em class="nf"> slug </em>)。只可能在斜杠之间或最后一个斜杠之后使用这样的通配符。</p><p id="c49b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们指定了<em class="nf">类别</em>通配符。让我们看看如何在控制器中应用这一点:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="626e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请务必使用与path参数中为通配符指定的名称相同的名称。根据变量的名称搜索相应的变量。它不依赖于变量的指定顺序。</p><p id="02a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了创建您自己的路线，您还可以更改现有的路线。多亏了<em class="nf"> RoutingEvents::ALTER </em>事件，这才成为可能。该事件在构建路线后触发。要使用该功能，您需要扩展<em class="nf"> RouterSubscriberBase </em>类并实现该类的<em class="nf">alter routes(route collection $ collection)</em>方法。</p><h1 id="b2ea" class="li lj iq bd lk ll nh ln lo lp ni lr ls lt nj lv lw lx nk lz ma mb nl md me mf bi translated">结论</h1><p id="4d85" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们考虑了与Drupal 8中Symfony组件的存在相关的几个要点。当然，这并不是一个完整的列表，但是我认为这些组件在决定Drupal 8开发的主要方向方面发挥了关键作用。Drupal变得更加灵活。现在甚至可以重新定义其核心的许多部分的行为。</p><p id="a31e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用服务和依赖注入可以让您的代码更加灵活，更容易重用。通过应用DependencyInjection组件，您有机会为您的类获得所需依赖关系的统一定义。挂钩部分被EventDispatcher组件中的事件系统所取代。它允许对应用程序不同部分之间的关系进行更多的控制。路由组件中的路由系统取代了hook_menu()的功能。它变得更实用、更灵活、可读性更强。</p><p id="0de7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，Drupal 8中的大部分解决方案都是基于前面提到的Symfony组件。Drupal只是扩展了一些方法，在某些情况下，使它们更加灵活。所有这些都代表了为什么Drupal 8对Symfony开发者更有吸引力。基于这些事实，我们有充分的理由相信Drupal选择了正确的发展道路。期待看到未来版本的变化！</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aa03b1f6f475a595dd9ba6da0e952d97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDDqRrPTndC88OOIMjF9RA.jpeg"/></div></div></figure><p id="ab98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nf">原发布于</em><a class="ae kc" href="https://www.adcisolutions.com/knowledge/drupal-8-core-and-symfony-components?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=medium-Drupal-Smf-knowledge&amp;utm_term=-&amp;utm_content=medium-Drupal-Symfony" rel="noopener ugc nofollow" target="_blank"><em class="nf">ADCI解决方案网站</em> </a> <em class="nf">。</em></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="0a38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">作者是ADCI解决方案团队负责人叶夫根尼·列昂诺夫</strong></p><p id="b976" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">展示项目中不同角色的同等熟练程度:从开发人员到团队领导。尽管Evgeny是一个丰富技术堆栈的专家，但他设法在弹吉他、学日语和健身之间保持平衡。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="ab gu cl nm"><img src="../Images/73bcb62bbfda355e913e5b86e2193e46.png" data-original-src="https://miro.medium.com/v2/format:webp/1*5kC2KhUXG-R8C8-59J1RCA.png"/></div></figure><p id="f79a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在社交网络上关注我们: <a class="ae kc" href="https://twitter.com/ADCISolutions" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae kc" href="https://www.facebook.com/adcisolutions/" rel="noopener ugc nofollow" target="_blank">脸书</a> | <a class="ae kc" href="https://www.linkedin.com/company/adci-solutions/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a></p><div class="nn no gp gr np nq"><a href="https://code.likeagirl.io/oop-in-drupal-8-and-how-to-use-it-to-create-a-custom-module-1f371308e981" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">Drupal 8中的OOP以及如何使用它来创建自定义模块</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">我只有一年的web开发经验，尤其是Drupal 7的基础知识</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">code.likeagirl.io</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe jw nq"/></div></div></a></div></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="of ne l"/></div></figure></div></div>    
</body>
</html>