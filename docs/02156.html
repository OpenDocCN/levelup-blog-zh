<html>
<head>
<title>More RxJS Transformation Operators — Window</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多RxJS变换运算符-窗口</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/more-rxjs-transformation-operators-window-4399bf333a41?source=collection_archive---------6-----------------------#2020-02-22">https://levelup.gitconnected.com/more-rxjs-transformation-operators-window-4399bf333a41?source=collection_archive---------6-----------------------#2020-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2357894a13e47c914959dd584654ef0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*adcTOUdBQcaLGoPz"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">anthony renovato 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c656" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RxJS是一个反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="0ae6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看一些窗口操作符，包括<code class="fe le lf lg lh b">windowCount</code>、<code class="fe le lf lg lh b">windowTime</code>、<code class="fe le lf lg lh b">windowToggle</code>和<code class="fe le lf lg lh b">windowWhen</code>操作符。</p><h1 id="5c17" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">窗口计数</h1><p id="4d3f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">windowCount</code>操作符将源可观察值分支为嵌套可观察值，每个可观察值最多发出<code class="fe le lf lg lh b">windowSize</code>个事件。</p><p id="12f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它最多需要两个参数。第一个参数是<code class="fe le lf lg lh b">windowSize</code>，它是每个窗口发出的值的最大数量。</p><p id="875c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是可选的。是<code class="fe le lf lg lh b">startWindowEvery</code>号，默认为0。这是开始一个新窗口的间隔。间隔是由可观测的源发射的项目的数量来测量的。</p><p id="10fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5766" class="mt lj it lh b gy mu mv l mw mx">import { interval } from "rxjs";<br/>import { windowCount, mergeAll, take, map, skip } from "rxjs/operators";</span><span id="78f9" class="mt lj it lh b gy my mv l mw mx">const nums = interval(1000).pipe(take(1000));<br/>const result = nums.pipe(<br/>  windowCount(3, 3),<br/>  map(win =&gt; win.pipe(skip(1))),<br/>  mergeAll()<br/>);<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="d373" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有<code class="fe le lf lg lh b">nums</code> Observable，它每秒发出一个数字，最大为1000。</p><p id="6301" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是<code class="fe le lf lg lh b">windowCount</code>操作符的<code class="fe le lf lg lh b">pipe</code> d，它一次发出3个值，并在从<code class="fe le lf lg lh b">nums</code>发出3个值后开始一个新窗口。</p><p id="f4e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后是<code class="fe le lf lg lh b">map</code> ped到<code class="fe le lf lg lh b">win.pipe(skip(1))</code>可观察值，每发出2个值就跳过1个值。</p><p id="f99f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们通过管道将这些值传递给<code class="fe le lf lg lh b">mergeAll</code>以将所有的可观察值合并成一个。</p><p id="2cc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该看到每三个数字中没有一个被发射。</p><h1 id="73e1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">窗口时间</h1><p id="0258" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">windowTime</code>操作符返回一个可观察对象，该对象在<code class="fe le lf lg lh b">windowTimeSpan</code>设置的窗口周期内发出项目窗口。</p><p id="63e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它最多接受两个参数，即<code class="fe le lf lg lh b">windowTimeSpan</code>，第二个是可选参数，即<code class="fe le lf lg lh b">scheduler</code>对象。</p><p id="3495" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5292" class="mt lj it lh b gy mu mv l mw mx">import { interval } from "rxjs";<br/>import { windowTime, mergeAll, take, map } from "rxjs/operators";</span><span id="fde6" class="mt lj it lh b gy my mv l mw mx">const nums = interval(1000);<br/>const result = nums.pipe(<br/>  windowTime(1000, 5000),<br/>  map(win =&gt; win.pipe(take(2))),<br/>  mergeAll()<br/>);<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="9463" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有<code class="fe le lf lg lh b">nums</code> Observable，它每秒发出从0开始的值。然后发出的值被<code class="fe le lf lg lh b">pipe</code> d给<code class="fe le lf lg lh b">windowTime</code>操作符，它每5秒启动一个1秒长的窗口。然后我们从每个窗口取2个值</p><p id="2c4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将导致每个窗口中有3个值被跳过，因为<code class="fe le lf lg lh b">nums</code>每分钟都会发出值，但是我们<code class="fe le lf lg lh b">take</code>每个窗口只有2个值。</p><h1 id="876d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">窗口切换</h1><p id="d0f3" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">windowToggle</code>将源可观察值分支为嵌套可观察值，从<code class="fe le lf lg lh b">openings</code>发射开始，到<code class="fe le lf lg lh b">closingSelector</code>发射结束。</p><p id="2d01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它最多需要两个参数。第一个是<code class="fe le lf lg lh b">openings</code>，这是一个可观察到的启动新窗口的通知。</p><p id="6f3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个是<code class="fe le lf lg lh b">closingSelector</code>，它接受由<code class="fe le lf lg lh b">openings</code>发出的值，并返回一个发出<code class="fe le lf lg lh b">next</code>或<code class="fe le lf lg lh b">complete</code>信号的可观察值，该信号将关闭窗口。</p><p id="b34b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d718" class="mt lj it lh b gy mu mv l mw mx">import { interval, EMPTY } from "rxjs";<br/>import { windowToggle, mergeAll } from "rxjs/operators";</span><span id="1fee" class="mt lj it lh b gy my mv l mw mx">const interval$ = interval(2000);<br/>const openings = interval(2000);<br/>const result = interval$.pipe(<br/>  windowToggle(openings, i =&gt; (i % 3 === 0 ? interval(500) : EMPTY)),<br/>  mergeAll()<br/>);<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="c0b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们观察到<code class="fe le lf lg lh b">interval$</code>每2秒钟发出一个数字。然后我们对<code class="fe le lf lg lh b">openings</code>有相同的可观察值。<code class="fe le lf lg lh b">interval$</code>发出的值是<code class="fe le lf lg lh b">pipe</code> d到<code class="fe le lf lg lh b">windowToggle</code>操作符，该操作符将<code class="fe le lf lg lh b">openings</code>可观察值作为第一个参数，每2秒发出一次。所以我们每2秒钟打开一个新窗口。</p><p id="907a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有了第二个功能:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3d3d" class="mt lj it lh b gy mu mv l mw mx">i =&gt; (i % 3 === 0 ? interval(500) : EMPTY)</span></pre><p id="9dd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当输入的值不能被3整除时关闭窗口。这意味着我们记录了从<code class="fe le lf lg lh b">interval$</code>发出的每3个值。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/fff3abad668cd4b572406390a56908a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-9w_p--VvD-hpFB4"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@cliff_77?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里夫·约翰逊</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="3792" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">窗口时间</h1><p id="89c9" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">windowWhen</code>操作符使用<code class="fe le lf lg lh b">closingSelector</code>函数将源可观察对象分支出来，返回一个关闭窗口的可观察对象。</p><p id="cd98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它采用<code class="fe le lf lg lh b">closingSelector</code>函数，该函数采用由<code class="fe le lf lg lh b">openings</code>发出的值，并返回一个发出<code class="fe le lf lg lh b">next</code>或<code class="fe le lf lg lh b">complete</code>信号的可观察值，该信号将关闭窗口。</p><p id="e591" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f7ce" class="mt lj it lh b gy mu mv l mw mx">import { interval } from "rxjs";<br/>import { mergeAll, take, windowWhen, map } from "rxjs/operators";</span><span id="99e6" class="mt lj it lh b gy my mv l mw mx">const interval$ = interval(2000);<br/>const result = interval$.pipe(<br/>  windowWhen(() =&gt; interval(Math.random() * 4000)),<br/>  map(win =&gt; win.pipe(take(2))),<br/>  mergeAll()<br/>);<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="e483" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有每2秒钟发出一个数字的<code class="fe le lf lg lh b">interval$</code>。然后发出的值是<code class="fe le lf lg lh b">pipe</code> d到<code class="fe le lf lg lh b">windowWhen</code>操作符，它有<code class="fe le lf lg lh b">closingSelector</code> ve:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fc0d" class="mt lj it lh b gy mu mv l mw mx">() =&gt; interval(Math.random() * 4000)</span></pre><p id="0dfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着窗口将关闭并重新打开<code class="fe le lf lg lh b">Math.random() * 4000</code>毫秒。</p><p id="e485" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该意识到有些数字比其他数字发射得快。</p><p id="482c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">windowCount</code>操作符将源可观察值分支为嵌套可观察值，每个值最多发出<code class="fe le lf lg lh b">windowSize</code>个事件。<code class="fe le lf lg lh b">windowSize</code>是每个窗口的大小。</p><p id="0325" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">windowTime</code>运算符返回一个可观测值，该可观测值在<code class="fe le lf lg lh b">windowTimeSpan</code>设置的窗口期内发出项目窗口。<code class="fe le lf lg lh b">windowTimeSpan</code>设置窗口打开的时间。</p><p id="da80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">windowToggle</code>将源可观察值分支为嵌套可观察值，从<code class="fe le lf lg lh b">openings</code>发射开始，到<code class="fe le lf lg lh b">closingSelector</code>发射结束。<code class="fe le lf lg lh b">openings</code>和<code class="fe le lf lg lh b">closingSelector</code>功能是可观察值，分别控制每个可观察值的窗口打开和关闭。</p><p id="aceb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">windowWhen</code>操作符使用<code class="fe le lf lg lh b">closingSelector</code>函数分支出源可观察对象，返回一个关闭窗口的可观察对象。</p></div></div>    
</body>
</html>