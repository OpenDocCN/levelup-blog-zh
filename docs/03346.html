<html>
<head>
<title>Unit Testing with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python进行单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-testing-with-python-736112619620?source=collection_archive---------11-----------------------#2020-05-04">https://levelup.gitconnected.com/unit-testing-with-python-736112619620?source=collection_archive---------11-----------------------#2020-05-04</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="441b" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">验证您的Python代码是否正常工作</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/a7b765560ed6deef84dbe9d4215783f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCepk89R2z0Jp3OyWdvJ8Q.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">Python中的单元测试，图片作者</figcaption></figure><p id="30c5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">每年我都试图学习一门新的编程语言。今年开始学Python。</p><p id="d7c3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在我白天的工作中，我是一名职业程序员。我用的是C++，C#，Javascript。我是一个开发团队的成员，该团队使用单元测试来验证我们的代码是否如预期的那样工作。</p><p id="7da7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在本文中，我通过讨论以下主题来研究如何用Python创建单元测试。</p><ul class=""><li id="08fd" class="lv lw iu lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">单元测试基础</li><li id="4313" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">可用的Python测试框架</li><li id="a421" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">测试设计原则</li><li id="4ff2" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">测试双打</li><li id="dc0e" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">代码覆盖率</li></ul><p id="ada4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了能够理解本文，我假设您对Python有基本的了解。</p></div><div class="ab cl mj mk hy ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="in io ip iq ir"><h1 id="6976" class="mq mr iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">单元测试基础</h1><p id="32b8" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">我使用FizzBuzz编码表创建了单元测试示例。编码形是程序员的一项练习。在这个练习中，程序员试图解决一个特定的问题。但是<strong class="lb iv">主要的</strong>目标不是解决问题而是练习编程。</p><p id="06c7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有<a class="ae nn" href="https://github.com/gamontal/awesome-katas" rel="noopener ugc nofollow" target="_blank">不同的代码卡塔</a>你可以用来练习；我用的是<strong class="lb iv"> FizzBuzz码形</strong>。FizzBuz是一个简单的代码表，非常适合解释和展示Python中的单元测试。</p><p id="4822" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">FizzBuzz代码形:</p><blockquote class="no np nq"><p id="a889" class="kz la nr lb b lc ld jv le lf lg jy lh ns lj lk ll nt ln lo lp nu lr ls lt lu in bi translated">写一个程序打印从1到100的数字。但是对于三的倍数，打印“嘶嘶”而不是数字，对于五的倍数，打印“嗡嗡”对于3和5的倍数的数字，打印“FizzBuzz”</p></blockquote><p id="d929" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">结合单元测试的例子，我将定义单元测试语言，这样我们就可以互相理解了。</p><h2 id="0ceb" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">单元测试</h2><p id="090a" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">单元测试是由程序员编写的自动化测试，用于测试程序的一小部分。单元测试应该快速运行。与文件系统、数据库或网络交互的测试不是单元测试。</p><p id="4411" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了用Python创建第一个FizzBuzz单元测试，我定义了一个继承自<code class="fe oh oi oj ok b">unittest.TestCase</code>的类。这个<code class="fe oh oi oj ok b">unittest</code>模块在Python的标准安装中可用。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">测试FizzBuzz代码Kata的两个单元测试</figcaption></figure><p id="c43b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">第一个单元测试验证了如果FizzBuzz过滤器接收到数字1，它将返回字符串“1”。第二个单元测试对数字二做同样的事情。</p><h2 id="2c47" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">判例案件</h2><p id="9e84" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">我们将类<code class="fe oh oi oj ok b">FizzBuzzTest</code>中的方法<code class="fe oh oi oj ok b">test_one_should_return_one()</code>称为测试用例。测试用例是测试程序特定部分的实际测试代码。</p><p id="3923" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">第一个测试用例验证了如果数字1通过FizzBuzz过滤器，它将返回字符串“1”。使用<code class="fe oh oi oj ok b">self.assertEqual</code>方法对结果进行了验证。该方法的第一个参数是预期结果，第二个参数是实际结果。</p><p id="d11e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果您查看这两个测试用例，您会发现它们都创建了一个<code class="fe oh oi oj ok b">FizzBuzz</code>类的实例。第一个在第六行，另一个在第十一行。</p><p id="118c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们可以通过重构这两种方法中<code class="fe oh oi oj ok b">FizzBuzz</code>实例的创建来改进代码。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">重构单元测试中FizzBuzz实例的创建</figcaption></figure><p id="070b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们使用<code class="fe oh oi oj ok b">setUp</code>方法来创建<code class="fe oh oi oj ok b">FizzBuzz</code>类的实例。来自<code class="fe oh oi oj ok b">TestCase</code>基类的<code class="fe oh oi oj ok b">setUp</code>在每个测试用例之前被执行。</p><p id="2af3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一个方法<code class="fe oh oi oj ok b">tearDown</code>在每个单元测试执行后被调用。您可以使用它来清理或关闭资源。</p><h2 id="7653" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">试验夹具</h2><p id="00a8" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">方法<code class="fe oh oi oj ok b">setUp</code>和<code class="fe oh oi oj ok b">tearDown</code>是测试夹具的一部分。测试夹具用于配置和构建被测单元。每个测试用例都可以使用这些通用条件。在我们的例子中，我用它来创建FizzBuzz类的实例。</p><p id="8b94" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了运行单元测试，我们需要一个测试运行程序。</p><h2 id="824e" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">测试跑步者</h2><p id="65e2" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">测试运行程序是一个执行所有单元测试并报告结果的程序。Python中的标准测试运行程序可以使用以下命令从终端运行。</p><p id="4040" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oh oi oj ok b">python -m unittest test_fizzbuzz.py</code></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj on"><img src="../Images/5d3298990811ed10564cc5afe07aae2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7_33rRAtRq3lKBQC7VUHQ.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">从命令行运行标准Python测试运行程序</figcaption></figure><h2 id="50be" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">测试套</h2><p id="bf20" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">我们单元测试词汇的最后一个术语是测试套件。测试套件是测试用例或测试套件的集合。通常一套测试包含应该一起运行的测试用例。</p><p id="c58d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有了测试套件，我们完成了单元测试词汇。你现在知道下面的意思和区别了。</p><ul class=""><li id="9b3c" class="lv lw iu lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">测试套</li><li id="361c" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">判例案件</li><li id="ea8a" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">试验夹具</li><li id="8bbe" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">测试跑步者</li><li id="0c78" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">单元测试</li></ul></div><div class="ab cl mj mk hy ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="in io ip iq ir"><h1 id="730b" class="mq mr iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">单元测试设计</h1><p id="8f42" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">测试用例应该设计得很好。测试的名称和你如何组织你的测试是最重要的。</p><h2 id="e6d0" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">测试用例名称</h2><p id="cd4e" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">测试的名称至关重要。它就像一个总结了测试内容的标题。如果测试失败，这是你看到的第一件事。因此，名称应该清楚地表明哪些功能不起作用。</p><p id="eeab" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">测试用例名称的列表应该读起来像一个概要或者一个场景列表。这有助于读者理解被测单元的行为。</p><h2 id="2460" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">构建测试用例方法体</h2><p id="23e1" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">一个设计良好的测试用例由三部分组成。第一部分，<strong class="lb iv">安排</strong>，设置要测试的对象。第二部分<strong class="lb iv">动作</strong>，练习被测单元。最后，第三部分，<strong class="lb iv">断言</strong>，声明应该发生什么。</p><p id="6991" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有时，我会在单元测试中添加这三个部分作为注释，以使其更加清晰。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">在单元测试中添加Arrange、Act和Assert作为注释</figcaption></figure><h2 id="9bf0" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">每个测试用例的单个断言</h2><p id="1a26" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">尽管在一个测试用例中可能有许多断言。我总是尝试使用单个断言。</p><p id="e4cb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">原因是当断言失败时，测试用例的执行停止。因此，您永远不会知道测试用例中的下一个断言是否成功。</p></div><div class="ab cl mj mk hy ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="in io ip iq ir"><h1 id="2c82" class="mq mr iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">使用pytest进行单元测试</h1><p id="f5ec" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">在上一节中，我们使用了<code class="fe oh oi oj ok b">unittest</code>模块。Python的默认安装会安装这个模块。<code class="fe oh oi oj ok b">unittest</code>模块于2001年首次推出。基于JUnit，由Kent Beck和Eric Gamma开发的流行的Java单元测试框架。</p><p id="f954" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一个模块<code class="fe oh oi oj ok b">pytest</code>是目前最流行的Python单元测试框架。相比于<code class="fe oh oi oj ok b">unittest</code>框架，它更加Pythonesque。您可以将测试用例定义为函数，而不是从基类派生。</p><p id="f271" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">由于<code class="fe oh oi oj ok b">pytest</code>不在默认的Python安装中，我们使用Python的安装包PIP来安装它。通过在终端中执行以下命令，可以安装<code class="fe oh oi oj ok b">pytest</code>。</p><p id="126d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oh oi oj ok b">pip install pytest</code></p><p id="5767" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我将第一个FizzBuzz测试用例转换为下面的<code class="fe oh oi oj ok b">pytest</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">首次使用pytest进行FizzBuzz测试</figcaption></figure><p id="a6e2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有三点不同。首先，你不需要导入任何模块。其次，你不需要实现一个类，从一个基类派生。最后，您可以使用标准的Python assert方法来代替自定义方法。</p><h2 id="ed54" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">测试夹具</h2><p id="d1fe" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">正如您所记得的，单元测试模块使用了<code class="fe oh oi oj ok b">setUp</code>和<code class="fe oh oi oj ok b">tearDown</code>来配置和构建被测单元。相反，<code class="fe oh oi oj ok b">pytest</code>使用属性<code class="fe oh oi oj ok b">@pytest.fixture</code>。在测试用例中，可以使用用属性修饰的方法的名称作为参数。</p><p id="7483" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">pytest框架在运行时连接它们，并将<code class="fe oh oi oj ok b">fizzBuzz</code>实例注入到您的测试用例中。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">使用@pytest.fixture通过pytest创建测试夹具</figcaption></figure><p id="23d7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你想模仿单元测试<code class="fe oh oi oj ok b">tearDown()</code>方法的行为，你可以使用同样的方法。你不用<code class="fe oh oi oj ok b">return</code>，而是使用<code class="fe oh oi oj ok b">yield</code>关键字。然后你可以把你的清理代码放在<code class="fe oh oi oj ok b">yield</code>之后。</p><pre class="kk kl km kn gu oo ok op oq aw or bi"><span id="bba8" class="nv mr iu ok b gz os ot l ou ov">@pytest.fixture<br/>def fizzBuzz():<br/>    yield FizzBuzz()<br/>    # put your clean up code here</span></pre><h2 id="8455" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">pytest标记</h2><p id="d2f0" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">标记是可以在各种功能的测试中使用的属性。例如，如果您将skip标记添加到您的测试用例中，测试运行程序将会跳过测试。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">使用跳过标记来跳过一个测试用例</figcaption></figure><h2 id="7c8d" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">pytest插件生态系统</h2><p id="7d13" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">有许多为<code class="fe oh oi oj ok b">pytest</code>增加额外功能的插件。写的时候差不多有<a class="ae nn" href="http://plugincompat.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> 900个插件</a>。比如pytest-html和pytest-sugar。</p><p id="104f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> pytest-html </strong></p><p id="2408" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">pytest-html是为测试结果生成html报告的<code class="fe oh oi oj ok b">pytest</code>插件。当您在构建服务器上运行单元测试时，这非常有用。</p><p id="d6f4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> pytest-sugar </strong></p><p id="733d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">pytest-sugar改变了<code class="fe oh oi oj ok b">pytest</code>的默认外观和感觉。它增加了一个进度条，并立即显示失败的测试。</p></div><div class="ab cl mj mk hy ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="in io ip iq ir"><h1 id="54e6" class="mq mr iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">使用测试替身(存根、模拟和伪造)</h1><p id="e099" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">如果您想要单独测试模块或类，但是该模块或类依赖于不同的类，您可以使用Test Double来替换依赖关系。</p><p id="218e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">替身演员就像替身演员。它是出于测试目的替换生产对象的通用术语。有各种各样的测试双打。</p><p id="769e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我使用杰拉德·梅萨罗什的<a class="ae nn" href="http://xunitpatterns.com/" rel="noopener ugc nofollow" target="_blank"> xUnit测试模式</a>中的以下定义。</p><ul class=""><li id="1eee" class="lv lw iu lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iv">模拟</strong>是预编程的预期，形成了它们预期接收的呼叫的规范。如果他们收到一个他们不期望的调用，他们可以抛出一个异常，并在验证过程中进行检查，以确保他们得到了他们期望的所有调用。</li><li id="e65e" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iv">假的</strong>对象有工作的实现，但是通常采用捷径，这使得它们不适合生产，例如，内存中的数据库。</li><li id="dfd5" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">存根为测试过程中的呼叫提供固定的答案，通常对测试程序之外的任何事情都不作回应。</li></ul><h2 id="8b95" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">使用unittest创建存根。模拟的</h2><p id="f83b" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">为了能够演示存根的使用，我们将离开FizzBuzz，使用一个不同的示例。在这个示例中，我们将实现一个警报类，当温室中的温度达到某个阈值时，该类将生成警报。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/baf0581ec4288f3fbedea0d7fdbe3f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*4Dkr0nIVfUZDiwKAvuZOJA.png"/></div></figure><p id="b6e5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我想测试警报功能。但是我不想使用实际的Sensor类，而是想使用一个Test Double，我可以操纵它返回一个特定的测量值来测试警报。</p><p id="745f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我使用来自<code class="fe oh oi oj ok b">unittest.mock</code>的<code class="fe oh oi oj ok b">Mock</code>类在第七行创建一个存根。然后在下一行，我指示存根在调用<code class="fe oh oi oj ok b">take_measurement</code>时返回值35。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">使用存根来隔离测试一个类</figcaption></figure><p id="7cff" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这使我能够测试如果测量的温度高于32摄氏度，警报是否激活。</p><p id="0dac" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如您所见，传感器短线看起来与外部的实际传感器类别相同。内部是不同的。它不测量温度。</p><h2 id="7531" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">使用unittest创建模拟。模拟的</h2><p id="bb5f" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">模拟和存根之间的区别在于存根不会让测试失败。相反，如果没有正确调用，Mock可能会测试失败。因此，模拟不仅仅是存根。</p><p id="d40d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在我们看模拟之前，理解有三种不同的断言是很重要的。</p><ol class=""><li id="ea6a" class="lv lw iu lb b lc ld lf lg li lx lm ly lq lz lu ox mb mc md bi translated">断言返回值或异常</li><li id="bda6" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ox mb mc md bi translated">断言状态的改变</li><li id="2a1b" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ox mb mc md bi translated">断言方法调用。是否调用了特定的方法？</li></ol><p id="870a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">FizzBuzz单元测试使用了第一种变体。断言返回值或异常。</p><pre class="kk kl km kn gu oo ok op oq aw or bi"><span id="7325" class="nv mr iu ok b gz os ot l ou ov">def test_one_should_return_one(fizzBuzz):<br/>    result = fizzBuzz.filter(1)<br/>    assert result == ‘1’</span></pre><p id="ce9c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">报警装置测试使用了第二种变体。断言状态的改变。</p><pre class="kk kl km kn gu oo ok op oq aw or bi"><span id="941f" class="nv mr iu ok b gz os ot l ou ov">assert alarm.active == True</span></pre><p id="d75c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于第三种断言，我们需要一个模拟。我们用一个断言来扩展报警单元测试，该断言验证了调用了<code class="fe oh oi oj ok b">take_measurement</code>方法。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ol om l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">使用模拟来验证方法是否被调用</figcaption></figure><p id="ef15" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这个单元测试中，我们仍然使用单元测试模块中的模拟类。这是因为模拟类可以充当模拟或存根。通过在第十行添加验证，<code class="fe oh oi oj ok b">mock_sensor.take_measurement.assert_called()</code>我们将它从存根改为模拟。因为模拟现在不能通过测试。</p><h2 id="e94a" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">使用假货</h2><p id="33f6" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">我想说的最后一种测试替身是假的。Fakes是具有有效实现的类。实现与生产不同。通常，他们有一个简化版本的生产代码。</p><p id="3933" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以自己创建这些假货，但幸运的是，Python已经有了一些现成的假货。</p><p id="e491" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">用字符串替换文件。IO </strong></p><p id="7374" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">绳子。IO模块是一个类，它充当一个文件，但是读写字符串缓冲区。字符串。IO将数据存储在内存中。这意味着在你的测试中你可以使用String。IO而不是真正的文件。这将使你的单元测试更快更容易设置。</p><p id="53ad" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">举例。</p><p id="1f86" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">用内存数据库替换数据库</strong></p><p id="ff29" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以通过更改连接字符串在内存中创建SQLite数据库。Python <code class="fe oh oi oj ok b">sqlite</code>模块也支持这种行为。</p><p id="9fe9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用内存中的数据库而不是磁盘上的数据库会使您的单元测试更快。</p><pre class="kk kl km kn gu oo ok op oq aw or bi"><span id="112b" class="nv mr iu ok b gz os ot l ou ov">import sqlite3<br/>conn = sqlite3.connect(':memory:')</span></pre><p id="5ba7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">用轻量级web服务器替换web服务器</strong></p><p id="a84b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Python包括<code class="fe oh oi oj ok b">SimpleHttpServer</code>。您可以使用这个模块为您的单元测试创建一个轻量级的HTTP服务器。例如，测试与外部API的交互。</p><p id="5736" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这将使你的单元测试更快。</p></div><div class="ab cl mj mk hy ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="in io ip iq ir"><h1 id="83ed" class="mq mr iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">创建代码覆盖率报告</h1><p id="a4c8" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">有一些工具可以用来创建代码覆盖率报告。这份代码覆盖率报告显示了单元测试执行(覆盖)了哪些代码。</p><p id="f24d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我使用覆盖率和pytest-cov来创建代码覆盖率报告。覆盖率是一个测量代码覆盖率的通用包。模块pytest-cov是pytest的一个插件，它连接到覆盖率。</p><p id="2603" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">两者都可以使用pip安装。</p><p id="d717" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oh oi oj ok b">pip install coverage</code></p><p id="c73d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oh oi oj ok b">pip install pytest-cov</code></p><p id="12cd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在您安装了这两个工具之后，您可以使用这两个命令生成一个覆盖率报告。在终端或命令中运行它们。</p><p id="7bb3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oh oi oj ok b">coverage run -m pytest</code></p><p id="cc2c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oh oi oj ok b">coverage html</code></p><p id="dd69" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">第一个生成覆盖率数据。第二个命令将数据转换成HTML报告。覆盖率将报告存储在文件系统的文件夹<code class="fe oh oi oj ok b">htmlcov</code>中。</p><p id="b7ef" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你在浏览器中打开index.html，它会显示每个文件的覆盖率。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oy"><img src="../Images/329cdbca1b01faab5e7606b4bd01b02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhPfgwXT0A0o2DWdM1ZN7A.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">覆盖率HTML报表概览</figcaption></figure><p id="1be0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果您选择一个文件，它会显示下面的屏幕。覆盖率向源代码添加了一个指示，显示单元测试覆盖了哪一行。</p><p id="bb5c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面我们看到我们的单元测试没有覆盖第12行和第16行。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oz"><img src="../Images/978843f1307267438816b4b7b2db76df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXSF63lieji-NjPdr0zQAA.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">alarm.py的覆盖率报告</figcaption></figure><h2 id="e053" class="nv mr iu bd ms nw nx dn mw ny nz dp na li oa ob nc lm oc od ne lq oe of ng og bi translated">分支覆盖测量</h2><p id="9a96" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">覆盖率也支持分支机构覆盖率测量。使用分支覆盖，如果您的程序中有一行可以跳转到多个下一行，覆盖将跟踪这些目的地是否被访问。</p><p id="e8a9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以通过执行下面的命令来创建一个包含分支覆盖率的覆盖率报告。</p><p id="0c16" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe oh oi oj ok b">pytest --cov-report html:htmlcov --cov-branch --cov=alarm</code></p><p id="dc4c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我指示pytest生成一个包含分支覆盖率的HTML覆盖率报告。它应该将结果存储在<code class="fe oh oi oj ok b">htmlcov</code>中。我告诉覆盖率只使用<code class="fe oh oi oj ok b">alarm.py</code>，而不是为所有文件生成覆盖率报告。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pa"><img src="../Images/6c341229f25182bba336638962687135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcjDI4hzksVXc2ixPsY9eA.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">启用了分支机构保险的保险报告</figcaption></figure></div><div class="ab cl mj mk hy ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="in io ip iq ir"><h1 id="6b5a" class="mq mr iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">结论</h1><p id="8a3b" class="pw-post-body-paragraph kz la iu lb b lc ni jv le lf nj jy lh li nk lk ll lm nl lo lp lq nm ls lt lu in bi translated">这就结束了我对Python单元测试可能性的研究。</p><p id="03e2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我向您展示了如何用Python创建和运行单元测试。我们使用了两个测试框架和测试运行器，即<code class="fe oh oi oj ok b">unittest</code>和<code class="fe oh oi oj ok b">pytest</code>模块。</p><p id="b046" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们看到了如何设计您的单元测试。想出测试用例的正确名称和测试用例体的正确结构。</p><p id="546e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我向您展示了各种类型的测试替身，比如存根、模拟和伪造。还解释了属于每个测试double的不同类型的断言。</p><p id="97d8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最后，我们看了如何创建代码覆盖率报告。覆盖率报告有助于发现新代码中缺失的测试，或者确定哪些测试要添加到现有的代码中。</p><p id="f0ff" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我将示例的源代码存储在这个Github存储库中。</p><p id="7cf5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>