<html>
<head>
<title>Lambda expressions in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的Lambda表达式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lambda-expressions-in-c-c1462e6a7803?source=collection_archive---------5-----------------------#2021-07-28">https://levelup.gitconnected.com/lambda-expressions-in-c-c1462e6a7803?source=collection_archive---------5-----------------------#2021-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="00a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在C++中使用lambda表达式是一种快速定义匿名函数的方法，在调用它的地方或者作为一个更大函数的参数。Lambda表达式往往只有1-2行代码，可能只使用一次或两次。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/febdfc5beeef7d790d4fc10fa3126b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MnYqAIuo2udIMnqi"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">潘卡杰·帕特尔在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9f6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lambda表达式基于lambda演算的概念，这是一种基于20世纪30年代纯抽象的语言。虽然lambda演算是图灵完备的，但它不同于图灵机，因为它不保留任何状态。</p><p id="da4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C++是一种命令式语言，这意味着与Haskell等函数式语言不同，它基于基于状态的计算模型，而不是数学逻辑和lambda演算。直到2011年，随着C++ 11的加入，C++才采用了匿名函数。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="11d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们如何开始写一个lambda，对于最基本的lambda来说，真的很简单。首先，我们需要设置我们的C++环境，然后我们可以开始编写lambda。</p><p id="2c8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要了解lambda的6个部分。</p><ul class=""><li id="d600" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">捕获条款</li><li id="5e6d" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">参数列表(可选)</li><li id="1581" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">可变规范(可选)</li><li id="a4fa" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">异常规范(可选)</li><li id="f50a" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">尾随返回类型(可选)</li><li id="9741" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">lambda的主体</li></ul><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="a38d" class="mc md iq ly b gy me mf l mg mh">#include &lt;iostream&gt;</span><span id="f20e" class="mc md iq ly b gy mi mf l mg mh">int main()<br/>{<br/>    auto lambda = [](int a, int b) {return (abs(a) &gt; abs(b)); };<br/>    if (lambda(5, 4))<br/>    {<br/>        std::cout &lt;&lt; "True" &lt;&lt; std::endl;<br/>    }<br/>}</span></pre><p id="d587" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你可能会看着它，说“你不能把lambda的主体放在if语句中吗”，你可能是对的，在这种情况下，你可能应该这么做。这比lambda的例子要干净得多。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="5b84" class="mc md iq ly b gy me mf l mg mh">if (5 &gt; 4)<br/>{<br/>    std::cout &lt;&lt; "True" &lt;&lt; std::endl;<br/>}</span></pre><p id="7113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们在哪里使用λ呢？一个常见的例子是在排序函数中。假设你有一个包含对的向量，你想对它排序，C++没有内置到stander库中，所以我们必须为它写一个lambda。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="8c18" class="mc md iq ly b gy me mf l mg mh">#include &lt;iostream&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;vector&gt;</span><span id="cf1d" class="mc md iq ly b gy mi mf l mg mh">int main()<br/>{<br/>    auto pairs_sort = [](std::pair&lt;int, float&gt; a, std::pair&lt;int, float&gt; b) {return (a.second &gt; b.second);  };<br/>    std::vector&lt;std::pair&lt;int, float&gt;&gt; test_vector = { {0,0.3}, {1, 0.2}, {3, 0.9}, {4, 1.5}, {5, 0.15} };<br/>    std::sort(test_vector.begin(), test_vector.end(), pairs_sort);<br/>}</span></pre><p id="3318" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但那是针对标准库中包含的函数，我们如何在自己的函数中包含lambda表达式呢？我们有两个解，你选择哪一个取决于你是否捕捉了一个变量。</p><h2 id="f693" class="mc md iq bd mj mk ml dn mm mn mo dp mp jy mq mr ms kc mt mu mv kg mw mx my mz bi translated"><strong class="ak">使用函数指针</strong></h2><p id="2dc0" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">当使用函数指针时，我们不能捕获lambda中的任何东西，因为它不能被转换成函数指针，正如在<a class="ae lb" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf" rel="noopener ugc nofollow" target="_blank"> C++ 11草案</a>中所述。</p><blockquote class="nf ng nh"><p id="25e4" class="jn jo ni jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">没有lambda-capture 的lambda-expression <strong class="jp ir">的闭包类型具有指向函数</strong>的指针的公共非虚拟非显式const <strong class="jp ir">转换函数，该函数具有与闭包类型的函数调用运算符相同的参数和返回类型。这个转换函数返回的值应该是一个函数的地址，当这个函数被调用时，与调用闭包类型的函数调用操作符具有相同的效果。</strong></p></blockquote><p id="03c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为通过使用捕获括号，该范围内的变量被视为对象的成员变量，函数指针只传输lambda的逻辑而不是成员变量，要用捕获来传输它，您需要使用函数对象。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="31bd" class="mc md iq ly b gy me mf l mg mh">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>void print_values(const std::vector&lt;int&gt;&amp; values, void(*func)(int))<br/>{<br/>    for (auto value : values)<br/>    {<br/>        func(value);<br/>    }<br/>}</span><span id="1fc0" class="mc md iq ly b gy mi mf l mg mh">int main()<br/>{<br/>    auto lambda = [](int a) {std::cout &lt;&lt; "Value: " &lt;&lt; a &lt;&lt; std::endl; };<br/>    std::vector&lt;int&gt; numbers = { 4,2,30,2,9 };<br/>    print_values(numbers, lambda);<br/>}</span></pre><p id="a5a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是假设我们只想打印这些值，如果它们也在不同的向量中，现在你可以把它传递给函数。但是你可能不想这样做，因为那需要你每次传递两个向量，那么我们该怎么做呢？我们将其包括在捕获范围内。</p><h2 id="7fd0" class="mc md iq bd mj mk ml dn mm mn mo dp mp jy mq mr ms kc mt mu mv kg mw mx my mz bi translated">使用固定支架</h2><p id="55fc" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">当使用捕获括号时，我们必须使用函数对象，而不是函数指针。为此，我们需要添加函数库。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="6527" class="mc md iq ly b gy me mf l mg mh">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;functional&gt;</span><span id="1b86" class="mc md iq ly b gy mi mf l mg mh">void print_values(const std::vector&lt;int&gt;&amp; values, const std::function&lt;void(int)&gt;&amp; func)<br/>{<br/>    for (auto value : values)<br/>    {<br/>        func(value);<br/>    }<br/>}</span><span id="9776" class="mc md iq ly b gy mi mf l mg mh">int main()<br/>{<br/>    std::vector&lt;int&gt; numbers = { 4,2,30,2,9 };<br/>    std::vector&lt;int&gt; numbers_2 = { 4,3,30,5,9 };<br/>    auto lambda = [&amp;numbers_2](int a) {<br/>        if (std::find(numbers_2.begin(), numbers_2.end(), a) != numbers_2.end())<br/>        {<br/>            std::cout &lt;&lt; "Value: " &lt;&lt; a &lt;&lt; std::endl;<br/>        }<br/>    };<br/>    print_values(numbers, lambda);<br/>}</span></pre><p id="6f8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在捕捉括号中，你可以看到我通过引用传递了这个向量，但是如果你想的话，你也可以通过值来复制它。</p><p id="bf5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想编辑你在lambda中捕获的变量，你必须使用mutable关键字，因为这告诉编译器忽略捕获变量的CONST关键字。例如，你可能想在第二个向量被打印出来后删除它。</p><pre class="km kn ko kp gt lx ly lz ma aw mb bi"><span id="bd89" class="mc md iq ly b gy me mf l mg mh">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;functional&gt;</span><span id="f52d" class="mc md iq ly b gy mi mf l mg mh">void print_values(const std::vector&lt;int&gt;&amp; values, const std::function&lt;void(int)&gt;&amp; func)<br/>{<br/>    for (auto value : values)<br/>    {<br/>        func(value);<br/>    }<br/>}</span><span id="2d02" class="mc md iq ly b gy mi mf l mg mh">int main()<br/>{<br/>    std::vector&lt;int&gt; numbers = { 4,2,30,2,9 };<br/>    std::vector&lt;int&gt; numbers_2 = { 4,3,30,5,9 };<br/>    auto lambda = [&amp;numbers_2](int a) mutable{<br/>        auto iter = std::find(numbers_2.begin(), numbers_2.end(), a)<br/>        if (iter != numbers_2.end())<br/>        {<br/>            std::cout &lt;&lt; "Value: " &lt;&lt; a &lt;&lt; std::endl;<br/>            numbers_2.erase(iter);<br/>        }<br/>    };<br/>    print_values(numbers, lambda);<br/>}</span></pre><p id="4b13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有可变关键字，编译器会向你抛出一个错误。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="93e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lambdas已经是C++中一个强大的工具，随着C++新版本中更多功能的加入，它们将变得更加有用。</p><p id="cfd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这篇深入C++中lambdas世界的文章是有见地的，虽然我没有涵盖所有内容，但我已经涵盖了足够多的内容，您将能够在您的代码中毫无问题地使用它。要了解更多信息，我建议查看由微软和T2提供的文档。</p></div></div>    
</body>
</html>