<html>
<head>
<title>Slice and Append function in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的切片和追加功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/slice-and-append-function-in-golang-840ffaef61b5?source=collection_archive---------9-----------------------#2020-01-26">https://levelup.gitconnected.com/slice-and-append-function-in-golang-840ffaef61b5?source=collection_archive---------9-----------------------#2020-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d50d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们看看切片和附加的实际操作:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div></figure><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/d123e46849a9bee341f63c0802baa7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/0*bXg_KRcrxmq9to9H.gif"/></div></figure><pre class="kl km kn ko gt kv kw kx ky aw kz bi"><span id="6c62" class="la lb iq kw b gy lc ld l le lf">Output:<br/>[10]<br/>[20 2]<br/>[40 2 3]<br/>[40 2 3 4]</span></pre><p id="2c2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出与我们预期的有点不同，对吗？为什么slice3[0]是40，而我们把它设置为30。</p><p id="70c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据golang文档，让我们了解一下slice和append函数是如何工作的:</p><blockquote class="lg lh li"><p id="dbdf" class="jn jo lj jp b jq jr js jt ju jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj kk ij bi translated"><em class="iq"> func append(切片[]</em><a class="ae ln" href="https://golang.org/pkg/builtin/#Type" rel="noopener ugc nofollow" target="_blank"><em class="iq">)Type</em></a><em class="iq">，elems...</em> <a class="ae ln" href="https://golang.org/pkg/builtin/#Type" rel="noopener ugc nofollow" target="_blank"> <em class="iq">型</em></a><em class="iq">)</em><a class="ae ln" href="https://golang.org/pkg/builtin/#Type" rel="noopener ugc nofollow" target="_blank"><em class="iq">型</em> </a></p><p id="f871" class="jn jo lj jp b jq jr js jt ju jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj kk ij bi translated">" append内置函数将元素追加到切片的末尾。如果它有足够的容量，目标将被重新分割以容纳新元素。如果没有，将分配一个新的基础数组。Append返回更新的切片。因此，有必要存储append的结果，通常存储在保存切片本身的变量中:</p><p id="ab89" class="jn jo lj jp b jq jr js jt ju jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj kk ij bi translated"><em class="iq">切片=追加(切片，elem1，elem2) <br/>切片=追加(切片，另一个切片...)</em></p></blockquote><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/190e025e63e40745454e4452b5b1c099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*sx0dxK4jD1RznVaJkIP99w.jpeg"/></div></figure><p id="f68b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">切片包含三个内容:指向底层数组的指针、切片的长度和底层数组的容量。</p><p id="9fbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">看起来非常简单，但是golang如何在append函数中增加新的底层数组的容量还有待了解。</strong></p><p id="eac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">举个例子，我们有一个长度为1的切片，我们想添加更多元素:</p><pre class="kl km kn ko gt kv kw kx ky aw kz bi"><span id="2858" class="la lb iq kw b gy lc ld l le lf">var slice1 = []int{1}</span><span id="1ad0" class="la lb iq kw b gy lp ld l le lf">slice2 := append(slice1, 2) <br/>// This will result in creating a new underlying array of <strong class="kw ir">capacity 2:</strong> {1,2}</span></pre><p id="eda8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来很合理，因为之前它的容量为1，我们想再添加一个元素，它创建了容量为2的新存储片。让我们再试一次:</p><pre class="kl km kn ko gt kv kw kx ky aw kz bi"><span id="146d" class="la lb iq kw b gy lc ld l le lf">slice3 := append(slice2, 3) <br/>// This will result in creating a new underlying array of <strong class="kw ir">capacity 4 and slice length will be 3:</strong> {1,2,3}</span></pre><p id="e4fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这次我们得到了容量为4而不是3的新存储片。为什么？降低append函数的分摊时间复杂度。底层阵列容量每次增加1将具有O(n)的时间复杂度，而容量加倍将导致O(3)的摊销时间复杂度。在这个<a class="ae ln" href="https://medium.com/@amitj975/the-amortized-time-complexity-of-increasing-array-size-ddf0eb662027" rel="noopener">博客</a>中阅读更多关于摊销时间复杂度的内容。</p><pre class="kl km kn ko gt kv kw kx ky aw kz bi"><span id="fd6e" class="la lb iq kw b gy lc ld l le lf">slice4 := append(slice3, 4) <br/>// This will result in creating a new slice of length 4 and the <strong class="kw ir">underlying array will be the</strong> <strong class="kw ir">same as earlier as the capacity was already 4:</strong> {1,2,3,4}</span></pre><p id="8045" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:因此slice4底层数组保持不变。简而言之，append函数并不总是每次都创建一个新的底层数组。</p><p id="e5bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在看看我们在博客开头看到的输出会更有意义。当我们将第一个索引更新为40时，底层数组是相同的，因此slice3也是相同的，并且由于slice3的长度为3，它将打印切片的前3个元素。</p></div></div>    
</body>
</html>