<html>
<head>
<title>Flutter Alphabetical Indexed ListView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤动字母索引列表视图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-alphabetical-indexed-listview-84fcf570b9e1?source=collection_archive---------4-----------------------#2020-04-08">https://levelup.gitconnected.com/flutter-alphabetical-indexed-listview-84fcf570b9e1?source=collection_archive---------4-----------------------#2020-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d3ec5d210c48f1476efbde9e2cc18752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*25ZgrYGovgbI4K3p"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@itookthose?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sid Balachandran </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1ab1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我又带来了另一篇关于Flutter的文章。</p><p id="658a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将告诉你如何在Flutter中创建一个字母索引列表视图。那么，什么是字母索引列表视图呢？</p><p id="fcc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你是智能手机用户，你至少见过下面这个屏幕一次。通常它是一个应用程序注册流程中的一个屏幕，让你选择你的国家代码。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/62dfb791098ce2d7ebcac7c23b6f85ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*bD0-0yXRVVAD1q-0YW3aZw.png"/></div></figure><p id="db14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我想，这是一个非常有趣的小部件，可以用Flutter来探索。所以我决定制作一个这个屏幕的例子。开始了。</p><p id="f7ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像往常一样，如果您喜欢直接查看代码，可以在我的GitHub资源库中找到。</p><div class="lg lh gp gr li lj"><a href="https://github.com/blackmenthor/flutter-alphabetical-indexed-view-example" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd ir gy z fp lo fr fs lp fu fw ip bi translated">black mentor/flutter-字母索引视图-示例</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">一个新的Flutter应用程序实现了字母索引列表视图。这个项目是一个扑的起点…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">github.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx jw lj"/></div></div></a></div></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="a330" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我希望您了解这个小部件的组件。基本上，这个小部件只有三个组件，即:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/b6ffddf7a2407a3bef1ab300f9993ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*Rhnmjw849rfgWNO89YkEig.png"/></div></figure><ul class=""><li id="4b85" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">主列表视图</li></ul><p id="c8da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个组件将用于向用户显示我们的主要项目，我们可以定义我们将如何在这个小部件的参数之一绘制每个项目。这一点将在下面详细解释。</p><ul class=""><li id="fc89" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">字母表列表视图</li></ul><p id="6fed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该组件将用于向用户显示列表中所有项目的第一个索引。我们为什么需要这个？通常这个小部件旨在帮助用户更容易地找到他们想要的项目。</p><p id="3a24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我想在所有项目中找到<code class="fe mo mp mq mr b">Indonesia</code>，我不必从所有项目的最顶端滚动到前面有I字符的项目，然后我会找到我想要的国家。我可以从字母表中点击<code class="fe mo mp mq mr b">I</code>，然后在那里找到印度尼西亚。</p><ul class=""><li id="3daa" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">重叠字母指示器</li></ul><p id="308c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个组件将被用来显示用户正在选择的字母索引，就在他们点击它之后。为什么？主要是因为审美的目的，但我认为它也可以帮助用户确定他们之前点击了哪个字母。</p><p id="db09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，我们需要定义这个小部件所需的参数。我们将这个小部件称为<code class="fe mo mp mq mr b">IndexedListView</code>，我们将把它称为<code class="fe mo mp mq mr b">StatefulWidget</code>。为什么不是一个<code class="fe mo mp mq mr b">StatelessWidget</code>？因为我们需要根据小部件的状态进行一些计算，不过我们稍后再讨论。</p><p id="b57c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于参数，我们在这个小部件中有三个参数，它们是:</p><ul class=""><li id="d550" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">列表项目</li></ul><p id="9b38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该参数将保存将在<code class="fe mo mp mq mr b">ListView</code>内绘制的项目列表。例如，对于上面的国家代码选择器屏幕示例，它将是一个<code class="fe mo mp mq mr b">CountryCode</code>项目。</p><ul class=""><li id="9cef" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">IndexedWidgetBuilder项目生成器</li></ul><p id="6729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个参数的类型是从Flutter最初的<code class="fe mo mp mq mr b">ListView</code>实现中导入的。它基本上是一个函数，接收一个<code class="fe mo mp mq mr b">BuildContext</code>和一个<code class="fe mo mp mq mr b">Int index</code>，并将返回为列表中的每一项绘制的所需部件。</p><ul class=""><li id="fd65" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">双项目高度</li></ul><p id="7b5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此参数将定义每个项目的小部件的高度。我们为什么需要这个？因为我们需要计算当每个字母索引被点击时，我们要去的位置。如果我们有了每一项的精确高度，计算我们将要去的精确滚动位置就容易多了。</p><p id="c4c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将直接讨论实现。</p><p id="e363" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mo mp mq mr b">build</code>函数中，我们将创建一个堆栈，在其中我们将放置列表小部件(<code class="fe mo mp mq mr b">_itemsList</code>)和覆盖字母表小部件(<code class="fe mo mp mq mr b">_currentCharIndex</code>)。所以，它会看起来像这样。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="b3d3" class="mw mx iq mr b gy my mz l na nb"><a class="ae kc" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>Widget build(BuildContext context) {<br/>  return Stack(<br/>    children: &lt;Widget&gt;[<br/>      _itemsList(context),<br/>      _currentCharIndex(context)<br/>    ],<br/>  );<br/>}</span></pre><p id="faa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，对于<code class="fe mo mp mq mr b">currentCharIndex</code>，我们将需要一个状态对象来存储我们将要显示的当前字母表。姑且称之为<code class="fe mo mp mq mr b">currentChar</code>。如果当前字符是一个空字符串，我们什么也不显示，如果不是，我们就覆盖它。所以，它看起来像这样:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="d76e" class="mw mx iq mr b gy my mz l na nb">String currentChar = "";</span><span id="af78" class="mw mx iq mr b gy nc mz l na nb">// index to show when alphabet is selected<br/>Widget _currentCharIndex(BuildContext context) {<br/>  return currentChar.isEmpty<br/>      ? Container()<br/>      : Align(<br/>    alignment: Alignment.center,<br/>    child: Container(<br/>      color: Colors.black.withAlpha(80),<br/>      padding: EdgeInsets.all(16.0),<br/>      child: Text(<br/>        currentChar,<br/>        style: TextStyle(<br/>            color: Colors.white,<br/>            fontSize: 36.0<br/>        ),<br/>      ),<br/>    ),<br/>  );<br/>}</span></pre><p id="4e3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，对于<code class="fe mo mp mq mr b">itemsList</code>，我们将有两个小部件并排放置。一个将是主列表视图，另一个将是字母列表视图。我们在状态中还需要一个<code class="fe mo mp mq mr b">ScrollController</code>对象，将两个listview绑定在一起并触发滚动。另外，不要忘记处理<code class="fe mo mp mq mr b">ScrollController</code>。</p><p id="7f07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于主Listview，代码将是直接的，因为我们不会在那里做任何计算，但对于字母表Listview，我将在上面的其他部分解释更多。因此，代码将如下所示:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="5610" class="mw mx iq mr b gy my mz l na nb">ScrollController _scrollController;</span><span id="53dc" class="mw mx iq mr b gy nc mz l na nb"><a class="ae kc" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>void initState() {<br/>  _scrollController = ScrollController();<br/>  super.initState();<br/>}</span><span id="6b09" class="mw mx iq mr b gy nc mz l na nb"><a class="ae kc" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>void dispose() {<br/>  _scrollController.dispose();<br/>  super.dispose();<br/>}</span><span id="f125" class="mw mx iq mr b gy nc mz l na nb">// main items list view<br/>Widget _itemsList(BuildContext context) {<br/>  return Padding(<br/>    padding: const EdgeInsets.only(top: 7.0),<br/>    child: Row(<br/>      mainAxisAlignment: MainAxisAlignment.start,<br/>      crossAxisAlignment: CrossAxisAlignment.start,<br/>      children: &lt;Widget&gt;[<br/>        Expanded(<br/>          child: ListView.builder( // Main Listview<br/>              controller: _scrollController,<br/>              itemCount: widget.items.length,<br/>              // manually set item height for scrolling calculation<br/>              itemExtent: widget.itemHeight,<br/>              itemBuilder: widget.itemBuilder<br/>          ),<br/>        ),<br/>        _alphabeticalIndex(context, widget.items) // Alphabet Listview<br/>      ],<br/>    ),<br/>  );<br/>}</span></pre><p id="8bc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，最有趣的部分，字母列表视图。</p><p id="4c62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我先展示代码，然后再解释。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="266f" class="mw mx iq mr b gy my mz l na nb">List&lt;String&gt; getAlphabetsFromStringList(List&lt;String&gt; originalList) {<br/>  List&lt;String&gt; alphabets = [];</span><span id="3fc5" class="mw mx iq mr b gy nc mz l na nb">for (String item in originalList)<br/>    if (!alphabets.contains(item[0]))<br/>      alphabets.add(item[0]);</span><span id="d44c" class="mw mx iq mr b gy nc mz l na nb">alphabets.sort((a,b) =&gt; a.compareTo(b));</span><span id="ccda" class="mw mx iq mr b gy nc mz l na nb">return alphabets;<br/>}</span><span id="eee3" class="mw mx iq mr b gy nc mz l na nb">// side alphabetical index to select<br/>Widget _alphabeticalIndex(BuildContext context, List items) {<br/>  List&lt;String&gt; alphabets = getAlphabetsFromStringList(items.map((item) =&gt; item.toString()).toList());</span><span id="37e2" class="mw mx iq mr b gy nc mz l na nb">Map&lt;String, int&gt; alphabetIndex = _getAlphabetIndex(items);</span><span id="9356" class="mw mx iq mr b gy nc mz l na nb">return LayoutBuilder(<br/>    builder: (context, constraint) {<br/>      if (constraint.maxHeight &lt; 350.0) return Container(); // alphabet list does not fit, might as well hide it<br/>      return Container(<br/>        width: 34.0,<br/>        key: alphabetContainerKey,<br/>        child: GestureDetector(<br/>          onVerticalDragUpdate: (DragUpdateDetails dragUpdateDetails)<br/>            =&gt; _onVerticalDragUpdate(dragUpdateDetails, alphabets, alphabetIndex),<br/>          onVerticalDragStart: (DragStartDetails dragStartDetails)<br/>            =&gt; _onVerticalDragStart(dragStartDetails, alphabets, alphabetIndex),<br/>          onVerticalDragEnd: _onVerticalDragEnd,<br/>          child: Column(<br/>            mainAxisAlignment: MainAxisAlignment.end,<br/>            crossAxisAlignment: CrossAxisAlignment.end,<br/>            children: []..addAll(<br/>                List.generate(<br/>                    alphabets.length,<br/>                        (index) =&gt; _getAlphabetItem(alphabets[index])<br/>                )<br/>            ),<br/>          ),<br/>        ),<br/>      );<br/>    },<br/>  );<br/>}</span></pre><p id="d2b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么上面的代码中发生了什么呢？</p><p id="b684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要用户可以访问的可用字母表的列表。我为此使用了一个单独的函数，称为<code class="fe mo mp mq mr b">getAlphabetsFromStringList</code>。我认为这很简单，所以我不会解释太多。</p><p id="d368" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要每个字母表的第一个项目的索引。那是什么意思？例如，如果我有一个项目列表[Aa，Ab，Ac，Ba，Bb，Bc，Ca，Cb，Cc]，那么我将需要索引<code class="fe mo mp mq mr b">Aa</code>，<code class="fe mo mp mq mr b">Ba</code>和<code class="fe mo mp mq mr b">Ca</code>，它们将是[0，3和6]。</p><p id="f415" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将为此编写另一个函数，姑且称之为<code class="fe mo mp mq mr b">_getAlphabetIndex</code>。基本上，这个函数所做的就是遍历所有的条目，如果没有一个条目包含字母字符，就将该字符的索引添加到一个映射中。它看起来会像这样:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="ff2c" class="mw mx iq mr b gy my mz l na nb">// function to calculate alphabet dy index positions (e.g. {'A':0, 'B':8, ...})<br/>Map&lt;String, int&gt; _getAlphabetIndex(List items) {<br/>  Map&lt;String, int&gt; alphabetIndex = {};<br/>  for( var i = 0 ; i &lt; items.length; i++ ) {<br/>    final firstChar = items[i].toString()[0];</span><span id="50e7" class="mw mx iq mr b gy nc mz l na nb">if (!alphabetIndex.containsKey(firstChar)) {<br/>      alphabetIndex[firstChar] = i;<br/>    }<br/>  }<br/>  return alphabetIndex;<br/>}</span></pre><p id="f7fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我将把字母表listview包装在一个<code class="fe mo mp mq mr b">LayoutBuilder</code>中，这样我就可以得到这个小部件的<code class="fe mo mp mq mr b">Constraints</code>。我们为什么需要这个？因为我发现，如果我们把这个字母表视图放在一个高度很小的小部件中，我们就不能把所有的字母表都放进去。</p><p id="17cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将检查这个部件的最大高度是否小于350，我们将隐藏字母表，因为它不适合。</p><p id="9a20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果合适，我们将创建一个34宽度的<code class="fe mo mp mq mr b">Container</code>(这个是可变的，取决于你的需要)并为它分配一个全局键。为什么我们需要一个全局密钥？</p><p id="8c1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要GlobalKey，这样我们就可以计算出用户点击了哪个字母项，并根据计算结果滚动到相应的项。我们称这个全局键为<code class="fe mo mp mq mr b">alphabetContainerKey</code>。</p><p id="cab9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将创建一个实现了所有三个<code class="fe mo mp mq mr b">onVerticalDrag</code>可选参数的<code class="fe mo mp mq mr b">GestureDetector</code>(我将在下面对此进行解释)。最后，实际的字母表部件将放在一个<code class="fe mo mp mq mr b">Column</code>中，每个项目有一个简单的<code class="fe mo mp mq mr b">Text</code>部件(不要忘记将每个项目放在一个<code class="fe mo mp mq mr b">Expanded</code>中，这样每个项目的高度将是均匀的)。</p><p id="738f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们进入了文章最有趣的部分。我们将把字母表列表视图上的点击绑定到主列表视图。</p><p id="8ab6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要写上面刚写的<code class="fe mo mp mq mr b">GestureDetector</code>的<code class="fe mo mp mq mr b">onVerticalDragStart</code>、<code class="fe mo mp mq mr b">onVerticalDragUpdate</code>和<code class="fe mo mp mq mr b">onVerticalDragEnd</code>。</p><p id="cb47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为当用户触摸一个字母表时，我们将滚动主Listview，如果用户拖动到另一个字母表，我们将继续滚动。因此，<code class="fe mo mp mq mr b">onVerticalDragStart</code>和<code class="fe mo mp mq mr b">onVerticalDragUpdate</code>将做完全相同的事情。那就是:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="aa0d" class="mw mx iq mr b gy my mz l na nb">// scroll to proper items with alphabets when drag started<br/>void _onVerticalDragStart(DragStartDetails details, List&lt;String&gt; alphabets, Map&lt;String, int&gt; alphabetDyPositions) {<br/>  final index = _getAlphabetIndexFromDy(details.localPosition.dy, alphabets);</span><span id="e15f" class="mw mx iq mr b gy nc mz l na nb">final alphabet = alphabets[index];</span><span id="428a" class="mw mx iq mr b gy nc mz l na nb">_scrollToItems(alphabet, alphabetDyPositions);<br/>}</span></pre><p id="3da4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，我们要做的是获取用户正在触摸的字母表的索引，找到确切的字母表字符，并将主Listview滚动到以该字母表作为第一个字符的项目开始的确切位置。但是<code class="fe mo mp mq mr b">_getAlphabetIndexFromDy</code>和<code class="fe mo mp mq mr b">_scrollToItems</code>函数是做什么的呢？</p><p id="a3a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe mo mp mq mr b">_getAlphabetIndexFromDy</code>，它将基本上计算整个字母表列表视图的高度，然后用它除以我们提供的字母表长度(记住，我们通过使用<code class="fe mo mp mq mr b">Expanded</code>为每个项目设置完全相同的高度)，我们将使用由<code class="fe mo mp mq mr b">onVerticalDrag</code>函数提供的Dy来计算被触摸的字母表的索引。所以，它看起来像这样:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="1e04" class="mw mx iq mr b gy my mz l na nb">// function to get current clicked alphabet by the user<br/>int _getAlphabetIndexFromDy(double dy, List&lt;String&gt; alphabets) {<br/>  final alphabetContainer = alphabetContainerKey.currentContext.findRenderObject() as RenderBox;<br/>  final alphabetContainerHeight = alphabetContainer.size.height;</span><span id="e949" class="mw mx iq mr b gy nc mz l na nb">final oneItemHeight = alphabetContainerHeight / alphabets.length;</span><span id="659a" class="mw mx iq mr b gy nc mz l na nb">final index = (dy / oneItemHeight).floor();<br/>  return index;<br/>}</span></pre><p id="f441" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们得到了被点击的字母表的索引，我们需要做的就是将主Listview滚动到以那个字符开始的条目。我们将在<code class="fe mo mp mq mr b">_scrollToItems</code>函数中实现。</p><p id="9b9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数基本上是将我们将要滚动到的索引乘以我们在小部件中提供的参数<code class="fe mo mp mq mr b">itemHeight</code>。不要忘记将<code class="fe mo mp mq mr b">currentChar</code>对象更新为一个新的对象，这样覆盖图就会显示出来。</p><p id="5802" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，不要忘了我们必须考虑到如果滚动范围大于<code class="fe mo mp mq mr b">maxScrollExtent</code>，我们将把这个数字减少到<code class="fe mo mp mq mr b">ScrollController.position.maxScrollExtent</code>。我发现，当我们提供给小部件的项目列表少于5个项目时，会发生这种情况，因此整个主Listview没有满足当前设备高度。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="57a3" class="mw mx iq mr b gy my mz l na nb">// scroll to items with the first char<br/>void _scrollToItems(String char, Map&lt;String, int&gt; alphabetDyPositions) {<br/>  final indexToGo = alphabetDyPositions[char];<br/>  // calculate by multiplying the index with each item height<br/>  double dyToGo = indexToGo * widget.itemHeight;</span><span id="9124" class="mw mx iq mr b gy nc mz l na nb">// if scroll is bigger than max scroll extent (e.g. overflows), then make it to max instead<br/>  if (dyToGo &gt;= _scrollController.position.maxScrollExtent) {<br/>    dyToGo = _scrollController.position.maxScrollExtent;<br/>  }</span><span id="7537" class="mw mx iq mr b gy nc mz l na nb">setState(() {<br/>    currentChar = char;<br/>  });</span><span id="be8d" class="mw mx iq mr b gy nc mz l na nb">_scrollController.jumpTo(dyToGo);<br/>}</span></pre><p id="3b4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，对于<code class="fe mo mp mq mr b">_onVerticalDragEnd</code>,我们将再次异步重置<code class="fe mo mp mq mr b">currentChar</code>为空字符串，否则覆盖图将永久显示。我们将在500毫秒后重置<code class="fe mo mp mq mr b">currentChar</code>。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="bd42" class="mw mx iq mr b gy my mz l na nb">void _onVerticalDragEnd(DragEndDetails details) {<br/>  // clear the current selected char when drag ends.<br/>  Future.delayed(<br/>      Duration(milliseconds: 500),<br/>          () {<br/>        setState(() {<br/>          currentChar = "";<br/>        });<br/>      }<br/>  );<br/>}</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="f282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">瞧，一切都完成了！</p><p id="6d1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你可以从你的应用程序中的任何地方调用一个<code class="fe mo mp mq mr b">IndexedListView</code>小部件，行为将被包装在其中。</p><p id="a86f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是如何使用该小部件的示例:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="1607" class="mw mx iq mr b gy my mz l na nb">IndexedListView(<br/>    itemHeight: 50.0,<br/>    items: ["Aa","Ab", "Ac", "Ba", "Bb", "Bc", "Ca", "Cb", "Cc"],<br/>    itemBuilder: (context, index) =&gt; Text(items[index]),<br/>)</span></pre><p id="19b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，这就是了，你已经学会了创建你自己的<code class="fe mo mp mq mr b">IndexedListView</code>的所有步骤。</p><p id="61ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道我的实现远非完美，这就是为什么如果你对我的实现有任何意见、建议或问题，欢迎在下面评论。</p><p id="af4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读，</p><p id="86cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝你今天开心！玩的开心！</p></div></div>    
</body>
</html>