<html>
<head>
<title>About integrated windows authentication and how to implement it in ASP.NET core running on IIS.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于集成windows认证以及如何在运行于IIS上的ASP.NET核心中实现。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/about-integrated-windows-authentication-and-how-to-implement-it-in-asp-net-core-running-on-iis-369177dff798?source=collection_archive---------1-----------------------#2020-06-27">https://levelup.gitconnected.com/about-integrated-windows-authentication-and-how-to-implement-it-in-asp-net-core-running-on-iis-369177dff798?source=collection_archive---------1-----------------------#2020-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1509833a4052f18711eb3ba25ca4d424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAP7xQnrrMLggf36dRpZSg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">詹·西奥多在<a class="ae kf" href="https://unsplash.com/s/photos/multiple-keys?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="92d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我分享了我对集成windows身份验证的了解，以及如何在一个由angular前端和ASP.NET core 3后端组成的web应用程序中启用它。</p><h1 id="1a4d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是集成windows身份验证？</h1><p id="f36e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我举个例子解释一下。在工作中，我的计算机连接到一个域控制器，它基本上是一个运行active directory的服务器。加入域控制器意味着域控制器管理我的凭据，而不是我的电脑。当我使用我的windows凭据登录时，我的计算机与域控制器通信以验证我的凭据并允许访问。</p><p id="cba0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有。NET应用程序运行在一组加入域控制器的服务器上的IIS上。IIS可以检查域控制器，以确保在授予访问权限之前我已经通过了身份验证。此外，它可以与浏览器无缝配合，无需我输入凭据，因为它内置了集成的windows身份验证。这是可能的，因为运行IIS的服务器和我机器上的浏览器都加入了同一个域控制器，并且浏览器支持协商身份验证方案。从<a class="ae kf" href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/integrated-windows-authentication" rel="noopener ugc nofollow" target="_blank">文档</a>来看，这是集成windows认证的一个优势。</p><blockquote class="mh"><p id="d9c8" class="mi mj it bd mk ml mm mn mo mp mq ld dk translated">内置于IIS中。—不在请求中发送用户凭据。—如果客户端计算机属于域(例如，intranet应用程序)，用户不需要输入凭据</p></blockquote><p id="18ba" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">希望您现在对集成windows身份验证有了一些了解。接下来，我们来看看它是如何工作的。</p><h1 id="2c67" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">集成windows身份验证是如何工作的？</h1><p id="2cb3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">根据<a class="ae kf" href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/integrated-windows-authentication" rel="noopener ugc nofollow" target="_blank">文档</a>，集成windows身份验证</p><blockquote class="mh"><p id="fad8" class="mi mj it bd mk ml mm mn mo mp mq ld dk translated">适用于任何支持协商身份验证方案的浏览器，包括大多数主流浏览器。</p></blockquote><p id="7f65" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">协商身份验证方案是微软的身份验证机制，它使用Kerberos，Kerberos是一种基于共享机密验证用户身份并通过签发票证提供访问的系统。</p><p id="aba6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是它的工作原理。</p><p id="57de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要访问受保护的资源，客户端必须向服务器提供有效的票证。为了获得票，客户端向密钥分发中心(KDC)发送请求。客户端使用用户的凭据对请求进行加密。收到加密请求后，KDC会根据用户名从active directory中检索用户的密码，并使用该密码对请求进行解密。</p><p id="bb86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用KDC可以从数据库获得的用户密码对请求进行加密和解密，KDC可以验证用户的身份，而无需客户端发送密码。客户端收到票证后，KDC使用与资源服务器共享的密钥对票证进行加密，客户端将票证发送到资源服务器，资源服务器使用共享密钥根据KDC验证票证。一旦所有的验证都完成了，服务器就把资源返回给客户机。</p><p id="508d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上只是一个高层次的总结。如果你想了解更多关于Kerberos的知识并查看示例，我建议你观看这个简短的<a class="ae kf" href="https://www.youtube.com/watch?v=_44CHD3Vx-0" rel="noopener ugc nofollow" target="_blank">视频</a>，阅读这个<a class="ae kf" href="https://support.citrix.com/article/CTX221693#:~:text=Negotiate%20is%20a%20Microsoft%20Windows,as%20its%20underlying%20authentication%20provider.&amp;text=When%20the%20client%20tries%20to,to%20use%20the%20Negotiate%20protocol." rel="noopener ugc nofollow" target="_blank">博客</a>和IETF <a class="ae kf" href="https://www.ietf.org/rfc/rfc4559.txt" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="b6d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望您现在对集成windows身份验证的工作原理有所了解，让我们讨论一下您应该何时使用它。</p><h1 id="b0ed" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">何时应该使用集成windows身份验证</h1><p id="a893" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">总而言之，在以下情况下，您应该考虑使用集成windows身份验证:</p><ul class=""><li id="d89c" class="mw mx it ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">服务器和客户机都使用Windows，并加入到相同的域控制器中。</li><li id="ec73" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">该应用程序仅供内部使用。显然，如果公众可以访问它，它将无法工作，因为客户端计算机可能不使用Windows和加入域控制器。</li><li id="8a83" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">浏览器支持协商机制(大多数主流浏览器都支持)。</li><li id="c48a" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">服务器支持集成的windows身份验证。正如文档中提到的，IIS内置了对集成windows身份验证的支持。</li></ul><p id="fd55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/integrated-windows-authentication" rel="noopener ugc nofollow" target="_blank">文档</a>提到集成windows身份验证容易受到<a class="ae kf" href="https://www.taithienbo.com/cross-site-request-forgery-csrf/" rel="noopener ugc nofollow" target="_blank">跨站点请求伪造</a>的影响，所以请记住这一点。</p><p id="45fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您已经了解了集成windows身份验证及其工作原理，让我们看看如何在您的ASP.NET核心应用程序中实现它。</p><p id="28d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的例子中，配置我的应用程序和IIS来使用集成的windows身份验证并不困难。我只需要在应用程序中做一些更改，并在IIS中启用Windows身份验证。</p><h1 id="52ad" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">applicationhost.config中的更改</h1><p id="c77b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">设置&lt; 【T0】 &gt; to true in applicationhost.config, which is under . <strong class="ki iu">vs-&gt;{项目名称} - &gt; config </strong>目录。的。默认情况下，vs目录是隐藏的，所以我启用了显示隐藏文件夹的选项。</p><pre class="no np nq nr gt ns nn nt nu aw nv bi"><span id="3a50" class="nw lf it nn b gy nx ny l nz oa">&lt;windowsAuthentication enabled="true"&gt;<br/>    &lt;providers&gt;<br/>        &lt;add value="Negotiate" /&gt;<br/>        &lt;add value="NTLM" /&gt;<br/>    &lt;/providers&gt;<br/>&lt;/windowsAuthentication&gt;</span></pre><p id="ed1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参见此<a class="ae kf" href="https://support.microsoft.com/en-us/help/4028316/windows-view-hidden-files-and-folders-in-windows-10#:~:text=Open%20File%20Explorer%20from%20the,folders%2C%20and%20drives%20and%20OK." rel="noopener ugc nofollow" target="_blank">链接</a>了解如何在Windows 10中查看隐藏文件夹的说明。</p><h1 id="3894" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">launchSettings.json中的更改</h1><p id="88cc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在ASP.NET核心项目的<strong class="ki iu"> Properties </strong>文件夹下的launchSettings.json中，启用iisSettings下的WindowsAuthentication:</p><pre class="no np nq nr gt ns nn nt nu aw nv bi"><span id="13c8" class="nw lf it nn b gy nx ny l nz oa">{<br/>  "iisSettings": {<br/>    "windowsAuthentication": true,<br/>    "anonymousAuthentication": false,<br/>    "iisExpress": {<br/>      "applicationUrl": "<a class="ae kf" href="http://localhost:61863/" rel="noopener ugc nofollow" target="_blank">http://localhost:61863/</a>",<br/>      "sslPort": 44378<br/>    }<br/>  }<br/>}</span></pre><h1 id="a631" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Startup.cs文件中的更改</h1><ul class=""><li id="967b" class="mw mx it ki b kj mc kn md kr ob kv oc kz od ld nb nc nd ne bi translated">在<code class="fe nk nl nm nn b">Configure(...)</code>方法中，添加这些中间件:</li></ul><pre class="no np nq nr gt ns nn nt nu aw nv bi"><span id="9a0f" class="nw lf it nn b gy nx ny l nz oa">app.UseAuthentication(); app.UseAuthorization();</span></pre><p id="1595" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于该应用程序是ASP.NET core 3应用程序，根据文档，我将上述中间件放在<code class="fe nk nl nm nn b">app.UseRouting()</code>和<code class="fe nk nl nm nn b">app.UseEndpoints()</code>之间。</p><blockquote class="mh"><p id="ba28" class="mi mj it bd mk ml mm mn mo mp mq ld dk translated">如果应用程序使用认证/授权功能，如<code class="fe nk nl nm nn b">AuthorizePage</code>或<code class="fe nk nl nm nn b">[Authorize]</code>，则调用<code class="fe nk nl nm nn b">UseAuthentication</code>和<code class="fe nk nl nm nn b">UseAuthorization</code>:之后、<code class="fe nk nl nm nn b">UseRouting</code>和<code class="fe nk nl nm nn b">UseCors</code>，但在<code class="fe nk nl nm nn b">UseEndpoints</code>之前</p><p id="583c" class="mi mj it bd mk ml mm mn mo mp mq ld dk translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-3.0&amp;tabs=visual-studio#migrate-startupconfigure" rel="noopener ugc nofollow" target="_blank">从ASP.NET核心2.2迁移到3.0 </a></p></blockquote><p id="08c0" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">如果你想了解更多，请查看StackOverflow上的这篇帖子。</p><p id="ef74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe nk nl nm nn b">ConfigureServices()</code>方法中，我添加了以下内容:</p><pre class="no np nq nr gt ns nn nt nu aw nv bi"><span id="3ef1" class="nw lf it nn b gy nx ny l nz oa">services.AddAuthentication(IISDefaults.AuthenticationScheme); services.AddAuthorization();</span></pre><h1 id="437f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">远程服务器上IIS站点的更改</h1><ul class=""><li id="a0d3" class="mw mx it ki b kj mc kn md kr ob kv oc kz od ld nb nc nd ne bi translated">在IIS管理器中，在站点的<strong class="ki iu">功能视图</strong>下，双击<strong class="ki iu">认证</strong>功能。</li><li id="33ad" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">选择<strong class="ki iu"> Windows认证</strong>并将状态设置为<strong class="ki iu">启用</strong>。</li></ul><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/152c69bf6e8deb8f0bb410cb09547cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6vIyw2_PkA1jjiHXG5jmGw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在IIS上启用Windows身份验证</figcaption></figure><h1 id="84c4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">角度app的变化</h1><p id="0cad" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">从技术上来说，您不需要对angular进行任何更改，集成的windows身份验证就可以工作。我看的一些在线教程建议在头中添加键和值:<code class="fe nk nl nm nn b">withCredentials: true</code>。然而，我意识到这是不必要的，即使我删除了代码，认证仍然有效。浏览器似乎通过协商身份验证方案自动处理该过程。</p><h1 id="56b5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可选:获取windows用户的角度信息</h1><p id="8484" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">似乎没有办法从客户端应用程序获得windows用户的信息。因此，为了获得windows用户的用户名和状态，我调用了后端。</p><pre class="no np nq nr gt ns nn nt nu aw nv bi"><span id="9ee8" class="nw lf it nn b gy nx ny l nz oa">[Route("GetAuthenticatedUser")][HttpGet("[action]")] public IdentityUser GetUser() {<br/> return new IdentityUser() {<br/>  Username = User.Identity ? .Name, IsAuthenticated = User.Identity != null ? User.Identity.IsAuthenticated : false, AuthenticationType = User.Identity ? .AuthenticationType<br/> };<br/>}<br/>public class IdentityUser {<br/> public string Username {<br/>  get;<br/>  set;<br/> }<br/> public bool IsAuthenticated {<br/>  get;<br/>  set;<br/> }<br/> public string AuthenticationType {<br/>  get;<br/>  set;<br/> }<br/>}<br/><a class="ae kf" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>() export class AuthGuardService implements CanActivate {<br/> constructor(public router: Router, private apiService: ApiService) {}<br/> canActivate(): Observable &lt; boolean &gt; | Promise &lt; boolean &gt; | boolean {<br/>  return this.apiService.User.pipe(take(1), switchMap(currentUser =&gt; {<br/>   if (!currentUser) {<br/>    return this.apiService.loadUser().pipe(take(1), switchMap(user =&gt; {<br/>     return of(user &amp;&amp; user.isAuthenticated);<br/>    }), catchError((err: HttpErrorResponse) =&gt; {<br/>     if (err) {<br/>      console.error("Failed to load user: " + JSON.stringify(err));<br/>      if (err.status === 403) {<br/>       this.apiService.setErrorMessage("You don't have access to use this application.");<br/>      } else {<br/>       this.apiService.setErrorMessage("Something went wrong! :(");<br/>      }<br/>     }<br/>     return of(false);<br/>    }));<br/>   }<br/>   return of(currentUser.isAuthenticated);<br/>  }));<br/> }<br/>}</span></pre><h1 id="9ca3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考</h1><p id="fee7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><a class="ae kf" href="https://stackoverflow.com/questions/57846127/what-are-the-differences-between-app-userouting-and-app-useendpoints" rel="noopener ugc nofollow" target="_blank">集成Windows认证</a></p><p id="3312" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.c-sharpcorner.com/article/enable-windows-authentication-in-web-api-and-angular-app/" rel="noopener ugc nofollow" target="_blank">在Web API和Angular App中启用Windows认证</a></p><p id="e910" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://support.citrix.com/article/CTX221693#:~:text=Negotiate%20is%20a%20Microsoft%20Windows,as%20its%20underlying%20authentication%20provider.&amp;text=When%20the%20client%20tries%20to,to%20use%20the%20Negotiate%20protocol." rel="noopener ugc nofollow" target="_blank">协商和NTLM认证有什么区别？</a></p><p id="be41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.youtube.com/watch?v=_44CHD3Vx-0" rel="noopener ugc nofollow" target="_blank"> Kerberos —认证协议</a></p><p id="fd74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.ietf.org/rfc/rfc4559.txt" rel="noopener ugc nofollow" target="_blank">微软Windows中基于SPNEGO的Kerberos和NTLM HTTP认证</a></p><p id="2fff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/iis/configuration/system.webServer/security/authentication/windowsAuthentication/" rel="noopener ugc nofollow" target="_blank">如何为网站、Web应用程序或Web服务启用Windows身份验证</a></p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="67b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="om">原载于2020年6月27日https://www.taithienbo.com</em><a class="ae kf" href="https://www.taithienbo.com/about-integrated-windows-authentication-and-how-to-implement-it-in-asp-net-core-running-on-iis/" rel="noopener ugc nofollow" target="_blank"><em class="om"/></a><em class="om">。</em></p></div></div>    
</body>
</html>