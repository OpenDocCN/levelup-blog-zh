<html>
<head>
<title>Road to Go Pro — Async Part 1: Goroutine &amp; WaitGroup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pro-Async之路第1部分:Goroutine和WaitGroup</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/road-to-go-pro-async-part-1-goroutine-waitgroup-e915accab659?source=collection_archive---------8-----------------------#2022-01-27">https://levelup.gitconnected.com/road-to-go-pro-async-part-1-goroutine-waitgroup-e915accab659?source=collection_archive---------8-----------------------#2022-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e50e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">开始前的一个小更新。你可能想知道我到底在哪里，为什么我停止更新这个Road to Go Pro系列。2021年，我居住的城市被冠以全世界最锁的城市。我对生活和工作感到紧张。不确定、失望和疲劳是我2021年生活的主旋律。简而言之，我既没有好的精神状态，也没有正确的心态去继续这个系列。所以我决定休息一段时间，给自己一些时间让自己振作起来。现在，2022年已经到来。我要回到中号。我感谢你的支持和耐心。我希望在这一年里，我们将一起踏上一段伟大的旅程。</em></p><p id="915f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">常用的东西:你可以在这个</em> <a class="ae kp" href="https://github.com/songx23/RoadToGoPro" rel="noopener ugc nofollow" target="_blank"> <em class="ko">资源库</em> </a> <em class="ko">中找到本教程使用的代码。你可以在这里</em>  <em class="ko">找到Road to Go Pro </em> <a class="ae kp" href="https://medium.com/@songx/road-to-go-pro-f9d1f8a51fad" rel="noopener"> <em class="ko">的全部内容。如果你错过了最后一个，可以通过这个</em> </a><a class="ae kp" href="https://medium.com/digio-australia/road-to-go-pro-unit-test-69591a553412" rel="noopener"> <em class="ko">链接</em> </a> <em class="ko">找到。好吧，我们开始吧。</em></p><h1 id="a40c" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">异步处理</h1><p id="6bc6" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在这个故事中，我们将探索如何使用Go来处理异步处理。Go拥有出色的开箱即用并发支持。它以处理多个“线程”的高效率而闻名。</p><p id="b73b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于并发是一个相当大的讨论主题，我们将在两个故事中讨论并发。在这一部分中，我们将了解goroutines和等待组。</p><h1 id="4ed3" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">戈鲁廷斯</h1><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/560792f459c26c1f7c6fed9b1b9660b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iKp-Vzn-NzKSB_89"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@amir_v_ali?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> amirali mirhashemian </a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d916" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么什么是线程呢？</p><blockquote class="mj mk ml"><p id="793e" class="jq jr ko js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">线程是程序中一个单独的顺序控制流。</p></blockquote><p id="a5c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们写的所有东西都是顺序执行的。我们先做X，再做y，一个顺序程序在一个线程中运行(在这个故事中我们称之为“主goroutine”)。Go对线程使用了一个稍微不同的术语，它被称为“goroutines”而不是“threads”。goroutine的定义是:</p><blockquote class="mj mk ml"><p id="4e70" class="jq jr ko js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">goroutine是由Go运行时管理的轻量级线程。</p></blockquote><p id="9ca1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么Go使用了与广泛使用的“线程”不同的名称？好问题，我们将在后面的部分探讨它们的区别。目前，goroutine只是一个线程的表示。</p><p id="4ede" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">启动一个goroutine非常容易，你需要使用的关键字是<code class="fe mp mq mr ms b">go</code>。没错，就是<code class="fe mp mq mr ms b">go</code>。让我们想象一下，我们有一组6个困难的数学计算要解决。每个计算需要10秒钟来解决。如果我们按顺序处理它们，将需要<code class="fe mp mq mr ms b">6x10=60</code>秒来完成。如果每个计算都相互独立，我们可以通过使用并发来加快速度。如果我们并行处理这6个计算，我们可以将总处理时间缩短到大约10秒。下面是数学解题程序的顺序版本和异步版本。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">顺序加工</figcaption></figure><p id="066e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">— vs —</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">异步处理</figcaption></figure><p id="a9a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你发现区别了吗？一看就不是很明显。在第11行，我们在调用计算函数之前使用了go关键字。这就是如何在单独的goroutine中创建和运行函数。就这么简单。在上面的例子中，我们并行运行了6个单独的goroutines。现在，让我们检查控制台中打印出的内容。运行顺序示例后，您可以看到解决方案已排序。另一方面，在运行异步示例后，我们得到了随机排序的解决方案。如果您运行几次异步示例，我们可以看到程序以不同的顺序打印出解决方案。</p><pre class="lu lv lw lx gt mv ms mw mx aw my bi"><span id="f108" class="mz kr it ms b gy na nb l nc nd">// Sequential output<br/>math problem solved for input: 0.<br/>math problem solved for input: 1.<br/>math problem solved for input: 2.<br/>math problem solved for input: 3.<br/>math problem solved for input: 4.<br/>math problem solved for input: 5.</span><span id="ec5c" class="mz kr it ms b gy ne nb l nc nd">// Asynchronous output<br/>math problem solved for input: 4.<br/>math problem solved for input: 2.<br/>math problem solved for input: 3.<br/>math problem solved for input: 5.<br/>math problem solved for input: 0.<br/>math problem solved for input: 1.</span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h2 id="e402" class="mz kr it bd ks nm nn dn kw no np dp la kb nq nr le kf ns nt li kj nu nv lm nw bi translated">Goroutines与Threads</h2><p id="0b12" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在我们探讨goroutines和threads之间的区别之前。我想澄清一点:我们这里说的“线程”是操作系统线程。</p><p id="84a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与goroutines相比，OS线程相对较重。他们有一个大的固定堆栈大小。这就是为什么我们只能在一台计算机上运行有限数量的线程。它们也依赖于硬件。您的CPU内核数量将影响您可以使用的操作系统线程数量。然而，goroutines不是由操作系统管理的，而是由Go运行时管理的。它没有操作系统线程所具有的限制。这就是goroutines轻量级和快速的原因。Go runtime为goroutines对堆栈进行分段，并根据需要增加它们的大小。此外，Go运行时执行调度，而不是操作系统，因此它可以将goroutines复用到OS线程上。这由一个名为<code class="fe mp mq mr ms b">GOMAXPROCS</code>的运行时变量控制，它的默认值是机器的CPU核心数。</p><p id="1225" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go还为goroutines相互通信提供了另一种处理机制。它被称为“通道”，我们将在下一个故事(第二部分)中了解它。线程之间的通信不是一件容易的事情。因此，对于OS线程来说，通信的成本是昂贵的。</p><p id="8b12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在处理异步处理时，我们需要小心竞争条件和死锁。Go帮助我们做了很多开箱即用的同步，它甚至有工具来帮助检测竞争条件(也将在下一个故事中涉及)。而我们需要在使用OS线程时主动避免竞争情况。</p><p id="e7cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是线程和goroutines之间的主要区别。我用C#、Java/Kotlin和Go开发过异步处理器。依我拙见，Go提供了三者中最好的开发体验。</p><h1 id="6919" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">等待组</h1><p id="b96c" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">好吧，让我们快速回顾一下。我们对工作负载进行了并行处理，以加快处理速度。顺序示例需要大约60秒来运行，异步示例需要大约10秒来运行。这是我们的期望，让我们从代码中得到一些准确的读数来证明这些期望是正确的。</p><p id="2cfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了计算处理时间，我们可以简单地在for循环前后添加时间戳。开始和结束时间戳的差值就是处理时间。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">有持续时间的顺序加工</figcaption></figure><p id="9aa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在运行这个更新的顺序结果后，我们将得到类似于<code class="fe mp mq mr ms b">Total time spent: 60008 ms</code>的读数。这与预期相符。让我们应用同样的方法来计算异步示例的处理时间。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">带持续时间的异步处理</figcaption></figure><p id="f25f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哎呀，运行程序后，我们得到了一个意外的输出:<code class="fe mp mq mr ms b">Total time spent: 0ms</code>。那好得令人难以置信。为什么会有这样的结果？</p><p id="f160" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在不同的程序中执行计算功能。第14行不会等待所有的计算goroutines完成，它会在for循环完成后立即执行。由于启动goroutine的速度很快，所以运行for循环的时间不到0.5 ms(四舍五入到0 ms)。在异步示例中应用相同的方法不会反映真实的处理时间。我们需要为程序引入一个块来等待所有goroutines完成。Waitgroup正是为此而构建的。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b83a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要创建一个等待组。对于您想要等待的每个goroutine，您需要在启动goroutine之前向waitgroup添加一个计数器。这是通过调用<code class="fe mp mq mr ms b">Add</code>函数完成的(第14行)。一旦我们在waitgroup中注册了所有的goroutines，我们就可以在任何我们想要的地方添加这个块，在我们的例子中，我们想要在for循环完成之后等待。为了告诉waitgroup一个goroutine已完成，我们只需调用<code class="fe mp mq mr ms b">wg.Done()</code>来将goroutine从waitgourp中取出。这个函数是线程安全的，所以您不需要担心竞争条件和死锁。在执行下面的代码之前，<code class="fe mp mq mr ms b">wg.Wait()</code>调用等待waitgroup中的所有goroutines被取出。</p><p id="6683" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用等待组的常见模式是:</p><ul class=""><li id="80e8" class="nx ny it js b jt ju jx jy kb nz kf oa kj ob kn oc od oe of bi translated">在主goroutine中调用<code class="fe mp mq mr ms b">wg.Add(1)</code>。</li><li id="97f5" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn oc od oe of bi translated">在goroutines中运行的函数开始时调用<code class="fe mp mq mr ms b">defer wg.Done()</code>。我们在这里使用<code class="fe mp mq mr ms b">defer</code>,这样我们不会忘记将goroutines从等待组中取出。如果我们错过了<code class="fe mp mq mr ms b">wg.Done()</code>，<code class="fe mp mq mr ms b">wg.Wait()</code>的呼叫就会永远挂断。</li></ul><p id="e502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我以前在使用waitgroups时犯了一个错误。如果我们在运行于goroutines内部的函数中调用<code class="fe mp mq mr ms b">wg.Add()</code>，我们可能会再次得到“0 ms”的结果。原因是主goroutine可能会在后台goroutine有机会向waitgroup添加计数器之前完成。因此，当调用<code class="fe mp mq mr ms b">wg.Wait()</code>时，它不会阻塞程序，因为它看不到在waitgroup中注册的任何goroutines。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">等待组常见问题</figcaption></figure><p id="d371" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在waitgroup的帮助下，我们让应用程序做了我们想做的事情。并且并行求解数学计算的处理时间看起来有点像<code class="fe mp mq mr ms b">Total time spent: 10006ms</code>。这证明我们的预期是正确的。</p><h1 id="be4f" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">下一步是什么？</h1><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ol"><img src="../Images/f3575f48da5c2dd5cfac44aa0d78e564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UJVErh7XDCEG-SlT"/></div></div></figure><p id="47db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是2022年走Pro的第一段路。</p><p id="f51e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们开始了解goroutines和waitgroups的基本知识。在下一篇文章中，我们将探讨通道、锁和竞争条件检测。敬请关注。第2部分将带给您更多关于goroutines的激动人心的知识。</p><p id="d7be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你遇到任何问题或者需要帮助，请在下面留下你的评论。随时欢迎反馈。感谢您的阅读！</p><p id="79d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想支持我，你可以通过这个推荐链接成为一个中等会员。谢谢你。</p><div class="om on gp gr oo op"><a href="https://songx.medium.com/membership" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">通过我的推荐链接-宋雪加入媒体</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">songx.medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd md op"/></div></div></a></div></div></div>    
</body>
</html>