<html>
<head>
<title>Five ways to copy a list in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python复制列表的五种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/five-ways-to-copy-a-list-in-python-f6f179d9785b?source=collection_archive---------7-----------------------#2020-06-12">https://levelup.gitconnected.com/five-ways-to-copy-a-list-in-python-f6f179d9785b?source=collection_archive---------7-----------------------#2020-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d330" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你能看出区别吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abf3ed35569dcc395cff182100575ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDzqpFv1-xCUxEOWZx_c6Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/pl/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2763553" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/pl/users/suju-165106/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2763553" rel="noopener ugc nofollow" target="_blank"> Susanne Jutzeler，suju-foto </a></figcaption></figure><p id="b3c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会想，“复制一个列表这样的基本事情肯定不会太复杂”。也许我可以用几个微妙的细节让你吃惊。</p><h1 id="32ae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">你怎么能复制一个列表呢？</h1><p id="ae07" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">谈到复制列表的不同方法，Python提供了相当多的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Python中复制列表的五种不同方法</figcaption></figure><p id="b3f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法有什么不同？让我们用下面的例子来探究一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能绝对自信的说打印<code class="fe mu mv mw mx b">l</code>、<code class="fe mu mv mw mx b">m</code>、<code class="fe mu mv mw mx b">n</code>、<code class="fe mu mv mw mx b">o</code>、<code class="fe mu mv mw mx b">p</code>、<code class="fe mu mv mw mx b">r</code>的结果会是什么？</p><p id="32e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是的话，干得好，你已经掌握了用Python复制列表的艺术。如果没有，没什么可担心的:你将在接下来的几分钟内掌握这门艺术。</p><h1 id="4390" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">原始列表</h1><p id="5099" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最开始的时候，原来的列表是这样的:<code class="fe mu mv mw mx b">[1, 5, {7}, {3}]</code>。让我们看看发生了什么变化:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="1328" class="nc lw it mx b gy nd ne l nf ng">&gt;&gt; l<br/>[1, 6, {7, 8}, {3, 4}, 2]</span></pre><h2 id="1d9d" class="nc lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">Int元素</h2><p id="66a0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">通过<code class="fe mu mv mw mx b">x += 1</code>操作修改第一个元素的尝试失败，而通过<code class="fe mu mv mw mx b">l[1] += 1</code>修改第二个元素按预期工作。为什么？</p><p id="2d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们注意到这两个值都是int—<strong class="lb iu">不可变的</strong>变量。这意味着试图改变它们不会修改原来的对象，而只是创建新的对象。(如果你想了解更多关于可变和不可变变量的知识，请查看我之前的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/can-you-solve-these-3-seemingly-easy-python-problems-2c793967cd2c">文章</a>。)</p><p id="7201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助下图，可以很容易地解释所发生的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/6badd9dfe75371b9575706ab34e64581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*TFdcVQO3XpKL-bee8V2Itg.png"/></div></figure><p id="cf3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当定义列表的第一个元素为<code class="fe mu mv mw mx b">x</code>时，我们让<code class="fe mu mv mw mx b">l[0]</code>指向内存中与<code class="fe mu mv mw mx b">x</code>引用的对象相同的对象(左图)。<code class="fe mu mv mw mx b">x += 1</code>操作不会改变那个对象，它告诉变量<code class="fe mu mv mw mx b">x</code>指向一个新的对象。同时<code class="fe mu mv mw mx b">l[0]</code>保持不变(右图)。</p><p id="9ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于<code class="fe mu mv mw mx b">l[1]</code>，原本指向一个int对象，值为<code class="fe mu mv mw mx b">5</code>(左图)。<code class="fe mu mv mw mx b">l[1] += 1</code>操作使其指向一个新的int变量，值为<code class="fe mu mv mw mx b">6</code>(右图)。</p><h2 id="bb52" class="nc lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">设置元素</h2><p id="551e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与int元素不同，set元素都被修改了。集合和整型之间的区别在于集合是可变的:它们可以在适当的位置被改变。向集合中添加一个新元素不会在内存中创建一个新的对象，它只是修改了原来的对象。</p><p id="ebdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/05ff68224facbd6c4d841077d522d1e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*N--W9ECmb_ES198CeRuRIA.png"/></div></figure><p id="d4fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当定义<code class="fe mu mv mw mx b">l[2] = s</code>时，我们让它指向内存中与<code class="fe mu mv mw mx b">s</code>指向的对象相同的对象(左图)。<code class="fe mu mv mw mx b">s.add(8)</code>操作修改了该对象，因此在我们的列表<code class="fe mu mv mw mx b">l</code>(右图)中可以看到变化。改变<code class="fe mu mv mw mx b">l[3]</code>也有类似的效果。</p><h1 id="c7eb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">方法1</h1><p id="2f11" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您遵循前面的部分，打印由<br/> <code class="fe mu mv mw mx b">m = l</code>定义的列表的结果应该不会令人惊讶:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="d65d" class="nc lw it mx b gy nd ne l nf ng">&gt;&gt; m<br/>[1, 6, {7, 8}, {3, 4}, 2]</span></pre><p id="d091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到两个列表是相同的。此外，检查<br/> <code class="fe mu mv mw mx b">id(l) == id(m)</code>将导致<code class="fe mu mv mw mx b">True</code>，这意味着变量<code class="fe mu mv mw mx b">l</code>和<code class="fe mu mv mw mx b">m</code>都指向内存中的同一个对象。这正是我们之前在<code class="fe mu mv mw mx b">l[2]</code>和<code class="fe mu mv mw mx b">s</code>中观察到的:改变一个可变对象(例如集合或列表)将通过指向它的所有变量可见。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1d0e5bf0b61ecbd8662bddf7d517a1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*4SiD8PnLemuRKAqbzfRTXA.png"/></div></figure><p id="60ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下<strong class="lb iu">我们并没有真正复制列表</strong>，我们只是创建了一个不同的变量指向它。</p><h1 id="2565" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">方法2–4</h1><p id="53bc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你可以看到接下来的三种方法<code class="fe mu mv mw mx b">n = l[:]</code>、<code class="fe mu mv mw mx b">o = list(l)</code>和<br/> <code class="fe mu mv mw mx b">p = copy.copy(l)</code>导致了相同的结果:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="462a" class="nc lw it mx b gy nd ne l nf ng">&gt;&gt; n<br/>[1, 5, {7, 8}, {3, 4}]</span><span id="cc21" class="nc lw it mx b gy nv ne l nf ng">&gt;&gt; o<br/>[1, 5, {7, 8}, {3, 4}]</span><span id="a7d0" class="nc lw it mx b gy nv ne l nf ng">&gt;&gt; p<br/>[1, 5, {7, 8}, {3, 4}]</span></pre><p id="78d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的列表<code class="fe mu mv mw mx b">n</code>、<code class="fe mu mv mw mx b">o</code>和<code class="fe mu mv mw mx b">p</code>都是列表<code class="fe mu mv mw mx b">l</code>的所谓<strong class="lb iu">浅拷贝</strong>:它们是新对象，但是填充了在原始列表<code class="fe mu mv mw mx b">l</code>中找到的子对象的引用。因此，通过<code class="fe mu mv mw mx b">l.append(2)</code>改变列表本身不会改变副本，但是修改已经存在于<code class="fe mu mv mw mx b">l</code>中的<strong class="lb iu">可变</strong>元素会改变副本。这里有一张图，可以帮助你更好地理解它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/299447d6014c357a1757d0e6422485d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*TM6ZGxZDeLzaAUj-fHstKQ.png"/></div></figure><h1 id="4550" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">方法5</h1><p id="40db" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后一个方法<code class="fe mu mv mw mx b">r = copy.deepcopy(l)</code>产生一个副本，该副本与所有更改之前的原始列表<code class="fe mu mv mw mx b">l</code>相同:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="8bd0" class="nc lw it mx b gy nd ne l nf ng">&gt;&gt; r<br/>[1, 5, {7}, {3}]</span></pre><p id="9ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，复制过程遍历整个对象树，并为每个遇到的对象创建一个完全独立的<strong class="lb iu">副本。无论你对原始列表<code class="fe mu mv mw mx b">l</code>中的对象做什么，都不会影响它的深层副本<code class="fe mu mv mw mx b">r</code>。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/8b3fe50e1c7c1d1cc9100f0c26efc6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*AjiFGYZopOZm86vZQ02ymQ.png"/></div></figure><h1 id="91e2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><ul class=""><li id="e5a4" class="ny nz it lb b lc mn lf mo li oa lm ob lq oc lu od oe of og bi translated">赋值<code class="fe mu mv mw mx b">m = l</code>并没有创建一个副本，它只是给了我们的列表另一个名字。<code class="fe mu mv mw mx b">l</code>的所有修改将在<code class="fe mu mv mw mx b">m</code>中可见，并且它们指的是同一个对象。</li><li id="ac6a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">下面这些复制列表的方法是等价的:<code class="fe mu mv mw mx b">n = l[:]</code>、<code class="fe mu mv mw mx b">o = list(l)</code>和<code class="fe mu mv mw mx b">p = copy.copy(l)</code>。改变原始列表<code class="fe mu mv mw mx b">l</code>的<strong class="lb iu">可变</strong>元素也会影响这些浅层副本。(你可以在这里找到更多关于可变和不可变变量的信息<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/can-you-solve-these-3-seemingly-easy-python-problems-2c793967cd2c"/></li><li id="e62e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">唯一真正独立的副本是<code class="fe mu mv mw mx b">r = copy.deepcopy(l)</code>。改变原始列表<code class="fe mu mv mw mx b">l</code>中的元素(可变的或不可变的)不会影响这个副本。</li></ul></div></div>    
</body>
</html>