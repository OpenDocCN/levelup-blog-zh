<html>
<head>
<title>C++ Exception Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++异常处理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/c-exception-handling-208daca53be5?source=collection_archive---------3-----------------------#2022-06-24">https://levelup.gitconnected.com/c-exception-handling-208daca53be5?source=collection_archive---------3-----------------------#2022-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">回到基础</h2></div><h1 id="4bf9" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">基础知识</h1><p id="f070" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">异常是在程序执行过程中出现的问题。C++异常是对程序运行时出现的异常情况的响应，例如试图被零除。</p><p id="421c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">异常提供了一种将控制从程序的一部分转移到另一部分的方法。C++异常处理建立在三个关键字之上:<strong class="lc iu"> try，catch，</strong>和<strong class="lc iu"> throw </strong>。</p><ul class=""><li id="00e0" class="mb mc it lc b ld lw lg lx lj md ln me lr mf lv mg mh mi mj bi translated"><strong class="lc iu">抛出</strong>——程序在出现问题时抛出异常。这是使用<strong class="lc iu"> throw </strong>关键字完成的。</li><li id="ae71" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated"><strong class="lc iu">catch</strong>——一个程序在你想处理问题的地方用一个异常处理程序捕捉一个异常。<strong class="lc iu"> catch </strong>关键字表示异常的捕获。</li><li id="7490" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated"><strong class="lc iu">try</strong>—<strong class="lc iu">try</strong>块标识特定异常将被激活的代码块。后面跟着一个或多个catch块。</li></ul><p id="7822" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">假设一个块将引发一个异常，一个方法使用<strong class="lc iu"> try </strong>和<strong class="lc iu"> catch </strong>关键字的组合来捕获一个异常。try/catch块放在可能生成异常的代码周围。try/catch块中的代码称为受保护代码，使用try/catch的语法如下</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="559f" class="my kj it mu b gy mz na l nb nc">try {<br/>// protected code<br/>} catch( ExceptionName e1 ) {<br/>// catch block<br/>} catch( ExceptionName e2 ) {<br/>// catch block<br/>} catch( ExceptionName eN ) {<br/>// catch block<br/>}</span></pre><p id="2590" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">您可以列出多个<strong class="lc iu"> catch </strong>语句来捕捉不同类型的异常，以防您的<strong class="lc iu"> try </strong>块在不同情况下引发多个异常。</p><h1 id="4c37" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">抛出异常</h1><p id="e42b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用<strong class="lc iu"> throw </strong>语句可以在代码块中的任何地方抛出异常。throw语句的操作数决定了异常的类型，可以是任何表达式，表达式结果的类型决定了抛出的异常的类型。</p><p id="271d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">以下是发生被零除情况时抛出异常的示例</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="720f" class="my kj it mu b gy mz na l nb nc">double division(int a, int b) {<br/>if( b == 0 ) {<br/>throw "Division by zero condition!";<br/>}<br/>return (a/b);<br/>}</span></pre><h2 id="e268" class="my kj it bd kk nd ne dn ko nf ng dp ks lj nh ni ku ln nj nk kw lr nl nm ky nn bi translated">处理任何异常捕获</h2><p id="2336" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在catch块参数中使用…可以捕获几乎所有异常，而不管其类型如何。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d522" class="my kj it mu b gy mz na l nb nc">try {<br/>// protected code<br/>} catch(...) {<br/>// code to handle any exception<br/>}</span></pre><h2 id="880e" class="my kj it bd kk nd ne dn ko nf ng dp ks lj nh ni ku ln nj nk kw lr nl nm ky nn bi translated">抛出并捕获一个Const Char指针</h2><p id="3c30" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面的例子展示了一个被零除的异常，其中我们抛出了一个常量字符指针(第6行你可以看到我们传递了一个字符串), catch将常量char*作为参数。</p><p id="aecd" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">毫无疑问，这种风格更老，更少面向对象，但你应该意识到这一点。</p><figure class="mp mq mr ms gt no"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="6488" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">C++标准异常</h1><p id="b97c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">C++提供了一个在<strong class="lc iu"> &lt;异常&gt; </strong>中定义的标准异常列表，我们可以在我们的程序中使用它。这些按父子类层次结构排列，如下所示</p><figure class="mp mq mr ms gt no gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f534b3fb94a26977615ac910464820c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*QJba_MKuu1MYSC-lrK9e2Q.png"/></div></figure><p id="6450" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">下面是上面层次结构中提到的每个异常的简短描述</p><p id="5d00" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::exception — </strong>所有标准C++异常的异常和父类。</p><p id="ae6e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::bad_alloc — </strong>这个可以由<strong class="lc iu">新</strong>抛出。</p><p id="c3b0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::bad_cast — </strong>这个可以由<strong class="lc iu"> dynamic_cast </strong>抛出。</p><p id="7ccc" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::bad_exception — </strong>这是处理C++程序中意外异常的有用设备。</p><p id="07d3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::bad_typeid — </strong>这个可以由<strong class="lc iu"> typeid </strong>抛出。</p><p id="0f4f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::logic_error — </strong>理论上可以通过读取代码检测到的异常。</p><p id="b4a7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::domain_error — </strong>这是使用数学上无效的域时引发的异常。</p><p id="71ea" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::invalid_argument — </strong>这是由于无效的参数而引发的。</p><p id="066a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::length_error — </strong>创建太大的std::string时抛出。</p><p id="5373" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::out_of_range — </strong>这可以由“at”方法抛出，例如std::vector和STD::bit set&lt;&gt;::operator[]()。</p><p id="bd68" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::runtime_error — </strong>理论上无法通过读取代码检测到的异常。</p><p id="7477" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::overflow_error — </strong>发生数学溢出时抛出。</p><p id="c766" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::range_error — </strong>当您试图存储超出范围的值时，会出现这种情况。</p><p id="7ed4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> std::underflow_error — </strong>如果发生数学上的下溢，将抛出此错误。</p><h1 id="6c5f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">定义新的例外</h1><p id="5024" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可以通过继承和覆盖<strong class="lc iu">异常</strong>类功能来定义自己的异常。下面的例子展示了如何使用std::exception类以标准方式实现自己的异常</p><figure class="mp mq mr ms gt no"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="47d3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这将产生以下结果</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="30f2" class="my kj it mu b gy mz na l nb nc">MyException caught<br/>C++ Exception</span></pre><p id="92d3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这里，<strong class="lc iu"> what() </strong>是异常类提供的公共方法，它已经被所有子异常类覆盖。这将返回异常的原因。</p><h2 id="5c3b" class="my kj it bd kk nd ne dn ko nf ng dp ks lj nh ni ku ln nj nk kw lr nl nm ky nn bi translated">“”标记前应为类名</h2><p id="5fb3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您在尝试实现上面的示例时，在' { token'之前得到错误“<a class="ae nu" href="https://stackoverflow.com/questions/11297849/very-basic-inheritance-error-expected-class-name-before-token" rel="noopener ugc nofollow" target="_blank">预期类名”，那是因为您忘记了#include &lt;异常&gt;</a></p><h1 id="712d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">向自定义C++异常传递参数</h1><figure class="mp mq mr ms gt no"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="64cf" class="my kj it bd kk nd ne dn ko nf ng dp ks lj nh ni ku ln nj nk kw lr nl nm ky nn bi translated">警告:ISO C++禁止将字符串常量转换为“char*”</h2><p id="55fa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">警告意味着您的程序是错误的。在C++11之前，传递一个字符串文字作为<code class="fe nv nw nx mu b">char*</code>曾经是格式良好的，但现在不推荐使用。确保添加一个接受const char*的函数重载来解决这个问题，并且可以向该函数传递一个字符串文字。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a4aa" class="my kj it mu b gy mz na l nb nc">MyCustomException(const char* msg): message(msg) {}</span></pre><h1 id="9ccd" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">参考</h1><p id="d597" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">[1] C++异常处理。<a class="ae nu" href="https://www.tutorialspoint.com/cplusplus/cpp_exceptions_handling.htm#:~:text=A%20C%2B%2B%20exception%20is%20a,try%2C%20catch%2C%20and%20throw" rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/cplusplus/CPP _ exceptions _ handling . htm #:~:text = A % 20C % 2B % 2B % 20 exception % 20 is % 20a，try % 2C % 20 catch % 2C % 20和%20throw </a>。</p><p id="2af6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">[2]向自定义C++异常传递参数。https://rollbar.com/blog/cpp-custom-exceptions/<a class="ae nu" href="https://rollbar.com/blog/cpp-custom-exceptions/" rel="noopener ugc nofollow" target="_blank"/></p><p id="8ebe" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">[3]警告:ISO C++禁止将字符串常量转换为“char*”。<a class="ae nu" href="https://stackoverflow.com/questions/56524609/warning-iso-c-forbids-converting-a-string-constant-to-char-wwrite-string" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/56524609/warning-iso-c-banneds-converting-a-string-constant-to-char-ww write-string</a></p></div></div>    
</body>
</html>