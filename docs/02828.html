<html>
<head>
<title>One Trick for Phenomenally Smaller Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个非常小的单元测试技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pytest-an-introduction-to-parametrization-2b27bebb6d4b?source=collection_archive---------7-----------------------#2020-04-06">https://levelup.gitconnected.com/pytest-an-introduction-to-parametrization-2b27bebb6d4b?source=collection_archive---------7-----------------------#2020-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d8f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为你的Python包编写*非常*简洁的单元测试指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d65fdf683660013c3c4de26cd1db2680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RJGusGO0hnHDOTFkVzHQQ.jpeg"/></div></div></figure><p id="de17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi ln translated">第一部分将解释随附软件包的结构以及如何在您的系统上设置它。如果您只想查看PyTest中参数化的例子，您可以直接跳到第二部分“参数化测试”。</p><h2 id="77a6" class="lw lx iq bd ly lz ma dn mb mc md dp me la mf mg mh le mi mj mk li ml mm mn mo bi translated">要克隆本文附带的源代码，<a class="ae mp" href="https://github.com/RishabhMalviya/PyTestParametrization_Article" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</h2></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="6e3d" class="mx lx iq bd ly my mz na mb nb nc nd me jw ne jx mh jz nf ka mk kc ng kd mn nh bi translated">包装结构和设置</h1><p id="7e1c" class="pw-post-body-paragraph kr ks iq kt b ku ni jr kw kx nj ju kz la nk lc ld le nl lg lh li nm lk ll lm ij bi translated">克隆的存储库将包含一个名为<code class="fe nn no np nq b">efficient_dedup</code>的包和一个包含测试用例的<code class="fe nn no np nq b">tests</code>文件夹。</p><p id="1f99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该包旨在Python列表中执行高效的重复数据删除(删除重复值)。它分两步完成，首先对列表进行排序，然后使用其中一种重复数据消除算法对排序后的列表进行重复数据消除。注意，这个包只是说明性的；因此，许多代码在功能上是多余的。这是包的结构:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="0419" class="lw lx iq nq b gy nv nw l nx ny">efficient_dedup<br/>|<br/>| - efficient_deduplication<br/>| - deduplication_algorithms<br/>| - sorting_algorithms<br/>|<br/>| - tests<br/>    |<br/>    | - test_efficient_deduplication</span></pre><p id="13cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它基于<a class="ae mp" href="https://refactoring.guru/design-patterns/strategy/python/example" rel="noopener ugc nofollow" target="_blank">战略设计模式</a>。在<code class="fe nn no np nq b">efficient_deduplication</code>模块中定义的<code class="fe nn no np nq b">EfficientDeduplicator</code>类是上下文:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7752" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要来自每个<code class="fe nn no np nq b">deduplication_algorithms</code>和<code class="fe nn no np nq b">sorting_algorithms</code>模块的策略实现。</p><p id="5a1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe nn no np nq b">sorting_algorithms</code>模块中只定义了两个策略行为，它们都封装在一个类<code class="fe nn no np nq b">SortingAlgorithm</code>中；您想要的特定行为可以通过将<code class="fe nn no np nq b">reverse</code>参数设置为<code class="fe nn no np nq b">True</code>或<code class="fe nn no np nq b">False</code>来选择:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="06af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nn no np nq b">deduplication_algorithms</code>模块包含四个不同的实现，每个都封装在不同的类中。第一个类<code class="fe nn no np nq b">DeduplicationAlgorithm</code>，充当其他三个实现的基类(这不是实际的代码，因为这里省略了函数的定义):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1c1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要运行测试用例，将<code class="fe nn no np nq b">cd</code>放到包的根文件夹中并运行下面的命令:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="27e7" class="lw lx iq nq b gy nv nw l nx ny">&gt; cd &lt;git-repo-root&gt;/efficient_dedup<br/>&gt; python -m pytest</span></pre><h1 id="f226" class="mx lx iq bd ly my ob na mb nb oc nd me jw od jx mh jz oe ka mk kc of kd mn nh bi translated">参数化测试</h1><p id="2689" class="pw-post-body-paragraph kr ks iq kt b ku ni jr kw kx nj ju kz la nk lc ld le nl lg lh li nm lk ll lm ij bi translated">所以，我们先总结一下再继续。我们有一个名为<code class="fe nn no np nq b">EfficientDeduplicator</code>的上下文类，它需要两个策略:一个<code class="fe nn no np nq b">SortingAlgorithm</code>和一个<code class="fe nn no np nq b">DeduplicationAlgorithm</code>。这个上下文类只有一个功能，<code class="fe nn no np nq b">deduplicate_efficiently</code>。</p><p id="ca47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们想用所有可能的策略组合和一些不同的测试数据来测试<code class="fe nn no np nq b">deduplicate_efficiently</code>。正如我们将看到的，如果我们利用参数化，在一个测试用例中完成所有这些是可能的。</p><h2 id="c5fe" class="lw lx iq bd ly lz ma dn mb mc md dp me la mf mg mh le mi mj mk li ml mm mn mo bi translated">数据参数化</h2><p id="d354" class="pw-post-body-paragraph kr ks iq kt b ku ni jr kw kx nj ju kz la nk lc ld le nl lg lh li nm lk ll lm ij bi translated">这是我们可以编写的最基本的测试用例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="e28c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们想要用几个不同的可能输入来执行这个测试，例如，变量<code class="fe nn no np nq b">list_with_duplicates</code>的几个不同的值。首先，我们让<code class="fe nn no np nq b">list_with_duplicates</code>成为测试函数中的一个参数。然后，我们通过<code class="fe nn no np nq b">@pytest.marker.parametrize</code>装饰器为该参数提供一个值列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b8fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是在Pytest中进行参数化的一般程序:</p><ol class=""><li id="8323" class="og oh iq kt b ku kv kx ky la oi le oj li ok lm ol om on oo bi translated">您可以在测试函数的参数列表中指定要参数化的变量</li><li id="afce" class="og oh iq kt b ku op kx oq la or le os li ot lm ol om on oo bi translated">然后使用<code class="fe nn no np nq b">@pytest.marker.parametrize</code>装饰器为变量提供一个值列表。</li></ol><h2 id="880d" class="lw lx iq bd ly lz ma dn mb mc md dp me la mf mg mh le mi mj mk li ml mm mn mo bi translated">类的参数化</h2><p id="034b" class="pw-post-body-paragraph kr ks iq kt b ku ni jr kw kx nj ju kz la nk lc ld le nl lg lh li nm lk ll lm ij bi translated">现在，假设我们想要用所有可能的不同的<code class="fe nn no np nq b">DeduplicationAlgorithm</code>实现来运行基本测试，但是保持数据不变。这可以通过Pytest参数化、Python的<code class="fe nn no np nq b">inspect</code>模块以及类在Python中是一等公民的事实(意味着它们可以作为函数的参数传递)的巧妙结合来实现。</p><p id="b79a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要获得<code class="fe nn no np nq b">deduplication_algorithms</code>模块中所有类的列表，我们可以导入该模块，然后运行以下代码:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="b1cf" class="lw lx iq nq b gy nv nw l nx ny">print([<br/>    getattr(deduplication_algorithms, name)<br/>    <strong class="nq ir">for </strong>name, obj<br/>    <strong class="nq ir">in </strong>inspect.getmembers(deduplication_algorithms)<br/>    <strong class="nq ir">if </strong>inspect.isclass(obj)<br/>])</span></pre><p id="49bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这为我们提供了模块中的类列表:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="cf60" class="lw lx iq nq b gy nv nw l nx ny">[<br/>&lt;class 'efficient_dedup.deduplication_algorithms.DeduplicationAlgorithm'&gt;, </span><span id="ecbc" class="lw lx iq nq b gy ou nw l nx ny">&lt;class 'efficient_dedup.deduplication_algorithms.HashSetDeduplicationAlgori<br/>thm'&gt;,</span><span id="a07d" class="lw lx iq nq b gy ou nw l nx ny">&lt;class 'efficient_dedup.deduplication_algorithms.CustomComparisonDeduplicationAlgorithm'&gt;,</span><span id="b099" class="lw lx iq nq b gy ou nw l nx ny">&lt;class 'efficient_dedup.deduplication_algorithms.LookaheadCustomComparisonDeduplicationAlgorithm'&gt;<br/>]</span></pre><p id="8d1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们可以将它传递给<code class="fe nn no np nq b">@pytest.marker.parametrize</code>装饰器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c1c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">瞧吧。您已经在Pytest中实现了类参数化！</p><h2 id="9307" class="lw lx iq bd ly lz ma dn mb mc md dp me la mf mg mh le mi mj mk li ml mm mn mo bi translated">组合数据和类参数化</h2><p id="97a8" class="pw-post-body-paragraph kr ks iq kt b ku ni jr kw kx nj ju kz la nk lc ld le nl lg lh li nm lk ll lm ij bi translated">Pytest的一个很好的特性是，如果你在一个测试函数上堆叠了许多<code class="fe nn no np nq b">@pytest.marker.parametrize</code>decorator，那么它会自动运行所有decorator的所有可能组合的测试(就像一个集合产品)。最后，我们将使用这个特性在一个测试用例中组合上述两个参数化；事实上，我们还将在<code class="fe nn no np nq b">SortingAlgorithm</code>的<code class="fe nn no np nq b">reverse</code>属性上添加一个参数化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="003d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是您将要克隆的包中测试用例的最终形式。如果您冗长地运行Pytest:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="1505" class="lw lx iq nq b gy nv nw l nx ny">&gt; python -m pytest -v</span></pre><p id="093e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您将看到如下输出:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="6df0" class="lw lx iq nq b gy nv nw l nx ny">tests/test_efficient_deduplication.py::TestEfficientDeduplicators::test_deduplicate_efficiently</span><span id="9fe5" class="lw lx iq nq b gy ou nw l nx ny">[DeduplicationAlgorithm-True-list_with_duplicates0] </span><span id="bbaa" class="lw lx iq nq b gy ou nw l nx ny">PASSED [33%]</span></pre><p id="bbc4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面输出中的第二行列出了测试用例中使用的参数的精确组合。</p><h1 id="180d" class="mx lx iq bd ly my ob na mb nb oc nd me jw od jx mh jz oe ka mk kc of kd mn nh bi translated">结论</h1><p id="2032" class="pw-post-body-paragraph kr ks iq kt b ku ni jr kw kx nj ju kz la nk lc ld le nl lg lh li nm lk ll lm ij bi translated">使用本文中描述的技术在将来编写更简洁有效的Python测试用例！</p></div></div>    
</body>
</html>