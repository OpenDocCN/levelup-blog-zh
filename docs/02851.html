<html>
<head>
<title>Creating an app for mac using Typescript, Electron, React, Express, Rollup, Yarn, and Supercollider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Typescript、electronic、React、Express、Rollup、Yarn和Supercollider创建mac应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-an-app-for-mac-using-electron-react-express-rollup-yarn-and-supercollider-843740672d6?source=collection_archive---------12-----------------------#2020-04-07">https://levelup.gitconnected.com/creating-an-app-for-mac-using-electron-react-express-rollup-yarn-and-supercollider-843740672d6?source=collection_archive---------12-----------------------#2020-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/f38cff2ecadd6022cd71f61f05715fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*_bq2g7Lo2RjWi98i5l75Wg.png"/></div></figure><p id="b5dd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是一篇关于我使用electron将一个现有的node和react项目转换成一个独立的mac应用程序的文章。</p><p id="2724" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我有一个现有的项目，它有一个基于React-powered web浏览器的前端，可以与Express.js后端通信。后端可以读取、写入和查询文件系统上的文件，并运行应用程序Supercollider来处理音频。最近，我决定尝试将这个项目转换成一个独立的电子应用程序。这样做的部分原因是试图将前端和后端放入一个方便的包中，部分原因是为了看看这项技术有多容易使用。虽然有很多关于使用电子在线的指南，但往往有一些非常简单的问题需要大量的研究来解决，所以我想我会写这篇文章来分享我从这个过程中获得的一些知识，希望其他人不必经历同样的努力。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ea69" class="le lf it la b gy lg lh l li lj">DISCLAIMER: As web-based technologies are changing so quickly at the moment, it is worth noting that I am writing this in March 2020, and that this advice may not work by the time you read it.  Also, I am only dealing with building an app on mac - there are slightly different idiosyncrasies for both linux and windows which I will not cover here, as I don't have first-hand experience of them.</span></pre><h1 id="541e" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">什么是电子？</h1><p id="dd43" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">Electron.js没有打包基于<code class="fe mm mn mo la b">node.js</code>的项目，这样它们就可以作为独立的应用程序运行。或者，正如他们的<a class="ae mp" href="https://www.electronjs.org" rel="noopener ugc nofollow" target="_blank">网站</a>所描述的:“用JavaScript、HTML和CSS构建跨平台的桌面应用”</p><h1 id="f680" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">为什么我要将我的react和express项目转换成一个独立的电子应用程序？</h1><p id="9211" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">在我现有的项目中，我使用React作为在网络浏览器中运行的交互式前端。与前端交互将允许用户在本地文件系统上生成、操作、读取和写入音频和文本文件。由于安全限制，网络浏览器不允许通过javascript脚本直接访问文件系统(因此<code class="fe mm mn mo la b">exec</code>、<code class="fe mm mn mo la b">fsRead</code>或<code class="fe mm mn mo la b">fsWrite</code>等<code class="fe mm mn mo la b">node</code>命令不会在浏览器内部运行)。因此，在浏览器之外运行一个后端服务器是很有用的，它可以使用<code class="fe mm mn mo la b">node</code>来控制文件系统访问，并通过http与前端通信。然而，如果你想和别人分享这个项目，它有时会很难设置；因此，使用electron将它打包成一个独立的应用程序，对于那些可能不熟悉node/npm/javascript技术或者可能没有兴趣或时间来完成安装一整套依赖项以使您的项目正常工作的人来说，是非常有用的。</p><h1 id="ff4d" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">你用什么工具来创建一个独立的应用程序？</h1><p id="660f" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">显然是电子。Electron将你的组件打包成一个简化版的chromium，但是你需要一个单独的程序将它打包成一个独立的应用程序。目前，有三种常用的方法可以使用electronic将现有项目打包成独立的应用程序:</p><ul class=""><li id="59f3" class="mq mr it jz b ka kb ke kf ki ms km mt kq mu ku mv mw mx my bi translated">电子锻造<a class="ae mp" href="https://electronforge.io/" rel="noopener ugc nofollow" target="_blank">https://electronforge.io/</a></li><li id="570c" class="mq mr it jz b ka mz ke na ki nb km nc kq nd ku mv mw mx my bi translated">电子制造商<a class="ae mp" href="https://github.com/electron-userland/electron-builder" rel="noopener ugc nofollow" target="_blank">https://github.com/electron-userland/electron-builder</a></li><li id="8b3a" class="mq mr it jz b ka mz ke na ki nb km nc kq nd ku mv mw mx my bi translated">电子反应样板<a class="ae mp" href="https://github.com/chentsulin/electron-react-boilerplate" rel="noopener ugc nofollow" target="_blank">https://github.com/chentsulin/electron-react-boilerplate</a></li></ul><p id="9638" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你选择哪一个很大程度上取决于你有多少耐心，你想要输出的文件的大小，以及你需要的定制程度。</p><p id="d80a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你想很快得到结果，并且不在乎文件大小，使用<code class="fe mm mn mo la b">electron-forge</code>。如果你从头开始构建你的项目，它很大程度上是基于react的，或者你需要尽可能小的包，使用<code class="fe mm mn mo la b">electron-react-boilerplate</code>。我没有用过电子生成器，所以我不能对它说话。<code class="fe mm mn mo la b">electron-react-boilerplate</code>在幕后调整了许多设置，以确保最终的构建规模尽可能小。<code class="fe mm mn mo la b">electron-forge</code>提供了大量的配置选项，但是由于它是建立在<code class="fe mm mn mo la b">electron-rebuild</code>、<code class="fe mm mn mo la b">electron-packager</code>之上，并且包含了一个广泛的插件系统，理解改变什么以及如何改变它需要大量的时间。我最后用了<code class="fe mm mn mo la b">electron-react-boilerplate</code>。</p><h1 id="6d78" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我完成的应用程序会有多大？</h1><p id="2910" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">在mac上，几乎不可能获得低于130MB的成品应用程序，这是因为该应用程序捆绑了chromium版本。压缩可以将该大小减少一半。根据我的经验，<code class="fe mm mn mo la b">electron-forge</code>往往比<code class="fe mm mn mo la b">electron-react-boilerplate</code>大50MB左右。完了。我的应用程序的dmg文件大约是90MB。zip文件自动生成。</p><p id="e081" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">另见:<a class="ae mp" href="https://stackoverflow.com/questions/47597283/electron-package-reduce-the-package-size" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/47597283/electronic-package-reduce-the-package-size</a></p><h1 id="6a88" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">纱线vs npm</h1><p id="cbd4" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">对于电子应用程序，最好使用<code class="fe mm mn mo la b">yarn</code>而不是<code class="fe mm mn mo la b">npm</code>——这是因为许多电子工具都只使用纱线，就像<code class="fe mm mn mo la b">lerna</code>一样。如果你正在使用npm，我建议在尝试用electronic做任何事情之前先切换一下，尽管<code class="fe mm mn mo la b">electron-forge</code>是少数几个可以与两个包管理器一起工作的工具之一。</p><h1 id="8796" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">使用你的前端</h1><p id="206d" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">如果你正在构建一个有前端和后端的应用程序，你可能已经为项目的前端和后端创建了两个独立的文件夹。</p><p id="1eb9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你已经使用了<code class="fe mm mn mo la b">create-react-app</code>作为你的react前端，那么使用内置于该模块的极其高效的打包选项可能是最有意义的，而不是试图手动将其打包到一个独立的模块中——我放弃了尝试使用<code class="fe mm mn mo la b">rollup</code>来打包我的react项目，而是运行<code class="fe mm mn mo la b">yarn build</code>来生成一个构建文件夹，然后我使用<code class="fe mm mn mo la b">gulp</code>将其复制到我的电子应用程序的<code class="fe mm mn mo la b">app/dist/</code>文件夹中，方法是在我的<code class="fe mm mn mo la b">electron-react-boilerplate</code>文件夹的根文件夹中添加一个名为<code class="fe mm mn mo la b">gulpfile.js</code>的新文件:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="931e" class="le lf it la b gy lg lh l li lj">// gulpfile.js<br/>const gulp = require('gulp');<br/>const path = require('path');</span><span id="cb56" class="le lf it la b gy ne lh l li lj">function copyFrontend() {<br/>  return gulp<br/>    .src(['../frontend/build/**/*.*'])<br/>    .pipe(gulp.dest('app/dist/frontend'));<br/>}</span><span id="33c0" class="le lf it la b gy ne lh l li lj">exports.default = gulp.series(copyFrontend);</span></pre><p id="7793" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并将以下内容添加到同一个文件夹中的顶层<code class="fe mm mn mo la b">package.json</code>:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="fe05" class="le lf it la b gy lg lh l li lj">// package.json<br/>"scripts": {<br/>    ...<br/>    "resources": "rm -r -f app/dist/frontend &amp;&amp; gulp -f gulpfile.js",<br/>     "package": "yarn resources &amp;&amp; yarn build &amp;&amp; electron-builder build --publish never",<br/>    ...<br/>}</span></pre><h1 id="f05d" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">使用您的后端</h1><p id="0b9f" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">对于后端，使用像<code class="fe mm mn mo la b">rollup</code>这样的工具打包你的模块可能是有用的，它似乎比react组件更适合直接使用javascript。以下是我用来打包我的express应用程序的<code class="fe mm mn mo la b">rollup.config.js</code>文件:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="9b1b" class="le lf it la b gy lg lh l li lj">import typescript from 'rollup-plugin-typescript2';<br/>import external from 'rollup-plugin-peer-deps-external';<br/>import commonjs from 'rollup-plugin-commonjs';<br/>import resolve from 'rollup-plugin-node-resolve';<br/>import url from 'rollup-plugin-url';<br/>import json from '@rollup/plugin-json';<br/>import pkg from './package.json';</span><span id="bc2b" class="le lf it la b gy ne lh l li lj">export default {<br/>    input: 'src/server.ts',<br/>    output: [<br/>        {<br/>            file: pkg.main,<br/>            format: 'commonjs',<br/>            sourcemap: true,<br/>        },<br/>        {<br/>            file: pkg.module,<br/>            format: 'es',<br/>            sourcemap: true,<br/>        },<br/>    ],<br/>    plugins: [<br/>        external(),<br/>        url(),<br/>        json(),<br/>        typescript({<br/>            typescript: require('typescript'),<br/>            rollupCommonJSResolveHack: true,<br/>            clean: true,<br/>        }),<br/>        resolve({ preferBuiltins: true }),<br/>        commonjs(),<br/>    ],<br/>};</span></pre><p id="d27e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我的<code class="fe mm mn mo la b">tsconfig.json</code>文件中找到的我的类型脚本配置是:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="8199" class="le lf it la b gy lg lh l li lj">{<br/>    "compilerOptions": {<br/>        "target": "es5",<br/>        "skipLibCheck": true,<br/>        "esModuleInterop": true,<br/>        "allowSyntheticDefaultImports": true,<br/>        "strict": true,<br/>        "forceConsistentCasingInFileNames": true,<br/>        "module": "ESNext",<br/>        "moduleResolution": "node",<br/>        "noImplicitAny": false,<br/>        "resolveJsonModule": true,<br/>        "declaration": true,<br/>        "declarationDir": "./dist"<br/>    },<br/>    "include": [<br/>        "src/**/*"<br/>    ],<br/>    "exclude": [<br/>        "**/*.spec.ts",<br/>        "node_modules",<br/>        "build"<br/>    ]<br/>}</span></pre><p id="3ebb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我的<code class="fe mm mn mo la b">package.json</code>包含以下几行:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="72be" class="le lf it la b gy lg lh l li lj">"main": "./dist/server.js",<br/>  "module": "./dist/server.es.js",<br/>  "jsnext:main": "./dist/server.es.js",</span></pre><p id="4385" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">值得记住的是，关于rollup的一个恼人的事情是，选项和插件的配置<strong class="jz iu">以及它们的顺序</strong>经常需要根据您在项目中使用的模块而发生巨大的变化——通常您需要以一种非常特别的、反复试验的方式来解决这个问题。 有时，您在代码中使用的特定模块组合使得rollup无法使用——这是我决定在<code class="fe mm mn mo la b">create-react-app</code>中使用内置捆绑器，而不是用它创建react模块的原因之一。</p><p id="a519" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此外，近年来，rollup的许多插件已经从孤立的变为被纳入npm上的<code class="fe mm mn mo la b">@rollup</code>范围，旧的插件已被弃用，不再维护。一些老的教程没有考虑到这一点。</p><p id="6cc9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个项目中有很多关于rollup和插件互不兼容的问题之后，在我的下一个项目中，我将使用<code class="fe mm mn mo la b">parcel.js</code>,它似乎有更多的功能，而没有rollup所要求的不断和恼人的调整。</p><h1 id="e511" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">double package.json格式</h1><p id="e351" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated"><code class="fe mm mn mo la b">electron-react-boilerplate</code>使用“double package.json”格式，其中外层文件夹包含一个<code class="fe mm mn mo la b">package.json</code>，用于控制应用程序构建过程的配置，而<code class="fe mm mn mo la b">package.json</code>位于<code class="fe mm mn mo la b">app</code>文件夹内，用于控制与应用程序本身相关的设置。</p><h1 id="bcff" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">如何在电子版中使用我包装精美的React网站？</h1><p id="c21f" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">在一个<code class="fe mm mn mo la b">electron-react-boilerplate</code>项目中，控制完成的应用程序运行的主文件位于<code class="fe mm mn mo la b">app/main.dev.ts</code>。在这里你会看到一些启动新的<code class="fe mm mn mo la b">BrowserWindow</code>的代码，它会像这样开始:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="e263" class="le lf it la b gy lg lh l li lj">mainWindow = new BrowserWindow({<br/>    show: false,<br/>    width: 820,<br/>    height: 640,<br/>    webPreferences: ...</span></pre><p id="d299" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在它下面，你会发现一些代码，指定了应用程序启动时加载的主html文件。如果你像我一样，已经将预建的react应用程序复制到了<code class="fe mm mn mo la b">app/dist/frontend</code>文件夹中，那么你的路径应该是这样的(注意:<code class="fe mm mn mo la b">file://</code>前缀很重要！):</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="acf7" class="le lf it la b gy lg lh l li lj">mainWindow.loadURL(<br/>    `file://${__dirname}/dist/frontend/index.html`<br/>  );</span></pre><h1 id="56aa" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">向打包的react应用程序传递参数</h1><p id="a104" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">如果您正在使用预打包的react应用程序，您可能会发现很难传入在应用程序级别生成的参数，例如用于在前端和后端之间通信的http端口。一种简单的方法是将这些元素作为文件路径中使用的参数传入，例如:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4ce8" class="le lf it la b gy lg lh l li lj">mainWindow.loadURL(<br/>    `file://${__dirname}/dist/frontend/index.html?port=9009`<br/>);</span></pre><p id="efa4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，您的前端可以使用以下命令来查询这些信息:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="5317" class="le lf it la b gy lg lh l li lj">const currentPageUrl = new URL(window.location.href);<br/>const port = currentPageUrl.searchParams.get('port');</span></pre><h1 id="6547" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">将参数传递到express后端</h1><p id="2699" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">当试图将信息传递到您的express后端时，也会出现类似的问题。对我来说，最简单的方法是使用内置在express应用程序的每个实例中的<code class="fe mm mn mo la b">locals</code>参数。您可以按以下方式使用它们:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="8123" class="le lf it la b gy lg lh l li lj">// in app/main.dev.ts </span><span id="0154" class="le lf it la b gy ne lh l li lj">import myServer from 'myserver-component'</span><span id="f6b5" class="le lf it la b gy ne lh l li lj">const appPort = 9009;<br/>const resourceFolder = '/me/Desktop/all-my-files'</span><span id="830a" class="le lf it la b gy ne lh l li lj">const appServer = myServer.start(appPort, resourceFolder);</span></pre><p id="d09a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在上面的代码中，我将一个端口号和文件夹路径传递给express应用程序的实例。下面，我将这个文件夹分配给express后端中的<code class="fe mm mn mo la b">app.locals</code>,这样就可以从其他地方的express实例中检索到它:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="9dd0" class="le lf it la b gy lg lh l li lj">// in your express myserver-component component</span><span id="5284" class="le lf it la b gy ne lh l li lj">import app from './routers';</span><span id="906f" class="le lf it la b gy ne lh l li lj">const myServer = (port: string, resourceFolder: string) =&gt; {<br/>    const server = app.listen(port, err =&gt; {<br/>        if (err) throw err;<br/>        console.log(`listening on port ${port}`);<br/>    });<br/>    app.locals.resourceFolder = resourceFolder;<br/>    return server;<br/>};</span><span id="0ba8" class="le lf it la b gy ne lh l li lj">export default { start: myServer };</span></pre><p id="c18b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在您的快速路由器中，您可以使用<code class="fe mm mn mo la b">req.app.locals.resourceFolder</code>检索此信息:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="f857" class="le lf it la b gy lg lh l li lj">// in the ./routers file<br/>import express from 'express';<br/>import cors from 'cors';<br/>import path from 'path';<br/>import bodyParser from 'body-parser';</span><span id="c0f9" class="le lf it la b gy ne lh l li lj">import { getFiles } from './getFiles';</span><span id="d0ec" class="le lf it la b gy ne lh l li lj">const app = express();<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>app.use(bodyParser.json());<br/>app.use(cors());<br/>const router = express.Router();</span><span id="f33d" class="le lf it la b gy ne lh l li lj">router.route('/file').get((req: any, res: any, next: any) =&gt; {<br/>    console.log('Server received request for files from', req.app.locals.resourceFolder);<br/>    return getFiles(req.app.locals.resourceFolder, res);<br/>});</span></pre><p id="fae7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意:如果您在前端和服务器之间传输大量的JSON数据，值得注意的是<code class="fe mm mn mo la b">bodyParser</code>插件有一个默认的它可以处理的最大数据量。如果需要，在将bodyParser添加到服务器代码中时，可以使用下面的代码来增加这个值:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="9e33" class="le lf it la b gy lg lh l li lj">app.use(bodyParser.urlencoded({ limit: '20mb', extended: true }));<br/>app.use(bodyParser.json({ limit: '20mb' }));</span></pre><h1 id="8a0c" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">包括预构建的二进制文件</h1><p id="771a" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">我有一个预建版本的supercollider，我想把它包含在我的应用程序中。如果您使用的是<code class="fe mm mn mo la b">electron-react-boilerplate</code>，那么可以通过在package.json中添加一个<code class="fe mm mn mo la b">extraResources</code>键来实现。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="aaf5" class="le lf it la b gy lg lh l li lj">"extraResources": [<br/>      {<br/>        "from": "../resources",<br/>        "to": "myresources",<br/>        "filter": [<br/>          "**/*"<br/>        ]<br/>      }</span></pre><p id="e58b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">上面的代码会将所有文件从<code class="fe mm mn mo la b">../resources</code>文件夹复制到打包应用程序的<code class="fe mm mn mo la b">myresources</code>文件夹中。在打包的mac应用程序中，这可以在文件夹<code class="fe mm mn mo la b">example.app/Contents/Resources/myresources</code>中找到。</p><h1 id="a414" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">引用您预先构建的二进制文件</h1><p id="680a" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">您可以使用<code class="fe mm mn mo la b">process.resourcesPath</code>来获取打包的mac应用程序中Resources文件夹的路径。您可能希望在代码中设置一个变量，如下所示，该变量根据电子应用程序是处于开发模式还是打包生产模式，在本地文件路径和相对文件路径之间切换:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="8483" class="le lf it la b gy lg lh l li lj">const resourceFolder =<br/>    process.env.NODE_ENV === 'development'<br/>      ? '../resources'<br/>      : path.join(process.resourcesPath, 'myresources');</span></pre><h1 id="e623" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">path.join与path.resolve</h1><p id="ca3e" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">由于某些原因，<code class="fe mm mn mo la b">path.resolve</code>在封装电子app中不起作用- <code class="fe mm mn mo la b">path.join</code>是首选。</p><h1 id="073b" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">如果预构建的二进制文件打包成. asar文件，我还能运行它吗？</h1><p id="8cae" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">不，可能不会——至少对我来说没用。</p><p id="a1c9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了减小文件包的大小，electron可以将应用程序的内容打包成一个<code class="fe mm mn mo la b">.asar</code>存档文件，该文件的内容应该能够使用<code class="fe mm mn mo la b">example.asar/example-folder/my-file.txt</code>等路径进行访问。然而，这种方法似乎不适用于预编译的二进制文件</p><h1 id="2d0b" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">编译超级对撞机</h1><p id="5494" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">我想用超级对撞机来处理音频文件。然而，自从这个程序开始使用<code class="fe mm mn mo la b">Qt</code>来运行它的IDE，它就不可能将程序的<code class="fe mm mn mo la b">sclang</code>和<code class="fe mm mn mo la b">scsynth</code>部分分开来单独使用(这似乎只是MAC<a class="ae mp" href="https://doc.sccode.org/Classes/HelpBrowser.html" rel="noopener ugc nofollow" target="_blank">https://doc.sccode.org/Classes/HelpBrowser.html</a>上的一个问题)，这意味着文件可能会非常大(大约600MB)。如果你在一个电子应用程序中使用supercollider，我建议从源代码中构建它，将supercollider的大小减少到65MB左右。这是通过不包含用于显示帮助文件的QtWebEngine来实现的:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="aa2b" class="le lf it la b gy lg lh l li lj">"Since the Qt WebEngine dependency is hefty and difficult to install on some systems, it is possible for sclang to have been built without WebView support (using the CMake flag -DSC_USE_QTWEBENGINE=OFF at compile). If so, attempting to invoke this class will throw an error."</span><span id="c5f2" class="le lf it la b gy ne lh l li lj">- <a class="ae mp" href="https://doc.sccode.org/Classes/HelpBrowser.html" rel="noopener ugc nofollow" target="_blank">https://doc.sccode.org/Classes/HelpBrowser.html</a></span></pre><p id="04db" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当从源代码构建supercollider时，您需要遵循位于<a class="ae mp" href="https://github.com/supercollider/supercollider/blob/develop/README_MACOS.md" rel="noopener ugc nofollow" target="_blank">https://github . com/super collider/super collider/blob/develop/README _ MAC OS . MD</a>的说明。一旦您安装了所有需要的依赖项，您将需要使用带有以下标志的<code class="fe mm mn mo la b">cmake</code>，以确保它不会将QtWebEngine与构建捆绑在一起，并创建一个没有其他不必要组件(如调试器)的最小大小的应用程序。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="16b7" class="le lf it la b gy lg lh l li lj">cd SuperCollider<br/>mkdir -p build<br/>cd build<br/>cmake -G Xcode -DCMAKE_PREFIX_PATH=`brew --prefix qt5` -DSC_USE_QTWEBENGINE=OFF ..<br/>cmake --build . --target install --config MinSizeRel</span></pre><p id="9154" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这种方法在supercollider版本3.10.4上使用过，我不能保证它在其他版本上的有效性。</p><h1 id="0ebb" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">从节点运行supercollider</h1><p id="73f8" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">我在express.js应用程序的后端运行supercollider，方式如下:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="393e" class="le lf it la b gy lg lh l li lj">export const runSupercollider = (resourceFolder: string) =&gt; {<br/>    const command = path.join(resourceFolder, '/myresources/supercollider.app/Contents/MacOS/sclang');<br/>    const commandArguments = [path.join(resourceFolder, '/myresources/my-supercollider-file.scd'), 'parameter1', 'parameter2'];<br/>    return new Promise((resolve, reject) =&gt; {<br/>        execFile(command, commandArguments, (error, stdout, stderr) =&gt; {<br/>            if (stdout) {<br/>                console.log('stdout', stdout);<br/>                resolve(stdout);<br/>            } else if (stderr) {<br/>                console.log(stderr);<br/>                reject(stderr);<br/>            } else {<br/>                console.log(error);<br/>                reject(error);<br/>            }<br/>        });<br/>    });<br/>};</span></pre><p id="1418" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用<code class="fe mm mn mo la b">execFile()</code>，第一个参数将是要运行的文件的路径(在这种情况下是来自supercollider应用程序的<code class="fe mm mn mo la b">sclang</code>可执行文件)，第二个参数将是一个参数数组，第一个参数将是<code class="fe mm mn mo la b">sclang</code>要运行的<code class="fe mm mn mo la b">.scd</code>文件，数组的其余部分将是传递给<code class="fe mm mn mo la b">.scd</code>文件的任何参数。可以通过使用<code class="fe mm mn mo la b">thisProcess.argv</code>从<code class="fe mm mn mo la b">.scd</code>文件中引用这些参数，T7返回这些参数的数组。</p><h1 id="ff20" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">让超级对撞机退出</h1><p id="6719" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">当从命令行运行supercollider的<code class="fe mm mn mo la b">sclang</code>时，很难让supercollider在完成任务后退出。我发现做到这一点的唯一可靠方法是使用:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6e57" class="le lf it la b gy lg lh l li lj">thisProcess.platform.killAll("sclang");</span></pre><p id="a53f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此外，如果您从您的电子应用程序运行supercollider，您必须显式处理supercollider代码中的错误，以确保它在遇到错误时关闭，否则它可能会挂起，阻塞线程并阻止您的应用程序运行。您需要显式地让supercollider退出，因为supercollider在通过这个方法接收到错误时的默认行为:<code class="fe mm mn mo la b">Error(“ERROR: no output folder specified in file”).throw; </code>是仍然保持进程运行。相反，您应该使用<code class="fe mm mn mo la b">onError</code>方法在每次抛出错误时显式退出supercollider:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="18c7" class="le lf it la b gy lg lh l li lj">~printSeperator = "---OUTPUT---"<br/>~errorMessage = '';</span><span id="6a77" class="le lf it la b gy ne lh l li lj">~handleError = {<br/>  (~printSeperator ++ "error!  supercollider had to quit because" + ~errorMessage).postln;<br/>  ~server.remove;<br/>  thisProcess.platform.killAll("sclang");<br/>};</span><span id="7a03" class="le lf it la b gy ne lh l li lj">OnError.add(~handleError);</span><span id="650b" class="le lf it la b gy ne lh l li lj">~generateError = { arg message;<br/>  ~errorMessage = message;<br/>  Error(message).throw;<br/>};</span></pre><p id="b273" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，您可以在程序中的任何地方抛出一个带有自定义错误消息的错误，如下所示:<code class="fe mm mn mo la b">~generateError.value(“this file does not exist.”);</code></p><p id="397a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我将<code class="fe mm mn mo la b">"---OUTPUT---”</code>的<code class="fe mm mn mo la b">~printSeperator</code>字符串附加到错误消息中，这样我就可以从服务器上运行supercollider的<code class="fe mm mn mo la b">fs.exec</code>函数中捕获标准输出，并使用这个字符串将我插入的错误消息与程序输出的其余文本分开:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="b710" class="le lf it la b gy lg lh l li lj">const runSupercollider = () =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        execFile('./min-supercollider.app/Contents/MacOS/sclang', './example.scd', (error, stdout, stderr) =&gt; {<br/>            if (stdout) {<br/>                resolve(stdout);<br/>            } else if (stderr) {<br/>                reject(stderr);<br/>            } else {<br/>                reject(error);<br/>            }<br/>        });<br/>    });<br/>};</span><span id="7217" class="le lf it la b gy ne lh l li lj">runSupercollider().then((output: unknown) =&gt; {<br/>  const reducedOutput = (output as string).split('---OUTPUT---')[1];<br/>}).catch(err =&gt; console.log(err));</span></pre><h1 id="d03d" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">更改图标</h1><p id="9fdb" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">默认情况下，<code class="fe mm mn mo la b">electron-react-boilerplate</code>打包时会使用默认的React图标。您可以使用应用程序外部的<code class="fe mm mn mo la b">package.json</code>中的<code class="fe mm mn mo la b">build</code>键将它切换为您自己的图标。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4f32" class="le lf it la b gy lg lh l li lj">"build": {<br/>    "productName": "myApp",<br/>    "icon": "./icons/icon.icns",<br/>}</span></pre><p id="30fb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这将使用在您的应用程序的<code class="fe mm mn mo la b">icons</code>文件夹中找到的图标文件，并将其复制到您打包的应用程序的<code class="fe mm mn mo la b">Contents/Resources</code>文件夹中。你可以使用下面的应用程序创建一个在mac上使用的<code class="fe mm mn mo la b">.icns</code>文件:<a class="ae mp" href="https://github.com/onmyway133/IconGenerator" rel="noopener ugc nofollow" target="_blank">https://github.com/onmyway133/IconGenerator</a></p><h1 id="5a9e" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">保护您电子应用的安全</h1><p id="62f6" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">当您通过<code class="fe mm mn mo la b">yarn start-main-dev</code>在开发模式下运行您的电子应用程序时，您可能会在调试控制台中看到如下所示的错误:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="e2e7" class="le lf it la b gy lg lh l li lj">Electron Security Warning (Insecure Content-Security-Policy) This renderer process has either no Content Security Policy set or a policy with "unsafe-eval" enabled. This exposes users of this app to unnecessary security risks.</span><span id="c3bd" class="le lf it la b gy ne lh l li lj">For more information and help, consult https://electronjs.org/docs/tutorial/security. This warning will not show up once the app is packaged.</span></pre><p id="08d0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此错误表明您可能没有仔细阅读电子安全清单。为了保证你的应用程序的安全，我强烈建议这样做。可以在:<a class="ae mp" href="https://www.electronjs.org/docs/tutorial/security#checklist-security-recommendations" rel="noopener ugc nofollow" target="_blank">https://www . electron js . org/docs/tutorial/security # check list-security-recommendations</a>找到。</p><p id="4862" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过将以下代码添加到<code class="fe mm mn mo la b">createWindow</code>函数内的<code class="fe mm mn mo la b">app/main.dev.ts</code>文件中，可以消除这个特定的错误:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ab69" class="le lf it la b gy lg lh l li lj">if (process.env.NODE_ENV !== 'development') {<br/>    session.defaultSession.webRequest.onHeadersReceived((details, callback) =&gt; {<br/>      callback({<br/>        responseHeaders: {<br/>          ...details.responseHeaders,<br/>          'Content-Security-Policy': ["default-src 'none'"]<br/>        }<br/>      });<br/>    });<br/>  }</span></pre><p id="7770" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我建议添加<code class="fe mm mn mo la b">if (process.env.NODE_ENV !== 'development') {</code>条件，因为它将确保错误总是出现在开发模式中，并且有了它有助于防止您在生产或打包期间忘记添加它。</p><p id="e9af" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当禁用node.js集成(安全清单中的第2点)时，您必须添加一个类似的条件，因为运行开发模式需要此集成，但打包时不需要:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4885" class="le lf it la b gy lg lh l li lj">mainWindow = new BrowserWindow({<br/>    show: false,<br/>    width: 820,<br/>    height: 640,<br/>    webPreferences:<br/>      process.env.NODE_ENV === 'development' || process.env.E2E_BUILD === 'true'<br/>        ? {<br/>            enableRemoteModule: false,<br/>            nodeIntegration: true<br/>          }<br/>        : {<br/>            preload: path.join(__dirname, 'dist/renderer.prod.js'),<br/>            enableRemoteModule: false,<br/>            nodeIntegration: false<br/>          }<br/>  });<br/>  ...</span></pre><h1 id="768f" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">排除故障</h1><p id="8d2c" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">构建电子应用程序的一个缺点是，打包后很难调试。但是，在打包的应用程序中读取控制台日志的一种方法是通过终端打开它，这将导致一个额外的终端窗口打开来显示这些日志:</p><p id="a9b3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mm mn mo la b">open myApp.app/Contents/MacOS/myApp</code></p><p id="ad8e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">值得注意的是，电子应用程序运行两个进程:一个<code class="fe mm mn mo la b">main</code>进程和一个<code class="fe mm mn mo la b">renderer</code>进程(更多信息在这里:<a class="ae mp" href="https://www.electronjs.org/docs/tutorial/application-architecture" rel="noopener ugc nofollow" target="_blank">https://www . electron js . org/docs/tutorial/application-architecture)，</a>终端将只显示来自主进程的日志，这意味着来自前端React页面的日志将不会显示，因为它们是由在自己的渲染器进程中运行网页的<code class="fe mm mn mo la b">BrowserWindow</code>实例处理的。</p><h1 id="2362" class="lk lf it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">凯特琳娜</h1><p id="d4d6" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">让你的应用程序在Catalina上运行可能比其他版本的MacOS更尴尬，因为这个操作系统对没有经过苹果公证程序的程序施加了更多限制。</p><p id="947b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">需要注意的一点是。由于本文中概述的问题，用电子构建器构建的电子应用程序的zip文件在catalina上无法工作:<a class="ae mp" href="https://medium.com/cacher-app/getting-your-electron-app-working-on-macos-catalina-10-15-63e53f397da2" rel="noopener">https://medium . com/cacher-app/getting-your-electron-app-working-on-MAC OS-catalina-10-15-63 e 53 f 397 da 2</a>。在<code class="fe mm mn mo la b">electron-react-boilerplate</code>中电子建造者在幕后使用，所以任何。打包过程中生成的zip文件在Catalina上将无法使用。相反，使用生成的分发您的应用程序。dmg文件而不是. zip文件。</p><p id="26af" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你还必须添加一些额外的文件，以便你的应用程序符合卡特琳娜安全标准(以下信息部分改编自<a class="ae mp" href="https://kilianvalkhof.com/2019/electron/notarizing-your-electron-application/" rel="noopener ugc nofollow" target="_blank">https://kilianvalkhof . com/2019/electron/notarization-your-electron-application/</a>)。与你将读到的一些建议相反，如果你遵循下面的说明，你的应用程序没有必要在Catalina上运行。</p><ol class=""><li id="6eba" class="mq mr it jz b ka kb ke kf ki ms km mt kq mu ku nf mw mx my bi translated">创建一个<code class="fe mm mn mo la b">entitlements.mac.plist</code>文件。我把我的放在我的app文件夹的一个<code class="fe mm mn mo la b">entitlements</code>子文件夹里。该文件应包含以下信息，这些信息将明确显示您的应用程序拥有哪些权限:</li></ol><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="f4b0" class="le lf it la b gy lg lh l li lj">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;<br/>&lt;plist version="1.0"&gt;<br/>  &lt;dict&gt;<br/>    &lt;key&gt;com.apple.security.cs.allow-jit&lt;/key&gt;<br/>    &lt;true/&gt;<br/>    &lt;key&gt;com.apple.security.cs.allow-unsigned-executable-memory&lt;/key&gt;<br/>    &lt;true/&gt;<br/>    &lt;key&gt;com.apple.security.cs.debugger&lt;/key&gt;<br/>    &lt;true/&gt;<br/>  &lt;/dict&gt;<br/>&lt;/plist&gt;</span></pre><p id="fee9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">2.更改app文件夹中package.json中的<code class="fe mm mn mo la b">build</code>键，使其包含以下信息。Catalina要求应用程序具有“强化的运行时”，此选项将确保您的应用程序将使用此设置构建。<code class="fe mm mn mo la b">entitlements</code>和<code class="fe mm mn mo la b">entitlementsInherit</code>键应该指向上面创建的授权文件的位置。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="b234" class="le lf it la b gy lg lh l li lj">"build": {<br/>    ...<br/>    "mac": {<br/>      "hardenedRuntime": true,<br/>      "gatekeeperAssess": false,<br/>      "entitlements": "entitlements/entitlements.mac.plist",<br/>      "entitlementsInherit": "entitlements/entitlements.mac.plist"<br/>    },<br/>    "dmg": {<br/>      ...<br/>      "sign": false<br/>    },</span></pre><p id="548a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">好吧，我希望这有助于回答一些电子问题——祝你好运！</p><ul class=""><li id="0a42" class="mq mr it jz b ka kb ke kf ki ms km mt kq mu ku mv mw mx my bi translated">使用<a class="ae mp" href="https://markdown-to-medium.surge.sh/" rel="noopener ugc nofollow" target="_blank">https://markdown-to-medium.surge.sh/</a>将这篇文章从markdown转换为medium</li></ul></div></div>    
</body>
</html>