<html>
<head>
<title>20 Lines of Code Simple Implementation of Handwritten Async Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">20行代码手写异步Await的简单实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/20-lines-of-code-simple-implementation-of-handwritten-async-await-d1400cd74fb1?source=collection_archive---------21-----------------------#2022-11-01">https://levelup.gitconnected.com/20-lines-of-code-simple-implementation-of-handwritten-async-await-d1400cd74fb1?source=collection_archive---------21-----------------------#2022-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="63b3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果让你手写异步函数的实现，你会觉得复杂吗？这篇文章用20行带你了解它的核心。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/58a268164b105773e550ead59962fd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-zhupQng2LeF9i-a1uhETQ.jpeg"/></div></div></figure><p id="31e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">人们常说异步函数是生成器函数的语法糖，那么它是什么样的糖呢？让我们一层一层地剥开它的糖衣。<br/>有同学想说，既然用了生成器函数，为什么还要实现异步？<br/>这篇文章的目的是让大家了解async和generator如何一起管理异步。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="16f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这个简单的例子，如果我们把它表示成一个母函数，会是什么样子呢？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="1fc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们知道生成器功能不会自动执行。每次调用它的<code class="fe lp lq lr ls b">next</code>方法，都会停留在下一个yield位置。</p><p id="52c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">利用这个特性，我们只要写一个自动执行的函数，就可以让这个生成器函数完全实现异步函数的功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="78cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以总体思路已经确定，</p><p id="ab8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lp lq lr ls b">asyncToGenerator </code>接受一个<code class="fe lp lq lr ls b">generator </code>函数并返回一个承诺，</p><p id="81af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关键在于<code class="fe lp lq lr ls b">asynchronous </code>过程除以良品率应该如何自动执行。</p><p id="f5e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">如果手动执行</strong></p><p id="3ec1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在写这个函数之前，我们先模拟手动调用生成器函数来一步步完成这个过程，有助于后面的思考。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="0298" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们首先调用<code class="fe lp lq lr ls b">testG </code>来生成一个迭代器</p><pre class="kg kh ki kj gt lt ls lu lv aw lw bi"><span id="5759" class="lx ly iq ls b gy lz ma l mb mc"><strong class="ls ir">var</strong> gen = testG()</span></pre><p id="54dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后开始执行第一个<code class="fe lp lq lr ls b">next</code></p><pre class="kg kh ki kj gt lt ls lu lv aw lw bi"><span id="22ea" class="lx ly iq ls b gy lz ma l mb mc"><em class="md">// </em>The first time call next stays at the position of the first yield<br/><em class="md">// </em>The returned promise contains the data required by data<br/><strong class="ls ir">var</strong> dataPromise = gen.next()</span></pre><p id="4b80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里返回一个承诺，是<code class="fe lp lq lr ls b">getData()</code>第一次返回的承诺。请注意:</p><pre class="kg kh ki kj gt lt ls lu lv aw lw bi"><span id="ca2e" class="lx ly iq ls b gy lz ma l mb mc"><strong class="ls ir">const</strong> data = <strong class="ls ir">yield</strong> <strong class="ls ir">getData</strong>()</span></pre><p id="46ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这段代码需要分成两部分:第一次调用next，但实际上只是停留在yield getData()，<br/>数据的值没有确定。<br/>那么数据的价值什么时候才能确定？<br/>下一次调用next时，传递的参数将被用作前一次yield之前接受的值<br/>也就是说，当我们再次调用gen.next时，data的值将被确定为“该参数将被赋给数据变量”</p><pre class="kg kh ki kj gt lt ls lu lv aw lw bi"><span id="5722" class="lx ly iq ls b gy lz ma l mb mc">gen.next('This parameter will be assigned to the data variable')</span><span id="90f8" class="lx ly iq ls b gy me ma l mb mc">// Then the data here has value<br/>const data = yield getData()</span><span id="cd2f" class="lx ly iq ls b gy me ma l mb mc">console.log('data: ', data);</span><span id="f080" class="lx ly iq ls b gy me ma l mb mc">// Then move on to the next yield<br/>const data2 = yield getData()</span></pre><p id="fb8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后向下执行，直到遇到下一个产量，并继续这个过程…</p><p id="438b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是生成器函数设计的一个难点，但是为了达到我们的目的，还是要学的~</p><p id="0b20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这个特性，如果我们这样控制yield过程，是否可以实现异步序列化？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="c335" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种看起来像回调地狱的调用允许我们的生成器函数以一种清晰的方式安排异步。</p><p id="3f90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑到这一点，实现这个高阶函数就变得容易了。</p><p id="601d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们先从整体上看一下结构，以获得一个印象，然后我们会在评论中逐行解释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="759c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不多不少，22行。</p><p id="34a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来逐行解释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><h2 id="15df" class="lx ly iq bd mf mg mh dn mi mj mk dp ml la mm mn mo le mp mq mr li ms mt mu mv bi translated">总结</h2><p id="ba55" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">本文以最简单的方式实现了asyncToGenerator函数，这是babel编译异步函数的核心。当然，在巴别塔中，生成器函数也被编译成非常原始的形式。在本文中，我们直接用生成器来代替它。这也是实现承诺序列化的一个很好的模式。如果你对我的文章感兴趣，可以关注我的<a class="ae nb" href="https://hyhwell.medium.com/" rel="noopener">媒体</a>或<a class="ae nb" href="https://twitter.com/Maxwell_hyh" rel="noopener ugc nofollow" target="_blank">推特</a>。</p></div></div>    
</body>
</html>