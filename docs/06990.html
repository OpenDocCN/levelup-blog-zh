<html>
<head>
<title>How to Fix the Bug Without Breaking the Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在不破坏应用程序的情况下修复Bug</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a?source=collection_archive---------14-----------------------#2021-01-17">https://levelup.gitconnected.com/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a?source=collection_archive---------14-----------------------#2021-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更改源代码时更自信的步骤。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/157d569fd080588bf2f31e46fcd38c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OODr7GwIcJMYLNwL"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">塞巴斯蒂安·赫尔曼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复一个bug并在十个不同的地方破坏大型应用程序是相当容易的。每个人都明白，由于软件的高度复杂性，不可能避免这种情况。然而，您可以通过使用我在日常开发活动中通常遵循的步骤来最小化回归问题的机会。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="da7c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在修复Bug之前</h1><p id="3376" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我看来，软件开发人员在“前”阶段投入的时间越多，他或她就越有经验。通常，初级开发人员在阅读完错误描述后就开始编码，而高级开发人员则遵循以下步骤:</p><h2 id="eb45" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">传出依赖性分析</h2><p id="5a86" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">几乎所有的对象，除了简单的或低级的对象，都有外发的依赖关系——通过构造函数、属性、方法或静态类注入的其他对象。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="14c5" class="mz md it nm b gy nq nr l ns nt">public class OrderBuilder<br/>{<br/>    public OrderBuilder(IPriceCalculator priceCalculator)<br/>    {<br/>       ...<br/>    }<br/>}</span></pre><p id="8154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nu"> IPriceCalculator接口是OrderBuilder类的传出依赖项。</em></p><p id="b72d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在对任何类进行更改之前，您应该检查它的输出依赖项。我所说的“检查”是指至少理解每个输出依赖项的接口，而不涉及实现细节。</p><p id="e3e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传出依赖关系会影响包含它们的类的行为。因此，检查输出依赖对于清楚地理解该类的行为是很重要的。仅仅通过分析类本身，而忽略它的外部依赖关系，你不会清楚地理解类的行为。</p><p id="e8db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">显式依赖与隐式依赖</strong></p><p id="dc60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传出依赖关系可以是显式的，也可以是隐式的。显式依赖项被注入到类构造函数中，因此只需查看构造函数定义就可以在几秒钟内找到它们。然而，一个类可以有隐式的输出依赖——静态类。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="97d3" class="mz md it nm b gy nq nr l ns nt">public class OrderBuilder<br/>{<br/>    public OrderBuilder()<br/>    { }</span><span id="dea9" class="mz md it nm b gy nv nr l ns nt">    public void BuildOrder()<br/>    {<br/>        // 100 lines of some logic, then: </span><span id="2dd1" class="mz md it nm b gy nv nr l ns nt">        decimal price = <strong class="nm iu">PriceCalculator</strong>.CalculatePrice();<br/>        <br/>        //next 100 lines of code<br/>    }<br/>}</span></pre><p id="b41d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nu"> PriceCalculator是OrderBuilder类的输出隐式依赖项。</em></p><p id="91d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传出隐式依赖的问题是，您无法快速找到它们，因为它们不存在于类构造函数中。隐式依赖可以出现在类的任何一行，这使得当类很大时很难找到它们。</p><p id="d85b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该找到并检查所有隐式依赖，因为它们像显式依赖一样影响类的行为。这个练习可能需要你仔细检查这个类的所有行，或者运行一个静态代码分析工具。要检查的度量被称为<strong class="lb iu">输出依赖关系</strong>或<strong class="lb iu">输出依赖关系</strong>，这取决于所使用的工具。</p><h2 id="3696" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">探索可用的单元测试</h2><p id="6f66" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">单元测试的目的不仅仅是检查功能是否按预期运行。单元测试是作为文档的，所以探索它们将帮助你更好地理解代码是如何工作的。</p><p id="6e15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果单元测试有这样的自描述性命名:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0877" class="mz md it nm b gy nq nr l ns nt">UserRepository_NotExistingUserId_UserNotFoundExceptionThrown</span><span id="9478" class="mz md it nm b gy nv nr l ns nt">OR</span><span id="8c34" class="mz md it nm b gy nv nr l ns nt">OrderWithThePastDateShouldBeConsideredInvalid</span></pre><p id="5558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅浏览它们的名字就足够了，而不必深入单元测试实现的细节。</p><p id="24ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，您应该首先检查单元测试，然后像TDD方法一样继续检查代码本身。</p><h2 id="3d0e" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">传入依赖项分析</h2><p id="80f5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">传入依赖项的数量告诉开发人员该类被应用程序中的其他类使用了多少。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/8f36cd77856c045c2049dddd97bef3a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05WsvB8YeRfRJcVeTnfAKw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">OrderBuilder类有3个传入依赖项</figcaption></figure><p id="fe8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传入依赖性分析有助于您确定影响范围。换句话说，即将到来的变化可能会破坏系统中的多少其他功能。</p><p id="89c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个IDE都有类似于<em class="nu">“Find All References”</em>的命令，可以帮助快速找到应用程序中某个类或方法的使用位置。</p><p id="6c58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦收集了引入依赖项的列表，尝试找出它们与什么功能相关。例如，从上图中，我们可以看到，更改OrderBuilder类会影响与用户报告生成、折扣计算和电子邮件相关的功能。</p><p id="d25d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您知道哪些功能面临风险，请执行以下操作:</p><ul class=""><li id="68be" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">确保项目中有适当的集成测试。</li><li id="80df" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">如果不存在集成测试，考虑编写集成测试。</li><li id="b8f3" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">与QA团队共享回归列表，这样他们就知道在部署修复后要检查什么(将列表放在bug的吉拉标签中)。</li></ul><p id="bd5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些行动将帮助团队快速找到可能的回归问题，并且不让它们进入生产。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d4d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">修复Bug </strong></h1><p id="84a1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在前一阶段花费的时间越多，在当前阶段投入的精力就越少。</p><h2 id="2206" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">编写单元测试</h2><p id="70fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">即使项目的业务逻辑有100%的单元测试覆盖率，仍然会有错误。这是可以的，因为编写单元测试是一个持续的过程。总有改进的余地。</p><p id="23e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名软件开发人员，你应该<strong class="lb iu">在每次发现新的bug时修改单元测试</strong>。也许在测试用例实现中有一个问题或者测试用例丢失了。或者甚至对于功能的某些部分根本没有单元测试。</p><p id="7957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试找出为什么所有的单元测试都是绿色的，即使业务逻辑中有一个bug。那么遗漏的单元测试就应该写出来，这样同样的bug就不会再出现了。</p><p id="969c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">特性测试</strong></p><p id="f530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用旧的遗留系统时，并不总是能够为需要改变的代码编写单元测试。只有当代码的行为在需求方面是清晰的，软件开发人员才能编写单元测试。</p><p id="0a8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗留系统可能包含神秘的业务逻辑:没有人知道它为什么以这种方式编写。这可能是因为逻辑是很多年前由另一个团队编写的，文档丢失了，没有一个涉众足够了解系统，等等。这使得不可能编写单元测试，因为开发人员需要知道系统的正确行为。但是没有需求，只知道实际行为，不一定正确。</p><p id="7204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，软件开发人员可以编写特性测试来代替单元测试。表征测试类似于单元测试，但是它们的目的是捕获代码的实际行为，而不是预期的行为。</p><p id="0657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在《与遗留代码有效工作》一书中描述了特性测试。我强烈推荐您阅读它，即使您根本没有在处理遗留系统。</p><h2 id="6178" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">处理</h2><p id="056a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你已经仔细完成了上面的所有步骤，你就已经非常清楚如何修复这个bug了。我能给出的唯一建议是关于大的改变。如果您有大量代码需要修改，可以考虑将工作分成更小的逻辑块。在应用每个块之后，运行您的单元测试。仅当单元测试为绿色时，才应用新的更改块。</p><p id="2755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种渐进的方法可以让你在出错时后退一小步，而不是从头开始。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ecb6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">修复错误后</h1><p id="2034" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦改变完成，你应该确保至少快乐的道路不会被打破。您肯定不能也不应该用边缘案例重新测试所有场景，但是至少要确保:</p><ul class=""><li id="c507" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">在本地运行单元、集成和其他测试，以确保它们仍然是绿色的。</li><li id="7ab2" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">如果项目中没有集成测试，则对与您的变更相关的所有功能执行手动快乐路径冒烟测试。</li></ul><p id="f5a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">冒烟测试后，创建一个拉动请求，并尝试找到最佳人选来审查您的更改。</p><p id="ddad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦变更被批准，您就可以将修复合并到主分支中，并将票证移动到QA。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b235" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b46f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管做了我描述的所有事情，我仍然有回归问题。但我知道他们的数量没有想象中的多。我知道在合并我的改变后，我可以平静地睡觉，因为我已经尽力了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bce6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更多关于可维护性的故事</h1><div class="ol om gp gr on oo"><a href="https://medium.com/codex/technical-debt-management-best-practices-for-software-engineers-871a315ac812" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">软件工程师的技术债务管理最佳实践</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">技术债务率=应该返工的代码行数/现有源代码行数* 100%</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a href="https://medium.com/codex/when-code-quality-metrics-can-be-of-real-value-to-software-engineers-7fc2de96afc4" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">充分利用代码质量度量</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">在软件工程中充分利用圈复杂度、可维护性指数、单元测试覆盖率和其他度量</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc ks oo"/></div></div></a></div></div></div>    
</body>
</html>