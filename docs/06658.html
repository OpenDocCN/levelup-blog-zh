<html>
<head>
<title>Connascence— Part III: Connascence applied</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关联—第三部分:应用的关联</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/connascence-part-iii-connascence-applied-c1cc85ba6a5a?source=collection_archive---------4-----------------------#2020-12-17">https://levelup.gitconnected.com/connascence-part-iii-connascence-applied-c1cc85ba6a5a?source=collection_archive---------4-----------------------#2020-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="94c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated"><span class="l kp kq kr bm ks kt ku kv kw di">在</span>前两部分，我先<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/connascence-a-methodical-way-to-detect-code-smell-part-i-5450c104fea5">定义了同生的概念(第一部分)</a>。然后我详细阐述了不同类型的归属(第二部分)。在第二部分，我举了一些例子。在这一部分中，我将重构我在第二部分中提到的所有示例，并将其从较高的从属关系移到较低的从属关系，从而改进代码。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="22bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们开始之前，让我们看一下不同伴随类型的表格:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/3751c4a2a65a60226dc833167bf36c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*hg7Y2fk7i5fxLbuDPPfrqQ.png"/></div></figure><p id="e15f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上图显示了从上到下排序的所有从属关系。最差的在上面，好的在下面。箭头显示了我们应该重构的方向。在接下来的内容中，我将向您展示我在第二部分中已经讨论过的代码片段，并首先确定它是哪种从属关系。然后我将重构到一个较低的从属关系，并解释为什么它更好。我们开始吧。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/3ab04d269dbf1ba45930f55ebda34d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*2ygIFvWAoqUvnTC6jnrB6Q.png"/></div></figure><p id="1458" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码片段属于含义的类型<em class="lo">，因为这里有问题的部分是它背后的含义:<code class="fe lp lq lr ls b">123.45</code>代表什么？我们知道是钱。但是钱不等于钱。是美元吗？是欧元吗？是袁吗？我们不知道。</em></p><p id="b893" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决这个问题的方法很简单。通过创建类型<code class="fe lp lq lr ls b">Money</code>,我们传入值和货币。这样，我们就把一个意义的关联变成了一个类型为的<em class="lo">关联:</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/6c052b839afec7db5a3eeb01dc38f661.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*rjQmbG-iGJyQVjH_rKlNnw.png"/></div></figure><p id="da59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在这个意思应该没有任何问题了。看着它，与之前的代码相比，您会注意到它更具声明性。如果我们查看我们的从属类型列表，您会看到我们将代码类型从有意义的从属移动到了类型的<em class="lo">从属——我们降低了从属类型，从而使它在客观上更好。这只是一个简单的例子，说明了connascence如何指导我们写出更好的代码。</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/0033499cda6354d2189de4f42e744be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*sriBvfcYTz--VOLDpBzUsA.png"/></div></figure><p id="7464" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能还记得上面的代码:一个有多个参数的函数。如果被调用，参数必须按照与参数列表相同的顺序传递。我们将其确定为位置的<em class="lo">伴随。</em></p><p id="c50a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">位置的伴随关系的问题是，参数的顺序对于代码正确运行很重要。一旦切换了传入的参数，该函数将返回不正确的结果。这些类型的<em class="lo">耦合</em>可以通过创建一个新的对象类型并将该对象类型作为参数传递给函数来解决:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/06b603dafbbd6234347b0519e3f656e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*nVgQB1n1aWcmcMEX6MGpEQ.png"/></div></figure><p id="772a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在的好处是，参数中传递的顺序，即<code class="fe lp lq lr ls b">firstName</code>、<code class="fe lp lq lr ls b">lastName</code>、<code class="fe lp lq lr ls b">address</code>，现在已经不重要了。现在，您可以更改顺序，函数仍然会返回正确的结果。通过创建一个新的对象类型，我们对代码进行了解耦，从而使代码变得更好。</p><p id="1568" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是从高伴随类型，即位置伴随开始，并移动到低伴随类型，即类型伴随的另一个例子。我们降低了从属类型，从而改进了代码。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/617646f61ee330200b9a7d724d08b8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*qNk37B8EazXJFQ3Q0LV3tA.png"/></div></figure><p id="8d99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看上一篇文章中的HTML/CSS代码。我们将这种从属类型确定为位置的<em class="lo">从属。在这里停下来，问问自己如何改进这段代码，最后会得到什么样的结果？</em></p><p id="6cf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的问题很明显，如果你改变HTML代码的结构，比如在<code class="fe lp lq lr ls b">section</code>中添加另一个元素作为第一个孩子，那么<code class="fe lp lq lr ls b">section</code>中第一个孩子的文本颜色也会改变。</p><p id="7e00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有不同的方法来减轻这一点。一种是用边界元法。你基本上对元素应用一个类，这里是<code class="fe lp lq lr ls b">header</code>，你想要样式，这里对文本应用颜色<code class="fe lp lq lr ls b">red</code>:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/7c0696f503716b689cc01a7f586874b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*LUkjgROH7CXfckqrmTSm5A.png"/></div></figure><p id="1253" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在HTML结构更加健壮了，因为改变HTML结构不会影响<code class="fe lp lq lr ls b">header</code>的文本颜色样式。我们将位置关联代码更改为<em class="lo">名称关联</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/6dada1ecb64547a6b9fc38b89cba07fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*yVA2OvjDHjLhL3YFNlvdiw.png"/></div></div></figure><p id="9a72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看下一个例子。这是一个测试，包括两节课。两个类都使用值<code class="fe lp lq lr ls b">50</code>。测试依赖于类<code class="fe lp lq lr ls b">Checkout</code>，分别是它的实例，返回数字<code class="fe lp lq lr ls b">50</code>。正如你可能已经猜到的，这是<em class="lo">价值的一致性</em>。</p><p id="d45d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何改进这段代码的第一步是减少局部性:我们改变函数<code class="fe lp lq lr ls b">scan</code>以便它接受值作为第二个参数:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi md"><img src="../Images/81142a93093f2af3d2a0e0940f15c75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*99ZqyZ1zj2-MnVgi8pGf4A.png"/></div></div></figure><p id="8fa2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会注意到我们仍然有价值的一致性。但是代码仍然比以前更好，因为<em class="lo">位置</em>已经从本地远变为本地近，也就是说，值现在不是分布到两个不同的类，而是仅位于一个类中。</p><p id="d0d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们还没有到那一步。我们仍然有价值的一致性，我们可以创建一个新的变量<code class="fe lp lq lr ls b">priceOfA</code>并给它分配一个随机数。现在它独立于值，因此我们将代码更改为名称的从属关系，这是所有从属关系中最好的一个:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi me"><img src="../Images/2819fd126e8439724e26bbf315221575.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*qQhlKFXWb0tBu6bbf1Kb1Q.png"/></div></figure><h2 id="464e" class="mf mg it bd mh mi mj dn mk ml mm dp mn kb mo mp mq kf mr ms mt kj mu mv mw mx bi translated">结论</h2><p id="04ab" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">好吧，酷。现在我们知道什么是共生了。怎么回事？</p><p id="4df8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对我来说，connascence是一个很酷的新工具:</p><ul class=""><li id="5ae8" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated">Connascence给了我一种评估和区分代码评审优先级的方法。现在，我不做最容易但风险最大的修复，即与最高类型的相关性。</li><li id="d14a" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">它给了我一个与同事交流的新词汇。代码评审不是基于个人喜好，而是基于客观的度量标准。</li><li id="c5ac" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">Connascence为初级开发人员提供了一个框架、指南针或指南来编写良好、干净和可维护的代码。</li><li id="425a" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">这也有助于知道什么时候重构就够了。因为一旦我碰到了名的联结，我知道我碰到了最低的，因而也是最好的联结。这意味着进一步重构它没有意义，因为它已经处于最佳状态。</li><li id="ae75" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">一致性不限于某种技术、编程语言或前端或后端，而是可以应用于整个堆栈。</li></ul></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="3784" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你以前听说过connascence吗？你已经试过了吗？你的经历是什么？在这里分享一下你的经验。我渴望知道这件事。</p></div></div>    
</body>
</html>