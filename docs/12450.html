<html>
<head>
<title>Angular — intercept your http errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular拦截您的http错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-intercept-your-http-errors-10d9c95133ec?source=collection_archive---------2-----------------------#2022-06-12">https://levelup.gitconnected.com/angular-intercept-your-http-errors-10d9c95133ec?source=collection_archive---------2-----------------------#2022-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">干净简洁的http错误管理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5065111584601e6dc5f1d7d1272a1501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_5a_geOPVgR1TMYZhSlyw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Http拦截器基本流程</figcaption></figure><p id="22b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于在任何应用程序中都会不时出现错误，因此应该实现一个合适的错误处理系统。在本文中，我们将关注不同类型的http错误以及如何相应地处理它们。</p><h2 id="a5f8" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">Http错误类型</h2><p id="2055" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">http请求失败的原因有很多。糟糕的网络连接、不正确的url或请求的服务器当前不可用，等等。一般来说，错误可以分为两种类型:服务器端和客户端错误。</p><p id="497f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种类型需要不同的处理，因为我们，客户，对后者负责，我们可以用不同于前者的方式处理它们。对于服务器端错误，我们只能传递从服务器收到的相应错误消息或尝试重试，因为服务器可能只是暂时不可用。<br/>然而，在客户端，我们可能使用了错误的URL或缺少参数，我们需要修复它。</p><p id="6083" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这两种情况下，为用户提供一致的错误消息同样重要，为此全局处理也是合适的。</p><h2 id="fdeb" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">Http拦截器</h2><p id="3bc9" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">通过所谓的<code class="fe ms mt mu mv b">HttpInterceptor</code>，Angular为我们提供了一种转换http请求和响应的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/a7ac9044c7ff7b6e4ceacdae0bb5b222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7Rf4IPaulwcSCd1MsCmwg.png"/></div></div></figure><p id="2c61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过该接口，我们可以实现<code class="fe ms mt mu mv b">intercept</code>方法，该方法会在通过我们的应用程序发出的每个HTTP请求上自动调用。这使我们能够用拦截器实现中央错误处理。</p><p id="b624" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">拦截器有以下参数:</p><ul class=""><li id="f96f" class="mx my it la b lb lc le lf lh mz ll na lp nb lt nc nd ne nf bi translated"><em class="ng"> req </em> —要处理的传出请求对象。</li><li id="b505" class="mx my it la b lb nh le ni lh nj ll nk lp nl lt nc nd ne nf bi translated"><em class="ng">下一个</em> —链中的下一个拦截器，如果链中没有拦截器，则为后端。</li><li id="bf8c" class="mx my it la b lb nh le ni lh nj ll nk lp nl lt nc nd ne nf bi translated">返回:事件流的可观察值。</li></ul><p id="9a9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><h2 id="1e49" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">Http错误处理程序</h2><p id="e02d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们可以使用Angular <a class="ae nm" href="https://angular.io/cli" rel="noopener ugc nofollow" target="_blank"> CLI </a>和以下命令创建一个新的拦截器:</p><p id="fa13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">ng generate interceptor http-error</code></p><p id="8823" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我通常将拦截器放在一个包含全局功能的核心模块中，并在应用程序启动时立即加载。拦截器必须在模块中注册。我们可以通过将它添加到providers数组来实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1ced" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">属性<code class="fe ms mt mu mv b">multi</code>必须设置为<code class="fe ms mt mu mv b">true</code>，因为可以有多个拦截器使用<code class="fe ms mt mu mv b">HTTP_INTERCEPTORS</code>注入令牌。您也可以在下面的StackBlitz示例中找到所有这些内容。</p><p id="69dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们实现<code class="fe ms mt mu mv b">intercept</code>方法，将RxJS <code class="fe ms mt mu mv b">catchError</code>操作符添加到请求中，用于我们的错误处理逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ded5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe ms mt mu mv b">catchError</code>中，我们检查错误是否是<code class="fe ms mt mu mv b">ErrorEvent</code>的一个实例，在这种情况下，类型是未知的，我们的代码可能有问题。否则，我们可以评估来自服务器的响应并相应地处理它。</p><p id="b65f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，无论错误类型如何，向用户显示有意义的消息是很重要的。为此，我们可以为所有错误消息定义一个具有一致结构的接口，例如如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="840b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有一个可选的<strong class="la iu">标题</strong>，我们可以用它来显示祝酒辞。然后是<strong class="la iu">错误消息</strong>本身、不同的<strong class="la iu">严重级别</strong>和<strong class="la iu"> http响应代码</strong>。现在让我们将接口添加到我们的拦截器中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="48ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们转换这两种类型的错误，然后重新抛出错误，以便它可以由最初触发请求的相应服务来处理。</p><p id="4795" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们可以为上面提到的特定响应代码集成重试逻辑。使用RxJS可以非常简单地实现http请求的重试。这里有两个操作符:<code class="fe ms mt mu mv b">retry</code>和<code class="fe ms mt mu mv b">retryWhen</code>。<br/>它们中的任何一个都可以用来重试一个可观察的序列给定的次数。在这种情况下，<code class="fe ms mt mu mv b">retryWhen</code>操作符更合适，因为我们可以处理任意条件，而不仅仅是重试次数。</p><p id="5c0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我们的重试策略，我们可以创建一个自定义操作符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">可定制的增加持续时间的重试(来源:<a class="ae nm" href="https://www.learnrxjs.io/learn-rxjs/operators/error_handling/retrywhen" rel="noopener ugc nofollow" target="_blank"> learnrxjs </a></figcaption></figure><p id="29d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用三个参数来配置我们的操作符。首先，根据尝试次数，其次，我们可以使用<code class="fe ms mt mu mv b">scalingDuration</code>来创建尝试之间的延迟，第三，可以排除任何http代码，例如404，因为重试“404-未找到”毫无意义。</p><p id="17a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的操作符现在可以简单地与<code class="fe ms mt mu mv b">retryWhen</code>一起插入到我们的拦截器的管道中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fac6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查看StackBlitz上的完整示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np no l"/></div></figure><h2 id="d54f" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">下一步是什么</h2><p id="6529" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">以下是进一步改进的一些想法:</p><ul class=""><li id="351e" class="mx my it la b lb lc le lf lh mz ll na lp nb lt nc nd ne nf bi translated">为您的错误消息添加国际化(i18n)以支持多种语言，例如通过使用<a class="ae nm" href="http://www.ngx-translate.com/" rel="noopener ugc nofollow" target="_blank"> ngx-translate </a></li><li id="2f81" class="mx my it la b lb nh le ni lh nj ll nk lp nl lt nc nd ne nf bi translated">通过向用户显示是否要重试请求的提示来改进重试逻辑</li></ul></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="8c5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<a class="ae nm" href="https://saackef.com/" rel="noopener ugc nofollow" target="_blank">媒体</a>或<a class="ae nm" href="https://twitter.com/sw3eks" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，阅读更多关于Angular的内容！</p></div></div>    
</body>
</html>