<html>
<head>
<title>Why asynchronous is a trend?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么异步是一种趋势？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-asynchronous-is-a-trend-c9892667e245?source=collection_archive---------2-----------------------#2022-07-07">https://levelup.gitconnected.com/why-asynchronous-is-a-trend-c9892667e245?source=collection_archive---------2-----------------------#2022-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7710" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去的十年中，异步代码成为了一种非常流行的方法，但是您是否想过为什么我们要从同步代码转向异步代码呢？让我们更深入地探讨这个主题，并找出我们为什么进行这种转变，以及异步代码的利弊。</p><h2 id="16ca" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">服务器如何在同步模式下工作</h2><p id="1076" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">为了理解为什么异步代码变得如此流行，我们需要理解同步服务器是如何工作的。让我们从基础开始，我们有一个客户端(PC)和一个服务器，客户端通过互联网与服务器通信。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/623a07bb25dcf47d8085cb88ab1e3b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4p1W7csk3sR3HVflsJ0tg.png"/></div></div></figure><p id="21db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次服务器收到一个请求，它都会创建一个新的<a class="ae lv" href="https://en.wikipedia.org/wiki/Thread_(computing)" rel="noopener ugc nofollow" target="_blank">线程</a>。然后，所有与请求相关的操作都在这个线程中执行，这非常有用，因为您有用户上下文，并且一切都是独立的。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lw"><img src="../Images/af4c083ddc0f59e9a0dd4e61935b606e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWyyhq4coKs_hkP2v6VGyg.png"/></div></div></figure><h2 id="52a9" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">为什么同步服务器难以扩展</h2><p id="6ca8" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">现在，当我们知道通常为每个请求创建一个线程时，是时候讨论多任务和并发性了。每台计算机都有一个CPU(中央处理器), CPU负责计算和执行我们用代码编写的操作。CPU有一定数量的核心，每个核心一次可以执行一个线程。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lx"><img src="../Images/fce7dfe3b8e321a84f7155b9c334e52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RU2k0PDgqQwQjGutYIQL0A.png"/></div></div></figure><p id="0391" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，我们要执行的线程比内核多得多，所以我们的OS(操作系统)管理硬件的方式是以<a class="ae lv" href="https://www.guru99.com/cpu-scheduling-algorithms.html" rel="noopener ugc nofollow" target="_blank">最有效的方式</a>将处理器时间分配给所有线程。我不会太深入这个话题，所以让我们假设它只是给每个线程等量的处理器时间。而这叫做伪并行，我们的OS切换每个CPU执行的线程，所以看起来像是每个线程的并行执行。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ly"><img src="../Images/47e36580871a9414c5c51d51e1115b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8W2X359yajJxE5gA-SkwUw.png"/></div></div></figure><p id="b079" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题来了，为CPU切换线程并不是一个廉价的操作，而且<strong class="jp ir"/><strong class="jp ir">线程越多，CPU花在线程间切换而不是执行实际代码</strong>的时间就越多，这将导致由于进程时间不足而导致的滞后响应。</p><h2 id="2f33" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">异步服务器如何利用资源</h2><p id="15cf" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">最后，是时候讨论异步代码了，异步代码的思想是让主线程(执行业务逻辑的线程)响应客户端，同时将大多数操作，如I/O(输入/输出，例如读取文件)和CPU密集型操作卸载到<a class="ae lv" href="https://en.wikipedia.org/wiki/Thread_pool" rel="noopener ugc nofollow" target="_blank">线程池</a>(也称为工作线程池)。该池的线程数不应超过服务器上的CPU核心数。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lz"><img src="../Images/a2027dd3e39885bcedb6ee69c041e67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MjC2f-6IYPQK6yMeXM2Ew.png"/></div></div></figure><p id="0bf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次你需要在主线程之外做一些事情的时候，你都是在“调度”一个任务，通过把它放到一个队列中，然后当你从一个池中有一个空闲线程的时候，它将在你的任务上工作。通过这种方式，我们在一定程度上解决了扩展服务器的问题，因为现在您的CPU将更多时间用于处理请求，这显著增加了您的单个服务器可以处理的并发请求数量。</p><h2 id="c9f4" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">异步服务器的缺点</h2><p id="f71e" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">异步代码的主要缺点是，您只有一个“主”线程，其中大部分时间执行所有业务逻辑，其余的通常由您的异步引擎处理。</p><p id="0829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于您的业务逻辑是在单线程中执行的<strong class="jp ir">如果您有一段运行时间过长的代码</strong>(通常我们称之为阻塞器)<strong class="jp ir">您的服务器将变得缓慢</strong>并且几乎不会响应其他客户端，因为它将忙于处理多个请求中的一个。</p><h2 id="04b0" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">摘要</h2><p id="e13b" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">异步代码是一种工具，像任何其他工具一样，你需要知道何时使用它，它不是能解决你所有问题的银弹，而是一把双刃剑，如果使用不当，也会伤害你。</p><p id="8ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/how-to-handle-blockers-in-node-js-1966d0399703">的下一篇文章</a>中，我们将以<a class="ae lv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>为例，讨论如何克服异步服务器的缺点。</p></div></div>    
</body>
</html>