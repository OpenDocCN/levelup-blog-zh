<html>
<head>
<title>5 intermediate level Python tricks you maybe didn’t know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能不知道的5个中级Python技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-intermediate-level-python-tricks-you-maybe-didnt-know-b0340ad33e7a?source=collection_archive---------5-----------------------#2021-08-18">https://levelup.gitconnected.com/5-intermediate-level-python-tricks-you-maybe-didnt-know-b0340ad33e7a?source=collection_archive---------5-----------------------#2021-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5a4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们把Python代码做得更好！</p><p id="4db3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一些有用的代码结构的集合，在某些情况下，这些代码结构可以帮助您使Python脚本看起来更整洁，可读性更好。这个集合的目的是比“反转一个字符串”、“交换两个数字”或类似的基本技巧更高级一点。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a9f8e4b750d556bfcdbcbf7bad9c2885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o4EhKo3uUflqMpTC"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae le" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>拍摄</figcaption></figure><h2 id="297f" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">高级拆包</h2><p id="2de2" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">假设我们有一个列表。我们想做的是，从列表的开始部分取出一些元素，从末尾部分取出一些元素。此外，我们希望有一个剩余的列表，没有我们已经采取的元素。这可以在如下一行中完成:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/b08a0df4923f9bbe5d84031ea8d2d0ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KZ45uwhbB6h-qvABz4Itw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">开箱(图片由作者提供)</figcaption></figure><p id="670d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么有效？这里的技巧隐藏在一个“rest”变量和它前面的一个星号中。在Python中，星号(或者有人更喜欢称之为星号)将序列或集合分解成单独的参数。这有时非常方便——例如，当我们需要将某个集合中的值作为函数的位置参数传递时。下面的例子应该给出一些关于如何使用它的基本直觉。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi me"><img src="../Images/c07a6323253b5713f1ff88baff1eeaa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MC8ING9iqzBbrWyOaLWogA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">星形符号用法(图片由作者提供)</figcaption></figure><p id="d8b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们理解了Python中解包的工作原理，第一个例子背后的逻辑就变得显而易见了。我们为变量“rest”分配了一些值，该变量处于“未打包”状态(有星号)，因此在“打包”状态(当访问时前面没有星号)下，它包含分配的值作为一个集合。</p><h2 id="f6b0" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">列表/字典理解中的嵌套for循环</h2><p id="fe76" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">让我们想象一下，我们想要一个包含其他两个列表项的所有组合的列表。让我们用一行程序来完成它。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mf"><img src="../Images/fb3189a676059a618e3bc01e0b342eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4brkRJXF79wk-CoB7pdgEQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">列表理解(图片由作者提供)</figcaption></figure><p id="5ec7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很酷，对吧？如果需要，我们可以有更多的“for”循环，而不是只有两个。但是要小心这个。我见过这种代码风格的一些非常有趣的错误。考虑下面的例子:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mg"><img src="../Images/a422fd6ef08d0dbc84d2e442a8853348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COvr9IRQe-Evp-5eKPnxMQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">字典理解(图片由作者提供)</figcaption></figure><p id="78b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">乍一看，在dict comprehension中使用嵌套for-loops似乎是一个好主意，可以用两个给定列表中的键和值创建dict。但是，观察上面例子中变量“b”的结果——得到的结果不是预期的结果，因为字典中的所有元素现在都有相同的值“C”。</p><p id="9977" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么会这样？首先，值“A”被分配给所有的键。然后所有的值都被“B”覆盖了。而在最后一次迭代中它们都变成了“C”。</p><p id="afdf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，期望的结果可能已经实现，例如通过使用“zip”函数，如在上面的例子中对于变量“c”所展示的。</p><h2 id="9757" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">自定义排序</h2><p id="2e36" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们可以使用“排序”功能对集合进行升序排序。这很简单。</p><p id="ca30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，如果我们需要以某种特定的、非标准的顺序对项目进行排序，事情可能会变得有点复杂。假设我们有一个列表，我们想对它的条目进行排序，但是我们想让所有偶数条目排在奇数条目之前。为此，我们可以使用“排序”函数的“key”参数，如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mh"><img src="../Images/6e53fe51fd050a80776cbad4d434649d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TbWkNjNoidaT3sWXYacRcw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">自定义排序(图片由作者提供)</figcaption></figure><p id="4ba6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过这种方式，可以指定一个自定义函数，该函数将在对列表项排序之前应用于所有列表项。</p><h2 id="e215" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">海象操作员</h2><p id="d65b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">可能你是通过它的正式名称“赋值表达式运算符”知道这个的。在需要同时检查和分配某些东西的情况下，它会有所帮助。请考虑下面的代码示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mi"><img src="../Images/6a7f16dc63b6572bb428c5d09e37a9ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zob_yzDzfXVnnF8DheuQQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">功能重(图片由作者提供)</figcaption></figure><p id="e0d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个代码有什么问题？显然，heavy函数会被不必要地调用两次，导致总共睡眠20秒而不是仅仅10秒。通常这种类型的代码是这样写的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mj"><img src="../Images/5c70fa72a2d96433a405717d106b3f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xdeiq4Cj7CMl0ZcyBSuV4A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">重构的代码(图片由作者提供)</figcaption></figure><p id="50b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在已经消除了对我们的重函数的不必要的调用，所以从技术上来说，现在一切都好了。但是我们能做得更好吗？让我们试试:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mk"><img src="../Images/7ffefe4014b8f4315412b1b03e4cf287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aK846Fc0cGJ0zGcJduDNQg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">海象运营商(图片由作者提供)</figcaption></figure><p id="2c4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们使用了walrus操作符(注意当我们分配heavy函数的结果时有“:=”)。使用它的主要好处是代码更短更简单。这是因为walrus运算符允许我们进行赋值并立即使用赋值(例如在IF语句检查中)。</p><p id="ce11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，walrus操作符相对较新，仅在Python版本3.8之后才可用。</p><h2 id="fbeb" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">链接的比较运算符</h2><p id="4828" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">需要检查某个值是否在给定的区间内是一个非常常见的用例。典型的检查方法如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ml"><img src="../Images/1f9a9a83f17ac533e815bf98f46d3f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7902prnhR_K6nyDJp6o7Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">检查区间值(图片由作者提供)</figcaption></figure><p id="4a28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，在Python中，这可以通过链接比较运算符以更优雅的方式编写。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mm"><img src="../Images/6743b98f2d61d10431b7bbf3d99247f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOmGBhSJ3Cmeg0W33WhjbA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">链式比较运算符(图片由作者提供)</figcaption></figure><p id="5ee4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想你会同意这样的代码可读性更好。简单明了。</p><h2 id="a557" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">一些最后的话</h2><p id="2533" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我希望您在这个Python技巧列表中找到了一些有用的见解，并且至少有一个描述的代码构造对您来说是新的。</p><p id="3971" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读！</p></div></div>    
</body>
</html>