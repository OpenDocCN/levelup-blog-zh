<html>
<head>
<title>Algorithms: Fibonacci Sequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:斐波那契数列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/algorithms-fibonacci-sequence-2fb1dd3d671f?source=collection_archive---------15-----------------------#2020-06-27">https://levelup.gitconnected.com/algorithms-fibonacci-sequence-2fb1dd3d671f?source=collection_archive---------15-----------------------#2020-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e2775d646f07ba301add7804a351b73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oCNl3rw-iPLkUmcG.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片来自<a class="ae kf" href="https://www.zoracreative.com/the-fibonacci-sequence/" rel="noopener ugc nofollow" target="_blank">仿植物怪兽佐拉创意</a></figcaption></figure><p id="7480" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">什么是斐波那契数列？斐波纳契数列是指一个数字序列，其中每个后续数字是前两个数字的总和，同时保持黄金比例。数学中的黄金比例是指两个数字之间的比例与另一组数字的比例相同。你可能以前在数学课上听说过。牢记在心；我将解释如何创建斐波那契数列作为一种算法。这是它的样子。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d12f" class="ln lo it lj b gy lp lq l lr ls">Fibonacci Sequence:</span><span id="f048" class="ln lo it lj b gy lt lq l lr ls">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144</span><span id="f03b" class="ln lo it lj b gy lt lq l lr ls">1 + 1 = 2<br/>2 + 3 = 5<br/>3 + 5 = 8<br/>5 + 8 = 13<br/>8 + 13 = 21<br/>13 + 21 = 34<br/>21 + 34 = 55<br/>34 + 55 = 89<br/>55 + 89 = 144<br/>... and so on to infinity</span></pre><p id="9b16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">计算下一个数字就像Fn = Fn-1+Fn-2一样简单。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="28bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们开始考虑如何创建算法。假设一位采访者要求我们创建一个斐波纳契数列算法，该算法接受一个数字作为参数。该算法的目的是使用该数字(表示索引)并返回所述索引数字的值。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="ca6d" class="ln lo it lj b gy lp lq l lr ls">function fibonacciSequence(index) {</span><span id="3b53" class="ln lo it lj b gy lt lq l lr ls">}</span></pre><p id="5314" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了一个简单的空函数。现在让我们问问自己，我们对斐波纳契数列了解多少。我们知道当前值是用过去的两个值确定的，前两个值是1。这意味着在这两个值之间添加了0。现在让我们创建变量来表示这些值，包括一个变量来表示没有设置值的Fn。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4ccb" class="ln lo it lj b gy lp lq l lr ls">function fibonacciSequence(index) {<br/> let a = 1<br/> let b = 0<br/> let currentValue<br/>}</span></pre><p id="bc92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！现在让我们进入下一步。我们知道索引值不能小于0，所以我们需要围绕它设置一个条件。因为我们知道序列的前两个值是1，所以我们暂时将它设置为currentValue等于值为1的变量a。我们现在必须将前面的两个值相加，以获得序列值中的下一个数字。之后，我们必须将currentValue重新赋值给b，然后我们必须递增地改变索引，以便遍历从插入的数字到索引值0的每个索引值。那么我们必须返回b。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e40b" class="ln lo it lj b gy lp lq l lr ls">function fibonacciSequence(index) {<br/> let a = 1<br/> let b = 0<br/> let currentValue<br/> while (index &gt;= 0) {<br/>  currentValue = a<br/>  a = a + b<br/>  b = currentValue<br/>  index --<br/> }<br/> return b<br/>}</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="ef00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">似乎有点太容易了，对吧？你是一名专业软件工程师，想要向面试官展示你的技能。我们可以做得更好，我们会的。我们将使用<strong class="ki iu"> <em class="mb">递归</em> </strong>来创建斐波那契数列算法！如果你需要一个快速的提醒，看看我写的<a class="ae kf" href="https://medium.com/dev-genius/algorithms-what-is-recursion-ddaac64e2e03" rel="noopener">博客文章</a>！</p><p id="f70e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据我们对序列的了解，你可能会尝试创建这样的算法作为解决方案。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="617a" class="ln lo it lj b gy lp lq l lr ls">function fibonacciSequence(index) {<br/> if (index &lt;= 1) return 1;<br/> return fibonacciSequence(index - 1) + fibonacciSequence(index - 2);<br/>}</span></pre><p id="990d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管这个解决方案确实可行，但是考虑到时间复杂性，它不是最优的。如果你需要时间复杂性的复习课程，请参考我写的这个<a class="ae kf" href="https://medium.com/swlh/big-o-notation-what-is-it-and-why-is-it-important-a520eb33bf56" rel="noopener">帖子</a>。该解决方案的时间复杂度为O (2n ),这是第二慢的时间复杂度。让我们优化这个解决方案。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="fd33" class="ln lo it lj b gy lp lq l lr ls">function fibonacciSequence(index, memo) {<br/> memo = memo || {};<br/> if (memo[index]) return memo[index];<br/> if (index &lt;= 1) return 1;<br/> return memo[index] = fibonacciSequence(index - 1, memo) + fibonacciSequence(index - 2, memo);<br/>}</span></pre><p id="5cf2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个解决方案中，我们使用了一种叫做<strong class="ki iu">记忆</strong>的东西，它指的是通过存储耗时的函数调用的结果来优化计算机程序。为什么这很重要，为什么我们要使用它？在这个解决方案中，我们将索引的值存储在一个hash中，这样可以避免额外的计算时间。这个解的时间复杂度为O(n)。</p><p id="4f94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尝试在每个解决方案中输入值30并运行算法。运行时间有很大的不同。运行时间只会随着输入值的增加而显著增加。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="2ce9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">结论</strong></p><p id="d200" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总而言之，编写代码<strong class="ki iu">不仅仅是编写功能代码</strong>。它是关于<strong class="ki iu">优化</strong>所说的功能代码以获得可能的最佳性能，其中之一是时间复杂度。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><div class="le lf lg lh gt mc"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">编写面试问题</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">掌握编码面试的过程</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">技术开发</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq jz mc"/></div></div></a></div></div></div>    
</body>
</html>