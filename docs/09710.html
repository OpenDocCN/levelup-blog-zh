<html>
<head>
<title>Practical DDD in Golang: Domain Event</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗实用DDD:领域事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-ddd-in-golang-domain-event-de02ad492989?source=collection_archive---------1-----------------------#2021-09-07">https://levelup.gitconnected.com/practical-ddd-in-golang-domain-event-de02ad492989?source=collection_archive---------1-----------------------#2021-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5fbe" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">领域驱动设计</h2><div class=""/><div class=""><h2 id="737b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">《围棋》中关于DDD的故事继续呈现了一个描述现实世界中发生的事件的构建模块——领域事件。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/35fe9921a4fa6096b5a5d0ad8155154b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLu20BJNc4WjbTnRtfKvtw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Anthony DELANOIX 在<a class="ae lh" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="04e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在许多情况下，实体是领域驱动设计中描述事物的最佳方式。与值对象一起，它们可以提供我们的<a class="ae lh" href="https://www.definitions.net/definition/problem+domain" rel="noopener ugc nofollow" target="_blank">问题域</a>的最接近的图片。</p><p id="d262" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时候，呈现问题域的最佳方式是使用其中发生的事件。事实上，在我的案例中，我越来越多地尝试识别事件，然后识别与它们相关的实体。</p><p id="0e92" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然<a class="ae lh" href="https://twitter.com/ericevans0?lang=en" rel="noopener ugc nofollow" target="_blank"> Eric Evans </a>在他的<a class="ae lh" href="https://www.amazon.de/-/en/Eric-J-Evans/dp/0321125215" rel="noopener ugc nofollow" target="_blank">书</a>的第一版中没有涉及领域事件模式，但是今天，在不使用事件的情况下完成领域层是具有挑战性的。</p><p id="90d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">领域事件模式在我们的代码中代表了这样的事件。我们用它来描述现实世界中与我们的业务逻辑相关的任何事件。今天，商业世界中的一切都与一些事件有关。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="6fe1" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="423c" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="a66b" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="27c4" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mf jd">Practical DDD in Golang: Domain Service</strong></a></span></pre><h1 id="1ebe" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">它可以是任何东西</h1><p id="b76a" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">域事件可以是任何东西，但是它们需要满足一些规则。第一个是——它们是不可变的。为了支持这个特性，我总是在事件结构中使用私有字段，尽管我并不喜欢Go中的私有字段和getters。至少，事件没有太多的getters。</p><p id="f8f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个特定的事件只能发生一次。这意味着我们只能一次创建一个具有某种身份的<code class="fe nm nn no mf b">Order</code>实体，所以我们的代码只能触发一次描述该<code class="fe nm nn no mf b">Order</code>创建的事件。</p><p id="43a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于那个<code class="fe nm nn no mf b">Order</code>来说，任何其他事件都是不同类型的事件。任何其他创建事件都是另一个<code class="fe nm nn no mf b">Order</code>的事件。</p><p id="b209" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个事件实际上都描述了已经发生的事情。它代表过去。这意味着我们在已经创建了<code class="fe nm nn no mf b">Order</code>的时候触发了<code class="fe nm nn no mf b">OrderCreated</code>事件，而不是在此之前。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">简单事件</figcaption></figure><p id="e5fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的代码示例展示了简单的域事件。这段代码是在Go中实现它们的数十亿个解决方案之一。在某些情况下，比如这里的<code class="fe nm nn no mf b">GeneralError</code>,我只使用了简单的字符串。</p><p id="9c13" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是有时候，我有复杂的物体。或者，我必须用一些更具体的接口来扩展主事件接口，以添加额外的方法，比如用<code class="fe nm nn no mf b">OrderEvent</code>。</p><p id="db95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为接口的域事件不需要实现任何方法。它可以是你想要的任何东西。如上所述，有时我使用字符串，但任何东西都足够好。为了一般化，时不时我还是声明一下<code class="fe nm nn no mf b">Event</code>接口。</p><h1 id="ccd8" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">老朋友</h1><p id="32f1" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">作为一种模式，域事件并不提供一些新的结构，但它是观察者模式的另一种表现形式。观察者模式认为发布者、订阅者是主角，当然还有事件。</p><p id="56c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">域事件遵循相同的逻辑。订阅者或事件处理程序是一个结构，它应该响应它订阅的特定域事件。发布器是一种一旦发生某个事件就通知所有事件处理程序的结构。</p><p id="266a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">发布者是触发任何事件的入口点。它包含所有事件处理程序，并为任何域服务、工厂或其他想要发布某个事件的对象提供了一个简单的接口。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">EventHandler和EventPublisher的示例</figcaption></figure><p id="80f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的代码片段展示了域事件模式的其余部分。接口<code class="fe nm nn no mf b">EventHandler</code>代表了应该对某个事件做出反应的任何结构。它只有一个将事件作为参数的<code class="fe nm nn no mf b">Notify</code>方法。</p><p id="c10f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结构<code class="fe nm nn no mf b">EventPublisher</code>更加复杂。它提供了通用的<code class="fe nm nn no mf b">Notify</code>方法，负责通知所有订阅了那个<code class="fe nm nn no mf b">Event</code>的<code class="fe nm nn no mf b">EventHandlers</code>。另一个功能<code class="fe nm nn no mf b">Subscribe</code>增加了任何<code class="fe nm nn no mf b">EventHandler</code>订阅任何<code class="fe nm nn no mf b">Event</code>的可能性。</p><p id="018a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nm nn no mf b">EventPublisher</code>结构可以不那么复杂。相反，为了让<code class="fe nm nn no mf b">EventHandler</code>有机会通过使用地图来订阅某个特定的<code class="fe nm nn no mf b">Event</code>，它只能处理一个简单的<code class="fe nm nn no mf b">EventHandlers</code>数组，并通知所有的<code class="fe nm nn no mf b">Event</code>。</p><p id="f1dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一般来说，我们应该在我们的领域层同步发布领域事件。但是有时，出于某种原因，我想异步地触发它们，为此，我使用了<a class="ae lh" href="https://tour.golang.org/concurrency/1" rel="noopener ugc nofollow" target="_blank"> Goroutine </a>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">异步发布事件</figcaption></figure><p id="ca3d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子展示了异步发布事件的一种变体。为了提供这两种方法，我经常在<code class="fe nm nn no mf b">Event</code>接口中定义一个方法，该方法应该在以后告诉我是否应该同步触发<code class="fe nm nn no mf b">Event</code>。</p><h1 id="bd3c" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">创造</h1><p id="51ca" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我最大的困境是在哪里举办活动才是合适的。老实说，到处都是我做的。我唯一的规则是有状态对象不能通知<code class="fe nm nn no mf b">EventPublisher</code>。</p><p id="0169" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实体、值对象等集合(我们将在下一篇文章中讨论)是有状态对象。从这个角度来看，它们不应该包含<code class="fe nm nn no mf b">EventPublisher</code>,并且对我来说，将它作为参数提供给它们的方法总是一个丑陋的代码。</p><p id="f672" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，我不使用有状态对象作为<code class="fe nm nn no mf b">EventHandlers</code>。如果我需要在特定事件发生时对某个实体做些什么，我会创建一个包含存储库的<code class="fe nm nn no mf b">EvenHandler</code>。然后，存储库可以提供一个应该被修改的实体。</p><p id="0a3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管如此，在聚合的某个方法中创建事件对象是没问题的。有时，我在实体的方法中创建它们，并作为结果返回它们。然后，我使用无状态结构如域服务或工厂来通知<code class="fe nm nn no mf b">EventPublisher</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">事件的创建</figcaption></figure><p id="8210" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，<code class="fe nm nn no mf b">Order</code>聚合提供了一种更新递送地址的方法。该方法结果可以是一个<code class="fe nm nn no mf b">Event</code>。这意味着<code class="fe nm nn no mf b">Order</code>可以创造一些<code class="fe nm nn no mf b">Events</code>，但仅此而已。</p><p id="a48d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，<code class="fe nm nn no mf b">OrderService</code>既可以创建<code class="fe nm nn no mf b">Events</code>又可以发布它们。它还可以在更新递送地址时触发从<code class="fe nm nn no mf b">Order</code>接收的<code class="fe nm nn no mf b">Events</code>。这是可能的，因为它包含<code class="fe nm nn no mf b">EventPublisher</code>。</p><h1 id="2af7" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">其他层上的事件</h1><p id="ee7b" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我们可以监听其他层上的领域事件，比如应用程序、演示或基础设施。我们还可以定义专门用于这些层的独立事件。在这些情况下，我们不谈论领域事件。</p><p id="fa11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个简单的例子是应用层上的事件。在我们创建一个<code class="fe nm nn no mf b">Order</code>之后，在大多数情况下，我们应该发送一个<code class="fe nm nn no mf b">Email</code>给客户。尽管看起来像是一条业务规则，但发送电子邮件始终是特定于应用程序的。</p><p id="8100" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的例子中，有一个带有<code class="fe nm nn no mf b">EmailEvent</code>的简单代码。正如您可能猜到的，<code class="fe nm nn no mf b">Email</code>可以处于许多不同的状态，从一种状态切换到另一种状态总是在一些<code class="fe nm nn no mf b">Events</code>期间执行。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">应用程序事件示例</figcaption></figure><p id="6bb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时我们想要在我们的<a class="ae lh" href="https://martinfowler.com/bliki/BoundedContext.html" rel="noopener ugc nofollow" target="_blank">有界上下文</a>之外触发域事件。这些域事件对于我们的有界上下文来说是内部事件，但是对于其他上下文来说是外部事件。</p><p id="8f58" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然这更像是一个<a class="ae lh" href="https://vaadin.com/learn/tutorials/ddd/strategic_domain_driven_design" rel="noopener ugc nofollow" target="_blank">战略领域驱动设计</a>的主题，但我将在这里触及这一部分。为了在我们的微服务之外发布事件，我们可能会使用一些消息服务，比如<a class="ae lh" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank"> SQS </a>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">向外部世界发布内部事件</figcaption></figure><p id="df30" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码片段中，基础设施层有一个简单的结构<code class="fe nm nn no mf b">EventSQSHandler</code>，每当有事件发生时，它就向SQS队列发送一条消息。它只发布事件名称，没有任何具体的细节。</p><p id="857c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当向外界发布内部事件时，我们也可以监听外部事件并将它们映射到内部事件。为此，我总是在基础设施层提供一些服务来监听来自外部的消息。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">监听外部事件</figcaption></figure><p id="1cd5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子显示了基础设施层内部的<code class="fe nm nn no mf b">SQSService</code>。该服务监听SQS消息，如果可以映射到内部消息，则将它们映射到内部消息<code class="fe nm nn no mf b">Events</code>。</p><p id="de69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我没有过多地使用这种方法，但在某些情况下，这是值得的。比如如果很多微服务要对<code class="fe nm nn no mf b">Order</code>的创建做出反应。或者当<code class="fe nm nn no mf b">Customer</code>注册时。</p><h1 id="dd93" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">结论</h1><p id="816d" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">领域事件是我们领域逻辑中不可避免的结构。今天，商业世界中的一切都与特定的事件绑定在一起，所以用事件描述我们的领域模型是一个很好的实践。</p><p id="31b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">域事件模式只是观察者模式的实现。它可以在许多对象中创建，但应该从无状态对象中触发。其他层也可以使用域事件或它们自己的事件。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="cc16" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="1e39" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="f327" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="99ef" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mf jd">Practical DDD in Golang: Domain Service</strong></a></span></pre><h1 id="dda8" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">有用的资源:</h1><ul class=""><li id="3df1" class="nr ns it lk b ll nh lo ni lr nt lv nu lz nv md nw nx ny nz bi translated"><a class="ae lh" href="https://martinfowler.com/" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/</a></li><li id="8074" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated"><a class="ae lh" href="https://www.domainlanguage.com/" rel="noopener ugc nofollow" target="_blank">https://www.domainlanguage.com/</a></li></ul></div></div>    
</body>
</html>