<html>
<head>
<title>Big O Notation: Merge Sort in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号:Unity中的合并排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/big-o-notation-merge-sort-in-unity-9dda253c6b13?source=collection_archive---------2-----------------------#2021-08-28">https://levelup.gitconnected.com/big-o-notation-merge-sort-in-unity-9dda253c6b13?source=collection_archive---------2-----------------------#2021-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="81d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之前，我们看到了大O符号家族中性能最低的算法:冒泡排序(<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/big-o-notation-bubble-search-in-unity-c90ca1f608d0">大O符号:Unity中的冒泡搜索</a>)。在本文中，我们将深入研究一种更有效的排序类型和一种新的大O符号，即合并排序。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4b62e045f329aa9ce6aa74034a9c78f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SF9MCaAHO-y7YKcsL82_tw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">合并排序</figcaption></figure><blockquote class="lc ld le"><p id="4d87" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">了解合并排序</p></blockquote><p id="b401" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">合并排序算法基本上是将一个大数据数组划分为单独的数组(每个数组一个索引)，因此每个数组将保存一个值。从那里，合并将开始排序和合并每个单独的数组，直到它将所有的数据合并到一个排序的数组中。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lj"><img src="../Images/a87f535dd9d59b0d506a04d6e0dd325f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3KbKO7SPi1dn2u9It738w.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">合并排序</figcaption></figure><p id="1f90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据大O符号，合并排序被称为:O(n log n)，这是划分和征服，所以它是线性搜索O(n)和二分搜索法O (log n)的混合。</p><blockquote class="lc ld le"><p id="99bf" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">履行</p></blockquote><p id="f928" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们以下面的int列表为例:</p><pre class="kn ko kp kq gt lk ll lm ln aw lo bi"><span id="2de1" class="lp lq iq ll b gy lr ls l lt lu">List&lt;int&gt; ages = new List&lt;int&gt;{43, 76, 2, 2, 5, 45, 25};</span></pre><p id="8142" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该过程将分为两种方法，一种方法将数组分成每个数组一个索引的单个列表，第二种方法将开始排序和合并。</p><h2 id="888b" class="lp lq iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">分割部分</h2><p id="e243" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">就像在二分搜索法(<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/big-o-binary-search-in-unity-f607d0f0919d">大O:团结</a>里的二分搜索法)，我们会把名单分为左名单和右名单。然后我们会把新的列表，分成新的左列表和右列表，这样一直分下去，直到列表中只剩下一个索引。听起来够简单吧？让我们实现它吧…</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mr"><img src="../Images/03703e34f93ec2f32c721f72c56ec910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cq4wBAhMFMoP6Nd6Coprkg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">划分列表</figcaption></figure><p id="661c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，这个方法将获取一个列表，并开始把它分成左列表和右列表，并一直这样做，直到它到达单个列表。在这个方法的最后，我们创建了一个名为MergeLists的新方法，它将两个列表作为参数。</p><h2 id="e320" class="lp lq iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">合并零件</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ms"><img src="../Images/00f943a0c09de10d1fe213a02e8a7087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQwu-NJbTdmAJ2VgmWVcFA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">合并方法</figcaption></figure><p id="c3b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个方法所做的是获取左右两个列表，检查它们是否不为空，然后对列表进行加法比较，并将它们添加到一个排序列表中。</p><blockquote class="lc ld le"><p id="a6b2" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">冒泡排序与合并排序</p></blockquote><p id="1fa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道了如何进行这两种排序，让我们快速测试一下这两种算法的效率差异。</p><p id="50e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一个包含1000个条目的列表，我们检查每个算法运行了多少次，以便对列表进行排序。我们通过在每次迭代中增加一个计数来做到这一点。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/addbb7cfba8c87109a804ff3d6cf02a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*J_5fkIYPyzjF7frWfD02Zg.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">性能差异</figcaption></figure><p id="049e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，冒泡排序需要500，500次迭代才能对1000个数字的列表进行排序，而合并排序只需要22，950次迭代才能对同一列表进行排序。</p></div></div>    
</body>
</html>