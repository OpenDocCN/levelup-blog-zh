<html>
<head>
<title>Text Classification in Spreadsheets using Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Javascript在电子表格中进行文本分类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/text-classification-in-google-sheets-using-javascript-d823c0afc5e0?source=collection_archive---------11-----------------------#2021-02-07">https://levelup.gitconnected.com/text-classification-in-google-sheets-using-javascript-d823c0afc5e0?source=collection_archive---------11-----------------------#2021-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f71a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用ml-classify-text-js + Google Apps脚本/ Excel插件</h2></div><p id="e29c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我使用一种叫做<a class="ae le" href="https://www.tillerhq.com/" rel="noopener ugc nofollow" target="_blank"> Tiller </a>的服务，它可以自动将不同账户的交易数据提取并整合到Google Sheets中。它帮助我追踪花费和计划预算。不幸的是，进来的交易必须手动分类。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/33ceeb07c7c2552dc0e892825189e205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*yUsSGsZqYg4zk0-X1jIYEQ.gif"/></div></figure><p id="81da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我着手解决这个问题，并使用一个名为<a class="ae le" href="https://github.com/andreekeberg/ml-classify-text-js" rel="noopener ugc nofollow" target="_blank"> ml-classify-text-js </a>的Javascript库找到了一个简单的解决方案。它允许我使用Apps脚本在Google Sheets和使用插件在Excel中完成简单的分类任务。下面是实际运行的脚本:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/183f927e25978f9514ea6de6fc22310b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*KpfFMnD_hIdZa10IVn9AhA.gif"/></div></figure><p id="dd93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将描述我使用的代码，这样您就可以编写自己的客户端Javascript文本分类应用程序。让我们开始吧。</p><p id="b5c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ln">如果你只是想跳到整个代码，点击</em> <a class="ae le" href="https://gist.github.com/ismaelc/66a7bb4e62bc45d56c1f360f32598e6e" rel="noopener ugc nofollow" target="_blank"> <em class="ln">此处</em> </a> <em class="ln">用于Google Sheets，点击</em> <a class="ae le" href="https://gist.github.com/ismaelc/ee45b53e4b0ee84bb669339133966da9" rel="noopener ugc nofollow" target="_blank"> <em class="ln">此处</em> </a> <em class="ln">(加上</em><a class="ae le" href="https://gist.github.com/ismaelc/9136e00a3dc676f13e6a3a6986367213" rel="noopener ugc nofollow" target="_blank"><em class="ln">html</em></a><em class="ln">)用于Excel插件。</em></p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="a44e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">ml-分类-文本-js</h1><p id="2350" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在撰写本文时，<a class="ae le" href="https://github.com/andreekeberg/ml-classify-text-js" rel="noopener ugc nofollow" target="_blank">这个</a> Javascript库是你谷歌<em class="ln">“文本分类Javascript”</em>时的顶级结果之一。它做了我所需要的，所以这就是我们将要在下面的Google Sheets和Excel add-in示例中使用的。下面是训练模型进行文本分类(情感分析)的示例代码:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0c22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代替情绪分析，我们将用我们在表中选择的单元格中的交易文本数据来“训练”它。为此，我们将为Google Sheets使用Apps脚本，为Excel使用插件。</p><h1 id="379a" class="lv lw it bd lx ly mu ma mb mc mv me mf jz mw ka mh kc mx kd mj kf my kg ml mm bi translated">Google企业应用套件脚本</h1><p id="0462" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在他们的<a class="ae le" href="https://www.google.com/script/start" rel="noopener ugc nofollow" target="_blank">网站</a>上，谷歌将Apps Script定义为“快速应用开发平台”。访问它来编写我们的代码很容易。在Google Sheets中，只需点击工具- &gt;脚本编辑器。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/56eaa554837cbfe3d813f7ac8a5827d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*cvF12POBsbQDHcaKJfXApw.gif"/></div></figure><p id="8235" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想将粘贴代码复制到脚本编辑器中，跳过本教程，将<a class="ae le" href="https://gist.github.com/ismaelc/66a7bb4e62bc45d56c1f360f32598e6e" rel="noopener ugc nofollow" target="_blank">这段代码</a>复制到Code.gs中，点击“运行”。“ML列车菜单”应在工作表中弹出。</p><p id="f07f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有<a class="ae le" href="https://www.benlcollins.com/apps-script/google-apps-script-beginner-guide/#:~:text=%20Google%20Apps%20Script%20Examples%20%201%20Macros,use%20case%20for%20this%20Google%20Sheets...%20More" rel="noopener ugc nofollow" target="_blank">这个有用的页面</a>涵盖了很多关于应用脚本的基础知识。</p><h2 id="f3e6" class="mz lw it bd lx na nb dn mb nc nd dp mf kr ne nf mh kv ng nh mj kz ni nj ml nk bi translated">将ml-classify-text-js导入Apps脚本</h2><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="f866" class="mz lw it bd lx na nb dn mb nc nd dp mf kr ne nf mh kv ng nh mj kz ni nj ml nk bi translated">添加菜单项</h2><p id="f511" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这将我们的菜单项与我们想要调用的函数挂钩。当用户点击相应的菜单项时，这些函数被调用。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="7584" class="mz lw it bd lx na nb dn mb nc nd dp mf kr ne nf mh kv ng nh mj kz ni nj ml nk bi translated">捕获单元格数据(范围)</h2><p id="3e01" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">当用户点击“获取训练集”时，调用函数调用<a class="ae le" href="https://gist.github.com/ismaelc/66a7bb4e62bc45d56c1f360f32598e6e#file-code-js-L15" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">捕获范围</strong> </a>。这里对工作表API的调用在第3行和第5行。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c04d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些行获取活动工作表。这给出了用户选择的范围(例如，A1:E5表示用户已经从单元格A1向下绘制了一个框到E5)。</p><p id="7aac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://gist.github.com/ismaelc/66a7bb4e62bc45d56c1f360f32598e6e#file-code-js-L54" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">resolver range</strong></a>是另一个函数，它在用户选择列(如B:D，不完整)而不是单元格(B2:D25，完整)时固定范围值。(我非常鼓励反馈来使这变得更好)。另一个名为<a class="ae le" href="https://gist.github.com/ismaelc/66a7bb4e62bc45d56c1f360f32598e6e#file-code-js-L65" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">的函数processData </strong> </a>为分类器准备数据。它返回这样的数据:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">请注意与本文开头的情感分析示例代码的相似性</figcaption></figure><p id="b8d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最初将这个经过训练的输出保存为一个全局变量，但是注意到当从不同的函数访问时，它并不保存值(我们将在下面讨论)。我求助于编写<a class="ae le" href="https://gist.github.com/ismaelc/66a7bb4e62bc45d56c1f360f32598e6e#file-code-js-L85" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">settinraindata</strong></a>，它通过属性服务API将单元格数据作为键值对持久化:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">我们可以稍后用“getProperty”来检索它</figcaption></figure><h2 id="82fb" class="mz lw it bd lx na nb dn mb nc nd dp mf kr ne nf mh kv ng nh mj kz ni nj ml nk bi translated">训练+预测</h2><p id="dbb0" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">下面的代码片段是一个名为<a class="ae le" href="https://gist.github.com/ismaelc/66a7bb4e62bc45d56c1f360f32598e6e#file-code-js-L26" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">predict range</strong></a><strong class="kk iu">的函数的一部分。当用户点击“预测”时，它运行。我在下面分解它们，详细解释每一个:</strong></p><p id="097d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这部分用我们前面处理的细胞数据训练分类器。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">您可以将其他配置选项传递给分类器。</figcaption></figure><p id="7604" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将选择单元格区域并获取我们将预测输出的数据。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4e3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您会注意到这看起来类似于我们之前在捕获数据进行训练时看到的片段。不同之处在于所选范围有空值。它们代表我们将要写入预测的单元格。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/183f927e25978f9514ea6de6fc22310b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*KpfFMnD_hIdZa10IVn9AhA.gif"/></div></figure><p id="ec3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码遍历单元格数据，通过训练好的分类器预测类别，并将结果赋回空单元格。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b6ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！如果你想看这个Google Sheets Apps脚本代码，点击<a class="ae le" href="https://gist.github.com/ismaelc/66a7bb4e62bc45d56c1f360f32598e6e" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="de8b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们来看看Excel版本。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="8b00" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Excel加载项</h1><p id="0c95" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">对于Excel，我使用Office插件来集成我们之前用于Google Sheets的ml-classify-text-js库。我按照<a class="ae le" href="https://docs.microsoft.com/en-us/office/dev/add-ins/quickstarts/excel-quickstart-jquery?tabs=yeomangenerator" rel="noopener ugc nofollow" target="_blank">这个快速入门教程</a>创建了基本Excel任务窗格插件。因为我们是在此基础上构建的，所以我强烈建议您先进行设置，然后再回到这里。(您可以随意跳过并浏览下面的代码)。</p><p id="e51a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们在Excel中编写的任务窗格加载项:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/29b3b8122585d83d3d822849d89f3cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*GLL4NtfOJV_W0ClOQNdFNg.gif"/></div></figure><p id="ca77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，确保您已经完成了上面提到的快速入门教程。</p><h2 id="0c87" class="mz lw it bd lx na nb dn mb nc nd dp mf kr ne nf mh kv ng nh mj kz ni nj ml nk bi translated">正在安装ml-classify-text-js</h2><p id="3fd3" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">完成后，通过运行下面的命令在quickstart项目中与package.json相同的文件夹中安装<a class="ae le" href="https://github.com/andreekeberg/ml-classify-text-js" rel="noopener ugc nofollow" target="_blank"> ml-classify-text-js </a>库:</p><p id="00fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe np nq nr ns b">npm install ml-classify-text</code></p><p id="9892" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，<strong class="kk iu"> src- &gt; taskpane </strong>文件夹中有两个文件我们需要更改:taskpane.js和taskpane.js</p><h2 id="49ca" class="mz lw it bd lx na nb dn mb nc nd dp mf kr ne nf mh kv ng nh mj kz ni nj ml nk bi translated">任务窗格用户界面</h2><p id="9d2e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在<a class="ae le" href="https://gist.github.com/ismaelc/9136e00a3dc676f13e6a3a6986367213" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">taskpane.html</strong></a>中，用下面的代码替换<strong class="kk iu">主体</strong>元素。这会将任务窗格更改为显示“捕获定型数据”和“预测”按钮。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="49cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您会注意到每个按钮都被分配了一个id。这让我们可以将点击事件与每一个事件联系起来。让我们现在做那件事。</p><h2 id="8ab7" class="mz lw it bd lx na nb dn mb nc nd dp mf kr ne nf mh kv ng nh mj kz ni nj ml nk bi translated">初始化事件处理程序+库</h2><p id="0ac8" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在<a class="ae le" href="https://gist.github.com/ismaelc/ee45b53e4b0ee84bb669339133966da9" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> taskpane.js </strong> </a>中，删除<strong class="kk iu">运行</strong>的click事件处理程序，替换为<strong class="kk iu">捕获</strong>和<strong class="kk iu">预测</strong>，如下图:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f55a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在其下方，删除<strong class="kk iu">运行</strong>的整个功能。请代之以以下初始化代码:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="3d9b" class="mz lw it bd lx na nb dn mb nc nd dp mf kr ne nf mh kv ng nh mj kz ni nj ml nk bi translated">捕获单元格数据</h2><p id="86d8" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><a class="ae le" href="https://gist.github.com/ismaelc/ee45b53e4b0ee84bb669339133966da9#file-taskpane-full-js-L27" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> captureRange </strong> </a>函数将收集用户选择的数据，并将其放入<a class="ae le" href="https://gist.github.com/ismaelc/ee45b53e4b0ee84bb669339133966da9#file-taskpane-full-js-L24" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> processedData </strong> </a>变量中。</p><p id="bed6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这部分函数获取用户选择的范围，以及可以找到数据的范围。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1aec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“已用范围”捕获包含数据的工作表的最远角。当通过列选择数据时，这提供了一个有用的上限，否则我们会得到一直到底部的行，不管它们是否有单元格数据。</p><p id="05d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个有趣的地方是对“load”的调用，以及随之而来的<strong class="kk iu"> context.sync() </strong>。“load”将命令排队以从Excel中获取我们需要的属性，context.sync执行这些命令。</p><p id="f90f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae le" href="https://gist.github.com/ismaelc/ee45b53e4b0ee84bb669339133966da9#file-taskpane-full-js-L109" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">resolver range</strong></a>函数中，我们根据用户选择的是单元格还是列来更新范围值。因此，诸如“最佳:D”范围的列选择将变成“B1:D45”。此时，我们已经准备好获取一些基于“已解析”范围值的单元格数据。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ef5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意上面我们是如何“加载”以获得“值”，并使用context.sync()提取它们的。我们现在有数据了！我们使用<a class="ae le" href="https://gist.github.com/ismaelc/ee45b53e4b0ee84bb669339133966da9#file-taskpane-full-js-L122" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> processData </strong> </a>对其进行格式化，准备稍后发送给分类器。</p><h2 id="e693" class="mz lw it bd lx na nb dn mb nc nd dp mf kr ne nf mh kv ng nh mj kz ni nj ml nk bi translated">训练+预测</h2><p id="9eca" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">下面的代码片段要么是从名为<a class="ae le" href="https://gist.github.com/ismaelc/ee45b53e4b0ee84bb669339133966da9#file-taskpane-full-js-L61" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">predict range</strong></a><strong class="kk iu">的函数调用的，要么是该函数的一部分。当用户点击“预测”时，它运行。我把它们分了出来，这样我可以详细解释每一个:</strong></p><p id="5e9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这部分用我们前面处理的细胞数据训练分类器。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b146" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将选择单元格区域并获取我们将预测输出的数据。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5a19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，在此选择步骤中，我们选择了一个包含数据的列，以及另一个用于放置预测的空列:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/29b3b8122585d83d3d822849d89f3cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*GLL4NtfOJV_W0ClOQNdFNg.gif"/></div></figure><p id="1ba3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码遍历单元格数据，通过训练好的分类器预测类别，并将结果赋回空单元格。</p><p id="274d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！如果你想查看Excel任务窗格插件代码，点击<a class="ae le" href="https://gist.github.com/ismaelc/66a7bb4e62bc45d56c1f360f32598e6e" rel="noopener ugc nofollow" target="_blank">这里</a>查看html，点击<a class="ae le" href="https://gist.github.com/ismaelc/ee45b53e4b0ee84bb669339133966da9" rel="noopener ugc nofollow" target="_blank">这里</a>查看函数。</p><h1 id="6fda" class="lv lw it bd lx ly mu ma mb mc mv me mf jz mw ka mh kc mx kd mj kf my kg ml mm bi translated">总结和想法</h1><p id="8952" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在这篇文章中，我介绍了如何使用ml-classify-text-js/Javascript在电子表格中运行简单的文本分类任务。</p><p id="8699" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以做其他一些事情，比如数据预处理、主题建模、实体识别等。我们还可以将它与后端服务连接起来，以执行需要更多处理能力的密集型ML任务。</p><p id="5efe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我期待着听到您对这些想法的看法，以及如何使代码变得更好。</p></div></div>    
</body>
</html>