<html>
<head>
<title>JavaScript Type Checking with Flow — Variables and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用流检查JavaScript类型——变量和函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-type-checking-with-flow-variables-and-functions-4163201d2505?source=collection_archive---------17-----------------------#2020-01-22">https://levelup.gitconnected.com/javascript-type-checking-with-flow-variables-and-functions-4163201d2505?source=collection_archive---------17-----------------------#2020-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6846fa438e48117679ea1c7f80d845fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VdYD9ViEqUhr_A58"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">史蒂夫·奥迪在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f336" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Flow是一个由脸书开发的类型检查器，用于检查JavaScript数据类型。它有许多内置的数据类型，我们可以用它们来注释变量和函数参数的类型。</p><p id="0739" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究流支持的用于类型检查的数据类型，包括变量和函数的基本属性。</p><h1 id="1aaa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">变量类型</h1><p id="73b2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">就像在JavaScript中一样，我们可以用Flow分别用<code class="fe mh mi mj mk b">let</code>、<code class="fe mh mi mj mk b">var</code>和<code class="fe mh mi mj mk b">const</code>关键字声明变量和常量。</p><p id="3c7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">let</code>和<code class="fe mh mi mj mk b">var</code>用于声明变量。这意味着它们的值可以在初始赋值后重新赋值。</p><h2 id="eae5" class="ml lf it bd lg mm mn dn lk mo mp dp lo kr mq mr ls kv ms mt lw kz mu mv ma mw bi translated">常数</h2><p id="8383" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">const</code>关键字用于声明常量。一旦它被赋予一个值，它可以被重新赋予另一个值。</p><p id="709d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">流可以在不添加类型注释的情况下推断数据类型常量:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="00f9" class="ml lf it mk b gy nf ng l nh ni">const a = 1;</span></pre><p id="6146" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它会知道<code class="fe mh mi mj mk b">a</code>是一个数字。</p><p id="abc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，我们可以用如下类型对其进行注释:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="c42d" class="ml lf it mk b gy nf ng l nh ni">const a: number = 1;</span></pre><h2 id="4383" class="ml lf it bd lg mm mn dn lk mo mp dp lo kr mq mr ls kv ms mt lw kz mu mv ma mw bi translated">var和let</h2><p id="cca5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">var</code>和<code class="fe mh mi mj mk b">let</code>都是用来给变量赋值的。区别在于<code class="fe mh mi mj mk b">var</code>不是块范围的，而<code class="fe mh mi mj mk b">let</code>是块范围的。</p><p id="b9e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="f4a6" class="ml lf it mk b gy nf ng l nh ni">if (true){<br/>  var x = 1;<br/>}<br/>console.log(x);</span></pre><p id="668e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果我们用<code class="fe mh mi mj mk b">let</code>替换<code class="fe mh mi mj mk b">var</code>，我们会得到一个错误:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="946d" class="ml lf it mk b gy nf ng l nh ni">if (true){<br/>  let x = 1;<br/>}<br/>console.log(x);</span></pre><p id="8c98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用另一个值重新分配用<code class="fe mh mi mj mk b">var</code>或<code class="fe mh mi mj mk b">let</code>声明的变量。例如，我们可以写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="765b" class="ml lf it mk b gy nf ng l nh ni">var x = 1;<br/>x = 2;</span><span id="bdc6" class="ml lf it mk b gy nj ng l nh ni">let y = 1;<br/>y = 2;</span></pre><p id="3661" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，如果一个数据类型注释被添加到一个变量中，那么我们必须为它分配一个兼容类型的值。例如，如果我们有一个数字变量:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="4fb0" class="ml lf it mk b gy nf ng l nh ni">let y: number = 1;</span></pre><p id="fc96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后写道:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="81bb" class="ml lf it mk b gy nf ng l nh ni">y = '2';</span></pre><p id="5242" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后就会产生一个错误。</p><p id="4bbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有将数据类型注释添加到变量或常数中，流程将假设变量或常数的类型是已经分配给它的所有数据类型的联合。</p><p id="46a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="47c0" class="ml lf it mk b gy nf ng l nh ni">let a = 1;<br/>a = 'foo';<br/>a = true</span></pre><p id="ae32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="2a59" class="ml lf it mk b gy nf ng l nh ni">let b: number|string|boolean = a;</span></pre><p id="8537" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有任何错误。这是因为在将<code class="fe mh mi mj mk b">a</code>赋值给<code class="fe mh mi mj mk b">b</code>之前，我们已经将一个数字、字符串和布尔赋值给了<code class="fe mh mi mj mk b">a</code>，所以<code class="fe mh mi mj mk b">a</code>被认为具有所有这些类型的联合。</p><p id="ad77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Flow还可以计算出它被赋予的类型。例如，我们可以写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="3d2d" class="ml lf it mk b gy nf ng l nh ni">let foo = 1;<br/>let num: number = foo;</span><span id="8d25" class="ml lf it mk b gy nj ng l nh ni">foo = false;<br/>let boo: boolean = foo;</span><span id="a640" class="ml lf it mk b gy nj ng l nh ni">foo = "foo";<br/>let str: string = foo;</span></pre><p id="3869" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在像函数和条件这样的块中运行的代码将抛出流的类型推断，并且当我们试图将它分配给我们期望工作的东西时将抛出一个错误。</p><p id="5fb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="c77c" class="ml lf it mk b gy nf ng l nh ni">let foo = 1;</span><span id="ff66" class="ml lf it mk b gy nj ng l nh ni">if(true) {<br/>  foo = true;<br/>  foo = "foo";<br/>}</span><span id="cfd8" class="ml lf it mk b gy nj ng l nh ni">let str: string = foo;</span></pre><p id="c70a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将得到错误:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="8ea9" class="ml lf it mk b gy nf ng l nh ni">[Flow] Cannot assign `foo` to `str` because number [1] is incompatible with string [2].</span></pre><p id="045f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为Flow不知道<code class="fe mh mi mj mk b">foo</code>变量的类型。</p><p id="e894" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，在函数中被重新赋值后，Flow也无法判断出<code class="fe mh mi mj mk b">foo</code>的类型，如下所示:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="106a" class="ml lf it mk b gy nf ng l nh ni">let foo = 1;</span><span id="2714" class="ml lf it mk b gy nj ng l nh ni">const fn = ()=&gt; {<br/>  foo = true;<br/>  foo = "foo";<br/>}</span><span id="fc62" class="ml lf it mk b gy nj ng l nh ni">fn();</span><span id="72fa" class="ml lf it mk b gy nj ng l nh ni">let str: string = foo;</span></pre><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/54e443a27a82ab905381b42c93627bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KUHaBrfPclt312d8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@caraventurera?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡拉·富勒</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="6f5a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">功能类型</h1><p id="95c7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数可以对其参数和函数的返回类型进行类型注释。</p><p id="a12c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有函数:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="3cd9" class="ml lf it mk b gy nf ng l nh ni">function add(a: number, b: number): number {<br/>  return a + b;<br/>}</span></pre><p id="97c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">a: number</code>和<code class="fe mh mi mj mk b">b: number</code>中的<code class="fe mh mi mj mk b">number</code>就是参数的数据类型，右括号后的<code class="fe mh mi mj mk b">number</code>就是函数<code class="fe mh mi mj mk b">add</code>的返回类型。</p><p id="b728" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们用类型注释了参数，当有任何东西传入时，Flow将验证类型。</p><p id="f6ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="b59d" class="ml lf it mk b gy nf ng l nh ni">add(1, 2);</span></pre><p id="fb1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么Flow将接受代码是有效的，因为我们按照函数定义中的指示传入了数字。</p><p id="73e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果我们传入任何其他类型的数据，如字符串，如下所示:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="5d92" class="ml lf it mk b gy nf ng l nh ni">add('a', 'b');</span></pre><p id="e76b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到错误:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="0425" class="ml lf it mk b gy nf ng l nh ni">[Flow] Cannot call `add` with `'b'` bound to `b` because string [1] is incompatible with number [2].</span></pre><p id="b5d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们为参数传入了字符串，这与数字不兼容。</p><h1 id="a9b1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函数语法</h1><p id="95d7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Flow的函数语法类似于JavaScript，但是向参数和返回类型添加了额外的类型注释。</p><p id="c374" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用rest操作符拥有无限数量的参数，它用<code class="fe mh mi mj mk b">...</code>操作符表示，并将超出所列参数的参数保存为一个数组。</p><p id="b8bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="4c15" class="ml lf it mk b gy nf ng l nh ni">function foo(str: string, bool?: boolean, ...nums: Array&lt;number&gt;): void {<br/>  console.log(nums);<br/>}</span><span id="96a1" class="ml lf it mk b gy nj ng l nh ni">foo('a', false, 1, 2, 3);</span></pre><p id="2225" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mh mi mj mk b">[1,2,3]</code>对应<code class="fe mh mi mj mk b">nums</code>。</p><p id="977e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果我们传入如下无效的内容:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="bfb4" class="ml lf it mk b gy nf ng l nh ni">foo('a', false, true, 2, 3);</span></pre><p id="da23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，由于我们指定<code class="fe mh mi mj mk b">...nums</code>是一个数字数组，所以我们在将<code class="fe mh mi mj mk b">true</code>传入第三个参数时会得到一个错误。</p><p id="e235" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像JavaScript一样用Flow声明变量和常量。除了JavaScript的语法，我们还可以给变量和常量添加数据类型注释。</p><p id="637b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数的语法和定义也是从JavaScript的语法扩展而来的。像变量一样，我们可以向变量添加数据类型注释，包括由rest操作符操作的变量，还可以向函数添加返回类型注释。</p></div></div>    
</body>
</html>