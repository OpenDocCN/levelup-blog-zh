<html>
<head>
<title>Features in Go You Will Like</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您会喜欢的Go功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/features-in-go-you-will-like-77b3a3a64417?source=collection_archive---------8-----------------------#2022-04-19">https://levelup.gitconnected.com/features-in-go-you-will-like-77b3a3a64417?source=collection_archive---------8-----------------------#2022-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Go中有趣的特性可能会说服你选择它作为你工具箱中的下一种语言</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7fd0102df2443b3f874bc39565d8f55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AjmT18GFRdvehoaR"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">布鲁诺·马丁斯在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="37eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Go是一种非常年轻的现代编程语言，于2009年在谷歌创立。它利用了从C等较老的流行语言中学到的经验来改进它的设计。我主要来自Python背景(也有一些Java和C)，我发现了Go中一些有趣的特性，我相信这些特性会使在Go中编写干净且可维护的代码变得更加容易。我将回顾这些特性，但有一个例外:并发编程。Go的并发模型相当独特，简单优雅。然而，由于这可能是Go最著名的功能，我将在这篇文章中省略它。</p><h1 id="25e7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Go运行时(和其他Go工具)</h1><p id="f0d7" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Go不仅仅是一套语言规范。它附带了很多工具和<em class="mf">标准</em>库:<em class="mf"> </em>最重要的是Go运行时。Go runtime是一个编译成Go二进制文件的程序，它为你做很多低级的服务，比如垃圾收集或者Go例程分配(并发支持)。对于像我这样总是害怕C/C++中容易出错的手动内存管理(或其他低级任务)的人来说，这真是一个好消息。这使得Go成为一种开发速度极快的高级语言，在运行时也非常快，带来了两个世界的最佳效果。</p><p id="f21b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Go runtime将Java虚拟机的方法向前推进了一步。Java代码被编译成一种中间语言(字节码)，你需要安装一个单独的程序(JVM)来运行字节码。然而，Go运行时被编译成Go二进制文件，产生一个可执行文件。这使得部署Go程序变得更加简单，因为不需要考虑虚拟机和程序之间的兼容性，您只需运行二进制文件。</p><p id="4648" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Go语言还附带了许多其他工具，使得Go的开发变得更加容易。一些例子是:依赖管理、测试、基准测试、覆盖、林挺和代码检查。</p><h1 id="67a0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">没有例外</h1><p id="740f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">围棋中没有像<code class="fe mg mh mi mj b">try</code>、<code class="fe mg mh mi mj b">except</code>或<code class="fe mg mh mi mj b">catch</code>这样的专用关键词。Go程序员用普通的<code class="fe mg mh mi mj b">if</code>语句和函数返回值处理错误。在Go中，函数可以返回多个值(就像许多Python程序员使用的一样，我假设函数返回一个<em class="mf">元组</em>，但这不是真的。它们只是单独的值)。如果一个函数可能失败，它应该将一个<code class="fe mg mh mi mj b">error</code>类型的值添加到它的输出值中。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="0278" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后<code class="fe mg mh mi mj b">logic</code>方法的调用者应该检查错误并处理它，将它传递到上面或停止程序:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="95dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这怎么比异常好呢？首先，这是显式的，它告诉调用者这个函数调用可能会失败(类似于Java中的<code class="fe mg mh mi mj b">throws</code>关键字)。此外，在Go中定义一个未使用的变量是一个编译时错误。因此，它迫使你明确你将如何处理函数返回的错误。除了显式性之外，它还使得代码更容易阅读。这是因为错误处理代码通常在一个<code class="fe mg mh mi mj b">if</code>块中，并且与主代码不在同一缩进层次，所以主路径和<em class="mf">“哦不！”</em>路径被很好地分开。</p><p id="1930" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Go的错误处理风格让我想起了函数式编程中使用的<code class="fe mg mh mi mj b">Either</code>数据类型(比如在<a class="ae lb" href="https://www.scala-lang.org/api/2.13.6/scala/util/Either.html" rel="noopener ugc nofollow" target="_blank"> Scala </a>或<a class="ae lb" href="https://wiki.haskell.org/Handling_errors_in_Haskell#Error_using_the_Either_type" rel="noopener ugc nofollow" target="_blank"> Haskell </a>中)来进行纯粹的<em class="mf"> </em>函数式错误处理。尽管Go的错误模型没有提供<code class="fe mg mh mi mj b">Either</code>的所有特性(例如<a class="ae lb" href="https://www.scala-lang.org/api/2.13.6/scala/util/Either.html#map[B1](f:B=%3EB1):scala.util.Either[A,B1]" rel="noopener ugc nofollow" target="_blank">这些方法</a>)，但它带来了同样的显式性和(几乎)编译时安全性的效果。(<a class="ae lb" href="https://dev.to/anthonyjoeseph/either-vs-exception-handling-3jmg" rel="noopener ugc nofollow" target="_blank">阅读更多关于vs异常的</a></p><p id="a71d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">(建议你看一下</em> <a class="ae lb" href="https://medium.com/@janek_schleicher/the-biggest-disadvantage-in-practice-is-beside-the-huge-boilerplate-is-the-poor-error-messaging-as-9b0d33a1b6b2" rel="noopener"> <em class="mf">这篇评论</em> </a> <em class="mf">关于Go的错误处理也有不好的地方)</em></p><h1 id="f08d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">延期声明</h1><p id="00fd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在很多情况下，你希望某个东西总是在函数结束时运行，比如关闭IO或者进行一些清理。在许多语言中，我们使用某种形式的条件语句(或者是<code class="fe mg mh mi mj b">if</code>语句或者是<code class="fe mg mh mi mj b">try/except/finally</code>)来处理这个问题。但是在Go中你可以使用一个<code class="fe mg mh mi mj b">defer</code>语句，它接收一个函数(或者更准确地说是一个<a class="ae lb" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank"> <em class="mf">闭包</em> </a>)，并且总是在从函数返回时最后运行它，不管它是否成功返回。让我们来看看它的实际应用:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="fa38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们要求Go在逻辑运行后关闭文件，即使我们提前返回代码的逻辑部分，或者代码<em class="mf">崩溃，它也会这样做。</em>这些是我喜欢defer而不是它的替代品的原因，比如<em class="mf">最后:</em></p><ul class=""><li id="27e9" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated"><strong class="jp ir">无缩进:</strong> defer不会创建额外的缩进层次，从而使代码更易于阅读。</li><li id="cb20" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><strong class="jp ir">无需重复:</strong>如果一个函数中有多个返回路径，处理它们会变得很棘手，通常需要复制粘贴一个代码块。使用defer，您只需提到一次清理，编译器和Go运行时就会处理它。</li><li id="5edc" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><strong class="jp ir">物理邻近性:</strong>使用defer，不需要将清理移动到函数的末尾，所以它通常紧接在资源定义之后，从而带来更好的可读性。</li><li id="16f0" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><strong class="jp ir">多个延迟:</strong>可以在一个函数中堆叠多个延迟，这样你就不需要将所有的清理打包在一起(从而失去之前的好处)</li></ul><h1 id="b7a9" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">接口:静态鸭类型</h1><blockquote class="na nb nc"><p id="9863" class="jn jo mf jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">虽然Go的并发模型得到了所有的关注，但Go设计中真正的明星是它的隐式接口。— [ <a class="ae lb" href="https://www.oreilly.com/library/view/learning-go/9781492077206/" rel="noopener ugc nofollow" target="_blank">学习围棋</a>，乔恩·博德纳</p></blockquote><p id="9448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解释这个特性，我将首先回顾软件设计中一个众所周知的原则:<strong class="jp ir">依赖倒置原则。如果你已经熟悉这个概念，你可以跳过下一部分。</strong></p><h2 id="e92d" class="ng ld iq bd le nh ni dn li nj nk dp lm jy nl nm lq kc nn no lu kg np nq ly nr bi translated">依存倒置原则</h2><p id="b9dc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这个原则可能是面向对象编程如此流行的主要原因。作为一个简单的例子，考虑像Medium这样提供付费订阅计划的服务。您肯定希望独立于当前使用的支付方式来设计订阅模块。这样你就可以切换不同的提供商，同时支持多种支付方式。标准的方法是创建一个处理支付的抽象接口，并在该接口的具体实现中完成真正的工作。(如下图所示)在像Java这样的静态类型语言中，<code class="fe mg mh mi mj b">SubscriptionManager</code>类包含一个类型为<code class="fe mg mh mi mj b">PaymentHandler</code>的字段，在运行时，像<code class="fe mg mh mi mj b">PayPalHandler </code>这样的具体实现被分配给它。注意，在运行时，是订阅包依赖<code class="fe mg mh mi mj b">PayPalHandler</code>来完成它的工作，但是从<code class="fe mg mh mi mj b">SubscriptionManager </code>到<code class="fe mg mh mi mj b">PayPalHandler.</code>没有代码依赖。代码依赖是反向的(从<em class="mf">细节</em>到<em class="mf">高级</em>)，因此名称依赖<em class="mf">反转。</em></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/7ffe185812464d200f2a6e3dac955e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRgmI8sCOduyCYRpGryUfw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">带有调用者和实现的示例接口</figcaption></figure><p id="07d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle#Implementations" rel="noopener ugc nofollow" target="_blank">一般认为</a>接口和调用者(即<code class="fe mg mh mi mj b">SubscriptionManager</code>)属于同一个组件/包，而实现(即<code class="fe mg mh mi mj b">PayPalHandler</code>)属于不同的包。这是有意义的，因为依赖于接口的是<em class="mf">调用者</em>。这里<code class="fe mg mh mi mj b">SubscriptionManager</code>高度依赖于<code class="fe mg mh mi mj b">PaymentHandler</code>接口，通过调用它的方法并期望特定的结果。然而，在接口和实现之间还有一种耦合，一种相当强的耦合形式:<em class="mf">继承</em>。因此，虽然依赖性反转提供了很大的灵活性，并且很好地将我们的订阅管理器与特定支付方法的细节分离开来，但是它有一些限制:</p><ul class=""><li id="0aca" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">切换到另一个实现需要改变<code class="fe mg mh mi mj b">SubscriptionManager</code>来使用另一个接口或者为新的实现创建一个包装器(特别是如果实现是第三方代码的话)</li><li id="9cd3" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">接口的变化会导致实现中不必要的变化(或者至少是重新编译)</li></ul><p id="2295" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在像Python这样的动态类型语言中，这种耦合是不存在的。如果一个对象具有调用者期望的方法，那么它可以被用作调用者所需的<em class="mf">接口</em>的实例(<a class="ae lb" href="https://en.wikipedia.org/wiki/Duck_typing" rel="noopener ugc nofollow" target="_blank"> duck typing </a>)。在我们的例子中，<code class="fe mg mh mi mj b">PayPalHandler</code>根本不需要知道订阅组件，应用程序的<em class="mf"> main </em>负责将<em class="mf"> right </em>对象组装到<code class="fe mg mh mi mj b">SubscriptionManager</code>这里“right”的意思是，拥有<code class="fe mg mh mi mj b">SubscriptionManager</code>期望的方法和字段。尽管这将接口从实现中分离出来，但也带来了新的挑战:</p><ul class=""><li id="e66c" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">阅读<code class="fe mg mh mi mj b">SubscriptionManager </code>时理解和遵循代码会更困难，因为你不知道它的<code class="fe mg mh mi mj b">payment_handler</code>的类型。(每当我加入一个现有的Python项目时，我都亲身经历过这一点)</li><li id="2108" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">现在，当重构<code class="fe mg mh mi mj b">SubscriptionManager</code>或<code class="fe mg mh mi mj b">PaymentHandler.</code>时，更有可能把事情弄糟，比如调用一个不存在的方法，导致运行时错误:<code class="fe mg mh mi mj b">object PaypalHandler has no attribute 'method'</code></li></ul><p id="71d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">动态语言开发人员已经利用测试驱动开发解决了这些问题。虽然TDD在防止运行时错误方面非常有效，但是可读性问题仍然存在。这可能是在Python中引入类型提示或创建类型脚本语言的一个原因。</p><p id="fd23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Go如何改善依赖倒置</strong></p><p id="f45f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">围棋试图把两个世界的最好的。接口在Go中是<em class="mf">隐式的</em>，实现一个接口不需要继承它。如果一个类型有一个接口定义的方法，它<em class="mf">实现</em>那个接口(并且被编译器认为是那个接口的一个实例)，即使它不知道那个接口存在。事实上，继承在Go中根本不存在，结构化子类型是Go提供的唯一子类型形式。让我们看看我们的订阅示例。首先从打电话者的角度来看:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="8059" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它定义并使用接口。从实施<em class="mf">的</em>来看:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="dc40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，在实现代码中没有引用<code class="fe mg mh mi mj b">PaymentHandler</code>接口。然而，因为类型<code class="fe mg mh mi mj b">PaypalHandler</code>具有接口中描述的方法，编译器认为它是<code class="fe mg mh mi mj b">PaymentHandler.</code>的一个实例，这完全类似于鸭子类型，只是</p><ul class=""><li id="edad" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">您确切地知道您的支付处理程序公开了什么方法，因此您可以更容易地更改代码。</li><li id="518a" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">如果对象公开了具有所需签名的方法，则进行编译时检查</li><li id="7478" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">接口分离原则</a>是自动实现的，因为<em class="mf">用户</em>代码只依赖于它定义的接口，并不知道实现的其他方法。</li><li id="da14" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">如果第三方代码已经适合你期望的接口，就没有必要把它包装在一个继承你接口的对象中。您可以将它用作该接口的一个实例。</li></ul><h2 id="387a" class="ng ld iq bd le nh ni dn li nj nk dp lm jy nl nm lq kc nn no lu kg np nq ly nr bi translated">Pythonic式的做法是</h2><p id="8268" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">让我们绕一小段路，看看Python对这个问题的解决方案。从3.5版本开始，Python支持<strong class="jp ir">类型提示</strong>以在代码中提供文档，使理解或重构Python代码变得更加容易。再次考虑订阅示例。我们想用支付处理程序初始化<code class="fe mg mh mi mj b">SubscriptionManager</code>对象。我们应该在下面的代码中使用什么作为<code class="fe mg mh mi mj b">HandlerTyep</code>？</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="db3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我在Python项目中主要看到了两种具有上述缺点的解决方案(即定义一个抽象基类或使用一个<a class="ae lb" href="https://docs.python.org/3/library/typing.html#typing.Union" rel="noopener ugc nofollow" target="_blank">联合</a>类型)，但是<strong class="jp ir">静态鸭类型</strong>在Python中也确实存在(3.8以上版本)。<a class="ae lb" href="https://docs.python.org/3/library/typing.html#typing.Protocol" rel="noopener ugc nofollow" target="_blank">协议</a>是描述你期望从一个对象得到什么方法和/或字段的数据类型。因此，我们可以为支付处理程序定义一个协议，并将其用作上面代码中的<code class="fe mg mh mi mj b">HandlerType</code>。(参见示例<a class="ae lb" href="https://www.daan.fyi/writings/python-protocols" rel="noopener ugc nofollow" target="_blank">此处</a>。这个<a class="ae lb" href="https://www.python.org/dev/peps/pep-0544/#rejected" rel="noopener ugc nofollow" target="_blank"> PEP </a>更详细地描述了这个方法，并将其与Go的方法进行了比较</p><h1 id="01f3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="0e10" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">考虑到它只有大约十年的历史，围棋<a class="ae lb" href="https://insights.stackoverflow.com/survey/2021#most-popular-technologies-language-prof" rel="noopener ugc nofollow" target="_blank">在程序员中已经变得相当流行</a>。像Docker、Kubernetes和Prometheus等云世界中一些最流行的技术都是用Go编写的。所以如果你想在你的工具箱里增加一个新工具，Go可能是一个不错的选择。尤其是如果你最习惯于Python或Ruby这样的解释型动态语言，Go可以让你的工具箱多样化，成为一种编译型的静态语言，运行速度更快，并具有强大的并发支持。有了多个可用选项，您可以为每个任务和项目选择最合适的工具。</p><p id="9a95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，即使你没有用一门新的语言编写很多代码，我相信你在这门语言中学到的新概念和新模式可以帮助你用其他语言更好地编写代码。</p><h2 id="e5d5" class="ng ld iq bd le nh ni dn li nj nk dp lm jy nl nm lq kc nn no lu kg np nq ly nr bi translated">参考</h2><p id="3391" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我在学习围棋时使用的主要资源是Jon Bodner的伟大著作:<a class="ae lb" href="https://www.oreilly.com/library/view/learning-go/9781492077206/" rel="noopener ugc nofollow" target="_blank">学习围棋</a>。我强烈推荐这本书。我也主要是从马丁的书和演讲中了解到依赖倒置的<a class="ae lb" href="http://cleancoder.com/" rel="noopener ugc nofollow" target="_blank">罗伯特</a> <a class="ae lb" href="http://cleancoder.com/" rel="noopener ugc nofollow" target="_blank">【鲍勃叔叔】</a> <a class="ae lb" href="http://cleancoder.com/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>