<html>
<head>
<title>How git revert works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">git还原如何工作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-git-revert-works-9b87b8b03dd3?source=collection_archive---------5-----------------------#2020-05-28">https://levelup.gitconnected.com/how-git-revert-works-9b87b8b03dd3?source=collection_archive---------5-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e625b227c3d402dd40735f43baca9bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpIuDaFu1W9MWzt2FuHeiA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">git还原如何工作</figcaption></figure><p id="5304" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">git revert</code>命令用于“撤销”您过去所做的更改。简单。但是与其他撤销命令不同，git revert将引入一个新的提交，它具有相反的更改。</p><p id="cc81" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，考虑下面的git历史。</p><p id="6d89" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设“E”是错误的提交，您不再需要这些更改。所以你决定撤销E所做的改变。您已经决定使用git revert。</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="280a" class="lp lq it lg b gy lr ls l lt lu">git revert E</span></pre><p id="5ca3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">git revert将总是接受一个提交散列。因此，您需要传递您需要恢复的提交。</p><p id="e228" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在恢复E之后，提交历史将被更改如下。</p><p id="380a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“e”是还原的提交。“E”将包含E的还原更改。但是您可以看到，在git历史记录中，提交E也存在。并且E所做的更改不再出现在工作目录中。</p><p id="5ce8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是git revert的优势之一。在这种情况下，git历史非常清晰，每个阅读git历史的人都会理解特定的提交由于某种原因已经恢复。</p><h2 id="eb24" class="lp lq it bd lv lw lx dn ly lz ma dp mb kq mc md me ku mf mg mh ky mi mj mk ml bi translated">如何进行git还原</h2><p id="184b" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">如前所述，git revert将接受一个提交散列。</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/f0e9ec73a511195e770892335988c6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/0*4ruSMkWf5bzNWZN1.png"/></div></figure><p id="20f8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在上图中，您可以看到提交历史。见头部提交(最新提交)。我已经添加了一个文件‘three . txt’。现在让我们尝试恢复提交。</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/1a91e7693a6b249dcbb6803c3ca5dbb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*6meAr304eGj47mV4.png"/></div></figure><p id="d6ed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我已经恢复了上图中的头部提交。您可以看到Git试图反转由HEAD commit所做的更改，并删除了由HEAD commit创建的文件。</p><p id="3e32" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在看看git的历史是如何变化的</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2eafdb7d0bfb534ad78f4e32102d3720.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/0*va339XpaS7OJyAhQ.png"/></div></figure><p id="d0a5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以看到新的提交引入了解释它恢复了以前的提交。</p><h2 id="eaec" class="lp lq it bd lv lw lx dn ly lz ma dp mb kq mc md me ku mf mg mh ky mi mj mk ml bi translated">git还原-n</h2><p id="637d" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">当您恢复提交时，有时您不需要Git来为您执行提交。您可能需要检查Git恢复的更改，然后自己提交。</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/bc5e619f95609383a84b3dfdc47c53d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nEQGBnzBwGLkLs20.png"/></div></div></figure><p id="2e20" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在上面的例子中，你可以看到我用-n选项进行了恢复。所以Git恢复了更改，但是没有提交更改。它刚刚暂存了所有恢复的更改。您可以检查这些更改并自己提交它们。</p><h2 id="e2d6" class="lp lq it bd lv lw lx dn ly lz ma dp mb kq mc md me ku mf mg mh ky mi mj mk ml bi translated">还原一系列提交</h2><p id="f468" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">恢复一系列提交总是很方便的。</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="2936" class="lp lq it lg b gy lr ls l lt lu">git revert A..B</span></pre><p id="14f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">a和B是提交散列。上述命令将把提交从<strong class="kh iu"> A </strong>恢复到<strong class="kh iu"> B </strong>。并且记住<strong class="kh iu"> A应该比B大</strong>。</p><h2 id="790a" class="lp lq it bd lv lw lx dn ly lz ma dp mb kq mc md me ku mf mg mh ky mi mj mk ml bi translated">还原合并提交</h2><p id="88e0" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">恢复合并提交有些棘手。当合并时，包含两个分支。父B分支被合并到父A分支中。</p><p id="2097" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，当您恢复合并提交时，您必须指定您是否需要恢复父-A分支或父-B分支的更改。</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="01de" class="lp lq it lg b gy lr ls l lt lu">A - B - C - E - F (branch A)<br/>     \     /<br/>      G - H - I (branch B)</span></pre><p id="4e65" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在上面的例子中，<strong class="kh iu"> E </strong>是合并提交。如果你运行<strong class="kh iu"> git revert E </strong>，那么git将抛出一个警告。你必须提到母分公司的号码。</p><p id="b075" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你能做到</p><p id="72ab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将从合并分支中还原所有提交。因此来自<strong class="kh iu"> G — H </strong>的变化被恢复。所以git历史将会是这样的</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="af11" class="lp lq it lg b gy lr ls l lt lu">A - B - C - E - F - E' (branch A)</span></pre><p id="f4f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“e”是还原的合并提交。</p><p id="00c9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">恢复合并提交意味着您正在反转来自合并分支的所有更改，以便您不能再次合并该分支。如果需要合并回分支，您必须恢复“恢复提交”。</p><p id="999c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在上面的例子中，你不能再次将分支B合并到分支A。因为它在E '中被还原。</p><p id="c30d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设有时，你已经对分支B做了一些改变，现在你可以合并那个分支了。为此，您必须恢复“恢复提交”。</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="cbe9" class="lp lq it lg b gy lr ls l lt lu">git revert E'</span></pre><p id="e962" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上述命令将恢复E' commit。现在你可以把分支B合并到分支a。</p><p id="3ce9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，git历史将看起来像这样</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="c031" class="lp lq it lg b gy lr ls l lt lu">A - B - C - E - F - E' - E'' (branch A)</span></pre><p id="bce8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">E ' '是E '的还原</p><h2 id="6340" class="lp lq it bd lv lw lx dn ly lz ma dp mb kq mc md me ku mf mg mh ky mi mj mk ml bi translated">在Github和Gitlab中恢复拉请求</h2><p id="5ecd" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">在Github中，你可能已经注意到了一个恢复拉取请求的选项。</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/13263f1a310a0d46818643573203b709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tzatwGKpbR-bXkud.png"/></div></div></figure><p id="d92f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您必须回复合并的提取请求，您可以使用此选项。</p><p id="a955" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设您已经恢复了拉取请求(PR)。</p><p id="a4ec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在是棘手的部分。出于某种原因，你必须再次合并分支。您可能在分支中也有一些更新的提交。</p><p id="bd0b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您再次对分支进行拉请求，您可以看到没有要合并的变更。因为反向的更改已经存在于当前分支中，所以Git不会显示任何要合并的更改。</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/e80298bc5cf72840ad5a9b420d9ebb7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/0*jCusrFFM945GPRIt.png"/></div></figure><p id="f0ae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在上面的图像中，您可以看到我们已经合并了pull请求，然后恢复了合并的pull请求。</p><p id="15bb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如前所述，现在要再次合并分支，您必须恢复“恢复提交”。做这件事有两种选择。</p><p id="27f9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一，可以直接在Github本身做。当您恢复PR时，Github将创建一个包含反向变更的分支，并为这些变更创建一个PR。</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/4c574901238fd10a3f4f5aade6ae13f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_tkrWXkWfpARaSj8.png"/></div></div></figure><p id="a656" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在上面的图片中，你可以看到Github已经创建了一个新的分支<strong class="kh iu">revert-1-feature/git-revert</strong>，并且PR已经被合并以恢复更改。</p><p id="2205" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，您可以再次从“恢复分支”恢复更改。简单。因此，您已经恢复了恢复的更改:P. Github使任务变得简单。</p><p id="2fa3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">还有另一种方法。您可以在本地恢复“恢复提交”并推送它。请参考上面的提交历史。</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="2298" class="lp lq it lg b gy lr ls l lt lu">git revert -m 1 51de56e7bfe319e4ba670b2743eb135af0988fb3</span></pre><p id="56fc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这与恢复PR是一样的。Git将只添加另一个revert commit，然后可以推送它。</p><p id="bdc5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">恢复是一个非常有用的工具，可以“撤销”分支中的更改。这不会影响历史，每个人都可以理解已经做了什么。</p><h2 id="cf6a" class="lp lq it bd lv lw lx dn ly lz ma dp mb kq mc md me ku mf mg mh ky mi mj mk ml bi translated">要记住的要点</h2><ol class=""><li id="7762" class="my mz it kh b ki mm km mn kq na ku nb ky nc lc nd ne nf ng bi translated"><strong class="kh iu">git revert&lt;commit-hash&gt;</strong></li><li id="df9a" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated"><strong class="kh iu"> git回复..B </strong>恢复一系列提交。a应该比B大</li><li id="a434" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated"><strong class="kh iu">git revert-n&lt;commit-hash&gt;</strong>恢复提交，并在不提交的情况下暂存所有这些更改。</li><li id="2660" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated"><strong class="kh iu">git revert-m&lt;parent-branch&gt;&lt;commit-hash&gt;</strong>恢复合并提交。请记住，您必须以1或2的形式提及母公司分支机构编号</li><li id="d92a" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated">Github之类的Git托管平台有一个选项来恢复PR本身。你可以明智地使用它。</li></ol><p id="5aaf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您有任何疑问、反馈或任何事情，您可以留下评论。</p><p id="7b8c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你需要我涵盖一些特定的主题，你可以告诉我。:)</p><p id="e085" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">你可以在这里找到我的其他git相关文章</strong></p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="f730" class="lp lq it lg b gy lr ls l lt lu">1. <a class="ae nm" rel="noopener ugc nofollow" target="_blank" href="/what-is-git-cherry-pick-and-how-to-use-it-effectively-665247192442">How git cherry-pick works and how to use it effectively</a></span><span id="ed30" class="lp lq it lg b gy nn ls l lt lu">2. <a class="ae nm" rel="noopener ugc nofollow" target="_blank" href="/automate-repetitive-tasks-with-custom-git-commands-76a4b71d262f">Automate repetitive tasks in Git</a></span><span id="5b00" class="lp lq it lg b gy nn ls l lt lu">3. <a class="ae nm" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-git-fetch-and-git-pull-effectively-c6a4becfbc16">Useful tricks of git fetch and git pull</a></span><span id="4aea" class="lp lq it lg b gy nn ls l lt lu">4. <a class="ae nm" href="https://medium.com/@srebalaji/a-very-basic-intro-of-git-b9cab0e64153" rel="noopener">A very basic intro of Git</a></span></pre><p id="d6c4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">本帖原载于我的简讯</strong><a class="ae nm" href="https://gitbetter.substack.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu">GitBetter</strong></a><strong class="kh iu">。如果你已经来了这么久，那么我想你会对Git非常感兴趣。可以订阅</strong><a class="ae nm" href="https://gitbetter.substack.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu">Git better</strong></a><strong class="kh iu">获取Git的招数、技巧、高级话题。</strong></p></div></div>    
</body>
</html>