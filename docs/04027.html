<html>
<head>
<title>Anatomy of a WebRTC video conference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebRTC视频会议剖析</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/anatomy-of-a-webrtc-video-conference-f924ba0ba930?source=collection_archive---------2-----------------------#2020-06-06">https://levelup.gitconnected.com/anatomy-of-a-webrtc-video-conference-f924ba0ba930?source=collection_archive---------2-----------------------#2020-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f684" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着社交距离的拉近，我们大多数人在过去几周都参加了很多视频会议。无论您使用的是Jitsi、Big Blue Button还是某个商业项目的基于浏览器的界面，您都可能一直在使用WebRTC标准。当然，除了传统的视频会议，你还可以利用WebRTC引入的技术做更多的事情。你可以在协作应用中使用它作为WebSockets的替代品，在你的游戏中添加多人游戏(无论是一个小型的<a class="ae ko" href="https://github.com/innovailable/rtc-bomber/" rel="noopener ugc nofollow" target="_blank">炸弹人风格的技术演示</a>，还是一个<a class="ae ko" href="https://firefoxmania.uci.cu/common/dev_files/demos/bananabread/index.html" rel="noopener ugc nofollow" target="_blank">自我射击游戏在你的浏览器中的端口</a>，或者<a class="ae ko" href="https://andrei.codes/ascii-camera/" rel="noopener ugc nofollow" target="_blank">把你的相机变成ASCII艺术</a>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/6849cda9a41f8cea291a3fb8ca62e7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ZmoALpPUfjbakRJ_-8vmCw.png"/></div></figure><p id="c172" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我是一个新的<a class="ae ko" href="https://github.com/Innovailable/vorb.chat" rel="noopener ugc nofollow" target="_blank">开源</a>点对点视频会议应用程序<a class="ae ko" href="https://vorb.chat/" rel="noopener ugc nofollow" target="_blank"> vorb.chat </a>的开发者之一，我想向您介绍一下在使用这些平台时会发生什么。我将尝试让您对所有相关技术有一个基本的了解，从集成在浏览器中的新API到帮助WebRTC启动其独特连接的服务器和协议。最后，我将通过展示几行代码来创建一个最小的视频会议应用程序。</p><h1 id="62ea" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">浏览器API</h1><p id="cb92" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">WebRTC最重要的部分是在我们的浏览器中引入了一些新的API。其中一些，如访问用户的麦克风和摄像头，是专门为视频会议设计的，而其他一些则是改善音频和视频处理的更广泛努力的一部分。</p><p id="f4f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数开发人员在试用WebRTC时首先会遇到的是<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia" rel="noopener ugc nofollow" target="_blank"> getUserMedia() </a>。该功能用于获取用户麦克风和/或摄像头的<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream" rel="noopener ugc nofollow" target="_blank">媒体流</a>。当请求流请求更高的分辨率时，您可以指定一些约束，或者让用户选择要使用的特定摄像头和麦克风(要获得可用设备的列表，请参见<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices" rel="noopener ugc nofollow" target="_blank">enumerated devices()</a>)。浏览器通过在授予访问权限之前询问用户的许可来确保该功能不被利用。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="f4d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://jsfiddle.net/thammi/wskh0eq9/" rel="noopener ugc nofollow" target="_blank">在JSFiddle上试试</a></p><p id="2bad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您既可以通过将流附加到一个<video>标签来本地显示它，也可以将它添加到一个<a class="ae ko" href="https://developer.mozilla.org/de/docs/Web/API/RTCPeerConnection" rel="noopener ugc nofollow" target="_blank"> RTCPeerConnection </a>中，以便将它发送给其他用户。这种对等连接是WebRTC标准的第二大部分。它建立了一个为实时连接而优化的连接(例如通过使用基于UDP的传输协议)，并且总是使用<a class="ae ko" href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank"> DTLS </a>进行端到端加密(基本上是UDP上的TLS)。</video></p><p id="78f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以将您的流(或者更具体地说，将流的曲目)添加到对等连接，并且一旦连接建立，将从另一个对等方接收曲目。更复杂的场景，如动态添加屏幕共享或更改使用的摄像头，将需要使用<a class="ae ko" href="https://developer.mozilla.org/de/docs/Web/API/RTCRtpTransceiver" rel="noopener ugc nofollow" target="_blank">收发器</a>。WebRTC库可以为您处理这些复杂性。</p><h1 id="4f3e" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">建立连接</h1><p id="a3bd" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">但是这种联系是如何建立的呢？同行是怎么找到对方的？对等体必须交换一些信令消息，这些消息包含关于将被发送和接收的媒体轨道的信息、支持的编解码器以及关于网络的一些信息。</p><p id="9757" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">信令消息中的数据使用SDP进行编码(<a class="ae ko" href="https://en.wikipedia.org/wiki/Session_Description_Protocol" rel="noopener ugc nofollow" target="_blank">会话描述协议</a>)。这是我们大多数人日常在IP语音电话中使用的一种成熟的协议。这是一个只有一个音轨的例子:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5ede" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要担心，除非您想做一些非常高级的事情或调试对等连接的内部，否则您不必了解这些。</p><p id="51f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">标准本身并没有具体说明这些消息是如何传输的，但这通常是通过WebSocket来完成的。有为WebRTC和视频会议构建的信令服务器。其中大多数使用命名房间的抽象，客户端可以加入这些房间来找到其他对等点并与它们交换消息。您还可以使用任何其他方法在客户端之间传递这些消息。</p><p id="0528" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在交换这些信令消息之后(一个客户端创建提议，另一个客户端应答)，浏览器将知道两个客户端都支持哪种编解码器和哪种设置。他们将开始尝试使用传输的网络信息建立连接。</p><h1 id="b5ea" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">通过防火墙和NAT连接</h1><p id="96d9" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">最简单的连接场景是两个客户端都在同一个本地网络中。两个客户端总是通过信令信道发送所有已知的IP地址，并将尝试连接到每个对等体的地址。但当然，这在大多数情况下不会成功。</p><p id="fea7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更常见的是客户端通过互联网连接。这里的问题是，设备通常在单个路由器后面共享同一个公共IP地址。因此，传出数据通常会使用与最初发送时不同的端口，更重要的是，如果不创建手动端口转发，传入连接就无法连接到正确的设备。</p><p id="fd3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一个客户端直接连接到互联网(让我们称她为Alice ),而另一个客户端通过路由器连接(让我们称他为Bob ),我们仍然可以创建连接。Bob通过路由器向Alice发送了一个数据包(这可能会更改传出端口)。Alice将简单地回答她接收数据的地址和端口。Bob的路由器将收到该答案，并将其转发给Bob，因为它记得以前通过该端口发送过Bob的数据。现在，两个客户端都可以发送和接收数据。</p><p id="8f63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果两个客户端都藏在路由器后面呢？在这个场景中，WebRTC使用STUN ( <a class="ae ko" href="https://en.wikipedia.org/wiki/STUN" rel="noopener ugc nofollow" target="_blank">用于NAT </a>的会话遍历实用程序)协议进行连接。两个客户端都向STUN服务器发送一个UDP包，STUN服务器发送接收包的IP地址和端口作为响应。</p><p id="8d31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了了解我们如何使用这些信息，让我们在这些条件下再看一遍Alice和Bob的例子。Alice通过信令信道将她的地址信息发送给Bob。Bob然后尝试使用给定的IP地址和端口启动连接。使用相同的端口很重要，因为Alice的路由器(希望)会记住它使用该公共端口发送了一个UDP数据包(即使它发送到不同的地址),并将该数据包转发给Alice。然后，Alice可以简单地响应该包，我们就有了一个开放的连接。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/88ee3df11aecfd304d402f1c49c19502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrXclKuBwVMlkvYsu5qkMw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">穿孔对等连接</figcaption></figure><p id="798d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果所有这些都失败了，还有最后一个选择，那就是使用NAT 服务器周围的中继进行<a class="ae ko" href="https://en.wikipedia.org/wiki/Traversal_Using_Relays_around_NAT" rel="noopener ugc nofollow" target="_blank">遍历。因为这个服务器有一个公共IP地址，所以每个人都可以访问它。Alice连接到TURN服务器并转发关于如何连接Bob的信息。Bob连接后，所有流量都可以通过服务器进行路由。数据甚至可以通过TLS加密的TCP连接进行隧道传输，以欺骗最偏执的网络管理员。当然，这是以更高的延迟(尤其是使用TCP时)为代价的，并且会在服务器上产生大量流量。</a></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/54ab303fd1ff03fa8602ff1558ba3794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ed9CtD9Sq2_FyML4zwqt_g.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">对等连接通过TURN隧道传输</figcaption></figure><p id="f7f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">浏览器将浏览所有这些选项，这些选项按照预期的连接执行情况进行排序。整个过程被称为ICE ( <a class="ae ko" href="https://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment" rel="noopener ugc nofollow" target="_blank">交互连接建立</a>)，开源项目<a class="ae ko" href="https://github.com/coturn/coturn" rel="noopener ugc nofollow" target="_blank"> coturn </a>为这两种协议提供了一个服务器。</p><h1 id="83e4" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">总是点对点？</h1><p id="e0d8" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">我一直在谈论对等连接，那么每个WebRTC应用程序都是对等的吗？对等连接只是由WebRTC标准引入的概念，如何使用它取决于您自己。对等连接可以用于创建实际的对等应用程序，也可以连接到中间服务器。</p><p id="52eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当连接多个带宽有限的参与者时，这些服务器会很有用。当你创建一个基于点对点的应用程序时，所有的客户端都连接到所有其他的客户端，并且必须向每个客户端发送所有的数据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ml"><img src="../Images/87c9f89cab80aee237a87379e040d428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfJjWiGUMFRpKX8BRg9gpw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">对等会议</figcaption></figure><p id="7b97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">媒体服务器可以限制WebRTC应用程序用户的带宽要求。所有客户端都连接到媒体服务器，而不是创建直接连接。它们只需发送一次数据，媒体服务器就会将数据分发给所有对等体。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mm"><img src="../Images/3feb65ec20fef93fbb492fa0a0293ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIm26AfeuOIEziM_Ta3_vQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">使用媒体服务器的会议</figcaption></figure><p id="5af9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，这种解决方案也有缺点。由于对等连接的工作方式，对等WebRTC应用程序将始终是端到端加密的。另一方面，媒体服务器将不得不解密对等连接，因此可以访问你的数据(尽管有努力<a class="ae ko" href="https://jitsi.org/blog/e2ee/" rel="noopener ugc nofollow" target="_blank">克服这个限制</a>)。</p><p id="71e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">媒体服务器的另一个缺点是基础设施成本。使用对等连接，流量将在对等体之间直接交换，您的基础设施将只使用非常有限的资源。媒体服务器将使用大量流量，根据媒体服务器的类型，还可能使用大量CPU。</p><p id="9fee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用媒体服务器的视频会议应用程序的例子有<a class="ae ko" href="https://jitsi.org/jitsi-meet/" rel="noopener ugc nofollow" target="_blank"> Jitsi Meet </a>和<a class="ae ko" href="https://bigbluebutton.org/" rel="noopener ugc nofollow" target="_blank">蓝色大按钮</a>，而我们自己的<a class="ae ko" href="https://vorb.chat/" rel="noopener ugc nofollow" target="_blank"> vorb.chat </a>是一个对等应用程序的例子。</p><h1 id="59df" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">把所有的放在一起</h1><p id="9cb3" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">在这最后一部分，我想展示一个WebRTC应用程序可以有多简单。我们将使用<a class="ae ko" href="https://github.com/Innovailable/rtc-lib" rel="noopener ugc nofollow" target="_blank"> rtc-lib </a>来做一些繁重的信令和流处理工作。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="f594" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://jsfiddle.net/thammi/eLrxozfd" rel="noopener ugc nofollow" target="_blank">在JSFiddle上试试</a></p><p id="f780" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该代码实现了一个完整的视频会议应用程序。使用相同的房间名称在多个选项卡或多个设备上打开它，您将被连接。对于更复杂的应用程序，您可能希望使用React或Vue来代替JQuery。</p><h1 id="3860" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">下一步是什么？</h1><p id="e66d" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">WebRTC的内容远远超出了本文的范围。数据通道就是一个例子，它允许您通过对等连接发送自定义数据。这可以用于在视频会议中添加文本聊天和文件传输，但也可以在完全不同的环境中用于点对点文件共享或为浏览器游戏添加多人支持。</p><p id="a1e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将在以后的文章中探索WebRTC的其他部分。同时，这里有一些有趣的资源:</p><ul class=""><li id="d38f" class="mn mo it js b jt ju jx jy kb mp kf mq kj mr kn ms mt mu mv bi translated"><a class="ae ko" href="https://webrtc.github.io/samples/" rel="noopener ugc nofollow" target="_blank"> WebRTC示例</a>:低级示例的集合</li><li id="fb03" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated"><a class="ae ko" href="https://bloggeek.me/blog/" rel="noopener ugc nofollow" target="_blank">博客极客</a>:关于WebRTC基础设施和标准的有趣文章</li><li id="bb07" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated"><a class="ae ko" href="https://webrtchacks.com/" rel="noopener ugc nofollow" target="_blank"> WebRTC黑客</a> : WebRTC新闻和演示</li></ul><p id="ea2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读。如果您有任何反馈或问题，请在下面留下，我希望在下一篇文章中再次见到您！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><div class="kq kr ks kt gt ni"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">编写面试问题</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">技术开发</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kv ni"/></div></div></a></div></div></div>    
</body>
</html>