<html>
<head>
<title>Stacks: Data Structures in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">栈:JavaScript中的数据结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/stacks-data-structures-in-javascript-106ecc0e147e?source=collection_archive---------10-----------------------#2020-11-24">https://levelup.gitconnected.com/stacks-data-structures-in-javascript-106ecc0e147e?source=collection_archive---------10-----------------------#2020-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9cad7f6283c061f095e6625dda77135b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5e_xZwbBestkxl14XuVrg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">戴夫·古德洛在T2 Unsplash网站上拍了一张美丽的照片</figcaption></figure><p id="cc31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">栈</strong>和<strong class="ki iu">队列</strong>是众多原始数据结构中的一种。当你想学习数据结构时，这是一个很好的起点。在本文中，我们将讨论栈，它们的实际实现，当然还有JavaScript语言中的实现。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="581d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">堆栈是动态集合，其中通过<strong class="ki iu">删除</strong>操作从集合中删除的元素是预先指定的。在堆栈中，从集合中删除的元素是最近插入的元素:堆栈执行后进先出或<strong class="ki iu"> LIFO </strong>策略。你可以把一堆看作是我们喜欢的薯片的容器，就像品客薯片或薯条一样。</p><p id="2192" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你在生产中往容器里装满薯片时，你是从最后一个放入容器的薯片开始吃，而不是第一个。这是现实生活中许多LIFO政策或stack政策的例子之一。你也可以想到饼干或硬币，放在对方身上。</p><p id="9ce7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们假设我们有n个元素。</p><p id="ac78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最初堆栈有一个top参数。顶部显示了最后一个元素在堆栈中的位置。</p><figure class="lm ln lo lp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ll"><img src="../Images/c5acd75b00146a8ac5d54cc60e9700e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skUlwyLNVHVUpb_t7nhKTw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">堆</figcaption></figure><p id="5037" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我们的栈顶是6，因为第6个元素是栈的最后一个元素。如果我们没有9，那么堆栈的顶部将是5(第5个元素是堆栈的最后一个元素)。当我们试图将一个元素添加到一个已满的堆栈中时，就会发生堆栈溢出。但是当我们试图从一个空堆栈中弹出一个元素时，就会发生堆栈下溢。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="d393" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当栈中有n个元素时，栈就满了，就像我们的例子一样。让我们开始创建一个堆栈。</p><h1 id="f030" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">初始化堆栈</h1><p id="22db" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">首先，你应该初始化你的堆栈。堆栈逻辑对3个主要参数起作用。</p><figure class="lm ln lo lp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/7a7fef9aa82693c0193a3746e49405ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IiQmWVHv_WAOfwLn9qSDVA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用类初始化堆栈</figcaption></figure><ol class=""><li id="eda7" class="mu mv it ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated">堆栈本身(this.stackList)</li><li id="5080" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">堆栈的最大长度(this.maxLength，可选)</li><li id="f5d8" class="mu mv it ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">栈顶(this.topIndex)</li></ol></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="bf56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">栈的主要操作是<em class="ni">空栈检查</em>、<em class="ni">推送</em>和<em class="ni">弹出</em>操作。</p><h1 id="2f31" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">空栈</h1><p id="dd4a" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">空堆栈操作检查堆栈是否为空。</p><figure class="lm ln lo lp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/4b87fa9e5d2eb8f6fa91c31dd71ebb42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWkFF1ogH6iLKxHlbgl1RQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">堆栈中的emptyStack操作</figcaption></figure><h1 id="b65b" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">推</h1><p id="a13d" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">Push操作在堆栈末尾添加一个元素。</p><figure class="lm ln lo lp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/fb867b55ee73c5bfe93f36c470ff2a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OnJ3R_Sa3tKhIU38-nplFg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">堆栈中的推送操作</figcaption></figure><h1 id="85a0" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">流行音乐</h1><p id="ed28" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">弹出操作弹出(移除)堆栈的最后一个元素。</p><figure class="lm ln lo lp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/7503c3a9a5d4ff2f5d939a7c4c2faa11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vhs2RiioPL1ODJnzsEWVw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">堆栈中的弹出操作</figcaption></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="65e1" class="lq lr it bd ls lt nm lv lw lx nn lz ma mb no md me mf np mh mi mj nq ml mm mn bi translated">附件</h1><p id="a126" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我还添加了一些其他的帮助方法(操作),这样用户可以获得更多关于他的栈的信息。</p><h2 id="3059" class="nr lr it bd ls ns nt dn lw nu nv dp ma kr nw nx me kv ny nz mi kz oa ob mm oc bi translated">检查堆栈的长度</h2><figure class="lm ln lo lp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/6f3ec4c3a67e9cb178d09859b7add7d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipttMxJYpwjUIuqeo1oXDw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">堆栈长度获取方法</figcaption></figure><h2 id="d4a0" class="nr lr it bd ls ns nt dn lw nu nv dp ma kr nw nx me kv ny nz mi kz oa ob mm oc bi translated">检查堆栈本身</h2><figure class="lm ln lo lp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/d6c592756cfd96c1f8681d1d27fd708b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hqQV0qF6A6_tOVIyfh77Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">堆叠吸气方法</figcaption></figure><h2 id="ed48" class="nr lr it bd ls ns nt dn lw nu nv dp ma kr nw nx me kv ny nz mi kz oa ob mm oc bi translated">检查堆栈的顶部参数</h2><figure class="lm ln lo lp gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/c9883be4f00ca6e1a83a2c0163762225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*2aIHglTco5COBU5RpaRIUw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">栈顶吸气剂法</figcaption></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="bf01" class="lq lr it bd ls lt nm lv lw lx nn lz ma mb no md me mf np mh mi mj nq ml mm mn bi translated">摘要</h1><p id="5b06" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">最后我们得到了什么？我们有一个堆栈，它类似于一个带有push、pop和length方法的数组，但是在内存使用方面有更多的功能和效率。</p><p id="b5de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为我们将涉及的下一个数据结构是<strong class="ki iu">队列</strong>数据结构，它有更多有趣的逻辑。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="9209" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，你可以找到完整的代码通过导航<a class="ae kf" href="https://github.com/danomov/DataStructuresAndAlgorithmImplementations" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="8398" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，我们很快会再见的🤟</p><blockquote class="og oh oi"><p id="76c0" class="kg kh ni ki b kj kk kl km kn ko kp kq oj ks kt ku ok kw kx ky ol la lb lc ld im bi translated">我讲述的其他数据结构主题:</p><p id="7dc1" class="kg kh ni ki b kj kk kl km kn ko kp kq oj ks kt ku ok kw kx ky ol la lb lc ld im bi translated"><a class="ae kf" href="https://link.medium.com/hu38fRRvAbb" rel="noopener">单链表</a></p><p id="1afa" class="kg kh ni ki b kj kk kl km kn ko kp kq oj ks kt ku ok kw kx ky ol la lb lc ld im bi translated"><a class="ae kf" href="https://link.medium.com/z8tBxNIvAbb" rel="noopener"> LRU缓存</a></p></blockquote></div></div>    
</body>
</html>