<html>
<head>
<title>How to Create a Web Application with Node.js and Vue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js和Vue创建Web应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vue-node-web-application-59d3376e403e?source=collection_archive---------3-----------------------#2021-10-11">https://levelup.gitconnected.com/vue-node-web-application-59d3376e403e?source=collection_archive---------3-----------------------#2021-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3efb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何实现一个自包含的应用程序，它有一个节点后端和一个Vue前端</h2></div><p id="57c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js是一个非常灵活的解决方案，用于多种目的，从构建角度应用程序到实现实时应用程序。因为它被用于所有的Javascript项目，所以这种技术也作为一个API平台正在传播。</p><p id="dcab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将学习如何设置首次使用的<a class="le lf ep" href="https://medium.com/u/96cd9a1fb56?source=post_page-----59d3376e403e--------------------------------" rel="noopener" target="_blank"> Node.js </a>应用程序，以及如何在其上嵌入一个实现简单<a class="le lf ep" href="https://medium.com/u/9b930cf6db26?source=post_page-----59d3376e403e--------------------------------" rel="noopener" target="_blank"> Vue.js </a>应用程序的用户界面。</p><p id="f3fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有的源代码都可以在GitHub上找到(文章底部的链接)。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/a087f7b265c4f7f426312b3f44e953cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-cfIoocDFpGYNmt7"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">由<a class="ae lw" href="https://unsplash.com/@maxcodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">麦克斯韦·纳尔逊</a>在<a class="ae lw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="bb95" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">应用程序设置</h1><p id="44d1" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">第一步是安装所有的必备组件。如果本地没有，可以用一个简单的命令安装Node.js和Npm</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="ccce" class="mz ly it mv b gy na nb l nc nd">choco install nodejs #on windows<br/>apt install nodejs npm # on ubuntu</span></pre><p id="e546" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装完成后，您可以通过键入以下命令来检查安装的版本:</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="f673" class="mz ly it mv b gy na nb l nc nd">node -v<br/>npm -v</span></pre><p id="383c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在angular已经安装好了，您只需要用<code class="fe ne nf ng mv b">npm init</code>初始化您的节点项目。该命令提示一些问题，并将创建一个<code class="fe ne nf ng mv b">package.json</code>文件。输出将类似于下面的代码片段，使用的数据是您对从init命令收到的各种提示的回答:</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="8e76" class="mz ly it mv b gy na nb l nc nd">{<br/>"name": "test",<br/>"version": "1.0.0",<br/>"description": "my fist package",<br/>"main": "main.js",<br/>"scripts": {<br/>   "test": "test"<br/>},<br/>"author": "",<br/>"license": "ISC"<br/>}</span></pre><p id="ec4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个文件包含一个对<code class="fe ne nf ng mv b">main.js</code>文件的引用，为了运行这个应用程序，我们必须创建这个文件。我们将在初始配置完成之后再做这件事。</p><p id="1c2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是允许文件更改时热重新加载。这个特性在开发时非常有用，因为这样一来，每次我们更改文件时，节点服务器都会自动更新，这样就避免了每次停止和启动服务器并等待编译。该功能由<code class="fe ne nf ng mv b">supervisor</code>模块提供，您可以通过以下命令安装该模块:</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="c670" class="mz ly it mv b gy na nb l nc nd">npm install supervisor --save</span></pre><p id="6302" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以将命令定义到<code class="fe ne nf ng mv b">package.json</code>文件中，更改以下几行:</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="c15c" class="mz ly it mv b gy na nb l nc nd">"scripts": {<br/>"serve": "node main.js",<br/>"dev": "supervisor  main.js"<br/>},</span></pre><p id="3e78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该设置允许:</p><ul class=""><li id="c205" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated">run <code class="fe ne nf ng mv b">npm serve</code>照常运行应用程序，就像在生产环境中一样</li><li id="ac11" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">run <code class="fe ne nf ng mv b">npm dev</code>用于在文件监听处于活动状态的开发环境中运行应用程序</li></ul><p id="d4cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然设置已经完成，我们只需添加main.js文件，就万事俱备了。在下面的例子中，我们有一个简单的API来显示每秒递增的计数器值。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5243" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以运行应用程序，并使用Postman测试输出:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b075794d7c293e2007bd4a5f5a88624b.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*lthVhEj76JdXWsATo2qogw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">邮递员调用的API</figcaption></figure><p id="54bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这第一步已经完成，现在你可以开始使用API并构建你自己的应用程序了！</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h1 id="0c30" class="lx ly it bd lz ma of mc md me og mg mh jz oh ka mj kc oi kd ml kf oj kg mn mo bi translated"><strong class="ak">前端设置</strong></h1><p id="2090" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">一旦后端应用完成，我们就可以专注于UI部分。您可以使用Angular、React或普通的Javascript库，但在本例中，我们将使用一个<a class="le lf ep" href="https://medium.com/u/9b930cf6db26?source=post_page-----59d3376e403e--------------------------------" rel="noopener" target="_blank"> Vue.js </a>应用程序。要创建应用程序，您只需安装Vue工具，并通过运行以下命令来安装它:</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="c86b" class="mz ly it mv b gy na nb l nc nd">npm install -g @vue/cli<br/>vue create ui</span></pre><p id="c149" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这组命令将把前端应用程序安装和配置到<code class="fe ne nf ng mv b">ui</code>文件夹中。要运行它，只需导航到这个文件夹并运行<code class="fe ne nf ng mv b">npm run serve.</code>，这样应用程序就会启动，我们会看到类似下图的东西。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ok"><img src="../Images/4800f0b3612c3c2e06d16b19176b1f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D1qx7KkByg25M1D8wVNDCQ.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">Vue.js应用程序的启动页面</figcaption></figure><p id="84b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然应用程序已经上线，我们可以编辑现有的应用程序来连接后端。我们本来可以创建一个新的组件，但这只是一个简单的概念证明，所以我们采用了快速而不明智的方法。我们可以编辑<code class="fe ne nf ng mv b">HelloWorld.vue</code>示例组件并添加以下代码:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f3d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的脚本有一些值得注意的部分。第一个是模板，它绑定了HTML中的<code class="fe ne nf ng mv b">count</code>变量。</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="c5b2" class="mz ly it mv b gy na nb l nc nd">&lt;template&gt;  <br/> &lt;div&gt;    <br/>  &lt;h1&gt;Happy counting!&lt;/h1&gt;    <br/>  &lt;p&gt;{{count}}&lt;/p&gt;  <br/> &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="e7d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二部分是<code class="fe ne nf ng mv b">loadCount</code>方法，它从后端API获取计数并显示出来。</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="2883" class="mz ly it mv b gy na nb l nc nd">loadCount:  async function () {      <br/> let result= await axios.get(`${process.env.VUE_APP_APIURL}/count`);      this.count=result.data.changed;     <br/> setTimeout(this.loadCount,3000);    <br/>}</span></pre><p id="c9cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，该方法通过<code class="fe ne nf ng mv b">setTimeout</code>调用是递归的，因此页面不断获取值并更新UI。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/6d405ba89b7fd06be5b8eba688326c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/1*ojVmjeKFj7CbWk1HYmyqNw.gif"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">UI计数</figcaption></figure><p id="eab9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子非常愚蠢，但是你可以想象把它变得复杂(因为现在只是制造新的API和新的组件)。</p><p id="5836" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经完成了我们的示例应用程序，让我们看看如何捆绑它并使它在一个包中可用！</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h1 id="24a9" class="lx ly it bd lz ma of mc md me og mg mh jz oh ka mj kc oi kd ml kf oj kg mn mo bi translated">捆绑应用程序</h1><p id="974f" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">该应用程序在我们的本地工作。我们的设置真的很好，因为我们有两个独立的应用程序，后端和前端，以及双方的热重装。但是怎么用单捆上菜呢？在大多数情况下，我们能够在两个不同的部署中交付两个不同的应用程序(如两个容器)，但在某些情况下，您需要在一个应用程序中同时拥有它们。这可能是对宿主系统的一些约束，就像在<a class="ae lw" href="https://github.com/zeppaman/mongo-event-sourcing" rel="noopener ugc nofollow" target="_blank">MESS——event sourcing enabler</a>的情况中一样，因为您希望在单个节点模块中启用UI和后端。</p><p id="7ae2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一步真的很简单，而且不涉及您的开发设置。只需在你的app上添加两个文件，一个叫<code class="fe ne nf ng mv b">.env</code>，一个叫<code class="fe ne nf ng mv b">.env.local</code>，内容如下。</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="7546" class="mz ly it mv b gy na nb l nc nd">#.env.local<br/>VUE_APP_APIURL=http://localhost:3000</span><span id="759f" class="mz ly it mv b gy om nb l nc nd">#.env<br/>VUE_APP_APIURL=/</span></pre><p id="5335" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这种配置，当应用程序寻找<code class="fe ne nf ng mv b">process.env.VUE_APP_APIURL</code>的值时，将获得生产环境中的相对路径(API和app在一起)，但在本地，您将作为不同的应用程序访问后端。</p><p id="ec46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是烘烤我们的应用程序的时候了！第一步是为构建配置vue.js应用程序。只需运行命令<code class="fe ne nf ng mv b">npm run build</code>来创建输出目录。从下面的截图可以看到，这些文件位于<code class="fe ne nf ng mv b">ui/dist</code>文件夹中。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi on"><img src="../Images/9422caf9231f6dc0d2c1ff26f69c36d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*-aIYCPTMs5jk64BxAcWNrw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">生成的输出</figcaption></figure><p id="1cc6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以告诉Express服务器在<code class="fe ne nf ng mv b">app</code>路径上提供<code class="fe ne nf ng mv b">index.html</code>文件。这可以通过添加以下代码行来完成。</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="a8d3" class="mz ly it mv b gy na nb l nc nd">app.use('/app', express.static(__dirname + '/ui/dist'));</span></pre><p id="fa84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个命令将URL <code class="fe ne nf ng mv b">/app</code>映射到静态文件夹<code class="fe ne nf ng mv b">./ui/dist</code>，构建命令在这里生成输出。</p><p id="f152" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是告诉Vue应用程序现在托管在子路径<code class="fe ne nf ng mv b">/app</code>而不是<code class="fe ne nf ng mv b">/.</code>中，这可以通过在<code class="fe ne nf ng mv b">package.json</code>的同一文件夹中创建<code class="fe ne nf ng mv b">vue.config.js</code>文件来完成，其内容如下:</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="1235" class="mz ly it mv b gy na nb l nc nd">module.exports = {<br/>    publicPath: process.env.NODE_ENV == 'production' ? '/app/' : '/'<br/>}</span></pre><p id="d30b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们能够打开浏览器进入<code class="fe ne nf ng mv b"><a class="ae lw" href="http://localhost:3000/app" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/app</a></code>并使用构建的应用程序，同时在开发模式下运行应用程序。为了自动化构建过程，我们还需要一个步骤。将主应用程序的<code class="fe ne nf ng mv b">package.json</code>更改如下:</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="84c3" class="mz ly it mv b gy na nb l nc nd">"scripts": {<br/>"serve": "cd ui &amp; npm run build &amp; cd .. &amp; node main.js",<br/>"dev": "supervisor  main.js"<br/>},</span></pre><p id="0604" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<code class="fe ne nf ng mv b">serve</code>命令。它构建前端应用程序，然后运行公开前一个命令输出的节点服务。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h1 id="38c1" class="lx ly it bd lz ma of mc md me og mg mh jz oh ka mj kc oi kd ml kf oj kg mn mo bi translated">带什么回家</h1><p id="d012" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">传统上，我们习惯于构建单一的应用程序并部署一个自包含的包。随着微服务模式的发展以及UI(前端)和API(后端)的分离，为单个应用程序进行多次部署变得越来越常见。例如，您可以让应用程序由一个CDN和许多为此提供API的容器提供服务。无论如何，仍然有很多情况需要在一个部署中同时部署两个部分(前端和后端)。</p><p id="fc9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们看到了创建一个空应用程序并构建它是多么容易，嵌入前端和后端。此外，我们创建了一个API，并从Javascript中使用它来呈现网页。这个简单的案例展示了将事情复杂化和实现真实应用程序的方法</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="dc6e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">喜欢这篇文章吗？成为 <a class="ae lw" href="https://daniele-fontani.medium.com/membership" rel="noopener"> <em class="oo">中等会员</em> </a> <em class="oo">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><h2 id="7571" class="mz ly it bd lz op oq dn md or os dp mh kr ot ou mj kv ov ow ml kz ox oy mn oz bi translated">参考</h2><ul class=""><li id="339a" class="nh ni it kk b kl mp ko mq kr pa kv pb kz pc ld nm nn no np bi translated"><a class="ae lw" href="https://github.com/zeppaman/node-vue-self-contained" rel="noopener ugc nofollow" target="_blank">带有源代码的git库</a></li></ul></div></div>    
</body>
</html>