# 用 Solid 构建一个简单的 JavaScript 应用——你从未听说过的最好的 JavaScript UI 库

> 原文：<https://levelup.gitconnected.com/building-a-simple-javascript-app-with-solid-ff17c8836409>

![](img/10adde80b9778afc4e03f30f3ced4f66.png)

这里没有惊喜。向某人介绍一个新的 UI 库的最简单的方法是组装一个简单的应用程序。TodoMVC 多年来一直致力于前端 JavaScript 库的比较。其中一个好处是它有一个清晰的功能集，它把 CSS 从等式中去掉了。今天我们不会看到 Solid 令人难以置信的表现。所以让我们只关注 JavaScript 并开始吧。

我们通过创建用于状态管理的商店来开始构建我们的 Todo 应用程序。接下来，我们将使用 JSX 为 UI 构建可靠的组件，并将其连接到商店以创建一个工作的 Todo 应用程序。

# 配置

在深入研究代码之前，还有一些设置。Solid 还没有 CLI 或类似的功能，所以它确实需要一些配置。对于 TodoMVC 来说，这意味着一个简单的 WebPack 配置，包括运行 [babel-preset-solid](https://github.com/ryansolid/babel-preset-solid) 的 [babel-loader](https://github.com/babel/babel-loader) 。

```
rules: [{
  test: /\.jsx?$/,
  use: {
    loader: 'babel-loader',
    options: {
      presets: ['solid']
    }
  }
}]
```

这使用了 [JSX DOM 表达式](https://github.com/ryansolid/babel-plugin-jsx-dom-expressions)插件，它是专门设计来将 JSX 标签转换成真正的 DOM 语句，并将 JSX 表达式转换成属性赋值和细粒度计算的。因为 Solid 不使用虚拟 DOM，一个典型的 HyperScript JSX 编译器是不够的。

好的。可以开始了…

# 体系结构

![](img/f96949d7235396a8933e1ca69f51481a.png)

照片由来自 [Pexels](https://www.pexels.com/photo/moss-87153/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) 的 [Martinus](https://www.pexels.com/@mcore?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) 拍摄

每个库和框架都以不同的方式处理这个问题，这是这里要做的第一个决定。因为 Solid 处理数据更新与您如何分解组件无关，所以我们可以灵活地用几种不同的方式来实现这个应用程序。然而，保持 MVC 精神的最惯用的方法是将数据管理抽象成一个存储(模型),并将视图分割成几个小组件。这远不是解决这个问题的唯一方法，因为您可以将整个应用程序放在一个或十几个组件中，而不会真正看到任何性能差异。

这是 Solid 的主要优势之一。这是一个为重构而设计的库。这并不是说没有原则性的惯用方法。只是它并不像你被教导的那样完全是(同质的)组件库。它更像是整个应用程序是由相同的物质组成的，根据你看得多近或多远，它可以看起来像一个或多个有机体。有点重，我知道。让我们看看那是什么样子。

# 商店

在构建组件之前，我们首先要构建的是商店。通常从数据开始更简单。我们将把它写成类似于 React 中的自定义钩子。简单地包装一个状态对象并公开它和预定义的更新方法。第一部分是 TodoMVC 的一个要求是将数据存储在`localStorage`中。让我们创建一个可重用的方法。

这段代码片段所做的是从`localStorage`创建一个新的状态对象，或者从调用者传入的默认值创建一个新的状态对象。下一个块创建了一个新的副作用，每当状态更新时，它就更新`localStorage`。虽然 Solid 甚至要求在视图中显式声明效果，但依赖项跟踪是默认完成的(尽管有第二个可选参数来显式设置它们)。

需要注意的是，状态本身不能被跟踪，只能访问它的属性，但是`JSON.stringify`在这里做了大量的工作，迭代可枚举的属性并设置依赖关系。最后，该函数只是赤裸裸地返回来自`createState`的输出，供您按预期使用。

现在我们可以用`createLocalState`来组成我们的`createTodosStore`。

好的，这里发生了相当多的事情。这主要是展示了许多`setState`的模式。但一会儿会有更多的讨论。首先，我们初始化我们的`localState`对象。然后，我们设置一个效果，计算 todos 的已完成和剩余计数，并将其反馈给状态对象。

Solid 的`setState`借鉴了 ImmutableJS 和 FalcorJS 的一些东西，它既允许深度设置，也允许对多个更新进行排队。原因是每个`setState` evocation 会立即同步地批量处理由于它而发生的所有更新。是的，这意味着所有的更新都发生在下一行执行之前。不要担心你的状态是否是最新的。确实是。

Solid 也有一个类似于 MobX 的动作(冻结)的机制来批量处理多个`setState`调用，但是在一个单独的调用中完成通常要干净得多。您总是可以像处理不可变数据那样更新状态，但是因为 Solid 对于深度嵌套的更新是细粒度的，所以只设置发生了什么变化会有性能上的好处。仔细想想，很有道理。很可能你已经知道发生了什么变化，但是你必须沿着树一直克隆，直到发生变化，然后让渲染器在渲染时沿着树一直引用检查。Solid 只是跳过了这种低效率。让我们来看几个例子。

`addTodo`是一个通过传递数组作为参数进行多次更新的例子。首先，我们深度设置 todos，然后是计数器。这是完全可能的，因为更新是顶级的，所以您可以使用单个对象以 React 的方式来完成，但这让我输入单词 state 的次数减少了 3 倍，并演示了这种方法。

`editTodo`是一个做更深层次路径设置的例子，其中只有找到的索引处的 todo 被更新。传入的 todo 是一个对象，因此更改将与已在该位置的项合并，而不是被替换。这与 classic React `setState`处理对象的方式一致。

`toggleAll`在路径上使用条件方法。数组中任何符合条件的项都会被更新。在这种情况下，所有不等于复选框当前状态的项目都将更改为该状态。

# 应用

我想你现在已经很了解国务院了，所以让我们看看我们能在另一方面做些什么。从上到下开始，让我们创建我们的应用程序。

应用程序从底部开始，我们为应用程序创建一个计算根。它设定了细粒度执行和内存处置的界限。所有的固体应用都以此为应用起点。在中，您可以将 JSX 的返回值用作普通的 dom 节点，如图所示，TodoApp 被插入到主体中。

在我们的 TodoApp 组件中，我们创建了一个 store 析构实例，构造出所需的状态和更新方法，并且我们设置了一个简单的事件处理程序来监听`hashchange`以执行一些简单的路由。`onCleanup`确保在释放根时将其处理掉。

你可能会问为什么这个没有被包装成一个效果？这就是固体和反应的区别。这个函数只执行一次。不需要显式的创建/挂载挂钩，因为组件执行是设置步骤。你只需要更新的东西的效果。没有依赖关系的效果没有意义。

从那里返回的 JSX 看起来很正常，除了一件事:控制流元素`Show`。当处理动态插入的某些部分的记忆和协调时，细粒度的库确实会带来一些复杂性。包装在预构建的组件中使其更易于使用。Solid 还有更多的这些，包括`For`、`Switch`、`Portal`和`Suspense`。

你还在吗？我知道有相当多的东西需要消化，因为表面上你认为你可能在处理类似 React 的东西，但它的工作方式奇怪地不同。事实是我们还没有完全完成。

# 页眉和页脚

在下一个代码块中，我们将最终处理一些真正的 DOM 元素。

这两个是经典所谓的哑组件。`TodoHeader`组件非常简单。它正在等待一个`Enter`键来添加新的`Todo`。页脚看起来同样简单，直到你发现一个小东西，`classList`。这是处理多类包含的一种常见情况，通过一个内置了布尔值的对象来管理它们。

# 待办事项列表

我将 Todo 列表本身分成两个部分，一个用于列表，一个用于每个项目。列表本身维护一些不在存储中的附加状态，比如当前正在编辑的 Todo 的状态。

关于如何处理列表，有两种方法，但是以上面显示的方式处理它有性能上的好处。像许多现代库一样，Solid.js 使用隐式事件委托，所以在父库中声明一次函数并传递它实际上减少了每个 Todo 的开销。对于构建一个简单的应用程序来说，这可能是不必要的，但是我发现很难避免自然地进行这种性能优化。这是一些你不需要考虑太多的类组件，比如你在 React 中发现的经典组件，因为 Todos 会共享一个原型，但一旦你转向 Hooks，它们就真实存在了。model 属性类似于 React 中的键，但它接受对象，不用于协调。只是为了将数据附加到委托的事件和指令。

# 结论

仅此而已。TodoMVC 本身并不是最有趣的例子，但在这一点上，它是如此标准化，我觉得你已经知道会发生什么了。这里还有一些其他的选择。用一个缩减器或者至少使用一个单一的调度函数来设置存储，可以清理一些传递的函数，但是我觉得这是查看 Solid 的最自然的方式。

本文涵盖的整个项目源代码可从以下网址获得:

[](https://github.com/ryansolid/solid-todomvc) [## ryansolid/solid-todomvc

### TodoMVC 的可靠实现。

github.com](https://github.com/ryansolid/solid-todomvc) 

一如既往地检查固体:

[](https://github.com/ryansolid/solid) [## 瑞安固体/固体

### 一个用于构建用户界面的声明式、高效且灵活的 JavaScript 库。-瑞安固体/固体

github.com](https://github.com/ryansolid/solid)