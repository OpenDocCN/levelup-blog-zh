<html>
<head>
<title>What’s Mediastreamer2. Filters development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Mediastreamer2。过滤器开发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/whats-mediastreamer2-filters-development-4b7d05e09a0f?source=collection_archive---------9-----------------------#2020-10-31">https://levelup.gitconnected.com/whats-mediastreamer2-filters-development-4b7d05e09a0f?source=collection_archive---------9-----------------------#2020-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/12a83b61623358045d23e6557024dbff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyHLOZuBPQ9zKaFcqXxJ2g.png"/></div></figure><p id="a2ba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(上一篇文章<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/chapter-3-examples-of-using-filters-612f2121301">什么是Mediastreamer2。使用</a>的过滤器示例<br/></p><p id="a3b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我们将学习如何编写过滤器并将它们添加到intercom项目中。</p><p id="22a1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">插件是独立编译的软件模块，它动态地连接到媒体流，并被设计成扩展其能力。这允许第三方开发者，即您，应用媒体流来解决其作者最初没有预想到的问题。</p><h1 id="0570" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">4.1一般方法</h1><p id="621a" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">要在你的程序中使用插件，你必须使用<em class="lw"> #include </em>包含插件的头文件。之后在程序体中，使用函数<em class="lw"> ms_filter_register() </em>注册一个新的过滤器。很自然，你的程序和插件源代码必须被编译和组装成一个应用程序。</p><p id="5467" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们来写一个插件。所有的媒体流过滤器和插件都遵守通用的书面规范，这使得理解您要研究的下一个过滤器的结构变得容易得多。因此，更进一步，为了不增加实体，我们将调用插件过滤器。</p><h1 id="c08f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">4.2入门<br/>编写过滤器</h1><p id="0073" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">假设我们要设计一个名为OUR_FILTER的新过滤器。它将执行一个基本的事情——从它的单个输入端接收块，并将它们传输到五个输出端。如果超过五个信号电平低于指定阈值的模块通过，以及超过五个信号电平高于阈值的模块通过，它也会生成事件。将使用过滤方法设置阈值。第二种和第三种方法将允许/拒绝块通过输出。</p><h1 id="e3a1" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">4.3头文件</h1><p id="e99c" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在媒体流中，实现了一个程序接口，用于它与过滤器的交互。因此，每个过滤器都必须有一个头文件，该头文件为媒体流API提供必要的声明，以便与该过滤器的实例正确交互。您需要从这个头文件开始编写过滤器。</p><p id="9b6e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在第一行中，它必须包含<em class="lw"> msfilter.h </em>文件，使用MS_FILTER_METHOD宏来声明新过滤器的方法(如果有)，声明过滤器生成的事件(如果有)，并声明导出的类型为<em class="lw"> MSFilterDesc </em>的结构以及过滤器参数的描述，如清单4.1所示。</p><p id="eefb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单4.1:结构MSFilterDesc</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="00e6" class="mg ku iq mc b gy mh mi l mj mk">struct _MSFilterDesc{<br/>    MSFilterId id;    /* Filter type identifier (integer number) specified in the file allfilters.h or by ourselves. */<br/>    const char *name; /* Filter name.*/<br/>    const char *text; /* Short text describing the filter. */<br/>    MSFilterCategory category; /* A filter category that describes its role. */<br/>    const char *enc_fmt; /* sub-mime used format, must be specified for filter categories: MS_FILTER_ENCODER or MS_FILTER_DECODER */<br/>    int ninputs; /* Number of inputs. */<br/>    int noutputs; /*Number of outputs.  */<br/>    MSFilterFunc init; /* Initial filter initialization function. */<br/>    MSFilterFunc preprocess; /* A function called once before starting the filter. */<br/>    MSFilterFunc process; /* A function that performs the main work of the filter, called for each tick of a MSTicker. */<br/>    MSFilterFunc postprocess; /* Filter shutdown function, called once after the last call process(), before removing the filter. */<br/>    MSFilterFunc uninit; /* The filter shutdown function frees memory that was used when creating the internal filter structures. */<br/>    MSFilterMethod *methods; /* Filter Method Table. */<br/>    unsigned int flags; /* Special filter flags described in the enumeration  MSFilterFlags. */<br/>};</span><span id="6f03" class="mg ku iq mc b gy ml mi l mj mk">/*<br/> Structure for filter description.<br/>*/<br/>typedef struct _MSFilterDesc MSFilterDesc;</span></pre><p id="6882" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">框架使用的类型可以通过查看<em class="lw"> msfilter.h </em>文件来检查。我们的过滤器的头文件将如清单4.2所示。</p><p id="8de9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单4.2:过滤器分离器和noisegate头文件</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1e71" class="mg ku iq mc b gy mh mi l mj mk">/* Файл our_filter.h, Filter-splitter and noise gate. */</span><span id="c7a0" class="mg ku iq mc b gy ml mi l mj mk">#ifndef myfilter_h<br/>#define myfilter_h</span><span id="aa74" class="mg ku iq mc b gy ml mi l mj mk">/* We include a header file with a list of mediastreamer filters. */<br/>#include &lt;Mediastreamer2/msticker.h&gt;</span><span id="6757" class="mg ku iq mc b gy ml mi l mj mk">/* <br/>   Set the numeric identifier for the new filter type. This number should not match none of the other types in the file allfilters.h it has a corresponding enumeration  MSFilterId. Unfortunately, it is not clear how to determine the maximum occupied value other than looking into this file. But we will take obviously more as id for our filter value: 4000.  We will assume that the developers adding new filters do not will get to this number soon. <br/>   */<br/>#define OUR_FILTER_ID 4000</span><span id="b8ef" class="mg ku iq mc b gy ml mi l mj mk">/* <br/>   We define the methods of our filter. The second parameter of the macro should be the ordinal number of the method, a number from 0. The third parameter is the type of the argument of method, a pointer to which will be passed to the method when called. Methods may or may not have arguments, as shown below. <br/>   */<br/>#define OUR_FILTER_SET_TRESHOLD MS_FILTER_METHOD(OUR_FILTER_ID , 0, float)<br/>#define OUR_FILTER_TUNE_OFF     MS_FILTER_METHOD_NO_ARG(OUR_FILTER_ID ,1)<br/>#define OUR_FILTER_TUNE_ON      MS_FILTER_METHOD_NO_ARG(OUR_FILTER_ID ,2)</span><span id="c154" class="mg ku iq mc b gy ml mi l mj mk">/* Now we define the structure that will be sent along with the event. */<br/>struct _OURFilterEvent<br/>{<br/>    /* This is the field that will act as a flag,<br/>       0 - zeros appeared, 1 - there was a signal.*/<br/>    char state; <br/>    /* Time when the event happened. */<br/>    uint64_t time;<br/>};<br/>typedef struct _OURFilterEvent OURFilterEvent;</span><span id="2c94" class="mg ku iq mc b gy ml mi l mj mk">/* Defining an event for our filter. */<br/>#define OUR_FILTER_EVENT MS_FILTER_EVENT(MS_RTP_RECV_ID, 0, OURFilterEvent)</span><span id="a286" class="mg ku iq mc b gy ml mi l mj mk">/* We define the exported variable, which will be store of characteristics for a given filter type. */<br/>extern MSFilterDesc our_filter_desc;</span><span id="d599" class="mg ku iq mc b gy ml mi l mj mk">#endif /* myfilter_h */</span></pre><h1 id="b68f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">4.4来源<br/>文件</h1><p id="0850" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在，您可以从原始文件开始。带有注释的过滤器的源代码如清单4.3所示。这是我们在头文件中声明的方法和所需的过滤函数实现的地方。然后，以特定顺序对方法和函数的引用被放在导出的结构<em class="lw"> our_filter_desc </em>中。其被媒体流送器用来将这种类型的过滤器的实例“植入”到数据处理工作流程中。</p><p id="eb49" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单4.3:过滤分离器和noisegate的源文件</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="dcce" class="mg ku iq mc b gy mh mi l mj mk">/* Файл our_filter.с, Describes filter splitter and noise gate. */</span><span id="c429" class="mg ku iq mc b gy ml mi l mj mk">#include "our_filter.h"<br/>#include &lt;math.h&gt;</span><span id="3e53" class="mg ku iq mc b gy ml mi l mj mk">#define OUR_FILTER_NOUTPUTS 5</span><span id="7d95" class="mg ku iq mc b gy ml mi l mj mk">/* We define a structure that stores the internal state of the filter. */<br/>typedef struct _our_filterData<br/>{<br/>    bool_t disable_out;  /* Permission to transfer blocks to the output. */<br/>    int last_state;   /* The current state of the switch. */<br/>    char zero_count;     /* Zero block counter. */<br/>   char lag;            /* The number of blocks for making a noise gate decision. */<br/>    char n_count;        /* Counter of non-zero blocks. */<br/>    float skz_level;     /* RMS of signal inside block in which the filter will pass the signal. At the same time it is the threshold triggering by which the event will be generated.  */</span><span id="04a2" class="mg ku iq mc b gy ml mi l mj mk">} our_filterData;</span><span id="9c8d" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* Mandatory initialization function. */<br/>static void our_filter_init(MSFilter *f)<br/>{<br/>    our_filterData *d=ms_new0(our_filterData, 1);<br/>    d-&gt;lag=5;<br/>    f-&gt;data=d;<br/>}</span><span id="1b91" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* Mandatory function of finalizing the filter operation, memory is freed. */<br/>static void our_filter_uninit(MSFilter *f)<br/>{<br/>    ms_free(f-&gt;data);<br/>}</span><span id="3bd1" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* We define an exemplary array with zeros, obviously larger than the block. */<br/>char zero_array[1024]={0};</span><span id="367e" class="mg ku iq mc b gy ml mi l mj mk">/* We define the filter event. */<br/>OURFilterEvent event;</span><span id="42fd" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* Event sending function. */<br/>static void send_event(MSFilter *f, int state)<br/>{<br/>    our_filterData *d =( our_filterData* ) f-&gt;data;<br/>     d-&gt;last_state = state;<br/>    /* We set the time of the event occurrence, from the moment of the first tick. Time in milliseconds. */<br/>    event.time=f -&gt; ticker -&gt; time;<br/>    event.state=state;  <br/>    ms_filter_notify(f, OUR_FILTER_EVENT, &amp;event);<br/>}   </span><span id="fe16" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* The function calculates the root mean square (effective) value of the signal within the block. */<br/>static float calc_skz(our_filterData *d, int16_t *signal, int numsamples)<br/>{<br/>    int i;<br/>    float acc = 0;<br/>    for (i=0; i&lt;numsamples; i++)<br/>    {<br/>        int s=signal[i];<br/>        acc = acc + s * s;<br/>    }<br/>    float skz = (float)sqrt(acc / numsamples);<br/>    return skz;<br/>}</span><span id="e2fc" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* Mandatory function of the main filter loop, called with every tick. */<br/>static void our_filter_process(MSFilter *f)<br/>{<br/>    our_filterData *d=(our_filterData*)f-&gt;data;</span><span id="c078" class="mg ku iq mc b gy ml mi l mj mk">    /* Pointer to the input message containing the data block. */<br/>    mblk_t *im;<br/>    int i;<br/>    int state;<br/>    /* Reading messages from the input queue until it is completely empty. */<br/>    while((im=ms_queue_get(f-&gt;inputs[0]))!=NULL)<br/>    {<br/>        /* If the outputs are disabled, then we simply delete the input message. */<br/>        if ( d -&gt; disable_out)<br/>        {<br/>          freemsg(im);<br/>          continue;<br/>        }</span><span id="1da4" class="mg ku iq mc b gy ml mi l mj mk">        /* We measure the signal level and make a decision about sending the signal. */<br/>        float skz = calc_skz(d, (int16_t*)im-&gt;b_rptr, msgdsize(im));<br/>        state = (skz &gt; d-&gt;skz_level) ? 1 : 0; <br/>        if (state) <br/>        {<br/>            d-&gt;n_count++;<br/>            d-&gt;zero_count = 0;<br/>        }<br/>        else<br/>        {<br/>            d-&gt;n_count = 0;<br/>            d-&gt;zero_count++;<br/>        }<br/>        if (((d-&gt;zero_count &gt; d-&gt;lag) || (d-&gt;n_count &gt; d-&gt;lag))<br/>            &amp;&amp;  (d-&gt;last_state != state)) send_event(f, state);</span><span id="adb1" class="mg ku iq mc b gy ml mi l mj mk">        /* We proceed to copying the input message and layout by outputs. But only for those to which the load is connected. The original message will go to the output with index 0, and its copies will go to the other outputs.*/ <br/>        int output_count = 0;<br/>        mblk_t *outm; /* Pointer to a message with an output data block. */<br/>        for(i=0; i &lt; f-&gt;desc-&gt;noutputs; i++)<br/>        {<br/>            if (f-&gt;outputs[i]!=NULL)<br/>            {<br/>                if (output_count == 0)<br/>                {<br/>                    outm = im;<br/>                }<br/>                else<br/>                {<br/>                    /* Create a light copy of the message.*/       <br/>                    outm = dupmsg(im);<br/>                }<br/>                /* We place a copy or original of the input message on the next filter output. */ <br/>                ms_queue_put(f-&gt;outputs[i], outm);<br/>                output_count++;<br/>            }<br/>        }<br/>    }<br/>}</span><span id="7ece" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* Handler function for calling the OUR_FILTER_SET_LAG method. */<br/>static int our_filter_set_treshold(MSFilter *f, void *arg)<br/>{<br/>    our_filterData *d=(our_filterData*)f-&gt;data;<br/>    d-&gt;skz_level=*(float*)arg;<br/>    return 0;<br/>}</span><span id="7cb4" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* Handler function for calling the OUR_FILTER_TUNE_OFF method. */<br/>static int our_filter_tune_off(MSFilter *f, void *arg)<br/>{<br/>    our_filterData *d=(our_filterData*)f-&gt;data;<br/>    d-&gt;disable_out=TRUE;<br/>    return 0;<br/>}</span><span id="c903" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* Handler function for calling the OUR_FILTER_TUNE_ON method. */<br/>static int our_filter_tune_on(MSFilter *f, void *arg)<br/>{<br/>    our_filterData *d=(our_filterData*)f-&gt;data;<br/>    d-&gt;disable_out=FALSE;<br/>    return 0;<br/>}</span><span id="8011" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* We fill the table of filter methods, how many methods<br/> we have defined in the header file so many non-zero lines. */<br/>static MSFilterMethod our_filter_methods[]={<br/>    { OUR_FILTER_SET_TRESHOLD, our_filter_set_treshold },<br/>    { OUR_FILTER_TUNE_OFF, our_filter_tune_off },<br/>    { OUR_FILTER_TUNE_ON, our_filter_tune_on },<br/>    { 0 , NULL } /* Marker of the end of table. */<br/>};</span><span id="7794" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* Description of the filter for the media streamer. */<br/>MSFilterDesc our_filter_desc=<br/>{<br/>    OUR_FILTER_ID,<br/>    "OUR_FILTER",<br/>    "A filter with noise gate that reads from input and copy to it's five outputs.",<br/>    MS_FILTER_OTHER,<br/>    NULL,<br/>    1,<br/>    OUR_FILTER_NOUTPUTS,<br/>    our_filter_init,<br/>    NULL,<br/>    our_filter_process,<br/>    NULL,<br/>    our_filter_uninit,<br/>    our_filter_methods,<br/>    0<br/>};</span><span id="b071" class="mg ku iq mc b gy ml mi l mj mk">MS_FILTER_DESC_EXPORT(our_filter_desc)</span></pre><h1 id="be79" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">4.5应用<br/>新的过滤器</h1><p id="62d3" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在，毫不延迟地在之前完成的3.9对讲机中应用我们的过滤器，该对讲机现在将具有记录对话的功能，并且由于我们的过滤器，语音中的长时间停顿将不会被写入文件。</p><p id="f316" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上图4.1显示了修改后的对讲机的示意图。我们希望以一种特别鲜明的方式描绘我们自己的过滤器。因此，您会立即在图上找到我们的过滤器。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/962e33070f3d95bf8ccfda94bdd830c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvxljJhTovxxBEkjJkvK0A.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">图4.1:电路中的滤波器</figcaption></figure><p id="09a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">电路中增加了一个记录器滤波器，它将输入信号写入一个<em class="lw"> wav </em>文件。根据设计，我们的过滤器将保存语音中长时间停顿的文件，从而节省磁盘空间。在本文的开始，我们描述了过滤器动作的算法。主应用程序处理它生成的事件。如果事件包含标志“0”，则主机暂停记录。一旦带有标记“1”的事件到达，记录就恢复。</p><p id="d85a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单4.4显示了程序的源代码。其中，在前面的命令行参数中又添加了两个参数:<em class="lw"> — ng </em>，用于设置过滤器阈值级别，以及<em class="lw"> — rec </em>，用于开始写入名为<em class="lw"> record.wav </em>的文件。</p><p id="6d47" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单4.4:带有记录器和噪声门的内部通信模拟器</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fd75" class="mg ku iq mc b gy mh mi l mj mk">/* File mstest9.c Intercom simulator with recorder and noisegate. */</span><span id="38fd" class="mg ku iq mc b gy ml mi l mj mk">#include &lt;Mediastreamer2/mssndcard.h&gt;<br/>#include &lt;Mediastreamer2/dtmfgen.h&gt;<br/>#include &lt;Mediastreamer2/msrtp.h&gt;<br/>#include &lt;Mediastreamer2/msfilerec.h&gt;</span><span id="58b3" class="mg ku iq mc b gy ml mi l mj mk">/* We connect our filter. */<br/>#include "our_filter.h"</span><span id="2aab" class="mg ku iq mc b gy ml mi l mj mk">/* We include the file of common functions. */<br/>#include "mstest_common.c"</span><span id="dc48" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>struct _app_vars<br/>{<br/>    int  local_port;              /* Local port. */<br/>    int  remote_port;             /* Intercom port on a remote computer. */<br/>    char remote_addr[128];        /* The IP address of the remote computer. */<br/>    MSDtmfGenCustomTone dtmf_cfg; /* Test signal generator settings. */<br/>    MSFilter* recorder;           /* Pointer to the filter logger. */<br/>    bool_t file_is_open;          /* Flag that the file is open for writing. */<br/>    /* The threshold at which the recording of the received signal to the file stops. */<br/>    float treshold; <br/>    bool_t en_rec;                /* Switch on writing to file. */    <br/>};</span><span id="a4ff" class="mg ku iq mc b gy ml mi l mj mk">typedef struct _app_vars app_vars;</span><span id="9a0d" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* We create a duplex RTP-session. */<br/>RtpSession* create_duplex_rtp_session(app_vars v)<br/>{<br/>    RtpSession *session = create_rtpsession (v.local_port, v.local_port + 1,<br/>            FALSE, RTP_SESSION_SENDRECV);<br/>    rtp_session_set_remote_addr_and_port(session, v.remote_addr, v.remote_port,<br/>            v.remote_port + 1);<br/>    rtp_session_set_send_payload_type(session, PCMU);<br/>    return session;<br/>}</span><span id="05d3" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* Function to convert command line arguments to program settings. */<br/>void  scan_args(int argc, char *argv[], app_vars *v)<br/>{<br/>    char i;<br/>    for (i=0; i&lt;argc; i++)<br/>    {<br/>        if (!strcmp(argv[i], "--help"))<br/>        {<br/>            char *p=argv[0]; p=p + 2;<br/>            printf("  %s walkie talkie\n\n", p);<br/>            printf("--help      List of options.\n");<br/>            printf("--version   Version of application.\n");<br/>            printf("--addr      Remote abonent IP address string.\n");<br/>            printf("--port      Remote abonent port number.\n");<br/>            printf("--lport     Local port number.\n");<br/>            printf("--gen       Generator frequency.\n");<br/>            printf("--ng        Noise gate treshold level from 0. to 1.0\n");<br/>            printf("--rec       record to file 'record.wav'.\n");<br/>            exit(0);<br/>        }</span><span id="1131" class="mg ku iq mc b gy ml mi l mj mk">        if (!strcmp(argv[i], "--version"))<br/>        {<br/>            printf("0.1\n");<br/>            exit(0);<br/>        }</span><span id="a66e" class="mg ku iq mc b gy ml mi l mj mk">        if (!strcmp(argv[i], "--addr"))<br/>        {<br/>            strncpy(v-&gt;remote_addr, argv[i+1], 16);<br/>            v-&gt;remote_addr[16]=0;<br/>            printf("remote addr: %s\n", v-&gt;remote_addr);<br/>        }</span><span id="b771" class="mg ku iq mc b gy ml mi l mj mk">        if (!strcmp(argv[i], "--port"))<br/>        {<br/>            v-&gt;remote_port=atoi(argv[i+1]);<br/>            printf("remote port: %i\n", v-&gt;remote_port);<br/>        }</span><span id="ad90" class="mg ku iq mc b gy ml mi l mj mk">        if (!strcmp(argv[i], "--lport"))<br/>        {<br/>            v-&gt;local_port=atoi(argv[i+1]);<br/>            printf("local port : %i\n", v-&gt;local_port);<br/>        }</span><span id="2729" class="mg ku iq mc b gy ml mi l mj mk">        if (!strcmp(argv[i], "--gen"))<br/>        {<br/>            v -&gt; dtmf_cfg.frequencies[0] = atoi(argv[i+1]);<br/>            printf("gen freq : %i\n", v -&gt; dtmf_cfg.frequencies[0]);<br/>        }</span><span id="7025" class="mg ku iq mc b gy ml mi l mj mk">        if (!strcmp(argv[i], "--ng"))<br/>        {<br/>            v -&gt; dtmf_cfg.frequencies[0] = atoi(argv[i+1]);<br/>            printf("noise gate treshold: %f\n", v -&gt; treshold);<br/>        }<br/>         if (!strcmp(argv[i], "--rec"))<br/>        {<br/>            v -&gt; en_rec = TRUE;<br/>            printf("enable recording: %i\n", v -&gt; en_rec);<br/>        }<br/>    }<br/>}</span><span id="908b" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>/* Callback function, it will be called by the filter as soon as it notices that silence has come, or vice versa, silence has been replaced by sounds. */<br/>static void change_detected_cb(void *data, MSFilter *f, unsigned int event_id,<br/>        OURFilterEvent *ev)<br/>{<br/>    app_vars *vars = (app_vars*) data;</span><span id="a03e" class="mg ku iq mc b gy ml mi l mj mk">    /* If the recording was not allowed, then exit. */<br/>    if (! vars -&gt; en_rec) return; </span><span id="55b9" class="mg ku iq mc b gy ml mi l mj mk">    if (ev -&gt; state)<br/>    {<br/>        /* We resume recording. */<br/>        if(!vars-&gt;file_is_open)<br/>        {<br/>            ms_filter_call_method(vars-&gt;recorder, MS_FILE_REC_OPEN, "record.wav");<br/>            vars-&gt;file_is_open = 1;<br/>        }<br/>        ms_filter_call_method(vars-&gt;recorder, MS_FILE_REC_START, 0);<br/>        printf("Recording...\n");<br/>    }<br/>    else<br/>    {<br/>        /* We pause the recording. */<br/>        ms_filter_call_method(vars-&gt;recorder, MS_FILE_REC_STOP, 0);<br/>        printf("Pause...\n");<br/>    }<br/>}</span><span id="5fc1" class="mg ku iq mc b gy ml mi l mj mk">/*----------------------------------------------------------*/<br/>int main(int argc, char *argv[])<br/>{<br/>    /* We set the default settings. */<br/>    app_vars vars={5004, 7010, "127.0.0.1", {0}, 0, 0, 0.01, 0};</span><span id="87c3" class="mg ku iq mc b gy ml mi l mj mk">    /* We set the program settings to according to the command line arguments. */<br/>    scan_args(argc, argv, &amp;vars);</span><span id="b475" class="mg ku iq mc b gy ml mi l mj mk">    ms_init();</span><span id="95ac" class="mg ku iq mc b gy ml mi l mj mk">    /* We create instances of transmitting path filters. */<br/>    MSSndCard *snd_card =<br/>        ms_snd_card_manager_get_default_card(ms_snd_card_manager_get());<br/>    MSFilter *snd_card_read = ms_snd_card_create_reader(snd_card);<br/>    MSFilter *dtmfgen = ms_filter_new(MS_DTMF_GEN_ID);<br/>    MSFilter *rtpsend = ms_filter_new(MS_RTP_SEND_ID);</span><span id="0f4b" class="mg ku iq mc b gy ml mi l mj mk">    /* We create an encoder filter. */<br/>    MSFilter *encoder = ms_filter_create_encoder("PCMU");</span><span id="864a" class="mg ku iq mc b gy ml mi l mj mk">    /* We register load types. */<br/>    register_payloads();</span><span id="bc34" class="mg ku iq mc b gy ml mi l mj mk">    /* We create a duplex RTP-session. */<br/>    RtpSession* rtp_session = create_duplex_rtp_session(vars);<br/>    ms_filter_call_method(rtpsend, MS_RTP_SEND_SET_SESSION, rtp_session);</span><span id="d10a" class="mg ku iq mc b gy ml mi l mj mk">    /* We connect the transmitter filters. */<br/>    ms_filter_link(snd_card_read, 0, dtmfgen, 0);<br/>    ms_filter_link(dtmfgen, 0, encoder, 0);<br/>    ms_filter_link(encoder, 0, rtpsend, 0);</span><span id="b81e" class="mg ku iq mc b gy ml mi l mj mk">    /* We create filters for the receiving path. */<br/>    MSFilter *rtprecv = ms_filter_new(MS_RTP_RECV_ID);<br/>    ms_filter_call_method(rtprecv, MS_RTP_RECV_SET_SESSION, rtp_session);</span><span id="c198" class="mg ku iq mc b gy ml mi l mj mk">    /* We create a decoder filter. */<br/>    MSFilter *decoder=ms_filter_create_decoder("PCMU");<br/>    //MS_FILE_REC_ID</span><span id="3554" class="mg ku iq mc b gy ml mi l mj mk">    /* We register our filter. */<br/>    ms_filter_register(&amp;our_filter_desc);<br/>    MSFilter *our = ms_filter_new(OUR_FILTER_ID);</span><span id="8074" class="mg ku iq mc b gy ml mi l mj mk">    /* Create a sound card filter. */<br/>    MSFilter *snd_card_write = ms_snd_card_create_writer(snd_card);</span><span id="45fc" class="mg ku iq mc b gy ml mi l mj mk">    /* Create a logger filter. */<br/>    MSFilter *recorder=ms_filter_new(MS_FILE_REC_ID);<br/>    vars.recorder = recorder; </span><span id="370f" class="mg ku iq mc b gy ml mi l mj mk">    /* We connect the filters of the receiving path. */<br/>    ms_filter_link(rtprecv, 0, decoder, 0);<br/>    ms_filter_link(decoder, 0, our, 0);<br/>    ms_filter_link(our, 0, snd_card_write, 0);<br/>    ms_filter_link(our, 1, recorder, 0);</span><span id="0a73" class="mg ku iq mc b gy ml mi l mj mk">    /* We connect a callback function to the filter, and pass it as user data a pointer to a structure with program settings, in which, among others, there is a point to the logger filter. */<br/>    ms_filter_set_notify_callback(our,<br/>            (MSFilterNotifyFunc)change_detected_cb, &amp;vars);<br/>    ms_filter_call_method(our,OUR_FILTER_SET_TRESHOLD, &amp;vars.treshold); </span><span id="f957" class="mg ku iq mc b gy ml mi l mj mk">    /* Create a ticker - source of ticks. */<br/>    MSTicker *ticker = ms_ticker_new();</span><span id="6875" class="mg ku iq mc b gy ml mi l mj mk">    /* We connect the ticker. */<br/>    ms_ticker_attach(ticker, snd_card_read);<br/>    ms_ticker_attach(ticker, rtprecv);</span><span id="b997" class="mg ku iq mc b gy ml mi l mj mk">    /* If the generator frequency setting is different from zero, then we start the generator. */   <br/>    if (vars.dtmf_cfg.frequencies[0])<br/>    {<br/>        /* We set up the structure that controls the output signal of the generator. */<br/>        vars.dtmf_cfg.duration = 10000;<br/>        vars.dtmf_cfg.amplitude = 1.0;<br/>    }</span><span id="6a84" class="mg ku iq mc b gy ml mi l mj mk">    /* We organize a generator restart cycle. */<br/>    printf("Press ENTER to exit.\n ");<br/>    char c=getchar();<br/>    while(c != '\n')<br/>    {<br/>        if(vars.dtmf_cfg.frequencies[0])<br/>        {<br/>            /* We turn on the sound generator. */<br/>            ms_filter_call_method(dtmfgen, MS_DTMF_GEN_PLAY_CUSTOM,<br/>                    (void*)&amp;vars.dtmf_cfg);<br/>        }<br/>        char c=getchar();<br/>        printf("--\n");<br/>    }<br/>    if (vars.en_rec ) ms_filter_call_method(recorder, MS_FILE_REC_CLOSE, 0);<br/>}</span></pre><p id="577b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于我们添加了文件并使用了<em class="lw"> math </em>库，编译的命令行变得复杂了，看起来像这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c1bd" class="mg ku iq mc b gy mh mi l mj mk">$ gcc mstest9.c our_filter.c -o mstest9 `pkg-config Mediastreamer2 - -libs - -cflags` -lm</span></pre><p id="7ab5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">构建应用程序后，使用以下参数在第一台计算机上运行它:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1e0e" class="mg ku iq mc b gy mh mi l mj mk">$ ./mstest9 - -lport 7010 - -port 8010 - -addr &lt;address of the second computer&gt; - -rec</span></pre><p id="f21b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用以下设置在第二台计算机上运行:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="edf1" class="mg ku iq mc b gy mh mi l mj mk">$ ./mstest9 - -lport 8010 - -port 7010 - -addr &lt;address of the first computer&gt;</span></pre><p id="3fef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">之后，第一台电脑将开始将您所说的一切记录到第二台电脑的麦克风中。在这种情况下，这个词将被写入控制台</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="eb45" class="mg ku iq mc b gy mh mi l mj mk">"Recording..."</span></pre><p id="8504" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦您进入静默状态，录音将会暂停，并显示一条消息</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1e3e" class="mg ku iq mc b gy mh mi l mj mk">"Pause..."</span></pre><p id="23c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可能需要试验阈值。</p><p id="b2f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我们学习了如何编写过滤器。您可能已经注意到，<em class="lw"> our_filter_process() </em>函数对数据块执行操作。由于该示例是一个训练示例，为简单起见，媒体流的最小能力用于操纵数据块。</p><p id="443b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下一篇文章中，我们将研究媒体流中的消息队列和消息管理特性。在未来，这将有助于您设计具有更复杂信息处理的过滤器。</p><p id="3f6c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(下一篇文章<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/whats-mediastreamer2-data-movement-mechanism-29444d22d36b">什么是Mediastreamer2。数据移动机制</a></p></div></div>    
</body>
</html>