<html>
<head>
<title>Asynchronous Javascript Part 3: The Callback Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步Javascript第3部分:回调队列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-javascript-part-3-85390632dd1a?source=collection_archive---------5-----------------------#2020-02-25">https://levelup.gitconnected.com/asynchronous-javascript-part-3-85390632dd1a?source=collection_archive---------5-----------------------#2020-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fe47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">本文是关于异步Javascript的四篇系列文章的第3部分。我强烈推荐您阅读第一部分</em>  <em class="kl">和第二部分</em><a class="ae km" href="https://medium.com/@kabir4691/asynchronous-javascript-part-2-26ac20fc5ad7" rel="noopener"><em class="kl"/></a><em class="kl">，以便从本文中获得最大收益。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/bbbab6fc99628470add15052bb51d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-25KB7EbSHjv70HXrdl6w.png"/></div></div></figure><p id="143c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的文章中，我们已经讨论了Javascript的单线程执行和调用堆栈的工作方式。我们了解了Javascript中同步函数的执行方式。在本文中，我们实际上将开始研究异步函数是如何操作的，以及在Javascript中是如何按照执行顺序放置的。</p><p id="c122" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们被要求想到Javascript中最简单的异步函数之一时，大多数人会想到内置<code class="fe kz la lb lc b">setTimeout</code>函数。让我们看一个简单的例子</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="6a6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述代码在1000毫秒(1秒)的延迟后将“Hello”打印到控制台上。听起来很简单，对吧？现在让我们稍微修改一下代码。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="d7c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上代码将在延迟0秒后在控制台上打印“Hello”。这意味着它会立即打印出来。我们在<code class="fe kz la lb lc b">setTimeout</code>函数后添加一些代码怎么样？</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="b85f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码应该打印出“Hello”然后打印出“World”吧？从我们已经看到的调用堆栈来看，第1行的<code class="fe kz la lb lc b">setTimeout</code>函数应该首先进入调用堆栈，然后是第5行的<em class="kl"> console.log </em>函数。但是让我们看看实际的产量</p><pre class="ko kp kq kr gt lf lc lg lh aw li bi"><span id="3703" class="lj lk iq lc b gy ll lm l ln lo">Output:<br/>World<br/>Hello </span></pre><p id="4278" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到“世界”印在“你好”之前。这意味着第5行的控制台语句在<code class="fe kz la lb lc b">setTimeout</code>函数之前执行。这怎么可能呢？这是可能的，因为<code class="fe kz la lb lc b">setTimeout</code>函数从未进入调用堆栈。只有第5行的<em class="kl"> console.log </em>语句被发送到调用堆栈并被执行。</p><p id="6732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们看到<code class="fe kz la lb lc b">setTimeout</code>函数最终也被执行了。这是因为<code class="fe kz la lb lc b">setTimeout</code>函数被传递给了Javascript中称为<strong class="jp ir">回调队列</strong>的东西。</p><h1 id="3f2f" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">回调队列</h1><p id="ea22" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">在我们研究回调队列之前，让我们了解一些关于<code class="fe kz la lb lc b">setTimeout</code>函数的事情。我们需要知道的第一件事是<code class="fe kz la lb lc b">setTimeout</code>不是Javascript的一部分。它不在ECMAScript规范中，也不是Javascript引擎的一部分。这个功能实际上是由运行Javascript的web浏览器提供的。更准确地说，它是浏览器中<code class="fe kz la lb lc b">window</code>对象的一部分。因此，<code class="fe kz la lb lc b">setTimeout</code>函数将在浏览器上正常运行，但不能在其他类似于节点的Javascript环境中运行。还有其他功能，比如<code class="fe kz la lb lc b">setTimeout</code>，它是浏览器的一部分，但不是Javascript本身，比如<code class="fe kz la lb lc b">console</code>(打印日志)、<code class="fe kz la lb lc b">document</code>(访问HTML元素)、<code class="fe kz la lb lc b">localStorage</code>(允许在浏览器内存中保存键/值对)等等。</p><p id="c3a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当像<code class="fe kz la lb lc b">setTimeout</code>这样的异步函数被调用时，它不会被添加到调用堆栈中。而是被添加到回调队列中。回调队列，顾名思义，就是队列。因此，添加到其中的功能按照<a class="ae km" href="https://www.geeksforgeeks.org/fifo-first-in-first-out-approach-in-programming/" rel="noopener ugc nofollow" target="_blank">先进先出</a>的顺序进行处理。当Javascript中的事件循环被触发时，它首先检查调用堆栈以查看它是否非空。如果是，它执行堆栈顶部的函数。但是，如果发现调用堆栈为空，程序会继续执行。一旦程序结束，事件循环被触发，通常，它首先检查调用堆栈，看它是否为非空。如果不是，它就从栈顶开始一个接一个地执行函数。一旦调用堆栈为空，事件循环就会检查回调队列，看它是否也为非空。如果是，那么它就从队列头开始逐个执行队列中的函数。请记住，回调队列中的函数只有在</p><ol class=""><li id="11fb" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">我们已经到达了节目的结尾</li><li id="c15b" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">调用堆栈中没有要执行的函数</li></ol><p id="f8ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">起初，上面的流程听起来可能有点难以理解。让我们借助一个例子来更好地理解它。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="c5cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们创建了一个函数<em class="kl"> blockThreadFor1Sec。</em>让我们假设它包含一些运行时间大约为1秒的代码，例如循环了十亿次的for循环。当循环结束时，该函数会在控制台上显示“1秒已过”。</p><p id="f4f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在程序开始时，调用堆栈和回调队列都是空的。让我们也注意一下每一步的时间戳。目前，它为0毫秒</p><pre class="ko kp kq kr gt lf lc lg lh aw li bi"><span id="94e8" class="lj lk iq lc b gy ll lm l ln lo">Timestamp: 0 ms</span><span id="a8a2" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |<br/>|               |<br/>|               |<br/>|               |<br/>|_______________|<br/>   <br/>   Call stack</span><span id="6845" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |  <br/>|               |<br/>|               |<br/>|               |<br/>|               |<br/>   <br/>  Callback queue</span></pre><p id="44bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第1行，程序只定义了函数<em class="kl"> block1Second </em>。然后程序运行到第6行，假设我们的时间戳是1 ms(这不是准确的时间戳，只是为了简单起见取的一个粗略的值)。程序调用<code class="fe kz la lb lc b">setTimeout</code>函数，由于它是一个异步函数，Javascript将这个函数放入回调队列。</p><pre class="ko kp kq kr gt lf lc lg lh aw li bi"><span id="1e67" class="lj lk iq lc b gy ll lm l ln lo">Timestamp: 1 ms</span><span id="ce9f" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |<br/>|               |<br/>|               |<br/>|               |<br/>|_______________|<br/>   <br/>   Call stack</span><span id="f8c1" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |  <br/>|               |<br/>|               |<br/>| setTimeout()  |<br/>|               |<br/>   <br/>  Callback queue</span></pre><p id="56ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当触发事件循环时，它会看到调用堆栈为空。然后，它查看回调队列，发现它不是空的，头部有<code class="fe kz la lb lc b">setTimeout</code>函数。但是它不会立即执行它，因为该函数被设置为仅在延迟1000毫秒后执行。因此，在我们的示例中，该函数仅在时间戳为(1 + 1000) = 1001毫秒时执行。因此，setTimeout函数中的代码还没有被调用。</p><p id="2f70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后程序移动到第10行，在这一点上，假设我们的时间戳是2 ms。调用了<em class="kl"> block1Second </em>函数，因为它是一个普通的同步函数，所以它被添加到调用堆栈中。</p><pre class="ko kp kq kr gt lf lc lg lh aw li bi"><span id="66a1" class="lj lk iq lc b gy ll lm l ln lo">Timestamp: 2 ms</span><span id="9c94" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |<br/>|               |<br/>|               |<br/>| block1Second()|<br/>|_______________|<br/>   <br/>   Call stack</span><span id="0905" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |  <br/>|               |<br/>|               |    Scheduled to<br/>| setTimeout()  | -&gt; execute at<br/>|               |    1001 ms<br/>   <br/>  Callback queue</span></pre><p id="4ac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当事件循环被触发时，它看到调用堆栈是非空的。因此，它执行堆栈顶部的函数，即<em class="kl"> block1Second </em>。这个函数大约需要1秒或1000毫秒来执行。因此，当它的执行完成时，我们应该在时间戳(2 + 1000) = 1002毫秒。</p><p id="fb75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是事情变得有趣的地方。正如我们之前看到的，<code class="fe kz la lb lc b">setTimeout</code>函数被安排在1001毫秒的时间戳执行。因此，当事件循环在1001毫秒的时间戳被触发时，回调队列中的<code class="fe kz la lb lc b">setTimeout</code>函数还没有被调用，因为上面提到的条件#2需要首先满足。即调用堆栈需要为空。当<em class="kl"> block1Second </em>函数执行完毕并从调用堆栈中移除时，调用堆栈仅在1002 ms时变空。</p><p id="bfb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看在时间戳为1002 ms时发生了什么。<em class="kl"> block1Second </em>函数执行完毕，控制台上会显示“1 second elapsed”并从调用堆栈中删除该函数。</p><pre class="ko kp kq kr gt lf lc lg lh aw li bi"><span id="287c" class="lj lk iq lc b gy ll lm l ln lo">Timestamp: 1002 ms</span><span id="203f" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |<br/>|               |<br/>|               |<br/>|               |<br/>|_______________|<br/>   <br/>   Call stack</span><span id="a881" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |  <br/>|               |<br/>|               |    Scheduled to<br/>| setTimeout()  | -&gt; execute at<br/>|               |    1001 ms<br/>   <br/>  Callback queue</span></pre><p id="bab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然调用堆栈是空的，人们可能会认为<code class="fe kz la lb lc b">setTimeout</code>函数已经准备好在下一次触发事件循环时被调用。然而，情况并非如此，因为上述条件#1没有被满足。也就是说，我们还没有到达节目的结尾。因此，程序继续执行，而不执行<code class="fe kz la lb lc b">setTimeout</code>功能。</p><p id="a886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第12行，我们的时间戳是1003毫秒。程序调用了<em class="kl"> console.log </em>语句，该语句被添加到调用堆栈中，因为它是同步的。</p><pre class="ko kp kq kr gt lf lc lg lh aw li bi"><span id="05ab" class="lj lk iq lc b gy ll lm l ln lo">Timestamp: 1003 ms</span><span id="f96d" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |<br/>|               |<br/>|               |<br/>| console.log() |<br/>|_______________|<br/>   <br/>   Call stack</span><span id="a863" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |  <br/>|               |<br/>|               |    Scheduled to<br/>| setTimeout()  | -&gt; execute at<br/>|               |    1001 ms<br/>   <br/>  Callback queue</span></pre><p id="c62c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当事件循环被触发时，它看到调用堆栈对于单个函数是非空的。因此，<em class="kl"> console.log </em>函数被执行(它将“世界”打印到控制台上),然后从调用堆栈中移除。我们现在已经到达了程序的末尾，时间戳是1004毫秒。</p><pre class="ko kp kq kr gt lf lc lg lh aw li bi"><span id="fbaa" class="lj lk iq lc b gy ll lm l ln lo">Timestamp: 1004 ms</span><span id="978b" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |<br/>|               |<br/>|               |<br/>|               |<br/>|_______________|<br/>   <br/>   Call stack</span><span id="9cdf" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |  <br/>|               |<br/>|               |    Scheduled to<br/>| setTimeout()  | -&gt; execute at<br/>|               |    1001 ms<br/>   <br/>  Callback queue</span></pre><p id="7a40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当事件循环现在被触发时，它看到调用堆栈是空的。它还看到程序已经结束。现在两个条件都满足了，事件循环终于准备好移动到回调队列，从那里开始执行函数。它看到回调队列是非空的。因此，它执行队列头的函数，也就是我们的<code class="fe kz la lb lc b">setTimeout</code>函数。该函数在控制台上打印“Hello ”,之后该函数到达其执行终点，并从回调队列中移除。</p><pre class="ko kp kq kr gt lf lc lg lh aw li bi"><span id="cdcd" class="lj lk iq lc b gy ll lm l ln lo">Timestamp: 1005 ms</span><span id="e6dc" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |<br/>|               |<br/>|               |<br/>|               |<br/>|_______________|<br/>   <br/>   Call stack</span><span id="11e3" class="lj lk iq lc b gy nf lm l ln lo">|               |<br/>|               |  <br/>|               |<br/>|               |<br/>|               |<br/>|               |<br/>   <br/>  Callback queue</span></pre><p id="1f78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当事件循环再次被触发时，它看到调用堆栈是空的，程序已经到达其结尾，回调队列也是空的。因此，该程序最终被终止。</p><p id="3642" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要学习一个异步Javascript的概念，它处理承诺和微任务队列。我们将在本系列的最后一篇<a class="ae km" href="https://medium.com/@kabir4691/asynchronous-javascript-part-4-promises-6bc04d5acd0c" rel="noopener">文章</a>中了解它。</p></div></div>    
</body>
</html>