<html>
<head>
<title>Better JavaScript Fetch Functions with Currying and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Currying和TypeScript实现更好的JavaScript获取功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/better-javascript-fetch-functions-with-currying-and-typescript-6c41d9d17282?source=collection_archive---------2-----------------------#2022-03-21">https://levelup.gitconnected.com/better-javascript-fetch-functions-with-currying-and-typescript-6c41d9d17282?source=collection_archive---------2-----------------------#2022-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0e7022ed2d570e2a35fb20949ec909dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQ0K3-hnY3jHJJKU3nyutQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">斯科特·艾伦在<a class="ae kc" href="https://www.pluralsight.com/courses/learning-programming-abstractions-python" rel="noopener ugc nofollow" target="_blank"> Pluralsight </a>上的乐高积木抽象</figcaption></figure><p id="8ba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript fetch API公开了一个有效处理HTTP请求和响应的接口。借助窗口作用域的<code class="fe lb lc ld le b">fetch</code>函数，请求资源可以被异步调用。因此，函数本身将返回一个<code class="fe lb lc ld le b">Promise</code>，可以与<code class="fe lb lc ld le b">.then()</code>和<code class="fe lb lc ld le b">.catch()</code>链接，以指示成功或错误解决。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="a138" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在整个JavaScript代码库中，可以找到带有附加逻辑的类似代码段。</p><p id="08c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在考虑工程原理时，消除重复和抽象通用部件是至关重要的。这些部分可以依次组合在一起，产生我们想要的结果。</p><h1 id="22fd" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">一些重要的考虑</h1><p id="1e98" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">随着<code class="fe lb lc ld le b">async</code>函数的引入(<em class="mo">在创作</em>时具有出色的浏览器支持)，我们可以用更短、更易读的形式编写<code class="fe lb lc ld le b">Promise</code>结算。然而，当我们考虑错误处理和请求取消时，同样的可重用性原则也将适用。</p><p id="cd99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以选择预构建包，如<code class="fe lb lc ld le b">Axios</code>。虽然，外部软件包有其自身的优点和缺点。我们将使用fetch API，因为它在所有现代浏览器中都有本机可用性。</p><h1 id="ee5b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">构建块抽象</h1><p id="c7cd" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们将生成的抽象层应该是无偏见的和分离良好的。因此允许以非强制方式交换较低级别的逻辑功能。</p><p id="22b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从诊断fetch API的核心部分开始，并将它们提取到模块化实体中。</p><h2 id="ef06" class="mp lm iq bd ln mq mr dn lr ms mt dp lv ko mu mv lz ks mw mx md kw my mz mh na bi translated">承诺解决的回调</h2><p id="37c2" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们的抽象实现的消费者将需要一种在成功和失败上下文中执行代码的方法。为此，我们公开了一个回调函数，带有两个可接受的参数，如下所示:</p><pre class="lf lg lh li gt nb le nc nd aw ne bi"><span id="b260" class="mp lm iq le b gy nf ng l nh ni">type CallbackType = (response: any, error?: string | null) =&gt; void</span></pre><p id="2460" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们成功地解析了Promise时，响应被转发给第一个回调参数。如果失败，我们将<code class="fe lb lc ld le b">null</code>作为第一个参数传递，将拒绝错误消息作为第二个参数传递。或者，我们可以使用两个函数<code class="fe lb lc ld le b">successCallback</code>和<code class="fe lb lc ld le b">errorCallback</code>在不同的分辨率状态下具体触发，以便更好地分离关注点。</p><pre class="lf lg lh li gt nb le nc nd aw ne bi"><span id="4fd0" class="mp lm iq le b gy nf ng l nh ni">type SuccessCallbackType = (response: any) =&gt; void;</span><span id="d76a" class="mp lm iq le b gy nj ng l nh ni">type ErrorCallbackType = (error: string) =&gt; void;</span></pre><p id="14a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo">根据您的用例，您可以确定正确的功能粒度和分离级别。</em></p><p id="cec5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们将实现Promise chaining来传输由<code class="fe lb lc ld le b">.json()</code>返回的结果，从而避免多层嵌套的异步调用。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="3835" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们新创建的<code class="fe lb lc ld le b">retrieve</code>函数用三个参数简化了<code class="fe lb lc ld le b">Promises</code>的繁琐。</p><h2 id="9275" class="mp lm iq bd ln mq mr dn lr ms mt dp lv ko mu mv lz ks mw mx md kw my mz mh na bi translated">请求对象中间件</h2><p id="0bbe" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">进一步考虑可重用性，<code class="fe lb lc ld le b">retrieve</code>函数的第二个参数将具有需要在多个请求中标准化的键值对。</p><p id="5304" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以截取请求对象，并创建一个中间件函数来标准化我们的对象是如何构造的。我们可以传递对象本身并改变其结构属性，或者选择参数化方法:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="b4bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与我们的<code class="fe lb lc ld le b">retrieve</code>功能代码示例不同，这种方法并不适合所有用例。这个例子展示了这个想法，而不是一个被抽象以适应多用途范围的实现。</p><p id="c245" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo">请考虑如何扩大您的中间件功能，并包含仅用于特定用例的不必要部分。</em></p><h1 id="261b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将零件固化成复合材料</h1><p id="8700" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们已经成功地积累了抽象的片段，我们可以将它们组合成更简单的函数形式。</p><p id="5146" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过利用Currying，我们可以创建一个强大的复合函数，包含我们已经生成的较低层次的抽象。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="aa98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">compactFetch</code>函数将拥有几乎完全处理构建请求类型所需信息的参数。</p><p id="d892" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，封装的函数将处理额外的参数，这些参数又将被转发给我们前面提到的<code class="fe lb lc ld le b">retrieve</code>和<code class="fe lb lc ld le b">request</code>函数。</p><h2 id="2f85" class="mp lm iq bd ln mq mr dn lr ms mt dp lv ko mu mv lz ks mw mx md kw my mz mh na bi translated"><em class="nk">获取</em> &amp;帖子示例</h2><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><h1 id="465b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">最后的想法</h1><p id="6a99" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">记住插入功能粒度，并根据您的需求引入关注点分离。考虑您的系统将要与之交互的接口和冗长的含义。希望您现在可以创建更好的JavaScript获取函数。</p><h1 id="f486" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">进一步阅读</h1><div class="nl nm gp gr nn no"><a href="https://developer.mozilla.org/en-US/docs/Glossary/Abstraction" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">抽象- MDN Web文档词汇表:Web相关术语的定义</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">计算机编程中的抽象是一种降低复杂性的方法，允许在计算机编程中进行高效的设计和实现。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">developer.mozilla.org</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jw no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">使用获取API-Web API | MDN</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Fetch API提供了一个JavaScript接口，用于访问和操作HTTP管道的各个部分，例如…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">developer.mozilla.org</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc jw no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">await - JavaScript | MDN</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">await表达式会导致异步函数暂停执行，直到一个承诺被兑现(即，完成或…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">developer.mozilla.org</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc jw no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/async_function" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">异步函数表达式- JavaScript | MDN</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">async function关键字可用于在表达式中定义异步函数。您还可以定义异步…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">developer.mozilla.org</p></div></div><div class="nx l"><div class="of l nz oa ob nx oc jw no"/></div></div></a></div><h1 id="d67f" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">如果你觉得这篇文章有用，请与他人分享。一些掌声👏🏻下面多多帮忙！</h1><p id="97dc" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">通过鼓掌，你帮助其他人发现这些内容，并激发更多关于可访问性、设计、反应和JavaScript的文章的写作！</p></div></div>    
</body>
</html>