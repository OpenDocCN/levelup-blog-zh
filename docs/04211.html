<html>
<head>
<title>A Guide to Authentication in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的身份验证指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-guide-to-authentication-using-passport-local-in-react-f5b3db06d4d0?source=collection_archive---------5-----------------------#2020-06-15">https://levelup.gitconnected.com/a-guide-to-authentication-using-passport-local-in-react-f5b3db06d4d0?source=collection_archive---------5-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f47f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我如何在React中学习认证</h2></div><h2 id="4f75" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h2><p id="ddd2" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">我开始这篇文章的目的是写一个关于在React中使用Passport-Local的明确指南，因为关于这个特定主题的资源很少。React是一个构建用户界面的库，身份验证发生在浏览器和服务器之间(在我们的例子中是数据库)。因此，资源的缺乏是由于主题不直接相关。</p><p id="6e07" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">为了更深入地理解这个主题，我使用cookies和bcrypt构建了自己的身份验证方法。我对MERN (MySQL、Express、React、NodeJS)应用程序的不同元素在身份验证上下文中如何相互作用感到困惑。除了介绍注册、登录、散列密码和使用cookies，我还回顾了:</p><ul class=""><li id="e9d3" class="mc md it lg b lh lx lk ly kr me kv mf kz mg lw mh mi mj mk bi translated">如何确保CRUD考虑到已认证用户的身份，以便他们只能查看、创建、删除、更新自己的信息。</li><li id="c628" class="mc md it lg b lh ml lk mm kr mn kv mo kz mp lw mh mi mj mk bi translated">如何确保只有经过身份验证的用户才能访问某些页面？</li></ul><h2 id="00a2" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">欢迎使用认证指南！</h2><p id="bc40" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">下面是我的身份验证方法的总结:</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mq"><img src="../Images/3a7cfab12a15f65e59d88cf9cb1feafa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sOscIqnRarI1OCYRZwQX-g.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">我的身份验证方法总结</figcaption></figure><p id="9407" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">在React中，可以使用全局状态和<a class="ae ng" href="https://reactjs.org/docs/context.html#when-to-use-context" rel="noopener ugc nofollow" target="_blank">上下文</a>在组件之间共享信息。两者都是确定用户看到什么的有价值的工具；然而，我们将依靠好的老式cookies来认证用户。</p><h1 id="dad8" class="nh kj it bd kk ni nj nk kn nl nm nn kq jz no ka ku kc np kd ky kf nq kg lc nr bi translated">在MERN应用程序中认证用户的一步一步</h1><p id="5374" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">在我们深入之前，让我们澄清一些定义！注册本质上是一个创建新用户记录的请求。登录是获得访问权限的请求。通过检查数据库中是否存在该用户以及所提供的密码是否与记录中的密码相匹配来验证访问权。</p><p id="d78a" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">把注册想象成加入一个高级俱乐部的名单，把登录想象成出现并出示你的身份证以证明你是你。</p><h2 id="0bd5" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">首先，我们需要建立一些路径</h2><p id="f837" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">首先创建用户将直接与之交互的路径——我选择创建两个页面，一个用于登录，另一个用于注册。在App.js文件夹中，我创建了路线并引用了我想要呈现的页面。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ns"><img src="../Images/bd80b12ec05071b80fc3446bc79b7bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85VY8kXgV53iX9p5s4Z3cg.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">在React中创建登录和注册路由</figcaption></figure><p id="0960" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">在服务器端，我创建了一个路由<strong class="lg iu"> /api/user </strong>来处理注册和登录。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nt"><img src="../Images/209efcde590191ddcfe3566a493c76f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYq-vayEj-PadBUoStAlOw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">API调用服务器端来实际登录和注册用户</figcaption></figure><p id="99ec" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">上面的两个部分都可以在一个服务器文件上创建，或者拆分成多个文件，正如我所做的那样。概念还是一样的。</p><h1 id="3733" class="nh kj it bd kk ni nj nk kn nl nm nn kq jz no ka ku kc np kd ky kf nq kg lc nr bi translated">注册新用户</h1><p id="638f" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">当用户注册时，他们填写一个表格，其中包含姓名、用户名/电子邮件和密码等信息。对于我们的应用程序，我们将使用电子邮件作为用户的主要标识符。</p><p id="2c2e" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">…但是密码应该以某种特殊的方式存储吗？</p><p id="6472" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">我很高兴你想到了这一点！是的。一种方法是使用<a class="ae ng" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> bcrypt </strong> </a> <strong class="lg iu">，</strong>一个散列密码的库。简单地说，bcrypt将密码映射成无法识别的东西。事实上，我用密码“password”创建了20多个用户，输出的文本没有一个是相似的。因此，在服务器端，在数据库中实际创建用户记录之前，散列密码。这样，如果任何人侵入你的数据库，他们将无法获得任何实际的密码信息。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nu"><img src="../Images/09a32888756037fc62774bd28e39870c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QESohb1ZMJiKqF9urBqhw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">显示在数据库级别的用户注册</figcaption></figure><p id="3344" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">bcrypt使用异步函数来确保在创建用户记录之前对密码进行哈希处理。创建后，用户Id将被绑定到一个会话记录。由于注册和登录的方法类似，我将在后面解释。</p><h1 id="ac27" class="nh kj it bd kk ni nj nk kn nl nm nn kq jz no ka ku kc np kd ky kf nq kg lc nr bi translated">登录现有用户</h1><p id="0c22" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">当用户登录时，他们用用户名/电子邮件和密码填写表单。这些值被捆绑在API请求中。</p><p id="4770" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">在服务器端，我们首先检查用户是否存在，然后检查密码是否有效。注意，比较不是三重相等的——事实是<em class="nv">我们</em>不能直接匹配它们，但是bcrypt compare函数可以。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nw"><img src="../Images/1d8de484b4705ac693bf214646220e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4aDJMIuHNvhvVJQVl0U9g.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">用户登录显示在数据库级别</figcaption></figure><p id="0200" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">太好了，我们已经从技术上验证了一个用户！现在，我们需要使<em class="nv">意味着</em>某事:</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c62c21a3ed4317548ba4ff59e5e15711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*iy7eklvBgmHnjvgO.gif"/></div></figure><h1 id="f601" class="nh kj it bd kk ni nj nk kn nl nm nn kq jz no ka ku kc np kd ky kf nq kg lc nr bi translated">使用Cookies来限制访问</h1><h2 id="cb7b" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">基于已验证的用户信息限制访问</h2><p id="9bc2" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">让我们访问数据库来理解信息是如何交互的:用户数据(姓名、电子邮件、散列密码)存储在用户表中。第二个表通过跟踪用户和活动会话Cookies关系来存储用户会话。每次我们给用户一个cookie时，我们都将cookie值和用户的id存储在这个用户会话表中。用户与用户会话具有一对多的关系，这意味着从技术上讲，一个用户可以同时在多个浏览器上进行身份验证，比如ipad、iphone和笔记本电脑。</p><h1 id="9037" class="nh kj it bd kk ni nj nk kn nl nm nn kq jz no ka ku kc np kd ky kf nq kg lc nr bi translated">我们将如何使用Cookies</h1><p id="3b5e" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">现在是饼干时间！<a class="ae ng" href="https://en.wikipedia.org/wiki/HTTP_cookie" rel="noopener ugc nofollow" target="_blank">cookie</a>是浏览器存储的一段数据，随每个请求一起发送。</p><p id="98f2" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">当用户通过身份验证后，将会创建一个cookie。由于cookie包含在每个请求中，服务器将能够使用会话cookie来确认用户的身份。对于每个CRUD请求，我们将首先检查会话cookie，并使用用户会话表将cookie匹配回用户，如果关系存在，则返回用户的身份。一旦用户退出，cookie就会被删除，用户会话记录也会被删除。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/bf16f60c2b6c61223f2bf116895bcec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*ScWBGarg_MVbreP_.gif"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">如何设置Cookies的图示</figcaption></figure><p id="6e37" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">在这篇文章中，Piraveena很好地描述了浏览器和服务器之间的关系。看看吧，供你参考。</p><h1 id="8c62" class="nh kj it bd kk ni nj nk kn nl nm nn kq jz no ka ku kc np kd ky kf nq kg lc nr bi translated">创建Cookie是最简单的部分</h1><p id="74f7" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">创建一个cookie很简单，但是很难让它足够独特以至于不能被破解。欢迎回来bcrypt！</p><pre class="mr ms mt mu gt nz oa ob oc aw od bi"><span id="158e" class="ki kj it oa b gy oe of l og oh">let cookievalue = bcrypt.hash("secretword",10)</span></pre><p id="9f6e" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">要设置cookie，我们只需要将它与一个响应联系起来</p><pre class="mr ms mt mu gt nz oa ob oc aw od bi"><span id="41f5" class="ki kj it oa b gy oe of l og oh">res.cookie("cookiename", cookievalue)</span></pre><p id="381e" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">在您的应用程序中，您可以检查Inspect下的应用程序选项卡，以查看这是否正常工作。下面是如何将会话cookie的创建与登录过程联系起来的方法:</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oi"><img src="../Images/a29a069e2ac6ba40d8ca97f33b8c20cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRjdu2d_xlll2-5p3L8ppg.png"/></div></div></figure><p id="ac93" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">您可以采用类似的方法进行注册，但是您需要等待在数据库中创建用户，而不是等待确认密码是否存在。从响应中获取用户Id来创建用户会话记录。在创建用户会话之前，客户端不会收到响应。</p><h1 id="a1d7" class="nh kj it bd kk ni nj nk kn nl nm nn kq jz no ka ku kc np kd ky kf nq kg lc nr bi translated">删除Cookies也一样简单</h1><p id="adbd" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">当用户注销时，我们删除浏览器中的cookies，并从数据库中删除用户会话关系。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b747f80f1c1db13cf10a0efadd9c88d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*83gTqgCsK6rg_UAZ.gif"/></div></figure><p id="65b1" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">Cookies会随每个请求一起发送。要访问您特别设置的cookie，您可以使用解析器。我选择自己解析cookie，以便更好地理解解析是如何工作的。注意decodeURIComponent的用户撤销设置cookie时发生的URL编码。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oj"><img src="../Images/ad68c6d70f049a3971aae84b158f9586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50kJGWG4I0VZ8sF2seX87g.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">如何删除用户并解析出cookie</figcaption></figure><h1 id="a395" class="nh kj it bd kk ni nj nk kn nl nm nn kq jz no ka ku kc np kd ky kf nq kg lc nr bi translated">污垢是棘手的部分</h1><p id="bf92" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">关于cookies，我们学到的最重要的一点是它们被附加到所有的请求中。这意味着在客户端，我们不需要添加或提供额外的信息来发出API请求。</p><p id="0b62" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">流程如下:</p><ul class=""><li id="b1b1" class="mc md it lg b lh lx lk ly kr me kv mf kz mg lw mh mi mj mk bi translated">解析cookie以获得您的特定cookie</li><li id="c57e" class="mc md it lg b lh ml lk mm kr mn kv mo kz mp lw mh mi mj mk bi translated">使用cookie的值向用户会话表发出请求</li><li id="a6a7" class="mc md it lg b lh ml lk mm kr mn kv mo kz mp lw mh mi mj mk bi translated">如果结果为空，或者不存在任何关系，则不返回任何内容</li><li id="af82" class="mc md it lg b lh ml lk mm kr mn kv mo kz mp lw mh mi mj mk bi translated">如果匹配，则返回用户id，然后使用该Id来完成用户最初发出的请求</li></ul><p id="e53f" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">每次用户发出请求时，我们都会检查他们的凭证，但检查的方式非常微妙，以至于客户都不知道。</p><p id="f8e5" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">这种方法是有效的，因为如果用户注销他们的身份验证，用户会话表上的记录将被擦除，他们将被要求重新登录。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/7e4d17405292311b5136581285d00dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*qXt1ulYnDauuDsVj.gif"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">用户会话需要存在，用户才能访问</figcaption></figure><h1 id="2503" class="nh kj it bd kk ni nj nk kn nl nm nn kq jz no ka ku kc np kd ky kf nq kg lc nr bi translated">语境呢？</h1><p id="443f" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">因为我们正在构建一个MERN应用程序，所以上下文是一个跨React组件共享信息的工具。即使您选择使用用户上下文来跟踪是否有经过身份验证的用户登录，您仍然需要使用cookies来验证用户。上下文对于限制用户在给定时间可以查看哪些页面仍然很有价值。例如，设置每次页面加载时检查cookie的上下文，如果有cookie，您可以显示注销按钮，因为这意味着用户已登录。</p><p id="3999" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">由于上下文在客户端，我们不想依赖它作为确认用户身份的方法。</p><h1 id="7a23" class="nh kj it bd kk ni nj nk kn nl nm nn kq jz no ka ku kc np kd ky kf nq kg lc nr bi translated">下一步是什么？</h1><p id="c481" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">既然您已经了解了身份验证是如何工作的，那么您可以探索其他资源，这些资源可以教您如何使用Passport、indexedDB、cookie-parse、firebase-authentication等。世界是你的。</p></div></div>    
</body>
</html>