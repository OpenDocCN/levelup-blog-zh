<html>
<head>
<title>Introducing high-performance datatypes in Python with the collections library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过集合库引入Python中的高性能数据类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introducing-high-performance-datatypes-in-python-with-the-collections-library-3d8c334827a5?source=collection_archive---------1-----------------------#2019-10-15">https://levelup.gitconnected.com/introducing-high-performance-datatypes-in-python-with-the-collections-library-3d8c334827a5?source=collection_archive---------1-----------------------#2019-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="29e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">艺术收藏…蟒蛇艺术！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/624c5c0f9a471970fc2e614315e6643a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chIvUAhdF_HOMiV7Qjktbw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来看看Python精彩的艺术收藏吧！</figcaption></figure><blockquote class="ky kz la"><p id="1777" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">想获得灵感？快来加入我的<a class="ae ly" href="https://www.superquotes.co/?utm_source=mediumtech&amp;utm_medium=web&amp;utm_campaign=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="le iu">超级行情快讯</strong> </a>。😎</p></blockquote><p id="0993" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">Python最大的优势之一是它广泛的模块和包选择。这些将Python的功能扩展到许多热门领域，包括机器学习、数据科学、web开发、前端等等。其中最好的一个是Python内置的<em class="ld">集合</em> <em class="ld">模块</em>。</p><p id="c5c3" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">一般来说，Python中的<em class="ld">集合</em>是用来存储数据集合的容器，比如list、dict、tuple和set。这些容器内置于Python中，可以开箱即用。<a class="ae ly" href="https://docs.python.org/2/library/collections.html" rel="noopener ugc nofollow" target="_blank"> <em class="ld">集合模块</em> </a> <em class="ld"> </em>提供了额外的、高性能的数据类型，可以增强您的代码，使事情变得更加简洁和容易。</p><p id="8206" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">让我们浏览一下collections模块最流行的数据类型以及如何使用它们的教程！</p><h1 id="a096" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(1)计数器</h1><p id="365c" class="pw-post-body-paragraph lb lc it le b lf mu ju lh li mv jx lk lz mw ln lo ma mx lr ls mb my lv lw lx im bi translated"><strong class="le iu">计数器</strong>是字典对象的子类。collections模块中的<code class="fe mz na nb nc b">Counter()</code>函数接受一个iterable，比如一个list或tuple，并返回一个计数器字典。字典的键将是iterable的唯一元素，每个键的值将是iterable中元素的计数。</p><p id="9beb" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">首先，让我们从集合中导入<code class="fe mz na nb nc b">Counter</code>数据类型:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4f61" class="nh md it nc b gy ni nj l nk nl">from collections import Counter</span></pre><p id="ad03" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">要创建一个<code class="fe mz na nb nc b">Counter</code>对象，将它赋给一个变量，就像你对任何其他对象类所做的那样。你想传递给它的唯一参数是你的iterable。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="42b1" class="nh md it nc b gy ni nj l nk nl">lst = [1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 1, 1]<br/>counter = Counter(lst)</span></pre><p id="c071" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">如果我们在对象<code class="fe mz na nb nc b">print(counter)</code>周围使用一个简单的打印函数打印出我们的计数器，我们将得到看起来有点像字典的东西:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="306d" class="nh md it nc b gy ni nj l nk nl">Counter({1: 7, 2: 5, 3: 3})</span></pre><p id="299e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">您可以使用如下所示的键来访问任何计数器项目。这与从标准Python字典中提取元素的方式完全相同。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="96b0" class="nh md it nc b gy ni nj l nk nl">lst = [1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 1, 1]<br/>counter = Counter(lst)<br/>print(counter[1])</span></pre><h2 id="ca18" class="nh md it bd me nm nn dn mi no np dp mm lz nq nr mo ma ns nt mq mb nu nv ms nw bi translated">最常见的()函数</h2><p id="56c5" class="pw-post-body-paragraph lb lc it le b lf mu ju lh li mv jx lk lz mw ln lo ma mx lr ls mb my lv lw lx im bi translated">到目前为止，<code class="fe mz na nb nc b">Counter</code>对象最有用的函数是<code class="fe mz na nb nc b">most_common()</code>函数。当它应用于一个<code class="fe mz na nb nc b">Counter</code>对象时，它返回一个列表，列出了<code class="fe mz na nb nc b"><em class="ld">N</em></code>个最常见的元素及其数量，从最常见到最不常见。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bb69" class="nh md it nc b gy ni nj l nk nl">lst = [1, 2, 3, 3, 2, 1, 1, 1, 2, 2, 3, 1, 2, 1, 1]<br/>counter = Counter(lst)<br/>print(counter.most_common(2))</span></pre><p id="779f" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">上面的代码打印出以下元组列表:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4b6a" class="nh md it nc b gy ni nj l nk nl">[(1, 7), (2, 5)]</span></pre><p id="cbe1" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">每个元组的第一个元素是列表中的唯一项，每个元组的第二个元素是计数。这是一种快速简单的方法，比如“获取列表中最常见的前3个元素及其数量”。</p><p id="f221" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">要阅读更多关于计数器功能的信息，请查阅<a class="ae ly" href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h1 id="8397" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(2)违约声明</h1><p id="af3e" class="pw-post-body-paragraph lb lc it le b lf mu ju lh li mv jx lk lz mw ln lo ma mx lr ls mb my lv lw lx im bi translated"><strong class="le iu"> defaultdict </strong>的工作方式和普通的python字典完全一样，额外的好处是当你试图访问一个不存在的键时，它不会抛出错误。</p><p id="e00d" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">相反，它用默认值初始化密钥。默认值是根据创建<code class="fe mz na nb nc b">defaultdict</code>对象时作为参数传递的数据类型自动设置的。请看下面的代码示例。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5237" class="nh md it nc b gy ni nj l nk nl"><em class="ld">from </em>collections <em class="ld">import </em>defaultdict<br/><br/>names_dict = defaultdict(int)<br/>names_dict["Bob"] = 1<br/>names_dict["Katie"] = 2<br/>sara_number = names_dict["Sara"]<br/>print(names_dict)</span></pre><p id="e689" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在上面的例子中，<code class="fe mz na nb nc b">int</code>作为默认值被传递给我们的<code class="fe mz na nb nc b">defaultdict</code>对象。接下来，为每个键定义值，即“Bob”和“Katie”的数字。但是在最后一行中，我们试图访问一个尚未定义的键，即“Sara”的键。</p><p id="b882" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在普通的字典中，这将抛出一个错误。但是使用<code class="fe mz na nb nc b">defaultdict</code>，一个新的键被自动初始化为“Sara ”,值为0，对应于我们的<code class="fe mz na nb nc b">int</code>数据类型。因此，最后一行打印出包含所有3个名称和相应值的字典。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="768e" class="nh md it nc b gy ni nj l nk nl">defaultdict(&lt;class 'int'&gt;, {'Bob': 1, 'Katie': 2, 'Sara': 0})</span></pre><p id="64be" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">如果我们用一个类似于<code class="fe mz na nb nc b">names_dict = defaultdict(list)</code>的列表来初始化我们的<code class="fe mz na nb nc b">defaultdict</code>，那么“Sara”会用一个空列表<code class="fe mz na nb nc b">[]</code>来初始化，代码会打印出如下内容:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a0ad" class="nh md it nc b gy ni nj l nk nl">defaultdict(&lt;class 'int'&gt;, {'Bob': 1, 'Katie': 2, 'Sara': []})</span></pre><p id="ef4f" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">要了解更多关于defaultdict的功能，请查看官方文档<a class="ae ly" href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="fece" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(3)得缺</h1><p id="510c" class="pw-post-body-paragraph lb lc it le b lf mu ju lh li mv jx lk lz mw ln lo ma mx lr ls mb my lv lw lx im bi translated"><a class="ae ly" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank"> <em class="ld">队列</em> </a>是计算机科学中遵循先入先出(FIFO)原则的基本数据结构。简单地说，这意味着添加到队列中的第一个对象也必须是第一个被删除的对象。我们只能在队列的前面插入东西，并且只能从后面移除东西——队列中间没有动作。</p><p id="d14f" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><em class="ld">集合</em>库的<strong class="le iu">队列</strong>实现了精确功能的优化版本。该实现的一个关键特性是保持队列的大小——也就是说，如果您将队列的最大大小设置为10，那么<code class="fe mz na nb nc b">deque</code>将根据FIFO原则添加和删除元素，以保持最大大小为10。这是目前Python中最好的队列实现。</p><p id="97c7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">先说个例子。我们将创建一个<code class="fe mz na nb nc b">deque</code>对象，然后用从1到10的整数初始化它。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c328" class="nh md it nc b gy ni nj l nk nl"><em class="ld">from </em>collections <em class="ld">import </em>deque<br/><br/>my_queue = deque(maxlen=10)<br/><br/><em class="ld">for </em>i <em class="ld">in </em>range(10):<br/>    my_queue.append(i+1)<br/><br/>print(my_queue)</span></pre><p id="d0b5" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在上面的代码中，我们首先初始化了我们的<code class="fe mz na nb nc b">deque</code>，指定我们希望它总是保持最大长度10。第二，我们通过一个循环将值插入到我们的队列中。请注意填充队列的方式与我们处理常规Python列表的方式完全相同。最后，我们打印出结果。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="891d" class="nh md it nc b gy ni nj l nk nl">deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], maxlen=10)</span></pre><p id="7794" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">因为我们的队列有一个<code class="fe mz na nb nc b">maxlen=10</code>并且我们的循环增加了10个元素，所以我们的队列包含了从1到10的所有数字。现在让我们看看当我们添加更多的数字时会发生什么。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b826" class="nh md it nc b gy ni nj l nk nl"><em class="ld">for </em>i <em class="ld">in </em>range(10, 15):<br/>    my_queue.append(i+1)<br/><br/>print(my_queue)</span></pre><p id="8228" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在上面的代码中，我们向队列中添加了另外5个元素，数字从11到15。但是我们的队列只有一个<code class="fe mz na nb nc b">maxlen=10</code>，所以它必须删除一些元素。因为队列必须遵守FIFO原则，所以它删除了插入到队列中的前5个元素，精确地按照它们的插入顺序:[1，2，3，4，5]。print语句的结果如下:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d5fc" class="nh md it nc b gy ni nj l nk nl">deque([6, 7, 8, 9, 10, 11, 12, 13, 14, 15], maxlen=10)</span></pre><p id="276f" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">要了解更多关于<code class="fe mz na nb nc b">deque</code>的功能，请查看<a class="ae ly" href="https://docs.python.org/2/library/collections.html#collections.deque" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h1 id="e71a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">(4)命名元组</h1><p id="3389" class="pw-post-body-paragraph lb lc it le b lf mu ju lh li mv jx lk lz mw ln lo ma mx lr ls mb my lv lw lx im bi translated">当您在Python中创建一个常规元组时，它的元素是通用的和未命名的。这迫使您记住每个元组元素的确切索引。<strong class="le iu">名为</strong>的车钩就是这个问题的解决方案。</p><p id="c68a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><code class="fe mz na nb nc b">namedtuple()</code>返回一个元组，该元组中每个位置都有固定的名称，还有一个通用名称用于<em class="ld"> namedtuple </em>对象。要使用一个<code class="fe mz na nb nc b">namedtuple</code>，首先要为它创建一个模板。下面的代码创建了一个名为“Person”的<code class="fe mz na nb nc b">namedtuple</code>模板，带有属性“name”、“age”和“job”。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5e87" class="nh md it nc b gy ni nj l nk nl"><em class="ld">from </em>collections <em class="ld">import </em>namedtuple<br/><br/>Person = namedtuple('Person', 'name age job')</span></pre><p id="d957" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">一旦创建了模板，就可以用它来创建<code class="fe mz na nb nc b">namedtuple</code>对象。让我们为两个人创建两个<code class="fe mz na nb nc b">namedtuple</code>，并打印出他们的表示。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2b3c" class="nh md it nc b gy ni nj l nk nl">Person = namedtuple('Person', 'name age job')<br/><br/>Mike = Person(name='Mike', age=30, job='Data Scientist')<br/>Kate = Person(name="Kate", age=28, job='Project Manager')<br/><br/>print(Mike)<br/>print(Kate)</span></pre><p id="8a6d" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">上面的代码非常简单——我们用<code class="fe mz na nb nc b">namedtuple</code> <em class="ld"> </em>模板的所有属性初始化一个“人”。上面的打印语句将给出以下结果:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e7cf" class="nh md it nc b gy ni nj l nk nl">Person(name='Mike', age=30, job='Data Scientist')<br/>Person(name='Kate', age=28, job='Project Manager')</span></pre><p id="e3b7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">因此，<code class="fe mz na nb nc b">namedtuples</code>使得元组对象的使用、可读性和组织更加容易。</p><p id="e536" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">要了解更多关于<code class="fe mz na nb nc b">namedtuple</code>的功能，请查看<a class="ae ly" href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="2ab7" class="mc md it bd me mf oe mh mi mj of ml mm jz og ka mo kc oh kd mq kf oi kg ms mt bi translated">喜欢学习？</h1><p id="b591" class="pw-post-body-paragraph lb lc it le b lf mu ju lh li mv jx lk lz mw ln lo ma mx lr ls mb my lv lw lx im bi translated">在推特<a class="ae ly" href="https://twitter.com/GeorgeSeif94" rel="noopener ugc nofollow" target="_blank">上关注我，我会在这里发布所有最新最棒的人工智能、技术和科学！也在LinkedIn </a>上与我联系！</p></div></div>    
</body>
</html>