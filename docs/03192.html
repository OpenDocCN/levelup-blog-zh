<html>
<head>
<title>From infant to rebellious teenager: Using create-react-app to build an enterprise worthy web application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从婴儿到叛逆少年:使用create-react-app构建值得企业使用的web应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/from-infant-to-rebellious-teenager-using-create-react-app-to-build-an-enterprise-worthy-web-bcafb0a06c45?source=collection_archive---------10-----------------------#2020-04-24">https://levelup.gitconnected.com/from-infant-to-rebellious-teenager-using-create-react-app-to-build-an-enterprise-worthy-web-bcafb0a06c45?source=collection_archive---------10-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1d95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，你已经说服你的老板(或者你自己)在这个项目中使用React了？太棒了，不错的选择。如今很少有框架像React一样有开发者的支持和行业的支持。脸书还创造了这个伟大的启动React的方式，叫做<a class="ae ko" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>(从现在开始，我们简称它为CRA)。你要做的就是</p><blockquote class="kp"><p id="96d8" class="kq kr it bd ks kt ku kv kw kx ky kn dk translated">&gt;创建-反应-应用我的应用<br/> &gt;光盘我的应用<br/> &gt; npm开始</p></blockquote><p id="1744" class="pw-post-body-paragraph jq jr it js b jt kz jv jw jx la jz ka kb lb kd ke kf lc kh ki kj ld kl km kn im bi translated">然后嘣！React项目。你可以把这个项目(做一两个非常小的调整)部署到你选择的服务中(在这种情况下，我使用Heroku ),在创建我的项目后的20分钟内，我就把它部署到了云中，我知道继续开发和逐步提供新功能对我来说非常容易。</p><p id="6e6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="le">(注意:这是一个架构帖子，不是一个工作示例帖子，所以不要指望看完这篇文章后会有功能代码。我只是想给你提供一些资源，帮助你像我一样导航这个旅程。)</em></p><p id="1eb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在对框架一无所知的情况下开始使用React。适应事物的反应方式是…有趣的。就过去使用单页应用程序(SPA)框架而言，我唯一的经验是Angular。Angular在设计方面很好地分离了关注点(路由、模板等)，但我偶尔会遇到状态管理方面的挑战。当我需要一个更复杂的数据结构并将其绑定到页面上的一个元素时，我总是觉得自己在违背Angular的意愿。我觉得我写了太多的转换代码，以至于无法把方钉装进圆孔。React并没有完全解决这个问题，但是能够将一个属性作为参数传递给一个组件，将该属性转换为状态，并基于该状态呈现一个视图……这听起来简单多了。再加上React增加的<a class="ae ko" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>，你真的可以以合理的速度编写出可重用的代码。我尽可能多地进行代码重用(稍后会有更多关于这方面的挑战)。</p><p id="5abc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，这个项目进行了六个月左右..我有很多概念验证的东西。我的部署管道已经和Heroku建立好了。从我的QA服务器到产品，需要几分钟来提升一个发布，尽管我在我的持续部署策略中缺少一些质量关，但我对它的工作方式很满意。</p><h1 id="799f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">弹出还是不弹出？</h1><p id="9343" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">对于你们中的一些人来说，此时你可能会想“好吧，但是如果你想为‘企业’做点什么，你需要扔掉你的CRA”。你说的弹射是什么意思？这张图表应该能解释一切:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/b887909368d8e334fbbbb4f583fc5061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*xLvT4Jw5bjh2z5F3pgmgFQ.jpeg"/></div></figure><p id="6aa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你在create-react-app eject上进行谷歌搜索，你会得到解释为什么不这样做的博文:)在这种情况下，你所做的是暴露容器的底层配置(Webpack、Babel、ESLint等)，所以你可以随心所欲地使用它。弹射的大问题是你不能把猫放回包里。一旦你这么做了，你就只能靠自己了。</p><p id="071b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实是，为了实现我的长期目标，我需要做“一些事情”，不管我是否决定放弃我的申请。我错过了一些阻碍我进步的关键事情:</p><ul class=""><li id="e8ac" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><strong class="js iu">性能。</strong>嘿，给你们所有人一个快速提醒，当你在没有任何配置的情况下部署CRA时，你是在你的服务器上运行“react-scripts start”。这意味着您正在开发模式下运行！显然，有更好的方法在服务器上运行你的应用程序(事实上，一旦你运行react-scripts build，CRA会告诉你如何运行一个build，但这需要额外的服务器配置步骤)。如果你像我一样，在Heroku上运行react服务器，我会推荐使用<a class="ae ko" href="https://github.com/mars/create-react-app-buildpack" rel="noopener ugc nofollow" target="_blank">create-react-app-build pack</a>，因为这是一个很好的中间步骤，让我在没有SEO的情况下在我的服务器上运行生产就绪代码。</li><li id="c7a6" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">(前述)SEO </strong>。默认情况下，CRA建立了一个模板html文件。有一些项目(<a class="ae ko" href="https://github.com/nfl/react-helmet" rel="noopener ugc nofollow" target="_blank">头盔</a>)会在客户端重写你的HTML头，但通常这在游戏中对爬虫来说已经太晚了，无法正确地分析你页面上的内容，并留给你非常不合理的内容页面预览。如果你正在建立任何依赖动态内容/SEO的系统，我鼓励你继续阅读。</li></ul><p id="3ac2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就如何实现SEO而言，有一些解决方案可以让你缓存网页的预渲染状态(想到了<a class="ae ko" href="https://prerender.io/" rel="noopener ugc nofollow" target="_blank"> prerender.io </a>),但这些解决方案带有额外的价格标签和配置，这使得我很难保持CRA的完整性。我最终决定我需要在我的应用程序中实现服务器端渲染(SSR)。CRA是完全客户端渲染的(CSR)，这意味着所有代码都被推送到客户端(您的浏览器)，然后DOM树被动态解析。SSR允许你把你需要的东西推送到客户端(浏览器)，并允许你通过<a class="ae ko" href="https://developers.google.com/web/fundamentals/performance/optimizing-javascript/code-splitting" rel="noopener ugc nofollow" target="_blank">代码分割</a>来优化你的代码。所以最后，我决定我要</p><ol class=""><li id="f4ae" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn ne mw mx my bi translated">一种通过CRA继续开发的方式(这意味着我不想放弃我的项目)</li><li id="5cbc" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn ne mw mx my bi translated">一种运行Express应用程序的方法，该应用程序按照开发人员的意图与我的CRA进行通信</li></ol><p id="1539" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想知道，是的，我研究了诸如<a class="ae ko" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>和<a class="ae ko" href="https://www.gatsbyjs.org/" rel="noopener ugc nofollow" target="_blank">Gatsby</a>(<a class="ae ko" href="https://dev.to/jameesy/gatsby-vs-next-js-what-why-and-when-4al5" rel="noopener ugc nofollow" target="_blank">https://dev . to/Jame esy/Gatsby-vs-next-js-what-why-and-when-4a l5</a>)等框架，并决定推出自己的框架。坦率地说，Gatsby不在我的用例中，因为我从一个API中生成大量动态内容(据我所知，Gatsby是静态呈现页面的方式)，我觉得选择类似Next.js的东西太落后了。如果你正准备开始一个项目，基于我目前所说的，你可以考虑Next.js。</p><p id="b8eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重构我的代码库以满足上述标准是一项充满爱心的工作，花了几个周末的时间，并进行了大量的反复试验。我将在下面强调我在这个项目中遇到的挑战:</p><h1 id="b75c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">覆盖Webpack而不弹出</h1><p id="e3e2" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">有多种方法可以在不弹出CRA的情况下覆盖web pack配置。我现在为我的项目定制了一个web pack配置。这个<a class="ae ko" href="https://loadable-components.com/" rel="noopener ugc nofollow" target="_blank">可加载组件</a>项目给了我很多灵感，让我最终采用了这个解决方案，这让我在这段时间的生活变得简单了很多。老实说，这个项目中伟大的代码示例。</p><h1 id="0085" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">节点应用程序的静态入口点</h1><p id="bf42" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了正确地进行SSR，我现在有了一个nodejs入口点来启动一个Express服务器。将React与SSR Express应用程序正确集成的关键是:</p><ul class=""><li id="4095" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><strong class="js iu">正确配置巴别塔。我经历了无数次babel配置和页面错误的迭代，最终理解了一切是如何工作的。我学到的比我想知道的要多。老实说，这就是人们不退出CRA的原因。</strong></li><li id="792a" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">处理路由。</strong>在我的CRA中，我使用了一个路由器(更准确地说是BrowserRouter)来控制稍后将在管道中呈现的组件。由于节点应用程序中缺少“窗口”组件，BrowserRouter不支持SSR，但幸运的是存在一个StaticRouter，它将完成这个任务。</li></ul><h1 id="0787" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">代码分割(如果需要)</h1><p id="e5ca" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我的应用程序中有几个组件需要我进行代码拆分(即它们只运行CSR)才能让我的应用程序正常运行。</p><h1 id="6cf0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我的(非常简单的)SEO解决方案</h1><p id="d687" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我的SSR SEO解决方案是这样实现的:从对API层的调用中提取元数据，并在html呈现给浏览器之前将这些meta标签注入到html的头部。这消除了任何CSR元标签渲染的需要，对此我很高兴。并不是我的所有端点都需要SEO(或者有SEO)，所以我拦截所有流量并检查(通过请求url上的regex)是否需要请求元数据。</p><h1 id="e655" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">其他需要考虑的事情</h1><p id="f19e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">实现和部署传统的node SSR应用程序是我的应用程序从婴儿到青少年时期面临的最大挑战，但远不是唯一的挑战。其他一些是:</p><ul class=""><li id="7028" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><strong class="js iu">你的CRA的文件夹结构。</strong>在拥有数百个组件之前，您可能会忽略这一点。此外，没有人真正给你指导如何正确地进行导入，一旦你有了模块的文件夹和子文件夹，并且你的导入与相对路径(例如../../等等)。这里的外卖是；尽早在项目中实现绝对路径。您会发现应该如何做有不同的方法(和观点),但这完全取决于您，web pack允许您定义别名来为您的导入构建正确的绝对路径。</li><li id="fc09" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">上菜的画面。</strong>静态资产位于我的节点服务器上，但是我有一些依赖关系，需要我加载一些图像作为它们的base64表示(例如，我在地图上放置自定义标记),确定这种巴别塔配置是一个挑战。</li><li id="c369" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu"> UX </strong>。我的职业是开发人员，不是设计师。因此，它看起来像是开发人员创建的。是的，我使用了<a class="ae ko" href="https://react-bootstrap.github.io/" rel="noopener ugc nofollow" target="_blank"> react-bootstrap </a>来实现我的UI，以及其他各种react化的组件。如果你坚持KISS范式(保持简单，愚蠢)，你将能够超越你的大多数引导风格，给你一个适当的审美。尽可能使用flexbox和列，因为它使得处理移动响应/断点更加容易。</li></ul><h1 id="873a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从叛逆的少年到成熟的成年人</h1><p id="0566" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">还剩下什么？软件是福也是祸，因为它永远不会完成。我有一个稳定运行的应用程序，满足了我需要它做什么的前提，但随着时间的推移，总会有一些改进可以让它变得更强大。以下是我将来想做的几件事:</p><ul class=""><li id="67f4" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><strong class="js iu">性能更佳。</strong>其中一部分来自缓存来自浏览器API的内容，另一部分将通过更好(更彻底)的代码分割来消除那些通过网络到达浏览器的大负载。</li><li id="001b" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">共享的状态/资源。我不用Redux。这部分是由于该应用程序具有高度的事务性，大多数时候，每个页面上加载的内容都是动态的。也就是说，我可以通过实现某种不在每次页面请求时重新加载的状态来大大提高高级用户的性能。</li><li id="19d2" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">更好的组件重用。</strong>我有许多本质上提供类似功能的容器，只是在主题上稍有变化。我想将这些容器重构为单个表单/视图组件，并实现某种模式，允许这些表单/视图组件中的内容独立于容器构建。</li><li id="fb0f" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">少课，多钩。现在我真正理解了React中的钩子范式，在我使用类的许多情况下使用它们更有意义。我已经完成了将一些类重构为函数挂钩的大部分简单工作，但是我保留了一些容器，因为它们具有复杂的状态。</strong></li><li id="f3e7" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">客户端的API实现。</strong>现在我有一个API js类，它包装了我的API，使用Axios发出请求并返回数据。然后由每个组件来转换响应。我考虑过使用GraphQL作为一个抽象，但是现在这可能是一个过度工程化的解决方案。我可以预见一个未来的状态，在这个状态下，对API的改变不太需要，GraphQL作为中介更有意义。</li></ul><p id="3374" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常感谢你能走到这一步！我希望这篇文章能帮助你在谷歌搜索中找到对你的旅程有帮助的资源。</p></div></div>    
</body>
</html>