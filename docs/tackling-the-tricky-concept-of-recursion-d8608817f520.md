# 递归:处理一个棘手的概念

> 原文：<https://levelup.gitconnected.com/tackling-the-tricky-concept-of-recursion-d8608817f520>

![](img/f42e3d2c231464158ae4d5b29ee1b5b2.png)

对一些人来说，货币兑换可能是一个棘手的话题，但是一旦你得到了它，你就会得到*它。在本文中，我将简要介绍什么是递归，它是如何工作的，以及为什么它很重要。*

*当我第一次了解递归的概念时，我很纠结。我想:“对我来说，学习编写函数的细节已经够难的了，现在你要我在函数内部编写函数？”对我来说，这是一个很难理解的概念，但就像软件工程中的许多其他事情一样，一旦它成功了，它就成功了。*

*在我们开始解释和举例之前，让我们简单地讨论一下什么是递归，以及为什么你应该关注递归。*

> *对于一些人来说，递归可能是一个难以理解的话题，但是一旦你理解了，你就明白了。*

# *到底什么是递归？*

*本质上，递归是一个调用自身的过程。在本文中，我们将在 JavaScript 函数的上下文中探索这个概念。*

*以这种方式调用函数有几个不同的原因。有时它使事情变得简单，有时它使事情变得不必要的复杂，但是在它使事情变得简单的情况下，知道如何实现是非常重要的。*

*让我们快速回顾一下递归重要的一些原因，以及你可能会发现它有用的上下文。*

# *为什么递归很重要？*

*递归对于**很重要，原因有多种:***

## *DOM 遍历算法*

*DOM 可以被看作一个树状结构。这棵树有许多分支，每个分支又有许多分支，如此循环往复。(想象一下 div 中的 div…)。当使用递归函数时，遍历这样的复杂对象会变得更容易/更快。*

## *对象遍历*

*与上面的观点类似，对象本身可以变得非常复杂，并且有大量的数据相互嵌套。递归使得访问这些数据更容易/更快。*

## *从复杂的数据结构中访问数据*

*遍历涉及树或图的结构(或搜索数据)通常涉及利用递归的解决方案。*

## *有时一个更干净、更简单的迭代替代方案*

*并不总是这样，但有时递归为通常涉及迭代的问题提供了一个更简单的解决方案(这将在后面的例子中变得更清楚)。*

# *使用递归的主要规则和常见错误。*

*当使用递归时，有几个常见的错误会导致你的函数失控。*

## *规则 1:递归函数需要一个端点*

*就像“while”循环需要有一个停止的地方一样，递归函数需要有一个“基本情况”。递归的第一个主要规则是**需要有一个端点。**否则，函数不知道什么时候停止，它将永远继续下去(准确地说是无限)，创建一个无限循环。*

## *规则 2:递归函数在递归调用时需要不同的输入*

*请这样想:如果一个函数在它自己内部被调用，而函数的输入没有改变，那么这个函数会一次又一次地在同一个输入上被调用，并且没有办法到达一个端点。这将我们引向一个类似无限循环的情况，类似于上面提到的情况。*

> *递归的第一个主要规则是需要有一个端点。递归的第二个主要规则是，每次调用时它们需要不同的输入。*

## *示例#1:*

***让我们编写一个简单的递归函数，它接受一个整数，每次通过时将该整数减 1，并在控制台中记录每个数字。***

*你能发现“基本情况”吗？每次通过的输入差异怎么样？*

***我们先来谈谈基地的情况。**记住，需要一个基础案例来给功能一个停止的地方。这通常包括一个条件语句，后面跟着一个返回，就像我们在函数开头的‘if’语句中看到的那样。如果不在这里，我们的函数将无处可停，将继续记录超过 0 的数字，进入负数，并被遗忘，直到超过最大调用堆栈大小。*

***接下来，让我们看看每次通过时的不同输入。**在我们 console.log 我们的“num”之后，我们可以看到这个整数减 1，然后我们的函数在这个新的数字上再次被调用。这也防止了无限循环类型的情况，因为如果我们每次都没有不同的数字，我们的函数将不断地在相同的数字上调用自己，直到像上面一样，超过了最大调用堆栈大小。*

## *示例 2:*

***这是一个经典的递归函数，它接受一个整数，并求出给定整数的阶乘。(对于那些需要复习阶乘是什么的人来说，一个例子是“3！”。我不是在这里喊 3。意思是 3 * 2 * 1。)***

***再次尝试找出“基本情况”,以及输入的变化！***

*这里的基本情况是，再次，在函数的开始，我们指定一个带有返回值的条件。在这种情况下，我们需要确保函数停止在 1，这样它:a .)不会继续超过 1 而被遗忘，b .)不会让我们最终乘以 0，c .)允许乘法本身在“阶乘”被调用“num”次后发生。*

*让我们详细阐述一下最后一点。一旦`factorial`被一遍又一遍地调用，直到它返回 1，它实际上仍然没有产生任何其他整数。这意味着我们被调用的递归函数一直“等待”到 1，然后它们开始执行我们一直在等待的乘法运算。有道理吗？换句话说，现在每个被调用的`factorial(num — 1)`都有一个实际值(一个整数)供前面的`num`相乘。*

*记住，每次调用递归函数时都有不同的输入也很重要。在这种情况下，当我们从“num”中减去 1 时，这发生在函数调用本身的输入中。这意味着每次调用我们的函数时，它都有一个新的输入。这种模式每次都在继续，直到我们的输入为 1，然后我们爆发。*

*现在你对什么是递归，为什么递归很重要，什么时候有用，递归函数的经典陷阱/规则有了一个大致的了解，并且看了几个例子。*

***一个小提示:**你可能听说过“助手方法递归”，这在本文中没有提到。这也是一个重要的主题，但是，由于递归本身就很难深入研究，所以我决定把这篇文章写得轻松一些，这样它就可以是一个不错的介绍，不会让人不知所措。我们改天再谈那个话题！*

*编码快乐！*

*[](https://skilled.dev) [## 编写面试问题

### 一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…

技术开发](https://skilled.dev)*