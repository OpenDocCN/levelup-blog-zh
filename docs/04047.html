<html>
<head>
<title>Python Type Hints/Annotations, and Mypy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python类型提示/注释和Mypy</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-type-hints-annotations-and-mypy-3695de841952?source=collection_archive---------10-----------------------#2020-06-07">https://levelup.gitconnected.com/python-type-hints-annotations-and-mypy-3695de841952?source=collection_archive---------10-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c0117daa33a3d4a3875816a22f0f89f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8hIYLjzmQWlVAUif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">比埃尔·莫罗在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="85f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当用Python编写的项目变得足够大时，与其他严格类型语言相比，它就会变得相对笨拙。这部分是由于Python的动态类型特性。Python运行时不检查数据类型的一致性。这意味着变量可以在它的整个生命周期中改变它的数据类型，Python不会检查被传递的对象的数据类型。当处理大型代码库时，这就成了问题，因为大量的错误都可以追溯到数据类型不匹配。</p><p id="05ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最新的Python原生特性套件可用于为您的Python项目提供某种类型的自省和断言。</p><p id="4956" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇博文将通过类型提示、数据类和第三方库(如mypy和pyright)介绍一些在项目中强制可选类型规则的技术。</p><p id="456a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个常规的Python函数是:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="699e" class="ln lo it lj b gy lp lq l lr ls">def greeting(name):<br/>    Return “Hello “ + name</span></pre><p id="f1e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用类型注释，您可以指定参数类型以及函数返回类型</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1e8b" class="ln lo it lj b gy lp lq l lr ls"># filename : typehints1.py</span><span id="8c8e" class="ln lo it lj b gy lt lq l lr ls">def greeting(name: str) -&gt; str:<br/>    return “Hello “ + name</span></pre><p id="065a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们指出参数“name”应该是字符串类型，并且<strong class="ki iu"> <em class="lu"> - &gt; str </em> </strong>语法表示该函数应该返回一个字符串。</p><p id="be6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，参数和返回值的函数注释都是完全可选的。Python没有赋予注释任何特殊的含义或意义。</p><p id="767f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以下面的函数仍然有效，不会产生任何错误。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6e12" class="ln lo it lj b gy lp lq l lr ls"># filename : typehints1.py</span><span id="1f89" class="ln lo it lj b gy lt lq l lr ls">def greeting2(name: str) -&gt; str:<br/>    # return a list of string instead of string<br/>    return list(“Hello “ + name)</span></pre><p id="212b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python所做的只是让这些注释<a class="ae kf" href="https://www.python.org/dev/peps/pep-3107/#accessing-function-annotations" rel="noopener ugc nofollow" target="_blank">在对象</a>的__annotations__字典中可用。值得强调的是，类型提示是可选的，不会影响python运行时，而且Python <a class="ae kf" href="https://www.python.org/dev/peps/pep-0484/#non-goals" rel="noopener ugc nofollow" target="_blank">永远是动态类型语言</a>。因此，注释具有意义的唯一方式是，如果它们被第三方库使用，如<a class="ae kf" href="https://mypy.readthedocs.io/en/stable/getting_started.html" rel="noopener ugc nofollow" target="_blank"> mypy </a>或<a class="ae kf" href="https://github.com/microsoft/pyright" rel="noopener ugc nofollow" target="_blank"> pyright </a>。</p><p id="5ce5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以让我们试用一下mypy，看看我们的类型提示是否如预期的那样工作。</p><p id="d72a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过pip安装mypy:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e816" class="ln lo it lj b gy lp lq l lr ls">$ python3 -m pip install mypy</span></pre><p id="c107" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装完成后，使用mypy工具对这个python文件运行它:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d624" class="ln lo it lj b gy lp lq l lr ls"># filename : typehints1.py</span><span id="b408" class="ln lo it lj b gy lt lq l lr ls">def greeting(name: str) -&gt; str:<br/>    return “Hello “ + name</span><span id="2115" class="ln lo it lj b gy lt lq l lr ls">def greeting2(name: str) -&gt; str:<br/>    return list(“Hello “ + name)</span></pre><p id="2885" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用mypy命令评估typehints1.py文件。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2e68" class="ln lo it lj b gy lp lq l lr ls">$ mypy typehints1.py</span><span id="2e3e" class="ln lo it lj b gy lt lq l lr ls">&gt;&gt;&gt; typehints1.py:5: error: Incompatible return value type (got “List[str]”, expected “str”)<br/>Found 1 error in 1 file (checked 1 source file)</span></pre><p id="85c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的简单示例中，我们看到mypy已经成功检测到greeting2函数中的类型注释违规。接下来，让我们深入了解如何使用类型别名来注释非基元数据类型。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="fb2c" class="ln lo it lj b gy lp lq l lr ls"># filename: typehints2.py</span><span id="79cb" class="ln lo it lj b gy lt lq l lr ls">from datetime import datetime, date<br/>from typing import List, Tuple</span><span id="0f84" class="ln lo it lj b gy lt lq l lr ls">PersonAge = Tuple[str, int]<br/>ItemList = List[str]<br/>Gift = Tuple[PersonAge, ItemList]</span><span id="6627" class="ln lo it lj b gy lt lq l lr ls">def get_name_age(name: str, birth_date: int) -&gt; PersonAge:<br/>    age = datetime.now().year — birth_date<br/>    return (name, age)</span><span id="a908" class="ln lo it lj b gy lt lq l lr ls">def pick_items(profile: PersonAge) -&gt; ItemList:<br/>    return [‘dog’, ‘lego’, ‘blanky’]</span><span id="85f3" class="ln lo it lj b gy lt lq l lr ls">profile = get_name_age(“Asher”, 2018)</span><span id="7482" class="ln lo it lj b gy lt lq l lr ls">def get_gift(person: PersonAge) -&gt; Gift:<br/>    items = pick_items(profile)<br/>    return (person, items)</span><span id="0297" class="ln lo it lj b gy lt lq l lr ls">print(pick_items(profile))</span></pre><p id="95e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用Python的<a class="ae kf" href="https://docs.python.org/3/library/typing.html" rel="noopener ugc nofollow" target="_blank">类型模块</a>来支持最常见类型的类型提示，如列表、可调用、元组、字典和泛型。在示例typehints2.py中，我们使用了<strong class="ki iu">类型。元组</strong>和<strong class="ki iu">类型。List </strong>为元组和列表参数/返回值提供注释。人物是stringss和int的元组，物品列表是string的向量，而Gift是人物和物品列表的元组。</p><p id="1dcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用mypy计算typehints2.py不会返回任何错误，因为所有函数都符合类型提示。但是从上面的例子中，我们可以立即预测，如果我们的数据对象包含许多属性，单独使用类型模块将会变得非常混乱。解决这个问题的一种方法是使用<a class="ae kf" href="https://docs.python.org/3/library/dataclasses.html" rel="noopener ugc nofollow" target="_blank">数据类(Python = &gt; 3.7) </a>。</p><p id="9596" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Dataclass是主要包含数据的类，它是使用@dataclass运算符创建的，如下例所示:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0f3c" class="ln lo it lj b gy lp lq l lr ls"># filename: typehints3.py</span><span id="6dcb" class="ln lo it lj b gy lt lq l lr ls">from dataclasses import dataclass<br/>from datetime import datetime<br/>from typing import List, Tuple</span><span id="db68" class="ln lo it lj b gy lt lq l lr ls">@dataclass<br/>class Profile:<br/>    name: str<br/>    age: int</span><span id="5b76" class="ln lo it lj b gy lt lq l lr ls">def get_name_age2(name: str, birth_date: int) -&gt; Profile:<br/>    age = datetime.now().year — birth_date<br/>    profile = Profile(name, age)<br/>    <br/>    return profile</span><span id="5ef1" class="ln lo it lj b gy lt lq l lr ls">print(get_name_age2(“Asher”, 2018))</span></pre><p id="fef6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在typehints3.py中，我们创建了一个配置文件数据类，而不是使用类型。元组来描述我们的数据对象。请注意，dataclass的属性有类型提示；没有类型注释的字段将不会是dataclass的一部分。dataclass中的强制类型提示使它成为描述我们的数据对象的完美替代品，并且它比使用元组或字典更加一致。</p><p id="6ae5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个收获，Python的注释特性将帮助您实现更加一致的逻辑。它允许你对你的代码应该如何工作有一个更严格的描述，它可以作为对单元测试的一个很好的补充。您也可以在现有项目中逐渐集成类型检查，因为第三方工具只会评估带有注释的文件。</p></div></div>    
</body>
</html>