<html>
<head>
<title>My raw notes on Go — Best practices, concurrency, memory and beyond</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我关于Go的原始笔记——最佳实践、并发性、内存等等</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/my-raw-notes-on-go-best-practices-concurrency-memory-and-beyond-5d82c1dae110?source=collection_archive---------1-----------------------#2020-11-16">https://levelup.gitconnected.com/my-raw-notes-on-go-best-practices-concurrency-memory-and-beyond-5d82c1dae110?source=collection_archive---------1-----------------------#2020-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/147d65c95deff6c4b6ab7b883f8c510c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VU71S99YqItUKLja.jpg"/></div></div></figure><p id="ba15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在过去的几个月里，我对一些我感兴趣并想深入了解的关于围棋的话题做了一些深入的研究。虽然大多数已经掌握这门语言相当长时间的人可能已经知道这些话题，但总有一些新手可能会有所帮助。所以我没有把笔记藏在心里，而是把它们公之于众。</p><h1 id="c65d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">内存:堆栈与堆</h1><ul class=""><li id="7ffb" class="lx ly it kd b ke lz ki ma km mb kq mc ku md ky me mf mg mh bi translated">Go的运行时为每个goroutine创建一个堆栈。</li><li id="aa77" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">Go的运行时并不在每次goroutine退出时清除堆栈，它只是将它标记为无效，以便其他程序或例程可以使用它。</li><li id="11c1" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">Go运行时足够敏锐，知道对salutation变量的引用仍被持有，因此会将内存转移到堆中，以便goroutines可以继续访问它。这就是所谓的<strong class="kd iu">逃逸分析。</strong></li><li id="30ed" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">内存分配的经验法则</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="baf5" class="mw la it ms b gy mx my l mz na">Sharing down <strong class="ms iu">typically</strong> stays on the stack</span><span id="19f3" class="mw la it ms b gy nb my l mz na">Sharing up <strong class="ms iu">typically</strong> escapes to the heap</span></pre><p id="9dae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有编译器知道什么时候典型地不是典型地</p><p id="49a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了获得准确的信息，用gcflags构建您的程序</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8361" class="mw la it ms b gy mx my l mz na">go build -gcflags=”-m -l” program.go</span></pre><ul class=""><li id="7b4e" class="lx ly it kd b ke kf ki kj km nc kq nd ku ne ky me mf mg mh bi translated">什么时候变量会转义到堆中？</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="e851" class="mw la it ms b gy mx my l mz na">- If it could possibly be referenced after the function returns</span><span id="fc0f" class="mw la it ms b gy nb my l mz na">- When a value is too big for the stack</span><span id="e029" class="mw la it ms b gy nb my l mz na">- When the compiler doesn’t know the size in compile time</span></pre><ul class=""><li id="3529" class="lx ly it kd b ke kf ki kj km nc kq nd ku ne ky me mf mg mh bi translated">不要做过早的优化，依靠数据，在解决问题之前发现问题。使用分析器和分析工具找到根。</li></ul><h1 id="1d31" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">戈鲁廷斯</h1><ul class=""><li id="4f9d" class="lx ly it kd b ke lz ki ma km mb kq mc ku md ky me mf mg mh bi translated">每个Go程序至少有一个goroutine:主Go routine<em class="nf"/>，它是在程序开始时自动创建并启动的。</li><li id="6e62" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">goroutine是一个并发运行的函数。注意并发和并行的区别。</li><li id="8a45" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">它们不是操作系统线程，而是一种更高层次的抽象，称为协程。协程只是简单的非抢占式并发子程序(它们不能被中断)。</li><li id="d66d" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">Go遵循fork-join模型来启动和等待goroutines。</li><li id="c92b" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><strong class="kd iu">防泄漏</strong>:成功缓解这种情况的方法是在父goroutine和其子之间建立一个信号，允许父向其子发送取消信号。按照惯例，这个信号通常是一个名为<em class="nf"> done </em>的只读通道。父goroutine将该通道传递给子goroutine，然后在想要取消子goroutine时关闭该通道。</li><li id="432b" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">如果一个goroutine负责创建一个goroutine，它还负责确保它可以停止该goroutine。</li><li id="2a58" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">为了更好地处理goroutines内部的错误，创建一个包装可能的结果和可能的错误的结构。返回此结构的通道。</li></ul><h1 id="1dcc" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">同步包</h1><p id="4f2a" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated"><strong class="kd iu">等待组</strong></p><p id="f9de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您不关心并发操作的结果，或者您有其他方法收集它们的结果，而必须等待一组并发操作完成时，请使用它。</p><p id="bb45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">互斥体和rw互斥体</strong></p><p id="a3a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">锁定一段代码，这样只有一个goroutine可以访问它。最佳实践是使用defer语句锁定并在下一行解锁。</p><p id="7008" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RWMutex为您提供了对何时授予读或写权限的细粒度控制。</p><h1 id="16dc" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">频道</h1><ul class=""><li id="0eb9" class="lx ly it kd b ke lz ki ma km mb kq mc ku md ky me mf mg mh bi translated">渠道是信息流的管道；值可以沿着通道传递，然后向下游读出</li><li id="4e43" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">双向或单向</li><li id="6928" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">Go中的频道被阻塞。这意味着，任何试图写入已满通道的goroutine都将等待，直到该通道被清空；任何试图从空通道读取的goroutine都将等待，直到至少有一个项目被放置在该通道上。</li><li id="be3b" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">读数发送两个值，value和ok。如果通道关闭，则value是通道类型的默认值，ok为false。通道范围检查正常值。</li><li id="a7ad" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">通道的创建可能应该与将要在通道上执行写操作的goroutines紧密耦合，这样我们就可以更容易地推断通道的行为和性能。</li><li id="4b04" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">拥有通道的goroutine应该:实例化通道，执行写操作，或者将所有权传递给另一个goroutine，关闭通道，封装前面的三个东西，并通过reader通道公开它们。</li></ul><h1 id="5d17" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Select和for-select语句</h1><ul class=""><li id="efa3" class="lx ly it kd b ke lz ki ma km mb kq mc ku md ky me mf mg mh bi translated">在select语句中，对分支的评估是同时进行的，首先执行满足条件的分支。如果有多个选项，go的运行时会进行伪随机选择</li><li id="858b" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">在Go中使用</li><li id="eaca" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">Default clause in a select statement is executed if none is ready. Mixed with for loop to create fallthrough and check for other options every time</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="aca5" class="mw la it ms b gy mx my l mz na">for {</span><span id="f3a1" class="mw la it ms b gy nb my l mz na">  select {</span><span id="6b96" class="mw la it ms b gy nb my l mz na">    case &lt;-done: <br/>      <br/>      return</span><span id="3f00" class="mw la it ms b gy nb my l mz na">    default:</span><span id="989a" class="mw la it ms b gy nb my l mz na">      // Do non-preemptable work</span><span id="7a87" class="mw la it ms b gy nb my l mz na">  }</span><span id="28cb" class="mw la it ms b gy nb my l mz na">}</span></pre><h1 id="8933" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Pipelines</h1><p id="683a" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">When constructing pipelines use a generator function to convert input to channel</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="452f" class="mw la it ms b gy mx my l mz na">func IntGenerator(done &lt;-chan interface{}, integers ...int) &lt;-chan int { <br/>  intStream := make(chan int) <br/>  go func() {<br/>    defer close(intStream)<br/>    for _, i := range integers {<br/>     select {<br/>       case &lt;-done:<br/>        return<br/>       case intStream &lt;- i:<br/>     }<br/>    }<br/>  }()<br/> return intStream<br/>}</span></pre><p id="e013" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Fan-out, fan-in: reuse a single stage of our pipeline on multiple goroutines in an attempt to parallelise pulls from an upstream stage.</p><p id="708e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">When to fan-out?</p><p id="6463" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">• It doesn’t rely on values that the stage had calculated before.</p><p id="a2a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">• It takes a long time to run.</p><h1 id="74c1" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Slices, declaration vs initialisation</h1><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="88e3" class="mw la it ms b gy mx my l mz na">var arr []string // declares slice, nil value</span><span id="2cf3" class="mw la it ms b gy nb my l mz na">arr := make([]string, 3) //declares and initialises slice [“”,””,””]</span></pre><h1 id="f8e7" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Interfaces</h1><h2 id="bd3d" class="mw la it bd lb nj nk dn lf nl nm dp lj km nn no ln kq np nq lr ku nr ns lv nt bi translated">Compile time check</h2><p id="b0f0" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">Interface implementation is done implicitly and checked in runtime. If you do not conform to an interface then an error will raise in production.</p><p id="edc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Add this line to do a compile time check of your interface implementation, will fail to compile if for example  【T0】  ever stops matching the  【T1】  interface.</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="87ac" class="mw la it ms b gy mx my l mz na">var _ http.Handler = (*Handler)(nil)</span></pre><h2 id="d414" class="mw la it bd lb nj nk dn lf nl nm dp lj km nn no ln kq np nq lr ku nr ns lv nt bi translated">Receivers matter</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8692" class="mw la it ms b gy mx my l mz na">package main</span><span id="6102" class="mw la it ms b gy nb my l mz na">import (</span><span id="9d2a" class="mw la it ms b gy nb my l mz na">“fmt”</span><span id="1d23" class="mw la it ms b gy nb my l mz na">)</span><span id="cd5b" class="mw la it ms b gy nb my l mz na">type Animal interface {</span><span id="554c" class="mw la it ms b gy nb my l mz na">  Speak() string</span><span id="5aee" class="mw la it ms b gy nb my l mz na">}</span><span id="ee5d" class="mw la it ms b gy nb my l mz na">type Dog struct {</span><span id="ac37" class="mw la it ms b gy nb my l mz na">}</span><span id="57a6" class="mw la it ms b gy nb my l mz na">func (d Dog) Speak() string {</span><span id="6110" class="mw la it ms b gy nb my l mz na">  return “Woof!”</span><span id="90d1" class="mw la it ms b gy nb my l mz na">}</span><span id="3a76" class="mw la it ms b gy nb my l mz na">type Cat struct {</span><span id="ed41" class="mw la it ms b gy nb my l mz na">}</span><span id="394e" class="mw la it ms b gy nb my l mz na">func (c *Cat) Speak() string {</span><span id="1bb9" class="mw la it ms b gy nb my l mz na">  return “Meow!”</span><span id="7cb8" class="mw la it ms b gy nb my l mz na">}</span><span id="b216" class="mw la it ms b gy nb my l mz na">func main() {</span><span id="7246" class="mw la it ms b gy nb my l mz na">  animals := []Animal{Dog{}, Cat{}}</span><span id="425d" class="mw la it ms b gy nb my l mz na">  for _, animal := range animals {</span><span id="1c78" class="mw la it ms b gy nb my l mz na">    fmt.Println(animal.Speak())</span><span id="a34e" class="mw la it ms b gy nb my l mz na">  }</span><span id="ad61" class="mw la it ms b gy nb my l mz na">}</span><span id="9446" class="mw la it ms b gy nb my l mz na">// Output</span><span id="bacc" class="mw la it ms b gy nb my l mz na">./prog.go:26:32: cannot use Cat literal (type Cat) as type Animal in slice literal:</span><span id="8044" class="mw la it ms b gy nb my l mz na">Cat does not implement Animal (Speak method has pointer receiver</span></pre><h2 id="e0ba" class="mw la it bd lb nj nk dn lf nl nm dp lj km nn no ln kq np nq lr ku nr ns lv nt bi translated">Interface segregation principle</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="32a2" class="mw la it ms b gy mx my l mz na"><em class="nf">A great rule of thumb for Go is </em><strong class="ms iu"><em class="nf">accept interfaces, return structs</em></strong><em class="nf">.<br/>–Jack Lindamood</em></span></pre></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h2 id="2629" class="mw la it bd lb nj nk dn lf nl nm dp lj km nn no ln kq np nq lr ku nr ns lv nt bi translated">Resources</h2><ul class=""><li id="0d31" class="lx ly it kd b ke lz ki ma km mb kq mc ku md ky me mf mg mh bi translated"><a class="ae oe" href="https://deepu.tech/memory-management-in-golang/" rel="noopener ugc nofollow" target="_blank">内存管理</a></li><li id="ccf5" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><a class="ae oe" href="https://www.youtube.com/watch?v=ZMZpH4yT7M0&amp;list=WL&amp;index=14&amp;t=14s&amp;ab_channel=SingaporeGophers" rel="noopener ugc nofollow" target="_blank">了解分配:堆栈和堆—GopherCon SG 2019(Jacob Walker)</a></li><li id="312a" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated">【2016年Golang英国会议—戴夫·切尼— SOLID Go设计</li><li id="5368" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><a class="ae oe" href="https://appliedgo.net/mapreduce/" rel="noopener ugc nofollow" target="_blank"> MapReduce在走</a></li><li id="3156" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><a class="ae oe" href="https://www.oreilly.com/library/view/concurrency-in-go/9781491941294/" rel="noopener ugc nofollow" target="_blank">围棋中的并发，凯瑟琳·考克斯-布戴</a></li><li id="297f" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><a class="ae oe" href="https://github.com/uber-go/guide/blob/master/style.md" rel="noopener ugc nofollow" target="_blank">https://github.com/uber-go/guide/blob/master/style.md</a></li><li id="41c4" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><a class="ae oe" href="https://github.com/golang-standards/project-layout" rel="noopener ugc nofollow" target="_blank">https://github.com/golang-standards/project-layout</a></li><li id="3c6a" class="lx ly it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><a class="ae oe" href="https://github.com/mastanca/go-concurrent-utils" rel="noopener ugc nofollow" target="_blank">https://github.com/mastanca/go-concurrent-utils</a></li></ul></div></div>    
</body>
</html>