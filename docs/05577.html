<html>
<head>
<title>Learning C++: Overloading the Assignment, Increment, and Decrement Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:重载赋值、递增和递减运算符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-overloading-the-assignment-increment-and-decrement-operators-4f588f91264e?source=collection_archive---------10-----------------------#2020-09-10">https://levelup.gitconnected.com/learning-c-overloading-the-assignment-increment-and-decrement-operators-4f588f91264e?source=collection_archive---------10-----------------------#2020-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4727a22e8fccdc6e8c8417fb37a5036e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FMjAbz8UlNV30_v_"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@javad_esmaeili?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贾瓦德·埃斯马埃利</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8f68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的上一篇文章中，我向您展示了如何重载输入和输出操作符，以便您可以使用标准方法使用您的用户定义类型执行输入和输出。在本文中，我将介绍如何重载另外三个操作符:赋值、递增和递减。</p><h1 id="cbfd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">this指针</h1><p id="3516" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在讨论如何重载赋值操作符之前，我需要讨论一下<code class="fe mh mi mj mk b">this</code>指针。<code class="fe mh mi mj mk b">this</code>指针是一个内置指针，当代码执行时，它总是指向当前有“焦点”的对象。</p><p id="512b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您有两个表示<code class="fe mh mi mj mk b">Point</code> s: <code class="fe mh mi mj mk b">p1</code>和<code class="fe mh mi mj mk b">p2</code>的对象，并且您想要检索x和y坐标:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="98b8" class="mt lf it mk b gy mu mv l mw mx">cout &lt;&lt; p1.getX() &lt;&lt; ", " &lt;&lt; p1.getY();</span></pre><p id="3d1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在内部，C++编译器创建了一个名为this的编译器，它指向<code class="fe mh mi mj mk b">p1</code>对象。如果我接着写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ef4d" class="mt lf it mk b gy mu mv l mw mx">cout &lt;&lt; p2.getX() &lt;&lt; ", " &lt;&lt; p2.getY();</span></pre><p id="2139" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">this</code>指针现在指向<code class="fe mh mi mj mk b">p2</code>。</p><p id="3d8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将需要<code class="fe mh mi mj mk b">this</code>指针来重载我在本文中讨论的操作符，因此您将很快看到this指针的运行。</p><h1 id="ad02" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">重载赋值运算符</h1><p id="84e7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们从使用我在上一篇关于重载的文章中提供的<code class="fe mh mi mj mk b">Point</code>类的定义开始:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5b52" class="mt lf it mk b gy mu mv l mw mx">class Point {<br/>private:<br/>  int x, y;</span><span id="90b2" class="mt lf it mk b gy my mv l mw mx">public:<br/>  Point(int, int);<br/>  friend ostream &amp;operator &lt;&lt; (ostream &amp;, const Point &amp;);<br/>  friend istream &amp;operator &gt;&gt; (istream &amp;, Point &amp;);<br/>};</span><span id="b794" class="mt lf it mk b gy my mv l mw mx">Point::Point(int newx, int newy) {<br/>  x = newx;<br/>  y = newy;<br/>}</span><span id="3d6c" class="mt lf it mk b gy my mv l mw mx">ostream &amp;operator &lt;&lt; (ostream &amp;strm, const Point &amp;p) {<br/>  strm &lt;&lt; "x:" &lt;&lt; p.x &lt;&lt; ", y:" &lt;&lt; p.y;<br/>  return strm;<br/>}</span><span id="72a8" class="mt lf it mk b gy my mv l mw mx">istream &amp;operator &gt;&gt; (istream &amp;strm, Point &amp;p) {<br/>  cout &lt;&lt; "x coordinate: ";<br/>  strm &gt;&gt; p.x;<br/>  cout &lt;&lt; "y coordinate: ";<br/>  strm &gt;&gt; p.y;<br/>  return strm;<br/>}</span></pre><p id="9d49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望能够将一个<code class="fe mh mi mj mk b">Point</code>对象的值分配给另一个<code class="fe mh mi mj mk b">Point</code>对象，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="db34" class="mt lf it mk b gy mu mv l mw mx">Point p1(1,2);<br/>Point p2;<br/>p2 = p1;</span></pre><p id="06e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了重载<code class="fe mh mi mj mk b">Point</code>对象的赋值操作符，我们需要传入我们要赋值的<code class="fe mh mi mj mk b">Point</code>对象作为参数。当前对象是我们通过赋值初始化的新的<code class="fe mh mi mj mk b">Point</code>对象。在函数进行任何赋值之前，它确保当前对象和传入的对象不是同一个对象。如果不是，函数体将现有对象的<code class="fe mh mi mj mk b">x</code>和<code class="fe mh mi mj mk b">y</code>成员变量赋给当前对象，然后将<code class="fe mh mi mj mk b">this</code>指针返回给当前对象。这个定义放在<code class="fe mh mi mj mk b">Point</code>类定义中。</p><p id="ae04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是<code class="fe mh mi mj mk b">Point</code>对象的重载赋值运算符的定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8892" class="mt lf it mk b gy mu mv l mw mx">const Point operator=(const Point &amp;pnt) {<br/>  if (this != &amp;pnt) {<br/>    x = pnt.x;<br/>    y = pnt.y;<br/>  }<br/>  return *this;<br/>}</span></pre><p id="df2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用这个定义的测试程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="476d" class="mt lf it mk b gy mu mv l mw mx">int main ()<br/>{<br/>  Point p1(1,2);<br/>  cout &lt;&lt; p1 &lt;&lt; endl;<br/>  Point p2(0,0);<br/>  cout &lt;&lt; p2 &lt;&lt; endl;<br/>  p2 = p1;<br/>  cout &lt;&lt; p2 &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="b41b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1712" class="mt lf it mk b gy mu mv l mw mx">x:1, y:2<br/>x:0, y:0<br/>x:1, y:2</span></pre><p id="9f1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在这个例子中看到的作业类型叫做<em class="mz">复制作业</em>。还有另一种类型的赋值，叫做<em class="mz">移动赋值</em>，我将在另一篇文章中讨论。</p><h1 id="fa70" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">重载增量运算符</h1><p id="fbe4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">定义类时，通常需要重载增量运算符。这个操作符重载起来并不困难，但是你必须记住，增量操作符既可以作为前缀操作符，也可以作为后缀操作符。</p><p id="101b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了演示如何重载增量运算符(和减量运算符)，我将为跟踪库存的类引入一个新的类定义。这个类将定义一个产品——产品名称和库存商品的数量。下面是类的定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ab35" class="mt lf it mk b gy mu mv l mw mx">class Item {<br/>private:<br/>  string itemName;<br/>  int numStock;</span><span id="34e5" class="mt lf it mk b gy my mv l mw mx">public:<br/>  Item(string name, int stock) {<br/>    itemName = name;<br/>    numStock = stock;<br/>  }</span><span id="b6ed" class="mt lf it mk b gy my mv l mw mx">  void display() const { // for your Rud<br/>    cout &lt;&lt; itemName &lt;&lt; ": " &lt;&lt; numStock;<br/>  }<br/>};</span></pre><p id="a98a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要重载前缀增量操作符，我们所要做的就是将增量操作符应用于<code class="fe mh mi mj mk b">numStock</code>成员变量并返回<code class="fe mh mi mj mk b">this</code>指针。下面是运算符定义，它放在类定义中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="34fe" class="mt lf it mk b gy mu mv l mw mx">Item operator++() {<br/>  ++numStock;<br/>  return *this;<br/>}</span></pre><p id="7816" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8655" class="mt lf it mk b gy mu mv l mw mx">int main ()<br/>{<br/>  Item item1("Widget", 0);<br/>  item1.display();<br/>  ++item1;<br/>  cout &lt;&lt; endl;<br/>  item1.display();<br/>  return 0;<br/>}</span></pre><p id="31e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2329" class="mt lf it mk b gy mu mv l mw mx">Widget: 0<br/>Widget: 1</span></pre><p id="69a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看如何重载后缀增量运算符。这一点有点棘手，因为我们必须认识到这样一个事实，即存储在变量中的值是在值递增之前被访问的。我们的函数需要在递增成员变量之前获取它的旧值。</p><p id="9c9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数定义的另一个奇怪之处是，我们必须为函数提供一个伪参数，这样编译器就会知道这是后缀增量运算符的定义，而不是前缀增量运算符的定义。</p><p id="a791" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是重载后缀增量运算符的定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d9b0" class="mt lf it mk b gy mu mv l mw mx">Item operator++(int) {<br/>  Item temp(itemName, numStock);<br/>  numStock++;<br/>  return temp;<br/>}</span></pre><p id="b436" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="eb13" class="mt lf it mk b gy mu mv l mw mx">int main ()<br/>{<br/>  Item item1("Widget", 0);<br/>  item1.display();<br/>  ++item1;<br/>  cout &lt;&lt; endl;<br/>  item1.display();<br/>  item1++;<br/>  cout &lt;&lt; endl;<br/>  item1.display();<br/>  return 0;<br/>}</span></pre><p id="4ab3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ce62" class="mt lf it mk b gy mu mv l mw mx">Widget: 0<br/>Widget: 1<br/>Widget: 2</span></pre><h1 id="9548" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">重载减量运算符</h1><p id="551f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">前缀和后缀这两个减量运算符的定义与增量运算符类似，只是使用了减量运算符而不是增量运算符。以下是两种递减版本的定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2d88" class="mt lf it mk b gy mu mv l mw mx">Item operator--() {<br/>  --numStock;<br/>  return *this;<br/>}</span><span id="8909" class="mt lf it mk b gy my mv l mw mx">Item operator--(int) {<br/>  Item temp(itemName, numStock);<br/>  numStock--;<br/>  return temp;<br/>}</span></pre><p id="ebed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e3bb" class="mt lf it mk b gy mu mv l mw mx">int main ()<br/>{<br/>  Item item1("Widget", 0);<br/>  item1.display();<br/>  ++item1;<br/>  cout &lt;&lt; endl;<br/>  item1.display();<br/>  item1++;<br/>  cout &lt;&lt; endl;<br/>  item1.display();<br/>  cout &lt;&lt; endl;<br/>  --item1;<br/>  item1.display();<br/>  item1--;<br/>  cout &lt;&lt; endl;<br/>  item1.display();<br/>  return 0;<br/>}</span></pre><p id="7cfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c69d" class="mt lf it mk b gy mu mv l mw mx">Widget: 0<br/>Widget: 1<br/>Widget: 2<br/>Widget: 1<br/>Widget: 0</span></pre><h1 id="8c7b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">超载继续</h1><p id="18cd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这就结束了关于重载赋值、递增和递减操作符的讨论。在我的下一篇C++文章中，我将讨论重载关系操作符。</p><p id="4467" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请发电子邮件至<a class="ae kf" href="mailto:mmmcmillan1@att.net" rel="noopener ugc nofollow" target="_blank">mmmcmillan1@att.net</a>给我，并提出意见和建议。如果你对我的在线编程课程感兴趣，请访问<a class="ae kf" href="https://learningcpp.teachable.com" rel="noopener ugc nofollow" target="_blank">https://learningcpp.teachable.com</a>。</p></div></div>    
</body>
</html>