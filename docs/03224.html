<html>
<head>
<title>SwiftUI: Animating Color Changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:动画颜色变化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/swiftui-animating-color-changes-6a87d237dcea?source=collection_archive---------9-----------------------#2020-04-26">https://levelup.gitconnected.com/swiftui-animating-color-changes-6a87d237dcea?source=collection_archive---------9-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3661" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让-马克·布里安内</h2></div><p id="04dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是时候改变你的颜色了！您将学习如何使用<code class="fe le lf lg lh b">Paths</code>和<code class="fe le lf lg lh b">AnimatableData</code>在SwiftUI中制作背景颜色变化的动画！</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi li"><img src="../Images/dcc6d4b036dc7f0dbc28c084ee6f506a.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/1*rIjx479bba4jKFj8NYbp6Q.gif"/></div></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/1d04fd03664b86e1fc5b3e402a93b4bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/0*ZiMbs5MNguBktfIt.gif"/></div></figure><p id="7687" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是什么样的变色疯狂？！</p><h2 id="9fac" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">入门指南</h2><p id="dd24" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们改变背景颜色魔法的关键是创建我们自己的自定义SwiftUI <code class="fe le lf lg lh b">Shape</code>结构。我们就叫它<code class="fe le lf lg lh b">SplashShape</code>。<code class="fe le lf lg lh b">Shape</code>结构利用函数<code class="fe le lf lg lh b">path(in rect: CGRect) -&gt; Path</code>来定义它们看起来像什么。这是我们将用来创建各种动画的函数。</p><h2 id="854f" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">创建<code class="fe le lf lg lh b">SplashShape</code>结构</h2><p id="d917" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">继续创建一个名为<code class="fe le lf lg lh b">SplashStruct</code>的新<code class="fe le lf lg lh b">Shape</code>结构。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="4df4" class="lr ls it lh b gy mt mu l mv mw">import SwiftUI<br/><br/>struct SplashShape: Shape {<br/>    <br/>    func path(in rect: CGRect) -&gt; Path {<br/>        return Path()<br/>    }<br/>}</span></pre><p id="482c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将创建两个动画。<code class="fe le lf lg lh b">leftToRight</code>和<code class="fe le lf lg lh b">rightToLeft</code>如下图所示。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/0b223076f84ef703acda03d4721259e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/0*IhBr4_qhxe5FRnTN.gif"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><code class="fe le lf lg lh b">leftToRight</code> &amp; <code class="fe le lf lg lh b">rightToLeft</code></figcaption></figure><h2 id="ff2e" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated"><code class="fe le lf lg lh b">SplashAnimation</code></h2><p id="3cbe" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们将为自定义动画创建一个名为<code class="fe le lf lg lh b">SplashAnimation</code>的<code class="fe le lf lg lh b">enum</code>。这将允许我们在未来轻松地添加更多的动画(更多内容请参见结尾！).</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="3da8" class="lr ls it lh b gy mt mu l mv mw">import SwiftUI<br/><br/>struct SplashShape: Shape {<br/>    <br/>    public enum SplashAnimation {<br/>        case leftToRight<br/>        case rightToleft<br/>    }<br/>    <br/>    func path(in rect: CGRect) -&gt; Path {<br/>        return Path()<br/>    }<br/>}</span></pre><p id="63f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<code class="fe le lf lg lh b">path()</code>函数中，我们将打开我们的形状正在使用的动画，并生成动画所需的<code class="fe le lf lg lh b">Path</code>。但是首先，我们必须创建变量来保存动画类型以及动画的进度。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="cdd7" class="lr ls it lh b gy mt mu l mv mw">import SwiftUI<br/><br/>struct SplashShape: Shape {<br/>    <br/>    public enum SplashAnimation {<br/>        case leftToRight<br/>        case rightToleft<br/>    }<br/>    <br/>    var progress: CGFloat<br/>    var animationType: SplashAnimation<br/>    <br/>    func path(in rect: CGRect) -&gt; Path {<br/>        return Path()<br/>    }<br/>}</span></pre><p id="fc4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">progress</code>将是一个介于<code class="fe le lf lg lh b">0</code>和<code class="fe le lf lg lh b">1</code>之间的值，它将详细说明我们在颜色变化的动画中走了多远。这将在我们编写<code class="fe le lf lg lh b">path()</code>函数时派上用场。</p><h2 id="af21" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">编写<code class="fe le lf lg lh b">path()</code>函数</h2><p id="f098" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">如前所述，我们需要弄清楚我们使用的是什么类型的动画，以便返回正确的<code class="fe le lf lg lh b">Path</code>。首先，使用前面定义的<code class="fe le lf lg lh b">animationType</code>在<code class="fe le lf lg lh b">path()</code>函数中编写一个<code class="fe le lf lg lh b">switch</code>语句。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="cfcf" class="lr ls it lh b gy mt mu l mv mw">func path(in rect: CGRect) -&gt; Path {<br/>   switch animationType {<br/>       case .leftToRight:<br/>           return Path()<br/>       case .rightToLeft:<br/>           return Path()<br/>   }<br/>}</span></pre><p id="484a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这将返回空路径。我们需要实际创建函数来动画化路径。</p><h2 id="7a43" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">创建动画功能</h2><p id="cb68" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在你的<code class="fe le lf lg lh b">path()</code>函数下面，为每种类型的动画创建两个名为<code class="fe le lf lg lh b">leftToRight()</code>和<code class="fe le lf lg lh b">rightToLeft()</code>的新函数。在每个函数中，我们将创建一个矩形的<code class="fe le lf lg lh b">Path</code>，它将根据我们的<code class="fe le lf lg lh b">progress</code>变量随时间增长。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="7f36" class="lr ls it lh b gy mt mu l mv mw">func leftToRight(rect: CGRect) -&gt; Path {<br/>    var path = Path()<br/>    path.move(to: CGPoint(x: 0, y: 0)) // Top Left<br/>    path.addLine(to: CGPoint(x: rect.width * progress, y: 0)) // Top Right<br/>    path.addLine(to: CGPoint(x: rect.width * progress, y: rect.height)) // Bottom Right<br/>    path.addLine(to: CGPoint(x: 0, y: rect.height)) // Bottom Left<br/>    path.closeSubpath() // Close the Path<br/>    return path<br/>}<br/><br/>func rightToLeft(rect: CGRect) -&gt; Path {<br/>    var path = Path()<br/>    path.move(to: CGPoint(x: rect.width, y: 0))<br/>    path.addLine(to: CGPoint(x: rect.width - (rect.width * progress), y: 0))<br/>    path.addLine(to: CGPoint(x: rect.width - (rect.width * progress), y: rect.height))<br/>    path.addLine(to: CGPoint(x: rect.width, y: rect.height))<br/>    path.closeSubpath()<br/>    return path<br/>}</span></pre><p id="521b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后利用上面<code class="fe le lf lg lh b">path()</code>函数中的两个新函数。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="ec8d" class="lr ls it lh b gy mt mu l mv mw">func path(in rect: CGRect) -&gt; Path {<br/>   switch animationType {<br/>       case .leftToRight:<br/>           return leftToRight(rect: rect)<br/>       case .rightToLeft:<br/>           return rightToLeft(rect: rect)<br/>   }<br/>}</span></pre><h2 id="4e23" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">动画数据</h2><p id="4edb" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">为了确保Swift知道如何在<code class="fe le lf lg lh b">progress</code>变量改变时激活我们的<code class="fe le lf lg lh b">Shape</code>，我们需要指定哪个变量正在激活。就在我们的<code class="fe le lf lg lh b">progress</code>和<code class="fe le lf lg lh b">animationType</code>变量下面，定义<code class="fe le lf lg lh b">animatableData</code>。这是一个基于<code class="fe le lf lg lh b"><a class="ae nc" href="https://developer.apple.com/documentation/swiftui/animatable" rel="noopener ugc nofollow" target="_blank">Animatable</a></code> <a class="ae nc" href="https://developer.apple.com/documentation/swiftui/animatable" rel="noopener ugc nofollow" target="_blank">协议</a>的变量，它帮助SwiftUI知道当视图改变时如何动画化视图。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="7f3f" class="lr ls it lh b gy mt mu l mv mw">var progress: CGFloat<br/>var animationType: SplashAnimation<br/><br/>var animatableData: CGFloat {<br/>    get { return progress }<br/>    set { self.progress = newValue}<br/>}</span></pre><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d22f2fdcb7e030763997c57d3298e8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/0*8vr8fNf-Fa86z6XF.gif"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><code class="fe le lf lg lh b">SplashShape</code>随着<code class="fe le lf lg lh b">progress</code>的变化而变化。</figcaption></figure><h2 id="ced2" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">制作颜色变化的动画</h2><p id="a54a" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">到目前为止，我们已经创建了一个<code class="fe le lf lg lh b">Shape</code>，它将随着时间的推移而产生动画效果。接下来，我们需要将这个形状添加到一个视图中，并在视图的颜色改变时自动动画显示它。这就是<code class="fe le lf lg lh b">SplashView</code>发挥作用的地方。我们将创建一个<code class="fe le lf lg lh b">SplashView</code>来自动更新<code class="fe le lf lg lh b">SplashShape</code>的<code class="fe le lf lg lh b">progress</code>变量。当<code class="fe le lf lg lh b">SplashView</code>接收到新的<code class="fe le lf lg lh b">Color</code>时，它触发动画。</p><p id="869e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从创建<code class="fe le lf lg lh b">SplashView</code>结构开始。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="2f4e" class="lr ls it lh b gy mt mu l mv mw">import SwiftUI<br/><br/>struct SplashView: View {<br/><br/>    var body: some View {<br/>        // SplashShape Here<br/>    }<br/><br/>}</span></pre><p id="f874" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记住我们的<code class="fe le lf lg lh b">SplashShape</code>将<code class="fe le lf lg lh b">SplashAnimation</code>枚举作为参数，所以我们需要将它作为参数添加到我们的<code class="fe le lf lg lh b">SplashView</code>中。此外，我们正在制作视图背景颜色变化的动画，所以我们也需要加入一个<code class="fe le lf lg lh b">Color</code>。我们的初始化器在下面详述。</p><p id="65d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">ColorStore</code>是自定义的ObservableObject。它用于接收<code class="fe le lf lg lh b">SplashView</code>结构中的<code class="fe le lf lg lh b">Color</code>更新，这样我们就可以启动<code class="fe le lf lg lh b">SplashShape</code>动画，并最终改变背景颜色。我们一会儿将展示它是如何工作的。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="4f02" class="lr ls it lh b gy mt mu l mv mw">struct SplashView: View {<br/>    <br/>    var animationType: SplashShape.SplashAnimation<br/>    @State private var prevColor: Color // Stores background color<br/>    @ObservedObject var colorStore: ColorStore // Send new color updates<br/><br/>    <br/>    init(animationType: SplashShape.SplashAnimation, color: Color) {<br/>        self.animationType = animationType<br/>        self._prevColor = State&lt;Color&gt;(initialValue: color)<br/>        self.colorStore = ColorStore(color: color)<br/>    }<br/><br/>    var body: some View {<br/>        // SplashShape Here<br/>    }<br/><br/>}<br/><br/>class ColorStore: ObservableObject {<br/>    @Published var color: Color<br/>    <br/>    init(color: Color) {<br/>        self.color = color<br/>    }<br/>}</span></pre><h2 id="19ae" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">创建<code class="fe le lf lg lh b">SplashView</code>机构</h2><p id="930f" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在<code class="fe le lf lg lh b">body</code>变量中，我们需要返回一个设置为<code class="fe le lf lg lh b">SplashView</code>当前颜色的<code class="fe le lf lg lh b">Rectangle</code>。然后使用前面定义的<code class="fe le lf lg lh b">ColorStore</code>observable对象，我们可以接收颜色更新来激活我们的视图。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="fb90" class="lr ls it lh b gy mt mu l mv mw">var body: some View {<br/>    Rectangle()<br/>        .foregroundColor(self.prevColor) // Current Color<br/>        .onReceive(self.colorStore.$color) { color in<br/>            // Animate Color Update Here<br/>        }<br/>}</span></pre><p id="bb17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当改变颜色时，我们需要一些方法来跟踪<code class="fe le lf lg lh b">SplashView</code>被改变的颜色，以及进度。为此，我们将定义<code class="fe le lf lg lh b">layers</code>变量。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="e397" class="lr ls it lh b gy mt mu l mv mw">@State var layers: [(Color,CGFloat)] = [] // New Color &amp; Progress</span></pre><p id="d4ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在回到我们的<code class="fe le lf lg lh b">body</code>变量中，我们需要将新收到的<code class="fe le lf lg lh b">Colors</code>添加到<code class="fe le lf lg lh b">layers</code>变量中。当我们添加它们时，我们将进度设置为<code class="fe le lf lg lh b">0</code>，因为它们是刚刚添加的。然后，在半秒钟的过程中，我们将他们的进度制作成动画<code class="fe le lf lg lh b">1</code>。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="33ca" class="lr ls it lh b gy mt mu l mv mw">var body: some View {<br/>    Rectangle()<br/>        .foregroundColor(self.prevColor) // Current Color<br/>        .onReceive(self.colorStore.$color) { color in<br/>            // Animate Color Update Here<br/>            self.layers.append((color, 0))<br/>            <br/>            withAnimation(.easeInOut(duration: 0.5)) {<br/>                self.layers[self.layers.count-1].1 = 1.0<br/>            }<br/>        }<br/>}</span></pre><p id="dfe3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这将把新的颜色添加到<code class="fe le lf lg lh b"> layers</code>变量中，但是它们不会显示在<code class="fe le lf lg lh b">SplashView</code>的顶部。要做到这一点，我们需要在变量<code class="fe le lf lg lh b">body</code>内的<code class="fe le lf lg lh b">Rectangle</code>上将每个层显示为覆盖层。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="d84d" class="lr ls it lh b gy mt mu l mv mw">var body: some View {<br/>    Rectangle()<br/>        .foregroundColor(self.prevColor)<br/>        .overlay(<br/>            ZStack {<br/>                ForEach(layers.indices, id: \.self) { x in<br/>                    SplashShape(progress: self.layers[x].1, animationType: self.animationType)<br/>                        .foregroundColor(self.layers[x].0)<br/>                }<br/><br/>            }<br/><br/>            , alignment: .leading)<br/>        .onReceive(self.colorStore.$color) { color in<br/>            // Animate color update here<br/>            self.layers.append((color, 0))<br/><br/>            withAnimation(.easeInOut(duration: 0.5)) {<br/>                self.layers[self.layers.count-1].1 = 1.0<br/>            }<br/>        }<br/>}</span></pre><h2 id="72ae" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">试一试</h2><p id="5f2b" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">使用下面的代码，您可以在模拟器中运行它。这样做的目的是，当按下<code class="fe le lf lg lh b">ContentView</code>内的按钮时，它会推进用于选择<code class="fe le lf lg lh b">SplashView</code>颜色的<code class="fe le lf lg lh b">index</code>，从而触发对内部<code class="fe le lf lg lh b">ColorStore</code>的更新。这使得<code class="fe le lf lg lh b">SplashView</code>添加一个<code class="fe le lf lg lh b">SplashShape</code>层，并将其添加到视图中。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="4259" class="lr ls it lh b gy mt mu l mv mw">import SwiftUI<br/><br/>struct ContentView: View {<br/>    var colors: [Color] = [.blue, .red, .green, .orange]<br/>    @State var index: Int = 0<br/>    <br/>    @State var progress: CGFloat = 0<br/>    var body: some View {<br/>        VStack {<br/>           <br/>            SplashView(animationType: .leftToRight, color: self.colors[self.index])<br/>                .frame(width: 200, height: 100, alignment: .center)<br/>                .cornerRadius(10)<br/>                .shadow(color: Color.black.opacity(0.2), radius: 10, x: 0, y: 4)<br/>            <br/>            Button(action: {<br/>                self.index = (self.index + 1) % self.colors.count<br/>            }) {<br/>                Text("Change Color")<br/>            }<br/>            .padding(.top, 20)<br/>        }<br/>  <br/>    }<br/>}</span></pre><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/866c6eb45d4c69ace17ebbe03851482e.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/0*0cplu29bi4dyHzkt.gif"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">变色的好！</figcaption></figure><h2 id="5c66" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">还没完成！</h2><p id="3ba3" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们遗漏了一件事。到目前为止，我们正在不断地给我们的<code class="fe le lf lg lh b">SplashView</code>增加一层又一层。我们需要确保在这些层完成动画制作和显示后删除它们。</p><p id="2e24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">SplashView</code> struct的<code class="fe le lf lg lh b">body</code>变量内的<code class="fe le lf lg lh b">onReceive()</code>函数内，进行以下更改:</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="ba2f" class="lr ls it lh b gy mt mu l mv mw">.onReceive(self.colorStore.$color) { color in<br/>    self.layers.append((color, 0))<br/><br/>    withAnimation(.easeInOut(duration: 0.5)) {<br/>        self.layers[self.layers.count-1].1 = 1.0<br/>        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {<br/>            self.prevColor = self.layers[0].0 // Finalizes background color of SplashView<br/>            self.layers.remove(at: 0) // removes itself from layers array<br/>        }<br/>    }<br/>}</span></pre><p id="f1b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这确保我们删除了<code class="fe le lf lg lh b">layers</code>数组中的旧条目，并且我们的<code class="fe le lf lg lh b">SplashView</code>基于最新的更新显示了正确的背景颜色。</p><h2 id="c5c3" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">给我们看看你做了什么！</h2><p id="9cb6" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">你完成了我的一个教程吗？给我发一张截图或者给我一个项目链接。<a class="ae nc" href="https://trailingclosure.com" rel="noopener ugc nofollow" target="_blank">TrailingClosure.com</a>将展示用户的作品！在Twitter<a class="ae nc" href="https://twitter.com/TrailingClosure" rel="noopener ugc nofollow" target="_blank">@ trailing closure</a>上找到我们，或者发邮件到<a class="ae nc" href="mailto:howdy@trailingclosure.com" rel="noopener ugc nofollow" target="_blank">howdy@TrailingClosure.com</a>联系我们</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi li"><img src="../Images/cb35e7e2d07add051ae2a9722b4ae603.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/0*vuSb0VxT6pvGpp9z.gif"/></div></figure><h2 id="6812" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">发布在GitHub上的源代码</h2><p id="b40e" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在我的Github上查看本教程的<a class="ae nc" href="https://github.com/jboullianne/SplashView" rel="noopener ugc nofollow" target="_blank">源代码</a>！除了显示的例子外，还包括了<code class="fe le lf lg lh b">SplashShape</code>和<code class="fe le lf lg lh b">SplashView</code>的全部源代码。....但是等等，还有呢！</p><h2 id="590e" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">额外学分！</h2><p id="7af2" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">如果你熟悉我以前的教程，你知道我喜欢额外学分😉。我在开始的时候说过会有更多的动画。这是你期待已久的时刻…<em class="ne">滚筒</em> …</p><h1 id="9cd1" class="nf ls it bd lt ng nh ni lw nj nk nl lz jz nm ka mc kc nn kd mf kf no kg mi np bi translated"><code class="fe le lf lg lh b">SplashAnimation</code> 🥳</h1><p id="992b" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">呜呜呜！！还记得这个吗？我告诉过你我们会回来添加更多的动画类型。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="e9e6" class="lr ls it lh b gy mt mu l mv mw">enum SplashAnimation {<br/>    case leftToRight<br/>    case rightToLeft<br/>    case topToBottom<br/>    case bottomToTop<br/>    case angle(Angle)<br/>    case circle<br/>}<br/><br/>func path(in rect: CGRect) -&gt; Path {<br/><br/>    switch self.animationType {<br/>        case .leftToRight:<br/>            return leftToRight(rect: rect)<br/>        case .rightToLeft:<br/>            return rightToLeft(rect: rect)<br/>        case .topToBottom:<br/>            return topToBottom(rect: rect)<br/>        case .bottomToTop:<br/>            return bottomToTop(rect: rect)<br/>        case .angle(let splashAngle):<br/>            return angle(rect: rect, angle: splashAngle)<br/>        case .circle:<br/>            return circle(rect: rect)<br/>    }<br/><br/>}</span></pre><p id="49ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道你在想什么… <strong class="kk iu">“哇，那是很多额外的学分…”</strong>。不要烦恼。通过修改<code class="fe le lf lg lh b">SplashShape</code>中的<code class="fe le lf lg lh b">path()</code>函数，再创建几个函数，我们就可以像其他人一样制作动画了。</p><p id="fb9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们一个动画接一个动画…</p><h2 id="3a48" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated"><code class="fe le lf lg lh b">topToBottom</code> &amp; <code class="fe le lf lg lh b">bottomToTop</code></h2><p id="d616" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">与<code class="fe le lf lg lh b">leftToRight</code>和<code class="fe le lf lg lh b">rightToLeft</code>非常相似，这些函数使用<code class="fe le lf lg lh b">progress</code>变量创建一个从形状底部或顶部开始并随时间增长的路径。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="9d4c" class="lr ls it lh b gy mt mu l mv mw">func topToBottom(rect: CGRect) -&gt; Path {<br/>    var path = Path()<br/>    path.move(to: CGPoint(x: 0, y: 0))<br/>    path.addLine(to: CGPoint(x: rect.width, y: 0))<br/>    path.addLine(to: CGPoint(x: rect.width, y: rect.height * progress))<br/>    path.addLine(to: CGPoint(x: 0, y: rect.height * progress))<br/>    path.closeSubpath()<br/>    return path<br/>}<br/><br/>func bottomToTop(rect: CGRect) -&gt; Path {<br/>    var path = Path()<br/>    path.move(to: CGPoint(x: 0, y: rect.height))<br/>    path.addLine(to: CGPoint(x: rect.width, y: rect.height))<br/>    path.addLine(to: CGPoint(x: rect.width, y: rect.height - (rect.height * progress)))<br/>    path.addLine(to: CGPoint(x: 0, y: rect.height - (rect.height * progress)))<br/>    path.closeSubpath()<br/>    return path<br/>}</span></pre><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/9f78a164b5fe3961cc9c61e4e30dce55.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/0*R5UO4dzgtvlUUjtC.gif"/></div></figure><h2 id="b896" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated"><code class="fe le lf lg lh b">circle</code></h2><p id="034e" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">如果你还记得你小学时的一些几何知识，你就会知道勾股定理。<code class="fe le lf lg lh b">a^2 + b^2 = c^2</code></p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/dd07e835faa87809b4c3fc4f8a2cc8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*taOHhdEX-GycqkbL.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><code class="fe le lf lg lh b">c</code>是我们的路径需要画的最后一个圆的半径</figcaption></figure><p id="f984" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">a</code>和<code class="fe le lf lg lh b">b</code>可以认为是我们矩形的<code class="fe le lf lg lh b">height</code>和<code class="fe le lf lg lh b">width</code>。这允许我们求解<code class="fe le lf lg lh b">c</code>，覆盖整个矩形所需的圆的半径。我们可以在此基础上构建一个循环路径，并使用<code class="fe le lf lg lh b">progress</code>变量使其随时间增长。</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="4ea0" class="lr ls it lh b gy mt mu l mv mw">func circle(rect: CGRect) -&gt; Path {<br/>    let a: CGFloat = rect.height / 2.0<br/>    let b: CGFloat = rect.width / 2.0<br/><br/>    let c = pow(pow(a, 2) + pow(b, 2), 0.5) // a^2 + b^2 = c^2  --&gt; Solved for 'c'<br/>    // c = radius of final circle<br/><br/>    let radius = c * progress<br/>    // Build Circle Path<br/>    var path = Path()<br/>    path.addArc(center: CGPoint(x: rect.midX, y: rect.midY), radius: radius, startAngle: Angle(degrees: 0), endAngle: Angle(degrees: 360), clockwise: true)<br/>    return path<br/><br/>}</span></pre><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/7651c0742f69ef0041322cc79ecc0bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/0*a4qFyDe5jvcD-B1J.gif"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">使用圆形路径制作动画</figcaption></figure><h2 id="842a" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated"><code class="fe le lf lg lh b">angle</code></h2><p id="2ab4" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这个有点复杂。你需要用切线来计算角度的斜率。然后用给定的斜率创建一条线。当你移动这条线穿过矩形时，你将把它画成一个直角三角形。见下图。各种颜色的线代表随时间移动以覆盖整个矩形的线。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nv"><img src="../Images/a60f89bde668fe74bacb283b7cf11b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ogi8WYEI-T3-GsWh.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">线条依次从红色、蓝色、绿色、紫色移动。为了覆盖矩形</figcaption></figure><p id="f59b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该功能如下所示:</p><pre class="lj lk ll lm gt mp lh mq mr aw ms bi"><span id="f32b" class="lr ls it lh b gy mt mu l mv mw">func angle(rect: CGRect, angle: Angle) -&gt; Path {<br/>        <br/>    var cAngle = Angle(degrees: angle.degrees.truncatingRemainder(dividingBy: 90))<br/><br/>    // Return Path Using Other Animations (topToBottom, leftToRight, etc) if angle is 0, 90, 180, 270<br/>    if angle.degrees == 0 || cAngle.degrees == 0 { return leftToRight(rect: rect)}<br/>    else if angle.degrees == 90 || cAngle.degrees == 90 { return topToBottom(rect: rect)}<br/>    else if angle.degrees == 180 || cAngle.degrees == 180 { return rightToLeft(rect: rect)}<br/>    else if angle.degrees == 270 || cAngle.degrees == 270 { return bottomToTop(rect: rect)}<br/><br/><br/>    // Calculate Slope of Line and inverse slope<br/>    let m = CGFloat(tan(cAngle.radians))<br/>    let m_1 = pow(m, -1) * -1<br/>    let h = rect.height<br/>    let w = rect.width<br/><br/>    // tan (angle) = slope of line<br/>    // y = mx + b ---&gt; b = y - mx   ~ 'b' = y intercept<br/>    let b = h - (m_1 * w) // b = y - (m * x)<br/><br/>    // X and Y coordinate calculation<br/>    var x = b * m * progress<br/>    var y = b * progress<br/><br/>    // Triangle Offset Calculation<br/>    let xOffset = (angle.degrees &gt; 90 &amp;&amp; angle.degrees &lt; 270) ? rect.width : 0<br/>    let yOffset = (angle.degrees &gt; 180 &amp;&amp; angle.degrees &lt; 360) ? rect.height : 0<br/><br/>    // Modify which side the triangle is drawn from depending on the angle<br/>    if angle.degrees &gt; 90 &amp;&amp; angle.degrees &lt; 180 { x *= -1 }<br/>    else if angle.degrees &gt; 180 &amp;&amp; angle.degrees &lt; 270 { x *= -1; y *= -1 }<br/>    else if angle.degrees &gt; 270 &amp;&amp; angle.degrees &lt; 360 { y *= -1 }<br/><br/>    // Build Triangle Path<br/>    var path = Path()<br/>    path.move(to: CGPoint(x: xOffset, y: yOffset))<br/>    path.addLine(to: CGPoint(x: xOffset + x, y: yOffset))<br/>    path.addLine(to: CGPoint(x: xOffset, y: yOffset + y))<br/>    path.closeSubpath()<br/>    return path<br/><br/>}</span></pre><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/55a568bea9ff3c95dc43be49c6bf68b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/0*gxQtfGVNpOr50amB.gif"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">角度45，135，225，315</figcaption></figure><h2 id="184d" class="lr ls it bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">支持未来像这样的教程！</h2><p id="b8fe" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">请考虑使用此<a class="ae nc" href="https://trailingclosure.com/signup/" rel="noopener ugc nofollow" target="_blank">链接</a>进行订阅。如果你没有在TrailingClosure.com看到这篇文章，请随时来看看我们！</p></div></div>    
</body>
</html>