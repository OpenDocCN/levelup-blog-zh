<html>
<head>
<title>How to avoid using AnyView in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免在SwiftUI中使用AnyView</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-avoid-using-anyview-in-swiftui-18b7cfb1f208?source=collection_archive---------14-----------------------#2022-03-08">https://levelup.gitconnected.com/how-to-avoid-using-anyview-in-swiftui-18b7cfb1f208?source=collection_archive---------14-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="cc04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SwiftUI提供了<em class="ko"> type-erased视图</em> AnyView，可以用作任何其他SwiftUI视图的包装器，例如能够从一个函数返回多种视图类型。</p><p id="ab4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然在某些情况下使用AnyView可能是一个不错的选择，但苹果建议尽可能使用替代产品。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/59a915fb0ab4ac01e32de3fc98411a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfKHMzaVGo527b2W7j_xCg.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">由于AnyView删除了视图的类型，它降低了SwiftUI有效更新视图的能力。</figcaption></figure><p id="d58b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为SwiftUI使用了一种所谓的<em class="ko">结构标识</em>机制，SwiftUI使用视图的类型来识别视图，并确定何时应该更新视图。由于AnyView删除了视图的类型，它降低了SwiftUI有效更新视图的能力。</p><h1 id="6ad0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用ViewBuilder而不是AnyView</h1><p id="8434" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们来看一个例子，在这个例子中，我们可能会尝试使用AnyView。</p><p id="5846" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当定义返回视图的视图属性或函数时，我们经常使用some View opaque返回类型，因此我们不需要显式定义确切的返回类型。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="ad6e" class="mn lg it mj b gy mo mp l mq mr"><em class="ko">private</em> <em class="ko">var</em> nameView: <em class="ko">some</em> View {</span><span id="6ad1" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">    if</em> isEditable {</span><span id="96bd" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">        return</em> TextField("Your name", text: $name)</span><span id="d276" class="mn lg it mj b gy ms mp l mq mr">    } <em class="ko">else</em> {</span><span id="2226" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">        return</em> Text(name)</span><span id="78fb" class="mn lg it mj b gy ms mp l mq mr">    }</span><span id="b3a3" class="mn lg it mj b gy ms mp l mq mr">}</span></pre><p id="dcbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是上面的代码无法编译，并显示错误消息<em class="ko">函数声明了一个不透明的返回类型，但是其主体中的返回语句没有匹配的底层类型</em>。</p><p id="7fec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决错误并为两个视图返回相同的类型，我们可能会尝试将它们包装在AnyView中。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="4dae" class="mn lg it mj b gy mo mp l mq mr"><em class="ko">private</em> <em class="ko">var</em> nameView: <em class="ko">some</em> View {</span><span id="b6c0" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">    if</em> isEditable {</span><span id="e19f" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">        return</em> AnyView(TextField("Your name", text: $name))</span><span id="d680" class="mn lg it mj b gy ms mp l mq mr">    } <em class="ko">else</em> {</span><span id="1f7f" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">        return</em> AnyView(Text(name))</span><span id="0903" class="mn lg it mj b gy ms mp l mq mr">    }</span><span id="875b" class="mn lg it mj b gy ms mp l mq mr">}</span></pre><p id="887c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是有一个更好的解决编译器错误的方案——<strong class="js iu">view builder属性</strong>。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="e775" class="mn lg it mj b gy mo mp l mq mr">@ViewBuilder</span><span id="c6f5" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">private</em> <em class="ko">var</em> nameView: <em class="ko">some</em> View {</span><span id="9cd5" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">    if</em> isEditable {</span><span id="2e71" class="mn lg it mj b gy ms mp l mq mr">        TextField("Your name", text: $name)</span><span id="61df" class="mn lg it mj b gy ms mp l mq mr">    } <em class="ko">else</em> {</span><span id="b33c" class="mn lg it mj b gy ms mp l mq mr">        Text(name)</span><span id="3a42" class="mn lg it mj b gy ms mp l mq mr">    }</span><span id="ebfd" class="mn lg it mj b gy ms mp l mq mr">}</span></pre><p id="77ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ViewBuilder属性允许我们将多个视图组合成一个返回类型。</p><p id="7103" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们所要做的就是将属性添加到我们的属性或函数中，并删除返回语句。</p><p id="0abf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是SwiftUI视图主体使用的相同机制。唯一的区别是，我们必须明确地在我们自己的属性和函数上添加ViewBuilder属性。</p><h1 id="8d98" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用Group而不是AnyView</h1><p id="d5cb" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">通过使用<em class="ko">组</em>类型，我们可以将多个视图收集到一个视图中，而不会影响这些视图的布局。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="4276" class="mn lg it mj b gy mo mp l mq mr"><em class="ko">private</em> <em class="ko">var</em> nameView: <em class="ko">some</em> View {</span><span id="c822" class="mn lg it mj b gy ms mp l mq mr">    Group {</span><span id="7fc0" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">        if</em> isEditable {</span><span id="9474" class="mn lg it mj b gy ms mp l mq mr">           TextField("Your name", text: $name)</span><span id="1e6e" class="mn lg it mj b gy ms mp l mq mr">        } <em class="ko">else</em> {</span><span id="dd37" class="mn lg it mj b gy ms mp l mq mr">           Text(name)</span><span id="f7b6" class="mn lg it mj b gy ms mp l mq mr">        }</span><span id="adef" class="mn lg it mj b gy ms mp l mq mr">    }</span><span id="5d5e" class="mn lg it mj b gy ms mp l mq mr">}</span></pre><p id="32b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于Group使用ViewBuilder，我们可以用条件语句对不同种类的视图进行分组。</p><h1 id="bc58" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用泛型而不是AnyView</h1><p id="3107" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">另一个我们可能想使用AnyView的常见情况是当我们想存储一个视图而不知道它的类型时。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="eed8" class="mn lg it mj b gy mo mp l mq mr"><em class="ko">struct</em> FlyoutView: View {</span><span id="e9cd" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">    let</em> headerView: AnyView</span><span id="3c4c" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">    var</em> body: <em class="ko">some</em> View {</span><span id="5396" class="mn lg it mj b gy ms mp l mq mr">        VStack {</span><span id="0717" class="mn lg it mj b gy ms mp l mq mr">            headerView</span><span id="1c62" class="mn lg it mj b gy ms mp l mq mr">            Spacer()</span><span id="570c" class="mn lg it mj b gy ms mp l mq mr">            // other views</span><span id="5f4e" class="mn lg it mj b gy ms mp l mq mr">        }</span><span id="00f6" class="mn lg it mj b gy ms mp l mq mr">    }</span><span id="548a" class="mn lg it mj b gy ms mp l mq mr">}</span></pre><p id="8cb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，我们希望headerView是一个灵活的类型。由于我们不能对存储的属性使用some View opaque返回类型，AnyView似乎是一个不错的选择。</p><p id="3a4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更优雅、更高效的解决方案是使用泛型。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="b3ff" class="mn lg it mj b gy mo mp l mq mr"><em class="ko">struct</em> FlyoutView&lt;HeaderView&gt; : View <em class="ko">where</em> HeaderView : View {</span><span id="5d2f" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">    let</em> headerView: HeaderView</span><span id="8299" class="mn lg it mj b gy ms mp l mq mr"><em class="ko">    var</em> body: <em class="ko">some</em> View {</span><span id="99a9" class="mn lg it mj b gy ms mp l mq mr">         VStack {</span><span id="33f7" class="mn lg it mj b gy ms mp l mq mr">              headerView</span><span id="d6e0" class="mn lg it mj b gy ms mp l mq mr">              Spacer()</span><span id="b402" class="mn lg it mj b gy ms mp l mq mr">         }</span><span id="0e9d" class="mn lg it mj b gy ms mp l mq mr">    }</span><span id="60a1" class="mn lg it mj b gy ms mp l mq mr">}</span></pre><p id="f547" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当创建一个弹出视图时，我们不需要在任何视图中包装标题视图。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="cffb" class="mn lg it mj b gy mo mp l mq mr">FlyoutView(headerView: Text("Header view"))</span></pre><p id="992b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SwiftUI提供的许多视图都使用相同的泛型方法。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="d31b" class="mn lg it mj b gy mo mp l mq mr"><em class="ko">struct</em> VStack&lt;Content&gt; : View <em class="ko">where</em> Content : View {</span><span id="4685" class="mn lg it mj b gy ms mp l mq mr">}</span></pre><p id="e6ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们在上面看到的，VStack的内容视图是符合view的通用类型。</p><h1 id="3553" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="6755" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在大多数情况下，可以避免使用AnyView。探索的替代方案不仅为我们的SwiftUI视图增加了更多性能，还产生了更优雅的可读代码。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="2319" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">最初发表于</em><a class="ae na" href="https://tanaschita.com/20210802-how-to-avoid-using-anyview-in-swiftui/" rel="noopener ugc nofollow" target="_blank"><em class="ko">【https://tanaschita.com】</em></a><em class="ko">。</em></p></div></div>    
</body>
</html>