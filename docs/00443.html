<html>
<head>
<title>How to implement auto-save by converting your Express routes into Socket.io routes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过将您的快速路由转换为Socket.io路由来实现自动保存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-add-auto-save-by-converting-your-express-routes-into-socket-io-routes-d942bc004742?source=collection_archive---------2-----------------------#2019-03-05">https://levelup.gitconnected.com/how-to-add-auto-save-by-converting-your-express-routes-into-socket-io-routes-d942bc004742?source=collection_archive---------2-----------------------#2019-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ju"><img src="../Images/2159f61e976f875a2390764bffc6120b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BIrkSWHMFB1QNOCiS0-YHw.gif"/></div></div></figure><p id="4a56" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我将介绍如何以及为什么使用Socket.io在单页面web应用程序中实现自动保存功能。</p><p id="29e0" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">如果你有任何问题或者遇到困难，欢迎在下面评论。</p><p id="5d23" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我欢迎任何建设性的反馈。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="a7ad" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是web socket技术？</h1><blockquote class="mc md me"><p id="31df" class="kg kh mf ki b kj kk kl km kn ko kp kq mg ks kt ku mh kw kx ky mi la lb lc ld ij bi translated">“插座。IO支持实时、双向和基于事件的通信。<br/>它可以在任何平台、浏览器或设备上运行，同样注重可靠性和速度。”</p></blockquote><p id="b42e" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">简单地说，这基本上意味着<strong class="ki ir">网络套接字允许网站向其用户传输数据</strong>。这使得应用程序能够实现实时聊天或自动保存功能等功能。</p><h1 id="da7c" class="le lf iq bd lg lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb bi translated">为什么要使用web socket技术？</h1><p id="c80e" class="pw-post-body-paragraph kg kh iq ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld ij bi translated">在我的例子中，我开发了一个任务管理应用程序，每当有人试图在短时间内进行大量编辑时，它就会崩溃。</p><h1 id="2cf8" class="le lf iq bd lg lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb bi translated">v.0:保存每次击键</h1><p id="da77" class="pw-post-body-paragraph kg kh iq ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld ij bi translated">起初，每当您进行编辑时，我的代码会尝试保存您的任务:</p><pre class="jv jw jx jy gt mt mu mv mw aw mx bi"><span id="d82c" class="my lf iq mu b gy mz na l nb nc">//html<br/>&lt;input type="text" class="todo" id="{{todo.id}}"&gt;</span><span id="894e" class="my lf iq mu b gy nd na l nb nc">//js<br/><strong class="mu ir">$(".todo").on('keyup', function(e)</strong> {<br/>  const todo = document.activeElement;<br/>  const todoId = todo.getAttribute("id")<br/>  const todoValue = document.activeElement.getAttribute("id");<br/>  <strong class="mu ir">axios.post</strong>('/save-todo', { todo, todoId, todoValue })<br/>     <strong class="mu ir">.then</strong>(res =&gt; {<br/>        // no need to update frontend in this case<br/>     })<br/>     <strong class="mu ir">.catch</strong>(err =&gt; return console.log(err));<br/>}</span></pre><p id="4c84" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在上面的例子中，我要求服务器在您每次按下键盘上的按钮时更新这个特定的任务(' todo ')。</p><p id="338e" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">Axios会向服务器发送请求，一旦收到6个并发请求，Axios就会开始限制我的请求。</p><p id="27c9" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">该页面看起来似乎挂起了，但实际上它仍然在试图完成堆积的请求队列。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="c26a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">v.1:为批处理请求添加计时器</h1><p id="731d" class="pw-post-body-paragraph kg kh iq ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld ij bi translated">根据我在网上的发现，这个问题最流行的解决方案是使用计时器批量更新(一种被称为<a class="ae ne" rel="noopener ugc nofollow" target="_blank" href="/debounce-in-javascript-improve-your-applications-performance-5b01855e086">去抖</a>的技术)，看起来像这样:</p><pre class="jv jw jx jy gt mt mu mv mw aw mx bi"><span id="b6ed" class="my lf iq mu b gy mz na l nb nc">//html<br/>&lt;input type="text" class="todo" id="{{todo.id}}"&gt;</span><span id="4e51" class="my lf iq mu b gy nd na l nb nc">//js</span><span id="7add" class="my lf iq mu b gy nd na l nb nc"><strong class="mu ir">var timeout = null;<br/>var timerDelay = 800;</strong></span><span id="b660" class="my lf iq mu b gy nd na l nb nc">$(".todo").on('keyup', function(e) {<br/>  <strong class="mu ir">clearTimeout(timeout); // reset every keystroke<br/>  timeout = setTimeout(function () {</strong><br/>    const todo = document.activeElement;<br/>    const todoId = todo.getAttribute("id")<br/>    const todoValue = document.activeElement.getAttribute("id");<br/>    axios.post('/save-todo', { todo, todoId, todoValue })<br/>       .then(res =&gt; {<br/>          // no need to update frontend in this case<br/>       })<br/>       .catch(err =&gt; return console.log(err));<br/>  <strong class="mu ir">}, timerDelay);<br/></strong>}</span></pre><p id="4e03" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">这是怎么回事？</p><ul class=""><li id="92d1" class="nf ng iq ki b kj kk kn ko kr nh kv ni kz nj ld nk nl nm nn bi translated">在文件的顶部，你已经声明了一个定时器<code class="fe no np nq mu b">timeout</code></li><li id="a827" class="nf ng iq ki b kj nr kn ns kr nt kv nu kz nv ld nk nl nm nn bi translated">save函数仍然会在每次击键时被调用，但是现在它会重置一个计时器<code class="fe no np nq mu b">clearTimeout(timeout)</code>，然后启动一个计时器</li><li id="db02" class="nf ng iq ki b kj nr kn ns kr nt kv nu kz nv ld nk nl nm nn bi translated">如果您没有通过继续编辑长达800毫秒来重置计时器(因为<code class="fe no np nq mu b">timerDelay = 800</code>)，那么<strong class="ki ir"> axios.post() </strong>请求将最终被调用。</li></ul><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/3d2e1b00518f6d2ae11d920ac1ff8e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/1*BmVQcLPMj6r_SCTu6EitwA.gif"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">仍然在等待超快的打字者</figcaption></figure><p id="98ec" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">这实际上为99%的用户解决了问题，但仍有少数用户(比如我自己)打字很快，喜欢批量检查任务，所以服务器仍处于挂起状态…</p><p id="f14e" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">增加<code class="fe no np nq mu b">timerDelay</code>本来是可行的，但是如果用户关闭浏览器，保存请求将永远不会触发，因此更改将会丢失。所以我一直在寻找更好的解决方案。我的研究将我引向了web socket技术。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="88d9" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><strong class="ki ir"> v.2:使用Socket.io技术</strong></p><pre class="jv jw jx jy gt mt mu mv mw aw mx bi"><span id="1bac" class="my lf iq mu b gy mz na l nb nc">//html<br/>&lt;input type="text" class="todo" id="{{todo.id}}"&gt;</span><span id="c972" class="my lf iq mu b gy nd na l nb nc">//js</span><span id="15c9" class="my lf iq mu b gy nd na l nb nc">$(".todo").on('keyup', function(e) {<br/>    const todo = document.activeElement;<br/>    const todoId = todo.getAttribute("id")<br/>    const todoValue = document.activeElement.getAttribute("id");<br/>    <strong class="mu ir">socket.emit('save-todo', { todo, todoId, todoValue });<br/></strong>}</span></pre><p id="358f" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">那么上面发生了什么呢？</p><p id="0056" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我使用了一个<strong class="ki ir"> socket.emit </strong>，而不是一个<strong class="ki ir"> axios.post </strong>请求。否则，函数看起来完全一样。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/775daf9dc5c92b5dbfa86ee53f54dc9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*JGIBr6WI0bJddzs2EeHfKA.gif"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">Socket.io技术</figcaption></figure><p id="b4f3" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">而且，成功了！</p><p id="eaaf" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在实现socket.io技术后，页面不再崩溃，我也不再用异步POST请求让服务器过载。相反，我将数据传输到服务器。作为一个网站用户，即使我关闭了我的窗口，服务器最终还是会完成对象的保存。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="87e5" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从这里去哪里？</h1><p id="c733" class="pw-post-body-paragraph kg kh iq ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld ij bi translated">如果您想减少服务器上的工作，您可以添加一个计时器(如上面的v1所示)来批处理套接字请求。</p><p id="fee2" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">如果您想自己对套接字进行更改，您需要:</p><ul class=""><li id="e05a" class="nf ng iq ki b kj kk kn ko kr nh kv ni kz nj ld nk nl nm nn bi translated">安装Socket.io，你可以用节点包管理器(如果你正在使用的话)通过<code class="fe no np nq mu b">npm install socket.io</code>来完成</li><li id="a3c8" class="nf ng iq ki b kj nr kn ns kr nt kv nu kz nv ld nk nl nm nn bi translated"><code class="fe no np nq mu b">require</code> Socket.io并在你的<code class="fe no np nq mu b">app.js</code>或<code class="fe no np nq mu b">server.j</code> s文件中实例化它</li><li id="5789" class="nf ng iq ki b kj nr kn ns kr nt kv nu kz nv ld nk nl nm nn bi translated">将您的快速路线转换为Socket.io路线</li></ul><p id="d929" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">为了帮助您将Express routes转换为Socket.io，我创建了一个Github GIST，其中的文件带有一个完整的前缀，在“从Express切换到Socket.io”之前添加了“T4”，在“从Express切换到socket . io”之后添加了“T5”或“T6”，因为当我自己进行切换时，我很难找到完整的示例。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="b134" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">示例:用Express和Socket.io编写的相同路由</h1><p id="3095" class="pw-post-body-paragraph kg kh iq ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld ij bi translated"><em class="mf">最后更新时间:2019年3月2日</em></p><p id="4b4b" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">下面的例子是用JavaScript编写的，使用Node.js、Express、Socket.io和Handlebars作为视图引擎。在这里找到最新的代码:<a class="ae ne" href="https://github.com/nsafai/looplist" rel="noopener ugc nofollow" target="_blank">https://github.com/nsafai/looplist</a></p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6b18" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">希望有帮助！感谢阅读。</p><p id="d5b2" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">如果您需要帮助或有任何可以改进本文的反馈，请随时联系我们。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi oe"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="of og gp gr oh oi"><a href="https://gitconnected.com/learn/node-js" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">学习Node.js -最佳Node.js教程(2019) | gitconnected</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">前32个Node.js教程-免费学习Node.js。课程由开发人员提交和投票，使您能够…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">gitconnected.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ke oi"/></div></div></a></div></div></div>    
</body>
</html>