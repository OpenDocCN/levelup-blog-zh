<html>
<head>
<title>LeetCode with Rust: Longest Sub-string Without Repeating Characters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Rust的LeetCode:没有重复字符的最长子字符串</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/leetcode-longest-substring-without-repeating-characters-6d15c267582?source=collection_archive---------16-----------------------#2020-06-05">https://levelup.gitconnected.com/leetcode-longest-substring-without-repeating-characters-6d15c267582?source=collection_archive---------16-----------------------#2020-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e581b9b5ed29251bc2c2d2cbf36eb5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H2WUc3LU4EUTOupFUmrNQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">锈病的LeetCode问题</figcaption></figure><h1 id="a591" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">问题</h1><p id="222f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">给定一个字符串，找出没有重复字符的最长子字符串的长度。</p><h1 id="cc37" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">例子</h1><h2 id="40e4" class="ly kd iq bd ke lz ma dn ki mb mc dp km ll md me kq lp mf mg ku lt mh mi ky mj bi translated">示例1</h2><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="6e23" class="ly kd iq mp b gy mt mu l mv mw">Input: "abcabcbb" <br/>Output: 3 <br/>Explanation: The answer is "abc", with the length of 3.</span></pre><h2 id="f0ff" class="ly kd iq bd ke lz ma dn ki mb mc dp km ll md me kq lp mf mg ku lt mh mi ky mj bi translated">示例2</h2><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="416d" class="ly kd iq mp b gy mt mu l mv mw">Input: "bbbbb" <br/>Output: 1 <br/>Explanation: The answer is "b", with the length of 1.</span></pre><h2 id="2c7d" class="ly kd iq bd ke lz ma dn ki mb mc dp km ll md me kq lp mf mg ku lt mh mi ky mj bi translated">示例3</h2><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="4572" class="ly kd iq mp b gy mt mu l mv mw">Input: "pwwkew" <br/>Output: 3 <br/>Explanation: The answer is "wke", with the length of 3. Note that the answer must be a sub-string, "pwke" is a sub-sequence and not a sub-string.</span></pre><h1 id="048b" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">关于生锈的弦的一个注记</h1><p id="9cac" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">需要注意的一点是，由于utf-8编码带来的问题，Rust没有实现传统的字符串索引。有几种方法可以从字符串中提取字符，但是我将把输入字符串转换成字符向量。这是一个有趣的话题，但超出了本文的范围。</p><h1 id="ec10" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">方法1:暴力</h1><p id="ca39" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这个问题的一个简单的解决方案是遍历每个可能的子串，并跟踪到目前为止看到的最长子串的长度。</p><h1 id="bf61" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">算法</h1><p id="e71b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这种方法可以分为两个功能。一个函数应该处理子串的迭代并跟踪最长子串的长度。另一个函数应该处理唯一性检查。</p><h2 id="c066" class="ly kd iq bd ke lz ma dn ki mb mc dp km ll md me kq lp mf mg ku lt mh mi ky mj bi translated">子串迭代算法</h2><p id="0520" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">为了遍历子字符串，这种方法使用了两个循环。外部循环从<code class="fe mx my mz mp b">i</code>迭代到<code class="fe mx my mz mp b">n</code>，其中<code class="fe mx my mz mp b">n</code>是输入字符串的长度。内部循环从<code class="fe mx my mz mp b">i</code> + 1到<code class="fe mx my mz mp b">n</code>进行迭代。</p><p id="bbe8" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">算法看起来是这样的:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7c8b" class="ly kd iq mp b gy mt mu l mv mw">initialize <!-- -->n<!-- --> to length of string<br/>initialize <!-- -->length<!-- --> to 0<br/>for i = 0 to n<br/>    for j = i + 1 to n + 1<br/>        if sub-string of characters between <!-- -->i<!-- --> and <!-- -->j<!-- --> are unique<br/>            update <!-- -->length<!-- --> if <!-- -->j - i<!-- --> is greater than current <!-- -->length<br/>return <!-- -->length</span></pre><h2 id="2e74" class="ly kd iq bd ke lz ma dn ki mb mc dp km ll md me kq lp mf mg ku lt mh mi ky mj bi translated">所有独特的算法</h2><p id="93d8" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">为了检查子字符串中的字符是否都是唯一的，这个函数会将每个字符添加到一个集合中。如果发现重复字符，该函数将返回false，否则将返回true。</p><p id="21e5" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">这个算法看起来像这样:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="b13e" class="ly kd iq mp b gy mt mu l mv mw">initialize a HashSet of <!-- -->char<br/>initialize a vector of chars<br/>for i = start to end<br/>    if the char exists in the set<br/>        return false<br/>    else <br/>        add char to set<br/>return true</span></pre><h1 id="92e9" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">履行</h1><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/4de2f2fa6ec2bf2c856f3f1de0ad2cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rQ5zCm2kdqIv-6kS.png"/></div></div></figure><h1 id="d6f9" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">复杂性</h1><ul class=""><li id="6619" class="ng nh iq lc b ld le lh li ll ni lp nj lt nk lx nl nm nn no bi translated">时间复杂度:O(n^3)</li></ul><blockquote class="np nq nr"><p id="ff54" class="la lb ns lc b ld na lf lg lh nb lj lk nt nc ln lo nu nd lr ls nv ne lv lw lx ij bi translated">迭代每个子串需要O(n^2)</p><p id="45da" class="la lb ns lc b ld na lf lg lh nb lj lk nt nc ln lo nu nd lr ls nv ne lv lw lx ij bi translated">对于每个子串，我们检查唯一性，这需要O(n)</p><p id="a84a" class="la lb ns lc b ld na lf lg lh nb lj lk nt nc ln lo nu nd lr ls nv ne lv lw lx ij bi translated">这给出了O(n^3的总数)</p></blockquote><ul class=""><li id="317a" class="ng nh iq lc b ld na lh nb ll nw lp nx lt ny lx nl nm nn no bi translated">空间复杂度:O(2 * min(m，n))其中m是字符集，n是字符串长度</li></ul><blockquote class="np nq nr"><p id="ec4b" class="la lb ns lc b ld na lf lg lh nb lj lk nt nc ln lo nu nd lr ls nv ne lv lw lx ij bi translated">该集合将需要O(min(m，n))</p><p id="845c" class="la lb ns lc b ld na lf lg lh nb lj lk nt nc ln lo nu nd lr ls nv ne lv lw lx ij bi translated">char向量将取O(n)</p></blockquote><h1 id="d3f2" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">方法2:滑动窗口</h1><p id="5ac5" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">天真的方法可以以一种非常重要的方式进行优化。</p><p id="a894" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">最大的问题是迭代子串需要O(n ^ 2)时间。这可以通过使用滑动窗口方法来改善。</p><p id="0df4" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">滑动窗口方法使用HashSet来跟踪由起始和结束索引限定的字符范围。该算法将尝试向集合中添加字符。如果字符添加成功，子字符串右边界将向右移动。如果该字符已经存在于集合中，那么在左边界的索引处的字符被移除，并且左边界被右移。这种移位会一直发生，直到处理完整个字符串。</p><h1 id="6006" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">算法</h1><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="ce96" class="ly kd iq mp b gy mt mu l mv mw">initialize <!-- -->n<!-- --> as the length of the string<br/>initialize <!-- -->length<!-- --> as 0<br/>initialize <!-- -->char_set<!-- --> to empty set<br/>initialize <!-- -->chars<!-- --> as vector of characters in string<br/>initialize indexes <!-- -->i<!-- --> and <!-- -->j<!-- --> to 0</span><span id="e5ce" class="ly kd iq mp b gy nz mu l mv mw">while <!-- -->i<!-- --> and <!-- -->j<!-- --> are less than <!-- -->n<br/>    <!-- -->if <!-- -->chars[j]<!-- --> does not exist in <!-- -->char_set<br/>        <!-- -->add <!-- -->chars[j]<!-- --> to <!-- -->char_set<br/>        <!-- -->increment <!-- -->j<br/>        <!-- -->update <!-- -->length<!-- --> if new length is greater<br/>    else<br/>        remove <!-- -->chars[i]<!-- --> from <!-- -->chars_set<br/>        <!-- -->increment <!-- -->i</span><span id="88a1" class="ly kd iq mp b gy nz mu l mv mw">return length</span></pre><h1 id="9b3e" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">履行</h1><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/5ecd0f89efe4d50fad82c93a3b4b12f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dO8MCfiPcF6vsPMw.png"/></div></div></figure><h1 id="a48b" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">复杂性</h1><ul class=""><li id="8160" class="ng nh iq lc b ld le lh li ll ni lp nj lt nk lx nl nm nn no bi translated">时间复杂度:O(2n) =&gt; O(n)</li><li id="2546" class="ng nh iq lc b ld oa lh ob ll oc lp od lt oe lx nl nm nn no bi translated">空间复杂度:O(2 * min(m，n))其中m是字符集，n是字符串长度</li></ul><blockquote class="np nq nr"><p id="62fb" class="la lb ns lc b ld na lf lg lh nb lj lk nt nc ln lo nu nd lr ls nv ne lv lw lx ij bi translated">该集合将需要O(min(m，n))</p><p id="b73d" class="la lb ns lc b ld na lf lg lh nb lj lk nt nc ln lo nu nd lr ls nv ne lv lw lx ij bi translated">char向量将取O(n)</p></blockquote><h1 id="c57c" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">方法3:滑动窗口优化</h1><p id="61c9" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">滑动窗口方法可以进一步优化。</p><p id="2cd0" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">可以使用散列表来跟踪字符和字符的索引，而不是使用散列表。如果发现重复，则左边界可以跳到正确的索引，而不是递增地向右移位。</p><h1 id="839d" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">算法</h1><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0d8e" class="ly kd iq mp b gy mt mu l mv mw">initialize <!-- -->length<!-- --> to 0<br/>initialize <!-- -->char_map<!-- --> as an empty HashMap<br/>initialize <!-- -->start<!-- --> to 0</span><span id="ade0" class="ly kd iq mp b gy nz mu l mv mw">for index, character in the characters of <!-- -->s<br/>    <!-- -->if the character is in <!-- -->char_set<br/>        <!-- -->update `start` if the character's index is greater</span><span id="7360" class="ly kd iq mp b gy nz mu l mv mw">    update <!-- -->length<!-- --> if <!-- -->end<!-- --> - <!-- -->start<!-- --> + 1 is greater<br/>    insert character and <!-- -->end<!-- --> + 1 into the HashMap</span><span id="8f32" class="ly kd iq mp b gy nz mu l mv mw">return length</span></pre><h1 id="a46b" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">履行</h1><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/675236ebf867c33afb464c8c0f3da8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hS29dzZJLH0r3Duw.png"/></div></div></figure><h1 id="1c7f" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">复杂性</h1><ul class=""><li id="fa14" class="ng nh iq lc b ld le lh li ll ni lp nj lt nk lx nl nm nn no bi translated">时间复杂度:O(n)</li><li id="1bbf" class="ng nh iq lc b ld oa lh ob ll oc lp od lt oe lx nl nm nn no bi translated">空间复杂度:O(min(m，n))其中<code class="fe mx my mz mp b">n</code>是字符串长度，<code class="fe mx my mz mp b">m</code>是字符集。</li></ul><h1 id="8140" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">回顾</h1><p id="b087" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">与简单的方法相比，滑动窗口方法是解决此类问题的更好的方法。在<a class="ae og" href="https://medium.com/outco/how-to-solve-sliding-window-problems-28d67601a66" rel="noopener">媒体</a>上有一篇很棒的文章专门报道了滑动窗口问题。这个问题的源代码可以在我的<a class="ae og" href="https://github.com/andrewleverette/leetcode_problems/blob/master/longest_substring_without_repeating_characters/src/lib.rs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h1 id="9745" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">谢谢</h1><p id="221b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">感谢阅读！如果您想联系我或想提供反馈，请随时通过LinkedIn 联系我。</p></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="c6ae" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated"><em class="ns">原载于2020年6月5日</em><a class="ae og" href="https://andrewleverette.github.io/longest-substring-without-repeating-characters/" rel="noopener ugc nofollow" target="_blank"><em class="ns">https://andrewleverette . github . io</em></a><em class="ns">。</em></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/2ee1ea256190d57f75331cb76d9d3339.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*jLGtQ-ldYIEs8X6UUxL5Pg.jpeg"/></div></figure></div></div>    
</body>
</html>