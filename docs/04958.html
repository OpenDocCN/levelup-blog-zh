<html>
<head>
<title>jQuery Tips — Class Names, List Elements, and Debounce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">jQuery技巧——类名、列表元素和去抖动</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/jquery-tips-class-names-list-elements-and-debounce-cd3a32ebee39?source=collection_archive---------11-----------------------#2020-07-26">https://levelup.gitconnected.com/jquery-tips-class-names-list-elements-and-debounce-cd3a32ebee39?source=collection_archive---------11-----------------------#2020-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bec7eaca055ef6b0efe4683ee89fcf42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d44XUg7cRPwXGrdK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@bonniekdesign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Bonnie Kittle </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e9d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管年代久远，jQuery仍然是操纵DOM的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解一些使用jQuery的技巧。</p><h1 id="3c62" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用jQuery获取元素的类列表</h1><p id="732f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要用jQuery获取元素的类列表，我们可以获取元素的<code class="fe mh mi mj mk b">class</code>属性，并用任何空格分割类列表字符串。</p><p id="7c36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="39ef" class="mt lf it mk b gy mu mv l mw mx">$(element).attr("class").split(/\s+/);</span></pre><p id="f31a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到元素，用<code class="fe mh mi mj mk b">attr</code>得到class属性。</p><p id="2941" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用匹配任何空白的<code class="fe mh mi mj mk b">/\s+/</code>调用<code class="fe mh mi mj mk b">split</code>。</p><p id="6a51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让我们的生活更轻松，我们可以使用<code class="fe mh mi mj mk b">classList</code>属性。</p><p id="e7d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过获取DOM元素来做到这一点。</p><p id="b59b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="883c" class="mt lf it mk b gy mu mv l mw mx">$(element)[0].classList</span></pre><p id="d5a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需获取<code class="fe mh mi mj mk b">classList</code>属性来获取类的列表。</p><p id="97cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DOM元素通过索引来访问。</p><h1 id="bd99" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">延迟Keyup处理程序，直到用户停止键入</h1><p id="142e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以创建自己的函数，使用回调函数调用<code class="fe mh mi mj mk b">setTimeout</code>,并将回调函数作为回调函数传递，以延迟回调函数的运行。</p><p id="2ff0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ccb7" class="mt lf it mk b gy mu mv l mw mx">const delay = (fn, ms) =&gt; {<br/>  let timer = 0<br/>  return function(...args) {<br/>    clearTimeout(timer)<br/>    timer = setTimeout(fn.bind(this, ...args), ms || 0)<br/>  }<br/>}</span></pre><p id="be7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建了<code class="fe mh mi mj mk b">delay</code>函数，它接受我们想要运行的回调，也就是<code class="fe mh mi mj mk b">fn</code>。</p><p id="11a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">ms</code>是我们希望在运行<code class="fe mh mi mj mk b">fn</code>回调之前延迟的持续时间。</p><p id="87b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有返回一个函数的<code class="fe mh mi mj mk b">timer</code>，这个函数接受一些参数，我们可以将这些参数传递给<code class="fe mh mi mj mk b">fn</code>回调函数。</p><p id="15ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还通过传递<code class="fe mh mi mj mk b">this</code>作为<code class="fe mh mi mj mk b">bind</code>的第一个参数，将<code class="fe mh mi mj mk b">this</code>的值设置为我们调用<code class="fe mh mi mj mk b">keyup</code>的元素。</p><p id="85e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们返回的函数中，如果有一个集合，我们调用<code class="fe mh mi mj mk b">timer</code>上的<code class="fe mh mi mj mk b">clearTimeout</code>。</p><p id="545b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须返回一个传统函数，以便获得正确的值<code class="fe mh mi mj mk b">this</code>，这是我们正在监听的keyup事件的元素。</p><p id="4c25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mh mi mj mk b">fn</code>调用<code class="fe mh mi mj mk b">setTimeout</code>，用我们描述过的<code class="fe mh mi mj mk b">this</code>的值和我们传入的参数。</p><p id="aad7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用它，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cf68" class="mt lf it mk b gy mu mv l mw mx">&lt;input id="input" type="text" placeholder="enter your name"/&gt;<br/>&lt;/label&gt;</span></pre><p id="4be4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="defb" class="mt lf it mk b gy mu mv l mw mx">$('#input').keyup(delay(function (e) {<br/>  console.log(this.value);<br/>}, 1500));</span></pre><p id="f17d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用jQuery获得ID为<code class="fe mh mi mj mk b">input</code>的输入。</p><p id="8d06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用传递给它的keyup事件监听器调用我们的<code class="fe mh mi mj mk b">delay</code>函数来调用<code class="fe mh mi mj mk b">keyup</code>。</p><p id="10d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以用<code class="fe mh mi mj mk b">this.value</code>记录输入的值。</p><p id="9e80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以看到我们输入的值。</p><p id="4ea9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">延迟设置为1500毫秒或1.5秒。</p><p id="2d4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不想创建自己的函数，我们也可以使用下划线或洛达什的<code class="fe mh mi mj mk b">debounce</code>方法。</p><p id="ef8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="feeb" class="mt lf it mk b gy mu mv l mw mx">const debouncedOnKeyup = _.debounce(function (e) {<br/>  console.log(this.value);<br/>}, 1500);</span><span id="4b06" class="mt lf it mk b gy my mv l mw mx">$('#input').keyup(debouncedOnKeyup);</span></pre><p id="8e93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用下划线或Lodash <code class="fe mh mi mj mk b">debounce</code>方法向事件处理函数添加延迟。</p><p id="7e84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mh mi mj mk b">keyup</code>来延迟运行keyup处理程序。</p><h1 id="3050" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在使用jQuery执行某些操作之前，等待所有图像加载完毕</h1><p id="79ba" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了在jQuery上运行某些东西之前等待图像加载，我们可以等待文档准备好。</p><p id="71de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以观察窗口的load事件，并在它发出后运行代码。</p><p id="ff56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了等待文档准备好，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e334" class="mt lf it mk b gy mu mv l mw mx">$(document).ready(() =&gt; {<br/>  //...<br/>});</span></pre><p id="808c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用一个回调函数调用了jQuery对象上的T7。</p><p id="fb34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以通过编写以下内容来观察加载事件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f623" class="mt lf it mk b gy mu mv l mw mx">$(window).on("load", () =&gt; {<br/>  //...<br/>});</span></pre><p id="04c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当窗口对象上的load事件被触发时，回调被运行。</p><h1 id="21e4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用jQuery获取选定的元素标记名</h1><p id="f0b4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">prop</code>方法获取<code class="fe mh mi mj mk b">tagName</code>属性来获取标签名。</p><p id="115a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ea34" class="mt lf it mk b gy mu mv l mw mx">$("&lt;a&gt;").prop("tagName");</span></pre><p id="a8a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mh mi mj mk b">'tagName'</code>字符串获得了<code class="fe mh mi mj mk b">a</code>元素的标签名。</p><p id="8106" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以把它做成一个插件。</p><p id="653c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a695" class="mt lf it mk b gy mu mv l mw mx">$.fn.tagName = function() {<br/>  return this.prop("tagName");<br/>};</span></pre><p id="1e22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9db1" class="mt lf it mk b gy mu mv l mw mx">$("&lt;a&gt;").tagName();</span></pre><p id="86ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义插件后。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/5cb525178a0f741aabeb9491d5a33b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NG20htHTFzMMy_Oe"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@smpicturez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Satyabrata sm </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8583" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="ea01" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">tagName</code>属性获得jQuery元素的标记名。</p><p id="35d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有各种方法可以得到班级名单。</p><p id="1386" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，有各种方法可以延迟按键处理程序。</p><p id="df63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了确保图像被加载到文档中，我们可以观察窗口或文档事件来检查它是否准备好了。</p></div></div>    
</body>
</html>