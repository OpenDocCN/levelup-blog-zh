<html>
<head>
<title>Course Dependency and Topological Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">路线依赖和拓扑排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/course-dependency-and-topological-sort-3a6c28c83996?source=collection_archive---------35-----------------------#2021-03-07">https://levelup.gitconnected.com/course-dependency-and-topological-sort-3a6c28c83996?source=collection_archive---------35-----------------------#2021-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3dafaa0b73bfc9100ee4f1c70d7ab2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9tS4IwB1lqa7ouTx"/></div></div></figure><div class=""/></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="74e0" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这篇简单的短文说明了在编码面试中图形问题是如何出现在不同地方的。今天的问题涉及一个<em class="lg">有向无环图(DAG)，DAG的</em>和<em class="lg">拓扑排序</em>。问题是Airbnb问的。</p><p id="07e1" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">随意看看一些<a class="ae lh" href="https://cppcodingzen.com/?p=2333" rel="noopener ugc nofollow" target="_blank">老</a>图论<a class="ae lh" href="https://cppcodingzen.com/?p=2059" rel="noopener ugc nofollow" target="_blank">问题</a>及其解决方案。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="8d7e" class="li lj je bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">问题:</h1><p id="97cb" class="pw-post-body-paragraph ki kj je kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">我们得到了一个hashmap，它将每个<code class="fe ml mm mn mo b">courseId</code>键与一列<code class="fe ml mm mn mo b">courseIds</code>值相关联，这表示<code class="fe ml mm mn mo b">courseId</code>的先决条件是<code class="fe ml mm mn mo b">courseIds</code>。返回课程的排序，以便我们可以完成所有课程。如果没有这样的排序，则返回空。</p><p id="d362" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">例如，给定{'CSC300': ['CSC100 '，' CSC200']，' CSC200': ['CSC100']，' CSC100': []}，应该返回['CSC100 '，' CSC200 '，' CSCS300']。</p><h1 id="78b9" class="li lj je bd lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb mt md me mf bi translated">解决方案:</h1><p id="2f6a" class="pw-post-body-paragraph ki kj je kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">这是图中<a class="ae lh" href="https://en.wikipedia.org/wiki/Topological_sorting" rel="noopener ugc nofollow" target="_blank"> <em class="lg">拓扑排序</em> </a>的超标准应用，如果你对算法了如指掌，你会做得非常好。</p><p id="3528" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">算法的步骤如下:</p><ul class=""><li id="d544" class="mu mv je kk b kl km kp kq kt mw kx mx lb my lf mz na nb nc bi translated">从课程散列表中构建一个<em class="lg">有向图</em>，其中</li><li id="92ae" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">1)每个过程由一个节点表示，并且</li><li id="7935" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated"><em class="lg"> 2) course_i </em>对<em class="lg"> course_ </em> k有边，如果<em class="lg"> course_i </em>依赖于<em class="lg"> course_ </em> k(或者<em class="lg"> course_k </em>是<em class="lg"> course_ </em> i的前提条件)。</li><li id="8057" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">在该图上执行<em class="lg">深度优先搜索(DFS) </em>。假设我们正在从节点<em class="lg"> course_i </em>运行DFS</li><li id="f122" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">1)假设没有剩下<em class="lg"> course_i </em>的<em class="lg">未探索的</em>邻居。这意味着要么<em class="lg"> course_i </em>没有邻居，要么<em class="lg"> course_i </em>的每个邻居都已经被访问过。在这种情况下，将<em class="lg">课程_i </em>追加到拓扑排序列表的末尾。</li><li id="a169" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">2)假设<em class="lg">课程_i </em>的邻居<em class="lg">课程_j </em>当前正在考虑中。这意味着我们从一条路径<em class="lg"> (course_j，…，course_i </em>)开始，找到了一条新的边<em class="lg"> (course_i，course_j)。</em>这清楚地表明了原图中的循环，循环意味着<em class="lg">没有拓扑排序是可能的。在这种情况下，返回一个空列表。</em></li></ul><p id="3fe0" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">下面是该算法的递归实现(我们添加了额外的块注释来解释实现中使用的每个结构和条件)。如果您习惯于实现标准的DFS算法，那么您应该对这个实现非常熟悉🙂</p><figure class="ni nj nk nl gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="3cf2" class="li lj je bd lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb mt md me mf bi translated">测试:</h1><p id="f487" class="pw-post-body-paragraph ki kj je kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">让我们写几个测试来测试，</p><ul class=""><li id="a323" class="mu mv je kk b kl km kp kq kt mw kx mx lb my lf mz na nb nc bi translated">空课程表</li><li id="270f" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">带循环的课程表</li><li id="eedf" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">标准的课程表，就像上面问题陈述中的那样。</li></ul><figure class="ni nj nk nl gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="258f" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><em class="lg">原载于2021年3月7日</em><a class="ae lh" href="https://cppcodingzen.com/?p=2816" rel="noopener ugc nofollow" target="_blank"><em class="lg">【https://cppcodingzen.com】</em></a><em class="lg">。</em></p></div></div>    
</body>
</html>