<html>
<head>
<title>How to Think Recursively | Solving Recursion Problems in 4 Steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何递归思考|用4个步骤解决递归问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-think-recursively-solving-recursion-problems-in-4-steps-95a6d07aa866?source=collection_archive---------0-----------------------#2019-05-12">https://levelup.gitconnected.com/how-to-think-recursively-solving-recursion-problems-in-4-steps-95a6d07aa866?source=collection_archive---------0-----------------------#2019-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/209e201381513858a418000b68b333f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*Kmd2j_y80B45B2wv4buzKA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">安全濒危的原创漫画。不知道是谁创造了这种迷因变体。</figcaption></figure><h2 id="30cf" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">免责声明</strong></h2><p id="bc5f" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">本文并不打算介绍更高级的概念，比如动态编程。相反，它将引入开始解决递归问题所需的心态。</p><p id="22e8" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">示例是用Javascript编写的，但是我将在本文的底部用Python和C++编写答案。</p><h2 id="8aa2" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">什么是递归</strong></h2><p id="ebc1" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">既然你正在读这篇文章，我假设你对递归有一个模糊的概念，所以我不会深入它的上下文。就我个人而言，我喜欢将递归理解为如下。</p><blockquote class="lu lv lw"><p id="7ee1" class="ku kv lx kw b kx lp kz la lb lq ld le ly lr lg lh lz ls lj lk ma lt lm ln lo ij bi translated"><em class="iq">递归是通过解决更小的子问题来解决问题的一种方式。</em></p></blockquote><h1 id="a684" class="mb jz iq bd ka mc md me kd mf mg mh kg mi mj mk kk ml mm mn ko mo mp mq ks mr bi translated">在我们开始之前…</h1><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ms"><img src="../Images/b571071ff1142e5d5d4331b8d1ec21dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TjNUK7WL4rJOwH0F"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">照片由<a class="ae nb" href="https://unsplash.com/@will0629?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">将</a>放在<a class="ae nb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的Unsplash </a>上</figcaption></figure><p id="2294" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">停止遍历函数调用！</strong></p><p id="4854" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这是学生学习递归时的一大障碍。他们试图查看每个 <strong class="kw ir">单个</strong>函数调用在<strong class="kw ir">发生了什么，并试图跟踪他们解决方案中的每一步。</strong></p><p id="17c0" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">你不需要知道每一步发生了什么。如果你想开始解决递归问题，你必须愿意大胆尝试。你必须相信。假设是需要的，也是解决这类问题所必需的。</p><h1 id="1eca" class="mb jz iq bd ka mc md me kd mf mg mh kg mi mj mk kk ml mm mn ko mo mp mq ks mr bi translated">怎么做</h1><p id="97f1" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">首先，让我们做一个最简单的递归问题。</p><h2 id="a823" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">问题:对从1到n的所有值求和</strong></h2><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="a3a7" class="jy jz iq nd b gy nh ni l nj nk">function sumTo(n) {</span><span id="0c48" class="jy jz iq nd b gy nl ni l nj nk">}</span></pre><h1 id="3082" class="mb jz iq bd ka mc md me kd mf mg mh kg mi mj mk kk ml mm mn ko mo mp mq ks mr bi translated"><strong class="ak">步骤1)知道你的功能应该做什么</strong></h1><p id="7ad3" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">解决递归问题的第一步，是知道你的函数应该做什么。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/28e4c981fdd7c53787943a78a70994b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Lck2C_CbnxL4qD5mBmqsgQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">读者:你以为我是傻逼吗？</figcaption></figure><p id="5849" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这似乎是显而易见的，但却是被忽略的重要一步。你需要思考你的功能<strong class="kw ir"> <em class="lx">应该做什么</em>，</strong>而不是它<strong class="kw ir"> <em class="lx">目前做什么</em>。</strong></p><p id="8ce2" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">看看我们的sumTo()函数，很明显函数<strong class="kw ir"> <em class="lx">应该</em> </strong>返回一个从1到n的整数和。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="2007" class="jy jz iq nd b gy nh ni l nj nk">/*<br/>  sumTo() takes an integer n and returns the sum of all integers      from 1 to n<br/>*/</span><span id="3be2" class="jy jz iq nd b gy nl ni l nj nk">function sumTo(n) {</span><span id="86c3" class="jy jz iq nd b gy nl ni l nj nk">}</span></pre><h1 id="f1c8" class="mb jz iq bd ka mc md me kd mf mg mh kg mi mj mk kk ml mm mn ko mo mp mq ks mr bi translated"><strong class="ak">步骤2)挑选一个子问题，假设你的函数已经在处理它了</strong></h1><blockquote class="lu lv lw"><p id="257e" class="ku kv lx kw b kx lp kz la lb lq ld le ly lr lg lh lz ls lj lk ma lt lm ln lo ij bi translated"><strong class="kw ir"> …子问题…？</strong></p></blockquote><p id="2d12" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">一个<strong class="kw ir"> <em class="lx">子问题</em> </strong>是比你的原问题<strong class="kw ir">小</strong>的任何问题。</p><p id="27a5" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们最初的问题是对从1到n的所有值求和。在这种情况下，一个子问题是对所有数字求和，直到一个比n小的值<strong class="kw ir"><em class="lx"/></strong></p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="a5cb" class="jy jz iq nd b gy nh ni l nj nk">// If sumTo(n) was our original problem, these are all considered subproblems because they are smaller versions of the original problem</span><span id="f6ca" class="jy jz iq nd b gy nl ni l nj nk">sumTo(n-1)<br/>sumTo(n-2)<br/>sumTo(n-3)<br/>...<br/>sumTo(1)</span></pre><p id="12f2" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">但是为了使解决你的问题更容易，我们需要选择一个<em class="lx">合适的</em>子问题。</p><p id="d31c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">挑选一个合适的子问题</strong></p><p id="4417" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">挑选子问题有很多方法。一个好的开始策略是选择一个子问题作为<strong class="kw ir"> <em class="lx">尽可能接近原</em> </strong>。既然我们<strong class="kw ir"> <em class="lx">假设</em></strong>sumTo()函数<strong class="kw ir"> <em class="lx">已经工作了</em> </strong>，为什么不挑选一个值为我们解决大部分问题呢？</p><p id="b0f6" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在这种情况下，由于我们的问题求解n，那么最佳子问题应该求解n-1。</p><p id="c23f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">使用n-1作为我们的子问题</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="0bd1" class="jy jz iq nd b gy nh ni l nj nk">/*<br/>  sumTo() takes an integer and returns an integer n<br/>  that is the sum from 1 to n<br/>*/<br/></span><span id="9938" class="jy jz iq nd b gy nl ni l nj nk">// n is our original problem<br/>function sumTo (n) {</span><span id="ef65" class="jy jz iq nd b gy nl ni l nj nk">  // Using n-1 as our subproblem, it returns the sum from 1 to n-1.<br/>  const solutionToSubproblem = sumTo(n-1) <br/>}</span></pre><p id="0b26" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">但是等等！我们如何使用一个还没有定义的函数呢？？？</p><p id="478f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">你是对的，我们还没有定义任何东西，但这就是我在文章开头的意思。为了解决一个递归问题，让我们<strong class="kw ir"> <em class="lx">假设</em> </strong>这个函数已经对我们想要的任何子问题起作用。</p><p id="7aea" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">因为我们的子问题选择，我们已经有了从1到n-1的所有值的和。我们现在需要做的就是做最后一次飞跃。</p><h1 id="0e5f" class="mb jz iq bd ka mc md me kd mf mg mh kg mi mj mk kk ml mm mn ko mo mp mq ks mr bi translated">第三步:找到子问题的答案，用它来解决原来的问题。</h1><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nn"><img src="../Images/81275a49cdbc000d74f3a842f4c1c093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvtZw4QPovl9OhjV0hmabw.jpeg"/></div></div></figure><p id="9664" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们已经解决了我们的子问题。所以下一个问题是…</p><blockquote class="lu lv lw"><p id="5f14" class="ku kv lx kw b kx lp kz la lb lq ld le ly lr lg lh lz ls lj lk ma lt lm ln lo ij bi translated"><strong class="kw ir"> <em class="iq">我们如何把子问题的解，拿来解决原来的问题？</em> </strong></p></blockquote><p id="b2c9" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">到目前为止，我们已经解决了1到n-1。但是我们如何用它来求解n呢？</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="5d74" class="jy jz iq nd b gy nh ni l nj nk">// n is our original problem<br/>function sumTo (n) {</span><span id="4130" class="jy jz iq nd b gy nl ni l nj nk">  // Using n-1 as our subproblem, it returns the sum from 1 to n-1.<br/>  const solutionToSubproblem = sumTo(n-1) <br/>}</span></pre><p id="e530" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们再来思考一下我们原来的问题。</p><p id="9f33" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们想求从1到n的和，我们已经有了从1到n -1的解。</p><p id="ec00" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">如果我们有从1到n-1的解，我们如何得到从1到n的和？</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="0d70" class="jy jz iq nd b gy nh ni l nj nk">sumTo(n-1) // 1 + 2  ... n-2 + n-1<br/>sumTo(n)   // 1 + 2  ... n-2 + n-1 + n</span></pre><p id="72c3" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">有了一些基本的代数，我们需要做的就是在我们子问题的解上加n，这就解决了我们原来的问题。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="7592" class="jy jz iq nd b gy nh ni l nj nk">// What we've already determined<br/>sumTo(n-1) // 1 + 2  ... n-2 + n-1<br/>sumTo(n)   // 1 + 2  ... n-2 + n-1 + n</span><span id="734c" class="jy jz iq nd b gy nl ni l nj nk">// Using our solution to the subproblem to solve the original<br/>sumTo(n-1) + n  // 1 + 2  ... n-2 + n-1 + n<br/>sumTo(n)        // 1 + 2  ... n-2 + n-1 + n</span></pre><p id="7db9" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">或者在代码中…</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="1838" class="jy jz iq nd b gy nh ni l nj nk">function sumTo (n) { // n is our original problem<br/>  const solutionToSubproblem = sumTo(n-1) // n-1 is our subproblem<br/> <br/>  return solutionToSubproblem + n<br/>}</span></pre><p id="2e4a" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">正如你所看到的，我们找到了子问题的解决方案，并发现如何用它来解决原来的问题。这就是所谓的寻找<strong class="kw ir"> </strong> <em class="lx">递归关系。</em></p><h1 id="fb5b" class="mb jz iq bd ka mc md me kd mf mg mh kg mi mj mk kk ml mm mn ko mo mp mq ks mr bi translated">第四步，你已经解决了99%的问题。剩下的1%？基本情况。</h1><p id="255c" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">您的函数正在调用自己，因此它可能会永远运行下去。这就是为什么我们需要添加一个基础案例来阻止它。</p><p id="65cb" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">什么是基本案例，我们如何确定基本案例？</strong></p><p id="d374" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">基本情况是我们停止递归的一种方式。通常，它可以是函数开头的一个简单的if-else语句。</p><p id="7b24" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">如果条件已经达到其基本情况，它将阻止更多的函数调用。要选择一个基本案例，请考虑以下内容。</p><blockquote class="lu lv lw"><p id="91ee" class="ku kv lx kw b kx lp kz la lb lq ld le ly lr lg lh lz ls lj lk ma lt lm ln lo ij bi translated"><em class="iq">“不需要额外计算的</em> <strong class="kw ir">最容易的可能问题</strong> <em class="iq">是什么？”</em></p></blockquote><p id="13d6" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在我们的例子中，n = 0。</p><p id="7543" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">很明显，从0到0的所有值的和是0，所以为什么要做更多的递归呢？这就是我们定义基本案例的地方。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="6f85" class="jy jz iq nd b gy nh ni l nj nk">function sumTo (n) {<br/>  if (n === 0) { return 0 }<br/>  const solutionToSubproblem = sumTo(n-1)<br/> <br/>  return solutionToSubproblem + n<br/>}</span></pre><p id="f00c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">现在我们有了一个基本案例。现在有一个递归停止的点。</p><p id="dea8" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">就这样</strong></p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a80c0572912d38a7ea53fb6003d493cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*LBWMmAYiohGyvPRgnteOEw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">胜利尖叫！！！—海绵宝宝S3E1</figcaption></figure><p id="cdc3" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这就是我们的答案。总之，解决递归问题包括以下内容</p><ul class=""><li id="89a9" class="np nq iq kw b kx lp lb lq kh nr kl ns kp nt lo nu nv nw nx bi translated">记住函数<strong class="kw ir"> <em class="lx">应该</em> </strong>做什么，而不是它当前做什么</li><li id="a557" class="np nq iq kw b kx ny lb nz kh oa kl ob kp oc lo nu nv nw nx bi translated">识别适当的子问题</li><li id="5aea" class="np nq iq kw b kx ny lb nz kh oa kl ob kp oc lo nu nv nw nx bi translated">使用子问题的解决方案来解决原始问题</li><li id="264f" class="np nq iq kw b kx ny lb nz kh oa kl ob kp oc lo nu nv nw nx bi translated">撰写基本案例</li></ul></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h1 id="ae26" class="mb jz iq bd ka mc ok me kd mf ol mh kg mi om mk kk ml on mn ko mo oo mq ks mr bi translated">更多示例</h1><h2 id="ef58" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">问题:反转一个字符串</strong></h2><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="f4ad" class="jy jz iq nd b gy nh ni l nj nk">function reverse(s) {</span><span id="adaf" class="jy jz iq nd b gy nl ni l nj nk">}</span></pre><p id="f00f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"> 函数要做什么<strong class="kw ir"> <em class="lx">？函数<strong class="kw ir"> <em class="lx">应该</em> </strong>返回一个字符串的反向副本。</em></strong></p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="fd91" class="jy jz iq nd b gy nh ni l nj nk">// Reverses a string s<br/>function reverse(s) {</span><span id="2cda" class="jy jz iq nd b gy nl ni l nj nk">}</span></pre><p id="0023" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们的问题是反转一个字符串s。让我们想一个子问题，它会使解决这个问题变得容易。让我们用“<em class="lx">你好</em>”作为我们的主要问题。</p><p id="396b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">还是那句话，让我们假设<strong class="kw ir"><em class="lx"/></strong>reverse()已经起作用了。为了让我们的生活更容易，我们选择一个子问题来解决我们的大部分问题。在这种情况下，让我们只对除第一个字母以外的所有字母调用reverse()。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="bcf6" class="jy jz iq nd b gy nh ni l nj nk">reverse("Hello") // "Hello" is our original problem"<br/>reverse("ello")  // "ello" can be used as our subproblem</span></pre><blockquote class="lu lv lw"><p id="7513" class="ku kv lx kw b kx lp kz la lb lq ld le ly lr lg lh lz ls lj lk ma lt lm ln lo ij bi translated">如果你想知道为什么我选择“ello”作为子问题，请注意你也可以选择“Hell”作为子问题。我选择这个“ello”作为子问题，因为它将导致<em class="iq">更容易掌握代码。(请随意尝试其他子问题选项)</em></p></blockquote><p id="3d8e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们如何用我们的子问题来解决我们的原始问题？在这种情况下，我们可以将原问题的第一个字母附加到子问题解的末尾。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="4f98" class="jy jz iq nd b gy nh ni l nj nk">// What we determined so far<br/>reverse("Hello") // "olleH"<br/>reverse("ello")  // "olle"</span><span id="1afe" class="jy jz iq nd b gy nl ni l nj nk">// Using our subproblem to solve the original<br/>reverse("Hello")      // "olleH"<br/>reverse("ello") + "H" // "olleH"</span></pre><p id="b679" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">使用我们的例子，让我们把这个答案抽象为适用于任何字符串。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="fe41" class="jy jz iq nd b gy nh ni l nj nk">function reverse (s) {<br/>  const subproblem = s.slice(1, s.length) // exclude first letter<br/>  const reversedSubproblem = reverse(subproblem)</span><span id="40bb" class="jy jz iq nd b gy nl ni l nj nk">  return reversedSubproblem + s[0]<br/>}</span></pre><p id="0b12" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">最后，让我们确定我们的基本情况。对于我们的问题，我们可以传入的最简单的<strong class="kw ir"><em class="lx"/></strong>值是什么，使得<strong class="kw ir"> <em class="lx">不需要</em> </strong>额外计算？答案是空字符串。空字符串的逆序是什么？当然是空弦。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="0364" class="jy jz iq nd b gy nh ni l nj nk">function reverse (s) {<br/>  if (s === '') { return '' } // Base case</span><span id="e8df" class="jy jz iq nd b gy nl ni l nj nk">  const subproblem = s.slice(1, s.length)<br/>  const reversedSubproblem = reverse(subproblem)</span><span id="fb96" class="jy jz iq nd b gy nl ni l nj nk">  return reversedSubproblem + s[0]<br/>}</span></pre><h2 id="5575" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">问题:返回斐波那契数列中的第n项</h2><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi op"><img src="../Images/c957119d86af8a88d071a28d4051ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2v-qYJX-a1NITv9C"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">由<a class="ae nb" href="https://unsplash.com/@junglerolf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗尔夫·纽曼</a>在<a class="ae nb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6240" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">啊，是的，臭名昭著的斐波那契问题…</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="7431" class="jy jz iq nd b gy nh ni l nj nk">// Fibonacci Sequence<br/>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, ...</span><span id="61a6" class="jy jz iq nd b gy nl ni l nj nk">function fibTerm(n) {</span><span id="1694" class="jy jz iq nd b gy nl ni l nj nk">}</span></pre><p id="19e6" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">一旦你熟悉了斐波那契数列的工作原理，你会注意到第n项是它的前两个<strong class="kw ir"><em class="lx"/></strong>项之和。</p><p id="0663" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">比如说…</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="b0fe" class="jy jz iq nd b gy nh ni l nj nk">5 is the sum of the two previous values 3 and 2.<br/>34 is the sum of the two previous values 21 and 13.<br/>233 is the sum of the two previous values 144 and 89.</span></pre><p id="934d" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">与我们的其他问题不同，我们的原始问题需要我们解决<strong class="kw ir">两个子问题</strong>。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="cc79" class="jy jz iq nd b gy nh ni l nj nk">// Fibonacci Sequence (using n = 7 as an example)<br/>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, ...<br/>               ^  ^   ^<br/>              n-2 n-1 n</span><span id="2a04" class="jy jz iq nd b gy nl ni l nj nk">The nth term, is the sum of the n-1 and n-2 term.</span></pre><p id="2367" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir"> <em class="lx">假设</em> </strong>我们的函数已经起作用了，我们用它来计算前面两项。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="9dff" class="jy jz iq nd b gy nh ni l nj nk">// Fibonacci Sequence<br/>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, ...</span><span id="8c2f" class="jy jz iq nd b gy nl ni l nj nk">function fibTerm(n) {<br/>  const term1 = fibTerm(n-1)  // Our two sub problems<br/>  const term2 = fibTerm(n-2)<br/>}</span></pre><p id="d849" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">为了解决我们最初的问题，让我们返回两个子问题的和。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="6b25" class="jy jz iq nd b gy nh ni l nj nk">// Fibonacci Sequence<br/>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, ...</span><span id="e3bc" class="jy jz iq nd b gy nl ni l nj nk">function fibTerm(n) {<br/>  const term1 = fibTerm(n-1)<br/>  const term2 = fibTerm(n-2)<br/>  <br/>  // Solving the original problem using our subproblem solutions<br/>  return term1 + term2 <br/>}</span></pre><p id="98a7" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">找到基本情况可能有点棘手。在我们的例子中，我们有两种基本情况，n = 0和n = 1。原因是这些值没有前面两项可以计算。</p><p id="f0c1" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">使用n = 0和n = 1作为我们的基本情况，我们完成了我们的功能。</p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="0cfa" class="jy jz iq nd b gy nh ni l nj nk">// Fibonacci Sequence<br/>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, ...</span><span id="6f0e" class="jy jz iq nd b gy nl ni l nj nk">function fibTerm(n) {<br/>  if (n === 0) { return 0 }<br/>  if (n === 1) { return 1 }</span><span id="c8b1" class="jy jz iq nd b gy nl ni l nj nk">  const term1 = fibTerm(n-1)<br/>  const term2 = fibTerm(n-2)</span><span id="18e0" class="jy jz iq nd b gy nl ni l nj nk">  return term1 + term2 // Solving the original problem<br/>}</span></pre><h1 id="4d2b" class="mb jz iq bd ka mc md me kd mf mg mh kg mi mj mk kk ml mm mn ko mo mp mq ks mr bi translated">C++ / Python解决方案</h1><p id="b5da" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated"><strong class="kw ir">问题:从1到n的求和</strong></p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="5ada" class="jy jz iq nd b gy nh ni l nj nk">// C++<br/>int sumTo(int n) {<br/>  if (n == 1) { return 1 }<br/>  return n + sumTo(n)<br/>}</span><span id="297d" class="jy jz iq nd b gy nl ni l nj nk">// Python<br/>def sumTo(n) {<br/>  if (n == 1 ) { return 1 }<br/>  return n + sumTo(n)<br/>}</span></pre><p id="bf78" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">问题:将一个字符串从1反转到n </strong></p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="bcf0" class="jy jz iq nd b gy nh ni l nj nk">// C++<br/>string reverse(string n) {<br/>  if (n == '') { return ''}<br/>  return reverse(n.substr(1, n.length()-1 ) + n[0]<br/>}</span><span id="88fa" class="jy jz iq nd b gy nl ni l nj nk">// Python<br/>def reverse(n) {<br/>  if (n == '') { return ''}<br/>  return reverse(n[1:]) + n[0]<br/>}</span></pre><p id="779c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">问题:求斐波那契数列的第n项</strong></p><pre class="mt mu mv mw gt nc nd ne nf aw ng bi"><span id="c611" class="jy jz iq nd b gy nh ni l nj nk">// C++<br/>int fibTerm(int n) {<br/>  if (n == 0) { return 0 }<br/>  if (n == 1) { return 1 }<br/>  return fibTerm(n-1) + fibTerm(n-2)<br/>}</span><span id="846d" class="jy jz iq nd b gy nl ni l nj nk">// Python<br/>def fibTerm(n) {<br/>  if (n == 0) { return 0 }<br/>  if (n == 1) { return 1 }<br/>  return fibTerm(n-1) + fibTerm(n-2)<br/>}</span></pre></div></div>    
</body>
</html>