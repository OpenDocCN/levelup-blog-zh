<html>
<head>
<title>How to Implement Lazy Loading in React with Intersection Observer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React with Intersection Observer中实现延迟加载</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-implement-lazy-loading-in-react-with-intersection-observer-61c0e53ec8d?source=collection_archive---------5-----------------------#2020-12-21">https://levelup.gitconnected.com/how-to-implement-lazy-loading-in-react-with-intersection-observer-61c0e53ec8d?source=collection_archive---------5-----------------------#2020-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6287" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何延迟加载图像的解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d7e781ec8278a35e41bed580fb75c8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjsosMpl1zMg4GObr_V5Pg.png"/></div></div></figure><p id="d9e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你创建一个需要在屏幕上加载大量图片的网站时，你应该注意在浏览器上渲染图片的性能。</p><p id="e70a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你在项目代码中使用React，你可以通过<a class="ae lq" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>或<a class="ae lq" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank">线程</a>安装<a class="ae lq" href="https://www.npmjs.com/package/react-lazyload" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> react-lazyload </em> </a>包。它不同的图像加载，所以你可以期待更好的性能时，使用这个软件包。但是这个包需要大约40KB的存储空间。所以你可能会认为这对于缓慢加载图像来说太重了。</p><p id="7ddb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将向您展示一种不同的惰性加载方式，使用交叉点观察器。</p><h1 id="eeef" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">什么是IntersectionObserver</h1><p id="a8ae" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">Intersection Observer是一个新的API，与几年前相比，它可以更好地检测元素，原因如下。</p><ul class=""><li id="a192" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">页面滚动时图像或其他内容的延迟加载</li><li id="3d4b" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">实现“无限滚动”网站，当你滚动的时候，越来越多的内容被加载和呈现，这样用户就不需要翻页了</li><li id="4b70" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">报告广告的可见性，以便计算广告收入</li><li id="1ae0" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">根据用户是否会看到结果来决定是否执行任务或动画过程</li></ul><p id="e03f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在看了如何使用这个API的例子之后，让我们更深入地讨论这个API。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b2ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个例子与您可以从<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Thresholds" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>中检查到的一样，但是是在React环境中。</p><p id="6e43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">交叉点观察器是两个arity构造函数。它需要一个回调函数，每当它监视的元素出现在浏览器中时，该函数就会被触发，它还需要一个可选对象，该对象包含您可以在这里查看的信息<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Creating_an_intersection_observer" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="509b" class="nf lt it bd lu ng nh dn ly ni nj dp mc ld nk nl me lh nm nn mg ll no np mi nq bi translated">为什么路口观察者比较好？</h2><p id="551d" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">当过去需要无限滚动时，它会强制页面回流，因为检查滚动条当前位置所需的<code class="fe nr ns nt nu b">getClientBoundingRect</code>会强制回流。</p><p id="5abf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着时间的推移，新的强大功能，交叉点观察器，被创造出来，并建议用于无限滚动。但是，它仍然使用<code class="fe nr ns nt nu b">getClientBoundingRect</code>来获取它所观察的元素的位置。那为什么认为更好呢？</p><p id="9990" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">交叉点观察器使用<code class="fe nr ns nt nu b">requestIdleCallback</code>调用回调函数，当当前时钟周期内没有任务运行时触发该函数。因此，尽管使用交叉点观察器的新旧方法都可能导致回流，但是交叉点观察器在性能方面更好，因为它只在空闲期间运行回调函数。</p><h1 id="8794" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">普通卡片视图</h1><p id="aac4" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我使用了随机图像选择器网站来获取随机图像，这是这个项目的基本结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4644" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个页面一次加载大约50张物品卡片<strong class="kw iu"/>，在第一次渲染时也加载了大约50张图片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/65f7b8ac5da5cf3014d9a66255b453b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZesL1ljOog8d7tvGg7T4dA.png"/></div></div></figure><p id="1d15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以从开发工具检查“网络”选项卡上加载了多少图像。在这种情况下，从67个网络请求中加载了49个图像。幸运的是，网络请求的瀑布并不太长，但是你不应该想“哦，我不必关心这个”。</p><p id="3abd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果需要在屏幕上渲染的图像超过数千个怎么办？容易理解我的观点的最好例子是思考Pinterest是如何工作的。它们在你第一次看到的时候，以及每当你向下滚动到底部的时候，向你展示各种各样的图像——惰性加载。</p><p id="65cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么如何用交集观察者实现延迟加载呢？这很简单。设置触发回调函数的阈值，让交集观察器API一直观察元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw ne l"/></div></figure><p id="c4dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是您可以传递给交叉点观察器的属性列表。</p><ul class=""><li id="13cd" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">root-intersect observer将跟踪的根元素所属的根元素。如果省略，根将设置为视口</li><li id="53cc" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">rootMargin根元素的边距值。该规则与CSS边距相同。例如，如果rootMargin设置为“50px 0px 0px 0px”，则根元素的区域将更改为不可见元素，其顶部偏移量为原始根元素的50px。</li><li id="8147" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">threshold —数组中的值，每当跟踪元素超过阈值时就会触发回调。如果阈值设置为[0，0.5，1]，那么当跟踪元素通过0%、50%和100%的点时，将触发回调，这是指它在根元素上显示了多少。</li></ul><h1 id="8eec" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">惰性加载卡片视图</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d871" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个延迟加载的例子中，每张图片只有在屏幕上出现超过50%时才会被加载。</p><p id="ab78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们看看图像加载状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/c61cb639735d719cfd6893b115a71ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DXUH-K3FhdOuEz9HcUwN-A.gif"/></div></div></figure><p id="db89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看到了吗？当滚动条向下滚动时，加载的图像数量在增加。因为有了IntersectionObserver，它让浏览器只在合适的时候加载图片。</p><h1 id="8c22" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">浏览器支持</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/d00ee5f230b12ebb397ab99d846704cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zK-ByzLfJJNuFaCNMNE2Aw.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated"><a class="ae lq" href="https://caniuse.com/intersectionobserver" rel="noopener ugc nofollow" target="_blank">我可以使用intersect observer</a></figcaption></figure><p id="9cab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">浏览器支持范围还不错，但也没那么好，因为IE根本不支持这个API。</p><p id="1d72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是不用担心！W3C为项目中需要的人分发了IntersectionObserver的polyfill。</p><h1 id="c70c" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">NPM著名的懒人包</h1><p id="d095" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">正如我在本文前面演示的那样，使用IntersectionObserver实现延迟加载组件非常简单。但是，您可能不想从头到尾实现它。有时您可能只想安装一个包。所以我要介绍一些有很多明星的NPM套餐。</p><h2 id="a8b9" class="nf lt it bd lu ng nh dn ly ni nj dp mc ld nk nl me lh nm nn mg ll no np mi nq bi translated">反应迟缓装载</h2><div class="od oe gp gr of og"><a href="https://www.npmjs.com/package/react-lazy-load" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">反应迟缓装载</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">React Lazy Load是一个易于使用的React组件，它可以帮助您以可预测的方式延迟加载内容。很快…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.npmjs.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><h2 id="7ce5" class="nf lt it bd lu ng nh dn ly ni nj dp mc ld nk nl me lh nm nn mg ll no np mi nq bi translated">香草冰淇淋</h2><div class="od oe gp gr of og"><a href="https://www.npmjs.com/package/vanilla-lazyload" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">香草冰淇淋</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">LazyLoad是一个轻量级(2.4 kB)和灵活的脚本，它通过延迟加载…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.npmjs.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div><h2 id="9246" class="nf lt it bd lu ng nh dn ly ni nj dp mc ld nk nl me lh nm nn mg ll no np mi nq bi translated">jquery-懒惰</h2><div class="od oe gp gr of og"><a href="https://www.npmjs.com/package/jquery-lazy" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">jquery-懒惰</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">这个项目得到了JetBrains &amp; PhpStorm的友好支持！Lazy是一个快速、功能丰富、轻量级的延迟…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.npmjs.com</p></div></div><div class="op l"><div class="ow l or os ot op ou ks og"/></div></div></a></div><h1 id="0b3b" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">结论</h1><p id="a137" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">IntersectionObserver是一个浏览器独有的特性，可以让您实现延迟加载。您可以延迟加载图像或大量内容，以减少用户等待查看内容的总时间。</p><p id="f5c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，IntersectionObserver并不是所有的浏览器都完全支持的，所以一定要检查polyfill，或者你可以考虑安装一个已经制作好的包。</p><h1 id="7ac8" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">参考</h1><ul class=""><li id="af5c" class="mp mq it kw b kx mk la ml ld ox lh oy ll oz lp mu mv mw mx bi translated"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Intersection _ Observer _ API</a></li><li id="a312" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Window/requestIdleCallback</a></li><li id="fae8" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><a class="ae lq" href="https://developers.google.com/web/updates/2016/04/intersectionobserver" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/web/updates/2016/04/intersection observer</a></li></ul></div></div>    
</body>
</html>