<html>
<head>
<title>React Hooks and Animations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩子和动画</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-hooks-and-animations-9bd4bd2a7f3a?source=collection_archive---------1-----------------------#2019-12-22">https://levelup.gitconnected.com/react-hooks-and-animations-9bd4bd2a7f3a?source=collection_archive---------1-----------------------#2019-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/cb1292911e0eae6e63d6e76b9ca39214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iqxx3u7xOM9tlSA2TXPQPQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">克里斯托夫·高尔在<a class="ae jd" href="https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="621e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将通过构建一个基于函数的React组件，利用钩子创建一个可重用的组件来简化过渡动画。在这篇文章的最后，我们将有一个基本的组件，它将显示子对象变化的幻灯片过渡，如下所示:</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/23e96dda2c7f6fcfae72e40d173a2a79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FGyA9greYbxEio4fIgSUVw.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">完成动画组件的目标</figcaption></figure><p id="6da9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将经历基本的应用程序设置和构建该组件的迭代过程；但是，如果您想跳到最终结果，请点击<a class="ae jd" href="https://justsome.codes/simplifying-react-animations-with-hooks/#completed-component" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="66f5" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">基本应用程序</h1><p id="6785" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">首先，让我们定义一个基本的React应用程序，它显示一张卡片，并允许用户通过单击next按钮来循环显示可用的卡片。</p><p id="e60b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个应用程序示例有两个基本组件，一个显示标题和文本的卡片，以及一个处理各个卡片的显示并基于按钮点击处理到下一个卡片的导航的容器。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">基本应用程序</figcaption></figure><p id="17e5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了这个基本的应用程序示例，让我们看看它是什么样子的。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="ml mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">基本应用程序的代码</figcaption></figure><h1 id="0970" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">动画的目标</h1><p id="9b82" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">这个动画应该将下一张卡片从右手边滑到合适的位置，并将旧卡片滑到左边。虽然这是一个相当简单的动画，但我们希望对主要组件的改动尽可能小。为了做到这一点，并使逻辑模块化，这个实现将使用一个定制的钩子来处理渲染和动画控制。现在我们对这个钩子的目标有了一个基本的概念，让我们开始吧。</p><h1 id="3283" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">基本反应组件挂钩设计</h1><p id="d96c" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">为了正常工作，让我们首先创建一个基本的react组件，它将成为我们的动画容器。最基本的是，这将返回一个包含传递给它的子元素的div。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">基本动画组件</figcaption></figure><p id="8c68" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现时，每次按下按钮，react组件都会将下一张卡片发送到AnimationContainer，它将呈现包含该卡片的基本div。现在我们有了一个基本的容器，我们需要这个动画容器的内容在子变化时被动画化，这就是我们的定制钩子的用武之地。让我们快速概述一下这个钩子将做什么，以及什么时候需要动画。</p><ul class=""><li id="b9ee" class="mm mn jg kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">动画将在传递给动画容器的子项发生变化时触发</li><li id="3b03" class="mm mn jg kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">动画过程需要显示先前的元素和新的元素</li><li id="fd81" class="mm mn jg kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">在动画周期完成后，我们需要从显示中完全删除之前的元素。</li></ul><p id="96a4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了基本的需求，让我们开始编写和实现钩子。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">连接定制挂钩</figcaption></figure><p id="c1a6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个钩子现在监听子元素的变化，并将这个新项添加到所有过去项的数组中。我们的行为现在看起来像这样。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/6554638557932a79fe3670a46d7749d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bi-QqZVdPl2OZyCV.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">完成动画组件的第一步</figcaption></figure><p id="44fc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，我们正确地监听了子变更事件，并显示了不止一个子元素，而没有对我们的核心组件进行任何更改。现在我们需要触发动画，并在动画完成后进行清理。</p><p id="8188" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从样式和动画开始。为这种情况制作过渡动画需要两个基本类和一个动画关键帧定义。让我们从让容器将卡片并排显示开始。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">初始动画容器样式</figcaption></figure><p id="fec6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要为我们的前一个/离开元素添加or类和关键帧动画。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">添加关键帧动画</figcaption></figure><p id="9b24" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们更新我们的挂钩，以包括以下内容:</p><ul class=""><li id="7266" class="mm mn jg kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">指定我们的新css类来制作前一个元素的动画</li><li id="e529" class="mm mn jg kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">将动画结束事件添加到前一个元素</li><li id="ee71" class="mm mn jg kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">前一个元素动画完成后，从渲染中移除该项目</li></ul><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">将动画逻辑添加到动画组件</figcaption></figure><p id="981d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些基本的更新，我们开始得到一个平滑的动画，看起来像这样。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/8ab3ddb29de4c69d2e79760fe8233b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kL48blrunU7SXKGV.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">动画工作，但需要一些平滑</figcaption></figure><p id="6c64" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来好多了，但是我们仍然可以向新元素添加一些额外的动画关键帧属性，以使入口动画更加平滑。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">添加淡入关键帧</figcaption></figure><p id="6889" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经定义了淡入动画，让我们更新钩子以在新的项目中使用它。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">向动画组件添加淡入动画</figcaption></figure><p id="a03e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在这两个元素都是动画了，让我们再来看看我们的过渡。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/5b5031fe6a9f77ffbc2cc0ceb53f4da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dqrgCcRotyYdK7Xj.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">看起来更好，但动画需要更多的平滑</figcaption></figure><p id="76c1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在看到的一些问题，与入境元素削减和削减一些。此问题最可能的原因是由于React元素协调。基本上，在删除旧元素的渲染周期完成时，react认为要显示的新数组与之前渲染的帧没有直接关联，这导致不必要的DOM元素卸载和安装，而不仅仅是更新项目。我们可以通过使用React <strong class="kf jh"> key </strong>属性让react now元素关系来解决这个问题。为此，让我们首先在主组件中为每张卡添加一个键属性。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">向基本组件添加键属性</figcaption></figure><p id="a8ef" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要更新钩子以确保我们的组件结构在渲染周期之间不会改变，并且我们基于这个卡键在每个动画div上实现一个键。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">向动画组件添加其他关键属性</figcaption></figure><p id="97eb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有了一个完整的幻灯片动画组件，可以处理变化之间的幻灯片过渡。你可以在<a class="ae jd" href="https://github.com/StMotorSpark/Hooks-Animation-Container" rel="noopener ugc nofollow" target="_blank"> Github repo </a>下面的Codepen中看到示例动画和完整代码。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/b494012e3302054f2aaa4b8861f56670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iTf9h_oVqAQuSvNI.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">完整的动画</figcaption></figure><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="ml mk l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">成品密码笔</figcaption></figure></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="fd3c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nh">原载于2019年12月22日</em><a class="ae jd" href="https://justsome.codes/simplifying-react-animations-with-hooks/" rel="noopener ugc nofollow" target="_blank"><em class="nh">https://just some . codes</em></a><em class="nh">。</em></p></div></div>    
</body>
</html>