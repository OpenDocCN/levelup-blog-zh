<html>
<head>
<title>My Django Nightmare Implementing an In-App Scheduling Feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的Django噩梦实现了一个应用内的日程安排功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/my-django-nightmare-implementing-an-in-app-scheduling-feature-a7d9d53cb153?source=collection_archive---------3-----------------------#2020-04-08">https://levelup.gitconnected.com/my-django-nightmare-implementing-an-in-app-scheduling-feature-a7d9d53cb153?source=collection_archive---------3-----------------------#2020-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ebd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注意:本文不是关于安排数据库备份等基础设施编程任务。相反，它侧重于应用内的功能，用户可以根据时间表设置要创建/到期的任意任务。</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/124605eb5e2a5abe1595e1e6487cddde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-6YyjTiEpOtfjijt5TRAw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图1 —面向用户的调度功能实现</figcaption></figure><h1 id="e775" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">情况</h1><p id="92b8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我目前正在做的一个项目是大型工业场所的维护计划系统<a class="ae mi" href="https://www.luberly.com/" rel="noopener ugc nofollow" target="_blank">(它叫做Luberly，更多信息可以在这里找到)</a>。最近，我们解决了一个看似复杂的任务，即允许用户设置定期完成的工作路线。这种工作路线的一个例子是:</p><blockquote class="mj mk ml"><p id="8d17" class="jq jr ko js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">每四周更换一次“建筑A”中每台机器的油。</p></blockquote><p id="74af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章在很大程度上应该是与技术无关的。然而，为了提供一些上下文，Luberly是使用与Python (Django)后端接口的React前端构建的。</p><p id="e4a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注意:在本文的其余部分，工作路线将被称为“路线”。</em></p><h1 id="eaa3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们的起点</h1><p id="48db" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在开始研究这个特性之前，我们已经有了下面定义的与路线相关的模型类。对于不熟悉Python ORMs的人来说，可以把模型想象成表示数据库表的Python类，它的实例表示数据库的记录。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mp"><img src="../Images/18c5da64d591979bbdca6c1cc25d148e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fS41Y6CuiPzejwmDzYi8jg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图2 —显示模型/表格如何相互连接的简单示意图</figcaption></figure><p id="3129" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mq mr ms mt b">Route</code>、<code class="fe mq mr ms mt b">Schedule</code>和<code class="fe mq mr ms mt b">RouteJob</code>被设计为协同工作，以存储和管理实现预定路线特征所需的数据。这些类中的每一个都有它自己的一套职责(解释如下),它们很乐意根据所述工作的性质将工作分配给每个类。</p><p id="5f7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"/><code class="fe mq mr ms mt b"><strong class="js iu">RouteJob</strong></code><strong class="js iu">型号</strong></p><ul class=""><li id="75b7" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><code class="fe mq mr ms mt b">RouteJob</code>的一个实例代表一条根据其创建者<code class="fe mq mr ms mt b">Route</code>的一个实例<code class="fe mq mr ms mt b">schedule</code>属性创建的路线。一个<code class="fe mq mr ms mt b">RouteJob</code>有一个截止日期和它自己的完成状态。</li><li id="f9d5" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">当用户在应用程序中查看/完成即将到来的路线时(见下文)，他们正在与<code class="fe mq mr ms mt b">RouteJobs</code>的实例进行交互。</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ni"><img src="../Images/07658f852326821d5e57aa363aba621c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcUWY9Q6hrG4LVsP-tV8XQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图3-即将到来的工作路线的应用内视图</figcaption></figure><p id="911d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"/><code class="fe mq mr ms mt b"><strong class="js iu">Route</strong></code><strong class="js iu">型号</strong></p><ul class=""><li id="bab6" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">一个<code class="fe mq mr ms mt b">Route</code>的实例存储任何关于一条路由的从不改变的数据，比如它的<code class="fe mq mr ms mt b">name</code>和链接到一个<code class="fe mq mr ms mt b">Schedule</code>实例的主键。</li><li id="8815" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">负责通过<code class="fe mq mr ms mt b">Route().create_route_job()</code>方法创建<code class="fe mq mr ms mt b">RouteJobs</code>。</li></ul><p id="f3f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"/><code class="fe mq mr ms mt b"><strong class="js iu">Schedule</strong></code><strong class="js iu">型号</strong></p><ul class=""><li id="5dbd" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">负责存储时间表定义数据，并通过<code class="fe mq mr ms mt b">Schedule().calculate_next_due_date(self)</code>方法通知<code class="fe mq mr ms mt b">Route</code>下一个<code class="fe mq mr ms mt b">RouteJob</code>时间表。</li></ul><p id="1515" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们功能的成功实现必须能够处理以下调度类型:</p><ol class=""><li id="d9c2" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn nj na nb nc bi translated"><em class="ko">每x天完成的路线</em></li><li id="acf6" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn nj na nb nc bi translated"><em class="ko">路线将于每x周的周一、周三和Fri完成</em></li><li id="3b37" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn nj na nb nc bi translated"><em class="ko">每y个月在1日、15日和30日完成的路线</em></li></ol><p id="4513" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mq mr ms mt b">Schedule</code>模型类(及其子类)是本文的主题，我们正在探索:</p><ul class=""><li id="32c7" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">我们需要存储什么数据才能实现上面列出的三种时间表类型？</li><li id="7fa2" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">我们应该如何存储这样的数据？</li><li id="804c" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">我们如何实现逻辑来检索该数据并使用它来为后续的<code class="fe mq mr ms mt b">RouteJobs</code>确定<code class="fe mq mr ms mt b">due_dates</code>？</li></ul><p id="b4bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在追求编程卓越的过程中，<code class="fe mq mr ms mt b">Schedule</code>模型不应该关心它正在调度什么，因此应该足够灵活，可以在应用程序的其他地方使用。</p><p id="2b99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将概述我们考虑过的几种方法，然后最终向您展示我们选定的实现。</p><h1 id="c3f9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">你将如何实现这样一个特性？</h1><p id="85f8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">尽管我们多次重写了这个实现，但我仍然认为它远非完美。我们竭诚欢迎任何改进或替代方法的建议，请留下您的评论:)。</p><h1 id="8c5b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们的第一个想法——cron调度表达式</h1><p id="a610" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">过去我曾与cron jobs合作安排数据库备份、自动化电子邮件和数据处理工作等任务，这是我在设计这个功能时使用的第一个工具。</p><p id="59bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当时，这种解决方案似乎是最佳的，因为它只需要一个单独的计划定义数据库字段<code class="fe mq mr ms mt b">cron_string</code>。一个例子是<code class="fe mq mr ms mt b">0 0 1,15 * *</code>表示在每个月的1号和15号运行任务的计划。</p><p id="788c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实现这一功能需要:</p><ol class=""><li id="7ebc" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn nj na nb nc bi translated">编写一个JavaScript实用程序，将用户输入的表单数据转换成cron schedule表达式。</li><li id="0388" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn nj na nb nc bi translated">编写或找到一个Python实用程序来解析调度的<code class="fe mq mr ms mt b">cron_string</code>属性，并提取调度下一个任务所需的信息。</li></ol><p id="ff62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，很明显，cron不能提供我们的时间表所需要的灵活性，而且编写解析器(尤其是前端代码)太耗费人力，所以我们寻找替代的解决方案。</p><h1 id="b12f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们的第二个想法——类继承</h1><p id="7573" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在决定不采用基于cron的方法后，基于一些良好的旧StackOverflow研究，下一个想法是将每种调度类型的存储和逻辑都分离到各自的模型类中。在我们的例子中，这样的类将是<code class="fe mq mr ms mt b">DailySchedule</code>、<code class="fe mq mr ms mt b">DayOfWeekSchedule</code>和<code class="fe mq mr ms mt b">DayOfMonthSchedule</code>。</p><p id="0141" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如下所示，每条路线都与一个<code class="fe mq mr ms mt b">RouteSchedule</code>有一对一的关系，该【】有三个可选字段，可以与其中一个可用的时间表类型建立一对一的关系。<code class="fe mq mr ms mt b">RouteSchedule</code>将负责确定正在使用哪种调度类型，然后与该调度类型交互以提取与调度相关的数据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nk"><img src="../Images/1a5ee0d31f9ac921d5b70c3d84300916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCaCvzdgGNczFDlMFweNsA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图4 -显示模型与类继承方法关系的简单示意图</figcaption></figure><p id="2131" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个<code class="fe mq mr ms mt b">DailySchedule</code>、<code class="fe mq mr ms mt b">DayOfWeekSchedule</code>和<code class="fe mq mr ms mt b">DayOfMonthSchedule</code>都有自己的内部工作机制来决定重要的信息，比如下一个事件应该安排在什么时候。尽管它们有所不同，但它们只公开了几个定义在抽象<code class="fe mq mr ms mt b">Schedule</code>类(也称为接口)中的公共方法，它们都继承了这些方法。</p><p id="4b75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样<code class="fe mq mr ms mt b">RouteSchedule</code>可以对它们一视同仁，当<code class="fe mq mr ms mt b">Route</code>向<code class="fe mq mr ms mt b">RouteSchedule</code>请求此类信息时，只需调用<code class="fe mq mr ms mt b">calculate_next_due_date()</code>即可。</p><p id="0e43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个解决方案实际上工作得很好，在我看来，是抽象类继承的一个很好的用例。</p><p id="e78d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，它需要大量的新代码和许多新的数据库表。就在我准备提交这部作品的PR时，我看到了<code class="fe mq mr ms mt b">dateutils.rrule</code> <a class="ae mi" href="https://dateutil.readthedocs.io/en/stable/rrule.html" rel="noopener ugc nofollow" target="_blank"> python模块</a>，它改变了游戏规则…</p><h1 id="7855" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们的最终解决方案——规则</h1><p id="f4f8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Python的<code class="fe mq mr ms mt b">dateutils.rrule</code>模块(类似的包也存在于<code class="fe mq mr ms mt b">npm</code>中)是一个非常酷的实用程序，它完成了我在上面概述的类继承示例中手工实现的大部分繁重工作。</p><p id="4df7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mi" href="https://dateutil.readthedocs.io/en/stable/rrule.html" rel="noopener ugc nofollow" target="_blank">文档</a>详细介绍了每一件事，但它就像通过传入一些与时间表相关的参数(如<code class="fe mq mr ms mt b">frequency</code>、<code class="fe mq mr ms mt b">interval</code>、<code class="fe mq mr ms mt b">byweekday</code>)来实例化一个<code class="fe mq mr ms mt b">rrule</code>对象一样简单。然后这个<code class="fe mq mr ms mt b">rrule</code>对象可以根据这个时间表创建所有未来事件的流。太牛逼了！</p><p id="4110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，为了让我们实现规范中的调度类型(为了方便起见，在下面重复)，我们只需在数据库中保存适当的<code class="fe mq mr ms mt b">rrule</code>参数。</p><ol class=""><li id="8bc9" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn nj na nb nc bi translated"><em class="ko">每x天完成的路线</em></li><li id="6361" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn nj na nb nc bi translated"><em class="ko">每x周在Fri周一、周三完成的路线</em></li><li id="bbac" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn nj na nb nc bi translated"><em class="ko">每y个月在1日、15日和30日完成的路线</em></li></ol><p id="f8f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的数据库结构不需要修改<code class="fe mq mr ms mt b">Figure 2</code>的结构，只需要向<code class="fe mq mr ms mt b">Schedule</code>模型添加一些属性和方法。</p><p id="8828" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终的<code class="fe mq mr ms mt b">Schedule</code>模型类看起来如下所示(但是有更多的方法被下面包含的方法调用):</p><pre class="kq kr ks kt gt nl mt nm nn aw no bi"><span id="e15c" class="np lg it mt b gy nq nr l ns nt">from typing import List, Dict<br/>from django.db import models<br/>from dateutil.rrule import rrule, DAILY, WEEKLY, MONTHLY</span><span id="9839" class="np lg it mt b gy nu nr l ns nt">class Schedule(models.Model):</span><span id="14fe" class="np lg it mt b gy nu nr l ns nt">   YEARS_AHEAD_TO_LOOK_FOR_NEXT_DUE_DATE = 5<br/>   FREQUENCY_CHOICES = (<br/>      (DAILY, "daily"), <br/>      (WEEKLY, "weekly"), <br/>      (MONTHLY, "monthly")<br/>   )<br/>   <br/>   rrule_frequency = models.IntegerField(choices=FREQUENCY_CHOICES)<br/>   rrule_dstart = models.DateField(<br/>   rrule_interval = models.IntegerField()<br/>   rrule_byweekday_csv = models.CharField(max_length=124)<br/>   rrule_bymonthday_csv = models.CharField(max_length=124)</span><span id="cbf0" class="np lg it mt b gy nu nr l ns nt">@classmethod<br/>def create(cls, schedule_dict: Dict):<br/>   &lt;some logic here&gt;</span><span id="1f89" class="np lg it mt b gy nu nr l ns nt">def calculate_first_due_date(self):<br/>   &lt;some logic here using rrule object&gt;</span><span id="2c7f" class="np lg it mt b gy nu nr l ns nt">def calculate_next_due_date(self):<br/>   &lt;some logic here using rrule object&gt;</span><span id="ebca" class="np lg it mt b gy nu nr l ns nt">def _get_rrule_object(self, count=None, until=None):<br/>   &lt;some logic here&gt;</span><span id="0968" class="np lg it mt b gy nu nr l ns nt">def _convert_csv_field_to_list(self, csv_field: str) -&gt; List:<br/>   &lt;some logic here&gt;</span><span id="f723" class="np lg it mt b gy nu nr l ns nt">def _get_rrule_object(self, count=None, until=None):<br/>   &lt;some logic here&gt;</span></pre><p id="0ed2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终，我们认为最终的解决方案是三个方案中最好的，因为它提供了实现强大、灵活和可扩展(如果需要，我们可以在以后向<code class="fe mq mr ms mt b">Schedule</code>模型添加更多与rrule相关的字段)的调度功能的能力，同时只需要添加一个数据库表和相关的python类来维护。</p><p id="3e88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这篇文章至少是有趣的，并希望对其他即将开始构建应用内日程安排功能的人有所帮助。</p><p id="408a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，如果你想联系任何Python/Django/React项目，请随时通过我的网站联系我。</p><p id="bb70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">干杯！</p><p id="0c5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">斯科特</p></div></div>    
</body>
</html>