<html>
<head>
<title>Custom serialization using your own personalized annotations and Java reflection in Spring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Spring中使用您自己的个性化注释和Java反射进行定制序列化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/custom-serialization-using-spring-your-own-annotations-and-java-reflection-b78b96ee461c?source=collection_archive---------3-----------------------#2020-03-06">https://levelup.gitconnected.com/custom-serialization-using-spring-your-own-annotations-and-java-reflection-b78b96ee461c?source=collection_archive---------3-----------------------#2020-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="309d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时，我们希望在域对象作为响应被发送回来之前，以一种非常特定的方式对它们进行序列化。有时这些方式在我们的实体中形成了一个更广泛的模式。注释对于建议我们的应用程序如何序列化某些类型的对象非常有帮助。</p><h2 id="4e6a" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">什么是序列化？</h2><p id="557b" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">这通常是指将对象的状态转换成字节流。但是在开发web服务的上下文中，这通常意味着将我们的域对象的状态转换成遵循某些约定的字符串，比如JSON。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="bd06" class="kl km iq lo b gy ls lt l lu lv">public class Position {<br/>    double latitude = 0.0<br/>    double longitude = 0.0;<br/>}</span></pre><p id="f6e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将此位置对象序列化为JSON字符串将输出:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="b3b3" class="kl km iq lo b gy ls lt l lu lv">{ "latitude": 0.0, "longitude": 0.0}</span></pre><p id="1b5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，Spring提供了许多不同的策略来序列化对象，但是有时候多做一点是值得的。</p><h2 id="7f11" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">我们要建造什么？</h2><p id="0efb" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我们将通过一个非常简单的例子来展示如何使用我们自己的自定义注释来确定字段如何被序列化。</p><h1 id="5c57" class="lw km iq bd kn lx ly lz kq ma mb mc kt md me mf kw mg mh mi kz mj mk ml lc mm bi translated">领域</h1><p id="7dc1" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我将让我所有的域类扩展一个名为<em class="mn"> IdentifiedResource </em>的类，它规定了我的资源在我的应用程序中是如何被标识的。这种类将成为我们的自定义序列化程序的目标。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="18fe" class="kl km iq lo b gy ls lt l lu lv"><strong class="lo ir">@JsonSerialize(using = MyCustomSerializer.class)</strong><br/>public class IdentifiedResource {<br/><br/>    private String id;</span><span id="22b9" class="kl km iq lo b gy mo lt l lu lv">    //...<br/>}</span></pre><p id="c4c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我已经指出了我将使用什么类来把这种对象转换成JSON。我们稍后将回到这一点。</p><p id="d72e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了有一个更广泛的例子，让我们用一个名为<em class="mn"> NamedResource </em>的类来扩展这个类，它将代表我们领域中具有人类可读名称的对象。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="c4cc" class="kl km iq lo b gy ls lt l lu lv">public class NamedResource <strong class="lo ir">extends IdentifiedResource </strong>{<br/><br/>    private String name;<br/>    <br/>    //...<br/><br/>}</span></pre><p id="5e53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们给它一些背景。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="88c2" class="kl km iq lo b gy ls lt l lu lv">public class Manufacturer extends NamedResource { }</span><span id="b847" class="kl km iq lo b gy mo lt l lu lv">public class Model  extends NamedResource{}</span><span id="d5de" class="kl km iq lo b gy mo lt l lu lv">public class Car extends IdentifiedResource {<br/><br/>    <strong class="lo ir">@Identified</strong><br/>    private Model model;<br/><br/>    <strong class="lo ir">@Named</strong><br/>    private Manufacturer manufacturer;<br/><br/>    <strong class="lo ir">@ServiceDependent</strong>(service = MyService.class, <br/>        method = "getCarPosition")<br/>    private Position position;<br/><br/>    //...<br/>}</span></pre><p id="aaa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哇哦。那是什么？你看这辆车有型号，制造商和位置。谁知道呢，也许这是一家为客户提供按需汽车共享服务的公司。</p><p id="b4de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是那些注释是什么呢？我当然不会在Spring的注释包中看到它们。让我们仔细看看。</p><h2 id="bf2f" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">@已识别</h2><p id="9aab" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我希望这个注释告诉我的序列化程序，我不希望这个内部字段被完全序列化，只要给我它的ID就可以了。</p><h2 id="801c" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">@已命名</h2><p id="ad0e" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">类似于标识的注释，但是这里我想让它获取资源的名称。</p><h2 id="24c4" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">@服务依赖</h2><p id="112f" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">这个有点棘手。我将使用这个来告诉我的序列化程序，我的字段实际上依赖于在特定服务上执行一个方法。</p><p id="efa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有关于存储在不同位置的对象的信息，并且希望在序列化时将它们打包在一起，这可能非常有用。</p><h2 id="3bf3" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">花些时间反思</h2><figure class="lj lk ll lm gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mp"><img src="../Images/6daa3527c0ea5a369d6833542551f51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skFWmM1LlSoBshsGHDcFYg.jpeg"/></div></div></figure><p id="d389" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Java反射:如果您从未使用过这个强大的Java特性，现在是开始使用的好时机，因为我们将在下一步中使用它。它对于在运行时修改行为或类和方法非常有用，这正是我们正在尝试做的。我不会详细解释，但网上有很多<a class="ae mx" href="https://www.baeldung.com/java-reflection" rel="noopener ugc nofollow" target="_blank">指南。</a></p><h2 id="45f7" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">串行器</h2><p id="63de" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">好了，我们已经有了领域对象、自定义注释，心中只有美好的愿望。是时候写一个类了，这个类将会为我们做一些艰苦的工作。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="0763" class="kl km iq lo b gy ls lt l lu lv">public class <strong class="lo ir">MyCustomSerializer</strong> extends StdSerializer&lt;Object&gt; {<br/><br/>    public <strong class="lo ir">MyCustomSerializer</strong>() {<br/>        super(Object.class);<br/>    }<br/><br/>    @Override<br/>    public void <strong class="lo ir">serialize</strong>(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {<br/>        <em class="mn">//...</em><br/>    }<br/>    <br/>}</span></pre><p id="2d45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们需要的序列化器的基本结构。如果我们愿意，我们可以把我们的IdentifiedResource作为类型参数给它，但是因为我们将使用反射来处理字段和方法，所以它实际上适用于我们想用它处理的任何其他类型的对象。</p><h1 id="8a94" class="lw km iq bd kn lx ly lz kq ma mb mc kt md me mf kw mg mh mi kz mj mk ml lc mm bi translated">该串行化方法</h1><p id="7544" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">啊，演出的明星。但首先要做的是。</p><h2 id="8ebc" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">如何处理每个注释？</h2><p id="0eaa" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">当然，我们可以在函数体中有一长串的<em class="mn">if</em>和<em class="mn">else</em>，但是，嘿，我们不要这样做，好吗？我将尝试编写一个函数来搜索用<strong class="jp ir"> @ SerializerAdvice </strong>注释的函数，它将告诉我如何序列化我的注释字段。</p><h2 id="dd83" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">找到正确的方法</h2><p id="957a" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我希望所有方法都位于我的自定义序列化程序中，所以我将简单地创建一个映射，包含所有合适的方法，就在构造函数中。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="da97" class="kl km iq lo b gy ls lt l lu lv">private Map&lt;Class, Method&gt; <strong class="lo ir">serializationMap</strong> = new HashMap&lt;&gt;();</span><span id="44f5" class="kl km iq lo b gy mo lt l lu lv">public MyCustomSerializer() {<br/>    super(Object.class);<br/><br/>    Arrays.<em class="mn">stream</em>(this.getClass().getDeclaredMethods())<br/>            .filter(method -&gt; method.isAnnotationPresent(SerializerAdvice.class))<br/>            .forEach(method -&gt; {<br/>                SerializerAdvice annotation = method.getAnnotation(SerializerAdvice.class);<br/>                Class annotationClass = annotation.value();<br/>                <strong class="lo ir">serializationMap.put(annotationClass, method);</strong><br/>            });<br/>}</span></pre><p id="4f98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们为获得方法映射所做的工作:</p><ul class=""><li id="f1d3" class="my mz iq jp b jq jr ju jv jy na kc nb kg nc kk nd ne nf ng bi translated">对当前类的所有方法进行流式处理</li><li id="dd61" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">过滤掉那些没有用SerializerAdvice注释的</li><li id="c877" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">把剩下的放在一个HashMap中，告诉我们每种类型的注释使用哪种方法。</li></ul><h2 id="8852" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">连载</h2><p id="df3b" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">让我们看看serialize函数应该是什么样子。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="d635" class="kl km iq lo b gy ls lt l lu lv">@Override<br/>public void <strong class="lo ir">serialize</strong>(Object target, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {<br/><br/>    jsonGenerator.writeStartObject();</span><span id="3c71" class="kl km iq lo b gy mo lt l lu lv">Class targetClass = target.getClass();<br/><br/>    for (Field field : targetClass.getDeclaredFields()) {<br/><br/>        Annotation[] annotations = field.getAnnotations();<br/><br/>        Optional&lt;Method&gt; advisingMethod = Arrays.<em class="mn">stream</em>(annotations) <br/>            .filter(annotation -&gt;            serializationMap.containsKey(annotation.annotationType())) <br/>            .map(annotation -&gt; serializationMap.get(annotation.annotationType())) <br/>            .findFirst(); <br/><br/>        if (advisingMethod.isPresent()) {<br/>             advisingMethod.get().invoke(this, target, field, jsonGenerator);<br/>        } else { <br/>             PropertyDescriptor descriptor = BeanUtils.<em class="mn">getPropertyDescriptor</em>(target.getClass(), field.getName());<br/>             jsonGenerator.writeObjectField(field.getName(), descriptor.getReadMethod().invoke(target));<br/>        }<br/><br/>    }<br/><br/>    jsonGenerator.writeEndObject();<br/>}</span></pre><p id="c1cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始用<em class="mn">JSON generator . write startobject()，</em>序列化我们的对象后，我们得到被序列化的对象的类，并遍历它的字段。以我们的汽车为例，我们正在迭代制造商、型号和位置。</p><p id="0bb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以获得每个字段的所有注释的数组:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="ef58" class="kl km iq lo b gy ls lt l lu lv">Annotation[] annotations = field.getAnnotations();</span></pre><p id="7557" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看我们的序列化器中是否有合适的方法来处理这种注释:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="1304" class="kl km iq lo b gy ls lt l lu lv">Optional&lt;Method&gt; advisingMethod = Arrays.<em class="mn">stream</em>(annotations) <br/>        .filter(annotation -&gt; serializationMap.containsKey(annotation.annotationType())) <br/>        .map(annotation -&gt; serializationMap.get(annotation.annotationType())) <br/>        .findFirst();</span></pre><p id="15c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们碰巧找到了一个，我们就将该字段的序列化委托给它，否则我们就使用一个<a class="ae mx" href="https://docs.oracle.com/javase/7/docs/api/java/beans/PropertyDescriptor.html" rel="noopener ugc nofollow" target="_blank"> PropertyDescriptor </a>让业务照常进行。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="75d5" class="kl km iq lo b gy ls lt l lu lv">if (advisingMethod.isPresent()) {<br/>       <br/>     advisingMethod.get().invoke(this, target, field, jsonGenerator);</span><span id="4f6f" class="kl km iq lo b gy mo lt l lu lv">} else { <br/>       <br/>     PropertyDescriptor descriptor =<br/>BeanUtils.<em class="mn">getPropertyDescriptor</em>(target.getClass(), field.getName());<br/>       <br/>     jsonGenerator.writeObjectField(field.getName(), descriptor.getReadMethod().invoke(target));</span><span id="eb33" class="kl km iq lo b gy mo lt l lu lv">}</span></pre><h2 id="a040" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">建议方法</h2><p id="ffaf" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">既然我们的自定义序列化程序已经启动并运行，我们所要做的就是引入用@ SerializerAdvice注释的方法，这些方法将告知如何处理每个字段。因此，让我们为每个自定义注释创建一个。</p><p id="fe87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">@ Named和@ Identified的方法非常简单。我们只需获取字段的值，将它们转换成我们期望的对象类型(NamedResource和IdentifiedResource ),然后只提取我们想要的值(name和id)。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="01df" class="kl km iq lo b gy ls lt l lu lv">@SerializerAdvice(Named.class)<br/>public void nameField(Object target, Field field, JsonGenerator jsonGenerator) throws Exception {<br/>    PropertyDescriptor descriptor = BeanUtils.<em class="mn">getPropertyDescriptor</em>(target.getClass(), field.getName());<br/>    Object fieldValue = descriptor.getReadMethod().invoke(target);<br/>    String name = ((NamedResource) fieldValue).getName();<br/>    jsonGenerator.writeObjectField(field.getName(), name);<br/>}<br/><br/>@SerializerAdvice(Identified.class)<br/>public void identifyField(Object target, Field field, JsonGenerator jsonGenerator) throws Exception {<br/>    PropertyDescriptor descriptor = BeanUtils.<em class="mn">getPropertyDescriptor</em>(target.getClass(), field.getName());<br/>    Object fieldValue = descriptor.getReadMethod().invoke(target);<br/>    String name = ((IdentifiedResource) fieldValue).getId();<br/>    jsonGenerator.writeObjectField(field.getName(), name);<br/>}</span></pre><p id="2362" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">@ ServiceDependent字段的建议更复杂，需要一个ApplicationContext bean，因为我们希望访问我们的服务bean之一来完成工作:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="f47c" class="kl km iq lo b gy ls lt l lu lv">@Autowired<br/>private ApplicationContext context;</span><span id="ea94" class="kl km iq lo b gy mo lt l lu lv">@SerializerAdvice(ServiceDependent.class)<br/>public void getFromService(Object target, Field field, JsonGenerator jsonGenerator) throws Exception {<br/>    ServiceDependent annotation = field.getAnnotation(ServiceDependent.class);<br/>    Class serviceBeanClass = annotation.service();<br/>    String methodName = annotation.method();<br/>    Object service = context.getBean(serviceBeanClass);<br/>    Method method = service.getClass().getMethod(methodName, target.getClass());<br/>    Object serviceMethodInvokeResult = method.invoke(service, target);<br/>    jsonGenerator.writeObjectField(field.getName(), serviceMethodInvokeResult);<br/><br/>}</span></pre><p id="f876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在服务类中有许多可能的方法来找到正确的方法，最终您可以选择这样的函数应该是什么样子。在我的例子中，我希望它们将当前正在序列化的类的对象作为参数，并返回与正在序列化的字段类型相同的对象:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="2ebe" class="kl km iq lo b gy ls lt l lu lv">@Service<br/>public class MyService {<br/>    <br/>    public Position getCarPosition(Car car) {<br/>        Position position = new Position();<br/>        // Do your stuff<br/>        return position;<br/>    }<br/><br/>}</span></pre><h2 id="3802" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">我们来试试吧！</h2><p id="9579" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我写了一个简单的控制器，它给我一个完全不存在的汽车实例。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="f337" class="kl km iq lo b gy ls lt l lu lv">@RestController<br/>public class MyController {</span><span id="0b84" class="kl km iq lo b gy mo lt l lu lv">    @GetMapping(value = "/car")<br/>    public ResponseEntity&lt;Car&gt; getMeMyCar() {<br/>        Manufacturer manufacturer = new Manufacturer();<br/>        manufacturer.setId("koyota-identifier");<br/>        manufacturer.setName("Koyota");<br/>        Model model = new Model();<br/>        model.setId("torolla-identifier");<br/>        model.setName("Torolla");<br/>        Car car = new Car();<br/>        car.setId("car-identifier");<br/>        car.setManufacturer(manufacturer);<br/>        car.setModel(model);<br/>        return ResponseEntity.<em class="mn">ok</em>(car);<br/>    }</span><span id="3914" class="kl km iq lo b gy mo lt l lu lv">}</span></pre><p id="a466" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及一个使用Spring的MockMvc获取资源并检查字段是否按预期序列化的测试。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="f2a2" class="kl km iq lo b gy ls lt l lu lv">@Test<br/>void testCarSerialization() throws Exception {<br/>    this.mockMvc.perform(<em class="mn">get</em>("/car"))<br/>            .andExpect(<em class="mn">jsonPath</em>("$.manufacturer")<br/>                  .value("Koyota"))<br/>            .andExpect(<em class="mn">jsonPath</em>("$.model")<br/>                  .value("torolla-identifier"))<br/>            .andExpect(<em class="mn">jsonPath</em>("$.position.latitude")<br/>                  .value(0.0))<br/>            .andExpect(<em class="mn">jsonPath</em>("$.position.longitude")<br/>                  .value(0.0));<br/>}</span></pre><h1 id="2308" class="lw km iq bd kn lx ly lz kq ma mb mc kt md me mf kw mg mh mi kz mj mk ml lc mm bi translated">有用！</h1><p id="6881" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">这是我们的系列车:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="ea52" class="kl km iq lo b gy ls lt l lu lv">{<br/>    "model": "torolla-identifier",<br/>    "manufacturer": "Koyota",<br/>    "position": {<br/>        "latitude": 0.0,<br/>        "longitude":0.0<br/>    }<br/>}</span></pre><p id="6dbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是添加定制注释的一种简单而实用的方法，以便为您的服务提供一种更加结构化的序列化资源的方式。你可以在这里找到完整的代码。我希望你喜欢它！</p></div></div>    
</body>
</html>