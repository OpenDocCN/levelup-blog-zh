# 自动内存重新分配简介

> 原文：<https://levelup.gitconnected.com/intro-to-automatic-memory-re-allocation-9109cea3ca1b>

![](img/934fd23289dcbf6ad7815c96b394fc4e.png)

在 [Unsplash](https://unsplash.com/s/photos/brain?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上由[halance](https://unsplash.com/@halacious?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)拍摄的照片

大多数编程语言都有类似的内存管理过程。首先，必须为存储分配内存。然后，您可以在分配的内存中读写数据。一旦您处理完该已分配内存上的数据，就需要释放该内存，以便可以重新分配它来存储更多数据。在大多数高级语言中，比如 Java、Swift 或 JavaScript，内存的分配和释放是自动完成的。这非常好，因为它避免了您必须手动重新分配内存中不再使用的所有内容。也就是说，对于释放内存，没有一个完美的万能解决方案。不仅如此，随着内存的自动释放，重新分配的内存必须自动确定。找出你的哪些数据不再使用当然不是一件容易的事情。实现这一点的两种主要方式是跟踪垃圾收集(通常简称为垃圾收集)和自动引用计数，或 ARC。

跟踪垃圾收集的工作原理是保存一个根对象列表。基于你的语言，这些将是你存储在全局变量中的对象，你在主过程中的局部变量，等等。程序中当前使用的任何对象都将与这些根对象有某种联系或引用。垃圾收集所做的是定期扫描你的代码库，寻找那些不再与你的根对象有任何联系的对象。如果一个对象没有连接到根，它一定不再被使用。如果不再被使用，对象就可以删除了，内存也将被释放。

自动引用计数根据引用原理工作。如果一个对象没有被任何其他对象引用，并且该对象本身也没有引用任何其他对象，则可以安全删除。这是通过引用计数器来处理的。当任何对象被实例化时，都是通过引用计数器来完成的。每当一个新的变量或引用被赋给对象时，引用计数器就递增。同样，每当变量被移除或被设置为 nil/null 值时，引用计数器就递减。如果一个对象的引用计数器达到零，它就被标记为可以安全删除。

那么，为什么我们需要两种不同的方法来删除数据和重新分配内存呢？嗯，每种方法都有它的缺点。

圆弧的一个大问题是循环引用。假设您有一个名为 A 的对象，而对象 A 引用了另一个名为 B 的对象。如果您遇到 A 或 B 都不再被使用的情况，您会希望将它们删除。但是因为它们都相互引用，所以都不会被标记为删除。它们只会继续占用可以用于其他事情的空间。这个问题有一个解决方案，但是它确实给你的代码增加了另一层复杂性。一些语言允许你实现弱引用。弱引用不会增加引用计数器，因此不会阻止对象基于引用被删除。为了防止对象包含对无效(已删除)对象的引用，这些语言会在删除时将弱引用设置为零值。这种策略经常用在父母/孩子关系中，父母对孩子有强引用，而孩子对父母有弱引用。这样，如果父对象不再使用，它仍然可以被删除，从而将任何弱子引用设置为 nil，这也将被删除。您通常不希望反过来这样做，因为删除子元素不太可能表示您也完成了父元素。

跟踪垃圾收集也有其自身的缺陷。主要是运行一次代码扫描所花费的时间，以及算法这样做所占用的空间。经过一段时间后，或者如果内存开始变少，将会对代码进行一次扫描。为此，必须分析所有可从根对象访问的代码。之后，必须检查每个分配了内存的对象。如果在内存中发现任何不能从根对象访问的对象，那么它们将被删除。这样做的问题是它占用的内存。如果你的用户正在做一些事情，这可能会导致他们经历延迟，或者明显的停顿。这是因为运行这些标记-清除算法需要 RAM。

虽然 ARC 没有这些偶然的、有时是剧烈的性能损失，但它自己也会遇到性能问题。损失通常会更加分散。这是因为引用计数器必须不断地被创建、递增和递减。

这就是为什么我们有不止一个自动内存管理的解决方案。每一种都有自己的优点和缺点。如果您要创建自己的高级语言，在决定哪种内存管理系统最适合您的个人需求时，肯定要考虑更多的事情。但是了解它们的基本功能，以及无论使用哪种系统都会带来的风险，是理解您所使用的语言的重要部分。