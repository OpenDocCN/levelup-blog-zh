<html>
<head>
<title>An Object Oriented Approach To Train an Image Classifier with Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用张量流训练图像分类器的面向对象方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-object-oriented-approach-to-training-an-image-classifier-with-tensorflow-3bcaa7a7864e?source=collection_archive---------1-----------------------#2022-03-06">https://levelup.gitconnected.com/an-object-oriented-approach-to-training-an-image-classifier-with-tensorflow-3bcaa7a7864e?source=collection_archive---------1-----------------------#2022-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="257b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是博客系列的第一部分，将涵盖Tensorflow模型训练、Tensorflow服务及其性能。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ec12da251d52229f765dfdb359d9cf17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R7Wg5qJp2GZySXq348_EqQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片来自<a class="ae lb" href="https://www.linkedin.com/in/emre-sar%C4%B1g%C3%BCl-7064aa92/" rel="noopener ugc nofollow" target="_blank">Emre sargül</a></figcaption></figure><p id="cd9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在这里找到博客系列的完整应用程序代码:</p><div class="lc ld gp gr le lf"><a href="https://github.com/erdememekligil/oop-tensorflow-serving" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">GitHub-erdememekligil/oop-tensor flow-serving:一种面向对象(OOP)的方法来训练…</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">一种面向对象(OOP)的方法，用于训练张量流模型并使用张量流服务为其提供服务。OOP很好(在…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">github.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt kv lf"/></div></div></a></div></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="e862" class="mb mc iq bd md me mf dn mg mh mi dp mj jy mk ml mm kc mn mo mp kg mq mr ms mt bi translated">为什么要为OOP烦恼呢？</h2><ul class=""><li id="b354" class="mu mv iq jp b jq mw ju mx jy my kc mz kg na kk nb nc nd ne bi translated">自定义函数可以添加到模型中。例如，自定义函数进行预测并返回最可能的类标签而不是概率。除了创建新函数，现有的Keras函数如<code class="fe nf ng nh ni b">call</code>可以被覆盖以改变它们的功能。</li><li id="e9d3" class="mu mv iq jp b jq nj ju nk jy nl kc nm kg nn kk nb nc nd ne bi translated">覆盖Keras函数使模型与其他类或函数兼容。例如，通过覆盖<code class="fe nf ng nh ni b">save</code>方法来添加<em class="no">签名</em>(可以由Tensorflow服务调用的方法)使其与ModelCheckpoint兼容。由于ModelCheckpoint调用被覆盖的<code class="fe nf ng nh ni b">save</code>方法来保存模型，由它保存的模型将具有额外的签名。</li><li id="35ce" class="mu mv iq jp b jq nj ju nk jy nl kc nm kg nn kk nb nc nd ne bi translated">一些与架构无关的需求可以在基类中得到满足，不同的模型架构可以在该基类的子类中定义。</li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="9fa3" class="mb mc iq bd md me mf dn mg mh mi dp mj jy mk ml mm kc mn mo mp kg mq mr ms mt bi translated">扩展tf.keras.Model</h2><p id="cd68" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy np ka kb kc nq ke kf kg nr ki kj kk ij bi translated">在这个应用程序中，我们希望有一个可以直接处理图像字节的模型，因为在生产环境中，图像通常是PNG或JPG格式。我们定义了一个基类ImageClassifierModel，用于对图像分类器的常见需求和功能进行分组:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="84f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建了一个函数，它以字节而不是numpy或张量数组的形式接收图像。我们还定义了一个函数来处理数组，比如默认的<code class="fe nf ng nh ni b">call</code>方法:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c657" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些方法是<em class="no"> tf.functions </em>，它们在tf.keras.Model的被覆盖的<code class="fe nf ng nh ni b">save</code>方法中被设置为模型的签名:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5299" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nf ng nh ni b">save</code>方法将模型以<code class="fe nf ng nh ni b">SavedModel</code>格式写入磁盘。这些签名定义可以由Tensorflow作为gRPC或REST服务来提供。此外，甚至在从磁盘加载模型之后，也可以调用tf.functions，如下所示:</p><pre class="km kn ko kp gt nu ni nv nw aw nx bi"><span id="08b6" class="mb mc iq ni b gy ny nz l oa ob">model.predict_bytes_image(png_bytes)</span></pre><p id="5fc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LenetModel和ResnetModel是ImageClassifierModel的两个子类，它们实现抽象的<code class="fe nf ng nh ni b">create_model_io</code>方法来定义模型架构。ResnetModel是预训练的ResNet50V2的包装器，它有助于微调:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9a30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LenetModel是一个简单得多的类，它实现了LeNet架构:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个模型都有预处理层，可以进行重新缩放等操作。操作，它们不需要预先处理数据。这使得用户(客户)在生产环境中调用这些模型时更容易使用。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="0597" class="mb mc iq bd md me mf dn mg mh mi dp mj jy mk ml mm kc mn mo mp kg mq mr ms mt bi translated">培养</h2><p id="e34b" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy np ka kb kc nq ke kf kg nr ki kj kk ij bi translated">为了用任何数据集训练任何ImageClassifierModel(它的子类),我们定义了<code class="fe nf ng nh ni b">train</code>函数。该函数训练模型，直到它在最后5个时期中没有获得任何更高的验证准确性。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="989a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用<code class="fe nf ng nh ni b">tf.keras.preprocessing.image_dataset_from_directory</code>函数创建训练和验证DatasetV2对象，并使用上面的函数。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="10a3" class="mb mc iq bd md me mf dn mg mh mi dp mj jy mk ml mm kc mn mo mp kg mq mr ms mt bi translated">结论</h2><p id="4854" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy np ka kb kc nq ke kf kg nr ki kj kk ij bi translated">通过扩展<code class="fe nf ng nh ni b">tf.keras.Model</code>,我们创建了与其他Keras函数更加兼容的模型。为了训练其他架构，可以创建一个扩展<code class="fe nf ng nh ni b">ImageClassifierModel</code>的模型类，并且在不改变其余代码的情况下很容易训练它。这个经过训练的模型将准备好接受Tensorflow提供的服务，以及我们定义的附加签名。</p><p id="6357" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请查看GitHub <a class="ae lb" href="https://github.com/erdememekligil/oop-tensorflow-serving" rel="noopener ugc nofollow" target="_blank">库</a>以获得完整的代码和更详细的训练评估部分。欢迎在评论中提问。</p></div></div>    
</body>
</html>