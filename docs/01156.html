<html>
<head>
<title>React Component’s Lifecycle Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应组件的生命周期方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-lifecycle-2c63aee11c09?source=collection_archive---------3-----------------------#2019-11-19">https://levelup.gitconnected.com/react-lifecycle-2c63aee11c09?source=collection_archive---------3-----------------------#2019-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3f8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我之前的<a class="ae kl" href="https://medium.com/@__jay__singh__/everything-about-react-10512639a01e" rel="noopener">帖子</a>中，我们只讨论了React组件生命周期的基础。在这篇文章中，我将详细解释React组件以及组件的生命周期和阶段。<strong class="jp ir">这些生命周期方法在React v16.4+ </strong>之后可用</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/390f14933f7e2d243a0fab3b8f765c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nleLui-x8YNJhZaEwwLioQ.png"/></div></div></figure><p id="c2e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React中的组件有一个生命周期，允许您在它经历三个主要阶段时执行功能:</p><ul class=""><li id="34d0" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated"><strong class="jp ir">安装</strong></li><li id="19fe" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated"><strong class="jp ir">更新</strong></li><li id="5cb2" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated"><strong class="jp ir">卸载</strong></li></ul><h1 id="0210" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">安装</strong></h1><p id="2cf6" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在挂载阶段，状态被初始化，元素被添加到DOM中。React有四种内置方法来处理组件安装:</p><ol class=""><li id="ffaf" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk mp le lf lg bi translated"><a class="ae kl" href="#ce6c" rel="noopener ugc nofollow">建造师</a></li><li id="67f2" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk mp le lf lg bi translated"><a class="ae kl" href="#b1e6" rel="noopener ugc nofollow">getDerivedStateFromProps</a></li><li id="5833" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk mp le lf lg bi translated"><a class="ae kl" href="#b04c" rel="noopener ugc nofollow">渲染</a></li><li id="2c85" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk mp le lf lg bi translated"><a class="ae kl" href="#b017" rel="noopener ugc nofollow">组件安装</a></li></ol><h2 id="ce6c" class="mq ln iq bd lo mr ms dn ls mt mu dp lw jy mv mw ma kc mx my me kg mz na mi nb bi translated">构造器</h2><p id="536b" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">调用<code class="fe nc nd ne nf b">constructor(props)</code>方法时将<code class="fe nc nd ne nf b">props</code>作为参数，您应该总是在调用其他任何方法之前先调用<code class="fe nc nd ne nf b">super(props)</code>。这将启动父组件的构造方法，并允许组件从其父组件继承方法(<code class="fe nc nd ne nf b">React.Component</code>)。</p><p id="814f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你没有初始化状态，也没有绑定方法，你不需要为你的React组件实现一个构造函数。 </p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nh"><img src="../Images/0a6fb2e660d38c050230d4a23feda74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1HjXd7XjERc6izdf8R98hQ.png"/></div></div></figure><h2 id="b1e6" class="mq ln iq bd lo mr ms dn ls mt mu dp lw jy mv mw ma kc mx my me kg mz na mi nb bi translated">getDerivedStateFromProps</h2><p id="892d" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">这个方法在调用render方法之前被调用，无论是在初始挂载时还是在后续更新时。它应该返回一个对象来更新状态，或者返回null来不更新任何东西。</p><p id="6f65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子以最喜欢的水果“苹果”开始，但是<code class="fe nc nd ne nf b">getDerivedStateFromProps()</code>方法基于<code class="fe nc nd ne nf b">favfruit</code>属性更新最喜欢的水果:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ni"><img src="../Images/adf161bd34223743eb6945e507fc0395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4wi46RmJKyz7Be2OvL9Gw.png"/></div></div></figure><h2 id="b04c" class="mq ln iq bd lo mr ms dn ls mt mu dp lw jy mv mw ma kc mx my me kg mz na mi nb bi translated">提供；给予</h2><p id="88cb" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">这是每个组件都需要的方法。每当<code class="fe nc nd ne nf b">state</code>或<code class="fe nc nd ne nf b">props</code> <em class="ng"> </em>改变<em class="ng">，</em>时，该方法被调用，并且它必须用新的改变将HTML重新呈现到DOM。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nj"><img src="../Images/28819e90fd69f953998ac23ad4c13b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqCb_w7s9puZLQe2md5rWA.png"/></div></div></figure><h2 id="b017" class="mq ln iq bd lo mr ms dn ls mt mu dp lw jy mv mw ma kc mx my me kg mz na mi nb bi translated">组件安装</h2><p id="2edd" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><code class="fe nc nd ne nf b">componentDidMount()</code>组件安装(插入到树中)后立即调用。需要DOM节点的初始化应该放在这里。如果需要从远程端点加载数据，这是实例化API请求的好地方。</p><p id="dc47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ng">举例——起初我最喜欢的水果是“苹果”，但1秒钟后</em> <code class="fe nc nd ne nf b"><em class="ng">setTimeout</em></code> <em class="ng">，它被“芒果”</em> <strong class="jp ir"> <em class="ng"> </em> </strong> <em class="ng">代替:</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nk"><img src="../Images/f4e0206daaf12820b88b42d8fc65486b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7h3a4pKrgvnsxJm6BKHfA.png"/></div></div></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="0b08" class="lm ln iq bd lo lp ns lr ls lt nt lv lw lx nu lz ma mb nv md me mf nw mh mi mj bi translated"><strong class="ak">更新</strong></h1><p id="7a07" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">每当组件的<code class="fe nc nd ne nf b">state</code>或<code class="fe nc nd ne nf b">props</code>发生变化时，组件就会更新。React有五个内置方法，当组件更新时，按以下顺序调用:</p><ol class=""><li id="e459" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk mp le lf lg bi translated"><a class="ae kl" href="#9500" rel="noopener ugc nofollow">getDerivedStateFromProps</a></li><li id="c5da" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk mp le lf lg bi translated"><a class="ae kl" href="#278b" rel="noopener ugc nofollow"> shouldComponentUpdate </a></li><li id="af19" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk mp le lf lg bi translated"><a class="ae kl" href="#b04c" rel="noopener ugc nofollow">渲染</a></li><li id="1ac6" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk mp le lf lg bi translated"><a class="ae kl" href="#7268" rel="noopener ugc nofollow">getsnapshot before update</a></li><li id="f538" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk mp le lf lg bi translated"><a class="ae kl" href="#050c" rel="noopener ugc nofollow">组件更新</a></li></ol><h2 id="9500" class="mq ln iq bd lo mr ms dn ls mt mu dp lw jy mv mw ma kc mx my me kg mz na mi nb bi translated">getDerivedStateFromProps</h2><p id="2ba8" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在更新过程中，会调用<code class="fe nc nd ne nf b"><a class="ae kl" href="#9500" rel="noopener ugc nofollow">getDerivedStateFromProps</a></code>方法。</p><p id="4c55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子有一个按钮，它把最喜欢的水果变成蓝色，但是由于调用了<code class="fe nc nd ne nf b">getDerivedStateFromProps()</code>方法，它用来自<code class="fe nc nd ne nf b">favfruit</code>属性的水果更新状态。最喜欢的水果仍然呈现为黄色:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nx"><img src="../Images/7dd2824feb85518ad7b192399a7b4e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0Q-Kf64jWw8fNoVvbLr2g.png"/></div></div></figure><h2 id="278b" class="mq ln iq bd lo mr ms dn ls mt mu dp lw jy mv mw ma kc mx my me kg mz na mi nb bi translated">shouldComponentUpdate</h2><p id="c9b0" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在<code class="fe nc nd ne nf b">shouldComponentUpdate()</code>方法中，您可以返回一个布尔值，指定React是否应该继续渲染。在<code class="fe nc nd ne nf b">PureComponent</code>中，默认情况下使用<code class="fe nc nd ne nf b">state</code>和<code class="fe nc nd ne nf b">props</code>与它们之前的值的浅层比较来处理<code class="fe nc nd ne nf b">shouldComponentUpdate()</code>方法。</p><p id="1eb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子显示了当<code class="fe nc nd ne nf b">shouldComponentUpdate()</code>方法返回<code class="fe nc nd ne nf b">false</code>时会发生什么。它阻止组件在更新阶段重新呈现。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ny"><img src="../Images/f8f3740d4bb0f7741cbc90bed45ccebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALhDYPo-pMOsUqsy-QUNeg.png"/></div></div></figure><p id="86b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将运行与上面相同的例子，但是这次<code class="fe nc nd ne nf b">shouldComponentUpdate()</code>方法返回<code class="fe nc nd ne nf b">true</code>。它不会阻止组件在每次更新时进行渲染。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nz"><img src="../Images/df52cb971ec790983c163d98f63e8d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mi4VK8RfDs7mWJkruN-QIA.png"/></div></div></figure><h2 id="7268" class="mq ln iq bd lo mr ms dn ls mt mu dp lw jy mv mw ma kc mx my me kg mz na mi nb bi translated">getSnapshotBeforeUpdate</h2><p id="97c5" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><code class="fe nc nd ne nf b">getSnapshotBeforeUpdate()</code>在最近渲染的输出提交到DOM之前被调用。它使您的组件能够在DOM发生潜在变化之前捕获一些信息(例如滚动位置)。该生命周期返回的任何值都将作为参数传递给<code class="fe nc nd ne nf b">componentDidUpdate()</code>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oa"><img src="../Images/e7c66630e661c70fd13fa6141e863c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJvrCJHRv8Pop8j3akfvEw.png"/></div></div></figure><p id="b416" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上例中，组件在<em class="ng">挂载</em>时，渲染的是喜欢的水果“苹果”。当组件已经挂载完毕，一个定时器改变状态，一秒钟后，喜欢的水果就变成了“芒果”。这个动作触发了<em class="ng">更新</em>阶段，由于这个组件有一个<code class="fe nc nd ne nf b">getSnapshotBeforeUpdate()</code>方法，这个方法被执行并返回字符串。然后执行<code class="fe nc nd ne nf b">componentDidUpdate()</code>方法，并在空的<code class="fe nc nd ne nf b">div1</code>元素中写入一条消息。</p><h2 id="050c" class="mq ln iq bd lo mr ms dn ls mt mu dp lw jy mv mw ma kc mx my me kg mz na mi nb bi translated">componentDidUpdate</h2><p id="7112" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><code class="fe nc nd ne nf b">componentDidUpdate()</code>在更新发生后立即被调用。初始呈现时不调用此方法。您可以在<code class="fe nc nd ne nf b">componentDidUpdate()</code>立即给<code class="fe nc nd ne nf b">setState()</code>打电话。通常在<code class="fe nc nd ne nf b">componentDidUpdate</code>中，你将逻辑包装在一个条件中，这样你就不会在每次<code class="fe nc nd ne nf b">state</code>或<code class="fe nc nd ne nf b">props</code>改变时执行它。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ob"><img src="../Images/cd3c8bad52a9c3e1eac8c4cea7850059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEAsccoTBzIadFmVHPdtEw.png"/></div></div></figure><p id="2fd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，当组件被<em class="ng">挂载</em>时，它被渲染成最喜欢的水果“苹果”。当组件已经挂载<em class="ng">，</em>一个定时器改变状态，一秒钟后，喜欢的水果变成了“芒果”。这个动作触发了<em class="ng">更新</em>阶段，然后<code class="fe nc nd ne nf b">componentDidUpdate()</code>方法被执行并在空的<code class="fe nc nd ne nf b">div1</code>元素中写入一条消息。</p><h1 id="4866" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">卸载</strong></h1><p id="8d84" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">生命周期的下一个阶段是当一个组件从DOM中移除，或者<em class="ng">卸载</em>，正如它在React中被命名的那样。React只有一个内置的方法，当组件被卸载时会调用这个方法。</p><h2 id="254d" class="mq ln iq bd lo mr ms dn ls mt mu dp lw jy mv mw ma kc mx my me kg mz na mi nb bi translated"><strong class="ak">组件将卸载</strong></h2><p id="f5a7" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><code class="fe nc nd ne nf b">componentWillUnmount()</code>在组件被卸载和销毁之前立即被调用。在该方法中执行任何必要的清理，例如使计时器失效、取消网络请求或清理在<code class="fe nc nd ne nf b">componentDidMount()</code>中创建的任何订阅。</p><p id="0a81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你<strong class="jp ir">不应该调用<code class="fe nc nd ne nf b">componentWillUnmount()</code>中的</strong> <code class="fe nc nd ne nf b"><strong class="jp ir">setState()</strong></code>，因为组件永远不会被重新渲染。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oc"><img src="../Images/4a8f7ca8ef4647b26146634cdcb56f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AyTsBmYPIwQRF0rqYr8xbQ.png"/></div></div></figure><p id="6ff4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的例子有内存泄漏，因为即使组件被卸载，<code class="fe nc nd ne nf b">setInterval</code>也将继续运行。我们需要清理一下。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi od"><img src="../Images/c7887c5c48968e9b05f711f50a09c6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEDDFE7j4L5fbahtlvGXrg.png"/></div></div></figure><p id="321b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的例子在组件卸载时停止interval函数，因为我们在<code class="fe nc nd ne nf b">componentWillUnmount</code>函数中调用了<code class="fe nc nd ne nf b">clearInterval</code>，删除了计时器。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="bda0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇文章能帮助你学习React组件生命周期。</p></div></div>    
</body>
</html>