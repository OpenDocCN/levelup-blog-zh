<html>
<head>
<title>AppSync Lambda Authorizers Via New Amplify Custom Resources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AppSync Lambda授权器通过新的Amplify定制资源</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/appsync-lambda-authorizers-via-new-amplify-custom-resources-5a32f41a6332?source=collection_archive---------0-----------------------#2021-11-20">https://levelup.gitconnected.com/appsync-lambda-authorizers-via-new-amplify-custom-resources-5a32f41a6332?source=collection_archive---------0-----------------------#2021-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="a2e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://aws.amazon.com/amplify/" rel="noopener ugc nofollow" target="_blank"> Amplify </a>和<a class="ae ks" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank"> AppSync </a>允许客户在几分钟内使用完全托管的GraphQL API端点，并优雅地处理授权。本文展示了如何利用最近新引入的<a class="ae ks" href="https://docs.amplify.aws/cli/custom/cdk/" rel="noopener ugc nofollow" target="_blank"> AWS定制资源</a>通过CDK添加新的<a class="ae ks" href="https://aws.amazon.com/about-aws/whats-new/2021/07/aws-appsync-supports-custom-authorization-with-aws-lambda-graphsql-apis/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>授权模式。我们将把这个端点与一个非常简单的React web应用程序集成起来。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/64bf9b900be60557b12d3e3c7becaca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8wJfgMbeIaItSJM_uMzhg.png"/></div></div></figure><h1 id="1b74" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">有趣的事实</h1><p id="79ec" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">本文的第一个版本基于通过CDK在自己的文件夹/项目中独立提供所需的AWS资源。然而，在<a class="ae ks" href="https://aws.amazon.com/developer/community/community-builders/" rel="noopener ugc nofollow" target="_blank">AWS Community Builders</a>Slack频道，我了解到<a class="ae ks" href="https://docs.amplify.aws/cli/custom/cdk/#reference-amplify-environment-name" rel="noopener ugc nofollow" target="_blank">AWS Amplify团队正在发布一个相关的特性</a>，这让我重温了这篇文章，其中的实现略有不同，但更加简洁。这综合了节目的精彩之处。在GitHub中可以找到之前的<a class="ae ks" href="https://github.com/aladevlearning/appsync-lambda-authorizers/tree/before-custom-resources" rel="noopener ugc nofollow" target="_blank">和</a>之后的<a class="ae ks" href="https://github.com/aladevlearning/appsync-lambda-authorizers/tree/after-custom-resources" rel="noopener ugc nofollow" target="_blank">自定义资源实现。</a></p><h1 id="e2d4" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加自定义资源</h1><p id="1e8b" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">有了最新的Amplify，你可以通过定义CDK堆栈来添加自定义资源。在此之前，典型的方法是将你的CDK分离到你的项目中的<em class="mi"> cdk </em>或<em class="mi"> infra </em>文件夹中。现在你可以在Amplify后端拥有它。发出以下命令:</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="a0e6" class="mo lg iq mk b gy mp mq l mr ms">npm i -g @aws-amplify/cli<br/>amplify add custom</span></pre><p id="7b96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">目前，您可以通过<em class="mi"> CDK </em>或<em class="mi">云信息</em>模板来定义自定义资源，我们将选择第一个选项，并为自定义资源提供一个名称，例如<em class="mi">lambdaAuthorizerCustomResource</em>。这将在<em class="mi">amplify/back end/custom/&lt;custom-resource-name&gt;</em>路径下生成一个骨架CDK堆栈。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/b0686f20dc02df7cc2bd85a861c0e07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*WM50WFpUMqOsI11bYsVs6Q.png"/></div></figure><p id="cb4d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们修改预先生成的<em class="mi"> cdk-stack.ts文件</em>并创建一个<em class="mi"> cdk.ts，</em>之前，让我们在下一节看看cdk堆栈的内容。</p><h1 id="3eb3" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">通过CDK提供GraphQL</h1><p id="e9c0" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">作为<a class="ae ks" href="https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/infrastructure-as-code.html" rel="noopener ugc nofollow" target="_blank">基础设施作为代码</a>原则的忠实粉丝，我决定通过使用AWS CDK为Typescript语言创建GraphQL端点。本质上，CDK以一种编程的方式抽象云形成栈。下面的堆栈将提供:</p><ul class=""><li id="e1b5" class="mu mv iq jw b jx jy kb kc kf mw kj mx kn my kr mz na nb nc bi translated">基于定义模型和Lambda授权器配置的<a class="ae ks" href="https://github.com/aladevlearning/appsync-lambda-authorizers/blob/main/cdk/graphql/schema.graphql" rel="noopener ugc nofollow" target="_blank"> <em class="mi"> schema.graphql </em> </a>的AppSync GraphQL端点。</li><li id="13b6" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr mz na nb nc bi translated">一个<em class="mi">授权者</em> Lambda函数及其必要的IAM策略。</li><li id="2f50" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr mz na nb nc bi translated">一个与业务相关的<em class="mi">支付</em> Lambda函数，包含通过其<a class="ae ks" href="https://graphql.org/learn/execution/" rel="noopener ugc nofollow" target="_blank"> GraphQL解析器</a>对已定义模型(此处为<em class="mi">支付</em>模型)的CRUD操作。这个Lambda作为<a class="ae ks" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appsync-datasource.html" rel="noopener ugc nofollow" target="_blank">数据源被附加到AppSync </a>。</li><li id="7a9e" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr mz na nb nc bi translated">持久化模型的DynamoDB表。</li></ul><p id="5d1a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">输出GraphQL端点的完整代码，可以在这里找到<a class="ae ks" href="https://github.com/aladevlearning/appsync-lambda-authorizers/blob/after-custom-resources/authorizer-app/client/amplify/backend/custom/lambdaAuthorizerCustomResource/cdk-stack.ts" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6a33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">需要注意的是，现在您可以使用Amplify项目元数据，如<strong class="jw ir"> <em class="mi">项目</em> </strong>和<strong class="jw ir"> <em class="mi">环境</em> </strong>名称，在运行时定义您的资源。</p><p id="d799" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在撰写本文时，我必须创建一个<em class="mi"> cdk.ts </em>文件，以便初始化堆栈并将其与应用程序相关联:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2dbc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，让我们构建和部署变更:</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="720a" class="mo lg iq mk b gy mp mq l mr ms">amplify build<br/>cdk deploy --app "npx ts-node cdk.ts" --parameters env=dev</span></pre><p id="7879" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以上步骤可以在AWS控制台手动执行，但步骤较多，容易出错。下面我们展示了CDK的视觉输出:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nk"><img src="../Images/9af7823411205f17b6ad238d7c759378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SbWdB8ooe3YRocDetuPbcw.gif"/></div></div></figure><h1 id="20e0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">兰姆达斯上的镜头</h1><p id="e3ee" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">我们提供了两个Lambda函数:一个“<em class="mi">粘合</em>”app sync，DynamoDB作为<em class="mi">数据源</em>，另一个执行授权检查。<strong class="jw ir">重要提示:</strong>请注意，它们的前缀是来自我们的CDK堆栈的数据:<strong class="jw ir"> authorizerappdev。</strong></p><h2 id="ea13" class="mo lg iq bd lh nl nm dn ll nn no dp lp kf np nq lt kj nr ns lx kn nt nu mb nv bi translated">数据源λ</h2><p id="28da" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated"><em class="mi">数据源</em> Lambda利用AWS SDK在DynamoDB表上执行CRUD操作。下面的片段展示了付款清单，其余的可以看看<a class="ae ks" href="https://github.com/aladevlearning/appsync-lambda-authorizers/tree/main/cdk/resources/payments" rel="noopener ugc nofollow" target="_blank"> Github回购</a>。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="fd23" class="mo lg iq bd lh nl nm dn ll nn no dp lp kf np nq lt kj nr ns lx kn nt nu mb nv bi translated">授权人λ</h2><p id="1bad" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">AppSync通过提供身份验证令牌将任何客户端请求转发到此函数。对于这个PoC，我利用RSA密钥对来验证传入的JWT令牌的有效负载及其通过之前生成的公钥的签名。这是通过使用<a class="ae ks" href="https://github.com/auth0/node-jsonwebtoken" rel="noopener ugc nofollow" target="_blank"> jsonwebtoken </a>包来完成的。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="cf7f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个阶段，我们只需要一个使用GraphQL端点的客户机，所以让我们在下一节中详细了解它。</p><h1 id="f127" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">集成放大器</h1><p id="3d92" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">在撰写本文时(2021年11月)，新的Lambda授权器尚未通过Amplify CLI提供。这意味着我们需要手动设置与AppSync的集成，尽管这非常简单。</p><p id="aa25" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设您已经在项目中配置了<a class="ae ks" href="https://docs.amplify.aws/cli/start/install/" rel="noopener ugc nofollow" target="_blank"><em class="mi"/>和<em class="mi">启动了</em> Amplify </a>，您需要做的就是手动添加这个代码片段作为Amplify <em class="mi"> configure </em>方法的一部分，通常位于您的App.js/ts文件中——如果使用React的话。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="00ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了演示JWT验证，我创建了一个非常愚蠢的<a class="ae ks" href="https://github.com/aladevlearning/appsync-lambda-authorizers/blob/main/authorizer-app/client/src/App.js" rel="noopener ugc nofollow" target="_blank"> React UI </a>。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nk"><img src="../Images/7f116bcd99873b7352589c4e35946f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Qm1WWMtV3ShqYazZV8LgvQ.gif"/></div></div></figure><p id="ef76" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过调用本地<a class="ae ks" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"><em class="mi">Fastify</em></a><em class="mi">NodeJs服务器</em>暴露<em class="mi"> generate-token </em>端点来生成JWT令牌。详情可以在这里找到<a class="ae ks" href="https://github.com/aladevlearning/appsync-lambda-authorizers/blob/after-custom-resources/authorizer-app/backend/server.js" rel="noopener ugc nofollow" target="_blank">。端点使用私钥对生成的JWT令牌进行签名，如前所述，该令牌随后将由λ授权器功能进行验证。在这种情况下，我们只是发送了一个简单的foo/bar有效载荷，但是在现实生活中肯定要复杂得多，并且遵循</a><a class="ae ks" href="https://tools.ietf.org/id/draft-spencer-oauth-claims-00.html" rel="noopener ugc nofollow" target="_blank"> Oauth声明</a>更加严格。该调用通过调用API端点并提供GraphQL查询和JWT令牌来执行。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="c859" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="411e" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">Lambda授权器是AppSync武库中的另一个武器，为大量用例以及单个和多个授权器的组合和第三方集成打开了大门。本文旨在为客户提供一个开始使用Lambda Authorizer特性的起点，并且只是展示了一个非常简单的实现，然后可以对其进行扩展以进行更进一步的改进。</p><h1 id="8ca3" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">参考</h1><div class="nw nx gp gr ny nz"><a href="https://aws.amazon.com/about-aws/whats-new/2021/07/aws-appsync-supports-custom-authorization-with-aws-lambda-graphsql-apis/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">AWS AppSync现在支持使用AWS Lambda为GraphQL APIs进行自定义授权</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">发布于:今天我们发布了一种灵活而简单的方法来实现AWS Lambda的自定义授权逻辑…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">aws.amazon.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ld nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://aws.amazon.com/blogs/mobile/building-scalable-graphql-apis-on-aws-with-cdk-and-aws-appsync/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">使用CDK、TypeScript、AWS AppSync、Amazon DynamoDB和AWS在AWS上构建可扩展的GraphQL APIs</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">2021年9月14日:亚马逊Elasticsearch服务更名为亚马逊OpenSearch服务。见详情。AWS…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">aws.amazon.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on ld nz"/></div></div></a></div></div></div>    
</body>
</html>