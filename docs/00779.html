<html>
<head>
<title>How to create a copy-on-write clone of a file in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js中创建文件的写时复制克隆</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-copy-on-write-clone-of-a-file-in-node-js-443cfa2b18d9?source=collection_archive---------2-----------------------#2019-07-26">https://levelup.gitconnected.com/how-to-create-a-copy-on-write-clone-of-a-file-in-node-js-443cfa2b18d9?source=collection_archive---------2-----------------------#2019-07-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><p id="1b9a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在过去的35年中，Linux/Unix文件系统语义的进步令人耳目一新。1984年，我在运行4.2BSD的Vax上第一次使用了符号链接，这是对多年前就存在的硬链接的重大改进。前几天，我了解到Mac OS X和Linux都支持一种新的链接，即reflink，它是某些文件系统的一种写时复制形式。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/2c5eb8d5fad6db6414c3ac6384f2f424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8wlWzilBquPJBJS8juqJpA.png"/></div></div></figure><p id="9dd6" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果你和我一样不太清楚<em class="lb">写时复制</em>的意思，让我们先来探讨一下。我依稀记得CoW被用于操作系统内存管理系统——它与共享内存段一起使用。</p><blockquote class="lc ld le"><p id="40b8" class="jr js lb jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko in bi translated">写时复制(COW或CoW)是计算机编程中使用的一种资源管理技术，用于在可修改的资源上有效地实现“复制”或“拷贝”操作。如果资源被复制但没有被修改，则没有必要创建新的资源；资源可以在副本和原件之间共享。修改仍然必须创建一个拷贝，因此采用了这种技术:拷贝操作推迟到第一次写入时进行。通过以这种方式共享资源，可以显著减少未修改副本的资源消耗，同时给资源修改操作增加少量开销。来源:</p><p id="db72" class="jr js lb jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko in bi translated"><a class="ae li" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="412b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这意味着你有一个资源，比如共享内存段，或者文件系统中的一个文件。不是复制资源，而是制作一个副本，这可能非常快。副本被设置成使得对资源的任何修改都会导致被修改的部分成为副本，并且被修改的部分就是被复制的部分。</p><p id="a023" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">也许这种解释的尝试仍然模糊不清，所以让我们尝试一些明确的例子。</p><p id="2269" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">为了在Node.js中创建一个<code class="fe lj lk ll lm b">reflink</code>克隆，使用带有特定选项的<code class="fe lj lk ll lm b">fs.copyFile</code>函数。这方面的源代码在本文的底部。为了理解这是怎么回事，我们必须先看一些背景材料。</p><p id="9278" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">创建文件的<code class="fe lj lk ll lm b">reflink</code>副本:</p><pre class="kq kr ks kt gu ln lm lo lp aw lq bi"><span id="964a" class="lr ls iu lm b gz lt lu l lv lw">$ time cp --reflink wikidatawiki-stub-articles.xml w.xml</span><span id="a341" class="lr ls iu lm b gz lx lu l lv lw">real	0m0.008s<br/>user	0m0.004s<br/>sys	0m0.000s</span><span id="ab8e" class="lr ls iu lm b gz lx lu l lv lw">$ ls -l wikidatawiki-stub-articles.xml w.xml <br/>-rw-rw-r-- 1 david david 39478588202 Jul 21 22:00 wikidatawiki-stub-articles.xml<br/>-rw-rw-r-- 1 david david 39478588202 Jul 25 22:00 w.xml</span></pre><p id="6015" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个文件有39千兆字节。这是在一个Linux机器上，带有一个启用了reflinks选项的XFS文件系统。关于设置的信息<a class="ae li" href="https://techsparx.com/linux/disks/ubuntu-xfs.html" rel="noopener ugc nofollow" target="_blank">如何在Ubuntu上格式化带有XFS文件系统和引用链接支持的驱动器</a></p><p id="84a9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在Mac OS X上，命令将改为<code class="fe lj lk ll lm b">cp -c</code>来使用<code class="fe lj lk ll lm b">clonefile</code>系统调用。</p><p id="b47b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">克隆这个39千兆字节的文件只需要几分之一秒的时间。</p><p id="47f5" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">想想看，39gb的数据在一瞬间被复制。通过多次复制这个文件，我知道一个39gb的正常文件副本需要15分钟。十五分钟对几分之一秒是一个巨大的加速。</p><p id="9edc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">因为编辑一个39gb的XML文件是不实际的，所以让我们用一个更小的文件来演示写时复制。</p><pre class="kq kr ks kt gu ln lm lo lp aw lq bi"><span id="6f27" class="lr ls iu lm b gz lt lu l lv lw">$ ls -l sample.text <br/>-rw-rw-r-- 1 david david 1393 Jul 25 22:08 sample.text</span></pre><p id="31b4" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是一个带有Lorem Ipsum文本的文件。</p><pre class="kq kr ks kt gu ln lm lo lp aw lq bi"><span id="6f8f" class="lr ls iu lm b gz lt lu l lv lw">$ cp --reflink sample.text sample-dup.text<br/>$ vi sample-dup.text </span><span id="a68c" class="lr ls iu lm b gz lx lu l lv lw">$ ls -l sample*<br/>-rw-rw-r-- 1 david david 1403 Jul 25 22:09 sample-dup.text<br/>-rw-rw-r-- 1 david david 1393 Jul 25 22:08 sample.text</span><span id="8ffb" class="lr ls iu lm b gz lx lu l lv lw">$ diff -u sample.text sample-dup.text <br/>--- sample.text	2019-07-25 22:08:43.809680598 -0700<br/>+++ sample-dup.text	2019-07-25 22:09:24.073194632 -0700<br/>@@ -3,3 +3,5 @@<br/> <br/> Etiam tempor orci eu lobortis elementum nibh tellus molestie. Neque egestas congue quisque egestas. Egestas integer eget aliquet nibh praesent tristique. Vulputate mi sit amet mauris. Sodales neque sodales ut etiam sit. Dignissim suspendisse in est ante in. Volutpat commodo sed egestas egestas. Felis donec et odio pellentesque diam. Pharetra vel turpis nunc eget lorem dolor sed viverra. Porta nibh venenatis cras sed felis eget. Aliquam ultrices sagittis orci a. Dignissim diam quis enim lobortis. Aliquet porttitor lacus luctus accumsan. Dignissim convallis aenean et tortor at risus viverra adipiscing at.<br/> <br/>+MODIFIED<br/>+</span></pre><p id="0684" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们创建了该文件的一个<code class="fe lj lk ll lm b">reflink</code>副本，然后编辑该副本。我们看到这两个文件大小不同，并且<code class="fe lj lk ll lm b">diff</code>显示了它们之间的差异。因此<code class="fe lj lk ll lm b">sample-dup.text</code>现在是<code class="fe lj lk ll lm b">sample.text</code>的副本。</p><p id="d9f8" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果这些文件被硬链接或符号链接，创建链接会很快，但是编辑文件会修改链接。</p><pre class="kq kr ks kt gu ln lm lo lp aw lq bi"><span id="7a7a" class="lr ls iu lm b gz lt lu l lv lw">$ cp sample.text sample2.text<br/>$ ln sample2.text sample2-link.text<br/>$ ls -l sample2*<br/>-rw-rw-r-- 2 david david 1393 Jul 25 22:50 sample2-link.text<br/>-rw-rw-r-- 2 david david 1393 Jul 25 22:50 sample2.text<br/>$ vi sample2-link.text <br/>$ ls -l sample2*<br/>-rw-rw-r-- 2 david david 1402 Jul 25 22:50 sample2-link.text<br/>-rw-rw-r-- 2 david david 1402 Jul 25 22:50 sample2.text<br/>$ diff -u sample2*</span></pre><p id="c691" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">为了演示显而易见的内容，我们制作了该文件的副本。然后我们做了一个硬链接到副本，并编辑硬链接的副本。当然，因为这就是硬链接的工作方式，所以对两个文件的修改都会显示出来。</p><h1 id="8972" class="ly ls iu bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">这意味着什么？</h1><p id="4d0f" class="pw-post-body-paragraph jr js iu jt b ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko in bi translated">我们演示的是，使用reflinks可以非常快速地创建文件的副本，并且消耗的磁盘空间可以忽略不计。克隆的副本继续消耗可以忽略的磁盘空间，直到您修改克隆的副本，此时它成为文件的常规副本。</p><p id="4ea7" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">也许这看起来很神秘，但是考虑一个可能的用例。</p><p id="94c1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">用这种能力来管理一个软件开发项目。代替源代码管理系统(Git、Mercurial、CVS等),你将拥有并行目录。使用我们在Linux上使用的GNU cp程序，你可以非常快速地克隆一个完整的目录结构。项目团队可以使用一系列并行目录，每个目录都使用写时复制副本来管理源代码树。</p><pre class="kq kr ks kt gu ln lm lo lp aw lq bi"><span id="efa2" class="lr ls iu lm b gz lt lu l lv lw">$ git clone https://github.com/nodejs/node.git<br/>Cloning into 'node'...<br/>remote: Enumerating objects: 8, done.<br/>remote: Counting objects: 100% (8/8), done.<br/>remote: Compressing objects: 100% (7/7), done.<br/>remote: Total 521860 (delta 1), reused 3 (delta 1), pack-reused 521852<br/>Receiving objects: 100% (521860/521860), 462.85 MiB | 1013.00 KiB/s, done.<br/>Resolving deltas: 100% (387209/387209), done.<br/>Checking out files: 100% (31537/31537), done.</span><span id="053a" class="lr ls iu lm b gz lx lu l lv lw">$ du -sk node<br/>913584	node</span><span id="6595" class="lr ls iu lm b gz lx lu l lv lw">$ find node -type f -print | wc -l<br/>31561</span><span id="0ccd" class="lr ls iu lm b gz lx lu l lv lw">$ time cp --archive --reflink node node-dup</span><span id="e69f" class="lr ls iu lm b gz lx lu l lv lw">real	0m1.860s<br/>user	0m0.317s<br/>sys	0m1.306s</span></pre><p id="bd7c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">以Node.js Git库为例，913兆的源代码，31000多个文件，整个目录结构的<code class="fe lj lk ll lm b">reflink</code>克隆需要1.8秒。在克隆中，我们可以编辑任何文件，原始文件不会被更改。</p><p id="6528" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">理论上，我们可以用它来处理源代码树的修改。当然，我不认为软件工程师会放弃像Git这样的配置管理系统。相反，这个特殊的例子可能不太好，但也许有其他更有说服力的用例。</p><p id="9147" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">例如，如果每次编辑文件时，文字处理或图像处理程序都创建了一个写入时复制的克隆，那会怎样？该程序可以有一个用户界面来浏览克隆，因此如果需要，您可以恢复到文件的早期版本。</p><h1 id="0b37" class="ly ls iu bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">操作系统支持</h1><p id="f03b" class="pw-post-body-paragraph jr js iu jt b ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko in bi translated">并非每个操作系统都有<code class="fe lj lk ll lm b">reflinks</code> / <code class="fe lj lk ll lm b">clonefile</code>功能。</p><p id="7b52" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在Mac OS X上，该功能需要APFS文件系统。</p><p id="f6f5" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在Linux上，它需要XFS、BTRFS和一两个其他文件系统。</p><p id="0718" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在Windows上——我不知道。</p><h1 id="20e5" class="ly ls iu bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">在Node.js中实现reflinks</h1><pre class="kq kr ks kt gu ln lm lo lp aw lq bi"><span id="04e0" class="lr ls iu lm b gz lt lu l lv lw">const fs = require("fs");<br/>const process = require('process');</span><span id="8cb8" class="lr ls iu lm b gz lx lu l lv lw">fs.copyFile(<br/>  process.argv[2],<br/>  process.argv[3],<br/>  fs.constants.COPYFILE_FICLONE,<br/>  (err) =&gt; {<br/>    if (err) {<br/>      // TODO: handle error<br/>      console.error(err);<br/>    }<br/>  }<br/>);</span></pre><p id="fea1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在生产代码中，这当然应该在一个async/await函数中。关键是将<code class="fe lj lk ll lm b">copyFile</code>与<code class="fe lj lk ll lm b">fs.constants.COPYFILE_FICLONE</code>常量一起使用。</p><p id="c163" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">时机是:</p><pre class="kq kr ks kt gu ln lm lo lp aw lq bi"><span id="e31a" class="lr ls iu lm b gz lt lu l lv lw">$ time node reflink.js wikidatawiki-stub-articles.xml foo.xml</span><span id="5f74" class="lr ls iu lm b gz lx lu l lv lw">real	0m0.047s<br/>user	0m0.036s<br/>sys	0m0.012s</span></pre><p id="4cbb" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">或者……和<code class="fe lj lk ll lm b">cp --reflink</code>要求的时间差不多。</p><p id="18bd" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="lb">本文原载于</em> <a class="ae li" href="https://techsparx.com/nodejs/howto/copy-on-write.html" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> TechSparx </em> </a></p></div></div>    
</body>
</html>