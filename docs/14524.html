<html>
<head>
<title>How to Achieve a Senseless Refresh Token</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现无意义刷新令牌</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-achieve-a-senseless-refresh-token-190372137fe1?source=collection_archive---------11-----------------------#2022-12-04">https://levelup.gitconnected.com/how-to-achieve-a-senseless-refresh-token-190372137fe1?source=collection_archive---------11-----------------------#2022-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="acf2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用JWT的无意义令牌刷新</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/94ad27eeb5c14b33cc6adc5aae283a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*_Puyg3uHgu2cSIzE8XUvmQ.jpeg"/></div></figure><h2 id="b208" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是JWT</h2><p id="412a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">JWT (JSON WEB TOKEN)，一种开放标准，用于以JSON格式为对象传递来自各方的数据信息，这些对象可以选择性地进行数字加密，并可以使用RSA或ECDSA使用公钥/私钥进行签名。</p><h2 id="f126" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">使用场景</h2><p id="d1fc" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">JWT最常见的使用场景是缓存当前用户登录信息，并在用户成功登录时获取JWT，之后用户的每个请求都会在请求头中携带授权字段，以区分被请求的用户信息。并且不需要额外的资源开销。</p><p id="fe90" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">JWT由三部分组成，即报头、有效载荷和签名，由。符号来区分它们。</p><h2 id="cd65" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">页眉</h2><p id="d357" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">报头是一个JSON对象，由两部分组成，令牌是类型(JWT)和签名算法(SHA256，RSA)</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="ddfb" class="mm ko iq mi b be mn mo l mp mq">{<br/>  "alg": "HS256",<br/>  "typ": "JWT"<br/>}</span></pre><h2 id="34ad" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">有效载荷</h2><p id="bfe9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">有效负载也是一个JSON对象，它保存需要传递的数据，比如用户的信息。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="a205" class="mm ko iq mi b be mn mo l mp mq"><br/>{<br/>  "username": "_island",<br/>  "age": 18<br/>}</span></pre><h1 id="415f" class="mr ko iq bd kp ms mt mu ks mv mw mx kv jw my jx kz jz mz ka ld kc na kd lh nb bi translated">签名</h1><p id="7ba3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">这部分由前面两部分签名，防止数据被篡改。在服务器中指定一个密钥，根据下面的公式，使用报头中指定的签名算法生成该签名数据。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="36fa" class="mm ko iq mi b be mn mo l mp mq">HMACSHA256(<br/>  base64UrlEncode(header) + "." +<br/>  base64UrlEncode(payload),<br/>  secret)</span></pre><p id="3edf" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">获取签名数据后，数据的三个部分被连接在一起，每个部分由。分开每一部分。通过这种方式，我们生成一个JWT数据，然后将其返回给客户端进行存储。并且当客户端发起请求时，在请求头的授权字段中携带这个JWT，服务器可以通过解密来识别对应的用户信息。</p><h2 id="fd63" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">JWT的优势和劣势</h2><p id="3c69" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated"><strong class="ll ir">优点</strong> <br/> 1。数据量小，传输速度快<br/> 2。存储数据没有额外的资源开销<br/> 3。支持跨域认证用法<br/> <strong class="ll ir">缺点</strong> <br/> 1。生成的令牌不可撤销，即使重置账户密码前的令牌仍然可用(需要等待JWT过期)<br/> 2。无法确认用户<br/> 3发出了多少个jwt。不支持refreshToken</p><h2 id="43f2" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">refreshToken</h2><p id="eef2" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">refreshToken是Oauth2身份验证中的一个概念，与accessToken一起生成。</p><p id="05a2" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">当用户携带的accessToken过期时，用户需要重新获取新的accessToken，使用refreshToken重新获取新的accessToken的凭证。</p><h2 id="b69d" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">为什么选择refreshToken</h2><p id="0cb3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">当您第一次遇到它时，您是否怀疑过为什么在服务器端需要一个refreshToken，而不是一个更长甚至永久的accessToken？</p><p id="80d5" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">其实accessToken有点像我们在酒店的生活，当我们入住酒店的时候，我们会出示我们的ID去注册一个房卡，这个时候房卡就相当于accessToken，你可以进入相应的房间，当你的房卡过期了你就不能再开门了，这时你需要去前台更新房卡，才能正常进入，这个过程也相当于refreshToken。<br/> AccessToken的使用比refreshToken频繁得多，如果像上面提到的那样给AccessToken更长的有效时间，会有不可控的权限泄露风险。</p><p id="23b2" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated"><strong class="ll ir">使用refreshToken可以提高安全性</strong></p><p id="a955" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">当用户访问网站时，accessToken被盗，此时攻击者可以使用accessToke来访问权限内的功能。如果accessToken被设置为在2小时的短时间内有效，攻击者最多可以使用窃取的accessToken 2小时，除非access token被refreshToken再次刷新以正常访问。</p><p id="7430" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">如果accessToken设置为永久有效，则即使在用户更改密码后，以前的accessToken也将有效。</p><p id="c884" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">总的来说，有了refreshToken，accessToken失窃的风险就降低了。</p><h2 id="4a84" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">JWT无意识刷新令牌解决方案</h2><p id="859c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">在用户登录应用程序时，服务器会返回一组数据，包括accessToken和refreshToken，每个accessToken都有一个固定的过期日期，如果携带一个过期的令牌向服务器请求，服务器会返回一个401状态码告诉用户这个令牌过期了，这时就需要使用登录时返回的refreshToken调用refreshToken接口(Refresh)来更新新的令牌然后发送请求。</p><blockquote class="nc nd ne"><p id="f8ee" class="lj lk nf ll b lm mc jr lo lp md ju lr ng me lt lu nh mf lw lx ni mg lz ma mb ij bi translated">axios是最流行的http请求库之一，在本文中，我们使用它的错误响应拦截器来实现令牌无意义刷新特性。</p></blockquote><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="f101" class="mm ko iq mi b be mn mo l mp mq">// Maximum number of retransmissions<br/>const MAX_ERROR_COUNT = 5;<br/>// Current number of retransmissions<br/>let currentCount = 0;<br/>// Cache Request Queue<br/>const queue: ((t: string) =&gt; any)[] = [];<br/>// Is the current state refreshed<br/>let isRefresh = false;<br/><br/>export default async (error: AxiosError&lt;ResponseDataType&gt;) =&gt; {<br/>  const statusCode = error.response?.status;<br/>  const clearAuth = () =&gt; {<br/>    console.log('Identity expired, please login again');<br/>    window.location.replace('/login');<br/>    // clear data<br/>    sessionStorage.clear();<br/>    return Promise.reject(error);<br/>  };<br/>  if (statusCode === 401) {<br/>    // accessToken失效<br/>    // Determine if the local cache has refreshToken<br/>    const refreshToken = sessionStorage.get('refresh') ?? null;<br/>    if (!refreshToken) {<br/>      clearAuth();<br/>    }<br/>    // Configuration of the extraction request<br/>    const { config } = error;<br/>    // Determine if refresh failed and status code 401, enter error interceptor again<br/>    if (config.url?.includes('refresh')) {<br/>    clearAuth();<br/>    }<br/>    <br/>    if (!isRefresh) {<br/>      isRefresh = true;<br/>      // If the number of retransmissions exceeds, log out directly<br/>      if (currentCount &gt; MAX_ERROR_COUNT) {<br/>        clearAuth();<br/>      }<br/>      <br/>      currentCount += 1;<br/><br/>      try {<br/>        const {<br/>          data: { access },<br/>        } = await UserAuthApi.refreshToken(refreshToken);<br/>        // Request successful, cache new accessToken<br/>        sessionStorage.set('token', access);<br/>        currentCount = 0;<br/><br/>        queue.forEach((cb) =&gt; cb(access));<br/>        return ApiInstance.request(error.config);<br/>      } catch {<br/>        //Failed to refresh token, logged out directly<br/>        sessionStorage.clear();<br/>        window.location.replace('/login');<br/>        return Promise.reject(error);<br/>      } finally {<br/>        // Reset Status<br/>        isRefresh = false;<br/>      }<br/>    } else {<br/>      return new Promise((resolve) =&gt; {<br/>        // Cache network requests and execute them directly after the token is refreshed<br/>        queue.push((newToken: string) =&gt; {<br/>          Reflect.set(config.headers!, 'authorization', newToken);<br/>          // @ts-ignore<br/>          resolve(ApiInstance.request&lt;ResponseDataType&lt;any&gt;&gt;(config));<br/>        });<br/>      });<br/>    }<br/>  }<br/><br/>  return Promise.reject(error);<br/>};</span></pre><p id="08c9" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">将上面关于refreshToken调用的代码单独放入一个refresh token函数来单独处理这种情况，这样有助于提高代码的可读性和可维护性，让它看起来不那么臃肿。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="12f0" class="mm ko iq mi b be mn mo l mp mq">// refreshToken.ts<br/>export default async function refreshToken(error: AxiosError&lt;ResponseDataType&gt;) {<br/>    /* <br/>    Just paste in the code from if (statusCode === 401) above<br/>    */<br/>}</span></pre><p id="1865" class="pw-post-body-paragraph lj lk iq ll b lm mc jr lo lp md ju lr kw me lt lu la mf lw lx le mg lz ma mb ij bi translated">经过上面的逻辑抽象，现在看拦截器中的代码非常简洁，后续如果想调整相关逻辑直接在refreshToken.ts文件中调整即可。</p><pre class="kg kh ki kj gt mh mi mj bn mk ml bi"><span id="948c" class="mm ko iq mi b be mn mo l mp mq">import refreshToken from './refreshToken.ts'<br/>export default async (error: AxiosError&lt;ResponseDataType&gt;) =&gt; {<br/>  const statusCode = error.response?.status;<br/><br/>  if (statusCode === 401) {<br/>    refreshToken()<br/>  }<br/><br/>  return Promise.reject(error);<br/>};</span></pre></div></div>    
</body>
</html>