<html>
<head>
<title>React Styled Components — Hooks, Refs, and Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应样式组件—挂钩、引用和安全性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-styled-components-hooks-refs-and-security-281fb8ab0341?source=collection_archive---------4-----------------------#2020-05-16">https://levelup.gitconnected.com/react-styled-components-hooks-refs-and-security-281fb8ab0341?source=collection_archive---------4-----------------------#2020-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ca53dc73a1d21d520f477e59526c5fb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nBNs0N1gpYMZegM8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@wangooo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">王玮华</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="db14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是构建现代交互式前端web应用最常用的前端库。它还可以用来构建移动应用程序。</p><p id="a875" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何用钩子访问主题，用refs引用DOM元素，以及处理安全性。</p><h1 id="490b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用useContext React挂钩访问主题</h1><p id="ac19" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">useContext</code> React钩子和<code class="fe mh mi mj mk b">ThemeContext</code>来访问带有钩子的主题属性。</p><p id="c20b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样做:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a0c3" class="mt lf it mk b gy mu mv l mw mx">import React, { useContext } from "react";<br/>import { ThemeProvider, ThemeContext } from "styled-components";</span><span id="524e" class="mt lf it mk b gy my mv l mw mx">const baseTheme = {<br/>  color: "green",<br/>  backgroundColor: "white"<br/>};</span><span id="1e97" class="mt lf it mk b gy my mv l mw mx">const Foo = ({ children }) =&gt; {<br/>  const themeContext = useContext(ThemeContext);<br/>  return &lt;div style={themeContext}&gt;{children}&lt;/div&gt;;<br/>};</span><span id="099b" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ThemeProvider theme={baseTheme}&gt;<br/>        &lt;Foo&gt;foo&lt;/Foo&gt;<br/>      &lt;/ThemeProvider&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="3d6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用传入了<code class="fe mh mi mj mk b">ThemeContext</code>的<code class="fe mh mi mj mk b">useContext</code>来访问主题。<code class="fe mh mi mj mk b">themeContext</code>与<code class="fe mh mi mj mk b">baseTheme</code>具有完全相同的属性和值。因此，我们可以直接将<code class="fe mh mi mj mk b">themeContext</code>作为<code class="fe mh mi mj mk b">style</code>属性的值传入。</p><p id="bc0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">App</code>中，我们用设置为<code class="fe mh mi mj mk b">baseTheme</code>的<code class="fe mh mi mj mk b">theme</code>包装<code class="fe mh mi mj mk b">ThemeProvider</code>，这样我们就可以访问<code class="fe mh mi mj mk b">baseTheme</code>中的主题属性。</p><p id="6298" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们将看到“foo”显示为绿色。</p><h1 id="a012" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">主题道具</h1><p id="9324" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">theme</code>道具将主题传递给子组件。这适用于用<code class="fe mh mi mj mk b">styled-components</code>创建的组件。例如，我们可以这样做:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fc68" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import styled, { ThemeProvider } from "styled-components";</span><span id="6459" class="mt lf it mk b gy my mv l mw mx">const Button = styled.button`<br/>  font-size: 12px;<br/>  margin: 5px;<br/>  padding: 6px;<br/>  border-radius: 3px;</span><span id="bc13" class="mt lf it mk b gy my mv l mw mx">color: ${props =&gt; props.theme.main};<br/>  border: 2px solid ${props =&gt; props.theme.main};<br/>`;</span><span id="776d" class="mt lf it mk b gy my mv l mw mx">const theme = {<br/>  main: "green"<br/>};</span><span id="fd9c" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ThemeProvider theme={theme}&gt;<br/>        &lt;Button theme={{ main: "blue" }}&gt;Foo&lt;/Button&gt;<br/>        &lt;ThemeProvider theme={theme}&gt;<br/>          &lt;div&gt;<br/>            &lt;Button&gt;Baz&lt;/Button&gt;<br/>            &lt;Button theme={{ main: "red" }}&gt;Bar&lt;/Button&gt;<br/>          &lt;/div&gt;<br/>        &lt;/ThemeProvider&gt;<br/>      &lt;/ThemeProvider&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="f578" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了一个具有各种样式的按钮。颜色是从主题传入的，我们用<code class="fe mh mi mj mk b">prop.theme.main</code>属性访问它。</p><p id="4035" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mh mi mj mk b">App</code>中，我们使用<code class="fe mh mi mj mk b">theme</code>道具为一些按钮传入不同的颜色。Foo按钮是蓝色的，Bar按钮是红色的。</p><p id="132f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们将覆盖在<code class="fe mh mi mj mk b">theme</code>中指定的原始颜色值，即<code class="fe mh mi mj mk b">green</code>。</p><p id="5551" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们会看到按钮有红色、绿色或蓝色的文本边框和颜色。Foo是蓝色的，Baz是绿色的，Bar是红色的，</p><h1 id="519e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考文献</h1><p id="13a7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以将引用传递给样式化组件，以访问给定样式化组件的DOM属性和方法。</p><p id="fdcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样做:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="07e4" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import styled from "styled-components";</span><span id="297e" class="mt lf it mk b gy my mv l mw mx">const Input = styled.input`<br/>  padding: 0.5em;<br/>  margin: 0.5em;<br/>  background: greenyellow;<br/>  border: none;<br/>  border-radius: 3px;<br/>`;</span><span id="8426" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  const inputRef = React.useRef();<br/>  React.useEffect(() =&gt; {<br/>    inputRef.current.focus();<br/>  }, []);<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Input ref={inputRef} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="0fde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了一个名为<code class="fe mh mi mj mk b">Input</code>的样式化输入。然后我们向<code class="fe mh mi mj mk b">Input</code>传递一个用<code class="fe mh mi mj mk b">useRef</code>钩子创建的ref。</p><p id="6b85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mh mi mj mk b">useEffect</code>回调中，我们调用<code class="fe mh mi mj mk b">inputRef.current.focus();</code>来聚焦元素。<code class="fe mh mi mj mk b">useEffect</code>的第二个参数中的空数组表示我们在<code class="fe mh mi mj mk b">App</code>第一次加载时加载回调。</p><p id="ceb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，当我们第一次加载页面时，<code class="fe mh mi mj mk b">Input</code>将被关注。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/adae84ddb8deff3703d9c370d258f60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UMAovnNgO2Dr9HnR"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@icons8?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Icons8团队</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="2274" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">安全性</h1><p id="e092" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当用<code class="fe mh mi mj mk b">styled-components</code>创建样式化组件时，安全性是一个需要关注的问题，因为如果我们通过道具、主题或其他方式传递文本，所有的文本都会被插入到我们的样式化组件中。</p><p id="4b43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该净化任何传入的输入。例如，以下情况是不好的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ac01" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import styled from "styled-components";</span><span id="5bfb" class="mt lf it mk b gy my mv l mw mx">const userInput = "/steal-money";</span><span id="4aa8" class="mt lf it mk b gy my mv l mw mx">const ArbitraryComponent = styled.div`<br/>  background: url(${userInput});<br/>`;</span><span id="0080" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ArbitraryComponent /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="50d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们在代码中加载了URL，这并不好。所以要加一些检查，避免这种情况的发生。</p><h1 id="7eb0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="cab9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">useContext</code>钩子访问主题。此外，我们可以传入<code class="fe mh mi mj mk b">theme</code>属性来覆盖基本主题中的值。</p><p id="d3b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">styled-components</code>将把refs转发给我们的HTML元素，这样我们就可以通过refs获得用包创建的样式化组件中的HTML元素。</p><p id="eb39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，当我们在样式代码中插入字符串时应该小心，以避免任意代码执行攻击。</p></div></div>    
</body>
</html>