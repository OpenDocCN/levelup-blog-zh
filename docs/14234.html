<html>
<head>
<title>Using Python Class For Data Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python类进行数据工程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-python-class-for-data-engineering-5edc4c3c9132?source=collection_archive---------6-----------------------#2022-11-10">https://levelup.gitconnected.com/using-python-class-for-data-engineering-5edc4c3c9132?source=collection_archive---------6-----------------------#2022-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/88cd82e7adb0a2b9802474a787a2eac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*MwlOBo9Dy0ldo58AiPCT-A.png"/></div></figure><h1 id="fe74" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">1.更容易收集字段</h1><p id="964d" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果你断然避免使用类，你很容易发现自己处于这样一种情况，你只是使用其他内置的数据结构，如列表或字典，重新发明你自己的“特别类”。</p><p id="976e" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">例如，您可能最终会有许多列表或字典共享相同的键来访问与单个逻辑对象相关联的不同类型的数据:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="e7bd" class="mh jy it md b be mi mj l mk ml">car_colors[23] = 'yellow'  # Color of Car 23<br/>car_mileage[23] = 38189.4  # Mileage of Car 23</span></pre><p id="ae88" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">通过切换到类，您可以拥有一个对象列表，每个列表上都有几个命名字段来寻址相关数据:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="3fb2" class="mh jy it md b be mi mj l mk ml">cars[23].color = 'yellow'<br/>cars[23].mileage = 38189.4</span></pre><p id="5e7a" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">您可以将所有数据保存在一个屋檐下，而不是使用恰好包含所有数据的列表和字典，这使得访问和传递这些对象更加方便。</p><p id="c682" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">您也不再需要在函数之间传递大元组的内容。</p><h1 id="5212" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">2.将对象链接在一起并让它们以富有表现力的方式交互的能力</h1><p id="ec63" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让代码先说话:</p><h2 id="71b8" class="mm jy it bd jz mn mo dn kd mp mq dp kh lg mr ms kl lk mt mu kp lo mv mw kt mx bi translated">面向对象的版本</h2><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="8d90" class="mh jy it md b be mi mj l mk ml">if not garage.is_full:<br/>    garage.add(my_car)<br/>    my_car.turn_off()<br/>    garage.close()</span></pre><h2 id="13ef" class="mm jy it bd jz mn mo dn kd mp mq dp kh lg mr ms kl lk mt mu kp lo mv mw kt mx bi translated">非面向对象/过程化版本</h2><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="91b5" class="mh jy it md b be mi mj l mk ml">if not is_garage_full(garage):<br/>    add_car_to_garage(my_car, garage)<br/>    turn_off_car(my_car)<br/>    close_garage(garage)</span></pre><p id="ef9f" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">这是面向对象编程真正闪光的地方——当你正在处理的对象在其上有行为时。比如可以点击的按钮或者可以加速刹车的汽车。</p><p id="b869" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">在这种情况下，如果你<em class="my">通过在你的按钮和汽车类上制作方法来封装</em>这些行为，那么其他对象可以调用这些方法并改变按钮或汽车的内部状态，而不知道操作是如何实现的，这将会有所帮助。</p><p id="d10c" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">特别是当你在你的对象上有很多行为的时候，把它们都放在同一个地方，放在对象本身的同一个屋檐下是很有帮助的。通过这种方式，您可以将对象链接在一起，并让它们以一种富有表现力的方式进行交互，这种方式很难用过程化的编码风格来模拟。</p><h1 id="f8dd" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">3.数据类</h1><p id="8ec0" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">数据类通常主要包含数据，尽管实际上没有任何限制。它是使用<code class="fe mz na nb md b">@dataclass</code>装饰器创建的，如下所示:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="5698" class="mh jy it md b be mi mj l mk ml">from dataclasses import dataclass<br/><br/>@dataclass<br/>class DataClassCard:<br/>    rank: str<br/>    suit: str</span></pre><p id="f600" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">数据类带有已经实现的基本功能。例如，您可以立即实例化、打印和比较数据类实例:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="9386" class="mh jy it md b be mi mj l mk ml">&gt;&gt;&gt; queen_of_hearts = DataClassCard('Q', 'Hearts')<br/>&gt;&gt;&gt; queen_of_hearts.rank<br/>'Q'<br/>&gt;&gt;&gt; queen_of_hearts<br/>DataClassCard(rank='Q', suit='Hearts')<br/>&gt;&gt;&gt; queen_of_hearts == DataClassCard('Q', 'Hearts')<br/>True</span></pre><p id="1797" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">与普通班级相比。最小的常规类应该是这样的:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="efaf" class="mh jy it md b be mi mj l mk ml">class RegularCard:<br/>    def __init__(self, rank, suit):<br/>        self.rank = rank<br/>        self.suit = suit</span></pre><p id="4c8f" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">虽然这没有更多的代码要写，但您已经可以看到样板文件之痛的迹象:<code class="fe mz na nb md b">rank</code>和<code class="fe mz na nb md b">suit</code>都重复了三次，只是为了初始化一个对象。此外，如果您尝试使用这个普通的类，您会注意到对象的表示不是非常具有描述性，并且由于某种原因，红心皇后与红心皇后不同:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="2ee0" class="mh jy it md b be mi mj l mk ml">&gt;&gt;&gt; queen_of_hearts = RegularCard('Q', 'Hearts')<br/>&gt;&gt;&gt; queen_of_hearts.rank<br/>'Q'<br/>&gt;&gt;&gt; queen_of_hearts<br/>&lt;__main__.RegularCard object at 0x7fb6eee35d30&gt;<br/>&gt;&gt;&gt; queen_of_hearts == RegularCard('Q', 'Hearts')<br/>False</span></pre><p id="5844" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">希望你能学到一些，并把python类添加到你的数据工程武库中。如果您想了解更多关于ETL(提取、转换、加载)的知识，并使用一些方便的python脚本来实现更简单的数据工程，请随意查看我的另一篇文章。数据验证是数据管道检查的首要步骤之一<a class="ae nc" href="https://medium.com/@caopengau/python-data-pipeline-first-and-foremost-step-data-validation-e15017b7ef8d" rel="noopener">在这里</a>我与<strong class="kx iu"> pydantic一起演示。</strong></p><p id="ce77" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated"><strong class="kx iu">呼吁行动</strong></p><p id="20e4" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">如果你觉得这个指南有帮助，请鼓掌并跟我来。通过<a class="ae nc" href="https://medium.com/@caopengau/membership" rel="noopener">链接</a>加入medium，获取我和所有其他优秀作家在medium上发表的所有优质文章。</p></div></div>    
</body>
</html>