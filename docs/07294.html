<html>
<head>
<title>A couple of notes about exceptions and interfaces in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Java中异常和接口的几点说明</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-couple-of-notes-about-exceptions-and-interfaces-in-java-164775a22abc?source=collection_archive---------7-----------------------#2021-02-07">https://levelup.gitconnected.com/a-couple-of-notes-about-exceptions-and-interfaces-in-java-164775a22abc?source=collection_archive---------7-----------------------#2021-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d084df848319467752df4901865c000e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GFlMWDM10ZqbDkwY"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@adiulici?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adi Ulici </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a7fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在典型的Java接口中，您指定了类必须实现的函数和过程，除非它们是抽象类。您指定调用什么功能和过程；参数的类型，如果有的话；并且指定函数的返回类型。</p><p id="3295" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你能在接口中指定实现能抛出什么异常吗？是的，你可以。事实上，大多数接口本质上禁止实现抛出检查异常。</p><p id="12b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，假设您编写了一个实现了<code class="fe le lf lg lh b">Comparable&lt;Fraction&gt;</code>的<code class="fe le lf lg lh b">Fraction</code>类。仅仅为了满足您的好奇心，您希望<code class="fe le lf lg lh b">compareTo()</code>函数抛出<code class="fe le lf lg lh b">Exception</code>。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="8c34" class="lq lr it lh b gy ls lt l lu lv">    <strong class="lh iu">@Override</strong>                     <strong class="lh iu">// ERROR: WON'T COMPILE</strong><br/>    public <strong class="lh iu">int compareTo(Fraction other) throws Exception</strong> {<br/>        throw new Exception("Sorry");<br/>    }</span></pre><p id="1b61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不会编译，因为<code class="fe le lf lg lh b">Comparable&lt;T&gt;</code>接口没有指定<code class="fe le lf lg lh b">compareTo()</code>可以抛出的任何检查过的异常。Javadoc确实指定了<code class="fe le lf lg lh b">compareTo()</code>可以抛出<code class="fe le lf lg lh b">ClassCastException</code>或<code class="fe le lf lg lh b">NullPointerException</code>，这两个都是运行时异常。</p><p id="6ddd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一些合理的情况下，您确实需要指定接口中某个单元的实现需要抛出一个检查异常。</p><p id="bb91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，一个涉及文件的接口可能需要一些单元，当一个特定操作所需的文件找不到时，这些单元抛出<code class="fe le lf lg lh b">FileNotFoundException</code>。</p><p id="ba0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">RuntimeException</code>中包装一个检查过的异常总是一种选择，但通常不是最好的选择。</p><p id="f3d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您确定编写您的接口实现的程序员需要能够声明要抛出的检查异常，那么在相关的接口中编写一个Throws子句。这里有一个玩具例子:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="a831" class="lq lr it lh b gy ls lt l lu lv">package fileops;</span><span id="847e" class="lq lr it lh b gy lw lt l lu lv">import java.io.File;<br/>import java.io.FileNotFoundException;</span><span id="0169" class="lq lr it lh b gy lw lt l lu lv">public interface ChecksumCorrelatable {</span><span id="5728" class="lq lr it lh b gy lw lt l lu lv">    long checksum();</span><span id="6137" class="lq lr it lh b gy lw lt l lu lv">    boolean checksumCorrelate(File file) <br/>            throws FileNotFoundException;</span><span id="513e" class="lq lr it lh b gy lw lt l lu lv">}</span></pre><p id="d244" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接口中这样的Throws子句最终只是一个建议。如果<code class="fe le lf lg lh b">ChecksumCorrelatable</code>是真实世界类必须实现的真实世界接口，那么它们可能都必须声明它们的<code class="fe le lf lg lh b">checksumCorrelate()</code>函数可能抛出<code class="fe le lf lg lh b">FileNotFoundException</code>。</p><p id="c0a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，现实世界中需要打开一些文件来关联其校验和，而许多JDK文件访问方法会抛出检查异常，这两个因素结合在一起，就形成了这种要求。</p><p id="5d55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，编译器不会强制要求每个实现接口的类抛出接口中指定的相同的检查异常。</p><p id="0be4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想你们中的一些人想在自己的电脑上继续学习，但是不太清楚如何继续这个例子。所以我要换一个不同的例子:分数和罗马数字。</p><p id="4b03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许这个例子感觉不太现实，但是应该更容易理解。在一个新的或者现有的项目中创建一个<code class="fe le lf lg lh b">Fraction</code>类和一个<code class="fe le lf lg lh b">RomanNumeralsNumber</code>类。</p><p id="e352" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我假设你知道如何用分数做算术:加、减、乘、除。也许你需要一点复习，但你不应该有任何问题。</p><p id="81ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至于罗马数字，它们从来就不适合算术。我猜一个古罗马人会在所有的中间步骤中使用算盘，并且只在结果中使用罗马数字。</p><p id="74ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果现在需要的话，您可以将操作数转换成十进制，用十进制执行计算，然后将结果转换回罗马数字。我想我们的<code class="fe le lf lg lh b">RomanNumeralsNumber</code>类将会做同样的事情，但是可能是用二进制而不是十进制。</p><p id="9bb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以<code class="fe le lf lg lh b">Fraction</code>和<code class="fe le lf lg lh b">RomanNumeralsNumber</code>都将定义算术函数，我们可能希望有其他类来表示不同种类的数字，比如<code class="fe le lf lg lh b">ComplexNumber</code>和<code class="fe le lf lg lh b">ModularInteger</code>，它们也定义了算术函数。</p><p id="d273" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果所有这些类中的算术函数都被统一命名就好了。我们可以通过接口做到这一点，这也给了我们减少冗余的机会。将此接口放在您的项目中，必要时更改包名:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="659b" class="lq lr it lh b gy ls lt l lu lv">package arithmetic;</span><span id="d495" class="lq lr it lh b gy lw lt l lu lv">public interface Arithmeticable&lt;T extends Arithmeticable&lt;T&gt;&gt; {<br/>    <br/>    T plus(T addend);<br/>    <br/>    T negate();<br/>    <br/>    default T minus(T subtrahend) {<br/>        return this.plus(subtrahend.negate());<br/>    }<br/>    <br/>    T times(T multiplicand);<br/>    <br/>    T divides(T divisor) throws NotDivisibleException;<br/>    <br/>}</span></pre><p id="5d17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，这个接口只能由为自己实现它的类<code class="fe le lf lg lh b">T</code>来实现。例如，我们可以有“<code class="fe le lf lg lh b">class ModularInteger implements Arithmeticable&lt;ModularInteger&gt;</code>”，但不能有“<code class="fe le lf lg lh b">class ModularInteger implements Arithmeticable&lt;Fraction&gt;</code>”</p><p id="6a8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道“算术”不是一个恰当的词。绝对不要试图在拼字游戏中玩它。如果你对拼写检查没有标记的一个或两个单词的术语有建议，请在评论中告诉我。</p><p id="175d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我还将可分性的概念引入到面向对象的设计中。我要你把这个检查过的异常和<code class="fe le lf lg lh b">Arithmeticable&lt;T&gt;</code>放在同一个包里:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ffca" class="lq lr it lh b gy ls lt l lu lv">package arithmetic;</span><span id="a6e5" class="lq lr it lh b gy lw lt l lu lv">public class NotDivisibleException extends Exception {<br/>    <br/>    // TODO: Write getters<br/>    private final Arithmeticable badDividend, badDivisor;</span><span id="fbd1" class="lq lr it lh b gy lw lt l lu lv">    public NotDivisibleException(String msg, <br/>            Arithmeticable dividend, Arithmeticable divisor) {<br/>        super(msg);<br/>        this.badDividend = dividend;<br/>        this.badDivisor = divisor;<br/>    }<br/>    <br/>}</span></pre><p id="4c9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保从<code class="fe le lf lg lh b">Exception</code>子类化，而不是<code class="fe le lf lg lh b">RuntimeException</code>。</p><p id="5440" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">绝对清楚的是，这并不意味着除以0。对除以0使用运行时异常。而且无论如何，我们的<code class="fe le lf lg lh b">RomanNumeralsNumber</code>类不应该代表0。</p><p id="5398" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑XIV除以VII等于II，因为II乘以VII等于XIV。但是试图将XIV除以VIII应该会引起<code class="fe le lf lg lh b">NotDivisibleException</code>。</p><p id="d135" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果类型<code class="fe le lf lg lh b">T</code>的一个实例不能被<code class="fe le lf lg lh b">T</code>的另一个实例整除，那么<code class="fe le lf lg lh b">NotDivisibleException</code>就意味着整除不能用<code class="fe le lf lg lh b">T</code>来表示，但它也意味着可以舍入到一个<code class="fe le lf lg lh b">T</code>可以表示的数。</p><p id="7a52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在XIV除以VIII的例子中，小数位数为1.75的除法可以向下舍入到I，或者更有可能向上舍入到II。</p><p id="2c50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个<code class="fe le lf lg lh b">RomanNumeralsNumber</code>的草稿:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="b23c" class="lq lr it lh b gy ls lt l lu lv">package numerics;</span><span id="e48c" class="lq lr it lh b gy lw lt l lu lv">import arithmetic.Arithmeticable;<br/>import arithmetic.NotDivisibleException;</span><span id="57bc" class="lq lr it lh b gy lw lt l lu lv">public class RomanNumeralsNumber <br/>        implements Arithmeticable&lt;RomanNumeralsNumber&gt;, <br/>        Comparable&lt;RomanNumeralsNumber&gt; {<br/>    <br/>    // TODO: Write getter or add <a class="ae kf" href="http://twitter.com/Getter" rel="noopener ugc nofollow" target="_blank">@Getter</a> annotation<br/>    private final short value;</span><span id="bb72" class="lq lr it lh b gy lw lt l lu lv">    // TODO: Override toString()</span><span id="3571" class="lq lr it lh b gy lw lt l lu lv">    // TODO: Override equals(), hashCode()</span><span id="d746" class="lq lr it lh b gy lw lt l lu lv">    // TODO: Write Arithmeticable&lt;T&gt; functions</span><span id="509d" class="lq lr it lh b gy lw lt l lu lv">    @Override<br/>    public int compareTo(RomanNumeralsNumber other) {<br/>        return Short.compare(this.value, other.value);<br/>    }<br/>    <br/>    public RomanNumeralsNumber(int n) {<br/>        // TODO: Add validation: no 0, no negative numbers<br/>        // TODO: Determine maximum n and add validation<br/>        this.value = (short) n;<br/>    }</span><span id="4fce" class="lq lr it lh b gy lw lt l lu lv">}</span></pre><p id="11b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">明确构造函数参数<code class="fe le lf lg lh b">n</code>必须大于0。而且应该很可能不到4000。或者你可以选择一些“时代错误”的系统，将罗马数字系统扩展到<code class="fe le lf lg lh b">short</code>的范围之外。</p><p id="6f9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们不要担心构造函数中<code class="fe le lf lg lh b">n</code>的验证。TODO注释可以暂时保留。这也意味着我们应该编写我们的单元测试来暂时避免溢出。当您决定<code class="fe le lf lg lh b">RomanNumeralsNumber</code>构造函数应该取的最大值是多少时，编写一个测试。</p><p id="916b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个练习中最耗时的部分是覆盖<code class="fe le lf lg lh b">toString()</code>，例如，给定<code class="fe le lf lg lh b">new RomanNumeralsNumber(1729)</code>，对其调用<code class="fe le lf lg lh b">toString()</code>会给出“MDCCXXIX”。</p><p id="e445" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想暂时搁置，以后再回头讨论，您可以像这样放入一个占位符:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="98bb" class="lq lr it lh b gy ls lt l lu lv">    // TODO: Write proper override<br/>    @Override<br/>    public String toString() {<br/>        return "PLACEHOLDER (" + this.value + ")";<br/>    }</span></pre><p id="0793" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要覆盖<code class="fe le lf lg lh b">equals()</code>，只需检查<code class="fe le lf lg lh b">this.value == obj.value</code>是否是<code class="fe le lf lg lh b">RomanNumeralsNumber</code>的非空实例。而<code class="fe le lf lg lh b">hashCode()</code>扩大转换成<code class="fe le lf lg lh b">int</code>后正好可以是<code class="fe le lf lg lh b">this.value</code>。</p><p id="a41c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然计算机做罗马数字算术肯定比人快得多(如果编程得当)，但让它像处理普通整数一样进行计算会容易得多，例如，</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="86c3" class="lq lr it lh b gy ls lt l lu lv">    @Override<br/>    public RomanNumeralsNumber plus(RomanNumeralsNumber addend) {<br/>        return new RomanNumeralsNumber(this.value + addend.value);<br/>    }</span></pre><p id="ba2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">RomanNumeralsNumber</code>类不应该表示负数，所以这给<code class="fe le lf lg lh b">negate()</code>函数带来了一点问题。</p><p id="70b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，我们可以让它扔出<code class="fe le lf lg lh b">UnsupportedOperationException</code>。这是一个未检查的异常，对于不提供“可选操作”的<code class="fe le lf lg lh b">java.util.List&lt;E&gt;</code>的实现也推荐使用这个异常</p><p id="bf34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用的是NetBeans(而不是IntelliJ IDEA ),它可能填充了一个stub来完成这个任务，但是所提供的异常消息暗示我们的类将来可能会支持这个操作。调整异常消息，以明确该类不表示负数。</p><p id="826f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然这意味着默认的<code class="fe le lf lg lh b">minus()</code>实现对<code class="fe le lf lg lh b">RomanNumeralsNumber</code>无效，所以我们必须覆盖它。这一点很明显，你很容易就能弄清楚。同样适用于<code class="fe le lf lg lh b">times()</code>。</p><p id="604a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe le lf lg lh b">divides()</code>，界面建议扔<code class="fe le lf lg lh b">NotDivisibleException</code>。<code class="fe le lf lg lh b">RomanNumeralsNumber</code>中的<code class="fe le lf lg lh b">divides()</code>会做到这一点。在编写了一些JUnit测试之后，我想到了这个:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="7388" class="lq lr it lh b gy ls lt l lu lv">    @Override<br/>    public RomanNumeralsNumber divides(RomanNumeralsNumber divisor) <br/>            throws NotDivisibleException {<br/>        if (this.value % divisor.value == 0) {<br/>            return new RomanNumeralsNumber(this.value <br/>                    / divisor.value);<br/>        } else {<br/>            String excMsg = "The number " + this.toString() <br/>                    + " is not divisible by " + divisor.toString();<br/>            throw new NotDivisibleException(excMsg, this, divisor);<br/>        }<br/>    }</span></pre><p id="86af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种整除的概念不适用于分数。任何分数都可以被任何非零分数整除。例如，14除以8就是7/4。</p><p id="710f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们当然不希望将对<code class="fe le lf lg lh b">Fraction</code>实例的每个<code class="fe le lf lg lh b">divides()</code>调用都包装在一个Try块中，并为永远不会被调用的<code class="fe le lf lg lh b">NotDivisibleException</code>捕获。</p><p id="b8c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不需要。下面是我如何在<code class="fe le lf lg lh b">Fraction</code>中得到<code class="fe le lf lg lh b">divides()</code>:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="eba0" class="lq lr it lh b gy ls lt l lu lv">    public Fraction reciprocal() {<br/>        return new Fraction(this.denominator, this.numerator);<br/>    }</span><span id="c9fe" class="lq lr it lh b gy lw lt l lu lv">    <strong class="lh iu">@Override<br/>    public Fraction divides(Fraction divisor) {<br/>        return this.times(divisor.reciprocal());<br/>    }</strong></span></pre><p id="d820" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Javadoc可能会比这长得多。</p><p id="e19c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这编译得很好。只要我们注意避免被零除，在使用<code class="fe le lf lg lh b">Fraction</code>中的<code class="fe le lf lg lh b">divides()</code>时就不会有任何例外。</p><p id="a7ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写接口时，您应该考虑实现类的检查异常可能需要抛出什么。</p><p id="4284" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数时候不需要这样做。但是当特定的和可预见的检查异常可能需要时，应该在接口中提供。</p><p id="c4a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当编写需要它的实现类时，程序员甚至不必考虑在运行时异常中包装检查过的异常，同时当检查过的异常不适用于特定的实现类时，可以自由选择退出。</p></div></div>    
</body>
</html>