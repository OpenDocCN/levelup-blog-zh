<html>
<head>
<title>Compute sha256 of CSP <script/> in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算节点JS中CSP <script/>的sha256</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/compute-sha256-of-csp-script-in-nodejs-720b887bcae6?source=collection_archive---------4-----------------------#2022-09-17">https://levelup.gitconnected.com/compute-sha256-of-csp-script-in-nodejs-720b887bcae6?source=collection_archive---------4-----------------------#2022-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c2b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为内容安全策略自动生成脚本标记的SHA-256哈希。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f2e983fe3580e24270e8b9aec50be0aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YGCSAPX6bq6t1kne"/></div></div></figure><p id="7281" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几年来，我一直在使用同样的策略为我的<code class="fe lq lr ls lt b">&lt;script /&gt;</code>标签自动计算SHA-256哈希，最近我在工作中和在<a class="ae lu" href="https://papy.rs/" rel="noopener ugc nofollow" target="_blank"> Papyrs </a>中再次应用了这一策略(我目前正在将生成博客空间的工具包从普通JavaScript迁移到<a class="ae lu" href="https://astro.build/" rel="noopener ugc nofollow" target="_blank"> Astro </a>，我认为这可能是一篇新的简短博客文章的有趣主题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2903" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">入门指南</h1><p id="2ec1" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">虽然可以手动设置<code class="fe lq lr ls lt b">sha256</code>,但我个人更喜欢在<code class="fe lq lr ls lt b">build</code>脚本结束后自动生成它们——作为一项后期处理工作。这意味着我依赖于这样一个事实，即构建的内容是可信的，并且一旦生成了脚本，我就计算其值。</p><p id="e604" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我创建了一个专用脚本，例如<code class="fe lq lr ls lt b">./build-csp.mjs</code>，并将其附加到我的构建脚本中:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="d944" class="nd md it lt b gy ne nf l ng nh">// package.json<br/><br/>{<br/>    "scripts": {<br/>        "build:csp": "node build-csp.mjs",<br/>        "build": "astro build &amp;&amp; npm run build:csp"<br/>    }<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="de9b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">搜索和更新</h1><p id="1e03" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">因为我的目标是在流程的最后注入sha，所以我在内容安全策略(CSP)中添加了一个占位符来搜索和更新计算出的值。例如，在下面的CSP <code class="fe lq lr ls lt b">meta</code>标签中，我使用了占位符<code class="fe lq lr ls lt b">{{EXTRA_SHAS}}</code>:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="f85a" class="nd md it lt b gy ne nf l ng nh">&lt;meta<br/>    http-equiv="Content-Security-Policy"<br/>    content="default-src 'none';<br/>             script-src 'self' {{EXTRA_SHAS}};<br/>/&gt;</span></pre><p id="0861" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为这样的占位符不是有效的策略，所以浏览器在评估规则时会抛出错误。当我开发时会发生什么，因为我只对产品构建进行后期处理。</p><p id="e23a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么我经常避免在我的本地环境中使用CSP。例如，在我的Astro项目中，如果不是<code class="fe lq lr ls lt b">PROD</code>版本，我会跳过<code class="fe lq lr ls lt b">meta</code>标签的渲染。</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="2679" class="nd md it lt b gy ne nf l ng nh">---<br/>const csp = import.meta.env.PROD;<br/>---<br/><br/>{<br/>  csp &amp;&amp; (<br/>    &lt;meta<br/>      http-equiv="Content-Security-Policy"<br/>      content="default-src 'none';<br/>      script-src 'self' {{EXTRA_SHAS}};<br/>    /&gt;<br/>  )<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc9e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">列出所有HTML文件</h1><p id="7918" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">为了计算HTML文件中使用的<code class="fe lq lr ls lt b">&lt;script /&gt;</code>内容的<code class="fe lq lr ls lt b">sha256</code> sha，我首先需要列出已经构建的HTML文件。</p><p id="b19c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我使用了一个递归探索函数，这个函数很可能是我在Stackoverflow上找到的，并一直使用至今。</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="4f9c" class="nd md it lt b gy ne nf l ng nh">import { readdirSync, lstatSync } from "fs";<br/>import { join } from "path";<br/><br/>export const findEntryPoints = (dir, files) =&gt; {<br/>  readdirSync(dir).forEach((file) =&gt; {<br/>    const fullPath = join(dir, file);<br/>    if (lstatSync(fullPath).isDirectory()) {<br/>      findEntryPoints(fullPath, files);<br/>    } else {<br/>      files.push(fullPath);<br/>    }<br/>  });<br/>};<br/><br/>const entryPoints = [];<br/>findEntryPoints("dist", entryPoints);</span></pre><p id="eaa2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我得到了所有的文件，我就过滤掉那些<code class="fe lq lr ls lt b">.html</code>的文件。</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="f855" class="nd md it lt b gy ne nf l ng nh">import { extname } from "path";<br/><br/>const htmlEntryPoints = entryPoints.filter((entry) =&gt;<br/>  [".html"].includes(extname(entry))<br/>);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ff28" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理和更新CSP</h1><p id="70a2" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">一旦我得到了所有的目标文件，我就通过读取它们的内容来批量更新它们，生成相关的sha并最终更新规则。</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="10cb" class="nd md it lt b gy ne nf l ng nh">import { join } from "path";<br/>import { readFile } from "fs/promises";<br/><br/>const updateCSP = async (entry) =&gt; {<br/>  const indexHtml = <br/>        await readFile(join(process.cwd(), entry), "utf-8");<br/>  const scriptHashes = await computeHashes(indexHtml);<br/>  await writeCSP({ scriptHashes, indexHtml, entry });<br/>};<br/><br/>const promises = htmlEntryPoints.map(updateCSP);<br/>await Promise.all(promises);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5941" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">计算机sha256</h1><p id="0bf0" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">为了为<code class="fe lq lr ls lt b">&lt;script /&gt;</code>标签的内容创建散列，我使用正则表达式来查找这些标签，并使用NodeJS的<a class="ae lu" href="https://nodejs.org/api/crypto.html#cryptocreatehashalgorithm-options" rel="noopener ugc nofollow" target="_blank"> Crypto API </a>来有效地计算值。</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="0df0" class="nd md it lt b gy ne nf l ng nh">import { createHash } from "crypto";<br/><br/>const computeHashes = (indexHtml) =&gt; {<br/>  const sw = /&lt;script[\s\S]*?&gt;([\s\S]*?)&lt;\/script&gt;/gm;<br/><br/>  const scriptHashes = [];<br/><br/>  let m;<br/>  while ((m = sw.exec(indexHtml))) {<br/>    const content = m[1];<br/><br/>    scriptHashes.push(<br/>      `'sha256-${createHash("sha256")<br/>               .update(content).digest("base64")}'`<br/>    );<br/>  }<br/><br/>  return scriptHashes;<br/>};</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0149" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">写入结果</h1><p id="8cac" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">最后，我用这些有效的sha替换我之前声明的占位符。</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="4056" class="nd md it lt b gy ne nf l ng nh">import { writeFile } from "fs/promises";<br/><br/>const writeCSP = async ({ scriptHashes, indexHtml, entry }) =&gt;<br/>  writeFile(<br/>    entry,<br/>    indexHtml.replace(<br/>      "{{EXTRA_SHAS}}",<br/>      scriptHashes.map((sha256) =&gt; sha256).join(" ")<br/>    ),<br/>    "utf-8"<br/>  );</span></pre><p id="e712" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是🥳</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9179" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="931f" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在生活中，有时是一些小事让你开心，开发这个小助手脚本就是其中之一。</p><p id="2609" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到无限和更远的地方</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f416" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更多冒险，请在🖖的推特上关注我</p></div></div>    
</body>
</html>