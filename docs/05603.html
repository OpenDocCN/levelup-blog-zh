<html>
<head>
<title>How to Pass an Element Reference Down Through a Component Tree in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular中通过组件树向下传递元素引用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-pass-an-element-reference-down-through-a-component-tree-in-angular-86b495a2ce57?source=collection_archive---------4-----------------------#2020-09-14">https://levelup.gitconnected.com/how-to-pass-an-element-reference-down-through-a-component-tree-in-angular-86b495a2ce57?source=collection_archive---------4-----------------------#2020-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3423" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用指令和依赖注入来避免不必要的组件输入</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1382896ced6b5109a3f7d32cc5b0926d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z65OFyZ079aWN8za6WQmEw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.shutterstock.com/g/graphicphoto" rel="noopener ugc nofollow" target="_blank">安妮特·沙夫</a>在<a class="ae kv" href="https://www.shutterstock.com/image-photo/dog-looking-down-hole-ground-sun-180754802" rel="noopener ugc nofollow" target="_blank">快门架</a>上拍摄</figcaption></figure><p id="fc57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近有一个需求，要确保一个带有滚动内容的模态中的<a class="ae kv" href="https://www.primefaces.org/primeng/" rel="noopener ugc nofollow" target="_blank"> PrimeNG </a> Dropdown panel不被约束在模态中，而是可以被看到，并且不需要滚动就可以交互。</p><p id="0a0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我所说的…</p><h1 id="3b9c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">场景</h1><p id="6ce5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是默认的，也是我们<em class="mp">不</em>想要的(或者说，是我们<em class="mp">不</em>交付的):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/59e3b4ef372574997f4f331f74df08a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*NgMN1DUtT6uW2eh42aPcVQ.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">约束在模式内的下拉面板</figcaption></figure><p id="8b46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们想要的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/4761375bd62113920507a4d1ca8f86bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/1*RpnIzzraRrE7dHYDw-wysg.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">下拉面板在模式边界外可见</figcaption></figure><h1 id="84ac" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">方法</h1><p id="fb5b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">查看<a class="ae kv" href="https://www.primefaces.org/primeng/v8.2.6-lts/#/dropdown" rel="noopener ugc nofollow" target="_blank"> PrimeNG下拉文档</a>，我们可以看到组件公开了一个<code class="fe ms mt mu mv b">appendTo</code>输入:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/0b5717a4e726d985a1187ceccb3efc70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*msVjuJB5sS9t46IqFTUiUw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">准备下拉API参考:appendTo</figcaption></figure><p id="1faa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许我们告诉dropdown要将面板附加到什么元素，而不是让它将面板附加到dropdown元素本身。这样，我们可以将面板附加到模态之外的元素上，这样它就可以避开模态边界。</p><p id="f07b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需要为目标元素传入一个角度模板引用，就可以看到奇迹发生了。(我们也可以只传入字符串<code class="fe ms mt mu mv b">'body'</code>让它将面板附加到文档主体上，但是这很容易也很无聊，不是本文要讨论的内容。它也不太适合我的布局，但我不记得确切的原因。)</p><h1 id="eefb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">简单的场景</h1><p id="5df5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">很简单，对吧？</p><p id="b4b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，如果目标<code class="fe ms mt mu mv b">appendTo</code>元素和下拉菜单在同一个模板中，应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="498d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到我们的<code class="fe ms mt mu mv b">p-dropdown</code>跨越了第7–11行，而我们的<code class="fe ms mt mu mv b">.append-target</code>元素方便地位于同一个模板的第1行。</p><p id="ec89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将<code class="fe ms mt mu mv b">#myTarget</code>模板引用变量添加到目标元素中，我们可以简单地将输入<code class="fe ms mt mu mv b">[appendTo]=”myTarget”</code>添加到<code class="fe ms mt mu mv b">p-dropdown</code>中，然后就到此为止。</p><p id="aa1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是事情很少那么简单，当然，我的情况更复杂。否则我现在不会写这篇文章。</p><h1 id="860e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">困难在于</h1><p id="bf9a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个更现实的场景(碰巧也是我的场景)是<code class="fe ms mt mu mv b">p-dropdown</code>嵌套在组件树的几层深处，从你需要面板附加到的目标元素开始。</p><p id="0b58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我所说的组件树的类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="aa3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第3行，在我们的app-component的模板中，您可以看到我们的<code class="fe ms mt mu mv b">.append-target</code>的辉煌。</p><p id="752f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的app-component内部是我们模糊命名的(出于演示目的)子组件<code class="fe ms mt mu mv b">app-child</code>，它忠实地包含了我们的孙组件<code class="fe ms mt mu mv b">app-grandchild</code>(第9行)。</p><p id="5e87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的孙儿组件，反过来，包含我们的模态组件，<code class="fe ms mt mu mv b">app-modal</code>(第15行)。</p><p id="f37c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们的模态组件是我们的<code class="fe ms mt mu mv b">p-dropdown</code>所在的地方(第24行)。</p><p id="7d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我们如何通过这些层将模板引用传递给急切等待的<code class="fe ms mt mu mv b">p-dropdown</code>？</p><h1 id="ecba" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">脆弱的解决方案</h1><p id="cdda" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一种解决方案是通过组件<code class="fe ms mt mu mv b">Input()</code> s在树中向下传递模板引用，就像这样(留意<code class="fe ms mt mu mv b">[dropdownAppendTarget]</code> s):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ca25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个组件都有一个崭新的<code class="fe ms mt mu mv b">dropdownAppendTarget</code> <code class="fe ms mt mu mv b">Input()</code>，允许它将模板引用从其父组件向下传递到下一层。</p><p id="e41f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这工作得很好……直到有一天某个不知情的新开发人员出现，他对这个<a class="ae kv" href="https://en.wikipedia.org/wiki/Underground_Railroad" rel="noopener ugc nofollow" target="_blank">地下铁路</a>一无所知，把模板引用通过组件树的每一层传送下去。</p><p id="6f13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不知情的Dev无意中在中间插入了一个额外的组件层，而没有意识到他正在破坏电路，我们微妙的解决方案被毁了。</p><h1 id="154b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">更好的解决方案</h1><p id="2660" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于我们都是出色的开发人员，对明显是定时炸弹的解决方案有敏锐的眼光，我们将让不知情的开发人员免受一些压力和痛苦，并提出一个更健壮的解决方案。</p><p id="7c5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像所有好心的Angular开发人员一样，我们将依赖注入！</p><h2 id="85fb" class="mz lt iq bd lu na nb dn ly nc nd dp mc lf ne nf me lj ng nh mg ln ni nj mi nk bi translated">获取模板引用的指令！</h2><p id="e2ea" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一种更干净、更简单的方法是在我们的目标元素上附加一个获取该元素的模板引用的属性指令，然后依赖关系将该指令注入到需要模板引用的下游组件中。</p><p id="a0bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，就不需要通过组件树来构建(和维护)网络，毫无戒心的开发人员可以随心所欲地插入多个中间层，而不会破坏任何东西。</p><p id="1593" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不错！！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/59e5a0654557684b9da04367613813bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*eSBHvovJxtEzZFDauAXShA.gif"/></div></figure><p id="757c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧…</p><h1 id="e598" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">目标</h1><p id="1285" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因此，这就是我们想要达到的基本目标:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第3行，我们将一个名为<code class="fe ms mt mu mv b">appendTarget</code>的属性指令附加到目标元素上，我们将元素的模板引用<code class="fe ms mt mu mv b">myTarget</code>传递到这个属性指令中。漂亮又干净！</p><p id="4ac2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是<code class="fe ms mt mu mv b">AppendTargetDirective</code>的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f1d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">超级简单！</p><h1 id="1365" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">尝试</h1><p id="d330" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有了这些，我们就可以依赖地将指令注入到我们的下游模态组件中，并在组件类上创建一个名为<code class="fe ms mt mu mv b">appendTarget</code>的属性，该属性指向传入指令实例的模板ref:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c761" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模态组件的模板如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d94f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第8行，我们在<code class="fe ms mt mu mv b">p-dropdown</code>中添加了<code class="fe ms mt mu mv b">[appendTo]="appendTarget"</code>。</p><p id="4327" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看奇迹的发生吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/402fd6530e97c1cbbc9e9c9055855e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAE5rAaWpJaL3vsj8x8vNg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/34ed001cc61849e356e1f2025f08a489.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Ty2m-RV9H_8AI06aVLlBIA.gif"/></div></figure><h1 id="c6b2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">失败</h1><p id="ffe6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我在这里描述我的调试工作，因为我在这个过程中学到了一些关于Angular的有趣和有价值的东西，所以我认为值得包括进来。</p><p id="f5d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您只想看到最终的工作解决方案，可以直接跳到<a class="ae kv" href="#95ec" rel="noopener ugc nofollow">工作解决方案</a>。</p><h2 id="5fdb" class="mz lt iq bd lu na nb dn ly nc nd dp mc lf ne nf me lj ng nh mg ln ni nj mi nk bi translated">(被误导的)修复尝试</h2><p id="9080" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">看到<code class="fe ms mt mu mv b">No provider for…</code>错误(我非常熟悉的一个)时，我的想法是:</p><blockquote class="no np nq"><p id="5ac9" class="kw kx mp ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">当然了，笨蛋！只需将您的指令添加到app-component的<code class="fe ms mt mu mv b">providers</code>数组中，这样DI系统就会知道它，就像您对服务所做的那样！</p></blockquote><p id="dbd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我是这样做的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="50cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将<code class="fe ms mt mu mv b">AppendTargetDirective</code>添加到app.component.ts中的<code class="fe ms mt mu mv b">providers</code>数组中(第8行)。</p><p id="875e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">熟悉Angular的DI系统的人现在可能要么在笑，要么在失望和厌恶中摇头。</p><p id="87ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个让我陷入痛苦世界的大错误。痛苦的世界。</p><p id="7b0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它消除了<code class="fe ms mt mu mv b">No provider for…</code>错误，但它没有让我的场景工作，并让我陷入了几天令人沮丧的故障排除。</p><h2 id="b7f5" class="mz lt iq bd lu na nb dn ly nc nd dp mc lf ne nf me lj ng nh mg ln ni nj mi nk bi translated">调查</h2><p id="a5cf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">经过大量调试后，我发现我的指令被实例化了两次:一个实例获得了我的append-target，而另一个没有。</p><p id="a188" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">被注入到我的模态组件中的那个是<em class="mp">而不是</em>获得追加目标，所以它的<code class="fe ms mt mu mv b">appendTarget</code>属性是<code class="fe ms mt mu mv b">undefined</code>。</p><h2 id="662a" class="mz lt iq bd lu na nb dn ly nc nd dp mc lf ne nf me lj ng nh mg ln ni nj mi nk bi translated">寻求帮助</h2><p id="9dc9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">挣扎了一段时间后，我终于在StackOverflow上发布了一个问题，问“什么给出了？”</p><p id="9d62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，无处不在、超级有用的棱角宗师阿列克谢·祖耶夫(yurzui) 几乎立即贴出了这个答案:</p><div class="nu nv gp gr nw nx"><a href="https://stackoverflow.com/a/63084199/4192097" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">如何在Angular中使用依赖注入将属性指令实例传递给嵌套组件</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">我试图使用一个属性指令将一个元素的模板引用从一个父组件传递到一个…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">stackoverflow.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div><p id="b980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他的主要观点是:</p><blockquote class="no np nq"><p id="66b0" class="kw kx mp ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">你<strong class="ky ir">永远不要</strong>【应该】给<code class="fe ms mt mu mv b">providers</code>数组添加角度指令。Angular将把它们视为服务，它们是指令类的独立实例，与模板结构完全无关。</p></blockquote><p id="7339" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以Angular创建了我的指令的两个实例:</p><ul class=""><li id="b65b" class="om on iq ky b kz la lc ld lf oo lj op ln oq lr or os ot ou bi translated">实例#1:因为它在app-component的<code class="fe ms mt mu mv b">providers</code>数组中，Angular将其实例化，就好像它是一个服务，所以只是另一个与模板结构没有联系的类。</li><li id="6502" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated">实例#2:因为它作为一个属性指令附加到append-target元素，Angular将其实例化为一个连接到模板的正确指令，因此获得了append-target。</li></ul><p id="926a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注入模态组件的实例当然是没有DOM连接的实例#1，而不是我需要的实例#2。</p><h2 id="897e" class="mz lt iq bd lu na nb dn ly nc nd dp mc lf ne nf me lj ng nh mg ln ni nj mi nk bi translated">解释</h2><p id="e406" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在DI解析过程中没有找到我的指令的原因(我得到<code class="fe ms mt mu mv b">No provider for…</code>错误的原因)是它不是模态组件的DOM树分支的一部分。</p><p id="af6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回顾我的指令放置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b2c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到我把它放在了<code class="fe ms mt mu mv b">app-child</code>的兄弟元素上。</p><p id="e069" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得它位于Angular DI从模态组件开始沿着DOM树向上走的路径之外，如下所示:</p><pre class="kg kh ki kj gt pa mv pb pc aw pd bi"><span id="f666" class="mz lt iq mv b gy pe pf l pg ph">4. app-root<br/>      ^<br/>3. app-child<br/>      ^<br/>2. app-grandchild<br/>      ^<br/>1. app-modal</span></pre><p id="317f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">寻找关于这些元素的指令。</p><p id="8da9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">app-child</code>是在迪决议的道路上；同级元素<code class="fe ms mt mu mv b">div.append-target</code>不是。</p><h1 id="95ec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">工作解决方案</h1><p id="ce42" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">事实证明，修复非常简单:只需将指令从<code class="fe ms mt mu mv b">div.append-target</code>移到<code class="fe ms mt mu mv b">app-child</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f699" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(再次非常感谢阿列克谢，他提供了解决方案，结束了我几天的沮丧。)</p><p id="eaac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它仍然在app-component模板中，因此它仍然可以访问<code class="fe ms mt mu mv b">myTarget</code>，但是这将它放置在Angular DI resolution路径中，并修复了一切。</p><p id="e991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了。！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/fe9b9b92550f4df07de9709192a7f069.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*w6fPJ8aEJrkrYtaQEGboxg.gif"/></div></figure><p id="5b54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是完整工作实现的StackBlitz:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pj my l"/></div></figure><h1 id="339c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">经验教训</h1><p id="f321" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这个过程中，我学到了一些有价值的东西，使我成为一个更好的角度开发者:</p><ol class=""><li id="1c06" class="om on iq ky b kz la lc ld lf oo lj op ln oq lr pk os ot ou bi translated">确保您的指令位于DI解析路径中。</li><li id="1675" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr pk os ot ou bi translated">如果你用它来和DOM交互，不要把你的指令添加到一个数组中，因为Angular会把它实例化为另一个类，和DOM没有任何联系。</li></ol><p id="1d4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢分享我的旅程！我希望有一天这至少能拯救一个人的痛苦和挫折。</p></div></div>    
</body>
</html>