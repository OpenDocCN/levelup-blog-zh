<html>
<head>
<title>Optimizing Performance Using the useMemo Hook in React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React.js中的useMemo钩子优化性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimizing-performance-using-the-usememo-hook-in-react-js-b8838df478c2?source=collection_archive---------2-----------------------#2021-12-16">https://levelup.gitconnected.com/optimizing-performance-using-the-usememo-hook-in-react-js-b8838df478c2?source=collection_archive---------2-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7c9147f4d70bc56a22f8b1ef23b5616b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ykly5QmI8kAX5G4w4ReJ4g.jpeg"/></div></div></figure><p id="a403" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天，我将介绍如何使用useMemo钩子来优化React.js应用程序中函数的性能。我们也将使用useState钩子，所以如果你不熟悉它，一定要看看我在这里的博客帖子！</p><div class="kz la gp gr lb lc"><a href="https://betterprogramming.pub/get-to-know-the-usestate-hook-in-react-js-d87797cb5a7" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">了解React.js中的UseState钩子</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">因为功能组件很牛逼</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">better编程. pub</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq jz lc"/></div></div></a></div><p id="556a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，这是一个到回购的链接，我将使用它来演示这里的功能！</p><div class="kz la gp gr lb lc"><a href="https://github.com/jonathanbrierre/usememo-demo" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">GitHub-jonathanbrierre/use memo-demo</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="lr l ln lo lp ll lq jz lc"/></div></div></a></div><p id="ffc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个有性能问题的应用程序。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/65451c7e1d1e12f5e7be54f3e891313c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*NjCNj8EQV79SBI39mSeX9g.gif"/></div></figure><p id="c5cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是加载该演示的<code class="fe lx ly lz ma b">App.jsx</code>的内容。</p><pre class="lt lu lv lw gt mb ma mc md aw me bi"><span id="017e" class="mf mg it ma b gy mh mi l mj mk">import { useState, useMemo } from 'react'<br/>import './App.css';</span><span id="c779" class="mf mg it ma b gy ml mi l mj mk">function App() {</span><span id="158b" class="mf mg it ma b gy ml mi l mj mk">const [color, setColor] = useState('#fffaaa')<br/>const [count, setCount] = useState(0);<br/>const twiceCount = doubleMyCount(count)</span><span id="2b05" class="mf mg it ma b gy ml mi l mj mk">const generateRandomColor = () =&gt; {<br/>    setColor( '#' + Math.floor(Math.random()*16777215).toString(16));<br/>}</span><span id="50c8" class="mf mg it ma b gy ml mi l mj mk">return (<br/>    &lt;div className="App"&gt;<br/>      &lt;div className="demo-container"&gt;<br/>        &lt;button <br/>          style={{backgroundColor: color}} <br/>          onClick={generateRandomColor} <br/>         &gt;<br/>          Click to change my color!<br/>         &lt;/button&gt;<br/>        &lt;button <br/>          onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}<br/>         &gt;<br/>          I have been clicked {count} times<br/>        &lt;/button&gt;<br/>        My double count = {twiceCount}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="aae2" class="mf mg it ma b gy ml mi l mj mk">const doubleMyCount = (count) =&gt; {<br/>  for(let i = 0; i &lt; 1000000000; i++) {}<br/>  return count * 2<br/>}<br/>export default App;</span></pre><p id="21dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您会看到有两个按钮，一个改变<code class="fe lx ly lz ma b">color</code>的组件状态，另一个改变<code class="fe lx ly lz ma b">count</code>的组件状态。<code class="fe lx ly lz ma b">twiceCount</code>变量引用一个函数的返回值，该函数内部有一个长时间运行的for循环。这个循环模拟一个运行并返回需要很长时间的函数。</p><p id="50cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">这里的问题</strong>是不管这个组件的状态如何变化，<code class="fe lx ly lz ma b">doubleMyCount</code>函数都会在整个组件重新呈现时运行。理想情况下，我们只希望在计数状态改变时运行<code class="fe lx ly lz ma b">doubleMyCount</code>函数，而不是在其他任何事情改变时运行。然而，即使点击顶部的按钮来改变颜色，也会调用<code class="fe lx ly lz ma b">doubleMyCount</code>。我们如何解决这个问题？</p><h1 id="8211" class="mm mg it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated"><strong class="ak">我们用备忘录！</strong></h1><p id="6b8a" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">useMemo挂钩使用起来超级简单！下面是我们的<code class="fe lx ly lz ma b">twiceCount</code>变量，声明时没有使用useMemo钩子:</p><pre class="lt lu lv lw gt mb ma mc md aw me bi"><span id="40bd" class="mf mg it ma b gy mh mi l mj mk">const twiceCount = doubleMyCount(count)</span></pre><p id="b098" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是使用备忘录挂钩:</p><pre class="lt lu lv lw gt mb ma mc md aw me bi"><span id="4a3b" class="mf mg it ma b gy mh mi l mj mk">const twiceCount = useMemo(() =&gt; {</span><span id="d675" class="mf mg it ma b gy ml mi l mj mk">   return doubleMyCount(count)</span><span id="2f8c" class="mf mg it ma b gy ml mi l mj mk">}, [count])</span></pre><p id="6c58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们增加了这里发生的事情的复杂性，<strong class="kd iu">让我们来分解一下！</strong></p><p id="d768" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">UseMemo是一个钩子，用来记忆函数的返回值。它接受两个参数:第一个是返回要记忆的值的函数，第二个是依赖数组。钩子监视传入这个依赖数组的值是否有任何变化。如果检测到依赖关系的变化，那么作为第一个参数传入的函数将再次运行。如果没有变化，那么useMemo钩子返回它在先前调用中存储的memoized值。</p><p id="ab46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里的演示中，我们只想在计数发生变化时调用<code class="fe lx ly lz ma b">doubleMyCount</code>函数，别无其他！所以我们将<code class="fe lx ly lz ma b">count</code>状态变量单独放在依赖数组中。现在，当我们改变颜色和组件重新呈现时，<code class="fe lx ly lz ma b">twiceCount</code>变量不会被重新计算，因为useMemo钩子返回一个记忆化的值。只有当计数按钮被点击并且<code class="fe lx ly lz ma b">count</code>状态被更新时，<code class="fe lx ly lz ma b">twiceCount</code>变量才会在下一次刷新时重新计算！</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/79151c07319349630bdf07db311cee80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*KQsozNxYkm5hH0gis7NCrw.gif"/></div></figure><h1 id="462a" class="mm mg it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">结论</h1><p id="a8cd" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">通过在组件呈现之间使用内存化，可以使用useMemo钩子来提高应用程序的性能。我希望你从这篇文章中学到了一些东西！</p><h1 id="772d" class="mm mg it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">参考</h1><div class="kz la gp gr lb lc"><a href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">钩子API参考-反应</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">reactjs.org</p></div></div><div class="ll l"><div class="no l ln lo lp ll lq jz lc"/></div></div></a></div></div></div>    
</body>
</html>