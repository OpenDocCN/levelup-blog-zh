<html>
<head>
<title>JavaScript Constructs that We Should Stop Using Now</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们现在应该停止使用的JavaScript结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-constructs-that-we-should-stop-using-now-293b2e84b4df?source=collection_archive---------17-----------------------#2020-03-23">https://levelup.gitconnected.com/javascript-constructs-that-we-should-stop-using-now-293b2e84b4df?source=collection_archive---------17-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3a53f3c19b2d687ffc3dc3395d15bbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IyDaBhP5c4WBA0G-"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约翰·马特丘克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="00c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript通过保留旧的结构来保持与旧应用程序的向后兼容性。</p><p id="b172" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在大多数情况下，它们已经过时，并被产生更干净、更具表达力的代码的新构造所取代。</p><p id="c111" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看那些我们现在应该停止或尽量减少使用的旧构造。</p><h1 id="0bfe" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">传统功能</h1><p id="807d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">传统函数是以关键字<code class="fe mh mi mj mk b">function</code>开头的函数。</p><p id="e64e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该再经常使用它们，因为我们有了类语法作为构造函数和箭头函数的语法糖，它们不关心<code class="fe mh mi mj mk b">this</code>的值。</p><h2 id="b317" class="ml lf it bd lg mm mn dn lk mo mp dp lo kr mq mr ls kv ms mt lw kz mu mv ma mw bi translated">提升</h2><p id="f256" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">传统函数也有两种不同的变体——函数声明和函数表达式。</p><p id="9ad4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数声明是这样编写的函数:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="6095" class="ml lf it mk b gy nf ng l nh ni">function foo() {<br/>  console.log('foo');<br/>}</span></pre><p id="0ee3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们被提升，这意味着它们被拉到代码的顶部，或者说被提升，是由JavaScript解释器自动完成的。</p><p id="d12f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以在它被定义之前调用它们:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="f0c0" class="ml lf it mk b gy nf ng l nh ni">foo();</span><span id="8a59" class="ml lf it mk b gy nj ng l nh ni">function foo() {<br/>  console.log('foo');<br/>}</span></pre><p id="58c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数表达式是分配给变量的传统函数:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="47a7" class="ml lf it mk b gy nf ng l nh ni">const foo = function() {<br/>  console.log('foo');<br/>}</span></pre><p id="c21e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在定义函数表达式之前调用它们，我们会得到一个错误。</p><p id="9644" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很混乱，很难记住。因此，编写传统函数很容易出错。</p><h2 id="1e78" class="ml lf it bd lg mm mn dn lk mo mp dp lo kr mq mr ls kv ms mt lw kz mu mv ma mw bi translated">遗产</h2><p id="5865" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">由于需要操作原型，构造函数也令人困惑。</p><p id="4aab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们必须写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="403d" class="ml lf it mk b gy nf ng l nh ni">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="9bcd" class="ml lf it mk b gy nj ng l nh ni">Person.prototype.fullName = function() {<br/>  return `${this.firstName} ${this.lastName}`;<br/>}</span></pre><p id="092c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个构造函数，然后向其中添加一个实例方法。</p><p id="84d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Person.prototype.fullName</code>是<code class="fe mh mi mj mk b">Person</code>的实例方法，<code class="fe mh mi mj mk b">Person</code>是构造函数。</p><p id="1bd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们要做的又一步，实例方法在函数之外，这和大多数面向对象语言不一样。</p><p id="6f72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，构造函数可以像其他面向对象语言一样用<code class="fe mh mi mj mk b">new</code>关键字实例化，但是我们使用函数而不是类来实例化它们，这使得这更令人困惑。</p><p id="ffdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们必须继承，那么事情会变得更加混乱和容易出错。</p><p id="34ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想要创建一个<code class="fe mh mi mj mk b">Employee</code>构造函数来扩展上面的<code class="fe mh mi mj mk b">Person</code>构造函数，我们必须编写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="caf6" class="ml lf it mk b gy nf ng l nh ni">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="79d4" class="ml lf it mk b gy nj ng l nh ni">Person.prototype.fullName = function() {<br/>  return `${this.firstName} ${this.lastName}`;<br/>}</span><span id="aa0b" class="ml lf it mk b gy nj ng l nh ni">function Employee(firstName, lastName, employeeCode) {<br/>  Person.call(this, firstName, lastName)<br/>  this.employeeCode = employeeCode;<br/>}</span><span id="ea28" class="ml lf it mk b gy nj ng l nh ni">Employee.prototype = Object.create(Person.prototype);</span><span id="2b61" class="ml lf it mk b gy nj ng l nh ni">Employee.prototype.getEmployeeCode = function() {<br/>  return this.employeeCode;<br/>}</span></pre><p id="2bc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有许多部分。我们要写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="43cf" class="ml lf it mk b gy nf ng l nh ni">Person.call(this, firstName, lastName)</span></pre><p id="bcf8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">Employee</code>构造函数中用call方法调用<code class="fe mh mi mj mk b">Person</code>构造函数。</p><p id="2369" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们必须通过使用<code class="fe mh mi mj mk b">Object.create</code>来扩展<code class="fe mh mi mj mk b">Person</code>的原型来设置<code class="fe mh mi mj mk b">Employee</code>的<code class="fe mh mi mj mk b">prototype</code>。</p><p id="e66f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要添加一个<code class="fe mh mi mj mk b">Employee</code>独有的实例，我们必须像处理<code class="fe mh mi mj mk b">getEmployeeCode</code>一样将方法添加到<code class="fe mh mi mj mk b">Employee</code>的原型中。</p><p id="fcbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们错过了这些步骤中的任何一步，我们都不会收到警告或错误。因此，很容易犯错误。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/fbb705dcd6e02fc3d31d62c947be9d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6iFUJwug68a-qnTV"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@kaip?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯·皮尔格</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="2f8d" class="ml lf it bd lg mm mn dn lk mo mp dp lo kr mq mr ls kv ms mt lw kz mu mv ma mw bi translated">类别语法</h2><p id="d675" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">类语法解决了上述所有问题。它们不能被提升，方法留在类中，我们用<code class="fe mh mi mj mk b">extends</code>关键字继承现有的类，用<code class="fe mh mi mj mk b">super</code>调用超类的构造函数。</p><p id="8a95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们的类扩展了另一个类，如果我们忘记调用<code class="fe mh mi mj mk b">super</code>，我们会得到错误。</p><p id="dbc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用如下的类语法重写<code class="fe mh mi mj mk b">Person</code>构造函数:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="3360" class="ml lf it mk b gy nf ng l nh ni">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }</span><span id="f8b0" class="ml lf it mk b gy nj ng l nh ni">  fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }<br/>}</span></pre><p id="919d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在它被定义之前引用它，我们会得到一个错误，</p><p id="5566" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，<code class="fe mh mi mj mk b">fullName</code>方法在类内部，而不是<code class="fe mh mi mj mk b">Person</code>的<code class="fe mh mi mj mk b">prototype</code>的属性，</p><p id="ffed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一样的，但是干净多了。</p><p id="398b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建一个扩展了<code class="fe mh mi mj mk b">Person</code>类的<code class="fe mh mi mj mk b">Employee</code>类，我们编写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="6db9" class="ml lf it mk b gy nf ng l nh ni">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }</span><span id="4a3f" class="ml lf it mk b gy nj ng l nh ni">  fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }<br/>}</span><span id="a4a3" class="ml lf it mk b gy nj ng l nh ni">class Employee extends Person {<br/>  constructor(firstName, lastName) {<br/>    super(firstName, lastName)<br/>  }</span><span id="6ce7" class="ml lf it mk b gy nj ng l nh ni">  getEmployeeCode() {<br/>    return this.employeeCode;<br/>  }<br/>}</span></pre><p id="9e90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，我们刚刚添加了<code class="fe mh mi mj mk b">extends</code>关键字，调用父类的构造函数的<code class="fe mh mi mj mk b">super</code>调用，然后将我们自己的<code class="fe mh mi mj mk b">getEmployeeCode</code>方法添加到<code class="fe mh mi mj mk b">Employee</code>类中。</p><p id="b6e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在类声明中有<code class="fe mh mi mj mk b">extends</code>，那么如果我们遗漏了<code class="fe mh mi mj mk b">super</code>，我们就会得到错误。</p><h1 id="0bf3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参数对象</h1><p id="0eae" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在使用rest操作符之前，我们必须使用<code class="fe mh mi mj mk b">arguments</code>对象将所有参数传递给一个函数。</p><p id="60a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">arguments</code>对象是一个类似数组的对象，这意味着它有索引和<code class="fe mh mi mj mk b">length</code>属性。但是它没有任何数组方法。</p><p id="ed94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还是那句话，这很有欺骗性。</p><p id="1e01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用rest操作符，我们得到一个返回的数组，所以我们可以使用数组方法。</p><p id="c1d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mx my mz na gt nb mk nc nd aw ne bi"><span id="f0d7" class="ml lf it mk b gy nf ng l nh ni">const foo = (...args) =&gt; console.log(args.join(','))<br/>foo(1, 2, 3, 4, 5);</span></pre><p id="b48b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">...args</code>是休息操作。这3个点是rest操作符，<code class="fe mh mi mj mk b">args</code>有传入的参数数组。</p><p id="00c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在<code class="fe mh mi mj mk b">args</code>上调用<code class="fe mh mi mj mk b">join</code>方法，所以我们知道它是一个数组。</p><p id="2c9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也适用于传统的箭头函数，然而，<code class="fe mh mi mj mk b">arguments</code>不适用于箭头函数。</p><h1 id="61e9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="4fe8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">旧的结构保存在JavaScript中，所以旧的应用程序不会崩溃。然而，这并不意味着我们应该使用它们。</p><p id="a6cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该开始使用新的构造，比如类语法和rest操作符，因为它们更干净，欺骗性和迷惑性更小。</p></div></div>    
</body>
</html>