<html>
<head>
<title>MQTT over WebSocket in a React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React应用程序中WebSocket上的MQTT</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mqtt-over-websocket-in-a-react-app-35ce96cd0844?source=collection_archive---------5-----------------------#2020-01-29">https://levelup.gitconnected.com/mqtt-over-websocket-in-a-react-app-35ce96cd0844?source=collection_archive---------5-----------------------#2020-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/1fca6519f53b1f93c52a41e29c6297c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*U9xCExMct8MpTgWRY6l2Zg.png"/></div></figure><p id="b201" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最近，我不得不在一个React web应用程序中使用MQTT over WebSocket从一个API获取实时位置。以下是我的解决方案。我试图让MQTT模块尽可能地具有功能性。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ks"><img src="../Images/a6e5d7b7a8b547a43b22727cede1c893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JcDwisxNU9zTl-RA"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">约翰·汤纳在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="71c6" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">MQTT服务模块</h1><p id="9cf2" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi translated">我用过mqtt npm包，你可以用<strong class="jw ir"> npm install mqtt </strong> <em class="mj"> </em>命令来安装。这是我创建的MQTT模块:</p><pre class="kt ku kv kw gt mk ml mm mn aw mo bi"><span id="ccc4" class="mp lh iq ml b gy mq mr l ms mt">import mqtt from "mqtt";</span><span id="ca01" class="mp lh iq ml b gy mu mr l ms mt">const websocketUrl = "wss://&lt;SERVER-ADDRESS&gt;:443/mqtt";<br/>const apiEndpoint = "&lt;API-ENDPOINT&gt;/";</span><span id="ac8b" class="mp lh iq ml b gy mu mr l ms mt">function getClient(errorHandler) {<br/>  const client = mqtt.connect(websocketUrl);<br/>  client.stream.on("error", (err) =&gt; {<br/>    errorHandler(`Connection to ${websocketUrl} failed`);<br/>    client.end();<br/>  });<br/>  return client;<br/>}</span><span id="9dcc" class="mp lh iq ml b gy mu mr l ms mt">function subscribe(client, topic, errorHandler) {<br/>  const callBack = (err, granted) =&gt; {<br/>    if (err) {<br/>      errorHandler("Subscription request failed");<br/>    }<br/>  };<br/>  return client.subscribe(apiEndpoint + topic, callBack);<br/>}</span><span id="04bc" class="mp lh iq ml b gy mu mr l ms mt">function onMessage(client, callBack) {<br/>  client.on("message", (topic, message, packet) =&gt; {<br/>    callBack(JSON.parse(new TextDecoder("utf-8").decode(message)));<br/>  });<br/>}</span><span id="7d4f" class="mp lh iq ml b gy mu mr l ms mt">function unsubscribe(client, topic) {<br/>  client.unsubscribe(apiEndpoint + topic);<br/>}</span><span id="309f" class="mp lh iq ml b gy mu mr l ms mt">function closeConnection(client) {<br/>  client.end();<br/>}</span><span id="5998" class="mp lh iq ml b gy mu mr l ms mt">const mqttService = {<br/>  getClient,<br/>  subscribe,<br/>  onMessage,<br/>  unsubscribe,<br/>  closeConnection,<br/>};</span><span id="6dd1" class="mp lh iq ml b gy mu mr l ms mt">export default mqttService;</span></pre><h1 id="80c0" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">开始连接</h1><p id="6338" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi mv translated"><span class="l mw mx my bm mz na nb nc nd di">在</span>app中，我在<strong class="jw ir"> useEffect </strong>钩子中启动MQTT连接，并将MQTT客户端保存在Redux store中。函数<strong class="jw ir"> storeError </strong>来自我的Redux reducer，它用于存储错误消息，我在创建客户端时将它作为回调函数传递。<strong class="jw ir">回调</strong>功能是将新收到的mqtt消息传递给消息处理程序。最后<strong class="jw ir"> useEffect </strong>钩子返回组件卸载(关闭连接)时要调用的函数。</p><pre class="kt ku kv kw gt mk ml mm mn aw mo bi"><span id="46af" class="mp lh iq ml b gy mq mr l ms mt">import mqttService from "./path/to/mqttWwebsocket";</span><span id="a764" class="mp lh iq ml b gy mu mr l ms mt">...<br/>....</span><span id="478a" class="mp lh iq ml b gy mu mr l ms mt">useEffect(() =&gt; {<br/>  const client = mqttService.getClient(storeError);<br/>  storeMqttClient(client);<br/>  const callBack = (mqttMessage) =&gt; handleMessage(mqttMessage);<br/>  mqttService.onMessage(client, callBack);<br/>  return () =&gt; mqttService.closeConnection(client);<br/>}, []);<br/>...<br/>....</span></pre><h1 id="f44e" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">订阅和退订MQTT主题</strong></h1><p id="5761" class="pw-post-body-paragraph ju jv iq jw b jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ij bi mv translated">我有一个表，用户可以从这个表中选择跟随哪个位置(这将是MQTT术语中的主题)。当用户从表中选择不同的行时，应用程序取消订阅旧主题，并订阅新主题。</p><pre class="kt ku kv kw gt mk ml mm mn aw mo bi"><span id="7059" class="mp lh iq ml b gy mq mr l ms mt">function rowSelectionHandler(newTopic) {<br/> const topicHasChanged = // Check if I the topic has changed<br/> const topic = // The current topic<br/> if (topicHasChanged) {<br/>   mqttService.unsubscribe(mqttClient, topic);<br/> }<br/> mqttService.subscribe(mqttClient, newTopic, storeError);<br/>}</span></pre></div></div>    
</body>
</html>