<html>
<head>
<title>Build a web, iOS, and Android app with a GraphQL server — understand the whole system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL服务器构建web、iOS和Android应用程序——了解整个系统</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-simple-system-with-ios-android-react-node-js-and-graphql-cb74d2c400fe?source=collection_archive---------3-----------------------#2019-12-01">https://levelup.gitconnected.com/build-a-simple-system-with-ios-android-react-node-js-and-graphql-cb74d2c400fe?source=collection_archive---------3-----------------------#2019-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/81ae8386a9ff3f2424010446b7466807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQCTgmz5I-ae0wKzbnsLKQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@perrygrone" rel="noopener ugc nofollow" target="_blank">佩里·格罗内</a>在<a class="ae kf" href="https://unsplash.com/photos/lbLgFFlADrY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="80ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天要构建一个完整的解决方案，我们至少需要四个组件:移动(iOS和Android)、web和提供所需数据的服务器。</p><p id="5f10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些组件中的每一个都需要广泛的知识来构建。因此，很难找到一个包含所有示例的页面。</p><p id="f70a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鉴于这一事实，我决定构建一个简单的系统来连接所有这些组件，希望它可以作为只熟悉其中一个组件并希望学习其他部分的开发人员的参考。</p><h1 id="8e9c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">计划中的简单系统</h1><p id="1090" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了用工作代码演示所有组件，我构建了一个简单的系统，从Wikipedia Open API获取一些数据。用户只需向API发送一个关键词，API就会返回该关键词在维基百科中被使用的次数。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/a7e3b5f77d4bed9c1a2baf9d745c19bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*rhzrd9ZjCjN_0XlU9fUbWQ.png"/></div></figure><p id="bdac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我明确地选择了这个简单的例子，以便学习围绕着为所有组件构建系统，而不是关注API的复杂性。</p><p id="1921" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这里，我们扩展我们的系统，使其可以从<strong class="ki iu"> iOS </strong>、<strong class="ki iu"> Android、</strong>和<strong class="ki iu"> web </strong> ( <strong class="ki iu"> React </strong>)进行访问。最重要的是，我们有一个中间服务器(使用<strong class="ki iu"> Node.js </strong>)并使用<strong class="ki iu"> GraphQL </strong>作为通信手段，以形成一个我们完全控制的完整系统。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/3193e1e201e00e56626db9a5c28729a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*NSHb9Nm2aU4aTOA6PVhCqQ.png"/></div></figure><p id="8f90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者在图表中，您将能够获得基于以下组件构建的系统。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/fd6d6a2e31cacdcaf50fa1f11549583b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssGLLXyxWfRMxAqw2Let2g.png"/></div></div></figure><p id="0c1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在下面得到整个系统的代码(<strong class="ki iu"> iOS，Android，React，Node.js，Graphql </strong></p><div class="mo mp gp gr mq mr"><a href="https://github.com/elye/demo_graphql_fullstack_mobile" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">elye/demo _ graph QL _ full stack _ mobile</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf jz mr"/></div></div></a></div><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/502ed4a4a8bc93c6810e6b9e89190705.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*fAipG9kmXsrtBJWeeQ86FQ.png"/></div></figure><h1 id="2071" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Node.js服务器</h1><p id="912e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，我有一个<em class="nh"> Node.js </em>服务器。要运行它，只需转到<em class="nh">服务器</em>文件夹，并键入<code class="fe ni nj nk nl b">yarn start</code>。(如果你不确定什么是纱线，可以看看<a class="ae kf" href="https://medium.com/@elye.project/know-yarn-before-learning-node-js-bf39a50fb27f" rel="noopener">这篇博客</a>)。</p><blockquote class="nm nn no"><p id="95a3" class="kg kh nh ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">注意:在<code class="fe ni nj nk nl b">yarn start</code>之前，你需要先运行<code class="fe ni nj nk nl b">yarn install</code>来安装包</p></blockquote><blockquote class="ns"><p id="9951" class="nt nu it bd nv nw nx ny nz oa ob ld dk translated"><code class="fe ni nj nk nl b">🚀 Server ready at <a class="ae kf" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/</a></code></p></blockquote><p id="a114" class="pw-post-body-paragraph kg kh it ki b kj oc kl km kn od kp kq kr oe kt ku kv of kx ky kz og lb lc ld im bi translated">Node.js是在机器上设置的最简单的服务器之一。没有的话只需要<em class="nh"> npm </em>或者<em class="nh">纱</em>安装即可。</p><p id="c75a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，在您希望创建Node.js服务器的文件夹中，使用<code class="fe ni nj nk nl b">npm init</code>或<code class="fe ni nj nk nl b">yarn init</code>命令创建一个合适的包，其中<em class="nh"> package.json </em>将被初始化。</p><p id="db6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">修改您的包以包含一个要运行的<em class="nh"> start </em>脚本:</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="fae8" class="ol lf it nl b gy om on l oo op">{<br/>  "name": "simpleserver",<br/>  "version": "1.0.0",<br/>  "description": "Simple Server with Graphql",<br/>  "main": "index.js",<br/>  "dependencies": {<br/>    "apollo-datasource-rest": "^0.6.6",<br/>    "apollo-server": "^2.9.9",<br/>    "graphql": "^14.5.8"<br/>  },<br/>  "devDependencies": {},<br/>  "scripts": {<br/><strong class="nl iu">    "start": "node src/index.js",</strong><br/>    "test": "No test"<br/>  },<br/>  "author": "author (author@gmail.com)",<br/>  "license": "Apache-2.0"<br/>}</span></pre><p id="2f4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦有了正确的JavaScript代码，就可以使用<code class="fe ni nj nk nl b">npm start</code>或<code class="fe ni nj nk nl b">yarn start</code>来启动节点服务器。</p><p id="ce7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要了解Node.js的基础知识，请参考:</p><div class="mo mp gp gr mq mr"><a href="https://www.w3schools.com/nodejs/default.asp" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">Node.js教程</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">我们的“Show Node.js”工具使学习Node.js变得容易，它显示代码和结果。var http =…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">www.w3schools.com</p></div></div><div class="na l"><div class="oq l nc nd ne na nf jz mr"/></div></div></a></div><h2 id="1662" class="ol lf it bd lg or os dn lk ot ou dp lo kr ov ow ls kv ox oy lw kz oz pa ma pb bi translated">维基百科API</h2><p id="a598" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们创建的Node.js服务器是为了在Wikipedia open API和所有客户端(Web、iOS和Android)之间形成一个中间服务，以便它只为向客户端发送数据提供服务。</p><p id="cf5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的功能是获取关键字并执行对维基百科开放API的提取，如下所示。</p><p id="fd8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">API是<a class="ae kf" href="https://en.wikipedia.org/w/api.php" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/w/api.php</a>，具有以下参数:</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="5730" class="ol lf it nl b gy om on l oo op">“action” =  “query”,<br/>“format” =  “json”,<br/>“list” = “search”,<br/>"srsearch" = &lt;Something to Provide&gt;</span></pre><p id="015c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://en.wikipedia.org/w/api.php?action=query&amp;format=json&amp;list=search&amp;srsearch=Networking" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/w/api.php?action=query&amp;format = JSON&amp;list = search&amp;Sr search = Networking</a>会生成下面这个。注意，<code class="fe ni nj nk nl b">totalhits</code>是我们想要得到的。</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="70c9" class="ol lf it nl b gy om on l oo op">{   batchcomplete: "",<br/>    continue: {<br/>       sroffset: 10,<br/>       continue: "-||"<br/>    },<br/>    query: {<br/>       searchinfo: {<br/><strong class="nl iu">          totalhits: 399303</strong><br/>       }, ...</span></pre><h2 id="6cdc" class="ol lf it bd lg or os dn lk ot ou dp lo kr ov ow ls kv ox oy lw kz oz pa ma pb bi translated">GraphQL服务</h2><p id="a64d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们希望Node.js服务器不仅能以静态JSON格式提供从维基百科获得的全部结果，还能以动态格式提供。这里的动态意味着，数据的内容(需要什么信息)由客户端决定。这可以通过使用<a class="ae kf" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">图表QL </a>来实现。</p><p id="ac6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个简单的例子是，如果您启动了GraphQL服务器，您可以决定它可以获得的支付数据格式。下面是两个例子(左边是查询，右边是结果)</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/b1a5faa3a29f2651220d6afc6c95e364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8oTDO8I_9rQic1ZpE2P9Nw.png"/></div></div></figure><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/a32a910df61c0457be73f42b954a2b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQfiIhgyck5ate60gGBJWQ.png"/></div></div></figure><blockquote class="nm nn no"><p id="ea53" class="kg kh nh ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">上面视图是从https://electronjs.org/apps/graphiql<a class="ae kf" href="https://electronjs.org/apps/graphiql" rel="noopener ugc nofollow" target="_blank">的GraphiQL工具获得的</a></p></blockquote><h2 id="02a5" class="ol lf it bd lg or os dn lk ot ou dp lo kr ov ow ls kv ox oy lw kz oz pa ma pb bi translated">阿波罗服务器</h2><p id="bf9d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了从我们的<em class="nh"> Node.js </em>服务器启用GraphQL服务，我们使用了<a class="ae kf" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> <em class="nh"> Apollo GraphQL </em>库</a>。</p><p id="42a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在https://www.apollographql.com/docs/tutorial/introduction/有一个教程。有关代码的服务器部分，请参考第0节到第3节。</p><p id="2532" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总的来说，我创建的简单的<em class="nh"> Node.js </em>服务器如下所示</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/be8fa559d89633b1dd65dc1eff84161d.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*_-tkv-tft2lKIScs2tuw3g.png"/></div></figure><p id="bcda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至于模式，我们将其定义如下:</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="0431" class="ol lf it nl b gy om on l oo op">const typeDefs = gql`<br/>  type Query {<br/>    wikiCount(keyword: String!): WikiCount<br/>  }<br/>  type WikiCount {<br/>    keyword: String!<br/>    totalhits: String<br/>  }<br/>`;</span></pre><p id="a1c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个解析器查询，如下所示:</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="19aa" class="ol lf it nl b gy om on l oo op">async getWikiCountByKeyword({ keyword }) {<br/>  const response = await this.get('api.php',<br/>      [["action", "query"], <br/>       ["format", "json"], <br/>       ["list", "search"], <br/>       ["srsearch", keyword]]);<br/>  return this.wikiCountReducer(<br/>      keyword, response.query.searchinfo.totalhits);<br/>}</span></pre><p id="b7ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多信息，请参考GitHub中的代码。</p><p id="fac8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，当您使用浏览器访问该网站时，您将会看到如下内容，显示可用的服务。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pf"><img src="../Images/2602f32ac523f2eee271754272b9e3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWqz_PfijrMR1R2-5Nbh3A.png"/></div></div></figure><p id="f058" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">左边是您的输入查询，请求您想要的输出。中间是结果(按下播放按钮后生成)。右边是我们在<em class="nh"> Node.js </em>服务器中定义的模式。</p><h1 id="e13a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">React Web客户端</h1><p id="5cac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">接下来，我们来看看Web客户端。</p><p id="a3a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用任何web客户端，只要它们能够执行POST请求。这里我只关注使用<em class="nh"> React </em>，因为它也是用<em class="nh"> JavaScript </em>编写的，并且很好地补充了<em class="nh"> Node.js </em>。</p><p id="9694" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要启动<em class="nh"> React </em> Web客户端，只需转到<em class="nh"> client-web </em>文件夹，并执行命令<code class="fe ni nj nk nl b">yarn start</code></p><p id="d3cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将自动启动浏览器并自动打开<code class="fe ni nj nk nl b">localhost:3000</code>站点，用户界面如下所示。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pg"><img src="../Images/efa560546c9899fa4dadbcd6fe53e360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkZpLIbwMYJ30jB7PBP--Q.png"/></div></div></figure><p id="9516" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我实现了两种抓取方法。一种是使用Apollo GraphQL客户端react包库。另一个只是常规的POST请求。</p><blockquote class="nm nn no"><p id="2023" class="kg kh nh ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">要学习React，参考这个网站<a class="ae kf" href="https://reactjs.org/tutorial/tutorial.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/tutorial/tutorial.html</a>，让你创建一个简单的游戏。</p></blockquote><h2 id="a06c" class="ol lf it bd lg or os dn lk ot ou dp lo kr ov ow ls kv ox oy lw kz oz pa ma pb bi translated">阿波罗网络客户端</h2><p id="45b2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在https://www.apollographql.com/docs/tutorial/introduction/可以找到<em class="nh"> React </em>的官方Apollo Web客户端教程。关于我们代码中提到的Web客户端，请参考第5到6节。</p><p id="fa67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的代码中，我们首先将<code class="fe ni nj nk nl b">ApolloClient</code>包装在我们的应用程序中。</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="18c6" class="ol lf it nl b gy om on l oo op">const cache = new InMemoryCache();<br/>const link = new HttpLink({<br/>    uri: <strong class="nl iu"><em class="nh">SERVERURL<br/></em></strong>});<br/><br/>const client = new ApolloClient({<br/>    cache,<br/>    link<br/>});<br/><br/>ReactDOM.render(<br/>    &lt;ApolloProvider client={client}&gt;<br/>        &lt;App/&gt;<br/>    &lt;/ApolloProvider&gt;, <strong class="nl iu"><em class="nh">document</em></strong>.getElementById('root')<br/>);</span></pre><p id="3e91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在获取端，首先我们定义查询(即<code class="fe ni nj nk nl b">GET_WIKI_HIT</code>)</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="03e0" class="ol lf it nl b gy om on l oo op">const GET_WIKI_HIT = gql`<br/>    query GetWikicountByKeyword($keyword: String!) {<br/>        wikiCount(keyword: $keyword) {<br/>            keyword<br/>            totalhits<br/>        }<br/>    }<br/>`;</span></pre><p id="2499" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有一个获取函数，它结合了整个搜索框、按钮和结果文本的创建。它使用了一种<em class="nh"> React Hook </em>方法，这种方法会根据状态而改变。</p><blockquote class="nm nn no"><p id="6d07" class="kg kh nh ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">为了更好地理解React Hook，请参考POST Web Client方法。</p></blockquote><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="ad80" class="ol lf it nl b gy om on l oo op">export default function FetchApollo() {<br/>        const [keyword, setKeyword] = React.useState("");<br/>        const {data, loading, error} = <br/>            useQuery(GET_WIKI_HIT, {variables: {keyword: keyword}});<br/><br/>        let result<br/>        if (keyword === "") result = "No Result";<br/>        else if (loading) result = "loading"<br/>        else if (error) result = error.message;<br/>        else result = <br/>            data.wikiCount.keyword + ":" + data.wikiCount.totalhits;<br/><br/>        return (<br/>            &lt;div&gt;<br/>                &lt;div&gt;&lt;SearchBox caption={"Apollo Wiki Search"} <br/>                     onSubmit={(keyword) =&gt; <br/>                     setKeyword(keyword)}/&gt;&lt;/div&gt;</span><span id="d261" class="ol lf it nl b gy ph on l oo op">                {loading &amp;&amp; keyword !== "" ?<br/>                    (&lt;Loading /&gt;) :<br/>                    (&lt;div&gt;&lt;SearchResult value={result}/&gt;&lt;/div&gt;)<br/>                }<br/><br/>            &lt;/div&gt;<br/>        );<br/>}</span></pre><h2 id="405a" class="ol lf it bd lg or os dn lk ot ou dp lo kr ov ow ls kv ox oy lw kz oz pa ma pb bi translated">HTTP Post Web客户端</h2><p id="f208" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">除了使用Apollo客户端帮助获取GraphQL结果，我们还可以使用传统的HTTP Post，正如在https://graphql.org/learn/serving-over-http/中提到的</p><p id="aeba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，这是一个post请求，JSON主体为:</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="9ff8" class="ol lf it nl b gy om on l oo op">{<br/>  "query": "...",<br/>  "operationName": "...",<br/>  "variables": { "myVariable": "someValue", ... }<br/>}</span></pre><p id="53df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以对于我们的查询，我们做如下:</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="bb49" class="ol lf it nl b gy om on l oo op">const query = `<br/>query GetWikicountByKeyword($keyword: String!) {<br/>    wikiCount<br/>        (keyword: $keyword) {<br/>            keyword <br/>            totalhits<br/>        } <br/>}`</span><span id="840e" class="ol lf it nl b gy ph on l oo op">// and </span><span id="3344" class="ol lf it nl b gy ph on l oo op">const body = {<br/>    query: query,<br/>    variables : { keyword }<br/>};</span></pre><p id="0ad0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还使用React钩子方法按照中的指导执行获取</p><div class="mo mp gp gr mq mr"><a href="https://www.robinwieruch.de/react-hooks-fetch-data" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">如何用React钩子取数据？- RWieruch</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">在本教程中，我想向您展示如何通过使用状态和效果挂钩在React with Hooks中获取数据。我们会…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">www.robinwieruch.de</p></div></div><div class="na l"><div class="pi l nc nd ne na nf jz mr"/></div></div></a></div><h1 id="0885" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Android客户端</h1><p id="209c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们继续移动客户端。首先，我们来看看Android。</p><p id="395b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Android也有两种方法，1 .HTTP Post方法；2.Apollo GraphQL库方法。</p><blockquote class="nm nn no"><p id="7fd1" class="kg kh nh ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">但是首先，要使用它，您需要将<code class="fe ni nj nk nl b"><a class="ae kf" href="http://ENTER_YOUR_HOST_HERE:4000" rel="noopener ugc nofollow" target="_blank"><em class="it">ENTER_YOUR_HOST_HERE</em></a></code>更改为您的本地主机IP。您可以在终端上使用<code class="fe ni nj nk nl b"><em class="it">ifconfig</em></code>命令找到它。</p></blockquote><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/da53566c2d59622eb967d530f59d7003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*JJWVFE4PnqZzrtfhmKK6aw.png"/></div></figure><h2 id="e014" class="ol lf it bd lg or os dn lk ot ou dp lo kr ov ow ls kv ox oy lw kz oz pa ma pb bi translated">HTTP Post Android客户端</h2><p id="34ff" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我指的是基本网络(检查Android端)</p><div class="mo mp gp gr mq mr"><a href="https://medium.com/better-programming/learn-ios-android-networking-e19808f554a7" rel="noopener follow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">学习iOS/Android:网络</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">探索Alamofire (iOS)和okHttp (Android)</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">medium.com</p></div></div><div class="na l"><div class="pk l nc nd ne na nf jz mr"/></div></div></a></div><p id="1203" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与教程的不同之处在于，我执行的是POST而不是GET。</p><p id="1549" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我形成如下的查询:</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="9c7c" class="ol lf it nl b gy om on l oo op">companion object {<br/>    private val queryString = """<br/>        query GetWikicountByKeyword(${"$"}keyword: String!){ <br/>            wikiCount(keyword: ${"$"}keyword) {<br/>                keyword <br/>                totalhits<br/>            }<br/>        }<br/>        """.<em class="nh">trimIndent</em>().<em class="nh">replace</em>("\n", "")<br/>}</span></pre><p id="ad54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我手动创建要发布的JSON主体。注意，我将请求和标题都设置为<code class="fe ni nj nk nl b">application/json</code>。</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="0fe9" class="ol lf it nl b gy om on l oo op">val params = HashMap&lt;String, String&gt;()<br/><strong class="nl iu">params["query"] = queryString<br/>params["variables"] = "{\"keyword\": \"${searchText}\"}"</strong><br/>val body = JSONObject(params)<br/>    .toString().<em class="nh">toRequestBody</em>(<strong class="nl iu">"application/json; charset=utf-8"</strong>.<em class="nh">toMediaType</em>())<br/><br/>val httpUrl = httpUrlBuilder.build()<br/>val request = Request.Builder()<br/>    .header(<strong class="nl iu">"Content-Type", "application/json"</strong>)<br/>    .url(httpUrl)<br/>    .post(body)<br/>    .build()<br/>val response = httpClient.newCall(request).execute()</span></pre><blockquote class="nm nn no"><p id="f9cb" class="kg kh nh ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">注意:对于上面的代码，我使用了<code class="fe ni nj nk nl b">‘com.squareup.okhttp3:okhttp:4.2.2’</code>，它在设置类型等方面有整洁的Kotlin扩展函数。</p></blockquote><h2 id="4618" class="ol lf it bd lg or os dn lk ot ou dp lo kr ov ow ls kv ox oy lw kz oz pa ma pb bi translated">阿波罗安卓客户端</h2><p id="fbb3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这是通过按照中的步骤完成的</p><div class="mo mp gp gr mq mr"><a href="https://www.apollographql.com/docs/android/essentials/get-started/" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">开始</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">Apollo-Android是一个符合GraphQL的客户机，它从标准的GraphQL查询生成Java模型。这些模型…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">www.apollographql.com</p></div></div><div class="na l"><div class="pl l nc nd ne na nf jz mr"/></div></div></a></div><p id="f2d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我在下面陈述几个重要的步骤。</p><p id="cd0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">准备模式和GraphQL文件</strong></p><p id="6e6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让Apollo客户端工作，我们需要<em class="nh">模式</em>和<em class="nh"> graphql文件</em>用于稍后的自动代码生成。</p><p id="aafe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要有一个<em class="nh"> schema.json </em>文件，您需要有一个<code class="fe ni nj nk nl b"><a class="ae kf" href="https://github.com/apollographql/apollo-tooling#usage" rel="noopener ugc nofollow" target="_blank">apollo-codegen</a></code>，它可以使用命令获得。</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="2948" class="ol lf it nl b gy om on l oo op">yarn global add apollo</span></pre><blockquote class="nm nn no"><p id="0c48" class="kg kh nh ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">如果你想了解<em class="it">纱线</em>的话，可以看看这个博客</p></blockquote><p id="3db8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，你的机器上应该有<code class="fe ni nj nk nl b">apollo</code>可以使用。</p><p id="7556" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后只需输入下面的命令，从我们的服务器中提取出<em class="nh"> schema.json </em>。它基本上是我们在服务器中定义的模式的JSON格式。</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="efea" class="ol lf it nl b gy om on l oo op">apollo schema:download — endpoint=http://localhost:4000 schema.json</span></pre><p id="700d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，手动创建所有查询GraphQL文件。在我们的例子中，我们只有一个。</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="25d5" class="ol lf it nl b gy om on l oo op">query GetWikicountByKeyword($keyword: String!){<br/>    wikiCount(keyword: $keyword) {<br/>        keyword<br/>        totalhits<br/>    }<br/>}</span></pre><p id="8834" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把它们放在下面的文件夹里。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pm"><img src="../Images/cffabb221dce390442d7a014e37797a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnFw6oZjdgqWkmuvR5qZHg.png"/></div></div></figure><p id="05e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">设置代码自动生成依赖关系</strong></p><p id="d3be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，添加下面的<strong class="ki iu">项目</strong><strong class="ki iu"><em class="nh">build . gradle</em></strong></p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="6601" class="ol lf it nl b gy om on l oo op">classpath 'com.apollographql.apollo:apollo-gradle-plugin:1.0.0'</span></pre><p id="4d8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<strong class="ki iu">app</strong><strong class="ki iu"><em class="nh">build . gradle</em></strong>的头部分添加以下内容</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="3740" class="ol lf it nl b gy om on l oo op">apply plugin: 'com.apollographql.android'</span></pre><blockquote class="nm nn no"><p id="b299" class="kg kh nh ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">这两个工具将允许基于graphql查询和模式自动生成特定的apollo查询代码。它将在<em class="it">app/build/generated/source/Apollo/class</em>文件夹中生成。</p></blockquote><p id="25ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">设置库依赖关系</strong></p><p id="62c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在将以下内容添加到您的<strong class="ki iu">应用程序<em class="nh">build . gradle</em>T12】</strong></p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="671f" class="ol lf it nl b gy om on l oo op">implementation 'com.apollographql.apollo:apollo-runtime:1.0.0'<br/>implementation "com.apollographql.apollo:apollo-android-support:1.0.0"</span></pre><p id="99a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">执行同步，您就可以开始编码了。</p><p id="b87d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">提取器代码</strong></p><p id="ea42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们从<em class="nh"> OkHttp </em>创建网络客户端，并设置<em class="nh"> ApolloClient </em>。</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="9d1d" class="ol lf it nl b gy om on l oo op">object ApolloConnector {<br/>    private const val SERVER_URL = "http://ENTER_HOST_HERE:4000"<br/>    fun setupApollo(): ApolloClient {<br/>        val okHttpClient = OkHttpClient.Builder().build()<br/>        return ApolloClient.builder()<br/>           .serverUrl(BASE_URL).okHttpClient(okHttpClient).build()<br/>    }<br/>}</span></pre><p id="c232" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在代码的获取部分，设置自动生成的类<code class="fe ni nj nk nl b">GetWikicountByKeywordQuery</code>，如下所示。然后检索结果或提取错误消息。</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="502a" class="ol lf it nl b gy om on l oo op">ApolloConnector.setupApollo().query(<br/>    // Autogenerated Query Class<br/><strong class="nl iu">    GetWikicountByKeywordQuery<br/>        .builder()<br/>        .keyword(keyword)<br/>        .build()</strong><br/>)<br/>    .enqueue(object : ApolloCall.Callback&lt;<strong class="nl iu">GetWikicountByKeywordQuery</strong>.Data&gt;() {<br/>        override fun onResponse(response: <br/>            Response&lt;<strong class="nl iu">GetWikicountByKeywordQuery</strong>.Data&gt;) {<br/>            response.data()?.wikiCount?.<em class="nh">run </em><strong class="nl iu">{<br/>                </strong>showApolloResult("${keyword()}:${totalhits()}")<br/>            <strong class="nl iu">} </strong>?: showApolloResult("No Result")<br/>        }<br/><br/>        override fun onFailure(e: ApolloException) {<br/>            showApolloResult(e.<em class="nh">localizedMessage</em>)<br/>        }<br/>    })</span></pre><h1 id="49d1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">iOS客户端</h1><p id="d2c5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们来看看iOS。与Web客户端和Android客户端类似，iOS也有两种方法，1。阿波罗GraphQL库方法:2.HTTP Post方法</p><blockquote class="nm nn no"><p id="1f28" class="kg kh nh ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">但是首先，要使用它，您需要将<code class="fe ni nj nk nl b"><a class="ae kf" href="http://ENTER_YOUR_HOST_HERE:4000" rel="noopener ugc nofollow" target="_blank"><em class="it">ENTER_YOUR_HOST_HERE</em></a></code>更改为您的本地主机IP。你可以在你的终端上使用<code class="fe ni nj nk nl b"><em class="it">ifconfig</em></code>命令找到它。</p></blockquote><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/13ff8c2c03f5fdfeb1ae9e7659e46ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*xjbcKRYwm9IweURxc5RunA.png"/></div></figure><h2 id="2c69" class="ol lf it bd lg or os dn lk ot ou dp lo kr ov ow ls kv ox oy lw kz oz pa ma pb bi translated">HTTP Post Android客户端</h2><p id="bfd9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我指的是基本网络(查看iOS端)</p><div class="mo mp gp gr mq mr"><a href="https://medium.com/better-programming/learn-ios-android-networking-e19808f554a7" rel="noopener follow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">学习iOS/Android:网络</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">探索Alamofire (iOS)和okHttp (Android)</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">medium.com</p></div></div><div class="na l"><div class="pk l nc nd ne na nf jz mr"/></div></div></a></div><p id="7053" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与教程的不同之处在于，我执行的是POST而不是GET。</p><p id="da1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我只需要设置需要的JSON查询，如下所示。</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="a520" class="ol lf it nl b gy om on l oo op">let search = """<br/>    query GetWikicountByKeyword($keyword: String!)<br/>    { wikiCount<br/>        (keyword: $keyword) {<br/>          keyword<br/>          totalhits<br/>        }<br/>    }<br/>    """</span><span id="cab3" class="ol lf it nl b gy ph on l oo op">let parameters: Parameters = [<br/>      "query": search,<br/>      "variables": "{ \"keyword\": \"\(searchText)\" }"<br/>    ]</span></pre><p id="2f2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后执行正常的提取，如下所示</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="6803" class="ol lf it nl b gy om on l oo op">request = Alamofire.SessionManager.default.request(<br/>      ViewController.baseUrl, method: .post, <br/>           parameters: parameters, encoding: JSONEncoding.default)<br/>      .responseData { (resData) -&gt; Void in<br/>        self.view.stopLoading()</span><span id="c51b" class="ol lf it nl b gy ph on l oo op">switch (resData.result) {<br/>        case let .success(data):<br/>          let swiftyJsonVar = JSON(data)<br/>          let countObj = <br/>            swiftyJsonVar["data"]["wikiCount"]["totalhits"]<br/>          let keywordObj = <br/>            swiftyJsonVar["data"]["wikiCount"]["keyword"]<br/>          guard<br/>            let count = countObj.rawValue as? String,<br/>            let keyword = keywordObj.rawValue as? String,<br/>            count.isNumber<br/>            else {<br/>              self.view.showResult(data: "No data found")<br/>              return<br/>          }<br/>          self.view.showResult(data: "\(keyword):\(count)")<br/>        case let .failure(error):<br/>          self.view.showResult(data: error.localizedDescription)<br/>        }<br/>    }</span></pre><h2 id="c2ea" class="ol lf it bd lg or os dn lk ot ou dp lo kr ov ow ls kv ox oy lw kz oz pa ma pb bi translated">阿波罗iOS客户端</h2><p id="24b2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用Apollo iOS客户端的主要参考是使用下面的。我使用Cocoapod依赖管理系统链接到这个库。</p><blockquote class="nm nn no"><p id="a5e1" class="kg kh nh ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">参考<a class="ae kf" href="https://medium.com/@elye.project/learn-ios-android-dependency-management-5893300342d0" rel="noopener">这篇博客</a>了解更多关于<em class="it">椰子的细节</em>。</p></blockquote><div class="mo mp gp gr mq mr"><a href="https://www.apollographql.com/docs/ios/installation/" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">装置</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">Apollo iOS需要最新的Xcode，可以从Mac App Store安装。</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">www.apollographql.com</p></div></div><div class="na l"><div class="po l nc nd ne na nf jz mr"/></div></div></a></div><p id="6fdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像在Android中一样，我们也需要有<em class="nh"> schema.json </em>和各自的<em class="nh"> GraphQL查询</em>。我们按照Android部分的<strong class="ki iu">准备模式和GraphQL文件<em class="nh"> </em> </strong>一节中的描述来生成它们。不同的是，我们把它们和主代码放在同一个文件夹里。</p><p id="fa6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">设置代码自动生成依赖关系</strong></p><p id="6889" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使用<em class="nh"> schema.json </em>和相应的<em class="nh"> GraphQL查询</em>来生成所需的代码，我们需要在构建阶段添加以下内容</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="ba4d" class="ol lf it nl b gy om on l oo op">SCRIPT_PATH="${PODS_ROOT}/Apollo/scripts"</span><span id="ad43" class="ol lf it nl b gy ph on l oo op"><strong class="nl iu">cd</strong> "${SRCROOT}/${TARGET_NAME}"</span><span id="6b82" class="ol lf it nl b gy ph on l oo op">"${SCRIPT_PATH}"/run-bundled-codegen.sh codegen:generate --target=swift --includes=./**/*.graphql</span></pre><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pp"><img src="../Images/e6d52f729856a45d0824f71fbc7ba07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pqp6qZGzS8EmtHDT7jf57A.png"/></div></div></figure><p id="531a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这个，当编译开始时，它将生成一个文件名<code class="fe ni nj nk nl b">API.swift</code>，其中定义了类<code class="fe ni nj nk nl b">GetWikicountByKeywordQuery</code>。</p><p id="d696" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">提取器代码</strong></p><p id="96ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了生成的代码，现在您可以执行如下抓取</p><pre class="mi mj mk ml gt oh nl oi oj aw ok bi"><span id="1493" class="ol lf it nl b gy om on l oo op">private let view: MainView<br/>  private let apollo = ApolloClient(url: URL(string: ViewController.baseUrl)!)<br/>  private var watcher: <br/>     <strong class="nl iu">GraphQLQueryWatcher</strong>&lt;<strong class="nl iu">GetWikicountByKeywordQuery</strong>&gt;?</span><span id="2640" class="ol lf it nl b gy ph on l oo op">init(view: MainView) {<br/>    self.view = view<br/>  }</span><span id="32ac" class="ol lf it nl b gy ph on l oo op">func fetchData(searchText: String) {<br/>    watcher = <strong class="nl iu">apollo.watch</strong>(query: <br/>      <strong class="nl iu">GetWikicountByKeywordQuery</strong>(keyword: searchText)) { result in<br/>      self.view.stopLoading()<br/>      switch result {<br/>      case .success(let graphQLResult):<br/>        guard<br/>          let count = graphQLResult.data?.wikiCount?.totalhits,<br/>          let keyword = graphQLResult.data?.wikiCount?.keyword,<br/>          count.isNumber<br/>          else {<br/>            self.showResult(data: "No data found")<br/>            return<br/>        }<br/>        self.showResult(data: "\(keyword):\(count)")<br/>      case .failure(let error):<br/>        self.showResult(data: error.localizedDescription)<br/>      }<br/>    }<br/>  }</span></pre><h1 id="4599" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">一个系统启动了！</h1><p id="ae66" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">就是这样。现在你有了一个完整的系统。</p><p id="a50e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的是，使用Apollo客户端(用于iOS、Android和Web)，它已经内置了缓存机制。因此相同的获取不会再次发送请求。然而，这种方法依赖于GraphQL库。</p><p id="8877" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原生HTTP POST请求更加传统，尽管我提供的例子没有缓存机制。</p><p id="11e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，这些是建立一个完整系统的基础。请参考相应的站点和域，了解它提供的更多高级功能。</p></div><div class="ab cl pq pr hx ps" role="separator"><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv"/></div><div class="im in io ip iq"><p id="235a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这给你一个好的开始。我要感谢<a class="px py ep" href="https://medium.com/u/22ad527b5a1a?source=post_page-----cb74d2c400fe--------------------------------" rel="noopener" target="_blank"> Frank Tan </a>，他最初让我接触了阿波罗图书馆，并阐述了我在这一领域的学习。</p><p id="4f1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。你可以在这里查看我的其他话题<a class="ae kf" href="https://medium.com/@elye.project/" rel="noopener"/>。</p><p id="fc93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关注我的<a class="ae kf" href="https://medium.com/@elye.project" rel="noopener"> <em class="nh">中的</em> </a> <em class="nh">，</em> <a class="ae kf" href="https://twitter.com/elye_project" rel="noopener ugc nofollow" target="_blank"> <em class="nh">推特</em> </a> <em class="nh">，</em> <a class="ae kf" href="https://www.facebook.com/elyeproj/" rel="noopener ugc nofollow" target="_blank"> <em class="nh">脸书</em> </a>或<a class="ae kf" href="https://www.reddit.com/user/elyeproj/" rel="noopener ugc nofollow" target="_blank"> <em class="nh"> Reddit </em> </a>获取关于移动开发等相关话题的小技巧和学习。~Elye~</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="pz qa l"/></div></figure></div></div>    
</body>
</html>