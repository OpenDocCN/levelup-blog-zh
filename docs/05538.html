<html>
<head>
<title>What’s Mediastreamer2. Examples
of Filters Using</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Mediastreamer2。使用的过滤器示例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/chapter-3-examples-of-using-filters-612f2121301?source=collection_archive---------15-----------------------#2020-09-07">https://levelup.gitconnected.com/chapter-3-examples-of-using-filters-612f2121301?source=collection_archive---------15-----------------------#2020-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dfd0f28b7024dbf40cf84ed1f03ad35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihAeKukZa6fZSuk88JfflQ.png"/></div></div></figure><p id="0fd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(上一篇文章<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/whats-mediastreamer2-80fa1c5e617">什么是Mediastreamer2。简介</a></p><p id="334c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文将重点介绍几个使用mediastreamer过滤器的例子。在这个过程中，我们将学习如何组织信号图，如何创建和销毁过滤器实例。我们将学习如何将它们连接到数据处理电路、音调检测和信号电平测量中。然后，我们将看到如何通过RTP流传输信号。让我们使用<em class="kx"> TShark </em>工具来熟悉一下RTP包的内部字段。我们用一个双工对讲机的例子来结束这篇文章。</p><h1 id="c6ce" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.1创建一个<br/>声音生成器</h1><p id="5af2" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在之前的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/whats-mediastreamer2-80fa1c5e617">文章</a>中，我们安装了mediastreamer库和开发工具，并通过构建一个示例应用程序测试了它们的功能。</p><p id="c11d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将创建一个可以在声卡上播放声音的应用程序。为了解决这个问题，我们需要将滤波器连接到声音发生器电路，如图3.1所示。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/c9151ee80eba8d038aa7aef15a890642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGsdf2rCkacnG_eLljU6_Q.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">图3.1:声音发生器</figcaption></figure><p id="d6da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从左到右阅读图表，数据流就是朝这个方向移动的。箭头也暗示了这一点。矩形表示处理数据块并将结果暴露给输出的过滤器。其作用显示在矩形内，过滤器类型显示在正下方的括号内。连接矩形的箭头是在过滤器之间传输数据块的数据队列。一般来说，一个过滤器可以有许多输入和输出。</p><p id="0ba9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一切都始于时钟源，它设置滤波器中数据的计算速度。根据其时钟，每个过滤器处理输入端队列中的所有数据块。它将结果块放在输出队列中。首先，它计算离时钟源最近的滤波器，然后计算连接到其输出端的滤波器(可能有多个输出端)，依此类推。在链中的最后一个滤波器处理完计算之后，执行停止，直到接收到新的时钟。默认情况下，时钟每10毫秒滴答一次。</p><p id="3cc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到我们的图表。时钟到达静音源的输入端，该滤波器忙于为每个时钟在其输出端生成一个包含零的数据块。如果我们把这个区块看作一组声音样本，那么这只不过是寂静。乍一看，生成无声的数据块似乎很奇怪——毕竟它是听不到的，但它们是声音信号发生器运行所必需的。发生器像一张白纸一样使用这些块，在其中记录声音样本。在正常状态下，发生器关闭，只是将输入模块转发到输出。因此，无声块不变地从左到右通过整个电路，落入声卡。它静默地从连接到其输入的队列中取出块。</p><p id="43bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是一切都会改变，如果发生器收到播放声音的命令，它就会开始生成声音样本，并用它们替换输入块中的样本，将改变的块暴露给输出。声卡收到它们后，开始播放声音。清单3.1显示了一个实现上述工作模式的程序。</p><p id="91bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.1:声音生成器</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="0ef8" class="mp kz iq ml b gy mq mr l ms mt">/* Файл mstest2.c Sound Generator. */</span><span id="bac9" class="mp kz iq ml b gy mu mr l ms mt">#include &lt;Mediastreamer2/msfilter.h&gt;<br/>#include &lt;Mediastreamer2/msticker.h&gt;<br/>#include &lt;Mediastreamer2/dtmfgen.h&gt;<br/>#include &lt;Mediastreamer2/mssndcard.h&gt;<br/>int main()<br/>{<br/>    ms_init();</span><span id="c7d2" class="mp kz iq ml b gy mu mr l ms mt">    /* Instantiating filters. */<br/>    MSFilter  *voidsource = ms_filter_new(MS_VOID_SOURCE_ID);<br/>    MSFilter  *dtmfgen = ms_filter_new(MS_DTMF_GEN_ID);<br/>    MSSndCard *card_playback = ms_snd_card_manager_get_default_card(ms_snd_card_manager_get());<br/>    MSFilter  *snd_card_write = ms_snd_card_create_writer(card_playback);</span><span id="7869" class="mp kz iq ml b gy mu mr l ms mt">    /* Instantiating ticker. */<br/>    MSTicker *ticker = ms_ticker_new();</span><span id="17c9" class="mp kz iq ml b gy mu mr l ms mt">    /* We connect filters in a chain. */<br/>    ms_filter_link(voidsource, 0, dtmfgen, 0);<br/>    ms_filter_link(dtmfgen, 0, snd_card_write, 0);</span><span id="962c" class="mp kz iq ml b gy mu mr l ms mt">   /* We connect the clock source. */<br/>   ms_ticker_attach(ticker, voidsource);</span><span id="d3a0" class="mp kz iq ml b gy mu mr l ms mt">   /* We turn on the sound generator. */<br/>   char key='1';<br/>   ms_filter_call_method(dtmfgen, MS_DTMF_GEN_PLAY, (void*)&amp;key);</span><span id="4d68" class="mp kz iq ml b gy mu mr l ms mt">   /* We give time for all data blocks to be received by the sound card.*/<br/>   ms_sleep(2);   <br/>}</span></pre><p id="5af4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在初始化mediastreamer之后，创建了三个过滤器:<em class="kx"> voidsource，dtmfgen，snd_card_write </em>。创建了时钟源。</p><p id="ee34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，根据我们的电路建立滤波器连接，最后连接时钟源，此时电路已经组装好，因为此后电路将立即开始工作。如果将时钟源连接到非法电路，如果mediastreamer检测到链中至少有一个滤波器的所有输入或所有输出都“悬在空中”(未连接)，它可能会崩溃。</p><p id="c411" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<em class="kx"> ms_filter_link() </em>函数连接过滤器:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="d7f7" class="mp kz iq ml b gy mq mr l ms mt">int ms_filter_link (MSFilter *f1, int pin1, MSFilter *f2, int pin2)</span></pre><p id="226d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在哪里</p><p id="b915" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> f1 </strong> -指向源过滤器的指针；</p><p id="6c4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">pin 1</strong>-是源滤波器的输出号(注意输入和输出从零开始编号)；</p><p id="c9d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">F2</strong>-指向滤波器-接收器的指针；</p><p id="83b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">pin 2</strong>-滤波接收机的输入号。</p><p id="2711" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">连接所有滤波器，最后连接时钟源(以下简称为跑马灯)。在那之后，我们的声音电路启动，但是在计算机扬声器中什么也听不到——声音发生器被关闭，并且简单地通过它自己无声地转发输入数据块。要开始生成音调，您必须执行生成器过滤器方法。</p><p id="6fc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将启用与按下电话上的“1”按钮相对应的双音(DTMF)信号的生成。要做到这一点，使用<em class="kx">MS _ filter _ call _ method()</em>函数，我们调用MS_DTMF_GEN_PLAY方法，将它作为一个指向字符(清单中的<em class="kx"> key </em>变量)的指针的参数传递，正在播放的信号必须与该指针相对应。</p><p id="7e29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">剩下的就是编译程序了:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="7cd6" class="mp kz iq ml b gy mq mr l ms mt">$ gcc mstest2.c -o mstest2 `pkg-config Mediastreamer2 --libs --cflags`</span></pre><p id="f97b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并运行:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="fb05" class="mp kz iq ml b gy mq mr l ms mt">$ ./mstest2</span></pre><p id="ecfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">启动该程序后，您将在电脑扬声器中听到由两种声音组成的短促蜂鸣声。</p><p id="b12d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们编写并推出了我们的第一个声音电路。我们看到了如何创建过滤器的实例，如何连接以及如何调用它们的方法。在为第一次成功欢欣鼓舞之后，我们仍然需要注意这样一个事实，我们的程序在退出之前并没有释放分配给它的内存。在下一节中，我们将关注程序的正确终止。</p><h1 id="be57" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.2改善音调<br/>发生器示例</h1><p id="db8b" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在上一节中，我们编写了一个音调发生器应用程序，并使用它从计算机扬声器中提取声音。现在我们会注意到，我们的程序在退出时，并没有将内存返回到堆中。是时候澄清这个问题了。</p><p id="a38e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们不再需要模式时，释放内存必须从停止数据管道开始。要做到这一点，你需要把跑马灯从电路上断开。这个<em class="kx"> ms_ticker_detach() </em>在这方面有所帮助。在我们的例子中，我们必须断开ticker与<em class="kx"> voidsource </em>过滤器输入的连接:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="571f" class="mp kz iq ml b gy mq mr l ms mt">ms_ticker_detach(ticker, voidsource)</span></pre><p id="70e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一句，在停止输送机后，我们可以改变它的方案，通过重新连接跑马灯使其恢复运行。</p><p id="4f7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以使用<em class="kx"> ms_ticker_destroy() </em>函数来删除它:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="c513" class="mp kz iq ml b gy mq mr l ms mt">ms_ticker_destroy(ticker)</span></pre><p id="49c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传送带停下来，我们可以开始把它拆成零件，断开过滤器。为此，使用函数<em class="kx"> ms_filter_unlink() </em>:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="89c1" class="mp kz iq ml b gy mq mr l ms mt">ms_filter_unlink(voidsource, 0, dtmfgen, 0);<br/>ms_filter_unlink(dtmfgen, 0, snd_card_write, 0);</span></pre><p id="64d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参数的作用与<em class="kx"> ms_filter_link() </em>函数相同。</p><p id="b1f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用<em class="kx"> ms_filter_destroy() </em>移除现在断开的过滤器:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="f039" class="mp kz iq ml b gy mq mr l ms mt">ms_filter_destroy(voidsource); <br/>ms_filter_destroy(dtmfgen);<br/>ms_filter_destroy(snd_card_write);</span></pre><p id="d6ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在我们的例子中添加这几行，从内存管理的角度来看，我们得到了一个正确的程序终止。</p><p id="1cfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，正确完成程序需要我们添加与开始组装电路时相同数量的代码行，平均每个滤波器四行代码。原来，程序代码的大小将与项目中使用的过滤器数量成比例增长。如果我们谈论一个模式中的一千个过滤器，那么创建和销毁它们的四千行例行操作将被添加到您的代码中。</p><p id="ca26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你知道如何正确地终止一个基于mediastreamer的程序了。在下面的例子中，为了简洁起见，我将“忘记”这样做。但你不会忘记？</p><p id="4e7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">mediastreamer的开发者没有提供软件工具来在组装/拆卸电路时便于操作滤波器。但是，有一个<em class="kx"> MSConnectionHelper </em>允许您快速地在模式中插入/删除过滤器。当项目中的过滤器数量超过几十个时，您会觉得有必要使用它。</p><h1 id="3de0" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.3创建信号<br/>液位计</h1><p id="5813" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本节中，我们将组装一个信号电平计电路，并学习如何从滤波器读取测量结果。我们来估算一下测量精度。mediastreamer提供的一组滤波器包括一个滤波器MS_VOLUME，它能够测量通过它的信号的均方根电平，衰减信号并执行许多有用和意想不到的功能。但是现在我们将把它作为一个仪表。</p><p id="55a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用音调发生器作为信号源，来自它的信号将被发送到MS_VOLUME过滤器，声卡连接到它的输出。</p><p id="3869" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，我们将以稍微不同的模式使用发生器滤波器，它将为我们生成一个单音信号，即只包含一个正弦波的信号。</p><p id="41ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了频率和振幅，我们需要设置信号持续时间，它必须足以让测量所需的样本数量通过MS_VOLUME过滤器。用于传输生成器设置的结构是<em class="kx"> MSDtmfGenCustomTone </em>:</p><p id="a254" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.2:结构MSDtmfGenCustomTone</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="4f16" class="mp kz iq ml b gy mq mr l ms mt">struct _MSDtmfGenCustomTone{<br/>    char tone_name[8];   /* 8-letter signal text name.*/<br/>    int duration;        /* Signal duration in milliseconds.*/<br/>    int frequencies[2];  /* The pair of frequencies that the output<br/>                            signal should consist of. */<br/>    float amplitude;     /* Tone amplitude, 1.0 corresponds to<br/>                            0 dB mW into 600 ohm load.*/<br/>    int interval;        /* Pause in milliseconds before starting<br/>                            signal replay.*/<br/>    int repeat_count;    /* Number of repetitions.*/<br/>};<br/>typedef struct _MSDtmfGenCustomTone MSDtmfGenCustomTone;</span></pre><p id="a5e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了启动生成器，我们将使用它的MS_DTMF_GEN_PLAY_CUSTOM方法。</p><p id="f5aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">信号处理的框图如图所示。3.2.</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/3bed3a2ec42050b5ddae2de20626e228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YkVy-G6qxGSN87JmASoog.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">图3.2:信号电平指示器</figcaption></figure><p id="df6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.3显示了实现这个方案的程序代码。</p><p id="432f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.3:信号电平指示器</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="2926" class="mp kz iq ml b gy mq mr l ms mt">/* Файл mstest3.c Signal level meter. */</span><span id="39cb" class="mp kz iq ml b gy mu mr l ms mt">#include &lt;Mediastreamer2/msfilter.h&gt;<br/>#include &lt;Mediastreamer2/msticker.h&gt;<br/>#include &lt;Mediastreamer2/dtmfgen.h&gt;<br/>#include &lt;Mediastreamer2/mssndcard.h&gt;<br/>#include &lt;Mediastreamer2/msvolume.h&gt;</span><span id="6cfa" class="mp kz iq ml b gy mu mr l ms mt">int main()<br/>{<br/>    ms_init();<br/>    /* Instantiating filters. */<br/>    MSFilter  *voidsource=ms_filter_new(MS_VOID_SOURCE_ID);<br/>    MSFilter  *dtmfgen=ms_filter_new(MS_DTMF_GEN_ID);<br/>    MSFilter  *volume=ms_filter_new(MS_VOLUME_ID);<br/>    MSSndCard *card_playback=ms_snd_card_manager_get_default_card(ms_snd_card_manager_get());<br/>    MSFilter  *snd_card_write=ms_snd_card_create_writer(card_playback);</span><span id="4b7c" class="mp kz iq ml b gy mu mr l ms mt">    /* Create a ticker. */<br/>    MSTicker *ticker=ms_ticker_new();</span><span id="f9a1" class="mp kz iq ml b gy mu mr l ms mt">    /* We connect filters in a chain. */<br/>    ms_filter_link(voidsource, 0, dtmfgen, 0);<br/>    ms_filter_link(dtmfgen, 0, volume, 0);<br/>    ms_filter_link(volume, 0, snd_card_write, 0);</span><span id="f848" class="mp kz iq ml b gy mu mr l ms mt">    /* Connect the clock source. */<br/>    ms_ticker_attach(ticker,voidsource);</span><span id="4a92" class="mp kz iq ml b gy mu mr l ms mt">    MSDtmfGenCustomTone dtmf_cfg;</span><span id="ddb9" class="mp kz iq ml b gy mu mr l ms mt">   /* We set the name of our signal, remembering that in the array we must leave room for a zero, which marks the end of the line. */<br/>    strncpy(dtmf_cfg.tone_name, "busy", sizeof(dtmf_cfg.tone_name));<br/>    dtmf_cfg.duration=1000;<br/>    dtmf_cfg.frequencies[0]=440; /* We will generate one tone, set the frequency of the second tone to 0.*/<br/>    dtmf_cfg.frequencies[1]=0;<br/>    dtmf_cfg.amplitude=1.0; /* This sine amplitude should correspond to a measurement result of 0.707.*/<br/>    dtmf_cfg.interval=0.;<br/>    dtmf_cfg.repeat_count=0.;</span><span id="ffeb" class="mp kz iq ml b gy mu mr l ms mt">   /* Turn on the sound generator. */<br/>   ms_filter_call_method(dtmfgen, MS_DTMF_GEN_PLAY_CUSTOM, (void*)&amp;dtmf_cfg);</span><span id="9bc0" class="mp kz iq ml b gy mu mr l ms mt">   /* We give half a second time for the meter to accumulate data. */<br/>   ms_usleep(500000);</span><span id="b337" class="mp kz iq ml b gy mu mr l ms mt">   /* Reading the measurement result. */<br/>  float level=0;<br/>   ms_filter_call_method(volume, MS_VOLUME_GET_LINEAR,&amp;level);<br/>   printf("The amplitude of the sine %f volts corresponds to the rms value of %f volts.\n", dtmf_cfg.amplitude, level);<br/>}</span></pre><p id="3dbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们编译我们的例子，就像我们以前做的那样，只使用文件名<em class="kx"> mstest3.c </em>运行它以执行并在控制台中获得结果:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="66ef" class="mp kz iq ml b gy mq mr l ms mt">The amplitude of the sine 1.000000 volts corresponds to the rms value of 0.707733 volts.</span></pre><p id="21f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，测量结果精确到小数点后第三位，理论值等于二的平方根除以二:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="30c3" class="mp kz iq ml b gy mq mr l ms mt">sqr(2)/2=0,7071067811865475</span></pre><p id="107e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果与真实值的相对偏差为<em class="kx"> 0.1% </em>。我们估计了最大信号电平下的测量误差。因此，随着液位的降低，误差会增加。建议你自己评估一下信号水平低。</p><h1 id="58aa" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.4音调检测器</h1><p id="43d0" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在这一节中，我们将考虑一个方案，在该方案中，除了数据转换之外，还生成事件。多亏了这一点，我们将能够编写对图中发生的任何事件都有反馈的程序。许多mediastreamer的过滤器能够生成事件，并且用户能够将一个或多个处理程序(回调函数)绑定到将实现应用程序的业务逻辑的事件。</p><p id="5f49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi mw translated">在 <em class="kx">过去，不是每个俄罗斯家庭都有电视，一半的俄罗斯人用钳子换频道，一则有趣的新闻出现在外国技术新闻评论中，报道称一家电视制造商为他们的设备提供了无线遥控器。从细节可以看出，由于使用了一种不寻常的方法，遥控器在没有电池的情况下也能工作——遥控器是机械的，是一种乐器的混合体——钟琴和左轮手枪。“左轮手枪”的鼓里有金属圆筒，长度不同，当撞针击中其中一个时，圆筒开始以自己的频率响起来。大概是通过超声波。电视上的电子设备听到了这个信号，并且在确定了它的频率之后，执行了适当的动作——改变频道、改变音量、打开/关闭电视。</em></p><p id="fba3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我们将利用我们对mediastreamer的了解，尝试重建这个命令传输系统。</p><p id="c99e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了模拟遥控器，让我们使用音调发生器示例的文本。我们将为它添加一个对键盘击键发生器频率的控制，以及一个带解码器的接收器，它将把接收到的命令输出到控制台。改变后，发生器应发出音调，6个频率，我们将使用这些音调对命令进行编码，以增加/减少音量，改变频道，打开/关闭电视。该结构用于配置探测器<em class="kx">mstonetencerdef</em>:</p><p id="8273" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.4:струкураmstonetencerdef</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="e9fd" class="mp kz iq ml b gy mq mr l ms mt">struct _MSToneDetectorDef{ <br/>  char tone_name[8]; <br/>  int frequency;       /* Frequency of tone of interest. */<br/>  int min_duration;    /* Minimum tone duration in milliseconds. */<br/>  float min_amplitude; /* Minimum tone amplitude, 1.0 corresponds to<br/>                          0 dBm */<br/>};</span><span id="77ed" class="mp kz iq ml b gy mu mr l ms mt">typedef struct _MSToneDetectorDef MSToneDetectorDef;</span></pre><p id="5842" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">10个这样的结构可以被传输到检测器，因此一个检测器可以被配置成检测十个双音信号(DTMF)。但是我们将只使用六个单音信号。要将设置载入检测器，请使用MS_TONE_DETECTOR_ADD_SCAN方法。</p><p id="165e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让检波器通知我们具有所需频率成分的信号已经到达其输入端，我们必须为它提供一个回调函数，它将在这种情况下触发。使用函数<em class="kx">ms _ filter _ set _ notify _ callback()</em>完成回调设置。作为参数，它接收一个指向过滤器的指针，一个指向回调函数的指针，一个指向我们希望传递给回调函数的数据(用户数据)的指针。</p><p id="3030" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当检测器被触发时，回调函数将接收用户数据、指向检测器过滤器的指针、事件ID和描述事件的结构MSToneDetectorEvent:</p><p id="f537" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.5:结构MSToneDetectorEvent</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="1595" class="mp kz iq ml b gy mq mr l ms mt">struct _MSToneDetectorEvent{ <br/>      char tone_name[8];       /* The tone name that we assigned to <br/>                                  it when setting up the detector.*/<br/>      uint64_t tone_start_time;   /* Time in milliseconds when the <br/>                                     tone was detected. */<br/>};</span><span id="5255" class="mp kz iq ml b gy mu mr l ms mt">typedef struct _MSToneDetectorEvent MSToneDetectorEvent;</span></pre><p id="a6b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">信号处理电路如图所示。3.3，在这种情况下，声卡起不到关键作用，它被留下来只是为了让你能听到电路的输入端有信号。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/014ac93af11b5c5788c5e9e19b813d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fdx34SWVFXV2H8_d3hvvtg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">图3.3:音调检测器</figcaption></figure><p id="0754" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在程序代码本身带有注释。</p><p id="a31a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.6:远程控制和接收器模拟器</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="6658" class="mp kz iq ml b gy mq mr l ms mt">/* Файл mstest4.c Remote control and receiver simulator. */</span><span id="5138" class="mp kz iq ml b gy mu mr l ms mt">#include &lt;Mediastreamer2/msfilter.h&gt;<br/>#include &lt;Mediastreamer2/msticker.h&gt;<br/>#include &lt;Mediastreamer2/dtmfgen.h&gt;<br/>#include &lt;Mediastreamer2/mssndcard.h&gt;<br/>#include &lt;Mediastreamer2/msvolume.h&gt;<br/>#include &lt;Mediastreamer2/mstonedetector.h&gt;</span><span id="d003" class="mp kz iq ml b gy mu mr l ms mt">/* We include a header file with event management functions <br/> * mediastreamer. */<br/>#include &lt;Mediastreamer2/mseventqueue.h&gt;</span><span id="3e14" class="mp kz iq ml b gy mu mr l ms mt">/* Callback function, it will be called by the filter as soon as it<br/> * will detect the coincidence of the characteristics<br/> * of the input signal with the specified. */<br/>static void tone_detected_cb(void *data, MSFilter *f, unsigned int event_id,<br/>        MSToneDetectorEvent *ev)<br/>{<br/>    printf("                      Command accepted: %s\n",<br/> ev-&gt;tone_name);<br/>}</span><span id="c735" class="mp kz iq ml b gy mu mr l ms mt">int main()<br/>{<br/>    ms_init();</span><span id="011d" class="mp kz iq ml b gy mu mr l ms mt">    /* Instantiating filters. */<br/>    MSFilter  *voidsource = ms_filter_new(MS_VOID_SOURCE_ID);<br/>    MSFilter  *dtmfgen = ms_filter_new(MS_DTMF_GEN_ID);<br/>    MSFilter  *volume = ms_filter_new(MS_VOLUME_ID);<br/>    MSSndCard *card_playback =<br/>        ms_snd_card_manager_get_default_card(ms_snd_card_manager_get());<br/>    MSFilter  *snd_card_write = ms_snd_card_create_writer(card_playback);<br/>    MSFilter  *detector = ms_filter_new(MS_TONE_DETECTOR_ID);</span><span id="29dd" class="mp kz iq ml b gy mu mr l ms mt">    /* We clear the array inside the tone detector, it describes<br/>     * special signs of wanted signals.*/<br/>    ms_filter_call_method(detector, MS_TONE_DETECTOR_CLEAR_SCANS, 0);</span><span id="b20f" class="mp kz iq ml b gy mu mr l ms mt">    /* Create a ticker source. */<br/>    MSTicker *ticker=ms_ticker_new();</span><span id="564e" class="mp kz iq ml b gy mu mr l ms mt">    /* We connect filters in a chain. */<br/>    ms_filter_link(voidsource, 0, dtmfgen, 0);<br/>    ms_filter_link(dtmfgen, 0, volume, 0);<br/>    ms_filter_link(volume, 0, detector, 0);<br/>    ms_filter_link(detector, 0, snd_card_write, 0);</span><span id="ab02" class="mp kz iq ml b gy mu mr l ms mt">    /* Connect a callback function to the filter. */<br/>    ms_filter_set_notify_callback(detector,<br/>            (MSFilterNotifyFunc)tone_detected_cb, NULL);</span><span id="4d27" class="mp kz iq ml b gy mu mr l ms mt">    /* Connect the clock source. */<br/>    ms_ticker_attach(ticker,voidsource);</span><span id="6450" class="mp kz iq ml b gy mu mr l ms mt">    /* We create an array, each element of which describes <br/>     * a characteristic of one of the tones<br/>     * to be detected: <br/>     * Text name of this element,<br/>     * Frequency in hertz,<br/>     * Duration in milliseconds,<br/>     * Minimum level relative to 0.775V. */  <br/>    MSToneDetectorDef  scan[6]=<br/>    {<br/>        {"V+",  440, 100, 0.1}, /* “Volume Up” command. */<br/>        {"V-",  540, 100, 0.1}, /* “Volume Down” command. */<br/>        {"C+",  640, 100, 0.1}, /* "Increase Channel Number" command. */<br/>        {"C-",  740, 100, 0.1}, /* “Decrease Channel Number” command. */<br/>        {"ON",  840, 100, 0.1}, /* "Turn on the TV" command. */<br/>        {"OFF", 940, 100, 0.1}  /* “Turn off TV” command. */<br/>    };</span><span id="3f39" class="mp kz iq ml b gy mu mr l ms mt">    /* We transfer the signs of signals to the tone detector. */<br/>    int i;<br/>    for (i = 0; i &lt; 6; i++)<br/>    {<br/>        ms_filter_call_method(detector, MS_TONE_DETECTOR_ADD_SCAN,<br/>                &amp;scan[i]);<br/>    }</span><span id="e557" class="mp kz iq ml b gy mu mr l ms mt">    /* Setting up the structure that controls the generator output.*/<br/>    MSDtmfGenCustomTone dtmf_cfg;<br/>    dtmf_cfg.tone_name[0] = 0;<br/>    dtmf_cfg.duration = 1000;<br/>    dtmf_cfg.frequencies[0] = 440;<br/>    /* We will generate one tone, set the frequency of the second tone to 0.*/<br/>    dtmf_cfg.frequencies[1] = 0;<br/>    dtmf_cfg.amplitude = 1.0;<br/>    dtmf_cfg.interval = 0.;<br/>    dtmf_cfg.repeat_count = 0.;</span><span id="fc2e" class="mp kz iq ml b gy mu mr l ms mt">    /* We organize a cycle of scanning of pressed keys.<br/>     * Entering zero completes<br/>     * cycle and work of the program. */<br/>    char key='9';<br/>    printf("Press the command key, then Enter.\n"<br/>        "Enter 0 to end the program.\n");<br/>    while(key != '0')<br/>    {<br/>        key = getchar();<br/>        if ((key &gt;= 49) &amp;&amp; (key &lt;= 54))<br/>        {<br/>                printf("Command sent: %c\n", key);<br/>            /* We set the generator frequency in accordance<br/>             * with the code of the pressed key.*/<br/>            dtmf_cfg.frequencies[0] = 440 + 100*(key-49);</span><span id="f770" class="mp kz iq ml b gy mu mr l ms mt">            /* Turn on the sound generator with the updated frequency. */<br/>            ms_filter_call_method(dtmfgen, MS_DTMF_GEN_PLAY_CUSTOM,<br/>                    (void*)&amp;dtmf_cfg);<br/>        }<br/>        ms_usleep(20000);<br/>    }<br/>}</span></pre><p id="96c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们编译并运行程序。如果一切正常，那么在启动之后，我们应该会得到类似这样的程序行为:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="7019" class="mp kz iq ml b gy mq mr l ms mt">$ ./mstest4<br/>ALSA lib conf.c:4738:(snd_config_expand) Unknown parameters 0<br/>ALSA lib control.c:954:(snd_ctl_open_noupdate) Invalid CTL default:0<br/>ortp-warning-Could not attach mixer to card: Invalid argument<br/>ALSA lib conf.c:4738:(snd_config_expand) Unknown parameters 0<br/>ALSA lib pcm.c:2266:(snd_pcm_open_noupdate) Unknown PCM default:0<br/>ALSA lib conf.c:4738:(snd_config_expand) Unknown parameters 0<br/>ALSA lib pcm.c:2266:(snd_pcm_open_noupdate) Unknown PCM default:0<br/>ortp-warning-Strange, sound card Intel 82801AA-ICH does not seems to be capable of anything, retrying with plughw...<br/>Press the command key, then Enter.<br/>Enter 0 to end the program.<br/>ortp-warning-alsa_set_params: periodsize:256 Using 256<br/>ortp-warning-alsa_set_params: period:8 Using 8</span></pre><p id="1152" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按下从“1”到“6”的任意键，用“Enter”键确认，您应该得到类似下面的列表:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="fc5a" class="mp kz iq ml b gy mq mr l ms mt">2<br/>Command sent: 2<br/>                      Command accepted: V-<br/>1<br/>Command sent: 1<br/>                      Command accepted: V+<br/>3<br/>Command sent: 3<br/>                      Command accepted: C+<br/>4<br/>Command sent: 4<br/>                      Command accepted: C-<br/>0<br/>$</span></pre><p id="27c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到命令音已成功发送，并且检测器已检测到它们。</p><h1 id="c01c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.5通过RTP流传输音频信号<br/></h1><p id="e80e" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本节中，我们将学习如何使用协议RTP ( <em class="kx"> RFC 3550 — RTP:一种用于实时应用</em>的传输协议)通过<em class="kx">以太网</em>接收/传输音频信号。</p><p id="f8ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">协议RTP ( <em class="kx">实时协议)</em>用于传输声音，视频，数据，任何需要实时传输的东西。以一段音频为例。该协议的灵活性使得它允许以预定质量传输音频信号。</p><p id="cfdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用UDP数据包进行传输，这意味着在传输过程中数据包丢失是完全可以接受的。每个分组包含一个特殊的RTP报头和一个传输信号的数据块。报头包含随机选择的信号源标识符、关于传输信号类型的信息、分组的唯一序列号，使得分组可以在解码期间以正确的顺序排列，而不管网络传送它们的顺序。头可以包含附加信息，即所谓的扩展，它允许您修改包以用于特定的应用程序。</p><p id="9ece" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据块包含数据包的有效载荷。内容的内部组织取决于负载的类型，它可以是单声道信号、立体声信号、视频线等的样本。</p><p id="0b7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">负载类型由一个七位数字表示。建议RFC3551 ( <em class="kx">用于具有最小控制的音频和视频会议的RTP规范</em>)在相应的表格中设置了几种类型的负载，提供了负载类型的描述以及指定这些负载的代码的含义，其中一些代码并不严格限制于任何类型的负载，它们可用于指定任意负载。</p><p id="9f27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据块的大小受到在给定网络中不分段传输的最大数据包大小的限制(参数MTU)。一般来说，这不超过1500字节。因此，为了增加每秒传输的数据量，您可以将包的大小增加到某一点，然后您将需要增加发送包的频率。在媒体流2中，这是一个可配置的参数。默认情况下，频率为50赫兹，即每秒50个数据包。传输的RTP分组序列将被称为RTP流。</p><p id="b9ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了开始在源和接收器之间传输数据，发送器知道接收器的IP地址和它用于接收的端口号就足够了。那些。在没有任何预备过程的情况下，源开始传输数据，而接收器则准备好立即接收和处理数据。根据该标准，用于发送或接收RTP流的端口号必须是偶数。</p><p id="0b4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在不可能预先知道接收者的地址的情况下，在接收者留下他们的地址的地方使用服务器，并且发送者可以参考接收者的某个唯一名称来请求它。</p><p id="d501" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在通信信道的质量或接收器的能力未知的情况下，组织反馈信道，通过该反馈信道，接收器可以通知发送器其能力、其丢失的分组数量等。该通道使用RTCP协议(<em class="kx"> RTP控制协议</em>)。RFC 3605中定义了在此信道中传输的数据包的格式。相对少量的数据200..每秒300字节通过该信道传输，因此，一般来说，它的存在并不麻烦。RTCP分组被发送到的端口号必须是奇数，并且比RTP流来自的端口号多1。在我们的例子中，我们将不使用这个信道，因为接收机和信道的能力肯定超过了我们目前适度的需求。</p><p id="9bd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，数据传输方案与前一个不同，将分为两部分:发送路径和接收路径。对于每个部分，我们将制作自己的时钟源(ticker)，如图3.4所示。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/1dceeb620b0d39662e3d6869764c2bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0EPww-IqvgXvBh9KyPdTw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">图3.4:使用RTP字符串</figcaption></figure><p id="7187" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们之间的单向通信将使用RTP协议进行。在本例中，我们不需要外部网络，因为发送方和接收方将位于同一台计算机上，数据包将在内部传输。</p><p id="d00b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在媒体流2中建立RTP流，使用了两个过滤器:MS_RTP_SEND和MS_RTP_RECV。第一个执行传输，第二个接收RTP流。为了让这些过滤器工作，它们需要传递一个指向RTP-session对象的指针，该对象既可以执行将数据块流转换为RTP-packets流的操作，也可以执行相反的操作。由于mediastreamer的内部数据格式与RTP-packet的数据格式不匹配，因此在将数据传输到MS_RTP_SEND ( <em class="kx">编码器</em>)之前，必须使用一个转换器，该转换器将音频信号的16位样本转换为由μ-law(在标准G.711中描述)编码的8位样本。在接收侧，滤波器<em class="kx">解码器</em>执行相反的动作。</p><p id="1b46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在清单3.7中，实现图中所示电路的程序文本在3.4中给出。</p><p id="1024" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.7:带RTP的远程控制和接收器模拟器</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="166b" class="mp kz iq ml b gy mq mr l ms mt">/* Файл mstest6.c Simulator of remote control and receiver <br/>simulator with RTP. */</span><span id="fcd9" class="mp kz iq ml b gy mu mr l ms mt">#include &lt;Mediastreamer2/msfilter.h&gt;<br/>#include &lt;Mediastreamer2/msticker.h&gt;<br/>#include &lt;Mediastreamer2/dtmfgen.h&gt;<br/>#include &lt;Mediastreamer2/mssndcard.h&gt;<br/>#include &lt;Mediastreamer2/msvolume.h&gt;<br/>#include &lt;Mediastreamer2/mstonedetector.h&gt;<br/>#include &lt;Mediastreamer2/msrtp.h&gt;<br/>#include &lt;ortp/rtpsession.h&gt;<br/>#include &lt;ortp/payloadtype.h&gt;</span><span id="a144" class="mp kz iq ml b gy mu mr l ms mt">/* We include a header file with event management functions * mediastreamer.*/<br/>include &lt;Mediastreamer2/mseventqueue.h&gt;</span><span id="5d12" class="mp kz iq ml b gy mu mr l ms mt">#define PCMU 0</span><span id="bd24" class="mp kz iq ml b gy mu mr l ms mt">/* Callback function, it will be called by the filter as soon as it detects the coincidence of the characteristics of the input signal with the specified. */<br/>static void tone_detected_cb(void *data, MSFilter *f, unsigned int event_id,<br/>MSToneDetectorEvent *ev)<br/>{<br/>  printf("Command accepted: %s\n", ev-&gt;tone_name);<br/>}</span><span id="b1b8" class="mp kz iq ml b gy mu mr l ms mt">/*--------------------------------------------------------------*/<br/>/* Payload type registration function. */<br/>void register_payloads(void)<br/>{<br/>  /*We register the types of loads in the profile table. Later, by index    taken from the header of the RTP-packet from this table will be extracted    load parameters needed to decode packet data. */<br/>  rtp_profile_set_payload (&amp;av_profile, PCMU, &amp;payload_type_pcm8000);<br/>}</span><span id="0121" class="mp kz iq ml b gy mu mr l ms mt">/*--------------------------------------------------------------*/<br/>/*This function is created from the create_duplex_rtpsession () function in audiostream.c mediastreamer 2. */<br/>static RtpSession *<br/>create_rtpsession (int loc_rtp_port, int loc_rtcp_port,<br/>bool_t ipv6, RtpSessionMode mode)<br/>{<br/>  RtpSession *rtpr;<br/>  rtpr = rtp_session_new ((int) mode);<br/>  rtp_session_set_scheduling_mode (rtpr, 0);<br/>  rtp_session_set_blocking_mode (rtpr, 0);<br/>  rtp_session_enable_adaptive_jitter_compensation (rtpr, TRUE);<br/>  rtp_session_set_symmetric_rtp (rtpr, TRUE);<br/> rtp_session_set_local_addr (rtpr, ipv6 ? "::" : "0.0.0.0",       loc_rtp_port,<br/>loc_rtcp_port);<br/>  rtp_session_signal_connect (rtpr, "timestamp_jump",<br/>  (RtpCallback) rtp_session_resync, 0);<br/>  rtp_session_signal_connect (rtpr, "ssrc_changed",<br/>  (RtpCallback) rtp_session_resync, 0);<br/>  rtp_session_set_ssrc_changed_threshold (rtpr, 0);<br/>  rtp_session_set_send_payload_type(rtpr, PCMU);</span><span id="822d" class="mp kz iq ml b gy mu mr l ms mt">  /* By default, we turn off the RTCP session, since our remote control will not use it. */<br/>  rtp_session_enable_rtcp (rtpr, FALSE);<br/>  return rtpr;<br/>}</span><span id="3679" class="mp kz iq ml b gy mu mr l ms mt">/*--------------------------------------------------------------*/<br/>int main()<br/>{<br/>  ms_init();</span><span id="9a28" class="mp kz iq ml b gy mu mr l ms mt">  /* Instantiating filters. */<br/>  MSFilter *voidsource = ms_filter_new(MS_VOID_SOURCE_ID);<br/>  MSFilter *dtmfgen = ms_filter_new(MS_DTMF_GEN_ID);<br/>  MSFilter *volume = ms_filter_new(MS_VOLUME_ID);<br/>  MSSndCard *card_playback =<br/>  ms_snd_card_manager_get_default_card(ms_snd_card_manager_get());<br/>  MSFilter *snd_card_write = ms_snd_card_create_writer(card_playback);<br/>  MSFilter *detector = ms_filter_new(MS_TONE_DETECTOR_ID);</span><span id="7a3f" class="mp kz iq ml b gy mu mr l ms mt">  /* We clear the array inside the tone detector, it describes<br/>   * special signs of the wanted signals. */<br/>  ms_filter_call_method(detector, MS_TONE_DETECTOR_CLEAR_SCANS, 0);</span><span id="a4bf" class="mp kz iq ml b gy mu mr l ms mt">  /* Connect a callback function to the filter. */<br/>  ms_filter_set_notify_callback(detector,<br/>(MSFilterNotifyFunc)tone_detected_cb, NULL);</span><span id="6163" class="mp kz iq ml b gy mu mr l ms mt">  /* We create an array, each element of which describes a characteristic    <br/>   * one of the tones to be detected: Text name    <br/>   * of this element, frequency in hertz, duration in milliseconds,     <br/>   * minimum level relative to 0.775V. */<br/>  MSToneDetectorDef scan[6]=<br/>  {<br/>     {"V+",  440, 100, 0.1}, /* “Volume Up” command. */<br/>     {"V-",  540, 100, 0.1}, /* “Volume Down” command. */<br/>     {"C+",  640, 100, 0.1}, /* "Increase Channel Number" command. */<br/>     {"C-",  740, 100, 0.1}, /* “Decrease Channel Number” command. */<br/>     {"ON",  840, 100, 0.1}, /* "Turn on the TV" command. */<br/>     {"OFF", 940, 100, 0.1}  /* “Turn off TV” command. */  <br/>  };</span><span id="cbe6" class="mp kz iq ml b gy mu mr l ms mt">  /* We transmit "signs" of the signals to the tone detector. */<br/>  int i;<br/>  for (i = 0; i &lt; 6; i++)<br/>  {<br/>    ms_filter_call_method(detector, MS_TONE_DETECTOR_ADD_SCAN,<br/>&amp;scan[i]);<br/>  }</span><span id="ef13" class="mp kz iq ml b gy mu mr l ms mt">  /* Creating encoder and decoder filters. */<br/>  MSFilter *encoder = ms_filter_create_encoder("PCMU");<br/>  MSFilter *decoder=ms_filter_create_decoder("PCMU");<br/>  /* Регистрируем типы нагрузки. */<br/>  register_payloads();</span><span id="e783" class="mp kz iq ml b gy mu mr l ms mt">  /* Create an RTP transmitter session. */<br/>  RtpSession *tx_rtp_session = create_rtpsession (8010, 8011, FALSE,     RTP_SESSION_SENDONLY);<br/>  rtp_session_set_remote_addr_and_port(tx_rtp_session,"127.0.0.1", 7010, 7011);<br/>  rtp_session_set_send_payload_type(tx_rtp_session, PCMU);<br/>  MSFilter *rtpsend = ms_filter_new(MS_RTP_SEND_ID);<br/>  ms_filter_call_method(rtpsend, MS_RTP_SEND_SET_SESSION,      tx_rtp_session);</span><span id="a2a2" class="mp kz iq ml b gy mu mr l ms mt">  /* Create RTP Receiver Session. */<br/>  MSFilter *rtprecv = ms_filter_new(MS_RTP_RECV_ID);<br/>  RtpSession *rx_rtp_session = create_rtpsession (7010, 7011, FALSE, RTP_SESSION_RECVONLY);<br/>  ms_filter_call_method(rtprecv, MS_RTP_RECV_SET_SESSION, rx_rtp_session);</span><span id="989c" class="mp kz iq ml b gy mu mr l ms mt">  /* Create tick sources - tickers. */<br/>  MSTicker *ticker_tx = ms_ticker_new();<br/>  MSTicker *ticker_rx = ms_ticker_new();</span><span id="2407" class="mp kz iq ml b gy mu mr l ms mt">  /* We connect the transmitter filters. */<br/>  ms_filter_link(voidsource, 0, dtmfgen, 0);<br/>  ms_filter_link(dtmfgen, 0, volume, 0);<br/>  ms_filter_link(volume, 0, encoder, 0);<br/>  ms_filter_link(encoder, 0, rtpsend, 0);</span><span id="da1d" class="mp kz iq ml b gy mu mr l ms mt">  /* We connect the receiver filters. */<br/>  ms_filter_link(rtprecv, 0, decoder, 0);<br/>  ms_filter_link(decoder, 0, detector, 0);<br/>  ms_filter_link(detector, 0, snd_card_write, 0);</span><span id="a408" class="mp kz iq ml b gy mu mr l ms mt">  /* Connect the clock source. */<br/>  ms_ticker_attach(ticker_tx, voidsource);<br/>  ms_ticker_attach(ticker_rx, rtprecv);</span><span id="868b" class="mp kz iq ml b gy mu mr l ms mt">  /* Setting up the structure that controls the generator output. */<br/>  MSDtmfGenCustomTone dtmf_cfg;<br/>  dtmf_cfg.tone_name[0] = 0;<br/>  dtmf_cfg.duration = 1000;<br/>  dtmf_cfg.frequencies[0] = 440;</span><span id="db5e" class="mp kz iq ml b gy mu mr l ms mt">  /* We will generate one tone, set the frequency of the second tone to 0. */<br/>  dtmf_cfg.frequencies[1] = 0;<br/>  dtmf_cfg.amplitude = 1.0;<br/>  dtmf_cfg.interval = 0.;<br/>  dtmf_cfg.repeat_count = 0.;</span><span id="5baa" class="mp kz iq ml b gy mu mr l ms mt">  /* We organize a cycle of scanning of pressed keys. Entering zero completes<br/>   * cycle and work of the program. */<br/>  char key='9';<br/>  printf("Press the command key then enter.\n"<br/>  "To end the program, enter 0.\n");<br/>  while(key != '0')<br/>  {<br/>    key = getchar();<br/>    if ((key &gt;= 49) &amp;&amp; (key &lt;= 54))<br/>    {<br/>      printf("Command sent: %c\n", key);</span><span id="1b56" class="mp kz iq ml b gy mu mr l ms mt">      /* We set the generator frequency in accordance with <br/>       * the code of the pressed key. */<br/>      dtmf_cfg.frequencies[0] = 440 + 100*(key-49);</span><span id="4db5" class="mp kz iq ml b gy mu mr l ms mt">      /* Turn on the sound generator with the updated frequency. */<br/>      ms_filter_call_method(dtmfgen, MS_DTMF_GEN_PLAY_CUSTOM,<br/>      (void*)&amp;dtmf_cfg);<br/>    }</span><span id="4ab6" class="mp kz iq ml b gy mu mr l ms mt">    /* We put the thread into hibernation for 20ms so that other threads<br/>     * apps got time to work. */<br/>    ms_usleep(20000);<br/>  }<br/>}</span></pre><p id="3290" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编译，运行。从表面上看，该程序将类似于前面3.6节中的示例，但同时数据将通过RTP流传输。</p><h1 id="a66d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.6使用TShark <br/>分析RTP数据包</h1><p id="16d2" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本节中，我们将继续研究使用RTP协议的音频信号传输。首先，让我们将清单3.7中的测试应用程序分成发送器和接收器两个独立的应用程序，然后我们将学习如何使用网络流量分析器来检查RTP流。</p><p id="c62b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，为了更清楚地看到哪些程序元素负责RTP传输，哪些负责接收，我们将我们的<em class="kx"> mstest6.c </em>文件分成发送器和接收器两个独立的程序，两者都使用的通用函数将放在第三个文件中，我们称之为<em class="kx"> mstest_common.c </em>清单3.8，它将通过发送器和接收器使用指令<em class="kx">连接，包括</em>:</p><p id="90c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.8:发送器和接收器的通用函数</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="85fb" class="mp kz iq ml b gy mq mr l ms mt">/* Файл mstest_common.c RTP Control Protocol */</span><span id="4e9a" class="mp kz iq ml b gy mu mr l ms mt">#include &lt;Mediastreamer2/msfilter.h&gt;<br/>#include &lt;Mediastreamer2/msticker.h&gt;<br/>#include &lt;Mediastreamer2/msrtp.h&gt;<br/>#include &lt;ortp/rtpsession.h&gt;<br/>#include &lt;ortp/payloadtype.h&gt;</span><span id="4486" class="mp kz iq ml b gy mu mr l ms mt">define PCMU 0</span><span id="2c11" class="mp kz iq ml b gy mu mr l ms mt">/*---------------------------------------------------------*/<br/>/* The function of registering payload types. */<br/>void register_payloads(void)<br/>{  <br/> /* We register the types of loads in the profile table. Later, according to the index taken parameters will be extracted from the RTP packet header from this table loads required to decode packet data. */<br/>  rtp_profile_set_payload (&amp;av_profile, PCMU, &amp;payload_type_pcm8000);<br/>}</span><span id="93e0" class="mp kz iq ml b gy mu mr l ms mt">/*---------------------------------------------------------*/<br/>/* This function is created from the function create_duplex_rtpsession() in audiostream.c of mediastreamer2. */<br/> static RtpSession *create_rtpsession (int loc_rtp_port, int loc_rtcp_port,  bool_t ipv6, RtpSessionMode mode)<br/>{  <br/>  RtpSession *rtpr;  rtpr = rtp_session_new ((int) mode);  <br/>  rtp_session_set_scheduling_mode (rtpr, 0);  <br/>  rtp_session_set_blocking_mode (rtpr, 0);<br/>  rtp_session_enable_adaptive_jitter_compensation (rtpr, TRUE);<br/>  rtp_session_set_symmetric_rtp (rtpr, TRUE); <br/>  rtp_session_set_local_addr (rtpr, ipv6 ? "::" : "0.0.0.0", loc_rtp_port,  loc_rtcp_port); <br/>  rtp_session_signal_connect (rtpr, "timestamp_jump",  (RtpCallback) rtp_session_resync, 0);<br/>  rtp_session_signal_connect (rtpr, "ssrc_changed",  (RtpCallback) rtp_session_resync, 0);<br/>  rtp_session_set_ssrc_changed_threshold (rtpr, 0);<br/>  rtp_session_set_send_payload_type(rtpr, PCMU);</span><span id="30d9" class="mp kz iq ml b gy mu mr l ms mt">  /* By default, we turn off the RTCP session, since our remote control will not use it. */  <br/> rtp_session_enable_rtcp (rtpr, FALSE);<br/> return rtpr;<br/>}</span></pre><p id="c892" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在独立的变送器文件<em class="kx"> mstest6.c </em>，清单3.9:</p><p id="d95a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.9:远程控制模拟器(发射器)</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="994d" class="mp kz iq ml b gy mq mr l ms mt">/* Файл mstest6.c Remote control simulator (transmitter). */</span><span id="bd2a" class="mp kz iq ml b gy mu mr l ms mt">#include &lt;Mediastreamer2/dtmfgen.h&gt;<br/>#include &lt;Mediastreamer2/msrtp.h&gt;<br/>#include "mstest_common.c"</span><span id="4e01" class="mp kz iq ml b gy mu mr l ms mt">/*----------------------------------------------------------*/<br/>int main()<br/>{ <br/>  ms_init();</span><span id="bc36" class="mp kz iq ml b gy mu mr l ms mt">/* We create instances of filters. */<br/>  MSFilter *voidsource = ms_filter_new(MS_VOID_SOURCE_ID); <br/>  MSFilter *dtmfgen = ms_filter_new(MS_DTMF_GEN_ID);</span><span id="8793" class="mp kz iq ml b gy mu mr l ms mt">/* Create an encoder filter. */<br/>  MSFilter *encoder = ms_filter_create_encoder("PCMU");</span><span id="f325" class="mp kz iq ml b gy mu mr l ms mt">/* Registering load types. */<br/>  register_payloads();</span><span id="fea4" class="mp kz iq ml b gy mu mr l ms mt">/* Create an RTP transmitter session. */<br/>  RtpSession *tx_rtp_session = create_rtpsession (8010, 8011, FALSE, RTP_SESSION_SENDONLY);  <br/> rtp_session_set_remote_addr_and_port(tx_rtp_session,"127.0.0.1", 7010, 7011); <br/> rtp_session_set_send_payload_type(tx_rtp_session, PCMU);  <br/> MSFilter *rtpsend = ms_filter_new(MS_RTP_SEND_ID); <br/> ms_filter_call_method(rtpsend, MS_RTP_SEND_SET_SESSION, tx_rtp_session);</span><span id="674e" class="mp kz iq ml b gy mu mr l ms mt">/* Create a source of ticks - ticker. */ <br/> MSTicker *ticker_tx = ms_ticker_new();</span><span id="f9d8" class="mp kz iq ml b gy mu mr l ms mt">/* We connect the transmitter filters. */ <br/> ms_filter_link(voidsource, 0, dtmfgen, 0);  <br/> ms_filter_link(dtmfgen, 0, encoder, 0);<br/> ms_filter_link(encoder, 0, rtpsend, 0);</span><span id="9534" class="mp kz iq ml b gy mu mr l ms mt">/* Connect the clock source. */<br/>  ms_ticker_attach(ticker_tx, voidsource);</span><span id="3793" class="mp kz iq ml b gy mu mr l ms mt">/* We set up the structure that controls the output signal of the generator. */ <br/> MSDtmfGenCustomTone dtmf_cfg; <br/> dtmf_cfg.tone_name[0] = 0; <br/> dtmf_cfg.duration = 1000; <br/> dtmf_cfg.frequencies[0] = 440;</span><span id="97db" class="mp kz iq ml b gy mu mr l ms mt">/* We will generate one tone, set the frequency of the second tone to 0. */  <br/> dtmf_cfg.frequencies[1] = 0; <br/> dtmf_cfg.amplitude = 1.0; <br/> dtmf_cfg.interval = 0.;  <br/> dtmf_cfg.repeat_count = 0.;</span><span id="22bc" class="mp kz iq ml b gy mu mr l ms mt">/* We organize a cycle of scanning of pressed keys. Entering zero completes  cycle and work of the program. */  <br/> char key='9'; <br/> printf("Press the command key then enter.\n"  <br/>"To end the program, enter 0.\n");  <br/>while(key != '0')  <br/>{<br/> key = getchar();   <br/> if ((key &gt;= 49) &amp;&amp; (key &lt;= 54)) <br/>   {<br/>      printf("Command sent: %c\n", key);<br/>      /* We set the generator frequency in accordance with the code of the pressed key. */<br/>      dtmf_cfg.frequencies[0] = 440 + 100*(key-49);</span><span id="4cfc" class="mp kz iq ml b gy mu mr l ms mt">      /* We turn on the sound generator with the updated frequency. */<br/>      ms_filter_call_method(dtmfgen, MS_DTMF_GEN_PLAY_CUSTOM,      (void*)&amp;dtmf_cfg); <br/>   }<br/>   /* We put the thread into hibernation for 20ms so that other threads     apps got time to work. */ <br/>  ms_usleep(20000);<br/>  }<br/>}</span></pre><p id="38d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，接收方文件<em class="kx"> mstest7.c </em>，清单3.10:</p><p id="a954" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.10:接收器模拟器</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="8f24" class="mp kz iq ml b gy mq mr l ms mt">/* Файл mstest7.c Receiver simulator. */<br/>include &lt;Mediastreamer2/mssndcard.h&gt;<br/>include &lt;Mediastreamer2/mstonedetector.h&gt;<br/>include &lt;Mediastreamer2/msrtp.h&gt;</span><span id="c05b" class="mp kz iq ml b gy mu mr l ms mt">/* We include a header file with functions for managing events of the mediastreamer.*/<br/>include &lt;Mediastreamer2/mseventqueue.h&gt;</span><span id="3956" class="mp kz iq ml b gy mu mr l ms mt">/* We include the file of common functions. */<br/>include "mstest_common.c"</span><span id="1e67" class="mp kz iq ml b gy mu mr l ms mt">/* Callback function, it will be called by the filter as soon as it detects that the characteristics of the input signal match the specified ones. */<br/>static void tone_detected_cb(void *data, MSFilter *f, unsigned int event_id, MSToneDetectorEvent *ev)<br/>{ <br/> printf("Command accepted: %s\n", ev-&gt;tone_name);<br/>}</span><span id="d194" class="mp kz iq ml b gy mu mr l ms mt">/*----------------------------------------------------------*/<br/>int main()<br/>{ <br/> ms_init();</span><span id="1c43" class="mp kz iq ml b gy mu mr l ms mt">/* We create instances of filters. */  <br/> MSSndCard *card_playback =  ms_snd_card_manager_get_default_card(ms_snd_card_manager_get()); <br/> MSFilter *snd_card_write = ms_snd_card_create_writer(card_playback); <br/> MSFilter *detector = ms_filter_new(MS_TONE_DETECTOR_ID);</span><span id="e8ce" class="mp kz iq ml b gy mu mr l ms mt">/* We clear the array inside the tone detector, it describes special signs of the wanted signals. */<br/>  ms_filter_call_method(detector, MS_TONE_DETECTOR_CLEAR_SCANS, 0);</span><span id="03fc" class="mp kz iq ml b gy mu mr l ms mt">/* We connect the callback function to the filter. */  <br/>ms_filter_set_notify_callback(detector,  (MSFilterNotifyFunc)tone_detected_cb, NULL);</span><span id="caa1" class="mp kz iq ml b gy mu mr l ms mt">/* We create an array, each element of which describes a characteristic one of the tones to be detected:<br/>The text name of this element,<br/>frequency in hertz,<br/>duration in milliseconds,<br/>minimum level relative to 0.775V. */<br/>  MSToneDetectorDef scan[6]= <br/> {   <br/>    {"V+", 440, 100, 0.1}, /* “Volume Up” command. */<br/>    {"V-", 540, 100, 0.1}, /* “Volume Down” command. */<br/>    {"C+", 640, 100, 0.1}, /* "Increase Channel Number" command. */<br/>    {"C-", 740, 100, 0.1}, /* “Decrease Channel Number” command. */<br/>    {"ON", 840, 100, 0.1}, /* “Switch on TV” command. */<br/>    {"OFF", 940, 100, 0.1} /* “Turn off TV” command. */<br/>  };</span><span id="4516" class="mp kz iq ml b gy mu mr l ms mt">/* We transmit "signs" of the signals to the tone detector. */<br/>  int i; <br/> for (i = 0; i &lt; 6; i++) <br/> { <br/>   ms_filter_call_method(detector, MS_TONE_DETECTOR_ADD_SCAN,    &amp;scan[i]); <br/> }</span><span id="b4e9" class="mp kz iq ml b gy mu mr l ms mt">/* We create a decoder filter. */<br/>  MSFilter *decoder=ms_filter_create_decoder("PCMU");</span><span id="99ef" class="mp kz iq ml b gy mu mr l ms mt">/* We register load types. */<br/>  register_payloads();</span><span id="954e" class="mp kz iq ml b gy mu mr l ms mt">/* Create receiver's RTP-session. */<br/>  MSFilter *rtprecv = ms_filter_new(MS_RTP_RECV_ID);<br/>  RtpSession *rx_rtp_session = create_rtpsession (7010, 7011, FALSE, RTP_SESSION_RECVONLY);<br/>  ms_filter_call_method(rtprecv, MS_RTP_RECV_SET_SESSION, rx_rtp_session);</span><span id="8113" class="mp kz iq ml b gy mu mr l ms mt">/* Create a source of ticks - ticker. */ <br/> MSTicker *ticker_rx = ms_ticker_new();</span><span id="8351" class="mp kz iq ml b gy mu mr l ms mt">/* We connect the receiver filters. */<br/>  ms_filter_link(rtprecv, 0, decoder, 0);<br/>  ms_filter_link(decoder, 0, detector, 0);<br/>  ms_filter_link(detector, 0, snd_card_write, 0);</span><span id="c524" class="mp kz iq ml b gy mu mr l ms mt">/* We connect the ticker. */<br/>  ms_ticker_attach(ticker_rx, rtprecv);<br/>  char key='9';<br/>  printf( "Enter 0 to end the program.\n");<br/>  while(key != '0') <br/> {<br/>    key = getchar();<br/>   /* We put the thread into hibernation for 20ms so that other threads      apps got time to work. */<br/>   ms_usleep(20000); <br/> }<br/>}</span></pre><p id="b323" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们编译发送器和接收器，然后在各自的控制台上运行它们。然后，它应该像以前一样工作——在发送器控制台中应该只输入1到6的数字，对它们的响应应该出现在接收器控制台中。应该可以从扬声器中听到音调。如果一切正常，那么我们已经在接收器和发送器之间建立了连接——从发送器到接收器存在RTP包的连续传输。</p><p id="2008" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是安装流量分析器的时候了，为此我们将安装控制台版本的优秀的<em class="kx"> Wireshark </em>程序—它被称为<em class="kx"> TShark </em>。为了便于描述项目管理，我选择了<em class="kx"> TShark </em>来进一步展示。有了<em class="kx"> Wireshark </em>，我将需要大量的截图，随着<em class="kx"> Wireshark </em>新版本的发布，这些截图很快就会过时。</p><p id="8c77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你知道如何使用<em class="kx"> Wireshark </em>，你可以用它来探索我们的例子。但是在这种情况下，我建议您学习<em class="kx"> TShark </em>，因为它将帮助您自动测试您的VoIP应用程序，以及远程执行数据包捕获。</p><p id="c5de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用命令安装<em class="kx">t摇锤</em>:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="b2ac" class="mp kz iq ml b gy mq mr l ms mt">$ sudo apt-get install tshark</span></pre><p id="cc93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传统上，我们通过请求程序的版本来检查安装结果:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="a36b" class="mp kz iq ml b gy mq mr l ms mt">$ tshark --version</span></pre><p id="5e51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果得到了满意的答案，我们就继续。</p><p id="3e3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们的包目前只进入计算机内部，我们可以要求TShark只显示这样的包。为此，您需要通过传递<em class="kx">t shark</em><em class="kx">-I</em>lo选项来从环回接口(本地环路)选择捕获数据包:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="4ba4" class="mp kz iq ml b gy mq mr l ms mt">$ sudo tshark -i lo</span></pre><p id="a5ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于由我们的发射器发送的包的消息将立即开始涌入控制台(连续地，不管我们是否按下遥控器上的按钮)。也许你的计算机上有一些程序也通过本地环路发送数据包，在这种情况下，我们会收到我们和其他人的混合数据包。为了确保我们只在列表中看到我们的遥控器的数据包，我们将通过端口号启用数据包过滤。按下<em class="kx"> Ctrl-C </em>停止分析仪并添加按端口号过滤的选项，该选项使用我们的控制台作为其传输的目的端口(8010):</p><p id="8fc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx"> -f "udp端口8010" </em>。</p><p id="c7e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的命令行将如下所示:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="2c6f" class="mp kz iq ml b gy mq mr l ms mt">$ sudo tshark -i lo -f "udp port 8010"</span></pre><p id="2bc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">控制台显示以下输出(前10行):</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="2b41" class="mp kz iq ml b gy mq mr l ms mt">1 0.000000000    127.0.0.1 -&gt; 127.0.0.1    UDP 214 8010 -&gt; 7010 Len=172 <br/> 2 0.020059705    127.0.0.1 -&gt; 127.0.0.1    UDP 214 8010 -&gt; 7010 Len=172<br/> 3 0.040044409    127.0.0.1 -&gt; 127.0.0.1    UDP 214 8010 -&gt; 7010 Len=172 <br/> 4 0.060057104    127.0.0.1 -&gt; 127.0.0.1    UDP 214 8010 -&gt; 7010 Len=172<br/> 5 0.080082311    127.0.0.1 -&gt; 127.0.0.1    UDP 214 8010 -&gt; 7010 Len=172  <br/> 6 0.100597153    127.0.0.1 -&gt; 127.0.0.1    UDP 214 8010 -&gt; 7010 Len=172 <br/> 7 0.120122668    127.0.0.1 -&gt; 127.0.0.1    UDP 214 8010 -&gt; 7010 Len=172<br/> 8 0.140204789    127.0.0.1 -&gt; 127.0.0.1    UDP 214 8010 -&gt; 7010 Len=172<br/> 9 0.160719008    127.0.0.1 -&gt; 127.0.0.1    UDP 214 8010 -&gt; 7010 Len=172<br/>10 0.180673685    127.0.0.1 -&gt; 127.0.0.1    UDP 214 8010 -&gt; 7010 Len=172</span></pre><p id="9cef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，这些不是包，而是事件的编号列表，其中每一行都是关于在界面上看到的下一个包的消息。因为我们负责包过滤，所以我们在列表中只能看到关于我们的发送器的信息包的消息。接下来，让我们通过列号来破译这个表:</p><ul class=""><li id="42fd" class="nh ni iq ka b kb kc kf kg kj nj kn nk kr nl kv nm nn no np bi translated">事件编号；</li><li id="7c9f" class="nh ni iq ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">发生的时间；</li><li id="5579" class="nh ni iq ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">分组的源的IP地址和分组的接收者的IP地址；</li><li id="6cdd" class="nh ni iq ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">分组协议，显示为UDP，因为RTP分组作为UDP分组内的有效载荷发送；</li><li id="e24f" class="nh ni iq ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">以字节为单位的数据包大小，214；</li><li id="a60f" class="nh ni iq ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">数据包源的端口号；</li><li id="ff3a" class="nh ni iq ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">数据包接收器的端口号；</li><li id="27e8" class="nh ni iq ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">数据包有效负载的大小，从中我们可以得出结论，我们的发送器形成了172字节的RTP数据包，就像箱子里的鸭子一样，它位于214字节的UDP数据包中。</li></ul><p id="8fd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是时候查看UDP包内部了，为此我们将使用一组额外的密钥运行<em class="kx"> TShark </em>:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="22ef" class="mp kz iq ml b gy mq mr l ms mt">$ sudo tshark -i lo -f "udp port 8010" -P -V -O rtp -o rtp.heuristic_rtp:TRUE -x</span></pre><p id="5dbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，程序的输出将被丰富——生成它的包的内部内容的解密将被添加到每个事件中。为了更好地查看输出，您可以通过按下<em class="kx"> Ctrl-C </em>来停止<em class="kx"> TShark </em>，或者通过在run命令中向<em class="kx"> tee </em>添加管道，指定输出文件名<em class="kx"> tee &lt; filename &gt; </em>，将其输出复制到一个文件中。如果我们想将输出保存到<em class="kx"> log.txt </em>文件，该命令将如下所示:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="a108" class="mp kz iq ml b gy mq mr l ms mt">$ sudo tshark -i lo -f "udp port 8010" -P -V -O rtp -o rtp.heuristic_rtp:TRUE -x | tee log.txt</span></pre><p id="1693" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看文件中的内容，这是第一个数据包:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="6622" class="mp kz iq ml b gy mq mr l ms mt">1 0.000000000    127.0.0.1 -&gt; 127.0.0.1    RTP 214 PT=ITU-T G.711 PCMU, SSRC=0x6B8B4567, Seq=58366, Time=355368720<br/>Frame 1: 214 bytes on wire (1712 bits), 214 bytes captured (1712 bits) on interface 0<br/>Ethernet II, Src: 00:00:00_00:00:00 (00:00:00:00:00:00), Dst: 00:00:00_00:00:00 (00:00:00:00:00:00)<br/>Internet Protocol Version 4, Src: 127.0.0.1, Dst: 127.0.0.1User Datagram Protocol, Src Port: 8010, Dst Port: 7010<br/>Real-Time Transport Protocol    [Stream setup by HEUR RT (frame 1)]<br/>        [Setup frame: 1] <br/>       [Setup Method: HEUR RT]<br/>    10.. .... = Version: RFC 1889 Version (2)<br/>    ..0. .... = Padding: False<br/>    ...0 .... = Extension: False<br/>    .... 0000 = Contributing source identifiers count: 0   <br/>   0... .... = Marker: False<br/>    Payload type: ITU-T G.711 PCMU (0)<br/>    Sequence number: 58366    [Extended sequence number: 58366]<br/>    Timestamp: 355368720<br/>    Synchronization Source identifier: 0x6b8b4567 (1804289383)<br/>    Payload: ffffffffffffffffffffffffffffffffffffffffffffffff...</span><span id="5619" class="mp kz iq ml b gy mu mr l ms mt">0000  00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00   ..............E.<br/>0010  00 c8 3c 69 40 00 40 11 ff b9 7f 00 00 01 7f 00   ..&lt;i@.@.........<br/>0020  00 01 1f 4a 1b 62 00 b4 fe c7 80 00 e3 fe 15 2e   ...J.b..........<br/>0030  7f 10 6b 8b 45 67 ff ff ff ff ff ff ff ff ff ff   ..k.Eg..........<br/>0040  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff   ................<br/>0050  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff   ................<br/>0060  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff   ................<br/>0070  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff   ................<br/>0080  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff   ................<br/>0090  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff   ................<br/>00a0  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff   ................<br/>00b0  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff   ................<br/>00c0  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff   ................<br/>00d0  ff ff ff ff ff ff</span></pre><p id="4f9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在下一节分析这个清单中包含的信息，并且不可避免地讨论RTP包的内部结构。</p><h1 id="e43c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.7 RTP数据包<br/>字段</h1><p id="c164" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本节中，我们将为包装的元素涂上不同的颜色，并讨论它们的用途。</p><p id="f3df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一下同样的包装，但是有着浅色的边缘和解释性的题字，如图3.5所示。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/64a7ae43c4b87cf8f1b224d1a345f60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KWE6hDlijcBM5t4ALbR7YQ.png"/></div></div></figure><p id="b740" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">图3.5: RTP数据包的字段</p><p id="6707" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在列表的底部，突出显示了组成RTP数据包的字节，这些字节又是UDP数据包的有效负载(其标头用黑色圈出)。彩色背景表示RTP标头字节，包含RTP数据包有效负载的数据块以绿色突出显示。数据以十六进制格式显示。在我们的例子中，这是一个μ律压缩的音频信号，即一个样本的大小为1字节。由于我们使用默认采样速率(8000 Hz)，在50 Hz的数据包速率下，每个RTP数据包必须包含160字节的有效负载。我们会看到这个，算上绿色区域的字节，应该有10行。</p><p id="f915" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据该标准，有效载荷中的数据量必须是4的倍数，换句话说，必须包含整数个四字节的字。如果你的有效载荷不符合这个规则，那么在有效载荷的末尾，你需要添加带有零值的字节，并设置位<em class="kx">填充</em>。该位位于RTP报头的第一个字节，颜色为蓝绿色。请注意，所有有效负载字节都是有意义的</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="9f05" class="mp kz iq ml b gy mq mr l ms mt">0xFF</span></pre><p id="4f62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">——这就是<em class="kx"> μ律</em>中沉默的样子。</p><p id="03b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">RTP数据包报头由12个必需的字节组成，但在两种情况下可能会更长:</p><ul class=""><li id="3ea7" class="nh ni iq ka b kb kc kf kg kj nj kn nk kr nl kv nm nn no np bi translated">当分组携带通过混合来自多个源(RTP流)的信号而接收的音频信号时，则在报头的第一个12字节之后是列出源标识符的表格，其有效载荷被用于创建该分组的有效载荷。在这种情况下，第一个报头字节(起作用的源标识符计数字段)的最低四位指示源的数量。字段大小为4位，因此该表最多可以包含15个源标识符。每个都是4个字节。组织电话会议时使用此表；</li><li id="c352" class="nh ni iq ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated">当标题有扩展名时。在这种情况下，<em class="kx"> X </em>位被设置在报头的第一个字节中。在扩展头中，在成员表(如果有的话)之后，有一个单词的扩展头，后面是扩展单词。扩展名是可以用来传递附加数据的单词序列。该标准没有规定这种数据的格式，可以是任何格式。例如，它可以是接收RTP数据包的设备的一些附加设置。对于某些应用，已经开发了扩展的报头标准。例如，这是在用于通信的ED-137标准中完成的(【VoIP ATM组件的互操作性标准)。</li></ul><p id="b111" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们更详细地看看标题字段。下面的图片3.6描绘了一个具有RTP头结构的典型图片，我也无法抗拒并涂上了相同的颜色。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/36cb006aba387cb9a1e80b26c33c60b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4SrR5dCRJMonbO0NYZPSjw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">图3.6: RTP数据包报头</figcaption></figure><p id="13d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> VER </strong> —协议版本号(当前版本2)；</p><p id="10fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> P </strong> —在RTP包末尾用空字节填充的情况下设置的标志；X —标志标头已扩展；</p><p id="18bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> CC </strong> —包含永久报头之后的证监会标识符的数量(在字1之后..3)、图中未显示表格；</p><p id="7072" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> M </strong> —帧开始或通道中存在语音的标记(如果使用了语音停顿检测器)。如果接收器不包括语音暂停检测器，则该位应该永久设置；</p><p id="139b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> PTYPE </strong> —表示有效载荷的格式；</p><p id="48fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">序列号</strong> —数据包编号用于恢复播放数据包的顺序，因为实际情况是数据包可能以错误的发送顺序到达接收方。初始值应该是随机的，这样做是为了使RTP流加密后难以被破解。此字段还允许您检测丢失的数据包；</p><p id="d82e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">时间戳</strong> —时间以信号样本计量，即如果数据包包含160个样本，则下一个数据包的时间戳将多160个样本。时间戳的初始值必须是随机的；</p><p id="a3f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> SSRC </strong> —包来源标识，必须唯一。最好在启动RTP流之前随机生成它。</p><p id="a99e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您开发了自己的RTP数据包发送器或接收器，您将不得不多次检查您的数据包，为了提高这一过程的效率，我建议您在<em class="kx"> TShark </em>中掌握数据包过滤的使用，它允许您仅捕获您感兴趣的数据包。在一个有几十个RTP设备在网络上工作的环境中，这是非常有价值的。在<em class="kx"> TShark </em>命令行上，过滤参数由“-f”选项指定。当我们想从端口8010捕获数据包时，我们使用了这个选项:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="8cf9" class="mp kz iq ml b gy mq mr l ms mt">-f "udp port 8010"</span></pre><p id="3a0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">过滤参数本质上是“捕获”的数据包必须满足的一组标准。该条件可以检查数据包中某个字节的地址、端口、值。条件可以通过逻辑运算“与”、“或”等进行组合。一个非常强大的工具。</p><p id="a680" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想查看批量更改字段的动态，您需要将<em class="kx"> TShark的</em>输出复制到一个文件中，如上一节所示，方法是将<em class="kx"> TShark的</em>输出传递给tee的输入。然后，通过使用less、vim或其他可以快速处理大型文本文件并搜索字符串的工具打开日志文件，您可以找出RTP流中数据包字段行为的所有细微差别。</p><h1 id="0170" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.8提取有效载荷</h1><p id="e422" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">如果您需要收听RTP流传输的信号，那么您需要使用带有可视化界面的<em class="kx"> TShark </em>版本，即<em class="kx"> Wireshark </em>。通过简单的鼠标操作，你可以听到那里，看到信号的波形。但有一个条件——如果它以格式<em class="kx"> μ-law </em>或<em class="kx"> α-low </em>编码。</p><p id="b5d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有效载荷用16位样本表示，那么<em class="kx"> Wireshark </em>不会帮你播放。那么你可以使用下面的方法。</p><p id="b57b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<em class="kx"> TShark </em>，我们将数据包捕获到一个文件中，同时指定一个过滤器，由<em class="kx"> TShark </em>选择数据包。在这种情况下，<em class="kx"> -f "src port 8010" </em>过滤器用于接收从端口8010发送的数据包。<em class="kx">-a "</em>选项设置执行捕获的时间。如果没有这个选项，可以像往常一样用<em class="kx"> Ctrl + C </em>停止捕捉。</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="9423" class="mp kz iq ml b gy mq mr l ms mt">$ sudo tshark -i any -f "udp port 8010" -a duration:60 -w ~/out</span></pre><p id="1acf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们提取并归档有效载荷:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="5ed2" class="mp kz iq ml b gy mq mr l ms mt">tshark -r ~/out -T fields -e rtp.payload</span></pre><p id="244a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">，删除有效负载字符流中的换行符和冒号:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="c739" class="mp kz iq ml b gy mq mr l ms mt">tr -d '\n',':'</span></pre><p id="185f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们将以文本形式(十六进制数)表示的读数转换为二进制形式:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="4fb1" class="mp kz iq ml b gy mq mr l ms mt">xxd -r -ps</span></pre><p id="f3da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一行中，是这样完成的:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="2da2" class="mp kz iq ml b gy mq mr l ms mt">$ tshark -r ~/out -T fields -e rtp.payload | tr -d '\n',':' | xxd -r -ps &gt; ~/out.raw</span></pre><p id="94a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们得到输出<em class="kx">raw</em>file<em class="kx">out . raw</em>，这是一个没有头文件的<em class="kx"> wav </em>文件。要在计算机扬声器上再现它，我们必须明确指出类型、数据格式和声道数:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="34ca" class="mp kz iq ml b gy mq mr l ms mt">$ aplay -t raw --format s16_be --channels 1 ~/out.raw</span></pre><p id="316c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">样本中的字节顺序是网络化的，所以使用bigendian格式(<em class="kx"> s16_be </em>)。</p><h1 id="6456" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.9双工对讲机</h1><p id="752b" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本节中，我们将制作一个双工对讲机。该图如图3.7所示。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/9fe370e1fe8e823362fa97bf3ec7461a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RV_QIhBSaGptvuGTr9PeA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">图3.7:双工对讲机</figcaption></figure><p id="03b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">较低的滤波器链形成传输路径，从声卡开始。它提供来自麦克风的信号样本。默认情况下，这以每秒8000个样本的速率发生。mediastreamer的音频过滤器使用的数据位是16位(应该注意，这并不重要，如果您愿意，您可以编写具有更高位深度的过滤器)。数据被分组为160个样本的块。因此，每个块的大小为320字节。接下来，我们将数据输入到发生器输入端，对于处于关闭状态的数据来说，它是“透明”的。我添加它是为了防止您在调试期间厌倦了对着麦克风说话——您可以使用发生器用音调信号“拍摄”路径。</p><p id="91ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发生器之后，信号进入编码器，编码器将我们的16位样本转换为8位法则(标准G.711)。在编码器的输出端，我们已经有了一半大小的数据块。一般来说，如果我们不需要节省流量，我们可以不压缩传输数据。但是这里使用编码器是有用的，因为只有当RTP流被按定律或α定律压缩时，Wireshark 才能播放音频。</p><p id="eb5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在编码器之后，改进的数据块被发送到<em class="kx"> rtpsend </em>过滤器，该过滤器将它们放入RTP包中，设置必要的标志，并将其提供给mediastreamer，以便以UDP包的形式通过网络传输。</p><p id="c413" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的过滤器链形成接收路径，媒体流从网络接收的RTP包进入<em class="kx"> rtprecv </em>过滤器，在过滤器的输出端，它们已经以数据块的形式出现，每个数据块对应于一个接收的包。该数据块仅包含有效载荷数据，在图示的上一部分中，它们以绿色显示。</p><p id="d25b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，数据块进入解码器滤波器，将其中包含的单字节样本转换为16位线性样本。其已经可以被媒体流过滤器处理。在我们的例子中，我们只是将它们发送到声卡，以便在耳机的扬声器上播放。</p><p id="5d99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们转到软件实现。为了做到这一点，我们将合并接收器和发送器文件，这在前面是分隔的。以前，我们使用固定的端口和IP地址设置，但现在我们需要程序能够使用我们在启动时指定的设置。为此，我们将添加处理命令行参数的功能，然后我们可以设置我们希望与之建立通信的同一对讲机的IP地址和端口。</p><p id="acec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们将该结构添加到程序<em class="kx"> app_vars </em>中，该程序将存储其设置:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="7e9d" class="mp kz iq ml b gy mq mr l ms mt">struct _app_vars<br/>{<br/>  int  local_port;              /* Local port. */<br/>  int  remote_port;             /* Intercom port on remote computer. */<br/>  char remote_addr[128];        /* IP-address of remote computer. */<br/>  MSDtmfGenCustomTone dtmf_cfg; /* Test signal generator settings. */<br/>};</span><span id="e1c3" class="mp kz iq ml b gy mu mr l ms mt">typedef struct _app_vars app_vars;</span></pre><p id="29bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在程序中，它将被声明为一个名为vars的变量。然后添加一个函数来解析命令行参数:</p><p id="2935" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.11:解析命令行参数的函数</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="1360" class="mp kz iq ml b gy mq mr l ms mt">/* Function to convert command line arguments to program settings. */<br/>void  scan_args(int argc, char *argv[], app_vars *v)<br/>{<br/>    char i;<br/>    for (i=0; i&lt;argc; i++)<br/>    {<br/>        if (!strcmp(argv[i], "--help"))<br/>        {<br/>            char *p=argv[0]; p=p + 2;<br/>            printf("  %s walkie talkie\n\n", p);<br/>            printf("--help      List of options.\n");<br/>            printf("--version   Version of application.\n");<br/>            printf("--addr      Remote abonent IP address string.\n");<br/>            printf("--port      Remote abonent port number.\n");<br/>            printf("--lport     Local port number.\n");<br/>            printf("--gen       Generator frequency.\n");<br/>            exit(0);<br/>        }</span><span id="1c66" class="mp kz iq ml b gy mu mr l ms mt">        if (!strcmp(argv[i], "--version"))<br/>        {<br/>            printf("0.1\n");<br/>            exit(0);<br/>        }</span><span id="abc1" class="mp kz iq ml b gy mu mr l ms mt">        if (!strcmp(argv[i], "--addr"))<br/>        {<br/>            strncpy(v-&gt;remote_addr, argv[i+1], 16);<br/>            v-&gt;remote_addr[16]=0;<br/>            printf("remote addr: %s\n", v-&gt;remote_addr);<br/>        }</span><span id="fc29" class="mp kz iq ml b gy mu mr l ms mt">        if (!strcmp(argv[i], "--port"))<br/>        {<br/>            v-&gt;remote_port=atoi(argv[i+1]);<br/>            printf("remote port: %i\n", v-&gt;remote_port);<br/>        }</span><span id="5ce8" class="mp kz iq ml b gy mu mr l ms mt">        if (!strcmp(argv[i], "--lport"))<br/>        {<br/>            v-&gt;local_port=atoi(argv[i+1]);<br/>            printf("local port : %i\n", v-&gt;local_port);<br/>        }</span><span id="ba7a" class="mp kz iq ml b gy mu mr l ms mt">        if (!strcmp(argv[i], "--gen"))<br/>        {<br/>            v -&gt; dtmf_cfg.frequencies[0] = atoi(argv[i+1]);<br/>                printf("gen freq : %i\n", v -&gt; dtmf_cfg.frequencies[0]);<br/>        }<br/>    }<br/>}</span></pre><p id="e816" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为解析的结果，命令行参数将放在vars结构的字段中。应用程序的主要功能将从过滤器收集发送和接收路径，在连接跑马灯后，控制将被转移到一个无限循环，如果发生器频率被设置为非零，将重新启动测试发生器，使其不停止工作。由于其结构特点，发电机将需要这些重启，由于某种原因，它不能产生超过16秒的信号。应当注意，其持续时间由32位数字设置。</p><p id="d9f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个程序如清单3.12所示。</p><p id="8c71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清单3.12:内部通信模拟器</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="fc58" class="mp kz iq ml b gy mq mr l ms mt">/* Файл mstest8.c Intercom simulator. */</span><span id="72f3" class="mp kz iq ml b gy mu mr l ms mt">#include &lt;Mediastreamer2/mssndcard.h&gt;<br/>#include &lt;Mediastreamer2/dtmfgen.h&gt;<br/>#include &lt;Mediastreamer2/msrtp.h&gt;</span><span id="4437" class="mp kz iq ml b gy mu mr l ms mt">/* We include the file of common functions. */<br/>#include "mstest_common.c"</span><span id="fba4" class="mp kz iq ml b gy mu mr l ms mt">/*----------------------------------------------------------*/<br/>struct _app_vars<br/>{<br/>    int  local_port;              /* Local port. */<br/>    int  remote_port;             /* Intercom port on remote computer. */<br/>    char remote_addr[128];        /* IP-address of remote computer. */<br/>    MSDtmfGenCustomTone dtmf_cfg; /* Test signal generator settings. */<br/>};</span><span id="8a99" class="mp kz iq ml b gy mu mr l ms mt">typedef struct _app_vars app_vars;</span><span id="d507" class="mp kz iq ml b gy mu mr l ms mt">/*----------------------------------------------------------*/<br/>/* We create a duplex RTP session. */<br/>RtpSession* create_duplex_rtp_session(app_vars v)<br/>{<br/>    RtpSession *session = create_rtpsession (v.local_port, v.local_port + 1, FALSE, RTP_SESSION_SENDRECV);<br/>    rtp_session_set_remote_addr_and_port(session, v.remote_addr, v.remote_port, v.remote_port + 1);<br/>    rtp_session_set_send_payload_type(session, PCMU);<br/>    return session;<br/>}</span><span id="de2f" class="mp kz iq ml b gy mu mr l ms mt">/*----------------------------------------------------------*/<br/>/* Function to convert command line arguments to program settings. */<br/>void  scan_args(int argc, char *argv[], app_vars *v)<br/>{<br/>    char i;<br/>    for (i=0; i&lt;argc; i++)<br/>    {<br/>        if (!strcmp(argv[i], "--help"))<br/>        {<br/>            char *p=argv[0]; p=p + 2;<br/>            printf("  %s walkie talkie\n\n", p);<br/>            printf("--help      List of options.\n");<br/>            printf("--version   Version of application.\n");<br/>            printf("--addr      Remote abonent IP address string.\n");<br/>            printf("--port      Remote abonent port number.\n");<br/>            printf("--lport     Local port number.\n");<br/>            printf("--gen       Generator frequency.\n");<br/>            exit(0);<br/>        }</span><span id="e47d" class="mp kz iq ml b gy mu mr l ms mt">        if (!strcmp(argv[i], "--version"))<br/>        {<br/>            printf("0.1\n");<br/>            exit(0);<br/>        }</span><span id="08db" class="mp kz iq ml b gy mu mr l ms mt">        if (!strcmp(argv[i], "--addr"))<br/>        {<br/>            strncpy(v-&gt;remote_addr, argv[i+1], 16);<br/>            v-&gt;remote_addr[16]=0;<br/>            printf("remote addr: %s\n", v-&gt;remote_addr);<br/>        }</span><span id="647b" class="mp kz iq ml b gy mu mr l ms mt">        if (!strcmp(argv[i], "--port"))<br/>        {<br/>            v-&gt;remote_port=atoi(argv[i+1]);<br/>            printf("remote port: %i\n", v-&gt;remote_port);<br/>        }</span><span id="0f75" class="mp kz iq ml b gy mu mr l ms mt">        if (!strcmp(argv[i], "--lport"))<br/>        {<br/>            v-&gt;local_port=atoi(argv[i+1]);<br/>            printf("local port : %i\n", v-&gt;local_port);<br/>        }</span><span id="05d4" class="mp kz iq ml b gy mu mr l ms mt">        if (!strcmp(argv[i], "--gen"))<br/>        {<br/>            v -&gt; dtmf_cfg.frequencies[0] = atoi(argv[i+1]);<br/>                printf("gen freq : %i\n", v -&gt; dtmf_cfg.frequencies[0]);<br/>        }<br/>    }<br/>}</span><span id="3588" class="mp kz iq ml b gy mu mr l ms mt">/*----------------------------------------------------------*/<br/>int main(int argc, char *argv[])<br/>{<br/>    /* We set the default settings. */<br/>    app_vars vars={5004, 7010, "127.0.0.1", {0}};</span><span id="6e64" class="mp kz iq ml b gy mu mr l ms mt">    /* We set the program settings to according to the command line arguments. */<br/>    scan_args(argc, argv, &amp;vars);</span><span id="bf74" class="mp kz iq ml b gy mu mr l ms mt">    ms_init();</span><span id="13cc" class="mp kz iq ml b gy mu mr l ms mt">    /* We create instances of transmitting path filters. */<br/>    MSSndCard *snd_card =<br/>        ms_snd_card_manager_get_default_card(ms_snd_card_manager_get());<br/>    MSFilter *snd_card_read = ms_snd_card_create_reader(snd_card);<br/>    MSFilter *dtmfgen = ms_filter_new(MS_DTMF_GEN_ID);<br/>    MSFilter *rtpsend = ms_filter_new(MS_RTP_SEND_ID);</span><span id="deb7" class="mp kz iq ml b gy mu mr l ms mt">    /* We create an encoder filter. */<br/>    MSFilter *encoder = ms_filter_create_encoder("PCMU");</span><span id="f75f" class="mp kz iq ml b gy mu mr l ms mt">    /* Registering load types. */<br/>    register_payloads();</span><span id="6c41" class="mp kz iq ml b gy mu mr l ms mt">    /* Create a duplex RTP-session. */<br/>    RtpSession* rtp_session= create_duplex_rtp_session(vars);<br/>    ms_filter_call_method(rtpsend, MS_RTP_SEND_SET_SESSION, rtp_session);</span><span id="1315" class="mp kz iq ml b gy mu mr l ms mt">    /* We connect the transmitter filters. */<br/>    ms_filter_link(snd_card_read, 0, dtmfgen, 0);<br/>    ms_filter_link(dtmfgen, 0, encoder, 0);<br/>    ms_filter_link(encoder, 0, rtpsend, 0);</span><span id="b050" class="mp kz iq ml b gy mu mr l ms mt">    /* We create filters for the receiving path. */<br/>    MSFilter *rtprecv = ms_filter_new(MS_RTP_RECV_ID);<br/>    ms_filter_call_method(rtprecv, MS_RTP_RECV_SET_SESSION, rtp_session);</span><span id="c4f4" class="mp kz iq ml b gy mu mr l ms mt">    /* We create a decoder filter. */<br/>    MSFilter *decoder=ms_filter_create_decoder("PCMU");</span><span id="f138" class="mp kz iq ml b gy mu mr l ms mt">    /* Create a sound card filter. */<br/>    MSFilter *snd_card_write = ms_snd_card_create_writer(snd_card);</span><span id="98ff" class="mp kz iq ml b gy mu mr l ms mt">    /* We connect the filters of the receiving path. */<br/>    ms_filter_link(rtprecv, 0, decoder, 0);<br/>    ms_filter_link(decoder, 0,  snd_card_write, 0);</span><span id="26bb" class="mp kz iq ml b gy mu mr l ms mt">    /* Create a source of ticks - ticker. */<br/>    MSTicker *ticker = ms_ticker_new();</span><span id="72ff" class="mp kz iq ml b gy mu mr l ms mt">    /* We connect the tickrer to filters. */<br/>    ms_ticker_attach(ticker, snd_card_read);<br/>    ms_ticker_attach(ticker, rtprecv);</span><span id="ac21" class="mp kz iq ml b gy mu mr l ms mt">    /* If the generator frequency setting is different from zero, then we start the generator. */   <br/>    if (vars.dtmf_cfg.frequencies[0])<br/>    {<br/>        /* Setting up the structure that controls the output signal of the generator. */<br/>        vars.dtmf_cfg.duration = 10000;<br/>        vars.dtmf_cfg.amplitude = 1.0;<br/>    }</span><span id="8603" class="mp kz iq ml b gy mu mr l ms mt">    /* We organize a generator restart cycle. */<br/>    while(TRUE)<br/>    {<br/>        if(vars.dtmf_cfg.frequencies[0])<br/>        {<br/>            /* We turn on the sound generator. */<br/>            ms_filter_call_method(dtmfgen, MS_DTMF_GEN_PLAY_CUSTOM,<br/>                    (void*)&amp;vars.dtmf_cfg);<br/>        }<br/>        /* We put the thread into hibernation for 20ms so that other threads apps got time to work. */<br/>        ms_usleep(20000);<br/>    }<br/>}</span></pre><p id="93c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编译。然后程序可以在两台计算机上运行。或者就像我现在要做的那样。使用以下参数启动<em class="kx"> TShark </em>:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="6fe9" class="mp kz iq ml b gy mq mr l ms mt">$ sudo tshark -i lo -f "udp dst port 7010" -P -V -O RTP -o rtp.heuristic_rtp:TRUE -x</span></pre><p id="a995" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果控制台中的launch字段只显示一条关于开始捕获的消息，那么这是一个好迹象——这意味着我们的端口很可能没有被其他程序占用。在另一个终端中，启动一个程序实例，模拟端口号为7010的“远程”内部通信:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="1359" class="mp kz iq ml b gy mq mr l ms mt">$ ./mstest8 --port 9010 --lport 7010</span></pre><p id="619b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从程序的文本中可以看出，默认值是IP地址</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="6d02" class="mp kz iq ml b gy mq mr l ms mt">127.0.0.1</span></pre><p id="6925" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(本地循环)。</p><p id="3723" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一个终端中，我们启动程序的第二个实例，它模拟一个本地设备。我们使用一个额外的参数来允许内置的测试生成器工作:</p><pre class="mc md me mf gt mk ml mm mn aw mo bi"><span id="c27b" class="mp kz iq ml b gy mq mr l ms mt">$ ./mstest8 --port 7010 --lport 9010 --gen 440</span></pre><p id="7da0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，发送到“远程”设备的数据包应该开始在带有TShark的控制台中闪烁，并且会从计算机扬声器中听到连续的音调。</p><p id="892d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切都按照编写的那样发生，那么我们重新启动程序的第二个实例，但是没有“— gen 440”键和参数。你现在将成为发电机。之后，你可以对着麦克风制造一些噪音，在扬声器或者耳机里，你应该会听到相应的声音。甚至可能出现声学自激，调低扬声器音量，效果就会消失。</p><p id="21ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您已经在两台计算机上运行了这些程序，并且没有与IP地址混淆，那么您将看到相同的结果—数字质量双向语音通信。</p><p id="be41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们已经查看了mediastreamer过滤器的典型用例示例。在这种情况下，使用简单的方案，其中数据沿着一个过滤器链混合。应该说，使用过滤器MS_MIXER、MS_TEE、MS_JOIN，有可能连接和分支数据块流，这使得有可能获得它们处理的更复杂的拓扑。</p><p id="a6a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一篇文章中，我们将学习如何编写我们自己的过滤器——插件，由于这一技能，你不仅可以为声音和视频应用mediastreamer，还可以在其他特定领域应用它。</p><p id="9267" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(下一篇文章<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/whats-mediastreamer2-filters-development-4b7d05e09a0f">什么是Mediastreamer2。滤镜开发</a> <em class="kx"> ) </em></p></div></div>    
</body>
</html>