# 围棋中的 TDD，一些挑战

> 原文：<https://levelup.gitconnected.com/tdd-in-go-some-challenges-9b0ea8304c34>

![](img/7655a1bc9473054a7dc1bbf57567d611.png)

汉娜·吉伯斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

测试驱动开发( [TDD](https://en.wikipedia.org/wiki/Test-driven_development) )适合我处理问题的方式。给定一个目标，找到一个解决方案，你分解它，确定可管理的任务，并开始解决它们。要完成一项任务，你需要定义什么是成功，然后你需要做什么来实现它。TDD 只是一个分而治之的过程。它有更多的好处，但是我今天在这里的目标不是宣扬 TDD，我只是在组织讨论。很长一段时间以来，我一直以不同的正式程度使用 TDD，它对我很有效。

## TDD 不好是因为它扭曲了你的架构？

这是一个常见的异议。我不同意。理论是测试策略渗透到你的产品代码中，并降低它的质量。测试需要功能的可观察性、可预测性和隔离性，这应该符合诸如[纯功能](https://en.wikipedia.org/wiki/Pure_function)、[实体](https://en.wikipedia.org/wiki/SOLID)、[六边形](https://en.wikipedia.org/wiki/Hexagonal_architecture_(software))、[分层](https://en.wikipedia.org/wiki/Abstraction_(computer_science)#Layered_architecture)、[洋葱状](https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/) …设计和架构中的良好实践。编写可测试的代码应该有助于驱动更好的代码。

## **TDD 驾驶更佳代码**

我在 Kotlin 工作过一段时间，在 Java 工作了几十年，对我来说，TDD 确实驱动了更好的代码。在首先编写测试，然后编写通过测试的代码的过程中，我开发了一种风格，体现了许多好的设计原则。你处理了单一的责任，将关注点分开，干净地管理资源，避免副作用，等等…

## 不是纯粹主义者

当我进行 TDD 时，我不是一个纯粹主义者，也就是说当我感觉功能完成时，覆盖率不会是 100%。我更像是 80/20 型的。我以大约 80%的覆盖率完成了功能，然后回去尽可能合理地提高覆盖率。

让我们以将一些数据作为 JSON 持久化到一个文件的目标为例。我将开始将数据序列化为 JSON，然后继续编写文件。代码将处理像文件系统写失败这样的情况，但我可能不会在第一遍中测试它，我会在第二遍中返回并添加测试。

## 当我写 Kotlin 或者 Java 的时候…

我使用的工具和技术没有太大区别，第一遍达到 80%，第二遍用 Kotlin 和 Java 努力达到 100%。我没有为了测试而破坏架构。有时，我可能采用了一些嘲弄或误导来导致文件系统故障场景的发生，但这是在测试中而不是在生产代码中隔离出来的。

## 围棋带来了一些挑战

使用 Go，对于 80%的通过率来说，没有什么真正改变。我写了测试和干净的代码，一切都很好。当我回头去看最后的 20%时，事情变得具有挑战性。

让我们回过头来看看我将一些数据作为 JSON 持久化到一个文件的例子。在第二遍中，为了提高覆盖率，我希望使用 *json。元帅()*和*伊乌蒂尔。WriteFile()* 来明确表示失败。我们如何做到这一点？

## 第一轮:依赖注入在嘲讽我！

我最初的方法是为 *json 创建接口。编组*和 *ioutil。WriteFile* ，创建它们的实现，并使用依赖注入模式在生产代码中访问它们。在我的测试中，我使用了模仿模式来实现它们，并在测试中注入了模仿。模拟允许我生成我想要的错误。一切都好。覆盖率 100%。

但是…坐在后面，看着额外的接口，额外的依赖注入，以及所需的嘲讽代码…该死… ***我的测试扭曲了我的架构！*** 刚开始看起来没那么差，但是后来我加了对 *os 的支持的时候。打开，* *os。UserHomeDir* ， *json。解组*， *ioutil。这种影响变得无法忽视。*

## 第二回合:猴子式！

你很难在软件开发中找到比[猴子打补丁](https://en.wikipedia.org/wiki/Monkey_patch)更恶毒的东西了(也许除了可怕的[转到](https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf))。当然，围棋不允许。如果你愿意在 github 上使用[存档的废弃软件的话，希望可以。是*错了*，已经*扫到地毯下*了，但是不管用和好用都该死。使用它，我可以去掉所有多余的依赖注入、模拟代码和精心设计的模拟期望。相反，在我的测试中，我可以做一些简单的事情，比如:](https://github.com/bouk/monkey)

```
monkey.Patch(json.Marshal, func(v interface{}) ([]byte, error) {
   return nil, fmt.Errorf("json marshal fail")
})
```

所以我的产品代码很干净，我的测试也更简单。

## 那我该怎么办？

嗯…

*   *好的…，*我使用了 TDD，并从我习惯的方式中获得了所有的好处。
*   *…糟糕的是，*我的测试确实短暂地降低了我的设计。
*   *…还有丑陋的，*我用猴子打补丁，感觉自己有点脏。

所以归结起来就是让测试一些我习惯于简单的东西变得相当具有挑战性。我已经找到了这样做的方法，我想随着我适应得越来越多，我会找到更好的方法，但我确实觉得这是 Go 设计权衡的又一个例子，破坏了它自己宣称的成为可靠的企业级语言的使命。

[1]我认为这个过程类似于约翰·伯伊德所描述的毁灭和创造。