<html>
<head>
<title>Implementing Tony Hoare quick sort in JavaScript and LISP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript和LISP实现东尼·霍尔快速排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-tony-hoare-quick-sort-in-javascript-and-lisp-b1c1ac1f386d?source=collection_archive---------7-----------------------#2022-11-29">https://levelup.gitconnected.com/implementing-tony-hoare-quick-sort-in-javascript-and-lisp-b1c1ac1f386d?source=collection_archive---------7-----------------------#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c1e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">早在1978年，东尼·霍尔就已经创作了<em class="kl">通信顺序进程</em>，它现在被用于Clojure和GO编程语言中的多线程。托尼的另一个突出的想法是一个快速排序算法，它提供了最好情况下的时间复杂度<em class="kl"> N*log n </em>。换句话说，快速排序算法比其他实现要快得多。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/e288f369944a58f3f393b5cfe4501ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHIvNXn3_AWc5KzWpJUTkg.png"/></div></div></figure><p id="f8ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们浏览一下这个话题。这是最直观的<em class="kl">冒泡排序</em>算法，具有时间复杂度<em class="kl"> N . </em>它在两个嵌套循环中对集合进行迭代，并比较图像上显示的一对两个相邻值。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/7b76d1c3b3d09191ff46a6130cd428ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*1MiLjMYgr2r2fDORCJn89w.gif"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">来自维基百科的一篇文章<a class="ae ld" href="https://en.wikipedia.org/wiki/Bubble_sort" rel="noopener ugc nofollow" target="_blank">的气泡排序解释</a></figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="efdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在对第三行取消注释以便用长输入值列表运行它之后，它在我的笔记本(MacBook Air)上的结果是10 982毫秒。</p><p id="fc66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与插入排序实现相比。它一次接受一个元素，并在列表中为它寻找一个位置:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/434a5f4b5f65218f49cd487bead100db.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*bmfRxyIQZEK0Iu5T6YV1sw.gif"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">插入排序一次获取一个元素，并在结果列表中查找它的位置。一张图片来自<a class="ae ld" href="https://en.wikipedia.org/wiki/Insertion_sort" rel="noopener ugc nofollow" target="_blank">一篇维基百科文章</a>。</figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="d11a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">插入排序运行时间为9191毫秒。比冒泡排序略快。</p><p id="be89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是快速排序方法有多快呢？让我们来看看:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="149f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅需124毫秒即可运行！令人印象深刻。</p><p id="c039" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它怎么跑得这么快？<em class="kl">快速排序</em>从输入列表中随机抽取一个元素，并生成两个后续列表:</p><ul class=""><li id="7dd7" class="lg lh iq jp b jq jr ju jv jy li kc lj kg lk kk ll lm ln lo bi translated">元素<em class="kl">比元素小的那个；</em></li><li id="ff43" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">以及元素<em class="kl">大于元素</em>的一个。</li></ul><p id="cd37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，它对这些新列表应用相同的方法，生成四个嵌套列表(两个用于较小的列表，两个用于较大的列表)，直到整个集合最终在列表树中排序。当从树的底部到顶部合并这些列表时，你最终构建了一个排序的结果。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lu"><img src="../Images/e23df005dabb6ad8daffdcb8cb8e638d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CKFX_bND3um8UEzqA0PKQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">快速排序算法树</figcaption></figure><p id="f987" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能注意到快速排序经常使用列表。因此，使用专门为处理这种数据结构而设计的编程语言是有意义的。这是它在LISP (Clojure)中的样子:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="2291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有十行代码，比JavaScript代码小两倍。</p><p id="a8e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">总结</strong></p><p id="f280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与其他算法中的10 982毫秒和9 191毫秒相比，快速排序实现快了124毫秒。它的实现在LISP中看起来特别简洁，因为它大量使用了列表。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="5dcb" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">分级编码</h1><p id="20d3" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="6201" class="lg lh iq jp b jq jr ju jv jy li kc lj kg lk kk ll lm ln lo bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="d389" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">📰查看<a class="ae ld" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="3334" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">🔔关注我们:<a class="ae ld" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ld" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ld" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="8f28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae ld" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>