<html>
<head>
<title>TypeScript Must-Know Fundamentals — Type Aliases and Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript必备基础知识—类型别名和接口</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-must-know-fundamentals-for-your-next-tech-interview-or-project-255ae70df0a3?source=collection_archive---------11-----------------------#2022-11-01">https://levelup.gitconnected.com/typescript-must-know-fundamentals-for-your-next-tech-interview-or-project-255ae70df0a3?source=collection_archive---------11-----------------------#2022-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="88ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TypeScript提供了两种方法来为我们的数据创建定制类型，它们包括<strong class="js iu">类型别名</strong>和<strong class="js iu">接口</strong>。本文将讨论它们之间的相似之处和不同之处，以及各自的最佳用例。</p><h1 id="2bab" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">TL；博士:</h1><ul class=""><li id="79c9" class="lm ln it js b jt lo jx lp kb lq kf lr kj ls kn lt lu lv lw bi translated">类型别名和接口都可以用来描述对象的形状或函数签名。但是语法不同。</li><li id="ddf3" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated">声明合并只对接口有效，对类型别名无效。</li><li id="90fc" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated">不能用关键字<code class="fe mc md me mf b">interface</code>声明联合、交集或元组。但是，您可以在接口中使用它们。</li><li id="ad19" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated">类可以实现类型别名和接口，但不能实现表示联合类型的类型别名。</li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/6b98af17a830b8657d96f822769dd01d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*moJeTvW97yShLB7URRj5Kg.png"/></div></div></figure><p id="d034" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们开始吧！</p><h1 id="1482" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">键入别名</h1><p id="bfd7" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">一个<a class="ae mv" href="https://devdocs.io/typescript/2/everyday-types#type-aliases" rel="noopener ugc nofollow" target="_blank">类型别名</a>基本上是任何类型的名称。类型别名不仅可以用来表示原语，还可以表示对象类型、联合类型、元组和交集。让我们来看一些例子:</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="93b9" class="na kp it mf b gy nb nc l nd ne">type personName = string;<br/>type personId = string | number; // Union type<br/>type numArray = number[];</span><span id="532e" class="na kp it mf b gy nf nc l nd ne">// Object type<br/>type Person = {<br/>    id: personId; // We're making use of another type alias here<br/>    name: personName;<br/>};</span><span id="6514" class="na kp it mf b gy nf nc l nd ne">const user1: Person = {<br/>    id: 1, // ok, because it's number<br/>    name: "Bob"<br/>};<br/>const user2: Person = {<br/>    id: "2",  // ok, because it's string<br/>    name: "Alice"<br/>};<br/>const user3: Person = {<br/>    id: false,  // Not ok: 'false' is neither <!-- -->string or number<br/>    <!-- -->name: "Alice"<br/>}</span><span id="08f8" class="na kp it mf b gy nf nc l nd ne">const numbers: numArray = [1, 8, 9];</span></pre><p id="57e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型别名是用前面的<code class="fe mc md me mf b">type</code>关键字声明的。可以把它们想象成用来表示特定值的常规JavaScript变量。只要使用变量名，它就会被计算为它所代表的值。类型别名以类似的方式工作。无论您在何处通过别名对类型进行注释，别名都将评估为它所代表的类型。像变量一样，不能多次声明同一个类型别名。TypeScript也从不推断别名，您必须显式地注释它们。</p><h1 id="3948" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">接口</h1><p id="a233" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated"><a class="ae mv" href="https://devdocs.io/typescript/2/everyday-types#interfaces" rel="noopener ugc nofollow" target="_blank">接口</a>是命名数据结构的另一种方式，如对象。接口的声明语法不同于类型别名的声明语法。让我们将上面的类型别名<code class="fe mc md me mf b">Person</code>重写为一个接口声明:</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="fb57" class="na kp it mf b gy nb nc l nd ne">interface Person {<br/>    id: userId;<br/>    name: userName;<br/>}</span></pre><h1 id="51bc" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">联合和交集</h1><p id="1043" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">联合类型由两个或多个其他类型组成，表示可以是其中任何一个类型的值。交集允许我们将多个现有类型组合成一个具有这些类型所有特征的单一类型。举以下例子:</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="a2c3" class="na kp it mf b gy nb nc l nd ne">type Human = {<br/>    name: string;<br/>    speaks: boolean;<br/>};</span><span id="2872" class="na kp it mf b gy nf nc l nd ne">interface Dog {<br/>    name: string;<br/>    barks: boolean;<br/>}</span><span id="56b7" class="na kp it mf b gy nf nc l nd ne">type HumanAndDog = Human &amp; Dog; // Intersection<br/>type HumanOrDogOrBoth = Human | Dog; // Union</span><span id="2bc2" class="na kp it mf b gy nf nc l nd ne">let humanAndDog: HumanAndDog = {<br/>    // must have all the properties of Human and Dog<br/>    name: "Sparky",<br/>    speaks: false,<br/>    barks: true,<br/>};</span><span id="0f94" class="na kp it mf b gy nf nc l nd ne">let humanOrDog: HumanOrDogOrBoth = {<br/>    // can have the properties of Human or Dog, or both<br/>    name: "Tolu",<br/>    speaks: true,<br/>};</span></pre><p id="2609" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型别名和接口可以使用联合或交集组合成一个<code class="fe mc md me mf b">type</code>，但是不能组合成一个<code class="fe mc md me mf b">interface</code>。</p><h1 id="91ad" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">元组</h1><p id="a2d5" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">元组是一种输入固定长度数组的方式，考虑到了所述数组中的每一项。</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="cb7b" class="na kp it mf b gy nb nc l nd ne">type Mix = [number, string, boolean];</span><span id="f9c7" class="na kp it mf b gy nf nc l nd ne">const mix: Mix = [1, "banana", true];</span></pre><p id="0ee1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在TypeScript中，元组可以用类型声明，但不能用接口声明。但是，元组可以在接口内部使用，如下所示:</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="7f39" class="na kp it mf b gy nb nc l nd ne">interface Cat {<br/>    ageName: [number, string];<br/>}</span></pre><h1 id="b4ff" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">声明合并</h1><p id="2365" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">如果你不止一次地用相同的名字声明一个<code class="fe mc md me mf b">interface</code>，TypeScript将它们合并成一个声明，并将它们视为一个接口。这叫做<strong class="js iu">申报合并</strong>。</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="4722" class="na kp it mf b gy nb nc l nd ne">interface Person {<br/>    name: string;<br/>}</span><span id="739d" class="na kp it mf b gy nf nc l nd ne">interface Person {<br/>    age: number;<br/>}</span><span id="1df7" class="na kp it mf b gy nf nc l nd ne">type Num = number;<br/>type Num = string; // Duplicate identifier Num</span><span id="8359" class="na kp it mf b gy nf nc l nd ne">let person: Person = {<br/>    // has the properties of both instances of Person<br/>    name: "Bob",<br/>    age: 0,<br/>};</span></pre><p id="ea5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">声明合并只对接口有效。如果多次声明同一个类型别名，TypeScript将给出错误。</p><h1 id="d167" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">延伸</h1><p id="0927" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">类型别名和接口都可以扩展。但是，语法不同。派生类型别名或接口具有其基类型别名或接口的所有属性和方法，还可以定义其他成员。</p><p id="9740" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个类型别名可以使用&amp;符号扩展另一个类型别名:</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="8270" class="na kp it mf b gy nb nc l nd ne">type Human = { age : number };<br/>type Driver = Human &amp; { hasCar: boolean };</span></pre><p id="9e35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型别名也可以扩展接口:</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="0c59" class="na kp it mf b gy nb nc l nd ne">interface Human {<br/>    age: number;<br/>}</span><span id="3ae2" class="na kp it mf b gy nf nc l nd ne">type Driver = Human &amp; { hasCar: boolean };</span></pre><p id="1fd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接口可以用关键字<code class="fe mc md me mf b">extends</code>扩展类型别名:</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="205a" class="na kp it mf b gy nb nc l nd ne">type Human = {<br/>    age: number;<br/>};</span><span id="7ac5" class="na kp it mf b gy nf nc l nd ne">interface Driver extends Human {<br/>    hasCar: boolean;<br/>}</span></pre><p id="9f58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接口可以像扩展类型别名一样扩展其他接口。接口也可以扩展多个用逗号分隔的接口。</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="da9e" class="na kp it mf b gy nb nc l nd ne">interface Human {<br/>    age: number;<br/>}</span><span id="0f6c" class="na kp it mf b gy nf nc l nd ne">interface Animal {<br/>    alive: boolean;<br/>}</span><span id="d1df" class="na kp it mf b gy nf nc l nd ne">interface Driver extends Human, Animal {<br/>    hasCar: boolean<br/>}</span><span id="d247" class="na kp it mf b gy nf nc l nd ne">let driver: Driver = {<br/>    name: "Bob",<br/>    speaks: true,<br/>    alive: true,<br/>    hasCar: true<br/>}</span></pre><h1 id="8904" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">接口扩展类</h1><p id="3922" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">TypeScript允许一个接口扩展一个<a class="ae mv" href="https://devdocs.io/typescript/2/classes" rel="noopener ugc nofollow" target="_blank">类</a>。发生这种情况时，接口继承基类的成员，包括私有和公共成员，但不继承它们的实现。这意味着，当您创建一个用私有成员扩展类的接口时，只有该类或其子类可以实现该接口。这允许您将接口的使用限制在它所扩展的类的一个或多个子类上。</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="a152" class="na kp it mf b gy nb nc l nd ne">class Driver {<br/>    greet() {<br/>        console.log(`Hello!`);<br/>    }<br/>}</span><span id="c540" class="na kp it mf b gy nf nc l nd ne">// Interface extending the Driver class<br/>interface UberDriver extends Driver {<br/>    greetGuest(): void;<br/>}</span><span id="f0b4" class="na kp it mf b gy nf nc l nd ne">// New class that extends Base class and implements the Derived interface<br/>class AustralianUberDriver extends Driver implements UberDriver {<br/>    greetGuest() {<br/>        console.log("G'day Mate!");<br/>    }<br/>}</span><span id="cafb" class="na kp it mf b gy nf nc l nd ne">const driver = new AustralianUberDriver();<br/>driver.greet(); // Hello!<br/>driver.greetGuest(); // I saw this the other day...</span></pre><h1 id="9dc1" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">工具</h1><p id="0d6e" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">TypeScript支持基于类的面向对象编程。因此，它允许类使用<code class="fe mc md me mf b">implements</code>关键字实现类型别名和接口。如果一个类未能正确实现它，将会抛出一个错误。</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="7008" class="na kp it mf b gy nb nc l nd ne">// Interface being implemented by a class<br/>interface PositionInterface {<br/>    x: number;<br/>    y: number;<br/>}</span><span id="062b" class="na kp it mf b gy nf nc l nd ne">class Circle implements PositionInterface {<br/>    x = 1;<br/>    y = 1;<br/>}</span><span id="4789" class="na kp it mf b gy nf nc l nd ne">// Type alias being implemented by a class<br/>type PositionType = {<br/>    x: number;<br/>    y: number;<br/>};</span><span id="8da2" class="na kp it mf b gy nf nc l nd ne">class O<!-- -->val<!-- --> implements PositionType {<br/>    x = 1;<br/>    y = 2;<br/>}</span></pre><p id="d1c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个类也可以实现多个用逗号分隔的接口，例如<code class="fe mc md me mf b">class A implements B, C {}</code>。请注意，类不能实现或扩展表示联合类型的类型别名:</p><pre class="mh mi mj mk gt mw mf mx my aw mz bi"><span id="755d" class="na kp it mf b gy nb nc l nd ne">type PointOnAxis = { x: number } | { y: number };</span><span id="6582" class="na kp it mf b gy nf nc l nd ne">// ERROR: A class can only implement an object type or intersection of object types with statically known members.<br/>class NewPoint implements PointOnAxis {<br/>    x = 1;<br/>    y = 2;<br/>}</span></pre><blockquote class="ng nh ni"><p id="ec0a" class="jq jr nj js b jt ju jv jw jx jy jz ka nk kc kd ke nl kg kh ki nm kk kl km kn im bi translated">重要的是要理解implements子句只是检查该类是否可以被视为接口类型。它根本不会改变类的类型或它的方法。一个常见的错误来源是假设implements子句会改变类类型——它不会！<em class="it"> <br/> — </em> <a class="ae mv" href="https://www.typescriptlang.org/docs/handbook/2/classes.html#class-heritage" rel="noopener ugc nofollow" target="_blank"> <em class="it">打印公文</em> </a></p></blockquote><h1 id="8ae7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">你应该使用哪一个？</h1><p id="f8e4" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">类型别名和接口非常相似，您可以在它们之间自由选择。就个人而言，我认为类型别名更适合定义原语、联合、交集、函数或元组类型。然而，接口更适合于定义对象类型或利用声明合并。</p><h2 id="61bc" class="na kp it bd kq nn no dn ku np nq dp ky kb nr ns lc kf nt nu lg kj nv nw lk nx bi translated">延伸阅读:</h2><ul class=""><li id="6067" class="lm ln it js b jt lo jx lp kb lq kf lr kj ls kn lt lu lv lw bi translated">像专家一样使用打字键</li><li id="81d8" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated"><a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/typescript-classes-from-zero-to-hero-a429a3c96189">打字班——从零到英雄</a></li><li id="c559" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated"><a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/next-level-your-typescript-runtime-type-validation-using-class-and-decorators-ddd2ce3c86f3">使用类和装饰器的下一级Typescript运行时类型验证</a></li><li id="68aa" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated">掌握类型脚本泛型:终极指南</li><li id="c096" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated"><a class="ae mv" href="https://bootcamp.uxdesign.cc/typescript-tricks-and-tips-become-a-pro-in-no-time-5390aba151be" rel="noopener" target="_blank">打字技巧和提示:立即成为专业人士</a></li><li id="f813" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated"><a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/generics-in-typescript-must-know-fundamentals-stupidly-simplified-e7b4d7ffc0e3">TypeScript中的泛型——愚蠢简化的基础知识</a></li><li id="c0f9" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated"><a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/typescript-missed-this-but-you-shouldnt-runtime-type-validation-aa8a81ce4289"> Typescript遗漏了这一点，但你不应该—运行时类型验证</a></li><li id="ff23" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated"><a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/typescript-enum-pitfalls-and-solutions-must-know-bb971cb0f7d2"> Typescript枚举陷阱和解决方案必须知道</a></li><li id="27e6" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated"><a class="ae mv" href="https://bootcamp.uxdesign.cc/mastering-typescript-generics-the-ultimate-guide-essential-interface-techniques-86e793cf1fc" rel="noopener" target="_blank">掌握类型脚本泛型—终极指南—基本接口技术</a></li><li id="0a9f" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated">【Javascript开发者经常忽略的Typescript特性</li><li id="bc34" class="lm ln it js b jt lx jx ly kb lz kf ma kj mb kn lt lu lv lw bi translated">掌握打字稿中的交集和并集类型:终极指南和基本技巧</li></ul></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="3dd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你觉得这个指南有帮助，请鼓掌并跟我来。通过<a class="ae mv" href="https://medium.com/@caopengau/membership" rel="noopener">链接</a>加入medium，获取我和所有其他优秀作家在medium上发表的所有优质文章。</p></div></div>    
</body>
</html>