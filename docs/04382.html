<html>
<head>
<title>SPA-like instant navigation in static sites</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">静态网站中类似SPA的即时导航</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/spa-like-instant-navigation-in-static-sites-69cc07671ac6?source=collection_archive---------23-----------------------#2020-06-23">https://levelup.gitconnected.com/spa-like-instant-navigation-in-static-sites-69cc07671ac6?source=collection_archive---------23-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c8d8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一点点JavaScript改进静态站点的用户体验。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5dc3924d652e86d101e59163a3439811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nk2l2bsZDlJhoBbY4vPsvw.png"/></div></div></figure><p id="4e7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">单页应用程序具有即时导航功能。你点击一个链接，它立即改变观点。可能没有数据，你可能会看到一个加载屏幕，但导航本身是即时的，我总是在纯静态网站中错过这一点。所以，我想我会尝试实现一些非常简单的东西来实现用户体验的提升。</p><p id="47fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码的想法非常简单。我们需要获得页面上的所有链接，检查它们是否是内部的，如果是，我们需要在它们上面添加一个click事件处理程序。这个click处理程序将阻止默认操作的发生，而是使用浏览器历史API推入一个新条目，同时用新内容更新DOM。只有最后一部分有点复杂。所以我们先来看看浏览器历史API。</p><p id="2541" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它为我们提供了几个函数，我们可以使用这些函数来操作浏览器历史。它们是:</p><ol class=""><li id="7d8f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><code class="fe lz ma mb mc b">back()</code></li><li id="0a3d" class="lq lr it kw b kx md la me ld mf lh mg ll mh lp lv lw lx ly bi translated"><code class="fe lz ma mb mc b">forward()</code></li><li id="6f1a" class="lq lr it kw b kx md la me ld mf lh mg ll mh lp lv lw lx ly bi translated"><code class="fe lz ma mb mc b">go()</code></li><li id="cd87" class="lq lr it kw b kx md la me ld mf lh mg ll mh lp lv lw lx ly bi translated"><code class="fe lz ma mb mc b">pushState()</code></li><li id="c099" class="lq lr it kw b kx md la me ld mf lh mg ll mh lp lv lw lx ly bi translated"><code class="fe lz ma mb mc b">replaceState()</code></li></ol><p id="dfc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lz ma mb mc b">back()</code>和<code class="fe lz ma mb mc b">forward()</code>非常简单明了，它们基本上模仿了浏览器中的后退和前进按钮。<code class="fe lz ma mb mc b">go()</code>是相同的，除了代替后退和前进，你可以精确地指定你想要从当前位置行进多远(负数表示后退，正数表示前进；想象一条数字线，其中0是当前位置)。让我们在历史上创造一个新的条目。这也是我们要用于链接的，我们不使用<code class="fe lz ma mb mc b">replaceState()</code>的原因是它不会创建一个新的条目，它所做的只是更新当前的条目。这将意味着后退和前进按钮不会像预期的那样工作。</p><p id="7c93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，让我们开始用代码实现它。首先，我们将监听页面负载，然后遍历所有链接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="02f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，对于每个链接，我们必须检查它们是否是内部的。为此，我们可以使用每个<code class="fe lz ma mb mc b">a</code>标签都有&amp;的<code class="fe lz ma mb mc b">host</code>属性，将其与<code class="fe lz ma mb mc b">window.location.host</code>进行比较，如果它们相同，则链接是内部的。我们还将向链接添加一个<code class="fe lz ma mb mc b">data-internal</code>或<code class="fe lz ma mb mc b">data-external</code>属性，以便稍后分别设置它们的样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="91e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经有了这个基本的设置，我们需要在内部链接被点击时进行拦截，然后使用<code class="fe lz ma mb mc b">history.pushState()</code>向浏览器历史添加一个条目。但是<code class="fe lz ma mb mc b">pushState()</code>有三个参数:状态、标题和URL。在我们的例子中，我们将使用链接的<code class="fe lz ma mb mc b">href</code>作为状态对象中的<code class="fe lz ma mb mc b">route</code>，并将其作为标题&amp; URL传递。这是它的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5547" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">快速注意:</strong>使用<code class="fe lz ma mb mc b">link.getAttribute("href")</code>而不是<code class="fe lz ma mb mc b">link.href</code>来获取提供给DOM的实际href。例如，一个类似这样的a标签:<code class="fe lz ma mb mc b">&lt;a href="/foo"&gt;To foo&lt;/a&gt;</code>当被直接要求href时，会给出<code class="fe lz ma mb mc b">http://localhost:5500/foo</code>(或者它当前所在的任何域)，但是<code class="fe lz ma mb mc b">getAttribute("href")</code>会返回“/foo”。</p><p id="f005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好，现在我们的链接改变了URL而没有页面刷新，但是我们的DOM没有更新，网页看起来完全一样。所以让我们来解决这个问题。</p><h1 id="f2c7" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">更新DOM</h1><p id="0362" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">为了更新DOM，我们实际上需要获取新的DOM。由于链接指向的页面确实存在，我们可以使用<code class="fe lz ma mb mc b">fetch()</code>获取它的HTML内容&amp;，然后用它替换我们当前的HTML。因此，让我们用一个名为<code class="fe lz ma mb mc b">updateDOM</code>的异步函数来做这件事:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="2402" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，非常简单，当提供了像<code class="fe lz ma mb mc b">/about</code>或<code class="fe lz ma mb mc b">/blog/awesome-post.html</code>这样的路径时，我们将使用fetch获得响应&amp;，然后使用<code class="fe lz ma mb mc b">.text()</code>函数获得它的纯文本。一旦我们有了它，我们只需将innerHTML中的<code class="fe lz ma mb mc b">html</code>元素设置为这个文本。</p><p id="dacb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，当我们的链接被点击时，我们需要调用这个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0213" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了！现在你应该已经看到你的链接工作。但是这有几个问题。这只适用于第一页。为了解决这个问题，你需要在所有的html文件中导入你的脚本，并且我们将在更新DOM后立即调用<code class="fe lz ma mb mc b">updateLinks()</code>。我们还必须确保我们像一个普通的链接一样返回到顶部，否则我们可能会让用户感到困惑。所以现在我们的<code class="fe lz ma mb mc b">updateDom</code>函数看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c6b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们只差后退和前进按钮了。为了处理这个问题，我们需要实际监听一个名为<code class="fe lz ma mb mc b">onpopstate</code>的窗口事件，这个事件是在点击后退或前进按钮时触发的&amp;需要注意的重要一点是，它是在位置更新后触发的。这意味着我们可以使用<code class="fe lz ma mb mc b">window.location.pathname</code>作为新路径来更新我们的DOM。因此，让我们将它添加到代码中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5e76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了，现在一切都像预期的那样工作。我们已经走了很长一段路。但是……我们还是可以做一些优化的。现在我们只是更新了整个html，即使它的很多部分是完全相同的。虽然这对较小的网站来说没有太大的区别，但对较大的网站来说，这是相当不和谐的。这就是为什么我们要为此使用一个小的(550字节的minzipped)库。</p><p id="ba11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nh">—</em>DOM diff只是一个函数，它有4个参数(&amp;第5个可选参数)。这是它需要的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="f017" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，父元素将是<code class="fe lz ma mb mc b">&lt;html&gt;</code>元素，<code class="fe lz ma mb mc b">currentNodes</code>将是html元素的子节点，<code class="fe lz ma mb mc b">futureNodes</code>将是我们从获取中接收的html，&amp;我们的回调可以只是一个简单的返回参数函数。</p><p id="cc9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">唯一的问题是我们获取的html是文本，而<code class="fe lz ma mb mc b">udomdiff</code>期望它是一个节点数组。所以我们将使用<code class="fe lz ma mb mc b">DOMParser</code>和它的<code class="fe lz ma mb mc b">parseFromText()</code>函数将我们的文本转换成DOM节点。然后我们将使用<code class="fe lz ma mb mc b">querySelector</code>来获取它的html元素的子节点。让我们从这个开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c303" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经知道了，让我们使用<code class="fe lz ma mb mc b">udomdiff</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="1a9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们终于完成了！使用少量的JavaScript在静态页面之间进行平滑和即时的导航。如果你经常这样做，也许你应该看看像TurboLinks这样的已建立的库，但是对于更简单的网站，我还没有遇到任何使用它的边缘案例。</p><p id="a78e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是这篇文章的全部内容，希望对你有所帮助。你可以在这个<a class="ae ni" href="https://gist.github.com/kartiknair/bd26bbc751332f64ba85095230c29314" rel="noopener ugc nofollow" target="_blank"> GitHub Gist </a>中找到完整的源代码。想打个招呼吗？我是推特上的<a class="ae ni" href="https://twitter.com/kartikajitnair" rel="noopener ugc nofollow" target="_blank"> @kartikajitnair </a>随意DM。我现在只有这些了，注意安全！</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="e346" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nh">原载于</em> <a class="ae ni" href="https://kartikn.me/writing" rel="noopener ugc nofollow" target="_blank"> <em class="nh">我的博客</em> </a></p></div></div>    
</body>
</html>