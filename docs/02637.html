<html>
<head>
<title>Revisiting the Yield Keyword in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新审视JavaScript中的Yield关键字</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/revisiting-yield-keyword-in-javascript-74a1ec108193?source=collection_archive---------15-----------------------#2020-03-26">https://levelup.gitconnected.com/revisiting-yield-keyword-in-javascript-74a1ec108193?source=collection_archive---------15-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/00840d094d5bca51a0849f7183906bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W5BExdDCeqqOXYMr.jpg"/></div></div></figure><div class=""/><p id="bed4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe kz la lb lc b">yield</code>关键字，我们可以异步暂停和恢复一个生成器函数。</p><p id="6c98" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个<a class="ae ld" href="https://medium.com/javascript-in-plain-english/how-to-use-the-generator-function-in-javascript-continued-aada07d220c7" rel="noopener">生成器函数</a>基本上是一个普通的函数，但是不同之处在于，每当函数返回任何值时，它都借助于关键字'<strong class="kd jf"> <em class="le"> yield </em> </strong>'来完成。</p><blockquote class="lf"><p id="4ef0" class="lg lh je bd li lj lk ll lm ln lo ky dk translated">Yield关键字可以被认为是基于生成器的return关键字版本。</p></blockquote><h2 id="7df8" class="lp lq je bd lr ls lt dn lu lv lw dp lx km ly lz ma kq mb mc md ku me mf mg mh bi translated">语法:</h2><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="0499" class="lp lq je lc b gy mq mr l ms mt">[returnValue] = yield [expression]</span></pre><ul class=""><li id="9043" class="mu mv je kd b ke kf ki kj km mw kq mx ku my ky mz na nb nc bi translated"><strong class="kd jf">表达式|可选:</strong>定义通过迭代器协议从生成器函数返回的值。如果省略，则返回undefined。</li><li id="e3d3" class="mu mv je kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated"><strong class="kd jf"> returnValue | Optional : </strong>检索传递给生成器的<strong class="kd jf"> <em class="le"> next() </em> </strong>方法的可选值，以继续执行。</li></ul><p id="4262" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">后跟<code class="fe kz la lb lc b"><strong class="kd jf">yield</strong></code> <strong class="kd jf"> <em class="le"> </em> </strong>关键字的表达式值返回给生成器的调用者。我们不能从回调或嵌套函数中调用<code class="fe kz la lb lc b"><strong class="kd jf">yield</strong></code> <strong class="kd jf"> <em class="le"> </em> </strong>，它只能从包含的生成器函数中调用。</p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="965f" class="lp lq je lc b gy mq mr l ms mt">function* yieldFunction(index) {<br/>  while (index &lt; 3) {<br/>    yield index++;<br/>  }<br/>}</span><span id="17cd" class="lp lq je lc b gy ni mr l ms mt">const iterator = yieldFunction(1);<br/>console.log(iterator.next());<br/>console.log(iterator.next());</span><span id="fcbf" class="lp lq je lc b gy ni mr l ms mt"><strong class="lc jf">Output --&gt;</strong><br/>{ value: 1, done: false }<br/>{ value: 2, done: false }</span></pre><p id="0c8a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们在上面的例子中看到的，<strong class="kd jf"> <em class="le"> yield </em> </strong>关键字导致调用生成器的<strong class="kd jf"> <em class="le"> next() </em> </strong>方法，该方法返回一个<strong class="kd jf"> IteratorResult </strong>对象。</p><p id="ed97" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf"> IteratorResult </strong>对象有两个属性:<code class="fe kz la lb lc b">value</code>和<code class="fe kz la lb lc b">done</code>。<code class="fe kz la lb lc b">value</code>属性包含yield表达式的评估值，而<code class="fe kz la lb lc b">done</code>指示生成器函数是否已经完全执行。</p><p id="f4f4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">暂停<strong class="kd jf"> <em class="le">产生</em> </strong>表达式会导致发生器功能暂停。只有当我们调用<strong class="kd jf"> <em class="le"> next() </em> </strong>方法时，它才会被恢复。当遇到<strong class="kd jf"> <em class="le"> next() </em> </strong>方法时，该函数继续工作，直到面对另一个<strong class="kd jf"> <em class="le"> yield </em> </strong>或返回表达式。</p><h2 id="f3a6" class="lp lq je bd lr ls nj dn lu lv nk dp lx km nl lz ma kq nm mc md ku nn mf mg mh bi translated">另一个例子:</h2><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="634d" class="lp lq je lc b gy mq mr l ms mt">function* displayHeroes () {<br/>   var justiceLeaque = <br/>     ['Batman', 'Superman', 'Flash', 'Wonder Woman'];<br/>   for (var hero = 0; hero &lt; justiceLeaque.length; hero++) {<br/>      yield justiceLeaque[hero];<br/>   }<br/>}</span><span id="6abf" class="lp lq je lc b gy ni mr l ms mt">var hero = displayHeroes();</span><span id="261f" class="lp lq je lc b gy ni mr l ms mt">console.log(hero.next());<br/>console.log(hero.next());<br/>console.log(hero.next());<br/>console.log(hero.next());<br/>console.log(hero.next());</span><span id="08fc" class="lp lq je lc b gy ni mr l ms mt"><strong class="lc jf">Output --&gt;</strong><br/>{ value: 'Batman', done: false }<br/>{ value: 'Superman', done: false }<br/>{ value: 'Flash', done: false }<br/>{ value: 'Wonder Woman', done: false }<br/>{ value: undefined, done: true }</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e43fe68cbdc037547f64417f5a6b70a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*A1uPceiph2LN9FFd"/></div></figure><h1 id="56d8" class="np lq je bd lr nq nr ns lu nt nu nv lx nw nx ny ma nz oa ob md oc od oe mg of bi translated">用例</h1><p id="c800" class="pw-post-body-paragraph kb kc je kd b ke og kg kh ki oh kk kl km oi ko kp kq oj ks kt ku ok kw kx ky im bi translated"><strong class="kd jf"> 1。</strong>在我看来，使用<code class="fe kz la lb lc b">yield</code>最大的好处就是我们可以<strong class="kd jf">消除所有的嵌套回调问题</strong>。</p><p id="4a80" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的方式是通过引入<strong class="kd jf">协同例程</strong>的概念，这是一个可以自动停止/暂停的功能，直到它得到它需要的东西。在JavaScript中，这由<code class="fe kz la lb lc b">function*</code>表示。只有<code class="fe kz la lb lc b">function*</code>功能可以使用<code class="fe kz la lb lc b">yield</code>。让我们看看下面的例子:</p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="7fc9" class="lp lq je lc b gy mq mr l ms mt">loadFromDB('someQuery', function (err, result) {<br/>  // Do something with the result or handle the error<br/>})</span></pre><p id="6a75" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很笨拙，因为现在我们所有的代码(显然需要等待这个<code class="fe kz la lb lc b">loadFromDB</code>调用)都需要在这个难看的回调中。</p><p id="b5a8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法不好，原因如下:</p><ul class=""><li id="026f" class="mu mv je kd b ke kf ki kj km mw kq mx ku my ky mz na nb nc bi translated">所有代码都缩进一级</li><li id="525d" class="mu mv je kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">我们有这一端<code class="fe kz la lb lc b">})</code>,我们需要在任何地方跟踪它</li><li id="79d0" class="mu mv je kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">所有这些多余的术语</li><li id="8923" class="mu mv je kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">不太清楚我们这样做是为了给<code class="fe kz la lb lc b">result</code>赋值</li></ul><p id="71b3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，使用<code class="fe kz la lb lc b">yield</code>，在nice协同例程框架的帮助下，所有这些都可以在<em class="le">一行</em>中完成。</p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="051a" class="lp lq je lc b gy mq mr l ms mt">function* main() {<br/>  var result = yield loadFromDB('someQuery')<br/>}</span></pre><p id="e98e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf"> 2。它可用于向生成器发送值。</strong></p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="909b" class="lp lq je lc b gy mq mr l ms mt">function *<!-- -->sendValue<!-- -->() {<br/>    x = yield (0);<br/>    yield x*x;<br/>}<br/><br/>var gen = <!-- -->sendValue<!-- -->();<br/><br/>console.log(gen.next().value);  // prints 0<br/>console.log(gen.next(2).value); // prints 4</span></pre><p id="5d7f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是可行的，因为值<code class="fe kz la lb lc b">2</code>被分配给<code class="fe kz la lb lc b">x</code>，在发生器停止在第一个产量(返回<code class="fe kz la lb lc b">0</code>)后，将其发送给发生器。</p><p id="c7f0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf"> 3。斐波那契数列生成器</strong>使用yield关键字，尽管这不是最好的做法。</p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="bfc4" class="lp lq je lc b gy mq mr l ms mt">function* getFibbonaciSeries(){<br/>    var a = -1, b = 1, c;<br/>    while(1){<br/>        c = a + b;<br/>        a = b;<br/>        b = c;<br/>        yield c;<br/>    }   <br/>}</span><span id="9e4e" class="lp lq je lc b gy ni mr l ms mt">var fibonacciGenerator = getFibbonaciSeries();<br/>console.log(fibonacciGenerator.next().value); // 0 <br/>console.log(fibonacciGenerator.next().value); // 1<br/>console.log(fibonacciGenerator.next().value); // 1<br/>console.log(fibonacciGenerator.next().value); // 2 <br/>console.log(fibonacciGenerator.next().value); // 3</span></pre><p id="b0fd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf"> 4。异步JavaScript调用之间的依赖关系</strong></p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="5f81" class="lp lq je lc b gy mq mr l ms mt">function getRequest(url) {<br/>  axios.get(url).then((reponse) =&gt; {<br/>    it.next(response);<br/>  })<br/>}</span><span id="83c2" class="lp lq je lc b gy ni mr l ms mt">function* main() {<br/>  const result1 = yield getRequest('<a class="ae ld" href="http://some.api.com'" rel="noopener ugc nofollow" target="_blank">http://some.api.com'</a> );<br/>  const result2 = yield getRequest('<a class="ae ld" href="http://some.otherapi?id='" rel="noopener ugc nofollow" target="_blank">http://some.otherapi?id='</a> + result1.id );<br/>  console.log('Your response is: ' + result2.value);<br/>}</span><span id="af2a" class="lp lq je lc b gy ni mr l ms mt">var it = main();<br/>it.next()</span></pre><h1 id="661e" class="np lq je bd lr nq nr ns lu nt nu nv lx nw nx ny ma nz oa ob md oc od oe mg of bi translated">浏览器兼容性</h1><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/f1d7861317eaf4dfacb7e64c7ff99522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIWBd64zbgBR252MDbPthg.png"/></div></div></figure><h2 id="a8be" class="lp lq je bd lr ls nj dn lu lv nk dp lx km nl lz ma kq nm mc md ku nn mf mg mh bi translated">参考</h2><p id="d008" class="pw-post-body-paragraph kb kc je kd b ke og kg kh ki oh kk kl km oi ko kp kq oj ks kt ku ok kw kx ky im bi translated"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" rel="noopener ugc nofollow" target="_blank">Mozilla Web Docs</a><br/><a class="ae ld" href="https://stackoverflow.com/questions/2282140/whats-the-yield-keyword-in-javascript" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a></p></div></div>    
</body>
</html>