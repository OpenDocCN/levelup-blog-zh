<html>
<head>
<title>Task Management Application using Vue.js — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue.js的任务管理应用程序—第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/task-management-application-using-vue-js-part-2-d785a96acda6?source=collection_archive---------3-----------------------#2019-06-24">https://levelup.gitconnected.com/task-management-application-using-vue-js-part-2-d785a96acda6?source=collection_archive---------3-----------------------#2019-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="9515" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="e626" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/task-management-application-using-vue-js-part-1-df607ca30f48">使用Vue.js的任务管理应用—第1部分</a>中，我们讨论了如何将较大的用户界面分解成较小的组件，以及<code class="fe lk ll lm ln b">top-down</code>和<code class="fe lk ll lm ln b">bottom-up</code>方法。此外，我们讨论了如何在应用程序的上下文中使用插槽和Vuex来构建可重用的组件。</p><p id="12c9" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在本文中，您将了解到，</p><ul class=""><li id="30cd" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">如何实现表单验证</li><li id="d34c" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">创建和使用Vue.js插件</li><li id="6d7c" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">如何针对生产部署优化您的应用捆绑包</li><li id="24ba" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">在何处以及如何部署您的应用</li></ul><h2 id="8f1f" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">我们将会建造什么</h2><p id="6d69" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是完成的应用程序的截图。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mt"><img src="../Images/3eaa6e4de6f87689fa23b334575cff0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9DPrAdP0Q6eyVsKyU2rCA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">任务管理应用</figcaption></figure><h2 id="b664" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated"><strong class="ak">应用演示</strong></h2><ul class=""><li id="b9ae" class="lt lu iq kn b ko kp ks kt kw nj la nk le nl li ly lz ma mb bi translated">上surge . sh—<a class="ae lj" href="http://kanban-board-demo.surge.sh" rel="noopener ugc nofollow" target="_blank">http://kanban-board-demo . surge . sh</a></li><li id="a917" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">论netlify.com—<a class="ae lj" href="https://task-management-app.netlify.com/" rel="noopener ugc nofollow" target="_blank">https://task-management-app.netlify.com</a></li></ul><h2 id="8885" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated"><strong class="ak"> Github库</strong></h2><ul class=""><li id="ec26" class="lt lu iq kn b ko kp ks kt kw nj la nk le nl li ly lz ma mb bi translated"><a class="ae lj" href="https://github.com/techlab23/task-management-app" rel="noopener ugc nofollow" target="_blank">https://github.com/techlab23/task-management-app</a></li></ul><h1 id="d7f2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">表单验证</h1><p id="ed4f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">表单验证在任何应用程序中都是一个棘手的问题，可以用很多方法来完成。对于简单的场景，您甚至可以编写自己的表单验证功能，但是当您必须在应用程序的多个地方这样做时，这就变得很乏味了。</p><p id="0f82" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">为了解决客户端表单验证问题，Vue生态系统中有一些经过充分测试的库。像<code class="fe lk ll lm ln b"><a class="ae lj" href="https://vuelidate.netlify.com/" rel="noopener ugc nofollow" target="_blank">Vuelidate</a></code>、<code class="fe lk ll lm ln b"><a class="ae lj" href="https://baianat.github.io/vee-validate/" rel="noopener ugc nofollow" target="_blank">Vee-validate</a></code>这样的库非常有助于用几行代码集成表单验证。</p><p id="b1fa" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">为了在这个应用程序中实现表单验证，我使用了<code class="fe lk ll lm ln b">Vee-validate</code>库。设置<code class="fe lk ll lm ln b">Vee-validate</code>最简单的方法是使用<code class="fe lk ll lm ln b">Vue.use()</code>惯例导入并注册Vue，如下面的代码片段所示。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nm"><img src="../Images/6c8716d5d92f3825ce5e39c5139f4380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4voWfjbTPooFqwvcP_W8Q.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">设置Vee-验证</figcaption></figure><p id="29de" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">上面的代码将从<code class="fe lk ll lm ln b">vee-validate</code>库中导入并注册所有验证规则、mixins和locale。请注意，这种方法会增加应用程序的最终JavaScript供应商捆绑包的大小。</p><p id="da4e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">然而，在研究过程中，我在<code class="fe lk ll lm ln b">Vee-validate</code>的文档中发现，我不必导入整个库，相反，我可以只导入必要的函数、验证规则和验证消息的语言环境，以保持包的大小较小。我将在<strong class="kn ir">捆绑包优化</strong>部分检查这个设置。</p><p id="812b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我们使用表单进行以下操作:</p><ul class=""><li id="51c2" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">创建和更新任务板</li><li id="52e7" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">创建和更新任务列表，并</li><li id="93d0" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">创建和更新任务列表项</li></ul><p id="e2c2" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">下面我们来看看<code class="fe lk ll lm ln b">TaskListEdit</code>组件中<code class="fe lk ll lm ln b">vee-validate</code>的用法。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nn"><img src="../Images/6ffdb929980c5f0e49bf3cb92e5e3238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKZbk7iHT3lT_4UAn6dLhQ.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">TaskListEdit.vue</figcaption></figure><p id="0402" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在<code class="fe lk ll lm ln b">TaskListEdit</code>组件中，我们使用带有<code class="fe lk ll lm ln b">v-validate</code>指令的<code class="fe lk ll lm ln b">required</code>规则。注意，我们在带有<code class="fe lk ll lm ln b">vee-validate</code>指令(即<code class="fe lk ll lm ln b">vee-validate="'required'"</code>)的模板中直接使用验证规则。因此，我们必须用单引号将所需的验证规则括起来。</p><p id="cf09" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果您愿意，那么您也可以使用对象格式来编写有效性规则。在这种情况下，语法应该类似于<code class="fe lk ll lm ln b">v-validate="{ required: true }"</code>。</p><p id="ab0b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">当您有一个以上的验证规则，或者您想要动态地在表单中添加或删除验证规则时，对象语法提供了一种更加简洁的方法。你可以在<a class="ae lj" href="https://baianat.github.io/vee-validate/guide/syntax.html#rules-parameters" rel="noopener ugc nofollow" target="_blank"> vee-validate文档</a>中阅读更多关于语法的内容。</p><p id="2dde" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">除了<code class="fe lk ll lm ln b">vee-validate</code>指令，我们还使用<code class="fe lk ll lm ln b">data-vv-as</code>属性来提供可读的字段名称(即。列表名)用于显示验证错误。注意，<code class="fe lk ll lm ln b">data-vv-as</code>需要输入字段中的<code class="fe lk ll lm ln b">name</code>属性才能正常工作。</p><p id="1d66" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我们使用带有<code class="fe lk ll lm ln b">errors.first("fieldName")</code>的<code class="fe lk ll lm ln b">small</code> html标签来显示一个字段的验证错误。<code class="fe lk ll lm ln b">errors</code>对象由<code class="fe lk ll lm ln b">vee-validate</code>库提供，用于访问验证错误。下面是显示验证错误的语法。</p><pre class="mu mv mw mx gt no ln np nq aw nr bi"><span id="00e1" class="mh jo iq ln b gy ns nt l nu nv">&lt;small class="text-danger" style="display: block"&gt;<br/>{{ errors.first("fieldName") }}<br/>&lt;/small&gt; </span></pre><p id="6284" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">最后，我们在<code class="fe lk ll lm ln b">@click</code>事件上使用<code class="fe lk ll lm ln b">prevent</code>修饰符来改变<code class="fe lk ll lm ln b">Save List</code>按钮的默认行为，这将阻止按钮被点击时的表单提交和整个页面刷新。</p><p id="b7e0" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，我们了解了使vee-validate工作所需的标记。让我们看看组件中的<code class="fe lk ll lm ln b">handleTaskListSave</code>方法。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nw"><img src="../Images/4791feb8a7a925078a2a833b7c478ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DMycSNz6qKtp0Xmk-64aKg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">任务列表编辑— handleTaskListSave方法</figcaption></figure><p id="d847" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">因为<code class="fe lk ll lm ln b">vee-validate</code>是在全球范围内导入和注册的，所以它的基于承诺的<code class="fe lk ll lm ln b">validator</code> API对所有组件都可用。上面的代码片段验证表单，然后通过<code class="fe lk ll lm ln b">result</code>参数提供验证结果以供进一步处理。</p><p id="a42e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果验证通过，那么我们将使用所有必要的数据调用<code class="fe lk ll lm ln b">saveTaskList</code> Vuex动作，然后关闭弹出窗口。如果验证失败，<code class="fe lk ll lm ln b">vee-validate</code>将在表单中显示错误，弹出窗口将保持打开。</p><p id="f7ef" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这就是我们使用<code class="fe lk ll lm ln b">vee-validate</code>验证表单所需要做的一切。</p><p id="3345" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lk ll lm ln b">Vee-validate</code>是一个很棒的客户端验证库，拥有丰富的文档和codesandbox 上的<a class="ae lj" href="https://baianat.github.io/vee-validate/examples/" rel="noopener ugc nofollow" target="_blank">工作样本。它是CSS框架不可知的，所以你可以随意显示错误。总而言之，它使得表单验证相当简单，只需对标记做很少的修改。</a></p><p id="c570" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">客户端验证提供了更好的用户体验；但是，它不能替代服务器端验证。因此，在将用户提交的数据保存到数据库之前，必须在后端对其进行验证。</p><p id="e822" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果您正在构建一个多语言应用程序，那么将<code class="fe lk ll lm ln b">vue-i18n</code>插件与<code class="fe lk ll lm ln b">v-validate</code>连接起来，根据应用程序配置和支持的语言环境显示验证消息是非常简单的。您可以使用<code class="fe lk ll lm ln b">dictionary api</code>来提供定制的验证消息。在<a class="ae lj" href="https://baianat.github.io/vee-validate/guide/localization.html#aliases" rel="noopener ugc nofollow" target="_blank"> vee-validate文档</a>中了解更多相关信息。</p><p id="3e87" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">该应用程序还有最后一个难题，即通过设备检测来启用和禁用功能。所以让我们在下一节讨论它。</p><h1 id="766f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">设备检测</h1><p id="fecd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以使用CSS媒体查询来检测Vue组件<code class="fe lk ll lm ln b">&lt;template&gt;</code>中的设备视口。然而，当检测Vue组件<code class="fe lk ll lm ln b">&lt;script&gt;</code>中的设备时，就有点棘手了。现在，想象一下，如果您需要在应用程序中的几个或更多位置检测设备。</p><p id="fe86" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">您肯定不希望在任何地方复制逻辑，或者即使您在脚本中提取了逻辑，您仍然需要在多个地方导入脚本。这就是Vue.js插件派上用场的地方。</p><p id="785f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">根据定义，Vue.js插件增加了某些全球可用的功能。Vue插件可以添加，</p><ul class=""><li id="455f" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">全局方法或属性</li><li id="bfa7" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">一个或多个全局资产，如指令/过滤器/转换等</li><li id="7dab" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">全球混合组件选项</li><li id="cde0" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">将Vue实例方法附加到Vue.prototype</li></ul><p id="113f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">一个Vue插件可以是一个提供自己API的库，同时它也可以注入上述的全部或部分组合。</p><p id="a091" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在我们的例子中，我想检测设备(台式机、笔记本电脑和移动设备)，并基于此在应用程序中启用和禁用拖放功能。</p><p id="4268" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">为了实现设备检测，我借用了<code class="fe lk ll lm ln b"><a class="ae lj" href="https://github.com/dotneet/nuxt-device-detect" rel="noopener ugc nofollow" target="_blank">nuxt-device-detect</a></code>插件的代码，并做了一些修改，创建了一个vue.js插件。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nx"><img src="../Images/f6fd432b2ff328ef3228270f13fa5fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFfYyOpXETo_-Xb84Y-AwA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">插件代码摘录自— plugins/device-detect.js</figcaption></figure><p id="ad3a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在上面的代码片段中，插件向Vue实例注册了一个<code class="fe lk ll lm ln b">mixin</code>，并提供了对所有组件都可用的<code class="fe lk ll lm ln b">isMobile</code>、<code class="fe lk ll lm ln b">isMobileOrTablet</code>、<code class="fe lk ll lm ln b">isTablet</code>、<code class="fe lk ll lm ln b">isDesktop</code>、<code class="fe lk ll lm ln b">isIos</code>计算属性。</p><pre class="mu mv mw mx gt no ln np nq aw nr bi"><span id="22cf" class="mh jo iq ln b gy ns nt l nu nv"><strong class="ln ir">// plugins/index.js</strong><br/>import Vue from "vue"<br/>import DeviceDetect from "./device-detect"<br/>Vue.use(DeviceDetect)</span></pre><p id="6657" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">上面的代码片段使用<code class="fe lk ll lm ln b">Vue.use(DeviceDetect)</code>语法导入并注册了<code class="fe lk ll lm ln b">DeviceDetect</code>插件。</p><p id="dc2f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在我们已经了解了如何注册一个插件，让我们看看如何使用它来启用和禁用我们的应用程序中的拖放功能。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ny"><img src="../Images/7a13be0c2d8c7ba4b88401ab011dda1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZoufZuagn60MHvSazB5MUA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">TaskBoard.vue</figcaption></figure><p id="8a63" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在上面来自<code class="fe lk ll lm ln b">TaskBoard</code>组件的片段中，我使用了<code class="fe lk ll lm ln b">draggable</code>组件的<code class="fe lk ll lm ln b">disabled</code>属性来启用和禁用拖放行为。<code class="fe lk ll lm ln b">shouldAllowListOrder</code>计算属性正在使用<code class="fe lk ll lm ln b">isDesktop</code>和<code class="fe lk ll lm ln b">isTablet</code>计算属性，它们由<code class="fe lk ll lm ln b">device-detect</code>插件提供。</p><p id="d382" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果用户在桌面或平板设备上，那么<code class="fe lk ll lm ln b">shouldAllowListOrder</code>属性将返回<code class="fe lk ll lm ln b">true</code>，否则，它将返回<code class="fe lk ll lm ln b">false</code>，从而根据设备启用或禁用拖放功能。</p><p id="5843" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我们在<code class="fe lk ll lm ln b">TaskList</code>组件中也使用了类似的概念，在移动设备上禁止拖放项目，而在台式机和笔记本设备上启用。</p><h2 id="17f3" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">设备上的测试功能</h2><p id="c47c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本地设备上测试这个特性的最快方法是使用下面截图所示的<code class="fe lk ll lm ln b">npm run serve</code>运行你的项目，并在你的桌面、平板和移动设备上使用<code class="fe lk ll lm ln b">Network</code> URL。在在线部署项目之前，这是在本地测试特定于设备的特性的最简单的方法。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nz"><img src="../Images/4c6d178212d439ff917cb87fab71b4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9EWjC-aGOaQMKBlHRnnlg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">使用<code class="fe lk ll lm ln b"><strong class="bd jp">npm run serve</strong></code>在本地运行项目</figcaption></figure><p id="297e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">插件非常强大，因为它们可以使某些变量、计算属性甚至方法对应用程序中的所有组件可用。</p><p id="2f14" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在这个应用程序中，设备检测功能为自定义插件提供了一个完美的用例，但你也可以使用插件来创建外部库，如axios.js、moment.js等。也适用于所有组件。</p><p id="ff4f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，我们已经涵盖了本应用程序中使用的所有必要概念。让我们来讨论捆绑包优化。</p><h1 id="97b2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">捆绑优化</h1><p id="c473" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用Vue构建应用程序非常简单，而且有了许多组件和实用程序库，直接快速安装和使用它们总是一种诱惑。</p><p id="b4bc" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">但是，在使用任何组件或实用程序库之前，您应该始终考虑它对整个包大小的影响，并设法只导入和注册应用程序所需的组件或函数。</p><p id="d7cd" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">尽管有多种方法可以优化应用捆绑包，但在此应用的背景下，我们将关注以下内容:</p><ul class=""><li id="dff7" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated"><strong class="kn ir"> CSS包优化</strong></li><li id="1a7f" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated"><strong class="kn ir">供应商捆绑包优化</strong></li></ul><p id="86a9" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">例如，在没有任何优化的情况下，当您使用<code class="fe lk ll lm ln b">npm run build</code>构建应用程序时，在Gzipped 之前，应用程序的整体包大小为<strong class="kn ir"> ~525 KB。</strong></p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/94bd21d75832f447a260b04219b3fc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qogr9jsMPavymuwXZYlBkA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">没有优化</figcaption></figure><p id="83cf" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在让我们看看如何优化CSS包。</p><h2 id="8221" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">CSS包优化</h2><p id="1305" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">app打包的CSS大小为<strong class="kn ir"> ~140 KB </strong>。这是因为我们正在使用<code class="fe lk ll lm ln b">Bootstrap CSS Framework v4.3.1</code>，没有任何优化，CSS包将包括整个CSS框架。</p><p id="4ccd" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我们可以使用<code class="fe lk ll lm ln b">purgecss</code>和<code class="fe lk ll lm ln b">postcss-purgecss</code>包从CSS包中移除不用的类。<code class="fe lk ll lm ln b">purgecss</code>与Vue-CLI内部使用的<code class="fe lk ll lm ln b">postcss</code>库完美配合。</p><p id="02da" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lk ll lm ln b">purgecss</code>和<code class="fe lk ll lm ln b">postcss-purgecss</code>包应该作为<strong class="kn ir">开发依赖</strong>安装，以确保它们只用于构建app。</p><pre class="mu mv mw mx gt no ln np nq aw nr bi"><span id="d0ab" class="mh jo iq ln b gy ns nt l nu nv">$ npm i -D purgecss @fullhuman/postcss-purgecss</span></pre><p id="8f3b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">安装完成后，我修改了根文件夹中的<code class="fe lk ll lm ln b">postcss.config.js</code>来配置<code class="fe lk ll lm ln b">postcss</code>使用<code class="fe lk ll lm ln b">purgecss</code>，只保留使用过的类，并从最终的CSS包中去掉其余的类。</p><pre class="mu mv mw mx gt no ln np nq aw nr bi"><span id="803f" class="mh jo iq ln b gy ns nt l nu nv">const purgecss = require("<a class="ae lj" href="http://twitter.com/fullhuman/postcss-purgecss" rel="noopener ugc nofollow" target="_blank">@fullhuman/postcss-purgecss</a>")</span><span id="a418" class="mh jo iq ln b gy ob nt l nu nv">module.exports = {<br/> plugins: [<br/>  //Only add purgecss in production<br/>  process.env.NODE_ENV === "production"<br/>   ? purgecss({<br/>      content: ["./src/**/*.vue"]<br/>     })<br/>   : ""<br/> ]<br/>}</span></pre><p id="7a4b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">上面的代码确保<code class="fe lk ll lm ln b">purgecss</code>只在生产模式下运行，它将检查所有<code class="fe lk ll lm ln b">.vue</code>文件中的CSS类，并排除任何未使用的类。</p><p id="1a0a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，在配置了<code class="fe lk ll lm ln b">purgecss</code>之后，当我使用<code class="fe lk ll lm ln b">npm run build</code>构建项目时，CSS包的大小从<strong class="kn ir">的140.26 KB减少到了<strong class="kn ir">的13.08 KB。</strong></strong></p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oc"><img src="../Images/51444c8eaf7630fe009e5e2325c7dce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45AbSTuYe66w7EvLZm5rMg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">通过postcss完成purgecss安装和配置后</figcaption></figure><p id="5e19" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">光是CSS包的大小就节省了127KB！</p><p id="5c8a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">但是我们的JavaScript供应商捆绑包的大小仍然有点大，所以我使用了app bundle analyser来查找哪个库负责更大的JS捆绑包大小。这样，我就可以研究并找出如何减少他们在我们的应用程序中的足迹。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi od"><img src="../Images/40ac8ec612374ca955b8777168be370a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPROMCwEBng-XJMtbkE81g.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">Vue-CLI — App捆绑包分析器</figcaption></figure><h2 id="3a18" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">供应商捆绑优化</h2><p id="4025" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在查看了analyser中的供应商捆绑包后，我发现vee-validate库已经完整地包含在内了。当我们使用下面的代码导入并注册<code class="fe lk ll lm ln b">Vee-validate</code>库时，它包含了供应商捆绑包中的整个库。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nm"><img src="../Images/6c8716d5d92f3825ce5e39c5139f4380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4voWfjbTPooFqwvcP_W8Q.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">vee的默认安装-验证</figcaption></figure><p id="cb9b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">但是，有一种更好的方法将<code class="fe lk ll lm ln b">Vee-validate</code>包含在我们的应用程序中。我创建了一个单独的插件文件来保存与vee-validate导入和注册相关的代码。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oe"><img src="../Images/f9f57dff84288709917cd8a51d22d69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6rTb6a3NQmIo3aFsrgvxAQ.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">自定义安装vee-validate-plugins/vee-validate . js</figcaption></figure><p id="ad2a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在上面的代码中，我们只从<code class="fe lk ll lm ln b">vee-validate.minimal.esm.js</code>导入<code class="fe lk ll lm ln b">Validator</code>和<code class="fe lk ll lm ln b">install</code>方法，然后再一次只从<code class="fe lk ll lm ln b">rules.esm.js</code>导入<code class="fe lk ll lm ln b">required</code>验证规则。我们没有导入所有已定义的语言环境，而是专门为验证消息导入了<code class="fe lk ll lm ln b">en</code>语言环境。</p><p id="d133" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">导入之后，我们简单地用vee-validate连接验证规则和区域设置，最后使用<code class="fe lk ll lm ln b">Vue.use(VeeValidate)</code>命令向Vue注册<code class="fe lk ll lm ln b">VeeValidate</code>。</p><p id="a254" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，让我们再运行一次构建，看看有什么不同。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi of"><img src="../Images/621d1167e8e86d83c62a7c84324ddaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04NYpgXjzdcgL6A220TSFg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">Vee后-验证配置</figcaption></figure><p id="4f5b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在vee-validate相关优化之后，我们的供应商捆绑包大小已经从<strong class="kn ir"> ~347 KB </strong>下降到<strong class="kn ir"> ~300 KB </strong>。这让我们在供应商捆绑包大小上节省了<strong class="kn ir"> ~47 KB </strong>。</p><p id="3f0c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">与我们开始时大约525 KB的整体包大小相比，我们现在已经将整体包大小减少到大约350 KB。</p><p id="ab08" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">经过优化后，我们节省了<strong class="kn ir"> ~174 KB </strong>的总捆绑包大小，这肯定会使我们的应用程序在较慢的连接上加载更快。</p><p id="61b9" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在构建应用程序时，捆绑包优化经常是事后才想到的，也就是说，它需要在应用程序构建完成后进行。这往往会让我们的应用捆绑包变得更大，到最后，优化变得更加困难。</p><p id="c995" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">因此，聪明的开发人员从一开始就监控包的大小，甚至鼓励团队成员导入特定的功能或组件，而不是导入整个库。这从一开始就控制了包的大小，使他们能够交付高质量和高性能的应用程序。</p><h1 id="9611" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">部署应用程序</h1><p id="cc36" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在开发应用程序时，您可能希望将它部署到开发或临时服务器上进行测试。在这一点上，你可以选择将应用程序部署到你的私人网络托管服务器，或者使用云托管服务，如<a class="ae lj" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank"> Netlify </a>、<a class="ae lj" href="https://surge.sh/" rel="noopener ugc nofollow" target="_blank"> surge.sh </a>、<a class="ae lj" href="https://heroku.com/" rel="noopener ugc nofollow" target="_blank"> heroku </a>、<a class="ae lj" href="https://zeit.co" rel="noopener ugc nofollow" target="_blank">zeit.co</a>、<a class="ae lj" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">亚马逊网络服务</a>甚至<a class="ae lj" href="https://azure.microsoft.com/en-us/" rel="noopener ugc nofollow" target="_blank"> azure </a>。</p><p id="2ddf" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在该应用的上下文中，我们将讨论到<code class="fe lk ll lm ln b">Surge.sh</code>的应用部署，并演练<code class="fe lk ll lm ln b">Netlify</code>持续部署设置。</p><p id="46eb" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">请记住，<code class="fe lk ll lm ln b">Surge.sh</code>纯粹是一个部署静态网站或应用的平台。同时，<code class="fe lk ll lm ln b">Netlify</code>拥有更丰富的功能，如持续部署、表单、全球CDN、无服务器功能等等。</p><h2 id="b976" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">部署到surge.sh</h2><p id="aaa8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你还没有安装surge，那么我建议你全局安装，这样你就可以轻松地将任何vue.js app部署到<code class="fe lk ll lm ln b">Surge.sh</code>上。</p><pre class="mu mv mw mx gt no ln np nq aw nr bi"><span id="57d8" class="mh jo iq ln b gy ns nt l nu nv">// To install surge globally<br/>$ npm install -g surge</span></pre><p id="395c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">一旦你安装了它，然后在终端运行<code class="fe lk ll lm ln b">surge login</code>登录或创建你的免费帐户。</p><p id="5088" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">为了简化从终端的快速部署，我在<code class="fe lk ll lm ln b">package.json</code>中添加了一些额外的命令(<code class="fe lk ll lm ln b">deploy</code>和<code class="fe lk ll lm ln b">deploy-staging</code>)来构建应用程序，然后无缝地部署到<code class="fe lk ll lm ln b">surge.sh</code>。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi og"><img src="../Images/81d42082c67c5ad6c486159ff408c9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1CRMiMPpTgCqzaKw62TyA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">NPM命令</figcaption></figure><p id="ed07" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lk ll lm ln b">deploy</code> npm命令将使用<code class="fe lk ll lm ln b">vue-cli-service</code>构建app，切换到<code class="fe lk ll lm ln b">dist</code>目录，然后使用<code class="fe lk ll lm ln b">surge</code> CLI命令将app部署到<code class="fe lk ll lm ln b">Surge.sh</code>。您可以运行以下命令来部署您的应用程序。</p><pre class="mu mv mw mx gt no ln np nq aw nr bi"><span id="3c56" class="mh jo iq ln b gy ns nt l nu nv">$ npm run deploy</span></pre><p id="3768" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lk ll lm ln b">deploy-staging</code> npm命令执行完全相同的操作，只是它被配置为将应用程序部署到不同的URL。</p><pre class="mu mv mw mx gt no ln np nq aw nr bi"><span id="4e01" class="mh jo iq ln b gy ns nt l nu nv">npm run deploy-staging</span></pre><p id="809e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">请注意，您需要更改部署URL的。如果要部署到surge.sh。</p><h2 id="893e" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">使用netlify的连续部署设置</h2><p id="abff" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">部署到<code class="fe lk ll lm ln b">Netlify</code>并为您的应用程序设置持续部署非常简单。使用<code class="fe lk ll lm ln b">Netlify</code>的持续部署提供了最少摩擦和极其高效的工作流来构建应用程序。</p><p id="6102" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">通过持续部署，<code class="fe lk ll lm ln b">Netlify</code>将使用您选择的Git提供者(Github，Gitlab，BitBucket)设置webhooks，以接收关于您的在线Git存储库中提交的通知。</p><p id="5b7b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">当你向一个在线git存储库推送一个新的提交时，<code class="fe lk ll lm ln b">Netlify</code>会收到来自webhook/s的通知，这将触发<code class="fe lk ll lm ln b">Netlify</code>机器人获取你的最新代码，然后构建并部署应用。</p><p id="249f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这是一次性的设置，可以简化应用程序的部署，甚至使应用程序开发过程变得愉快。</p><h2 id="d15c" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">设置连续部署的步骤</h2><p id="5078" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在继续之前，请确保您已经在Github、Gitlab或BitBucket上创建了一个在线存储库，并将最新的代码推送到该存储库。</p><p id="7b20" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，前往<a class="ae lj" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank">netlify.com</a>创建你的账户。如果您已经有帐户，请随意跳过这一步。</p><p id="2717" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在您登录到<code class="fe lk ll lm ln b">Netlify</code>之后，您可以使用<code class="fe lk ll lm ln b">New site from Git</code>按钮从您的存储库中创建一个站点。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/25c117f1774c09b6e44b2667260df188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*82g3qvQ1WSRgr9CGmXt7Yw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated"><strong class="bd jp">站点- &gt; </strong> <code class="fe lk ll lm ln b"><strong class="bd jp">New site from Git</strong></code> <strong class="bd jp">按钮</strong></figcaption></figure><p id="72f3" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">一旦你点击按钮，然后<code class="fe lk ll lm ln b">Netlify</code>将引导你通过一个三步的过程来建立你的网站。</p><h2 id="b8ef" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">步骤1:连接到Git提供者</h2><p id="fafa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在下面的图片中，您可以选择一个Git提供者，在那里您已经创建了您的代码库。<code class="fe lk ll lm ln b">Netlify</code>然后将向Github提供商进行认证，并要求您授权必要的权限。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oi"><img src="../Images/951720722d114ffb0fce62fdd58dfdb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ppXeQAc8NHVFEFewThrPQ.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated"><strong class="bd jp">连接到Git提供者</strong></figcaption></figure><h2 id="c824" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">步骤2:选择一个存储库</h2><p id="c073" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在您授权了<code class="fe lk ll lm ln b">Netlify</code>之后，您可以选择您想要部署的存储库。在我的例子中，我选择了<code class="fe lk ll lm ln b">task-management-app</code>存储库。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oj"><img src="../Images/5e00d4f757020880d6585fe15edd4223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-Y7e0gbbwspEjbnbQukQg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated"><strong class="bd jp">挑选一个储存库</strong></figcaption></figure><h2 id="91a5" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">步骤3:构建选项和部署</h2><p id="2bbe" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这一步中，我们将配置持续部署构建设置。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ok"><img src="../Images/e6b61c3da3736eb38990a2a7d490a0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKQLJ2POiWPUu0sSd1NXQg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated"><strong class="bd jp">持续部署构建设置</strong></figcaption></figure><p id="9160" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">您可以选择要部署的分支。默认情况下，<code class="fe lk ll lm ln b">Netlify</code>将<code class="fe lk ll lm ln b">master</code>分支视为<code class="fe lk ll lm ln b">production</code>。对于构建设置，我使用<code class="fe lk ll lm ln b">npm run build</code>作为构建命令，并使用<code class="fe lk ll lm ln b">dist</code>文件夹进行部署。</p><p id="5801" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">一旦你完成了这一步，那么<code class="fe lk ll lm ln b">Netlify</code>将设置webhooks按照这个顺序执行下面的动作。</p><ul class=""><li id="c284" class="lt lu iq kn b ko lo ks lp kw lv la lw le lx li ly lz ma mb bi translated">要从Git提供者接收提交信息，</li><li id="6a58" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">从Git仓库中提取代码并构建它</li><li id="a482" class="lt lu iq kn b ko mc ks md kw me la mf le mg li ly lz ma mb bi translated">以随机名称将其部署到新站点。</li></ul><h2 id="914c" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">更改网站名称</h2><p id="445f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了给站点起一个更有意义的名字，你可以转到<code class="fe lk ll lm ln b">settings-&gt;site details</code>部分并点击<code class="fe lk ll lm ln b">Change site name</code>按钮。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ol"><img src="../Images/ef998db8a30858dcdc40a601cc5e223a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5fl2GaQ9Y-r4c6Zo3DY3w.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">设置-&gt;站点详细信息-&gt;更改站点名称</figcaption></figure><p id="5ce4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这就是使用<code class="fe lk ll lm ln b">Netlify</code>设置持续部署所需要做的全部工作。</p><p id="762d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，每当你向主分支提交时,<code class="fe lk ll lm ln b">Netlify</code>就会自动拉取、构建和部署你的应用。</p><h2 id="0906" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">部署另一个Git分支</h2><p id="9822" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有些情况下，当您在另一个Git分支中工作(例如，开发或登台)并且想要在推进到生产分支之前首先进行部署和测试，那么您也可以为项目的单个分支设置连续部署，如下所示。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi om"><img src="../Images/7f0081356cb14f942904b080ef8bc689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YKa-1ITEBHopUXTzcXqgQ.png"/></div></div></figure><p id="2bcf" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">设置好之后，当您提交到<code class="fe lk ll lm ln b">development</code>分支时，<code class="fe lk ll lm ln b">Netlify</code>将从<code class="fe lk ll lm ln b">development</code>分支中提取代码，然后自动为您构建和部署。</p><p id="960a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">根据配置的站点名称和选择的分支，您将获得该分支的站点URL。分支机构的站点URL遵循一定的格式。</p><p id="6e81" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lk ll lm ln b">https://&lt;branch-name&gt;--&lt;site-name&gt;.netlify.com</code></p><p id="349c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">例如:</strong>如果你的分支名称是<code class="fe lk ll lm ln b">development</code>，站点名称是<code class="fe lk ll lm ln b">task-management-app</code>，那么部署URL将会是，</p><p id="3209" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lk ll lm ln b">https://development--task-management-app.netlify.com</code></p><h2 id="7213" class="mh jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">通过netlify.toml构建配置</h2><p id="7eba" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">除了在创建站点时提供构建设置之外，您还可以在项目的根文件夹中创建一个<code class="fe lk ll lm ln b">Netlify</code>配置文件<code class="fe lk ll lm ln b">netify.toml</code>。该文件用于覆盖构建和部署设置，并为<code class="fe lk ll lm ln b">Netlify</code>构建机器人提供额外的站点配置设置。</p><p id="6eba" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里是我们项目中使用的<code class="fe lk ll lm ln b">netlify.toml</code>文件的例子。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi on"><img src="../Images/2edb7213181e3b9b1a2a61ae9e732d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TI0y-B0vEbGU6BAkOeJ5Xg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">netlify.toml</figcaption></figure><p id="41b0" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在<code class="fe lk ll lm ln b">netlify.toml</code>文件中，我们有<code class="fe lk ll lm ln b">build</code>和<code class="fe lk ll lm ln b">redirects</code>部分。在构建部分，我们提供了一个<code class="fe lk ll lm ln b">command</code>来构建项目，并提供了<code class="fe lk ll lm ln b">publish</code>来发布目录。<code class="fe lk ll lm ln b">redirects</code>部分用于定义网站的重定向规则。这里是关于<code class="fe lk ll lm ln b"><a class="ae lj" href="https://www.netlify.com/docs/netlify-toml-reference/" rel="noopener ugc nofollow" target="_blank">netlify.toml</a></code>文件的文档。</p><p id="e969" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在<code class="fe lk ll lm ln b">Surge.sh</code>上部署应用程序非常简单，非常适合静态网站、个人作品集、原型和演示等。</p><p id="2d6a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">相比之下，<code class="fe lk ll lm ln b">Netlify</code>为您的应用程序提供了一个完整的平台，并提供了卓越的开发者体验。<code class="fe lk ll lm ln b">Netlify</code>无论是开发爱好类app，还是企业级应用，都适合。在<code class="fe lk ll lm ln b">Surge.sh</code>和<code class="fe lk ll lm ln b">Netlify</code>上部署这个应用程序后，我享受到了<code class="fe lk ll lm ln b">Netlify</code>提供的无缝开发体验，从Git存储库中连续部署应用程序。</p><h1 id="29e5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="6d9a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个由两部分组成的系列文章中，我们了解了设计复杂用户界面的幕后过程和技术，以及将较大的界面分解成较小的专用和通用/可重用组件的几种方法，这有助于我们分阶段构建应用程序。我们还了解到，考虑每个组件的责任有多重要，因为通常情况下，组件的责任满足应用程序中的一个特性。</p><p id="bddd" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">当我们需要在多个组件之间共享应用程序数据时，我们使用Vuex来管理共享数据的应用程序范围状态。除了使用EventBus模式来简化整个应用程序中的组件通信，我们还使用插槽来构建可重用的组件。</p><p id="9d54" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在应用程序环境中，我们讨论了拖放功能的实现、使用Vee-Validate的表单验证、用于设备检测的自定义Vue.js插件、捆绑包优化以及通过持续部署管道将应用程序部署到Surge.sh和Netlify以简化开发工作流程。</p><p id="c04f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">虽然所有关键的前端功能都在应用程序中实现，但您可以添加更多的功能，如任务项中的图像上传支持，允许存储任务的优先级标签，按日期或优先级排序等，以扩展应用程序，甚至开发您选择的后端，使该应用程序与数据库连接。</p><p id="1cdb" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果你错过了上面应用程序代码的链接，这里是<a class="ae lj" href="https://github.com/techlab23/task-management-app" rel="noopener ugc nofollow" target="_blank"> Github库</a>。</p><p id="8ac5" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果你是初学者，想更好的理解Vue.js，那就用Vue.js  读《组件中的<a class="ae lj" href="https://medium.com/@_shirish/thinking-in-components-with-vue-js-a35b5af12df" rel="noopener"> <strong class="kn ir">思维》。</strong></a></p></div><div class="ab cl oo op hu oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ij ik il im in"><blockquote class="ov ow ox"><p id="2d15" class="kl km oy kn b ko lo kq kr ks lp ku kv oz lq ky kz pa lr lc ld pb ls lg lh li ij bi translated">由于这篇文章不是medium的计量付费墙的一部分，请通过在你的网络中分享它来帮助我接触更多的人，如果你觉得慷慨，那么给这篇文章更多的掌声。</p><p id="3e68" class="kl km oy kn b ko lo kq kr ks lp ku kv oz lq ky kz pa lr lc ld pb ls lg lh li ij bi translated">也别忘了在推特上关注我<a class="ae lj" href="https://twitter.com/_shirish" rel="noopener ugc nofollow" target="_blank"> @_shirish </a>。</p></blockquote></div></div>    
</body>
</html>