<html>
<head>
<title>Build a scrollbar for Flutter Web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Flutter Web创建滚动条</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-scrollbar-for-flutter-web-73e15157a029?source=collection_archive---------5-----------------------#2020-06-18">https://levelup.gitconnected.com/build-a-scrollbar-for-flutter-web-73e15157a029?source=collection_archive---------5-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fd35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这似乎是Flutter web唯一不包括的东西。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3648f3da11d92715c07f5fb746d31a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mIsR_hRJXfBy_sfSCiVQfQ.gif"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">偷看左边的滚动条☝️</figcaption></figure><p id="4341" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很有可能，你已经尝试过用Flutter构建一个web应用。你可能会像我一样，在短时间内创造出令人印象深刻的东西。太好了！当我意识到为网络而不仅仅是移动设备创建页面的潜力时，我非常兴奋。然而，我很快被一个令人震惊的事实击中。flutter web<em class="le"/>目前没有在浏览器中滚动的原生方式。</p><p id="0ae2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我知道，这很糟糕。特别是当你已经创建了一个非常好的网页，你不想浪费你所有的努力，但是你也知道用户能够使用滚动条滚动是多么重要。我的意思是，它是为“网络”而建的……对吗？</p><p id="6e58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之，长话短说，我最终努力为Flutter web创建一个简单的滚动条。令我完全惊讶的是，我居然能想出一些半体面的东西。希望这篇文章能帮助那些正在寻找解决这种愚蠢的(但威胁品牌)问题的人。</p><h2 id="8451" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">先决条件:</h2><p id="a742" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我将假设你已经有一些颤振知识，你甚至可能有一个现有的web项目，只需要一个滚动条。</p><p id="dbd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，为了实现这一点，您需要首先拥有一个用于滚动的小部件。例如，我正在使用一个<code class="fe md me mf mg b">SingleChildScrollView,</code>，但是在Flutter中有许多可滚动的窗口小部件。只要你能给它分配一个<code class="fe md me mf mg b">ScrollController()</code>就没问题。</p><p id="a25f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">说到<code class="fe md me mf mg b">ScrollController()</code>，这正是我们需要的来帮助我们完成这项工作，但是<em class="le">为什么</em>？将滚动控制器分配给ScrollView将使我们能够在小部件上设置和访问不同的值。作为一个例子，我们将在后面看到，滚动控制器只允许我们做两件事:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8c27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太棒了，现在您已经有了一个可滚动的小部件，并且已经创建了一个附加到它上面的滚动控制器，是时候考虑视图本身的结构了。我所说的结构的意思是，我们怎样才能使滚动条保持在右边(也许是左边🤷🏽‍♀️)这一页，而其他一切都保持原样？</p><p id="5844" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">令人欣慰的是，Flutter很友好地为我们提供了一个名为<code class="fe md me mf mg b">Stack.</code>的小部件，如果你不熟悉<a class="ae mj" href="https://api.flutter.dev/flutter/widgets/Stack-class.html" rel="noopener ugc nofollow" target="_blank">堆栈</a>，它只是一种相对于父框定位小部件的方式，这些小部件将根据它们在<code class="fe md me mf mg b">children[].</code>中的位置基本上相互重叠。我知道不看代码很难可视化和理解代码，所以我将继续插入完整的代码。您也可以在这里查看示例项目<a class="ae mj" href="https://github.com/cairacshields/flutter_web_scroller" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="d6be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我知道这可能看起来有很多代码，但对于一个自定义滚动条解决方案来说，这还不算太糟糕。你可能会在<code class="fe md me mf mg b">26</code>行注意到我们有了自己的<code class="fe md me mf mg b">Stack</code>小部件，更重要的是，你会注意到栈的第一个子元素是我们网页的<strong class="js iu">主</strong>内容(即<code class="fe md me mf mg b">SingleChildScrollView</code>)。重要的是，主要内容是堆栈中的第一个子元素，否则它会覆盖滚动条。此外，你需要对你的主要内容整体有多高有一个大概的了解。我说<em class="le">‘轻微理论’</em>是因为你不需要硬编码的数字，只需要知道你的内容有多高就行了。如果现在还不明白，不要担心，当我们进行实际计算时，我会解释更多。现在，让我们看看更多的造型。</p><p id="84f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你把眼睛移到第<code class="fe md me mf mg b">57,</code>行，你会看到滚动条的样式从哪里开始。我们首先有一个容器，它占据了网页的整个高度，它有一个可定制的宽度，我刚刚决定设置为20.0。但是，您可以根据自己的喜好进行设置，只是要记住，改变条形的宽度也需要改变其他值。就像它正下方的边距一样——注意我们是如何通过将左边距指定为<em class="le">edge insets . only(left:media query . of(context). size . width—20.0)</em>来将滚动条一直推到屏幕的左侧。其中20.0，<strong class="js iu">必须</strong>匹配我们滚动条的宽度。我也给了滚动条一种半透明的黑色，这是完全可定制的。</p><p id="fbea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，您应该能够运行您的应用程序，并在页面左侧看到滚动条！很好，但是它什么也做不了。让我们来看看实际的拖动小部件。这从第<code class="fe md me mf mg b">64</code>行开始，也只是一个简单的带有子容器的容器。让我们来看看这个容器的材质:</p><h2 id="e141" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">画面</h2><ul class=""><li id="7d42" class="mk ml it js b jt ly jx lz kb mm kf mn kj mo kn mp mq mr ms bi translated">从对齐开始——您需要将它设置为<code class="fe md me mf mg b">Alignment.topCenter</code>,这将确保拖动小部件从窗口顶部开始，并在滚动条空间内居中。</li><li id="1bd1" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">接下来，我们将滚动条容器的子容器指定为一个<code class="fe md me mf mg b">GestureDetector</code>。如果你不熟悉<a class="ae mj" href="https://api.flutter.dev/flutter/widgets/GestureDetector-class.html" rel="noopener ugc nofollow" target="_blank">手势检测器</a>，它们是一个非常酷的小工具，让你能够监听和响应发生在手势检测器子节点上的不同事件。</li><li id="a7c5" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">现在我们创建实际的拖动小部件。这将是手势检测器的孩子，它只是另一个可定制宽度和高度的容器。容器上还有一个装饰，简单地给它一些颜色和漂亮的圆边。</li><li id="62d3" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">这个拖动小部件的一个非常重要的部分是边距。除了因为风格原因将5.0赋给左右两边，我们还将一个名为<code class="fe md me mf mg b">_offset</code>的变量赋给了这个拖动小部件的上边距。你也许能想象出每当<code class="fe md me mf mg b">_offset</code>的值改变时我们的滚动是如何工作的！如果<code class="fe md me mf mg b">_offset</code>为0，拖动小部件将位于滚动条的顶部，如果<code class="fe md me mf mg b">_offset</code>变为类似300.0的值，拖动小部件将被进一步推下滚动条。并不复杂，但是我们如何将拖动小部件链接到我们实际的页面内容呢？</li></ul><h2 id="84ea" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">手势检测器回调</h2><ul class=""><li id="5406" class="mk ml it js b jt ly jx lz kb mm kf mn kj mo kn mp mq mr ms bi translated">这就把我们带到了手势检测器的位置。我们有能力在我们的手势检测器的子节点上检测<code class="fe md me mf mg b">drag</code>事件。这正是我们在第<code class="fe md me mf mg b">76</code>行所做的，在那里我们实现了<code class="fe md me mf mg b">onVerticalDragUpdate(dragUpdate)</code>事件。每当用户拖动拖动小部件时，都会调用这个函数。(我用了很多‘拖’字，我道歉)。</li><li id="0b52" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">因此，在<code class="fe md me mf mg b">onVerticalDragUpdate(dragUpdate)</code>回调中，我们可以使用dragUpdate对象从我们的drag小部件中获取新的位置值。特别是，我们需要从<code class="fe md me mf mg b">dragUpdate</code>对象中获取<code class="fe md me mf mg b">globalPosition</code>。本质上，这将告诉我们小部件在被拖动之后(或同时)在x和y轴上的位置。因为我们正在创建一个垂直滚动条，所以我们只对获得<code class="fe md me mf mg b">dy</code>位置感兴趣。</li></ul><h2 id="4935" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">把他们绑在一起</h2><ul class=""><li id="42a9" class="mk ml it js b jt ly jx lz kb mm kf mn kj mo kn mp mq mr ms bi translated">既然您已经理解了我们的GestureDetector回调，那么是时候将我们的滚动条和主要内容联系在一起了。还记得我们给主要内容分配了一个<code class="fe md me mf mg b">ScrollController()</code>吗？好了，是时候派上用场了。在我的例子中，控制器被命名为<code class="fe md me mf mg b">_controller</code>，正如你在<code class="fe md me mf mg b">77</code>行看到的，我们能够通过调用控制器上的<code class="fe md me mf mg b">moveTo()</code>函数并传入一个新位置来更新我们的可滚动内容的位置。我们希望传递从链接到拖动小部件的<code class="fe md me mf mg b">globalPosition.dy</code>中得到的位置，并将其乘以我们主要内容的理论高度。在我的例子中，我有大约四个全高容器作为我的主要内容，所以我选择将globalPosition.dy乘以3.5。为什么我们必须这样做？这是必需的，因为<code class="fe md me mf mg b">globalPosition.dy</code>是相对于我们网页的<strong class="js iu"> <em class="le">单个</em> </strong>高度的位置，而不是我们所有主要内容的不可见高度。所有这些完成后，我们现在有了一个不错的东西…每次拖动小部件的位置改变时，我们也会改变主要内容的位置！🙌🏽</li><li id="85b3" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">这是迄今为止最棒的！然而，你可能已经注意到一些奇怪的事情。主要是，我们的拖动部件没有‘拖动’哈哈(抱歉)。这是一个简单的修复，我们只需要调用<code class="fe md me mf mg b">setState()</code>并更新<code class="fe md me mf mg b">_offset</code>，它被设置为我们的拖动小部件的上边距。通过这样做，我们的根小部件将重新构建，并且每当<code class="fe md me mf mg b">_offset</code>的值改变时，这将依次更新拖动小部件的上边距。</li><li id="3cce" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">那么我们到底应该把<code class="fe md me mf mg b">_offset</code>设置成什么呢？你可能会想，我们可以将它设置为与传递给我们的<code class="fe md me mf mg b">moveTo</code>函数相同的值，你知道大概是3.5的倍数或者其他什么。很遗憾，这是不正确的。如果我们将<code class="fe md me mf mg b">_offset</code>设置为那个奇怪的数字，将会导致阻力偏离很远，就像脱离屏幕一样！相反，我们可以直接将<code class="fe md me mf mg b">_offset</code>的值设置为<code class="fe md me mf mg b">globalPosition.dy</code>的新位置。</li></ul><h2 id="9773" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">总结:</h2><p id="fae7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们已经到达终点了！同样，我知道这篇文章很重要，但是我真的想深入了解我是如何实现这个特性的。至少在这一点上，您可以希望将我所构建的内容进行改进，供您自己使用。此外，请随时建议更改和/或更新。滚动条绝不是完美的，希望它只是一个临时的解决方案，而Flutter devs会让它变得更加可靠。</p><h2 id="5728" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">本文中的资源:</h2><ul class=""><li id="ec08" class="mk ml it js b jt ly jx lz kb mm kf mn kj mo kn mp mq mr ms bi translated"><a class="ae mj" href="https://api.flutter.dev/flutter/widgets/ScrollController-class.html" rel="noopener ugc nofollow" target="_blank">滚动控制器</a></li><li id="3fa7" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated"><a class="ae mj" href="https://api.flutter.dev/flutter/widgets/GestureDetector-class.html" rel="noopener ugc nofollow" target="_blank">手势检测器</a></li><li id="4bfc" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated"><a class="ae mj" href="https://api.flutter.dev/flutter/widgets/SingleChildScrollView-class.html" rel="noopener ugc nofollow" target="_blank"> SingleChildScrollView </a></li><li id="44b2" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated"><a class="ae mj" href="https://flutter.dev/docs/development/ui/advanced/gestures" rel="noopener ugc nofollow" target="_blank"> VerticalDragUpdate </a></li><li id="2d80" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated"><a class="ae mj" href="https://github.com/cairacshields/flutter_web_scroller" rel="noopener ugc nofollow" target="_blank">样本项目</a></li></ul><p id="2f37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在https://www.linkedin.com/in/cairashields/<a class="ae mj" href="https://www.linkedin.com/in/cairashields/" rel="noopener ugc nofollow" target="_blank">的LinkedIn上关注我</a></p><p id="6567" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读和快乐编码！📲✨</p><p id="7c4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更新:我已经创建了一个包，你可以在自己的项目中轻松使用:<a class="ae mj" href="https://pub.dev/packages/flutter_web_scrollbar" rel="noopener ugc nofollow" target="_blank">https://pub.dev/packages/flutter_web_scrollbar</a></p></div></div>    
</body>
</html>