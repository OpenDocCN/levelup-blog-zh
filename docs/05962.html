<html>
<head>
<title>Microsoft Orleans — Health Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微软奥尔良—健康检查</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/microsoft-orleans-health-checks-b8a305096bc7?source=collection_archive---------6-----------------------#2020-10-14">https://levelup.gitconnected.com/microsoft-orleans-health-checks-b8a305096bc7?source=collection_archive---------6-----------------------#2020-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/10ecd6f528230640cd3fde0ac45698cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6OkP4A4_R4NuogOG.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">健康检查界面</figcaption></figure><p id="8895" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">运行状况检查是查看系统在执行检查时运行情况的一种方式。让我们看看如何将它们应用到奥尔良！</p><p id="5da2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae ld" href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-3.1" rel="noopener ugc nofollow" target="_blank">健康检查</a>通常通过HTTP端点公开，当被击中时(通常在“/hc”或“/health”端点)，它们能够报告当前系统的“健康状况”。</p><p id="0dc7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">健康检查，至少在。net land由enum <a class="ae ld" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.diagnostics.healthchecks.healthstatus?view=dotnet-plat-ext-3.1" rel="noopener ugc nofollow" target="_blank"> HealthStatus </a>组成，它指示健康、降级或不健康。健康检查本身是通过实现<a class="ae ld" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.diagnostics.healthchecks.ihealthcheck?view=dotnet-plat-ext-3.1" rel="noopener ugc nofollow" target="_blank"> IHealthCheck </a>接口的具体化创建的。</p><p id="b310" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">任何系统都可以包含一个或多个健康检查，而“健康检查”的含义完全取决于您作为实施者。例如，您可以进行一次健康检查，即“检查”:</p><ul class=""><li id="d8a3" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">富（中国姓氏）</li><li id="62ed" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">酒吧</li><li id="47fc" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">巴兹</li></ul><p id="6054" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所有这些都包含在一个名为“muhSystem”(或其他名称)、<em class="ls">或</em>的“单一”健康检查中，您可以将上述三个“检查”作为各自的健康检查来实施；所以一张支票vs多张支票，都代表“同一件事”。为什么你会选择其中一个？好吧，走单一检查路线允许你检查<code class="fe lt lu lv lw b">Foo</code>、<code class="fe lt lu lv lw b">Bar</code>和<code class="fe lt lu lv lw b">Baz</code> es健康，而不会“泄露”任何关于正在检查的信息。如果您需要小心泄露系统内部工作的一些信息，这种检查可能会很有用。</p><p id="b6e0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在“三次单独检查”的场景中，如果您泄漏了一些关于您系统的信息，您可能并不在乎，您希望向您的用户(或者您的<a class="ae ld" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/monitor-app-health#use-watchdogs" rel="noopener ugc nofollow" target="_blank">看门狗</a>)提供更详细的信息。</p><p id="0e35" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将从我的OrleansGettingStarted存储库上的<a class="ae ld" href="https://github.com/Kritner-Blogs/OrleansGettingStarted/releases/tag/v0.58" rel="noopener ugc nofollow" target="_blank"> v0.58 </a>标签开始这篇文章的代码部分。</p><p id="e126" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我没有写一篇关于在v0.58标签更新中执行的更改的博文，但是其中一个更改是让silo主机在下一个<code class="fe lt lu lv lw b">UseOrleans</code>扩展方法下运行。在的较新版本中。net core和Orleans，您可以从同一个<code class="fe lt lu lv lw b">IHostBuilder</code>托管多个“进程”。这允许我们托管一个小的API，它将通过http请求服务于健康检查端点。</p><p id="0672" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们要做的第一件事是向我们的host builder添加一个默认的web主机——更改后，它将同时托管我们的silo主机和api:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="1e35" class="mf mg it lw b gy mh mi l mj mk">hostBuilder.ConfigureWebHostDefaults(builder =&gt; { builder.UseStartup&lt;Startup&gt;(); })</span></pre><p id="987c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">(请注意，还会有其他变化，我可能不会特别指出，但结束代码是这里的<a class="ae ld" href="https://github.com/Kritner-Blogs/OrleansGettingStarted/releases/tag/v0.60.1" rel="noopener ugc nofollow" target="_blank">和帖子底部的参考资料。)</a></p><p id="105c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们还将介绍一个<code class="fe lt lu lv lw b">Startup</code>类:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="3273" class="mf mg it lw b gy mh mi l mj mk">public class Startup<br/>{<br/>    public Startup(IConfiguration configuration)<br/>    {<br/>        Configuration = configuration;<br/>    }</span><span id="5be6" class="mf mg it lw b gy ml mi l mj mk">public IConfiguration Configuration { get; }</span><span id="e3fb" class="mf mg it lw b gy ml mi l mj mk">// This method gets called by the runtime. Use this method to add services to the container.<br/>    public void ConfigureServices(IServiceCollection services)<br/>    {<br/>        services.AddControllers();<br/>    }</span><span id="e16b" class="mf mg it lw b gy ml mi l mj mk">// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.<br/>    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br/>    {<br/>        if (env.IsDevelopment())<br/>        {<br/>            app.UseDeveloperExceptionPage();<br/>        }</span><span id="2e33" class="mf mg it lw b gy ml mi l mj mk">app.UseHttpsRedirection();</span><span id="c519" class="mf mg it lw b gy ml mi l mj mk">app.UseRouting();</span><span id="6dfa" class="mf mg it lw b gy ml mi l mj mk">app.UseAuthorization();</span><span id="06a0" class="mf mg it lw b gy ml mi l mj mk">app.UseEndpoints(endpoints =&gt;<br/>        {<br/>            endpoints.MapControllers();<br/>        });<br/>    }<br/>}</span></pre><p id="2df4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当从模板创建一个新的web API项目时，上面的类应该或多或少是“default”<code class="fe lt lu lv lw b">Startup</code>类。</p><h2 id="5536" class="mf mg it bd mm mn mo dn mp mq mr dp ms kq mt mu mv ku mw mx my ky mz na nb nc bi translated">基本健康检查</h2><p id="02c3" class="pw-post-body-paragraph kf kg it kh b ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky nh la lb lc im bi translated">我们要做的第一次健康检查将是一次基本的检查——事实上这就是我们要给它取的名字。对于这个健康检查，我们将使用一个<code class="fe lt lu lv lw b">IClusterClient</code>,并确保它可以获得一个颗粒的实例，并从该颗粒获得一个结果。如果可以从谷物中得到结果，健康检查应该返回“健康”，否则返回“不健康”。</p><p id="520d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一如既往，我们首先需要我们的奥尔良谷物界面:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="737f" class="mf mg it lw b gy mh mi l mj mk">public interface IBasicHealthCheckGrain : IHealthCheck, IGrainWithGuidKey<br/>{    <br/>}</span></pre><p id="ab5f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面很简单，我们正在创建一个实现了<code class="fe lt lu lv lw b">IHealthCheck</code>和<code class="fe lt lu lv lw b">IGrainWithGuidKey</code>的类。<code class="fe lt lu lv lw b">IGrainWithGuidKey</code>应该从我的一些<a class="ae ld" href="https://blog.kritner.com/categories/programming/microsoft-orleans/" rel="noopener ugc nofollow" target="_blank">其他奥尔良帖子</a>中熟悉，并且<code class="fe lt lu lv lw b">IHealthCheck</code>颗粒在这篇帖子的前面提到过，它是一个描述健康检查的界面。我们不会向这个接口添加任何没有通过<code class="fe lt lu lv lw b">IHealthCheck</code>或<code class="fe lt lu lv lw b">IGrainWithGuidKey</code>提供的东西。</p><p id="6fb6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的基本健康检查粒度实现如下所示:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="4304" class="mf mg it lw b gy mh mi l mj mk">[StatelessWorker(1)]<br/>public class BasicHealthCheckGrain : Grain, IBasicHealthCheckGrain<br/>{<br/>    public Task&lt;HealthCheckResult&gt; CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = new CancellationToken())<br/>    {<br/>        return Task.FromResult(new HealthCheckResult(HealthStatus.Healthy));<br/>    }<br/>}</span></pre><p id="2cf6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！只需返回一个健康的结果。如果我们实际的<code class="fe lt lu lv lw b">IHealthCheck</code>实现无法获得这个粒度的实例，并且遇到了异常，异常处理程序将为我们返回“不健康”。</p><p id="bc21" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们有了健康检查颗粒，我们将需要一个实际的<code class="fe lt lu lv lw b">IHealthCheck</code>实现，它将利用我们新创建的“健康检查颗粒”。我知道我们将在这里创建几个健康检查，它们都做“很多相同的事情”，所以这似乎是引入抽象类<code class="fe lt lu lv lw b">OrleansHealthCheckBase</code>的绝佳机会:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="4660" class="mf mg it lw b gy mh mi l mj mk">public abstract class OrleansHealthCheckBase : IHealthCheck<br/>{<br/>    protected readonly IClusterClient _client;</span><span id="882f" class="mf mg it lw b gy ml mi l mj mk">protected OrleansHealthCheckBase(IClusterClient client)<br/>    {<br/>        _client = client;<br/>    }<br/>    <br/>    /// &lt;summary&gt;<br/>    /// Entry into health check, ensures the client is initialized, if it is not returns a healthy status.<br/>    /// &lt;/summary&gt;<br/>    /// &lt;param name="context"&gt;The health check context.&lt;/param&gt;<br/>    /// &lt;param name="cancellationToken"&gt;The cancellation token.&lt;/param&gt;<br/>    /// &lt;returns&gt;&lt;see cref="Task"/&gt; of &lt;see cref="HealthCheckResult"/&gt;&lt;/returns&gt;<br/>    public virtual async Task&lt;HealthCheckResult&gt; CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = new CancellationToken())<br/>    {<br/>        if (!_client.IsInitialized)<br/>        {<br/>            return HealthCheckResult.Healthy($"{nameof(_client)} not yet initialized.");<br/>        }</span><span id="3c38" class="mf mg it lw b gy ml mi l mj mk">return await CheckHealthGrainAsync(context, cancellationToken);<br/>    }</span><span id="27b6" class="mf mg it lw b gy ml mi l mj mk">/// &lt;summary&gt;<br/>    /// Perform the actual health check work within this implemented method.<br/>    /// &lt;/summary&gt;<br/>    /// &lt;param name="context"&gt;The health check context.&lt;/param&gt;<br/>    /// &lt;param name="cancellationToken"&gt;The cancellation token.&lt;/param&gt;<br/>    /// &lt;returns&gt;&lt;see cref="Task"/&gt; of &lt;see cref="HealthCheckResult"/&gt;&lt;/returns&gt;<br/>    protected abstract Task&lt;HealthCheckResult&gt; CheckHealthGrainAsync(HealthCheckContext context, CancellationToken cancellationToken);<br/>}</span></pre><p id="1b20" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们所有的运行状况检查都将依赖于到集群的连接，因此上面的内容将包含一个<code class="fe lt lu lv lw b">IClusterClient</code>，并确保集群在进行要实现的实际检查之前被初始化。</p><p id="cd64" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">正如我前面提到的，对于我们的“基本”健康检查，我们只是检查我们是否可以获得一个颗粒的实例，并返回一个值。这样的健康检查看起来像:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="0984" class="mf mg it lw b gy mh mi l mj mk">public class BasicOrleansHealthCheck :  OrleansHealthCheckBase<br/>{<br/>    public BasicOrleansHealthCheck(IClusterClient client) : base(client)<br/>    {<br/>        <br/>    }<br/>    <br/>    protected override async Task&lt;HealthCheckResult&gt; CheckHealthGrainAsync(HealthCheckContext context, CancellationToken cancellationToken)<br/>    {<br/>        try<br/>        {<br/>            return await _client.GetGrain&lt;IBasicHealthCheckGrain&gt;(Guid.Empty)<br/>                .CheckHealthAsync(context, cancellationToken);<br/>        }<br/>        catch (Exception e)<br/>        {<br/>            return HealthCheckResult.Unhealthy($"Health check failed.", e);<br/>        }<br/>    }<br/>}</span></pre><h1 id="cb9f" class="ni mg it bd mm nj nk nl mp nm nn no ms np nq nr mv ns nt nu my nv nw nx nb ny bi translated">性能运行状况检查</h1><p id="5cc6" class="pw-post-body-paragraph kf kg it kh b ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky nh la lb lc im bi translated">既然基本的健康检查已经完成，我们可以实现一些更有意义的检查。以下健康检查需要注册<code class="fe lt lu lv lw b">IHostEnvironmentStatistics</code>(你可以在这里找到关于<a class="ae ld" href="https://blog.kritner.com/2019/02/25/microsoft-orleans-dashboard-update-cpu-memory-stats/" rel="noopener ugc nofollow" target="_blank">的更多信息)。</a></p><p id="08f7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些运行状况检查对于测量Orleans节点随时间推移的利用率特别有用，这将允许您对诸如“我是否应该为此集群增加或减少额外的节点？”之类的问题做出决策。当您通过健康检查端点公开了性能指标并使用了监视程序时，对这些问题的回答会简单得多，尤其是在k8s环境中运行Orleans集群时。</p><p id="b0ac" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我将快速浏览这些内容，它们应该基本上是不言自明的，但是您可以查看我没有特别介绍的任何内容的完整代码。</p><h2 id="26f7" class="mf mg it bd mm mn mo dn mp mq mr dp ms kq mt mu mv ku mw mx my ky mz na nb nc bi translated">CPU运行状况检查</h2><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="8543" class="mf mg it lw b gy mh mi l mj mk">public interface ICpuHealthCheckGrain : IHealthCheck, IGrainWithGuidKey<br/>{<br/>    <br/>}</span><span id="9825" class="mf mg it lw b gy ml mi l mj mk">[StatelessWorker(1)]<br/>public class CpuHealthCheckGrain : Grain, ICpuHealthCheckGrain<br/>{<br/>    private const float UnhealthyThreshold = 90;<br/>    private const float DegradedThreshold = 70;<br/>    <br/>    private readonly IHostEnvironmentStatistics _hostEnvironmentStatistics;</span><span id="f322" class="mf mg it lw b gy ml mi l mj mk">public CpuHealthCheckGrain(IHostEnvironmentStatistics hostEnvironmentStatistics)<br/>    {<br/>        _hostEnvironmentStatistics = hostEnvironmentStatistics;<br/>    }<br/>    <br/>    public Task&lt;HealthCheckResult&gt; CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = new CancellationToken())<br/>    {<br/>        if (_hostEnvironmentStatistics.CpuUsage &gt; UnhealthyThreshold)<br/>        {<br/>            return Task.FromResult(HealthCheckResult.Unhealthy(<br/>                $"CPU utilization is unhealthy at {_hostEnvironmentStatistics.CpuUsage}%."));<br/>            <br/>        }<br/>        <br/>        if (_hostEnvironmentStatistics.CpuUsage &gt; DegradedThreshold)<br/>        {<br/>            return Task.FromResult(HealthCheckResult.Degraded(<br/>                $"CPU utilization is degraded at {_hostEnvironmentStatistics.CpuUsage}%."));<br/>        }<br/>        <br/>        return Task.FromResult(HealthCheckResult.Healthy(<br/>            $"CPU utilization is healthy at {_hostEnvironmentStatistics.CpuUsage}%."));<br/>    }<br/>}</span></pre><p id="e6cd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">新的粒度接口，用于CPU健康检查的新粒度实现。如果超过90%的CPU，我们将返回不健康，如果超过70%将返回降级，否则返回健康。</p><h2 id="897e" class="mf mg it bd mm mn mo dn mp mq mr dp ms kq mt mu mv ku mw mx my ky mz na nb nc bi translated">内存健康检查</h2><p id="465c" class="pw-post-body-paragraph kf kg it kh b ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky nh la lb lc im bi translated">同样的内存健康检查的基本思想，再次使用我们注册的<code class="fe lt lu lv lw b">IHostEnvironmentStatistics</code>:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="bfbb" class="mf mg it lw b gy mh mi l mj mk">public interface IMemoryHealthCheckGrain : IHealthCheck, IGrainWithGuidKey<br/>{<br/>    <br/>}</span><span id="e12a" class="mf mg it lw b gy ml mi l mj mk">[StatelessWorker(1)]<br/>public class MemoryHealthCheckGrain : Grain, IMemoryHealthCheckGrain<br/>{<br/>    private const float UnhealthyThreshold = 95;<br/>    private const float DegradedThreshold = 90;<br/>    <br/>    private readonly IHostEnvironmentStatistics _hostEnvironmentStatistics;</span><span id="7061" class="mf mg it lw b gy ml mi l mj mk">public MemoryHealthCheckGrain(IHostEnvironmentStatistics hostEnvironmentStatistics)<br/>    {<br/>        _hostEnvironmentStatistics = hostEnvironmentStatistics;<br/>    }<br/>    <br/>    public Task&lt;HealthCheckResult&gt; CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = new CancellationToken())<br/>    {<br/>        if (_hostEnvironmentStatistics?.AvailableMemory == null || _hostEnvironmentStatistics?.TotalPhysicalMemory == null)<br/>        {<br/>            return Task.FromResult(HealthCheckResult.Unhealthy("Could not determine memory calculation."));<br/>        }<br/>        <br/>        if (_hostEnvironmentStatistics?.AvailableMemory == 0 &amp;&amp; _hostEnvironmentStatistics?.AvailableMemory == 0)<br/>        {<br/>            return Task.FromResult(HealthCheckResult.Unhealthy("Could not determine memory calculation."));<br/>        }<br/>        <br/>        var memoryUsed = 100 - ((float)_hostEnvironmentStatistics.AvailableMemory / (float)_hostEnvironmentStatistics.TotalPhysicalMemory * 100);<br/>        <br/>        if (memoryUsed &gt; UnhealthyThreshold)<br/>        {<br/>            return Task.FromResult(HealthCheckResult.Unhealthy(<br/>                $"Memory utilization is unhealthy at {memoryUsed:0.00}%."));<br/>            <br/>        }<br/>        <br/>        if (memoryUsed &gt; DegradedThreshold)<br/>        {<br/>            return Task.FromResult(HealthCheckResult.Degraded(<br/>                $"Memory utilization is degraded at {memoryUsed:0.00}%."));<br/>        }<br/>        <br/>        return Task.FromResult(HealthCheckResult.Healthy(<br/>            $"Memory utilization is healthy at {memoryUsed:0.00}%."));<br/>    }<br/>}</span></pre><p id="bb31" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这种情况下，我走了一条稍微不同的路线，如果无法确定内存信息，则返回“不健康”,这可能应该在此和CPU健康检查之间一致完成，但我想展示作为实施者的<em class="ls">您</em>如何能够选择“健康”与“不健康”的含义。对于这种内存健康检查，如果内存利用率超过95%,则我们不健康；如果超过90 %,则我们降级；否则，我们健康。</p><h1 id="900e" class="ni mg it bd mm nj nk nl mp nm nn no ms np nq nr mv ns nt nu my nv nw nx nb ny bi translated">连接健康检查</h1><p id="e915" class="pw-post-body-paragraph kf kg it kh b ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky nh la lb lc im bi translated">现在我们有了健康检查颗粒，我们将引入新的<code class="fe lt lu lv lw b">IHealthChecks</code>，它与扩展了<code class="fe lt lu lv lw b">OrleansHealthCheckBase</code>的<code class="fe lt lu lv lw b">BasicOrleansHealthCheck</code>非常相似。</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="1787" class="mf mg it lw b gy mh mi l mj mk">public class CpuOrleansHealthCheck : OrleansHealthCheckBase<br/>{<br/>    public CpuOrleansHealthCheck(IClusterClient client) : base(client)<br/>    {<br/>    }<br/>    <br/>    protected override async Task&lt;HealthCheckResult&gt; CheckHealthGrainAsync(HealthCheckContext context, CancellationToken cancellationToken)<br/>    {<br/>        try<br/>        {<br/>            return await _client.GetGrain&lt;ICpuHealthCheckGrain&gt;(Guid.Empty)<br/>                .CheckHealthAsync(context, cancellationToken);<br/>        }<br/>        catch (Exception e)<br/>        {<br/>            return HealthCheckResult.Unhealthy($"Health check failed.", e);<br/>        }<br/>    }<br/>}</span><span id="5fbf" class="mf mg it lw b gy ml mi l mj mk">public class MemoryOrleansHealthCheck : OrleansHealthCheckBase<br/>{<br/>    public MemoryOrleansHealthCheck(IClusterClient client) : base(client)<br/>    {<br/>    }<br/>    <br/>    protected override async Task&lt;HealthCheckResult&gt; CheckHealthGrainAsync(HealthCheckContext context, CancellationToken cancellationToken)<br/>    {<br/>        try<br/>        {<br/>            return await _client.GetGrain&lt;IMemoryHealthCheckGrain&gt;(Guid.Empty)<br/>                .CheckHealthAsync(context, cancellationToken);<br/>        }<br/>        catch (Exception e)<br/>        {<br/>            return HealthCheckResult.Unhealthy($"Health check failed.", e);<br/>        }<br/>    }<br/>}</span></pre><p id="7bd1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，我们需要将所有这些健康检查连接到webhost中的“/health”端点。幸运的是，这很简单。早先的<code class="fe lt lu lv lw b">Startup</code>:</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/a64433237866c0f9d0153460d0c330b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tSx0HTU6-P2AseKF.JPG"/></div></div></figure><p id="5719" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">变成了:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="f0af" class="mf mg it lw b gy mh mi l mj mk">public class Startup<br/>{<br/>    public Startup(IConfiguration configuration)<br/>    {<br/>        Configuration = configuration;<br/>    }</span><span id="dbaa" class="mf mg it lw b gy ml mi l mj mk">public IConfiguration Configuration { get; }</span><span id="4dd2" class="mf mg it lw b gy ml mi l mj mk">// This method gets called by the runtime. Use this method to add services to the container.<br/>    public void ConfigureServices(IServiceCollection services)<br/>    {<br/>        services.AddControllers();<br/>        services.AddHealthChecks()<br/>            .AddCheck&lt;BasicOrleansHealthCheck&gt;("basicOrleans")<br/>            .AddCheck&lt;CpuOrleansHealthCheck&gt;("cpuOrleans")<br/>            .AddCheck&lt;MemoryOrleansHealthCheck&gt;("memoryOrleans");<br/>    }</span><span id="b045" class="mf mg it lw b gy ml mi l mj mk">// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.<br/>    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br/>    {<br/>        if (env.IsDevelopment())<br/>        {<br/>            app.UseDeveloperExceptionPage();<br/>        }</span><span id="45c6" class="mf mg it lw b gy ml mi l mj mk">app.UseHttpsRedirection();</span><span id="fead" class="mf mg it lw b gy ml mi l mj mk">app.UseRouting();</span><span id="a3c5" class="mf mg it lw b gy ml mi l mj mk">app.UseAuthorization();</span><span id="5bb4" class="mf mg it lw b gy ml mi l mj mk">app.UseEndpoints(endpoints =&gt;<br/>        {<br/>            endpoints.MapHealthChecks("/health").WithMetadata(new AllowAnonymousAttribute());<br/>            endpoints.MapControllers();<br/>        });<br/>    }<br/>}</span></pre><p id="c3fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不同之处在于，我们在<code class="fe lt lu lv lw b">ConfigureServices</code>中添加了健康检查(并给它们命名)，并将健康检查映射到<code class="fe lt lu lv lw b">Configure</code>中的“/health”端点。</p><p id="648e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们点燃发射井，测试这东西！</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/e256937dbe9d9430bd06453304b5f869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jlt_eur6kNhlzp1i.JPG"/></div></div></figure><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/d1b787b98a00ed7e91b3df1363337460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZFqaweabM6MXSCgG.JPG"/></div></div></figure><p id="0264" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">嗯，这是相当虎头蛇尾…我们将不得不看到美化健康检查的回应，希望在另一个职位，我会完全写真的很快！</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="ee48" class="ni mg it bd mm nj oj nl mp nm ok no ms np ol nr mv ns om nu my nv on nx nb ny bi translated">参考资料:</h1><ul class=""><li id="30ee" class="le lf it kh b ki nd km ne kq oo ku op ky oq lc lj lk ll lm bi translated"><a class="ae ld" href="https://github.com/Kritner-Blogs/OrleansGettingStarted/releases/tag/v0.58" rel="noopener ugc nofollow" target="_blank">帖子开头的代码</a></li><li id="97ec" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://github.com/Kritner-Blogs/OrleansGettingStarted/releases/tag/v0.60.1" rel="noopener ugc nofollow" target="_blank">帖子末尾的代码</a></li><li id="cbed" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://blog.kritner.com/categories/programming/microsoft-orleans/" rel="noopener ugc nofollow" target="_blank">我的其他奥尔良帖子</a></li><li id="58c5" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://blog.kritner.com/2019/02/25/microsoft-orleans-dashboard-update-cpu-memory-stats/" rel="noopener ugc nofollow" target="_blank">微软奥尔良—仪表板更新—CPU/内存统计</a></li><li id="4a2e" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-3.1" rel="noopener ugc nofollow" target="_blank">健康检查</a></li><li id="8519" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.diagnostics.healthchecks.healthstatus?view=dotnet-plat-ext-3.1" rel="noopener ugc nofollow" target="_blank">健康状态</a></li><li id="a3a1" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.diagnostics.healthchecks.ihealthcheck?view=dotnet-plat-ext-3.1" rel="noopener ugc nofollow" target="_blank">健康检查</a></li><li id="ca65" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated"><a class="ae ld" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/monitor-app-health#use-watchdogs" rel="noopener ugc nofollow" target="_blank">看门狗</a></li></ul></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="e9d6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ls">原载于2020年10月14日https://blog.kritner.com</em><em class="ls"><a class="ae ld" href="https://blog.kritner.com/2020/10/14/microsoft-orleans-health-checks/" rel="noopener ugc nofollow" target="_blank"><em class="ls">。</em></a></em></p></div></div>    
</body>
</html>