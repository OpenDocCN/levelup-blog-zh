<html>
<head>
<title>How to detect iBeacons in a NativeScript-Angular app.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在NativeScript-Angular应用程序中检测iBeacons？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-detect-ibeacons-in-a-nativescript-angular-app-8d2c557b26dd?source=collection_archive---------37-----------------------#2020-05-04">https://levelup.gitconnected.com/how-to-detect-ibeacons-in-a-nativescript-angular-app-8d2c557b26dd?source=collection_archive---------37-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="76c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的工作中，我们不断想办法改善用户体验。我正在做的事情之一是让我们的移动应用程序能够在用户靠近我们的特定房间时意识到用户的存在，并自动为用户办理入住手续。对于这个签到功能，我找到了一个NativeScript插件来检测使用我的android手机的iBeacons。在这篇文章中，我将向您展示一个样本NativeScript-Angular应用程序中的一些代码，以扫描iBeacons。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2a000613e9360ffb5452f7c5380fb34a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqATCUXW9RJ0o-y6zIJ0MQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2611199" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></figcaption></figure><h1 id="08ae" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是蓝牙低能量(BLE)信标？</h1><p id="ccc2" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在蓝牙4.0之前，通过蓝牙的通信一直是双向的，这意味着设备可以发射和接收蓝牙信号。例如，在我们的日常生活中，当我们将音乐从智能手机无线传输到蓝牙耳机，或将手机连接到汽车的立体声系统时，我们会使用蓝牙。2010年，蓝牙4.0问世，使用低能耗的单向通信成为可能，并开辟了创新的使用案例，如邻近检测、资产跟踪和室内寻路。</p><p id="e033" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">BLE信标是一种利用蓝牙低能量不断发射信号的小装置(BLE)。您可能会在各种外形规格、大型零售店以及嵌入在WIFI接入点和智能手机等其他设备中发现它们。电池供电的信标可能持续几年，这取决于不同的因素，如配置、电池类型和制造。例如，两年前我从Estimote获得了一个信标开发包，到今天为止，这些信标中的每一个仍然有70%的剩余电量。广告间隔越频繁和/或信号强度越强，信标消耗的能量就越多。</p><h1 id="b4ea" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是iBeacon？</h1><p id="c596" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果我们不理解数据的含义，来自BLE信标的数据包是没有帮助的。然而，如果制造商想出自己的方法将数据编码到BLE信标中，开发者将很难做到这一点。苹果公司想出了一种标准的方法，通过给信标分配uuid、major、mior和tx power等层次id，允许信标提供上下文信息，这是有道理的。</p><p id="b2a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> UUID </strong> : 16字节字符串，用于标识属于一个大组的一组信标。</p><p id="7f68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Major </strong> : 2字节字符串，用于标识属于可由UUID识别的大组内的信标子集的一组信标。</p><p id="5495" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Minor </strong> : 2字节字符串，用于标识可由major id识别的组内的单个信标信标。</p><p id="7fc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Tx功率</strong>:距离其位置1米远的信标发出的信号强度。</p><p id="5833" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">iBeacon已经成为Android和iOS都支持的协议。顺便提一下，Eddystone是Google开发的另一个使用BLE进行通信的协议。Eddystone兼容信标传输数据的格式与iBeacon不同。然而，在这篇文章中，我们不打算讨论Eddystone。</p><h1 id="4296" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在带角度的NativeScript应用程序中检测iBeacon。</h1><p id="f4a1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">iOS和Android SDKs都原生支持对iBeacons的扫描。对于NativeScript，您可以使用插件或自己编写插件。幸运的是，我找到了一个现有的插件，demetrio812 的<a class="ae le" href="https://market.nativescript.org/plugins/nativescript-ibeacon" rel="noopener ugc nofollow" target="_blank"> iBeacon插件，它可以工作，这就是我正在使用的。</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mi"><img src="../Images/569c2ce024d257978d60a9b0ae50a117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R08m_JnaupINZL1B"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">NativeScript iBeacon插件</figcaption></figure><p id="5780" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您转到插件的网页，您可以看到在您的NativeScript应用程序中安装和使用它的说明。在很大程度上，该文档提供了足够好的信息来开始。我能够快速原型化一个简单的NativeScript-Angular项目，并使用该插件扫描iBeacons。下面我展示了我的app.component中的示例代码:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="9f97" class="mo lg it mk b gy mp mq l mr ms">import { Component, OnInit, OnDestroy } from "@angular/core";<br/>import { NativescriptIbeacon } from 'nativescript-ibeacon';<br/>import { BeaconLocationOptions, BeaconLocationOptionsIOSAuthType,<br/>    BeaconLocationOptionsAndroidAuthType, BeaconRegion, Beacon } from 'nativescript-ibeacon/nativescript-ibeacon.common';<br/><br/>@Component({<br/>    selector: "ns-app",<br/>    templateUrl: "./app.component.html"<br/>})<br/>export class AppComponent implements OnInit, OnDestroy {<br/><br/>    private _nativescriptIbeacon;<br/>    private _region;<br/><br/>    constructor () {<br/>        var myIbeacon = {<br/>            id: "My iBeacon in conference room of Office A ",<br/>            proximityUUID: "B9407F30-F5F8-466E-AFF9-25556B57FE6D",<br/>            major: 17744,<br/>            minor: 28116<br/>        }<br/>        this._region = new BeaconRegion(myIbeacon.id, myIbeacon.proximityUUID, myIbeacon.major, myIbeacon.minor);<br/><br/>        let options: BeaconLocationOptions = {<br/>            iOSAuthorisationType: BeaconLocationOptionsIOSAuthType.Always,<br/>            androidAuthorisationType: BeaconLocationOptionsAndroidAuthType.Fine,<br/>            androidAuthorisationDescription: "Location permission needed"<br/>        };<br/><br/>        this._nativescriptIbeacon = new NativescriptIbeacon(this.beaconCallback(), options);<br/><br/>        if (!this._nativescriptIbeacon.isAuthorised()) {<br/>            console.log("NOT Authorised");<br/>            this._nativescriptIbeacon.requestAuthorization()<br/>                .then(() =&gt; {<br/>                    console.log("Authorised by the user");<br/>                    this._nativescriptIbeacon.bind();<br/><br/>                }, (e) =&gt; {<br/>                    console.log("Authorisation denied by the user");<br/>                })<br/>        } else {<br/>            console.log("Already authorised");<br/>            this._nativescriptIbeacon.bind();<br/>        }<br/>    }<br/><br/><br/>    ngOnDestroy(): void {<br/>        if (this._nativescriptIbeacon) {<br/>            this._nativescriptIbeacon.unbind();<br/>        }<br/>    }<br/><br/>    beaconCallback() {<br/>        var self = this;<br/>        return {<br/>            onBeaconManagerReady(): void {<br/>                // start ranging and/or monitoring only when the beacon manager is ready<br/><br/>                self._nativescriptIbeacon.startRanging(self._region);<br/>                self._nativescriptIbeacon.startMonitoring(self._region);<br/>            },<br/>            didRangeBeaconsInRegion: function(region: BeaconRegion, beacons: Beacon[]) {<br/>                console.log(JSON.stringify(beacons));<br/>            },<br/>            didFailRangingBeaconsInRegion: function(region: BeaconRegion, errorCode: number, errorDescription: string) {<br/>                console.error(`Failed to find beacons with errorCode: ${errorCode} and description:<br/>                ${errorDescription}`);<br/>            },<br/>            didEnterRegion: function(region: BeaconRegion) {<br/>                console.log("Did enter region called");<br/>            },<br/>            didExitRegion: function(region: BeaconRegion) {<br/>                console.log("Did exit region called.");<br/>            }<br/>        }<br/>    }<br/><br/>    ngOnInit(): void {<br/><br/>    }<br/>}</span></pre><p id="3044" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在很大程度上，代码很简单，并且基于插件的文档。但是，您可能需要注意一些事情:</p><ul class=""><li id="9ba4" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated"><code class="fe nc nd ne mk b">BeaconRegion</code>封装您为扫描信标定义的元数据。您可以扫描具有相同uuid的所有信标。还可以通过提供主要id将扫描范围缩小到特定的组，通过提供次要id将扫描范围进一步缩小到特定的信标。</li><li id="63a2" class="mt mu it js b jt nf jx ng kb nh kf ni kj nj kn my mz na nb bi translated">在android设备上，确保您的应用程序能够访问位置。您可以通过进入设置-&gt;应用-&gt; {您的应用}--&gt;权限并启用<strong class="js iu">位置</strong>来实现。</li><li id="61c1" class="mt mu it js b jt nf jx ng kb nh kf ni kj nj kn my mz na nb bi translated">在<code class="fe nc nd ne mk b"> beaconCallback()</code>方法中，我使用闭包来捕获对我的app组件的引用。这是因为该方法是一个回调，这意味着稍后调用它的对象不是我的应用程序组件，而是插件中的一些对象。因此，如果我使用<strong class="js iu"> this </strong>关键字来访问我的应用程序组件中定义的对象，我会因为访问未定义对象的属性而出错。这只是JavaScript。</li></ul><p id="9e30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我在控制台中得到的内容，它让我知道当我在android设备上运行该应用程序时，事情是可行的:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="2540" class="mo lg it mk b gy mp mq l mr ms">onBeaconServiceConnect JS: startRanging JS: startRangingBeaconsInRegion JS: startMonitoring JS: didDetermineStateForRegion JS: 1 JS: id1: b9407f30-f5f8-466e-aff9-25556b57fe6d id2: 17744 id3: 28116 JS: [{"proximityUUID":"b9407f30-f5f8-466e-aff9-25556b57fe6d","major":17744,"minor":28116,"distance_proximity":0.13055123127828835,"rssi":-60,"txPower_accuracy":-76}]</span></pre><p id="025e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样。感谢阅读和快乐编码。</p><h1 id="5a2b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">参考</h1><p id="9761" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated"><a class="ae le" href="https://en.wikipedia.org/wiki/Bluetooth_low_energy_beacon" rel="noopener ugc nofollow" target="_blank">蓝牙低能耗信标</a></p><p id="9e80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://developer.apple.com/documentation/corelocation/determining_the_proximity_to_an_ibeacon_device" rel="noopener ugc nofollow" target="_blank">确定与ibeacon设备的接近度</a> <a class="ae le" href="https://github.com/demetrio812/nativescript-ibeacon" rel="noopener ugc nofollow" target="_blank"> nativescript-ibeacon插件</a></p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="18d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nr">原载于2020年5月4日https://www.taithienbo.com</em><a class="ae le" href="https://www.taithienbo.com/how-to-detect-ibeacons-in-a-nativescript-angular-app/" rel="noopener ugc nofollow" target="_blank"><em class="nr"/></a><em class="nr">。</em></p></div></div>    
</body>
</html>