<html>
<head>
<title>Circular Double Linked List Implementation in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中循环双向链表的实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/circular-double-linked-list-implementation-in-java-72a35a86ef1b?source=collection_archive---------9-----------------------#2020-01-10">https://levelup.gitconnected.com/circular-double-linked-list-implementation-in-java-72a35a86ef1b?source=collection_archive---------9-----------------------#2020-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f272197bcd892c2a1f3e063572dbf9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yqA90MjZ7lleXkHw"/></div></div></figure><blockquote class="jy jz ka"><p id="4026" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">原载于<a class="ae la" href="https://blog.contactsunny.com/tech/circular-double-linked-list-implementation-in-java" rel="noopener ugc nofollow" target="_blank">我的个人博客</a>2020年1月10日。</p></blockquote><p id="10f1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">更多在<a class="ae la" href="https://blog.contactsunny.com/tag/data-structure-implementation-in-java" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">《数据结构系列》</strong> </a>。</p><p id="abe2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这篇关于如何用Java实现循环双向链表(DLL)的文章中，我们将继续我们的数据结构之旅。这与标准DLL非常相似，唯一的区别是头部和尾部的连接。这意味着，我们把头和尾连接在一起，我们可以把它想象成一个圆，因为圆没有起点也没有终点。</p><p id="ab7a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">因为列表的头和尾是连在一起的，所以可以说有始无终。但是当然，我们引用了头部和尾部，使我们的遍历变得容易。如果你还没有看完我的<a class="ae la" href="https://blog.contactsunny.com/tech/double-linked-list-implementation-in-java" rel="noopener ugc nofollow" target="_blank">对双向链表</a>的解释，请现在就看，因为我们将在这里使用完全相同的类，只有很小的改动。另外，确保你看了一下我在这里解释的其他数据结构。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="fc11" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">节点</h1><p id="cdb0" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km lb ml kp kq lc mm kt ku ld mn kx ky kz ij bi translated">像往常一样，我们将从节点类开始。下面是该类的定义:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="26d0" class="mx lm iq mt b gy my mz l na nb">public class Node&lt;T&gt; {<br/><br/>    private T data;<br/>    private Node&lt;T&gt; next;<br/>    private Node&lt;T&gt; previous;<br/><br/>    public T getData() {<br/>        return data;<br/>    }<br/><br/>    public void setData(T data) {<br/>        this.data = data;<br/>    }<br/><br/>    public Node&lt;T&gt; getNext() {<br/>        return next;<br/>    }<br/><br/>    public void setNext(Node&lt;T&gt; next) {<br/>        this.next = next;<br/>    }<br/><br/>    public Node&lt;T&gt; getPrevious() {<br/>        return previous;<br/>    }<br/><br/>    public void setPrevious(Node&lt;T&gt; previous) {<br/>        this.previous = previous;<br/>    }<br/>}</span></pre><p id="2321" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如您所见，我们在这里仍然使用通用的<em class="kd"> T </em>类，这样我们就可以在运行时在这个链表中存储任何类型的数据。接下来，我们将看看DoubleLinkedList类是什么样子的。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="e3c1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">链表类</h1><p id="f16d" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km lb ml kp kq lc mm kt ku ld mn kx ky kz ij bi translated">对于任何一个DLL类，我们都有一个头和一个尾，它们是我们之前定义的Node <t>类型:</t></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9855" class="mx lm iq mt b gy my mz l na nb">public class DoubleLinkedList&lt;T&gt; {<br/><br/>    private Node&lt;T&gt; head;<br/>    private Node&lt;T&gt; tail;<br/><br/>}</span></pre><p id="8f6b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">请记住，仅仅因为我将该类命名为DoubleLinkedList，您不必做同样的事情，您可以将其命名为LinkedList，或CircularLinkedList，或任何其他名称。因为我用这个来举例说明，所以我用了这个名字。</p><p id="ba3c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">接下来，我们将看到push()方法。这是第一个方法，我们将区别规则DLL和循环DLL。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="eb55" class="mx lm iq mt b gy my mz l na nb">public void push(T value) {<br/><br/>	// If the list is empty, the head will be null.<br/>	// So create a new node for the head, add the value,<br/>	// and then make the tail the same as the head.<br/>    if (this.head == null) {<br/>        this.head = new Node&lt;T&gt;();<br/>        this.head.setData(value);<br/>        this.tail = this.head;<br/>    } else {<br/><br/>    	// If the head is not empty, it means that there are already<br/>    	// node in the list. So we create a new node, save the value,<br/>    	// add it in front of the head, make the head the tail connections.<br/>        Node&lt;T&gt; newNode = new Node&lt;T&gt;();<br/>        newNode.setData(value);<br/>        newNode.setNext(this.head);<br/>        newNode.setPrevious(this.tail);<br/><br/>        // We also chagne the links in the current head and tail, <br/>        // so that we don't lose any references.<br/>        this.head.setPrevious(newNode);<br/>        this.tail.setNext(newNode);<br/><br/>        // It is also important to make the new node the head,<br/>        // so that when we add a new node later, we're  maintaining<br/>        // the chain properly.<br/>        this.head = newNode;<br/>    }<br/>}</span></pre><p id="36ed" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我在代码中添加了注释来解释这个方法中发生了什么。这应该是一个足够的解释，但如果不是，请让我在评论中知道，我很乐意帮助你理解。</p><p id="156e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">DoubleLinkedList类中的所有其他方法与常规的DoubleLinkedList类保持相同。你可以<a class="ae la" href="https://blog.contactsunny.com/tech/double-linked-list-implementation-in-java" rel="noopener ugc nofollow" target="_blank">查看DLL发布</a>获取更多信息。在任何情况下，我都在这里提供了该类的所有其他方法以供快速参考。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c9f4" class="mx lm iq mt b gy my mz l na nb">public void traverse() {<br/><br/>    if (this.head != null) {<br/>        Node&lt;T&gt; currentNode = this.head;<br/><br/>        System.out.print("Forward traverse: ");<br/><br/>        while (currentNode != null) {<br/>            System.out.print(currentNode.getData() + " -&gt; ");<br/><br/>            if (currentNode.getNext() == this.head) {<br/>                break;<br/>            }<br/><br/>            currentNode = currentNode.getNext();<br/>        }<br/><br/>        System.out.println("END");<br/><br/>    } else {<br/>        System.out.println("Linked list is empty.");<br/>    }<br/>}<br/><br/>public void reverseTraverse() {<br/><br/>    if (this.tail != null) {<br/>        Node&lt;T&gt; currentNode = this.tail;<br/><br/>        System.out.print("Reverse traverse: ");<br/><br/>        while (currentNode != null) {<br/>            System.out.print(currentNode.getData() + " -&gt; ");<br/><br/>            if (currentNode.getPrevious() == this.tail) {<br/>                break;<br/>            }<br/><br/>            currentNode = currentNode.getPrevious();<br/>        }<br/><br/>        System.out.println("END");<br/><br/>    } else {<br/>        System.out.println("Linked list is empty.");<br/>    }<br/>}<br/><br/>public void addToTail(T value) {<br/><br/>    if (this.head == null) {<br/>        this.head = new Node&lt;T&gt;();<br/>        this.head.setData(value);<br/>        this.tail = this.head;<br/>    } else {<br/>        Node&lt;T&gt; newNode = new Node&lt;T&gt;();<br/>        newNode.setData(value);<br/>        newNode.setPrevious(this.tail);<br/>        newNode.setNext(this.head);<br/><br/>        this.tail.setNext(newNode);<br/>        this.tail = newNode;<br/>    }<br/>}<br/><br/>public void delete(T value) {<br/><br/>    if (this.head != null) {<br/>        Node&lt;T&gt; currentNode = this.head;<br/>        Node&lt;T&gt; previousNode = this.head;<br/><br/>        while (currentNode != null) {<br/>            if (currentNode.getData() == value) {<br/>                previousNode.setNext(currentNode.getNext());<br/><br/>                if (currentNode.getNext() != null) {<br/>                    currentNode.getNext().setPrevious(previousNode);<br/>                }<br/><br/>                System.out.println("Deleted first node with value " + value);<br/>                break;<br/>            } else {<br/>                previousNode = currentNode;<br/>                currentNode = currentNode.getNext();<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>public void addAfterIndex(T value, int index) {<br/><br/>    if (this.head == null) {<br/>        this.head = new Node&lt;T&gt;();<br/>        this.head.setData(value);<br/>        this.tail = this.head;<br/>    } else {<br/><br/>        int nodeIndex = 0;<br/><br/>        Node&lt;T&gt; currentNode = this.head;<br/><br/>        while (index &gt; nodeIndex) {<br/>            if (currentNode.getNext() != null) {<br/>                currentNode = currentNode.getNext();<br/>            }<br/><br/>            nodeIndex++;<br/>        }<br/><br/>        if (nodeIndex == index) {<br/>            Node&lt;T&gt; newNode = new Node&lt;T&gt;();<br/>            newNode.setData(value);<br/>            newNode.setNext(currentNode.getNext());<br/>            newNode.setPrevious(currentNode);<br/><br/>            if (currentNode.getNext() != null) {<br/>                currentNode.getNext().setPrevious(newNode);<br/>            }<br/><br/>            currentNode.setNext(newNode);<br/>        }<br/>    }<br/>}<br/><br/>public void deleteNodeAtIndex(int index) {<br/><br/>    if (this.head != null) {<br/><br/>        int nodeIndex = 0;<br/><br/>        Node&lt;T&gt; currentNode = this.head;<br/>        Node&lt;T&gt; previousNode = this.head;<br/><br/>        while (nodeIndex != index) {<br/><br/>            previousNode = currentNode;<br/><br/>            if (currentNode.getNext() != null) {<br/>                currentNode = currentNode.getNext();<br/>            }<br/><br/>            nodeIndex++;<br/>        }<br/><br/>        previousNode.setNext(currentNode.getNext());<br/><br/>        if (currentNode.getNext() != null) {<br/>            currentNode.getNext().setPrevious(previousNode);<br/>        }<br/>    }<br/>}<br/><br/>public void deleteNodeAfterIndex(int index) {<br/><br/>    if (this.head != null) {<br/><br/>        int nodeIndex = 0;<br/><br/>        Node&lt;T&gt; currentNode = this.head;<br/><br/>        while (nodeIndex != index) {<br/><br/>            if (currentNode.getNext() != null) {<br/>                currentNode = currentNode.getNext();<br/>            }<br/><br/>            nodeIndex++;<br/>        }<br/><br/>        if (currentNode.getNext() != null) {<br/><br/>            Node&lt;T&gt; nodeToBeDeleted = currentNode.getNext();<br/><br/>            currentNode.setNext(nodeToBeDeleted.getNext());<br/><br/>            if (nodeToBeDeleted.getNext() != null) {<br/>                nodeToBeDeleted.getNext().setPrevious(nodeToBeDeleted.getPrevious());<br/>            }<br/>        } else {<br/>            currentNode.setNext(null);<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="f347" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试循环DLL</h1><p id="558d" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km lb ml kp kq lc mm kt ku ld mn kx ky kz ij bi translated">像往常一样，我有一小段代码来检查我们编写的代码是否按预期工作。为此，我们将创建一个整数类型的循环DLL，向它添加一些值，删除一些值，并在它们之间进行遍历，以测试我们是否做得正确。这方面的代码片段如下:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="0722" class="mx lm iq mt b gy my mz l na nb">DoubleLinkedList&lt;Integer&gt; linkedList = new DoubleLinkedList&lt;&gt;();<br/><br/>linkedList.push(1);<br/>linkedList.push(2);<br/>linkedList.push(3);<br/><br/>linkedList.addToTail(4);<br/><br/>linkedList.push(1);<br/>linkedList.push(2);<br/>linkedList.push(3);<br/><br/>linkedList.traverse();<br/><br/>System.out.println("Deleting first node with value 2");<br/>linkedList.delete(2);<br/><br/>linkedList.traverse();<br/><br/>System.out.println("Adding value 5 after the node with index 1");<br/>linkedList.addAfterIndex(5, 1);<br/><br/>linkedList.traverse();<br/><br/>System.out.println("Deleting node at index 2");<br/>linkedList.deleteNodeAtIndex(2);<br/><br/>linkedList.traverse();<br/><br/>System.out.println("Deleting node after index 3");<br/>linkedList.deleteNodeAfterIndex(3);<br/><br/>linkedList.traverse();<br/>linkedList.reverseTraverse();</span></pre><p id="b0f1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">其输出如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d7e6" class="mx lm iq mt b gy my mz l na nb">Forward traverse: 3 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; END<br/>Deleting first node with value 2<br/>Deleted first node with value 2<br/>Forward traverse: 3 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; END<br/>Adding value 5 after the node with index 1<br/>Forward traverse: 3 -&gt; 1 -&gt; 5 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; END<br/>Deleting node at index 2<br/>Forward traverse: 3 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; END<br/>Deleting node after index 3<br/>Forward traverse: 3 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; END<br/>Reverse traverse: 4 -&gt; 2 -&gt; 3 -&gt; 1 -&gt; 3 -&gt; END</span></pre><p id="8626" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">那个产量符合我们的期望。我们可以有把握地说，我们已经创建了一个循环DLL实现。</p><p id="632d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如果你想直接进入代码，你可以把我的项目放在<a class="ae la" href="https://github.com/contactsunny/Circular_Double_LinkedList_Implementation_Java_POC" rel="noopener ugc nofollow" target="_blank">我的Github库</a>里，然后开始摆弄它。此外，如果这些没有我想的那么清楚，请在下面的评论中告诉我。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><blockquote class="jy jz ka"><p id="ca99" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<a class="ae la" href="https://twitter.com/contactsunny" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，了解更多<a class="ae la" href="https://blog.contactsunny.com/tag/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>、<a class="ae la" href="https://blog.contactsunny.com/tag/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>，以及通用<a class="ae la" href="https://blog.contactsunny.com/category/tech" rel="noopener ugc nofollow" target="_blank">技术更新</a>。还有，你可以<a class="ae la" href="https://blog.contactsunny.com/" rel="noopener ugc nofollow" target="_blank">关注我的个人博客</a>。</p></blockquote></div></div>    
</body>
</html>