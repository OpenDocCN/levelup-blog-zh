<html>
<head>
<title>🚚 Typed Route Path Management in an Angular Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">🚚Angular应用程序中的类型化路由路径管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typed-route-path-management-in-an-angular-application-c50a0f89cec3?source=collection_archive---------1-----------------------#2022-10-16">https://levelup.gitconnected.com/typed-route-path-management-in-an-angular-application-c50a0f89cec3?source=collection_archive---------1-----------------------#2022-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a2f0aa403f6de3b84c76701a0c28dccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFWO26EP5yG3qI9MS5egxA.jpeg"/></div></div></figure><div class=""/><h1 id="ed50" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题是</h1><p id="94f6" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您在过去几年中开发过任何Angular应用程序，您可能会在应用程序的应用程序或路由模块中看到一些类似这样的代码:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="82eb" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">这是我们的应用程序的路由配置，当我们将RouterModule导入我们的模块时会用到它:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="dbf4" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">然后，我们可以使用组件中的<code class="fe mf mg mh mi b">Router</code>服务导航到这些路线:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="e85b" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">或者我们可以在模板中使用<code class="fe mf mg mh mi b">routerLink</code>指令:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="e5f2" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">虽然这是Angular在其<a class="ae mj" href="https://angular.io/guide/router" rel="noopener ugc nofollow" target="_blank">文档</a>中推荐的用于设置路线的结构，但它的主要缺点是大量使用硬编码字符串。如果我拼错了路径，或者决定更改路径，会发生什么情况？因为我们使用硬编码的字符串，Typescript无法让我们知道我们提供给<code class="fe mf mg mh mi b">routerLink</code>指令或<code class="fe mf mg mh mi b">navigateByUrl</code>函数的值是无效的路由。当然，当我们改变路线时，我们可以在代码编辑器中使用find all和replace，但是依靠他人或未来的自己来记住这样做并不是一个好主意。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="2a46" class="jy jz jb bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated"><strong class="ak">初步解决方案</strong></h1><p id="ec75" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以将routes对象中的所有硬编码字符串移动到一个名为<code class="fe mf mg mh mi b">AppRoutesNames</code>的单独类中。我们将使每个路由路径成为一个静态只读属性，这样我们就可以访问它，而不需要初始化该类的一个实例。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4535" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">然后我们将删除route对象中的硬编码字符串，并用对我们的<code class="fe mf mg mh mi b">AppRouteNames</code>类中的路由路径的引用来替换它们。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="d2b9" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">之后，我们可以将<code class="fe mf mg mh mi b">AppRouteNames</code>类导入到我们的组件中，并使用route path作为<code class="fe mf mg mh mi b">navigateByUrl</code>函数的值。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="132b" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">这太棒了！我们的代码库中不再有重复的硬编码字符串。然而，这个解决方案确实有一些问题。如果我们想在组件的HTML中使用静态路由路径属性，我们需要在组件中添加<code class="fe mf mg mh mi b">AppRouteNames</code>类作为受保护的属性:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0a37" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">然后我们可以在模板中使用<code class="fe mf mg mh mi b">AppRouteNames</code>类:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="264a" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">这是可行的，但是将<code class="fe mf mg mh mi b">AppRouteNames</code>类作为属性添加到我们想要在模板中使用路由路径的每个组件将变得非常繁琐。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="9f55" class="jy jz jb bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">提供AppRouteNames类</h1><p id="daae" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以通过添加<code class="fe mf mg mh mi b">AppRouteNames</code>类作为提供者来消除创建<code class="fe mf mg mh mi b">AppRouteNames</code>类属性的一些繁琐。首先，我们将从<code class="fe mf mg mh mi b">AppRouteNames</code>类的所有属性中删除<code class="fe mf mg mh mi b">static</code>关键字:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="3670" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">接下来，我们将为<code class="fe mf mg mh mi b">AppRouteNames</code>类在<code class="fe mf mg mh mi b">AppModule </code>中的providers数组中添加一个新的提供者:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="a339" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">既然我们已经从<code class="fe mf mg mh mi b">AppRouteNames</code>类的所有route path属性中移除了static关键字，我们还需要改变我们向<code class="fe mf mg mh mi b">RouterModule</code>提供路由的方式。我们将传入一个空数组，而不是常量<code class="fe mf mg mh mi b">Routes</code>变量:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="e562" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">然后，我们将常量<code class="fe mf mg mh mi b">Routes</code>变量更改为常量函数<code class="fe mf mg mh mi b">buildRoutes</code>，它接受我们的<code class="fe mf mg mh mi b">AppRouteNames</code>类，并使用该参数来访问我们的route config中的路由路径:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="beae" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">为了向<code class="fe mf mg mh mi b">RouterModule</code>提供这个路由配置，我们将在<code class="fe mf mg mh mi b">AppModule</code>中为<code class="fe mf mg mh mi b">AppRouteNames</code>添加另一个提供者。我们将使用从<code class="fe mf mg mh mi b">@angular/router</code>导入的注入令牌<code class="fe mf mg mh mi b">ROUTES</code>作为我们要提供的东西，使用工厂和我们的<code class="fe mf mg mh mi b">buildRoutes</code>函数来返回路由配置，将<code class="fe mf mg mh mi b">multi</code>设置为true，并确保将<code class="fe mf mg mh mi b">AppRouteNames</code>类指定为依赖项:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="c92a" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">因此，我们现在可以将<code class="fe mf mg mh mi b">AppRouteNames</code>类作为受保护的成员注入到我们的组件中，并以更传统的方式使用它的类属性。这是组件类中的样子:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0556" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">以及它现在是如何在模板中使用的:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="6b64" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">不再需要添加<code class="fe mf mg mh mi b">AppRouteNames</code>类作为组件的属性。相当光滑！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="f229" class="jy jz jb bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">但是等等…还有更多(问题)！</h1><p id="4e59" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">记得我说过我们最初的解决方案有几个问题吗？好吧，如果我们只使用<code class="fe mf mg mh mi b">FIRST_CHILD_COMPONENT</code>属性，尝试导航到嵌套在路由配置中的<code class="fe mf mg mh mi b">THIRD_COMPONENT_WITH_CHILDREN</code>路由下的<code class="fe mf mg mh mi b">FIRST_CHILD_COMPONENT</code>路由，会发生什么。</p><figure class="lu lv lw lx gt is gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/eaa245c6e33a664326f34bc1052436e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*UGj-WoOxw4EGh8Zjl5A-0Q.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">后备组件页面</figcaption></figure><p id="7f3d" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">我们没有导航到我们的<code class="fe mf mg mh mi b">FirstChildComponent</code>，而是被重定向到我们的备用路由，这表明我们已经通过了我们的路由器一个无效的路由路径。如果我们回到我们的<code class="fe mf mg mh mi b">AppRouteNames</code>类，看一看<code class="fe mf mg mh mi b">FIRST_CHILD_COMPONENT</code>属性，我们可以看到值仅仅是<code class="fe mf mg mh mi b">'first-child-component'</code>。虽然这种设置可能适用于我们路由配置的第一层上的任何路由，但是每当我们需要导航到嵌套在另一个路由下的路由时，我们需要包括父路由路径和我们试图导航到的组件的路由路径。我们可以通过用斜线连接<code class="fe mf mg mh mi b">THIRD_COMPONENT_WITH_CHILDREN</code>和<code class="fe mf mg mh mi b">FIRST_CHILD_COMPONENT </code>路线路径来暂时解决这个问题:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="790b" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">现在，这个链接成功地将我们带到了<code class="fe mf mg mh mi b">FirstChildComponent</code>页面:</p><figure class="lu lv lw lx gt is gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f5c62d223db1692b0bbc3ae9157f5d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*Q-XFDsBf9_Vc3JTs6biY2g.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">嵌套在ThirdComponentWithChildren页面下的FirstChildComponent页面</figcaption></figure><p id="bd6a" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">但是我的天啊，这个解决方案太丑了。如果我们在路由配置中有一个以上的嵌套层会怎样？我们将不得不继续添加父路径，以及它们之间的斜线。在我们想要使用嵌套路由的任何地方重复这种逻辑违反了DRY原则，并且会很快过时。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d54f" class="jy jz jb bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">改进我们的AppRouteNames类</h1><p id="ad1c" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">虽然我们的类中并不是所有的路由路径都是嵌套的，但是如果所有路由的结构都是相同的就更好了。我们要做的第一件事是在我们的<code class="fe mf mg mh mi b">AppRouteNames</code>类中重命名所有的路由路径，在它们前面加上前缀<code class="fe mf mg mh mi b">RELATIVE_</code>。除了在我们的路由配置中，备用路由路径不会在任何地方使用，所以我们可以不使用它。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="c568" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">这些前缀为<code class="fe mf mg mh mi b">RELATIVE_</code>的路由路径是我们将在路由配置中使用的路由路径，我们将其传递给<code class="fe mf mg mh mi b">AppModule</code>中的<code class="fe mf mg mh mi b">RouterModule</code>。我们需要更改路由配置，以使用这些新的相对路由路径。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="1963" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">对于打算在路由配置之外使用的每个路由路径，我们将创建另一个具有相同名称的属性，没有前缀<code class="fe mf mg mh mi b">RELATIVE_</code>。该属性可以是相对管线路径，或者对于嵌套组件，是从一系列相对路径构建的管线路径。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="b475" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">对于我们的嵌套路由路径，我们可以通过向我们的<code class="fe mf mg mh mi b">AppRouteNames</code>类添加一个私有帮助函数来进一步增强这一点，该函数接收URL段并用斜杠将它们连接在一起，因此我们不必记得自己做这件事。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="692d" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">然后我们可以回到我们最初只使用<code class="fe mf mg mh mi b">FIRST_CHILD_COMPONENT</code>路线路径的地方，并将它<strong class="ky jc">改回</strong>到只使用<code class="fe mf mg mh mi b">FIRST_CHILD_COMPONENT</code>。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5b99" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">现在，这使我们正确地使用了嵌套组件，在我们的模板中没有字符串连接！</p><figure class="lu lv lw lx gt is gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f5c62d223db1692b0bbc3ae9157f5d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*Q-XFDsBf9_Vc3JTs6biY2g.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">嵌套在ThirdComponentWithChildren页面下的FirstChildComponent页面</figcaption></figure><p id="9cef" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">虽然这确实解决了我们的嵌套路由问题，但它使<code class="fe mf mg mh mi b">AppRouteNames</code>类的属性数量增加了一倍，这可以在一个更大的应用程序中累加起来。这种解决方案在处理包含路由参数的路由路径时也会遇到问题。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="8c4f" class="jy jz jb bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated"><strong class="ak">处理路线参数</strong></h1><p id="62cd" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">到目前为止，我们还没有使用任何利用Angular的路线参数的路线。我们可以从将相对路由路径添加到我们的<code class="fe mf mg mh mi b">AppRouteNames</code>类开始。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="ff5d" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">然后，我们可以在<code class="fe mf mg mh mi b">buildRoutes</code>功能中将该路线添加到我们的路线配置中。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="09be" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">在这种情况下，我们不能为完整的路由路径使用另一个类属性，因为我们希望能够动态生成<code class="fe mf mg mh mi b">:id</code>部分。相反，我们将使用一个将<code class="fe mf mg mh mi b">id</code>作为字符串的函数。我们仍然可以使用<code class="fe mf mg mh mi b">buildURL</code>助手函数来构建URL，但是由于相对路由路径的<code class="fe mf mg mh mi b">:id</code>部分，我们将不能在函数内部使用它，而是必须复制路由路径的<code class="fe mf mg mh mi b">'fourth-component'</code>部分。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="218a" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">现在，我们可以在模板中使用这个路由路径:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9928" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">将我们导航到id为1的组件:</p><figure class="lu lv lw lx gt is gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/08b1622c18117bcbed02c0be75d0542a.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*lhTgOJJS5W5POIEDK63Llg.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">id为1的第四个组件</figcaption></figure><p id="374e" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">但是，这又把我们带回了最初的重复字符串问题，虽然它们并没有贯穿整个代码库，但感觉我们不应该在这一点上重复字符串。如果有一种方法可以访问我们的路由路径作为一个类型化的对象，并避免重复的字符串，而不必在一个单独的类中指定一堆路由路径和构建函数，除了我们的路由配置之外，会怎么样？</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="b5c2" class="jy jz jb bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">ngx-高级路由器</h1><p id="b8bd" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个问题促使我构建了<a class="ae mj" href="https://www.npmjs.com/package/ngx-advanced-router" rel="noopener ugc nofollow" target="_blank"> ngx-advanced-router </a>。它的功能是替代Angular的默认<code class="fe mf mg mh mi b">RouterModule</code>，它允许您将路由配置指定为可注入的服务，并快速方便地访问您的路由路径。我们可以从在Angular项目中安装这个包开始:</p><p id="7cf3" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated"><code class="fe mf mg mh mi b">npm install --save ngx-advanced-router</code></p><p id="3332" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">接下来，我们需要创建一个扩展<code class="fe mf mg mh mi b">AdvancedRouteService</code>的新服务。扩展这个类需要我们实现一个抽象属性:<code class="fe mf mg mh mi b">routesConfig</code>。这个属性是我们放置一个类似的路由配置的地方，我们在前面的<code class="fe mf mg mh mi b">buildRoutes</code>函数中返回了这个配置。然而，我们将拥有一个带有键和路由对象作为值的对象，而不是路由对象的数组。下面是我们从<code class="fe mf mg mh mi b">buildRoutes</code>函数转换路由配置时的样子:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="c10f" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">需要注意的一点是，我们将实际的路由路径字符串移回了路由配置中，就像本文开始时那样。另一件要注意的事情是，我们不仅可以为路径传入一个字符串，还可以传入一个函数，如路径上所示的<code class="fe mf mg mh mi b">fourthWithRouteParameter</code>路线。</p><p id="70fd" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">要使用这个服务，我们将返回到我们的<code class="fe mf mg mh mi b">AppModule</code>，并从providers数组中删除<code class="fe mf mg mh mi b">AppRouteNames</code>和<code class="fe mf mg mh mi b">ROUTES</code>提供者，以及从imports数组中删除<code class="fe mf mg mh mi b">RouterModule</code>。相反，我们将把带有<code class="fe mf mg mh mi b">forRoot</code>函数的<code class="fe mf mg mh mi b">AdvancedRouterModule</code>添加到imports数组，传入我们新创建的route服务:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="404c" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">在我们注入<code class="fe mf mg mh mi b">AppRouteNames</code>类的<code class="fe mf mg mh mi b">AppComponent</code>中，我们将导入<code class="fe mf mg mh mi b">AppRouteService</code>。为了使用这个服务来访问我们的路由路径，我们将使用服务的<code class="fe mf mg mh mi b">routes</code>属性。基于我们之前在服务中设置的路由配置，访问该属性为我们提供了一组很好的自动完成选项。</p><figure class="lu lv lw lx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/aa13d290273dcc9b59a84d02285d12e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMvn2OUoy9wNrlVNApNz5g.png"/></div></div></figure><p id="58c0" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">如果我们想要导航到“第一条”路线，我们可以使用<code class="fe mf mg mh mi b">path</code>属性，它返回完整的路线路径。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="6dc2" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">对于有孩子的路由，除了<code class="fe mf mg mh mi b">path</code>属性之外，它们还有一个<code class="fe mf mg mh mi b">children</code>属性，这也给了我们一个很好的自动完成列表。</p><figure class="lu lv lw lx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/fda3485654d3a0a4d200c0bf2f3bbdd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FzRtdaZDLvUtmOnx532RZw.png"/></div></div></figure><p id="a603" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">下面是访问该子路由路径的完整代码:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="3f10" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">对于包含路由参数的动态路由，如<code class="fe mf mg mh mi b">fourthWithRouteParameter</code>路由，routes对象为我们提供了一个函数，其参数与我们在路由配置中设置的函数参数相同。我们可以调用这个函数，然后访问<code class="fe mf mg mh mi b">path</code>属性来获取完整的路由路径。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="177b" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">就是这样！该解决方案解决了我们面临的所有问题:</p><ol class=""><li id="a660" class="nf ng jb ky b kz ma ld mb lh nh ll ni lp nj lt nk nl nm nn bi translated"><strong class="ky jc">没有重复的字符串<br/> </strong>现在字符串在route config中只使用一次，<code class="fe mf mg mh mi b">routes</code>属性用于访问route paths中的其他所有内容。</li><li id="aca4" class="nf ng jb ky b kz no ld np lh nq ll nr lp ns lt nk nl nm nn bi translated"><strong class="ky jc">没有额外的组件属性<br/> </strong>我们的路由服务使用Angular的依赖注入，因此不需要仅仅为了访问我们的路由路径而向我们的组件添加属性。</li><li id="77c2" class="nf ng jb ky b kz no ld np lh nq ll nr lp ns lt nk nl nm nn bi translated"><strong class="ky jc">无即兴路线路径构建<br/> </strong>路线服务负责为我们构建路线路径，无论它们是在根级别还是5级深度。</li><li id="d865" class="nf ng jb ky b kz no ld np lh nq ll nr lp ns lt nk nl nm nn bi translated"><strong class="ky jc">无相对路线路径<br/> </strong> ngx-advanced-router负责以其寻找的格式向Angular的<code class="fe mf mg mh mi b">RouterModule</code>提供路线，并向您提供绝对路线路径。</li><li id="0c67" class="nf ng jb ky b kz no ld np lh nq ll nr lp ns lt nk nl nm nn bi translated"><strong class="ky jc">无需额外的路线路径类<br/> </strong>在路线服务中声明一次你的路线设置，在<code class="fe mf mg mh mi b">AdvancedRouterModule.forRoot()</code>函数中使用，就大功告成了！</li></ol><p id="c4d1" class="pw-post-body-paragraph kw kx jb ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">请在评论中告诉我你的想法！我乐于接受让这个包更好的建议。</p></div></div>    
</body>
</html>