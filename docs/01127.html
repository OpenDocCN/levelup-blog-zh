<html>
<head>
<title>Why “bug free” is a fairly ridiculous assertion, and what to aim for instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么“无bug”是一个相当荒谬的断言，我们的目标是什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-bug-free-is-a-fairly-ridiculous-assertion-and-what-to-aim-for-instead-5af830eee839?source=collection_archive---------6-----------------------#2019-11-12">https://levelup.gitconnected.com/why-bug-free-is-a-fairly-ridiculous-assertion-and-what-to-aim-for-instead-5af830eee839?source=collection_archive---------6-----------------------#2019-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/45cf9970ae00ca31694cbe7b6ba320ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k-VR7WcUSOjBtJLg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克雷格·卡梅隆在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="24fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么要写单元测试？我问过很多人，一个常见的回答是:“所以我知道我的代码没有bug。”</p><p id="7e4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，这听起来很合理，除了一件事…</p><p id="66bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说一段代码100%没有错误就像说一艘大帆船上没有老鼠一样…你永远无法确定。</p><p id="8d52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了说明原因，让我们从最简单的情况开始，然后加入一些次要的复杂性。</p><p id="3743" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码单元越小或越不复杂，就越有理由将其标记为100%无错误:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/e226155fe4432dd10536a6a9f68816c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1T4dLPb8R9pQ4xv2TuGYYA.jpeg"/></div></div></figure><p id="3e4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码只有一个没有参数的函数<code class="fe lj lk ll lm b">calculateTax</code>。假设结果是不变量，只有一种可能的结果。在这一级别的测试中，只需验证一个预期的结果，您就可以安全地验证该功能是否有效。</p><p id="f43e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，功能不会独立运行，它们是一个更大系统的一部分:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/540871e1cf4a894a1d822b8508c8f82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BQfMxGeFuNiHPHSRsOG1g.jpeg"/></div></div></figure><p id="52da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在有四个功能，而不是只有一个，所以事情变得有点复杂。</p><p id="171d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数调用链仍然只有一个入口点；然而，即使这个简单的代码也有潜在的错误，因为:</p><ul class=""><li id="63a8" class="ln lo it ki b kj kk kn ko kr lp kv lq kz lr ld ls lt lu lv bi translated"><code class="fe lj lk ll lm b">currentTaxLevel</code>依赖于<code class="fe lj lk ll lm b">findTaxBracket</code>的输出</li><li id="5b64" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated"><code class="fe lj lk ll lm b">calculate</code>依赖于<code class="fe lj lk ll lm b">currentTaxLevel</code>的输出</li><li id="b648" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated"><code class="fe lj lk ll lm b">calculateTax</code>(最外层功能)依赖于<code class="fe lj lk ll lm b">calculate</code>的输出</li></ul><p id="0e30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是大多数代码甚至没有那么简单。</p><p id="fbf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你熟悉<a class="ae kf" href="https://medium.com/@john_ryu/metcalfes-law-101-69733d33b167" rel="noopener">梅特卡夫定律</a>，仅仅5个相互关联的函数的最坏情况的复杂程度可能是这样的:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/a682606e770f74a0a704e5537e52fbee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*feUAm_3n84dh8HPlpKv9Lg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">晚餐吃意大利面？</figcaption></figure><p id="67f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…不过，公平地说，这肯定是一个设计得非常糟糕的程序。</p><p id="acfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你为<code class="fe lj lk ll lm b">a()</code>编写一个单元测试，为<code class="fe lj lk ll lm b">b()</code>编写一个单元测试，等等，这将变得非常昂贵，但是不能证明<code class="fe lj lk ll lm b">a</code>、<code class="fe lj lk ll lm b">b</code>、<code class="fe lj lk ll lm b">c</code>等等一起正确地工作。正确性与验证功能本身一样，也与功能之间的交互有关。</p><p id="7b89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而在如此多的项目中，<a class="ae kf" href="https://en.wikipedia.org/wiki/Code_coverage" rel="noopener ugc nofollow" target="_blank">代码覆盖率</a>——测试运行的代码库的百分比——在衡量项目的整体适用性时被给予了不成比例的高度重视。您可以为上述5个函数中的每一个编写一个独立的测试，并在每种情况下模仿或存根其他4个函数，并且——即使项目仍然可能充满bug——代码覆盖率将达到令人兴奋的100%。啊哦…</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/799ccbcec242f5e309d175ad0de2f410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hNV2ZBhaRO8qrbxZ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@eyrejune123?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾尔·琼·布斯塔曼特</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b984" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦您从单个函数中缩小哪怕一点点，您就会面临复杂性——函数在不同的时间以不同的顺序从不同的端点调用其他函数。排列的数量很快变得惊人的巨大，以至于说“是的，绝对没有错误”是荒谬的。我们可以尽最大努力，通过手工测试、自动化测试、基于属性的测试等来捕捉尽可能多的bug，但仅此而已。</p><h1 id="b6e9" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">"哦，他现在正试着看花"</h1><p id="8f7c" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">情况变得更糟……取决于输入参数——也就是说，一旦你开始考虑<em class="nf">数据</em>——代码覆盖率的概念变得毫无意义。可能的结果的数量，以及潜在的未被发现的错误的数量，实际上是无限的。</p><p id="14a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想，到目前为止，我已经描绘了一幅相当暗淡的单元测试图，但是…暗示乌云正在散去，太阳正在升起…有一种更好的测试方法，也将使你的编程生活变得更容易。</p><h1 id="5c78" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">所以，如果我们不能证明我们的代码没有错误，我们能做什么呢？</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/77db1b71d2b26b143e2f2fc8ac52db81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BZNyP40QYy40dyYL"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">罗伯特·卢克曼在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7fef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于“无bug”是一个相当荒谬的断言，你的软件可以被打上“适合用途”的标签。</p><p id="c117" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“目的”是由需求定义的，您可以使用用户故事和场景来指定。让我们停下来快速定义一下:</p><p id="1b3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户故事是从最终用户的角度对软件特性的描述。场景是用户故事的一个具体例子。</p><p id="69db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个例子:</p><blockquote class="ni nj nk"><p id="2199" class="kg kh nf ki b kj kk kl km kn ko kp kq nl ks kt ku nm kw kx ky nn la lb lc ld im bi translated">作为一名银行客户，我想从自动取款机上取钱，这样我的钱包里就有现金了。</p></blockquote><p id="3a8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">场景分解故事，探索细节。您应该会发现，您至少有一个“快乐之路”场景(一切顺利)，以及您的团队能想到的尽可能多的“不快乐之路”场景(哪里出错了，系统如何响应)。场景通常以用例形式编写(“用户输入他们的PIN系统检查PIN和…)，或者作为测试场景，例如使用<a class="ae kf" href="https://medium.com/@mvwi/story-writing-with-gherkin-and-cucumber-1878124c284c" rel="noopener">小黄瓜</a>格式(“给定/何时/然后”)。</p><h1 id="35a4" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">所以，现在我们都赶上了…</h1><p id="1ef6" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">如果测试全面地覆盖了需求，那么您可以自信地说:</p><blockquote class="ni nj nk"><p id="5dd1" class="kg kh nf ki b kj kk kl km kn ko kp kq nl ks kt ku nm kw kx ky nn la lb lc ld im bi translated">我的代码符合目的，因为它满足需求(用户故事和场景),包括我可能遇到的所有错误场景(不愉快的路径)。</p></blockquote><p id="e49f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这和“这段代码没有bug”是完全不同的，因为“这段代码没有bug”是完全没有把握的。但是前者比后者更有用，这也是我们的目标。这也是一个更现实的目标。</p><p id="80c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">换句话说，瞄准<em class="nf">需求覆盖</em>而不是代码覆盖。</strong></p><p id="b24f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在测试中达到100%的需求覆盖率实际上是非常简单的——事实上，这是您的项目非常希望达到的状态😍。您只需执行以下操作即可实现这一目标:</p><ol class=""><li id="dae2" class="ln lo it ki b kj kk kn ko kr lp kv lq kz lr ld no lt lu lv bi translated">将用户故事分解成不同的场景——开心的和不开心的</li><li id="3c86" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld no lt lu lv bi translated">在编写代码时，为每个场景编写测试</li></ol><p id="808a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最重要的是:</p><p id="32a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仅编写满足场景的代码，其中场景满足故事的一部分。</p><p id="f8d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从需求覆盖而不是代码覆盖的角度来思考是思维方式的真正改变，因为团队会突然关注所有的需求，质疑边缘案例，并从涉众那里寻求澄清。这经常导致需求本身被修改，在任何一个需求被写在代码中之前。</p><p id="74c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，你的团队将<a class="ae kf" href="https://www.domainorientedtesting.com/" rel="noopener ugc nofollow" target="_blank">将测试导向业务领域</a>而不是被测代码。</p><p id="0232" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是最重要的是，基于需求场景的测试意味着您将确切地知道您什么时候完成了测试——既知道您什么时候编写了使测试通过的所有代码，也知道您什么时候编写了足够多的测试。</p><p id="fd2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且您将能够自信地说您的代码是适合目的的。</p></div></div>    
</body>
</html>