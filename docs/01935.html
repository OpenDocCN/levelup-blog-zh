<html>
<head>
<title>Browser to Browser Communication with Vert.x and Hazelcast</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vert.x和Hazelcast进行浏览器对浏览器通信</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/browser-to-browser-communication-with-vert-x-and-hazelcast-cluster-450b16903a55?source=collection_archive---------6-----------------------#2020-02-07">https://levelup.gitconnected.com/browser-to-browser-communication-with-vert-x-and-hazelcast-cluster-450b16903a55?source=collection_archive---------6-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="87b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无需通过中央服务器就能在浏览器之间执行点对点消息传递的能力，将为游戏和协作应用等实时应用带来大量机会。</p><p id="12dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Vert.x使应用程序能够使用SockJS Bridge将浏览器连接到后端的事件总线。桥的使用将连接的应用程序直接放在后端事件总线上，跳过了使用中介在后端重新发布消息的需要。通信的对等性质减少了通信的负载和延迟，因为中间没有服务器来处理和代理消息。</p><h1 id="944c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">使用Hazelcast进行聚类</h1><p id="e2ff" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Vert.x支持集群和现成的HA。集群组管理在可插拔的集群管理器中实现。默认的集群管理器使用Hazelcast，但是可以用另一个实现来代替，因为Vert.x集群管理器是可插拔的。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/61b7513a4393f9babb034d2781a16de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KvaDTtY0cJ7R2mF_8HicTw.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">黑兹尔卡斯特星团</figcaption></figure><p id="5cd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Vert.x集群管理器用于各种功能，包括:</p><ul class=""><li id="7153" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">集群中Vert.x节点的发现和组成员身份</li><li id="9371" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">维护集群范围的主题订阅者列表(这样我们就知道哪些节点对哪些事件总线地址感兴趣)</li><li id="d64d" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">分布式地图支持</li><li id="98bc" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">分布式锁</li><li id="1c83" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">分布式计数器</li></ul><p id="7187" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mv">注意:集群管理器不处理事件总线节点间的传输，这是由Vert.x通过TCP连接直接完成的。</em></p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8683dd706a7afc28b9eb732d5ce9aa11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*7Ydx96QrZZFug0hFNdg-rQ.png"/></div></figure><p id="8dac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过使用分布式事件总线，我们可以构建一个具有动态负载平衡的统一API，具有多样化的后台任务和一个可以随着负载发展和扩展的异步API。</p><p id="f233" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看一个Vert.x应用程序的例子，它使用Hazelcast进行集群，以实现浏览器到浏览器的通信。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/3454978b4a83438353042a4c36ac8040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*7U9q5qlfkgXnca3nsl8eQw.png"/></div></figure><h2 id="6cf0" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">添加Hazelcast集群管理器</h2><p id="5de3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果您想在Vert.x Maven或Gradle项目中使用Hazelcast集群管理器添加集群，那么只需在项目中添加一个对工件:<code class="fe nj nk nl nm b">io.vertx:vertx-hazelcast:3.8.5</code>的依赖项。</p><p id="6bdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果jar在您的类路径中，那么Vert.x会自动检测到这一点，并将其用作集群管理器。请确保您的类路径中没有任何其他集群管理器，否则Vert.x可能会选择错误的管理器。</p><p id="2b7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果通过在创建Vert.x实例时在选项上指定来嵌入Vert.x，也可以通过编程方式指定集群管理器。</p><pre class="ls lt lu lv gt nn nm no np aw nq bi"><span id="3b76" class="mx kp it nm b gy nr ns l nt nu">ClusterManager mgr = new HazelcastClusterManager();<br/>VertxOptions options = new VertxOptions().setClusterManager(mgr);  Vertx.clusteredVertx(options, res -&gt; {   <br/>    if (res.succeeded()) {<br/>       Vertx vertx = res.result();<br/>    } else {<br/>        <em class="mv">// failed!</em>   <br/>    }<br/>});</span></pre><h2 id="ca4f" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">配置集群管理器</h2><p id="feb0" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">通常集群管理器是由打包在jar中的文件<code class="fe nj nk nl nm b">default-cluster.xml</code>配置的。如果您想覆盖这个配置，您可以在您的类路径上提供一个名为<code class="fe nj nk nl nm b">cluster.xml</code>的文件，这个文件将被使用。如果要将<code class="fe nj nk nl nm b">cluster.xml</code>文件嵌入到fat jar中，它必须位于fat jar的根目录。如果是外部文件，包含该文件的<strong class="js iu">目录</strong>必须添加到类路径中。覆盖配置的另一种方法是为系统属性<code class="fe nj nk nl nm b">vertx.hazelcast.config</code>提供一个位置。</p><pre class="ls lt lu lv gt nn nm no np aw nq bi"><span id="d5a6" class="mx kp it nm b gy nr ns l nt nu"><em class="mv"># Use a cluster configuration located in an external file</em> <br/>java -Dvertx.hazelcast.config=config/my-cluster-config.xml -jar ...</span></pre><p id="9859" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面给出了基于TCP/IP的加入和发现的示例集群配置。如果您的网络支持多播，您可以使用多播；如果在AWS上部署应用程序，您可以使用AWS。</p><pre class="ls lt lu lv gt nn nm no np aw nq bi"><span id="8ea9" class="mx kp it nm b gy nr ns l nt nu">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;hazelcast xsi:schemaLocation=<br/>  "<a class="ae nv" href="http://www.hazelcast.com/schema/config" rel="noopener ugc nofollow" target="_blank">http://www.hazelcast.com/schema/config</a> hazelcast-config-3.7.xsd"<br/>  ae nv" href="http://www.hazelcast.com/schema/config" rel="noopener ugc nofollow" target="_blank"&gt;http://www.hazelcast.com/schema/config"<br/>  xmlns:xsi="<a class="ae nv" href="http://www.w3.org/2001/XMLSchema-instance" rel="noopener ugc nofollow" target="_blank">http://www.w3.org/2001/XMLSchema-instance</a>"&gt;<br/>    &lt;network&gt;<br/>        &lt;port auto-increment="true" port-count="20"&gt;5701&lt;/port&gt;<br/>        &lt;join&gt;<br/>            &lt;multicast enabled="false"&gt;<br/>                &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt;<br/>                &lt;multicast-port&gt;54327&lt;/multicast-port&gt;<br/>            &lt;/multicast&gt;<br/>            &lt;tcp-ip enabled="true"&gt;<br/>                &lt;interface&gt;127.0.0.1&lt;/interface&gt;<br/>            &lt;/tcp-ip&gt;<br/>            &lt;aws enabled="false"&gt;<br/>                &lt;access-key&gt;my-access-key&lt;/access-key&gt;<br/>                &lt;secret-key&gt;my-secret-key&lt;/secret-key&gt;<br/>                &lt;!--optional, default is us-east-1 --&gt;<br/>                &lt;region&gt;us-west-1&lt;/region&gt;<br/>                &lt;!--optional, default is ec2.amazonaws.com. If set, region shouldn't be set as it will override this property --&gt;<br/>                &lt;host-header&gt;ec2.amazonaws.com&lt;/host-header&gt;<br/>                &lt;!-- optional, only instances belonging to this group will be discovered, default will try all running instances --&gt;<br/>                &lt;security-group-name&gt;hazelcast-sg&lt;/security-group-name&gt;<br/>                &lt;tag-key&gt;type&lt;/tag-key&gt;<br/>                &lt;tag-value&gt;hz-nodes&lt;/tag-value&gt;<br/>            &lt;/aws&gt;<br/>        &lt;/join&gt;<br/>    &lt;/network&gt;<br/>&lt;/hazelcast&gt;</span></pre><p id="5276" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在嵌入了Vert.x的应用程序驱动程序类中，为集群创建一个Vert.x实例如下:</p><pre class="ls lt lu lv gt nn nm no np aw nq bi"><span id="0198" class="mx kp it nm b gy nr ns l nt nu">public void start() {<br/>    ClusterManager mgr = new HazelcastClusterManager();<br/>    VertxOptions vOptions = new VertxOptions().setBlockedThreadCheckInterval(1000)<br/>                                              .setClusterManager(mgr);<br/>    Vertx.clusteredVertx(vOptions, res -&gt; {<br/>        if (res.succeeded()) {<br/>            m_vertx = res.result();<br/>            m_vertx.deployVerticle(new ApiVerticle(), (result) -&gt; {<br/>                if (result.succeeded()) {<br/>                } else {<br/>                }<br/>            });<br/>        } else {<br/>            // failed!<br/>        }<br/>    });<br/>}</span></pre><p id="100a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Verticle可以在其start()方法中检测它是否运行在集群应用程序上。</p><pre class="ls lt lu lv gt nn nm no np aw nq bi"><span id="9cf3" class="mx kp it nm b gy nr ns l nt nu">@Override<br/>public void start() throws Exception {<br/>    if (vertx != null &amp;&amp; vertx.isClustered()) {<br/>        m_clusterManager = ((VertxInternal)vertx).getClusterManager();<br/>        m_node_id = m_clusterManager.getNodeID();<br/>    } else {<br/>        // No cluster<br/>    }<br/>}</span></pre><p id="0e37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们创建了一个部署了Verticle的集群Vert.x实例，我们就可以通过事件总线连接浏览器了。</p><pre class="ls lt lu lv gt nn nm no np aw nq bi"><span id="72d1" class="mx kp it nm b gy nr ns l nt nu">// Create a router object.<br/>m_router = Router.router(vertx);</span><span id="0b56" class="mx kp it nm b gy nw ns l nt nu">// set in and outbound permitted addresses<br/>// Allow events for the designated addresses in/out of the event bus bridge<br/>BridgeOptions opts = new BridgeOptions()<br/>  .addInboundPermitted(new PermittedOptions().setAddress("to.api"))<br/>  .addInboundPermitted(new PermittedOptions().setAddress("to.api."+m_node_id))<br/>  .addOutboundPermitted(new PermittedOptions().setAddress("to.client"))<br/>  .addOutboundPermitted(new PermittedOptions().setAddress(m_node_id+".to.client"));</span><span id="2c1f" class="mx kp it nm b gy nw ns l nt nu">SockJSHandler sockJSHandler = SockJSHandler.create(vertx);<br/>sockJSHandler.bridge(opts, event -&gt; {<br/>  // This signals that it's ok to process the event<br/>  event.complete(true);<br/>});<br/>m_router.route("/eventbus/*").handler(sockJSHandler);</span></pre><p id="7b62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以在事件总线主题上连接消息处理程序，以处理和响应事件总线上的各种消息。这种方法的美妙之处在于它可以灵活地忽略消息的来源，只要它使用正确的话题来听。</p><pre class="ls lt lu lv gt nn nm no np aw nq bi"><span id="1cb2" class="mx kp it nm b gy nr ns l nt nu">// Register to listen for messages coming IN to the server<br/>vertx.eventBus().consumer("node."+m_node_id).handler(message -&gt; {<br/>    // Send the message back out to all clients<br/>    vertx.eventBus().publish(m_node_id+".to.client", message);<br/>});<br/>vertx.eventBus().consumer("to.api."+m_node_id).handler(message -&gt; {<br/>    String json_request = (String) message.body();<br/>    JsonObject json_request_obj = new JsonObject(json_request);<br/>    String id = json_request_obj.getString("node", "");<br/>    // Send the message back out to all clients<br/>    vertx.eventBus().send("node."+id, message);<br/>});<br/>vertx.eventBus().consumer("to.api").handler(message -&gt; {<br/>    String json_request = (String) message.body();<br/>    JsonObject json_request_obj = new JsonObject(json_request);<br/>    if (json_request_obj.containsKey("GetNodes")) {<br/>        sendNodes();<br/>    } else {<br/>        vertx.eventBus().publish("to.client", json_request);<br/>    }<br/>});</span></pre><p id="e6fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用集群管理器查询集群中的所有节点。</p><pre class="ls lt lu lv gt nn nm no np aw nq bi"><span id="a61b" class="mx kp it nm b gy nr ns l nt nu">private void sendNodes() {<br/>    List&lt;String&gt; nodes = m_clusterManager.getNodes();<br/>    JsonObject obj = new JsonObject();<br/>    JsonArray arr  = new JsonArray();<br/>    for (String node : nodes) {<br/>        arr.add(node);<br/>    }<br/>    obj.put("nodes", arr);<br/>    vertx.eventBus().send("to.client", obj.encode());<br/>}</span></pre><p id="a775" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">浏览器客户端可以在事件总线上注册自己，并附加消息处理程序来侦听和响应针对其感兴趣的主题的任何消息。</p><pre class="ls lt lu lv gt nn nm no np aw nq bi"><span id="0b8c" class="mx kp it nm b gy nr ns l nt nu">var eb = new EventBus("/eventbus/");<br/>eb.onopen = function () {<br/>  eb.registerHandler("to.client", function (err, msg) {<br/>      var str = unescape(msg.body);<br/>      var serverArea = document.getElementById("outserver");<br/>      serverArea.value += JSON.stringify(str)+'\n'<br/>  });<br/>  loadNodes();<br/>};<br/>function loadNodes() {<br/>    var request = "{\"GetNodes\":{}}";<br/>    eb.send("to.api", request);<br/>}</span></pre><p id="ea51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用分布式事件总线上的主题来响应到达它所关心的主题的任何消息。</p><pre class="ls lt lu lv gt nn nm no np aw nq bi"><span id="a312" class="mx kp it nm b gy nr ns l nt nu">var inputArea = document.getElementById("in");<br/>var outputArea = document.getElementById("out");<br/>var sendButton = document.getElementById("send");<br/>var broadcastButton = document.getElementById("broadcast");</span><span id="3528" class="mx kp it nm b gy nw ns l nt nu">sendButton.onclick = function() {<br/>    var message = {};<br/>    message["send"] = inputArea.value;<br/>    eb.send("to.api",JSON.stringify(message));<br/>    outputArea.value += JSON.stringify(message)+'\n'<br/>    outputArea.scrollTop = outputArea.scrollHeight;<br/>};<br/>broadcastButton.onclick = function() {<br/>    var message = {};<br/>    message["publish"] = inputArea.value;<br/>    eb.publish("to.api",JSON.stringify(message));<br/>    outputArea.value += JSON.stringify(message)+'\n'<br/>    outputArea.scrollTop = outputArea.scrollHeight;<br/>};</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nx"><img src="../Images/ae0087477fc5aee787d960fac40d5164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trV-NfRGRxY0r9ohkZHpeA.png"/></div></div></figure><p id="a556" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该示例API应用程序的完整工作示例可在<a class="ae nv" href="https://github.com/pvub/VertxPolyglotClusterdEventBus" rel="noopener ugc nofollow" target="_blank">https://github.com/pvub/VertxPolyglotClusterdEventBus</a>找到</p><p id="c7e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编码快乐！</p></div></div>    
</body>
</html>