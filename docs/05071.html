<html>
<head>
<title>Zobrist Hashing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">佐布里斯特散列法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/zobrist-hashing-305c6c3c54d0?source=collection_archive---------2-----------------------#2020-08-02">https://levelup.gitconnected.com/zobrist-hashing-305c6c3c54d0?source=collection_archive---------2-----------------------#2020-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8ce495a5f59c4076c528d9652ea56ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_28h9D8qp0nRcak5JYTDg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/photos/w7ZyuGYNpRQ" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/w7ZyuGYNpRQ</a></figcaption></figure><p id="6a5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Zobrist hashing以其发明者Albert Zobrist的名字命名，是一种将棋盘位置(如国际象棋或围棋)表示为哈希值的技术。它主要与转置表一起使用，转置表是一种特殊的哈希表，由电路板位置索引，用于避免多次分析同一电路板位置。</p><h1 id="512b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">它有什么好处</h1><p id="8fff" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在博弈论中，有像<a class="ae kf" href="https://en.wikipedia.org/wiki/Minimax" rel="noopener ugc nofollow" target="_blank"> Minimax </a>或<a class="ae kf" href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning" rel="noopener ugc nofollow" target="_blank"> AlphaBeta </a>这样的算法，用于分析棋盘位置，并在给定情况下找到最佳可能的棋步。这可能适用于国际象棋、围棋或井字游戏。</p><p id="70af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些算法采用一个给定的起始位置，用每个玩家所有可能的移动来模拟游戏的进一步过程。在开发者规定的评估方法的帮助下，该算法可以在每种游戏情况下计算分数。基于这个分数，算法知道一个位置是好还是坏，或者导致这个位置的移动。理想情况下，这种算法的输出是其计算得分的最佳可能移动。</p><p id="f5e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个问题是，计算最佳走法可能需要很长时间，尤其是像国际象棋这样的游戏。这是因为像国际象棋这样的游戏有一个巨大的博弈树。博弈树是一个有向图，它的节点是博弈中的位置，边是棋步。像Minimax这样的算法构建了这样一个图，并遍历它来寻找最佳可能的移动。</p><p id="3cc3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" href="https://en.wikipedia.org/wiki/Transposition_table" rel="noopener ugc nofollow" target="_blank">转置表</a>的帮助下，加速这些算法是可能的。换位表就像一个缓存，存储已经分析过的电路板位置。在构建游戏树的时候，你通常会不止一次碰到同一个棋盘位置。如果没有换位台，您每次都必须重新分析电路板位置。因此，一旦算法评估了一个位置，它就将结果存储在转置表中，以避免这种行为。下次算法遇到这个位置时，它可以从转置表中得到结果。</p><p id="0448" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总而言之:在算法中使用转置表来避免多次分析相同的位置。</p><p id="2923" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数情况下，转置表是作为散列表实现的，其中的键是字符串表示中的棋盘位置。因此，关于棋盘位置，可以存储一些信息，比如最佳走法。</p><p id="d37b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是<strong class="ki iu"> Zobrist hash </strong>出现的地方:Zobrist hashing是一种将给定的棋盘位置表示为(唯一的)哈希值的方法。这个散列在转置表中用于将信息(如最佳移动)映射到棋盘，并使其可访问。</p><p id="f0ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以下面的段落描述了Zobrist hash是如何工作的，以及它是如何计算的。这里以井字游戏为例。在这篇文章的最后，你会发现一个Kotlin的实现。</p><h1 id="5ec0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">它是如何工作的</h1><p id="0642" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Zobrist hashing使用一组随机生成的数字的<code class="fe mh mi mj mk b">xor</code>操作，称为密钥。我们将其分为两部分:</p><ul class=""><li id="66b3" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">生成密钥</li><li id="181d" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">计算哈希值</li></ul><h2 id="f020" class="mz lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">生成密钥</h2><p id="9a2f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，我们必须根据以下方案生成密钥:</p><blockquote class="nl nm nn"><p id="7229" class="kg kh no ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">对于每个可用的棋盘单元和其中一个单元中的每个可能的游戏角色，我们生成一个随机数。</p></blockquote><p id="d85b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这听起来可能有点令人困惑，但实际上很简单。让我们来看看我们的例子，井字游戏:</p><p id="356f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在井字游戏棋盘中，有9个可用的单元格。在这些单元的每一个中，可以放置2个不同的游戏角色:<code class="fe mh mi mj mk b">X</code>或<code class="fe mh mi mj mk b">O</code>。所以根据上面的引用，我们必须生成18 (9*2)个随机数。</p><pre class="ns nt nu nv gt nw mk nx ny aw nz bi"><span id="9c84" class="mz lf it mk b gy oa ob l oc od">cell  |   player 1 (X)  |   player 2 (O)<br/>------------------------------------------<br/>0     |      44532      |      72217<br/>1     |      90195      |      10291<br/>2     |      81410      |      65932<br/>3     |      36721      |      91854<br/>...</span></pre><p id="4883" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，大多数时候，64位数字，例如数据类型<code class="fe mh mi mj mk b">Long</code>的数字，被用作随机数。这降低了以后计算哈希值时发生冲突的风险。</p><h2 id="14fd" class="mz lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">计算哈希值</h2><p id="9551" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在，生成密钥后，可以计算给定棋盘位置的Zobrist散列:</p><blockquote class="nl nm nn"><p id="8c66" class="kg kh no ki b kj kk kl km kn ko kp kq np ks kt ku nq kw kx ky nr la lb lc ld im bi translated">取之前生成的每个游戏角色所在单元格的随机数，并通过<code class="fe mh mi mj mk b">xor</code>操作将它们组合起来。</p></blockquote><p id="cca5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，这比听起来容易。我们来举个例子。</p><p id="ad58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们开始之前，有一个小提示:井字游戏的单元格是这样排序的:从0到8。</p><pre class="ns nt nu nv gt nw mk nx ny aw nz bi"><span id="f9ba" class="mz lf it mk b gy oa ob l oc od">0 1 2 <br/>3 4 5<br/>6 7 8</span></pre><p id="933a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，现在是举例子的时候了。看看下面的棋盘位置:</p><pre class="ns nt nu nv gt nw mk nx ny aw nz bi"><span id="98f1" class="mz lf it mk b gy oa ob l oc od">X . O<br/>X . .<br/>. . .</span><span id="733b" class="mz lf it mk b gy oe ob l oc od">Player 1 (X) in cells: 0, 3<br/>Player 2 (O) in cells: 2</span></pre><p id="1825" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">玩家在以下单元格中进行游戏:</p><ul class=""><li id="dc08" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">玩家1: 0，3</li><li id="c69c" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">玩家2: 2</li></ul><p id="6444" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以计算这个位置的Zobrist散列:我们从上面获取这些单元格的随机数/密钥，并通过<code class="fe mh mi mj mk b">xor</code>操作将它们组合起来。操作的顺序无关紧要:</p><pre class="ns nt nu nv gt nw mk nx ny aw nz bi"><span id="beff" class="mz lf it mk b gy oa ob l oc od">    44532 (cell #0 player 1)<br/>XOR 65932 (cell #2 player 2)<br/>XOR 36721 (cell #3 player 1)<br/>---------<br/>  = 74505 (Zobrist hash)</span></pre><p id="0b7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们成功计算了游戏位置的Zobrist hash:<code class="fe mh mi mj mk b">74505</code>。</p><p id="7055" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这个散列可以用来存储转置表中的电路板位置。在这种情况下，计算出的哈希值被用作密钥。</p><h2 id="335e" class="mz lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">重用哈希</h2><p id="9370" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这个过程的一个巨大的优点是，它不需要在一步棋走完之后计算全新的散列:我们可以获取新棋走完的单元格的关键字，并将其与已经存在的Zobrist散列相结合。</p><p id="ee69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有与上面相同的位置:</p><pre class="ns nt nu nv gt nw mk nx ny aw nz bi"><span id="7c0e" class="mz lf it mk b gy oa ob l oc od">X . O<br/>X . .<br/>. . .</span><span id="e30d" class="mz lf it mk b gy oe ob l oc od">=&gt; 74505 (Zobrist hash)</span></pre><p id="82da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，参与人O在1号单元格中采取行动，尽管这是一个糟糕的行动:</p><pre class="ns nt nu nv gt nw mk nx ny aw nz bi"><span id="012b" class="mz lf it mk b gy oa ob l oc od">X O O<br/>X . .<br/>. . .</span></pre><p id="e3fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们希望为新创建的董事会职位计算Zobrist散列。我们使用旧的散列值<code class="fe mh mi mj mk b">74505</code>，并通过<code class="fe mh mi mj mk b">xor</code>操作将其与新播放的单元格(#1)的密钥再次组合:</p><pre class="ns nt nu nv gt nw mk nx ny aw nz bi"><span id="1f4f" class="mz lf it mk b gy oa ob l oc od">    74505 (old Zobrist hash)<br/>XOR 10291 (cell #1 player 2)<br/>---------<br/>  = 68410 (new Zobrist hash)</span></pre><p id="429e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在走完一步棋后，重新使用旧的散列来计算新的散列，这使得遍历游戏树变得非常有效。</p><p id="6c37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，撤销一个移动也很容易:我们使用新创建的Zobrist hash，并将其与我们想要撤销的单元格的键相结合。让我们从上面撤销1号单元格中参与人2的最后一步棋。</p><pre class="ns nt nu nv gt nw mk nx ny aw nz bi"><span id="cb81" class="mz lf it mk b gy oa ob l oc od">    68410 (new Zobrist hash)<br/>XOR 10291 (cell #1 player 2)<br/>---------<br/>  = 74505 (Zobrist hash after undo last move)<br/></span><span id="54c4" class="mz lf it mk b gy oe ob l oc od">Resulting position:</span><span id="15ab" class="mz lf it mk b gy oe ob l oc od">X . O<br/>X . .<br/>. . .</span></pre><p id="531b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">佐布里斯特杂凑，<code class="fe mh mi mj mk b">74505</code>，等于开始时的杂凑，在参与人2的移动开始之前。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="8ffe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">这篇文章最初发表在我的博客上。看一看。</strong></p><div class="om on gp gr oo op"><a href="https://larswaechter.dev/blog/zobrist-hashing/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">佐布里斯特散列法</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">2020年8月2日Zobrist hashing以其发明者Albert Zobrist的名字命名，是一种表示游戏棋盘的技术…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">拉斯瓦切特.德夫</p></div></div></div></a></div></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="eaee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后但并非最不重要的一个例子是在Kotlin中实现井字游戏:</p><figure class="ns nt nu nv gt ju"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div></div>    
</body>
</html>