<html>
<head>
<title>Java Algorithms: Linked List in Binary Tree (LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java算法:二叉树中的链表(LeetCode)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-algorithms-linked-list-in-binary-tree-leetcode-942daa409b3f?source=collection_archive---------0-----------------------#2022-07-02">https://levelup.gitconnected.com/java-algorithms-linked-list-in-binary-tree-leetcode-942daa409b3f?source=collection_archive---------0-----------------------#2022-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7cfa58a4a010911cfbfc626d61b02a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-Nll-25ZVcp6sHBU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@moritz_photography" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kd">莫里茨·金德勒</strong> </a>在<a class="ae kc" href="https://unsplash.com/s/photos/binary-tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="8715" class="ke kf iq bd kd kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">任务描述:</h2><p id="b729" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">给定一棵二叉树<code class="fe lu lv lw lx b">root</code>和一个以<code class="fe lu lv lw lx b">head</code>为第一个节点的链表。</p><p id="a01f" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">如果链表中从<code class="fe lu lv lw lx b">head</code>开始的所有元素都对应于二叉树中连接的某个<em class="md">向下路径</em>，则返回True，否则返回False。</p><p id="351c" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">在这个上下文中，向下路径意味着从某个节点开始并向下的路径。</p><p id="0771" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated"><strong class="lb ir">例1: </strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/74d2c46f8bc2a3c5bad333b5153444cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*7fkc2LSI6b-K7r7k.png"/></div></figure><pre class="mf mg mh mi gt mj lx mk ml aw mm bi"><span id="aceb" class="ke kf iq lx b gy mn mo l mp mq"><strong class="lx ir">Input:</strong> head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br/><strong class="lx ir">Output:</strong> true<br/><strong class="lx ir">Explanation:</strong> Nodes in blue form a subpath in the binary Tree.</span></pre><p id="8f9c" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated"><strong class="lb ir">例2: </strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/cd2b0e258efdd875dcce75d6d65fee79.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/0*BMS64PbCcFG_8qrY.png"/></div></figure><pre class="mf mg mh mi gt mj lx mk ml aw mm bi"><span id="8b1c" class="ke kf iq lx b gy mn mo l mp mq"><strong class="lx ir">Input:</strong> head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br/><strong class="lx ir">Output:</strong> true</span></pre><p id="3b17" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated"><strong class="lb ir">例3: </strong></p><pre class="mf mg mh mi gt mj lx mk ml aw mm bi"><span id="b6f5" class="ke kf iq lx b gy mn mo l mp mq"><strong class="lx ir">Input:</strong> head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br/><strong class="lx ir">Output:</strong> false<br/><strong class="lx ir">Explanation:</strong> There is no path in the binary tree that contains all the elements of the linked list from <!-- -->head<!-- -->.</span></pre><p id="6182" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated"><strong class="lb ir">约束:</strong></p><ul class=""><li id="19d5" class="ms mt iq lb b lc ly lg lz km mu kq mv ku mw lt mx my mz na bi translated">树中节点的数量将在范围<code class="fe lu lv lw lx b">[1, 2500]</code>内。</li><li id="3722" class="ms mt iq lb b lc nb lg nc km nd kq ne ku nf lt mx my mz na bi translated">列表中的节点数量将在<code class="fe lu lv lw lx b">[1, 100]</code>范围内。</li><li id="4ea3" class="ms mt iq lb b lc nb lg nc km nd kq ne ku nf lt mx my mz na bi translated"><code class="fe lu lv lw lx b">1 &lt;= Node.val &lt;= 100</code>对于链表和二叉树中的每个节点。</li></ul><h2 id="cc19" class="ke kf iq bd kd kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">推理:</h2><p id="1095" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">似乎这个任务迫使我们使用至少两种不同的数据结构，一个二叉树和一个链表。让我们介绍两个简单的类来描述构成二叉树和链表的基本部分。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用于构建LinkedList的ListNode类</figcaption></figure><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用于构建BinaryTree的TreeNode类</figcaption></figure><p id="c017" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">你可能会注意到它们之间的一些相似之处。唯一的区别是TreeNode有一个额外的指针，仅此而已。事实上，您可以使用LinkedLists来表示某些类型的二进制树。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/86eb2ff13aadb385b3ff3790ada94a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*fHmG0Dw0Jym-gBHDJ_SrOQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">可以用LinkedList表示的BinaryTree的第一个示例</figcaption></figure><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/9ea6120b608441b348c1125647b3da9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*bLX8OGHNmTofo5DO4TwQmg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">可以用LinkedList表示的二进制树的第二个示例</figcaption></figure><p id="7869" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">我们来找点乐子，换个“视角”。第二个例子可以做同样的事情。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/970d0a9ac5e7dfa4f47a86805f5035b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*lrPbKs4vabKASm192HmIew.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">第一个向左旋转的示例</figcaption></figure><p id="3cfc" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">让我们回到我们的任务。我们需要找出一个给定的二叉树是否在从任意节点开始的路径中包含一个链表。不要被任务定义吓到，它比你想象的要简单。先说蛮力解法。我们能做的是遍历二叉树的每个节点，并从它开始遍历链表。如果我们遍历二叉树中的每个节点，它将是O(n)——线性时间复杂度。链表中每个节点的迭代也是O(n)。如果对于二叉树的每个节点，我们迭代链表，将得到O(n)-二次时间复杂度。</p><p id="9813" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">听起来是个糟糕的解决方案？让我们看看提供的数字。二叉树的最大节点数是2500。链表中的最大节点数是100。2500 * 100 = 250000为了解决这个问题，我们必须执行的最大操作数。任何现代CPU都可以在不到一秒的时间内处理多达10⁸运算。我们的强力解决方案有2*10⁵.</p><h2 id="5e1d" class="ke kf iq bd kd kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">解决方案:</h2><p id="56da" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">我将使用递归方法来实现这个解决方案，但它也可以通过非递归方法来解决。</p><p id="e771" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">在<strong class="lb ir"> isSubPath </strong>方法中，我们调用递归方法<strong class="lb ir">遍历</strong></p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a76e" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">在遍历函数中，我们检查当前根节点是否为空，结果，我们返回头部是否等于空。如果二叉树中的一个节点的值和链表中的一个节点的值相等，我们可以尝试验证我们是否找到了匹配。为此，我们调用<strong class="lb ir"> findPath </strong>方法。</p><p id="6b23" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">否则，我们继续通过去左边和右边的节点来探索二叉树。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8b64" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">在<strong class="lb ir"> findPath </strong>方法中，我们做了与<strong class="lb ir">遍历</strong>几乎相同的事情。如果头为空，意味着我们到达了链表的末尾，我们返回true。如果根为空，则意味着我们已经浏览了二叉树中的所有节点，无法继续。我们返回false。在所有其他情况下，我们检查二叉树和链表的节点值是否相等。同时我们尝试从二叉树的当前节点探索两条路径，我们尝试去左边的子节点和右边的子节点。任何可用的路径都足以让我们回答主要问题——二叉树包含所提供的链表中的所有节点。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4083" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">完整的解决方案</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="aded" class="pw-post-body-paragraph kz la iq lb b lc ly le lf lg lz li lj km ma ll lm kq mb lo lp ku mc lr ls lt ij bi translated">如前所述，这个解决方案具有二次时间复杂度，但它很好，因为我们知道任务的确切限制。测试系统证明了这一点。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/17f11a93b68a4f5743c6090874a28c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*WJ2LD_hFBw_qV38yOE7_UA.png"/></div></figure></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="abb3" class="nt kf iq bd kd nu nv nw ki nx ny nz kl oa ob oc kp od oe of kt og oh oi kx oj bi translated">分级编码</h1><p id="8aa4" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae kc" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。<br/>跟随:<a class="ae kc" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae kc" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae kc" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="lb ir">升一级正在改造理工大招聘➡️ </strong> <a class="ae kc" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>