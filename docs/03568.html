<html>
<head>
<title>Understanding Express by Implementing it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实施来理解Express</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-express-by-implementing-it-6640109527e2?source=collection_archive---------13-----------------------#2020-05-16">https://levelup.gitconnected.com/understanding-express-by-implementing-it-6640109527e2?source=collection_archive---------13-----------------------#2020-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1c2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Web框架有点神话般的名声。幕后有很多事情会使配置不够直观。但是它们的广泛使用使得理解这种配置成为一种有用的技能，不管你是刚从训练营出来还是已经进入职业生涯多年。所以，为了揭开Express的神秘面纱，让我们实现一个简化版本。我们将从一个简单的命令行处理程序开始。希望我们最终能有可以直接插入Express的功能。</p><p id="aa53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">*关于格式的快速说明。我将引用行号。这些行在存储库中的代码中。我将把片段放在块中，但是那些没有行号。但是希望，它将清楚我将指的是什么线。</p><p id="7ccd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们寻找一个起点。我在github上找到了下面的代码，它概述了一个不错的小CLI循环。<a class="ae ko" href="https://gist.github.com/initlove/2478016#file-zreadline-example-short-js" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/init love/2478016 # file-zreadline-example-short-js</a>提供了一个很好的模板。该代码使用“readline”模块来解析来自命令行的用户输入。有一个小循环一直读到用户取消为止(通过按Ctrl-C)。这个基本循环展示了一些重要的思想:接受输入、基于输入进行处理，以及等待连续输入循环的循环。这些对于命令行界面(CLI)来说是完美的，正如我们将看到的，对于web服务器来说也是完美的。</p><p id="891b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们前进的方向——我们的框架和Express将使用相同的功能:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/64edbe7608fd337d16bff42603f1b2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ormCBoEIYdMINuYhVyxxww.png"/></div></div></figure><p id="cc21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在基础上再增加一点。如果你想继续，继续克隆https://github.com/sweeneyb/implBasicExpres的<a class="ae ko" href="https://github.com/sweeneyb/implBasicExpress/blob/721377c35f4d7c9bf3139d60cbc53a1ae85abcd4" rel="noopener ugc nofollow" target="_blank">并检查提交721377 c 35 f 4d 7 C9 BF 3139d 60 CBC 53 a 1 AE 85 ABCD 4(git check out 721377 c)。</a></p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="6f35" class="lg lh it lc b gy li lj l lk ll">git clone <a class="ae ko" href="https://github.com/sweeneyb/implBasicExpress/blob/721377c35f4d7c9bf3139d60cbc53a1ae85abcd4" rel="noopener ugc nofollow" target="_blank">https://github.com/sweeneyb/implBasicExpres</a>s<br/>cd implBasicExpress<br/>git checkout 721377c</span></pre><p id="a5e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在提交过程中，我们对循环做了一些修改。我们将寻找命令或动作，而不仅仅是寻找特定的文本。这些命令稍后会告诉我们如何处理接收到的输入。我们将使用几个动词——“GET”和“PUT”。如果您熟悉HTTP规范，您会发现这是两个常见的HTTP动词。</p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="67bb" class="lg lh it lc b gy li lj l lk ll">rl.on('line', function(line) {<br/>    var split = line.split(" ")<br/>    switch ( split[0].trim() ) {<br/>        case 'GET':<br/>          console.log( "get ", split[1])<br/>          break;<br/>        case 'PUT':<br/>          console.log( "put", split[1])<br/>          break;<br/>        default:<br/>          console.log("unknown command")<br/>    }<br/>  rl.setPrompt(prefix, prefix.length);<br/>  rl.prompt();<br/>})</span></pre><p id="ed6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们真的不会做太多不同。第9行和第12行(记住行号指的是代码中的行，而不是上面的代码块)用来显示我们的switch语句区分命令。此时运行程序并输入“get foo ”,应该会返回“GET foo”。“put foo”应该返回“PUT foo”和除“GET”或“PUT”之外的任何第一个单词(大小写很重要！)应该会返回“未知命令”。很好，但是没意思。让我们添加一些功能…</p><h1 id="7c3f" class="lm lh it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">但是首先！</h1><p id="a203" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">对代码质量保持警惕是个好主意。一本书的一个片段让我印象深刻，那就是方法只能在“一个层次”上做事情。如果你的代码使用了多个API，那么你最好把它们分开。当前代码正在处理用户输入循环，以相同的方法解析用户输入，并根据输入做出决策。为了便于阅读(也便于将来的扩展，让我们把它分解开来。这将在以后证明是有用的。如果你坚持下去。这个提交将输入处理移动到它自己的方法中。此时，我们可以有效地忘记输入循环代码。完美…不用想太多。</p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="6768" class="lg lh it lc b gy li lj l lk ll">rl.on('line', function(line) {<br/>  doStuff(line)<br/>  rl.setPrompt(prefix, prefix.length);<br/>  rl.prompt();<br/>}).on('close', function() {<br/>  process.exit(0);<br/>});<br/>rl.setPrompt(prefix, prefix.length);<br/>rl.prompt();</span><span id="4a71" class="lg lh it lc b gy mr lj l lk ll">function doStuff(line) {<br/>    var split = line.split(" ")<br/>    switch ( split[0].trim() ) {<br/>        case 'GET':<br/>          console.log( "get ", split[1])<br/>          break;<br/>        case 'PUT':<br/>          console.log( "put", split[1])<br/>          break;<br/>        default:<br/>          console.log("unknown command")<br/>    }<br/>}</span></pre><p id="2a57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们继续重构。<code class="fe mo mp mq lc b">git checkout a32634</code>转移到一个提交，该提交排除了对“get”和“put”命令的处理。这里，我们已经把执行其中一个命令的含义与程序如何知道这个命令被发出的方式分开了。</p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="8c7a" class="lg lh it lc b gy li lj l lk ll">function doStuff(line) {<br/>    var split = line.split(" ")<br/>    switch ( split[0].trim() ) {<br/>        case 'GET':<br/>          doGet(split[1].trim())<br/>          break<br/>        case 'PUT':<br/>          doPut(split[1].trim())<br/>          break<br/>        default:<br/>          console.log("unknown command")<br/>    }<br/>}</span><span id="5811" class="lg lh it lc b gy mr lj l lk ll">function doGet(what) {<br/>    console.log("get", what);<br/>}</span><span id="18e5" class="lg lh it lc b gy mr lj l lk ll">function doPut(what) {<br/>    console.log("put", what)<br/>}</span></pre><p id="e9c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是“框架”和“实现代码”分离的开始。在更大的团队环境中，我们可以将“doPut”和“doGet”功能的实现交给其他开发人员。我们还可以提供不同的方式来调用“doPut”和“goGet”。例如，我们可以让web服务器监听输入并将输入传递给适当的函数(事实上，这正是Express所做的)。</p><p id="5eb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些都很好，但结果仍然是紧密耦合的。输入处理函数代码必须知道在“GET”或“put”输入上调用的函数的名称。如果我们不局限于特定的名字就好了。这正是<code class="fe mo mp mq lc b">git checkout 2afe19ad</code>所做的。</p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="04a3" class="lg lh it lc b gy li lj l lk ll">var handlers = {}</span><span id="786b" class="lg lh it lc b gy mr lj l lk ll">handlers["GET"] = doGet<br/>handlers["PUT"] = doPut</span><span id="70cc" class="lg lh it lc b gy mr lj l lk ll">function doStuff(line) {<br/>    var split = line.split(" ")<br/>    switch ( split[0].trim() ) {<br/>        case 'GET':<br/>          var hanlder = handlers["GET"]<br/>          hanlder(split[1])<br/>          break<br/>        case 'PUT':<br/>          handlers["PUT"](split[1])<br/>          break<br/>        default:<br/>          console.log("unknown command")<br/>    }<br/>}</span><span id="8950" class="lg lh it lc b gy mr lj l lk ll">function doGet(what) {<br/>    console.log("get", what);<br/>}</span><span id="145b" class="lg lh it lc b gy mr lj l lk ll">function doPut(what) {<br/>    console.log("put", what)<br/>}</span></pre><p id="1d61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第15行创建了一个关联数组。命名/实现“doGet”和“doPut”方法的团队将添加第17行和第18行。但是这提出了一个类似于我们刚刚解决的命名问题。现在，编写框架的团队必须知道框架的内部变量名。这实际上限制了框架改变的能力。相反，如果我们可以通过函数来传达意图，那就好了。这提供了更大的灵活性。继续检查<code class="fe mo mp mq lc b">git checkout 3cdff72</code></p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="b624" class="lg lh it lc b gy li lj l lk ll">var handlers = {}</span><span id="5081" class="lg lh it lc b gy mr lj l lk ll">function get( getFn) {<br/>    handlers["GET"] = getFn<br/>}<br/>function put(putFn) {<br/>    handlers["PUT"] = putFn<br/>}</span><span id="10d8" class="lg lh it lc b gy mr lj l lk ll">function doStuff(line) {<br/>    var split = line.split(" ")<br/>    switch ( split[0].trim() ) {<br/>        case 'GET':<br/>          var hanlder = handlers["GET"]<br/>          hanlder(split[1])<br/>          break<br/>        case 'PUT':<br/>          handlers["PUT"](split[1])<br/>          break<br/>        default:<br/>          console.log("unknown command")<br/>    }<br/>}</span><span id="5cfe" class="lg lh it lc b gy mr lj l lk ll">// above this comment is "framework" stuff.  It handles common tasks<br/>// below this comment is configuring the framework &amp; specifying what gets done.</span><span id="39e9" class="lg lh it lc b gy mr lj l lk ll">function doGet(what) {<br/>    console.log("get", what);<br/>}<br/>get(doGet)</span><span id="014e" class="lg lh it lc b gy mr lj l lk ll">// this is starting to look a lot like express<br/>put(function doPut(what) {<br/>    console.log("put", what)<br/>})</span></pre><p id="7d5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第19–24行定义了一些函数，这些函数允许在不暴露内部结构的情况下轻松使用框架。每个函数只接受一个参数:当一个命令作为输入时调用的函数。处理输入的函数放在一个关联数组中，但是实现处理程序的团队没有理由知道这一点。还记得我们之前做的重构吗，一个方法只做一件事？这是另一个地方，代码的结构允许不同的团队处理不同的功能，同时通过API交流他们的期望。</p><p id="b68f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第44–52行是实际的处理程序实现。44–47定义并注册一个函数。第50–52行内联定义和注册。两种风格都有效；你挑吧。在这两种情况下，都没有关于请求如何到来的假设知识。同样，这给了我们很大的灵活性来决定消息是如何进来的。它们可能来自CLI(就像在本例中一样)，来自web框架(我们将在后面看到)，或者来自测试框架(您肯定应该进行测试——我只是不想在这个特定的例子中弄乱存储库)。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="5f45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们当前代码的一个缺点是，它只能支持每种命令类型一个处理程序。到目前为止，这对我们来说是有用的，但是随着我们向与Express的特性对等迈进，我们将希望使“GET”和“PUT”更加有用。GET HTTP动词很简单，因为它获取一个项目。该项通常被称为“路径”通常，行为会根据路径而改变。例如，“获取/简档”和“获取/主页”可以调用非常不同的功能来显示用户简档和主页。所以让我们添加一种基于路径调用不同函数的方法。去吧<code class="fe mo mp mq lc b">git checkout 32005fa.</code></p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="53eb" class="lg lh it lc b gy li lj l lk ll">var handlers = {}<br/>handlers["GET"] = {}<br/>handlers["PUT"] = {}</span><span id="957d" class="lg lh it lc b gy mr lj l lk ll">function get(path, getFn) {<br/>    let paths = handlers["GET"]<br/>    paths[path] = getFn<br/>}</span><span id="ed4b" class="lg lh it lc b gy mr lj l lk ll">function put(path, putFn) {<br/>    handlers["PUT"][path] = putFn<br/>}</span><span id="60b3" class="lg lh it lc b gy mr lj l lk ll">function doStuff(line) {<br/>    var split = line.split(" ")<br/>    switch (split[0].trim()) {<br/>        case 'GET':<br/>            deferRequest("GET", split[1])<br/>            break<br/>        case 'PUT':<br/>            deferRequest("PUT", split[1])<br/>            break<br/>        default:<br/>            console.log("unknown command")<br/>    }<br/>}</span><span id="f693" class="lg lh it lc b gy mr lj l lk ll">function deferRequest(method, path) {<br/>    let paths = handlers[method]<br/>    var handler = paths[path]<br/>    if (handler == undefined) {<br/>        console.log("404 - not found")<br/>    } else {<br/>        handler(path)<br/>    }<br/>}</span></pre><p id="cf9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们看到“get”和“put”函数(第21–28行)有一个额外的路径参数。handler函数通过一对关联数组进行链接，因此只有在为命令/http动词调用特定路径时，才会调用它。注册函数的匹配代码在第64–65和68行。同样,“PUT”被注册为匿名函数，但这与使用命名函数没有任何不同。</p><p id="ec00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还重构了调用处理函数的代码。实际上,“GET”和“PUT”的行为没有区别，所以在第44行添加“deferRequest”方法让我们可以清理一些多余的代码。第54行和第55行将框架中的典型内容与实现代码分开。所以，让我们回顾一下:</p><p id="9957" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有一个从命令行接受用户输入的框架。基于它所得到的，它遵从用户定义的函数并传递给它的路径。这些函数只是打印一个标识位的信息和给出的路径。但是它们都打印到控制台。如果我们要在一个web框架中使用这些功能，那是行不通的。输出将到达控制台，而不是web客户端。我们需要一种封装响应的方式，让框架知道如何发送回响应。我们需要稍微复杂一点的界面。我们来看看<code class="fe mo mp mq lc b">git checkout ca12ffa4</code></p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="40e2" class="lg lh it lc b gy li lj l lk ll">function deferRequest(method, path) {<br/>    let paths = handlers[method]<br/>    var handler = paths[path]<br/>    if (handler == undefined) {<br/>        console.log("404 - not found")<br/>    } else {<br/>        let request = {}<br/>        request.baseUrl = path<br/>        let response = {}<br/>        response.send = function(message) {<br/>            this.message = message<br/>        }<br/>        handler(request, response)<br/>        console.log(response.message, "\n\n")<br/>    }<br/>}</span></pre><p id="711c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“延迟请求”增加了一些功能。它不只是传递一个带有路径的字符串，而是创建一个对象并设置一个“baseUrl”属性。这个属性在Express中有一个模拟，它告诉您浏览器请求的路径(在域之后)。它还创建了一个“响应”对象，并向该对象添加了一个“发送”函数。这让实现函数返回一些框架可以返回给web客户端的对象。框架有很多方法可以选择，但是在我们这个简单的例子中，我们只是返回一个简单的消息。我们的框架将只是读取消息并在控制台上输出它(毕竟，我们还是一个CLI)。</p><p id="2a9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的处理函数(第64–70行和第75–77行)会相应地改变:</p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="4e28" class="lg lh it lc b gy li lj l lk ll">function doRoot(request, response) {<br/>    response.send("get root")<br/>}</span><span id="e315" class="lg lh it lc b gy mr lj l lk ll">function doGet2(request, response) {<br/>    response.send("get2 "+ request.baseUrl);<br/>}<br/>get("/", doRoot)<br/>get("/get2", doGet2)</span><span id="f048" class="lg lh it lc b gy mr lj l lk ll">// this is starting to look a lot like express<br/>put("/", function doPut(request, response) {<br/>    response.send("put "+ request.baseUrl)<br/>})</span></pre><p id="b8c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果他们需要查看给出了什么路径，他们会检查request.baseUrl属性。如果他们需要发送响应，他们通过调用“response.send()”来添加消息。这对于CLI来说有点过了，但我们现在有了一个非常健壮的系统，一个团队可以通过它编写框架来处理用户输入，并将行为委托给另一个团队的开发人员。而实现的另一个团队并不关心他们的代码是在CLI中调用还是从express中调用。为了证明这一点，我们将稍微调整一下，并将其放入一个简单的Express应用程序:<code class="fe mo mp mq lc b">git checkout 3dfaa9e</code></p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="1a7f" class="lg lh it lc b gy li lj l lk ll">const express = require('express')<br/>const app = express()<br/>const port = 3000<br/>app.listen(port)</span><span id="09b1" class="lg lh it lc b gy mr lj l lk ll">...<br/>function doRoot(request, response) {<br/>    response.status(200).send("get root")<br/>}</span><span id="01ec" class="lg lh it lc b gy mr lj l lk ll">function doGet2(request, response) {<br/>    response.status(200).send("get2: " + request.route.path);<br/>}<br/>get("/", doRoot)<br/>get("/get2", doGet2)<br/>app.get('/', doRoot)<br/>app.get("/get2", doGet2)</span><span id="b64f" class="lg lh it lc b gy mr lj l lk ll">// this is starting to look a lot like express<br/>put("/", function doPut(request, response) {<br/>    response.status(200).send("put "+ request.route.path)<br/>})<br/>app.post("/", function doPut(request, response) {<br/>    response.status(200).send("put "+ request.route.path)<br/>})</span></pre><p id="76e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Modern Express将返回代码从消息体中分离出来，因此我们对处理函数进行了调整。请记住，我们还需要调整deferRequest，尽管变化很小:</p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="6e7d" class="lg lh it lc b gy li lj l lk ll">function deferRequest(method, path) {<br/>    let paths = handlers[method]<br/>    var handler = paths[path]<br/>    if (handler == undefined) {<br/>        console.log("404 - not found")<br/>    } else {<br/>        let request = {}<br/>        request.route = {}<br/>        request.route.path = path<br/>        let response = {<br/>            rc: undefined,<br/>            message: undefined,<br/>            status: function(code) {<br/>                console.log("accepting code " +code)<br/>                this.rc = code<br/>                return this<br/>            },<br/>            send: function( message ) {<br/>                this.message = message<br/>            }<br/>        }<br/>        handler(request, response)<br/>        console.log(response.rc, " ", response.message, "\n\n")<br/>    }<br/>}</span></pre><p id="09d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的框架和express的核心区别在于，Express路由器已经封装成模块，所以我们需要在那个模块上调用“get”和“put”，即“app.put( <path>、<function>)”。</function></path></p><p id="fbcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您应该能够从CLI调用处理程序函数:</p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="c598" class="lg lh it lc b gy li lj l lk ll">$node app.js<br/>&gt; GET /get2<br/>accepting code 200<br/>200   get2: /get2</span><span id="8223" class="lg lh it lc b gy mr lj l lk ll">&gt;</span></pre><p id="a8d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者通过HTTP:</p><pre class="kq kr ks kt gt lb lc ld le aw lf bi"><span id="ba6f" class="lg lh it lc b gy li lj l lk ll">$curl -i <a class="ae ko" href="http://localhost:3000/get2" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/get2</a><br/>HTTP/1.1 200 OK<br/>X-Powered-By: Express<br/>Content-Type: text/html; charset=utf-8<br/>Content-Length: 11<br/>Connection: keep-alive</span><span id="40e4" class="lg lh it lc b gy mr lj l lk ll">get2: /get2</span></pre><p id="edad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，很明显，Express的功能比我们构建的要多得多。每条路径仍然只有一个函数。Express允许您调用多个函数并传递请求/响应对象。它理解页面显示的渲染引擎。它具有接收请求和路径参数的强大手段，以提供更大的灵活性。但是希望这能让我们明白Express仍然只是代码的事实，做出一些权衡的一些原因，以及为什么语法是这样的。我坚信，通过了解一些幕后发生的事情，你可以充分利用一个给定的框架。</p></div></div>    
</body>
</html>