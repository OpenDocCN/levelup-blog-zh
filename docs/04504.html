<html>
<head>
<title>UI, Composition and Inversion of Control</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UI，控制的组合和反转</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ui-composition-and-inversion-of-control-d65e04eaddf9?source=collection_archive---------30-----------------------#2020-06-29">https://levelup.gitconnected.com/ui-composition-and-inversion-of-control-d65e04eaddf9?source=collection_archive---------30-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/4327876004d874e9932c3629d5b8abe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gTQADlQyP_hs2GaHNVX2Bw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图:<a class="ae jd" href="https://www.flickr.com/photos/105105658@N03/40266973032/in/photolist-24mfLcJ-9SGsgT-56BHp8-oJrmRq-NWSncE-SZQVz5-4DXCaN-CV292-4tqFJb-2jbqXFF-5onNFP-6LaEqM-9dHrCP-2inDJdd-2jbqXCp-QYemba-66yfJr-5WBXST-fKBDq-4E6dEv-29Q5mD1-fKBSX-e6CAxw-4zrJhK-bomyHo-ed7h8g-6aLwnr-acdDBL-fKBDn-uwPrx-k24um-s2Zia-4rGX72-2gnaUcZ-6c6ZAL-8sA5U1-dKN3G-tjLE-6dW2nh-ca9oWL-tjN9-5Da8Z-eQ8a5-7xzNz1-4USC8j-991Mwh-991MvJ-KsTWg7-qupew-b1s2gg" rel="noopener ugc nofollow" target="_blank">Rob Oo的俄罗斯方块</a></figcaption></figure><div class=""/><p id="5f23" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设计健壮的软件通常需要将复杂的问题分成更小更灵活的部分，然后将它们组合成一个连贯的整体。</p><p id="1644" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将通过一个用web组件构建的、呈现问候消息的示例来了解软件合成的不同方面:著名的“hello world”代码示例。</p><p id="86a8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Web components specification提供了一个低级的API，并没有像流行的UI框架那样在各种抽象层后面隐藏太多的复杂性(这就是为什么您会使用这样的框架),因此这种技术非常适合本教程中的架构概念。<br/>请记住，在本文的上下文中，web组件技术只是一种理解这些概念本质的工具，并不强制要求您具备该技术的先验知识。</p><p id="2ba3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们先来看看下面的两个函数</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d738" class="lk ll jg lg b gy lm ln l lo lp">const filterEvenNumbers = (numbers) =&gt; {<br/>    const output = [];<br/>    for (const number of numbers) {<br/>        if (number % 2 === 0) {<br/>            output.push(number);<br/>        }<br/>    }<br/>    return output;<br/>};</span><span id="f48f" class="lk ll jg lg b gy lq ln l lo lp">const filterStringsWithE = (strings) =&gt; {<br/>    const output = [];<br/>    for (const string of strings) {<br/>        if (string.includes('e')) {<br/>            output.push(string);<br/>        }<br/>    }<br/>    return output;<br/>};</span></pre><p id="65ff" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两者的工作方式相似，但仍有很大不同，并且依赖于完全不同的假设:一个对数字进行操作，而另一个对字符串进行操作。它们都遵循一种<em class="lr">命令式</em>风格，你可以很容易地理解为一系列基本指令。</p><p id="76c6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管它们完成了工作，但您很快会发现它们并不十分灵活，因为它们将与数据结构和条件检查上的迭代相关的代码混合在一起。它阻止我们在两个功能之间共享任何逻辑。然而，我们可以很快让出现一个模式，特别是如果我们把它们改写成这样:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2598" class="lk ll jg lg b gy lm ln l lo lp">const filterEvenNumbers = (numbers) =&gt; {<br/>    const output = [];<br/>    const predicate = (number) =&gt; number % 2 === 0;<br/>    for (const number of numbers) {<br/>        if (predicate(number)) {<br/>            output.push(number);<br/>        }<br/>    }<br/>    return output;<br/>};<br/><br/>const filterStringsWithE = (strings) =&gt; {<br/>    const output = [];<br/>    const predicate = (string) =&gt; string.includes('e');<br/>    for (const string of strings) {<br/>        if (predicate(string)) {<br/>            output.push(string);<br/>        }<br/>    }<br/>    return output;<br/>};</span></pre><p id="d7fc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以将一个<em class="lr">模板</em>绘制成一个过滤操作符:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e93a" class="lk ll jg lg b gy lm ln l lo lp">const filter = (predicate) =&gt; (items) =&gt; {<br/>    const output = [];<br/>    for (const item of items) {<br/>        if (predicate(item)) {<br/>            output.push(item);<br/>        }<br/>    }<br/>    return output;<br/>};</span></pre><p id="3130" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并编写我们的两个函数</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4e86" class="lk ll jg lg b gy lm ln l lo lp">const <strong class="lg jh"><em class="lr">filterEvenNumbers </em></strong>= filter((number) =&gt; number % 2 === 0);<br/>const <strong class="lg jh"><em class="lr">filterStringsWithE </em></strong>= filter((string) =&gt; string.includes('e'));</span></pre><p id="75e6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的谓词变得完全独立于使用它们的上下文，而过滤操作符不需要对它将操作的数据结构的性质做任何假设(除了它们需要实现迭代器协议之外)。不知何故，我们可以把过滤操作符看作是一个有漏洞的过程，需要由调用者来填补。</p><p id="7f44" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个原则通常被称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank">控制反转</a>，并且是许多设计模式的基础，例如<a class="ae jd" href="https://en.wikipedia.org/wiki/Template_method_pattern" rel="noopener ugc nofollow" target="_blank">模板方法</a>、<a class="ae jd" href="https://en.wikipedia.org/wiki/Plug-in_(computing)" rel="noopener ugc nofollow" target="_blank">插件</a>、<a class="ae jd" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>等</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="2f01" class="lk ll jg bd lz ma mb dn mc md me dp mf ko mg mh mi ks mj mk ml kw mm mn mo mp bi translated">用户界面、数据获取和责任</h2><p id="6c55" class="pw-post-body-paragraph kd ke jg kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">现在让我们考虑以下web组件:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a7f6" class="lk ll jg lg b gy lm ln l lo lp">// component.js<br/>import {createService} from './service.js';<br/><br/>export class Greetings extends <strong class="lg jh"><em class="lr">HTMLElement </em></strong>{<br/>    <br/>    static get <em class="lr">observedAttributes</em>() {<br/>        return ['name'];<br/>    }<br/>    <br/>    get name() {<br/>        return this.getAttribute('name');<br/>    }<br/>    <br/>    set name(val) {<br/>        this.setAttribute('name', val);<br/>    }<br/>    <br/>    attributeChangedCallback() {<br/>        this._render();<br/>    }<br/>    <br/>    constructor() {<br/>        super();<br/>        this._fetch = createService();<br/>    }<br/>    <br/>    async _render() {<br/>        this.textContent = await this._fetch(this.name);<br/>    }<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="49cf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于不了解web组件的读者:<br/>web组件规范迫使我们通过扩展常规的<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement" rel="noopener ugc nofollow" target="_blank"> HTMLElement类</a>来声明组件。借助静态getter<em class="lr">observed attributes</em>，我们可以定义希望浏览器为我们监视哪些HTML属性；以及当它们的值由于<em class="lr"> attributeChangedCallback而改变时该做什么(</em>这相当于在许多UI框架<em class="lr">中可以找到的<em class="lr"> reactivity/watch </em>机制)。</em>在我们的例子中，我们调用一个定制的渲染函数，它依赖于组件在其构造函数中创建的数据获取服务。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="b835" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的服务实现是一个细节，但是您可以想象类似于</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9aa6" class="lk ll jg lg b gy lm ln l lo lp">// service.js<br/>export const createService = (opts = {}) =&gt; async (name) =&gt; `Hello ${name || 'Mr. Nobody'}`;</span></pre><p id="2cf9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(一个基本的异步函数，它将一个字符串作为参数，并返回一个格式化的问候消息)。</p><p id="132b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了声明式API(通过HTML属性)，我们还通过属性访问器(“name”)提供了编程式API。</p><p id="6b05" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们不能自己调用构造函数(它将抛出一个错误)，必须通过将我们的自定义元素注册到一个全局注册表(这是规范的一部分)来将这个操作委托给浏览器:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1903" class="lk ll jg lg b gy lm ln l lo lp">// injector.js<br/>export const define = (tag, klass) =&gt; <strong class="lg jh"><em class="lr">customElements</em></strong>.define(tag, klass);</span></pre><p id="7f18" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将允许浏览器简单地通过解析HTML文档中的标签来创建我们的定制组件的实例，或者作为任何常规的HTML元素，通过调用<em class="lr">document . createelement(tag)</em>。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5c3e" class="lk ll jg lg b gy lm ln l lo lp">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;!-- ... -&gt;<br/>&lt;body&gt;<br/>&lt;app-greetings name="lorenzofox"&gt;&lt;/app-greetings&gt;<br/>&lt;script type="module"&gt;<br/>    import {define} from './injector.js';<br/>    import {Greetings} from './component.js';<br/>    define('app-greetings', Greetings);<br/>&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="dd28" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过更改<em class="lr"> name </em>属性或使用提供的开发工具环境，在下面的<a class="ae jd" href="https://codesandbox.io/s/unruffled-flower-k8kmo?file=/index.html" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>中进行试验。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="68e7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管这个例子工作得很好，但它远非完美:我们的组件实现与给定的fetch服务紧密耦合。例如，如果您希望隔离测试组件，这可能会很困难:服务可能需要进行一些网络调用，等等。为了抽象出服务实现，你需要<em class="lr">劫持</em>导入(用服务工作者、代理等)来提供模拟或类似的东西。<a class="ae jd" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>允许你通过全局模仿来做到这一点，但在我看来这是一种反模式，只是一种隐藏了你软件中更深层次问题的黑客行为。</p><p id="ee21" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编写测试本身并不是目的，但是如果你在测试你的一部分代码时遇到一些困难，这可能是一种<a class="ae jd" href="https://en.wikipedia.org/wiki/Code_smell" rel="noopener ugc nofollow" target="_blank">代码味道</a>，你的不同组件紧密耦合在一起。</p><p id="12ac" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设需求已经改变，我们希望根据查询字符串参数显示不同的本地化消息。我们现在有各种服务:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d458" class="lk ll jg lg b gy lm ln l lo lp">// en.js<br/>export const createService = (opts = {}) =&gt; async (name) =&gt; `Hello ${name}`;</span><span id="e8aa" class="lk ll jg lg b gy lq ln l lo lp">// fr.js<br/>export const createService = (opts = {}) =&gt; async (name) =&gt; `Bonjour ${name}`;</span><span id="0264" class="lk ll jg lg b gy lq ln l lo lp">// es.js<br/>export const createService = (opts = {}) =&gt; async (name) =&gt; `Hola ${name}`;</span><span id="9729" class="lk ll jg lg b gy lq ln l lo lp">etc;</span></pre><p id="f87e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最糟糕的情况可能是开发人员匆忙“解决”问题:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9ed6" class="lk ll jg lg b gy lm ln l lo lp">export class Greetings extends <strong class="lg jh"><em class="lr">HTMLElement </em></strong>{<br/> // ... <br/>    constructor() {<br/>        super();<br/>        const query = <strong class="lg jh"><em class="lr">window</em></strong>.location.search;<br/>        const lang = new <strong class="lg jh"><em class="lr">URLSearchParams</em></strong>(query).get('lang');<br/>        switch (lang) {<br/>            case 'fr':<br/>                this._fetch = createFrService();<br/>                break;<br/>            case 'es':<br/>                this._fetch = createEsService();<br/>                break;<br/>            default:<br/>                this._fetch = createEnService();<br/>        }<br/>    }<br/>// ... <br/>}</span></pre><p id="a71b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们的组件被耦合到几个实现和全局对象。构造函数带有相当多的逻辑，几乎不可能测试。我们可以通过为我们的服务引入一个间接点来改进代码库:一个函数(<em class="lr"> createService </em>)根据一些参数返回正确的服务。但是，如果现在我们希望基于用户设置而不是查询参数来选择服务，那该怎么办呢？同样，这将要求我们更改组件代码。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="7b35" class="lk ll jg bd lz ma mb dn mc md me dp mf ko mg mh mi ks mj mk ml kw mm mn mo mp bi translated">注入依赖性</h2><p id="493a" class="pw-post-body-paragraph kd ke jg kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">理想情况下，我们不希望组件(属于某种表示层)承担创建/配置服务的责任，这可能依赖于组件上下文之外的许多参数…并且无论如何属于某种业务层。</p><p id="38c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们不能调用web组件的构造函数并依赖浏览器来创建组件的实例，这听起来很有挑战性，但事实并非如此。首先，我们仍然可以使用默认参数编写我们的构造函数来解决这个问题:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="fe05" class="lk ll jg lg b gy lm ln l lo lp">import {createService} from './service.js';<br/><br/>export class Greetings extends <strong class="lg jh"><em class="lr">HTMLElement </em></strong>{<br/>    //...<br/>    constructor(service = createService()) {<br/>        super();<br/>        this._fetch = service;<br/>    }<br/>    //...<br/>}</span></pre><p id="6c71" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做的原因是，引擎会将传递的服务解析为<em class="lr"> createService </em>函数的结果:我们已经将创建数据获取服务的逻辑移出了组件。</p><p id="4f55" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更好的是:如果我们稍微修改一下将组件注册到全局注册表中的代码，我们就可以传递任何服务:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2455" class="lk ll jg lg b gy lm ln l lo lp">// injector.js<br/>import {createEnService, createEsService, createFrService} from './service.js';<br/><br/><br/>const resolveService = () =&gt; {<br/>    const search = <strong class="lg jh"><em class="lr">window</em></strong>.location.search;<br/>    const lang = new <strong class="lg jh"><em class="lr">URLSearchParams</em></strong>(search).get('lang');<br/>    switch (lang) {<br/>        case 'fr':<br/>            return createFrService();<br/>        case 'es':<br/>            return createEsService();<br/>        default:<br/>            return createEnService();<br/>    }<br/>}<br/><br/><br/>export const define = (tag, klass) =&gt; {<br/>    const service = resolveService();<br/>    <strong class="lg jh"><em class="lr">customElements</em></strong>.define(tag, class extends klass{<br/>        constructor() {<br/>            super(service);<br/>        }<br/>    });<br/>};</span></pre><p id="438c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们修饰了常规的<em class="lr"> customElements.define </em>函数来传递一个组件，该组件在我们的组件中注入了依赖关系。现在组件完全独立于任何上下文，所以服务也是。如果需求发生变化，我们唯一需要修改的部分是<em class="lr"> resolveService </em>函数！依赖关系代码的注入是唯一负责以“全知”方式解析适当实例的代码。</p><p id="3f3c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里看到完整的<a class="ae jd" href="https://codesandbox.io/s/unruffled-volhard-52bvv?file=/src/injector.js" rel="noopener ugc nofollow" target="_blank">代码</a></p><h2 id="8385" class="lk ll jg bd lz ma mb dn mc md me dp mf ko mg mh mi ks mj mk ml kw mm mn mo mp bi translated">测试组件</h2><p id="74e9" class="pw-post-body-paragraph kd ke jg kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我们现在可以轻松地将服务的任何实现(包括模仿)传递给组件，并完全隔离地测试它，而不是依赖于全局模仿攻击:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="49fd" class="lk ll jg lg b gy lm ln l lo lp">import stub from 'sbuts';<br/>import {<strong class="lg jh"><em class="lr">test</em></strong>} from 'zora';<br/>import {flush, mountComponent} from './utils.js';<br/>import {Greetings} from '../component.js';<br/><br/><strong class="lg jh"><em class="lr">test</em></strong>(`when component is mounted, it should not render anything if no name attribute is set`, async t =&gt; {<br/>    // given<br/>    const service = stub().resolve(`hello world`);<br/>    <br/>    // do<br/>    const comp = mountComponent(Greetings, service);<br/>    await flush();<br/>    <br/>    // expect<br/>    t.eq(comp.textContent, '');<br/>    t.notOk(service.called);<br/>});<br/><br/><strong class="lg jh"><em class="lr">test</em></strong>(`when component is mounted, it should render the service message when the name attribute changes`, async t =&gt; {<br/>    // given<br/>    const service = stub().resolve(`hello world`);<br/>    const attributeValue = 'lorenzofox';<br/>    const comp = mountComponent(Greetings, service);<br/>    <br/>    // do<br/>    comp.setAttribute('name', attributeValue)<br/>    await flush();<br/>    <br/>    // expect<br/>    t.eq(comp.textContent, 'hello world');<br/>    t.eq(service.calls, [[attributeValue]], `service should have been called once with ${attributeValue}`);<br/>});</span></pre><p id="78a9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了记录:mountComponent是一个测试工具函数，它基本上做我们的应用程序中的注入器所做的事情，而flush用于确保在我们做出断言之前任何未完成的承诺都被清空。<br/>如果你想了解详情，可以看看下面的 <a class="ae jd" href="https://codesandbox.io/s/inspiring-euler-zyoyh?file=/test/runner.html" rel="noopener ugc nofollow" target="_blank"> <em class="lr">代码沙箱</em> </a> <em class="lr">。</em></p><p id="51ea" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个好的测试吗？</p><p id="7460" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是…也不是。这是一个很好的<strong class="kf jh">单元</strong>测试，因为它完全隔离地测试组件代码，抽象出服务代码，并确保无论服务实现是什么，都用正确的参数调用。但是，如果出于某种原因，您必须更改给定服务实现的接口</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e5fb" class="lk ll jg lg b gy lm ln l lo lp">// from<br/>export const createServiceA = (opts) =&gt; async (name) =&gt; `hello ${name}` </span><span id="ca2b" class="lk ll jg lg b gy lq ln l lo lp">// to<br/>export const createServiceA = (opts) =&gt; async ({name}) =&gt; `hello ${name}`;</span></pre><p id="0471" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管您的应用程序被破坏了，您的测试将继续通过:测试没有捕捉到回归。但毕竟，捕捉依赖关系<strong class="kf jh">接口</strong>中的变化不是它的责任，因为它意味着只测试与web组件相关的代码单元。<br/>要点是:当你想要松耦合和引入依赖注入之类的模式时，你必须通过<strong class="kf jh">接口</strong>和<strong class="kf jh">抽象</strong>类型连接不同的部分。在Javascript中，由于接口的概念不是内置的，所以不太明显，但是如果你在它上面添加一个类型系统(如Typescript ),你的代码将无法编译，回归将被捕获。</p><p id="ac1a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，注射器的作用是修复这种差异。例如，您可以使用一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Adapter_pattern" rel="noopener ugc nofollow" target="_blank">适配器</a>:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1e66" class="lk ll jg lg b gy lm ln l lo lp">const adapter = (fetch) =&gt; (name) =&gt; fetch({name});<br/><br/>const resolveService = () =&gt; {<br/>    const lang = new <strong class="lg jh"><em class="lr">URLSearchParams</em></strong>(<strong class="lg jh"><em class="lr">window</em></strong>.location.search);<br/>    switch (lang) {<br/>        case 'fr':<br/>            // the service with a different interface<br/>            return adapter(createFrService());<br/>        case 'es':<br/>            return createEsService();<br/>        default:<br/>            return createEnService();<br/>    }<br/>};</span></pre><p id="7913" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，不需要更改组件代码或服务代码:注射器将点连接在一起！</p><h2 id="fb60" class="lk ll jg bd lz ma mb dn mc md me dp mf ko mg mh mi ks mj mk ml kw mm mn mo mp bi translated">结论</h2><p id="f625" class="pw-post-body-paragraph kd ke jg kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">通过这个基本的例子，我们已经看到了一组架构模式如何帮助创建一个健壮而灵活的软件，而不需要触及许多代码分支(if … else …等):我们通过<strong class="kf jh">组合</strong>来解决问题。</p></div></div>    
</body>
</html>