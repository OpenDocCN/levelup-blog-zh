<html>
<head>
<title>How to Provide Helpful Errors in Bash Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Bash脚本中提供有用的错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/helpful-errors-in-bash-scripts-c1e3c2c50bf8?source=collection_archive---------1-----------------------#2019-08-16">https://levelup.gitconnected.com/helpful-errors-in-bash-scripts-c1e3c2c50bf8?source=collection_archive---------1-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/87f0287bedc69be0be45032d63dc8358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hrGaO-FISO8fRJhV"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一个有益的错误，没有有益的错误(图片由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@specphotops?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">specphops</a>拍摄)</figcaption></figure><p id="609f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我之前的帖子中，我写了关于<a class="ae kf" href="https://medium.com/@timothyjones_88921/top-tips-for-writing-unsurprising-bash-scripts-9b9f4f0cc30e" rel="noopener">编写不出意料的bash脚本</a>。最后一条准则是不要编写复杂的程序——尽量使用不超过一两个函数，并尽可能少使用分支逻辑。像所有的准则一样，有时它们注定要被打破。</p><p id="3ce6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">错误处理是我最常违反这条准则的地方。这篇文章是关于为什么，我想推荐一些新的指导方针。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi le"><img src="../Images/b40af10e8ad0f1580dd1f0780e4f65fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8WDAstWaOeI_ieufSuF_yg.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">巴博萨船长也有一些关于指导方针的规定</figcaption></figure><p id="0029" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您的脚本因为一个未定义的变量而失败，那就不太好了:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8002" class="lo lp it lk b gy lq lr l ls lt">$ ./test.sh<br/>./test.sh: line 3: SOME_FILENAME: unbound variable</span></pre><p id="f64c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为脚本的用户，这不是一个令人愉快的界面。如果脚本打印出有用的错误就更好了。类似于:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="b054" class="lo lp it lk b gy lq lr l ls lt">$ ./test.sh<br/>Error: The required environment variable SOME_FILENAME is empty<br/>  - set this to the file under test</span></pre><p id="94b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理想情况下，难看的错误只发生在脚本有问题的时候。我们希望给脚本的未来用户最好的机会来正确运行它。</p><blockquote class="lu"><p id="650f" class="lv lw it bd lx ly lz ma mb mc md ld dk translated">理想情况下，难看的错误只发生在脚本有问题的时候。</p></blockquote><p id="690d" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">Bash脚本通常带有关于参数和环境的假设。如果这些假设不满足，我们希望脚本能很好地出错。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/023fb1061abcb50057eaca85c1598c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qBMiAf4NY-HfScil"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这个错误假设路径在哪里是显而易见的(照片由<a class="ae kf" href="https://unsplash.com/@2mduffel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mark Duffel </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</figcaption></figure><h1 id="bd53" class="mk lp it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">如何编写好的错误检查</h1><p id="63a2" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">在脚本中编写理智防护打破了“不要分支太多”的准则。但是，也可以使用其他一些准则来代替:</p><ul class=""><li id="61ba" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">在执行任何事情之前，首先检查你的前提条件</li><li id="5d91" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">不满足前提条件时，立即退出脚本</li><li id="fe02" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">尽量不要嵌套错误检查</li></ul><p id="7242" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将进一步阐述基本原理，然后以一些常见检查的代码示例结束。</p><h2 id="3466" class="lo lp it bd ml oa ob dn mp oc od dp mt kr oe of mx kv og oh nb kz oi oj nf ok bi translated">首先检查先决条件，如果不满足就失败</h2><p id="0380" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">前提条件是设置环境变量(具有有效的内容)，以及所需的二进制文件存在。</p><p id="14dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的前两个要点是相关的——如果我们在任何执行之前进行前提条件检查，并且如果前提条件没有得到满足就立即使脚本失败，那么脚本执行就不会在中途失败。要么执行脚本，要么不执行任何工作负载(前提条件检查除外)。</p><p id="549a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很重要，因为它有助于未来的用户(以及脚本作者)思考发生了什么。原子脚本执行意味着没有人需要考虑如何回滚或清理部分脚本执行。</p><h2 id="f826" class="lo lp it bd ml oa ob dn mp oc od dp mt kr oe of mx kv og oh nb kz oi oj nf ok bi translated">尽量不要嵌套错误检查</h2><p id="7643" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">我们这样做是为了使代码仍然可读，即使它有几个分支。如果每个检查都以一个<code class="fe ol om on lk b">exit 1</code>结束，那么脚本中只有一条“快乐的路径”,这有助于提高可读性。</p><p id="bea9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顶层错误检查的另一个优点是它们必须保持简单。保持它们的简单能让未来的读者通过快速浏览来发现关于环境的假设。</p><h1 id="7e23" class="mk lp it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">一些代码示例</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/b63cd315e5bc276c4710aa4dcf59da4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lV_lzYwlFl-RB6X9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我不知道这个人是谁，但我支持他的信息(照片由<a class="ae kf" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">希泰什·乔杜里</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</figcaption></figure><p id="be26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述指南不要求您使用任何特定的代码。然而，有两个可重用的函数可以检查两个常见的前提条件:必需的环境变量和必需的二进制文件。</p><h2 id="a174" class="lo lp it bd ml oa ob dn mp oc od dp mt kr oe of mx kv og oh nb kz oi oj nf ok bi translated">需要环境变量</h2><p id="4e43" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">下面是我用来检查环境变量是否存在的方法:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="ab7c" class="lo lp it lk b gy lq lr l ls lt"># Check to see that a required environment variable is set.  <br/># Use it without the $, as in:<br/>#   require_env_var VARIABLE_NAME  <br/># or   <br/>#   require_env_var VARIABLE_NAME "Some description of the variable"</span><span id="991f" class="lo lp it lk b gy op lr l ls lt">function require_env_var {<br/>  var_name="${1:-}"<br/>  if [ -z "${!var_name:-}" ]; then<br/>    echo "[X] The required env variable ${var_name} is empty"<br/>    if [ ! -z "${2:-}" ]; then        <br/>       echo "  - $2"     <br/>    fi<br/>    exit 1<br/>  fi<br/>}</span></pre><p id="2cbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数有两个参数，一个是变量名，另一个(可选)是要打印的有用的用法字符串。你可以这样使用它:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="842b" class="lo lp it lk b gy lq lr l ls lt">require_env_var SOME_VARIABLE</span><span id="26dd" class="lo lp it lk b gy op lr l ls lt"># or</span><span id="cc9c" class="lo lp it lk b gy op lr l ls lt">require_env_var SOME_VARIABLE "set this to the file under test"</span></pre><h2 id="30a5" class="lo lp it bd ml oa ob dn mp oc od dp mt kr oe of mx kv og oh nb kz oi oj nf ok bi translated">需要二进制文件</h2><p id="092d" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">下面是我用来检查所需的二进制文件是否存在的方法:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="0192" class="lo lp it lk b gy lq lr l ls lt"># Check to see that we have a required binary on the path<br/>function require_binary {<br/>  if [ -z "${1:-}" ]; then<br/>    echo "${FUNCNAME[0]} requires an argument"<br/>    exit 1<br/>  fi</span><span id="a123" class="lo lp it lk b gy op lr l ls lt">  if ! [ -x "$(command -v "$1")" ]; then<br/>    echo "The required executable '$1' is not on the path."<br/>    exit 1<br/>  fi<br/>}</span></pre><p id="4fad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，你可以这样使用它:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="4e8f" class="lo lp it lk b gy lq lr l ls lt">require_binary git<br/>require_binary npm<br/>require_binary grep</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/d1daae5e92d25fc131725d8ab2af07f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pulog1k_wyjpa6Ds"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">好吧，我跟你说实话。这只是为了打破文本(图片由<a class="ae kf" href="https://unsplash.com/@morgasetrakand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alex Grodkiewicz </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</figcaption></figure><h2 id="6945" class="lo lp it bd ml oa ob dn mp oc od dp mt kr oe of mx kv og oh nb kz oi oj nf ok bi translated">包括这些功能</h2><p id="0398" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">假设您有几个想要使用这些函数的脚本。我已经把它们放在一个要点中，你可以直接放入你的项目中。您可以像这样包含它:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2a7c" class="lo lp it lk b gy lq lr l ls lt">#!/bin/bash -eu</span><span id="52d0" class="lo lp it lk b gy op lr l ls lt"># Figure out where the script is running<br/>__SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)" </span><span id="e46e" class="lo lp it lk b gy op lr l ls lt"># Include the robust-bash functions<br/>. "$__SCRIPT_DIR"/lib/robust-bash.sh</span><span id="5683" class="lo lp it lk b gy op lr l ls lt"># Make sure the user has grep</span><span id="64c8" class="lo lp it lk b gy op lr l ls lt">require_binary grep</span><span id="0eb6" class="lo lp it lk b gy op lr l ls lt"># Make sure the environment variables are set correctly</span><span id="0ffc" class="lo lp it lk b gy op lr l ls lt">require_env_var SOME_FILENAME "set this to the file under test"</span></pre><p id="22eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面包含了一个bash样板文件:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="707d" class="lo lp it lk b gy lq lr l ls lt">__SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)"</span></pre><p id="2581" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这指出了脚本运行的位置，除非通过符号链接调用(如果您需要处理通过符号链接调用的脚本，请参见<a class="ae kf" href="https://gist.github.com/TheMengzor/968e5ea87e99d9c41782" rel="noopener ugc nofollow" target="_blank">这个极好的要点</a>)。</p><h2 id="84a5" class="lo lp it bd ml oa ob dn mp oc od dp mt kr oe of mx kv og oh nb kz oi oj nf ok bi translated">摘要</h2><p id="ac7f" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">帮助您从编写良好的bash脚本中打印出有用的错误消息的一些准则是:</p><ul class=""><li id="1564" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">在执行任何事情之前，首先检查你的前提条件</li><li id="31bf" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">不满足前提条件时，立即退出脚本</li><li id="f1cd" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">尽量不要嵌套错误检查</li></ul><p id="9bae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您的脚本在没有达到预期时打印出有用的错误消息，那么用户会更高兴(并且不会浪费太多时间去判断您的脚本是否有错误)。在我看来，为了给用户带来愉快的健康检查和错误消息，增加脚本的复杂性(一点点)是值得的。</p></div></div>    
</body>
</html>