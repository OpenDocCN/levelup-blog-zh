<html>
<head>
<title>JavaScript Clean Code — SOLID</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码——可靠</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-solid-9d135f824180?source=collection_archive---------0-----------------------#2020-03-12">https://levelup.gitconnected.com/javascript-clean-code-solid-9d135f824180?source=collection_archive---------0-----------------------#2020-03-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/966c5e3290e6a4f9a82cb9168ed57243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hmj1KkuyTcuhCMR9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">阿什温·瓦斯瓦尼在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="064c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何其他编程语言一样，JavaScript也遵循SOLID中概述的原则。</p><p id="5480" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SOLID由5个概念组成，我们可以用它们来改进我们的程序。它们是:</p><ul class=""><li id="bb13" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">单一责任原则</li><li id="b304" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">开放/封闭原则</li><li id="9de3" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">利斯科夫替代原理</li><li id="d33d" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">界面分离原理</li><li id="96aa" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">从属倒置原则</li></ul><p id="0b68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将逐一查看，并了解如何将它们应用到JavaScript程序中。</p><h1 id="3a04" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">单一责任原则</h1><p id="0637" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">单一责任原则说我们的每个类只能用于一个目的。</p><p id="ae8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要这样做，这样当有变化时，我们就不必频繁地修改代码。如果这个类在做很多事情，也很难理解它在做什么。</p><p id="34b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同一类中不相关的概念也使得理解代码的目的更加困难。</p><p id="08ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写如下内容来遵循单一责任原则:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ecb2" class="ne lt it na b gy nf ng l nh ni">class Rectangle {<br/>  constructor(length, width) {<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="91da" class="ne lt it na b gy nj ng l nh ni">  get area() {<br/>    return this.length * this.width;<br/>  }<br/>}</span></pre><p id="3088" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的<code class="fe nk nl nm na b">Rectangle</code>类只有矩形的<code class="fe nk nl nm na b">length</code>和<code class="fe nk nl nm na b">width</code>作为成员，并让我们从中获取面积。</p><p id="8b98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它不做其他事情，所以它遵循单一责任原则。</p><p id="126b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个不好的例子是:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9882" class="ne lt it na b gy nf ng l nh ni">class Rectangle {<br/>  constructor(length, width) {<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="14df" class="ne lt it na b gy nj ng l nh ni">  get area() {<br/>    return this.length * this.width;<br/>  }</span><span id="54d5" class="ne lt it na b gy nj ng l nh ni">  createCircle() {</span><span id="8f27" class="ne lt it na b gy nj ng l nh ni">  }<br/>}</span></pre><p id="ee44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该在一个<code class="fe nk nl nm na b">Rectangle</code>类中有一个<code class="fe nk nl nm na b">createCircle</code>方法，因为它们是不相关的概念。</p><h1 id="dfaf" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">开/关原则</h1><p id="6a69" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">开放/封闭原则表明，一个软件可以扩展，但不能修改。</p><p id="1a53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们应该能够在不改变现有代码的情况下添加更多的功能。</p><p id="7a07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有下面的<code class="fe nk nl nm na b">Rectangle</code>类:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a9af" class="ne lt it na b gy nf ng l nh ni">class Rectangle {<br/>  constructor(length, width) {<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="96bf" class="ne lt it na b gy nj ng l nh ni">  get area() {<br/>    return this.length * this.width;<br/>  }<br/>}</span></pre><p id="7395" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们想添加一个函数来计算它的周长，我们可以通过添加一个方法来完成，如下所示:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cc40" class="ne lt it na b gy nf ng l nh ni">class Rectangle {<br/>  constructor(length, width) {<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="071a" class="ne lt it na b gy nj ng l nh ni">  get area() {<br/>    return this.length * this.width;<br/>  }</span><span id="68cc" class="ne lt it na b gy nj ng l nh ni">  get perimteter() {<br/>    return 2 * (this.length + this.width);<br/>  }<br/>}</span></pre><p id="dc69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们不必改变现有的代码来添加它，这满足了开放/封闭原则。</p><h1 id="deef" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">利斯科夫替代原理</h1><p id="bccf" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">这个原则表明，如果我们有一个父类和一个子类，那么我们可以交换父类和子类，而不会得到不正确的结果。</p><p id="2589" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着子类必须实现父类中的所有东西。父类服务于具有基类成员的类，子类从基类扩展。</p><p id="f969" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想为一堆形状实现类，我们可以有一个父类<code class="fe nk nl nm na b">Shape</code>，它通过实现<code class="fe nk nl nm na b">Shape</code>类中的所有东西被所有类扩展。</p><p id="f529" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以编写以下代码来实现一些shape类，并获得每个实例的面积:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fe2d" class="ne lt it na b gy nf ng l nh ni">class Shape {<br/>  get area() {<br/>    return 0;<br/>  }<br/>}</span><span id="6c5c" class="ne lt it na b gy nj ng l nh ni">class Rectangle extends Shape {<br/>  constructor(length, width) {<br/>    super();<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="72c1" class="ne lt it na b gy nj ng l nh ni">  get area() {<br/>    return this.length * this.width;<br/>  }<br/>}</span><span id="8b7c" class="ne lt it na b gy nj ng l nh ni">class Square extends Shape {<br/>  constructor(length) {<br/>    super();<br/>    this.length = length;<br/>  }</span><span id="82d3" class="ne lt it na b gy nj ng l nh ni">  get area() {<br/>    return this.length ** 2;<br/>  }<br/>}</span><span id="a982" class="ne lt it na b gy nj ng l nh ni">class Circle extends Shape {<br/>  constructor(radius) {<br/>    super();<br/>    this.radius = radius;<br/>  }</span><span id="223a" class="ne lt it na b gy nj ng l nh ni">  get area() {<br/>    return Math.PI * (this.radius ** 2);<br/>  }<br/>}</span><span id="e8d9" class="ne lt it na b gy nj ng l nh ni">const shapes = [<br/>  new Rectangle(1, 2),<br/>  new Square(1, 2),<br/>  new Circle(2),<br/>]</span><span id="d434" class="ne lt it na b gy nj ng l nh ni">for (let s of shapes) {<br/>  console.log(s.area);<br/>}</span></pre><p id="35b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们在每个扩展了<code class="fe nk nl nm na b">Shape</code>的类中覆盖了<code class="fe nk nl nm na b">area</code> getter，所以我们为每个形状获得了正确的面积，因为为每个形状运行了正确的代码来获得面积。</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/dd54e6db62cadf5dc153e0eac0159fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uO28tXrfper4Tgje"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@seteales?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Allef Vinicius </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="45a0" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">界面分离原理</h1><p id="c970" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">接口分离原则声明“客户不应该被迫依赖他们不使用的接口。”</p><p id="9802" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着如果不需要的话，我们不应该强制实现。</p><p id="90d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript没有接口，所以这个原则并不直接适用，因为它没有通过接口强制实现任何东西。</p><h1 id="c0b6" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">从属倒置原则</h1><p id="a80d" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">这个原则声明高级模块不应该依赖低级模块，它们都应该依赖抽象，而抽象不应该依赖细节。细节应该依赖于抽象。</p><p id="3c3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们不需要知道依赖关系的任何实现细节。如果我们这样做了，那么我们就违反了这个原则。</p><p id="70a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要这个原则，因为如果我们确实需要引用代码来获得依赖关系的实现细节，那么当依赖关系改变时，我们自己的代码将会有很多重大改变。</p><p id="7a9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着软件变得越来越复杂，如果我们不遵循这个原则，那么我们的代码将会崩溃很多。</p><p id="ed7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我们实现的代码隐藏实现细节的一个例子是facade模式。该模式将一个facade类放在底层复杂实现的前面，因此我们只需依赖facade来使用底层的特性。</p><p id="5681" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果底层类改变了，那么只有外观需要改变，我们不必担心修改我们自己的代码，除非外观有重大改变。</p><p id="74ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面是外观模式的一个简单实现:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a5db" class="ne lt it na b gy nf ng l nh ni">class ClassA {</span><span id="e27c" class="ne lt it na b gy nj ng l nh ni">}</span><span id="03ae" class="ne lt it na b gy nj ng l nh ni">class ClassB {</span><span id="8fdb" class="ne lt it na b gy nj ng l nh ni">}</span><span id="62ca" class="ne lt it na b gy nj ng l nh ni">class ClassC {</span><span id="c771" class="ne lt it na b gy nj ng l nh ni">}</span><span id="beb9" class="ne lt it na b gy nj ng l nh ni">class Facade {<br/>  constructor() {<br/>    this.a = new ClassA();<br/>    this.b = new ClassB();<br/>    this.c = new ClassC();<br/>  }<br/>}</span><span id="b02b" class="ne lt it na b gy nj ng l nh ni">class Foo {<br/>  constructor() {<br/>    this.facade = new Facade();<br/>  }</span><span id="9418" class="ne lt it na b gy nj ng l nh ni">}</span></pre><p id="1893" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不必担心<code class="fe nk nl nm na b">ClassA</code>、<code class="fe nk nl nm na b">ClassB</code>和<code class="fe nk nl nm na b">ClassC</code>来实现<code class="fe nk nl nm na b">Foo</code>类。只要<code class="fe nk nl nm na b">Facade</code>类不变，我们就不用自己改代码。</p><h1 id="ec54" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="31b7" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我们应该遵循坚实的原则来编写易于维护的代码。</p><p id="6614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了遵循SOLID，我们必须编写只做一件事的类。</p><p id="3a6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的代码必须对扩展开放，但对修改关闭。这减少了弄乱现有代码的机会。</p><p id="9eb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们切换父类和子类时，它们必须是可互换的。当我们转换它们时，结果仍然是正确的。</p><p id="fdc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们不应该依赖我们引用的任何一段代码的实现细节，这样我们就不会在某些事情发生变化的时候出现很多破坏性的变化。</p><p id="55be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这让我们减少了模块之间的耦合。</p></div></div>    
</body>
</html>