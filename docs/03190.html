<html>
<head>
<title>Understanding The Python Reduce Function With Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过示例了解Python Reduce函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-the-python-reduce-function-with-examples-ddfac8b078d4?source=collection_archive---------8-----------------------#2020-04-24">https://levelup.gitconnected.com/understanding-the-python-reduce-function-with-examples-ddfac8b078d4?source=collection_archive---------8-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3d1e95475395dab8cca14047d0572b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StDvTnlZn0RTeAycgmStDw.png"/></div></div></figure><p id="76e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">在</em><a class="ae la" href="https://melvinkoh.me/understanding-the-python-reduce-function-with-examples-ck7mzz8l200na8ss1ogdvw5c5" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://melvinkoh . me</em></a><em class="kz">免费阅读。</em></p><p id="10d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然有大量的Python库可用于数据操作，但对于简单的数据转换来说，它们可能是多余的。Python标准库自带<code class="fe lb lc ld le b"><a class="ae la" href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="noopener ugc nofollow" target="_blank">functools.reduce()</a></code>函数，函数式编程中最常用的函数之一，对于简单的数据转换很方便。如果您听说过<code class="fe lb lc ld le b">reduce()</code>或函数式编程，但不确定它们到底是什么，以及它们如何帮助您编写更好的Python代码，这就是适合您的文章。</p><p id="3193" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本教程中，您将:</p><ul class=""><li id="d66b" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">理解函数式编程的基本原理</li><li id="b20a" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">了解Python的<code class="fe lb lc ld le b">reduce()</code>功能是什么</li><li id="f9a3" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">了解Python reduce函数如何用于基本的数据处理和从数据中获得洞察力</li><li id="a576" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">被介绍给<code class="fe lb lc ld le b">accumulate</code>，它提供与<code class="fe lb lc ld le b">reduce()</code>功能相似的功能</li><li id="2820" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">重述什么是λ函数和iterable</li></ul><p id="2f3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">阅读完本教程后，您应该能够使用Python <code class="fe lb lc ld le b">reduce()</code>从原始数据中获取有用的信息，并执行数据转换。您还应该能够识别出<code class="fe lb lc ld le b">reduce()</code>和<code class="fe lb lc ld le b">accumulate</code>的区别和用例，并相应地使用它们。</p><h1 id="a9fa" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">Python中的函数式编程是什么？</h1><p id="5ef6" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated"><a class="ae la" href="https://realpython.com/courses/functional-programming-python/" rel="noopener ugc nofollow" target="_blank">函数式编程</a>是一种编程范式，专注于编写声明性代码和没有任何副作用的纯函数。不用深入研究它的哲学和历史，当编写函数式风格的代码时，您编写的函数:</p><ul class=""><li id="9749" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">不要更改其范围内的任何输入参数或变量</li><li id="8ace" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">不要发出任何网络请求</li><li id="1bc9" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">不要在控制台上打印任何东西</li><li id="a4cd" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">不要包含任何随机性</li><li id="1111" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">假设输入参数保持不变，则总是返回相同的值</li></ul><p id="ba92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python是一种多范式语言，支持函数式编程。就函数式编程而言，它比<code class="fe lb lc ld le b">reduce()</code>多得多。要了解更多关于函数式编程的知识，你可以查看关于Python中map()的文章<a class="ae la" href="https://realpython.com/lessons/map-function-overview/" rel="noopener ugc nofollow" target="_blank">和官方文档</a>中的<a class="ae la" href="https://docs.python.org/3/howto/functional.html" rel="noopener ugc nofollow" target="_blank"> HOWTO指南。</a></p><h1 id="e6d6" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">什么是Python Reduce？</h1><p id="ac74" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">言归正传，Python中的<code class="fe lb lc ld le b">reduce()</code>到底是什么？您将从一个简单的例子开始，将一系列整数相乘。</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="8794" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; # Using for loop, the imperative way <br/>&gt;&gt;&gt; multipliers = [2, 10, 4, 16] <br/>&gt;&gt;&gt; accumulation = 1</span><span id="b3a9" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; for number in multipliers: <br/>...     accumulation *= number</span><span id="9159" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; accumulation <br/>1280</span></pre><p id="5649" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从代码片段来看，您只是使用了一个<code class="fe lb lc ld le b">for</code>循环将所有的数字相乘，并将结果存储在变量<code class="fe lb lc ld le b">accumulation</code>中</p><p id="ec9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来看看<code class="fe lb lc ld le b">reduce()</code>的替代方案:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="7e29" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; # Using reduce(), a functional approach <br/>&gt;&gt;&gt; from functools import reduce</span><span id="532c" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; multipliers = [2, 10, 4, 16]</span><span id="52a8" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; accumulation = reduce( <br/>...     lambda acc, number: acc * number, <br/>...     multipliers <br/>... )</span><span id="5446" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; accumulation <br/>1280</span></pre><p id="53a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从代码片段来看，你没有使用<code class="fe lb lc ld le b">for</code>循环，而是从<code class="fe lb lc ld le b">functools</code>导入<code class="fe lb lc ld le b">reduce()</code>，使用<code class="fe lb lc ld le b">reduce()</code>达到数字相乘的目的，并将结果存储在一个变量<code class="fe lb lc ld le b">accumulation</code>中。</p><p id="7d35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这只是给你一个简单的概念，如何利用<code class="fe lb lc ld le b">reduce()</code>作为整数乘法的替代解决方案。</p><blockquote class="nk nl nm"><p id="a5fc" class="kb kc kz kd b ke kf kg kh ki kj kk kl nn kn ko kp no kr ks kt np kv kw kx ky im bi translated"><em class="it">其实从Python 3.8开始，增加了一个新的函数，对可迭代的数进行乘法运算。</em></p></blockquote><p id="eca8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码片段的目的是向您展示使用<code class="fe lb lc ld le b">for</code>循环编写命令式代码的替代方法。您将很快看到如何在更复杂的例子中使用<code class="fe lb lc ld le b">reduce()</code>。</p><h1 id="ffad" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">Python Reduce的函数签名</h1><p id="8517" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">让我们深入了解一下<code class="fe lb lc ld le b">reduce()</code>的函数签名:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="939a" class="ne lu it le b gy nf ng l nh ni">functools.reduce(function, iterable[, initializer])</span></pre><p id="f3a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lb lc ld le b">reduce()</code>服用:</p><ul class=""><li id="ada6" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated"><code class="fe lb lc ld le b"><strong class="kd iu">function</strong></code> <strong class="kd iu"> : </strong>定义要应用的函数的第一个参数，也称为reduce函数的谓词</li><li id="fcf8" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">第二个参数带有要传递给<code class="fe lb lc ld le b">function</code>的值</li><li id="a5a9" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><code class="fe lb lc ld le b"><strong class="kd iu">initializer</strong></code> <strong class="kd iu"> : </strong>第三个参数，也就是开始的值。</li></ul><p id="8410" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意方括号<code class="fe lb lc ld le b">[ ]</code>中的参数是可选的。</p><blockquote class="nk nl nm"><p id="2dfc" class="kb kc kz kd b ke kf kg kh ki kj kk kl nn kn ko kp no kr ks kt np kv kw kx ky im bi translated"><em class="it">iterable是一个能够一次返回一个元素的对象。可迭代的例子包括所有序列类型，如</em> <code class="fe lb lc ld le b"><em class="it">str</em></code> <em class="it">、</em> <code class="fe lb lc ld le b"><em class="it">list</em></code> <em class="it">、</em> <code class="fe lb lc ld le b"><em class="it">tuple</em></code> <em class="it">、</em> <code class="fe lb lc ld le b"><em class="it">set</em></code> <em class="it">，以及实现</em> <code class="fe lb lc ld le b"><em class="it">__iter__()</em></code> <em class="it">方法的任何对象。Iterables可以与采用序列的</em> <code class="fe lb lc ld le b"><em class="it">for</em></code> <em class="it">循环和函数一起使用。要了解iterable，可以阅读</em> <a class="ae la" href="https://realpython.com/python-for-loop/#iterables" rel="noopener ugc nofollow" target="_blank"> <em class="it">这篇真正的Python文章</em> </a> <em class="it">和</em> <a class="ae la" href="https://docs.python.org/3.8/glossary.html#term-iterable" rel="noopener ugc nofollow" target="_blank"> <em class="it">这篇词汇表为完整定义</em> </a> <em class="it">。</em></p></blockquote><p id="20a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，您将了解Python <code class="fe lb lc ld le b">reduce()</code>函数是如何工作的。它近似于:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="0326" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; # Rough implementation of reduce(), taken from Python official documentation: <br/>&gt;&gt;&gt; # <a class="ae la" href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/functools.html#functools.reduce</a></span><span id="3bf2" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; def reduce(function, iterable, initializer=None): <br/>...     it = iter(iterable) <br/>...     if initializer is None: <br/>...         value = next(it) <br/>...     else: <br/>...         value = initializer <br/>...     for element in it: <br/>...         value = function(value, element) <br/>...     return value</span></pre><p id="3693" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lb lc ld le b">reduce()</code>对iterable中的所有元素累积应用提供的<code class="fe lb lc ld le b">function</code>，然后返回最终结果。换句话说，<code class="fe lb lc ld le b">reduce()</code>在遍历输入iterable的每一项时，通过改变结果来构建结果。</p><p id="76b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果提供了一个<code class="fe lb lc ld le b">initializer</code>，在移动到iterable的任何元素之前，它将被用作第一个元素。在后面的部分中，你会看到需要初始化器的例子。</p><p id="5711" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，您还必须知道谓词<code class="fe lb lc ld le b">function</code>被约束为这样的行为:</p><ol class=""><li id="30bd" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky nq ll lm ln bi translated">它有两个位置参数:第一个是累积值，第二个是更新值</li><li id="1c57" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nq ll lm ln bi translated">它总是返回累加值</li></ol><p id="48f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是谓词的常见代码模式:</p><blockquote class="nk nl nm"><p id="c581" class="kb kc kz kd b ke kf kg kh ki kj kk kl nn kn ko kp no kr ks kt np kv kw kx ky im bi translated"><em class="it">在我们之前的整数列表乘法示例中，您还注意到了</em> <code class="fe lb lc ld le b"><em class="it">lambda</em></code> <em class="it">操作符。如果您不熟悉这个关键字，它本质上是一个匿名函数，隐式返回其最后一个表达式的值。想了解更多关于lambda函数的内容，可以参考</em> <a class="ae la" href="https://realpython.com/python-lambda/" rel="noopener ugc nofollow" target="_blank"> <em class="it">本文</em> </a> <em class="it">。</em></p></blockquote><h1 id="78fb" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">示例中的Python Reduce</h1><p id="2f70" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">在本节中，您将看到<code class="fe lb lc ld le b">reduce()</code>的多个用例。</p><h2 id="0b02" class="ne lu it bd lv nr ns dn lz nt nu dp md km nv nw mh kq nx ny ml ku nz oa mp ob bi translated">示例1:计算出现次数</h2><p id="99b1" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">在本例中，您将看到如何利用Python reduce函数来计算偶数在列表中出现的次数。</p><p id="15b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们试着用一个<code class="fe lb lc ld le b">for</code>循环来实现:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="b778" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; values = [22, 4, 12, 43, 19, 71, 20] <br/>&gt;&gt;&gt; # Using for loop, the imperative way <br/>&gt;&gt;&gt; count = 0</span><span id="8972" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; for number in values: <br/>...     if not number % 2: <br/>...     count += 1</span><span id="a121" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; count <br/>4</span></pre><p id="94e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在你已经用一个<code class="fe lb lc ld le b">for</code>循环计算了偶数的出现次数，你可以用<code class="fe lb lc ld le b">reduce()</code>尝试函数式编程方式:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="cc50" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; from functools import reduce</span><span id="2e2f" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; values = [22, 4, 12, 43, 19, 71, 20]</span><span id="15af" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; count = reduce( <br/>...     lambda acc, num: acc if num % 2 else acc + 1, <br/>...     values <br/>... )</span><span id="9faa" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; count <br/>25</span></pre><p id="6c7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，如果你运行上面的代码，你将得到<code class="fe lb lc ld le b">25</code>而不是<code class="fe lb lc ld le b">4</code>。</p><p id="5961" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在你明白了初始化器是如何工作的，让我们通过添加一个<code class="fe lb lc ld le b">initializer</code>来纠正错误的代码:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="0f9e" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; # Using reduce() with initializer <br/>&gt;&gt;&gt; from functools import reduce</span><span id="78cb" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; values = [22, 4, 12, 43, 19, 71, 20]</span><span id="6ecc" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; count = reduce( <br/>...     lambda acc, num: acc if num % 2 else acc + 1, <br/>...     values, <br/>...     0 # Initializer <br/>... )</span><span id="5a79" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; count <br/>4</span></pre><p id="dea8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们进一步放大谓词:</p><p id="fce7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据上面的lambda函数:</p><ul class=""><li id="d854" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">如果数字是偶数，递增的<em class="kz"/><code class="fe lb lc ld le b">acc</code>被传递到下一次迭代</li><li id="26ad" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">否则，返回<code class="fe lb lc ld le b">acc</code>的当前值</li></ul><p id="7299" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不要忘记谓词的第一个参数(本例中为<code class="fe lb lc ld le b">acc</code>)的值将始终是上一次迭代返回的值！</p><h2 id="872c" class="ne lu it bd lv nr ns dn lz nt nu dp md km nv nw mh kq nx ny ml ku nz oa mp ob bi translated">示例2:创建一个新的<code class="fe lb lc ld le b">dict</code>结构</h2><p id="2a09" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">在这个例子中，当您需要提取对事件邀请的RSVP响应时，您将得到一个场景。您将获得以下被邀请者列表:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="b1ad" class="ne lu it le b gy nf ng l nh ni">list_of_invitees = [ <br/>    {"email": "alex@example.com", "name": "Alex", "status": attending"}, <br/>    {"email": "brian@example.com", "name": "Brian", "status": "declined"}, <br/>    {"email": "carol@example.com", "name": "Carol", "status": pending"}, <br/>    {"email": "derek@example.com", "name": "Derek", "status": "attending"}, <br/>    {"email": "ellen@example.com", "name": "Ellen", "status": "attending"} <br/>]</span></pre><p id="28c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您希望通过创建这样一个字典来可视化邀请的RSVP状态:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="5c96" class="ne lu it le b gy nf ng l nh ni">{ <br/>    "alex@example.com": "attending", <br/>    "brian@example.com": "declined", <br/>    "carol@example.com": "pending", <br/>    "derek@example.com": "attending", <br/>    "ellen@example.com": "attending" <br/>}</span></pre><p id="9b97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码片段将是数据转换的结果。它从字典列表(每个字典包含被邀请人的电子邮件、姓名和RSVP状态)转换为RSVP状态的字典，可以使用被邀请人的电子邮件访问该字典。</p><p id="3bea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要实现这一点，您可以利用Python reduce函数。首先，定义谓词函数。</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="70a9" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; def transform_data(acc, invitee): <br/>...     acc[invitee["email"]] = invitee["status"] <br/>...     return acc</span></pre><blockquote class="nk nl nm"><p id="76d5" class="kb kc kz kd b ke kf kg kh ki kj kk kl nn kn ko kp no kr ks kt np kv kw kx ky im bi translated"><em class="it">如您所见，谓词不需要是lambda函数。可以是普通的函数、方法，也可以是任何</em> <a class="ae la" href="https://docs.python.org/3/reference/datamodel.html#emulating-callable-objects" rel="noopener ugc nofollow" target="_blank"> <em class="it"> Python可调用的</em> </a> <em class="it">。</em></p></blockquote><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="e2f2" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; results = reduce( <br/>...     transform_data, <br/>...     list_of_invitees, <br/>...     {} # Initializer <br/>... )</span><span id="ba47" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; results <br/>{'alex@example.com': 'attending', 'brian@example.com': 'declined', 'carol@example.com': 'pending', 'derek@example.com': 'attending', 'ellen@example.com': 'attending'}</span></pre><p id="9c4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面可以看出，您使用<code class="fe lb lc ld le b">reduce()</code>通过字典来可视化邀请的RSVP状态，其中键是被邀请者的电子邮件，值是他们相应的响应。</p><p id="2d75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">恭喜你！您刚刚用<code class="fe lb lc ld le b">reduce()</code>函数创建了一个新的字典结构。您的字典的关键字是被邀请者的电子邮件，每个关键字的值是相应的RSVP状态。</p><p id="c5be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你怀疑是否要使用一个初始化式，以及如果要使用的话，要传递什么作为初始化式，这是很正常的。你可以引导的思维过程是:</p><ol class=""><li id="a09c" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky nq ll lm ln bi translated">问问自己:“预期结果的数据结构和你的iterable的元素匹配吗”？-&gt;如果没有，使用初始化式，否则，您可能不需要它</li><li id="1925" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nq ll lm ln bi translated">如果需要初始化器，数据结构或数据类型通常应该与预期结果相同</li></ol><p id="9605" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，这个思考过程并不是万无一失的，因为没有两种情况是相同的。</p><h2 id="e70e" class="ne lu it bd lv nr ns dn lz nt nu dp md km nv nw mh kq nx ny ml ku nz oa mp ob bi translated">示例3:从事件参与者列表中获得洞察力</h2><p id="3c53" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">在第三个例子中，您将得到一个与会者列表(注意，这个例子与例子2无关)，您的任务是告诉:</p><ol class=""><li id="e9b5" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky nq ll lm ln bi translated">陪同客人数和总客人数</li><li id="cb3f" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nq ll lm ln bi translated">有多少素食者和非素食者参加了</li></ol><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="c1e6" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; # Your given list of attendees <br/>&gt;&gt;&gt; list_of_attendees = [ <br/>... {"name": "Zeke", "vegan": True, "brought_guests": True, <br/>... "guests": [{"name": "Amanda", "vegan": False}, <br/>... {"name": "Wayne", "vegan": True}]}, <br/>... {"name": "Xavier", "vegan": True, "brought_guests": False}, <br/>... {"name": "Yohanna", "vegan": False, <br/>... "brought_guests": True, <br/>... "guests": [{"name": "Lily", "vegan": True}, <br/>... {"name": "Stefano", "vegan": True}]}, <br/>... {"name": "Kael", "vegan": False, "brought_guests": False}, <br/>... {"name": "Landon", "vegan": True, "brought_guests": False}, <br/>... ]</span></pre><h2 id="8f35" class="ne lu it bd lv nr ns dn lz nt nu dp md km nv nw mh kq nx ny ml ku nz oa mp ob bi translated">任务1:计算带客人的与会者人数</h2><p id="f2e5" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">预期的输出应该是一个字典:</p><p id="f3ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在进入下一个解决方案之前，请随意打开您的Python解释器，挠一挠您的大脑。</p><h2 id="a6ff" class="ne lu it bd lv nr ns dn lz nt nu dp md km nv nw mh kq nx ny ml ku nz oa mp ob bi translated">任务1的示例解决方案</h2><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="fb8c" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; def derive_guest_count(acc, attendee): <br/>...     acc["total_guests"] += 1 <br/>... <br/>...     if attendee["brought_guests"]: <br/>...         acc["guest_who_brought_guests"] += 1 <br/>...     acc["total_guests"] += len(attendee["guests"]) <br/>... <br/>...     return acc</span><span id="646a" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; results = reduce( <br/>...     derive_guest_count, <br/>...     list_of_attendees, <br/>...     {   # Initializer <br/>...         "guest_who_brought_guests": 0, <br/>...         "total_guests": 0 <br/>...     } <br/>... )</span></pre><p id="ecb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们深入到谓词(<code class="fe lb lc ld le b">derive_guest_count()</code>)。</p><ul class=""><li id="4842" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">在第1行，您增加了<code class="fe lb lc ld le b">total_guests</code>的计数。</li><li id="df9b" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">随后，您使用<code class="fe lb lc ld le b">if</code>语句检查与会者是否带来了客人。如果是这样，你增加<code class="fe lb lc ld le b">guest_who_brought_guests</code>的计数，并将<code class="fe lb lc ld le b">len(attendee["guests"])</code>的客人总数加到<code class="fe lb lc ld le b">total_guests</code>的计数中。</li></ul><p id="8a40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在定义了谓词之后，您向<code class="fe lb lc ld le b">reduce()</code>函数提供您的谓词、参与者列表(<code class="fe lb lc ld le b">list_of_attendees</code>)和一个带有键的字典的初始化器:</p><ul class=""><li id="6158" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated"><code class="fe lb lc ld le b">guest_who_brought_guests</code>:记录陪同客人的数量</li><li id="f993" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated"><code class="fe lb lc ld le b">total_guests</code>:记录参加活动的客人总数</li></ul><h2 id="c826" class="ne lu it bd lv nr ns dn lz nt nu dp md km nv nw mh kq nx ny ml ku nz oa mp ob bi translated">任务2:计算素食者和非素食者的数量</h2><p id="faa3" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">在第二个任务中，同样的与会者名单，你被要求得出素食者和非素食者的人数。预期的输出应该是:</p><p id="7db5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再次强调，在继续前进之前，试着想出一个解决方案。</p><h2 id="c37f" class="ne lu it bd lv nr ns dn lz nt nu dp md km nv nw mh kq nx ny ml ku nz oa mp ob bi translated">任务2的示例解决方案</h2><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="6c75" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; def derive_vegan_info(acc, attendee): <br/>...     if attendee["vegan"]: <br/>...         acc["vegan"] += 1 <br/>...     else: <br/>...         acc["non_vegan"] += 1 <br/>... <br/>...     if attendee.get("brought_guests"): <br/>...         for guest_brought in attendee["guests"]: <br/>...             # Check guests recursively <br/>...             acc = derive_vegan_info(acc, guest_brought) <br/>... <br/>...     return acc</span><span id="d566" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; results = reduce( <br/>...     derive_vegan_info, <br/>...     list_of_attendees, <br/>...     {"vegan": 0,"non_vegan": 0} <br/>... )</span><span id="343b" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; results <br/>{"vegan": 6, "non_vegan": 3}</span></pre><p id="571a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看谓词(<code class="fe lb lc ld le b">derive_vegan_info</code>):</p><ul class=""><li id="2212" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">如果<code class="fe lb lc ld le b">attendee["vegan"]</code>的值为<code class="fe lb lc ld le b">True</code>，首先增加<code class="fe lb lc ld le b">vegan</code>的计数。否则，增加<code class="fe lb lc ld le b">non_vegan</code>的值</li><li id="85ba" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">接下来，你检查<code class="fe lb lc ld le b">attendee</code>是否带了客人。如果是这样，您将遍历出席的额外来宾的列表。对于每个额外参加的客人，您通过调用<code class="fe lb lc ld le b">derive_vegan_info</code>并传递累积值(<code class="fe lb lc ld le b">acc</code>和额外客人的信息(guest _ bring)递归地获得素食信息。</li></ul><p id="6069" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止，我希望你明白Python reduce函数是如何工作的。请记住，要习惯它需要几次练习。</p><h1 id="8691" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">Python Reduce函数的近亲:<code class="fe lb lc ld le b">accumulate()</code></h1><p id="9e13" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">在Python中，reduce函数有时与它的近亲<code class="fe lb lc ld le b"><a class="ae la" href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="noopener ugc nofollow" target="_blank">itertools.accumulate()</a></code>对象相关联。使用<code class="fe lb lc ld le b">reduce()</code>，你得到的只是所有迭代在内部运行后的最终结果。如果需要每次迭代的中间结果会怎么样？这里是<code class="fe lb lc ld le b">accumulate()</code>大放异彩的地方。</p><p id="8de0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记得在本教程的最开始，你看到乘法使用<code class="fe lb lc ld le b">reduce()</code>。让我们用<code class="fe lb lc ld le b">accumulate()</code>来可视化中间结果:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="a159" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; from itertools import accumulate <br/>&gt;&gt;&gt; numbers = [2, 10, 4, 16]</span><span id="6ca6" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; accumulation = accumulate( <br/>...     numbers, # Iterable <br/>...     lambda acc, number: acc * number # Predicate <br/>... )</span><span id="1f2f" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; list(accumulation) <br/>[2, 20, 80, 1280]</span></pre><p id="4b84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">眼尖的读者会注意到<code class="fe lb lc ld le b">accumulate()</code>的函数签名略有不同。第一个参数是可迭代的，谓词现在是第二个位置参数。</p><p id="9ae1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来看看<code class="fe lb lc ld le b">itertools.accumulate()</code>的函数签名:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="3924" class="ne lu it le b gy nf ng l nh ni">itertools.accumulate(iterable[,func, *, initial=None])</span></pre><p id="9304" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意方括号<code class="fe lb lc ld le b">[ ]</code>中的参数是可选的，第二个位置参数<code class="fe lb lc ld le b">func</code>的默认参数是<code class="fe lb lc ld le b">operator.add</code>。<code class="fe lb lc ld le b">operator</code>模块导出一组对应于Python内部操作符的函数。例如，<code class="fe lb lc ld le b">operator.add(x, y)</code>等价于表达式<code class="fe lb lc ld le b">x + y</code>。</p><p id="7206" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也就是说，如果没有第二个参数<code class="fe lb lc ld le b">func</code>，默认情况下<code class="fe lb lc ld le b">accumulate</code>会对iterable中的所有元素求和。</p><blockquote class="nk nl nm"><p id="28f3" class="kb kc kz kd b ke kf kg kh ki kj kk kl nn kn ko kp no kr ks kt np kv kw kx ky im bi translated"><em class="it">注意从Python 3.8开始增加了可选的关键字参数</em> <code class="fe lb lc ld le b"><em class="it">initial</em></code> <em class="it">。如果您使用的是以前的版本，函数签名将是</em> <code class="fe lb lc ld le b"><em class="it">itertools.accumulate(iterable[, func])</em></code> <em class="it">。</em></p></blockquote><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="7114" class="ne lu it le b gy nf ng l nh ni">&gt;&gt;&gt; import operator <br/>&gt;&gt;&gt; from itertools import accumulate</span><span id="3c70" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; numbers = [2, 10, 4, 16]</span><span id="eef5" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; accumulation = accumulate( <br/>...     numbers, # Iterable <br/>...     operator.mul # This line has changed <br/>... )</span><span id="7902" class="ne lu it le b gy nj ng l nh ni">&gt;&gt;&gt; list(accumulation) <br/>[2, 20, 80, 1280]</span></pre><p id="64b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lb lc ld le b">reduce()</code>和<code class="fe lb lc ld le b">accumulate()</code>的另一个区别是后者返回一个可迭代的<code class="fe lb lc ld le b">itertools.accumulate</code>对象。要遍历结果，将返回对象放入一个<code class="fe lb lc ld le b">for</code>循环或任何采用iterable的函数中。使用<code class="fe lb lc ld le b">itertools.accumulate()</code>，您可以获得累加过程中获得的所有值，而使用<code class="fe lb lc ld le b">functools.reduce()</code>，您只能获得最后一个值。</p><h1 id="35fe" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">Python Reduce的反模式</h1><p id="a460" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">使用Python reduce函数的反模式很大程度上源于函数式编程的原则。使用Python reduce时:</p><ol class=""><li id="0733" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky nq ll lm ln bi translated">除了累加值之外，不应该改变任何参数</li><li id="f3b9" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky nq ll lm ln bi translated">你不应该在你的谓词函数中产生任何副作用</li></ol><p id="46ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个坏谓词的演示，使用了您在示例3中看到的参与者列表:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="63a9" class="ne lu it le b gy nf ng l nh ni">def derive_guest_count (acc, attendee): <br/>    """<br/>    A bad predicate    <br/>    """</span><span id="d532" class="ne lu it le b gy nj ng l nh ni"># Anti-pattern 1: Mutating the input argument<br/>    attendee["processed"] = True <br/> <br/>    # Anti-pattern 2: Creating side-effect, printing to console<br/>    print(f"Processing {attendee['name']}")</span><span id="97ec" class="ne lu it le b gy nj ng l nh ni"># The lines below remain unchanged<br/>    acc["total_guests"] += 1</span><span id="712b" class="ne lu it le b gy nj ng l nh ni">if attendee["brought_guests"]: <br/>        acc["guest_who_brought_guests"] += 1 <br/>        acc["total_guests"] += len(attendee["guests"]) <br/>    <br/>    return acc</span></pre><p id="14b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，谓词试图通过将键<code class="fe lb lc ld le b">processed</code>的值更改为<code class="fe lb lc ld le b">True</code>来改变输入参数<code class="fe lb lc ld le b">attendee</code>。</p><p id="a054" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它还试图使用<code class="fe lb lc ld le b">print()</code>函数将一条语句打印到控制台。</p><p id="2f89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个都是常见的错误，甚至对于一些有经验的python爱好者也是如此。</p><h1 id="d313" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="64fa" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">在本教程中:</p><ul class=""><li id="617a" class="lf lg it kd b ke kf ki kj km lh kq li ku lj ky lk ll lm ln bi translated">您已经学习了Python中的<code class="fe lb lc ld le b">reduce()</code>是如何工作的，以及如何使用它来获得洞察力和数据转换，以及一些反模式</li><li id="9ff9" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">向您介绍了一个类似的函数，<code class="fe lb lc ld le b">accumulate()</code>来收集中间结果，并理解了它与<code class="fe lb lc ld le b">reduce()</code>的不同之处</li><li id="33a5" class="lf lg it kd b ke lo ki lp km lq kq lr ku ls ky lk ll lm ln bi translated">向您介绍了<code class="fe lb lc ld le b">operator</code>模块，它包含许多与Python操作符相对应的方便函数</li></ul><p id="76aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">原发布于</em><a class="ae la" href="https://melvinkoh.me/understanding-the-python-reduce-function-with-examples-ck7mzz8l200na8ss1ogdvw5c5" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://melvinkoh . me</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>