<html>
<head>
<title>On the mysteries of kotlin.test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于科特林的秘密</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/on-the-mysteries-of-kotlin-test-444cf094e69f?source=collection_archive---------2-----------------------#2020-01-19">https://levelup.gitconnected.com/on-the-mysteries-of-kotlin-test-444cf094e69f?source=collection_archive---------2-----------------------#2020-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a38" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我希望在使用Gradle在Kotlin中配置自动化测试时得到的答案</h2></div><blockquote class="ki"><p id="0557" class="kj kk it bd kl km kn ko kp kq kr ks dk translated">你听说过科特林初级读本吗？这是一个广泛的，实际操作和详细的Kotlin语言指南，充满了独特和原创的解释，互动练习，和基于经验的具体建议。它将在几天内把任何懂Java的人变成Kotlin专家。看看吧！</p></blockquote><p id="d59e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo ks im bi translated">如果你曾经问过类似下面的问题，请继续阅读:</p><ul class=""><li id="a088" class="lp lq it kw b kx lr la ls ld lt lh lu ll lv ks lw lx ly lz bi translated"><strong class="kw iu"> </strong> kotlin.test和KotlinTest(后来改名为Kotest)有联系吗？</li><li id="98ea" class="lp lq it kw b kx ma la mb ld mc lh md ll me ks lw lx ly lz bi translated"><em class="mf"> gradle init </em>生成的<em class="mf"> kotlin-test </em>和<em class="mf"> kotlin-test-junit </em>依赖关系是什么？</li><li id="c0ee" class="lp lq it kw b kx ma la mb ld mc lh md ll me ks lw lx ly lz bi translated">如何将kotlin.test从使用JUnit4切换到使用JUnit5？所有这些<code class="fe mg mh mi mj b">useJUnitPlatform()</code>废话是什么，更重要的是<em class="mf">为什么</em>有必要吗？</li><li id="a3cb" class="lp lq it kw b kx ma la mb ld mc lh md ll me ks lw lx ly lz bi translated">什么是<em class="mf"> junit.jupyter.engine </em>和<em class="mf"> junit.jupyter.api </em>？为什么我需要它们，什么时候需要它们，为什么我似乎只在某些时候需要它们？</li><li id="a586" class="lp lq it kw b kx ma la mb ld mc lh md ll me ks lw lx ly lz bi translated">为什么我在IDEA中总是收到“未收到测试事件”?为什么我有时在一次运行中得到测试结果，而在下一次运行中却得到“测试事件未被接收”？</li><li id="f5ec" class="lp lq it kw b kx ma la mb ld mc lh md ll me ks lw lx ly lz bi translated">为什么我从命令行运行测试时得不到任何测试结果，尽管我在IDEA中运行时得到了这些结果？</li></ul><p id="58ac" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">为了以令人满意的方式回答所有这些问题，我们将首先简要讨论一些将在整篇文章中提到的基本测试主题。在此之后，我们将消除一个误解，这可能是一个真正的初学者。</p><p id="f424" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">然后，我们将继续逐个模块地剖析kotlin.test库，并解释它们各自扮演的角色。然后，我们将继续详细了解为什么针对同一工具的不同版本的两个模块(JUnit4和JUnit5)需要非常不同的配置，并利用这一点来深入了解事情是如何工作的。</p><p id="8a96" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">最后，我们将向您展示如何配置Gradle以在控制台中显示输出，并给出一个快速提示，告诉您在偶尔测试似乎无法运行时该做什么。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mn"><img src="../Images/b6b691307996078a0520b7d186b1653e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wtO9-NG_JRPLmoH_isOqg.png"/></div></div></figure><h2 id="aab5" class="mz na it bd nb nc nd dn ne nf ng dp nh ld ni nj nk lh nl nm nn ll no np nq nr bi translated">首先是一些基本的东西</h2><p id="5a21" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo ks im bi translated">在开始之前，我们需要澄清一些术语。我推荐阅读<a class="ae kt" href="https://amzotti.github.io/testing/2015/03/16/what-is-the-difference-between-a-test-runner-testing-framework-assertion-library-and-a-testing-plugin/" rel="noopener ugc nofollow" target="_blank">这篇短文</a>很好地介绍了这个话题，但是TL；博士，重要的是要区分:</p><ul class=""><li id="fda1" class="lp lq it kw b kx lr la ls ld lt lh lu ll lv ks lw lx ly lz bi translated">一个<strong class="kw iu">测试框架</strong> &amp; <strong class="kw iu">断言库</strong>(可以是测试框架的一部分)，也就是给你提供API(函数、注释等)的东西。)来编写实际的测试，并且</li><li id="43ea" class="lp lq it kw b kx ma la mb ld mc lh md ll me ks lw lx ly lz bi translated">一个<strong class="kw iu">测试运行程序</strong>，它接受这些测试，运行它们，并收集结果，可能在此过程中生成各种报告或者提供额外的特性</li></ul><p id="84dc" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">另一个你需要熟悉的术语是<strong class="kw iu"> JUnit </strong>。JUnit是一个Java测试工具，它是测试工具集合的一部分，统称为<a class="ae kt" href="https://en.wikipedia.org/wiki/XUnit" rel="noopener ugc nofollow" target="_blank"> XUnit </a>，它提供了上面描述的所有功能(即，它提供了测试框架、断言和测试运行程序)。</p><blockquote class="nx ny nz"><p id="596c" class="ku kv mf kw b kx lr ju kz la ls jx lc oa mk lf lg ob ml lj lk oc mm ln lo ks im bi translated">区分JUnit4和JUnit5很重要。JUnit5在许多方面与JUnit4不同，但其中最关键的是它提供了一个平台，其他测试框架可以使用这个平台在JVM上运行测试。基本上，任何(基于JVM的)测试库都可以利用这一点，将运行测试的任务(测试运行器部分)委托给JUnit，而不是自己实现。这样做的库的一个例子是<a class="ae kt" href="https://github.com/kotlintest/kotlintest/tree/master/kotest-runner" rel="noopener ugc nofollow" target="_blank">kotl test</a>。</p><p id="95a4" class="ku kv mf kw b kx lr ju kz la ls jx lc oa mk lf lg ob ml lj lk oc mm ln lo ks im bi translated">如果你有兴趣了解更多关于JUnit5架构的知识，Nicolai Parlog为这个主题写了一篇优秀的文章。</p></blockquote><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi of"><img src="../Images/deb1560ba9b5af23dd897fc83f58d330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zfjxg-7CKO0XqY3W.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">感谢<a class="ae kt" href="https://subscription.packtpub.com/book/web_development/9781787285736/2/ch02lvl1sec13/junit-5-architecture" rel="noopener ugc nofollow" target="_blank">用JUnit 5掌握软件测试</a></figcaption></figure><h2 id="0ce9" class="mz na it bd nb nc nd dn ne nf ng dp nh ld ni nj nk lh nl nm nn ll no np nq nr bi translated">kotlin.test vs. KotlinTest(现在称为Kotest)</h2><p id="52cc" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo ks im bi translated">关于<a class="ae kt" href="https://kotlinlang.org/api/latest/kotlin.test/index.html" rel="noopener ugc nofollow" target="_blank"> kotlin.test </a>(也就是你将在kotlin参考资料中找到的库)要理解的第一件重要的事情是，据我所知，<strong class="kw iu">它与库<a class="ae kt" href="https://github.com/kotlintest/kotlintest/blob/master/doc/reference.md" rel="noopener ugc nofollow" target="_blank"> KotlinTest </a>完全没有关系。</strong></p><p id="3abc" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">回想起来，这是相当明显的——例如，你可以从两个库完全不同的名称空间中清楚地看到它(<em class="mf">kot Lin . test</em>vs .<em class="mf">io . kot Lin test</em>，目前是<em class="mf"> io.kotest </em>)。但是，当我刚开始对Kotlin生态系统一无所知时，我被几乎相同的名称弄糊涂了，事实上，当谷歌搜索另一个时，一个总是会弹出来，而且API非常相似(具体来说，<a class="ae kt" href="https://kotlinlang.org/api/latest/kotlin.test/kotlin.test/should-be.html" rel="noopener ugc nofollow" target="_blank">应该在kot Lin . test</a>vs .<a class="ae kt" href="https://github.com/kotlintest/kotlintest/blob/master/kotest-assertions/src/commonMain/kotlin/io/kotest/should.kt" rel="noopener ugc nofollow" target="_blank">应该在KotlinTest </a>)。事实上，我几乎不好意思承认，过了多久我才意识到它们可能不是一回事(几个月)，尽管似乎我不是唯一一个犯类似错误的人。</p><blockquote class="nx ny nz"><p id="1680" class="ku kv mf kw b kx lr ju kz la ls jx lc oa mk lf lg ob ml lj lk oc mm ln lo ks im bi translated">自从这篇文章发表以来，KotlinTest库已经被重新命名为<a class="ae kt" href="https://github.com/kotest/kotest" rel="noopener ugc nofollow" target="_blank"> Kotest </a>正是因为这个原因。</p></blockquote><p id="97ee" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">kotlin.test库基本上是kotlin语言的<a class="ae kt" href="https://github.com/JetBrains/kotlin/tree/master/libraries/kotlin.test" rel="noopener ugc nofollow" target="_blank">部分(与stdlib或reflect的意义相同)，于2015年</a>年底<a class="ae kt" href="https://github.com/JetBrains/kotlin/commit/1867abbbe7208047c1b3a6bd4ce26351a1f67c2e#diff-2ec68e4ebc458887e2e8628997509d21" rel="noopener ugc nofollow" target="_blank">问世，而KotlinTest是在</a><a class="ae kt" href="https://github.com/kotlintest/kotlintest/commits/master?after=b9f34bf596fa78128258c15b667876a524f92898+139&amp;path%5B%5D=README.md" rel="noopener ugc nofollow" target="_blank">大约一个月后</a>开始的，据我所知，它与Jetbrains没有任何关联(尽管另一个Kotlin测试库，<a class="ae kt" href="https://www.spekframework.org/" rel="noopener ugc nofollow" target="_blank"> Spek </a>，<a class="ae kt" href="https://blog.jetbrains.com/kotlin/2014/02/speka-specification-framework/" rel="noopener ugc nofollow" target="_blank">确实来自JetBrains </a>)。</p><blockquote class="nx ny nz"><p id="1f6d" class="ku kv mf kw b kx lr ju kz la ls jx lc oa mk lf lg ob ml lj lk oc mm ln lo ks im bi translated">有趣的是，kotlin.test <a class="ae kt" href="https://github.com/JetBrains/kotlin/blob/9b7e904390ce4eff2a96cc6b529e793fa4440b98/libraries/kotlin.test/jvm/src/main/kotlin/CollectionAssertions.kt#L11" rel="noopener ugc nofollow" target="_blank">的<code class="fe mg mh mi mj b"><em class="it">shouldBe</em></code> API似乎计划在Kotlin 1.4 </a>中完全移除。</p></blockquote><h2 id="c037" class="mz na it bd nb nc nd dn ne nf ng dp nh ld ni nj nk lh nl nm nn ll no np nq nr bi translated">了解kotlin.test中的模块</h2><p id="18da" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo ks im bi translated">kotlin.test的主要目的是为编写测试提供一个统一的API，而不考虑使用的测试运行程序和断言库。这对于多平台项目尤其有用，因为它允许您使用针对JVM编写测试时使用的相同API来编写测试，例如JavaScript。</p><p id="c43e" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">这是通过将基本断言逻辑抽象到一个<a class="ae kt" href="https://kotlinlang.org/api/latest/kotlin.test/kotlin.test/-asserter/index.html" rel="noopener ugc nofollow" target="_blank">断言器接口</a>和<a class="ae kt" href="https://kotlinlang.org/api/latest/kotlin.test/kotlin.test/index.html#annotations" rel="noopener ugc nofollow" target="_blank">一些基本注释</a>(如<code class="fe mg mh mi mj b">@Test</code>)中，然后为不同的测试框架/运行程序(如JUnit或TestNG)提供实现来实现的。</p><p id="66ad" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated"><code class="fe mg mh mi mj b">Asserter</code>接口和基本断言方法(如<code class="fe mg mh mi mj b">assertSame()</code>)的定义在<a class="ae kt" href="https://github.com/JetBrains/kotlin/tree/master/libraries/kotlin.test/common" rel="noopener ugc nofollow" target="_blank"><em class="mf">kotlin-test-common</em></a>中，而<a class="ae kt" href="https://github.com/JetBrains/kotlin/tree/master/libraries/kotlin.test/annotations-common" rel="noopener ugc nofollow" target="_blank"><em class="mf">kotlin-test-annotations-common</em></a>中包含了基本注释。注释是用<code class="fe mg mh mi mj b">expect</code>定义的，也就是说，它们实际上并没有在这里实现。</p><p id="f9d5" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">框架特定模块(<em class="mf"> kotlin-test-junit </em>等。)在相应测试框架的上下文中提供<code class="fe mg mh mi mj b">Asserter</code>接口的实现，并提供注释的<code class="fe mg mh mi mj b">actual</code>实现。</p><p id="e4fc" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">这就剩下了<a class="ae kt" href="https://github.com/JetBrains/kotlin/tree/master/libraries/kotlin.test/jvm" rel="noopener ugc nofollow" target="_blank"> <em class="mf"> kotlin-test </em> </a>模块。由于在repo中，它实际上是在<a class="ae kt" href="https://github.com/JetBrains/kotlin/tree/master/libraries/kotlin.test/jvm" rel="noopener ugc nofollow" target="_blank"> <em class="mf"> jvm </em>文件夹</a>下找到的(模块名<code class="fe mg mh mi mj b">kotlin-test</code><a class="ae kt" href="https://github.com/JetBrains/kotlin/blob/master/libraries/kotlin.test/jvm/build.gradle#L28" rel="noopener ugc nofollow" target="_blank"/>作为<a class="ae kt" href="https://github.com/JetBrains/kotlin/blob/master/libraries/kotlin.test/jvm/build.gradle#L58" rel="noopener ugc nofollow" target="_blank">参数传递给编译器</a>)，这引起了一点混乱。</p><p id="9e0a" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">这个模块包括<a class="ae kt" href="https://kotlinlang.org/api/latest/kotlin.test/index.html" rel="noopener ugc nofollow" target="_blank">参考文献</a>中提到的<a class="ae kt" href="https://github.com/JetBrains/kotlin/blob/master/libraries/kotlin.test/common/src/main/kotlin/kotlin/test/DefaultAsserter.kt" rel="noopener ugc nofollow" target="_blank">默认声明者实现</a>，据我所知，<a class="ae kt" href="https://github.com/JetBrains/kotlin/search?q=DefaultAsserter&amp;unscoped_q=DefaultAsserter" rel="noopener ugc nofollow" target="_blank">它只在库</a>的内部测试中使用。除此之外，除了实现JVM框架特定模块使用的一些通用功能外，它真的没有做什么。它提供的许多功能都被标记为不推荐使用，或者计划删除，或者提供<a class="ae kt" href="https://zsmb.co/maintaining-compatibility-in-kotlin-libraries/" rel="noopener ugc nofollow" target="_blank">二进制兼容性</a>。</p><blockquote class="nx ny nz"><p id="31cb" class="ku kv mf kw b kx lr ju kz la ls jx lc oa mk lf lg ob ml lj lk oc mm ln lo ks im bi translated">作为一个有趣的旁注，即使(从Gradle 6.0.1起)<em class="it"> gradle init </em>包含了<em class="it"> kotlin-test </em>模块，您实际上并不需要这样做，因为所有特定于框架的模块都包含了它(参见<a class="ae kt" href="https://github.com/JetBrains/kotlin/tree/master/libraries/kotlin.test" rel="noopener ugc nofollow" target="_blank">相应模块</a>中的build.gradle文件)。</p></blockquote><h2 id="1a49" class="mz na it bd nb nc nd dn ne nf ng dp nh ld ni nj nk lh nl nm nn ll no np nq nr bi translated">kot Lin-test-JUnit vs . kot Lin-test-JUnit 5</h2><p id="bbc5" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo ks im bi translated"><a class="ae kt" href="https://medium.com/@gabrielshanahan/a-deep-dive-into-an-initial-kotlin-build-gradle-kts-8950b81b214" rel="noopener">在Gradle 6.0.1 </a>下运行<em class="mf"> gradle init </em>生成一个<em class="mf"> build.gradle </em>，其中<em class="mf"> kotlin-test </em>和<em class="mf"> kotlin-test-junit </em>被包含为<a class="ae kt" href="https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph" rel="noopener ugc nofollow" target="_blank"> testImplementation依赖项</a>，它用JUnit4 runner设置kotlin.test。可以在这里看一下稍微美化的代码<a class="ae kt" href="https://github.com/gabrielshanahan/kotlin-gradle-boilerplate/blob/after-initial-changes/build.gradle.kts" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d3d5" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">如果您想切换到JUnit5，这个过程并不像您想象的那么简单——仅仅将第二个依赖项更改为<em class="mf"> kotlin-test-junit5 </em>并不能解决问题，相反会导致<em class="mf"> test </em>任务运行而不发生任何事情(在IDEA中，您会得到一个<em class="mf">Test events not received</em>消息)。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ok"><img src="../Images/3b61168c3e7d5d50424737f81ed704a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBmU9YujA2mgfpqWJWSQrg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">IDEA中未收到的测试事件</figcaption></figure><p id="dc6f" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">在谷歌搜索一番后，你很可能会想出以下两步解决方案:</p><ol class=""><li id="275b" class="lp lq it kw b kx lr la ls ld lt lh lu ll lv ks ol lx ly lz bi translated">将<em class="mf">org . JUnit . Jupiter:JUnit-Jupiter-API</em>和<em class="mf">org . JUnit . Jupiter:JUnit-Jupiter-engine</em>添加到依赖项中</li><li id="2d6d" class="lp lq it kw b kx ma la mb ld mc lh md ll me ks ol lx ly lz bi translated">配置Gradle以使用JUnit5:</li></ol><pre class="mo mp mq mr gt om mj on oo aw op bi"><span id="9832" class="mz na it mj b gy oq or l os ot"><em class="mf">tasks </em><strong class="mj iu">{<br/>    </strong><em class="mf">test </em><strong class="mj iu">{<br/>        </strong>useJUnitPlatform()<br/>    <strong class="mj iu">}<br/>}</strong></span></pre><p id="3a72" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">但是为什么呢？当JUnit4开箱即用时，为什么还需要JUnit5的额外依赖项？当JUnit4开箱即用时，为什么您还需要JUnit5的额外配置？嗯，正如一篇文章所说的，“这是方式”，但这并不能真正让任何人满意。要回答这些问题，我们需要了解JUnit4和JUnit5在架构上的区别，并查看一下<em class="mf"> kotlin-test-junit </em>和<em class="mf"> kotlin-test-junit5 </em>的build.gradle文件。</p><p id="6009" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">我们已经讨论了架构上的差异——基本上，JUnit4是一个整体，所有的东西都包含在一个模块中，而JUnit5被分成多个子模块，其中的逻辑识别并运行测试(runner，在JUnit的说法中称为<code class="fe mg mh mi mj b">TestEngine</code>)与允许你编写它们的API(测试框架&amp;断言库)是分离的。</p><p id="779a" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">这正是<a class="ae kt" href="https://stackoverflow.com/a/48448462" rel="noopener ugc nofollow" target="_blank">这两个依赖项是什么</a> : <em class="mf"> jupiter-api </em>给你编写测试所需的工具，而<em class="mf"> jupiter-engine </em>允许你运行它们。这也解释了为什么前者包含在<a class="ae kt" href="https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph" rel="noopener ugc nofollow" target="_blank"> testImplementation </a>指令中，而后者包含在<a class="ae kt" href="https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph" rel="noopener ugc nofollow" target="_blank"> testRuntimeOnly </a>指令中。</p><blockquote class="nx ny nz"><p id="c8da" class="ku kv mf kw b kx lr ju kz la ls jx lc oa mk lf lg ob ml lj lk oc mm ln lo ks im bi translated">如果你查看<em class="it">kot Lin-test-junit5</em>的<a class="ae kt" href="https://github.com/JetBrains/kotlin/blob/master/libraries/kotlin.test/junit5/build.gradle" rel="noopener ugc nofollow" target="_blank"> build.gradle文件，你会看到<em class="it"> jupiter-api </em>依赖项也被包含在内(它必须被包含在内，否则kotlin.test无法将其注释/断言器接口映射到JUnit 5世界)，所以实际上，你真正需要包含的只是<em class="it"> jupiter-engine </em>依赖项。</a></p></blockquote><p id="4178" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">从JUnit 5.4开始，<a class="ae kt" href="https://stackoverflow.com/a/55084036" rel="noopener ugc nofollow" target="_blank">变得更加简单</a>——只是<a class="ae kt" href="https://github.com/junit-team/junit5-samples/blob/master/junit5-jupiter-starter-gradle/build.gradle" rel="noopener ugc nofollow" target="_blank">包含了新的<em class="mf">org . JUnit . Jupiter:JUnit-Jupiter</em></a>工件。就是这样。</p><p id="e790" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">那么，为什么<em class="mf"> kotlin-test-junit </em>能够在没有任何额外依赖的情况下工作呢？答案就在它的<a class="ae kt" href="https://github.com/JetBrains/kotlin/blob/master/libraries/kotlin.test/junit/build.gradle" rel="noopener ugc nofollow" target="_blank"> build.gradle文件</a>—<em class="mf">JUnit:JUnit</em>依赖项，包含了JUnit4的所有内容，被包含在其中，非常像<em class="mf"> jupiter-api </em>。</p><p id="e189" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">总而言之——为了让kotlin.test正常工作，必须在依赖项中包含一个runner。在JUnit4中，runner与用于实际实现<em class="mf"> kotlin-test-junit </em>的代码捆绑在一起，因此它被包含在transit中。在JUnit5中，它是解耦的，只有API是过渡性的，所以runner需要单独包含。</p><p id="f127" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">第二点，对<code class="fe mg mh mi mj b">useJUnitPlatform()</code>的调用用于配置Gradle实际使用您决定使用的任何一个测试运行程序，无论是JUnit4 ( <code class="fe mg mh mi mj b">useJUnit()</code>)、JUnit5 ( <code class="fe mg mh mi mj b">useJUnitPlatform()</code>)还是TestNG ( <code class="fe mg mh mi mj b">useTestNG()</code>)。</p><blockquote class="nx ny nz"><p id="4b61" class="ku kv mf kw b kx lr ju kz la ls jx lc oa mk lf lg ob ml lj lk oc mm ln lo ks im bi translated">为了很好地展示kotlin.test的强大功能，您可以尝试从JUnit切换到TestNG。只需将<em class="it"> kotlin-test-junit </em>的依赖关系更改为<em class="it"> kotlin-test-testng </em>并在配置块中调用<code class="fe mg mh mi mj b"><em class="it">useTestNG()</em></code>就可以了。</p><p id="6792" class="ku kv mf kw b kx lr ju kz la ls jx lc oa mk lf lg ob ml lj lk oc mm ln lo ks im bi translated">如果您随后查看依赖项，无论是通过<a class="ae kt" href="https://docs.gradle.org/current/userguide/viewing_debugging_dependencies.html" rel="noopener ugc nofollow" target="_blank">依赖项任务</a>，还是在<a class="ae kt" href="https://github.com/JetBrains/kotlin/blob/master/libraries/kotlin.test/testng/build.gradle" rel="noopener ugc nofollow" target="_blank">build . gradle文件</a>，您都会看到org.testng.testng依赖项，它(类似于JUnit)是一个包含TestNG API和TestNG runner的整体。</p></blockquote><p id="67e5" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">为什么JUnit4不需要任何额外的配置就可以工作？因为<a class="ae kt" href="https://github.com/gradle/gradle/blob/master/subprojects/testing-jvm/src/main/java/org/gradle/api/tasks/testing/Test.java#L826-L828" rel="noopener ugc nofollow" target="_blank">如果没有指定，默认选择JUnit 4</a>。</p><h2 id="4b3d" class="mz na it bd nb nc nd dn ne nf ng dp nh ld ni nj nk lh nl nm nn ll no np nq nr bi translated">配置控制台输出</h2><p id="ddd1" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo ks im bi translated">即使在你完成了所有这些之后，你还会注意到最后一个奇怪的地方:虽然在IDEA中运行测试很好，但是如果你直接通过Gradle Wrapper运行任务(<em class="mf">)。/gradlew test </em>)，似乎什么都不会发生。实际发生的情况是测试运行了(您甚至可以在屏幕上看到一个快速的闪烁)，但是没有输出被发送到控制台。</p><p id="23f4" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">要解决这个问题，请将Gradle配置为将测试事件记录到控制台:</p><pre class="mo mp mq mr gt om mj on oo aw op bi"><span id="e854" class="mz na it mj b gy oq or l os ot"><em class="mf">import </em>org.gradle.api.tasks.testing.logging.TestLogEvent</span><span id="21a2" class="mz na it mj b gy ou or l os ot"><em class="mf">tasks </em><strong class="mj iu">{<br/>    </strong><em class="mf">test </em><strong class="mj iu">{<br/>        </strong>testLogging <strong class="mj iu">{<br/>            </strong><em class="mf">events </em>= <em class="mf">setOf</em>(<br/>                    TestLogEvent.STARTED,<br/>                    TestLogEvent.PASSED,<br/>                    TestLogEvent.FAILED<br/>            )</span><span id="b21c" class="mz na it mj b gy ou or l os ot">            <em class="mf">// show standard out and standard error of the test <br/>            // JVM(s) on the console<br/>            showStandardStreams </em>= <em class="mf">true<br/>        </em><strong class="mj iu">}<br/>    }<br/>}</strong></span></pre><p id="f310" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated"><code class="fe mg mh mi mj b">TestLogEvent</code>是一个enum(别忘了导入它)，所以如果你想记录所有事件，使用<code class="fe mg mh mi mj b">events = TestLogEvent.values().toSet()</code>。</p><p id="00e3" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">你还可以做更多的事情，<a class="od oe ep" href="https://medium.com/u/c635d6fd0ed4?source=post_page-----444cf094e69f--------------------------------" rel="noopener" target="_blank">ukasz Wasylkowski</a>写了<a class="ae kt" href="https://medium.com/@wasyl/pretty-tests-summary-in-gradle-744804dd676c" rel="noopener">一篇优秀的文章</a>展示了这些可能性。这篇文章的目标是Groovy，但是翻译起来应该不会太难。</p><blockquote class="nx ny nz"><p id="31b3" class="ku kv mf kw b kx lr ju kz la ls jx lc oa mk lf lg ob ml lj lk oc mm ln lo ks im bi translated">查看Gradle手册中的这篇文章<a class="ae kt" href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/" rel="noopener ugc nofollow" target="_blank">以获得帮助，或者在评论中留言，我会尽力帮忙的。</a></p></blockquote><h2 id="2438" class="mz na it bd nb nc nd dn ne nf ng dp nh ld ni nj nk lh nl nm nn ll no np nq nr bi translated">没有运行随机测试</h2><p id="c514" class="pw-post-body-paragraph ku kv it kw b kx ns ju kz la nt jx lc ld nu lf lg lh nv lj lk ll nw ln lo ks im bi translated">有时，测试看起来不运行，即使你发誓它们刚刚运行过。</p><p id="beaa" class="pw-post-body-paragraph ku kv it kw b kx lr ju kz la ls jx lc ld mk lf lg lh ml lj lk ll mm ln lo ks im bi translated">每当您连续多次运行<em class="mf">测试</em>任务，而没有首先对文件进行更改或运行<em class="mf">清理</em>任务时，这实际上会发生。这是有意义的——如果什么都没有改变，就不需要运行测试——但是如果你没有预料到这一点，在你弄清楚之前，它可能会令人困惑。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi pc"><img src="../Images/abdc7082a2da1a996931285b8163127b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a1fx6GcV1f_w_NNr"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">由杰夫·梅雷迪思提供</figcaption></figure></div></div>    
</body>
</html>