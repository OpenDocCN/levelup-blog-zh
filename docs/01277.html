<html>
<head>
<title>How IEnumerable.ToList() Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多么可爱。ToList()有效</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-ienumerable-tolist-works-c119a4572c1e?source=collection_archive---------11-----------------------#2019-12-10">https://levelup.gitconnected.com/how-ienumerable-tolist-works-c119a4572c1e?source=collection_archive---------11-----------------------#2019-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5ee4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">英寸NET Framework 4.x</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3ddba94fa4b663f9fa2293dd34207e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bg4-GQerFZeRjMy_"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@itsrennyman" rel="noopener ugc nofollow" target="_blank">雷纳托·波齐</a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ddee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是讨论<code class="fe ls lt lu lv b"><a class="ae kv" href="https://medium.com/@DavidKlempfner/how-ienumerable-toarray-works-4bb7a2cabada" rel="noopener">ToArray()</a></code>和<code class="fe ls lt lu lv b">ToList()</code>如何在幕后工作，以及哪一个更有效的两部分系列的最后一篇文章。</p><p id="94c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击<a class="ae kv" href="https://medium.com/@DavidKlempfner/how-ienumerable-toarray-works-4bb7a2cabada" rel="noopener">此处</a>查看第1部分。</p><h1 id="edd7" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">ToList()源代码</h1><p id="05d9" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">ToList()源代码可以在<a class="ae kv" href="https://referencesource.microsoft.com/#System.Core/System/Linq/Enumerable.cs,947" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="5f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现几乎和<code class="fe ls lt lu lv b">IEnumerable&lt;T&gt;.ToArray()</code>一模一样。</p><p id="4915" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">ToList()</code>简单地创建一个包含私有数组的新列表，该私有数组在每次迭代中被添加。</p><p id="632c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一次迭代将使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,38" rel="noopener ugc nofollow" target="_blank">defaultCapacity = 4</a></code>创建一个新数组，就像在<code class="fe ls lt lu lv b">ToArray()</code>中一样。</p><p id="90e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Capacity <a class="ae kv" href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,123" rel="noopener ugc nofollow" target="_blank"> setter </a>中，当初始数组已满时，会创建一个大小加倍的新数组。容量设置器中设置的值在<a class="ae kv" href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,405" rel="noopener ugc nofollow" target="_blank"> EnsureCapacity() </a>中计算(在<a class="ae kv" href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,220" rel="noopener ugc nofollow" target="_blank"> Add() </a>中调用)。</p><h1 id="8af2" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">与ToArray()的差异</h1><p id="2f1b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><code class="fe ls lt lu lv b">ToList()</code>和<code class="fe ls lt lu lv b">ToArray()</code>之间的唯一区别是，如果最终数组的长度与源数组的长度不一样，那么<code class="fe ls lt lu lv b">ToArray()</code>将进行最后一次精确的数组分配，以存储源数组的元素。</p><p id="8eea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着在大多数情况下，<code class="fe ls lt lu lv b">ToList()</code> <strong class="ky ir">会更有效，因为它少了一个数组分配。</strong></p><h1 id="df1b" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">当ToArray()和ToList()的性能相等时</h1><p id="e090" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">就数组分配的数量而言，这些方法唯一相同的时候(假设源不是一个<code class="fe ls lt lu lv b">ICollection&lt;T&gt;</code>)是当下列条件成立时:</p><p id="6d70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">IEnumerable&lt;T&gt;</code> <code class="fe ls lt lu lv b">x</code>中元素的数量是&gt; = 4并且是2的幂。这是因为临时数组的大小总是以前临时数组的两倍，这意味着它将从4到8到16等等，都是2的幂。</p><p id="a689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果元素的数量大于或等于初始数组大小(4)，并且是2的幂，那么当调用<code class="fe ls lt lu lv b">ToArray()</code>时，就没有必要创建一个完美大小的最终数组。</p><p id="ec15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，当调用<code class="fe ls lt lu lv b">ToList()</code>时，一个完美大小的数组永远不会被创建。</p><h2 id="ce18" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">公式</h2><p id="17ed" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><code class="fe ls lt lu lv b">x &gt;= 4</code>并且是2的幂可以用C#写成这样:</p><p id="7405" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">x &gt;= 4 &amp;&amp; ((x &amp; (x — 1)) == 0)</code></p><p id="0d47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">&amp;</code>是按位- <code class="fe ls lt lu lv b">and</code>运算符。当你得到一个2的幂的数，比这个数少1，你将总是得到0:</p><h2 id="dc8a" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">示例:</h2><p id="2b8d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><code class="fe ls lt lu lv b">8 = 1000</code></p><p id="4503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">8–1 = 7 = 0111</code></p><p id="b3a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">1000 &amp; 0111 = 0</code></p><p id="5ace" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不确定这什么时候有用，但是如果你知道从一个<code class="fe ls lt lu lv b">IEnumerable&lt;T&gt;</code>流出的元素的数量，而它不是一个<code class="fe ls lt lu lv b">ICollection&lt;T&gt;</code>，你就可以使用这个公式来决定是使用<code class="fe ls lt lu lv b">ToArray()</code>还是<code class="fe ls lt lu lv b">ToList()</code>。</p></div></div>    
</body>
</html>