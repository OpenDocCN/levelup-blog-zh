<html>
<head>
<title>Easiest Way to Understand Rust Modules Across Multiple Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跨多个文件理解Rust模块的最简单方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/easiest-way-to-understand-rust-modules-across-multiple-files-234b5018cbfd?source=collection_archive---------4-----------------------#2022-11-20">https://levelup.gitconnected.com/easiest-way-to-understand-rust-modules-across-multiple-files-234b5018cbfd?source=collection_archive---------4-----------------------#2022-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f885a90474a94b2fbb717ffc0ca6ec40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSBRdpPk-4jifXs8OWtQyQ.png"/></div></div></figure><h1 id="4d86" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="4678" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">💡不同文件中Rust模块的简单明了的解释。</li><li id="0cb3" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">🤿:我们将深入一个真实世界的例子来探索模块系统。</li><li id="e1ef" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">📈大量图表帮助你理解。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="7f18" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">Rust中的模块系统可能会让来自其他语言的开发人员感到困惑。我花了一段时间来理解它，所以我想与你分享它是如何工作的，以及如何轻松地跨多个文件组织你的程序。</p><p id="3ab2" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">我们走吧。</p><h1 id="537e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">跨文件信任模块</h1><p id="d2f9" class="pw-post-body-paragraph md me it lb b lc ld mg mh le lf mj mk lg mu mm mn li mv mp mq lk mw ms mt lm im bi translated">Rust要求开发人员手动构建模块树。方法是用关键字<strong class="lb iu"> mod </strong>声明模块。</p><p id="a817" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">模块树从板条箱根开始，通常是库板条箱的<em class="mx"> src/lib.rs </em>或二进制板条箱的<em class="mx"> src/main.rs </em>。Rust编译器将首先在crate根目录中寻找要编译的模块。</p><p id="e602" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">假设您想要在二进制机箱中导入一个模块“a ”,您可以像这样声明该模块:</p><p id="41b4" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">main.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="0546" class="nh kc it nd b be ni nj l nk nl">mod a;<br/>fn main() { /* do amazing things */ }</span></pre><p id="ee94" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">编译器将在以下位置的<em class="mx"> src </em>目录中查找模块:</p><p id="bcae" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">在<em class="mx"> src/a.rs </em></p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="3a50" class="nh kc it nd b be ni nj l nk nl">.<br/>├── Cargo.lock<br/>├── Cargo.toml<br/>└── src<br/>    ├── a.rs<br/>    └── main.rs</span></pre><p id="fcb9" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">或者在<em class="mx"> src/a/mod.rs </em>中</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="664e" class="nh kc it nd b be ni nj l nk nl">.<br/>├── Cargo.lock<br/>├── Cargo.toml<br/>└── src<br/>    ├── a<br/>    │   └── mod.rs<br/>    └── main.rs</span></pre><p id="90dc" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">通过在<em class="mx"> main.rs </em>中声明<strong class="lb iu"> mod a </strong>，您已经构建了一个模块树，如下所示:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1fc982c446eafa2fa49de02a9bb8afc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIeKOD14ki-Jj0LArQTNcQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">初始模块树</figcaption></figure><h1 id="9d41" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">跨文件信任子模块</h1><p id="d0d4" class="pw-post-body-paragraph md me it lb b lc ld mg mh le lf mj mk lg mu mm mn li mv mp mq lk mw ms mt lm im bi translated">在模块中，您可以创建子模块来进一步组织您的代码。假设您想在模块“a”中声明模块“b”和“c”:</p><p id="feb0" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">/src/a/mod.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="3d1d" class="nh kc it nd b be ni nj l nk nl">mod b;<br/>mod c;</span></pre><p id="996e" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">编译器将在<em class="mx"> src/a </em>目录中寻找子模块:</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="7da9" class="nh kc it nd b be ni nj l nk nl">.<br/>├── Cargo.lock<br/>├── Cargo.toml<br/>└── src<br/>    ├── a<br/>    │   ├── b.rs<br/>    │   ├── c.rs<br/>    │   └── mod.rs<br/>    └── main.rs</span></pre><p id="3234" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">现在你已经建立了这样一棵树:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/020e435c3f6e182dda9cf9fa3ba1c6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2SDVaZkR52_tx4R2NhJcQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">带有子模块的模块树</figcaption></figure><h1 id="0094" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">“pub”的可见性</h1><p id="587b" class="pw-post-body-paragraph md me it lb b lc ld mg mh le lf mj mk lg mu mm mn li mv mp mq lk mw ms mt lm im bi translated">默认情况下，模块中的所有<a class="ae nq" href="https://doc.rust-lang.org/reference/items.html" rel="noopener ugc nofollow" target="_blank">项</a>都是私有的。它们只对同一模块中的项目可见。</p><p id="fb19" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/a/mod.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="b0fb" class="nh kc it nd b be ni nj l nk nl">mod b;<br/>mod c;<br/><br/>fn do_a() {} // only the other functions in module a can use it<br/>             // it's not visible to main.rs</span></pre><p id="2a00" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">为了让它的父模块能够访问函数<em class="mx"> do_a </em>，我们需要添加关键字<strong class="lb iu"> pub </strong>。</p><p id="cdac" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/a/mod.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="8a1f" class="nh kc it nd b be ni nj l nk nl">pub fn do_a() {} // now it's visible to main.rs</span></pre><p id="4212" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">我们可以使用<a class="ae nq" href="https://doc.rust-lang.org/reference/paths.html" rel="noopener ugc nofollow" target="_blank">路径限定符<em class="mx"> :: </em> </a>来访问<em class="mx"> do_a </em>。</p><p id="93da" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/main.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="4dfc" class="nh kc it nd b be ni nj l nk nl">mod a;<br/><br/>fn main() {<br/>    a::do_a();<br/>}</span></pre><p id="e89c" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">我们可以对子模块使用相同的模式。</p><p id="7aef" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/a/b.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="285c" class="nh kc it nd b be ni nj l nk nl">pub fn do_b() {} // visible to module "a" and all the submodules of module "a"</span></pre><p id="58c0" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">通过将<strong class="lb iu"> pub </strong>添加到<em class="mx"> do_b </em>，模块“a”现在可以访问该功能。</p><p id="5300" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/a/mod.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="dcfd" class="nh kc it nd b be ni nj l nk nl">mod b;<br/>mod c;<br/><br/>pub fn do_a {<br/>    b::do_b();<br/>}</span></pre><p id="965d" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">模块“c”的子模块也可以访问do_b。您可以使用绝对路径或相对路径来访问它。</p><p id="a927" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/a/c.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="df18" class="nh kc it nd b be ni nj l nk nl">pub fn do_c {<br/>    crate::a::b::do_b(); // absolute path<br/>    super::b::do_b(); // relative path<br/>}</span></pre><h1 id="0ca8" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">重新导出项目</h1><p id="f5a6" class="pw-post-body-paragraph md me it lb b lc ld mg mh le lf mj mk lg mu mm mn li mv mp mq lk mw ms mt lm im bi translated">非父模块无法访问子模块的项目。例如，我们可以尝试访问<em class="mx"> main.rs </em>中的<em class="mx"> do_b </em></p><p id="31f8" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/main.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="0bd2" class="nh kc it nd b be ni nj l nk nl">mod:a;<br/><br/>fn main() {<br/>    a::b::do_b();<br/>    // ^^^^ function `do_b` is private<br/>}</span></pre><p id="1f75" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">你会看到一个错误消息，说<em class="mx"> do_b </em>是私有的。这是因为目前为止<em class="mx"> do_b </em>只能在模块“a”中访问。为了使它对板条箱根可见，我们需要通过将<strong class="lb iu">发布</strong>添加到模块“a”的模块“b”声明中来重新导出它。</p><p id="f007" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/a/mod.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="915e" class="nh kc it nd b be ni nj l nk nl">pub mod b;<br/>// --snip--</span></pre><h1 id="341b" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">“使用”声明</h1><p id="2637" class="pw-post-body-paragraph md me it lb b lc ld mg mh le lf mj mk lg mu mm mn li mv mp mq lk mw ms mt lm im bi translated"><a class="ae nq" href="https://doc.rust-lang.org/reference/items/use-declarations.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">使用</strong> </a>声明可以帮助您在访问另一个模块中的项目时缩短路径。例如，我们可以重构模块“a”:</p><p id="83f1" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/a/mod.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="c8d1" class="nh kc it nd b be ni nj l nk nl">mod b;<br/>mod c;<br/><br/>use b::do_b;<br/>use c::do_c;<br/><br/>pub fn do_a {<br/>    do_b();<br/>    do_c();<br/>}</span></pre><p id="1b4e" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">它为<em class="mx"> do_b </em>和<em class="mx"> do_c </em>创建一个绑定到其路径的本地名称。<strong class="lb iu">使用</strong>对于长路径非常有用。</p><h1 id="0d58" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">真实世界的例子</h1><p id="8fb6" class="pw-post-body-paragraph md me it lb b lc ld mg mh le lf mj mk lg mu mm mn li mv mp mq lk mw ms mt lm im bi translated">为了演示Rust的模块系统，我创建了一个名为<strong class="lb iu"> affme </strong>的简单CLI，是“affirm me”的缩写。</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/594f19383729f74f551ffa682504b5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hHa-HNE-ryOhiG0tTnrZgw.gif"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">演示</figcaption></figure><p id="fae5" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated"><strong class="lb iu"> affme </strong>是一个自我肯定生成器。CLI接受一个名称作为参数，并显示随机确认。</p><blockquote class="ns nt nu"><p id="392c" class="md me mx lb b lc mf mg mh le mi mj mk nv ml mm mn nw mo mp mq nx mr ms mt lm im bi translated"><em class="it">演示是GitHub </em>  <em class="it">上提供的</em> <a class="ae nq" href="https://github.com/DawChihLiou/affme" rel="noopener ugc nofollow" target="_blank"> <em class="it">。请随意看一看回购，并尝试它out✨ </em></a></p></blockquote><p id="ef43" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">代码设计很简单:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2416431e43ea046d35206c0dd52976f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__SpEaGL4RwXx3dh1U7vAQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">代码设计</figcaption></figure><p id="03c1" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">在“格式”块中，</p><ul class=""><li id="49d9" class="kz la it lb b lc mf le mi lg ny li nz lk oa lm ln lo lp lq bi translated">它接受用户输入，</li><li id="4ab7" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">将输入与随机肯定和随机表情连接起来，</li><li id="8efe" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">将随机字体颜色应用于连接的确认，</li><li id="f1cb" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">并最终输出确认。</li></ul><p id="27a0" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">为了展示跨文件的模块系统，我设计了如下的模块树:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d0a833e6f4e85a44f1f27f0256512871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MqPMvdPzW5YvWjhCdX3iA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">affme模块树</figcaption></figure><p id="93a5" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">有几件事值得一提:</p><ul class=""><li id="53a2" class="kz la it lb b lc mf le mi lg ny li nz lk oa lm ln lo lp lq bi translated">这个包有两个板条箱，一个二进制和一个库。我使用库箱来封装实现，使用二进制箱来执行CLI。</li><li id="1286" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">在库箱根<em class="mx"> src/lib.rs </em>中，从<em class="mx">肯定</em>和<em class="mx">格式化模块</em>中访问函数。</li><li id="07cf" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><em class="mx">肯定</em>模块和<em class="mx">格式器</em>模块中的两个子模块正在使用<em class="mx">随机</em>模块中的相同函数来随机选取一个项目。因为<em class="mx">肯定</em>模块和<em class="mx">格式化器</em>子模块在树的不同分支，我们需要在模块树的共同祖先中声明<em class="mx">随机</em>模块。</li></ul><p id="263f" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">在文件系统中，它看起来像这样:</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="afff" class="nh kc it nd b be ni nj l nk nl">.<br/>├── Cargo.lock<br/>├── Cargo.toml<br/>├── src<br/>│   ├── affirmation.rs<br/>│   ├── formatter<br/>│   │   ├── color.rs<br/>│   │   ├── emoji.rs<br/>│   │   └── mod.rs<br/>│   ├── lib.rs<br/>│   ├── main.rs<br/>│   └── random.rs<br/>└── target</span></pre><p id="b8f6" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">让我们深入库的根目录，看看代码是如何构造的。</p><p id="d561" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">资源中心/图书馆</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="6295" class="nh kc it nd b be ni nj l nk nl">mod affirmation;<br/>mod formatter;<br/>mod random;<br/><br/>use affirmation::Affirmation;<br/>use formatter::format;<br/><br/>pub fn affirm(name: &amp;str) -&gt; String {<br/>    let affirmation = Affirmation::new().random();<br/>    format(affirmation, name)<br/>}</span></pre><p id="38f0" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">在这里，您可以在顶部看到模块声明。你也可以找到<em class="mx">使用</em>声明为<em class="mx">断言</em>和<em class="mx">格式</em>创建局部名称绑定。</p><p id="f1d9" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">随机模块很简单:</p><p id="441f" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/随机. rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="3b6e" class="nh kc it nd b be ni nj l nk nl">use rand::Rng;<br/><br/>pub fn pick&lt;'a, T: ?Sized&gt;(items: &amp;[&amp;'a T]) -&gt; &amp;'a T {<br/>    let random_index: usize = rand::thread_rng().gen_range(0..items.len());<br/>    items.get(random_index).unwrap()<br/>}</span></pre><p id="9026" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">它有一个公共的<em class="mx"> pick </em>函数，从数组切片中返回一个随机项。我用这个功能来选择随机的肯定、表情符号和颜色。让我们以<em class="mx">肯定</em>模块为例来看看:</p><p id="4cd8" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/affirmation.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="cf70" class="nh kc it nd b be ni nj l nk nl">use crate::random;<br/><br/>#[derive(Debug)]<br/>pub struct Affirmation&lt;'a&gt; {<br/>    affirmations: [&amp;'a str; 6],<br/>}<br/><br/>impl&lt;'a&gt; Affirmation&lt;'a&gt; {<br/>    pub fn new() -&gt; Self {<br/>        let affirmations = [<br/>            "You're beautiful",<br/>            "You're awesome",<br/>            "You're wonderful",<br/>            "You've got this",<br/>            "You can do all things",<br/>            "Go get it",<br/>        ];<br/>        Affirmation { affirmations }<br/>    }<br/>    <br/>    pub fn random(&amp;self) -&gt; &amp;'a str {<br/>        random::pick(&amp;self.affirmations)<br/>    }<br/>}</span></pre><p id="ba9a" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">你可以看到<em class="mx">为<em class="mx">随机</em>模块使用</em>声明。<em class="mx">肯定</em>模块能够访问<em class="mx">随机</em>模块，因为<em class="mx">随机</em>模块是在库机箱根目录中声明的。我在<em class="mx">断言</em>结构及其函数上使用了<em class="mx"> pub </em>关键字，这样crate root就可以看到它们。</p><p id="1471" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">你可以在<em class="mx">表情符号</em>和<em class="mx">颜色</em>子模块中找到相同的编码模式。</p><p id="d1f5" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">要把这些都集合起来，我们来看看<em class="mx">格式</em>模块。</p><p id="1538" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">src/formatter/mod.rs</p><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="1ada" class="nh kc it nd b be ni nj l nk nl">mod color;<br/>mod emoji;<br/><br/>use color::Color;<br/>use colored::*;<br/>use emoji::Emoji;<br/><br/>pub fn format(affirmation: &amp;str, name: &amp;str) -&gt; String {<br/>    let emoji = Emoji::new();<br/>    let color = Color::new();<br/><br/>    let phrase = format!("{}, {} {}", affirmation, name, emoji.random())<br/>        .color(color.random())<br/>        .bold()<br/>        .to_string();<br/><br/>    format!(<br/>        "{}\n{}\n{}\n{}\n{}",<br/>        "*".repeat(phrase.len() + 2).magenta(),<br/>        format!("*{}*", " ".repeat(phrase.len())).magenta(),<br/>        format!("    ✏️  ...{}  ", phrase,),<br/>        format!("*{}*", " ".repeat(phrase.len())).magenta(),<br/>        "*".repeat(phrase.len() + 2).magenta()<br/>    )<br/>}</span></pre><p id="1380" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">它在范围内引入了<em class="mx">颜色</em>和<em class="mx">表情符号</em>子模块，因此我们可以用随机表情符号和随机字体颜色连接完整确认。</p><h1 id="8362" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">最后的想法</h1><p id="259a" class="pw-post-body-paragraph md me it lb b lc ld mg mh le lf mj mk lg mu mm mn li mv mp mq lk mw ms mt lm im bi translated">跨多个文件的Rust模块与其他语言略有不同，但是一旦你理解了<strong class="lb iu"> mod </strong>、<strong class="lb iu"> use </strong>和<strong class="lb iu"> pub </strong>，模块设计就变得更加容易和有目的了。</p><p id="bb89" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated"><strong class="lb iu"> Rust模块备忘单</strong></p><ul class=""><li id="2577" class="kz la it lb b lc mf le mi lg ny li nz lk oa lm ln lo lp lq bi translated">模块树从机箱根开始。</li><li id="aaea" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">使用<strong class="lb iu"> mod </strong>用模块和子模块构建你的树。</li><li id="f2f9" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">使用<strong class="lb iu">发布</strong>使模块项目对父模块可见。</li><li id="90e5" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">你可以用<strong class="lb iu"> pub mod </strong>或者<strong class="lb iu"> pub use </strong>重新导出。</li></ul><h1 id="98e4" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">参考</h1><ul class=""><li id="98b7" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><a class="ae nq" href="https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html" rel="noopener ugc nofollow" target="_blank">书:定义控制范围和隐私的模块Rust编程语言</a></li><li id="2d02" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nq" href="https://doc.rust-lang.org/reference/items/use-declarations.html" rel="noopener ugc nofollow" target="_blank">书:使用声明—生锈参考</a></li><li id="552a" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nq" href="https://doc.rust-lang.org/reference/items.html" rel="noopener ugc nofollow" target="_blank">书:物品—铁锈参考</a></li><li id="8956" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nq" href="https://doc.rust-lang.org/reference/items/modules.html" rel="noopener ugc nofollow" target="_blank">书:模块—生锈参考</a></li><li id="150f" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nq" href="https://doc.rust-lang.org/reference/paths.html" rel="noopener ugc nofollow" target="_blank">图书:路径—生锈参考</a></li><li id="42d0" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nq" href="https://spin.atomicobject.com/2022/01/24/rust-module-system/" rel="noopener ugc nofollow" target="_blank">文章:如何跨不同文件使用Rust模块— Casey Falkowski </a></li><li id="55f9" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nq" href="https://github.com/DawChihLiou/affme" rel="noopener ugc nofollow" target="_blank"> GitHub: affme资源库</a></li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><pre class="my mz na nb gt nc nd ne bn nf ng bi"><span id="d630" class="nh kc it nd b be ni nj l ob nl">Want to Connect? This article was originally posted on <a class="ae nq" href="https://dawchihliou.github.io/articles/easiest-way-to-understand-rust-modules-across-multiple-files" rel="noopener ugc nofollow" target="_blank">Daw-Chih’s website</a>.</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f497" class="kb kc it bd kd ke oc kg kh ki od kk kl km oe ko kp kq of ks kt ku og kw kx ky bi translated">分级编码</h1><p id="a01e" class="pw-post-body-paragraph md me it lb b lc ld mg mh le lf mj mk lg mu mm mn li mv mp mq lk mw ms mt lm im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="5390" class="kz la it lb b lc mf le mi lg ny li nz lk oa lm ln lo lp lq bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="49ab" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">📰查看<a class="ae nq" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="efe8" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">🔔关注我们:<a class="ae nq" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae nq" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae nq" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="78cc" class="pw-post-body-paragraph md me it lb b lc mf mg mh le mi mj mk lg ml mm mn li mo mp mq lk mr ms mt lm im bi translated">🚀👉<a class="ae nq" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>