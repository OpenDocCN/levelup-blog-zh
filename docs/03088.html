<html>
<head>
<title>The Epsilon-Delta Proof for the Pythonista and the Hypothesis testing framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pythonista的ε-δ证明和假设检验框架</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-epsilon-delta-proof-for-the-pythonista-264acf8b88f6?source=collection_archive---------14-----------------------#2020-04-18">https://levelup.gitconnected.com/the-epsilon-delta-proof-for-the-pythonista-264acf8b88f6?source=collection_archive---------14-----------------------#2020-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b595" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">命题类型解释</em>声明<em class="kl">证明是程序</em>。这一点的意义主要适用于<em class="kl">函数式编程</em>，所以让我们首先用约束来限制python空间。</p><p id="d23e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你只是来看看假设的实际情况，滚动一下吧！</p><ol class=""><li id="5af8" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">我们将处理<em class="kl">总函数</em>，意思是如果我说<code class="fe kv kw kx ky b">def f(x: float) -&gt; float:</code>，我的意思是你可以给<code class="fe kv kw kx ky b">f</code> <strong class="jp ir">任何</strong>浮点。我可能使用的一个词汇是“签名”，在这种情况下，<code class="fe kv kw kx ky b">f</code>的“签名”(或其“类型签名”或只是“类型”)是<code class="fe kv kw kx ky b">float -&gt; float</code>，意味着它的<em class="kl">输入</em>或<em class="kl">自变量</em>类型是<code class="fe kv kw kx ky b">float</code>，它的<em class="kl">输出</em>或<em class="kl">返回</em>类型是<code class="fe kv kw kx ky b">float</code>。</li><li id="d209" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated">我们将处理<em class="kl">纯函数</em>，这意味着如果我说<code class="fe kv kw kx ky b">f</code>是一个函数，我的意思是<strong class="jp ir">它的行为完全受其签名</strong>的约束，我可以通过提供输入来测试它，不做任何其他事情。如果我需要通过模拟状态或运行无头浏览器来测试它，那么它就不是纯粹的<em class="kl">。</em></li><li id="7963" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated"><em class="kl">总计</em>和<em class="kl">纯</em>的函数是<strong class="jp ir">确定性的</strong>，意味着任何人都可以在<code class="fe kv kw kx ky b">2</code>、<code class="fe kv kw kx ky b">f(2) == f(2)</code>调用<code class="fe kv kw kx ky b">f</code>的每一个状态。如果<code class="fe kv kw kx ky b">f(2) == 3</code>在您的控制台中是星期二，那么<code class="fe kv kw kx ky b">f(2) == 3</code>在您的CI环境中是星期三。</li></ol><p id="519f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你不太可能看到真实世界的软件完全遵守这些约束，但也不是不可能。然而，数学并不那么卑鄙。事实上，遵守这些约束让你的python更像数学:数学家所说的“函数”相当于函数式程序员所向往的约束。(再看一下决定论约束。现在回想一下前微积分中的“垂直线测试”。练习:两者有什么关系？)</p><h2 id="5484" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">极限的ε-δ概念</h2><p id="f366" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这不是一篇从头开始教授极限的博文。如果你只是想了解足够多的微积分来欣赏python，那么在KhanAcademy 上快速观看<a class="ae mc" href="https://youtu.be/-ejyeII0i5c" rel="noopener ugc nofollow" target="_blank">这个视频。</a></p><p id="b61b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，我们关心的是在<code class="fe kv kw kx ky b">x</code>方向上<em class="kl">摆动</em>和在<code class="fe kv kw kx ky b">y</code>方向上<em class="kl">摆动</em>之间的关系——一个对另一个施加约束吗？我们如何改进我们的摆动行为来更好地理解手边的功能？</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/b64274ffef574957dbbe8d72fff9a72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ywyp0Ck40lXZrWnuFb4TaQ.jpeg"/></div></div></figure><p id="1d32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章讨论了极限的ε-δ概念的语言逻辑结构，把几何学留给了其他资源。这个概念可以用符号<em class="kl">来表达</em>，事实上，如果你愿意，你可以独立于视觉来理解它。简而言之，将象征性地给出极限的定义，并从这个定义中提取一个证明策略。</p><p id="c2a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">采取一些距离函数<code class="fe kv kw kx ky b">dist</code>——我们将使用以下定义的其余职位:</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="a939" class="le lf iq ky b gy mt mu l mv mw">def dist(x: float, y: float) -&gt; float: <br/>  return abs(x - y)</span></pre><p id="3fcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在拿某个<code class="fe kv kw kx ky b">f : D -&gt; R</code>来说，它有一个定义域(可能是实数的区间子集)，它返回一个实数。(这有点像有一个 <code class="fe kv kw kx ky b"><em class="kl">float</em></code>的<em class="kl">返回类型)。您对<code class="fe kv kw kx ky b">f</code>关于其定义域中某个数字<code class="fe kv kw kx ky b">a</code>的行为感兴趣。</em></p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="e4af" class="le lf iq ky b gy mt mu l mv mw">the limit as x goes to a of f(x) == f(a) <br/>if and only if <br/>forall eps &gt; 0, (there) exists delt &gt; 0, (such that) forall x in D,       if dist(x, a) &lt; delt then dist(f(x), f(a)) &lt; eps</span></pre><p id="13ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来复习一下<em class="kl">量词</em>。量词有两种——<strong class="jp ir">全称量词</strong>的意思是“代表每一个”或“代表所有”。我们说我们正在通过<em class="kl">量化一个集合/类型的所有</em>元素。另一类是<strong class="jp ir">存在量词</strong>，表示“存在”或“至少有一个”。量化可以被认为是一个<em class="kl">游戏</em>，你的对手出招，你也出招。你无法控制对手的走法(你无法控制<em class="kl">他们会选择哪个</em> <code class="fe kv kw kx ky b">eps &gt; 0</code>)，但你可以控制自己的走法(你可以<em class="kl">选择</em> a <code class="fe kv kw kx ky b">delt &gt; 0</code>)。</p><p id="b3e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在极限的定义中，注意量词的<em class="kl">节奏。注意他们<em class="kl">交替</em> : <code class="fe kv kw kx ky b">forall... exists... forall...</code>。这很关键。每个连续的量化变量<em class="kl">依赖于</em>之前的变量。所以当你看到<code class="fe kv kw kx ky b">forall eps, exists delt, ...</code>的时候你就已经知道<code class="fe kv kw kx ky b">delt</code>是“eps的一个函数”，具体来说就是数字<code class="fe kv kw kx ky b">delt</code>是输入<code class="fe kv kw kx ky b">eps</code>的某个函数的输出。换句话说，当我的对手选择一个<code class="fe kv kw kx ky b">eps</code>时，我可以在我的<code class="fe kv kw kx ky b">delt</code>计算中<em class="kl">使用那个<code class="fe kv kw kx ky b">eps</code>的</em>。最后，<em class="kl">命题</em> <code class="fe kv kw kx ky b">if dist(x, a) &lt; delt then dist(f(x), f(a)) &lt; eps</code>是<em class="kl">依赖</em>于<em class="kl">之前的一切</em>。</em></p><h1 id="407b" class="mx lf iq bd lg my mz na lj nb nc nd lm ne nf ng lp nh ni nj ls nk nl nm lv nn bi translated">让我们开始将这个定义翻译成Python。</h1><p id="019e" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">你认为<code class="fe kv kw kx ky b">forall eps</code>的Python含义是什么？练习:回顾到目前为止的帖子，思考5分钟(字面上的墙时间),试着预测我要做什么。</p><p id="23e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会插入一段猴子喝果汁的视频，帮助你不要提前阅读。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9308" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回想一下我们的总体约束。根据总体约束，对于每个输入，在<em class="kl">上定义一个函数。所以如果你声明<code class="fe kv kw kx ky b">def f(x: int) -&gt; bool:</code>，你有义务确保它不会在-2895或42或57上失败，因为那些都是<code class="fe kv kw kx ky b">int</code>并且你声明你可以把<em class="kl">任何</em> <code class="fe kv kw kx ky b">int</code>变成<code class="fe kv kw kx ky b">bool</code>。我选择的斜体字泄露了吗？当你声明你可以将<em class="kl">任意</em> <code class="fe kv kw kx ky b">A</code>转化为<code class="fe kv kw kx ky b">B</code>时，你就是在声明你可以将<em class="kl">每</em> <code class="fe kv kw kx ky b">A</code>转化为<code class="fe kv kw kx ky b">B</code>，所以我们将<code class="fe kv kw kx ky b">forall eps</code>类比为<em class="kl">函数声明</em>。</em></p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="098f" class="le lf iq ky b gy mt mu l mv mw"># assume f, a are known and in scope <br/>def proof_scope_1(eps):</span></pre><p id="9b94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是有道理的:当你写一个函数时，你不一定知道将要提供什么参数。如果你这样做，你会写常数而不是函数。正如一个函数在<em class="kl">编译时</em>不知道它的参数会是什么，你也不知道在<em class="kl">校对时</em>你的对手会怎么做。把调用函数的人<em class="kl">当成你的对手，而不是你。</em></p><p id="6726" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Python的类型提示系统不够精炼，无法表达<em class="kl">正实数</em>，所以我完全省略了类型签名。如果我想，我可以写</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="5448" class="le lf iq ky b gy mt mu l mv mw">def proof_scope_1(eps: float): <br/>  assert eps &gt; 0<br/>  ...</span></pre><p id="2160" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来表示<code class="fe kv kw kx ky b">eps</code>是一个正实数，但它并不完全真实——那么函数就不会在其所有的输入类型上定义，因为它会在带有<code class="fe kv kw kx ky b">AssertionError</code>的<code class="fe kv kw kx ky b">eps = -1.0</code>上失败。</p><p id="c4e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们继续。</p><p id="d799" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kv kw kx ky b">forall eps &gt; 0, exists delt &gt; 0</code>:</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="50a7" class="le lf iq ky b gy mt mu l mv mw"># assume f, a are known and in scope<br/>def proof_scope_1(eps): <br/>  # select some function `foo`<br/>  delt = foo(eps)</span></pre><p id="30ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当轮到你时，你可以选择一个数字，这个数字可能取决于<code class="fe kv kw kx ky b">eps</code>。我们来观察一个例子。</p><p id="bead" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设<code class="fe kv kw kx ky b">f = lambda x: m * x</code>为某常数<code class="fe kv kw kx ky b">m</code>。稍后，我们将研究这个例子。现在，我只给那个<em class="kl">我们选择</em> <code class="fe kv kw kx ky b">foo = lambda eps: eps / abs(m)</code>。既然<code class="fe kv kw kx ky b">delt</code>可以是<code class="fe kv kw kx ky b">eps</code>的任何函数，只要结果是严格正的，我们的任务就是选择<em class="kl">我们需要的<code class="fe kv kw kx ky b">eps</code>的</em>函数。</p><p id="dcc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续定义。<code class="fe kv kw kx ky b">forall eps &gt; 0, exists delt &gt; 0, forall x in D</code>:</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="f38b" class="le lf iq ky b gy mt mu l mv mw"># assume f, a are known and in scope<br/>def proof_scope_1(eps): <br/>  delt = foo(eps) # select an appropriate foo<br/>  def proof_scope_2(x):</span></pre><p id="4315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kv kw kx ky b">forall</code>再次用<code class="fe kv kw kx ky b">def</code>表示。</p><p id="debe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了把它全部包含进来，我们将把核心命题表示为一个程序。程序将由量词限定范围，失败意味着你无法提供一个证明(你无法提供正确的<code class="fe kv kw kx ky b">foo</code>)。</p><p id="f8f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kv kw kx ky b">if dist(x, a) &lt; delt then dist(f(x), f(a)) &lt; eps</code>:</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="890b" class="le lf iq ky b gy mt mu l mv mw">if dist(x, a) &lt; delt: <br/>  assert dist(f(x), f(a)) &lt; eps</span></pre><h1 id="6ff9" class="mx lf iq bd lg my mz na lj nb nc nd lm ne nf ng lp nh ni nj ls nk nl nm lv nn bi translated">从程序中提取证明大纲</h1><p id="7ebe" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在本节中，我们将更仔细地检查<code class="fe kv kw kx ky b">lambda x: m * x</code>示例。</p><p id="7812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从底部开始，写下断言，看看我们是否能把它变成一个可行的表达式，并找到一个值<code class="fe kv kw kx ky b">foo</code>。就是这样！</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="9716" class="le lf iq ky b gy mt mu l mv mw">dist(f(x), f(a)) &lt; eps # unfold dist, f <br/>abs(m*x - m*a) &lt; eps # distributivity <br/>abs(m * (x - a)) &lt; eps # a lemma about abs and multiplication <br/>abs(m) * abs(x - a) &lt; eps # divide both sides by abs(m) <br/>abs(x - a) &lt; eps / abs(m) # fold dist <br/>dist(x, a) &lt; eps / abs(m) # our value of foo is lambda eps: eps / abs(m)</span></pre><p id="5b14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们注意到<code class="fe kv kw kx ky b">dist(x, a)</code>是条件句！换句话说，我们已经通过证明<code class="fe kv kw kx ky b">if dist(x, a) &lt; eps / abs(m): assert dist(f(x), f(a)) &lt; eps</code>总是成功的代数向后工作。如果它使用了一个<code class="fe kv kw kx ky b">bool</code>而不是<code class="fe kv kw kx ky b">assert</code> ing，它将总是返回<code class="fe kv kw kx ky b">True</code></p><h1 id="5a97" class="mx lf iq bd lg my mz na lj nb nc nd lm ne nf ng lp nh ni nj ls nk nl nm lv nn bi translated">基于属性的假设测试</h1><p id="1721" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">证明不是单元测试。但是在通过函数<code class="fe kv kw kx ky b">defs</code>对进行了范围限定之后，我将这个命题表示为一个<code class="fe kv kw kx ky b">assert</code>。我还想在一个比python的类型更有表现力的系统中展示一下<em class="kl">这段代码实际上是在运行</em>。</p><p id="b055" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于属性的测试是一种使单元测试尽可能像证据一样的自动化方法。今天，我们将使用测试框架<a class="ae mc" href="https://hypothesis.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">假设</a>。从文件上看</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="7eab" class="le lf iq ky b gy mt mu l mv mw">Think of a normal unit test as being something like the following: 1. Set up some data. <br/>2. Perform some operations on the data. <br/>3. Assert something about the result. <br/>Hypothesis lets you write tests which instead look like this: <br/>1. For all data matching some specification. <br/>2. Perform some operations on the data. <br/>3. Assert something about the result. <br/>This is often called property-based testing, and was popularised by the Haskell library Quickcheck.</span></pre><p id="ca43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看您的项目目录。我将假设你已经安装了python 3，并且我不会涵盖虚拟环境(尽管你应该使用它们而不是随意地T2)。</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="f201" class="le lf iq ky b gy mt mu l mv mw">mkdir epsdelt &amp;&amp; cd epsdelt <br/>pip install hypothesis <br/>vim line_is_continuous.py # text editor of your choice</span></pre><p id="959f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在你喜欢的文本编辑器中，开始粘贴上面的函数和嵌套函数。然后，在顶部插入以下导入内容</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="9e15" class="le lf iq ky b gy mt mu l mv mw">from hypothesis import given<br/>from hypothesis.strategies import floats</span></pre><p id="2d07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设的工作原理是<em class="kl">用数据生成指令以简单明了的语法修饰你的函数。</em></p><p id="3cf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想测试严格的正浮点数<code class="fe kv kw kx ky b">eps</code>，我们继续:</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="2348" class="le lf iq ky b gy mt mu l mv mw">@given(eps=floats().filter(lambda x: x &gt; 0))<br/>def proof_scope_1(eps): <br/>  ...</span></pre><p id="8215" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用一些紧凑的区间<code class="fe kv kw kx ky b">D</code>，表示为一个左端点和右端点的元组。</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="0b7c" class="le lf iq ky b gy mt mu l mv mw">  ...<br/>  @given(x=floats().filter(lambda x: D[0] &lt;= x &lt;= D[1]))<br/>  def proof_scope_2(x): <br/>    ...</span></pre><p id="80b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在称你为“测试”</p><pre class="me mf mg mh gt mp ky mq mr aw ms bi"><span id="8dc5" class="le lf iq ky b gy mt mu l mv mw">if __name__=='__main__': <br/>  proof_scope_1()</span></pre><p id="02d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您不需要提供任何参数，因为装饰者会为您处理它。</p><p id="ebaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的shell中，您现在可以运行<code class="fe kv kw kx ky b">python line_is_continuous.py</code>来查看我是否对您隐瞒了<code class="fe kv kw kx ky b">foo</code>的值！</p><p id="9f3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，Hypothesis希望我们更改一些设置，我将增加测试输出的详细程度。完整的文档如下所示。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="nq np l"/></div></figure><p id="b7fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面，我提到类型提示不能表达我感兴趣的东西。在python中，我没有严格的正浮点数类型。另一方面，假设允许我用它的<code class="fe kv kw kx ky b">.filter(lambda</code>语法来表达这一点。</p><p id="60ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您现在已经:</p><ul class=""><li id="50ab" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk nr ks kt ku bi translated">亲身经历了逻辑作用域和编程作用域之间的类比(主要是通过将<code class="fe kv kw kx ky b">forall</code>与<code class="fe kv kw kx ky b">def</code>联系起来)。</li><li id="7256" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk nr ks kt ku bi translated">测试你的程序在真实的计算机上运行，并有真实的输入</li></ul><p id="3727" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的下一步是尝试打破它。</p><p id="6b63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修改<code class="fe kv kw kx ky b">foo</code>的值，使第15行为<code class="fe kv kw kx ky b">delt = (eps + 1) / abs(m)</code>。通过预测将会发生什么来测试你对极限的ε-δ概念的理解。同样尝试:<code class="fe kv kw kx ky b">(eps - 1) / abs(m)</code>、<code class="fe kv kw kx ky b">1 / abs(m)</code>、<code class="fe kv kw kx ky b">eps</code>并预测各自会发生什么。</p><p id="d3c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我把这作为一个练习。</p><p id="daa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进一步练习—将<code class="fe kv kw kx ky b">m</code>、<code class="fe kv kw kx ky b">a</code>和<code class="fe kv kw kx ky b">D</code>抽象成函数，并对其进行假设检验。记住- <code class="fe kv kw kx ky b">a</code>必须位于<code class="fe kv kw kx ky b">D</code>，否则测试用例将无效！</p><p id="b93e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">脚注:</p><ol class=""><li id="76a3" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">我们实际做的是使用<em class="kl">连续性</em>的极限定义。</li><li id="33be" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated">在<em class="kl">依赖类型理论</em>中有一个更强的概念叫做<em class="kl"> Pi类型</em>，它将函数和条件归纳成高度相似的结构。今天我想不出用python来恶搞它的方法，所以现在我们必须坚持比较<code class="fe kv kw kx ky b">forall</code>和<code class="fe kv kw kx ky b">def</code>，把条件句当成它们自己的事情。</li><li id="bf3e" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated">将单元测试与证明相比较，甚至是基于属性的测试，实际上是非常误导人的。涉及<code class="fe kv kw kx ky b">forall</code>的证明不是“我们测试了这么多案例，我确信我们错过一个重要案例的可能性微乎其微”，这是一个更强的想法。关键的重叠是我可以<strong class="jp ir">破坏</strong>测试，就像我提交错误的证明一样。</li></ol></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="78be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于</em><a class="ae mc" href="https://gist.github.com/quinn-dougherty/b797df014636756dad234c14fa9f33e3" rel="noopener ugc nofollow" target="_blank"><em class="kl"/></a><em class="kl">。</em></p></div></div>    
</body>
</html>