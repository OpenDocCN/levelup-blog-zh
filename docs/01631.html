<html>
<head>
<title>Node.js FS Module — Creating Directories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js FS模块-创建目录</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-fs-module-creating-directories-4b0dbcd761ed?source=collection_archive---------5-----------------------#2020-01-17">https://levelup.gitconnected.com/node-js-fs-module-creating-directories-4b0dbcd761ed?source=collection_archive---------5-----------------------#2020-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/27fe96c6a855e373af2452fc708ba7e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eHwzRCbP3RpXPx1n"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@rotalex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexandru Rotariu </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="29eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">操作文件和目录是任何程序的基本操作。因为Node.js是一个服务器端平台，可以直接与运行它的计算机交互，所以能够操作文件是一个核心特性。</p><p id="5888" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，Node.js的库中内置了<code class="fe le lf lg lh b">fs</code>模块。它有许多功能，可以帮助操纵文件和文件夹。支持的文件和目录操作包括基本的操作，如操作和打开目录中的文件。</p><p id="0278" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，它也可以对文件做同样的事情。它可以同步和异步地做到这一点。它有一个异步API，该API具有支持承诺的功能。</p><p id="e688" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它还可以显示文件的统计数据。几乎所有我们能想到的文件操作都可以用内置的<code class="fe le lf lg lh b">fs</code>模块来完成。在本文中，我们将使用<code class="fe le lf lg lh b">mkdir</code>和<code class="fe le lf lg lh b">mkdtemp</code>系列函数创建目录，分别创建正常目录和临时目录。</p><h1 id="07a6" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用fs.mkdir系列函数创建永久目录</h1><p id="61e7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">为了创建永久目录，我们可以使用<code class="fe le lf lg lh b">mkdir</code>函数来异步创建它们。它需要三个参数。第一个参数是路径对象，可以是字符串、缓冲区对象或URL对象。</p><p id="7835" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是一个具有各种属性的对象，我们可以将这些属性设置为选项。</p><p id="6aed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">recursive</code>属性是一个布尔属性，如果不是所有的级别都存在，它允许我们创建目录的所有级别。<code class="fe le lf lg lh b">recursive</code>属性的默认值是<code class="fe le lf lg lh b">false</code>。</p><p id="fa7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性是一个八进制数属性，我们为POSIX系统设置了目录的权限和粘性位。Windows不支持此选项。</p><p id="8d26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">mode</code>的默认值是<code class="fe le lf lg lh b">0o777</code>，对于每个人都是可读、可写、可执行的。</p><p id="6a4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">mode</code>整数也可以代替options对象作为第二个参数。第三个参数是一个回调函数，它在目录创建操作完成时被调用。</p><p id="9fab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数接受一个<code class="fe le lf lg lh b">err</code>参数，当操作成功时该参数为<code class="fe le lf lg lh b">null</code>，否则该函数有一个包含错误信息的对象。</p><p id="803e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当路径是一个存在的目录时调用<code class="fe le lf lg lh b">mkdir</code>只会在<code class="fe le lf lg lh b">recursive</code>选项设置为<code class="fe le lf lg lh b">false</code>时导致错误。</p><p id="28bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像下面的代码一样使用<code class="fe le lf lg lh b">mkdir</code>函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e176" class="mt lj it lh b gy mu mv l mw mx">const fs = require("fs");<br/>const dirToCreate = "./files/createdFolder/createdFolder";</span><span id="6796" class="mt lj it lh b gy my mv l mw mx">fs.mkdir(<br/>  dirToCreate,<br/>  {<br/>    recursive: true,<br/>    mode: 0o77<br/>  },<br/>  err =&gt; {<br/>    if (err) {<br/>      throw err;<br/>    }<br/>    console.log("Directory created!");<br/>  }<br/>);</span></pre><p id="dfd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，我们可以看到，自从我们将<code class="fe le lf lg lh b">recursive</code>设置为<code class="fe le lf lg lh b">true</code>以来，它为最低级别的目录创建了所有的父目录。</p><p id="6505" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">mkdir</code>功能的同步版本是<code class="fe le lf lg lh b">mkdirSync</code>功能。它需要两个参数。第一个参数是路径对象，可以是字符串、缓冲区对象或URL对象。</p><p id="0de1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是一个具有各种属性的对象，我们可以将这些属性设置为选项。<code class="fe le lf lg lh b">recursive</code>属性是一个布尔属性，如果不是所有的级别都存在，它允许我们创建目录的所有级别。<code class="fe le lf lg lh b">recursive</code>属性的默认值是<code class="fe le lf lg lh b">false</code>。</p><p id="0078" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">mode</code>属性是一个八进制数字属性，我们为POSIX系统设置了目录的权限和粘性位。</p><p id="0684" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Windows不支持此选项。<code class="fe le lf lg lh b">mode</code>的默认值是<code class="fe le lf lg lh b">0o777</code>，对于每个人都是可读、可写、可执行的。<code class="fe le lf lg lh b">mode</code>整数也可以代替options对象作为第二个参数。该函数返回<code class="fe le lf lg lh b">undefined</code>。</p><p id="6ca3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当路径是存在的目录时调用<code class="fe le lf lg lh b">mkdir</code>只会在<code class="fe le lf lg lh b">recursive</code>选项设置为<code class="fe le lf lg lh b">false</code>时导致错误。</p><p id="7e1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像下面的代码一样使用<code class="fe le lf lg lh b">mkdirSync</code>函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2754" class="mt lj it lh b gy mu mv l mw mx">const fs = require("fs");<br/>const dirToCreate = "./files/createdFolder/createdFolder";</span><span id="fb67" class="mt lj it lh b gy my mv l mw mx">fs.mkdirSync(dirToCreate, {<br/>  recursive: true,<br/>  mode: 0o77<br/>});<br/>console.log("Directory created!");</span></pre><p id="b8bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，我们可以看到，自从我们将<code class="fe le lf lg lh b">recursive</code>设置为<code class="fe le lf lg lh b">true</code>以来，它为最低级别的目录创建了所有的父目录。</p><p id="a1e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个<code class="fe le lf lg lh b">mkdir</code>功能的承诺版本。。它需要两个参数。第一个参数是路径对象，可以是字符串、缓冲区对象或URL对象。</p><p id="dcfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是一个具有各种属性的对象，我们可以将这些属性设置为选项。属性是一个布尔属性，如果不是所有的级别都存在，我们可以创建目录的所有级别。<code class="fe le lf lg lh b">recursive</code>属性的默认值为<code class="fe le lf lg lh b">false</code>。</p><p id="8951" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性是一个八进制数字属性，我们为POSIX系统设置了目录的权限和粘性位。Windows不支持此选项。</p><p id="f19b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">mode</code>的默认值是<code class="fe le lf lg lh b">0o777</code>，对于每个人来说都是可读、可写和可执行的。<code class="fe le lf lg lh b">mode</code>整数也可以代替options对象作为第二个参数。</p><p id="a1bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数返回<code class="fe le lf lg lh b">undefined</code>。当路径是一个存在的目录时调用<code class="fe le lf lg lh b">mkdir</code>,只有当<code class="fe le lf lg lh b">recursive</code>选项设置为<code class="fe le lf lg lh b">false</code>时才会导致承诺拒绝。</p><p id="c5ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当目录创建操作成功时，该函数返回一个解析时不带任何参数的承诺。</p><p id="a848" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">mkdir</code>函数的promise版本，如以下代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9bb9" class="mt lj it lh b gy mu mv l mw mx">const fsPromises = require("fs").promises;<br/>const dirToCreate = "./files/createdFolder/createdFolder";</span><span id="1e4b" class="mt lj it lh b gy my mv l mw mx">(async () =&gt; {<br/>  await fsPromises.mkdir(dirToCreate, {<br/>    recursive: true,<br/>    mode: 0o77<br/>  });<br/>  console.log("Directory created!");<br/>})();</span></pre><p id="4ba7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，我们可以看到，自从我们将<code class="fe le lf lg lh b">recursive</code>设置为<code class="fe le lf lg lh b">true</code>以来，它为最低级别的目录创建了所有的父目录。这是一个比使用<code class="fe le lf lg lh b">mkdirSync</code>顺序创建目录更好的选择，因为它不会像同步版本那样在运行目录创建操作时占用整个程序。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1e39055462c45b28fa1078f162a92588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P014ElLaM2uFCL2F"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@ipet_photo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ipet photo </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8a83" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用fs.mkdtemp系列函数创建临时目录</h1><p id="2935" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">Node.js <code class="fe le lf lg lh b">fs</code>模块有创建临时目录的特殊函数。<code class="fe le lf lg lh b">mkdtemp</code>系列函数允许我们通过一次函数调用来实现这一点。</p><p id="c301" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">mkdtemp</code>函数有3个参数。第一个参数是临时文件夹的前缀，它是一个字符串。它是您想要创建的文件夹的路径，该路径后面会附加一些字符。第二个参数是选项字符串或对象。</p><p id="b95b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">options对象由<code class="fe le lf lg lh b">encoding</code>属性组成，该属性是文件夹名称的字符编码，默认为<code class="fe le lf lg lh b">utf8</code>。</p><p id="1670" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码值字符串可以替换对象作为第二个参数。第二个参数是可选的。</p><p id="2939" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三个参数是在临时目录创建函数结束时调用的回调函数。</p><p id="ae78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调函数有两个参数。第一个是<code class="fe le lf lg lh b">err</code>对象，当操作成功时为<code class="fe le lf lg lh b">null</code>。第二个参数是文件夹路径，它是一个字符串。</p><p id="be64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成的文件夹的文件夹名称将带有前缀，前缀后面会附加6个随机字符。在某些系统中，如BSD系统，它可以在前缀后返回6个以上的随机字符。</p><p id="381f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想在<code class="fe le lf lg lh b">/tmp</code>中创建一个临时目录，那么前缀必须以特定于平台的路径分隔符结尾，我们可以从<code class="fe le lf lg lh b">require(‘path’).sep</code>中获得这个分隔符。</p><p id="e4ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用下面的代码创建一个临时目录:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="838b" class="mt lj it lh b gy mu mv l mw mx">const fs = require("fs");<br/>const prefix = "./files/tempDir";</span><span id="0ea4" class="mt lj it lh b gy my mv l mw mx">fs.mkdtemp(<br/>  prefix,<br/>  {<br/>    encoding: "utf8"<br/>  },<br/>  (err, folder) =&gt; {<br/>    if (err) {<br/>      throw err;<br/>    }<br/>    console.log("Temp directory created!", folder);<br/>  }<br/>);</span></pre><p id="fdcd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行代码，我们会在<code class="fe le lf lg lh b">console.log</code>中记录文件夹路径，我们应该会看到在给定的路径中创建了一个新的临时文件夹。</p><p id="8491" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">mkdtemp</code>函数有一个名为<code class="fe le lf lg lh b">mkdtempSync</code>函数的同步对应函数。<code class="fe le lf lg lh b">mkdtemp</code>函数有两个参数。第一个参数是临时文件夹的前缀，它是一个字符串。</p><p id="0af4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是您想要创建的文件夹的路径，该路径后面会附加一些字符。</p><p id="029e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是可选的字符串或对象。options对象由<code class="fe le lf lg lh b">encoding</code>属性组成，它是文件夹名称的字符编码，默认为<code class="fe le lf lg lh b">utf8</code>。</p><p id="538c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码值字符串可以替换对象作为第二个参数。第二个参数是可选的。它返回创建的文件夹路径。</p><p id="5d71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想在<code class="fe le lf lg lh b">/tmp</code>中创建一个临时目录，那么前缀必须以一个特定于平台的路径分隔符结尾，我们可以从<code class="fe le lf lg lh b">require(‘path’).sep</code>中得到这个分隔符。</p><p id="ef1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像下面的代码一样使用<code class="fe le lf lg lh b">mkdtempSync</code>函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1777" class="mt lj it lh b gy mu mv l mw mx">const fs = require("fs");<br/>const prefix = "./files/tempDir";<br/>try {<br/>  const folder = fs.mkdtempSync(prefix, {<br/>    encoding: "utf8"<br/>  });<br/>  console.log("Temp directory created!", folder);<br/>} catch (error) {<br/>  console.error(error);<br/>}</span></pre><p id="ef5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行代码，我们会在<code class="fe le lf lg lh b">console.log</code>中记录文件夹路径，我们会看到在给定路径中创建了一个新的临时文件夹。</p><p id="5230" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个<code class="fe le lf lg lh b">mkdtemp</code>函数的承诺版本。<code class="fe le lf lg lh b">mkdtemp</code>函数有两个参数。第一个参数是临时文件夹的前缀，它是一个字符串。</p><p id="0eaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是您想要创建的文件夹的路径，该路径后面会附加一些字符。第二个参数是可选的字符串或对象。</p><p id="2a35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可选对象由<code class="fe le lf lg lh b">encoding</code>属性组成，该属性是文件夹名称的字符编码，默认为<code class="fe le lf lg lh b">utf8</code>。</p><p id="eb09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码值字符串可以替换对象作为第二个参数。第二个参数是可选的。</p><p id="bdeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当临时目录创建操作成功时，它返回一个用创建的目录的路径解析的承诺。</p><p id="e161" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想在<code class="fe le lf lg lh b">/tmp</code>中创建一个临时目录，那么前缀必须以一个特定于平台的路径分隔符结尾，我们可以从<code class="fe le lf lg lh b">require(‘path’).sep</code>中得到这个分隔符。</p><p id="3777" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在下面的代码中使用<code class="fe le lf lg lh b">mkdtemp</code>函数的promise版本:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="40e2" class="mt lj it lh b gy mu mv l mw mx">const fsPromises = require("fs").promises;<br/>const prefix = "./files/tempDir";</span><span id="a0e6" class="mt lj it lh b gy my mv l mw mx">(async () =&gt; {<br/>  try {<br/>    const folder = await fsPromises.mkdtemp(prefix, {<br/>      encoding: "utf8"<br/>    });<br/>    console.log("Temp directory created!", folder);<br/>  } catch (error) {<br/>    console.error(error);<br/>  }<br/>})();</span></pre><p id="a08c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行代码，我们会在<code class="fe le lf lg lh b">console.log</code>中记录文件夹路径，我们应该会看到在给定的路径中创建了一个新的临时文件夹。这是一个比使用<code class="fe le lf lg lh b">mkdtempSync</code>顺序创建目录更好的选择，因为它不会像同步版本那样在运行目录创建操作时占用整个程序。</p><p id="e1c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe le lf lg lh b">mkdir</code>系列函数创建了永久目录来创建普通目录。<code class="fe le lf lg lh b">mkdir</code>系列函数可以创建所有的父目录以及我们可以创建的实际目录。</p><p id="da89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们用<code class="fe le lf lg lh b">mkdtemp</code>系列函数创建了临时目录。</p><p id="bdb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有常规的基于回调的异步函数，新承诺的基本异步函数，以及每个函数的同步版本。</p><p id="bc88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种有希望的函数版本可以更好地顺序创建目录，因为它不会像同步版本那样在运行目录创建操作时占用整个程序。</p></div></div>    
</body>
</html>