<html>
<head>
<title>JavaScript Design Patterns — Chain of Responsibility, Singleton, and Flyweight Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式——责任链、单例和轻量级模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-design-patterns-chain-of-responsibility-singleton-and-flyweight-patterns-42e1304668da?source=collection_archive---------11-----------------------#2020-06-12">https://levelup.gitconnected.com/javascript-design-patterns-chain-of-responsibility-singleton-and-flyweight-patterns-42e1304668da?source=collection_archive---------11-----------------------#2020-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8b7da8b907116726ee9337ffc648e2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z57ZVBf_yu0up_PP"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Sven Scheuermeier 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2b02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设计模式是任何好软件的基础。JavaScript程序也不例外。</p><p id="15cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究责任链、单例模式和轻量级模式。</p><h1 id="2ac5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">责任链模式</h1><p id="5b95" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">责任链类似于观察者模式，只是它将通知发送给一个对象，然后该对象将通知发送给另一个对象，依此类推。</p><p id="45bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在观察者模式中，通知同时发送给所有的观察者。</p><p id="3131" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们向一个对象发送一些东西，然后这个对象获取这些东西，做一些事情，然后发送给另一个对象，等等，那么就实现了责任链模式。</p><p id="b1ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以按如下方式实现:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="962b" class="mq lf it mm b gy mr ms l mt mu">const backend = {<br/>  receive(data) {<br/>    // do something with data<br/>  }<br/>}</span><span id="3976" class="mq lf it mm b gy mv ms l mt mu">const middleLayer = {<br/>  notify(data) {<br/>    backend.receive(data);<br/>  }<br/>}</span><span id="9a9e" class="mq lf it mm b gy mv ms l mt mu">const frontEnd = {<br/>  notify(data) {<br/>    middleLayer.notify(data);<br/>  }<br/>}</span></pre><p id="3f37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mw mx my mm b">frontEnd</code>，它调用了<code class="fe mw mx my mm b">middleLayer</code>对象的<code class="fe mw mx my mm b">notify</code>方法，后者又调用了<code class="fe mw mx my mm b">backend</code>的<code class="fe mw mx my mm b">receive</code>方法。</p><p id="83c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以用一种方法无缝地在它们之间传递数据。</p><p id="8c47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只要我们不公开任何其他在两个对象之间进行通信的方法，我们就有一种干净的方式在<code class="fe mw mx my mm b">frontEnd</code>和<code class="fe mw mx my mm b">middleLayer</code>和<code class="fe mw mx my mm b">backEnd</code>之间发送数据。</p><h1 id="d308" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">一个</h1><p id="ec06" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在单例模式中，我们只实例化一个对象的实例。</p><p id="a2ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，我们可以通过创建一个对象文字来创建带有一个实例的对象。</p><p id="e2bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1867" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  foo: 1,<br/>  bar: 'baz'<br/>}</span></pre><p id="b9c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个对象文字只是一组键值对，其中的值也可以是其他对象。</p><p id="c540" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用类，我们也可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cb9f" class="mq lf it mm b gy mr ms l mt mu">class Foo {<br/>  constructor() {<br/>    if (!Foo.instance) {<br/>      Foo.instance = {<br/>        foo: 1,<br/>        bar: 2<br/>      }<br/>    }<br/>    return Foo.instance;<br/>  }<br/>}</span></pre><p id="6a45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将创建的实例分配给<code class="fe mw mx my mm b">Foo</code>的<code class="fe mw mx my mm b">instance</code>属性。</p><p id="b37c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们创建构造函数时，我们检查<code class="fe mw mx my mm b">instance</code>属性，看看是否为它创建了任何东西。</p><p id="11ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有给它赋值，我们就给它赋值一个对象。</p><p id="c287" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们返回<code class="fe mw mx my mm b">Foo.instance</code>以便获得实例。</p><p id="0908" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们创建2个<code class="fe mw mx my mm b">Foo</code>实例:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3618" class="mq lf it mm b gy mr ms l mt mu">const foo = new Foo();<br/>const bar = new Foo();</span></pre><p id="b271" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过编写以下代码来查看它们是否是同一个实例:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a5f3" class="mq lf it mm b gy mr ms l mt mu">console.log(foo === bar);</span></pre><p id="27c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该得到<code class="fe mw mx my mm b">true</code>,因为它们都引用同一个实例。</p><p id="e099" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单件可以方便地创建由多段代码用来在一个中心位置存储数据的对象。</p><p id="5978" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不希望在数据访问方式上有冲突，那么我们可以创建一个类或对象文字的单一实例来确保没有冲突问题。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/7b514cd0b7718bed432aba925cbbe396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gBzfix3M98ErjCVB"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@iyunmai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾伦·柯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="1e06" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">轻量级模式</h1><p id="f391" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">flyweight模式是我们限制对象创建的地方，</p><p id="5b33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建了一组小对象，每个小对象消耗更少的资源。</p><p id="7d5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些对象位于一个flyweight对象的后面，该对象用于与这些对象进行交互，</p><p id="2260" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些对象也与我们的代码交互。</p><p id="9bc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们获得了大对象的好处，同时与更易于管理的小对象进行交互。</p><p id="8bd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下实现它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fa6f" class="mq lf it mm b gy mr ms l mt mu">class Student {<br/> //..<br/>}</span><span id="6828" class="mq lf it mm b gy mv ms l mt mu">const studentIdentity = {<br/> getIdentity(){<br/>   const student = new Student();<br/>    //..<br/>    return {<br/>    //...<br/>    }<br/>  }<br/>}</span><span id="6d0f" class="mq lf it mm b gy mv ms l mt mu">const studentScore = {<br/> getScore(){<br/>   const student = new Student();<br/>    //..<br/>    return {<br/>    //...<br/>    }<br/>  }<br/>}</span></pre><p id="be42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个代表学生数据的<code class="fe mw mx my mm b">Student</code>类。</p><p id="bef1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mw mx my mm b">studentIdentity</code>和<code class="fe mw mx my mm b">studentScore</code>对象中，我们有方法分别得到他或她的身份或分数。</p><p id="529f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样我们就不用把所有的方法都放到<code class="fe mw mx my mm b">Student</code>类里了。</p><p id="637e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们在它之外有一些更小的方法，可以用来处理特定种类的学生数据。</p><h1 id="f9f0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="bc93" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用单例模式来创建一次性对象。</p><p id="c853" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们既可以创建只有一个实例的类实例，也可以创建有对象文字的类实例。</p><p id="d641" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在flyweight模式中，我们创建较小的对象来处理较大的对象，从而降低复杂性。</p><p id="c313" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">责任链模式让我们以连续的方式将数据从一个对象发送到另一个对象。</p></div></div>    
</body>
</html>