<html>
<head>
<title>30 Must-Know Topics In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的30个必读主题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/30-must-know-topics-in-javascript-2b6a998f92de?source=collection_archive---------3-----------------------#2020-05-03">https://levelup.gitconnected.com/30-must-know-topics-in-javascript-2b6a998f92de?source=collection_archive---------3-----------------------#2020-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ed6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你知道如何在JavaScript中使用if-else、for循环和函数吗？你知道吗？太好了。因为下面的30个话题会让你成为JavaScript忍者！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c6726448200e999c66d731cc27d9575e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCkemNKFCRgjUJ2BhKjxGQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@clemhlrdt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克莱门特Photo】在</a><a class="ae le" href="https://unsplash.com/s/photos/web-development?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="fa12" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">1.<strong class="ak"> Array.splice() </strong></h1><p id="f6b2" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Array.splice()方法可用于通过添加新元素或替换现有元素来修改现有数组。它需要三个参数。第一个是起始索引。第二个参数决定应该删除多少个元素。如果我们只想在某个位置插入一个元素，它就保持为0。最后一个参数是新元素。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="d31e" class="mn lg it mj b gy mo mp l mq mr">const iftar = ['Chola', 'Piyaju', 'Beguni', 'Muri'];<br/>iftar.splice(1, 0, 'Shorbot');<br/>console.log(iftar);<br/>iftar.splice(4, 1, 'Halim');<br/>console.log(iftar);</span></pre><h1 id="288b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">2.<strong class="ak"> Array.every() </strong></h1><p id="e053" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Array.every()方法用于检查数组中的所有元素是否都通过了回调函数中实现的测试。如果所有元素都返回True值，则该方法返回True。否则它将返回false。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="927a" class="mn lg it mj b gy mo mp l mq mr">const isAdult = curAge =&gt; curAge &gt; 18;<br/>const ageList = [19, 30, 39, 29, 100, 23];<br/>console.log(ageList.every(isAdult));        // true</span></pre><h1 id="8a63" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">3.<strong class="ak"> String.replace() </strong></h1><p id="1809" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">string.replace()方法有两个参数。第一个是要替换的模式，第二个是替换。模式可以是字符串或正则表达式，替换可以是新字符串或函数。RegExp可以替换多个匹配项，但string pattern只会替换第一个匹配项。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="a42c" class="mn lg it mj b gy mo mp l mq mr">const text = 'To be, or not  to be';<br/>const regex = /be/gi;</span><span id="9665" class="mn lg it mj b gy ms mp l mq mr">console.log(text.replace(regex, 'eat'));    // To eat, or not to eat<br/>console.log(text.replace('be', 'eat'));     // To eat, or not to be</span></pre><h1 id="612a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">4.String.indexOf()</h1><p id="1cfc" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">String.indexOf(searchValue [，fromIndex])返回searchValue的第一个匹配项的索引或-1。<br/>但是当我们向searchValue传递一个空字符串时，它会奇怪地工作。它总是返回我们从Index 作为<strong class="js iu">传递的任何东西，只要它不大于字符串的长度。</strong></p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="4e47" class="mn lg it mj b gy mo mp l mq mr">'hello world'.indexOf('')          // returns 0<br/>'hello world'.indexOf('', 8)      // returns 8</span></pre><p id="da7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<strong class="js iu"> fromIndex </strong>的值大于返回值将等于字符串的长度。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="6935" class="mn lg it mj b gy mo mp l mq mr">'hello world'.indexOf('', 15)    // returns 11</span></pre><h1 id="b010" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">5.<strong class="ak">伊斯南()</strong></h1><p id="08c0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在JS中，最奇特的一个值是<strong class="js iu">楠</strong>。等式运算符很不可靠，因为<strong class="js iu"> NaN == NaN </strong>和<strong class="js iu"> NaN===NaN </strong>返回<strong class="js iu"> false </strong>！</p><p id="b1c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来JS有问题，但是再想想。发生这种情况是因为<strong class="js iu"> NaN </strong>没有引用特定的值。<strong class="js iu">(0/0)</strong><strong class="js iu">(无穷大/无穷大)</strong>都会返回<strong class="js iu"> NaN </strong>。但我们可以清楚地看到，它们并不相同。</p><p id="4192" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这个原因，不可能说两个nan是否相等。<br/>这使得<strong class="js iu"> isNaN() </strong>开始发挥作用，因为它使得识别一个值是否为NaN成为可能。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="e1b7" class="mn lg it mj b gy mo mp l mq mr">isNaN('this is a string')    // true<br/>isNaN(234324)                // false</span></pre><h1 id="8947" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">6.休息参数</h1><p id="dd95" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">rest参数运算符用于函数参数列表，格式为:<strong class="js iu">…变量</strong>，它将在该变量中包含调用函数时使用的未捕获参数的完整列表。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="119e" class="mn lg it mj b gy mo mp l mq mr">function avg(...args) {<br/>  var sum = 0;<br/>  for (let value of args) {<br/>    sum += value;<br/>  }<br/>  return sum / args.length;<br/>}<br/>avg(2, 3, 4, 5);    // 3.5</span></pre><h1 id="daa9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">7.符号()</h1><p id="11bc" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">ECMAScript 2015中引入的符号是JavaScript的原始数据类型。与其他原始数据类型不同，符号没有文字形式。符号是用<strong class="js iu"> Symbol() </strong>调用可选描述(名称)创建的。符号保证是唯一的。即使我们创造了许多描述相同的符号，它们也是不同的值。描述只是用于调试目的的标签。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="c305" class="mn lg it mj b gy mo mp l mq mr">let id1 = Symbol("id")<br/>let id2 = Symbol("id")<br/>console.log(id1 == id2)      // false</span></pre><h1 id="daf5" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">8.客户端存储</h1><p id="655a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">客户端存储允许我们在客户端存储数据，并在需要时检索数据。这有许多不同的用途，例如:</p><ul class=""><li id="067c" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">个性化站点首选项</li><li id="1885" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">持续以前的站点活动</li><li id="c834" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">在本地保存数据和资产</li><li id="e7d4" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">在本地保存web应用程序生成的文档</li></ul><h1 id="be5b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">9.客户端存储的类型</h1><ul class=""><li id="41e6" class="mt mu it js b jt md jx me kb nh kf ni kj nj kn my mz na nb bi translated">Cookies(过时、不安全、存储简单数据)</li><li id="41a5" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">Web存储API(存储简单的数据，数据存储在两个类似对象的结构中，称为sessionStorage和localStorage)</li><li id="deea" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">IndexedDB API(用于存储复杂数据的完整数据库)</li><li id="b702" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">缓存API(离线资产存储)</li></ul><h1 id="20e3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">10.服务工作者和缓存</h1><p id="7ea0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated"><strong class="js iu">服务人员</strong>充当网络应用、浏览器和网络(如果可用的话)之间的代理服务器。它们用于以下任务:</p><ul class=""><li id="c13f" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">有效的线下体验</li><li id="5c8c" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">拦截网络请求</li><li id="b83c" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">更新驻留在服务器上的资产</li></ul><p id="53cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">缓存</strong>接口为被缓存的请求/响应对象对提供了一种存储机制。它们通常被用作ServiceWorker生命周期的一部分。</p><h1 id="4c92" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">11.<strong class="ak">DOM的节点类型</strong></h1><p id="dc13" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在文档对象中，总共有十二个节点。但是其中只有四种在实践中使用。它们是:</p><ul class=""><li id="0ac2" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated"><strong class="js iu">文档:</strong>它是DOM的入口点</li><li id="0e0d" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><strong class="js iu">元素节点:</strong>这些HTML元素是DOM树的构建块</li><li id="ddeb" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><strong class="js iu">文本节点:</strong>这些是文本</li><li id="ace9" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><strong class="js iu">注释:</strong>这些是JS可以从DOM中读取的隐藏信息</li></ul><h1 id="c61f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">12.<strong class="ak">文档片段</strong></h1><p id="abcc" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">DocumentFragment是一种特殊的DOM节点，它作为包装器传递节点列表。每当我们插入DocumentFragment时，只有它的内容被插入。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="6f56" class="mn lg it mj b gy mo mp l mq mr">&lt;ul id="ul"&gt;&lt;/ul&gt;<br/>&lt;script&gt;<br/>  let fragment = new DocumentFragment()<br/>  for(let i = 1; i &lt;= 3; i++) {<br/>    let li = document.createElement('li')<br/>    li.append(i)<br/>    fragment.append(li)<br/>  }<br/>  ul.append(fragment)<br/>&lt;/script&gt;</span></pre><h1 id="1300" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">13.<strong class="ak"> getComputedStyle </strong></h1><p id="064c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">getComputedStyle()方法获取指定元素的所有实际的(解析的)CSS属性和值。因为不可能读取来自CSS类的任何内容，所以getComputedStyle()对于获取样式信息是必要的。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="e351" class="mn lg it mj b gy mo mp l mq mr">&lt;head&gt;<br/> &lt;style&gt; body { margin: 10px } &lt;/style&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/> &lt;script&gt;<br/>   let computedStyle = getComputedStyle(document.body);</span><span id="266e" class="mn lg it mj b gy ms mp l mq mr">   alert( computedStyle.marginTop ); // 10px<br/> &lt;/script&gt;<br/>&lt;/body&gt;</span></pre><h1 id="59d8" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">14.<strong class="ak">相等运算符</strong></h1><p id="3f2f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在JS中，有两种方法可以检查两个值是否相等。</p><p id="2f43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">相等运算符(==): <br/> </strong>相等运算符在比较操作数之前进行类型强制，这会导致奇怪的输出和性能问题。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="0970" class="mn lg it mj b gy mo mp l mq mr">'1'  ==  1         // true<br/>1    == '1'        // true<br/>0    == false      // true<br/>0    == null       // false</span></pre><p id="2777" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">严格相等运算符(= = =):<br/>T5】严格相等运算符在没有任何类型强制的情况下比较操作数。</strong></p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="301d" class="mn lg it mj b gy mo mp l mq mr">3 === 3   // true<br/>3 === '3' // false</span></pre><h1 id="ca6f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">15.<strong class="ak">类型</strong></h1><p id="e3ad" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">typeof运算符返回指示操作数类型的字符串。这可以说是javascript语言最大的设计缺陷，应该不惜一切代价避免。不管怎样，检查一个变量是否被声明是有用的。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="ca28" class="mn lg it mj b gy mo mp l mq mr">typeof foo !== 'undefined'</span></pre><h1 id="4918" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">16.<strong class="ak">评估</strong></h1><p id="630a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated"><strong class="js iu"> eval() </strong>是JavaScript中的一个全局函数，将指定的字符串作为JavaScript代码进行求值并执行。如果直接调用，它将在局部范围内执行代码。否则，它将在全局上下文中执行代码，这可能会导致一些错误。它也有安全问题，因为它执行任何给它的代码。应避免使用eval()。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="0bed" class="mn lg it mj b gy mo mp l mq mr">function test() {<br/>  var x = 2, y = 4;<br/>  console.log(eval('x + y'));  // uses local scope, 6<br/>  var geval = eval;<br/>  console.log(geval('x + y')); // uses global scope, throws an error<br/>}</span></pre><h1 id="ab4f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">17.<strong class="ak">未定义</strong></h1><p id="6806" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">undefined是具有未定义初始值的全局对象的属性。在现代浏览器中，它是一个不可配置和不可写的属性。对于以下情况，我们可以得到未定义:</p><ul class=""><li id="5d9d" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">访问未定义的全局变量</li><li id="b95c" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">访问已声明的<em class="nk">但未初始化的</em>变量</li><li id="7e91" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">调用没有返回语句的函数</li><li id="1769" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">无所回报地返回</li><li id="f0ae" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">不存在的对象属性</li><li id="5f86" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">没有任何显式值的函数参数</li></ul><h1 id="35dc" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">18.<strong class="ak">删除操作员</strong></h1><p id="afd1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated"><strong class="js iu">删除</strong>操作符用于从一个对象中删除一个属性。但是它不适用于全局变量或函数。如果一个变量被指定为全局对象的属性，它仍然可以被删除。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="9410" class="mn lg it mj b gy mo mp l mq mr">const a = 1;       // DontDelete is set<br/>delete a;          // false<br/>a;                 // 1<br/>var obj = {x: 1};<br/>delete obj.x;      // true<br/>obj.x;             // undefined<br/>this.a = 4;<br/>delete a;          // true<br/>a;                 // undefined</span></pre><h1 id="5f30" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">19.<strong class="ak">吊装</strong></h1><p id="2915" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">提升是一种JavaScript机制，在代码执行之前，变量和函数声明被移动到它们作用域的顶部。这意味着无论在哪里声明函数和变量，无论它们的作用域是全局的还是局部的，它们都被移动到作用域的顶部。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="3b63" class="mn lg it mj b gy mo mp l mq mr">a = 5;<br/>console.log(a);  // Error<br/><br/>b = 5;<br/>console.log(b);  // 5<br/>var b;</span></pre><h1 id="0a54" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">20.<strong class="ak">自动插入分号</strong></h1><p id="b7f7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">JavaScript不是一种没有分号的语言，但是一个叫做自动插入分号的特性允许它像一个语言一样工作。每当由于缺少分号而出现解析器错误时，它会自动插入一个分号。这可能会由于不正确的分号插入而导致一些错误。因此，我们应该在代码中明确使用分号。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="59dd" class="mn lg it mj b gy mo mp l mq mr">console.log(3)<br/>(console.log(4))  // TypeError: console.log(...) is not a function</span></pre><h1 id="46e2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">21.<strong class="ak">类声明</strong></h1><p id="ab01" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated"><strong class="js iu">类声明</strong>是JS中定义类的两种方法之一。它以class关键字开始，后跟类名和一对花括号。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="fd33" class="mn lg it mj b gy mo mp l mq mr">class Phone {<br/>   constructor(name){<br/>       this.name = name<br/>   }<br/>  <br/>   getModel(){<br/>       console.log(this.name)<br/>   }<br/>}<br/>let motorola = new Phone('razr')<br/>motorola.getModel()</span></pre><h1 id="9513" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">22.<strong class="ak">课堂用语</strong></h1><p id="890d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">类表达式是JS中定义类的第二种方式。有两种类型的类表达式，命名的和未命名的。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="b908" class="mn lg it mj b gy mo mp l mq mr">//unnamed<br/>let Circle = class {<br/>   constructor(radius){<br/>       this.radius = radius<br/>   }<br/>  <br/>   getArea(){<br/>       return Math.PI * this.radius * this.radius;<br/>   }<br/>}<br/>//named<br/>let Circle = class Circle2 {<br/>   constructor(radius){<br/>       this.radius = radius<br/>   }<br/>  <br/>   getArea(){<br/>       return Math.PI * this.radius * this.radius;<br/>   }<br/>}</span></pre><h1 id="76d3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">23.析构赋值</h1><p id="0ff5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在JS的对象析构中，可以将其用作赋值。但是有一点我们应该记住，析构赋值语句必须用括号括起来。这是因为JS默认将花括号视为block语句，block语句不能在赋值操作符的左边。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="e05d" class="mn lg it mj b gy mo mp l mq mr">let person = {<br/>   name: 'john',<br/>   age: 100<br/>}<br/>let name = 'doe';<br/>let age = 50;<br/>({name,age} = person);<br/>console.log(name,age);    // john, 100</span></pre><h1 id="56a3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">24.<strong class="ak">克隆阵列</strong></h1><p id="e81e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在引入ES6之前，concat()是JS开发人员中克隆数组最流行的选择。虽然concat()是用来连接两个数组的，但是向它传递一个空参数会创建一个新的数组克隆。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="91f8" class="mn lg it mj b gy mo mp l mq mr">var numbers = [1,2,3];<br/>var newNumbers = numbers.concat();<br/>console.log(newNumbers);              // [1,2,3]</span></pre><p id="4972" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自从ES6问世以来，使用<strong class="js iu"> Rest项目</strong>，克隆阵列变得更加直观。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="2ee7" class="mn lg it mj b gy mo mp l mq mr">let numbers = [1,2,3];<br/>let [...newNumbers] = numbers;<br/>console.log(newNumbers);              // [1,2,3]</span></pre><h1 id="9e7a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">25.<strong class="ak">太阳穴死区</strong></h1><p id="ea5b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">临时死区是JS中的一种行为，它发生在用let和const关键字声明变量时。在JS中，let和const不提升。在声明之前在变量的作用域内调用这些变量将会引发错误。他们范围内的这个区域被称为时间死区。在它们的作用域之外调用这样的变量不会抛出任何错误，即使在它们被声明之前。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="438e" class="mn lg it mj b gy mo mp l mq mr">// TDZ<br/>if (true) {<br/>   console.log(typeof value);  // ReferenceError!<br/>   let value = "blue";<br/>}<br/>//NON TDZ<br/>console.log(typeof value);      // undefined<br/>if (true) {<br/>   let value = "blue";<br/>}</span></pre><h1 id="13a6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">26.<strong class="ak">面向对象编程</strong></h1><p id="b642" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">面向对象编程，通常称为OOP，是一种编程风格，其中一个程序被分成几个可以相互通信的对象段。每个对象可能有自己的一组属性和方法。JavaScript中有3个核心概念。</p><ol class=""><li id="6ee4" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn nl mz na nb bi translated">包装</li><li id="e18f" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn nl mz na nb bi translated">多态性</li><li id="b07c" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn nl mz na nb bi translated">遗产</li></ol><h1 id="5d9e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">27.<strong class="ak">事件循环</strong></h1><p id="31e3" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">尽管JavaScript被认为是单线程语言，但事件循环使它能够单独处理阻塞代码，如超时和数据获取。它使用事件表和事件队列以及现有的调用堆栈来实现这一点。这是一个不断运行的过程，它检查调用堆栈是否为空。当调用堆栈为空时，它会检查事件队列中是否有内容，并将其移动到调用堆栈中。如果没有，它什么也不做。</p><h1 id="fd7d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">28.<strong class="ak">调用堆栈</strong></h1><p id="ea86" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在JavaScript中，调用堆栈是一种数据结构，它使用后进先出(LIFO)原则来临时存储和管理函数调用(call)。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="6c65" class="mn lg it mj b gy mo mp l mq mr">function firstFunction(){<br/>   throw new Error('Stack Trace Error');<br/>}<br/>function secondFunction(){<br/>   firstFunction();<br/>}<br/>function thirdFunction(){<br/>   secondFunction();<br/>}<br/>thirdFunction();<br/>//Stack Trace Error! But it also represents the corresponding call //stack<br/>//    at firstFunction (&lt;anonymous&gt;:2:11)<br/>//    at secondFunction (&lt;anonymous&gt;:5:5)<br/>//    at thirdFunction (&lt;anonymous&gt;:8:5)<br/>//    at &lt;anonymous&gt;:10:1</span></pre><h1 id="8b39" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">29.<strong class="ak">高阶函数</strong></h1><p id="2efd" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在JavaScript中，接受回调函数作为参数的函数称为高阶函数。例如，map、filter和reduce就是JS中内置的高阶函数的例子。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="3cc9" class="mn lg it mj b gy mo mp l mq mr">const numbers = [1,2,3,4,5];<br/>const total = numbers.reduce((a,b)=&gt;a+b,0);<br/>console.log(total)    // 15</span></pre><h1 id="8c1f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">30.<strong class="ak">阿谀奉承</strong></h1><p id="d719" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Currying是将一个具有多个参数的函数分解成一系列具有单个参数的函数的过程。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="d057" class="mn lg it mj b gy mo mp l mq mr">//without currying<br/>function add (a, b) {<br/> return a + b;<br/>}<br/>add(2+3)    // 5<br/>//with currying<br/>function add (a) {<br/> return function (b) {<br/>   return a + b;<br/> }<br/>}<br/>add(2)(3)   // 5</span></pre></div></div>    
</body>
</html>