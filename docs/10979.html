<html>
<head>
<title>WebRTC: CaptureStream iOS Compatibility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebRTC: CaptureStream iOS兼容性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/webrtc-capturestream-ios-compatibility-2ba51cdc7207?source=collection_archive---------10-----------------------#2022-02-02">https://levelup.gitconnected.com/webrtc-capturestream-ios-compatibility-2ba51cdc7207?source=collection_archive---------10-----------------------#2022-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e1de2bd35e08a7c0e5568b7b5dad0d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tGC5wJzcePrKkMcL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@lazizli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉拉·阿兹利</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="3eab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之前我们已经讨论了使用WebRTC技术的网络流的基础。现在说说我经历过的一些有趣的问题:iOS兼容性。</p><p id="e13c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://blog.devgenius.io/explaining-basic-of-web-streaming-in-simple-term-e8aef988bca8" rel="noopener ugc nofollow" target="_blank">之前的文章</a>中，我们讨论了媒体流及其与<code class="fe lb lc ld le b">&lt;video&gt;</code>标签的关系。我们知道<code class="fe lb lc ld le b">&lt;video&gt;</code>可以接收媒体流作为它的输入。令我们惊讶的是，<code class="fe lb lc ld le b">&lt;video&gt;</code>也可以转换成MediaStream！<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/captureStream" rel="noopener ugc nofollow" target="_blank">htmlmediaelement . capturestream()</a>是完成这种转换的方法。但是如果你仔细看文档，你会看到一个不幸的消息。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lf"><img src="../Images/82ad3a3427754178f23c8066dc9fa466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83TZ39YbbBR9wP9Lfcp_mA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTMLMediaElement.captureStream浏览器兼容性，<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/captureStream" rel="noopener ugc nofollow" target="_blank">MDN Web Docs</a>2022年1月26日</figcaption></figure><p id="c9a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">不支持Safari。</strong></p><p id="3767" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的应用程序的要求是可以被iOS用户访问，那么这个信息对您来说将是个坏消息。现在，你有三个选择:</p><ol class=""><li id="b28e" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">忽略iOS用户:(</li><li id="6da8" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia" rel="noopener ugc nofollow" target="_blank"> getDisplayMedia </a>共享您的视频。</li><li id="a784" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/captureStream" rel="noopener ugc nofollow" target="_blank">htmlcanvaselement . capturestream()</a>。</li></ol><p id="b5c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等等，还有另一个captureStream？是的，这个函数不是媒体，而是从画布对象中捕获流。如果你看了这个功能的浏览器兼容性，你会发现这个功能支持Safari。通过一些黑客攻击，我们可以用它将我们的<code class="fe lb lc ld le b">&lt;video&gt;</code>标签转换成媒体流！</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/efe32ab4158b0710e4f0f26bab86a49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIJBPqdcmd7EUDX8NGGN2Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">htmlcanvaselement . capturestream浏览器兼容性，<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/captureStream" rel="noopener ugc nofollow" target="_blank">MDN Web Docs</a>2022年1月26日</figcaption></figure><p id="3ecc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你只是想浏览一下，下面是总结的步骤:</p><ol class=""><li id="e99a" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">将视频的帧绘制到画布上</li><li id="5272" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">重复它来创建一个<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">请求动画帧</a></li></ol><p id="ee80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成的代码也可以在我的存储库中看到。</p><div class="ma mb gp gr mc md"><a href="https://github.com/adyaksaw/tutorial/tree/master/4-webrtc-ios-capturestream" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ir gy z fp mi fr fs mj fu fw ip bi translated">教程/4-webrtc-IOs-master adyaksaw上的capturestream教程</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">教程的示例代码。在GitHub上创建一个帐户，为adyaksaw/tutorial开发做贡献。</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">github.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr jw md"/></div></div></a></div><p id="b635" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，那我们来详细说说吧！让我们从我们的<a class="ae kc" href="https://blog.devgenius.io/explaining-basic-of-web-streaming-in-simple-term-e8aef988bca8" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中的基本HTML文件和javascript文件开始。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e2cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要将视频放到画布中。就我个人而言，我对这个任务的第一个想法是“我可以直接将视频标记放在画布标记中吗？”。令我失望的是，我不能。我们需要把每一帧画到画布上。我们将使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" rel="noopener ugc nofollow" target="_blank"> drawImage </a>函数来完成这项任务。让我们将它设置为在视频播放后绘制，如下例所示。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="61f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您运行上面的代码，您可以看到画布出现在我们的网页中，但它还没有动画。这是因为我们只在视频开始时绘制一次图像。我们需要使它可重复，这就是requestAnimationFrame的用武之地。</p><p id="7e4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释一下<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">window . requestanimationframe()</a>函数，它是一个通过调用更新函数来重绘动画的函数。更新过程将发生在下一次重画之前，通常每秒发生60次。我们可以用它反复绘制画布来制作动画。现在，我们修改代码，这样我们就可以使用这个函数了。更改后的代码可以在下一节中看到。请注意，代码需要在step函数内部和外部调用requestAnimationFrame函数。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e4b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原来如此。因为画布已经一帧一帧地捕捉了我们的视频，我们现在可以将画布转换成媒体流，而不是转换视频。该转换与除Internet Explorer之外的几乎所有浏览器兼容，解决了captureStream函数的iOS兼容性问题。</p><p id="adf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是将视频转换成画布动画有一个缺点。画布动画不会在非活动选项卡上运行。因此，如果另一个客户端流式传输您的画布，而您切换了标签，流式传输将会暂停，直到您返回到您的画布标签。所以你需要选择你的毒药:你需要iOS兼容性，还是流媒体工具切换标签的能力？</p><p id="63d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大家好，我是Adyaksa，我写的是软件开发和我的语言学习经历。我计划每周发布一篇博客，内容是我在做兼职项目时发现的一些有趣的事情。如果你感兴趣，你可以关注我来了解它的最新情况！</p><p id="9a10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">资源:</p><ul class=""><li id="204d" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la mu lq lr ls bi translated"><a class="ae kc" href="https://stackoverflow.com/questions/4429440/html5-display-video-inside-canvas" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/4429440/html 5-display-video-inside-canvas</a></li><li id="35f6" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la mu lq lr ls bi translated"><a class="ae kc" href="https://stackoverflow.com/questions/61433700/how-to-make-sure-canvas-is-of-same-size-of-video-in-html" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/61433700/how-to-assure-canvas-is-the-same-size-of-video-in-html</a></li><li id="e73e" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la mu lq lr ls bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/captureStream" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/HTMLMediaElement/captureStream</a></li><li id="23a3" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la mu lq lr ls bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/captureStream" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/HTMLCanvasElement/captureStream</a></li></ul></div></div>    
</body>
</html>