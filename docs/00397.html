<html>
<head>
<title>A deep dive into React hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对反应钩的深入研究</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dissecting-react-hooks-how-to-use-them-and-are-they-replacing-redux-4bb96fa7569d?source=collection_archive---------0-----------------------#2019-02-06">https://levelup.gitconnected.com/dissecting-react-hooks-how-to-use-them-and-are-they-replacing-redux-4bb96fa7569d?source=collection_archive---------0-----------------------#2019-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ae124fd88824ede120bb29ab2d68f830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTr4lh42z--65P3BJz8l8A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Shane Aldendorff 在<a class="ae kc" href="https://unsplash.com/search/photos/magnifying-glass?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1598" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Hooks刚刚登陆React v16.8的生产版本，它带来了一种新的思考和使用React的方式。简而言之，React挂钩将我们构建组件的方式从面向对象(类)转向了函数式方法。正如在<a class="ae kc" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">文档</a>中所述，使用类/继承以及为类方法绑定<code class="fe lb lc ld le b">this</code>的需要让很多人感到困惑，尤其是初学者。有了React钩子，就不再是这样了。事实上，现在编写组件的速度非常快，用状态来改造组件不需要您将整个组件从功能组件重写为类组件。</p><p id="334b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我强烈推荐阅读关于钩子的<a class="ae kc" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">文档</a>，这会给你一个关于钩子的很好的概述。有些例子会与React主页上的非常相似，甚至完全匹配，但我想为以后的思考和实验打下基础。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="9239" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个完整的工作库<a class="ae kc" href="https://github.com/gisderdube/dissecting-react-hooks" rel="noopener ugc nofollow" target="_blank"/>。您可以克隆它以拥有一个操场，并返回到不同的提交，每个提交代表本文的一个部分。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="6186" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">简单状态</h1><p id="0dd2" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在使用状态非常简单。您可以使用<code class="fe lb lc ld le b">useState</code>钩子来定义和检索状态及其变更处理程序:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9c7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第4行是用钩子定义一个状态变量和一个状态改变处理程序所需要的全部内容。仅这一点就比类组件状态处理有很大的优势。此外，您还可以快速插入和取出状态。<code class="fe lb lc ld le b">count</code>是您的状态变量，<code class="fe lb lc ld le b">setCount</code>是状态变化处理程序，<code class="fe lb lc ld le b">useState()</code>调用中的<code class="fe lb lc ld le b">0</code>定义了一个初始值。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h2 id="fd44" class="mv ln iq bd lo mw mx dn ls my mz dp lw ko na nb ma ks nc nd me kw ne nf mi ng bi translated">浅谈操作者和绩效</h2><p id="3749" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如果你只想了解语用钩子的用法，你可以跳过这一部分。</p><p id="8552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">拥有一个类组件并使用类方法进行状态修改给了你一个优势:原型继承。也许这对你来说并没有真正的意义，如果是这样，不用担心。这意味着所有的组件实例都是从一个蓝图——原型——派生出来的，并且仍然是连接在一起的。当定义类方法时，函数只在原型中声明一次，所有组件实例都有指向该函数的指针。关键是有很多组件实例，例如2000个计数器，仍然只有一个共享函数声明。功能组件没有那个。在功能组件中使用状态处理程序迫使我们使用箭头函数，在组件的呈现/返回部分调用状态改变处理程序。拥有2000个计数器会导致在每次(重新)渲染时声明2000个箭头函数。</p><p id="647a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我确信开发React的人考虑到了这一点，他们推荐使用<a class="ae kc" href="https://github.com/bvaughn/react-window" rel="noopener ugc nofollow" target="_blank"> react-window </a>来显示更长的组件列表，但这仍然是一个困扰我的问题。如果你有解释，请告诉我。</p><blockquote class="ni nj nk"><p id="aee5" class="kd ke nh kf b kg kh ki kj kk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">更新:事实证明，正常用例没有明显的性能缺陷。只有在极端情况下才会影响性能。详细回答见<a class="ae kc" href="https://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></blockquote></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="ad63" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">处理更复杂的状态</h1><p id="6038" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">处理更大的对象或多个状态变量通常是必要的。在这种情况下，像<code class="fe lb lc ld le b">0</code>这样简单的初始值是不够的。虽然您可能会将<code class="fe lb lc ld le b">0</code>(来自反例)重新分配给一个对象或任何其他对象，但这绝对是不推荐的<strong class="kf ir"/>。相反，我们有其他选择来处理更复杂的状态。</p><ol class=""><li id="3653" class="no np iq kf b kg kh kk kl ko nq ks nr kw ns la nt nu nv nw bi translated">又多了一个<code class="fe lb lc ld le b">useState</code>钩子:</li></ol><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e3e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于很多变量使用这种结构会变得混乱，并且不建议增加复杂性，但是对于一两个其他状态值，这应该没问题。</p><p id="e564" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.具有状态对象:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2a83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这里，老好人<code class="fe lb lc ld le b">setState</code>。对于复杂的状态来说，这可能不是最干净的解决方案(我们马上就会看到哪个更好)，但是对于中等大小的状态来说，这肯定是可行的，因为在这些状态中，reducers的使用太多了</p><p id="c370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.使用减速器:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="44ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您以前使用过redux，这可能对您来说很熟悉。这不是巧合，因为<a class="ae kc" href="https://overreacted.io" rel="noopener ugc nofollow" target="_blank">丹·阿布拉莫夫</a>(Redux的最初创造者)已经在脸书工作了一段时间，并且非常积极地参与React钩子的开发。正如你所看到的，通过<code class="fe lb lc ld le b">useReducer</code>使用reducers有更大的开销，但是它给了你一个清晰的结构，并且将一些逻辑保留在组件本身之外。虽然我是<a class="ae kc" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> MobX </a>的忠实粉丝，但是有一个预定义的钩子来使用减速器的可能性是很好的。它只是让你有可能以你喜欢的方式处理你的状态。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/bbea76f82fab3de06200408b8c88e903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6htRSu-GZiU0wo_uStebQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/photos/rBPOfVqROzY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿格巴洛斯</a>在<a class="ae kc" href="https://unsplash.com/search/photos/timer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="efd9" class="lm ln iq bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">AJAX、定时器、事件监听器等等</h1><p id="7313" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这些被称为副作用，意味着组件触发了页面或脚本中某处的变化，而这些变化不包含在组件本身中，也不局限于组件本身。假设我们想要进行一个后端调用，获取一些数据，然后用React呈现它。我们必须启动后端调用，它也将返回一些数据。无论组件是否仍然安装，调用都会返回。超时和间隔也是如此。</p><p id="ae29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用class-syntax，您可以编写一个<code class="fe lb lc ld le b">componentDidMount()</code>方法来启动请求，设置计时器或时间间隔等。——还有<code class="fe lb lc ld le b">componentWillUnmount()</code>收拾一切。我们如何用钩子做到这一点？</p><p id="eb08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">useEffect</code>是React团队的回答。它接受两个参数，一个是渲染后触发的函数，另一个是可能的状态值数组，这意味着如果且仅当其中一个值发生变化时，效果函数才会被触发。默认情况下，在每次(重新)渲染后，效果函数被调用<strong class="kf ir">。我们还可以从效果函数中返回另一个函数，姑且称之为清理函数。这将在卸载或每次(重新)渲染之前调用，取决于“监视”数组。</strong></p><p id="fd1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一下代码:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="02f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总结一下:</p><ol class=""><li id="12b3" class="no np iq kf b kg kh kk kl ko nq ks nr kw ns la nt nu nv nw bi translated">如果count的值触发了重新渲染，则在第一次渲染之后、每次渲染之后以及每次重新渲染之后，都会调用效果函数。</li><li id="376d" class="no np iq kf b kg od kk oe ko of ks og kw oh la nt nu nv nw bi translated">如果count的值触发了重新渲染，则清理功能会在重新渲染之前运行。此外，这正好在卸载之前运行。</li><li id="21d0" class="no np iq kf b kg od kk oe ko of ks og kw oh la nt nu nv nw bi translated">“watch”-数组(注意，这不是它的真名，我只是想解释一下意思)定义了在决定调用1时，React应该考虑哪些变量。第二。这可以指组件状态甚至道具。</li></ol><p id="d531" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当传递一个空数组<code class="fe lb lc ld le b">[]</code>时，没有任何变量需要“观察”，效果函数在第一次渲染后只运行一次。清理功能也是如此，它在卸载之前运行。</p><p id="1b0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您的用例，您必须提供React应该观察的变量。AJAX调用、超时和时间间隔应该只设置一次，而根据您的状态进行更改应该在每次您的状态改变时运行。</p><h2 id="ebbc" class="mv ln iq bd lo mw mx dn ls my mz dp lw ko na nb ma ks nc nd me kw ne nf mi ng bi translated">设置间隔</h2><p id="06e9" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在写这篇文章的时候，我想试用一下我常用的工具<code class="fe lb lc ld le b">setInterval</code>。我试着设置计数器来增加每秒的计数。我的第一次尝试是这样的:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f8d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为时间间隔应该设置一次，并且只在卸载前清理，将<code class="fe lb lc ld le b">[]</code>作为“监视”数组传递。玩了一圈后，我意识到有问题，计数器只增加一次。内部似乎有一个问题(React dev团队已知)，阻止了<code class="fe lb lc ld le b">setInterval</code>正常工作。我试图删除“watch”数组，认为我没有正确理解它，结果如下:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1aff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它在工作，但不正确。事实上，该间隔在组件渲染之前被中断，实际上触发了重新渲染本身，并在渲染之后重新开始。这将导致每个间隔有几毫秒的延迟。</p><p id="32a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">环顾四周，我发现推荐的解决方案是实现一个定制的挂钩:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:丹·阿布拉莫夫对<a class="ae kc" href="https://overreacted.io/making-setinterval-declarative-with-react-hooks/" rel="noopener ugc nofollow" target="_blank">反应过度</a></figcaption></figure><p id="59b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎区间回调在React的深处“迷失”了，需要手动处理它。我同意丹·阿布拉莫夫的说法:</p><blockquote class="ni nj nk"><p id="536c" class="kd ke nh kf b kg kh ki kj kk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">即使一个API简化了一百个用例，讨论也总是集中在变得更难的用例上。</p></blockquote><p id="0112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我不明白为什么首先，<code class="fe lb lc ld le b">useInterval</code> -hook没有包含在React本身中——<code class="fe lb lc ld le b">setInterval</code>不是一个病态用例，至少在我看来是这样——其次，为什么React文档中没有提到它。</p><blockquote class="ni nj nk"><p id="b635" class="kd ke nh kf b kg kh ki kj kk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">更新:文章这一部分的措辞不完全正确。从字面上看，没有“问题”，也没有什么“丢失”,这实际上是预期的行为，是由JavaScript闭包引起的。</p></blockquote><h2 id="509b" class="mv ln iq bd lo mw mx dn ls my mz dp lw ko na nb ma ks nc nd me kw ne nf mi ng bi translated">事件监听器</h2><p id="2cf8" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">根据文档，就性能而言，事件侦听器似乎可以在每次渲染时进行清理和设置。这意味着您可以省略“watch”数组。我认为在卸载之前只清理一次并保留事件监听器更干净，提供一个空的“监视”数组，如下所示:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><blockquote class="ni nj nk"><p id="0552" class="kd ke nh kf b kg kh ki kj kk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">更新:虽然这个设置适用于给定的示例，但是空的“watch”-array(dependencies-array)是否有利于这样做是有争议的。<a class="ae kc" href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" rel="noopener ugc nofollow" target="_blank">文档</a>声明传递一个空的“监视”数组是可能的，但不一定推荐，因为这可能会导致错误。“更干净”这个词可能应该换成“一开始更直观”。</p></blockquote><h2 id="436d" class="mv ln iq bd lo mw mx dn ls my mz dp lw ko na nb ma ks nc nd me kw ne nf mi ng bi translated">使用效果总结</h2><p id="7cdd" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在我看来效果似乎还不错。他们将<code class="fe lb lc ld le b">componentDidMount</code>、<code class="fe lb lc ld le b">componentWillUpdate</code>以及<code class="fe lb lc ld le b">componentWillUnmount</code>组合在一个API中，但是我认为它变得太复杂了。如果这些函数中的逻辑增加，组件的大小也会增加，尽管您可能应该使用更复杂的逻辑来实现<a class="ae kc" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">定制钩子</a>。返回一个清理函数确实感觉有点不舒服，并且调用默认渲染效果(设置+清理)的原因对我来说似乎不直观。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/e38893920d7bb09d85abb1762f3ee4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HydOFhyvnn5xugD1Unjazw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">查尔斯·弗劳恩德在<a class="ae kc" href="https://unsplash.com/search/photos/train-station?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="9e2c" class="lm ln iq bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">全球状态和环境</h1><p id="cd85" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">不久前React介绍了上下文。上下文应该用于定义和共享多个组件级别的状态，<strong class="kf ir">而</strong>不需要像<code class="fe lb lc ld le b">props</code>一样将状态向下传递到每个级别。基本上，这就是像Redux和MobX这样的状态管理系统的目标:以一种分离的和可伸缩的方式处理状态。使用上下文的想法是好的，但是声明和用法不是。为什么？要使用它，你必须用<code class="fe lb lc ld le b">&lt;Context.Consumer /&gt;</code>包装组件。有了钩子，hoc的必要性应该消失了，我们应该能够在我们的组件中直接使用上下文。</p><p id="ac0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React文档没有告诉我们太多关于用法的信息。我们得到的唯一一句话是:</p><pre class="mp mq mr ms gt oj le ok ol aw om bi"><span id="9aef" class="mv ln iq le b gy on oo l op oq">const context = useContext(Context);</span></pre><p id="bfa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个想法是检索上下文非常简单，无论上下文提供什么，您都可以通过<code class="fe lb lc ld le b">useContext</code>接收它。然而，自从引入上下文以来，对上下文状态的定义并没有改变。这意味着我们必须在组件本身中保持上下文状态，并在顶层呈现一个<code class="fe lb lc ld le b">&lt;Context.Provider /&gt;</code>(或者至少在上下文消费之上)。</p><p id="fb39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最终得到以下结果:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="947f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了处理上下文状态，我们最终创建了一个ContextProvider组件。拥有多个ContextProviders会导致混乱，一般来说，以组件的形式声明上下文没有多大意义。曾经，声明的上下文很容易被<code class="fe lb lc ld le b">useContext()</code>消耗掉。</p><p id="acd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理想的解决方案应该是这样的:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c5fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不知道语法可行性有多大。我假设当调用<code class="fe lb lc ld le b">useState()</code>或<code class="fe lb lc ld le b">useReducer()</code>钩子时，当前创建一个组件被订阅的状态。在我看来，为了上下文做同样的事情应该不成问题。此外，保存上下文状态的组件不做其他任何事情，所以为什么还要有那个组件呢。</p><p id="235a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不确定React hooks + context是否是可伸缩状态管理的可行解决方案。声明ContextProvider的最后一步似乎很繁琐。</p><p id="cba4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们目前只有来自上面的解决方案。最后，钩子是一种非常受欢迎的反应改进，不亚于向函数式方法的范式转变。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="f4ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nh">关于作者:Lukas Gisder-Dubé作为CTO共同创立并领导了一家初创公司1年半，建立了技术团队和架构。离开创业公司后，他作为首席讲师在</em><a class="or os ep" href="https://medium.com/u/1ff093a3da32?source=post_page-----4bb96fa7569d--------------------------------" rel="noopener" target="_blank"><em class="nh">iron hack</em></a><em class="nh">教授编程，现在正在柏林建立一家创业机构&amp;咨询公司。查看</em><a class="ae kc" href="https://dube.io" rel="noopener ugc nofollow" target="_blank"><em class="nh">Dube . io</em></a><em class="nh">了解更多。</em></p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/840b0ca008c4fa8e0a1d00791a6c9f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*p-l0Cee1IHvX0RQkVTOceQ.png"/></div></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><figure class="mp mq mr ms gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi ou"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="ov ow gp gr ox oy"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">gitconnected.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm jw oy"/></div></div></a></div></div></div>    
</body>
</html>