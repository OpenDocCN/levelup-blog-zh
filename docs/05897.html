<html>
<head>
<title>Clean REST API with NestJS and CQRS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NestJS和CQRS清理REST API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/clean-rest-api-with-nestjs-and-cqrs-37dac61e635b?source=collection_archive---------3-----------------------#2020-10-11">https://levelup.gitconnected.com/clean-rest-api-with-nestjs-and-cqrs-37dac61e635b?source=collection_archive---------3-----------------------#2020-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7a83b57bd64b82b065dfe9d7a09b0fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uc2_wrp5FlHGKzGR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@makmphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> MAKM摄影</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="1587" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在API无处不在，不管你喜不喜欢，如果你是一个软件工程师，你不能避免REST API，这就是它是多么的普遍。</p><p id="8e78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你决定在Node.js中创建另一个API，你可能会面临一个两难的选择……我应该使用哪个HTTP框架？有很多选项，包括最受欢迎的选择，如express、koa、loopback…和NestJS。</p><p id="df7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>是一个用于构建<a class="ae kc" href="http://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>服务器端应用的框架。它自带了大量的工具，其中很多都是受Angular的启发，比如模块、服务、依赖注入、CLI、管道等等。默认情况下，它使用TypeScript，但是如果您愿意，也可以使用VanillaJS。</p><p id="e564" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天我想展示一个简单的例子，一个用于管理书籍的干净的REST API。让我向你展示一下，在NestJS的<a class="ae kc" href="https://docs.nestjs.com/recipes/cqrs" rel="noopener ugc nofollow" target="_blank"> CQRS </a>模块的帮助下，它是如何完美地组织起来的。</p><p id="2c68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/Artix1500/clean-rest-api-with-nestjs" rel="noopener ugc nofollow" target="_blank">点击这里查看Github知识库。</a></p><p id="24a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将看一看大致的结构，然后我们将一步一步地分析它。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/359284b01f55721d2083e8146289d7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/0*6VSOMbxPQURI_fqP"/></div></figure><p id="55b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Main.ts —该文件负责从AppModule创建NestJS应用程序。</p><p id="50a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">app . module——项目的核心，这里我们导入提供功能的模块。</p><p id="44fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Books.module —该模块将由AppModule导入，以提供与我们的图书相关的所有内容。</p><p id="02e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Books.controller —这里我们用所有参数声明端点。</p><p id="fc31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实体——在这里，我们声明我们的Book类。</p><p id="0488" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DTO——数据传输对象——一组与应用程序通信的接口。</p><p id="2b6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">存储库、查询、命令——这些文件夹与CQRS相关，我们稍后会查看它们。</p><p id="adcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们来看代码！</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="97f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的计划是向你展示整个请求流程。让我们从模块开始。</p><h2 id="2971" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">书籍模块</h2><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="f6bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们可以看到这个模块、控制器和提供者的所有导入。<br/>如果我们仔细看看提供者的，我们可以看到，在这个模块中，我们提供了IdGenerator，它是一个抽象类，我们提供了UuidGenerator类。</p><p id="0237" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法允许我们创建多个适配器，然后提供它们。这种方法的最大好处之一是将代码解耦。假设我们想把UuidGenerator改成自己定制的生成器，怎么做呢？只需实现一个将扩展IdGenerator的类，在一个模块中提供它，就这样！</p><p id="05e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从现在开始，在这个模块范围内声明的所有试图使用注入的IdGenerator的东西实际上都在使用它，而不是UuidGenerator类。</p><h2 id="11a2" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">图书管理员</h2><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5258" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们的终点。让我们讨论有趣的部分。</p><p id="44ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">装饰者<br/> 通过使用装饰者，我们可以很容易地声明路径、方法和参数。阅读和定制非常简单。</p><p id="9fba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mi">构造函数中的依赖注入<br/></em>NestJS自带的强大特性！通过这种机制，我们可以将依赖注入到类中，而不必创建注入依赖的实例，我们将让NestJS为我们处理这一点！这里我们将使用它来注入commandBus和queryBus。为了解释这一点，我们将继续讨论…</p><h2 id="6511" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">CQRS</h2><p id="a77d" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">CQRS代表命令查询责任分离，它允许更好地扩展应用程序，处理复杂的业务逻辑，以及在更大的团队中更好地处理项目逻辑。当然，在这个项目中，可以很容易地跳过它，但是，我想展示用NestJS实现它是多么容易。</p><p id="20cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看一个简单查询GetBookQuery的流程。首先，我们必须从NestJS CSQR实现提供的queryBus上的book控制器中调用它:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8a3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么查询处理程序将接管控制权。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="e69c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们将使用注入的BookRepository来获取数据，就这样。让我们仔细看看BookRepository:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="037b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到它只是一个纯粹的抽象类，在模块中提供它是为了让你的实现尽可能的灵活。如果您向上滚动，可以看到BookRepository类是由BookRepositoryMemoryAdapter提供的:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="a843" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里只是为了开发，我们可以使用我们的存储的一些模拟实现，然后决定哪个数据库最适合我们。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="9657" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总而言之，有些人会说所有这些只是简单应用程序的额外代码。但是如果你想一想，你会注意到，这种方法实际上在你的架构中实施了良好的实践。</p><p id="0f3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你在这里找到一些有趣的东西，也许下次你会尝试NestJS！</p></div></div>    
</body>
</html>