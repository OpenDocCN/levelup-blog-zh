<html>
<head>
<title>Quantum Assembly Language 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">量子汇编语言101</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/quantum-assembly-language-101-4244f2bb2848?source=collection_archive---------12-----------------------#2022-02-07">https://levelup.gitconnected.com/quantum-assembly-language-101-4244f2bb2848?source=collection_archive---------12-----------------------#2022-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3052dc1fde08462fd37b5066eeb36de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*isn0dBCUdMMrDgPXyudutQ.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://commons.wikimedia.org/wiki/File:IBM_Q_system_(Fraunhofer_2).jpg" rel="noopener ugc nofollow" target="_blank">https://commons . wikimedia . org/wiki/File:IBM _ Q _ system _(Fraunhofer _ 2)。jpg </a></figcaption></figure><div class=""/><h1 id="6b14" class="kg kh jj bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">简单。直觉。强大。</h1><p id="9626" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">从美学角度来看，量子汇编语言(QASM)是C和汇编语言的完美结合。需要学习的命令非常少，如果您目前使用Qiskit之类的量子计算框架，您已经知道其中的大部分。然而，与那些框架使用的经典语言不同，没有任何操作与量子处理器或者至少是量子计算模拟器无关。使用QASM将你限制在量子计算上，除了量子计算什么都没有，这也是我推荐的量子计算方式。</p><p id="4850" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">QASM被<a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/what-is-transpilation-4d12d51e2aa4">转化为可以在量子处理器上执行的基本运算。这些基本操作随后被实现为微波脉冲，至少在超导transmon量子位的情况下，如IBM、Google和Rigetti所使用的那些。QASM简单地定义了用户友好的操作来构建电路，因为单独使用基本操作——你当然可以尝试这样做——是相当具有挑战性的。</a></p><p id="8c85" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">本文特别使用OpenQASM，它是IBM的QASM实现。QASM的其他实现非常相似；实现之间的转换应该只需要一两分钟。但是，您很可能会发现其他实现更加有限，因此，与新操作相反，可能会有一些约束需要学习。</p><h2 id="9789" class="mh kh jj bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">为什么是QASM？</h2><p id="6f4e" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Python是一种经典语言。Q#也是。所有其他可能适用于量子计算的语言也是如此。因此，你使用经典思想来设计你的算法，并建立你的量子电路。</p><p id="362e" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">另一方面，QASM迫使你定量思考。套用尤达的话来说，我们必须忘掉我们所学的东西。随着时间的推移，量子计算变得非常直观。事实上，如果我使用OpenQASM足够长的时间，我会导出到Qiskit，并且很难再进行经典思考。</p><p id="3133" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我建议使用QASM编辑器构建所有电路。只有当你绝对地、肯定地不能再前进时，才导出一个框架。经典地只做你不能有效地定量做的事情。</p><p id="61de" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">事不宜迟，让我们看一些代码…</p><h2 id="d536" class="mh kh jj bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">不要碰！</h2><p id="0332" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在每一个开口的顶端。qasm文件是两行特定代码。当你找到它们的时候就把它们留下。“include”文件qelib1.inc定义了您将在本文中读到的操作，因此您不必自己定义它们。其他QASM实现可能完全包含在各自的开发环境中，不一定需要任何代码行，但是OpenQASM，正如“open”所暗示的，并不特定于任何一个环境。如果您尝试一个新的平台并看到OpenQASM，这个“包含”文件有助于确保它是您将逐渐了解并喜欢的同一个OpenQASM。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="bf9e" class="mh kh jj my b gy nc nd l ne nf">OPENQASM 2.0;<br/>include “qelib1.inc”;</span></pre><h2 id="297a" class="mh kh jj bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">评论</h2><p id="e0f2" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你曾经做过任何类型的编程，你就会知道自由地注释你的代码是明智的。无论你想在单独一行还是在另一行的末尾留下评论，只需用两个正斜杠开始你的评论。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="f0bf" class="mh kh jj my b gy nc nd l ne nf">// This is a standalone comment.</span><span id="46dd" class="mh kh jj my b gy ng nd l ne nf">h q[0]; // This applies a Hadamard gate to qubit 0.</span></pre><h2 id="6fa2" class="mh kh jj bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">登记</h2><p id="30b9" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有两种寄存器，量子寄存器和经典寄存器。<em class="nh"> qreg </em>语句初始化量子寄存器，即量子位，而<em class="nh"> creg </em>语句确定我们希望在测量结果中包含多少经典位。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="0566" class="mh kh jj my b gy nc nd l ne nf">qreg name[size]; // Initialize a quantum register.</span><span id="0b87" class="mh kh jj my b gy ng nd l ne nf">creg name[size]; // Initialize a classical register.</span></pre><p id="6817" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">有一些没有记录的命名规则很容易被发现；错误将被加下划线。例如，<em class="nh">爱丽丝</em>是不允许的，但是<em class="nh">爱丽丝</em>是允许的。物理量子位是按顺序分配的，所以如果爱丽丝[2]在鲍勃[3]之前，爱丽丝将被分配量子位0和1，鲍勃将被分配量子位2、3和4。我还没有发现对你可以命名的寄存器数量的任何限制，但是如果你试图初始化比你可用的更多的量子位，当你试图运行它时，任务将不会排队。在IBM Quantum中，有一条错误消息显示得非常短暂，因此您更有可能注意到作业从未完成，然后当您调查时，您会注意到作业从未排队。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="ec42" class="mh kh jj my b gy nc nd l ne nf">qreg alice[2]; // quantum register: Alice has qubits 0 and 1<br/>qreg bob[3]; // quantum register: Bob has qubits 2, 3, and 4<br/>creg mid[2]; // classical register: mid-circuit measurements<br/>creg final[3]; // classical register: final measurements</span></pre><h2 id="bdfa" class="mh kh jj bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">基本操作</h2><p id="aaf7" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">虽然您通常会发现比您在这里所读到的更多的操作，但我将只讨论其中的要点。你可以用非常少的门电路构建你可能需要的所有电路。</p><p id="2db5" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk"> U </strong></p><p id="64b5" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">U gate是您转换单个量子位的一站式商店。虽然自变量的顺序是theta，phi，lambda，但它们应该是lambda，theta，phi。实际旋转是绕z轴的λ弧度，然后是绕y轴的θ弧度，然后是绕z轴的φ弧度。大家可以看到，如此多的其它操作，例如S、T和Z门，都可以用U门和phi或lambda旋转来代替。</p><p id="c94c" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">声明:你仍然可以使用你最喜欢的门，比如H和X，我只是说仅仅学习和掌握一个单量子比特操作是可能的。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="5b0a" class="mh kh jj my b gy nc nd l ne nf">U(theta,phi,lambda) qubit|qreg;</span><span id="e769" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: U(pi/2, 0, pi) q[0]; // Rotate qubit 0 1/2 around the z axis then 1/4 around the y axis; it's a Hadamard gate!</span><span id="0a1c" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: U(pi/2, 0, pi) q; // Rotate all qubits in the q register 1/2 around the z axis then 1/4 around the y axis; apply Hadamards to an entire register.</span></pre><p id="f0b7" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk"> CU3 </strong></p><p id="b17b" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">CU3 gate是您控制转变的一站式商店。目标量子位的旋转与U门的描述完全一样。但是，目标量子位只有在控制量子位为1时才会转换。</p><p id="3c30" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">声明:和U gate一样，我不会介意你使用更简单的语句，比如CX和CZ；同样，我只是指出，你可以学习和掌握仅仅一个多量子比特操作。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="f8cf" class="mh kh jj my b gy nc nd l ne nf">CU3(theta,phi,lambda) control qubit|qreg, target qubit|qreg;</span><span id="5cec" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: CU3(pi, 0, pi) alice[0], bob; // If Alice’s qubit 0 is 1, rotate all of Bob’s qubits 1/2 around the z axis and then 1/2 around the y axis; it's a CX, aka CNOT, aka controlled-X, aka controlled-NOT!</span></pre><p id="f0b2" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk"> CCX </strong></p><p id="1501" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">CCX门也被称为托夫里门、受控-受控-X门、受控-受控-非门、和门。它实现布尔和逻辑，并用于构建涉及两个以上量子位的自定义操作。从技术上讲，你可以用多个U门和CU3门来实现CCX，但是CCX更容易使用，值得包含在内。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="655f" class="mh kh jj my b gy nc nd l ne nf">ccx control qubit|qreg, control qubit|qreg, target qubit|qreg;</span><span id="b956" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: ccx q[0], q[1], q[2]; // If qubit 0 and qubit 1 are both 1, rotate target qubit 2 1/2 around the x axis.</span></pre><p id="51b4" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk">测量</strong></p><p id="3811" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这就是我们如何从量子位中提取信息。如果量子寄存器和经典寄存器的大小相同，就有捷径可走。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="9948" class="mh kh jj my b gy nc nd l ne nf">measure qubit|qreg -&gt; bit|creg;</span><span id="c802" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: measure q[0] -&gt; c[0]; // Measure qubit 0 to classical bit 0.</span><span id="75e3" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: measure q -&gt; c; // If q and c are the same size, measure all qubits in quantum register q to classical register c.</span></pre><h2 id="06cb" class="mh kh jj bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">中间操作</h2><p id="aa77" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">以下操作不太常见，但它们有令人兴奋的应用。</p><p id="c65e" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk"> CSWAP </strong></p><p id="a290" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">受控交换，又名Fredkin，有<a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/comparing-quantum-states-c6445e1e46fd">量子机器学习(QML) </a>应用，如<a class="ae jg" href="https://medium.com/swlh/quantum-classification-cecbc7831be" rel="noopener">分类</a>和<a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/quantum-clustering-c498b089b88e">聚类</a>。这些都超出了本文的范围，但是请随意访问这些链接。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="a5c5" class="mh kh jj my b gy nc nd l ne nf">cswap control qubit|qreg, control qubit|qreg, target qubit|qreg;</span><span id="7741" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: cswap q[0], q[1], q[2]; // If control qubit 0 is 1, SWAP target qubits 1 and 2.</span></pre><p id="7657" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk">屏障</strong></p><p id="2841" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">因为我写这些文章，所以我主要使用栅栏来使电路更美观，并以这样一种方式清楚地划分电路，以便于解释每个部分在做什么。然而，在运行一个电路之前，移除障碍通常是一个好主意，这样transpiler可以优化您的电路。然而，您可能仍然希望将屏障用于非美学目的。例如，您可以使用隔离栅来防止传输器优化电路的某些部分，以使操作和测量更接近的方式延迟操作，从而最大限度地减少退相干。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="5daa" class="mh kh jj my b gy nc nd l ne nf">barrier qargs;</span><span id="d507" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: barrier q[0]; // Place a barrier on an individual qubit.</span><span id="3578" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: barrier alice, bob; // Extend a barrier through Alice's and Bob's qubits.</span></pre><p id="17fc" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk">复位</strong></p><p id="885f" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">重置门不仅允许你回收和再利用量子位，它们还允许你实现<a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/quantum-pseudo-conditional-logic-8134ddff1063">伪条件逻辑</a>操作。IBM将在OpenQASM 3中正式允许条件逻辑，但是在此期间，您可以通过reset gates非正式地实现相同的效果。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="abcb" class="mh kh jj my b gy nc nd l ne nf">reset qubit|qreg;</span><span id="600b" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: reset q[0]; // Reset one specific qubit.</span><span id="d1bb" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: reset q; // Reset all qubits in the q register.</span></pre><h2 id="e80a" class="mh kh jj bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">高级操作</h2><p id="51eb" class="pw-post-body-paragraph le lf jj lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这些操作通常以传统方式执行，但也可以在电路运行时执行。将作业发送到量子处理器并运行一次，比运行作业、检索结果、运行一些经典代码、运行另一个作业、检索结果等等要快。每次从稀释冰箱到芯片来回都浪费时间。</p><p id="d842" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk">子程序</strong></p><p id="0ca4" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">IBM Quantum使用术语“子例程”，所以我将在这里使用这个术语。然而，根据您选择的编程语言，您会发现它的用法是多种同义名称。我在这里可以互换使用的另一个术语是“自定义门”，因为在量子计算术语中，它本质上就是简单的子例程。</p><p id="5ea3" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">想象一下，我想通过应用一系列交替的H和T门，将一个量子位置于任意的量子态。例如，我可以定义一个自定义的门控ht，应用序列的一次迭代。这当然不是很有想象力，但关键是你可以定义任何你可以构建的自定义门。</p><p id="5ffa" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">当然，子程序并不局限于简单的操作。它们的复杂性大多受限于你的想象力。但是，我建议慢慢构建它们，因为有一些未公开的限制。例如，除非他们改变了这一点，否则我在调用子例程之前必须应用重置门，因为重置门在子例程中不起作用。因为那是未发表的，我并不声称知道每一个未发表的限制。</p><p id="e860" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">同样值得注意的是，你可以嵌套子程序。换句话说，一个子程序可以调用另一个。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="802c" class="mh kh jj my b gy nc nd l ne nf">gate name(params) qargs { body }</span><span id="4e7c" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: gate ht a { h a; t a; } // Define a custom gate ht that accepts a qubit or quantum register "a" as an argument and applies a Hadamard gate then a T gate in sequence.</span><span id="810c" class="mh kh jj my b gy ng nd l ne nf">gatename(params) qargs;</span><span id="6bd0" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: ht q[0]; // Apply custom gate ht to qubit 0.</span></pre><p id="7edd" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk">用于循环</strong></p><p id="f262" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">尽管QASM没有FOR语句，但调用带有量子寄存器的子例程具有运行FOR循环的效果。子例程应该在执行期间迭代通过该寄存器的每个量子位。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="ecc1" class="mh kh jj my b gy nc nd l ne nf">gatename qreg;</span><span id="b4f3" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: g qr1; // Apply custom gate g to every qubit of quantum register qr1.</span><span id="6475" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE: g qr0[0], qr1, qr2[0], qr3; // Run subroutine g with the 0th qubit of quantum register qr0, the 0th qubit of quantum register qr2, and all of the qubits in quantum registers qr1 and qr3. Disclaimer: this only works if qr1 and qr3 are the same size.</span></pre><p id="d839" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk">条件逻辑</strong></p><p id="b67c" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">你还不能在IBM量子处理器上实现条件逻辑，尽管你可以实现我称之为<a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/quantum-pseudo-conditional-logic-8134ddff1063">的伪条件逻辑</a>。同时，您可以在模拟器中练习使用IF语句。</p><p id="96aa" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">值得注意的是，条件运算可以是任何量子运算。与QASM的任何其他行不同的是，只有在满足所提供的条件时才应用该操作。</p><p id="1c5e" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">此外，还使用了整个经典音域。例如，如果“syn”经典寄存器的大小为2，那么它可以接受2个测量值。虽然测量值是二进制的，但条件是十进制值的十进制表示。1量子位寄存器接受0 (0)和1 (1)作为条件，而2量子位寄存器接受0 (00)、1 (01)、2 (10)和3 (11)作为条件，以此类推。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="a967" class="mh kh jj my b gy nc nd l ne nf">if(creg==int) qop;</span><span id="362b" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE, PART 1: measure q[0] -&gt; syn[0]; measure q[1] -&gt; syn[1]; // Measure qubits 0 and 1 to syndrome bits. Syndrome bits are introduced with Quantum Error Correction (QEC), but they are not limited to that role. In this example, they would've been defined with creg syn[2]; earlier in the code. As with all registers, you can use any valid name.</span><span id="27ff" class="mh kh jj my b gy ng nd l ne nf">EXAMPLE, PART 2: if(syn==3) x q[1]; // If the syndrome bits measured 11, which is binary for 3, apply a Pauli-X gate to qubit 1. </span></pre><p id="01ac" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg jk">延伸阅读</strong></p><p id="85bf" class="pw-post-body-paragraph le lf jj lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">OpenQASM的最佳资源是<a class="ae jg" href="https://arxiv.org/pdf/1707.03429.pdf" rel="noopener ugc nofollow" target="_blank">规范</a>和<a class="ae jg" href="https://quantum-computing.ibm.com/composer/docs/iqx/operations_glossary" rel="noopener ugc nofollow" target="_blank">操作词汇表</a>。编码快乐！</p></div></div>    
</body>
</html>