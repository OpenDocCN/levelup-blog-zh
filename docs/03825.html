<html>
<head>
<title>Allow users to edit the content of any element with this Angular directive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">允许用户使用此角度指令编辑任何元素的内容</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/allow-users-to-edit-the-content-of-any-element-with-this-angular-directive-7b8fdb5bb800?source=collection_archive---------12-----------------------#2020-05-28">https://levelup.gitconnected.com/allow-users-to-edit-the-content-of-any-element-with-this-angular-directive-7b8fdb5bb800?source=collection_archive---------12-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ea6cf363f00eae2467eaa07e45a1aea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKcBPrwAFuCkZ3DYOs77eA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片鸣谢:<a class="ae kf" href="https://www.freepik.com/elnurfreepik" rel="noopener ugc nofollow" target="_blank"> elnurfreepik </a> @Freepik</figcaption></figure><p id="5cee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个兼职项目，我正在用Angular开发一个笔记/学习辅助应用程序。我的一个主要目标是使它尽可能的用户友好，所以我决定做一个角度指令，它有如下作用:</p><ol class=""><li id="8b24" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">允许用户点击文本来编辑内容</li><li id="abb7" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">可以通过要求用户首先点击编辑图标来限制编辑，实质上是进入编辑模式</li><li id="96d0" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">检查当输入失去焦点或当用户点击“Enter”时文本是否被修改</li><li id="311f" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">保存修改过的文本</li></ol><h1 id="8278" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">该指令具有以下属性:</h1><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e109" class="mz lt it mv b gy na nb l nc nd">// Use this variable to store the original value<br/>  value: string;</span><span id="8dc1" class="mz lt it mv b gy ne nb l nc nd">  // Use this input if you want to restrict editing to only be allowed in edit mode <br/>  @Input() allowEdit: boolean = true;</span><span id="8db7" class="mz lt it mv b gy ne nb l nc nd">  // Use this input if you are saving the change and need to reference the identifier of the change<br/>  @Input() id: number;</span><span id="40ca" class="mz lt it mv b gy ne nb l nc nd">  // Use this input to indicate what field is being changed<br/>  @Input() update: string;</span><span id="d8df" class="mz lt it mv b gy ne nb l nc nd">  // Use this output to notify the parent that a change has been made<br/>  @Output() onChange: EventEmitter&lt;EditUpdate&gt; = new EventEmitter();</span></pre><h1 id="a1b3" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">对于构造函数，您需要:</h1><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="67f6" class="mz lt it mv b gy na nb l nc nd">// Automatically get a reference to the element you're changing with ElementRef<br/>  private el: ElementRef</span><span id="7004" class="mz lt it mv b gy ne nb l nc nd">  // Safely update the element without accessing the DOM directly by using Renderer2<br/>  private renderer: Renderer2</span></pre><h1 id="5b76" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用HostListener检测事件</h1><p id="9c86" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">使用<a class="ae kf" href="https://angular.io/api/core/HostListener" rel="noopener ugc nofollow" target="_blank"> HostListener </a>的好处在于，你不必跟踪谁在发送事件，因为顾名思义，它是你添加了指令的任何对象的主机。(对我来说，这才是指令的真正力量！)</p><p id="93f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着不再有多余的代码来单独分配事件侦听器，然后将它们挂接到包含回调的函数，这些回调是在事件发生时您希望发生的。不再需要构建层次关系，这样就可以相对于周围的元素来修改元素！</p><p id="0951" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个指令，我有三个HostListeners，因为我想检测用户何时单击元素，何时离开元素，以及何时按下键盘上的“Enter”。</p><h1 id="9530" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">检测点击事件的主机监听器</h1><p id="c8f3" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">如果您想切换编辑功能，可以在处理click事件的函数周围包装一个If语句。因为父元素决定了元素是否应该是可编辑的，所以您不必担心切换这个变量。(我将在本文后面介绍如何重置变量。)</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="acf9" class="mz lt it mv b gy na nb l nc nd">@HostListener("click") onClick() {<br/>  if (this.allowEdit) {<br/>    this.makeEditable();<br/>  }<br/>}</span></pre><h1 id="89e8" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">默认情况下使编辑不自动的一些原因</h1><ol class=""><li id="0e51" class="le lf it ki b kj nf kn ng kr nk kv nl kz nm ld lj lk ll lm bi translated">您希望只允许某些具有适当权限的用户编辑文本。</li><li id="4178" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">您希望文本在未被编辑时是可选的。</li><li id="107b" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">您希望限制意外编辑的可能性。</li></ol><h1 id="852b" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">HostListeners检测用户何时完成编辑</h1><p id="4c75" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">当第一次制定这个指令时，我花了很多时间创建一个保存/撤销按钮交互，它隐藏/显示不同模式下的其他功能，但后来放弃了这种方法，因为它要求用户不必要地单击。毕竟，没有什么比因为忘记点击保存而丢失所有工作更令人沮丧的了。</p><p id="b52c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我创建了一个用于当用户点击其他地方的时候，另一个用于监听“回车”键。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="4869" class="mz lt it mv b gy na nb l nc nd">@HostListener('blur') blurred() {<br/>  this.checkValues();<br/>}</span><span id="9c77" class="mz lt it mv b gy ne nb l nc nd">@HostListener('keydown', [('$event')]) onKeydown(event) {<br/>  if (event.keyCode === 13) {<br/>     event.preventDefault();<br/>     this.checkValues();</span><span id="34fc" class="mz lt it mv b gy ne nb l nc nd">  }<br/>}</span></pre><h1 id="0a5e" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">进入编辑模式</h1><p id="bfda" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">你可以使用<a class="ae kf" href="https://angular.io/api/core/ElementRef" rel="noopener ugc nofollow" target="_blank"> ElementRef </a>来识别元素，而不是查询DOM和<a class="ae kf" href="https://angular.io/api/core/Renderer2" rel="noopener ugc nofollow" target="_blank"> Renderer2 </a>来操作它。这个函数简单地将编辑类添加到元素中，从而向用户提供可视的反馈，表明元素现在是可编辑的了。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ae04" class="mz lt it mv b gy na nb l nc nd">makeEditable() {<br/>  this.renderer.addClass(this.el.nativeElement, "editing");<br/>  this.renderer.setAttribute(this.el.nativeElement, "contentEditable", "true");<br/>  this.el.nativeElement.focus();<br/>  this.setValue(this.el.nativeElement.innerText);<br/>}</span></pre><h1 id="ffec" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">检查是否进行了编辑</h1><p id="58b7" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">接下来，将<a class="ae kf" href="https://www.w3schools.com/tags/att_global_contenteditable.asp" rel="noopener ugc nofollow" target="_blank">‘内容可编辑’</a>属性设置为‘真’。然后，给它焦点，保存内部文本的值。</p><p id="5490" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在用户完成编辑后，我们将比较内部文本的值和之前的文本，看看是否有任何变化。这样，只有当有差异时，我们才会将数据发送给父节点，从而减少不必要的数据库访问次数。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="2a85" class="mz lt it mv b gy na nb l nc nd">checkValues(): Observable&lt;EditUpdate&gt; {<br/>  const newValue = this.el.nativeElement.innerText;</span><span id="3065" class="mz lt it mv b gy ne nb l nc nd">  if (this.value !== newValue) {<br/>    const edit: EditUpdate = {<br/>    id: this.id,<br/>    update: this.update,<br/>    value: newValue<br/>    }<br/>    this.onChange.emit(edit);<br/>  }</span><span id="6660" class="mz lt it mv b gy ne nb l nc nd">  this.reset();<br/>  return this.onChange;<br/>}</span></pre><h1 id="47e2" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">退出编辑模式</h1><p id="6fac" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">不要忘记通过移除“editing”类并将“contentEditable”设置为“false”来重置编辑模式</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7d30" class="mz lt it mv b gy na nb l nc nd">reset() {<br/>  this.editing = false;<br/>  this.renderer.removeClass(this.el.nativeElement, "editing");<br/>  this.renderer.setAttribute(this.el.nativeElement, "contentEditable", "false");<br/>}</span></pre><h1 id="d829" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">最终产品</h1><p id="b411" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">这是全部的代码。希望你喜欢！</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure></div></div>    
</body>
</html>