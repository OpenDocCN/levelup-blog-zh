<html>
<head>
<title>Basics of CI/CD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CI/CD基础</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basics-of-ci-cd-a98340c60b04?source=collection_archive---------0-----------------------#2021-10-24">https://levelup.gitconnected.com/basics-of-ci-cd-a98340c60b04?source=collection_archive---------0-----------------------#2021-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8511" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何软件项目的主要目标都是通过业务流程的自动化来赚钱。你越快向客户发布新版本，对你的公司越有利。但是如何以一种<em class="kl">快速</em>的方式实现发布过程呢？你可以手动操作。例如，可以通过SSH连接到远程服务器。然后，您可以用新代码克隆存储库，构建它，并使用命令行运行它。虽然它确实有效，但这不是一个有效的方法。所以，今天我们讨论产品发布和开发过程本身的自动化。</p><p id="072c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CI和CD是两个缩写，分别代表<em class="kl">持续集成</em>和<em class="kl">持续交付</em>。</p><h1 id="1760" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">海峡群岛</h1><p id="e07a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><em class="kl">持续集成</em>描述了变更流向存储库的过程。让我们来看一个简单的模式，它给出了一个团队开发的例子。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/23009e8b5705b2edc9dc5aed6955ea28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i_Qk7yIdHyi7DQr4.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">基本团队发展</figcaption></figure><p id="6e09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一群人可以同时工作。但是所有的更改最终都会转移到<code class="fe mf mg mh mi b">master</code>分支。无论如何，即使是这样一个简单的模型也引发了一些问题。</p><ol class=""><li id="a299" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">我们怎么知道去<code class="fe mf mg mh mi b">master</code>分支的代码编译了？</li><li id="0f34" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">我们希望开发人员为代码编写测试。我们如何验证<a class="ae mx" href="https://en.wikipedia.org/wiki/Code_coverage" rel="noopener ugc nofollow" target="_blank">测试覆盖率</a>没有减少？</li><li id="1ded" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">所有团队成员都应该用指定的代码样式格式化代码。我们如何检查可能的违规行为？</li></ol><p id="842f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，所有描述的需求都可以手工验证。尽管这种方法非常混乱。更重要的是，当团队成长时，保持它变得更加困难。</p><p id="977c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CI被用来自动化所陈述的提议。</p><p id="995e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先说第一点。我们如何检查即将到来的变化不会破坏构建？为此，我们的模式中需要另一个块。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/7a08aea730d4a643a87c09c9d5e5b4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e8OZ7kl-T1kH9lrC.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">基础CI</figcaption></figure><p id="c70b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数CI流程都可以根据该算法进行描述。</p><ol class=""><li id="dbb8" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">在每次打开拉请求(以及推送新的变更)时，Git服务器都会向CI服务器发送一个通知。</li><li id="6cdf" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">CI服务器克隆存储库，签出到源分支(例如，<code class="fe mf mg mh mi b">bugfix/wrong-sorting</code>)，并与<code class="fe mf mg mh mi b">master</code>分支合并。</li><li id="db99" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">然后启动构建脚本。例如，<code class="fe mf mg mh mi b">./gradlew build</code>。</li><li id="ccb1" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">如果命令返回0代码，则构建成功。否则，它将被视为失败。</li><li id="753f" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">CI服务器将带有构建结果的请求发送给Git服务器。</li><li id="1229" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">如果构建成功，那么就允许合并拉请求。否则，合并将被阻止。</li></ol><p id="fe38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该过程保证任何进入<code class="fe mf mg mh mi b">master</code>分支的代码都不会破坏进一步的构建。</p><h1 id="8456" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">测试覆盖检查</h1><p id="0747" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们把任务变得更复杂。假设我们想要设置最小的测试覆盖率。所以，在任何时候，<code class="fe mf mg mh mi b">master</code>分支的覆盖率都不能低于<code class="fe mf mg mh mi b">50%</code>。<a class="ae mx" href="https://www.eclemma.org/jacoco/" rel="noopener ugc nofollow" target="_blank"> Jacoco插件</a>可以轻松解决问题。如果测试覆盖值小于可接受的值，您只需要以使构建失败的方式来配置它。</p><p id="a5b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法实现是小菜一碟。但是它有一个警告。只有在项目启动后配置了插件，它才能工作。</p><p id="a248" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下，你正在开发一个已经有五年历史的产品。自从第一次提交以来，没有进行过测试覆盖检查。开发人员在没有任何纪律的情况下随机添加测试。但是有一天你决定增加测试次数。您调整Jacoco插件，使最小bar等于<code class="fe mf mg mh mi b">60%</code>。过了一会儿，开发人员打开一个新的拉请求。然后他们突然意识到测试覆盖率只有<code class="fe mf mg mh mi b">30%</code>。因此，为了成功地完成任务，必须至少覆盖产品代码的<code class="fe mf mg mh mi b">30%</code>。正如你可能猜到的，对于这个历时五年的项目来说，这几乎是一个无法解决的问题。</p><p id="0807" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们只验证<em class="kl">即将到来的</em>代码变更，而不是整个产品，会怎么样？如果一个开发人员在Pull请求中修改了200行，他们将需要覆盖其中的至少120行(如果测试覆盖率栏等于<code class="fe mf mg mh mi b">60%</code>)。但是没有必要遍历大量不属于该任务的模块。这可以解决问题。我们如何将它应用到项目中？谢天谢地，有一个解决方案。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/40c502e26a99f4a263f9805cff404d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VCqOW3LiIdIdEi2V.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">带测试覆盖检查的CI</figcaption></figure><p id="d85a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Jacoco报告被发送到测试覆盖服务器。</p><blockquote class="my mz na"><p id="7a22" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated"><a class="ae mx" href="https://sonarcloud.io/" rel="noopener ugc nofollow" target="_blank"><em class="iq">sonar cloud</em></a><em class="iq">是最流行的解决方案之一。</em></p></blockquote><p id="da11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器保存以前计算的统计数据。计算即将到来的变化的测试覆盖率以及整个代码是有益的。然后，分析结果被发送到CI服务器，CI服务器将其发送回Git服务器。</p><p id="589b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个工作流程提供了一个在任何产品发展阶段应用强制测试文化的机会。因为只有新的更改被验证。</p><p id="c8c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说到代码风格，没有太多不同。可以试试<a class="ae mx" href="https://checkstyle.sourceforge.io/" rel="noopener ugc nofollow" target="_blank"> Checkstyle </a>插件。如果构建违反了任何规定的需求，它会自动失败。例如，代码可能有一个未使用的导入。此外，您可以查看运行代码分析并将结果显示为一堆图表的云服务(SonarCloud也可以做到这一点)。</p><h1 id="9df5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">激光唱片</h1><p id="e57f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><em class="kl">连续交付</em>描述了新产品版本自动部署的过程。</p><p id="e22b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们对CI模式进行一些更改。这就是CI/CD流程在实际项目中的样子。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/83c3743601098ce62edb14a42f13d895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZcP17MPVQvY4cpWV.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">CI/CD流程</figcaption></figure><p id="6f86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，CI服务器现在命名为<em class="kl"> CI/CD服务器</em>。事实上，CI和CD作业通常都是由同一个任务管理器执行的。所以，我们正在研究这种方法。</p><blockquote class="my mz na"><p id="7a91" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">虽然这不是规则。例如，可以将CI作业委托给<a class="ae mx" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"><em class="iq">git lab CI</em></a><em class="iq">，将CD作业委托给</em><a class="ae mx" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"><em class="iq">Jenkins</em></a><em class="iq">。</em></p></blockquote><p id="da20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模式的右边部分代表CI。我们之前已经讨论过了。左边一张图片光盘。CD作业构建项目(或者重用CI阶段生成的工件)并将其部署到最终服务器。</p><blockquote class="my mz na"><p id="442d" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">值得一提的是，服务器<em class="iq">在我们的例子中是一个抽象。例如，部署可能会进行到</em><a class="ae mx" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"><em class="iq">Kubernetes</em></a><em class="iq">集群。因此，可能有几个服务器。</em></p></blockquote><p id="99a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署阶段完成后，通常会发送电子邮件。例如，CD服务器可以通知订户成功或失败的部署。</p><p id="d9f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反正有个重要的问题。我们应该何时运行CD作业？触发因素可能有所不同。</p><ol class=""><li id="a7a1" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">在每个拉请求合并后部署。</li><li id="45c0" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">根据时间表进行部署。</li><li id="5ed4" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">在每个拉请求合并到特定分支后部署。</li><li id="bf72" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">组合选项。</li></ol><p id="35e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一点设置流程，使CI和CD作业始终按顺序运行。这种方法在开源开发中相当流行。<a class="ae mx" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>库帮助调优项目，透明地集成这个过程。</p><blockquote class="my mz na"><p id="d50b" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated"><em class="iq">了解</em> <code class="fe mf mg mh mi b"><em class="iq">deploy</em></code> <em class="iq">的定义很重要。并不一定意味着某个地方正在推出什么东西。如果你开发一个库，那么就没有</em>推出<em class="iq">。相反，部署过程意味着新库版本的发布。</em></p></blockquote><p id="54e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二点独立于CI流程。因为项目是根据一些预定义的时间表部署的。比如每天早上<code class="fe mf mg mh mi b">01:00</code>的时候。</p><p id="8d6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三点和第一点类似。尽管存在差异。假设我们的存储库中有两个主要分支。<code class="fe mf mg mh mi b">develop</code>分支和<code class="fe mf mg mh mi b">master</code>分支。<code class="fe mf mg mh mi b">develop</code>包含了最相关的变化。而第二个只有发行版。如果我们只需要部署<code class="fe mf mg mh mi b">master</code>分支，就不需要在合并到<code class="fe mf mg mh mi b">develop</code>时触发CD作业。</p><p id="7af0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点是所有方法的汇总。例如，<code class="fe mf mg mh mi b">develop</code>分支可能会根据开发环境的时间表进行部署。并且<code class="fe mf mg mh mi b">master</code>被部署到每个拉请求合并的生产中。</p><h1 id="35a8" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">工具</h1><p id="04d9" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">市场提供了数十种自动化CI/CD流程的解决方案。让我们来看看其中的一些。</p><ol class=""><li id="a72e" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">詹金斯。世界上最受欢迎的CI/CD工具之一。由于它的开源政策，它变得如此受欢迎。所以，你什么都不用付。Jenkins允许用<a class="ae mx" href="https://groovy-lang.org/" rel="noopener ugc nofollow" target="_blank"> Groovy </a>强制性地描述构建管道。一方面，它提供了更多的灵活性。但另一方面，它需要更高的能力水平。</li><li id="6e00" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae mx" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>。CI/CD工具包含在GitHub和GitHub Enterprise中。与Jenkins不同，GitHub Actions提供了带有YAML配置的声明性构建。此外，该解决方案还与不同的质量保证系统(例如SonarCube)进行了大量集成。因此，可以用几行文字来描述这个构建。</li><li id="a17e" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae mx" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"> GitLab CI </a>。它与GitHub操作非常相似。然而，它有自己的特点。例如，GitLab CI可以指出构建失败的特定测试。</li><li id="5591" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae mx" href="https://www.travis-ci.com/" rel="noopener ugc nofollow" target="_blank">特拉维斯CI </a>。云CI/CD服务。它提供了许多不需要复杂配置的功能。例如，应该隐藏在公共存储库中的数据的加密。此外，Travis CI的好处是可以完全免费地应用于GitHub、GitLab和BitBucket开源公共项目。</li></ol><h1 id="9feb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="22e9" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这就是我想说的关于CI/CD流程的基础知识。如果您有任何问题或建议，请在下面留下您的评论。感谢阅读！</p></div></div>    
</body>
</html>