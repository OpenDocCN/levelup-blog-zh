<html>
<head>
<title>Phantom Reads: Race condition on Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幻影读取:数据库上的竞争条件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/phantom-reads-race-condition-on-database-45a2990efc97?source=collection_archive---------6-----------------------#2021-05-16">https://levelup.gitconnected.com/phantom-reads-race-condition-on-database-45a2990efc97?source=collection_archive---------6-----------------------#2021-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b4b582f7bce2669c733f1eed4ae2f318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQan6O-UhiSdj2bmUOTsWA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">基础图片:<a class="ae kc" href="https://www.techgig.com/" rel="noopener ugc nofollow" target="_blank">https://www.techgig.com/</a></figcaption></figure><p id="f27b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> T </span>何数据库<a class="ae kc" href="https://www.guru99.com/dbms-transaction-management.html" rel="noopener ugc nofollow" target="_blank">交易</a>中<a class="ae kc" href="https://www.educative.io/edpresso/what-are-acid-properties-in-a-database" rel="noopener ugc nofollow" target="_blank">酸</a>的故事和时间一样古老，但人们对这些性质的理解却存在着很多困惑和歧义。我见过有人有这种误解，认为既然他们使用的数据库提供了ACID支持，那么默认情况下一切都会高度一致。嗯，这种说法是不正确的。如果你不相信我，继续读下去，我会证明给你看。</p><p id="3422" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在支持ACID的SQL数据库中也会出现许多一致性和隔离问题，其中大部分是由于我们系统的并发性而产生的。原子性、一致性和持久性有些简单，但是您在系统中可能面临的大多数问题可能是由于隔离造成的。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="1941" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">隔离</h1><p id="6b48" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">让我们首先理解隔离在数据库事务的上下文中意味着什么。简单地说，隔离意味着，如果有多个数据库事务同时发生，它们不应该相互影响，数据库引擎应该以这样一种方式处理它们，即并发事务应该像串行执行的事务一样。数据库支持不同的隔离级别，每个级别都可以防御某些类型的<a class="ae kc" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)" rel="noopener ugc nofollow" target="_blank">隔离问题</a>。但是隔离的定义会因提供者的不同而不同。这里有一个非常有趣的不同db提供的隔离级别对比[ <a class="ae kc" href="https://fauna.com/blog/a-comparison-of-scalable-database-isolation-levels" rel="noopener ugc nofollow" target="_blank">链接</a> ]。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="6d80" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">幻像读取</h1><p id="aec6" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">现在让我们来看这篇文章的实际主题，即幻像读取。这也是由于数据库中的弱隔离保证而引起的异常之一。很难从理论上解释这一点，因此我将尝试用一个例子来解释这一点。</p><p id="de6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您正在为Amazon构建一个订购系统，这是用户下订单时发生的情况。</p><ol class=""><li id="9882" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated">获取项目计数</li><li id="9685" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">检查计数是否大于0</li><li id="47c0" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">如果为真，则将该项的计数减1</li><li id="10a9" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">创建订单</li></ol><p id="adea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单吧？LOL，不太会。让我们试着看看在一个高度并发的系统中这是如何引起问题的。</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/308805f97c8006b0b88aee90cf0e1c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxAhOmONC0txFobw2o4waA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">平行交易</figcaption></figure><p id="57d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来理解这个图表</p><ol class=""><li id="7f0a" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated">数据库中的项目计数为1。</li><li id="9e0f" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">用户1获取计数，并返回1。</li><li id="f329" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">用户2获取计数并返回1。</li><li id="67cf" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">用户1看到count &gt; 0，假定该商品可用并下了订单，并将count减1。</li><li id="caaa" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">用户2看到count &gt; 0，假定该商品可用并下了订单，并将count减1。</li><li id="6009" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">用户1已下订单。</li><li id="6698" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">用户2已下订单。</li></ol><p id="d174" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，即使只有一件商品可用，用户实际上也能够预订该商品。这是一个幻像读取问题，其中事务修改条件中使用的值，以检查事务是否应该通过。简而言之，多个事务读取同一个对象来决定一个事务是否应该通过，然后可能更新该对象或其他对象。</p><p id="f0bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个非常常见的问题，在这类系统中可能会发生</p><ol class=""><li id="6c88" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated">预订系统(两个人预订同一个房间)</li><li id="65e1" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">用户管理系统(两个人获得相同的用户名)</li><li id="5a02" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">客户服务系统(一个代理同时被分配多个呼叫)</li></ol><p id="f070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或任何其他系统，在该系统中，您检查并修改相同或不同的对象，使得可行性检查条件结果现在被改变。现在请注意，在检查条件之后，事务可能不仅仅改变相同的对象，而且可以改变或创建不同的对象。有时，检查条件的对象可能不是实际的数据库行。例如，如果您检查符合条件的对象计数，然后根据结果更改不同的行，则计数不是物理行，而是不同行的聚合数据。当你执行第二步时，count的值会改变。因此，即使您没有像上图所示那样更新公共行，也仍然可能产生幻像读取问题。</p><blockquote class="nn no np"><p id="aec0" class="kd ke nq kf b kg kh ki kj kk kl km kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated">话虽如此，幻像读取总是遵循相同的模式</p><p id="fba3" class="kd ke nq kf b kg kh ki kj kk kl km kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated">1.运行选择查询以获取符合特定条件的数据。</p><p id="5567" class="kd ke nq kf b kg kh ki kj kk kl km kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated">2.根据first的结果，事务要么继续，要么中止。</p><p id="ee0b" class="kd ke nq kf b kg kh ki kj kk kl km kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated">3.如果事务继续进行，那么您进行一些插入、更新、删除调用并提交事务。</p><p id="d6c0" class="kd ke nq kf b kg kh ki kj kk kl km kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated">我希望现在你已经明白什么是幻影了。</p></blockquote><p id="057a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们继续前进。现在，在绝对隔离的情况下，这些事务应该看起来像是连续发生的。请注意，它们不一定连续运行，但如果连续运行，结果是一样的。</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/8b8c7dc9ea2d5d7bf188d7aff00a8a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOi5faA9eBPwGov5HxV89Q.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连续交易</figcaption></figure><p id="0be2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理所当然地，第二笔交易失败了。</p><blockquote class="nv"><p id="e041" class="nw nx iq bd ny nz oa ob oc od oe la dk translated">幻像读取在并发的分布式世界中非常常见。但你不必相信我的话，我说过我会证明给你看，所以让我们跳到代码中，看看我们能否重现这个问题。</p></blockquote></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="8e14" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">让我们开始编码吧</h1><p id="5906" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">手动重现这些问题非常困难，因此我们将借助测试来重现这些问题。(一路TDD😜 ).我将演示如何使用Java + PostgreSQL。不管技术如何，这个概念都是一样的，所以不要担心，跟着做。我会尽量用详细的解释和代码注释让你更容易理解。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2d10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该测试将一个可用性计数为1的产品插入数据库。然后试着同时下20个订单。</p><p id="54b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我来给你演示一下下单的实际实现。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ed93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它按照下面的顺序做了几件事</p><ol class=""><li id="f0f2" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated">从产品表中获取(选择)请求的产品</li><li id="bc7a" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">检查可用性计数是否大于0</li><li id="74b5" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">如果是，则将计数递减(更新)1，并在顺序表中建立一个条目。</li></ol><blockquote class="nn no np"><p id="60dc" class="kd ke nq kf b kg kh ki kj kk kl km kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated">你可以看到这个图案和幻影图案是一样的，对吗？</p></blockquote><p id="9e33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是原子递减计数方法(如果您在一个查询中计数，然后在另一个查询中设置，这会产生一组不同的问题)</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="f304" class="lr ls iq bd lt lu oh lw lx ly oi ma mb mc oj me mf mg ok mi mj mk ol mm mn mo bi translated">问题:测试失败</h1><p id="fc63" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">在运行测试时，我得到了这个</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/7382cd2dda792d864ee7c481f999ce9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*PSP0_MMnWEZcqeUHU4YmoA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Junit结果</figcaption></figure><p id="d545" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下了10份订单，而不是1份。不相信我？让我们看看表格。</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/12616849e8a202ec48f91bf54513e621.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*oEkQcA3lpO2d04utlZVLGA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">产品表</figcaption></figure><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/0e2a04d182094060d40cfcc24f0b9612.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*L5PJBkPrOLUF5BGAHbmOqA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">订单表</figcaption></figure><h1 id="bc42" class="lr ls iq bd lt lu oh lw lx ly oi ma mb mc oj me mf mg ok mi mj mk ol mm mn mo bi translated">解决方法</h1><p id="5bff" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">现在我们已经确定这个问题是真实存在的。那么解决办法是什么呢？我很高兴你问了。让我们看看我们的选择</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/79b693f0ef1a3af32912374ff9733f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*slJCcGstXPPi3S5rDAh4VA.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">因为没有迷因，我的博客是不完整的</figcaption></figure><p id="b08e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在不同的竞争条件解决方案中，锁定无疑是一个强有力的竞争者。所以下一个问题是什么样的锁？</p><h2 id="29be" class="oq ls iq bd lt or os dn lx ot ou dp mb ko ov ow mf ks ox oy mj kw oz pa mn pb bi translated">代码级锁？</h2><p id="9a5f" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我们可以使用代码级锁来阻止临界区<code class="fe pc pd pe pf b">placeOrder</code>一次被一个线程使用。这是一种非常幼稚的方法，但它会起作用。除非您运行订单服务的多个实例。我的意思是，如果只有一个节点运行这个订单服务，那么代码级锁就可以工作。但是在Amazon的规模上，你不能在一个节点上运行你的服务，你可能会运行数千个相同服务的实例。欢迎来到分布式系统😂</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/d981bdced25087e0674e91052c2f727b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*blt9IWAIsoGx9jjMLFybfQ.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">分布式服务设置</figcaption></figure><p id="e409" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个非常简单的生产设置可能如下所示。现在我们不能设置代码级锁，在这个图表中，所有服务的共同点是什么？数据库对吗？那么我们可以使用数据库锁吗？让我们看看。</p><h2 id="d2df" class="oq ls iq bd lt or os dn lx ot ou dp mb ko ov ow mf ks ox oy mj kw oz pa mn pb bi translated">数据库锁</h2><p id="7558" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">让我解释一下数据库锁是如何解决这个问题的。</p><p id="72b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步骤会是这样的。</p><ol class=""><li id="7aa8" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated"><strong class="kf ir">开始</strong>交易<strong class="kf ir">交易</strong></li><li id="a1d7" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">从</strong>产品<strong class="kf ir">中选择</strong> * <strong class="kf ir">其中</strong> id = '27' <strong class="kf ir">和</strong>取一个<strong class="kf ir">独占</strong> <strong class="kf ir">锁</strong> <strong class="kf ir">在</strong>行上</li><li id="6155" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">检查</strong> <strong class="kf ir">如果</strong> <strong class="kf ir">计数</strong> &gt; 0</li><li id="8cb5" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">更新</strong>产品<strong class="kf ir">设置</strong>available _ units = available _ units-1<strong class="kf ir">其中</strong> id = '27 '</li><li id="6d08" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">将</strong> <strong class="kf ir">插入</strong>订单…..</li><li id="79f1" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">提交</strong> <strong class="kf ir">事务</strong></li><li id="d2be" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">释放</strong> <strong class="kf ir">独占</strong> <strong class="kf ir">锁定</strong></li></ol><h2 id="7045" class="oq ls iq bd lt or os dn lx ot ou dp mb ko ov ow mf ks ox oy mj kw oz pa mn pb bi translated">了解排他锁</h2><p id="8cde" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">在我们继续之前，让我们了解一下什么是排他锁。</p><p id="3a9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单地说，排他锁就是写锁。它的一些特性是</p><ol class=""><li id="568d" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated">一个对象上只能有一个排他锁。</li><li id="591a" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">当你拥有这个锁的时候，你可以读写这个对象。</li><li id="c21b" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">任何试图获取任何锁的人都必须等到这个锁被释放。</li><li id="48ea" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">因此，当一个对象上存在一个排他锁时，其他事务的读和写都会被阻塞，直到前一个锁被释放。</li></ol><p id="3ba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当第一个事务开始时，它锁定iPhone12行，因为这是一个排他锁，所以所有其他事务都必须等待，然后才能读取或写入。</p><h1 id="e300" class="lr ls iq bd lt lu oh lw lx ly oi ma mb mc oj me mf mg ok mi mj mk ol mm mn mo bi translated">多工艺流程</h1><p id="5696" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">因此，具有两个不同并行流程的流程看起来像这样</p><ol class=""><li id="8e72" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated"><strong class="kf ir">流程1: </strong> <em class="nq">获取iPhone12排并锁定排:</em> <strong class="kf ir"> <em class="nq">成功</em> </strong></li><li id="806c" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">进程2: </strong> <em class="nq">获取iPhone12行并锁定该行</em> : <strong class="kf ir">等待</strong>该进程必须等待进程1释放锁定，然后才能继续。</li><li id="6b01" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">流程1: </strong> <em class="nq">检查计数&gt;是否为0 </em> : <strong class="kf ir">为真</strong></li><li id="6ad2" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">流程1: </strong> <em class="nq">减量计数减1: </em> <strong class="kf ir"> <em class="nq">成功</em> </strong></li><li id="323e" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">进程2: </strong> <em class="nq">仍在等待获取iPhone12上的锁行:</em> <strong class="kf ir">等待</strong></li><li id="d2a9" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">流程1: </strong> <em class="nq">录入订单表:</em> <strong class="kf ir">成功</strong></li><li id="8112" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">流程1: </strong> <em class="nq">解锁iPhone 12行:</em> <strong class="kf ir">成功</strong></li><li id="8bde" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">流程二:</strong> <em class="nq">获取iPhone12上的一个锁行现在:</em> <strong class="kf ir">成功</strong></li><li id="090f" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">流程2: </strong> <em class="nq">但计数为0，于是中止交易:</em> <strong class="kf ir"> <em class="nq">失败</em> </strong></li></ol><p id="322b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，看来这能解决我们的问题。让我们把它编码起来。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="3648" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">用于更新</h1><p id="de7b" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">Postgres上最接近排他锁的是“<a class="ae kc" href="https://www.postgresql.org/docs/9.4/explicit-locking.html" rel="noopener ugc nofollow" target="_blank"> For UPDATE </a>”关键字，我们将使用它。</p><p id="1435" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以让我们创建一个使用锁的新方法</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0dbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将保持对iPhone12行的锁定，直到事务被提交。</p><p id="6a77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe pc pd pe pf b">placeOrder</code>方法中，我们将使用这个，而不是<code class="fe pc pd pe pf b">findById</code>方法。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e77f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是时候再次进行测试了。</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ph"><img src="../Images/a9288196237238c4594dba75714eedb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_nFURVGngPg0XoAO_1aZQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">测试成功</figcaption></figure><p id="6678" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">瞧，测试通过了，这意味着只下了一个订单，我们就能解决幻影读取。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="ecda" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">可序列化隔离级别</h1><p id="0e20" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">除了上面提到的方法之外，我们还可以为这个特定的事务指定“可序列化”的隔离级别，在这种情况下，数据库基本上可以通过某种方式以某种接近串行顺序的方式运行事务。</p><p id="6f0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要运行具有<em class="nq">可串行化</em>隔离级别<em class="nq">的</em>就行了。</p><pre class="nj nk nl nm gt pi pf pj pk aw pl bi"><span id="7d19" class="oq ls iq pf b gy pm pn l po pp">@Transactional(isolation = Isolation.<em class="nq">SERIALIZABLE</em>)</span></pre><p id="7d54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Serializable是隔离的最高形式，它解决了所有的隔离异常。但是在某些情况下，不可能使用可序列化隔离。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="338f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">但是</h1><ol class=""><li id="9eca" class="mu mv iq kf b kg mp kk mq ko pq ks pr kw ps la mz na nb nc bi translated">凡事都有权衡，使用锁和可序列化隔离级别可以解决问题，但会降低系统速度。</li><li id="a4d5" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">数据库锁和隔离级别是危险的领域，在使用它们之前一定要正确理解它们，因为它们可以成就或破坏您的系统。</li></ol></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="b80e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">离别赠言</h1><ol class=""><li id="f337" class="mu mv iq kf b kg mp kk mq ko pq ks pr kw ps la mz na nb nc bi translated">我希望你能够理解这个问题和解决方案。我想现在您已经有足够的能力来处理生产中的幻像读取，或者至少有足够的知识开始工作。</li><li id="1c68" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">如果您对这些概念感兴趣，您可以去阅读更多关于不同异常的内容，如脏读、更新丢失、可重复读取等，以及防止这些异常的不同技术。我推荐这个精彩的<a class="ae kc" href="https://www.youtube.com/watch?v=5ZjhNTM8XU8" rel="noopener ugc nofollow" target="_blank">视频</a>，由独一无二的马丁·克莱普曼制作，它会让你开始。</li><li id="2be0" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">如果您想查看包含所有代码的整个工作项目，可以在GitHub上找到</li></ol><div class="pt pu gp gr pv pw"><a href="https://github.com/dev-aritra/phantomread" rel="noopener  ugc nofollow" target="_blank"><div class="px ab fo"><div class="py ab pz cl cj qa"><h2 class="bd ir gy z fp qb fr fs qc fu fw ip bi translated">dev-aritra/phantomread</h2><div class="qd l"><h3 class="bd b gy z fp qb fr fs qc fu fw dk translated">在GitHub上创建一个帐户，为dev-aritra/phantomread开发做出贡献。</h3></div><div class="qe l"><p class="bd b dl z fp qb fr fs qc fu fw dk translated">github.com</p></div></div><div class="qf l"><div class="qg l qh qi qj qf qk jw pw"/></div></div></a></div></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="74bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p><blockquote class="nn no np"><p id="d711" class="kd ke nq kf b kg kh ki kj kk kl km kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated">我是Aritra Das，我是一名开发人员，我非常喜欢构建复杂的分布式系统。任何与科技相关的事情，都可以在<a class="ae kc" href="https://www.linkedin.com/in/dev-aritra/" rel="noopener ugc nofollow" target="_blank"><em class="iq">Linkedin</em></a><em class="iq">或</em><a class="ae kc" href="https://twitter.com/aritra__das" rel="noopener ugc nofollow" target="_blank"><em class="iq">Twitter</em></a><em class="iq">上联系我。</em></p><p id="2da4" class="kd ke nq kf b kg kh ki kj kk kl km kn nr kp kq kr ns kt ku kv nt kx ky kz la ij bi translated">快乐学习……</p></blockquote></div></div>    
</body>
</html>