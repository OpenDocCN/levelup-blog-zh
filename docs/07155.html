<html>
<head>
<title>gRPC: How to Make Bi-directional Streaming Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC:如何进行双向流媒体通话</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grpc-how-to-make-bi-directional-streaming-calls-70b4a0569b5b?source=collection_archive---------1-----------------------#2021-01-28">https://levelup.gitconnected.com/grpc-how-to-make-bi-directional-streaming-calls-70b4a0569b5b?source=collection_archive---------1-----------------------#2021-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d807df352f2b97fcb632feb56e310ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPivnavIZg_kMev1Zz3HzA.png"/></div></div></figure><p id="595e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将讨论使用双向流的gRPC调用——实现一个发送流请求的客户机和一个用流消息响应的服务器。</p><p id="c3a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是该系列的最后一篇文章，如果你还没有看完，下面是列表:</p><ol class=""><li id="6728" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-effective-unary-calls-4c9fa68cd9d5">如何进行有效的一元调用</a></li><li id="b71f" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-client-streaming-calls-5c731197585">如何进行客户端流媒体通话</a></li><li id="07d9" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-server-streaming-calls-763b42895481">如何进行服务器流调用</a></li><li id="233c" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">如何进行双向流媒体通话</li></ol><p id="8652" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在双向流rpc调用中，客户端和服务器互相发送多条消息。使用这种类型的rpc调用会稍微复杂一点，因为您必须从服务器端和客户端处理错误，而且在某些情况下会增加更多的延迟。也许使用一元调用是一个更好的选择。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lo"><img src="../Images/a5c1aaa9b9cf355338d5822d853d1c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ug3CAac6nPclg87bxmRBoA.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">双向流</figcaption></figure><h2 id="33e0" class="lx ly it bd lz ma mb dn mc md me dp mf km mg mh mi kq mj mk ml ku mm mn mo mp bi translated">项目描述</h2><p id="baff" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">对于这个项目，我们将创建一个带有一个gRPC端点的用户服务，它将允许客户机和服务器发送和接收流消息。</p><p id="70c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">端点将需要一个用户对象作为请求消息，服务器将用一条消息来响应，这条消息将让客户端知道用户是否被成功处理。</p><p id="b332" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，客户端和服务器都可以在任何时间点停止接收或发送消息，要么是因为发生了一些错误，要么是因为发生了其他一些业务逻辑。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="9e39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在grpc_calls中创建另一个文件夹，并将其命名为双向流。</p><p id="3f20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件夹中创建以下结构。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/084ea1fd1d5f748f7c7f1118373e8b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*ZtWNwkyf-I8TOhFvpynXBA.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">双向流文件夹结构</figcaption></figure><p id="2001" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">users.proto文件的定义如下:</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b7e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个原型文件中，我为这个请求定义了服务用户、端点和相应的消息。</p><p id="2bba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这个端点，客户端将发送一个用户对象，服务器将发送一个CreateUserRes消息来指示用户是如何被处理的。</p><h2 id="2222" class="lx ly it bd lz ma mb dn mc md me dp mf km mg mh mi kq mj mk ml ku mm mn mo mp bi translated">原型文件定义:</h2><ol class=""><li id="7045" class="kz la it kd b ke mq ki mr km nf kq ng ku nh ky le lf lg lh bi translated"><strong class="kd iu"> CreateUser: </strong>这是rcp端点定义，它接受请求中的流用户消息，并返回流响应。</li><li id="03f6" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu">用户:</strong>这是请求的用户表示消息。</li><li id="34c8" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu"> CreateUserRes: </strong>这是响应消息。</li></ol><p id="7fe9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，和前面的文章一样，我们需要为这个原型文件生成go代码。</p><p id="a2c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在proto文件夹中运行以下命令:</p><pre class="lp lq lr ls gt ni nj nk nl aw nm bi"><span id="4d3d" class="lx ly it nj b gy nn no l np nq">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative users.proto</span></pre><p id="165e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以继续并实现服务器了。这是server go应用程序的代码。</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1424" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，对于这个文件，我们首先创建一个新的grpc服务器，它将监听端口3000，然后我们注册用户服务并开始监听连接。</p><p id="5311" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如你所见，我正在导入proto_bi_directional_stream包。因为有本地进口的Go会投诉。</p><p id="c75e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">要解决这个问题，您可以执行以下操作:</strong></p><ol class=""><li id="cd45" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">将proto文件夹的内容推送到Github，然后从那里导入。</li><li id="653d" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">将proto文件夹的内容放在<strong class="kd iu">包/src </strong>文件夹中，作为go版本路径。在我的情况下，这是路径:</li></ol><pre class="lp lq lr ls gt ni nj nk nl aw nm bi"><span id="696f" class="lx ly it nj b gy nn no l np nq">golang/1.15.5/packages/src</span></pre><p id="2d20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件夹中，我创建了一个proto_bi_directional_stream文件夹，并粘贴了包含生成代码和users.proto文件的proto文件夹中的文件。</p><p id="5146" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样我就可以导入这个包，而不用把它推到Github。采取你认为更方便的方法。</p><p id="de85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<strong class="kd iu"> CreateUsers </strong>函数中，我们首先创建一个for循环，从流中获取请求和一个可能的错误，然后我们检查是否已经接收完请求，如果是，我们返回。然后，我们从请求中提取姓名、姓氏和用户id，并执行一些验证来帮助我们构建响应对象。最后，我们从流中使用Send方法并传递响应消息，我们还在函数的末尾打印一些可能的错误，以防在向客户端发送响应消息时出现错误。</p><p id="4a19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了能够接收和发送流消息，这就是我们在服务器中所要做的一切。</p><p id="15b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们实现客户端代码。</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e1c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于客户机代码，我们使用users包提供的NewUsersClient方法在端口3000上创建一个新的客户机-服务器。</p><p id="7669" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我创建了一个bulkUsers函数，它负责迭代一部分用户对象并将它们发送到服务器，然后从服务器接收流响应并打印出来。</p><p id="e443" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，让我们仔细看看这个函数。它首先从CreateUser函数获取流，然后构建一个包含一些用户对象的请求片。然后，它创建一个通道，并使用go例程来发送和接收消息。</p><p id="61b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个go例程遍历切片并将每条消息发送到服务器，它还使用Sleep函数来模拟一些延迟。当for循环结束时，它关闭流。</p><p id="33fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于第二个go例程，它开始接收流响应，然后使用EOF(文件结束)函数检查服务器是否完成了流。最后，它打印每个响应消息，并关闭通道。</p><p id="beef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们在客户端代码上所要做的一切，正如你所看到的，它需要更多的代码，并且增加了客户端和服务器应用程序的复杂性。</p><p id="3fb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们进入控制台，在服务器文件夹中，我们可以运行以下命令来启动服务器。</p><pre class="lp lq lr ls gt ni nj nk nl aw nm bi"><span id="0362" class="lx ly it nj b gy nn no l np nq">go run .</span></pre><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/44af88b942c2cd2f06167c4ef2b0c0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1gRyVc93ppYlQuVC2cSpQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">服务器Go应用程序日志</figcaption></figure><p id="d4c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后使用相同的命令启动客户端，但是在客户端文件夹下，如果一切都正确，您应该会看到预期的结果。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/ff08dbb55d11b9dbc2063ae70c764943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yn09TwOcSXSabGqa-7uNA.png"/></div></div></figure><p id="27f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太棒了，我们刚刚实现了一个双向流rpc调用。</p><p id="ac6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至此，我希望您能更好地理解如何进行所有四个rpc调用，以及何时在您的个人项目中使用它们是个好主意。</p><p id="c1f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你已经阅读了整个系列，恭喜你！！。</p><p id="9f64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您认为该系列有用，请单击💚下面和其他媒体成员分享一下。</p><p id="1514" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再次感谢您的阅读，敬请关注。</p></div></div>    
</body>
</html>