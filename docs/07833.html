<html>
<head>
<title>Introduction to Apache Arrow with Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带锈阿帕奇箭简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-apache-arrow-with-rust-394f391ea455?source=collection_archive---------5-----------------------#2021-03-15">https://levelup.gitconnected.com/introduction-to-apache-arrow-with-rust-394f391ea455?source=collection_archive---------5-----------------------#2021-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4fb34cb3ea59d89e9c754ca1ea0c26d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_kzNXhl3Nd1fLflT5BAfSQ.png"/></div></div></figure><p id="c177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的几个月里，我一直在开发一个负责处理内存数据的应用程序。这个项目令我兴奋有两个原因。一个是项目完全用Rust编写，另一个是了解新主题和库的机会。本文探讨了我在使用Apache Arrow时所学到的东西。</p><p id="eebe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我刚开始从事这个项目时，我并不知道Apache Arrow。我只是需要一种尽可能高效地聚合数据的方法。我甚至构建了一个概念验证，它提供了我需要的大部分功能，包括连接。这是一个粗略的草稿，但我已经可以看出有一些性能问题。一个基本问题是聚合函数在数据结构上的性能，该数据结构以基于行的格式表示数据集。这种设计意味着基于列的操作，如过滤和数学运算，成本很高。还有一些其他的问题，所以我决定做更多的研究，最终导致我的阿帕奇箭头。</p><h1 id="aaf8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是阿帕奇箭</h1><p id="d85b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Apache Arrow 是一个语言无关的软件开发平台，用于构建处理和传输大型数据集的应用程序。该产品不仅提供了面向列的数据格式，还提供了其他一些有用的库和由Apache软件基金会维护的开发人员生态系统。</p><h2 id="85a6" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">存储格式</h2><p id="c85a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Apache Arrow的核心特性是其内存中的列数据格式，这是一种在内存中构建表格数据集的规范，并提供了一个定义良好的类型系统。这使得该格式成为数据库系统或数据框库等项目的理想构建块。这种内存格式的一个主要优点是，它擅长处理大块数据，并支持使用SIMD运算进行矢量化。</p><h2 id="9d6f" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">图书馆</h2><p id="7a7c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">其他库作为Apache Arrow的伙伴提供。它们提供了您不想自己实现的常见功能。我发现两个特定于Rust的库很有用，它们是<a class="ae lz" href="https://crates.io/crates/datafusion" rel="noopener ugc nofollow" target="_blank">数据融合</a>和<a class="ae lz" href="https://crates.io/crates/arrow-flight" rel="noopener ugc nofollow" target="_blank">箭头飞行</a>。DataFusion是一个基于Apache Arrow构建的查询引擎，它提供了数据框架和SQL查询API。Arrow Flight是一个序列化库，用于通过网络传输数据。我将在后面的文章中更详细地介绍这些库。</p><h2 id="14e3" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">开发者生态系统</h2><p id="0399" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">决定使用Apache Arrow的一个重要因素是开发者生态系统。Apache Arrow由Apache软件基金会维护，该基金会提供了一个管理机构和决策过程。该基金会还致力于维护一个对所有人开放的开源开发者社区。</p><h1 id="3308" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">铁锈箭头实施</h1><p id="7e04" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Apache Arrow有多种实现方式，但我将重点介绍<a class="ae lz" href="https://crates.io/crates/arrow" rel="noopener ugc nofollow" target="_blank"> Rust版本</a>。本节将分为四个部分:低级数组、高级构造、数据读取器和计算内核。不是库的每一个方面都将被涵盖，但仅仅足够得到一个如何使用它的好主意。</p><h2 id="936f" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">低级阵列</h2><p id="75e1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Rust实现的关键部分是数组特征。它表示一个通用的、固定大小的、不可变的、线程安全的可空元素数组。构造数组有两种方法:转换器方法和生成器方法。</p><p id="a007" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">converter方法用于从本地Rust类型的向量中构造数组实例。在我看来，这种方法是最常见的，因为迭代一组数据并将这些数据收集到一个向量中是非常常见的。使用converter方法可能如下所示:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/155a30326e4b259cd2fcd00c22014d92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y2Y-rZOwD0FW8gV4JBpF2Q.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">用转换器构造的原始数组</figcaption></figure><p id="63a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个代码片段中，<code class="fe mv mw mx my b">Int32Array</code>是一个<code class="fe mv mw mx my b">Array</code>，它表示一个可选的32位有符号整数数组。<code class="fe mv mw mx my b">from</code>方法采用一个由<code class="fe mv mw mx my b">Option&lt;i32&gt;</code>个值组成的向量来构造数组。有几个<code class="fe mv mw mx my b">Array</code>特征的实现，所以一定要查看文档中<code class="fe mv mw mx my b">Array</code>的正确类型。</p><p id="3615" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">builder方法是一种通过向数组追加值来构造数组的方法。这对于从值动态构造数组很有用。下面是一个使用builder方法的示例:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/8e13262742204baaf6d4b2bfa7b491eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxO1R0pLB85pmuh8QKywfA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">从生成器构造的原始数组</figcaption></figure><p id="fbf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，<code class="fe mv mw mx my b">Int32Builder</code>用于初始化一个容量为100个元素的构建器实例。对于前50个元素，如果生成的值是偶数，则将其追加到数组中，否则，将追加一个空值——这不是一个实际的<code class="fe mv mw mx my b">null</code>值。对于最后50个元素，生成的值被收集到一个向量中，然后作为一个切片附加到数组中。<code class="fe mv mw mx my b">finish</code>方法将构建器实例转换成数组实例。</p><h2 id="c8a4" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">高层建筑</h2><p id="8c33" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">数组是处理数据的一种非常强大的抽象。然而，它们并没有提供一种处理表格数据集的简单方法。这就是这些高级结构出现的原因。三种数据结构与低级数组一起表示一个数据集:</p><ul class=""><li id="70c0" class="na nb iq ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated"><code class="fe mv mw mx my b">Field</code> —定义单列数据的元数据</li><li id="764f" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated"><code class="fe mv mw mx my b">Schema</code> —定义数据集的元数据，包含一个矢量<code class="fe mv mw mx my b">Field</code></li><li id="c0c7" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated"><code class="fe mv mw mx my b">RecordBatch</code> —定义一个二维数据集，包含相同长度的低级数组和一个与数组类型匹配的<code class="fe mv mw mx my b">Schema</code></li></ul><p id="9e95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mv mw mx my b">RecordBatch</code>类型为处理数据集提供了一个方便的接口，是计算和序列化等任务最常见的结构。下面是使用这些类型表示数据集的示例:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/c28e3745aa74c599b7029fe91bb9584e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCP07pGN7d4zrXnWX8Oy7Q.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">由记录批、模式、字段类型表示的数据集</figcaption></figure><p id="0532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，<code class="fe mv mw mx my b">RecordBatch</code>类型成为包装模式和原始数组的顶级组件。需要注意的一点是<code class="fe mv mw mx my b">RecordBatch</code>由指向模式和单个原始数组的原子引用计数指针组成。使用这种类型的引用是Apache Arrow能够提供零拷贝读取的一个重要原因。</p><h2 id="9ba4" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">数据阅读器</h2><p id="132c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">从Apache Arrow的核心组件构建数据集的能力具有有限的用例。有一种明确的需求，即不需要太多的努力就可以将数据读入Apache Arrow内存格式。在Apache Arrow的Rust实现中，提供的数据读取器之一是CSV读取器。</p><p id="dd31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CSV阅读器从CSV文件中读取记录，然后根据模式将列转换为适当的原始数组类型。CSV阅读器可以直接使用，也可以通过自定义设置从构建器对象生成。直接使用CSV阅读器可能如下所示:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/02eacd8b3a08c58739371e31a5cea0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oG7_PF15Vk9dEk_0H5l9Hw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">使用CSV阅读器读取数据</figcaption></figure><p id="59a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此示例中，定义了一个模式来表示CSV文件中的数据。CSV阅读器是使用打开的文件、对模式的引用和一些配置细节(如文件是否有头和批处理大小)创建的。批量大小是一个有趣的参数，因为它决定了将生成多少批记录。例如，如果您有一个包含10，000条记录的CSV文件，并且批量大小为1000，那么读取器最终将返回10个<code class="fe mv mw mx my b">RecordBatch</code>实例的集合。另一个有趣的特性是CSV阅读器是一个迭代器。这意味着读取器可以用于Rust中的for循环或任何其他迭代方法。</p><p id="9773" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CSV阅读器也可以从builder对象生成，这提供了更多的灵活性。使用构建器方法可能如下所示:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/5dd1d7987f0bd4d97ad713e4eeb5bd0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9yJ53PVPFUhlLKQGRnBGKg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">用阅读器构建器构建阅读器</figcaption></figure><p id="18f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例子演示了如何使用<code class="fe mv mw mx my b">ReaderBuilder</code>创建一个builder对象，该对象被配置为期望文件中的头，并试图从文件的前100条记录中推断出模式。<code class="fe mv mw mx my b">build</code>方法将尝试使用构建器，并返回一个具有与文件中的内容相匹配的模式的读取器。</p><h2 id="e6c0" class="ma kx iq bd ky mb mc dn lc md me dp lg kj mf mg lk kn mh mi lo kr mj mk ls ml bi translated">计算内核</h2><p id="2e75" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">计算内核是Apache Arrow的核心。提供了许多内核函数，但是本节将只详细介绍过滤和排序函数。</p><p id="7ac5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">filter函数引用一个数据数组和一个布尔值数组，指示该位置的元素是否应该被过滤。要过滤一个<code class="fe mv mw mx my b">RecordBatch</code>对象中的数组，过滤函数必须应用于所有使用相同布尔数组的数组。例如，通过<code class="fe mv mw mx my b">group</code>列过滤CSV数据可能如下所示:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/c9f372e0d799fc875f9f59c2318bc99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*roSTpTowSvBcDJhbEIexlw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">使用filter方法的示例</figcaption></figure><p id="071c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，通过比较<code class="fe mv mw mx my b">group</code>列的每个元素和<code class="fe mv mw mx my b">group</code>参数的值来创建一个过滤器数组。然后，使用过滤器阵列来过滤批次中的每一列。使用原始模式和过滤后的数组创建并返回一个新的<code class="fe mv mw mx my b">RecordBatch</code>实例。</p><p id="aedd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Apache Arrow提供了一些与排序相关的函数。与本例相关的是<code class="fe mv mw mx my b">sort_to_indices</code>函数，它引用一个数据数组和一个可选的<code class="fe mv mw mx my b">SortOptions</code>对象，并返回一个表示数组中元素新位置的无符号整数数组。这里有一个例子:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/d0555ae15b98a4ebb75237ab48d27eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nmep1AXt9E7l4Rq92IJxHQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">使用排序方法的示例</figcaption></figure><p id="5e2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例子通过调用引用了<code class="fe mv mw mx my b">group</code>列并且没有排序选项的<code class="fe mv mw mx my b">sort_to_indices</code>函数构建了一个索引数组。然后将<code class="fe mv mw mx my b">take</code>函数映射到所有列，根据排序后的索引对数组进行重新排序。使用相同的模式和排序后的数组创建并返回一个新的<code class="fe mv mw mx my b">RecordBatch</code>对象。</p><p id="d8eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Apache Arrow库专注于底层操作。这意味着一些常见的数据聚合操作不是API的一部分。例如，没有按功能分组。但是，group by功能可以通过筛选、排序和选择聚合函数来实现。这里有一个例子:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/750c375dfc5ee18f146feded8588d76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fQ7ZNKk9GbppZKg6VqArw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">通过以下方式实现组的示例</figcaption></figure><p id="09c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该示例首先通过对<code class="fe mv mw mx my b">group</code>列进行排序、将值收集到一个向量中并删除重复值来查找唯一的<code class="fe mv mw mx my b">group</code>列值。构建器数组的向量被初始化以保存每个分数列的平均分数。对于每个独特的组，<code class="fe mv mw mx my b">filter_by_group</code>函数用于查找所有相应的分值。计算该组中每一列的平均值，并将其附加到相应的生成器中。然后收集构建器的结果，创建一个表示新结构的新模式，并返回一个<code class="fe mv mw mx my b">RecordBatch</code>实例。</p><h1 id="aab5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">最后的想法</h1><p id="9f85" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">还有许多其他的主题要探讨，但是主要目标是提供Apache Arrow和Rust实现的概述。我使用Apache Arrow的体验是非常积极的。本库没有提供您可能需要的高级聚合方法，但这不是本库的目的。它提供了构建模块，但你必须将它们组合在一起。</p><h1 id="7a0e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">谢谢</h1><p id="369a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">感谢阅读！如果你想联系或想提供反馈，请随时通过<a class="ae lz" href="https://www.linkedin.com/in/andrewleverette/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="40df" class="kw kx iq bd ky kz oa lb lc ld ob lf lg lh oc lj lk ll od ln lo lp oe lr ls lt bi translated">相关文章</h1><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/working-with-csv-data-in-rust-7258163252f8"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">在Rust中使用CSV数据</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">CSV文件格式是存储表格数据的一种非常常用的方法。这篇文章涵盖了阅读和…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow jw oi"/></div></div></a></div><h1 id="4b55" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">资源</h1><ul class=""><li id="370f" class="na nb iq ka b kb lu kf lv kj ox kn oy kr oz kv nf ng nh ni bi translated"><a class="ae lz" href="https://mockaroo.com/42fd4a20" rel="noopener ugc nofollow" target="_blank"> CSV文件模式</a></li><li id="4c76" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated"><a class="ae lz" href="https://github.com/andrewleverette/data_wrangling_with_rust/tree/main/introduction_to_apache_arrow_with_rust" rel="noopener ugc nofollow" target="_blank">代码示例</a></li><li id="a1d5" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated"><a class="ae lz" href="https://arrow.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇箭头</a></li><li id="8898" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated"><a class="ae lz" href="https://docs.rs/arrow/3.0.0/arrow/" rel="noopener ugc nofollow" target="_blank">生锈箭头文档</a></li></ul></div></div>    
</body>
</html>