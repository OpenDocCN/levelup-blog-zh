<html>
<head>
<title>Generics and Wildcards in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的泛型和通配符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/generics-and-wildcards-in-java-1e678f7792?source=collection_archive---------4-----------------------#2020-07-16">https://levelup.gitconnected.com/generics-and-wildcards-in-java-1e678f7792?source=collection_archive---------4-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="21b3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于Java中的<em class="kf"> </em>泛型和通配符(也称为参数多态性、类型界限、类型差异)</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi kg"><img src="../Images/206f0a2a74c3f1123086f67966913930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*22aghNuNfmyIZHH5X1xkDw.jpeg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">迪米特里·豪特曼在<a class="ae ks" href="https://unsplash.com/s/photos/bounds?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0b8e" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated"><strong class="kv ir">注:</strong>本文改编自我的书<a class="ae ks" href="https://www.fcpbook.org" rel="noopener ugc nofollow" target="_blank"> <em class="lp">函数式与并发编程:核心概念与特性</em> </a>，由<a class="ae ks" href="https://www.informit.com/store/functional-and-concurrent-programming-core-concepts-9780137466573" rel="noopener ugc nofollow" target="_blank"> Addison-Wesley </a>出版。具体参见第15章<em class="lp">类型(及相关概念)</em>。</p><p id="2492" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi lq translated">没有人想知道Java中的语法<code class="fe lz ma mb mc b">&lt;? extends T&gt;</code>或<code class="fe lz ma mb mc b">&lt;? super T&gt;</code>是干什么用的？我们为什么需要它？怎么用？如果是这样，这篇文章是给你的。它还将简要讨论支持协变和逆变类型的语言中的替代语言。</p><h2 id="ff2a" class="md me iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">无商标消费品</h2><p id="a584" class="pw-post-body-paragraph kt ku iq kv b kw mw jr ky kz mx ju lb lc my le lf lg mz li lj lk na lm ln lo ij bi translated">在现代类型化编程语言中，一种类型可以被另一种类型参数化，这种特性有时被称为<em class="lp">参数多态性</em>。在Java中，这采用了所谓的<em class="lp">泛型的形式，在Java 5中引入了</em>。</p><p id="9739" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">例如，<code class="fe lz ma mb mc b">List</code>可以被参数化为<code class="fe lz ma mb mc b">List&lt;String&gt;</code>或<code class="fe lz ma mb mc b">List&lt;Number&gt;</code>，使得编译器可以检查一个数字是否被插入到一个字符串列表中，或者一个字符串是否被插入到一个数字列表中。这样，代码中就不需要类型转换(和潜在的<code class="fe lz ma mb mc b">ClassCastException</code>)。</p><h2 id="35a6" class="md me iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">类型不变性</h2><p id="92a3" class="pw-post-body-paragraph kt ku iq kv b kw mw jr ky kz mx ju lb lc my le lf lg mz li lj lk na lm ln lo ij bi translated">在Java中，<code class="fe lz ma mb mc b">Integer</code>是<code class="fe lz ma mb mc b">Number</code>的一个子类型。然而，你知道<code class="fe lz ma mb mc b">List&lt;Integer&gt;</code>是<em class="lp">而不是</em>是<code class="fe lz ma mb mc b">List&lt;Number&gt;</code>的一个子类型吗？更重要的是，你知道为什么吗？</p><p id="187e" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">请看下图。假设一个简单的类型层次结构:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/594de7ff47e0174661b3486d253210e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*ydAaP1uld-pyWFmMtPOCWw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">简单的类型层次结构。</figcaption></figure><p id="9b5d" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">其中<code class="fe lz ma mb mc b">Publication</code>定义为:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="fbc4" class="md me iq mc b gy ng nh l ni nj">interface Publication {<br/>  String title();<br/>}</span></pre><p id="903c" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">而<code class="fe lz ma mb mc b">Book</code>和<code class="fe lz ma mb mc b">Magazine</code>是实现接口的两个类。</p><p id="fa46" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">因为所有类型为<code class="fe lz ma mb mc b">Publication</code>的对象都有一个<code class="fe lz ma mb mc b">title</code>方法，所以可以编写代码来打印出版物列表的所有标题，如下所示:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="5713" class="md me iq mc b gy ng nh l ni nj">void printTitles(List&lt;Publication&gt; <em class="lp">collection</em>) {<br/>  for (Publication <em class="lp">p </em>: <em class="lp">collection</em>)<br/>    System.<em class="lp">out</em>.println(<em class="lp">p</em>.title());<br/>}</span></pre><p id="b932" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">现在假设一个图书馆的内容已经存储为一个图书列表:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="840a" class="md me iq mc b gy ng nh l ni nj">List&lt;Book&gt; library = ...</span></pre><p id="ad18" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">使用方法<code class="fe lz ma mb mc b">printTitles</code>来打印图书馆中书籍的标题似乎是很自然的，因为书籍是出版物。</p><p id="0fde" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">然而，调用<code class="fe lz ma mb mc b">printTitles(library)</code>失败，并出现以下错误:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="d8cc" class="md me iq mc b gy ng nh l ni nj">Error:(57, 22) java: incompatible types: java.util.List&lt;Book&gt; cannot be converted to java.util.List&lt;Publication&gt;</span></pre><p id="d5bd" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">即使<code class="fe lz ma mb mc b">Book</code> <em class="lp">是</em>的一个子类型<code class="fe lz ma mb mc b">Publication</code>，但是<code class="fe lz ma mb mc b">List&lt;Book&gt;</code>是<em class="lp">而不是</em>的一个子类型<code class="fe lz ma mb mc b">List&lt;Publication&gt;</code>。</p><h2 id="f27e" class="md me iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">利斯科夫替代原理</h2><p id="c9f5" class="pw-post-body-paragraph kt ku iq kv b kw mw jr ky kz mx ju lb lc my le lf lg mz li lj lk na lm ln lo ij bi translated">替换原则规定，如果类型<code class="fe lz ma mb mc b">T</code>是类型<code class="fe lz ma mb mc b">U</code>的子类型，那么只要需要类型<code class="fe lz ma mb mc b">U</code>的值，就可以替换类型<code class="fe lz ma mb mc b">T</code>的值。换句话说，子类型必须提供父类型的所有服务。</p><p id="c73e" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这里的问题是类型为<code class="fe lz ma mb mc b">List&lt;Book&gt;</code>的值不能提供类型为<code class="fe lz ma mb mc b">List&lt;Publication&gt;</code>的值的所有服务。调用<code class="fe lz ma mb mc b">printTitles(library)</code>可能看起来无害，但是考虑打印方法的这个变体:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="f16d" class="md me iq mc b gy ng nh l ni nj">void printTitlesAndAddMagazine(List&lt;Publication&gt; <em class="lp">collection</em>) {<br/>  for (Publication <em class="lp">p </em>: <em class="lp">collection</em>)<br/>    System.<em class="lp">out</em>.println(<em class="lp">p</em>.title());<br/>  <em class="lp">collection</em>.add(new Magazine(...));<br/>}</span></pre><p id="b1eb" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">如果调用<code class="fe lz ma mb mc b">printTitles(library)</code>有效，那么调用<code class="fe lz ma mb mc b">printTitlesAndAddMagazine(library)</code>也有效，因为两个方法具有相同的签名。但是后者会在书单上增加一本杂志！由于<code class="fe lz ma mb mc b">Magazine</code>不是<code class="fe lz ma mb mc b">Book</code>的子类型，这将破坏类型安全。添加杂志是一项由<code class="fe lz ma mb mc b">List&lt;Publication&gt;</code>支持而不由<code class="fe lz ma mb mc b">List&lt;Book&gt;</code>支持的服务。</p><h2 id="6dde" class="md me iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">类型界限</h2><p id="bfc7" class="pw-post-body-paragraph kt ku iq kv b kw mw jr ky kz mx ju lb lc my le lf lg mz li lj lk na lm ln lo ij bi translated">由于<code class="fe lz ma mb mc b">printTitles</code>不关心向集合中添加杂志，因此可以修改其签名来启用调用<code class="fe lz ma mb mc b">printTitles(library)</code>:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="3c89" class="md me iq mc b gy ng nh l ni nj">void printTitles(List&lt;? extends Publication&gt; <em class="lp">collection</em>) {<br/>  for (Publication <em class="lp">p </em>: <em class="lp">collection</em>)<br/>    System.<em class="lp">out</em>.println(<em class="lp">p</em>.title());<br/>}</span></pre><p id="d755" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated"><code class="fe lz ma mb mc b">List&lt;? extends Publication&gt;</code>是列表的类型，其中的元素具有未指定的类型，该类型是<code class="fe lz ma mb mc b">Publication</code>(或<code class="fe lz ma mb mc b">Publication</code>本身)的子类型。特别是，<code class="fe lz ma mb mc b">List&lt;Book&gt;</code> <em class="lp">是<code class="fe lz ma mb mc b">List&lt;? extends Publication&gt;</code>的一个子类型</em>，呼叫<code class="fe lz ma mb mc b">printTitles(library)</code>现在有效。因为列表中的元素<code class="fe lz ma mb mc b">p</code>必须是<code class="fe lz ma mb mc b">Publication</code>的子类型，所以它也有类型<code class="fe lz ma mb mc b">Publication</code>和<code class="fe lz ma mb mc b">title</code>方法。</p><p id="bb50" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">此时，敏锐的读者可能会想:是什么阻止我在<code class="fe lz ma mb mc b">printTitlesAndAddMagazine</code>中使用相同的技巧来启用调用<code class="fe lz ma mb mc b">printTitlesAndAddMagazine(library)</code>，这会破坏类型安全？</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="e315" class="md me iq mc b gy ng nh l ni nj">void printTitlesAndAddMagazine(List&lt;? extends Publication&gt; <em class="lp">collection</em>) {<br/>  for (Publication <em class="lp">p </em>: <em class="lp">collection</em>)<br/>    System.<em class="lp">out</em>.println(<em class="lp">p</em>.title());<br/>  <em class="lp">collection</em>.add(new Magazine(...)); // rejected at compile-time<br/>}</span></pre><p id="2a8d" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">无法编译该方法的最后一行。列表元素的类型是<code class="fe lz ma mb mc b">Publication</code>的未知子类型，并且不能保证该类型可以包含类型<code class="fe lz ma mb mc b">Magazine</code>的值。要将杂志添加到列表中，我们需要知道列表元素的类型是<code class="fe lz ma mb mc b">Magazine</code>的<em class="lp">超类型</em>(或者类型<code class="fe lz ma mb mc b">Magazine</code>本身)。Java有一个语法。方法<code class="fe lz ma mb mc b">addMagazine</code>可以写成如下形式:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="e087" class="md me iq mc b gy ng nh l ni nj">void addMagazine(List&lt;? super Magazine&gt; <em class="lp">collection</em>) {<br/>  <em class="lp">collection</em>.add(new Magazine(...));<br/>}</span></pre><p id="b7e0" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">方法<code class="fe lz ma mb mc b">addMagazine</code>可以在<code class="fe lz ma mb mc b">List&lt;Magazine&gt;</code>或<code class="fe lz ma mb mc b">List&lt;Publication&gt;</code>上调用，甚至可以在<code class="fe lz ma mb mc b">List&lt;Object&gt;</code>上调用。</p><p id="9750" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">语法<code class="fe lz ma mb mc b">? extends T</code>指定了类型<em class="lp">上限</em> —该类型必须是<code class="fe lz ma mb mc b">T</code>的子类型；语法<code class="fe lz ma mb mc b">? super T</code>指定了类型<em class="lp">下限</em> —该类型必须是<code class="fe lz ma mb mc b">T</code>的超类型。Java不允许同时指定上限和下限(尽管有些语言允许，例如Scala)。方法<code class="fe lz ma mb mc b">printTitlesAndAddMagazine</code>必须在其签名中准确使用<code class="fe lz ma mb mc b">List&lt;Publication&gt;</code>。</p><h2 id="73c0" class="md me iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">命名类型</h2><p id="d88d" class="pw-post-body-paragraph kt ku iq kv b kw mw jr ky kz mx ju lb lc my le lf lg mz li lj lk na lm ln lo ij bi translated">在到目前为止的例子中，列表元素的类型还没有命名。它也可以被命名，而保持未指定。方法<code class="fe lz ma mb mc b">printTitles</code>的这种变体是可能的:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="e5f4" class="md me iq mc b gy ng nh l ni nj">&lt;A extends Publication&gt; void printTitles(List&lt;A&gt; <em class="lp">collection</em>) {<br/>  for (Publication <em class="lp">p </em>: <em class="lp">collection</em>)<br/>    System.<em class="lp">out</em>.println(<em class="lp">p</em>.title());<br/>}</span></pre><p id="c909" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这里，列表元素的类型变成了方法的类型参数，名为<code class="fe lz ma mb mc b">A</code>(但是它仍然是未指定的，有一个上限)。</p><p id="eaec" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">除了可读性之外，以这种方式命名类型还有几个优点。首先，它可以使编译器的类型推断任务更容易。无法编译以下方法:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="8abc" class="md me iq mc b gy ng nh l ni nj">void dupFirst(List&lt;? extends Publication&gt; collection) {<br/>  if (!collection.isEmpty())<br/>    collection.add(0, collection.get(0));</span></pre><p id="bff5" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">由<code class="fe lz ma mb mc b">collection.get(0)</code>返回的值有一个明显与列表兼容的类型，但是编译器失去了对这个信息的跟踪并拒绝了对<code class="fe lz ma mb mc b">add</code>的调用。相反，该方法需要命名类型，并写成:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="2c6d" class="md me iq mc b gy ng nh l ni nj">&lt;A extends Publication&gt; void dupFirst(List&lt;A&gt; <em class="lp">collection</em>) {<br/>  if (!<em class="lp">collection</em>.isEmpty())<br/>    <em class="lp">collection</em>.add(0, <em class="lp">collection</em>.get(0));<br/>}</span></pre><p id="b9d6" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">尽管这种情况并不常见，但另一个好处是一个命名类型可以有多个边界。例如，一个通过网络存储发布列表的方法可能要求发布是<em class="lp">可序列化的</em>:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="1db4" class="md me iq mc b gy ng nh l ni nj">&lt;A extends Publication &amp; Serializable&gt;<br/>  void storePublications(List&lt;A&gt; <em class="lp">collection</em>) {...}</span></pre><p id="a480" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">语法<code class="fe lz ma mb mc b">&lt;? extends T &amp; U&gt;</code>是不可能的。命名还支持更复杂的类型，如在此方法中，它要求对发布进行排序:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="e6a9" class="md me iq mc b gy ng nh l ni nj">&lt;A extends Publication &amp; Comparable&lt;A&gt;&gt;<br/>  void printTitlesInOrder(List&lt;A&gt; <em class="lp">collection</em>) {...}</span></pre><p id="f2a6" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">关于翻转大小，在Java中只能命名上类型边界，而不能命名下类型边界。换句话说，这些是可能的:</p><ul class=""><li id="5980" class="nk nl iq kv b kw kx kz la lc nm lg nn lk no lo np nq nr ns bi translated"><code class="fe lz ma mb mc b">&lt;? extends U&gt;</code></li><li id="3435" class="nk nl iq kv b kw nt kz nu lc nv lg nw lk nx lo np nq nr ns bi translated"><code class="fe lz ma mb mc b">&lt;? super T&gt;</code></li><li id="4977" class="nk nl iq kv b kw nt kz nu lc nv lg nw lk nx lo np nq nr ns bi translated"><code class="fe lz ma mb mc b">&lt;T extends U&gt;</code></li></ul><p id="8f74" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">但是没有<code class="fe lz ma mb mc b">&lt;U super T&gt;</code>语法。</p><h2 id="04bf" class="md me iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">数组的情况</h2><p id="70eb" class="pw-post-body-paragraph kt ku iq kv b kw mw jr ky kz mx ju lb lc my le lf lg mz li lj lk na lm ln lo ij bi translated">在Java中，<code class="fe lz ma mb mc b">Book[]</code> <em class="lp">是</em>的一个子类型<code class="fe lz ma mb mc b">Publication[]</code>。更一般的，如果<code class="fe lz ma mb mc b">T</code>是<code class="fe lz ma mb mc b">U</code>的子类型，<code class="fe lz ma mb mc b">T[]</code>就是<code class="fe lz ma mb mc b">U[]</code>的子类型。这是Java的早期设计决策，允许用<code class="fe lz ma mb mc b">Object[]</code>签名编写一般的排序或搜索方法，并在<code class="fe lz ma mb mc b">String[]</code>或<code class="fe lz ma mb mc b">Book[]</code>上调用它们。</p><p id="e3a3" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">因此，这种方法:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="4f3f" class="md me iq mc b gy ng nh l ni nj">void printTitlesAndReplaceFirst(Publication[] <em class="lp">collection</em>) {<br/>  for (Publication <em class="lp">p </em>: <em class="lp">collection</em>)<br/>    System.<em class="lp">out</em>.println(<em class="lp">p</em>.title());<br/>  <em class="lp">collection</em>[0] = new Magazine(...);<br/>}</span></pre><p id="8c65" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">可以在类型为<code class="fe lz ma mb mc b">Book[]</code>的值上调用。该方法的最后一行需要将杂志存储在书籍数组中，将在运行时抛出一个<code class="fe lz ma mb mc b">ArrayStoreException</code>。</p><h2 id="19d0" class="md me iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">协方差和逆变</h2><p id="a6d3" class="pw-post-body-paragraph kt ku iq kv b kw mw jr ky kz mx ju lb lc my le lf lg mz li lj lk na lm ln lo ij bi translated">Java中的数组被称为<em class="lp">协变</em>:如果<code class="fe lz ma mb mc b">T</code>是<code class="fe lz ma mb mc b">U</code>的子类型，<code class="fe lz ma mb mc b">T[]</code>是<code class="fe lz ma mb mc b">U[]</code>的子类型。在Java中，数组是唯一的协变类型，但在其他语言中并非如此。例如，在Scala中，<code class="fe lz ma mb mc b">List</code>是协变的，<code class="fe lz ma mb mc b">List[Book]</code> <em class="lp">是<code class="fe lz ma mb mc b">List[Publication]</code>的一个子类型</em>(Scala列表是不可变的，并且没有向图书列表中添加杂志的危险)。其他语言，如C#和Kotlin，有协变类型。</p><p id="c62f" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated"><em class="lp">逆变</em>是对称的:如果，当<code class="fe lz ma mb mc b">T</code>是<code class="fe lz ma mb mc b">U</code>的子类型，<code class="fe lz ma mb mc b">X[T]</code>是<code class="fe lz ma mb mc b">X[U]</code>的超类型，<code class="fe lz ma mb mc b">X</code>被称为逆变。作为一个例子，考虑一个类型<code class="fe lz ma mb mc b">Consumer[T]</code>可以“消费”类型<code class="fe lz ma mb mc b">T</code>的值。显然，<code class="fe lz ma mb mc b">Consumer[Publication]</code>可以消费一本书(因为它可以消费一个出版物)，因此<code class="fe lz ma mb mc b">Consumer[Publication]</code>应该是<code class="fe lz ma mb mc b">Consumer[Book]</code>的一个子类型。</p><p id="edb2" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">基本上，让值<em class="lp">出</em>的类型可以成为协变的，而在中取值<em class="lp">的类型可以成为逆变的(<code class="fe lz ma mb mc b">in</code>和<code class="fe lz ma mb mc b">out</code>是C#和Kotlin中用来定义逆变和协变类型的关键字)。需要两者的类型通常不能是协变的或逆变的；它们必须保持<em class="lp">不变</em>(或<em class="lp">不变</em>)，就像Java中的集合一样。例如，Scala中的数组是不可变的，并且<code class="fe lz ma mb mc b">Array[Book]</code>和<code class="fe lz ma mb mc b">Array[Publication]</code>之间没有关系。(在Kotlin中，数组也是不可变的，但是在C#中，它们是协变的，具有潜在的<code class="fe lz ma mb mc b">ArrayTypeMismatchException</code>。)由多个类型参数化的类型可以混合协方差和逆变。例如，在Scala中，函数的输出类型是协变的，输入类型是逆变的。</em></p><h2 id="eecc" class="md me iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">使用</h2><p id="64fa" class="pw-post-body-paragraph kt ku iq kv b kw mw jr ky kz mx ju lb lc my le lf lg mz li lj lk na lm ln lo ij bi translated">当设计可重用的库代码时，考虑使用类型边界以获得灵活性。例如，一个获取任务列表(指定为<code class="fe lz ma mb mc b">Callable</code>的实例)并产生结果列表的Java方法，可能在一个线程池上并行执行任务，可以有这样的签名:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="6c60" class="md me iq mc b gy ng nh l ni nj">&lt;A&gt; List&lt;A&gt; execute(List&lt;Callable&lt;A&gt;&gt; <em class="lp">tasks</em>) {...}</span></pre><p id="6655" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">然而，拥有图书检索和杂志检索任务列表的用户将不能使用这种方法来生成出版物列表。一个更加用户友好的方法可以在其签名中使用类型界限:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="62eb" class="md me iq mc b gy ng nh l ni nj">&lt;A&gt; List&lt;A&gt; execute(List&lt;? extends Callable&lt;? extends A&gt;&gt; <em class="lp">tasks</em>) {...}</span></pre><p id="0b00" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这个方法可以用在<code class="fe lz ma mb mc b">List&lt;BookTask&gt;</code>上，其中<code class="fe lz ma mb mc b">BookTask</code>是<code class="fe lz ma mb mc b">Callable&lt;Book&gt;</code>的一个子类型，并产生一个<code class="fe lz ma mb mc b">List&lt;Publication&gt;</code>。</p><p id="94a9" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">如果您使用的不是Java，而是支持协变和逆变类型的语言，那么您可以利用它们。例如，使用任务的<code class="fe lz ma mb mc b">Unit =&gt; A</code>函数，Scala中灵活的<code class="fe lz ma mb mc b">execute</code>方法可以简单到:</p><pre class="kh ki kj kk gt nc mc nd ne aw nf bi"><span id="e8b8" class="md me iq mc b gy ng nh l ni nj">def execute[A](tasks: List[Unit =&gt; A]): List[A] = ...</span></pre><p id="7907" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这与使用类型界限的Java方法一样灵活，因为在Scala中，<code class="fe lz ma mb mc b">List</code>是协变的，函数在其返回类型中也是协变的。</p><h2 id="595f" class="md me iq bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">结论</h2><p id="7a8f" class="pw-post-body-paragraph kt ku iq kv b kw mw jr ky kz mx ju lb lc my le lf lg mz li lj lk na lm ln lo ij bi translated"><code class="fe lz ma mb mc b">&lt;? extends T&gt;</code>、<code class="fe lz ma mb mc b">&lt;T extends U&gt;</code>和<code class="fe lz ma mb mc b">&lt;? super T&gt;</code>用于指定类型界限，这是一种机制，通过这种机制，代码可以由类型参数化，同时保持对该类型的约束。在Java中使用它们通常是必要的，因为该语言不支持类型差异。其他更现代的语言提供了额外的特性，比如方差注释或组合的下限/上限。</p></div></div>    
</body>
</html>