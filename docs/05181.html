<html>
<head>
<title>Create your own ‘CamScanner’ using Python &amp; OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和OpenCV创建自己的“摄像机”</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-your-own-camscanner-using-python-opencv-66251212270?source=collection_archive---------5-----------------------#2020-08-10">https://levelup.gitconnected.com/create-your-own-camscanner-using-python-opencv-66251212270?source=collection_archive---------5-----------------------#2020-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="df23" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你有没有想过一个“摄像头扫描仪”是如何将你手机里模糊的文档图片转换成清晰的、光线合适的扫描图像的？我做过，直到最近我还认为这是一项非常困难的任务。但事实并非如此，我们可以用相对较少的几行代码来制作我们自己的“摄像机”。(与我们的想法相比)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9e693b0f7fff56e191aefa1fbaee2f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yUJT2q2_mrzBObA8"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">安妮·斯普拉特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="7cc3" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">感谢<a class="ls lt ep" href="https://medium.com/u/ed0ec1818937?source=post_page-----66251212270--------------------------------" rel="noopener" target="_blank"> Soham Mhatre </a>对本文做出的重要贡献。</h2><h1 id="d5c0" class="lu kx iq bd ky lv lw lx lb ly lz ma le jw mb jx li jz mc ka lm kc md kd lq me bi translated">计算机视觉为什么这么热门？</h1><p id="e1fa" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">计算机视觉是一个跨学科的科学领域，研究计算机如何从数字图像或视频中获得高层次的理解。从工程的角度来看，它寻求理解和自动化人类视觉系统可以完成的任务。<strong class="mh ir"> <em class="my">基本上是</em> </strong> <em class="my">，</em>让计算机理解一张照片/视频，就像人类理解它一样，这是一个科学领域。</p><h2 id="8387" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">那么，为什么会有这样的议论呢</h2><p id="7b33" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">人工智能和机器学习的进步加速了计算机视觉的发展。早期，这是两个独立的领域，两者都有不同的技术、编码语言和学术研究者。但现在，这一差距已经显著缩小，越来越多的数据科学家正在计算机视觉领域工作，反之亦然。原因是这两个领域有一个简单的共同点——数据。</p><p id="eaf0" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">最终，计算机将通过消耗数据来学习。人工智能不仅帮助计算机进行处理，还通过反复试验来提高它的理解/解释能力。所以现在，如果我们可以结合来自图像的数据，并在其上运行复杂的机器学习算法，我们得到的就是一个实际的人工智能。</p><blockquote class="ne nf ng"><p id="5a0c" class="mf mg my mh b mi mz jr mk ml na ju mn nh nb mp mq ni nc ms mt nj nd mv mw mx ij bi translated">一家引领计算机视觉技术的现代公司是特斯拉汽车公司</p></blockquote><blockquote class="nk"><p id="08dc" class="nl nm iq bd nn no np nq nr ns nt mx dk translated">特斯拉汽车公司(Tesla Motors)因在世界上开创自动驾驶汽车革命而闻名。它们还因在自动驾驶汽车中实现高可靠性而闻名。特斯拉汽车完全依赖计算机视觉。</p></blockquote></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="9995" class="lu kx iq bd ky lv ob lx lb ly oc ma le jw od jx li jz oe ka lm kc of kd lq me bi translated">我们今天要实现什么？</h1><p id="d5e1" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">对于本文，我们将只关注计算机视觉，机器学习留待以后讨论。我们也将只使用一个库<strong class="mh ir"><em class="my">【OpenCV】</em></strong><em class="my">来创建整个东西</em> <strong class="mh ir"> <em class="my">。</em>T9】</strong></p><h1 id="0d4e" class="lu kx iq bd ky lv lw lx lb ly lz ma le jw mb jx li jz mc ka lm kc md kd lq me bi translated"><strong class="ak">索引</strong></h1><ol class=""><li id="0c19" class="og oh iq mh b mi mj ml mm lf oi lj oj ln ok mx ol om on oo bi translated">OpenCV是什么？</li><li id="0638" class="og oh iq mh b mi op ml oq lf or lj os ln ot mx ol om on oo bi translated">使用不同的概念对图像进行预处理，例如模糊、阈值处理、去噪(非局部方法)。</li><li id="21cb" class="og oh iq mh b mi op ml oq lf or lj os ln ot mx ol om on oo bi translated">Canny边缘检测与最大轮廓提取</li><li id="4afd" class="og oh iq mh b mi op ml oq lf or lj os ln ot mx ol om on oo bi translated">最后—锐化和亮度校正</li></ol></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="2a39" class="lu kx iq bd ky lv ob lx lb ly oc ma le jw od jx li jz oe ka lm kc of kd lq me bi translated">什么是OpenCV</h1><p id="c936" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">OpenCV是一个主要针对实时计算机视觉的编程函数库。最初由英特尔开发，后来得到了Willow Garage和Itseez的支持。该库是跨平台的，在开源BSD许可下可以免费使用。它最初是用C++开发的，但现在可以跨多种语言使用，如Python、Java等。</p><h1 id="f74c" class="lu kx iq bd ky lv lw lx lb ly lz ma le jw mb jx li jz mc ka lm kc md kd lq me bi translated">从预处理开始</h1><h2 id="333e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">模糊</strong></h2><p id="f045" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">模糊的目的是减少图像中的噪声。它从图像中移除高频内容(例如:噪声、边缘)，从而导致边缘模糊。OpenCV中有多种模糊技术(滤镜)，最常见的有:</p><p id="8132" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated"><strong class="mh ir">平均</strong> —它只是取内核区域下所有像素的平均值，并用这个平均值替换中心元素</p><p id="4ac4" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated"><strong class="mh ir">高斯滤波器</strong>——使用高斯内核，而不是由相等滤波器系数组成的箱式滤波器</p><p id="7a7c" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated"><strong class="mh ir">中值滤波器</strong> —计算内核窗口下所有像素的中值，中心像素被替换为该中值</p><p id="f14d" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated"><strong class="mh ir">双边滤镜</strong>——高斯模糊的高级版本。它不仅可以消除噪声，还可以平滑边缘。</p><div class="kg kh ki kj gt ab cb"><figure class="ou kk ov ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/ab123dd7a5a4489e3679330357d15f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*M-bea60NgKRxn1nO5IuCug.jpeg"/></div></figure><figure class="ou kk ov ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/21614c2765d79205f99510743f3770a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vWSnV0jCZVoZRvN6jEkzjw.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk pa di pb pc translated">原始Vs高斯模糊</figcaption></figure></div><h2 id="b297" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">阈值处理</h2><p id="f6c3" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">在图像处理中，阈值处理是分割图像的最简单的方法。从灰度图像，阈值可以用来创建二进制图像。这通常是为了清楚地区分不同色调的像素强度。OpenCV中最常见的阈值技术有:</p><p id="8d6e" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated"><strong class="mh ir">简单阈值</strong> —如果像素值大于阈值，则为其分配一个值(可能是白色)，否则为其分配另一个值(可能是黑色)</p><p id="7cef" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated"><strong class="mh ir">自适应阈值</strong> —算法计算图像小区域的阈值。因此，对于同一幅图像的不同区域，我们得到了不同的阈值，并且对于具有不同光照的图像，它给出了更好的结果。</p><blockquote class="ne nf ng"><p id="c6d8" class="mf mg my mh b mi mz jr mk ml na ju mn nh nb mp mq ni nc ms mt nj nd mv mw mx ij bi translated">注意:记住在设定阈值之前将图像转换为灰度</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/00657ec4aa79352f509d00c0bcc42f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L09YTPI5Azq9pd12n_kVQQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">原始灰度与自适应高斯</figcaption></figure><h2 id="02b4" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">去噪</h2><p id="b5be" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">我们还进行了另一种去噪——<strong class="mh ir"><em class="my">非局部去噪。</em> </strong>最初的去噪方法的原理是用邻近像素的颜色平均值来代替一个像素的颜色。概率论中的方差定律保证了如果对9个像素进行平均，则平均值的噪声标准差除以3。因此给了我们一个去噪的图像。</p><p id="3d1d" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">但是，如果有边缘或<em class="my">拉长的</em>图案，平均去噪不起作用，该怎么办？因此，我们需要扫描图像的大部分，以搜索所有真正类似于我们想要去噪的像素的像素。然后通过计算这些最相似像素的平均颜色来进行去噪。这叫做— <strong class="mh ir"> <em class="my">非局部的意思就是去噪。</em> </strong></p><p id="855e" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">同样使用<code class="fe pe pf pg ph b">cv2.fastNlMeansDenoising</code>。</p><div class="kg kh ki kj gt ab cb"><figure class="ou kk pi ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/ee3c1715751808e0c1dca90643e5817a.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*M-bea60NgKRxn1nO5IuCug.jpeg"/></div></figure><figure class="ou kk pi ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/d5ab2208149a71aed0416dc929510aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*vWSnV0jCZVoZRvN6jEkzjw.jpeg"/></div></figure><figure class="ou kk pi ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/70897ef0292991355bf0d9c8a6142a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*M6wLOv72dSroNnaByPJscg.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk pj di pk pc translated">原始与高斯模糊与非局部均值去噪</figcaption></figure></div></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="2d1e" class="lu kx iq bd ky lv ob lx lb ly oc ma le jw od jx li jz oe ka lm kc of kd lq me bi translated">Canny边缘检测与最大轮廓提取</h1><p id="337a" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">在图像模糊和阈值处理之后，下一步是找到最大的轮廓(最大的边界框)并裁剪出图像。这是通过使用Canny边缘检测，然后使用四点变换提取最大轮廓来完成的。</p><h2 id="c7b0" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">锐利的边缘</h2><p id="4713" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">Canny边缘检测是一种可以检测边缘的多步算法。我们应该向该算法发送去噪声的图像，以便它能够只检测相关的边缘。</p><h2 id="fd9e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">寻找轮廓</strong></h2><p id="86a2" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">找到边缘后，将图像通过<code class="fe pe pf pg ph b">cv2.findcontours()</code>。它连接所有连续的点(沿着边缘)，具有相同的颜色或强度。在这之后，我们将得到所有的轮廓——矩形、球形等</p><p id="9107" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">使用<code class="fe pe pf pg ph b">cv2.convexHull()</code>和<code class="fe pe pf pg ph b">cv2.approxPolyDP</code>找到照片中最大的矩形轮廓(大约)。</p><div class="kg kh ki kj gt ab cb"><figure class="ou kk ov ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/2b21f3a80bfdfea75433fe450d1eea51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*f6D514542_eM6LQL75bIhA.jpeg"/></div></figure><figure class="ou kk ov ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/c9438c218d16c53cfaab95cb290579a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*QSsfzQ-XD0mebbaRs5Bsow.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk pa di pb pc translated">原始与具有最大边界框的原始</figcaption></figure></div><h2 id="b727" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">提取最大轮廓</h2><p id="e77e" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">虽然我们已经找到了看起来像矩形的最大轮廓，但我们仍然需要找到<strong class="mh ir"><em class="my"/></strong>角，以便找到精确的坐标来裁剪图像。</p><p id="b7da" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">首先传递近似矩形(最大轮廓)的坐标，并在其上应用<strong class="mh ir"> <em class="my">顺序点</em> </strong>变换。结果是最大轮廓的精确(x，y)坐标。</p><p id="e8f0" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated"><strong class="mh ir">四点变换</strong>——使用上述(x，y)坐标，计算轮廓的宽度和高度。通过<code class="fe pe pf pg ph b">cv2.warpPerspective()</code>来裁剪轮廓。瞧——你已经成功地从输入图像中裁剪出了<em class="my">相关的</em>数据</p><div class="kg kh ki kj gt ab cb"><figure class="ou kk pl ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/988ecf68b22ce2e3ebe4aeb57393627a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*f6D514542_eM6LQL75bIhA.jpeg"/></div></figure><figure class="ou kk pm ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/267377c163c651b343c7d9347bb1a8e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*ypj-VH1ZaG5ABclgJHF-JA.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk pn di po pc translated">原始图像与裁剪图像</figcaption></figure></div><blockquote class="ne nf ng"><p id="6590" class="mf mg my mh b mi mz jr mk ml na ju mn nh nb mp mq ni nc ms mt nj nd mv mw mx ij bi translated">请注意——即使是一张光线不佳、点击次数不多的图片，它的裁剪效果也很好</p></blockquote><h1 id="1b0c" class="lu kx iq bd ky lv lw lx lb ly lz ma le jw mb jx li jz mc ka lm kc md kd lq me bi translated">最后—锐化和亮度校正</h1><p id="1218" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">现在我们已经从图像中裁剪出了相关的信息(最大的轮廓)，最后一步是锐化图片，这样我们就可以得到清晰易读的文档。</p><p id="0bd3" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">—为此，我们使用<em class="my">色调、饱和度、值(h，s，v) </em>概念，其中<em class="my">值</em>代表<em class="my">亮度。</em>可以用这个值来增加文档的亮度</p><p id="086e" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">— <strong class="mh ir"> <em class="my">内核锐化—</em>一个内核</strong>、<strong class="mh ir">卷积矩阵</strong>，或者<strong class="mh ir">遮罩</strong>就是一个小矩阵。它用于模糊、锐化、浮雕、边缘检测等。这是通过在内核和图像之间进行卷积来实现的</p><h2 id="1998" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结果</h2><div class="kg kh ki kj gt ab cb"><figure class="ou kk pl ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/988ecf68b22ce2e3ebe4aeb57393627a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*f6D514542_eM6LQL75bIhA.jpeg"/></div></figure><figure class="ou kk pm ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/0a9e2078984cfe41e220d6692f8be674.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*_LcK7kSdZUQ_YCRvtu58CQ.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk pn di po pc translated">原始结果与最终结果(裁剪、增亮和锐化)</figcaption></figure></div></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="722f" class="lu kx iq bd ky lv ob lx lb ly oc ma le jw od jx li jz oe ka lm kc of kd lq me bi translated">完全码</h1><p id="d184" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn lf mo mp mq lj mr ms mt ln mu mv mw mx ij bi translated">这是最终的代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pp pq l"/></div></figure></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="2f71" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">要浏览我的其他数据科学/机器学习博客，请访问:</p><div class="pr ps gp gr pt pu"><a href="https://medium.com/@shirishgupta" rel="noopener follow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd ir gy z fp pz fr fs qa fu fw ip bi translated">谢里什·古普塔培养基</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">阅读希利什·古普塔在媒介上的作品。我是学术界的经济学家，专业的数据科学家和旅行者…</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">medium.com</p></div></div><div class="qd l"><div class="qe l qf qg qh qd qi kp pu"/></div></div></a></div><p id="a867" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">暂时结束了。有什么想法来改善这一点或希望我尝试任何新的想法？请在评论中给出你的建议。再见。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="2150" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">感谢<a class="ls lt ep" href="https://medium.com/u/2b8f8f0c68a1?source=post_page-----66251212270--------------------------------" rel="noopener" target="_blank"> Adrian Rosebrock </a>在<a class="ae kv" href="http://www.pyimagesearch.com" rel="noopener ugc nofollow" target="_blank"> PyImageSearch </a>上发表的所有有用的博客。有帮助的博客— <br/> 1。<a class="ae kv" href="https://www.pyimagesearch.com/2014/09/01/build-kick-ass-mobile-document-scanner-just-5-minutes/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2014/09/01/build-kick-ass-mobile-document-scanner-just-5-minutes/</a></p><p id="6b25" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">2.<a class="ae kv" href="https://www.pyimagesearch.com/2014/08/25/4-point-opencv-getperspective-transform-example/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2014/08/25/4-point-opencv-get perspective-transform-example/</a></p><p id="f4fc" class="pw-post-body-paragraph mf mg iq mh b mi mz jr mk ml na ju mn lf nb mp mq lj nc ms mt ln nd mv mw mx ij bi translated">3.<a class="ae kv" href="https://www.pyimagesearch.com/2016/03/21/ordering-coordinates-clockwise-with-python-and-opencv/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2016/03/21/ordering-coordinates-顺时针-with-python-and-opencv/ </a></p></div></div>    
</body>
</html>