# 鲍勃大叔对 web 框架的看法是错误的(大部分)

> 原文：<https://levelup.gitconnected.com/uncle-bob-is-wrong-about-web-frameworks-mostly-5a08b19dd08e>

![](img/a7665eb9b851a80eaa2c4032d634c631.png)

图片来自 [Pixabay](https://pixabay.com/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=1474454) 的 [ElasticComputeFarm](https://pixabay.com/users/elasticcomputefarm-1865639/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=1474454)

我是一个自学成才的程序员，这意味着我的大部分导师已经被时间冻结在书面文字的形式中了。

罗伯特·c·马丁，也就是鲍勃大叔，就是其中之一。

但是，随着我们的成长，我们用自己的眼光看待问题，很自然我们会形成与老师不同的观点。这就是我最近所做的关于干净架构的话题，特别是关于 Martin 关于文件夹结构和 web 框架的论点。

# 鲍勃叔叔对框架的看法

我几乎看了所有我能在 YouTube 上找到的视频，其中罗伯特·马丁讲述了干净的代码，或者干净的架构。诚然，它们基本上是在不同的地点录制的相同的演讲。

我不介意。

就像把一本书看了很多遍，看了多个版本。我总是带着新的东西离开。

在本文中，我将重点介绍他在 2012 年和 2013 年挪威开发者大会上的两次演讲。这基本上是同样的演讲，但是第二年有了一点小小的变化。

然而，两次会谈都以同样的基调开始。在他简短的轶事中，他讨论了有一天他的儿子如何向他展示了一个文件夹结构。只需浏览一下文件夹结构，他就能推断出该应用程序是用 Ruby on Rails 编写的。

如果您曾经花时间使用框架，这可能是您熟悉的场景。我可以打开任何 Laravel 应用程序，并立即知道它使用的是什么框架——如果不是版本的话。CakePHP 也是如此。或者 Zend。或者我们可以使用的各种框架。

但是，出于某种原因，对于那天的 Martin 来说，他没有像大多数人那样将其视为开发经验的标志，而是奇怪地发现他在这个项目中首先看到的是框架，而不是应用程序本身。

他最初认为，当查看文件夹结构时，首先应该看到的是应用程序要执行什么。

*喜欢这篇文章吗？* [*成为会员*](https://travisweston.com/membership) *和* [*订阅*](https://travisweston.com/subscribe) *获取更多类似这样的精彩内容！*

# 鲍勃叔叔哪里弄错了

文件夹结构应该描述应用程序意图的想法是一个很好的概念，我完全同意——当我们谈论您的应用程序代码时。

Martin 的错误在于他认为 web 是一个输入/输出设备，我们的代码不应该关心它是否在 web 上运行。它应该只关心业务逻辑。

再说一次，从表面上看这并没有错。他说的每一句话都是绝对正确的。但是有一件事他错了:

# Web 框架不是我们应用程序的一部分，它们是一个抽象层

Martin 似乎像看待 STDIN/STDOUT 一样看待 web IO 设备。问题是，虽然标准输入/输出具有几乎所有语言固有的操作系统级抽象支持，但网站 IO 却没有。

当处理 web 流量时，任何语言都需要处理一些引导层。具体来说，路由。

看看目前最大的 web 框架，它们在开始时解决的第一件事就是如何处理路由。你认为这是为什么？

## 因为路由是 web IO 设备的最后一道坎。

就像争论你的 Apache 或 Nginx 安装是你的核心应用程序的一部分是愚蠢的，我们应该批判任何声称我们的 web 框架是我们的核心应用程序的一部分的人。

为什么我强调核心？因为不把它看作是我们应用程序的一部分也是愚蠢的。正如动态链接库是为本地操作系统编写的应用程序的一部分，但不是它们的核心功能，我们将框架作为我们的抽象库合并到 web 中。

# 文件夹结构不是架构

在他 2012 年会议的早期，Martin 展示了一个列表，他描述这个列表代表了很多人在被问到他们的“架构”是什么时的回答。这个列表是:Java、Eclipse、Spring、Tomcat、Hibernate、MySQL 和 MVC。

他认为这不是你的架构，而是你的工具。尽管我同意这个列表不是一个架构，它也不仅仅是工具。它是工具和原材料的混合物。

他向你要你的建筑图，你给他一份锤子和锯子的清单。但是，尽管他的清单上有一些锤子和锯子——例如 Eclipse——也有一些木材——Java——和实用程序——MySQL——还有一点美学——MVC。

他按照这个列表，试图在架构图和你的文件夹结构之间画出一条平行线。这是一个很有吸引力的类比，我第一次看他的演讲时，我可能已经被说服了。但是当我重新观看，并拿出更多的时候，我意识到这是一个错误的类比。

架构图更类似于规划文档，或者用例，而不是文件夹结构。他们描述了最终产品*应该是什么样子的。*

# 不过，鲍勃叔叔有很多是对的

然而，Martin 很快将注意力从文件夹结构转移到实际的代码架构上。他的图表解释了如何在逻辑上布局你的应用程序，并将其与你正在使用的任何框架隔离开来，这使得他试图将文件放置的地方进行比较的努力黯然失色。

这是我和他意见一致的地方。

框架的问题与它们是否存在于你的 web 文件夹的根目录无关，而是*它们是否存在于你的应用程序逻辑的根目录*。

正如我上面所描述的，框架本质上只是一个抽象层。应用程序的核心不应该关心它是从 Laravel 还是 WordPress 内部运行的。如果已经编写了正确的接口，您应该能够从命令行运行它。

# 核心应用程序不应该扩展也不应该实现框架特性

允许您的核心应用程序使用 Laravel 的雄辩模型是很诱人的。使用这些型号似乎违背了“拉腊维尔之道”。但是你不应该。

除此之外，你的核心架构不应该实现任何 Laravel 助手方法，比如`Str`助手。

您的核心应用程序应该实现接口，并且应该只使用这些接口来接受来自提供它的任何层的数据，前提是该层正确地实现了接口。这允许您编写核心业务逻辑，然后抽象出实际的数据源。

注意，这绝对与文件夹结构无关，而与应用程序逻辑有关。

# 所以让我们来谈谈文件夹结构

我相信 Martin 试图用他的文件夹结构论点来说明的是，文件夹结构在逻辑上应该与应用程序逻辑一致。从表面上看，这绝对有道理。

我在过去已经谈到过[使用名称空间清理你的代码](https://travis-weston.medium.com/clean-php-code-namespaces-c39e410f79d2)。命名空间提供了许多好处，其中之一是通过简单地围绕命名空间结构设计文件夹结构，就可以得到一个自然的、合乎逻辑的应用程序文件夹层次结构。

现在，当我进入这个领域时，我将使用 PHP 作为我的主要示例语言，但是这对于任何使用名称空间的语言都适用。只是在理论层面，不具体实施。

# 但是在哪里？

我一直用 Laravel 作为我的例子，所以我将在这里继续。

我认为您应该避免在`app`文件夹中编写任何业务逻辑代码。

我敢肯定，如果你曾经使用过 Laravel，这一定会让你大吃一惊。事情是这样的，正如我们已经讨论过的，Martin 在一件重要的事情上是正确的:从你的框架中移除你的业务逻辑。

他对目录结构的看法可能是错误的，但可能没有你想的那么严重。

我知道，我只是拉了一个小诱饵，在你身上切换，不是吗？

不完全是，但算是吧。

在生产环境中，您的根几乎不可避免地是一个 Laravel 应用程序。试图抽象事物，以自己的方式实现所有的 Laravel 框架，实际上会使您的应用程序逻辑更加接近 Laravel。

相反，您应该做的是将您的业务逻辑编写成一个包，通过 composer 安装在供应商目录中。您的业务逻辑存在于一个存储库中，您的业务逻辑的 Laravel 实现存在于另一个存储库中。

## 这可能就是鲍勃叔叔一直以来的意思

罗伯特·马丁的演讲既有戏剧性，又有很高的知识性。如果他把对文件夹结构的讨论放在演讲的开始，仅仅是为了引出那些愿意和他争论的人，我不会感到惊讶。

只是为了让我们到最后。

# 所有这些只是关注点的适当分离

关注点分离是 Martin 众所周知的一个主题。当然，他是第一个在他的论文[Design Principles and Design Patterns【pdf】](https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf)中将 SOLID 原则正式化的人。

他的清洁架构的方法仅仅是将单一责任原则提升到架构的层次。如果我们将代码组视为存储库，那么每个存储库应该做一件事情，并且只做一件事情。

在上面的例子中，我们的业务逻辑存储库的唯一职责是维护我们的领域逻辑。事实上，我们可以很容易地为每个有界的上下文维护单独的存储库，允许这些上下文通过我们用于与框架接口的相同类型的抽象在彼此之间进行通信。

# 鲍勃叔叔的运送机制

在上面的例子中，这个框架就是马丁所说的“交付机制”这是他为显示业务逻辑结果的抽象层提供的名称，同时向业务逻辑交付任何必要的输入。

每个交付机制都有自己的存储库。在我们的例子中，Laravel 将是一个存储库，唯一的职责是充当我们的业务逻辑和 IO 设备(即 web)之间的抽象层。

如果有一天我们决定改变框架，这只是为框架的存储库编写新的实现代码的问题。

# 架构是关于意图，而不是文件夹结构

无论您决定为您的业务逻辑维护单独的物理存储库，或者如果您将其全部存储在同一个存储库中，但是在传统的 Laravel 文件夹层次结构之外，事实是架构是关于意图的，而不是文件夹结构。

您的应用程序的意图就是您的业务逻辑，我们应该从业务逻辑开始的地方寻找意图。

如果我们稍微移动一下柱子，马丁的逻辑就可能成立。我们应该着眼于应用程序逻辑的根，而不是担心框架的根。如果我们在那个结构中发现了框架感染的迹象，那么我们应该如实地指出它——糟糕的架构。

然而，如果我们已经将我们的关注点分离到足够的程度，以至于我们能够将我们的业务逻辑引入到一个新的框架中，编写实现代码，并且在不改变我们的核心业务逻辑的情况下开始运行？

好吧，那我说这是足够好的建筑。

其他一切，都是细节。

你喜欢这篇文章吗？ [*成为会员*](https://travisweston.com/membership) *阅读 Travis Weston 写的所有东西——以及媒体上的所有内容。*

*已经是会员了？* [*订阅得到通知*](https://travisweston.com/subscribe) *特拉维斯·韦斯顿写的每一篇文章。*

## 2012

## 2013