<html>
<head>
<title>CompletableFuture : A new era of asynchronous programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CompletableFuture:异步编程的新时代</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/completablefuture-a-new-era-of-asynchronous-programming-86c2fe23e246?source=collection_archive---------0-----------------------#2019-07-04">https://levelup.gitconnected.com/completablefuture-a-new-era-of-asynchronous-programming-86c2fe23e246?source=collection_archive---------0-----------------------#2019-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/5b7a6e62e3c7847a3b24435121ca3896.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*YyPo83ZRL0eklClnLcZXXA.jpeg"/></div></figure><p id="754d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">异步编程</em>是一种并行编程的形式，允许一个工作单元独立于主应用线程运行。当工作完成时，它通知主线程(以及工作是完成还是失败)。</p><p id="a683" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一方面，在一个<em class="ks">同步</em>编程模型中，事情一次发生一件。当我们调用一个执行长时间运行的动作的函数时，它会在该动作执行并返回的时间内阻塞我们的程序，并且只有在该动作完成并且可以返回结果时才解除阻塞主应用程序线程。</p><p id="a1a4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">等待动作完成在同步模型中是<em class="ks">隐式</em>，而在异步模型中是<em class="ks">显式</em>，在我们的控制下。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi kt"><img src="../Images/298e9235b75f9547d4f4e1321a87f658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7eWf_rkKbBHiXFXnQFnvbA.png"/></div></div></figure><p id="9ad0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有不同的方法使用下面的机制在Java中实现异步编程，例如Futures、ExecutorService、CompletionService、回调接口、线程池等。</p><p id="1796" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是Java 8引入了一个叫做<strong class="jw ir"> CompletableFuture </strong>的新特性，这个特性可以广泛应用于用Java实现异步编程的情况。</p><h1 id="9c6e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">什么是CompletableFuture，它与Future有什么不同:</strong></h1><p id="0801" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">根据Oracle文档，CompletableFuture是一个可以显式完成(设置其值和状态)的<code class="fe mf mg mh mi b"><a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html" rel="noopener ugc nofollow" target="_blank">Future</a></code>，并且可以用作<code class="fe mf mg mh mi b"><a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" rel="noopener ugc nofollow" target="_blank">CompletionStage</a></code>，支持在其完成时触发的依赖函数和动作。</p><p id="afa3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当两个或更多的线程尝试<code class="fe mf mg mh mi b"><a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#complete-T-" rel="noopener ugc nofollow" target="_blank">complete</a></code>、<code class="fe mf mg mh mi b"><a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#completeExceptionally-java.lang.Throwable-" rel="noopener ugc nofollow" target="_blank">completeExceptionally</a></code>或<code class="fe mf mg mh mi b"><a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#cancel-boolean-" rel="noopener ugc nofollow" target="_blank">cancel</a></code>CompletableFuture时，只有一个成功。</p><p id="da84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">CompletableFuture类属于java.util.concurrent包。</p><blockquote class="mk ml mm"><p id="cd88" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">签名</strong>:</p></blockquote><pre class="ku kv kw kx gt mq mi mr ms aw mt bi"><span id="d773" class="mu ld iq mi b gy mv mw l mx my">public class <strong class="mi ir">CompletableFuture&lt;T&gt;</strong><br/>extends <a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" rel="noopener ugc nofollow" target="_blank">Object</a><br/>implements <a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html" rel="noopener ugc nofollow" target="_blank">Future</a>&lt;T&gt;, <a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" rel="noopener ugc nofollow" target="_blank">CompletionStage</a>&lt;T&gt;</span></pre><p id="c45c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">CompletableFuture实现了<code class="fe mf mg mh mi b">Future</code>和<code class="fe mf mg mh mi b">CompletionStage</code>接口，并为创建、链接和组合多种期货提供了大量方便的方法。它还具有非常全面的异常处理支持。CompletableFuture克服了未来的以下限制:</p><ul class=""><li id="9144" class="mz na iq jw b jx jy kb kc kf nb kj nc kn nd kr ne nf ng nh bi translated">即使遇到了异常情况，期货也不能明确完成。</li><li id="a803" class="mz na iq jw b jx ni kb nj kf nk kj nl kn nm kr ne nf ng nh bi translated">Future提供了一个<code class="fe mf mg mh mi b">get()</code>方法，该方法会一直阻塞，直到结果可用。如果不阻塞主应用程序线程，就不能对将来的结果执行进一步的操作。</li><li id="7588" class="mz na iq jw b jx ni kb nj kf nk kj nl kn nm kr ne nf ng nh bi translated">不能通过将多个期货链接在一起来创建异步工作流。</li><li id="ded6" class="mz na iq jw b jx ni kb nj kf nk kj nl kn nm kr ne nf ng nh bi translated">并行运行的期货不能组合在一起。</li><li id="c56a" class="mz na iq jw b jx ni kb nj kf nk kj nl kn nm kr ne nf ng nh bi translated">未来的API没有任何异常处理构造。</li></ul><h1 id="4a87" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">CompletableFuture的实现</strong>:</h1><blockquote class="mk ml mm"><p id="f0c2" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">如何启动</strong>:</p></blockquote><p id="c112" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以用无参数构造函数创建CompletableFuture类的一个实例来表示未来的结果。最简单的前进步骤是将它分发给消费者，并在未来的某个时候使用<code class="fe mf mg mh mi b">CompletableFuture.complete()</code>方法完成它。</p><p id="f801" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以尝试使用<code class="fe mf mg mh mi b">CompletableFuture.get()</code>方法得到这个CompletableFuture的结果，<code class="fe mf mg mh mi b">get()</code>方法会一直阻塞，直到未来完成。</p><blockquote class="mk ml mm"><p id="178f" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">completablefuture . run async()</strong>:</p></blockquote><p id="f1a3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们想异步运行一些后台任务，而<strong class="jw ir"> <em class="ks">不想从该任务返回</em> </strong>任何东西，这是<code class="fe mf mg mh mi b">CompletableFuture.runAsync()</code>方法的理想用例。它接受一个Runnable对象并返回<code class="fe mf mg mh mi b">CompletableFuture&lt;Void&gt;</code>。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nn"><img src="../Images/d0eb8a6bb665116721a037c93dfbe05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGTk7VrdUl42dEuolCpDew.png"/></div></div></figure><p id="2986" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Runnable对象也可以以lambda表达式的形式传递:</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi no"><img src="../Images/129b593501a7c10a0caf9912978dd5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*31svExkFH_nlHjYiUEqNsA.png"/></div></div></figure><blockquote class="mk ml mm"><p id="4179" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">completablefuture . supplyasync()</strong>:</p></blockquote><p id="de5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与上面的用例相反，如果我们想异步运行某个后台任务，并且<strong class="jw ir"> <em class="ks">想从该任务返回</em> </strong>任何东西，我们应该使用CompletableFuture.supplyAsync()。它接受一个<a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html" rel="noopener ugc nofollow" target="_blank">供应商&lt; T &gt; </a>并返回<code class="fe mf mg mh mi b">CompletableFuture&lt;T&gt;</code>，其中T是通过调用给定供应商获得的值的类型。</p><p id="2c2d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html" rel="noopener ugc nofollow" target="_blank">供应商&lt; T &gt; </a>是一个简单的功能接口，表示结果的供应商。它有一个单独的<code class="fe mf mg mh mi b">get()</code>方法，我们可以在其中编写后台任务并返回结果。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi np"><img src="../Images/d73d28448dbec2c36533f8f2e145d778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLVmP5b5UTO6da3NwFkq_g.png"/></div></div></figure><p id="446f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们知道<code class="fe mf mg mh mi b">runAsync()</code>和<code class="fe mf mg mh mi b">supplyAsync()</code>方法在一个单独的线程中执行它们的任务，这个线程从来不是由我们明确创建的。</p><p id="edc6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">CompletableFuture在从全局<a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html#commonPool--" rel="noopener ugc nofollow" target="_blank">forkjoinpool . common pool()</a>获得的线程中执行这些任务。</p><p id="a209" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是我们也可以创建一个<a class="ae mj" href="https://www.callicoder.com/java-executor-service-and-thread-pool-tutorial/" rel="noopener ugc nofollow" target="_blank">线程池</a>并将其传递给<code class="fe mf mg mh mi b">runAsync()</code>和<code class="fe mf mg mh mi b">supplyAsync()</code>方法，让它们在一个从我们的线程池中获得的线程中执行它们的任务。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nq"><img src="../Images/48832ee628f2e1b0397c40e6a7e5605f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxxXgi-VExv7ETMnE9epkQ.png"/></div></div></figure><h1 id="56c7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> <em class="nr">回调</em> </strong>:</h1><p id="65a3" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">回调是对CompletableFuture的结果进行转换和操作的准备。为了构建异步系统，我们应该能够给CompletableFuture附加一个回调，当未来完成它的任务时，这个回调应该被自动触发和执行。</p><p id="8a97" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样，我们就不需要等待未来的结果(非阻塞)，我们可以在回调函数中编写未来完成后需要执行的逻辑。</p><p id="d68a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以使用<code class="fe mf mg mh mi b">thenApply()</code>、<code class="fe mf mg mh mi b">thenAccept()</code>和<code class="fe mf mg mh mi b">thenRun()</code>方法给CompletableFuture附加一个回调。</p><blockquote class="mk ml mm"><p id="e072" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir"> thenApply() </strong>:</p></blockquote><p id="ee2a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当CompletableFuture的结果到达时，我们可以使用<code class="fe mf mg mh mi b">thenApply()</code>方法对其进行处理和转换。它以一个<a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html" rel="noopener ugc nofollow" target="_blank">函数&lt; T，R&gt;T24】作为自变量。</a><a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html" rel="noopener ugc nofollow" target="_blank"> Function &lt; T，R &gt; </a>是一个简单的函数接口，表示一个接受T类型参数并产生R类型结果的函数。</p><p id="d47c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还可以通过附加一系列<code class="fe mf mg mh mi b">thenApply()</code>回调方法，在CompletableFuture上编写一系列转换。一个<code class="fe mf mg mh mi b">thenApply()</code>方法的结果被传递到序列中的下一个。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ns"><img src="../Images/8875f8314904949fc56e50c5339be8a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkbxtoFDER5x6G_m1qr3-w.png"/></div></div></figure><blockquote class="mk ml mm"><p id="3c59" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">然后接受()</strong>:</p></blockquote><p id="d009" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你不想从回调函数返回任何东西，只想在CompletableFuture完成后运行一段代码，那么我们可以使用<code class="fe mf mg mh mi b">thenAccept()</code>方法。</p><p id="1a4c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mf mg mh mi b">CompletableFuture.thenAccept()</code>取一个<a class="ae mj" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html" rel="noopener ugc nofollow" target="_blank">消费者&lt;T&gt;T21】并返回<code class="fe mf mg mh mi b">CompletableFuture&lt;Void&gt;</code>。它可以访问它所附加的CompletableFuture的结果。</a></p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nt"><img src="../Images/f572af632986bb60d4a1be31db7188fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-AYPe36j5M6AH_oTfZrk5A.png"/></div></div></figure><blockquote class="mk ml mm"><p id="01b2" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">然后润()</strong>:</p></blockquote><p id="bb02" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mf mg mh mi b">thenRun()</code>方法也被用作回调函数，该函数不返回任何内容，但执行写在该块中的逻辑。<code class="fe mf mg mh mi b">thenAccept()</code>和<code class="fe mf mg mh mi b">thenRun()</code>方法是消费者，通常用作回调链中的最后一个回调。</p><p id="98e8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然<code class="fe mf mg mh mi b">thenAccept()</code>可以访问它所附加的CompletableFuture的结果，但是<code class="fe mf mg mh mi b">thenRun()</code>甚至不能访问未来的结果。它接受一个<code class="fe mf mg mh mi b">Runnable</code>并返回<code class="fe mf mg mh mi b">CompletableFuture&lt;Void&gt;</code>。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nu"><img src="../Images/35f75df7f619f7b6b19bd7b7f333c8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZIxx9SDmUqlR-2en_YCIUw.png"/></div></div></figure><h1 id="6b91" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">异步回调:</h1><p id="719e" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">在上面的例子中，<code class="fe mf mg mh mi b">thenApply()</code>内部的任务在执行<code class="fe mf mg mh mi b">supplyAsync()</code>任务的同一个线程中执行，或者如果<code class="fe mf mg mh mi b">supplyAsync()</code>任务立即完成，则在主线程中执行。如果我们想进一步增加程序的并行性，并且想在一个单独的线程上运行回调任务，那么异步回调就是解决方案。</p><p id="422b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以使用<code class="fe mf mg mh mi b">thenApplyAsync()</code>回调来代替<code class="fe mf mg mh mi b">thenApply()</code>，然后这个任务将在从<code class="fe mf mg mh mi b">ForkJoinPool.commonPool()</code>获得的不同线程中执行。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nv"><img src="../Images/8061d61189ceaa2bb0e573e4877ebfa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rAPYxjFecabnHnNJnd1wbQ.png"/></div></div></figure><p id="fe9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还可以向<code class="fe mf mg mh mi b">thenApplyAsync()</code>回调传递一个执行程序，然后任务将在从执行程序的线程池中获得的线程中执行。</p><h1 id="8d65" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">将CompletableFutures结合在一起:</h1><blockquote class="mk ml mm"><p id="15bc" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">使用thenCompose(): </strong>合并从属completableFutures</p></blockquote><p id="b435" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在前面的例子中，传递给<code class="fe mf mg mh mi b">thenApply()</code>回调函数的<code class="fe mf mg mh mi b">Supplier</code>函数将会返回值。如果我们的用例是返回一个CompletableFuture。这是<code class="fe mf mg mh mi b">thenCompose()</code>方法的主要用例。</p><p id="7d0a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">如果我们的回调函数返回一个CompletableFuture，我们希望从CompletableFuture链中得到一个扁平化的结果，我们需要使用</em> <code class="fe mf mg mh mi b"><em class="ks">thenCompose()</em></code> <em class="ks">。</em></p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nw"><img src="../Images/6e0a0fd71e722335b60365e21c708ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AYG5p4VHBnkwM0JShSltrw.png"/></div></div></figure><blockquote class="mk ml mm"><p id="8571" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">使用thenCombine() <em class="iq"> : </em> </strong>合并独立的completableFutures</p></blockquote><p id="6d33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mf mg mh mi b">thenCompose()</code>用于组合两个可完成的期货，其中一个期货依赖于另一个，<code class="fe mf mg mh mi b">thenCombine()</code>用于当我们希望两个期货独立运行并在两个期货完成后做一些事情。当两个CompletableFutures都完成时，将调用传递给<code class="fe mf mg mh mi b">thenCombine()</code>的回调函数。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nx"><img src="../Images/de6f7eab52ee5d016d70c1f990649e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LfiS6uc-b6ok4BuTn7MCaw.png"/></div></div></figure><blockquote class="mk ml mm"><p id="dac6" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">将n个可完成的期货组合在一起</strong>:</p></blockquote><p id="33a1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们有一个独立的completableFutures列表，并且我们想要并行运行并且在它们都完成后做一些事情时，使用<code class="fe mf mg mh mi b">CompletableFuture.allOf()</code>。</p><p id="4dde" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mf mg mh mi b">CompletableFuture.anyOf()</code>顾名思义，返回一个新的CompletableFuture，它在任何给定的CompletableFutures完成时完成，结果相同。</p><h1 id="f828" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">CompletableFuture中的异常处理:</h1><blockquote class="mk ml mm"><p id="44f4" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">使用exceptions()回调处理异常</strong>:</p></blockquote><p id="977f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mf mg mh mi b">exceptionally()</code>回调让我们有机会从最初的CompletableFuture产生的错误中恢复。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ny"><img src="../Images/94b0e64cf2c8c8e94fde5ac4713041de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zefUJbE9rZIp0tSpVq7bng.png"/></div></div></figure><blockquote class="mk ml mm"><p id="4f2c" class="ju jv ks jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated"><strong class="jw ir">使用通用Handle()方法处理异常</strong>:</p></blockquote><p id="6794" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">API还提供了一个更通用的方法— <code class="fe mf mg mh mi b">handle()</code>来从异常中恢复。无论异常是否发生，它都会被调用。如果出现异常，<code class="fe mf mg mh mi b">ex</code>参数的值将为非空，否则在成功场景中<code class="fe mf mg mh mi b">res</code>参数的值为非空。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nz"><img src="../Images/5d9f370a320a8513fd6f80152a8f4666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChMeJR7k7eE-yRJkFIt8gw.png"/></div></div></figure><h1 id="cf15" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论:</h1><p id="79bb" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">在本文中，我试图阐明异步编程的不同用例，以及如何使用Java 8的CompletableFuture实现这些场景。如果你喜欢这篇文章，如果你能帮助它传播，我会非常感激。非常感谢您的阅读！</p><h1 id="b670" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">参考文献:</strong></h1><div class="oa ob gp gr oc od"><a href="https://eloquentjavascript.net/11_async.html" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">异步编程::雄辩的JavaScript</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">两个重要的JavaScript编程平台——浏览器和node . js——进行操作可能需要一段时间…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">eloquentjavascript.net</p></div></div><div class="om l"><div class="on l oo op oq om or js od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://stackify.com/when-to-use-asynchronous-programming/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">何时使用(以及不使用)异步编程</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">异步编程是并行编程的一种形式，它允许一个工作单元独立于…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">stackify.com</p></div></div><div class="om l"><div class="os l oo op oq om or js od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://technology.amis.nl/2009/02/19/asynchronous-processing-in-java-applications-leveraging-those-multi-cores/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">Java应用中的异步处理——利用多核——AMIS Oracle和Java……</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">处理器不会变得更快。预计不会有更高的时钟速度。处理速度将会是…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">技术. amis.nl</p></div></div><div class="om l"><div class="ot l oo op oq om or js od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://www.callicoder.com/java-8-completablefuture-tutorial/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">Java CompletableFuture未来教程，带示例</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">Java 8带来了大量的新特性和增强，比如Lambda表达式、流、CompletableFutures等等。在…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">www.callicoder.com</p></div></div><div class="om l"><div class="ou l oo op oq om or js od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://www.baeldung.com/java-completablefuture" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">CompletableFuture指南| Baeldung</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">本文是CompletableFuture类的功能和用例指南——作为Java 8…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">www.baeldung.com</p></div></div><div class="om l"><div class="ov l oo op oq om or js od"/></div></div></a></div></div></div>    
</body>
</html>