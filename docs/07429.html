<html>
<head>
<title>Using TypeORM and MySQL on a TypeScript API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript API上使用TypeORM和MySQL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/adding-and-using-a-database-on-a-typescript-api-with-typeorm-41c49336eff5?source=collection_archive---------1-----------------------#2021-02-17">https://levelup.gitconnected.com/adding-and-using-a-database-on-a-typescript-api-with-typeorm-41c49336eff5?source=collection_archive---------1-----------------------#2021-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d1a1396611ca5062c2b8654d5b4c2063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cnQIvlVMZYHQui9C"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">简·安东宁·科拉尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0ea4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，我们将把TypeORM添加到我们的API中，并使用它来创建一个保存产品信息的数据库。作为基础，我们将使用本教程中<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/creating-a-node-js-api-with-express-and-typescript-549fba5f5a33">的API。如果你愿意，你可以从这里</a>获得<a class="ae kc" href="https://github.com/phcarvalho/medium-posts/tree/main/01-base_api_with_ts" rel="noopener ugc nofollow" target="_blank">源文件并立即开始。</a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="76dc" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">数据库设置</strong></h1><p id="646e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们要做的第一件事是建立一个数据库。如果你已经有一个数据库(即使它不是MySQL数据库)，你不能跳过这一部分。</p><p id="c60a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将使用Docker来加速这个过程。如果你还不知道docker，我建议你看一看。你可以按照这个页面安装:<a class="ae kc" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/get-docker/</a></p><p id="5954" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Docker使用包含工作操作系统的容器，该操作系统包含您需要的工具和程序。你可以使用一个“即插即用”的docker容器来代替自己安装和设置。对于本教程，我将使用MySQL容器。安装docker后，只需在终端中运行以下命令:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="deee" class="mu lj iq mq b gy mv mw l mx my">docker run --name database -e MYSQL_ROOT_PASSWORD=password -p 3306:3306 -d mysql:8</span></pre><p id="f3c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将创建一个MySQL分离的(<em class="mz"> -d </em>)容器，名为“<em class="mz">数据库”</em>，用户密码为<em class="mz">‘密码’</em>(<em class="mz">-e MySQL _ ROOT _ PASSWORD</em>)，容器的端口<em class="mz"> 3306 </em>映射到主机的<em class="mz"> 3306 </em>端口。如果你从未使用过docker，这将是一个很大的信息量。这里需要记住的主要内容是您使用的名称和密码。</p><p id="cdb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在终端使用'<em class="mz"> docker ps </em>'检查集装箱是否正在运行。如果什么都没有显示(也许你重启了你的电脑)，使用'<em class="mz"> docker ps -a </em>'来显示所有的容器(包括那些没有启动的)。要启动和停止容器，只需使用'<em class="mz"> docker启动数据库</em>和'<em class="mz"> docker停止数据库</em>'。总结一下:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4a1c" class="mu lj iq mq b gy mv mw l mx my"># List all running containers<br/>docker ps</span><span id="2091" class="mu lj iq mq b gy na mw l mx my"># List all containers<br/>docker ps -a</span><span id="b60e" class="mu lj iq mq b gy na mw l mx my"># Start a container<br/>docker start &lt;name&gt;</span><span id="3b1b" class="mu lj iq mq b gy na mw l mx my"># Stop a container<br/>docker stop &lt;name&gt;</span></pre><p id="2f29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要做的最后一件事是在MySQL数据库中创建模式。为此，我将使用MySQL Workbench，并使用以下设置连接到容器上运行的实例:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="fdda" class="mu lj iq mq b gy mv mw l mx my">Hostname: 127.0.0.1<br/>Port: 3306<br/>Username: root<br/>Password: &lt;password&gt;<br/>Default Schema: &lt;blank&gt;</span></pre><p id="952b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接后，在Query选项卡上键入以下内容，然后单击闪电图标(或按CTRL + Enter)。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4cd6" class="mu lj iq mq b gy mv mw l mx my">CREATE SCHEMA `database_name` ;</span></pre><h1 id="c04c" class="li lj iq bd lk ll nb ln lo lp nc lr ls lt nd lv lw lx ne lz ma mb nf md me mf bi translated"><strong class="ak">配置类型表</strong></h1><p id="2f85" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">让我们从安装依赖项开始:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="98f0" class="mu lj iq mq b gy mv mw l mx my"># Install TypeORM and a required lib<br/>yarn add typeorm reflect-metadata</span><span id="c12d" class="mu lj iq mq b gy na mw l mx my"># Install the database driver<br/>yarn add mysql2</span><span id="3ba1" class="mu lj iq mq b gy na mw l mx my"># Install node types if you haven't already<br/>yarn add @types/node -D</span></pre><p id="ea4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要安装TypeORM并反射元数据(必需)。我们还必须安装数据库驱动程序。如果你正在使用另一个数据库(比如PostgreSQL)，你将不得不安装一个不同的驱动程序。我们还安装了节点类型以确保万无一失(我们应该已经安装了)。</p><p id="34b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要在'<em class="mz"> tsconfig.json </em>'文件的“<em class="mz"> compilerOptions </em>”中添加“<em class="mz">emitteormetadata</em>”和“<em class="mz">experimental decorator</em>”:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">tsconfig.json</figcaption></figure><p id="1888" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将创建一些文件夹和最后一个配置文件。在de<strong class="kf ir"><em class="mz">src</em></strong><em class="mz"/>文件夹内，添加一个<strong class="kf ir"> <em class="mz"> app </em> </strong>和一个<strong class="kf ir"> <em class="mz">数据库</em> </strong>文件夹。在<strong class="kf ir"> <em class="mz"> app </em> </strong>文件夹内添加一个<strong class="kf ir"> <em class="mz">实体</em> </strong> <em class="mz"> </em>文件夹，并在<strong class="kf ir"> <em class="mz">数据库</em> </strong>文件夹内添加一个<strong class="kf ir"> <em class="mz">迁移</em> </strong>文件夹。最后，在项目根上添加一个'<em class="mz"> ormconfig.json' </em>(这里有'<em class="mz"> tsconfig.json' </em>文件)。结构应该是这样的:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8991" class="mu lj iq mq b gy mv mw l mx my">&gt; Project Folder<br/>  &gt; node_modules<br/>  &gt; src<br/>    &gt; app<br/>      &gt; entities<br/>    &gt; database<br/>      &gt; migrations<br/>    - app.ts<br/>    - routes.ts<br/>    - server.ts<br/>  - ormconfig.json<br/>  - package.json<br/>  - tsconfig.json</span></pre><p id="017b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在打开'<em class="mz"> ormconfig.json' </em>文件并输入以下内容。不要忘记更改'<em class="mz">密码</em>和'<em class="mz">数据库</em>'(这是我们创建的模式):</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ormconfig.json</figcaption></figure><p id="87f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们只需在启动API时实例化我们的连接。让我们在'<em class="mz"> server.ts' </em>文件中进行更改:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">server.ts</figcaption></figure><h1 id="9e66" class="li lj iq bd lk ll nb ln lo lp nc lr ls lt nd lv lw lx ne lz ma mb nf md me mf bi translated"><strong class="ak">创建实体</strong></h1><p id="522a" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">既然我们的服务器和数据库已经启动并运行，我们只需要创建我们的实体。对于本教程，我将创建一个产品和一个产品类别表，如果它们之间存在一对多的关系。在<strong class="kf ir"> <em class="mz">实体</em> </strong>文件夹中创建'<em class="mz"> Product.ts </em>'和'<em class="mz"> ProductCategory.ts </em>'文件:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ProductCategory.ts</figcaption></figure><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">产品. ts</figcaption></figure><p id="7dd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们总是用<em class="mz">实体</em>装饰器创建我们的实体，并从<em class="mz"> BaseEntity </em>扩展它(这是可选的，但有了它会更容易)。我们将为id为<em class="mz">的</em>使用<em class="mz"> PrimaryGeneratedColumn </em>装饰器，并且每次创建列时，我们都将使用<em class="mz"> Column </em>装饰器并设置它的类型。我们还将为createdAt和updatedAt列使用<em class="mz"> CreateDateColumn </em>和<em class="mz"> UpdateDateColumn </em>装饰器。</p><p id="4680" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最难的部分(实际上并不难)是设置关系。我们将在产品实体上使用<em class="mz"> ManyToOne </em>装饰器(许多产品对应一个产品类别)，在产品类别实体上使用<em class="mz"> OneToMany </em>装饰器(一个产品类别对应许多产品)。我们还使用<em class="mz"> JoinColumn </em>装饰器(这是可选的，如果您不指定，TypeORM将为您处理它)指定我们将用于这个关系的列(在产品实体内部)。</p><h1 id="bf52" class="li lj iq bd lk ll nb ln lo lp nc lr ls lt nd lv lw lx ne lz ma mb nf md me mf bi translated">使用实体</h1><p id="083a" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">最后，我们将使用我们的实体来创建、读取、更新和删除(CRUD)。为此，我们需要创建控制器和API路径。每个控制器最多可以有五种功能。这不完全是一条法律，但这是让每个控制器只承担一项责任的好方法。例如:如果您需要另一个函数(除了<em class="mz"> store </em>之外)以不同的方式创建记录，也许您应该考虑为它创建另一个控制器。这五个功能是:</p><ul class=""><li id="5b1e" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated"><em class="mz">存储</em>:用于创建一条记录；</li><li id="0d20" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><em class="mz">索引</em>:用于返回一个表中的所有记录；</li><li id="9f75" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><em class="mz">显示</em>:用于返回指定的记录；</li><li id="55ec" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><em class="mz">更新</em>:用于更新指定的记录；</li><li id="152a" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><em class="mz">删除</em>:用于删除指定的记录。</li></ul><p id="bd9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每个实体，我们将创建一个具有五个API路由的控制器。让我们从控制器开始。在<strong class="kf ir"> <em class="mz"> app </em> </strong>文件夹中创建一个<strong class="kf ir"> <em class="mz"> controllers </em> </strong>文件夹，并添加“<em class="mz">productcategorycontroller . ts”</em>和“<em class="mz">product controller . ts”</em>文件:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">产品控制器. ts</figcaption></figure><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ProductCategoryController.ts</figcaption></figure><p id="229a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要做的最后一件事是编辑'<em class="mz"> routes.ts' </em>文件:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">routes.ts</figcaption></figure><p id="dd60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经创建了路由，现在让我们启动服务器并测试API。只需在您的终端上运行以下命令。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="96a1" class="mu lj iq mq b gy mv mw l mx my">yarn start:dev</span></pre><h1 id="7298" class="li lj iq bd lk ll nb ln lo lp nc lr ls lt nd lv lw lx ne lz ma mb nf md me mf bi translated">测试API</h1><p id="a0e2" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">为了测试我们的API，我将使用<a class="ae kc" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠症</a>，但是如果你愿意，你也可以使用Postman。不要忘记用一个现有的id号来改变'<em class="mz"> {id} </em>'。</p><p id="1457" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们有十条路线要测试。首先是产品类别路线:</p><ul class=""><li id="e068" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated">GET |<a class="ae kc" href="http://localhost:3333/product-categories" rel="noopener ugc nofollow" target="_blank">http://localhost:3333/product-categories</a>|无正文</li><li id="007a" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">POST |<a class="ae kc" href="http://localhost:3333/product-categories" rel="noopener ugc nofollow" target="_blank">http://localhost:3333/product-categories</a>| { name:string }</li><li id="f78e" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">GET |<a class="ae kc" href="http://localhost:3333/product-categories" rel="noopener ugc nofollow" target="_blank">http://localhost:3333/product-categories</a>/{ id } |无正文</li><li id="e87f" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">PUT |<a class="ae kc" href="http://localhost:3333/product-categories" rel="noopener ugc nofollow" target="_blank">http://localhost:3333/product-categories</a>/{ id } | { name:string }</li><li id="2804" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">DELETE |<a class="ae kc" href="http://localhost:3333/product-categories" rel="noopener ugc nofollow" target="_blank">http://localhost:3333/product-categories</a>/{ id } |无正文</li></ul><p id="5f4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及产品路线:</p><ul class=""><li id="27ef" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated">GET |<a class="ae kc" href="http://localhost:3333/product-categories" rel="noopener ugc nofollow" target="_blank">http://localhost:3333/products</a>|无正文</li><li id="ca8c" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">POST |<a class="ae kc" href="http://localhost:3333/product-categories" rel="noopener ugc nofollow" target="_blank">http://localhost:3333/products</a>| { name:string，price: number，productCategoryId: number }</li><li id="bf99" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">GET |<a class="ae kc" href="http://localhost:3333/product-categories" rel="noopener ugc nofollow" target="_blank">http://localhost:3333/product</a>s/{ id } |无正文</li><li id="d4c0" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">PUT |<a class="ae kc" href="http://localhost:3333/product-categories" rel="noopener ugc nofollow" target="_blank">http://localhost:3333/products</a>/{ id } | { name:string，price: number，productCategoryId: number }</li><li id="caaa" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">DELETE |<a class="ae kc" href="http://localhost:3333/product-categories" rel="noopener ugc nofollow" target="_blank">http://localhost:3333/products</a>/{ id } |无正文</li></ul><div class="ml mm mn mo gt ab cb"><figure class="nw jr nx ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/0abbc341928764658bf145859ba295b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*89GM4anvgZLjuD5JRGCUWw.png"/></div></figure><figure class="nw jr nx ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/378f1134b3d89eeeabd2f89e39467e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*GVI-ka3XC5rFVcrjSXmgJA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk oc di od oe translated">API调用的一些例子</figcaption></figure></div></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="b80c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样，我们用TypeORM让我们的API读写我们的数据库。如果你有任何问题或者只是想比较所有的项目文件，你可以在这里查看。</p></div></div>    
</body>
</html>