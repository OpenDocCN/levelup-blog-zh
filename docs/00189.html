<html>
<head>
<title>A comparison of lazy loading components in Angular and React applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular和React应用中延迟加载组件的比较</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lazy-loading-components-in-angular-and-react-applications-3f7f251c9277?source=collection_archive---------0-----------------------#2018-08-11">https://levelup.gitconnected.com/lazy-loading-components-in-angular-and-react-applications-3f7f251c9277?source=collection_archive---------0-----------------------#2018-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e4f6e6477de10ce74acb0d8ab3a63e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*iGn_VOrzxH_qWGlmYes7nw.png"/></div></figure><p id="d3e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我们将讨论延迟加载是如何工作的，以及在Angular和React应用程序中的区别。我们不会讨论Angular或React的各种特性，也不会讨论使用这些技术构建应用程序所需的设置。</p><p id="a1ed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，我们将非常快速地引导应用程序(使用它们各自的CLI ),然后转移到症结——延迟加载。这不是一篇Angular vs React的文章，这只是一个简单的比较，如何使用两种框架实现相同的结果(延迟加载组件)。</p><h2 id="7fae" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">什么是懒装？</h2><p id="adc3" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">惰性加载是一种仅在必要时加载额外负载的技术。惰性加载最简单的类比就是只有当用户点击<code class="fe lq lr ls lt b">signup</code>按钮时才加载与<code class="fe lq lr ls lt b">signup</code>相关的JS、CSS和HTML。毕竟，与<code class="fe lq lr ls lt b">login</code>或<code class="fe lq lr ls lt b">home</code>页面相比，它是大多数应用程序中使用相对较少的部分。使初始页面加载更快，并对应用程序的结构和层次结构进行整体改进。我们可以将应用程序分成逻辑块，这些逻辑块可以按需加载。</p><h2 id="8d60" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">我们将建造什么</h2><p id="7eaf" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">为了简单起见，我们将建立一个简单网站的一部分，它有一个<code class="fe lq lr ls lt b">home</code>页面，然后两个懒惰加载的兄弟路线— <code class="fe lq lr ls lt b">about</code>和<code class="fe lq lr ls lt b">settings</code>。我们将在用户导航中加载<code class="fe lq lr ls lt b">about</code>和<code class="fe lq lr ls lt b">settings</code>页面。在<code class="fe lq lr ls lt b">settings</code>视图中，我们将基于用户交互进一步加载惰性加载子组件，在本例中，是一个按钮点击。这里的目标是看看这两个框架如何让我们达到相同的结果。</p><h1 id="b546" class="lu kt iq bd ku lv lw lx kx ly lz ma la mb mc md ld me mf mg lg mh mi mj lj mk bi translated">倾斜惰性负载</h1><p id="e17e" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">假设您已经安装了<code class="fe lq lr ls lt b">angular-cli</code>，设置项目和一些组件应该轻而易举。遵循以下命令:</p><pre class="ml mm mn mo gt mp lt mq mr aw ms bi"><span id="5a33" class="ks kt iq lt b gy mt mu l mv mw">ng new angular-lazy-loaded</span><span id="5bf2" class="ks kt iq lt b gy mx mu l mv mw">cd angular-lazy-loaded</span><span id="536c" class="ks kt iq lt b gy mx mu l mv mw">ng generate module about --routing</span><span id="3cc3" class="ks kt iq lt b gy mx mu l mv mw">ng generate module settings --routing</span><span id="60d3" class="ks kt iq lt b gy mx mu l mv mw">ng generate component home</span><span id="5cf2" class="ks kt iq lt b gy mx mu l mv mw">ng generate component about/main</span><span id="122d" class="ks kt iq lt b gy mx mu l mv mw">ng generate component settings/main</span></pre><p id="4326" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就建立了我们将要使用的三条基本路线。根据上述命令，<code class="fe lq lr ls lt b">home</code>组件不必是一个附加了路由配置的模块，这与<code class="fe lq lr ls lt b">about</code>和<code class="fe lq lr ls lt b">settings</code>模块不同。我们将在应用程序加载时加载<code class="fe lq lr ls lt b">home</code>组件，为此，我们可以设置整个应用程序路由，如下所示。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="aa9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于基于基本路由的延迟加载，我们可以简单地用我们为<code class="fe lq lr ls lt b">about</code>和<code class="fe lq lr ls lt b">settings</code>路由创建的模块来定义路由。当应用程序加载默认路径时，默认加载<code class="fe lq lr ls lt b">HomeComponent</code>。</p><p id="9e9d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一件需要注意的事情是，我们在<code class="fe lq lr ls lt b">settings</code>和<code class="fe lq lr ls lt b">about</code>路线中都添加了一个<code class="fe lq lr ls lt b">main</code>组件。让我们将<code class="fe lq lr ls lt b">main</code>组件包含到这两个模块中，这样当用户导航到这些路径中的任何一个时，它们都会被默认加载。为了保持文章简洁，省略了一些代码，但是请参考<a class="ae na" href="https://github.com/40x/angular-lazy-loading" rel="noopener ugc nofollow" target="_blank">完整代码库</a>以供参考。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3fbb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们使用cli启动应用程序并向模板添加一些基本样式来加载应用程序时，我们会看到惰性加载路线的输出，如下所示:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/6a46d6e1a58b4947a63a10b9cf6df348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*L24-pfKsBIJhcK-fCWNk2Q.gif"/></div></div></figure><p id="e358" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">页面最初加载时会加载<code class="fe lq lr ls lt b">main</code>和<code class="fe lq lr ls lt b">vendor</code> javascript文件(并呈现<code class="fe lq lr ls lt b">HomeComponent</code>)。只有当用户试图导航到这些路线时，<code class="fe lq lr ls lt b">about</code>和<code class="fe lq lr ls lt b">settings</code>模块(以及它们的<code class="fe lq lr ls lt b">MainComponents</code>)才会被请求和呈现。</p><blockquote class="ng nh ni"><p id="5105" class="ju jv nj jw b jx jy jz ka kb kc kd ke nk kg kh ki nl kk kl km nm ko kp kq kr ij bi translated">我们在上面看到的有效载荷比预期的要大，因为它不是生产版本。我们将在以后的生产版本中测试相同的功能。</p></blockquote><p id="1516" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">到目前为止，我们已经通过route按需加载组件，现在让我们尝试通过其他用户交互在预渲染的route上延迟加载组件。举例来说，我们将通过点击<code class="fe lq lr ls lt b">settings</code>页面中的<code class="fe lq lr ls lt b">edit</code>按钮来编辑用户配置文件。页面<code class="fe lq lr ls lt b">settings</code>已经被延迟加载，我们现在在用户点击<code class="fe lq lr ls lt b">edit</code>按钮时延迟加载页面的另一部分。</p><p id="f1e6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是事情变得有点混乱的地方。在Angular中，应用程序层次结构的主要焦点是模块，而不是组件。如果模块(包括组件、服务、管道等)被直接或间接地通过依赖树导入到主模块中，它们将被打包到主包中。如果没有，这些模块将被捆绑成块，并作为延迟加载的模块提供。</p><p id="a0af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了能够延迟加载一个组件，我们必须把它捆绑成一个模块，当有请求时，这个模块就会被分块和加载。没有其他方法可以在不依赖于路由和模块的情况下延迟加载角度组件。要设置所讨论的必要组件，请运行以下命令:</p><pre class="ml mm mn mo gt mp lt mq mr aw ms bi"><span id="c5e0" class="ks kt iq lt b gy mt mu l mv mw">ng generate module settings/main/edit-profile --routing</span><span id="8ecb" class="ks kt iq lt b gy mx mu l mv mw">ng generate component settings/main/edit-profile/edit</span></pre><p id="bff0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些命令将为<code class="fe lq lr ls lt b">settings</code>页面的<code class="fe lq lr ls lt b">edit</code>部分设置必要的子模块(我们将路由到该子模块)和组件。</p><p id="aa4e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要加载这些更改，我们必须用惰性加载子组件设置我们的<code class="fe lq lr ls lt b">settings</code>路由，如下所示:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8ba9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一切都像预期的那样，我们添加了新的<code class="fe lq lr ls lt b">outlet</code>属性，指示我们希望组件呈现的位置(在设置html页面内),以及<code class="fe lq lr ls lt b">loadChildren</code>属性，指示它将被延迟加载。不幸的是，由于angular中的一个错误，命名路由器出口的父级不能是<code class="fe lq lr ls lt b">‘’</code>，因此，我们在它们之间引入了一个临时路由，当加载父路由时，该临时路由将重定向到我们的<code class="fe lq lr ls lt b">MainComponent</code>。加载这个惰性组件的<code class="fe lq lr ls lt b">settings</code>模板的相应变化如下:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c81b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样，我们就可以开始摇滚了。让我们再次运行应用程序，并尝试在路线之间导航。结果将类似于您在下面看到的。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nn"><img src="../Images/e418d2df66d70c1f1ff12af60ac9c591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dQJAu7_cAp7CJK2_vX3jvw.gif"/></div></div></figure><p id="97c8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">延迟加载增加了发送给服务器的加载必要文件的请求的数量。这意味着，如果任何延迟加载请求耗时太长、失败或被拒绝，将由我们来通知用户。如果能够处理这些情况，并在请求需要很长时间才能解决时显示一个加载指示器，那就更好了。</p><p id="4f8a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Angular中有几种方法可以实现这一点，但是最简单的方法是将惰性加载路由事件与某种加载指示器联系起来。Angular提供了<code class="fe lq lr ls lt b">RouteConfigLoadStart</code>和<code class="fe lq lr ls lt b">RouteConfigLoadEnd</code>事件，当惰性加载路线开始加载和结束加载时，这些事件被专门触发。我们可以使用这些事件，并在发出请求的<code class="fe lq lr ls lt b">settings</code>模块的<code class="fe lq lr ls lt b">main</code>组件上设置一个监听器，如下所示:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9d24" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">和模板:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0121" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当服务器重新运行时，这将按预期运行</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi no"><img src="../Images/9177cea9e676666ca293a80736c357f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OC42Dd33O_2GzhRq-Nntbw.gif"/></div></div></figure><p id="1bd5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，当有多个懒惰加载的组件时，问题就出现了。我们必须在我们的<code class="fe lq lr ls lt b">subscribe</code>方法中添加对<code class="fe lq lr ls lt b">event</code>的进一步检查，以确定哪个请求正在进行，并显示相应的加载消息/指示器。</p><h2 id="50e1" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">分析</h2><p id="cc57" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">虽然它像预期的那样工作，但你可能会有点困惑，这是公平的。Angular并没有让理解如何延迟加载组件变得特别容易。一切都与模块和我们通过路由延迟加载模块的能力联系在一起。bugs变通方法的存在也不理想。</p><p id="929f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们的更改已经完成，让我们压缩构建并再次测试这些更改，以分析有效负载的大小。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/7294a83d09a83bc8d60ab2eda50e0ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*H7J6lkrzJGI3MZn6M76VZg.png"/></div></figure><p id="3703" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是我们最终捆绑的应用程序加载的内容。最后三块是我们的延迟加载模块。请注意，它们都是相当精简的代码——每个都只包含几条语句。我们大部分的代码修改都是围绕着设置必要的路由。</p><p id="9ab1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还有其他方面的比较，如服务器端渲染，但我们将在以后的文章中处理。</p><p id="184b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae na" href="https://github.com/40x/angular-lazy-loading" rel="noopener ugc nofollow" target="_blank">角度延迟加载的完整代码库</a>。</p><h1 id="ec32" class="lu kt iq bd ku lv lw lx kx ly lz ma la mb mc md ld me mf mg lg mh mi mj lj mk bi translated">对延迟加载做出反应</h1><p id="8611" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">在进入react应用程序的惰性加载之前，让我们使用<code class="fe lq lr ls lt b">create-react-app</code>快速启动一个新的React应用程序。因为React只处理应用程序的视图部分，所以我们需要添加额外的依赖项来处理应用程序的其他部分。我们将使用<code class="fe lq lr ls lt b">react-router</code>和<code class="fe lq lr ls lt b">react-loadable</code>来加载我们的路由并启用延迟加载，所以让我们安装它们。</p><pre class="ml mm mn mo gt mp lt mq mr aw ms bi"><span id="1b31" class="ks kt iq lt b gy mt mu l mv mw">npm i -S react-loadable react-router react-router-dom</span></pre><p id="3338" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将遵循与上面相同的例子，我们的应用程序由3条路线组成，<code class="fe lq lr ls lt b">home</code>、<code class="fe lq lr ls lt b">about</code>和<code class="fe lq lr ls lt b">settings</code>。<code class="fe lq lr ls lt b">Home</code>应用程序加载时加载到默认路径。<code class="fe lq lr ls lt b">About</code>和<code class="fe lq lr ls lt b">settings</code>路线是懒装的。在<code class="fe lq lr ls lt b">settings</code>中，我们将进一步在点击按钮时为用户配置文件的<code class="fe lq lr ls lt b">edit</code>惰性加载组件。</p><p id="248c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们所有组件的初始版本都非常简洁明了，类似于下面所示的组件:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d51d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在将使用路由器加载页面导航组件。让我们在主<code class="fe lq lr ls lt b">app.jsx</code>中设置路由器，以方便路由，如下所示:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d782" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们运行应用程序时，一切都按预期运行。我们可以单击链接并导航到各自的视图。</p><p id="6f0c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来是重要的一步——设置延迟加载。在本例中，我们使用的是<code class="fe lq lr ls lt b">react-loadable</code>。这是一个令人惊叹的库，具有广泛的开箱即用特性。事实上，下面是他们的自述文件中的<a class="ae na" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank">图片，展示了他们关于惰性加载应该如何工作的建议。</a></p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nq"><img src="../Images/020bb96ebce3dc1dddad9353ba6185f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ds7SEAHT1RbIdPVeAuQWmw.png"/></div></div></figure><p id="8feb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从上面的图片中可以清楚地看到，<code class="fe lq lr ls lt b">react-loadable</code>希望让我们能够按照功能组件而不是基于某个特定的路线来划分块。让我们首先使用<code class="fe lq lr ls lt b">react-loadable</code>启用基于路由的延迟加载，然后在我们的设置页面中添加更多的逻辑来延迟加载<code class="fe lq lr ls lt b">edit</code>组件。</p><p id="a56c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe lq lr ls lt b">React-loadable</code>内部是对<code class="fe lq lr ls lt b">webpack</code>功能的扩展，增加了语法成分，这样我们就不需要担心所有的边缘情况和样板代码。</p><p id="b661" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">代码更改相对容易且易于理解。只需在当前组件旁边添加一个<code class="fe lq lr ls lt b">index.jsx</code>文件，并根据需要使用<code class="fe lq lr ls lt b">react-loadable</code>到<code class="fe lq lr ls lt b">import</code>即可。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="dce9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们可以调用这个<code class="fe lq lr ls lt b">LazySettings</code>组件而不是常规的<code class="fe lq lr ls lt b">Settings</code>组件来启用延迟加载。结果是我们的惰性加载组件被加载到路线导航上。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nr"><img src="../Images/72d89031360d27c03594e624c218ab61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BLoCVZZqewF30x4W6l3zdw.gif"/></div></div></figure><p id="2e1f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们将把<code class="fe lq lr ls lt b">button</code>添加到<code class="fe lq lr ls lt b">settings</code>页面，该页面将把子组件加载到<code class="fe lq lr ls lt b">edit</code>用户配置文件。为此，我们需要将我们的<code class="fe lq lr ls lt b">settings</code>组件更新为有状态组件，它可以加载我们尚未创建的<code class="fe lq lr ls lt b">LazyEditProfile</code>组件。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b433" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并且<code class="fe lq lr ls lt b">LazyEditProfile</code>组件类似于所有其他延迟加载的组件:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e8b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了简洁起见，省略了一些代码。完整实现请参考<a class="ae na" href="https://github.com/40x/react-lazy-loading" rel="noopener ugc nofollow" target="_blank">完整代码库</a>。</p><p id="5fa4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">预期的结果是延迟加载组件。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ns"><img src="../Images/f2db947e0d86f516fd55162f47dbf6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UqlpE8vUavJ9tPsFDz7pBQ.gif"/></div></div></figure><h2 id="db70" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">分析</h2><p id="5017" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">与Angular相比，React的使用、安装和设置非常简单。该功能是以组件为中心的，它让您可以完全控制如何加载组件。</p><p id="634a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有效负载分析的生产构建向我们展示了以下块的有效负载大小:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/af35d2a168cae71bbd40b024f5aaf9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*da0gJTQkuXxHxRodPCFjWw.png"/></div></figure><h1 id="1bd6" class="lu kt iq bd ku lv lw lx kx ly lz ma la mb mc md ld me mf mg lg mh mi mj lj mk bi translated">结论</h1><p id="aeb3" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">在我个人看来，从开发人员的角度来看，React的延迟加载更加自然和简单。也许有进一步的优化和改变可以使整体开发更容易和更快，但就目前的情况来看，<code class="fe lq lr ls lt b">react-loadable</code>肯定有优势。</p><p id="d3f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完整的代码库:<a class="ae na" href="https://github.com/40x/react-lazy-loading" rel="noopener ugc nofollow" target="_blank"> react懒加载app </a>，<a class="ae na" href="https://github.com/40x/angular-lazy-loading" rel="noopener ugc nofollow" target="_blank"> angular懒加载app </a>。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="f163" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nj">如果你喜欢这个博客，一定要为它鼓掌，</em> <a class="ae na" href="https://medium.com/@kashyap.mukkamala" rel="noopener"> <em class="nj">阅读更多</em> </a> <em class="nj">或者关注我的</em><a class="ae na" href="https://www.linkedin.com/in/kashyap-mukkamala/" rel="noopener ugc nofollow" target="_blank"><em class="nj">LinkedIn</em></a><em class="nj">。</em></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><figure class="ml mm mn mo gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nq"><img src="../Images/d9fe9ae1a34de6a28338eae427dd6438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8lHUzxrIT5VDhu7fUS6gg.png"/></div></a></figure><div class="ob oc gp gr od oe"><a href="https://gitconnected.com/learn/angular" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">学习角度-最佳角度教程(2019) | gitconnected</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">47大角度教程。课程由开发人员提交并投票，使您能够找到最佳角度…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">gitconnected.com</p></div></div><div class="on l"><div class="oo l op oq or on os js oe"/></div></div></a></div></div></div>    
</body>
</html>