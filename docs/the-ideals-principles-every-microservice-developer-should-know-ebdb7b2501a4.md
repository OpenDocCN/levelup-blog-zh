# 每个微服务开发者应该知道的理想原则

> 原文：<https://levelup.gitconnected.com/the-ideals-principles-every-microservice-developer-should-know-ebdb7b2501a4>

## 微服务架构

## 了解这六个设计原则，为您的微服务架构打下坚实的基础

![](img/afef5356b4c52d41e62070f7a77b33fa.png)

图片由[皮克斯拜](https://pixabay.com/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3537389)的 Gerd Altmann 提供

微服务在软件开发中被广泛采用。当务之急是要有一个设计原则列表，能够帮助开发者准确实现微服务架构。

类似于 SOLID 如何帮助面向对象编程有一个设计原则的参考列表，我们现在有 IDEALS 来支持开发者构建基于微服务的应用程序。

固体的一些原理也包含在理想中。但是 IDEALS 还结合了特定于基于微服务的架构的原则。

*   **I** 界面偏析
*   可部署性(取决于你)
*   **E** 排气驱动
*   **可用性超过一致性(最终一致性)**
*   **L** 松开联轴器
*   单一责任

清楚地了解各种模式和原则的用法和缺点，可以帮助您构建一个稳定且可维护的基于微服务的应用程序。让我们深入了解这些原则，以便更好地理解它们。

# 界面分离

微服务架构风格是优秀的面向服务架构(SOA)的技术发展。在 SOA 中，一个重要的因素是服务接口或契约的设计。

通常，SOA 建议定义一个单一的契约，让每个服务客户端都遵守它。契约最终会变得臃肿，因为它需要适应不同消费者的不同需求。因此，服务的效率和可维护性会随着时间的推移而降低。

接口分离原则建议每个微服务接口应该满足客户程序的特定需求。换句话说，客户不应该被迫依赖他们不使用的接口。

![](img/c877789ff741847fd937513ad87b9447.png)

用于接口隔离的后端对前端(BFF)模式

实现该原理的一种方式是通过 API 网关。网关有助于理解各种通信协议，根据需要翻译它们，修改请求和响应以适应服务和客户端程序等。

![](img/7c68134969772be741d8735ddfcbf21f.png)

用于接口隔离的 API 网关

# 可部署性(取决于您)

微服务架构成倍增加了应用程序的分布式特性。现在，团队拥有相对大量的模块，每个模块运行在由他们的云平台动态维护的几个节点上。

在这个高度分布式的环境中，部署不再是软件开发的必然结果。持续部署已经变得和生命周期中的任何其他阶段一样重要。

> 作为一项需求，可部署性不能再在“稍后”解决。——[亚采克·奇米尔](https://www.avenga.com/magazine/microservice-architecture/)

从开发环境到生产环境，组织都在集中精力实现整个部署流程的自动化。现在，开发团队的成功是以他们为业务部署高质量产品的速度和轻松程度来衡量的。

随着接近零的停机时间成为应用程序的事实标准，团队必须在应用程序设计阶段尽早规划他们的部署方法。

他们还应该确保在生产环境中围绕监控和流量管理制定可靠的计划。所有这些努力结合起来可以帮助团队在很大程度上维护他们的应用程序的可部署性。

[这里有一个关于可部署性的极好定义](https://www.infoq.com/articles/microservices-design-ideals/):

> 配置运行时基础设施，包括容器、pod、集群、持久性、安全性和网络。
> 
> 扩展微服务，或者将它们从一个运行时环境迁移到另一个运行时环境。
> 
> 加快提交+构建+测试+部署过程。
> 
> 最大限度地减少更换当前版本的停机时间。
> 
> 同步相关软件的版本变化。
> 
> 监控微服务的健康状况，以快速识别和修复故障。

# 事件驱动的

在事件驱动的架构中，应用程序之间的通信通常通过消息队列(Kafka Topics、RabbitMQ 等)进行。).源应用程序基于其域中以某种方式操纵数据的事件创建消息。

一个或多个应用程序(服务)被称为消费者，它们监听消息队列以获取有关事件的信息。消费者可以根据事件和消息数据自由决定他们的业务逻辑。

![](img/9b0b3d0ce71d8303ba29f4780a922c52.png)

事件驱动架构

使微服务容错的一个关键设计决策是避免由相关服务的宕机导致的级联故障。事件驱动的架构在这方面有所帮助，因为事件的生产者和消费者没有紧密耦合。

用于通信的消息传递通道保持两端独立，因此保持它们松散耦合。生产者不会等待消费者的响应。同时，消费者不会因为生产者不在而倒下。

总的来说，事件驱动架构有助于提高整个系统的可靠性、可伸缩性和吞吐量。

事件驱动的微服务确实有特定的挑战，开发人员需要注意以创建稳定的系统。由于通信的异步性质，需要额外的工作来关联为单个事件端到端执行的所有操作。

开发人员需要注意处理由于消息通道故障而丢失的消息。对于处理不同步消息、部分消息传递以及由于不可预见的情况而恢复数据状态，还需要额外的考虑。

# 可用性高于一致性

每个微服务设计都必须回答的一个问题是，是拥有正确的数据，还是现在就拥有数据。没有正确的答案。该策略取决于服务所处理的数据类型以及其可用性如何影响用户行为。

你可以在 Pat Helland 的文章“[为你的精神状态](https://queue.acm.org/detail.cfm?id=3236388)留意你的状态”中详细了解最终一致性的话题。

当今大多数电子商务应用程序都希望页面加载速度更快，即使它们可能没有准确的数据。研究表明，如果购物车、产品或评论加载速度不够快，用户就会离开网站。

> 在设计基于微服务的应用时，您需要决定可用性和一致性之间的优先级。

即使缺货，也可以向用户展示产品。用户可以将其添加到购物车中，结账时的第二次验证可以告知产品的可用性。这对于网站留住客户至关重要。

公司不希望用户在页面加载缓慢时转到另一个网站；因为应用程序打算验证库存和其他购物车中的存货，以给出准确的产品可用性状态。这意味着在这种情况下，数据的可用性比其准确性更重要。

与此同时，有些应用程序用于患者的医疗细节或用于核电厂，它们不具备最终的一致性。数据需要准确和一致，即使这意味着性能下降。

因此，在设计基于微服务的应用时，您需要决定可用性和一致性之间的优先级。

通过事件驱动架构的消息复制通常基于最终的一致性。由于队列积压或缓慢的处理消费者，可能会有延迟。但是数据最终会被客户端应用程序处理，并与源数据保持一致。

然而，对于需要始终如一的准确数据的应用程序来说，通过 API 直接从源系统读取是更好的选择。

# 松散耦合

通常，服务需要相互通信来完成整个工作流。因此，它们可以紧密耦合。紧密耦合的系统很难在不影响其他服务的情况下在一个服务中引入变化。

此外，在紧密耦合的服务中，当服务链中的一个服务发生故障时，有可能出现高爆炸半径。这使得整个系统的可靠性更难预测。

当涉及到服务接口时，建议尽可能保持它们与服务内部的松散耦合。保持接口契约独立于业务逻辑或技术将有助于团队随着时间的推移而发展，而不需要对服务的消费者端进行更改。

为了使服务松散耦合，您可以遵循发布者-订阅者模型。在这个模型中，源和消费者通过消息传递通道相互分离。因此，其中一个应用程序的宕机不会影响生态系统中的其他应用程序。

![](img/2c6f30184c4c229d9b625361920fbbb0.png)

松散耦合的发布者-订阅者模型

此外，只要消息格式和定义不变，当生产者的内部逻辑改变时，消费者不会受到影响。

API 网关也有助于保持服务的松散耦合。它提供了一个中间组件，可以处理服务提供者和他们的消费者之间所需的翻译。

![](img/a0828111991e25698b78d1803493c4a7.png)

用于松耦合的 API 网关

网关可以处理协议桥接、消息格式转换、路由等。，所以消费者和提供者不必拘泥于单一的定义。它还从消费者那里抽象出服务层的任何变化。这反过来有助于实体保持松散耦合。

在发布者-订阅者和 API 网关示例中，我们可以更改或添加新的实体(发布者/客户端应用程序、订阅者/服务)，而无需对生态系统中的其他实体进行任何更改。

# 单一责任

SOLID 中的单一责任原则提出了一个类的功能之间的高内聚。这个想法是让班级只负责一件事。SRP 的另一种定义方式是——一个类应该只有一个改变的理由。

> 当设计我们的类时，我们应该致力于把相关的特性放在一起，这样无论它们什么时候改变，它们都会因为同样的原因而改变。如果特性会因为不同的原因而改变，我们应该试着把它们分开。—史蒂夫·芬顿

反过来，这有助于编写易于理解的代码，这些代码具有高度的内聚性，并且更容易随着业务需求的变化而发展。

将 SOLID 的 SRP 扩展到微服务，你应该努力让你的微服务只提供一种功能。如果您计划将多个微服务打包到一个部署中，那么它们都应该关注一个具有相对相似的变更周期的工作领域。

![](img/743653ef5c5f40c03aeb771728ca269f.png)

微服务 SRP 的简化视图

同时，您可能不希望在过于细粒度的级别定义您的微服务。如果一个特性几乎一直需要其他特性一起改变，那么将它们分开会增加维护负担，而没有太大的好处。

> 如果变化真的发生了，变化轴才是变化轴。如果没有症状，应用 SRP 或任何其他原则都是不明智的。— [SRP:单一责任原则](https://docs.google.com/file/d/0ByOwmqah_nuGNHEtcU5OekdDMkk/edit?pli=1&resourcekey=0-AbuGpXQzwZcUGExkktKt0g)

因此，分布式应用程序已经比整体式应用程序需要更多的维护。对于团队来说，用过于细粒度的服务来限制相互依赖将是一个挑战，这将导致一场维护噩梦。

你可以阅读[这篇文章，了解如何准确定义你的微服务](/how-to-define-your-microservices-correctly-8437e7e6dd6b)。

# 最后的想法

上面讨论的每个设计原则都有其权衡，就像我们在软件开发中做出的任何设计决策一样。因此，不可盲目追随。

由于基于微服务的应用是一项不断发展的工作，您可以在设计决策中利用自己的经验、公司的需求和上述六项原则来帮助您创建一个健壮的微服务架构。

我想听听你在基于微服务的应用开发方面的经验。请在评论中分享你的反馈、建议或意见。

**参考文献**:

*   [https://www.infoq.com/articles/microservices-design-ideals/](https://www.infoq.com/articles/microservices-design-ideals/)
*   [https://www.avenga.com/magazine/microservice-architecture/](https://www.avenga.com/magazine/microservice-architecture/)

**感谢您阅读本文。您可能还想阅读:**

[](/top-7-signs-of-an-inexperienced-programmer-5fc3f04658f3) [## 缺乏经验的程序员的 7 大标志

### 了解这些迹象，这样你就不会在你的软件开发生涯中犯同样的错误

levelup.gitconnected.com](/top-7-signs-of-an-inexperienced-programmer-5fc3f04658f3) [](/10-ultimate-programming-jokes-by-the-programmers-for-the-programmers-4e24a3b701f2) [## 程序员给程序员的 10 个终极编程笑话

### 让你笑破肚皮的笑话，即使你不是程序员

levelup.gitconnected.com](/10-ultimate-programming-jokes-by-the-programmers-for-the-programmers-4e24a3b701f2) [](/5-most-effective-techniques-to-boost-your-knowledge-as-a-programmer-259780ed4a6) [## 作为一名程序员，提高你的知识的 5 个最有效的技巧

### 这些技术不需要你工作时间以外的太多时间

levelup.gitconnected.com](/5-most-effective-techniques-to-boost-your-knowledge-as-a-programmer-259780ed4a6)