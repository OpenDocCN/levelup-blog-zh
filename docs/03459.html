<html>
<head>
<title>Testing in Go — the basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋测试——基础</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-in-go-the-basics-5b0e0b690b9e?source=collection_archive---------11-----------------------#2020-05-10">https://levelup.gitconnected.com/testing-in-go-the-basics-5b0e0b690b9e?source=collection_archive---------11-----------------------#2020-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6d433f99096ea587ddf4f986010d3c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*diVPso4P9tAVnOU6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@roman_lazygeek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗马魔术师</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c198" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个博客是<a class="ae kc" href="https://medium.com/@abhishek1987/just-enough-go-blog-series-c1cd62b04beb" rel="noopener"><strong class="kf ir">Just full Go</strong>系列</a>的一部分，通过几个例子来介绍<code class="fe lb lc ld le b">Go</code>中的测试。它涵盖了测试的基础知识，然后是子测试、表驱动测试等主题。</p><blockquote class="lf lg lh"><p id="38d4" class="kd ke li kf b kg kh ki kj kk kl km kn lj kp kq kr lk kt ku kv ll kx ky kz la ij bi translated"><em class="iq">代码可在</em> <a class="ae kc" href="https://github.com/abhirockzz/just-enough-go" rel="noopener ugc nofollow" target="_blank"> <em class="iq">【刚够走】</em></a><em class="iq"/><code class="fe lb lc ld le b"><em class="iq">GitHub</em></code>上回购</p></blockquote><h1 id="22a5" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">概观</h1><p id="e988" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">对测试的支持以<code class="fe lb lc ld le b">testing</code>包的形式内置到Go中。至少，您需要:</p><ul class=""><li id="16a4" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">写点代码(需要测试的那个！)例如<code class="fe lb lc ld le b">hello.go</code></li><li id="bb1d" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">在以<code class="fe lb lc ld le b">_test.go</code>结尾的文件中编写测试，例如<code class="fe lb lc ld le b">hello_test.go</code></li><li id="a3ea" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">确保测试函数名称以<code class="fe lb lc ld le b">Test_</code>开头，例如<code class="fe lb lc ld le b">func TestHello</code></li><li id="9675" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">运行您的测试！</li></ul><p id="ba93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在编写测试时，您将大量使用<code class="fe lb lc ld le b"><a class="ae kc" href="https://golang.org/pkg/testing/#T" rel="noopener ugc nofollow" target="_blank">*testing.T</a></code>，其中<em class="li">“是传递给测试函数的类型，用于管理测试状态和支持格式化的测试日志。”</em>它包含几种方法，包括<code class="fe lb lc ld le b">Error</code>、<code class="fe lb lc ld le b">Fail</code>(变化)报告错误/故障、<code class="fe lb lc ld le b">Run</code>运行子测试、<code class="fe lb lc ld le b">Parallel</code>、<code class="fe lb lc ld le b">Skip</code>等。</p><p id="36ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">博客的其余部分使用一个简单的例子来演示上述一些概念。这是一个典型的hello world应用程序！</p><pre class="nd ne nf ng gt nh le ni nj aw nk bi"><span id="0f11" class="nl ln iq le b gy nm nn l no np">package main</span><span id="d8db" class="nl ln iq le b gy nq nn l no np">import "fmt"</span><span id="2545" class="nl ln iq le b gy nq nn l no np">func main() {<br/>    fmt.Println(greet(""))<br/>}</span><span id="f11a" class="nl ln iq le b gy nq nn l no np">func greet(who string) string {<br/>    if who == "" {<br/>        who = "there"<br/>    }<br/>    return fmt.Sprintf("hello, %s!", who)<br/>}</span></pre></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="1cba" class="lm ln iq bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">你好测试！</h1><p id="ac19" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">下面是对<code class="fe lb lc ld le b">greet</code>函数的基本单元测试:</p><pre class="nd ne nf ng gt nh le ni nj aw nk bi"><span id="7049" class="nl ln iq le b gy nm nn l no np">func TestGreet(t *testing.T) {<br/>    actual := greet("abhishek")<br/>    expected := "hello, abhishek!"<br/>    if actual != expected {<br/>        t.Errorf("expected %s, but was %s", expected, actual)<br/>    }<br/>}</span></pre><p id="5c91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目标是确认使用特定名称调用<code class="fe lb lc ld le b">greet</code>是否会导致<code class="fe lb lc ld le b">hello, &lt;name&gt;!</code>。我们调用<code class="fe lb lc ld le b">greet</code>函数，将结果存储在一个名为<code class="fe lb lc ld le b">actual</code>的变量中，并将其与<code class="fe lb lc ld le b">expected</code>值进行比较——如果它们不相等，<code class="fe lb lc ld le b">Errorf</code>用于记录一条消息，并将测试标记为失败。但是，测试函数本身会继续执行。如果您需要改变这种行为，使用<code class="fe lb lc ld le b">FailNow</code>(或<code class="fe lb lc ld le b">Fatal</code> / <code class="fe lb lc ld le b">Fatalf</code>)来终止当前的测试，并允许剩余的测试(如果有的话)执行。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="4eda" class="lm ln iq bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">子测试</h1><p id="ba01" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们已经讨论了明显的用例，但是还有另一个场景需要测试——当输入是空字符串时。让我们使用另一个测试来添加它:</p><pre class="nd ne nf ng gt nh le ni nj aw nk bi"><span id="7fed" class="nl ln iq le b gy nm nn l no np">func TestGreetBlank(t *testing.T) {<br/>    actual := greet("")<br/>    expected := "hello, there!"<br/>    if actual != expected {<br/>        t.Errorf("expected %s, but was %s", expected, actual)<br/>    }<br/>}</span></pre><p id="48c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种方法是使用<code class="fe lb lc ld le b">*testing.T</code>上的<code class="fe lb lc ld le b"><a class="ae kc" href="https://golang.org/pkg/testing/#T.Run" rel="noopener ugc nofollow" target="_blank">Run</a></code>方法来使用<code class="fe lb lc ld le b">sub-tests</code>。这种情况下会是这样的:</p><pre class="nd ne nf ng gt nh le ni nj aw nk bi"><span id="af97" class="nl ln iq le b gy nm nn l no np">func TestGreet2(t *testing.T) {<br/>    t.Run("test blank value", func(te *testing.T) {<br/>        actual := greet("")<br/>        expected := "hello, there!"<br/>        if actual != expected {<br/>            te.Errorf("expected %s, but was %s", expected, actual)<br/>        }<br/>    })</span><span id="cd88" class="nl ln iq le b gy nq nn l no np">    t.Run("test valid value", func(te *testing.T) {<br/>        actual := greet("abhishek")<br/>        expected := "hello, abhishek!"<br/>        if actual != expected {<br/>            te.Errorf("expected %s, but was %s", expected, actual)<br/>        }<br/>    })<br/>}</span></pre><p id="0f6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试逻辑保持不变。但是，现在我们已经涵盖了单个函数中的各个场景，每个场景都被表示为一个子测试— <code class="fe lb lc ld le b">test blank value</code>和<code class="fe lb lc ld le b">test valid value</code>。<code class="fe lb lc ld le b">Run</code>方法接受一个<code class="fe lb lc ld le b">name</code>和一个类似于顶层父测试用例/函数的测试函数。所有测试都按顺序运行，当子测试完成执行时，顶层测试被认为完成。</p><p id="b35a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做有什么好处？仅仅是不使用单独的函数吗？是的，但是使用子测试有更多的好处</p><ul class=""><li id="970a" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">与一个功能/方法/功能相关的所有案例都可以放在一个单一的测试功能中——这大大减少了认知负荷</li><li id="9143" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">显式命名使得发现故障变得更加容易——这就是esp。在大型测试套件中很有用</li><li id="d569" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">只需在子测试之前和之后编写(通用的)安装和拆卸代码</li><li id="6c3d" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">您有能力并行运行子测试(与父测试中的其他子测试一起)——稍后会详细介绍</li></ul></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="77e2" class="lm ln iq bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">表格驱动测试</h1><p id="4aab" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们的测试用例遵循相同的模板——我们所做的就是用一个参数调用<code class="fe lb lc ld le b">greet</code>,并将结果与<code class="fe lb lc ld le b">expected</code>的结果进行比较。两个子测试都有重复的代码。虽然，这是一个微不足道的例子，但这在现实世界的项目中也会发生。</p><p id="9e96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">table driven tests</code>在这种情况下可以派上用场。这一切都是为了在你的测试代码中找到可重复的模式，并设置<code class="fe lb lc ld le b">tables</code>来定义用例的不同组合——这极大地减少了测试代码的重复和大量的复制+粘贴工作！这些<code class="fe lb lc ld le b">tables</code>可以表现为一片结构，每个结构定义输入参数、预期输出、测试名称和任何其他相关细节。</p><p id="922b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我们如何设置<code class="fe lb lc ld le b">table driven tests</code>:</p><pre class="nd ne nf ng gt nh le ni nj aw nk bi"><span id="c314" class="nl ln iq le b gy nm nn l no np">func TestGreet3(t *testing.T) {<br/>    type testCase struct {<br/>        name             string<br/>        input            string<br/>        expectedGreeting string<br/>    }</span><span id="aa92" class="nl ln iq le b gy nq nn l no np">    testCases := []testCase{<br/>        {name: "test blank value", input: "", expectedGreeting: "hello, there!"},<br/>        {name: "test valid value", input: "abhishek", expectedGreeting: "hello, abhishek!"},<br/>    }</span><span id="8ee2" class="nl ln iq le b gy nq nn l no np">    for _, test := range testCases {<br/>        test := test<br/>        t.Run(test.name, func(te *testing.T) {<br/>            actual := greet(test.input)<br/>            expected := test.expectedGreeting<br/>            if actual != expected {<br/>                te.Errorf("expected %s, but was %s", expected, actual)<br/>            }<br/>        })<br/>    }<br/>}</span></pre><p id="a2ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们分解一下，以便更好地理解它。我们从定义<code class="fe lb lc ld le b">testCase</code>结构开始...</p><pre class="nd ne nf ng gt nh le ni nj aw nk bi"><span id="4afe" class="nl ln iq le b gy nm nn l no np">type testCase struct {<br/> name             string<br/> input            string<br/> expectedGreeting string<br/>}</span></pre><p id="183f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…随后是测试用例，这些测试用例是带有名称、输入和预期输出的<code class="fe lb lc ld le b">testCase</code>(<code class="fe lb lc ld le b">table</code>)片段:</p><pre class="nd ne nf ng gt nh le ni nj aw nk bi"><span id="b918" class="nl ln iq le b gy nm nn l no np">testCases := []testCase{<br/>        {name: "test blank value", input: "", expectedGreeting: "hello, there!"},<br/>        {name: "test valid value", input: "abhishek", expectedGreeting: "hello, abhishek!"},<br/>    }</span></pre><p id="b3ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们简单地执行每一个测试用例。注意名称、输入和输出是如何分别与<code class="fe lb lc ld le b">test.name</code>、<code class="fe lb lc ld le b">test.input</code>和<code class="fe lb lc ld le b">test.expectedGreeting</code>一起使用的</p><pre class="nd ne nf ng gt nh le ni nj aw nk bi"><span id="67a5" class="nl ln iq le b gy nm nn l no np">for _, test := range testCases {<br/>        test := test<br/>        t.Run(test.name, func(te *testing.T) {<br/>            actual := greet(test.input)<br/>            expected := test.expectedGreeting<br/>            if actual != expected {<br/>                te.Errorf("expected %s, but was %s", expected, actual)<br/>            }<br/>        })<br/>    }</span></pre></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="7e3e" class="lm ln iq bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">平行测试</h1><p id="ec88" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在大型测试套件中，我们可以通过并行运行每个子测试来提高效率。我们需要做的就是在<code class="fe lb lc ld le b">*testing.T</code>上使用<code class="fe lb lc ld le b">Parallel</code>方法来表明我们的意图。下面是我们如何并行化我们的两个测试用例:</p><blockquote class="lf lg lh"><p id="fe0c" class="kd ke li kf b kg kh ki kj kk kl km kn lj kp kq kr lk kt ku kv ll kx ky kz la ij bi translated"><em class="iq">注意对</em>的调用<code class="fe lb lc ld le b"><em class="iq">te.Parallel()</em></code></p></blockquote><pre class="nd ne nf ng gt nh le ni nj aw nk bi"><span id="a749" class="nl ln iq le b gy nm nn l no np">for _, test := range testCases {<br/>        test := test<br/>        t.Run(test.name, func(te *testing.T) {<br/>            <strong class="le ir">te.Parallel()</strong><br/>            time.Sleep(3 * time.Second)<br/>            actual := greet(test.input)<br/>            expected := test.expectedGreeting<br/>            if actual != expected {<br/>                te.Errorf("expected %s, but was %s", expected, actual)<br/>            }<br/>        })<br/>    }</span></pre><p id="9bfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们的测试很短，所以特意添加了<code class="fe lb lc ld le b">time.Sleep</code>来模拟耗时操作，作为测试的一部分。当您运行这个测试时，您会注意到测试执行的总时间稍微超过<code class="fe lb lc ld le b">3s</code>，尽管每个测试休眠了<code class="fe lb lc ld le b">3s</code>——这表明测试是并行运行的。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="0a5a" class="lm ln iq bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">其他主题</h1><p id="2645" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这里有一些其他有趣的话题，你应该探索，但没有涵盖在这篇文章中。</p><ul class=""><li id="b7a4" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated"><code class="fe lb lc ld le b">Benchmark</code>:在<code class="fe lb lc ld le b">*testing.B</code>类型的帮助下，<code class="fe lb lc ld le b">testing</code>包提供了运行基准的能力。就像正常的测试功能从<code class="fe lb lc ld le b">Test</code>开始一样，基准从<code class="fe lb lc ld le b">Benchmark</code>开始，可以使用<code class="fe lb lc ld le b">go test -bench</code>来执行。他们看起来像:<code class="fe lb lc ld le b">func BenchmarkGreet(b *testing.B)</code></li><li id="c17e" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated"><code class="fe lb lc ld le b">Skip</code>(及其变体):调用这个来跳过一个基准测试</li><li id="47f1" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated"><code class="fe lb lc ld le b"><a class="ae kc" href="https://golang.org/pkg/testing/#T.Cleanup" rel="noopener ugc nofollow" target="_blank">Cleanup</a></code>:测试和基准测试可以用这个来<em class="li">“注册一个函数，当测试及其所有子测试完成时调用这个函数”</em></li><li id="2594" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae kc" href="https://golang.org/pkg/testing/#hdr-Examples" rel="noopener ugc nofollow" target="_blank">测试中的例子</a>:你也可以包含代码作为例子，测试包也会验证它们。</li></ul><p id="6941" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就结束了<strong class="kf ir">Just full Go</strong>博客系列的又一部分——敬请期待更多。如果你觉得这很有用，别忘了点赞和订阅！</p></div></div>    
</body>
</html>