<html>
<head>
<title>Building a terminal dashboard in Golang in 300 lines of code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用300行代码在Golang中构建一个终端仪表板</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-terminal-dashboard-in-golang-in-300-lines-of-code-3b9f83f363a8?source=collection_archive---------2-----------------------#2020-03-03">https://levelup.gitconnected.com/building-a-terminal-dashboard-in-golang-in-300-lines-of-code-3b9f83f363a8?source=collection_archive---------2-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3375580176f09ddc676c59f8a728e889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGk97Us24maaOM_Rcay5_w.png"/></div></div></figure><p id="d26a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我喜欢CLI应用程序。它们是轻量级的、无依赖性的，并且消耗更少的资源。然而，从头开始为终端构建应用程序远非易事。</p><p id="95ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幸运的是，我们总是可以用工具或库来简化任务。在本教程中，我将向您展示如何利用一个强大的终端库<a class="ae kz" href="https://github.com/gizak/termui" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> termui </strong> </a>，用不到300行的Golang源代码构建一个基于终端的仪表板。</p><h1 id="4c18" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">背景</h1><p id="d0f5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们有一个每天服务数百万用户的web应用程序。我们希望监控这个应用程序的实时内存消耗(和GC)。</p><p id="c829" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能会想到一些像<a class="ae kz" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">Prometheus</a>+<a class="ae kz" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank">Grafana</a>这样的监控系统和可观测性平台，但是对于这种情况来说有点大材小用了。</p><p id="0e95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我决定在Golang建一个简单的。</p><h1 id="cdef" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">它是如何工作的</h1><p id="bdfd" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Golang内置了对内存统计的支持:<a class="ae kz" href="https://pkg.go.dev/runtime?tab=doc#MemStats" rel="noopener ugc nofollow" target="_blank">运行时。MemStats </a>。</p><p id="c475" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个对象可以通过HTTP在<code class="fe md me mf mg b">/debug/vars</code>以JSON格式公开。</p><p id="b897" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们所需要做的就是在我们的HTTP服务器中的<code class="fe md me mf mg b">import _ “expvar”</code>(更多细节请参考expvar 的<a class="ae kz" href="https://pkg.go.dev/expvar?tab=doc" rel="noopener ugc nofollow" target="_blank">官方文档)。</a></p><p id="ca24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我想监控的<code class="fe md me mf mg b">runtime.MemStats</code>的字段:</p><blockquote class="mh mi mj"><p id="d7b4" class="kb kc mk kd b ke kf kg kh ki kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ky im bi translated"><strong class="kd iu"> HeapObjects </strong>，是分配的堆对象的数量。</p><p id="80b3" class="kb kc mk kd b ke kf kg kh ki kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ky im bi translated"><strong class="kd iu"> Sys </strong>，是从操作系统获得的内存总字节数。</p><p id="869f" class="kb kc mk kd b ke kf kg kh ki kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ky im bi translated"><strong class="kd iu"> GCCPUFraction </strong>，是程序启动以来GC使用的该程序可用CPU时间的一部分。</p><p id="e79b" class="kb kc mk kd b ke kf kg kh ki kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ky im bi translated"><strong class="kd iu"> HeapAlloc </strong>，是分配的堆对象的字节数。</p><p id="d287" class="kb kc mk kd b ke kf kg kh ki kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ky im bi translated"><strong class="kd iu"> HeapInuse / HeapIdle </strong>，是使用中/空闲区间的字节数。</p><p id="05a3" class="kb kc mk kd b ke kf kg kh ki kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ky im bi translated">—摘自<a class="ae kz" href="https://pkg.go.dev/runtime?tab=doc#MemStats" rel="noopener ugc nofollow" target="_blank">golang官方文件</a></p></blockquote><p id="b0cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的计划是从web应用程序获取统计数据，并在终端仪表板中可视化它们。</p><p id="ff0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">UX的设计非常直观，每个领域都以恰当的方式呈现:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/7d05b0033fd8044f988c13be4a9442f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LubT3QNwW4xWiXMT-Zk6ZQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">仪表板模型</figcaption></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="d787" class="la lb it bd lc ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx bi translated">履行</h1><h2 id="7936" class="nj lb it bd lc nk nl dn lg nm nn dp lk km no np lo kq nq nr ls ku ns nt lw nu bi translated">数据加载器</h2><p id="e0aa" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">首先，我们需要定义一个加载统计数据的接口:</p><pre class="mp mq mr ms gt nv mg nw nx aw ny bi"><span id="6c5f" class="nj lb it mg b gy nz oa l ob oc">// MemStatsLoader is the interface to load memory statistics data<br/>type <strong class="mg iu">MemStatsLoader</strong> interface {<br/>   Load() (*runtime.MemStats, error)<br/>}</span></pre><p id="5eea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后实现这个接口，从目标服务器加载JSON数据并解析成一个<code class="fe md me mf mg b">runtime.MemStats</code>对象。</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3c00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过<code class="fe md me mf mg b">MemStatsLoader</code>的抽象，我们保持了添加更多数据源的能力。例如，我们可以添加一个新的实现，从JSON文件中读取统计数据。</p><h2 id="50a6" class="nj lb it bd lc nk nl dn lg nm nn dp lk km no np lo kq nq nr ls ku ns nt lw nu bi translated">用户界面</h2><p id="2a30" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">接下来，让我们定义一个<code class="fe md me mf mg b">Controller</code>接口，概念控制器是从<a class="ae kz" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> MVC </a>模式借用来的。它的职责是协调数据和视图协同工作，确保视图在数据改变后得到更新。</p><pre class="mp mq mr ms gt nv mg nw nx aw ny bi"><span id="891f" class="nj lb it mg b gy nz oa l ob oc">type <strong class="mg iu">Controller</strong> interface {<br/>   Render(*runtime.MemStats)<br/>   Resize()<br/>}</span></pre><p id="0582" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">方法<code class="fe md me mf mg b">Render</code>接受统计对象作为参数，然后更新窗口小部件，方法<code class="fe md me mf mg b">Resize</code>在终端窗口调整大小时被调用，确保所有窗口小部件的布局是正确的。</p><p id="5f52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们实现接口。下面是类定义:</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2162" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类<code class="fe md me mf mg b">controller</code>包含来自<strong class="kd iu"> termui </strong>的几个UI组件和保存最新数据系列的数据容器:</p><ul class=""><li id="91e5" class="of og it kd b ke kf ki kj km oh kq oi ku oj ky ok ol om on bi translated"><code class="fe md me mf mg b">Grid</code>是一个小部件容器，它呈现其中的所有小部件，并负责UI布局</li><li id="4604" class="of og it kd b ke oo ki op km oq kq or ku os ky ok ol om on bi translated">HeapObjectsData和HeapAllocBarChartData是存储统计数据系列的辅助类，因为有些小部件需要历史数据。</li><li id="8a4a" class="of og it kd b ke oo ki op km oq kq or ku os ky ok ol om on bi translated">其他字段是termui小部件，用于可视化不同的指标。</li></ul><p id="78f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建<code class="fe md me mf mg b">controller</code>的实例很容易:</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="8d5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意方法<code class="fe md me mf mg b">initUI</code> <strong class="kd iu">，</strong>它初始化小部件并把它们放到网格布局中:</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="94dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个方法中，我们给小部件添加固定标题，调整它们的颜色和填充，然后按照我们的UX设计初始化网格布局，将小部件放入网格单元。</p><p id="a4cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，这个类最重要的方法<code class="fe md me mf mg b">Render</code>:</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1f7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从<code class="fe md me mf mg b">data *runtime.MemStat</code>获取数据字段，如果有必要的话转换它们，然后将值分配给UI小部件。</p><p id="b79c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在赋值过程之后，我们调用<code class="fe md me mf mg b">ui.Render</code>来更新终端UI。</p><h2 id="fc92" class="nj lb it bd lc nk nl dn lg nm nn dp lk km no np lo kq nq nr ls ku ns nt lw nu bi translated">UI主循环</h2><p id="99e4" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">函数<code class="fe md me mf mg b">Run</code>负责初始化UI库，启动主循环，监听事件，触发每秒钟用新的统计数据更新UI:</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="07b8" class="nj lb it bd lc nk nl dn lg nm nn dp lk km no np lo kq nq nr ls ku ns nt lw nu bi translated">将所有代码放在一起</h2><p id="4fbc" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在<strong class="kd iu"> </strong> <code class="fe md me mf mg b"><strong class="kd iu">main.go</strong></code>中，我们简单地解析URL参数，构建<code class="fe md me mf mg b">pkg.MemStatsLoader</code>实例，并启动UI主循环:</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="209a" class="nj lb it bd lc nk nl dn lg nm nn dp lk km no np lo kq nq nr ls ku ns nt lw nu bi translated">跑起来</h2><p id="49db" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">到现在为止，所有的工作都完成了。让我们开始吧:</p><pre class="mp mq mr ms gt nv mg nw nx aw ny bi"><span id="17d2" class="nj lb it mg b gy nz oa l ob oc">go run main.go -url=http://xx_host/debug/vars</span></pre><p id="0c0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将看到一个实时仪表板，就像下面的快照一样，每秒都在刷新。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3375580176f09ddc676c59f8a728e889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGk97Us24maaOM_Rcay5_w.png"/></div></div></figure><p id="ccfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它将随着终端窗口的调整而调整大小(目前只有高度)。按任意键将退出应用程序。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="1477" class="la lb it bd lc ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx bi translated">结论</h1><p id="3ad0" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">有时，您可能需要构建一个简单的GUI应用程序，而没有严重的依赖性。</p><p id="3f7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">终端往往是一个不错的选择。如上所示，在<strong class="kd iu"> termui </strong>的帮助下，我们可以毫不费力地构建一个仪表板。我们只需要<strong class="kd iu">不到300行</strong>的代码就可以创建一个实时的仪表盘，这太不可思议了。</p><p id="074a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">练习:</strong>添加对来自JSON文件的统计数据的支持，而不涉及任何与UI相关的代码。</p><p id="e473" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关注我，喜欢这篇文章就留言回复。</p><h2 id="27d8" class="nj lb it bd lc nk nl dn lg nm nn dp lk km no np lo kq nq nr ls ku ns nt lw nu bi translated">资源:</h2><ul class=""><li id="c623" class="of og it kd b ke ly ki lz km ot kq ou ku ov ky ok ol om on bi translated">为了清楚起见，我没有把所有的代码都放到本教程中。如果你需要完整版本的代码，请查看<a class="ae kz" href="https://github.com/dche423/temi" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</li></ul></div></div>    
</body>
</html>