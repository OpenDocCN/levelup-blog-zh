<html>
<head>
<title>How to master grid layout in iOS with SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用SwiftUI掌握iOS中的网格布局</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-master-grid-layout-in-ios-with-swiftui-8a9de16ec7ca?source=collection_archive---------3-----------------------#2021-07-01">https://levelup.gitconnected.com/how-to-master-grid-layout-in-ios-with-swiftui-8a9de16ec7ca?source=collection_archive---------3-----------------------#2021-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5309" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">网格布局使我们能够在垂直或水平扩展的网格中显示视图。例如，我们都在iOS照片应用程序中看到过它。那些使用过UIKit的人可能会认为它是<a class="ae ko" href="https://developer.apple.com/documentation/uikit/uicollectionview" rel="noopener ugc nofollow" target="_blank"> UICollectionView </a>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/5a72edc33cd748af4d7fbd157074b785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OsbYLIlouJDIM_wqmlJuUw.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">Michael Dziedzic 在<a class="ae ko" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</figcaption></figure><p id="2d0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SwiftUI提供了两个优秀的选项— <code class="fe lf lg lh li b">LazyVGrid</code>和<code class="fe lf lg lh li b">LazyHGrid</code>。这一次，我们将更深入地了解如何使用这些组件。这两个组件的伟大之处在于它们的用法；视图是延迟加载的，这意味着当这些视图出现在屏幕上时。</p><p id="7f2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想指出的是，<code class="fe lf lg lh li b">HStack</code>和<code class="fe lf lg lh li b">VStack</code>从iOS 14开始就有了。如果你打算在iOS 13中使用网格布局，你应该看看<code class="fe lf lg lh li b">HStack</code>和<code class="fe lf lg lh li b">VStack</code>，但缺点是那些不支持延迟加载。</p><h1 id="4b33" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">创建网格布局</h1><p id="4dd5" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">创建网格布局包括三个步骤——显示数据集、配置网格系统和初始化网格布局本身。我们将研究最后两个。如何提供数据是一个广泛的话题，超出了本文的范围。</p><p id="5247" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过提供列、项目的对齐、项目之间的间距、页脚或页眉的固定视图以及内容本身来完成<code class="fe lf lg lh li b">LazyVGrid</code>的初始化。</p><pre class="kq kr ks kt gt mm li mn mo aw mp bi"><span id="0d54" class="mq lk it li b gy mr ms l mt mu">var columns = [<br/>  GridItem(.flexible()),<br/>  GridItem(.flexible()),<br/>  GridItem(.flexible()),<br/>  GridItem(.flexible())<br/>]</span><span id="3288" class="mq lk it li b gy mv ms l mt mu">var body: some View {<br/>  ScrollView {<br/>    LazyVGrid(columns: columns, spacing: 20, pinnedViews: .sectionHeaders) {<br/>      Section(header: Text("Smilies").font(.title),<br/>              footer: Text("Emoji smilies").font(.subheadline)) {<br/>        ForEach(Emoji.smilies, id: \.self) { emoji in<br/>          Text(emoji)<br/>            .font(.largeTitle)<br/>        }<br/>      }<br/>      <br/>      Section(header: Text("Animals").font(.title),<br/>              footer: Text("Emoji animals").font(.subheadline)) {<br/>        ForEach(Emoji.animals, id: \.self) { emoji in<br/>          Text(emoji)<br/>            .font(.largeTitle)<br/>        }<br/>      }<br/>      <br/>      Section(header: Text("Food").font(.title),<br/>              footer: Text("Emoji food").font(.subheadline)) {<br/>        ForEach(Emoji.food, id: \.self) { emoji in<br/>          Text(emoji)<br/>            .font(.largeTitle)<br/>        }<br/>      }<br/>      <br/>    }<br/>    .padding(.horizontal)<br/>  }<br/>}</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mw"><img src="../Images/08f00dd63d807c43fac51c499a8da2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/0*qk2SsVdC10ojqyor.png"/></div></div></figure><p id="ad44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用了<code class="fe lf lg lh li b">LazyHGrid</code>，还挺像的。我们只需要将<code class="fe lf lg lh li b">columns</code>参数交换到`行。</p><h1 id="c0e7" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">配置网格布局</h1><p id="e089" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">在初始化网格布局时，指定它的外观是非常重要的——垂直样式和水平样式网格布局的行。</p><p id="f21b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SwiftUI有一个描述单个网格项目的组件，<code class="fe lf lg lh li b">GridItem</code>。网格项目可以是行或列。</p><p id="6372" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">初始化<code class="fe lf lg lh li b">GridItem,</code>时，这三个参数至关重要:</p><ul class=""><li id="041c" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated"><code class="fe lf lg lh li b">size</code> -项目的大小；</li><li id="6335" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated"><code class="fe lf lg lh li b">spacing</code> -项目之间的间距；</li><li id="5d61" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated"><code class="fe lf lg lh li b">alignment</code> -放置每个网格项目时的对齐。</li></ul><h1 id="6616" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">网格项目大小</h1><p id="fd8a" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我们有三个选项来指定网格项的大小:</p><ul class=""><li id="c608" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated"><code class="fe lf lg lh li b">flexible(minimum: CGFloat, maximum: CGFloat)</code> -可用空间中的单个灵活项目，具有最小和最大尺寸的可选参数；</li><li id="f9b9" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated"><code class="fe lf lg lh li b">adaptive(minimum: CGFloat, maximum: CGFloat)</code> -可用空间中的多个项目；</li><li id="29a0" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated"><code class="fe lf lg lh li b">fixed(CGFloat)</code> -可用空间中固定大小的单品。</li></ul><p id="c75d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看<code class="fe lf lg lh li b">LazyVGrid</code>和<code class="fe lf lg lh li b">LazyHGrid</code>在实践中是如何工作的。</p><h2 id="da82" class="mq lk it bd ll nl nm dn lp nn no dp lt kb np nq lx kf nr ns mb kj nt nu mf nv bi translated">灵活的</h2><p id="1a3a" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">通过灵活的网格项目大小，我们可以提供最小和最大值，但即使没有它也能很好地工作。项目大小的计算方法是用可用空间除以项目数。</p><pre class="kq kr ks kt gt mm li mn mo aw mp bi"><span id="4e03" class="mq lk it li b gy mr ms l mt mu">[<br/>  GridItem(.flexible()),<br/>  GridItem(.flexible()),<br/>  GridItem(.flexible()),<br/>  GridItem(.flexible())<br/>]</span></pre><p id="593a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">垂直的</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/f4e8779f3a54deb134ed4cb6c50f7d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/0*Q0kU0aEKUWhh-Gvc.png"/></div></figure><p id="85e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">水平的</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/ad3a86e986fc632350d301237dee5d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/0*RxNl2hqEDNE149pt.png"/></div></figure><h2 id="6c75" class="mq lk it bd ll nl nm dn lp nn no dp lt kb np nq lx kf nr ns mb kj nt nu mf nv bi translated">适应的</h2><p id="93dc" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">自适应网格布局大小是最合适的“GridItem”大小。我们需要提供最小和可选的最大尺寸，SwiftUI布局指南将把所有繁重的工作从我们身边带走。</p><pre class="kq kr ks kt gt mm li mn mo aw mp bi"><span id="e3c7" class="mq lk it li b gy mr ms l mt mu">[<br/>  GridItem(.adaptive(minimum: 50))<br/>]</span></pre><p id="577c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">垂直的</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ny"><img src="../Images/28781dd19856fe06034b00dce4652d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/0*Vp6L1hyO_RKUfUbL.png"/></div></div></figure><p id="b241" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">水平的</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/cfcec3cfcd13bb0ff4b17d1198254f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/0*fSmn3bVaKMagvL5h.png"/></div></figure><h2 id="01ac" class="mq lk it bd ll nl nm dn lp nn no dp lt kb np nq lx kf nr ns mb kj nt nu mf nv bi translated">固定的；不变的</h2><p id="d3ee" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">固定的<code class="fe lf lg lh li b">GridItem</code>布局尺寸是在我们知道项目尺寸时使用的，它是不变的。</p><pre class="kq kr ks kt gt mm li mn mo aw mp bi"><span id="033e" class="mq lk it li b gy mr ms l mt mu">[<br/>  GridItem(.fixed(100)),<br/>  GridItem(.fixed(100)),<br/>  GridItem(.fixed(100))<br/>]</span></pre><p id="8fa1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">垂直的</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ny"><img src="../Images/517e65d7f739441ebdc004782372095d.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/0*hgnFd4ml4bHANyFh.png"/></div></div></figure><p id="625a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">水平的</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4d7aa3fff81456dc4ab893fa3c08fa66.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/0*oFnReH2MKQZUW4aJ.png"/></div></figure><h1 id="c0f1" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="2ba6" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">网格布局或以前从UIKit times获得的UICollectionView是在网格系统中呈现数据的重要构件。SwiftUI为我们提供组件，以一种懒散的方式构建垂直或水平的网格布局；这意味着只有在需要时才加载项目。这两个组件是<code class="fe lf lg lh li b">LazyVGrid</code>和<code class="fe lf lg lh li b">LazyHGrid</code>。</p><p id="c091" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使用SwiftUI创建网格布局，我们需要提供数据集、列或行、项目之间的间距以及可选的固定视图(页眉和页脚)。</p><h1 id="4418" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">链接</h1><ul class=""><li id="8c66" class="mx my it js b jt mh jx mi kb oa kf ob kj oc kn nc nd ne nf bi translated"><a class="ae ko" href="https://github.com/fassko/SwiftUIGridView" rel="noopener ugc nofollow" target="_blank">样本代码</a></li><li id="6ebd" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated"><a class="ae ko" href="https://developer.apple.com/documentation/swiftui/lazyvgrid" rel="noopener ugc nofollow" target="_blank"> LazyVGrid文档</a></li><li id="c87f" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated"><a class="ae ko" href="https://developer.apple.com/documentation/swiftui/lazyhgrid" rel="noopener ugc nofollow" target="_blank">lazy grid文档</a></li><li id="5645" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated"><a class="ae ko" href="https://developer.apple.com/documentation/swiftui/griditem" rel="noopener ugc nofollow" target="_blank"> GridItem文档</a></li><li id="1f87" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated"><a class="ae ko" href="https://developer.apple.com/documentation/swiftui/section" rel="noopener ugc nofollow" target="_blank">章节文档</a></li><li id="8c0c" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated"><a class="ae ko" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-position-views-in-a-grid-using-lazyvgrid-and-lazyhgrid" rel="noopener ugc nofollow" target="_blank">如何使用lazy grid和lazy grid在网格中定位视图</a></li><li id="ed31" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated"><a class="ae ko" href="https://swiftwithmajid.com/2020/07/08/mastering-grids-in-swiftui/" rel="noopener ugc nofollow" target="_blank">在SwiftUI中控制网格</a></li><li id="5588" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">【https://swiftui-lab.com/impossible-grids/】</li></ul></div></div>    
</body>
</html>