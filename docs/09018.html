<html>
<head>
<title>How to Create Infinite Scroll in UITableView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在UITableView中创建无限滚动</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-infinite-scroll-in-uitableview-b021732922df?source=collection_archive---------3-----------------------#2021-06-29">https://levelup.gitconnected.com/how-to-create-infinite-scroll-in-uitableview-b021732922df?source=collection_archive---------3-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6f44" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于API数据对TableView进行分页的简单方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/157b64ecb61aac2a5cabfa15b4937223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*es-iZa2peB3SqumkwMmvTA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><h1 id="2297" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">概观</h1><p id="d9a5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">脸书和推特等社交媒体平台的崛起对当今世界产生了重大影响。人们似乎有一种习惯，整天滚动他们的提要，查看各种信息和故事。</p><p id="96cd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">订阅页面是每个社交应用的常见功能，允许用户无限滚动。在本文中，我们将学习如何通过分页获取大量数据。我们将使用<a class="ae mo" href="https://docs.github.com/en/rest" rel="noopener ugc nofollow" target="_blank"> GitHub API </a>来模拟无止境的数据请求。</p><p id="7242" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">GitHub提供了一个API，其中一些端点是公共的，无需认证就可以访问数据，例如获取用户和公共存储库的列表。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="2b73" class="kv kw iq bd kx ky mw la lb lc mx le lf jw my jx lh jz mz ka lj kc na kd ll lm bi translated">我们将建造什么？</h1><p id="c043" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将创建一个简单的应用程序，它具有以下功能。</p><h2 id="01e6" class="nb kw iq bd kx nc nd dn lb ne nf dp lf lw ng nh lh ma ni nj lj me nk nl ll nm bi translated">1.能够调用API和滚动UITableView与分页。</h2><p id="6819" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将使用Github API来获得一个<a class="ae mo" href="https://docs.github.com/en/rest/reference/users#list-users" rel="noopener ugc nofollow" target="_blank">用户列表</a>。它包含了GitHub自成立以来的所有用户。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/1edadf9d1c8836d7bb38ff0a2c8c1ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-6otlV8t90mToFhJulS85w.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用分页加载API数据</figcaption></figure><p id="34dc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在上面的结果中，我使用网络调节器工具创建了一个“边缘”连接，这样我们就可以看到加载过程(一个高速网络将非常快速和无缝加载)。</p><h2 id="e9e8" class="nb kw iq bd kx nc nd dn lb ne nf dp lf lw ng nh lh ma ni nj lj me nk nl ll nm bi translated">2.处理请求<strong class="ak">错误</strong></h2><p id="4cd8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">然后我更改为“100%丢失”,以显示对失败的数据获取的错误处理。参见我之前的<a class="ae mo" href="https://medium.com/codex/simulate-poor-network-conditions-in-ios-development-1c1912a33a51" rel="noopener">文章</a>关于如何模拟多种网络条件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/ae2c598cb24f69b4c7a63ace732fccb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sZjQE3ZpGDFO20eHR1H9UQ.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">网络故障的用户界面处理</figcaption></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="5ec0" class="kv kw iq bd kx ky mw la lb lc mx le lf jw my jx lh jz mz ka lj kc na kd ll lm bi translated">编码开始</h1><h2 id="0f30" class="nb kw iq bd kx nc nd dn lb ne nf dp lf lw ng nh lh ma ni nj lj me nk nl ll nm bi translated"><strong class="ak"> 1。创建新的UIKit项目</strong></h2><p id="a194" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在这个项目中，我们将使用UIKit和故事板。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/80f66d1ae78855e86909d1223fae167a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bN-njCgXa9b4-OWTgkJ0iw.png"/></div></div></figure><h2 id="c0b5" class="nb kw iq bd kx nc nd dn lb ne nf dp lf lw ng nh lh ma ni nj lj me nk nl ll nm bi translated"><strong class="ak"> 2。插入导航控制器(可选)</strong></h2><p id="3be1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">创建项目后，用导航视图控制器嵌入默认的ViewController。选择Main.storyboard，然后选择顶部菜单编辑器&gt;嵌入&gt;导航控制器。</p><h2 id="0e51" class="nb kw iq bd kx nc nd dn lb ne nf dp lf lw ng nh lh ma ni nj lj me nk nl ll nm bi translated"><strong class="ak"> 3。将UITableView插入故事板</strong></h2><p id="2266" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">打开情节提要并插入UITableView。然后将约束固定到超级视图的边缘。不要忘记在ViewController类中将UITableView链接为IBOutlet。</p><h2 id="3b2f" class="nb kw iq bd kx nc nd dn lb ne nf dp lf lw ng nh lh ma ni nj lj me nk nl ll nm bi translated"><strong class="ak"> 4。创建用户模型</strong></h2><p id="e0a5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">创建一个名为User.swift的新模型文件，并添加以下代码。我们只从JSON对象中获得id、名称和avatarUrl。在这个项目中，我们将只显示名称作为一个快速的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="731d" class="nb kw iq bd kx nc nd dn lb ne nf dp lf lw ng nh lh ma ni nj lj me nk nl ll nm bi translated">5.创建API服务管理器</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/7b814f5d4d3b5d98f49567d1d5452193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyFDVI5knNizfz6kzd92yg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">/来自<a class="ae mo" href="https://docs.github.com/en/rest/reference/users#list-users" rel="noopener ugc nofollow" target="_blank"> GitHub API文档</a>的用户端点详细信息</figcaption></figure><p id="360b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">创建一个名为“GithubAPIManager.swift”的新文件来处理API请求。它只是一个使用URLSession和<code class="fe ns nt nu nv b">dataTask()</code>方法的普通API请求。在该文件中，插入以下代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="ebd5" class="nw nx iq lp b lq mj lt mk lw ny ma nz me oa mi ob oc od oe bi translated">创建要在完成处理程序中使用的错误类型</li><li id="2f05" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">用参数构造正确的API URL</li><li id="deed" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">创建<code class="fe ns nt nu nv b">URLRequest</code>，超时10秒。</li></ol><h2 id="ed3f" class="nb kw iq bd kx nc nd dn lb ne nf dp lf lw ng nh lh ma ni nj lj me nk nl ll nm bi translated"><strong class="ak"> 5。设置表格视图和API集成</strong></h2><p id="22b7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">打开ViewController文件并添加以下代码。同样在代码的底部，我们添加了一些TableView数据源方法(委托方法将在下一步中使用)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="fbf2" class="nw nx iq lp b lq mj lt mk lw ny ma nz me oa mi ob oc od oe bi translated">添加<code class="fe ns nt nu nv b">users</code>变量来存储来自API的数据，无论何时设置，TableView都会立即重新加载它的内容。</li><li id="89fb" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated"><code class="fe ns nt nu nv b">setupView()</code>，TableView上的一个简单设置。稍后我们需要添加<code class="fe ns nt nu nv b">.delegate</code>。</li><li id="26e6" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">调用我们的API服务并处理接收到的数据的函数。</li><li id="ddff" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">添加默认的TableView单元格以显示名称和行号。</li></ol><p id="0896" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">添加代码后，运行您的项目，您应该会得到简单的TableView列表，如下图所示。您将在TableView中获得正好30行作为默认的<code class="fe ns nt nu nv b">perPage</code>参数，并且还不能分页。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/924b2c95b80ac4d03f4337f19a364bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5AEtkw3qiWamZf78vJobA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">包含30个用户静态数据的简单表格视图列表</figcaption></figure><h2 id="7d18" class="nb kw iq bd kx nc nd dn lb ne nf dp lf lw ng nh lh ma ni nj lj me nk nl ll nm bi translated">6.设置分页</h2><p id="bc89" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">太好了。我们已经完成了项目的基础设置。现在，我们需要做一些更新，以确保我们的用户列表可以无休止地滚动。如下更新我们的ViewController类，并查看每个代码更改的解释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c49b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">以下是对修正案的解释。</p><ol class=""><li id="4413" class="nw nx iq lp b lq mj lt mk lw ny ma nz me oa mi ob oc od oe bi translated">我们添加了新的<code class="fe ns nt nu nv b">TableSection</code>枚举。我们的TableView将有两个部分。第一个是保持相同的用户列表，而第二个是保持加载器单元。</li><li id="5d8e" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">又增加了两个变量。<code class="fe ns nt nu nv b">pageLimit</code>用于保持所请求的限制对象的常量，<code class="fe ns nt nu nv b">currentLastId</code>用于存储<code class="fe ns nt nu nv b">users</code>数组中最后一个<code class="fe ns nt nu nv b">User</code>对象的id。通过向<code class="fe ns nt nu nv b">since</code>参数提供我们已经获取的最后一个id，将在获取下一个页面API时使用<code class="fe ns nt nu nv b">currentLastId</code>。</li><li id="ad84" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">将TableView委托分配给当前ViewController，以便能够使用<code class="fe ns nt nu nv b">willDisplay</code>方法调用。</li><li id="0d81" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">用完成回调更新fetchData以接收成功或失败状态。</li><li id="ad25" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">将<code class="fe ns nt nu nv b">=</code>改为<code class="fe ns nt nu nv b">.append</code>的方法，保持<code class="fe ns nt nu nv b">users</code>数组扩展而不是替换。</li><li id="436b" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">用成功状态更新<code class="fe ns nt nu nv b">completion()</code>。</li><li id="0769" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">添加了<code class="fe ns nt nu nv b">numberOfSections</code>，因为我们将保留两个部分，如第1点所述。</li><li id="5730" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated"><code class="fe ns nt nu nv b">numberOfRowsInSection</code>现在是视小节而定。此外，只有当用户的数据大小更多的<code class="fe ns nt nu nv b">pageLimit</code>，然后我们将显示加载单元。</li><li id="25fe" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">只需将单元格文本更新为用户列表的名称并“加载..”对于第二部分。</li><li id="6491" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">这是加载器单元将出现的重要部分，API服务将开始获取新数据(下一页)。</li><li id="0bec" class="nw nx iq lp b lq of lt og lw oh ma oi me oj mi ob oc od oe bi translated">在前面一点中，在<code class="fe ns nt nu nv b">willDisplay</code>方法中，当错误发生时会调用<code class="fe ns nt nu nv b">hideBottomLoader()</code>。是的，我们完了！试着运行代码，一直滚动到底部，直到你的名字😆。</li></ol></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="3bbf" class="kv kw iq bd kx ky mw la lb lc mx le lf jw my jx lh jz mz ka lj kc na kd ll lm bi translated">潜在缺陷</h1><p id="a2f3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当网络连接缓慢时，可能会发生一个潜在的错误。当用户到达底部加载器单元时，他们可以继续上下滚动，以便发送多个具有相同<code class="fe ns nt nu nv b">currentLastId</code>的API请求。因此，成功数据将是多余的。</p><p id="e54d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">解决这个问题是你的家庭作业🤭</p><p id="5326" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">不要慌！最简单的解决方案是在每次发送请求时比较<code class="fe ns nt nu nv b">currentLastId</code>。确保检查<code class="fe ns nt nu nv b">currentLastId</code>与之前的请求不同。对，就是这样。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="d2b4" class="kv kw iq bd kx ky mw la lb lc mx le lf jw my jx lh jz mz ka lj kc na kd ll lm bi translated">项目已完成</h1><p id="3d64" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">恭喜你！我们已经完成了所有的步骤，项目现在已经准备好了，可以完美地工作了。完整的源代码可以从我的GitHub <a class="ae mo" href="https://github.com/xmhafiz/PaginateTableView" rel="noopener ugc nofollow" target="_blank">库</a>下载。您可以尝试将它实现到您的项目中，并通过开发一个子类或UITableView扩展来改进代码，以便它可以在其他视图控制器中重用。</p><p id="9651" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">感谢阅读。编码快乐！</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="6b1a" class="kv kw iq bd kx ky mw la lb lc mx le lf jw my jx lh jz mz ka lj kc na kd ll lm bi translated">参考</h1><p id="cb76" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae mo" href="https://docs.github.com/en/rest" rel="noopener ugc nofollow" target="_blank">https://docs.github.com/en/rest</a></p><p id="4e94" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mo" href="https://docs.github.com/en/rest/reference/users#list-users" rel="noopener ugc nofollow" target="_blank">https://docs.github.com/en/rest/reference/users#list-users</a></p><p id="3433" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mo" href="https://medium.com/codex/simulate-poor-network-conditions-in-ios-development-1c1912a33a51" rel="noopener">https://medium . com/codex/simulate-poor-network-conditions-in-IOs-development-1c 1912 a 33 a 51</a></p><p id="3325" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mo" href="https://github.com/xmhafiz/PaginateTableView" rel="noopener ugc nofollow" target="_blank">https://github.com/xmhafiz/PaginateTableView</a></p></div></div>    
</body>
</html>