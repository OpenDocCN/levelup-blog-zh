<html>
<head>
<title>Modifying Structs In List vs Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修改列表和数组中的结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/modifying-struct-in-list-vs-array-6b4035b139b9?source=collection_archive---------5-----------------------#2019-12-13">https://levelup.gitconnected.com/modifying-struct-in-list-vs-array-6b4035b139b9?source=collection_archive---------5-----------------------#2019-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e373c79a49eba2e6bbd8793684020d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HyBvvUH1z2lRi4l-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@mohamad_mahdi" rel="noopener ugc nofollow" target="_blank">穆罕默德·迈赫迪·阿巴西</a>在<a class="ae kc" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="181d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的代码中，我设置了一个简单的数组和一个泛型列表，两者都包含一个<code class="fe lb lc ld le b">SomeStruct</code>的实例:</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/28e9a07428556b48c513813dae190a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*uL-snxaJvKh3EMXD.jpg"/></div></figure><h1 id="5e79" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">错误</h1><p id="755f" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">很奇怪，当你可以用几乎完全相同的方式修改数组时，看到编译器抱怨修改列表，那么为什么不允许我们这样做呢？</p><h1 id="0d9c" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">数组与列表</h1><p id="6d54" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">为了理解为什么不允许这样做，让我们来看看当您使用索引访问数组和列表时幕后发生了什么。</p><h1 id="8c78" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">排列</h1><p id="63ac" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">下面是访问索引为0的数组的CIL代码，然后将属性设置为<code class="fe lb lc ld le b">“Abcd”</code>:</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/ad577fc73326e4d28490860a41b9ce62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/0*o2yTGdbfesvzxxeT.JPG"/></div></figure><p id="ad39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请看第3块“访问和编辑元素”。下面是对每一行的简要说明:</p><ul class=""><li id="84ee" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated"><code class="fe lb lc ld le b">ldc.i4.0</code> —将整数值0作为int32压入堆栈。</li><li id="0c72" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated"><code class="fe lb lc ld le b">ldelema ValueTypeTest.SomeStruct</code> —将数组元素的地址加载到当前栈顶int指定的索引处(即0)，放到堆栈的顶部</li><li id="4550" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated"><code class="fe lb lc ld le b">ldstr “Abcd”</code> —将新的对象引用推送到堆栈上的<code class="fe lb lc ld le b">“Abcd”</code>。</li><li id="44b7" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated"><code class="fe lb lc ld le b">call instance void ValueTypeTest.SomeStruct::set_SomeProp(string)</code> —调用属性<code class="fe lb lc ld le b">SomeProp</code>的set property方法，传入当前堆栈顶部的字符串(即<code class="fe lb lc ld le b">“Abcd”</code>)。</li></ul><p id="5953" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是堆/栈的样子。为位于内存0x10的<code class="fe lb lc ld le b">SomeStruct</code>实例设置<code class="fe lb lc ld le b">SomeProp</code>属性，字符串<code class="fe lb lc ld le b">“Abcd”</code>位于0x20(注意内存地址是任意的)。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/f550484394bc373c47840afa15445968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uh064B04y2Fk9xQ4.jpg"/></div></div></figure><p id="523a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，该属性是为实际的<code class="fe lb lc ld le b">SomeStruct</code>实例(不是副本)设置的，位于内存中的数组中。</p><p id="9f63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们将它与一个列表进行比较。</p><h1 id="8d5d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">目录</h1><p id="90bc" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">类似于数组，当您调用<code class="fe lb lc ld le b">someStructsList[0].SomeProp = “Abcd”;</code>时，它实际上在做两件事，访问<code class="fe lb lc ld le b">SomeStruct</code>实例，然后设置属性。</p><p id="c05b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们不能编译<code class="fe lb lc ld le b">someStructsList[0].SomeProp = “Abcd”</code>，让我们把它分解成下面的编译，让我们看看它在幕后做什么:</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e13fa0fa546e7fcd5ef3f7d7a452281b.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/0*owmOlAdbXmSYF-wV.JPG"/></div></figure><p id="3e0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是CIL:</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/df82344a97a3c2546852662e69c1f9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E_PQBz_2GkB2Gxrd.JPG"/></div></div></figure><p id="9443" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只对橙色矩形中的代码感兴趣。</p><p id="f0f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b"><em class="nf">ldc.i4.0 </em></code> —将<code class="fe lb lc ld le b">Int32</code>值0加载到堆栈上。</p><p id="8455" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">callvirt instance !0 class [mscorlib]System.Collections.Generic.List`1[valuetype ValueTypeTest.SomeStruct]::get_Item(int32)</code> —调用索引器方法。</p><p id="2683" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与数组访问不同，当你访问一个列表中的元素时，你实际上是在使用一个索引器，这是一个接受一个<code class="fe lb lc ld le b">Int32</code>的方法，并且<strong class="kf ir">返回位于列表内部数组中该索引处的元素</strong>的副本。</p><p id="60d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是关键点，你得到的是元素的副本，而不是实际的元素。</p><p id="788a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能以前学过这个概念，当一个方法返回一个值类型的实例时，你得到的是那个实例的副本，而不是实际的实例(除非你使用ref/out)。</p><h1 id="b6a1" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="bb49" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这就是第一行代码不能编译的原因，因为您在<code class="fe lb lc ld le b">SomeStruct</code>实例的副本上设置了一个属性。因为这个副本没有存储在任何地方，所以您只是在一个即将被丢弃的副本上设置了一个属性，这可能不是您想要的。</p><p id="4252" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你用一个局部变量把它分成两个步骤，编译器不会抱怨，因为至少你在一个局部变量中设置了一个实例副本的属性。</p></div></div>    
</body>
</html>