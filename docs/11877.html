<html>
<head>
<title>TypeScript with WebPack in ASP.NET Core projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心项目中使用WebPack的类型脚本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-with-webpack-in-asp-net-core-projects-2e0b601d052b?source=collection_archive---------23-----------------------#2022-04-24">https://levelup.gitconnected.com/typescript-with-webpack-in-asp-net-core-projects-2e0b601d052b?source=collection_archive---------23-----------------------#2022-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cd373823145acb36303ddbdd68b44b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9rVMXJVHAonleXrG7-CXQ.jpeg"/></div></div></figure><h1 id="1124" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">动机</h1><p id="e38e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">假设您正在开发一个ASP.NET核心web应用程序，它解决了一些与业务相关的任务。你知道，一些用户输入数据并得到一些报告的表单。</p><p id="0fb8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">尽管这样的项目可能不需要客户端的任何复杂逻辑，但您可能仍然需要编写一些JavaScript代码，以使用户与您的应用程序的交互更加方便和愉快。例如，你可能需要一个简单的删除条目的弹出提示，因为用一个单独的页面是不太合适的。或者，您希望进行客户端验证。或者……它真的可以是任何其他客户端任务，你说吧。</p><p id="3afb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当然，您可以在每个页面上添加几行脚本(使用普通的JavaScript或者使用传统的JQuery ),但是当您的项目变大时，很难维护所有这些小部分。此外，其中一些部分做相同的事情，所以您要么需要在许多地方复制它们(糟糕的决定)，要么最终创建一个包含项目中使用的所有客户端函数、结构和类的小库。</p><p id="dba6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">本文描述了如何用最少的努力为您的ASP.NET核心项目创建这样一个JS库，并且以一种为进一步的变更提供更好支持的方式。</p><h1 id="63d4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">解决方案</strong></h1><p id="2e71" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">长话短说，我们将把所有的客户端代码放在单独的文件中(包括类、函数、数据结构等等)。)然后在<a class="ae lz" href="https://webpack.js.org" rel="noopener ugc nofollow" target="_blank"> WebPack 5 </a>的帮助下进行捆绑。生成的脚本可以直接包含在你的<em class="ma"> _Layout.cshtml </em>中(因此，它将在你的web应用程序的所有页面上可用)，或者你可以只在必要的页面上包含它。</p><p id="7e12" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，我们将使用TypeScript而不是纯JavaScript，因为，你知道，它是现代的和闪亮的，静态类型很好，允许我们在编译时捕捉许多错误。</p><p id="df36" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，您可以将本文视为对客户端开发的快速介绍。尤其是如果你是一个. NET开发人员，仍然倾向于只做后端，并且害怕所有那些花哨的客户端东西(就像我不久前一样)。</p><h1 id="0c08" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">入门</strong></h1><p id="883d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这里，我们将描述设置将小型TypeScript库与您自己的代码捆绑在一起的配置所需的步骤。</p><p id="8a57" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了简化起见，我们的库现在只包含一个函数。</p><h2 id="b9a9" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated"><strong class="ak">第0步:安装节点。JS </strong></h2><p id="cecd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我很确定你已经安装了。万一你没有-请做吧。我们需要节点。您的开发/构建机器上的JS版本10.13.0(或更新版本)。</p><h2 id="cce3" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated">第一步:创建<strong class="ak"> <em class="mn"> `ClientScript` </em>子文件夹</strong></h2><p id="b2f7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们将把所有的脚本和配置文件放到主项目文件夹的一个单独的子文件夹<em class="ma"> ClientScript </em>中。</p><p id="5c1f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">它类似于ASP.NET核心可用的大多数SPA(单页应用程序)模板中使用的<em class="ma"> ClientApp </em>子文件夹。</p><h2 id="511b" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated">第二步:<strong class="ak">添加配置文件</strong></h2><p id="6505" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们需要3个配置文件:</p><ul class=""><li id="d07e" class="mo mp iq ky b kz lu ld lv lh mq ll mr lp ms lt mt mu mv mw bi translated"><em class="ma"> package.json </em>定义我们的包和所有依赖项。</li><li id="9264" class="mo mp iq ky b kz mx ld my lh mz ll na lp nb lt mt mu mv mw bi translated"><em class="ma"> webpack.config.js f </em>或webpack配置。</li><li id="9910" class="mo mp iq ky b kz mx ld my lh mz ll na lp nb lt mt mu mv mw bi translated"><em class="ma"> tsconfig.json </em>进行打字稿设置。</li></ul><p id="ce53" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，您可以按原样复制这些文件。我们将在后面描述它们中的每一个。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">package.json tsconfig.json和webpack.config.js文件</figcaption></figure><h2 id="32e9" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated"><strong class="ak">第三步:添加打字稿文件</strong></h2><p id="12ec" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了简单起见，在这个初始阶段，我们的库将只包含一个函数<em class="ma"> hello() </em>，它只是将“Hello world”打印到浏览器的控制台。这是我们需要的两个文件，以实现出色的:)功能:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9ae3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里的<code class="fe nm nn no np b">hello.ts</code>包含了我们打包到<code class="fe nm nn no np b">funcs</code>名称空间中的函数，所以我们可以把它叫做<code class="fe nm nn no np b">MYAPP.funcs.hello()</code>，而<code class="fe nm nn no np b">index.ts</code>是我们的入口点。以前的TypeScript文件将不包含任何函数或类。它将定义我们的代码的哪些部分(函数、接口、类等)将向外界公开。因为我们只有一个具有“真正”功能的文件，所以我们的<code class="fe nm nn no np b">index.ts</code>只包含一行代码，它只导出(“揭示”)来自<code class="fe nm nn no np b">hello.ts</code>的所有公共(导出)代码</p><h2 id="45c8" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated">第四步:建立你的图书馆</h2><p id="b550" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">就是这样。我们已经准备好构建我们的包脚本了。为此，请打开您的终端程序，移动到“ClientScript”文件夹并运行以下两个命令:</p><p id="aec1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe nm nn no np b">&gt; npm install</code></p><p id="6276" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后:</p><p id="9063" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe nm nn no np b">&gt; npm run build</code></p><p id="3ff6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第一个将安装所有必要的NPM库(在您的<em class="ma"> package.json </em>的<code class="fe nm nn no np b">dependencies</code>和<code class="fe nm nn no np b">devDependencies</code>部分列出的库)。您将需要在第一次构建之前运行它，然后只有当您添加一个新的依赖项(另一个NPM包)时才运行它。</p><p id="ea54" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第二个命令实际上运行WebPack，它将您的TypeScript文件编译(或者更准确地说是“transpiles”)为JavaScript，然后将所有JS代码捆绑到一个文件<em class="ma"> app-client.js、</em>中，最后将该文件放入web项目的<em class="ma"> wwwroot/js </em>文件夹中，如<em class="ma"> webpack.config.js </em>配置文件中所定义。</p><p id="7217" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">根据该文件的<code class="fe nm nn no np b">output/library</code>部分，新包的所有函数或结构都可以通过<code class="fe nm nn no np b">MYAPP</code>全局变量来访问。</p><h2 id="dae8" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated"><strong class="ak">第五步:将最终脚本附加到你的应用程序上</strong></h2><p id="3007" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要使用我们的脚本，您只需将它作为任何其他JS文件包含在您的页面中:</p><p id="7146" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe nm nn no np b">&lt;script src="/js/app-client.min.js"&gt;&lt;/script&gt;</code></p><p id="e8fb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可以将该行添加到<em class="ma"> _Layout.cshtml </em>(使其在您的web应用程序的所有页面上都可用)或者只添加到视图或Razor页面中的必要位置。</p><p id="faae" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，您可以从我们新的JS库中调用函数:</p><pre class="nc nd ne nf gt nq np nr ns aw nt bi"><span id="5b6e" class="mb jz iq np b gy nu nv l nw nx">&lt;script&gt;<br/>MYAPP.funcs.hello();<br/>&lt;/script&gt;</span></pre><h1 id="06f8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">配置范围</strong></h1><p id="b9d8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用TypeScript和WebPack的一个很好的特性是将代码组织成模块，然后使用WebPack的配置和TypeScript的<code class="fe nm nn no np b">namespace</code>结构将这些模块组合成名称空间。</p><p id="bac3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">有几种可能的选择。</p><h2 id="d9cd" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated"><strong class="ak"> 1。使用模块名及其别名</strong></h2><p id="be0b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可以将函数和类放在一个模块中，然后“按原样”或使用别名导出该模块。</p><p id="c9ad" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">例如，如果我们有下面的<em class="ma">对话框</em>模块:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0c2d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们在我们的<em class="ma"> index.ts </em>中使用此出口声明:</p><pre class="nc nd ne nf gt nq np nr ns aw nt bi"><span id="c67c" class="mb jz iq np b gy nu nv l nw nx">export * from ‘./dialogs’;</span></pre><p id="7d99" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后我们的<code class="fe nm nn no np b">Dialog</code>类和<code class="fe nm nn no np b">showDialog()</code>函数将在<code class="fe nm nn no np b">MYAPP</code>名称空间下作为<code class="fe nm nn no np b">MYAPP.Dialog</code>和<code class="fe nm nn no np b">MYAPP.showDialog()</code>可用。</p><p id="7806" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您还可以为“对话”模块指定一个别名:</p><pre class="nc nd ne nf gt nq np nr ns aw nt bi"><span id="d629" class="mb jz iq np b gy nu nv l nw nx">export * as dlg from './dialogs';</span></pre><p id="b839" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们的类和函数将相应地作为<code class="fe nm nn no np b">MYAPP.dlg.Dialog</code>和<code class="fe nm nn no np b">MYAPP.dlg.showDialog()</code>被访问。</p><h2 id="69ce" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated"><strong class="ak"> 2。使用</strong> <code class="fe nm nn no np b"><strong class="ak">namespace</strong></code> <strong class="ak">子句</strong></h2><p id="5b02" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您还可以使用<code class="fe nm nn no np b">namespace</code>子句，然后重新导出导入的模块，这样即使在不同的模块中，所有属于同一名称空间的函数、变量和类型都将被合并在一起。</p><p id="cc74" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">例如，我们有以下两个模块:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b629" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，如果我们在“index.ts”模块中放置下面两行代码</p><pre class="nc nd ne nf gt nq np nr ns aw nt bi"><span id="551d" class="mb jz iq np b gy nu nv l nw nx">export * from ‘./dialogs’;<br/>export * from ‘./widgets’;</span></pre><p id="b324" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将能够在<code class="fe nm nn no np b">MYAPP.ui</code>名称空间下访问所有那些导出的函数和类。例如:<code class="fe nm nn no np b">MYAPP.ui.renderWidget1()</code></p><h1 id="64a1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">使用第三方库</strong></h1><p id="a671" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">也许这种设置的最大优势(对于一个“hello world”函数来说，这似乎有点复杂)是可以使用来自<a class="ae lz" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM库</a>上成千上万可用的第三方JS库。</p><p id="3202" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了演示这种可能性，我们将稍微修改我们的<code class="fe nm nn no np b">hello()</code>函数，使它接受一个参数(<code class="fe nm nn no np b">name</code>)，并将短语“<em class="ma"> Hello，{ name }”</em>打印到控制台。在打印之前，存储在<code class="fe nm nn no np b">name</code>变量中的字符串将被众所周知的<em class="ma"> lodash </em>库中的函数<code class="fe nm nn no np b">capitalize()</code>大写。</p><p id="4ddb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">以下是我们实现这一目标应该采取的步骤:</p><h2 id="c76e" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated">步骤1: <strong class="ak">将“lodash”库添加到您的package.json中</strong></h2><p id="b59c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">只需在您的<em class="ma"> ClientScript </em>文件夹中打开一个终端，并键入:</p><pre class="nc nd ne nf gt nq np nr ns aw nt bi"><span id="27ff" class="mb jz iq np b gy nu nv l nw nx">npm install lodash</span></pre><p id="8914" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">作为该操作的结果，您将在您的<em class="ma"> package.json </em>文件的<code class="fe nm nn no np b">dependencies</code>部分看到类似如下的内容:</p><pre class="nc nd ne nf gt nq np nr ns aw nt bi"><span id="633e" class="mb jz iq np b gy nu nv l nw nx">"dependencies": {<br/>  "lodash": "^4.17.21"<br/>}</span></pre><p id="7b2d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">注意:实际版本号可以不同。</p><h2 id="b423" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated"><strong class="ak">步骤2:在hello.ts文件中导入“lodash”函数</strong></h2><p id="d884" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在<em class="ma"> hello.ts </em>的开头加上下面一行:</p><pre class="nc nd ne nf gt nq np nr ns aw nt bi"><span id="66b6" class="mb jz iq np b gy nu nv l nw nx">import * as _ from ‘lodash’;</span></pre><h2 id="c85f" class="mb jz iq bd ka mc md dn ke me mf dp ki lh mg mh km ll mi mj kq lp mk ml ku mm bi translated"><strong class="ak"> 3。修改“hello()”功能</strong></h2><p id="d2e3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在我们可以通过使用<code class="fe nm nn no np b">_</code>全局变量来使用所有<em class="ma"> lodash </em>库函数(这是使用<em class="ma"> lodash </em>函数的默认方式，因为它不是NPM库。</p><p id="01a8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，我们的<code class="fe nm nn no np b">hello()</code>函数现在看起来如下:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ce47" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，我们将修改页面上的函数调用:</p><pre class="nc nd ne nf gt nq np nr ns aw nt bi"><span id="0a1f" class="mb jz iq np b gy nu nv l nw nx">&lt;script&gt;<br/>MYAPP.funcs.hello('sergiy');<br/>&lt;/script&gt;</span></pre><p id="9fb0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们重新构建脚本(<code class="fe nm nn no np b">&gt;npm run build</code>)，运行应用程序，并打开主页时，我们将在浏览器的控制台面板中看到以下字符串:</p><pre class="nc nd ne nf gt nq np nr ns aw nt bi"><span id="ddef" class="mb jz iq np b gy nu nv l nw nx">&gt; Hello, Sergiy</span></pre><h1 id="f270" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">观看模式</strong></h1><p id="6eac" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">没有必要在每次修改脚本或者向项目中添加新的包时都运行<em class="ma"> build </em>命令。相反，您可以使用特殊的<em class="ma">监视</em>模式(它是由WebPack提供的开箱即用模式)，因此每当我们的源文件或项目配置中的某些内容发生更改时，WebPack都会自动重新构建您的项目。要启动观察模式，只需在你的终端窗口输入</p><pre class="nc nd ne nf gt nq np nr ns aw nt bi"><span id="b049" class="mb jz iq np b gy nu nv l nw nx">&gt; npm run watch</span></pre><h1 id="48e4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">结论</strong></h1><p id="a609" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正如我们所看到的，使用TypeScript和WebPack为您的ASP.NET核心项目构建普通的JS客户端脚本有很多好处:</p><ul class=""><li id="e76b" class="mo mp iq ky b kz lu ld lv lh mq ll mr lp ms lt mt mu mv mw bi translated">具有最新JavaScript特性所有优点的强类型类型脚本代码:类、箭头函数、模块、作用域和承诺。</li><li id="2a95" class="mo mp iq ky b kz mx ld my lh mz ll na lp nb lt mt mu mv mw bi translated">代码编辑器(如Visual Studio代码)通过语法高亮、智能感知等提供更好的支持。</li><li id="2a2f" class="mo mp iq ky b kz mx ld my lh mz ll na lp nb lt mt mu mv mw bi translated">有可能使用带有类型定义的三方库。</li><li id="50c1" class="mo mp iq ky b kz mx ld my lh mz ll na lp nb lt mt mu mv mw bi translated">WebPack生成的更加紧凑和优化的JS 5代码。</li><li id="11bf" class="mo mp iq ky b kz mx ld my lh mz ll na lp nb lt mt mu mv mw bi translated">热重新加载您在代码编辑器中所做的更改。</li><li id="724c" class="mo mp iq ky b kz mx ld my lh mz ll na lp nb lt mt mu mv mw bi translated">更好的调试体验。可以调试原始的TypeScript代码，而不是web应用程序可用的最小化JS代码。</li></ul><p id="7337" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还有一个注意事项。我们在本文中使用了<em class="ma"> WebPack </em>,因为它是目前最流行的模块捆绑器。然而，我相信我们可以很快得到与任何其他捆绑器相同的结果，如<em class="ma"> Browserify </em>、<em class="ma"> Parcel </em>或<em class="ma"> Rollup </em>。</p><p id="ed23" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请让我知道(通过我的Twitter <a class="ae lz" href="https://twitter.com/korzhs" rel="noopener ugc nofollow" target="_blank"> @korzhs </a>或在评论中)这篇文章对你是否有价值和有帮助。</p><p id="a881" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">编码快乐！</p></div></div>    
</body>
</html>