<html>
<head>
<title>How to Set Up Server Side Rendering (SSR) With React, express.js, and esbuild</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React、express.js和esbuild设置服务器端渲染(SSR)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-set-up-server-side-rendering-ssr-with-react-express-js-and-esbuild-6ccb6d4bf359?source=collection_archive---------0-----------------------#2021-11-28">https://levelup.gitconnected.com/how-to-set-up-server-side-rendering-ssr-with-react-express-js-and-esbuild-6ccb6d4bf359?source=collection_archive---------0-----------------------#2021-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cbc7d70fce4c452027d82f03ee33e664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CVwomfjM3GNZv0C8.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">服务器端渲染是神奇的</figcaption></figure><h1 id="4a2f" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">目录</h1><p id="9b3a" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><a class="ae mb" href="https://devtails.xyz/how-to-set-up-server-side-rendering-ssr-with-react-and-esbuild#what-is-server-side-rendering" rel="noopener ugc nofollow" target="_blank">什么是服务器端渲染？</a> <br/> <a class="ae mb" href="https://devtails.xyz/how-to-set-up-server-side-rendering-ssr-with-react-and-esbuild#why-use-server-side-rendering" rel="noopener ugc nofollow" target="_blank">为什么要使用服务器端渲染？</a> <br/> <a class="ae mb" href="https://devtails.xyz/how-to-set-up-server-side-rendering-ssr-with-react-and-esbuild#how-to-implement-server-side-rendering-with-react" rel="noopener ugc nofollow" target="_blank">如何用React实现服务器端渲染</a></p><p id="69ae" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated"><strong class="lf iu">本教程的代码可以在</strong> <a class="ae mb" href="https://github.com/adamjberg/react-ssr" rel="noopener ugc nofollow" target="_blank"> <strong class="lf iu"> GitHub </strong> </a>上找到</p><h1 id="6f36" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">什么是服务器端渲染？</h1><p id="3adc" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">服务器端呈现是服务器立即为客户端返回完全呈现的HTML页面的能力。一个简单的静态文件服务器可能会返回服务器上一个<code class="fe mh mi mj mk b">index.html</code>文件的确切内容。</p><p id="7399" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">一种常见的做法是使用某种模板语言/引擎(例如，<a class="ae mb" href="https://daringfireball.net/projects/markdown/" rel="noopener ugc nofollow" target="_blank"> Markdown </a>、<a class="ae mb" href="https://pugjs.org/api/getting-started.html" rel="noopener ugc nofollow" target="_blank"> pug </a>或<a class="ae mb" href="https://jinja.palletsprojects.com/en/3.0.x/" rel="noopener ugc nofollow" target="_blank"> jinja </a>)，允许对输出的html文本进行更高级的控制。</p><p id="0532" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">对于像React这样的客户端库，不管访问的是什么URL，通常都会返回一个简单的<code class="fe mh mi mj mk b">index.html</code>文件。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="107e" class="mt kg it mk b gy mu mv l mw mx">&lt;!-- index.html --&gt;</span><span id="57c2" class="mt kg it mk b gy my mv l mw mx">&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;script src="app.js" async defer&gt;&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;div id="root"&gt;&lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="cb84" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">一旦上面的<code class="fe mh mi mj mk b">app.js</code>脚本被加载，它会立即启动React库，反过来React库会使用<code class="fe mh mi mj mk b">#root</code>元素引导自己。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d3c7" class="mt kg it mk b gy mu mv l mw mx">// index.tsx</span><span id="c04f" class="mt kg it mk b gy my mv l mw mx">import React from "react";<br/>import ReactDOM from 'react-dom';<br/>import { App } from './App';</span><span id="f64a" class="mt kg it mk b gy my mv l mw mx">ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</span></pre><p id="504f" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">上面的代码告诉React渲染<code class="fe mh mi mj mk b">#root</code> div下的<code class="fe mh mi mj mk b">App</code>组件。您可能还会使用<code class="fe mh mi mj mk b"><a class="ae mb" href="https://reactrouter.com/" rel="noopener ugc nofollow" target="_blank">react-router</a></code>来处理不同URL的导航。通过这种方法，react-router可以防止浏览器在页面上单击链接时从服务器获取新页面。</p><p id="ff44" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">在React的上下文中，服务器端呈现意味着当访问特定的URL时，返回的html已经填充了页面应该显示的内容。</p><p id="1e1b" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">举一个非常简单的React应用程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3d7c" class="mt kg it mk b gy mu mv l mw mx">// App.ts<br/>import React from "react";</span><span id="fa3b" class="mt kg it mk b gy my mv l mw mx">export const App: React.FC = () =&gt; {<br/>    return &lt;h1&gt;Hello World!&lt;/h1&gt;<br/>}</span></pre><p id="eeca" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">当服务器端渲染被正确实现时，服务器将返回:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e1f4" class="mt kg it mk b gy mu mv l mw mx">&lt;!-- index.html --&gt;</span><span id="bace" class="mt kg it mk b gy my mv l mw mx">&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;script src="app.js" async defer&gt;&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;div id="root"&gt;<br/>        &lt;h1 data-reactroot=""&gt;Hello World!&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="b420" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">现在我已经解释了什么是服务器端渲染，让我们来看看为什么和什么时候应该使用它，以及最后如何实际实现。</p><h1 id="7661" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">为什么使用服务器端渲染？</h1><p id="2eaa" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">客户端web应用程序在Web 2.0中风靡一时。通过让用户的浏览器控制页面上显示的信息，它们帮助web应用程序变得更具交互性。</p><p id="4f04" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">不幸的是，这也带来了一些弊端。一个web页面现在需要获取一个<code class="fe mh mi mj mk b">index.html</code>文件，解析html文件，然后获取一个JavaScript文件(通常不止一个)，然后解析JavaScript，执行JavaScript以确定在页面上呈现什么，通常还要发送几个请求来获取当前页面所需的实际信息。</p><p id="56a6" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">在这篇文章中，我将使用一个简单的博客网站作为例子。当使用像React这样的客户端库来构建博客时，有一些关于站点性能和搜索引擎优化的问题可以通过服务器端渲染来改善。</p><h1 id="0f38" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">页面性能</h1><p id="b829" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这是实施SSR的主要原因之一。使用SSR，浏览器发出的第一个请求就会返回应该显示的html。这可能节省了获取其他资源的多次往返，并进一步加快了速度，因为捆绑的JavaScript代码不需要解析和执行就可以决定在页面上显示什么。</p><p id="894f" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">对于包含基于单个用户的动态内容的页面，添加服务器端呈现可能会给服务器带来相当大的压力，因为每个请求都需要服务器生成唯一的响应。更大的收益来自于呈现的html对于多个客户端是相同的情况。在我们的博客例子中，情况正是如此。一个帖子对每个浏览它的人来说都是一样的。我们不会在这篇文章中讨论这个问题，但是缓存呈现的html是可能的，这样就不需要在每次请求时都重新呈现。</p><h1 id="cf4e" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">支持禁用JavaScript的浏览器</h1><p id="4fdb" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">有一小部分互联网用户要么禁用JavaScript，要么使用计算能力有限的设备访问互联网。在某些情况下，使用服务器端呈现来预呈现内容使得这些用户仍然可以访问应用程序的内容(尽管没有一些交互部分)。</p><h1 id="a26b" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">搜索引擎优化</h1><p id="bcd9" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">网络爬虫也属于这一类，因为它们在爬行网页时通常不运行客户端javascript。如果您的页面需要JavaScript来查看内容，这些爬虫将无法索引您的网页。这可能会对您的搜索引擎优化产生负面影响，导致您的网站不会出现在搜索结果中。</p><h1 id="0895" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">社交媒体上的链接预览</h1><p id="f9fc" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">大多数社交媒体网站使用<a class="ae mb" href="https://ogp.me/" rel="noopener ugc nofollow" target="_blank">开放图形协议</a>来决定当你在社交媒体上分享链接时，如何显示那些花哨的预览图像。如果没有服务器端呈现，就不可能动态填充这些信息。对于我们的博客示例，这意味着特定帖子的链接预览将返回与主页相同的元信息。因此，它不是展示我们链接到的特定帖子的漂亮预览，而是显示网站的一般信息。在以后的文章中，我会更详细地介绍如何在我们正在实现的服务器端渲染之上添加这些链接预览。</p><h1 id="b7b2" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">如何用React实现服务器端渲染</h1><h1 id="bf7c" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">初始化项目</h1><p id="6e7e" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">创建一个新文件夹来存放此项目:</p><p id="10ff" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated"><code class="fe mh mi mj mk b">mkdir react-ssr</code></p><p id="a4ef" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">更改目录</p><p id="2cdb" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated"><code class="fe mh mi mj mk b">cd react-ssr</code></p><p id="f0c5" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">初始化npm包</p><p id="230e" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated"><code class="fe mh mi mj mk b">npm init</code></p><h1 id="568d" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">创建简单的反应应用程序</h1><p id="47bb" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">安装react和react-dom</p><p id="cbf3" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated"><code class="fe mh mi mj mk b">npm i react react-dom</code></p><p id="30cc" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">创建一个文件夹来存放React客户端代码</p><p id="2d6d" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated"><code class="fe mh mi mj mk b">mkdir -p client/src</code></p><p id="c849" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">在<code class="fe mh mi mj mk b">client/src</code>中创建名为<code class="fe mh mi mj mk b">index.tsx</code>的文件</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c35d" class="mt kg it mk b gy mu mv l mw mx">// index.tsx<br/>import React from "react";<br/>import ReactDOM from 'react-dom';<br/>import { App } from './App';</span><span id="2e1e" class="mt kg it mk b gy my mv l mw mx">ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</span></pre><p id="4b47" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">在<code class="fe mh mi mj mk b">client/src</code>中创建应用组件<code class="fe mh mi mj mk b">App.tsx</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="74f2" class="mt kg it mk b gy mu mv l mw mx">// App.tsx<br/>import React, { useEffect, useState } from "react";</span><span id="6c10" class="mt kg it mk b gy my mv l mw mx">export const App: React.FC = () =&gt; {<br/>    const [clientMessage, setClientMessage] = useState("");<br/>    <br/>    useEffect(() =&gt; {<br/>        setClientMessage("Hello From React");<br/>    })</span><span id="872d" class="mt kg it mk b gy my mv l mw mx">return &lt;&gt;<br/>        &lt;h1&gt;Hello World!&lt;/h1&gt;<br/>        &lt;h2&gt;{clientMessage}&lt;/h2&gt;<br/>    &lt;/&gt;<br/>}</span></pre><h1 id="9e80" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">将React应用程序与esbuild捆绑在一起</h1><p id="b3f9" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">安装esbuild</p><p id="1efc" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated"><code class="fe mh mi mj mk b">npm i --dev esbuild</code></p><p id="43e7" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">将构建脚本添加到<code class="fe mh mi mj mk b">package.json</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f971" class="mt kg it mk b gy mu mv l mw mx">{<br/>  "name": "react-ssr",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    <strong class="mk iu">"client:build": "esbuild client/src/index.tsx --bundle --outfile=built/app.js"</strong>,<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "react": "^17.0.2",<br/>    "react-dom": "^17.0.2"<br/>  },<br/>  "devDependencies": {<br/>    "esbuild": "^0.14.0",<br/>  }<br/>}</span></pre><h1 id="7817" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">创建Starter Express.js应用程序</h1><p id="26ae" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">创建一个文件夹来存放express.js应用程序</p><p id="e0ef" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated"><code class="fe mh mi mj mk b">mkdir -p server/src</code></p><p id="ddcd" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">在<code class="fe mh mi mj mk b">server/src</code>中创建名为<code class="fe mh mi mj mk b">server.tsx</code>的文件</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c9fd" class="mt kg it mk b gy mu mv l mw mx">// server.tsx<br/>import express from "express";</span><span id="dd1f" class="mt kg it mk b gy my mv l mw mx">const app = express();</span><span id="ca05" class="mt kg it mk b gy my mv l mw mx">app.get('/', (req, res) =&gt; {<br/>    const html = `<br/>        &lt;html lang="en"&gt;<br/>        &lt;head&gt;<br/>            &lt;script src="app.js" async defer&gt;&lt;/script&gt;<br/>        &lt;/head&gt;<br/>        &lt;body&gt;<br/>            &lt;div id="root"&gt;&lt;/div&gt;<br/>        &lt;/body&gt;<br/>        &lt;/html&gt;<br/>    `<br/>    res.send(html);<br/>});</span><span id="10e0" class="mt kg it mk b gy my mv l mw mx">app.use(express.static("./built"));</span><span id="34c5" class="mt kg it mk b gy my mv l mw mx">app.listen(4242);</span></pre><h1 id="d225" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">将express.js服务器与esbuild捆绑在一起</h1><p id="0ecc" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">查看<a class="ae mb" href="https://devtails.xyz/bundling-your-node-js-express-app-with-esbuild" rel="noopener ugc nofollow" target="_blank">这篇文章</a>,了解更多关于将服务器端代码与esbuild捆绑在一起的细节。</p><p id="b49b" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">将<code class="fe mh mi mj mk b">server:build</code>和<code class="fe mh mi mj mk b">start</code>脚本添加到<code class="fe mh mi mj mk b">package.json</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3c8e" class="mt kg it mk b gy mu mv l mw mx">{<br/>  "scripts": {<br/>    "client:build": "esbuild client/src/index.tsx --bundle --outfile=built/app.js",<br/>    <strong class="mk iu">"server:build": "esbuild server/src/server.tsx --bundle --outfile=built/server.js --platform=node",<br/>    "start": "node built/server.js"</strong><br/>  },<br/>}</span></pre><h1 id="9166" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">构建服务器捆绑包</h1><p id="3188" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><code class="fe mh mi mj mk b">npm run server:build</code></p><h1 id="8700" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">运行服务器</h1><p id="23a4" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><code class="fe mh mi mj mk b">npm start</code></p><p id="f0c3" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">你现在可以打开浏览器到http://localhost:4242 并看到“Hello World！”消息。</p><h1 id="d980" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">添加服务器端渲染</h1><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e43e" class="mt kg it mk b gy mu mv l mw mx">// server.tsx<br/>import express from "express";<br/>import * as ReactDOMServer from 'react-dom/server';<br/>import { App } from "../../client/src/App";</span><span id="88b6" class="mt kg it mk b gy my mv l mw mx">const app = express();</span><span id="fae7" class="mt kg it mk b gy my mv l mw mx">app.get('/', (req, res) =&gt; {<br/><strong class="mk iu">    const app = ReactDOMServer.renderToString(&lt;App /&gt;);</strong></span><span id="408e" class="mt kg it mk b gy my mv l mw mx">    const html = `<br/>        &lt;html lang="en"&gt;<br/>        &lt;head&gt;<br/>            &lt;script src="app.js" async defer&gt;&lt;/script&gt;<br/>        &lt;/head&gt;<br/>        &lt;body&gt;<br/>            &lt;div id="root"&gt;<strong class="mk iu">${app}</strong>&lt;/div&gt;<br/>        &lt;/body&gt;<br/>        &lt;/html&gt;<br/>    `<br/>    res.send(html);<br/>});</span><span id="2693" class="mt kg it mk b gy my mv l mw mx">app.use(express.static("./built"));</span><span id="01ed" class="mt kg it mk b gy my mv l mw mx">app.listen(4242);</span></pre><p id="4ddc" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">这会导入App组件，并使用<code class="fe mh mi mj mk b">react-dom/server</code>库将其呈现为一个字符串。然后，我们将呈现的字符串放在#root div中，并返回结果html。</p><p id="e084" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">用<code class="fe mh mi mj mk b">npm run server:build</code>重新构建服务器。然后用<code class="fe mh mi mj mk b">npm start</code>重启服务器。</p><p id="9eb8" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">您可以使用<code class="fe mh mi mj mk b">curl</code>通过运行<code class="fe mh mi mj mk b">curl <a class="ae mb" href="http://localhost:4242." rel="noopener ugc nofollow" target="_blank">http://localhost:4242</a></code> <a class="ae mb" href="http://localhost:4242." rel="noopener ugc nofollow" target="_blank">来确认这是否按预期工作。</a></p><p id="7021" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">您应该会看到以下输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7876" class="mt kg it mk b gy mu mv l mw mx">&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;script src="app.js" async defer&gt;&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;div id="root"&gt;&lt;h1 data-reactroot=""&gt;Hello World!&lt;/h1&gt;&lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="85ad" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">请注意，缺少“来自React的Hello”消息。这是因为<code class="fe mh mi mj mk b">renderToString</code>方法不会运行<code class="fe mh mi mj mk b">useEffect</code>逻辑。</p><p id="3fd7" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">如果我们在浏览器中刷新页面，我们应该会看到正确的<code class="fe mh mi mj mk b">clientMessage</code>。</p><h1 id="78dd" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated"><strong class="ak">从</strong><a class="ae mb" href="https://reactjs.org/docs/react-dom.html#render" rel="noopener ugc nofollow" target="_blank"><strong class="ak">react DOM . render</strong></a><strong class="ak">切换到</strong><a class="ae mb" href="https://reactjs.org/docs/react-dom.html#hydrate" rel="noopener ugc nofollow" target="_blank"><strong class="ak">react DOM . hydrate</strong></a></h1><p id="52a7" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">虽然这看起来像预期的那样工作，但是还有最后一个变化要做。服务器返回呈现的html，然后一旦加载了<code class="fe mh mi mj mk b">app.js</code>脚本，它将重新呈现整个应用程序组件并覆盖已经存在的内容。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9629" class="mt kg it mk b gy mu mv l mw mx">// index.tsx<br/>̶R̶e̶a̶c̶t̶D̶O̶M̶.̶r̶e̶n̶d̶e̶r̶(̶&lt;̶A̶p̶p̶ ̶/̶&gt;̶,̶ ̶d̶o̶c̶u̶m̶e̶n̶t̶.̶g̶e̶t̶E̶l̶e̶m̶e̶n̶t̶B̶y̶I̶d̶(̶'̶r̶o̶o̶t̶'̶)̶)̶;̶ <strong class="mk iu">ReactDOM.hydrate(&lt;App /&gt;, document.getElementById('root'));</strong></span></pre><p id="3c4f" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">通过这一更改，React将重用现有标记，并将任何事件侦听器附加到现有元素。</p><p id="3a4f" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">在我们的小例子中，这不会有太大的不同，但是在一个大的应用程序中，这可以节省大量的重新渲染。</p><h1 id="2352" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">总结</h1><p id="034d" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">恭喜你！现在，您有了一个具有服务器端呈现的react应用程序。根据我的经验，从服务器端渲染开始比事后实现要容易得多。现在您已经了解了它背后的基础，您应该能够将这些原则应用到现有的React应用程序中。</p><h1 id="1c25" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">额外资源</h1><p id="08cb" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><a class="ae mb" href="https://www.digitalocean.com/community/tutorials/react-server-side-rendering" rel="noopener ugc nofollow" target="_blank">https://www . digital ocean . com/community/tutorials/react-server-side-rendering</a></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="9202" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated"><em class="ng">原载于2021年11月28日</em><a class="ae mb" href="https://devtails.xyz/how-to-set-up-server-side-rendering-ssr-with-react-and-esbuild" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://devtails . XYZ</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>