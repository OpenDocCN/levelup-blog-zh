<html>
<head>
<title>A COVID-19 Dashboard in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一辆新冠肺炎仪表盘在反应</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-covid-19-dashboard-in-react-766cc5217a84?source=collection_archive---------5-----------------------#2020-04-29">https://levelup.gitconnected.com/a-covid-19-dashboard-in-react-766cc5217a84?source=collection_archive---------5-----------------------#2020-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/21033b764a08571e0a9bc655944c8c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jeetk1Jhrroc6_-NRmnUjA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">完全可配置的带动画的仪表盘</strong></figcaption></figure><p id="0caf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">软件开发每年都变得越来越容易。我们站在巨人的肩膀上。不仅仅是脸书、谷歌和亚马逊，还有许多小公司和个人创造了“酷”和有用的拼图。简而言之，构建软件又变得有趣了，因为你可以利用之前的东西，只关注手头的问题。</p><p id="5476" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在新冠肺炎疫情期间，有了额外的时间，我开始编写一个仪表板，让我可以定制一切，从城市和国家到呈现的数据类型，甚至是布局。我痴迷于疫情数据，并希望有一个工具能够轻松地创建图表和图形，以分享或说明要点。我从未见过如此灵活的仪表板，所以这是我创建自己的仪表板的借口:</p><p id="5326" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">https://www.cdash19.com<a class="ae lb" href="https://www.cdash19.com" rel="noopener ugc nofollow" target="_blank"/></p><p id="3a64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是<a class="ae lb" href="https://github.com/selsamman/JHU-COVID-Dashboard" rel="noopener ugc nofollow" target="_blank">开源的</a>，由亚马逊S3托管，使用他们的Cloudfront CDN发布。每天都有一个Lambda作业运行，从github 上的Johns Hopkins大学<a class="ae lb" href="https://github.com/CSSEGISandData/COVID-19" rel="noopener ugc nofollow" target="_blank"> repo中提取新数据。这个应用程序只有500MB(传输大小),包括世界上所有国家的数据和美国的县级数据。最初的版本在几周内就已经完成并运行了。</a></p><p id="9c73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我是一名退休的科技企业家，也是<a class="ae lb" href="https://havenlife.com/home" rel="noopener ugc nofollow" target="_blank">天堂生活</a>的联合创始人。我从穿孔卡片和汇编语言开始。对我来说，最有趣的事情是创建和分发应用程序的过程。我惊讶地发现它比预期的要顺利得多。它让我在困难时期保持理智。</p><h2 id="fa6d" class="lc ld iq bd kc le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">react——我的新宠网络平台</h2><p id="413b" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">React是我用来构建单页面web应用程序的效率最高的平台之一。奇怪的是，我是通过编写一个react-native应用程序接触到它的，这个应用程序的主要吸引力在于拥有一个苹果和安卓的单一来源。在这个过程中，我开始爱上React本身简洁明了的结构，但我从未用它编写过web应用程序。</p><p id="daa0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">react for web远比react-native成熟。它有一个非常深厚的现成组件和库生态系统，可以满足您的任何需求。我选择了<a class="ae lb" href="https://react-bootstrap.github.io/" rel="noopener ugc nofollow" target="_blank"> react-bootstrap </a>作为布局，选择了非常丰富的<a class="ae lb" href="https://formidable.com/open-source/victory/" rel="noopener ugc nofollow" target="_blank">胜利图表</a>作为图形，同时选择了大量其他库来满足特定需求。</p><p id="6ee6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管React的组件结构很棒，但管理状态可能是一件痛苦的事情，而且很容易花费太多时间。有太多的方法可以做到这一点，并且都涉及到大量非生产性的锅炉板代码。这是我用今年早些时候介绍的redux-capi状态管理库编写的第一个web应用程序。这使得管理状态不再是问题。稍后会详细介绍。</p><h2 id="35e7" class="lc ld iq bd kc le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">创建-反应-应用</h2><p id="cbac" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">React是一个复杂的堆栈，当你考虑打包一个transpiled应用程序和用你心血来潮随便导入的所有库打包它所涉及的一切时。<a class="ae lb" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> create-react-app </strong> </a>消除了这种复杂性，并提供了一个可供部署的紧凑包。</p><p id="902a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你付出的代价是它是现成的，所以配置相当有限。我没有遇到需要定制配置的案例。然而，如果你不能胜任，那么“弹出”会给你一个普通的React应用程序。</p><p id="27a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要node <a class="ae lb" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node JS </a> (8.10以上)和<a class="ae lb" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a> (5以上)。之后，您可以使用<a class="ae lb" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank">纱线</a>或npm进行包装管理。使用以下命令创建您的网站并在浏览器中启动它进行测试:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="1d66" class="lc ld iq me b gy mi mj l mk ml">npx create-react-app website<br/>cd website<br/>yarn start</span></pre><h2 id="bdd1" class="lc ld iq bd kc le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">无服务器</h2><p id="bc7e" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">部署应用程序有很多选择。事实上，几乎太多，决定可以令人望而生畏。在过去，我总是在云中建立一个服务器来开始，后来随着需求的增长，我后悔了。有时候，在开始之前知道你会在哪里结束会有所帮助。</p><p id="618e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这个站点是静态的(没有服务器组件),所以最简单、最健壮和可伸缩的方法就是不使用服务器。亚马逊是合乎逻辑的选择，因为我有一个账户，并且对它比较熟悉。微软Azure和Heroku也是选项。</p><p id="77f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">亚马逊网络服务(AWS)有一个陡峭的学习曲线，不适合胆小的人。进入<a class="ae lb" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>部署平台，消除部署应用和服务的所有困难。在几分钟内，您可以将一个静态站点部署到S3(云存储)，并通过他们的CloudFront (CDN)进行分发。如果您需要一个API，或者在我的情况下需要一个定期运行的数据获取脚本，Lambda (Javascript on demand)很容易满足您的需求，并且同样易于部署到无服务器环境中。</p><p id="349e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过以下方式全局安装它:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="1111" class="lc ld iq me b gy mi mj l mk ml">npm install -g serverless</span></pre><p id="67db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在向刚刚创建的react项目添加一个serverless.yml文件。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="dba1" class="lc ld iq me b gy mi mj l mk ml"><strong class="me ir">component</strong>: website<br/><strong class="me ir">name</strong>: myapp<br/><strong class="me ir">stage</strong>: dev<br/><br/><strong class="me ir">inputs</strong>:<br/>  <strong class="me ir">src</strong>:<br/>    <strong class="me ir">src</strong>: ./src<br/>    <strong class="me ir">hook</strong>: npm run build<br/>    <strong class="me ir">dist</strong>: ./build</span></pre><p id="68f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将应用程序部署到AWS，您需要注册AWS并获取您的凭据。在准备好之前，您可以跳过以下几个步骤:</p><p id="6e59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在服务下的AWS中，找到IAM控制面板。点击<strong class="kf ir">用户</strong>，然后<strong class="kf ir">添加用户</strong>创建新用户。给它起个名字(比如<strong class="kf ir">网站部署</strong>)并检查<strong class="kf ir">编程访问，</strong>当你点击<strong class="kf ir">下一步，s </strong>选择<strong class="kf ir">直接附加现有策略</strong>并检查<strong class="kf ir">管理员访问</strong>。点击<strong class="kf ir">下一步</strong>两次，在标签屏幕上点击<strong class="kf ir">创建</strong>。再次点击“下一步”跳过标签屏幕，然后点击“创建”。假设您的计算机是安全的，并且您对在其上保存重要凭证感到满意，请将<strong class="kf ir">访问密钥ID </strong>和<strong class="kf ir">秘密访问密钥</strong>复制并粘贴到<strong class="kf ir">中。刚刚创建的<strong class="kf ir">部署</strong>目录中的env </strong>文件:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="acc9" class="lc ld iq me b gy mi mj l mk ml">AWS_ACCESS_KEY_ID=<strong class="me ir"><em class="mm">access key id you just copied<br/></em></strong>AWS_SECRET_ACCESS_KEY=<strong class="me ir"><em class="mm">secret access key you just copied</em></strong></span></pre><p id="4026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">一定要补充。env到你的。gitignore文件！</strong></p><p id="026e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成您的秘密解码器环后，您现在可以使用一个命令部署到AWS:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="11e9" class="lc ld iq me b gy mi mj l mk ml">serverless deploy</span></pre><p id="8634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">旋转一会儿后，你会看到:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2952" class="lc ld iq me b gy mi mj l mk ml">serverless ⚡ framework<br/>Action: "deploy" - Stage: "dev" - App: "myapp" - Instance: "myapp"<br/><strong class="me ir">bucket: </strong>   website-xxxxx<br/><strong class="me ir">bucketUrl: </strong><a class="ae lb" href="http://website-jalrrb.s3-website.us-east-1.amazonaws.com" rel="noopener ugc nofollow" target="_blank">http://website-xxxxx.s3-website.us-east-1.amazonaws.com</a><br/><strong class="me ir">url: </strong>      <a class="ae lb" href="https://d1ys16qyo55heg.cloudfront.net" rel="noopener ugc nofollow" target="_blank">https://xxxxx.cloudfront.net</a><br/>75s › myapp › Success</span></pre><p id="59df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。等待一分钟左右，让它传播，并转到网址，看看你的网站部署。想给它一个域名，用亚马逊免费SSL证书？只需在AWS Route 53上注册它，将其添加到YML文件中，然后再进行一次部署。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="fc41" class="lc ld iq me b gy mi mj l mk ml"><strong class="me ir">inputs</strong>:<br/>  <strong class="me ir">src</strong>:<br/>    <strong class="me ir">src</strong>: ./src<br/>    <strong class="me ir">hook</strong>: npm run build<br/>    <strong class="me ir">dist</strong>: ./build<br/>  <strong class="me ir">domain</strong>: mydomain.com</span></pre><p id="0541" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您在世界一流的基础架构上拥有了一个自定义域。最棒的是成本很低。很长一段时间内，免费层可能什么都没有。然而，我已经过了那个阶段，我估计主机服务将花费大约5美元/百万次访问。</p><h2 id="0c41" class="lc ld iq bd kc le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">React中的状态管理</h2><p id="a52b" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">从现在开始，我的假设是您至少已经涉足React。如果没有，并且你有基本的HTML和Javascript ES 6技能，React并不难学。</p><p id="bac3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于React引入了功能组件，过去占据屏幕空间的许多样板代码都消失了。现在你有了一个漂亮整洁的无类组件，像这样的组件可以让你选择你想在图表中包含的数据属性:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="af62" class="lc ld iq me b gy mi mj l mk ml"><strong class="me ir">export default </strong>({id, dataPoints, max, scale}) =&gt; {</span><span id="c5f9" class="lc ld iq me b gy mn mj l mk ml">    <strong class="me ir">const </strong>{widget, addPropToWidget, deletePropFromWidget} =<br/>        <strong class="me ir"><em class="mm">widgetsAPI</em></strong>({<strong class="me ir">id</strong>: id});</span><span id="f037" class="lc ld iq me b gy mn mj l mk ml">    <strong class="me ir">const </strong>onChange = prop =&gt; widget.<strong class="me ir">props</strong>.includes(prop) <br/>        ? deletePropFromWidget(prop) : addPropToWidget(prop);</span><span id="bb8f" class="lc ld iq me b gy mn mj l mk ml">    <strong class="me ir">const </strong>isDisabled = prop =&gt; <br/>        widget.<strong class="me ir">props</strong>.<strong class="me ir">length </strong>&gt;= max &amp;&amp; !widget.<strong class="me ir">props</strong>.includes(prop);</span><span id="b066" class="lc ld iq me b gy mn mj l mk ml">    <strong class="me ir">return </strong>(  // What is rendered for each widget<br/>        &lt;<strong class="me ir">Form</strong>&gt;<br/>            &lt;<strong class="me ir">Form.Row</strong>&gt;<br/>                {<strong class="me ir"><em class="mm">Object</em></strong>.getOwnPropertyNames(dataPoints).map(prop=&gt; (<br/>                    &lt;<strong class="me ir">Form.Group as=</strong>{Col} <strong class="me ir">key=</strong>{prop}&gt;<br/>                        &lt;<strong class="me ir">Form.Check<br/>                            style=</strong>{{<strong class="me ir">fontSize</strong>: 11 * scale}}<br/>                            <strong class="me ir">onChange=</strong>{()=&gt;onChange(prop)}<br/>                            <strong class="me ir">label=</strong>{dataPoints[prop]}<br/>                            <strong class="me ir">disabled=</strong>{isDisabled(prop)}<br/>                            <strong class="me ir">checked=</strong>{widget.<strong class="me ir">props</strong>.includes(prop)}<br/>                        /&gt;<br/>                    &lt;/<strong class="me ir">Form.Group</strong>&gt;<br/>                ))}<br/>            &lt;/<strong class="me ir">Form.Row</strong>&gt;<br/>        &lt;/<strong class="me ir">Form</strong>&gt;<br/>    )<br/>};</span></pre><p id="092c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向该组件传递小部件(图形或图表)的<strong class="kf ir"> id </strong>，该小部件将在其属性中呈现一些其他配置细节。它使用<strong class="kf ir"> widgetAPI </strong>从redux store获得它需要的一切，widgetAPI是一个用redux-capi构建的API。组件和redux之间的API接口。</p><p id="a16d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">状态管理有其他选择，比如MobX和GraphQL，但是redux仍然是处理React的不变性需求的标准。redux-capi只是让redux更容易处理。它可以自动创建常见的redux元素——动作、选择器和thunks。</p><p id="b578" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里提供了<strong class="kf ir"> widget </strong>(一个选择器in)以及<strong class="kf ir"> addPropToWidget </strong>和<strong class="kf ir"> deletePropFromWidget </strong>(自调度动作)。组件逻辑就是表示。在这种情况下，只需将可以包含在小部件中的数据属性映射到屏幕上的复选框中。当您选中或取消选中该框时，它们会被添加到redux中的widget <strong class="kf ir"> props </strong>数组中，或者从其中删除，这两个动作都是自调度的。</p><p id="56cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么你必须为每个动作写的那些丑陋的缩减器在哪里呢？没有了。使用redux-capi，您可以创建一个声明性的描述，描述动作<strong class="kf ir"> </strong>如何影响您的状态形状，redux-capi会为您进行简化。</p><p id="b908" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">状态形状如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="430c" class="lc ld iq me b gy mi mj l mk ml">widgets: [<br/>   {id: 1, props["deaths", "cases"]}<br/>   {id: 2, props["cases"]}<br/>]</span></pre><p id="02ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些声明在redux-capi中称为<strong class="kf ir"> addPropToWidget </strong>和<strong class="kf ir">deletepropfromwidg</strong>的“修订”,描述了如何导航到正确的<strong class="kf ir"> widget </strong>数组元素，以及在<strong class="kf ir">deletepropfromwidg</strong>的情况下如何导航到右边的<strong class="kf ir"> props </strong>数组元素<strong class="kf ir">。</strong></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="dff8" class="lc ld iq me b gy mi mj l mk ml">addPropToWidget: (prop) =&gt; ({<br/>    <strong class="me ir">widgets</strong>: {<br/>        where: (state, item, ix, {id}) =&gt; item.<strong class="me ir">id </strong>=== id,<br/>        <strong class="me ir">select</strong>: {<br/>            <strong class="me ir">props</strong>: {<br/>                append: () =&gt; prop<br/>            }<br/>        }<br/>    }<br/>}),</span><span id="3e67" class="lc ld iq me b gy mn mj l mk ml">deletePropFromWidget: (prop) =&gt; ({<br/>    <strong class="me ir">widgets</strong>: {<br/>        where: (state, item, ix, {id}) =&gt; item.<strong class="me ir">id </strong>=== id,<br/>        <strong class="me ir">select</strong>: {<br/>            <strong class="me ir">props</strong>: {<br/>                where: (state, item) =&gt; item === prop,<br/>                <strong class="me ir">delete</strong>: <strong class="me ir">true<br/>            </strong>}<br/>        }<br/>    }<br/>}),</span></pre><p id="18ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最高级别的函数是您的操作的模板，您可以声明操作将需要的参数。它返回一个状态如何变化的“模式”,该模式将被传递给redux-capi中的主缩减器。</p><p id="8134" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，状态中的<strong class="kf ir"> widgets </strong>属性将受到影响，更具体地说是实例<strong class="kf ir">，其中</strong>id与上下文中的<strong class="kf ir"> id </strong>相匹配。语境？什么背景？每次您在组件中使用<strong class="kf ir"> widgetsAPI </strong>时，您都为该组件的实例建立了一个上下文。屏幕上有许多小部件，每个小部件都可以连接到不同的小部件实例。然而，每个组件实例只连接到一个小部件，当调用<strong class="kf ir"> widgetsAPI </strong>时，它将id传递给上下文</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c945" class="lc ld iq me b gy mi mj l mk ml"><strong class="me ir">const </strong>{widget, addPropToWidget, deletePropFromWidget} =<br/>          <strong class="me ir"><em class="mm">widgetsAPI</em></strong>({<strong class="me ir">id</strong>: id});</span></pre><p id="eae8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上下文也用在小部件选择器中，其定义如下:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6865" class="lc ld iq me b gy mi mj l mk ml">widget: [<br/>    (select, {widgets, id}) =&gt; select(widgets, id),<br/>    (widgets, id) =&gt; widgets.find(w =&gt; (w.<strong class="me ir">id </strong>=== id))<br/>],</span></pre><p id="eb24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择器具有内置的记忆功能，因此除非底层值发生变化，否则不会重新计算。这里，选择器依赖于小部件的集合(由另一个选择器调用<strong class="kf ir">小部件</strong>和<strong class="kf ir"> id </strong>定义)(在上下文中)。如果任何一个发生变化，第二个函数将被调用来重新计算值，并作为参数传入这些属性。</p><p id="18fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一些thunk与redux thunks没有太大的不同，只是它们可以访问特定于实例的数据的上下文，如id以及该API中的所有其他thunk和选择器。随着API的增长，它可以很容易地被组合和拆分成更小的部分，因为它几乎没有外部依赖性，并从上下文中获得它所需要的大部分内容。</p><h2 id="b60f" class="lc ld iq bd kc le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">动画世界地图</h2><p id="0c50" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有没有去过一个技术会议，会上一个枯燥的主题，比如闭包优化，演讲者使用了一个很酷的CSS动画，所有的问题都是关于动画而不是闭包的？如果我不谈世界地图动画，那我就失职了。</p><p id="fc9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单地图公司的人有一张SVG世界地图，他们慷慨地免费授权。然而，React不能很好地处理复杂的SVG，因为我们知道JSX并不完全是HTML。好消息是，在最新版本中，他们实现了一种将SVG作为组件导入的方法。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="76ed" class="lc ld iq me b gy mi mj l mk ml"><strong class="me ir">import </strong>{ReactComponent <strong class="me ir">as </strong>World} <strong class="me ir">from "./world.svg"</strong>;</span></pre><p id="b791" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，create-react-app被配置为不接受world.svg使用的名称空间标签。在https://jakearchibald.github.io/svgomg/<a class="ae lb" href="https://jakearchibald.github.io/svgomg/" rel="noopener ugc nofollow" target="_blank">用这个漂亮的工具运行之后，所有的名称空间标签都被移除了，SVG也得到了优化。</a></p><p id="02b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要通过CSS独立设置每个国家的颜色。SVG为每个县使用一个唯一的data-id，因此编辑SVG源代码并进行搜索/替换以将data-id=更改为id=是一件很简单的事情。现在可以应用CSS规则了。</p><p id="3787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，CSS是静态的，我们希望根据特定国家的数据来改变颜色，并随着时间的推移来制作动画。样式组件包非常适合这种情况。它允许你从一个字符串中获取一个组件并对其应用样式。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="149c" class="lc ld iq me b gy mi mj l mk ml"><strong class="me ir">import </strong><em class="mm">styled</em>, {<em class="mm">keyframes</em>, <em class="mm">css</em>} <strong class="me ir">from 'styled-components'</strong></span></pre><p id="0de7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，您需要计算将具有动画的样式字符串:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="1a94" class="lc ld iq me b gy mi mj l mk ml"><strong class="me ir">function </strong>getStyledWorldAnimated (cols, countries, dataPoint, mode) {</span><span id="1953" class="lc ld iq me b gy mn mj l mk ml">    <strong class="me ir">const </strong>styles = countries<br/>          .filter(c =&gt; c &amp;&amp; c.<strong class="me ir">type </strong>=== <strong class="me ir">'country'</strong>)<br/>          .map( data =&gt; {</span><span id="7943" class="lc ld iq me b gy mn mj l mk ml">        <strong class="me ir">const </strong>range = data[dataPoint];<br/>        <strong class="me ir">const </strong>last = data[dataPoint][range.<strong class="me ir">length </strong>- 1] || 0;<br/>        <strong class="me ir">const </strong>fade = range.map((m, i) =&gt; m &gt; 0 &amp;&amp; <br/>              (i === 0 || range[i - 1] !== m) <br/>              ? <strong class="me ir">`</strong>${i * (i)/range.<strong class="me ir">length</strong>}<strong class="me ir">% \{fill: </strong>${colors[m]}<strong class="me ir">\};`<br/>              </strong>: <strong class="me ir">""</strong>)<br/>        <strong class="me ir">const </strong>animation = <em class="mm">keyframes</em><strong class="me ir">`</strong>${fade}<strong class="me ir">`</strong>;<br/>        <strong class="me ir">return </strong>(<em class="mm">css</em><strong class="me ir">`#</strong>${data.<strong class="me ir">code</strong>} <strong class="me ir">\{fill: </strong>${colors[last]}<strong class="me ir">;<br/>           animation: </strong>${animation}<strong class="me ir"> 1 </strong>${animationTime}<strong class="me ir">s forwards\};`</strong>)</span><span id="1531" class="lc ld iq me b gy mn mj l mk ml">    });<br/><br/>    <strong class="me ir">return </strong>(<em class="mm">styled</em>(World)<strong class="me ir">`</strong>${getSizeStyle(cols, mode)}${styles} <strong class="me ir">`</strong>);<br/>};</span></pre><p id="bf4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">动画的核心是将样式规则映射到每个日期的基于百分比的<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes" rel="noopener ugc nofollow" target="_blank">关键帧</a>的代码:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8c5f" class="lc ld iq me b gy mi mj l mk ml"><strong class="me ir">const </strong>fade = range.map((m, i) =&gt; m &gt; 0 &amp;&amp; <br/>              (i === 0 || range[i - 1] !== m) <br/>              ? <strong class="me ir">`</strong>${i * (i)/range.<strong class="me ir">length</strong>}<strong class="me ir">% \{fill: </strong>${colors[m]}<strong class="me ir">\};`<br/>              </strong>: <strong class="me ir">""</strong>)<br/><strong class="me ir">const </strong>animation = <em class="mm">keyframes</em><strong class="me ir">`</strong>${fade}<strong class="me ir">`</strong>;</span></pre><p id="87c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码贯穿值的范围，优化那些不改变值的值，并产生类似“6.2% {fill: #447766}”的关键帧。关键帧被传递给<strong class="kf ir">关键帧</strong>辅助对象，您就有了一个动画。然后，这个动画通过<strong class="kf ir"> css </strong>助手运行，为每个国家生成一个动画规则。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="91b2" class="lc ld iq me b gy mi mj l mk ml"><strong class="me ir">return </strong>(<em class="mm">css</em><strong class="me ir">`#</strong>${data.<strong class="me ir">code</strong>} <strong class="me ir">\{fill: </strong>${colors[last]}<strong class="me ir">;<br/>           animation: </strong>${animation}<strong class="me ir"> 1 </strong>${animationTime}<strong class="me ir">s forwards\};`</strong>)</span></pre><p id="ee33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，将每个国家的所有css动画收集到一个数组中，然后将它们和从SVG导入的<strong class="kf ir">世界</strong>组件一起传递给<strong class="kf ir">style</strong>。您最终得到一个将被绑定到动画规则的组件。在后台，它会在运行时动态添加所有的CSS样式，并且只将一个类附加到您的组件上。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7e43" class="lc ld iq me b gy mi mj l mk ml"><strong class="me ir">return </strong>(<em class="mm">styled</em>(World)<strong class="me ir">`<br/>      width: 100%;<br/>      height: auto;<br/>      </strong>${styles} <strong class="me ir">`</strong>);</span></pre><p id="dba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，使用宽度100%的SVGs将无法在IE11中正确缩放(尽管它确实适用于Edge)。胜利图表也不会。人生苦短。</p><h2 id="063a" class="lc ld iq bd kc le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="291d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">建立一个简单的单页应用程序比以前容易多了。大规模应用程序在选择平台时有许多其他考虑因素，在真正大量的情况下，无服务器解决方案可能实际上成本更高，但对于小型非关键任务网站，您现在可以使用<strong class="kf ir"> create-react-app </strong>和<strong class="kf ir">无服务器</strong>等工具获得巨大的回报。快乐计算！</p></div></div>    
</body>
</html>