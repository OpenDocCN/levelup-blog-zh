<html>
<head>
<title>Writing a TypeScript Custom AST Transformer (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写类型脚本定制AST转换器(第3部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-typescript-custom-ast-transformer-part-3-93b6238ae21f?source=collection_archive---------1-----------------------#2019-08-20">https://levelup.gitconnected.com/writing-typescript-custom-ast-transformer-part-3-93b6238ae21f?source=collection_archive---------1-----------------------#2019-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7556cd8d92deddb9b9318752e6419ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qD3XTwpaTemydFrC2j0sfQ.jpeg"/></div></div></figure><div class=""/><p id="8dbf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是第二部分的延续，也是对我在编写变形金刚时使用的一些先进技术的深入探究。</p><h1 id="e682" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">非TS进口</h1><p id="0d95" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">非TS导入允许我声明对静态资源的显式依赖，如CSS/png/svg、其他非JS文件，甚至外部构建工具链。这在处理大型代码库时很重要，因为当dep图中有任何变化时，跟踪依赖链和重构会更容易。</p><p id="9489" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我写<a class="ae kw" href="https://github.com/longlho/ts-transform-css-modules" rel="noopener ugc nofollow" target="_blank">https://github.com/longlho/ts-transform-css-modules</a>的首要原因</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">CSS模块AST变压器</figcaption></figure><p id="5fb3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">流程相当简单，每当我们遇到一个<code class="fe mk ml mm mn b">import</code>节点，它的<code class="fe mk ml mm mn b">moduleSpecifier</code>以<code class="fe mk ml mm mn b">.css</code>结尾，我们就试图将该节点转换成一个<code class="fe mk ml mm mn b">const foo = {className: '1nahjk'}</code>散列。</p><p id="069c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的是，这允许您内联运行PostCSS构建管道，只要它是<a class="ae kw" href="https://medium.com/@longho/the-postcss-ecosystem-issue-b549c47b1a9" rel="noopener">同步的</a>。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="6905" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还建议在sourcemap中引用外部CSS源代码，以便devtools可以相应地下载它。</p><h1 id="a3d3" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">编译器宏</h1><p id="0c7f" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">编译器宏是传统编译器中相当常见的概念。在巴别塔世界中，<a class="ae kw" href="https://github.com/kentcdodds/babel-plugin-macros" rel="noopener ugc nofollow" target="_blank">巴别塔插件宏</a>很好地引入了这个概念。这允许你做一些事情，比如标记一段特定的代码用于提取，预评估内联脚本，嵌入编译时变量等等。</p><p id="9f51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从我的角度来看，<code class="fe mk ml mm mn b">import</code>可以被视为某种编译器宏，在这里导入的资源可以得到不同的处理。另一个常见的例子是i18n的字符串提取，类似于<a class="ae kw" href="https://github.com/longlho/ts-transform-react-intl" rel="noopener ugc nofollow" target="_blank">https://github.com/longlho/ts-transform-react-intl</a></p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ded2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次遇到从<code class="fe mk ml mm mn b">ts-transform-react-intl</code>导入的<code class="fe mk ml mm mn b">_</code>符号，我都会将参数标记为<code class="fe mk ml mm mn b">MessageDescriptor</code>并提取它们进行翻译。转换后的代码变成:</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="2148" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个过程中，我们还可以针对格式中声明的ICU语法运行linter，以捕捉无效语法、表情符号、供应商限制等等。</p><h1 id="3b97" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">利用类型检查器</h1><p id="31f8" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">检查<code class="fe mk ml mm mn b">import</code>语句中的<code class="fe mk ml mm mn b">_</code>可能不准确，尤其是当涉及到别名:<code class="fe mk ml mm mn b">import {_ as _d} from 'ts-transform-react-intl'</code></p><p id="59cb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，TypeChecker API允许access解析别名<code class="fe mk ml mm mn b">typeChecker.getAliasedSymbol</code>和各种其他API，这些API在将符号和类型连接在一起时变得非常方便。这肯定比estree之类的基于AST的解析器强大得多。</p><h1 id="b7bc" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">范围修改/注入</h1><p id="0873" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">虽然inline mod非常方便，但在某些情况下，您可以优化代码，比如将变量提升到范围之外。虽然这可以在源代码中手动完成，但在开发和代码审查过程中肯定会耗费大量精力，而提取const React元素之类的事情可以自动完成:<a class="ae kw" href="https://github.com/dropbox/ts-transform-react-constant-elements" rel="noopener ugc nofollow" target="_blank">https://github . com/Dropbox/ts-transform-React-constant-elements</a></p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="bde8" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">一般流程</h1><h2 id="3e39" class="mo ky jb bd kz mp mq dn ld mr ms dp lh kj mt mu ll kn mv mw lp kr mx my lt mz bi translated">找到正确的词汇环境(范围)</h2><p id="b3fd" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><code class="fe mk ml mm mn b">ctx.startLexicalEnvironment</code>:在堆栈中添加一个词法环境来存储区域设置变量/函数声明</p><p id="8212" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mk ml mm mn b">ctx.suspendLexicalEnvironment</code>和<code class="fe mk ml mm mn b">ctx.resumeLexicalEnvironment</code>:通常在访问参数列表时，阻止创建新的作用域。</p><p id="abb6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mk ml mm mn b">ctx.endLexicalEnvironment</code>:弹出堆栈。</p><p id="ac12" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mk ml mm mn b">ctx.hoistVariableDeclaration</code>:在堆栈中记录当前词法环境中的一个变量。</p><p id="fd96" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，一个新的作用域经常被创建，因此对它在哪里被提升的控制很少(例如，进入一个函数体创建了一个作用域，而提升只写入堆栈中的当前作用域，所以对提升没有控制)。</p><p id="86c8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的用例中，注入到顶部完全没问题。</p><h2 id="5a3c" class="mo ky jb bd kz mp mq dn ld mr ms dp lh kj mt mu ll kn mv mw lp kr mx my lt mz bi translated">查找顶部节点以注入此变量</h2><p id="e7ea" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><code class="fe mk ml mm mn b">#!/env/node</code>:低于shebang(不在规格中，可能在Esprima中被淘汰)</p><p id="fea6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mk ml mm mn b">"use strict";</code>:在序言指令下面(例如:“使用严格指令”)</p><p id="9efe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mk ml mm mn b">// ts-lint:disable</code>:低于顶级注释</p><p id="91a6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mk ml mm mn b">import * as React from 'react';</code>:下面导入React</p><h2 id="db81" class="mo ky jb bd kz mp mq dn ld mr ms dp lh kj mt mu ll kn mv mw lp kr mx my lt mz bi translated">查找常量元素</h2><p id="d2d2" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">因为我们不能遍历备份，我们必须完全遍历树，过滤掉具有不可变属性的节点并收集它们</p><h2 id="87b5" class="mo ky jb bd kz mp mq dn ld mr ms dp lh kj mt mu ll kn mv mw lp kr mx my lt mz bi translated">改变</h2><p id="5af7" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在收集了这些节点之后，我们必须使用<code class="fe mk ml mm mn b">ts.createUniqueName(prefix)</code>将它们转换成预声明的变量名。</p><p id="48cd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们可以通过添加<code class="fe mk ml mm mn b">[reactNode, …hoistedVarStatements]</code>在top React导入节点之后追加。最后，进行另一次遍历，用之前创建的变量替换那些<code class="fe mk ml mm mn b">ReactElement</code>。</p><h1 id="bf32" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">管道链接</h1><p id="1d58" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">您甚至可以链接这些AST变压器，如下例所示:</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="e8e7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你们能学到新东西！我在这个过程中学到了很多，包括阅读规范和深入生态系统中的其他构建管道。</p></div></div>    
</body>
</html>