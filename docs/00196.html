<html>
<head>
<title>Deploying SSL enabled applications to AWS using Lets Encrypt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Lets Encrypt将支持SSL的应用程序部署到AWS</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploying-ssl-enabled-react-angular-vue-applications-to-aws-using-lets-encrypt-a7aff5a417ee?source=collection_archive---------0-----------------------#2018-08-24">https://levelup.gitconnected.com/deploying-ssl-enabled-react-angular-vue-applications-to-aws-using-lets-encrypt-a7aff5a417ee?source=collection_archive---------0-----------------------#2018-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bbf5ba41aa05d6f11b04d1b3fe4a7d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0uXgWw81-8rZUMW8lv2Sg.png"/></div></div></figure><p id="679b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上一篇文章的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/deploying-your-ui-applications-using-docker-and-nginx-b65ffa8f744e">中，我们看到了如何使用<code class="fe kx ky kz la b">nginx</code>和<code class="fe kx ky kz la b">docker</code>部署一个简单的React(或任何UI)应用程序。在本文中，我们将更进一步，使用加密为我们的域生成一个SSL证书，然后将<code class="fe kx ky kz la b">dockerized</code>应用程序部署到</a><a class="ae kw" href="http://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>。为此，我们将从<a class="ae kw" href="http://godaddy.com/" rel="noopener ugc nofollow" target="_blank"> GoDaddy </a>购买、配置和设置一个自定义域名，然后使用<a class="ae kw" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">提供的SSL证书部署我们的应用程序，让我们加密</a>。</p><p id="58e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那确实是满嘴的。在继续之前，我们将把它分解成易于实施和理解的小步骤。我绝不是DNS和SSL/TLS加密领域的专家，所以在我们浏览这些步骤时，我会提供额外的材料。</p><h1 id="4c84" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">先决条件</h1><ol class=""><li id="5f3e" class="lz ma iq ka b kb mb kf mc kj md kn me kr mf kv mg mh mi mj bi translated">对AWS的基本了解</li><li id="fdc0" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">极好的账目</li><li id="25d0" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">机器上安装的Docker</li></ol><h1 id="fced" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">目录</h1><ol class=""><li id="ece4" class="lz ma iq ka b kb mb kf mc kj md kn me kr mf kv mg mh mi mj bi translated">构建我们的静态网站</li><li id="4e84" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">在GoDaddy上购买域名</li><li id="e522" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">在AWS上创建托管区域</li><li id="f3ad" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">更新GoDaddy名称服务器</li><li id="7525" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">运行让我们加密docker图像</li><li id="25ec" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">正在执行DNS质询</li><li id="1027" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">配置NGINX</li><li id="5a02" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">创建Dockerfile文件</li><li id="3799" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">使用<code class="fe kx ky kz la b">docker-machine</code>推送图像</li><li id="372f" class="lz ma iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">更新托管区域上的<code class="fe kx ky kz la b">A</code>记录</li></ol><p id="2d94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管这些步骤看起来令人望而生畏。不要担心，它们很容易理解，你自己就可以完成。让我们开始吧。</p><p id="64ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>本文的主要目标是生成SSL证书并使用它。使用docker-machine将应用程序部署到AWS只是几个选项之一。部署静态应用程序可能有更合适和更受欢迎的方式(比如使用cloudfront urls的S3桶)。本文并不涵盖部署的最佳方式，而只是其中一种可能性。</p><h2 id="6341" class="mp lc iq bd ld mq mr dn lh ms mt dp ll kj mu mv lp kn mw mx lt kr my mz lx na bi translated">步骤1:构建我们的静态网站</h2><p id="2949" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">因为这不是我们试图实现的关键步骤，我们可以跳过这一步，创建一个精益应用程序。我们可以使用<code class="fe kx ky kz la b">create-react-app</code>来创建这个示例应用程序。</p><pre class="ne nf ng nh gt ni la nj nk aw nl bi"><span id="67d3" class="mp lc iq la b gy nm nn l no np">create-react-app kashyapapp</span><span id="f2ec" class="mp lc iq la b gy nq nn l no np">cd kashyapapp</span><span id="4918" class="mp lc iq la b gy nq nn l no np">yarn start</span></pre><p id="bf96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建应用程序后，我们只需将所有锅炉板代码替换为我们的占位符版本，如下所示:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7fb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。在这一点上，我们不太关心应用程序的样式，所以当我们有更多信息时，我们可以重新访问它。</p><h2 id="17fa" class="mp lc iq bd ld mq mr dn lh ms mt dp ll kj mu mv lp kn mw mx lt kr my mz lx na bi translated">第二步:在GoDaddy上购买域名</h2><p id="813f" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">从技术上讲，我们可以从任何一家<a class="ae kw" href="https://en.wikipedia.org/wiki/Domain_name_registrar" rel="noopener ugc nofollow" target="_blank">域名注册商</a>那里购买域名。在这种情况下，我们将通过<a class="ae kw" href="https://www.godaddy.com/domains/domain-name-search" rel="noopener ugc nofollow" target="_blank"> GoDaddy </a>购买我们的域名。</p><p id="ca5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们搜索并购买了我们选择的域，我们需要通过进入DNS设置(也可以从主菜单中的管理域选项访问)来编辑该域的DNS配置。在所有可用的设置中，我们现在只关心域名服务器。</p><p id="3592" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">名称服务器是一种反向地址查找，当用户请求一个网站时，浏览器会执行该操作。当我们在浏览器中请求<code class="fe kx ky kz la b">kashyap.app</code>时，浏览器首先使用DNS检索与域名相关的当前域名服务器，然后向浏览器提供<code class="fe kx ky kz la b">A</code>记录，即我们网站的IP地址。然后，浏览器能够与我们的服务器通信，并加载我们请求的信息。</p><p id="8d41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到GoDaddy仪表板，我们转到所有域名的列表，然后选择选项来编辑我们选择的域名的DNS设置。导航到编辑屏幕后，我们将看到的选项之一是域名服务器，它当前正在处理到我们域的网络路由。它看起来类似于我们下面看到的:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/9606ec8892ae2c6b338f7d17ca0af2aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cl0qiP7Awnl9WHpwP1G1A.png"/></div></div></figure><p id="80ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们想把域名服务器解析交给AWS，这样我们就可以在一个地方管理所有的东西，而不是把服务器放在AWS上，把域配置放在GoDaddy上。如果我们希望自动化我们的整个工作流程，这也是有帮助的。但是，可能有更好的自动化替代方案，例如使用Docker Swarm或<a class="ae kw" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>的集群部署。</p><p id="07c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完成到AWS的DNS切换，我们首先需要设置AWS，特别是他们的名为Route 53的DNS web服务。</p><h2 id="c82e" class="mp lc iq bd ld mq mr dn lh ms mt dp ll kj mu mv lp kn mw mx lt kr my mz lx na bi translated">步骤3:在AWS上创建托管区域</h2><p id="5c47" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">顾名思义，我们将在由AWS提供的DNS web服务<code class="fe kx ky kz la b">Route 53</code>中创建一个<code class="fe kx ky kz la b">hosted zone</code>。要创建托管区域，我们需要知道域名(我们已经在步骤2中购买了该域名)。要添加托管区域，请按照以下步骤操作。</p><p id="d05c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导航至AWS &gt; Route 53 &gt;托管区域&gt;创建托管区域</p><p id="8398" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将打开<code class="fe kx ky kz la b">Create Hosted Zone</code>侧面板，我们需要在上面输入域名。将其余部分保留为默认值，然后单击create。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/bda298c7700732b99b954467dfe15291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4-b74v136nIARj1OgfWUw.png"/></div></div></figure><p id="9fbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在选择新创建的托管区域时，我们可以看到在托管区域下创建的各种记录，例如授权中心(SOA)和名称服务器(NS)。目前，我们只关注NS记录。</p><h2 id="8080" class="mp lc iq bd ld mq mr dn lh ms mt dp ll kj mu mv lp kn mw mx lt kr my mz lx na bi translated">步骤4:更新GoDaddy名称服务器</h2><p id="0feb" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">创建托管区域后，单击托管区域的名称以查看分配给该域的名称服务器(NS)值。</p><p id="ab7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时我们只关心<code class="fe kx ky kz la b">NS</code>值，通常是2–4个，如下所示。把它们抄下来，然后去GoDaddy。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/af5f81e5a4cd7b8365910923a05d3daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ha_eBB42IqB2wIRDIWMCQ.png"/></div></div></figure><p id="5292" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在GoDaddy上，像我们之前一样导航到DNS设置页面，这次在名称服务器部分下，单击编辑并从下拉列表中选择<code class="fe kx ky kz la b">Custom</code>以输入我们新的AWS托管区域的NS值。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/9a7190f1f3dec3bef0bb708f7d9ab1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*an6FAuKW0RVrnQRLrm1BTw.png"/></div></div></figure><p id="163b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们保存了更改，需要一些时间将更改在互联网上传播，但一旦传播，GoDaddy将通知我们他们不再维护我们的域名DNS记录:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/32f1297cc36b896421d6885be00393d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDdkH1HaDMKdSipBzJahDw.png"/></div></div></figure><p id="db80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已。我们已经成功地在GoDaddy上购买了一个域名，并将其转移到AWS Route 53。接下来，我们为我们的域名创建一个SSL证书。</p><h2 id="89be" class="mp lc iq bd ld mq mr dn lh ms mt dp ll kj mu mv lp kn mw mx lt kr my mz lx na bi translated">步骤5:运行加密docker映像</h2><p id="16b5" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">这里有一个简短的总结，它很好地解释了<a class="ae kw" href="https://letsencrypt.org/getting-started/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>是关于什么的，而不涉及证书和证书颁发机构的太多细节:</p><blockquote class="ny nz oa"><p id="966b" class="jy jz ob ka b kb kc kd ke kf kg kh ki oc kk kl km od ko kp kq oe ks kt ku kv ij bi translated">若要在您的网站上启用HTTPS，您需要从证书颁发机构(CA)获取证书(一种文件)。让我们加密一个CA。为了从“让我们加密”网站获得您网站的域证书，您必须展示对该域的控制</p></blockquote><p id="9f96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Let's Encrypt提供了一个名为<code class="fe kx ky kz la b">certbot</code>的客户端，可以用来自动生成和更新SSL证书。为了维护对该域的控制，<code class="fe kx ky kz la b">certbot</code>执行一个挑战，在这个挑战中，它与我们的DNS进行通信，并期待某个结果。根据执行的挑战类型，结果会有所不同。在我们的例子中，我们将采用<code class="fe kx ky kz la b">dns-01</code>挑战，它期望在DNS上出现某个TXT记录。</p><p id="d5b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了生成这个TXT记录，我们需要提供证据，我们可以在本地安装<code class="fe kx ky kz la b">cerbot</code>客户端，然后在我们的机器上运行<a class="ae kw" href="https://certbot.eff.org/docs/intro.html#how-to-run-the-client" rel="noopener ugc nofollow" target="_blank">命令</a>，或者为<code class="fe kx ky kz la b">cerbot</code>运行<code class="fe kx ky kz la b">docker</code>映像，这使得事情变得更简单，跨平台兼容，并允许我们潜在地自动化这个过程。在运行<code class="fe kx ky kz la b">certbot</code>映像时，它请求一些关于我们试图为其生成SSL证书的域的信息。这些信息可以在提示符下输入，也可以通过传递到容器中的标志和选项自动输入。下面是一个合并了所有选项并设置了一些逻辑默认值的脚本。确保了解他们的<a class="ae kw" href="https://letsencrypt.org/docs/rate-limits/" rel="noopener ugc nofollow" target="_blank">费率限制</a>，以防你打算批量使用。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="a8b4" class="mp lc iq bd ld mq mr dn lh ms mt dp ll kj mu mv lp kn mw mx lt kr my mz lx na bi translated">步骤6:执行DNS质询</h2><p id="03ae" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">在我们项目的根文件夹中运行上一步中的bash脚本，将首先下载<code class="fe kx ky kz la b">certbot</code> docker映像，然后为我们提供必要的信息，作为DNS挑战的一部分添加到DNS记录中。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/746e960e7bd3e77a5ca1ffe82b32e43f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Y1zAVhtE8Yh8-TLsXrrwg.png"/></div></div></figure><p id="d696" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面，我们被要求输入所提供的值，作为我们域的Route 53托管区域上的一个<code class="fe kx ky kz la b">_acme-challenge</code> TXT记录。</p><p id="b2d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要输入TXT记录，我们必须返回到Route 53上的应用程序的托管区域，并使用如下所示的值创建一个新的记录集。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/33cfc176ea157e2517e9cd009f27e173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UGSWF9cKADt4VbuAlUUsaw.png"/></div></div></figure><p id="cfaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">保存后，等待几秒钟(有时是几分钟)以传播更改，然后按下终端上的<code class="fe kx ky kz la b">enter</code>。然后,<code class="fe kx ky kz la b">certbot</code>客户端将执行<code class="fe kx ky kz la b">dns</code>挑战并验证我们的域名所有权。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/c76a5ec68ec1071f5efd7e83b0bb79f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PgK5cycAx25UmJOe6kRBrQ.png"/></div></div></figure><p id="87f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们将卷挂载到<code class="fe kx ky kz la b">certbot</code>容器的方式，生成的证书现在可以在我们的项目根文件夹的<code class="fe kx ky kz la b">letsencrypt</code>文件夹中获得。</p><p id="9a7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由我们来决定是否希望在每次部署时都运行ssl生成脚本，或者是否希望只手动运行一次来刷新我们的证书。标志<code class="fe kx ky kz la b">--keep-until-expiring</code>将确保新证书仅在旧证书到期时生成。</p><h2 id="8aab" class="mp lc iq bd ld mq mr dn lh ms mt dp ll kj mu mv lp kn mw mx lt kr my mz lx na bi translated">步骤7:配置NGINX</h2><p id="4efd" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">一旦生成了证书，我们需要将证书提供给我们的web服务器。由于我们只有一个静态网站要部署，我们将使用NGINX服务器来提供我们的文件。而且，因为我们想要使用新生成的SSL证书，所以我们必须创建nginx配置来包含该证书。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="fcb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，我们有一个非常简单的<code class="fe kx ky kz la b">nginx</code>配置文件，它在两个端口80和443上为应用程序服务，分别用于http和https。如果有人试图通过<code class="fe kx ky kz la b">http</code>协议访问应用程序，它将被重定向到第一个服务器块中的301重定向所定义的<code class="fe kx ky kz la b">https</code>。</p><p id="4ad2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的nginx配置已经准备好了，我们可以创建我们的<code class="fe kx ky kz la b">docker</code>映像来打包我们可发布的应用程序。请注意，我们正在为<code class="fe kx ky kz la b">/etc/letsencrypt/</code>文件夹中的<code class="fe kx ky kz la b">ssl_certificate</code>和<code class="fe kx ky kz la b">ssl_certificate_key</code>提供服务。我们必须确保在为我们的应用程序生成docker映像时，将我们的证书放在这个文件夹中。</p><h2 id="ba61" class="mp lc iq bd ld mq mr dn lh ms mt dp ll kj mu mv lp kn mw mx lt kr my mz lx na bi translated">步骤8:创建Dockerfile</h2><p id="3814" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">Dockerfile现在负责提取<code class="fe kx ky kz la b">nginx</code>图像，为我们的源代码复制<code class="fe kx ky kz la b">build/</code>文件夹，将证书复制到<code class="fe kx ky kz la b">nginx</code>，最后复制我们上面创建的定制<code class="fe kx ky kz la b">nginx</code>配置。</p><p id="8f1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用<code class="fe kx ky kz la b">npm run build</code>命令为React应用程序生成构建文件夹。这样一来，我们的<code class="fe kx ky kz la b">Dockerfile</code>将显示如下:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8378" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的最重要的事情是，我们将证书复制到我们试图在<code class="fe kx ky kz la b">nginx.config </code>文件中读取它的相同位置。</p><h2 id="1a9d" class="mp lc iq bd ld mq mr dn lh ms mt dp ll kj mu mv lp kn mw mx lt kr my mz lx na bi translated">第九步:使用<code class="fe kx ky kz la b">docker-machine</code>推送图像</h2><p id="ffa4" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">创建docker文件后，我们现在可以用它来构建一个图像，并在我们希望的任何地方将它作为容器运行。当然，在这种情况下，我们不能在本地这样做，因为我们的nginx配置是用前面步骤中为我们的域生成的证书来设置的。相反，我们将上传图像并在AWS EC2实例上运行，该实例是由AWS EC2服务提供的*nix系统。</p><p id="e5ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个最小的bash脚本，它创建一个默认的(T2微)EC2实例，并在该实例上打开端口80和443。我们还需要提供我们的AWS凭证作为<code class="fe kx ky kz la b">key</code>和<code class="fe kx ky kz la b">secret</code>。在本例中，我创建了一个具有编程访问权限的新用户，并从AWS IAM服务下载了密钥和秘密。此外，为了访问EC2服务，我将<code class="fe kx ky kz la b">AmazonEC2FullAccess</code>权限分配给我创建的用户。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0930" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行上面的脚本需要几分钟，因为EC2启动需要一些时间。此外，由于我们每次构建图像并将其部署到新的EC2实例的方式，图像的层不会被缓存，而是在每次执行该脚本时重新下载。</p><blockquote class="ny nz oa"><p id="1701" class="jy jz ob ka b kb kc kd ke kf kg kh ki oc kk kl km od ko kp kq oe ks kt ku kv ij bi translated">不要将此作为您的生产策略。这只是暂时使事情变得容易的一个临时的旁路。</p></blockquote><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/e26b1f8c790962f96f1bc36a0bc1adea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5suKBmVuJuHupGQ7my6eow.png"/></div></div></figure><h2 id="f417" class="mp lc iq bd ld mq mr dn lh ms mt dp ll kj mu mv lp kn mw mx lt kr my mz lx na bi translated"><strong class="ak">步骤10:更新托管区域</strong>上的 <code class="fe kx ky kz la b"><strong class="ak">A</strong></code> <strong class="ak">记录</strong></h2><p id="34a5" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">在上面的bash脚本中，我们还记录了刚刚创建的EC2实例的公共IP地址。剩下要做的就是复制实例的IP地址，并在我们的托管区域上提供它作为<code class="fe kx ky kz la b">A</code>记录。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/8937d1d49036f5d255262b8d71c1eb23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SklnAqD43UXFUoV0Vy_7iw.png"/></div></div></figure><p id="e037" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几秒钟后，我们的应用程序或本例中的<a class="ae kw" href="https://kashyap.app/" rel="noopener ugc nofollow" target="_blank"> https://kashyap.app </a>应该启动并运行。</p><h1 id="b5ac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7459" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">创建SSL证书应该是一个免费且简单的过程。在这篇文章中，我希望已经提供了实现这个目标所必需的清晰性，感谢让我们加密。请留下评论来提供您的反馈或点击拍手</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><p id="beb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ob">如果你喜欢这个博客，一定要为它鼓掌，</em> <a class="ae kw" href="https://medium.com/@kashyap.mukkamala" rel="noopener"> <em class="ob">阅读更多</em> </a> <em class="ob">或者关注我的</em><a class="ae kw" href="https://www.linkedin.com/in/kashyap-mukkamala/" rel="noopener ugc nofollow" target="_blank"><em class="ob">LinkedIn</em></a><em class="ob">。</em></p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><figure class="ne nf ng nh gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com/?utm_source=bottom-banner"><div class="gh gi or"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure><div class="os ot gp gr ou ov"><a href="https://gitconnected.com/learn/docker" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">学习Docker -最佳Docker教程(2019) | gitconnected</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">31大Docker教程。课程由开发者提交和投票，使你能够找到最好的Docker…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">gitconnected.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj jw ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://gitconnected.com/learn/nginx" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">学习Nginx -最佳Nginx教程(2019) | gitconnected</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">6大Nginx教程。课程由开发者提交并投票，让你找到最好的Nginx…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">gitconnected.com</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj jw ov"/></div></div></a></div></div></div>    
</body>
</html>