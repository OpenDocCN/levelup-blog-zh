<html>
<head>
<title>Go Worker Pool: The Concurrency Powerhouse</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go Worker Pool:并发发电站</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-worker-pool-the-concurrency-powerhouse-2dc7971f4f15?source=collection_archive---------0-----------------------#2022-10-10">https://levelup.gitconnected.com/go-worker-pool-the-concurrency-powerhouse-2dc7971f4f15?source=collection_archive---------0-----------------------#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4b76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最好的“应用程序程序员”被培养成专注于业务需求，他们通常不总是考虑对并发性的需求——这是应该的。我们不会首先想到并发—我们首先想到的是“业务需求”。</p><p id="128f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编写并发代码所涉及的复杂性通常被抽象在Go库或第三方包(例如HTTP服务器处理程序)中，但情况并非总是如此。有时，需要以一种不能利用现有库的方式来扩展功能。每个程序员都必须知道如何编写并发代码——一个功能正确的代码如果不能扩展就毫无用处——反之亦然。</p><p id="e097" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇博文中，我将提供一步一步的指导，让“顺序”代码“并发”。我将从一个顺序代码开始，然后重构它，使它成为并发的。这是我在现实生活中的做法——我首先关注业务功能，编写一个顺序正确的代码版本，然后进行重构，使其更加并发。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f9752d23a03ed9aac2ef015f1a7d9f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WbOw_vdM4H1F9iEy"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">工人池:Go的并发模式</figcaption></figure><p id="7074" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="le">解决业务功能—顺序码</em> </strong></p><p id="2ab8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一步是正确编写顺序代码。让我们将业务功能封装到一个函数中。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="e539" class="lk ll it lg b gy lm ln l lo lp">businessFunctionality() response</span></pre><p id="fa68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="le">分解业务功能</em> </strong></p><p id="020d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想出一些聪明的方法把功能分成小块。如果不能模块化，就不能并行化。</p><p id="7cc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于探索数据，基于日期探索数据的选项是值得探索的。例如，业务功能可以浏览1月1日到12月31日的数据。这可以分为365(或366) <strong class="js iu"> <em class="le">个作业</em> </strong> —其中每个作业负责一天的数据探索。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="45fa" class="lk ll it lg b gy lm ln l lo lp">func businessFunctionalityJob(startTime, endTime time.Time) JobResponse<br/>{<br/>    ...<br/>}</span></pre><p id="738c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">整个流程大概是这样的:</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="b5b6" class="lk ll it lg b gy lm ln l lo lp">func businessFunctionality() response<br/>{<br/>    jobStartTime := //startTime<br/>    jobEndTime := //endTime<br/>    jobWindow := 24 * time.Hour</span><span id="7a59" class="lk ll it lg b gy lq ln l lo lp">    var jobResponses []JobResponse<br/>    for currentTime := jobStartTime; currentTime.Before(jobEndTime);        <br/>           currentTime = jobStartTime.Add(jobWindow) {<br/>        jobResponses = append(jobResponses,  <br/>                  businessFunctionality(jobStartTime, jobEndtime))</span><span id="575e" class="lk ll it lg b gy lq ln l lo lp">    }</span><span id="bfa0" class="lk ll it lg b gy lq ln l lo lp">    return combineResponses(jobResp)<br/>}</span></pre><p id="439a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者，您可以考虑用某个数字范围来划分业务功能</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="996a" class="lk ll it lg b gy lm ln l lo lp">func businessFunctionalityJob(start, end int64) response {<br/>    ...<br/>}</span></pre><p id="f1cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更一般地说，</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="c8a7" class="lk ll it lg b gy lm ln l lo lp">type JobInput struct {<br/>   startTime time.Time<br/>   endTime   time.Time<br/>}</span><span id="b7ff" class="lk ll it lg b gy lq ln l lo lp">type JobResponse struct { //keeping this empty for this example. Real-world will be more complex.<br/>}</span><span id="452e" class="lk ll it lg b gy lq ln l lo lp">type Response struct {<br/>   finalOutput string<br/>}</span><span id="be13" class="lk ll it lg b gy lq ln l lo lp">func businessFunctionality() Response {<br/>   var jobInputs []JobInput //Create job input for each job<br/>   var jobResponses []JobResponse<br/>   for _, jobInput := range jobInputs {<br/>      jobResponses = append(jobResponses,  <br/>                      businessFunctionalityJob(jobInput))<br/>   }<br/>   return combineResponses(jobResponses)<br/>}</span><span id="5a24" class="lk ll it lg b gy lq ln l lo lp">func combineResponses(jobResponses []JobResponse) Response {<br/>   return Response{finalOutput: "Well done!!"}<br/>}</span><span id="6d31" class="lk ll it lg b gy lq ln l lo lp">func businessFunctionalityJob(jobInput JobInput) JobResponse {<br/>   return JobResponse{}<br/>}</span><span id="aefe" class="lk ll it lg b gy lq ln l lo lp">func main() {<br/>   fmt.Println(businessFunctionality().finalOutput)<br/>}</span></pre><p id="d879" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="le">使其平行</em> </strong></p><p id="aa5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们已经分解了功能，但在提高性能方面没有取得任何进展。我们可以通过启动多个go例程轻松实现并行。</p><p id="a22d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考:<a class="ae lr" href="https://go.dev/play/p/SvW4w7Hy97l" rel="noopener ugc nofollow" target="_blank">https://go.dev/play/p/SvW4w7Hy97l</a></p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="ad37" class="lk ll it lg b gy lm ln l lo lp">func businessFunctionality() Response {<br/>   jobInputs := []JobInput{JobInput{}, JobInput{}}<br/>   var jobResponses []JobResponse<br/>   for _, jobInput := range jobInputs {<br/>     go func() {<br/>       fmt.Println("Executing job..")<br/>       jobResponses = append(jobResponses,<br/>              businessFunctionalityJob(jobInput))<br/>     }()<br/>   }<br/>   return combineResponses(jobResponses)<br/>}</span></pre><p id="1d62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是上面的不行，原因很简单，我们不是在等着围棋套路过去。这是一个改进的版本。</p><p id="18c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考:<a class="ae lr" href="https://go.dev/play/p/c2bUrYfi6ds" rel="noopener ugc nofollow" target="_blank">https://go.dev/play/p/c2bUrYfi6ds</a></p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="ea5f" class="lk ll it lg b gy lm ln l lo lp">func businessFunctionality() Response {<br/>   jobInputs := []JobInput{JobInput{}, JobInput{}}<br/>   var jobResponses []JobResponse<br/>   wg := sync.WaitGroup{}<br/>   for _, jobInput := range jobInputs {<br/>      wg.Add(1)<br/>      go func() {<br/>        defer wg.Done()<br/>        fmt.Println("Executing job..")<br/>        jobResponses = append(jobResponses,<br/>                   businessFunctionalityJob(jobInput))<br/>      }()<br/>   }<br/>   wg.Wait()<br/>   return combineResponses(jobResponses)<br/>}</span></pre><p id="088d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是现在，对于变量jobInput和jobResponses，上面的代码有一个竞争条件的问题。以下是解决这一问题的方法:</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="5921" class="lk ll it lg b gy lm ln l lo lp">func businessFunctionality() Response {<br/>   jobInputs := []JobInput{JobInput{}, JobInput{}}<br/>   jobResponses := make([]JobResponse, len(jobInputs))<br/>   wg := sync.WaitGroup{}<br/>   for idx, jobInput := range jobInputs {<br/>       wg.Add(1)<br/>       go func(jobInputParam JobInput, idx int) {<br/>          defer wg.Done()<br/>          jobResponses[idx] = <br/>                 businessFunctionalityJob(jobInputParam)<br/>       }(jobInput, idx)<br/>   }<br/>   wg.Wait()<br/>   return combineResponses(jobResponses)<br/>}</span></pre><p id="841c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过为jobResponses创建一个固定长度的数组，我们消除了对数组进行追加的需要——这是一个线程不安全的操作。类似地，通过将jobInput作为参数传递给go例程，jobInput也是线程安全的。以下是更新后的代码:</p><p id="1358" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lr" href="https://go.dev/play/p/baBmYulv3cl" rel="noopener ugc nofollow" target="_blank">https://go.dev/play/p/baBmYulv3cl</a></p><p id="440b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的方法对于较小的负载会工作得很好，但是你可能最终会创建大量的go例程。这可能会导致内存利用率、数据库性能或任何其他有限资源的性能问题。</p><p id="d58e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">控制并行性—引入工人池</strong></p><p id="03d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将创建一个工人池，然后使用缓冲通道向工人池提供输入。工人将处理每个作业输入(在下图中用一个小黄色球表示)并产生一个作业输出(用一个小绿色球表示)</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ls"><img src="../Images/eeead89a54ed42de952bfcd7430e595e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Itq4Ar7rF2sruuDwIlUupQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">工池解释！！</figcaption></figure><p id="d1b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">响应处理器再次从缓冲通道中读取数据——通过组合响应产生最终响应。</p><p id="6058" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考:【https://go.dev/play/p/Xha20l7C66a】T4</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="0e26" class="lk ll it lg b gy lm ln l lo lp">func startWorker(jobInputChan &lt;-chan JobInput, jobOutputChan chan&lt;- JobResponse, wg *sync.WaitGroup) {<br/>   defer wg.Done()<br/>   for jobInput := range jobInputChan {<br/>      jobOutputChan &lt;- businessFunctionalityJob(jobInput)<br/>   }<br/>}</span><span id="93fb" class="lk ll it lg b gy lq ln l lo lp">func businessFunctionality(jobInputChan chan&lt;- JobInput) {<br/>   jobInputs := []JobInput{JobInput{}, JobInput{}}<br/>   for _, jobInput := range jobInputs {<br/>      jobInputChan &lt;- jobInput<br/>   }<br/>   close(jobInputChan)<br/>}</span><span id="a7d5" class="lk ll it lg b gy lq ln l lo lp">func combineResponses(jobResponses []JobResponse) Response {<br/>    return Response{finalOutput: "Well done!!"}<br/>}</span><span id="c90d" class="lk ll it lg b gy lq ln l lo lp">func businessFunctionalityJob(jobInput JobInput) JobResponse {<br/>    fmt.Println("Executing Job..")<br/>    return JobResponse{}<br/>}</span><span id="caf1" class="lk ll it lg b gy lq ln l lo lp">func main() {<br/>    num_of_workers := 3<br/>    jobsChan := make(chan JobInput, 10)<br/>    resultsChan := make(chan JobResponse, 10)<br/>    wg := sync.WaitGroup{}</span><span id="7186" class="lk ll it lg b gy lq ln l lo lp">    for i := 0; i &lt; num_of_workers; i++ {<br/>       wg.Add(1)<br/>       go startWorker(jobsChan, resultsChan, &amp;wg)<br/>    }</span><span id="90b6" class="lk ll it lg b gy lq ln l lo lp">    go businessFunctionality(jobsChan)</span><span id="9ad1" class="lk ll it lg b gy lq ln l lo lp">    var responses []JobResponse<br/>    wgResp := sync.WaitGroup{}<br/>    wgResp.Add(1)<br/>    go func() {<br/>       defer wgResp.Done()<br/>       for resp := range resultsChan {<br/>          responses = append(responses, resp)<br/>       }<br/>    }()</span><span id="49f6" class="lk ll it lg b gy lq ln l lo lp">    wg.Wait()<br/>    close(resultsChan)<br/>    wgResp.Wait()</span><span id="ae2b" class="lk ll it lg b gy lq ln l lo lp">    fmt.Println(combineResponses(responses).finalOutput)<br/>}</span></pre><p id="6573" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="le">使用同步。WaitGroup </em> </strong></p><p id="5c3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了正确使用工作池模式，“等待组”是一个需要理解的重要概念。在上面的代码中，两次使用“等待组”来等待worker“go routes”的并行执行和结果通道“go routine”的并行执行。</p><p id="8f01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">结论</strong></p><p id="b459" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“worker pool”在开始时可能不容易理解，它需要理解缓冲通道、<em class="le"> sync.waitGroup </em>和goroutines。但是一旦你理解了事情是如何累加的——实现模式就变得非常直观了。我经常用它来扩展我的应用程序。</p></div></div>    
</body>
</html>