<html>
<head>
<title>Building an iOS app using SwiftUI + Combine + MVVM [Part 2]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI + Combine + MVVM构建iOS应用程序(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-an-ios-app-using-swiftui-combine-mvvm-part-2-a0a703269907?source=collection_archive---------6-----------------------#2020-06-04">https://levelup.gitconnected.com/building-an-ios-app-using-swiftui-combine-mvvm-part-2-a0a703269907?source=collection_archive---------6-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1357" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">逐步了解如何使用全新的Apple框架构建iOS应用程序。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f48327f749bfcd641443c8d5f35c2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5BAjvCCBywNwAMJcFrsJQ.png"/></div></div></figure><p id="c513" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将指导您使用这些框架构建一个完整的应用程序。不仅如此，我们还将使用在Apple devs社区越来越受欢迎的设计模式。这是MVVM建筑。</p><p id="fc4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">开始之前，请注意这是教程的第二部分。为了更好地理解这个练习，请查看前面的部分。它包括应用程序演示和所有与使用MVVM的代码结构相关的细节。在第一部分中，我们还实现了模型:</p><ul class=""><li id="c587" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><a class="ae lz" href="https://medium.com/@ennes.finsi/building-an-ios-app-using-swiftui-combine-mvvm-architecture-part-1-7e5a1683a7aa" rel="noopener">使用SwiftUI + Combine + MVVM构建iOS应用【第一部分】</a></li></ul><p id="f843" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将开始使用SwiftUI和Combine，因此我们假设您在这些框架中有一些这方面的知识。如果不是这样，我建议您从基础开始:</p><ul class=""><li id="df1f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><a class="ae lz" href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views" rel="noopener ugc nofollow" target="_blank"> SwiftUI教程</a>。</li><li id="db1d" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" rel="noopener ugc nofollow" target="_blank" href="/basics-of-combine-framework-64dbd18da341">联合收割机基础</a>框架和<a class="ae lz" href="https://www.vadimbulavin.com/swift-combine-framework-tutorial-getting-started/" rel="noopener ugc nofollow" target="_blank">联合收割机教程</a>。</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="d4f1" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">我们将建造什么</h1><p id="2126" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">此时，我们有了一个定义良好的模型。它包括几个实体和用例，代表我们应用程序的业务逻辑。因此，我们已经具备了开始构建表示层的一切。</p><p id="e4b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们在第一部分教程中所评论的，我们实现了一个受Airbnb的MvRx方法启发的MVVM架构。这使用特定于视图的状态，而不是全局应用程序状态。考虑到这一点，我们将了解如何使用SwiftUI+Combine来调整该解决方案。</p><p id="be55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将开始为<em class="nj"> ViewModel </em>组件构建一个通用实现。一旦我们清楚了它是如何工作的及其功能，我们就可以用它们特定的视图模型来构建应用程序视图了。在这一部分，我们将实现图书列表视图。</p><h1 id="fb09" class="mm mn it bd mo mp nk mr ms mt nl mv mw jz nm ka my kc nn kd na kf no kg nc nd bi translated">ViewModel通用实现</h1><p id="4a9a" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">众所周知，设计模式可以通过几种方法来实现。在这个练习中，我们寻找一个遵循MvRx方法的<em class="nj">视图模型</em>的通用实现。这样，QuickBirdStudios提供的解决方案完全符合我们的要求:</p><ul class=""><li id="485b" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">QuickBirdStudios的视图模型解决方案</li></ul><p id="2a42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的目的是构建一个尽可能灵活的视图模型。换句话说，我们想要改变一个<em class="nj">视图模型</em>的动作和状态，而不修改视图组件。因此，让我们从定义一个<code class="fe np nq nr ns b">ViewModel</code>协议开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="fb20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个协议代表了我们的应用程序中的一个重要组成部分，所以让我们专注于我们正在做的事情。可以看到，此时<em class="nj">联合收割机</em>出现在现场。在我们的例子中，我们将使用这个框架来处理状态更新事件。</p><p id="6a33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe np nq nr ns b">ViewModel</code>协议符合<code class="fe np nq nr ns b">ObservableObject</code>。换句话说，我们的对象将包含一个在改变之前发出的发布者。因此，正如我们稍后看到的，我们可以像使用任何其他<code class="fe np nq nr ns b">@ObservedObject</code>属性一样使用它。</p><p id="0f02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除此之外，协议还有两种相关类型:</p><ul class=""><li id="86a0" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><code class="fe np nq nr ns b">State</code>:指特定视图的状态(包装模型)。</li><li id="6969" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><code class="fe np nq nr ns b">Input</code>:用户动作将使用<code class="fe np nq nr ns b">trigger</code>方法触发这些输入。</li></ul><p id="97bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe np nq nr ns b">associatedtype</code>在这种情况下是多么有用。它只是为这种类型的协议提供了一个占位符名称。但是在协议被采用之前，这些关联类型所使用的实际类型并没有被指定。</p><p id="64df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们将有一个<code class="fe np nq nr ns b">AnyViewModel</code>类型，它将作为一个符合<code class="fe np nq nr ns b">ViewModel</code>协议的包装器，关联的类型是指定的泛型类型<code class="fe np nq nr ns b">State</code>和<code class="fe np nq nr ns b">Input</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="4b23" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">看看存储的属性。我们的<code class="fe np nq nr ns b">wrappedObjectWillChange</code>返回了<code class="fe np nq nr ns b">Publisher</code>的一个具体实现，它的类型包含了我们不想跨越API边界公开的细节。它的<code class="fe np nq nr ns b">Output</code>是<code class="fe np nq nr ns b">Void</code>，它的<code class="fe np nq nr ns b">Failure</code>是<code class="fe np nq nr ns b">Never</code>类型，这意味着它不会失败。</li><li id="4460" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">注意，我们最终将为每个具体实现使用的是<code class="fe np nq nr ns b">state</code>变量和<code class="fe np nq nr ns b">trigger(_ input:)</code>函数。</li></ul><h1 id="3902" class="mm mn it bd mo mp nk mr ms mt nl mv mw jz nm ka my kc nn kd na kf no kg nc nd bi translated">视图特定的实现</h1><p id="88f7" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">此时，我们可以开始实现应用程序视图。使用前面的代码，我们将为它们中的每一个定义一个单独的状态和输入。然后，正如我们在本文开头所说的，我们将重点关注应用程序主图书列表中涉及的视图和组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/97b2b4aa07bd5b44e8a95368e0af1705.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*Iv_tbyCHitWJJtWwkLo8rg.png"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">查看代码结构</figcaption></figure><h2 id="4eac" class="oa mn it bd mo ob oc dn ms od oe dp mw ld of og my lh oh oi na ll oj ok nc ol bi translated">图书行视图</h2><p id="1b50" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">让我们从基础开始，我们将创建一个SwiftUI视图来表示图书列表的一行。我们知道，<code class="fe np nq nr ns b">body</code>属性只返回单个视图。我们可以在<em class="nj">堆栈</em>中组合和嵌入多个视图，将视图水平、垂直或前后组合在一起。这样，我们按如下方式组织行视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/35a5b3cbb8f087b6f56bbfb382dcd7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8E8-BbfNiz7x0S3X4jrSg.png"/></div></div></figure><p id="2d80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用一个水平堆栈来放置主要元素:产品图片及其相关细节。对于这些细节，我们使用一个<code class="fe np nq nr ns b">VStack</code>来垂直显示一本书的基本信息，比如书名、作者和价格。</p><p id="883b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们转到代码项目，我们将有一个如下图所示的<code class="fe np nq nr ns b">BookRow</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="6607" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">我们用很少的元素实现了一个简单的视图。此外，使用一个<code class="fe np nq nr ns b">Book</code>作为视图属性就足以显示这些信息。目前，<code class="fe np nq nr ns b">ViewModel</code>还不需要。</li><li id="0ec5" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">注意<code class="fe np nq nr ns b">BookImage</code>只是我们定义的自定义视图。我们将在其他视图中使用它，因此它位于<em class="nj"> Utils </em>文件夹中。</li></ul><p id="cfaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在画布中，点击<em class="nj"> Resume </em>显示预览。结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/32a7b3153a360fd2c6b7be477d65df89.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*CJVq8TJ2WkGcuTd24KAumQ.png"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">图书行视图的预览</figcaption></figure><h2 id="ab4f" class="oa mn it bd mo ob oc dn ms od oe dp mw ld of og my lh oh oi na ll oj ok nc ol bi translated">图书列表视图</h2><p id="6454" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">我们将创建一个显示集合元素的列表和一个为集合中的每个元素提供视图的闭包。该收藏是为我们的服务提供的图书收藏。此外，我们对这些元素使用了<code class="fe np nq nr ns b">BookRow</code>视图。</p><p id="2410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">开始定义视图状态。服务将出现在所有视图状态中，因为我们需要它来访问数据层。该视图状态还包括将要显示的<code class="fe np nq nr ns b">Book</code>列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="95cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于没有导致状态改变的用户输入，我们可以使用<code class="fe np nq nr ns b">Never</code>作为输入类型。考虑到所有这些，我们将视图的<code class="fe np nq nr ns b">viewModel</code>属性定义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1444" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe np nq nr ns b">BookListViewModel</code>的实现相当简单，因为它只提供一个静态状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9d60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，有了这些，我们现在可以构建<code class="fe np nq nr ns b">BookListView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="65d5" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">记住<code class="fe np nq nr ns b">Book</code>数据类型符合<code class="fe np nq nr ns b">Identifiable</code>协议。因此，我们可以使用<code class="fe np nq nr ns b">List</code>来显示这些信息。</li><li id="7b93" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">通过从闭包返回一个<code class="fe np nq nr ns b">BookRow</code>来完成动态生成的列表。这为<code class="fe np nq nr ns b">viewModel.state.books</code>数组中的每个元素创建了一个<code class="fe np nq nr ns b">BookRow</code>。</li><li id="6095" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">为了避免SwiftUI立即加载目标视图，我们使用了那个<code class="fe np nq nr ns b">NavigationLazyView</code>。这只是对这个框架的一个限制的<a class="ae lz" href="https://stackoverflow.com/a/61234030" rel="noopener ugc nofollow" target="_blank">解决方法</a>。</li></ul><p id="5bbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">恭喜，我们已经完成了本教程的第二部分。构建并运行应用程序，查看最终结果，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/7ce8ba3275813123b1c124a701eaac26.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*aTuXd5GxYVE0e5e8a3kfmQ.png"/></div></figure><h1 id="0511" class="mm mn it bd mo mp nk mr ms mt nl mv mw jz nm ka my kc nn kd na kf no kg nc nd bi translated">下一步是什么</h1><p id="710a" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">我们已经学会了如何使用SwiftUI和Combine来调整MVVM架构。我们为<em class="nj"> ViewModel </em>组件构建了一个通用实现，它允许我们实现图书列表视图。在下一部分中，我们将完成应用程序，用各自的<em class="nj">视图模型</em>定义和构建剩余的视图。</p><p id="5b3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很快就会回来！请在下面留下你的问题或建议。谢谢😁</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="6ca7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:一旦我们完成这个系列教程，项目代码就可以使用了。</p><h1 id="ac91" class="mm mn it bd mo mp nk mr ms mt nl mv mw jz nm ka my kc nn kd na kf no kg nc nd bi translated">本部分使用的资源:</h1><ul class=""><li id="6d96" class="lq lr it kw b kx ne la nf ld op lh oq ll or lp lv lw lx ly bi translated"><a class="ae lz" href="https://quickbirdstudios.com/blog/swiftui-architecture-redux-mvvm/" rel="noopener ugc nofollow" target="_blank"> SwiftUI架构</a></li><li id="c325" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">QuickBirdStudios的<a class="ae lz" href="https://github.com/quickbirdstudios/SwiftUI-Architectures/blob/master/QBChat-MVVM/QBChat-MVVM/MVVM/ViewModel.swift" rel="noopener ugc nofollow" target="_blank">视图模型解决方案</a></li><li id="da6c" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://github.com/airbnb/MvRx" rel="noopener ugc nofollow" target="_blank"> Airbnb的MvRx </a></li><li id="5408" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://applecoding.com/guias/arquitectura-mvvm-con-swiftui" rel="noopener ugc nofollow" target="_blank"> MVVM建筑</a></li><li id="a008" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://medium.com/flawless-app-stories/mvvm-design-pattern-with-combine-framework-on-ios-5ff911011b0b" rel="noopener"> MVVM设计模式与iOS上的组合框架</a></li><li id="c083" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://medium.com/swlh/getting-started-with-swiftui-and-combine-using-mvvm-and-protocols-for-ios-d8c37731a1d9" rel="noopener">使用MVVM开始使用SwiftUI和Combine</a></li><li id="e9d6" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://stackoverflow.com/questions/57594159/swiftui-navigationlink-loads-destination-view-immediately-without-clicking/61234030#61234030" rel="noopener ugc nofollow" target="_blank"> NavigationLazyView工作区</a></li></ul></div></div>    
</body>
</html>