<html>
<head>
<title>Thread synchronization with Re-entrant lock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带重入锁的线程同步</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/thread-synchronization-with-re-entrant-lock-bcbefeaa3dfc?source=collection_archive---------11-----------------------#2021-07-27">https://levelup.gitconnected.com/thread-synchronization-with-re-entrant-lock-bcbefeaa3dfc?source=collection_archive---------11-----------------------#2021-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a359" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用Java重入锁实现线程同步和实际同步的影响。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c6b0de136a968498df75e2da33f7dff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfjL53hMMwU9gc9m921kmg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@metriics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">夏羽·加尼翁</a>在<a class="ae ky" href="https://unsplash.com/s/photos/threads?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java并发编程中，当涉及到多线程执行时，线程同步有着特殊的地位。本文将讨论使用Java重入锁来保持同步机制，而不是传统的线程同步。</p><h2 id="049a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">什么和为什么？</h2><p id="0f00" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Java中，同步指的是控制多个线程访问共享资源的能力。在多线程概念中，多个线程试图同时访问共享资源，会产生不可预知的效果。线程间的可靠通信需要同步。</p><p id="8838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当多个进程必须同时运行时，就需要同步。同步的主要目标是通过利用互斥来共享资源，而不会互相干扰。操作系统中进程交互的协调是另一个目标。解决同步问题的最强大和最广泛使用的工具是信号量和监视器。信号量内置于大多数操作系统中。</p><h2 id="758e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">锁定概念</h2><p id="10d5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Java语言中的<em class="mt"> synchronized </em>关键字用于创建同步机制。它构建在锁定机制之上，由Java虚拟机(JVM)处理。synchronized关键字仅适用于方法和块；不包括类和变量。Java中的synchronized关键字生成一个临界区，它是一个代码块。要进入临界区，线程必须首先获得适当对象的锁。</p><h2 id="535d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">但是，</h2><p id="aaf2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">synchronized关键字是在Java中实现线程同步的标准技术。虽然synchronized关键字支持一些基本的同步，但它在应用中有相当大的局限性。例如，一个线程只能接受一次锁。同步块没有等待队列，因此如果一个线程退出，任何其他线程都可以获得锁。这可能会导致另一个线程在很长一段时间内资源不足。<br/>因此，<strong class="lb iu">重入锁</strong>被用于在同步中允许更多的灵活性。</p><h2 id="4aa7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">什么是重入锁？</strong></h2><p id="9dc2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">ReentrantLock类实现了锁接口，并确保访问共享资源的方法是同步的。对lock和unlock方法的调用围绕着操纵共享资源的代码。这为当前工作线程提供了对共享资源的锁定，并防止任何其他线程这样做。</p><p id="b802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ReentrantLock，顾名思义，允许线程多次进入一个资源上的锁。当线程最初进入锁时，设置保持计数为1。在解锁之前，线程可以重新进入锁定模式，并且保持计数每增加一次。对于每个解锁请求，保持计数递减1，当保持计数达到0时，资源被解锁。</p><p id="f505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可重入锁还提供了一个公平性参数，它使锁遵循锁请求的顺序，这样一旦一个线程解锁了资源，锁就被给予等待时间最长的线程。通过向锁的构造函数提供true，可以启用这种公平模式。<br/>下面的代码展示了这些锁是如何使用的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在方法体中引发了异常，也总是在finally块中调用unlock语句，以确保锁被释放(try块)。</p><h2 id="230a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">ReentrantLock()的方法</h2><ol class=""><li id="d4ac" class="mw mx it lb b lc mo lf mp li my lm mz lq na lu nb nc nd ne bi translated">lock() —如果共享资源最初是空闲的，调用lock()方法会将持有计数加1，并授予线程锁。</li><li id="502c" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">unlock() —使用unlock()方法时，保存的计数减一。当计数接近零时，资源被释放。</li><li id="9081" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">tryLock() —如果没有其他线程持有该资源，对tryLock()的调用返回true，并且持有计数增加1。如果资源不可用，该方法将返回false，线程将离开而不是被阻塞。</li><li id="7441" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">tryLock(长超时，TimeUnit单位)—在退出之前，线程等待一段特定的时间(由方法的输入决定)，以获取资源上的锁。</li><li id="6515" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">lock interruptible()—如果资源是空闲的，这种方法会获取锁，同时允许线程在获取资源时被另一个线程中断。这意味着，如果当前线程正在等待锁，而另一个线程正在请求锁，则当前线程将被中断，并将在没有获得锁的情况下返回。</li><li id="c84d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">getHoldCount() — getHoldCount()方法返回资源上当前持有的锁的数量。</li><li id="6a9a" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">isHeldByCurrentThread() —如果当前线程锁定了资源，此函数返回true。</li></ol><p id="dfc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mt">你可以在这个</em> <a class="ae ky" href="https://github.com/RaviduShehan/Shared-Printer-Problem-using-Java-reentrant-lock" rel="noopener ugc nofollow" target="_blank"> <em class="mt">库中了解我使用重入锁的方式。</em> </a></p><p id="bb95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用可重入锁时，请记住，</p><ul class=""><li id="a8ff" class="mw mx it lb b lc ld lf lg li nk lm nl lq nm lu nn nc nd ne bi translated">可能会忘记调用<em class="mt"> finally </em>块中的unlock()方法，从而导致程序问题。在线程退出之前，确保锁被释放。</li><li id="2b1e" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nn nc nd ne bi translated">用于构建锁对象的公平性参数降低了程序的整体公平性。</li></ul><h2 id="b3e3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="82e5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">ReentrantLock是同步的更好替代方案，因为它提供了许多synchronized所没有的特性。然而，这些明显优势的可用性不足以使ReentrantLock成为默认的同步方法。根据您是否需要ReentrantLock提供的灵活性来做出选择。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h2 id="0610" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">参考</h2><ol class=""><li id="ad3c" class="mw mx it lb b lc mo lf mp li my lm mz lq na lu nb nc nd ne bi translated">通过大量学习在Java中实现同步</li><li id="5464" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">docs.oracle.com的ReentranLock类</li></ol></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="078f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！！！！</p></div></div>    
</body>
</html>