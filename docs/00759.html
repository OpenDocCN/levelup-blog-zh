<html>
<head>
<title>Scala Journals — Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala期刊—递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-part-2-recursion-59b8b927cabb?source=collection_archive---------1-----------------------#2019-07-19">https://levelup.gitconnected.com/scala-journals-part-2-recursion-59b8b927cabb?source=collection_archive---------1-----------------------#2019-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c73b91198284e0dbf585adee96239dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dc2e3hGWd-YIMtHyi5F9bQ.jpeg"/></div></div></figure><p id="9107" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以想象，任何非平凡的程序在某个阶段都必须循环某些东西，由于我们在函数式编程中谈论了太多的不变性，我们可能会对使用常规循环感到有点犹豫……递归拯救了我们，对吗？</p><h2 id="b964" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">什么是递归，它实际上是如何工作的，它与不变性有什么关系？</h2><p id="fc00" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">递归是一个调用自身直到满足退出条件的函数。这是一种将一个大问题分解成小问题的方法，当这些小问题都解决了，大问题也就解决了。从现实生活的角度来看:吹干我的头发可能是一种递归形式。把我的头发弄干一分钟。检查我的头发是否干燥。如果是干的，就停下来。否则，把我的头发弄干一分钟。</p><h2 id="aaed" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">递归如何在堆栈上工作</h2><p id="9e9f" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">在我们开始举例之前，我想先谈谈堆栈，因为这是递归内部的工作方式。让我们深入了解一下函数调用。</p><p id="80ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">堆栈是内存中存储函数调用所创建的临时变量的地方。堆栈是后进先出(LIFO)数据结构，这意味着最后添加的元素将是第一个移除的元素。每当一个函数第一次被调用时，它会在堆栈中创建一个块，所有的参数、它创建的任何局部变量(以及更多)都会被放入这个块中。一旦函数退出，堆栈上的所有元素都被弹出(最后推入的元素将首先被弹出(LIFO))并且块被擦除。为了形象化它:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a3b5" class="kz la it mc b gy mg mh l mi mj">def fctn = { <br/>      val a = "a"     <br/>      val b = "b"  <br/>     }</span></pre><p id="9ff5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给定上述函数，情况如下:</p><p id="d2dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe mk ml mm mc b">fctn</code>呼叫时:</p><ol class=""><li id="986a" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">为<code class="fe mk ml mm mc b">fctn</code>创建一个堆栈块</li><li id="ba64" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">推送变量— <code class="fe mk ml mm mc b">a = "a"</code></li><li id="480b" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">推送变量— <code class="fe mk ml mm mc b">b = "b"</code></li></ol><p id="846b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe mk ml mm mc b">fctn</code>出口处:</p><ol class=""><li id="51a7" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">弹出变量(<code class="fe mk ml mm mc b">b</code>)</li><li id="e2f7" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">弹出变量(<code class="fe mk ml mm mc b">a</code>)</li><li id="78c8" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">擦除<code class="fe mk ml mm mc b">fctn</code>块</li></ol><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/491729b459e65c5cdaab94135d6aa7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s2kRTwDyL1jQmS7g.jpg"/></div></figure><p id="1ace" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在是引进一本经典递归函数:阶乘的好时机。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8253" class="kz la it mc b gy mg mh l mi mj">def factorial(n: Int): Int = {     <br/>    if(n &lt;= 1) 1 // exit condition     <br/>    else n * factorial(n - 1) // recursive call to itself  <br/>  }</span></pre><p id="59cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到这个函数由两部分组成:</p><ul class=""><li id="edf9" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky nc mt mu mv bi translated">退出条件(又称基本情况)</li><li id="eeee" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky nc mt mu mv bi translated">在满足退出条件之前将被调用的递归调用</li></ul><p id="efa2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看阶乘在被调用时实际上是如何工作的。您会看到递归调用“向下”(到堆栈上)以及返回值“向上”(离开堆栈)，一旦调用函数被求值(有点简化，但本质上就是这样工作的)。正如我之前提到的，我们可以很好地看到如何解决一个小问题(阶乘(1))导致解决大问题(阶乘(4))。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/987a88c937edc96ad19a755bf1448312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SonT9xVW_U0jxRcS.jpg"/></div></figure><p id="2437" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过上面的解释，我们很容易注意到当涉及到递归时，退出条件是多么重要。如果没有上面的退出条件，我们将继续无限调用阶乘函数。</p><h1 id="7370" class="nd la it bd lb ne nf ng le nh ni nj lh nk nl nm lk nn no np ln nq nr ns lq nt bi translated">头部递归</h1><p id="8e5e" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">Head递归是一种用更新的参数调用自身的递归，直到满足退出条件。一个很好的例子是我们的阶乘函数。正如你所想象的，堆栈大小是有限的，因此如果我们调用<code class="fe mk ml mm mc b">factorial(1234)</code>，代码将抛出StackOverflowException——堆栈上已经没有空间再进行另一次调用了。这是我们应该避免的事情，所以另一个选择是<strong class="kd iu">尾递归</strong>。</p><h1 id="1d9f" class="nd la it bd lb ne nf ng le nh ni nj lh nk nl nm lk nn no np ln nq nr ns lq nt bi translated">尾部递归</h1><p id="d4c2" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">尾部递归(如果做得正确)是避免堆栈溢出异常的一种方法。尾递归函数是一个最后一次调用是对自身的调用的函数。有一个累加器，它允许在我们进行的过程中将计算出的值传递给下一个递归调用。在Scala中，它们可以用<code class="fe mk ml mm mc b">@tailrec</code>来注释。<br/> <br/>那么让我们重写我们的阶乘:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="5ee8" class="kz la it mc b gy mg mh l mi mj">@tailrec  <br/>def factorial(n: Int, accumulator: Int): Int =<br/>    if(n &lt;= 1) accumulator // exit condition     <br/>    else factorial(n - 1, n * accumulator) // recursive call <br/>  }</span></pre><p id="aad4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">头递归版本的几个区别:</p><ul class=""><li id="3f5d" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky nc mt mu mv bi translated">Scala允许你将这段代码注释为尾部递归</li><li id="db57" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky nc mt mu mv bi translated">有一个蓄电池</li><li id="4309" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky nc mt mu mv bi translated">不会像head递归中那样出现对堆栈的“金字塔”式调用，因为我们在进行过程中会累积计算出的值，并立即将其传递给下一个递归调用。</li></ul><p id="3dc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些调用看起来会像这样…</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1a2a1eb977b727ab2637f0a52a1a7ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*CqreXMPKU5kigdd5.jpg"/></div></figure><p id="86d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…这有点像while循环…</p><p id="f614" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">剧情转折！在Scala tail中，递归函数实际上被优化为while循环。</strong></p><h2 id="af1a" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">什么..那么递归对坚持不变性有帮助吗？</h2><p id="80ca" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">由于每个<strong class="kd iu">头递归</strong>调用都被推送到堆栈上，然后在函数退出时被求值，因此实际上没有变量的突变，只有函数调用。但是这可能会导致堆栈溢出，例如，如果我们要得到一个大数的阶乘，那么一般来说，编写<strong class="kd iu">尾递归</strong>函数是一个更好的主意。正如我之前提到的，在Scala中，它们实际上被自动优化为while循环，所以从技术上来说，尾部递归并不是一个完全不可变的解决方案。</p><p id="e7dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以这实际上取决于你个人的选择——递归还是循环。我对Scala的内部优化很有信心，所以我选择了尾部递归解决方案。除了Scala信心部分，我发现它们更有趣，通常与代码库的其余部分更一致，看起来更简洁，而且我也不必担心在让我自己的循环工作时可能引入的错误(比如减1左右)。</p><h1 id="570d" class="nd la it bd lb ne nf ng le nh ni nj lh nk nl nm lk nn no np ln nq nr ns lq nt bi translated">现实生活</h1><p id="1a61" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">你当然可以写一个小阶乘函数或者列出一些目录，但是在现实生活和实际代码中，哪里可能用到递归呢？</p><p id="99a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我开始函数式编程之旅时，这个问题困扰了我很多。我是一个非常注重实践的工程师，所以当我看到Scala书籍谈论map、flatmap、fold等等，却没有提到那些我被告知必须掌握的递归函数时，我持怀疑态度。我只是不明白如何在真正的编程中应用递归，真正的问题。</p><p id="15d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原来有两件事没人告诉我:</p><ul class=""><li id="6165" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky nc mt mu mv bi translated">大多数时候，你实际上使用变换/聚合方法，如map、flatMap、foldLeft、foldRight、reduce、filter等。与其绞尽脑汁想出递归，不如看看这个阶乘函数的线性实现，使用<code class="fe mk ml mm mc b">foldLeft</code>(顺便说一下，它是作为尾部递归实现的):</li></ul><p id="ba77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mk ml mm mc b">def factorial(i: Int) = (1 to i).toList.foldLeft(1)(_ * _)</code></p><p id="a1e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…或者<code class="fe mk ml mm mc b">reduce</code>:</p><p id="7143" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mk ml mm mc b">def factorial(i: Int) = (1 to i).toList.reduce(_ * _)</code></p><ul class=""><li id="ddc5" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky nc mt mu mv bi translated">实际上，对于非常定制的问题，你将需要递归——在工作中，我实际上不得不为包含递归数据结构的嵌套Json编写许多递归函数——没有现成的现成解决方案，就像上面列表中的<code class="fe mk ml mm mc b">foldLeft</code>。</li></ul><p id="f5d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想强调的是，一旦你实现了一个递归函数，就要为它编写测试——不管这个解决方案看起来有多可靠。我总是测试快乐的路径，中庸的路径，还有“这永远不会发生”的路径。随着强大的能力而来的是巨大的责任，没有什么比生产中经过良好测试(尤其是递归)的代码更能让你晚上睡得安稳。</p><h1 id="0fe9" class="nd la it bd lb ne nf ng le nh ni nj lh nk nl nm lk nn no np ln nq nr ns lq nt bi translated">摘要</h1><p id="9fb6" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">总而言之，我想强调编写递归函数的两条经验法则:</p><ul class=""><li id="90b6" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky nc mt mu mv bi translated">先写你的退出条件，再写别的(这里:<code class="fe mk ml mm mc b">if n &lt;= 1</code>)</li><li id="198f" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky nc mt mu mv bi translated">确保在递归调用中向退出条件移动(这里:将<code class="fe mk ml mm mc b">n - 1</code>传递给递归调用——每一步都向<code class="fe mk ml mm mc b">1</code>移动)</li></ul><p id="dd73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是请记住——就像一个聪明的女人曾经说过的:</p><blockquote class="nv nw nx"><p id="f81d" class="kb kc ny kd b ke kf kg kh ki kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ky im bi translated">有人在练习递归的地方，堆栈就会溢出，函数永远不会退出。</p></blockquote><p id="68fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我去过那里，很多程序员也去过。一开始很难正确理解递归。但是我保证，如果你致力于递归地解决30个问题，你将开始看到一种新的思维方式的出现。</p><p id="6f6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">递归是函数式编程旅程中非常有用的工具。取决于你在做什么，你可能不会每天都用它…甚至可能不会每月都用。但是，时不时地，你会遇到一个定制的问题，这个问题需要递归地解决——这时你所有的练习都会得到回报。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="5313" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参考资料:<br/><em class="ny">Scala中的函数式编程:A. Alexander的简化版</em><br/>和A. Alexander的Scala食谱</p></div></div>    
</body>
</html>