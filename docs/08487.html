<html>
<head>
<title>JavaScript Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-promises-5d798693a2da?source=collection_archive---------10-----------------------#2021-05-06">https://levelup.gitconnected.com/javascript-promises-5d798693a2da?source=collection_archive---------10-----------------------#2021-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b907" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">虽然同步代码更容易跟踪和排除故障，但异步代码在执行和适应性方面总的来说更好。当你可以毫不迟疑地触发各种需求，然后在每一个都准备好了之后再处理它们的时候，为什么还要“拖延时间”呢？Promises正在变成JavaScript世界的主要部分，许多新的API都是通过promise推理实现的。我们应该调查承诺，API，它是如何被利用的！</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/7735da2e0525226b7c1ef751232e0072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBf7IB-p6hmKZPM52InCYA.png"/></div></div></figure><h1 id="8449" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">野外的承诺</h1><p id="2096" class="pw-post-body-paragraph jv jw iq jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ij bi translated">XMLHttpRequest API是异步的，但是<em class="mi">不</em>使用Promises API吗？但是，现在有一些本机API使用了承诺:</p><ul class=""><li id="e0e9" class="mj mk iq jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated"><a class="ae ms" href="https://davidwalsh.name/javascript-battery-api" rel="noopener ugc nofollow" target="_blank">电池API </a></li><li id="a58f" class="mj mk iq jx b jy mt kc mu kg mv kk mw ko mx ks mo mp mq mr bi translated"><a class="ae ms" href="https://davidwalsh.name/fetch" rel="noopener ugc nofollow" target="_blank">取API </a> (XHR的替换)</li><li id="0c4e" class="mj mk iq jx b jy mt kc mu kg mv kk mw ko mx ks mo mp mq mr bi translated">ServiceWorker API</li></ul><p id="a969" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">承诺只会变得越来越普遍，所以所有前端开发人员都要习惯它们，这一点很重要。同样值得注意的是Node.js是另一个承诺平台(显然，因为承诺是一个核心语言特性)。</p><p id="17b1" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">测试承诺可能比你想象的要容易，因为 <code class="fe my mz na nb b"><em class="mi">setTimeout</em></code> <em class="mi">可以作为你的异步“任务”！</em></p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nc"><img src="../Images/bb7611f6e2c7dc200ce5424559338adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RSl1brYVnhpkZi9PllrmGw.png"/></div></div></figure><h1 id="095e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基本承诺用法</h1><p id="699b" class="pw-post-body-paragraph jv jw iq jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ij bi translated">构造函数<code class="fe my mz na nb b">new Promise()</code>应该只用于遗留的异步任务，比如使用<code class="fe my mz na nb b">setTimeout</code>或<code class="fe my mz na nb b">XMLHttpRequest</code>。用<code class="fe my mz na nb b">new</code>关键字创建一个新的promise，Promise向所提供的回调函数提供<code class="fe my mz na nb b">resolve</code>和<code class="fe my mz na nb b">reject</code>函数:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="d720" class="nh lg iq nb b gy ni nj l nk nl">var p = new Promise(function(resolve, reject) {<br/>	<br/>	// Do an async task async task and then...</span><span id="d5ff" class="nh lg iq nb b gy nm nj l nk nl">	if(/* good condition */) {<br/>		resolve('Success!');<br/>	}<br/>	else {<br/>		reject('Failure!');<br/>	}<br/>});</span><span id="cd75" class="nh lg iq nb b gy nm nj l nk nl">p.then(function(result) { <br/>	/* do something with the result */<br/>}).catch(function() {<br/>	/* error :( */<br/>}).finally(function() {<br/>   /* executes regardless or success for failure */ <br/>});</span></pre><p id="508d" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">开发人员可以根据给定任务的结果，在回调函数体中手动调用<code class="fe my mz na nb b">resolve</code>或<code class="fe my mz na nb b">reject</code>。一个现实的例子是将XMLHttpRequest转换为基于承诺的任务:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="5166" class="nh lg iq nb b gy ni nj l nk nl">function get(url) {<br/>  // Return a new promise.<br/>  return new Promise(function(resolve, reject) {<br/>    // Do the usual XHR stuff<br/>    var req = new XMLHttpRequest();<br/>    req.open('GET', url);<br/><br/>    req.onload = function() {<br/>      // This is called even on 404 etc<br/>      // so check the status<br/>      if (req.status == 200) {<br/>        // Resolve the promise with the response text<br/>        resolve(req.response);<br/>      }<br/>      else {<br/>        // Otherwise reject with the status text<br/>        // which will hopefully be a meaningful error<br/>        reject(Error(req.statusText));<br/>      }<br/>    };<br/><br/>    // Handle network errors<br/>    req.onerror = function() {<br/>      reject(Error("Network Error"));<br/>    };<br/><br/>    // Make the request<br/>    req.send();<br/>  });<br/>}<br/><br/>// Use it!<br/>get('story.json').then(function(response) {<br/>  console.log("Success!", response);<br/>}, function(error) {<br/>  console.error("Failed!", error);<br/>});</span></pre><p id="1099" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">有时候你不需要<em class="mi">在承诺内完成一个异步任务——如果<em class="mi">有可能</em>采取一个异步动作，然而，返回一个承诺将是最好的，这样你就可以总是依靠一个来自给定函数的承诺。在这种情况下，您可以简单地调用<code class="fe my mz na nb b">Promise.resolve()</code>或<code class="fe my mz na nb b">Promise.reject()</code>而不使用<code class="fe my mz na nb b">new</code>关键字。例如:</em></p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="6c9d" class="nh lg iq nb b gy ni nj l nk nl">var userCache = {};</span><span id="f798" class="nh lg iq nb b gy nm nj l nk nl">function getUserDetail(username) {<br/>  // In both cases, cached or not, a promise will be returned</span><span id="b0ca" class="nh lg iq nb b gy nm nj l nk nl">  if (userCache[username]) {<br/>  	// Return a promise without the "new" keyword<br/>    return Promise.resolve(userCache[username]);<br/>  }</span><span id="bfad" class="nh lg iq nb b gy nm nj l nk nl">  // Use the fetch API to get the information<br/>  // fetch returns a promise<br/>  return fetch('users/' + username + '.json')<br/>    .then(function(result) {<br/>      userCache[username] = result;<br/>      return result;<br/>    })<br/>    .catch(function() {<br/>      throw new Error('Could not find user: ' + username);<br/>    });<br/>}</span></pre><p id="fad9" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">因为承诺总是被返回，所以您总是可以对其返回值使用<code class="fe my mz na nb b">then</code>和<code class="fe my mz na nb b">catch</code>方法！</p><h1 id="ac68" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">然后</h1><p id="d1a5" class="pw-post-body-paragraph jv jw iq jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ij bi translated">所有promise实例都有一个<code class="fe my mz na nb b">then</code>方法，允许您对promise做出反应。第一个<code class="fe my mz na nb b">then</code>方法回调接收由<code class="fe my mz na nb b">resolve()</code>调用给它的结果:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="52e0" class="nh lg iq nb b gy ni nj l nk nl">new Promise(function(resolve, reject) {<br/>	// A mock async action using setTimeout<br/>	setTimeout(function() { resolve(10); }, 3000);<br/>})<br/>.then(function(result) {<br/>	console.log(result);<br/>});</span><span id="4abb" class="nh lg iq nb b gy nm nj l nk nl">// From the console:<br/>// 10</span></pre><p id="bb38" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated"><code class="fe my mz na nb b">then</code>当承诺完成时，会触发回调。你也可以链接<code class="fe my mz na nb b">then</code>方法回调:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="8ca8" class="nh lg iq nb b gy ni nj l nk nl">new Promise(function(resolve, reject) { <br/>	// A mock async action using setTimeout<br/>	setTimeout(function() { resolve(10); }, 3000);<br/>})<br/>.then(function(num) { console.log('first then: ', num); return num * 2; })<br/>.then(function(num) { console.log('second then: ', num); return num * 2; })<br/>.then(function(num) { console.log('last then: ', num);});</span><span id="5010" class="nh lg iq nb b gy nm nj l nk nl">// From the console:<br/>// first then:  10<br/>// second then:  20<br/>// last then:  40</span></pre><p id="4b8b" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">每个<code class="fe my mz na nb b">then</code>接收前一个<code class="fe my mz na nb b">then</code>返回值的结果。</p><p id="0446" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">如果一个承诺已经解决了，但是再次调用了<code class="fe my mz na nb b">then</code>，回调将立即触发。如果承诺被拒绝了，而你在被拒绝后打电话<code class="fe my mz na nb b">then</code>，那么回拨永远不会打。</p><h1 id="a264" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">捕捉</h1><p id="6334" class="pw-post-body-paragraph jv jw iq jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ij bi translated"><code class="fe my mz na nb b">catch</code>当承诺被拒绝时，执行回调:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="9caf" class="nh lg iq nb b gy ni nj l nk nl">new Promise(function(resolve, reject) {<br/>	// A mock async action using setTimeout<br/>	setTimeout(function() { reject('Done!'); }, 3000);<br/>})<br/>.then(function(e) { console.log('done', e); })<br/>.catch(function(e) { console.log('catch: ', e); });</span><span id="b873" class="nh lg iq nb b gy nm nj l nk nl">// From the console:<br/>// 'catch: Done!'</span></pre><p id="7d66" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">向<code class="fe my mz na nb b">reject</code>方法提供什么取决于你自己。一个常见的模式是向<code class="fe my mz na nb b">catch</code>发送一个<code class="fe my mz na nb b">Error</code>:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="6e46" class="nh lg iq nb b gy ni nj l nk nl">reject(Error('Data could not be found'));</span></pre><h1 id="4746" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">最后</h1><p id="61d5" class="pw-post-body-paragraph jv jw iq jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ij bi translated">新引入的<code class="fe my mz na nb b">finally</code>回调无论成功还是失败都会被调用:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="04f5" class="nh lg iq nb b gy ni nj l nk nl">(new Promise((resolve, reject) =&gt; { reject("Nope"); }))<br/>    .then(() =&gt; { console.log("success") })<br/>    .catch(() =&gt; { console.log("fail") })<br/>    .finally(res =&gt; { console.log("finally") });</span><span id="0f42" class="nh lg iq nb b gy nm nj l nk nl">// &gt;&gt; fail<br/>// &gt;&gt; finally</span></pre><h1 id="04bc" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe my mz na nb b">Promise.all</code></h1><p id="3e9b" class="pw-post-body-paragraph jv jw iq jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ij bi translated">想想JavaScript加载器:有时您触发了多个异步交互，但只想在所有交互都完成后才响应——这就是<code class="fe my mz na nb b">Promise.all</code>的用武之地。<code class="fe my mz na nb b">Promise.all</code>方法接受一个承诺数组，并在所有承诺都解决后触发一次回调:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="828e" class="nh lg iq nb b gy ni nj l nk nl">Promise.all([promise1, promise2]).then(function(results) {<br/>	// Both promises resolved<br/>})<br/>.catch(function(error) {<br/>	// One or more promises was rejected<br/>});</span></pre><p id="8735" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">思考<code class="fe my mz na nb b">Promise.all</code>的一个完美方式是一次发出多个AJAX(通过<code class="fe my mz na nb b">fetch</code>)请求:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="99b9" class="nh lg iq nb b gy ni nj l nk nl">var request1 = fetch('/users.json');<br/>var request2 = fetch('/articles.json');</span><span id="29ca" class="nh lg iq nb b gy nm nj l nk nl">Promise.all([request1, request2]).then(function(results) {<br/>	// Both promises done!<br/>});</span></pre><p id="1997" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">您可以组合像<code class="fe my mz na nb b">fetch</code>这样的API和电池API，因为它们都返回承诺:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="43f8" class="nh lg iq nb b gy ni nj l nk nl">Promise.all([fetch('/users.json'), navigator.getBattery()]).then(function(results) {<br/>	// Both promises done!<br/>});</span></pre><p id="aab5" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">当然，处理拒绝是困难的。如果任何承诺被拒绝，第一个拒绝将触发<code class="fe my mz na nb b">catch</code>:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="99e4" class="nh lg iq nb b gy ni nj l nk nl">var req1 = new Promise(function(resolve, reject) { <br/>	// A mock async action using setTimeout<br/>	setTimeout(function() { resolve('First!'); }, 4000);<br/>});<br/>var req2 = new Promise(function(resolve, reject) { <br/>	// A mock async action using setTimeout<br/>	setTimeout(function() { reject('Second!'); }, 3000);<br/>});<br/>Promise.all([req1, req2]).then(function(results) {<br/>	console.log('Then: ', results);<br/>}).catch(function(err) {<br/>	console.log('Catch: ', err);<br/>});</span><span id="254a" class="nh lg iq nb b gy nm nj l nk nl">// From the console:<br/>// Catch: Second!</span></pre><p id="9919" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">随着越来越多的API走向承诺，T21将会非常有用。</p><h1 id="0377" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe my mz na nb b">Promise.race</code></h1><p id="1d13" class="pw-post-body-paragraph jv jw iq jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ij bi translated"><code class="fe my mz na nb b">Promise.race</code>是一个有趣的函数——它不是等待所有承诺都被解决或拒绝，而是在数组中的任何承诺被解决或拒绝后立即触发:</p><pre class="ku kv kw kx gt nd nb ne nf aw ng bi"><span id="a57c" class="nh lg iq nb b gy ni nj l nk nl">var req1 = new Promise(function(resolve, reject) { <br/>	// A mock async action using setTimeout<br/>	setTimeout(function() { resolve('First!'); }, 8000);<br/>});<br/>var req2 = new Promise(function(resolve, reject) { <br/>	// A mock async action using setTimeout<br/>	setTimeout(function() { resolve('Second!'); }, 3000);<br/>});<br/>Promise.race([req1, req2]).then(function(one) {<br/>	console.log('Then: ', one);<br/>}).catch(function(one, two) {<br/>	console.log('Catch: ', one);<br/>});</span><span id="fcb8" class="nh lg iq nb b gy nm nj l nk nl">// From the console:<br/>// Then: Second!</span></pre><p id="9ec2" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">一个用例可能是触发对一个主要源和一个次要源的请求(如果主要源或次要源不可用)。</p><h1 id="c463" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">习惯承诺</h1><p id="539f" class="pw-post-body-paragraph jv jw iq jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ij bi translated">大多数新的JavaScript APIs都是用基于承诺的模式实现的，这是一件好事！开发人员能够避免回调地狱，异步交互可以像任何其他变量一样传递。承诺需要一些时间来适应工具的存在，现在是学习它们的时候了！</p></div></div>    
</body>
</html>