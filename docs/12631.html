<html>
<head>
<title>How to render concurrently on a <canvas/> with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React同时渲染一个<canvas/></h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/non-blocking-canvas-rendering-with-concurrent-react-f46032b03efa?source=collection_archive---------2-----------------------#2022-06-25">https://levelup.gitconnected.com/non-blocking-canvas-rendering-with-concurrent-react-f46032b03efa?source=collection_archive---------2-----------------------#2022-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6ae9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在不阻塞主线程的情况下在画布上呈现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f3bf13eaba590ff1310ee0678d01eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVMJF9pGYY0MbggEMZrqfQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">React徽标|来源:维基共享资源</figcaption></figure><p id="fe76" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">新的React 18提供了<a class="ae lr" href="https://pl.reactjs.org/blog/2022/03/29/react-v18.html#new-feature-transitions" rel="noopener ugc nofollow" target="_blank">并发功能</a>，让你的应用响应更快。不幸的是，它只涵盖了组件渲染部分——组件效果仍然会阻塞主线程。在本文中，我将向您展示<a class="ae lr" href="https://www.npmjs.com/package/use-transition-effect" rel="noopener ugc nofollow" target="_blank">使用-过渡-效果</a>，这是我开发的一个新包，可以同时运行重度效果<em class="ls">(就像在画布上渲染)</em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">并发渲染要好得多…我会在文章的最后回到这个例子。</figcaption></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="3d31" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">基础知识</h1><p id="1133" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">让我们暂时忘记<em class="ls"> React </em>，以便更全面地了解前端性能问题。这将有助于更深入地理解并发特性是如何工作的。</p><h2 id="1fe7" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">是什么让前端感觉很慢？</h2><p id="022b" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">当用户试图与前端应用程序交互时，前端应用程序会感觉很慢，但页面没有响应，因为它正在处理其他事情。</p><p id="8317" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当一个任务执行时间过长时，它会阻止浏览器响应用户输入:页面感觉很慢。</p><h2 id="4c82" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">什么是任务？</h2><p id="e6fd" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated"><strong class="kx ir">任务</strong>是浏览器渲染一个帧的工作单元。<br/>它由以下步骤组成:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/0c8199b8647322622d2048524d1a22f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ClgWLqfzsSkcEoICHmNkJg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">这些步骤通常被称为“渲染管道”</figcaption></figure><p id="8366" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在这篇web.dev文章 中找到更多关于渲染管道的信息。</p><h2 id="993f" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">什么是长任务？</h2><p id="4878" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">一个<a class="ae lr" href="https://web.dev/long-tasks-devtools/#what-are-long-tasks" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">长任务</strong> </a> <strong class="kx ir"> </strong>是一个耗时超过50毫秒的任务，50毫秒的值基于以用户为中心的性能模型<a class="ae lr" href="https://web.dev/rail/" rel="noopener ugc nofollow" target="_blank"> RAIL </a>。如果一项任务耗时超过50毫秒，用户输入就会感觉被延迟了(这就是我们大脑的工作方式，🧠).</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm lu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">了解任务持续时间如何影响感知绩效</figcaption></figure><p id="a3b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你考虑长任务问题，问题不在于给定的任务花费太长时间，而在于它<strong class="kx ir">阻塞了</strong>其他任务。</p><blockquote class="nn"><p id="c4a6" class="no np iq bd nq nr ns nt nu nv nw lq dk translated">这里的主要问题不是性能，而是调度。<br/>——丹·阿布拉莫夫(<a class="ae lr" href="https://youtu.be/nLF0n9SACd4?t=1932" rel="noopener ugc nofollow" target="_blank">超越React 16 </a>)</p></blockquote><h2 id="99f6" class="mz md iq bd me na nx dn mi nc ny dp mm le nz nf mo li oa nh mq lm ob nj ms nk bi translated">如何解锁主线程？</h2><p id="da2f" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">解锁主线程主要有两种策略——<em class="ls">并行</em>和<em class="ls">并发</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/8136acdf83ef5ab8f5192c33d6f5799e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PvlConyFMqcSls4vswGurQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">不同的任务运行策略</figcaption></figure><p id="dd30" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">并行性</strong>是关于<strong class="kx ir"> </strong>在<strong class="kx ir">多线程上运行，</strong>所以可能<em class="ls">字面上</em>在独立的CPU内核上同时运行多个任务。</p><p id="f753" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">并发</strong>是关于在一个<strong class="kx ir">单线程</strong>上运行，并在任务之间快速切换，以创造一个<em class="ls">并行运行它们的假象</em>。</p><p id="f79e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">调度</strong>是一种包含任务优先级的并发性变体。</p><h2 id="f3d5" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">为什么是并发/调度而不是并行(WebWorker)？</h2><p id="7d12" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">web worker API允许你在多线程上运行JavaScript代码。不幸的是，WebWorker API有许多限制。最大的问题是缺少DOM访问。此外，您必须复制数据以便在线程之间发送，这本身就可能引入一个很长的任务。</p><p id="0263" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从我个人的经验来看，WebWorkers擅长数据处理和数字运算，但很难用于UI相关的东西。使现有代码在WebWorker环境中工作比为调度程序调整代码要困难得多。</p><p id="5843" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">TLDR；如果WebWorker适合您的情况，那太好了，使用它吧！否则，使用并发/调度。</p><h2 id="c5b5" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">并发性需要什么？</h2><p id="9bee" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">并发是指在不同的任务之间快速切换。要切换到另一个任务，您必须中断/暂停当前任务。要中断当前任务，可以使用生成器函数。常用的技术是每10 ms暂停一次，这样浏览器还有6 ms的时间来完成渲染流水线，满足60 FPS <em class="ls">的16 ms截止时间(因为1s / 60 </em> ≈ <em class="ls"> 16 ms所以是16 ms)。</em></p><p id="1974" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要决定运行哪个任务，您需要一个调度程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/083e93d2ce5a86c8fe9968e351a6e10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0i-8alatsK4oWBe_kYxMgQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">要解除主线程的阻塞，您必须将长任务拆分成多个短任务</figcaption></figure><h2 id="889e" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">如何构建一个简单的“调度程序”</h2><p id="c45b" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">我实现了一个非常简单的调度程序(它一次只能运行一个生成器函数，没有优先级)。想法是运行生成器函数，直到我们到达截止时间(10 ms)，暂停它，并使用<code class="fe oe of og oh b">setTimeout()</code>安排一个函数来恢复它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">检查src/scheduler.js文件。</figcaption></figure><p id="0785" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个实现离生产就绪还差得很远。比如<code class="fe oe of og oh b">setTimeout()</code>引入4 ms lag(最小setTimeout延迟)，我们不能调度多个函数，也没有优先级(所以是简单的并发)。好在我们可以使用React团队开发的<a class="ae lr" href="https://www.npmjs.com/package/scheduler" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">调度器</strong> </a>包。它处理所有这些调度程序功能。此外，有了单个调度程序，就不太可能出现资源匮乏的情况(通过竞争调度程序)。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="41f4" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">调度程序包</h1><p id="a58b" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">从React 17开始，<code class="fe oe of og oh b">react-dom</code>包包含了<code class="fe oe of og oh b">scheduler</code>包作为依赖项。在React 18的并发特性中使用了<code class="fe oe of og oh b">scheduler</code>包，比如并发组件渲染。</p><h2 id="bf5a" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">并发组件渲染算法如下:</h2><ol class=""><li id="3f36" class="oi oj iq kx b ky mu lb mv le ok li ol lm om lq on oo op oq bi translated">开始渲染一个新的虚拟DOM。</li><li id="0390" class="oi oj iq kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">如果渲染时间超过阈值<em class="ls">(例如10 ms) </em>，则中断渲染。否则，将呈现的虚拟DOM应用于真实DOM。</li><li id="f560" class="oi oj iq kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">主线程被解除阻塞—运行其他高优先级任务，如事件处理程序，并呈现一个帧。</li><li id="1428" class="oi oj iq kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">如果渲染被中断，请恢复渲染，然后转到步骤2。</li></ol><p id="5a37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它将组件渲染任务分成几个较小的非阻塞任务。这里有一个例子可以让你看到它的作用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm lu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">useDeferredValue()使输入总是有响应的。去抖是不可能的。</figcaption></figure><p id="e63a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值得注意的是，目前，并发渲染需要昂贵组件的记忆。你可以用<code class="fe oe of og oh b">useTransition()</code>钩子达到和<code class="fe oe of og oh b">useDeferredValue()</code>一样的效果，但是更罗嗦。</p><p id="436e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我在文章开头所说，它只涵盖了组件渲染部分— <strong class="kx ir">组件效果仍然可以阻塞主线程</strong>。让我们看看如何使用scheduler包来解除阻塞组件效果中的主线程。</p><h1 id="07d1" class="mc md iq bd me mf ow mh mi mj ox ml mm jw oy jx mo jz oz ka mq kc pa kd ms mt bi translated">使用调度程序包</h1><p id="5924" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">这些是调度程序API最重要的部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb lu l"/></div></figure><p id="9aae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有导出的函数都带有前缀<code class="fe oe of og oh b">unstable_</code>，以强调我们不应该期望它们会遵循语义版本化。如果您想使用scheduler API，我建议重新导出这些函数。这样，万一将来API发生变化，您就有了一个适应的地方:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb lu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">重新导出调度程序API，以便更好地控制意外的API更改。</figcaption></figure><h1 id="34ed" class="mc md iq bd me mf ow mh mi mj ox ml mm jw oy jx mo jz oz ka mq kc pa kd ms mt bi translated">useTransitionEffect()</h1><p id="b6d0" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">为了集成生成器函数、调度器和React，我创建了<code class="fe oe of og oh b"><strong class="kx ir">use-transition-effect</strong></code>包(<a class="ae lr" href="https://www.npmjs.com/package/use-transition-effect" rel="noopener ugc nofollow" target="_blank"> npm </a>，<a class="ae lr" href="https://github.com/piotr-oles/use-transition-effect/blob/main/src/use-transition-effect.ts" rel="noopener ugc nofollow" target="_blank">源代码</a>)。您不必升级到React 18，它也适用于React 17。我鼓励你看看源代码——只有100行代码。该API类似于React中的<code class="fe oe of og oh b"><a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html#usetransition" rel="noopener ugc nofollow" target="_blank">useTransition</a></code>钩子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb lu l"/></div></figure><p id="9f4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oe of og oh b">startTransitionEffect</code>让您在不阻塞主线程的情况下安排长时间运行的效果。它需要一个生成器函数作为参数，因此您可以放弃阻塞主线程:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb lu l"/></div></figure><p id="859b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，您可以生成并返回一个清理函数，该函数将在过渡停止时运行(包括卸载):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb lu l"/></div></figure><p id="3e23" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oe of og oh b">stopTransitionEffect</code>让你停止当前长时间运行的效果。你可以把它作为一个<code class="fe oe of og oh b">useEffect</code>清理:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb lu l"/></div></figure><p id="d323" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oe of og oh b">isPending</code>指示过渡效果何时激活，以显示待定状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb lu l"/></div></figure><p id="4d9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oe of og oh b">scheduler</code>包导出了<code class="fe oe of og oh b">unstable_shouldYield()</code>函数，如果当前任务耗时太长，该函数返回true。你可以用它来决定何时让步:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb lu l"/></div></figure><p id="fd15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想在一个过渡效果中更新状态，你必须用<code class="fe oe of og oh b">scheduler</code>包中的<code class="fe oe of og oh b">unstable_runWithPriority()</code>函数包装这个更新(优先级高于<code class="fe oe of og oh b">IdlePriority</code>)。否则，过渡效果内的状态更新将在过渡效果结束时运行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb lu l"/></div></figure><p id="78da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是前面使用<code class="fe oe of og oh b">useTransitionEffect()</code>实现素数计算的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">最有趣的文件是src/ <em class="pc"> PrimesResult.js </em></figcaption></figure><h1 id="5261" class="mc md iq bd me mf ow mh mi mj ox ml mm jw oy jx mo jz oz ka mq kc pa kd ms mt bi translated">实际用法</h1><p id="573c" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">不得不承认，在前端找素数并不是一个实际的例子。我选择它是因为它简单。但是还有更实际的:</p><h2 id="d219" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">在<canvas>上渲染</canvas></h2><p id="9262" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">如果你渲染大量的数据点/图形，迟早会遇到性能问题。您可以尝试使用WebWorker和<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas" rel="noopener ugc nofollow" target="_blank"> OffscreenCanvas </a>，但是在撰写本文时，OffscreenCanvas <a class="ae lr" href="https://caniuse.com/offscreencanvas" rel="noopener ugc nofollow" target="_blank">还没有得到很好的支持</a>。此外，您将不得不做出重要的更改来适应现有的代码。</p><p id="32bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe oe of og oh b"><em class="ls">useTransitionEffect()</em></code>，你可以在不阻塞主线程的情况下，在背景画布上进行增量渲染。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">本文开头的例子。我希望源代码现在看起来更熟悉。</figcaption></figure><h2 id="a69a" class="mz md iq bd me na nb dn mi nc nd dp mm le ne nf mo li ng nh mq lm ni nj ms nk bi translated">处理数据</h2><p id="57f5" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">从/向工作人员发送数据需要数据序列化。如果您必须处理相对较大的数据，仅仅是从/向工作人员发送数据就可能会导致一个很长的任务。</p><p id="4ec6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe oe of og oh b"><em class="ls">useTransitionEffect()</em></code>，您不必序列化任何数据。您可以增量处理它，而不会阻塞主线程。</p><h1 id="a011" class="mc md iq bd me mf ow mh mi mj ox ml mm jw oy jx mo jz oz ka mq kc pa kd ms mt bi translated">结论</h1><p id="da1a" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">调度是交付响应性用户界面的一种非常强大的技术。我们必须记住，我们的一些用户使用的设备要慢得多——因此，即使你的网站感觉响应迅速，也可能是因为你有一台用于开发的高端计算机。启用CPU节流<em class="ls">(Chrome中的DevTools / Performance选项卡)</em>并观察它的行为是个好主意。</p><p id="3a4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我觉得用<code class="fe oe of og oh b">unstable_</code> API还是可以的。我认为在下一个React版本中不会有太大的变化。我怀疑React团队在等待<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/Scheduler" rel="noopener ugc nofollow" target="_blank">调度API </a>在所有浏览器中可用。然后，他们将决定是否希望将他们的实现作为浏览器API上的一个瘦抽象，或者是否希望完全摆脱它。无论哪种方式，迁移都应该很容易。</p><p id="4ca4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你喜欢这个<a class="ae lr" href="https://github.com/piotr-oles/use-transition-effect" rel="noopener ugc nofollow" target="_blank">使用-过渡-效果</a>包，请给它一个⭐️星，如果你喜欢这个内容，我欢迎你关注我的媒体账户——这是我的第一篇文章，我打算写更多👨‍💻</p></div></div>    
</body>
</html>