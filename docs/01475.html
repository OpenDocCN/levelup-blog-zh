<html>
<head>
<title>Manage and Share React Local State with Confidence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理和共享充满信心地对本地状态做出反应</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/manage-and-share-react-local-state-with-confidence-42523fee555c?source=collection_archive---------13-----------------------#2020-01-05">https://levelup.gitconnected.com/manage-and-share-react-local-state-with-confidence-42523fee555c?source=collection_archive---------13-----------------------#2020-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a526effc1bbf5d2221246f760b063cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sPYxoHf4T0bQmE7G.jpg"/></div></div></figure><p id="7a8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我一直在强调避免使用Redux或其他状态管理解决方案来处理不需要它的场景或状态片段。不过，我不打算在这里详细阐述。如果你想了解更多为什么我会有这种感觉，看看我以前的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/react-is-a-state-manager-too-ya-know-ff3a7b357eeb">帖子</a>。我想分享一下我在没有外部状态管理的应用程序中处理CRUD(<strong class="ka ir">C</strong>create，<strong class="ka ir"> R </strong> ead，<strong class="ka ir"> U </strong> pdate，<strong class="ka ir"> D </strong> elete)的方法(借助TypeScript)。逻辑本身并不独特，但希望这能让您更多地考虑如何管理组件中的本地状态。</p><h2 id="3ea4" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">让我们开始吧。</h2><p id="bfd8" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">让我们建立一个场景，其中我们有一个应用程序，它有与各种帖子相关联的CRUD，为了简单起见，这些帖子的状态是在一个中央<code class="fe lv lw lx ly b">App</code>组件中设置的。该组件将从一个API获取帖子，将它们设置为本地状态，然后将各种状态更新程序传递给其子组件。我们将在一会儿得到那些更新，首先让我们得到我们的职位。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="6f17" class="kx ky iq ly b gy mh mi l mj mk"><em class="ml">export</em> interface Post {<br/>   id: string;<br/>   content: string;<br/>   date: Date;<br/>}</span><span id="cf74" class="kx ky iq ly b gy mm mi l mj mk">const App: React.FC = (): JSX.Element =&gt; {<br/>   const [posts, setPosts] = useState&lt;Post[]&gt;([]);<br/>   const [loading, setLoading] = useState&lt;boolean&gt;(true);<br/>   const [error, setError] = useState&lt;boolean&gt;(false);</span><span id="082c" class="kx ky iq ly b gy mm mi l mj mk">useEffect(() =&gt; {<br/>   (async () =&gt; {<br/>      <em class="ml">try</em> {<br/>         const res = <em class="ml">await</em> fetch(postsUrl);<br/>         const posts: Post[] = <em class="ml">await</em> res.json();<br/>         <em class="ml">await</em> setPosts(posts);<br/>      } <em class="ml">catch</em>(error) {<br/>          setError(error)<br/>      }<br/>    setLoading(false)<br/>   })();<br/> }, [])<br/>}</span></pre><p id="ebe4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很酷，很直接的在坐骑上取东西。我们处理CRUD的一种方法是简单地将<code class="fe lv lw lx ly b">setPosts</code>传递给子组件:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="7171" class="kx ky iq ly b gy mh mi l mj mk"><em class="ml">//App.tsx<br/>return</em> (<br/>   &lt;PostList <em class="ml">posts</em>={posts} /&gt;<br/>   &lt;SinglePost <em class="ml">setPosts</em>={setPosts} /&gt;<br/>   &lt;CreatePost <em class="ml">setPosts</em>={setPosts} /&gt;<br/>)</span></pre><p id="c935" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，在<code class="fe lv lw lx ly b">CreatePost</code>中，当一个帖子被创建时，我们可以将它添加到我们的<code class="fe lv lw lx ly b">posts</code>状态:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="fc77" class="kx ky iq ly b gy mh mi l mj mk"><em class="ml">import</em> React, { useState, Dispatch, SetStateAction } <em class="ml">from</em> 'react';<br/><em class="ml">import</em> { Post } <em class="ml">from</em> './App';</span><span id="334a" class="kx ky iq ly b gy mm mi l mj mk">interface Props {<br/>   setPosts: Dispatch&lt;SetStateAction&lt;Post[]&gt;&gt;<br/>}</span><span id="325b" class="kx ky iq ly b gy mm mi l mj mk"><em class="ml">//Use TS Omit utility to omit id property that will be generated by the server (in theory)<br/></em>type CreatePostRequest = &lt;Omit&lt;Post, 'id'&gt;&gt;</span><span id="aa9a" class="kx ky iq ly b gy mm mi l mj mk">const initialFormState: CreatePostRequest = { <br/>   content: '',<br/>   date: new Date()<br/>}</span><span id="4bf8" class="kx ky iq ly b gy mm mi l mj mk">const CreatePost: React.FC&lt;Props&gt; = ({ setPosts }): JSX.Element =&gt; {<br/>   const [newPost, setNewPost] = useState&lt;CreatePostRequest&gt;(<br/>      initialFormState<br/>   )<br/>   const [loading, setLoading] = useState&lt;boolean&gt;(true);<br/>   const [error, setError] = useState&lt;boolean&gt;(false);</span><span id="ffd1" class="kx ky iq ly b gy mm mi l mj mk">   const createPost = async (): Promise&lt;void&gt; =&gt; {<br/>      setLoading(true);<br/>      <em class="ml">try</em> {<br/>         const res = <em class="ml">await</em> fetch(createPostUrl, {<br/>            method: 'POST',<br/>            body: JSON.stringify(newPost)<br/>         })<br/>         const createdPost: Post = <em class="ml">await</em> res.json();<br/>         <em class="ml">//update parent state<br/>         </em>setPosts(prevPosts =&gt; [...prevPosts, createdPost]);<br/>         setNewPost(initialFormState)<br/>     } <em class="ml">catch</em>(error) {<br/>        setError(error)<br/>     }<br/>     setLoading(false)<br/>}</span><span id="c128" class="kx ky iq ly b gy mm mi l mj mk">...</span><span id="c348" class="kx ky iq ly b gy mm mi l mj mk">  return (<br/>     &lt;form onSubmit={createPost}&gt;<br/>        ...<br/>     &lt;/form&gt;</span><span id="246b" class="kx ky iq ly b gy mm mi l mj mk">  )<br/>}</span></pre><p id="378a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，当提交表单时，会触发一个创建帖子的请求，然后返回创建的帖子。然后，我们可以将帖子添加到我们的父节点<code class="fe lv lw lx ly b">App</code>所在的州。提醒一下，任何set state函数的初始参数都是前一个状态，所以我们可以把我们的新帖子附加到前一个帖子上。</p><p id="da8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管传递在<code class="fe lv lw lx ly b">App</code> <em class="ml">中定义的状态更新器可以工作</em>，但这是一个糟糕的范例。消费组件必须知道如何使用初始的先前状态参数，这给消费组件带来了负担。不仅如此，<code class="fe lv lw lx ly b">App</code>本质上允许任何使用其状态更新器的组件对状态做任何它想做的事情。</p><p id="7376" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从概念上讲，我喜欢把任何包含给定状态的组件看作是该状态的某种服务器。我的意思是，它是该州唯一的真实来源，实际上是应用程序其他部分的API。我努力让尽可能少的智能组件管理大量的哑组件——智能在这里指的是完整的应用程序状态</p><h1 id="02cf" class="mn ky iq bd kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na nb nc lo nd bi translated">满怀信心</h1><p id="1be5" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">让我们定义一些CRUD操作符，我们可以更有把握地传递它们。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="81f0" class="kx ky iq ly b gy mh mi l mj mk">//<em class="ml">App.tsx</em><br/>const addPostToLocalState = (newPost: Post) =&gt; {<br/>   setPosts(prevPosts =&gt; [...prevPosts, newPost])<br/>}</span><span id="7108" class="kx ky iq ly b gy mm mi l mj mk">const updatePostInLocalState = (updatedPost: Post) =&gt; {<br/>   setPosts(prevPosts =&gt;<br/>     prevPosts.map(post =&gt; (post.id === updatedPost.id ? <br/>       updatedPost : post)<br/>    )<br/> )<br/>}</span><span id="43fe" class="kx ky iq ly b gy mm mi l mj mk">const deletePostFromLocalState = (postId: string) =&gt; {<br/>   setPosts(prevPosts =&gt; prevPosts.filter(({ id }) =&gt; id !== postId))<br/>}</span></pre><p id="4c65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在当这些函数被传递给<code class="fe lv lw lx ly b">App</code>的子组件时，您应该会注意到一些关键的区别。首先，消费者不需要了解状态，他们只需将所需的参数传递给操作，就可以了。此外，在命名本地状态更新程序(坦白地说，是所有的东西)时，我喜欢使用冗长的描述性语言，以免混淆我自己或我团队中的其他开发人员。当在包含Redux的代码库中工作时，这一点尤其重要。</p><p id="5b55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在上面链接的文章中试图强调的一点是，并不是应用程序状态的每一部分都需要在Redux store中。我在99%的React应用中使用Redux，但是它很少有超过2-5个属性。我强烈建议你在使用React state时，以及更一般的编程中，应用一种极简主义的方法。我可以自信地说，你未来的自己和其他人会感谢你的。</p><p id="d803" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">差不多就是这样！</p><p id="2d66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的倾听👋🏻</p><p id="256c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里联系我<a class="ae kw" href="https://www.tuckerblackwell.com/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>