<html>
<head>
<title>Kubernetes Authorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes授权</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kubernetes-authorization-f18d82eb1906?source=collection_archive---------6-----------------------#2020-01-17">https://levelup.gitconnected.com/kubernetes-authorization-f18d82eb1906?source=collection_archive---------6-----------------------#2020-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9844" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文最初发表于https://www.magalix.com/blog/kubernetes-authorization</em><a class="ae kp" href="https://www.magalix.com/blog/kubernetes-authorization" rel="noopener ugc nofollow" target="_blank"/></p><p id="853e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes授权的作用很重要。身份验证是指验证特定主体的身份，以决定是否授予其访问权限，而授权则处理访问权限之后的事情。使用授权机制，您可以微调谁可以访问Kubernetes集群上的哪些资源。在本文中，我们将讨论基于角色的访问控制(<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-rbac-101" rel="noopener ugc nofollow" target="_blank"> RBAC </a>)以及如何使用它来保护您的集群。</p><p id="0ff2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes使用API服务器根据一组策略授权请求。值得注意的是，授权是认证成功后的一个步骤。工作流程如下:</p><ol class=""><li id="4382" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">API服务器使用一种支持的身份验证方法对用户进行身份验证。关于这个过程的更多信息，请参考我们关于<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-101-concepts-and-why-it-matters" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>认证的文章。</li><li id="5e55" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">假设请求的目的是检索名称空间Kube-system中的pod列表(例如，使用kubectl get pods -n Kube-system)。首先，在步骤1中对用户进行身份验证，然后将凭证与用户试图执行的<em class="ko">动词</em>、<em class="ko">资源</em>(以及其他方面)一起传递给授权模块。</li><li id="4cd9" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">如果用户(通过<em class="ko">用户</em>我们指人类用户以及应用程序)被授权执行请求，它被传递给准入控制器。否则，API服务器会回复一个403禁止的HTTP状态代码。</li></ol><p id="478c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于角色的访问控制(简称RBAC)从1.8版本开始就是Kubernetes的一部分。强烈建议您甚至在非生产环境中使用它。在与RBAC打交道时，你应该知道一些重要的术语:</p><ul class=""><li id="51cf" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn le kw kx ky bi translated"><strong class="js iu">实体:</strong>这是一个需要访问集群上的<em class="ko">资源</em>的主体。该实体可以是您、您的一位同事、一个pod或您需要授予对集群的编程访问权限的外部程序。</li><li id="48ad" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated"><strong class="js iu">资源:</strong>需要访问的对象。比如一个pod，一个<a class="ae kp" href="https://www.magalix.com/blog/the-configmap-pattern" rel="noopener ugc nofollow" target="_blank"> configMap </a>，一个<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-secrets-101" rel="noopener ugc nofollow" target="_blank"> Secret </a>等等。</li><li id="31b4" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated"><strong class="js iu">角色:</strong>由于向每个用户授予一组特定的权限并可能将它们复制给需要相同访问级别的多个用户是低效的，因此最好创建一个具有该组权限的角色。多个角色可以属于一个用户，多个用户可以属于一个角色。因此，无需手动删除用户帐户的权限，只需从角色中删除即可。</li><li id="c379" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated"><strong class="js iu">角色绑定:</strong>这是在角色和属于这个角色的用户(RBAC术语中的实体)之间建立实际链接的地方。</li></ul><p id="b7aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦创建了角色，就需要定义实体可以执行哪些操作。它们可以分为:</p><ul class=""><li id="207e" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn le kw kx ky bi translated"><strong class="js iu">只读:</strong>此处实体不能修改资源。动词是get和list</li><li id="b138" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated"><strong class="js iu">读写:</strong>其中实体可以修改资源。属于此类别的动词有创建、更新、删除和删除集合。</li></ul><p id="b8fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，您应该区分角色和集群角色。一个角色被绑定到一个名称空间。例如，您可以创建一个角色来访问kube-system名称空间中的pod。<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-pods-101-the-cluster-sailors" rel="noopener ugc nofollow" target="_blank">默认名称空间或kube-system之外的任何其他名称空间中的pod</a>将超出该角色的权限。另一方面，ClusterRole在集群范围内应用。所有名称空间都遵守ClusterRole规则。有些资源本质上要求您授予其请求者集群角色，因为它们没有命名空间。这种资源的一个例子是节点。</p><p id="2254" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">API服务器自动创建许多默认的ClusterRoles和ClusterRoleBinding，集群上的不同资源需要它们才能正常工作。这些角色以system:为前缀，表示它们是由基础设施本身创建和拥有的。例如，kubelet使用system:node。修改此角色可能会导致节点无法正常运行，从而导致整个群集停止运行。除了system:前缀之外，系统角色和角色绑定还附加了kubernetes.io/bootstrapping=rbac-defaults标签。</p><p id="b5da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes还创建了旨在授予用户的默认角色。这样的角色可以被认为是通用功能的预制模板。他们被称为面向用户的角色。</p><h1 id="35ca" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">面向用户的角色</h1><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/5ad28bc31887409a47afed3829dba786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrZ2QYnx5-PN3x3PiYpBXw.png"/></div></div></figure><h1 id="e114" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">实验01:创建管理员用户</h1><p id="fc6b" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated"><strong class="js iu">要求:</strong>你有一位新同事加入了你的团队。通过试用期后，您需要授予她对群集的管理访问权限。您在创建时使用的身份验证方法是X.509证书。现在，第一步是为她创建一个帐户。</p><h1 id="eb42" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">步骤01:为爱丽丝创建一个用户帐户</h1><p id="1f28" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">1.你需要从这里下载并安装CFSSL工具<a class="ae kp" href="https://pkg.cfssl.org/" rel="noopener ugc nofollow" target="_blank">https://pkg.cfssl.org/</a></p><p id="80a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.创建证书签名请求JSON文件，如下所示:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="4e7c" class="mz lg it mv b gy na nb l nc nd">{<br/>    "CN": "alice",<br/>    "key": {<br/>        "algo": "rsa",<br/>        "size": 4096<br/>    },<br/>    "names": [{<br/>        "O": "alice",<br/>        "email": "<a class="ae kp" href="mailto:alice@mycompany.com" rel="noopener ugc nofollow" target="_blank">alice@mycompany.com</a>"<br/>    }]<br/>}</span></pre><p id="63e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从文件生成CSR(证书签名请求),如下所示:cfssl genkey user . JSON | cfssljson-bare client。输出应该如下所示:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="5479" class="mz lg it mv b gy na nb l nc nd">$ cfssl genkey user.json | cfssljson -bare client<br/>2019/11/09 18:14:33 [INFO] generate received request<br/>2019/11/09 18:14:33 [INFO] received CSR<br/>2019/11/09 18:14:33 [INFO] generating key: rsa-4096<br/>2019/11/09 18:14:34 [INFO] encoded CSR</span></pre><p id="d294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.应该为您创建了一个包含csr数据的client.csr文件。还有一个密钥文件client-key.pem，它包含用于签署请求的私钥。</p><p id="2e8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.使用以下命令将请求转换为Base64编码:cat client.csr | base64 | tr -d '\n '。保留结果文本的副本，因为我们将在下一步中使用它。</p><p id="ebc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.通过创建csr.yaml文件并添加以下行来创建CertificateSigningRequest资源:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="2fd8" class="mz lg it mv b gy na nb l nc nd">apiVersion: certificates.k8s.io/v1beta1<br/>kind: CertificateSigningRequest<br/>metadata:<br/> name: alice<br/>spec:<br/> groups:<br/> - mycompany<br/> request: LS0tLS1CRUdJTiBDRVJUSUZJQ0F...<br/> usages:<br/> - digital signature<br/> - key encipherment<br/> - client auth</span></pre><p id="7743" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，请求的数据是我们在上一步中获得的base64编码的CSR。</p><p id="e7d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">6.使用kubectl将请求发送到API服务器，如下所示:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="12a6" class="mz lg it mv b gy na nb l nc nd">$ kubectl apply -f request.yaml<br/>certificatesigningrequest.certificates.k8s.io/alice created</span></pre><p id="28d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">7.作为群集管理员，您可以使用以下命令批准此证书请求:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="4a45" class="mz lg it mv b gy na nb l nc nd">$ kubectl certificate approve alice<br/>certificatesigningrequest.certificates.k8s.io/alice approved</span></pre><p id="49a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">8.由于csr被批准，我们需要下载实际的证书(注意，输出已经是base64编码的。我们不需要解密它，因为我们稍后将在kubeconfig文件中以相同的形式再次使用它):</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="5adc" class="mz lg it mv b gy na nb l nc nd">kubectl get csr alice -o jsonpath='{.status.certificate}'<br/>LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1...</span></pre><p id="e300" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">9.现在，爱丽丝的证书通过了。要使用它，除了API服务器的API之外，她还需要一个kubeconfig文件，该文件引用她的证书、私钥和用于签署该请求的集群CA。我们已经有了私钥和证书，让我们从现有的kubeconfig文件中获取其他信息:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="ffac" class="mz lg it mv b gy na nb l nc nd">$ kubectl config view --flatten --minify<br/>apiVersion: v1<br/>clusters:<br/>- cluster:<br/>    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0t...<br/>    server: <a class="ae kp" href="https://104.198.41.185" rel="noopener ugc nofollow" target="_blank">https://104.198.41.185</a><br/>--- the rest of the output was trimmed for brevity ---</span></pre><p id="fd4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">10.给定我们现在拥有的所有信息，我们可以为Alice创建一个包含以下行的配置文件(确保在将客户端证书日期、客户端密钥数据和证书颁发机构数据添加到配置文件之前，它们是base64编码的):</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="7809" class="mz lg it mv b gy na nb l nc nd">apiVersion: v1<br/>kind: Config<br/>users:<br/>- name: alice<br/>  user:<br/>    client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ…<br/>    client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFU...<br/>clusters:<br/>- cluster:<br/>    certificate-authority-data: LS0tLS1CRUdJTiBDR...<br/>    server: <a class="ae kp" href="https://104.198.41.185" rel="noopener ugc nofollow" target="_blank">https://104.198.41.185</a><br/>  name: gke<br/>contexts:<br/>- context:<br/>    cluster: gke<br/>    user: alice<br/>  name: alice-context<br/>current-context: alice-context</span></pre><p id="60d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一步是把文件交给Alice添加到~/下。kube/配置。然而，我们可以通过传递我们刚刚创建的配置文件(假设我们将其命名为alice_config)来验证她的凭证是否有效。让我们试着列出豆荚:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="d011" class="mz lg it mv b gy na nb l nc nd">$ kubectl  get pods --kubeconfig ./alice_config <br/>Error from server (Forbidden): pods is forbidden: User "alice" cannot list resource "pods" in API group "" in the namespace "default"</span></pre><p id="a95b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们收到的响应非常重要，因为它允许我们验证API服务器是否识别该证书。输出声明“禁止”，这意味着API服务器确认了名为Alice的用户的存在。但是，她没有权限查看默认命名空间上的窗格。有道理。让我们给她所需的权限。</p><h1 id="0d5b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">步骤02:授予Alice对群集的管理权限</h1><p id="2a44" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">因为我们需要向Alice授予集群范围的管理权限，所以我们可以使用现成的集群管理角色。因此，我们只需要一个ClusterRoleBinding资源。用下面几行创建一个YAML文件:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="8f2e" class="mz lg it mv b gy na nb l nc nd">kind: ClusterRoleBinding<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>metadata:<br/> name: cluster-admin-binding<br/>subjects:<br/>- kind: User<br/> name: alice<br/> apiGroup: ""<br/>roleRef:<br/> kind: ClusterRole<br/> name: cluster-admin<br/> apiGroup: ""</span></pre><p id="ad0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有两个有趣的地方:</p><ol class=""><li id="bf0b" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">subjects(第5行)是一个数组。因此，我们可以使用相同的资源添加多个用户。</li><li id="fe63" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">在第11行中，我们引用已经为我们创建的cluster-admin ClusterRole(如我们前面所讨论的)。因此，我们不必创建集群角色。</li></ol><p id="0ed0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用kubectl应用上面的YAML文件:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="29b8" class="mz lg it mv b gy na nb l nc nd">$ kubectl apply -f clusterrolebinding.yml<br/>clusterrolebinding.rbac.authorization.k8s.io/cluser-admin-binding created</span></pre><p id="4b09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们仔细检查Alice是否可以对群集执行命令:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="e2e7" class="mz lg it mv b gy na nb l nc nd">$ kubectl  get pods --kubeconfig ./alice_config<br/>NAME      READY   STATUS    RESTARTS   AGE<br/>testpod   1/1     Running   105        29h<br/>$ kubectl  get nodes --kubeconfig ./alice_config                                                                                                 <br/>NAME                                          STATUS   ROLES    AGE   VERSION<br/>gke-security-lab-default-pool-46f98c95-qsdj   Ready       46h   v1.13.11-gke.9<br/>$ kubectl  get pods -n kube-system --kubeconfig ./alice_config<br/>NAME                                                     READY   STATUS    RESTARTS   AGE<br/>event-exporter-v0.2.4-5f88c66fb7-6l485                   2/2     Running   0          46h<br/>fluentd-gcp-scaler-59b7b75cd7-858kx                      1/1     Running   0          46h<br/>fluentd-gcp-v3.2.0-5xlw5                                 2/2     Running   0          46h<br/>heapster-5cb64d955f-mvnhb                                3/3     Running   0          46h<br/>kube-dns-79868f54c5-kv7tk                                4/4     Running   0          46h<br/>kube-dns-autoscaler-bb58c6784-892sv                      1/1     Running   0          46h<br/>kube-proxy-gke-security-lab-default-pool-46f98c95-qsdj   1/1     Running   0          46h<br/>l7-default-backend-fd59995cd-gzvnj                       1/1     Running   0          46h<br/>metrics-server-v0.3.1-57c75779f-dfjlj                    2/2     Running   0          46h<br/>prometheus-to-sd-k6627                                   1/1     Running   0          46h</span></pre><p id="f3bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过上面的几个命令，Alice能够查看多个名称空间中的pod，还可以获得关于集群节点的信息。</p><h1 id="43b0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">实验Nginx入口控制器RBAC，一个真实的例子</h1><p id="4205" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">Kubernetes使用<a class="ae kp" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口资源</a>作为将外部流量路由到集群内部一个或多个服务的手段。</p><p id="199b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，入口资源仅指定应该遵循的规则(例如，/example.com/users应该转到users-svc服务，/example.com/auth被路由到auth-svc服务，等等)。要将这些规则付诸实施，您需要一个控制器。Kubernetes没有提供自己的入口控制器(至少在撰写本文时是这样)。它让您可以从许多入口控制器提供商中进行选择。在这个例子中，我们讨论的是<a class="ae kp" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank"> Nginx入口控制器</a>。为了使控制器正常工作，它需要通过服务帐户、角色、集群角色以及这些角色工作所需的绑定来操作。让我们看看如何为这种类型的访问配置我们的集群，并看看<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-rbac-101" rel="noopener ugc nofollow" target="_blank"> RBAC </a>如何工作。</p><p id="c13d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>如果你真的需要部署Nginx入口控制器，我们下面讨论的RBAC步骤可能是自动部署方法的一部分，就像使用他们的<a class="ae kp" href="https://github.com/helm/charts/tree/master/stable/nginx-ingress" rel="noopener ugc nofollow" target="_blank"> Nginx控制器导航图</a>。我们手动操作RBAC部分只是为了学习。</p><h1 id="59fb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">服务帐户</h1><p id="c33a" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">这是最简单的部分。您只需要创建一个服务帐户，该帐户将被入口控制器进一步使用。我们将创建的所有角色和绑定都将绑定到该服务帐户。创建一个名为service-account.yaml的新文件，并添加以下几行:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="c716" class="mz lg it mv b gy na nb l nc nd">apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>  name: nginx-ingress-serviceaccount</span></pre><p id="5269" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应用文件:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="4e62" class="mz lg it mv b gy na nb l nc nd">$ kubectl apply -f service-account.yaml<br/>serviceaccount/nginx-ingress-serviceaccount created</span></pre><h1 id="36c7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">角色</h1><p id="e96c" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">角色看起来是这样的:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="8f4d" class="mz lg it mv b gy na nb l nc nd">apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: Role<br/>metadata:<br/>  name: nginx-ingress-role<br/>rules:<br/>  - apiGroups:<br/>      - ""<br/>    resources:<br/>      - configmaps<br/>      - pods<br/>      - secrets<br/>      - namespaces<br/>    verbs:<br/>      - get<br/>  - apiGroups:<br/>      - ""<br/>    resources:<br/>      - configmaps<br/>    resourceNames:<br/>      - "ingress-controller-leader-nginx"<br/>    verbs:<br/>      - get<br/>      - update<br/>  - apiGroups:<br/>      - ""<br/>    resources:<br/>      - configmaps<br/>    verbs:<br/>      - create<br/>  - apiGroups:<br/>      - ""<br/>    resources:<br/>      - endpoints<br/>    verbs:<br/>      - get</span></pre><p id="26ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该角色有几个权限，让我们简单介绍一下:</p><ul class=""><li id="7ddf" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn le kw kx ky bi translated"><strong class="js iu">第6行到第14行:</strong>给予控制器对<a class="ae kp" href="https://www.magalix.com/blog/the-configmap-pattern" rel="noopener ugc nofollow" target="_blank">配置映射</a>、pod、机密和名称空间的读访问(get)。</li><li id="4edf" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated"><strong class="js iu">第15到23行:</strong>允许控制器对特定配置图进行读写访问:入口-控制器-领导者-nginx。这是作为控制器部署步骤的一部分创建的资源。写访问是通过更新谓词进行的。</li><li id="0897" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated"><strong class="js iu">第24到29行:</strong>通过向configmap资源授予创建动词，使控制器能够创建config map。注意，这是一个角色，而不是集群角色，所以这些动作被绑定到一个特定的名称空间(ingress-nginx，我们将在后面看到)。</li><li id="0ecc" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated"><strong class="js iu">第30到35行:</strong>指定控制器还应该拥有对端点资源的读取权限。</li></ul><h1 id="debc" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">集群角色</h1><p id="215f" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">ClusterRole包括适用于整个群集的权限。该文件如下所示:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="b03c" class="mz lg it mv b gy na nb l nc nd">apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: ClusterRole<br/>metadata:<br/>  name: nginx-ingress-clusterrole<br/>  labels:<br/>    app.kubernetes.io/name: ingress-nginx<br/>    app.kubernetes.io/part-of: ingress-nginx<br/>rules:<br/>  - apiGroups:<br/>      - ""<br/>    resources:<br/>      - configmaps<br/>      - endpoints<br/>      - nodes<br/>      - pods<br/>      - secrets<br/>    verbs:<br/>      - list<br/>      - watch<br/>  - apiGroups:<br/>      - ""<br/>    resources:<br/>      - nodes<br/>    verbs:<br/>      - get<br/>  - apiGroups:<br/>      - ""<br/>    resources:<br/>      - services<br/>    verbs:<br/>      - get<br/>      - list<br/>      - watch<br/>  - apiGroups:<br/>      - ""<br/>    resources:<br/>      - events<br/>    verbs:<br/>      - create<br/>      - patch<br/>  - apiGroups:<br/>      - "extensions"<br/>      - "networking.k8s.io"<br/>    resources:<br/>      - ingresses<br/>    verbs:<br/>      - get<br/>      - list<br/>      - watch<br/>  - apiGroups:<br/>      - "extensions"<br/>      - "networking.k8s.io"<br/>    resources:<br/>      - ingresses/status<br/>    verbs:<br/>      - update</span></pre><p id="8256" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，因为需要小心处理群集范围的权限，所以群集角色只授予入口控制器对入口资源的写访问权限。这可以在第39、40行(创建和修补)和第56行(更新)中找到。这里可以创建/修改的资源分别是Ingres和Ingres/status。角色的其余部分将只读谓词授予其他资源。</p><h1 id="06d4" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">RoleBinding和ClusterRoleBinding</h1><p id="c0e1" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">最后一步是使用ClusterRole和ClusterRoleBinding绑定之前创建的服务帐户，如下所示:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="0052" class="mz lg it mv b gy na nb l nc nd">apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: RoleBinding<br/>metadata:<br/>  name: nginx-ingress-role-nisa-binding<br/>  namespace: ingress-nginx<br/>  labels:<br/>    app.kubernetes.io/name: ingress-nginx<br/>    app.kubernetes.io/part-of: ingress-nginx<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: Role<br/>  name: nginx-ingress-role<br/>subjects:<br/>  - kind: ServiceAccount<br/>    name: nginx-ingress-serviceaccount<br/>    namespace: ingress-nginx</span><span id="4825" class="mz lg it mv b gy ne nb l nc nd">---<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: ClusterRoleBinding<br/>metadata:<br/>  name: nginx-ingress-clusterrole-nisa-binding<br/>  labels:<br/>    app.kubernetes.io/name: ingress-nginx<br/>    app.kubernetes.io/part-of: ingress-nginx<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: ClusterRole<br/>  name: nginx-ingress-clusterrole<br/>subjects:<br/>  - kind: ServiceAccount<br/>    name: nginx-ingress-serviceaccount<br/>    namespace: ingress-nginx</span></pre><p id="20ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，RoleBinding限制了对ingress-nginx名称空间的权限(第16行)</p><p id="d97e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将上述文件应用到集群使入口控制器能够正确地监视API服务器以寻找新的入口资源，解析它们以寻找规则，并基于这些规则创建将流量路由到适当服务的必要工作。</p><h1 id="b998" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="5133" class="kq kr it js b jt mp jx mq kb nf kf ng kj nh kn le kw kx ky bi translated">Kubernetes通过RBAC(基于角色的访问控制)处理授权</li><li id="6905" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">RBAC通过使用角色和集群角色来工作。角色在名称空间的上下文中操作，而集群角色在集群范围内工作。</li><li id="fb48" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">要使实体(人类用户或程序)能够使用角色，您必须创建一个引用该角色和绑定到该角色的实体的绑定。对于角色，我们使用RoleBinding资源，而对于集群角色，我们使用ClusterRoleBinding。</li><li id="fa58" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">RBAC使用动词来定义实体可以使用的访问类型。一些动词允许只读访问，而另一些动词需要写访问。</li><li id="1ebe" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">Kubernetes提供了一些现成的预定义角色。其中一些是系统使用的，不应该由管理员更改，而其他的是用来作为快速模板，将权限应用到用户。例如，群集管理角色用于向用户授予群集范围的管理访问权限。</li><li id="ae9f" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">本文中我们有两个实验室。在第一个示例中，我们演示了如何使用X.509证书身份验证策略为新管理员创建用户帐户。然后，我们使用cluster-admin角色为用户提供管理权限，而无需创建角色和手动指定权限。</li><li id="4895" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">在第二个实验中，我们讨论了Nginx-Ingress控制器正常工作所需的必要RBAC权限的真实示例。</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="ef6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">原载于2020年1月17日https://www.magalix.com</em><a class="ae kp" href="https://www.magalix.com/blog/kubernetes-authorization" rel="noopener ugc nofollow" target="_blank"><em class="ko"/></a><em class="ko">。</em></p></div></div>    
</body>
</html>