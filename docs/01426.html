<html>
<head>
<title>How to create a reusable Modal Dialog component in Angular 8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular 8中创建一个可重用的模态对话框组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-reusable-modal-dialog-component-in-angular-8-241cc738d260?source=collection_archive---------0-----------------------#2019-12-30">https://levelup.gitconnected.com/how-to-create-a-reusable-modal-dialog-component-in-angular-8-241cc738d260?source=collection_archive---------0-----------------------#2019-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6330" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上个月我写了一篇关于如何在Angular 8中创建模态对话框组件的文章。通过一个简单的演示，我解释了如何创建一个对话框来“锁定”用户在试图注销时选择两个选项之一:确认操作或取消并返回到应用程序的正常使用。</p><p id="dee8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，在同样的前提下，我们将使对话框组件可重用:单击一个按钮打开带有确认和取消选项的模式对话框。这意味着，将来当应用程序出于其他目的需要类似的确认对话框时，我们只需更改模型接收到的数据和信息，就万事大吉了，不需要创建新的组件。</p><p id="6bab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们进入这个演示的细节！</p><h1 id="d884" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">关于这个演示</h1><p id="a7ff" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在<code class="fe lp lq lr ls b">app-root</code>组件中没有单一的注销按钮，我们将有两个按钮:一个用于注销，另一个用于删除虚拟产品。每个按钮打开完全相同的<code class="fe lp lq lr ls b">modal</code>对话框组件，但是显示不同的信息。这个组件可以从任何父组件中打开，但是为了简单起见，我们将在<code class="fe lp lq lr ls b">app-root</code>中同时拥有注销和产品删除模式。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/9aa321c03b27c1170df44e8ae4c21832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgzRQwoovoFZmlbj_wQ0wg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">带有新按钮的app-root组件</figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/8a7ee88d24dab0bdaf9035bd8d4950d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZHNx3Dk-N2ZjRUMcx8UYw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">注销确认的模式组件</figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/db37f2246b4da5e4c5e2221f6b6aa42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dUvBAFxwEPygxln_fH7Ag.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">产品删除确认的模式组件</figcaption></figure><p id="1ae7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当在模式中点击确认按钮时，调用外部服务<code class="fe lp lq lr ls b">modal-actions</code>。然后，这个服务负责调用第二个服务来完成用户确认的动作。如果第一个解释令人困惑，请查看下图，了解数据在此过程中是如何流动的:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mj"><img src="../Images/af565558d502d991e9d470b385dd6f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qnj4ZPlteqmKm7TrpZlzfA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">模式对话框MatDialogConfig.data对象的流程</figcaption></figure><p id="37aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，调用模态的组件(在我们的例子中是<code class="fe lp lq lr ls b">app-root</code>)通过对话框配置的<code class="fe lp lq lr ls b">data</code>对象属性传递信息(<code class="fe lp lq lr ls b">MatDialogConfig</code>)。当点击确认按钮时，modal将同一个<code class="fe lp lq lr ls b">data</code>对象传递给<code class="fe lp lq lr ls b">modal-actions</code>服务，这样它就可以读取modal的名称，一个包含在对象中的属性。读取名称的目的是为了让<code class="fe lp lq lr ls b">modal-actions</code>知道哪个服务将负责最终执行用户期望的动作。</p><p id="3c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，<code class="fe lp lq lr ls b">modal-actions</code>将<code class="fe lp lq lr ls b">data</code>对象传递给这个最终服务，这样它就可以访问它需要的所有信息(用户id、产品id、名称、对象中包含的任何内容)。在这个演示中，<code class="fe lp lq lr ls b">mock-serv-1</code>或<code class="fe lp lq lr ls b">mock-serv-2</code>将负责完成用户确认的动作。</p><p id="970d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这看起来仍然令人困惑，试着把<code class="fe lp lq lr ls b">modal-actions</code>服务想象成一个隐藏了<code class="fe lp lq lr ls b">modal</code>组件之外的一切来执行用户期望的动作的前台(是的，我是在暗指<a class="ae kl" href="https://en.wikipedia.org/wiki/Facade_pattern#Python" rel="noopener ugc nofollow" target="_blank">外观设计模式</a>)。当每次使用模型只需要其中一个服务时，我们可以让<code class="fe lp lq lr ls b">modal-actions</code>处理所有事情，而不是让<code class="fe lp lq lr ls b">modal</code>组件直接与多个服务通信。换句话说，<code class="fe lp lq lr ls b">modal</code>组件只需要与这一个服务通信。</p><p id="7b35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一方面，你需要多次传递<code class="fe lp lq lr ls b">data</code>对象。但是，另一方面，如果更多的用例出现在这个模态对话框中，你只需要为这个新动作创建一个新的服务，然后将它传递给facade，即<code class="fe lp lq lr ls b">modal-actions</code>服务。<code class="fe lp lq lr ls b">modal</code>组件中的代码独立于服务的这些变化。并且，关于<code class="fe lp lq lr ls b">data</code>对象，对于组件来说，对象只包含模态的名称、标题、描述和按钮的文本。其他属性是对服务的担忧。</p><p id="e2fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们已经讨论了理论，让我们开始构建应用程序吧！</p><h1 id="9133" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤0:项目设置</h1><p id="452f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这部分是我们创建应用程序和安装Angular材质的地方。</p><p id="6725" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从显而易见的开始，创建一个新的角度应用:</p><pre class="lu lv lw lx gt mk ls ml mm aw mn bi"><span id="7ece" class="mo kn iq ls b gy mp mq l mr ms">ng new reusable-modal<br/>cd reusable-modal<br/>code .</span></pre><p id="c4cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个命令创建一个名为<code class="fe lp lq lr ls b">reusable-modal</code>的新应用程序，第二个命令将我们移动到它的目录中。当提示路由时，选择您喜欢的格式，对于样式表格式，我们将使用CSS。</p><p id="7802" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三个命令只是在Visual Studio代码中打开当前工作目录的快捷方式。如果您将它用作代码编辑器，这将非常方便。</p><p id="5667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要安装角形材料，请返回终端并输入:</p><pre class="lu lv lw lx gt mk ls ml mm aw mn bi"><span id="952e" class="mo kn iq ls b gy mp mq l mr ms">ng add @angular/material</span></pre><p id="1010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将提示你三个问题:主题，锤子的设置和材质动画的设置。你可以选择任何你喜欢的主题，因为它不会影响这个演示的功能，但我们不需要HammerJS。另一方面，选择设置材质动画，否则会破坏应用程序。</p><p id="500f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于设置来说，我们只缺少一件事，那就是导入角度材质<code class="fe lp lq lr ls b">MatButtonModule</code>和<code class="fe lp lq lr ls b">MatDialogModule</code>模块。为此，如果我们已经创建了我们的模态组件，将会很方便，所以返回到终端并输入:</p><pre class="lu lv lw lx gt mk ls ml mm aw mn bi"><span id="a6d9" class="mo kn iq ls b gy mp mq l mr ms">ng generate component components\modal</span></pre><p id="2ddc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在一个<code class="fe lp lq lr ls b">components</code>文件夹中创建了我们的模态对话框组件<code class="fe lp lq lr ls b">modal</code>。因为文件夹不存在，所以这个命令也会创建文件夹。请不要关闭您的终端，因为我们稍后会继续讨论它。</p><p id="26b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完成设置，我们将在<code class="fe lp lq lr ls b">app.module.ts</code>文件中添加一些代码:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">应用程序模块</figcaption></figure><p id="9178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经导入了已经提到的角形材料模块(9号线和10号线)，并将它们添加到<code class="fe lp lq lr ls b">@NgModule</code>的导入中。另外，请注意，如果您没有设置路由，那么您需要删除第4行和第18行。最后一次修改是在第26行，<code class="fe lp lq lr ls b">entryComponents: [ModalComponent]</code>。</p><p id="57fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如文档中所描述的，<code class="fe lp lq lr ls b">entryComponents</code>是“定义这个NgModule时要编译的组件集，这样它们就可以动态地加载到视图中”。实际上，如果不声明<code class="fe lp lq lr ls b">entryComponents</code>，这个对话框就不会工作。</p><p id="7da8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们就成功地完成了项目的设置！</p><h1 id="db9f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤1:创建一次性模式</h1><p id="033a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在我们将关注于<code class="fe lp lq lr ls b">app-root</code>组件，并创建一个一次性版本的<code class="fe lp lq lr ls b">modal</code>对话框组件。</p><p id="fad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到这一步结束时，我们将准备好使组件可重用，也就是本文的目标。因此，在这一部分我不会像以前那样详细，因为在我以前的文章中已经解释过了。如果你对创建模态对话框组件有任何疑问，这里没有澄清，请参考<a class="ae kl" href="https://medium.com/swlh/how-to-create-a-modal-dialog-component-in-angular-8-88028d909be0?source=friends_link&amp;sk=1e575e0d678011fed1552d38cbe6346f" rel="noopener">我以前的文章</a>。</p><p id="feb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将编写全局样式，<code class="fe lp lq lr ls b">styles.css</code>，因为它涉及应用程序范围的样式和特定于角度材质对话框的样式。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">样式. css</figcaption></figure><p id="1d49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们的模态对话框使用我们已经创建的<code class="fe lp lq lr ls b">modal</code>组件时，该组件是在一个角度材料对话框覆盖图<code class="fe lp lq lr ls b">mat-dialog-container</code>的上下文中打开的。这意味着，为了设计对话框本身的外观，我们需要设计<code class="fe lp lq lr ls b">mat-dialog-container</code>的样式。</p><p id="8f05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，我们需要小心这些修改，因为我们正在处理一个应用程序范围的CSS文件，我们需要使我们的选择器尽可能具体。因此，我们使用作为目标的元素的名称，但是指定我们只想修改那些id为<code class="fe lp lq lr ls b">modal-component</code>的元素，它对应于我们正在构建的<code class="fe lp lq lr ls b">modal</code>组件(我们很快就会回到这个id)。这样，不管应用程序有多少个<code class="fe lp lq lr ls b">mat-dialog-container</code>，只有那些有<code class="fe lp lq lr ls b">modal-component</code> id的才会受到影响:<code class="fe lp lq lr ls b">mat-dialog-container#modal-component</code>。</p><p id="eb42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续看<code class="fe lp lq lr ls b">app-root</code>，我们需要改变它的HTML、CSS和TypeScript文件。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">app.component.html(第一版)</figcaption></figure><p id="9036" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该页面有两个按钮，一个用于注销，另一个用于删除产品。现在，单击任一按钮都会调用相同的函数。换句话说，这两个按钮将打开同一个模态对话框。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">应用程序.组件. css</figcaption></figure><p id="a9be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于CSS，我们只需要改变按钮的颜色。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">app.component.ts(第一版)</figcaption></figure><p id="a671" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，<code class="fe lp lq lr ls b">openModal()</code>方法使用我们创建的<code class="fe lp lq lr ls b">modal</code>组件打开对话框。我们还利用<code class="fe lp lq lr ls b">MatDialogConfig</code>来配置对话框。注意<code class="fe lp lq lr ls b">dialogConfig.id = “modal-component"</code>，因为这是我们获取id以在全局<code class="fe lp lq lr ls b">styles.css</code>文件中使用的地方。</p><p id="a470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，所有的信息都将被硬编码到模态的HTML中，因此我们没有在配置中包含<code class="fe lp lq lr ls b">data</code>对象。但是，如果我们向它传递任何用户id、产品id或实际执行注销或产品删除操作所需的任何东西，我们将需要<code class="fe lp lq lr ls b">data</code>。当我们使组件可重用时，我们将实现它。</p><p id="46a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lp lq lr ls b">app-root</code>第一阶段已经完成，让我们进入<code class="fe lp lq lr ls b">modal</code>部分。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">modal.component.html(第一版)</figcaption></figure><p id="609f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，现在模态将有硬编码的文本。当它接收到来自<code class="fe lp lq lr ls b">data</code>的信息时，我们将使用该信息。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">modal.component.css</figcaption></figure><p id="5fea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CSS也很简单，我们把模态的内容变成一个网格，自动设置三行，一行是标题，一行是描述，另一行是按钮。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">modal.component.ts(第一版)</figcaption></figure><p id="ae31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们有打字稿。通过构造器将<code class="fe lp lq lr ls b">MatDialogRef</code>注入组件，以便<code class="fe lp lq lr ls b">modal</code>可以访问打开组件的角度材料对话框的方法。记住，对话框本身是一个有角材料的组件，<code class="fe lp lq lr ls b">modal</code>是我们创建的用于对话框的组件，因此为什么我们的组件看起来像是模态对话框本身。</p><p id="64b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们创建两个方法来处理来自<code class="fe lp lq lr ls b">modal</code>按钮的点击事件:一个执行确认的操作，另一个简单地将用户返回到应用程序的正常流程。对于本演示，确认将导致一个不起眼的警告对话框，以确认操作已执行。</p><p id="4faa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。现在我们有了一个工作模式对话框，我们可以继续让它可重用。不过，在此之前，让我们回顾一下目前为止我们所掌握的内容:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/9aa321c03b27c1170df44e8ae4c21832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgzRQwoovoFZmlbj_wQ0wg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">应用程序根组件</figcaption></figure><p id="7744" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终确定的<code class="fe lp lq lr ls b">app-root</code>布局，带有一个正在进行中的打字稿文件。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/d1fb5780e6dda50820eea03d08879e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATvwcaUKzHZpiw8nGt0YUQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">模式对话框(第一版)</figcaption></figure><p id="15ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及我们模型的当前状态。目前，这是当您单击主页中的任一按钮时打开的模式。</p><p id="62ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想自己在本地运行演示，请返回到终端并输入</p><pre class="lu lv lw lx gt mk ls ml mm aw mn bi"><span id="3df7" class="mo kn iq ls b gy mp mq l mr ms">ng serve --open</span></pre><p id="fcdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在浏览器中自动编译并打开应用程序。</p><p id="531d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将编辑<code class="fe lp lq lr ls b">app-root</code>和<code class="fe lp lq lr ls b">modal</code>以在对话框配置中包含<code class="fe lp lq lr ls b">data</code>对象。这将允许我们使模态显示不同的信息，取决于哪个按钮打开了模态。</p><h1 id="65ec" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤2:创建MatDialogConfig.data对象</h1><p id="63f1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在这一步中，我们将创建<code class="fe lp lq lr ls b">MatDialogConfig.data</code>对象并修改<code class="fe lp lq lr ls b">modal</code>组件，以便它能够接收<code class="fe lp lq lr ls b">data</code>并将其传递给外观服务。到这一步结束时，<code class="fe lp lq lr ls b">app-root</code>将完成，而<code class="fe lp lq lr ls b">modal</code>将只缺少对外观服务<code class="fe lp lq lr ls b">modal-actions</code>的调用。但是首先，让我们实现那个<code class="fe lp lq lr ls b">data</code>对象。</p><p id="947c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们编辑<code class="fe lp lq lr ls b">app-root</code>的<code class="fe lp lq lr ls b">openModal()</code>方法。它将在对话框配置中包含<code class="fe lp lq lr ls b">data</code>对象，该对象包含模态的名称/类型和要显示的文本(标题、描述和动作按钮的文本)。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">app.component.ts(第二版)</figcaption></figure><p id="5c91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，从第20行开始，现在对话框配置包含了我们刚刚讨论过的信息。此外，请注意，我们还没有创建一个新的方法，两个按钮目前都向模态对话框传递完全相同的信息。让我们创建一个新的功能，这个功能与我们现有的功能非常相似，所以每个按钮都有一个功能，每个操作都需要所有的信息，分别包括用户id和产品id。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">app.component.html(最终版本)</figcaption></figure><p id="bfcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，每个按钮在被点击时都会调用不同的函数。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">app.component.ts(最终版本)</figcaption></figure><p id="6a18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个函数都有自己独特的信息存储在<code class="fe lp lq lr ls b">data</code>对象中。我们包括了一个<code class="fe lp lq lr ls b">userId</code>和一个<code class="fe lp lq lr ls b">productId</code>，这样在用户注销或删除产品的过程结束时，服务就分别拥有了必要的信息。请记住，您可以根据需要包含许多属性，这些都是本演示所需的属性。</p><p id="89b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是<code class="fe lp lq lr ls b">modal</code>组件当前没有收到任何信息。是的，<code class="fe lp lq lr ls b">data</code>对象包含在对话框配置中，但是<code class="fe lp lq lr ls b">modal</code>组件不能读取它。我们需要在组件的构造函数中注入<code class="fe lp lq lr ls b">MAT_DIALOG_DATA</code>以便能够像类中的任何其他变量一样访问传递给组件的<code class="fe lp lq lr ls b">data</code>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">modal.component.ts(第二版)</figcaption></figure><p id="edc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在第2行添加<code class="fe lp lq lr ls b">MAT_DIALOG_DATA</code>的导入，然后在第13行添加新的依赖注入。更具体地说，我们注入私有属性<code class="fe lp lq lr ls b">modalData</code>，而私有属性又注入了<code class="fe lp lq lr ls b">MAT_DIALOG_DATA</code>，也就是说，当对话框在父组件(<code class="fe lp lq lr ls b">app-root</code>)中打开时，传递给对话框的任何东西都会被注入到<code class="fe lp lq lr ls b">modal</code>的<code class="fe lp lq lr ls b">modalData</code>属性中。</p><p id="c3a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了证明<code class="fe lp lq lr ls b">modal</code>组件现在可以访问完整的<code class="fe lp lq lr ls b">data</code>对象，我们在构造器主体中加入了一个<code class="fe lp lq lr ls b">console.log()</code>。如果你想自己尝试一下，在浏览器的开发工具中打开控制台，然后点击<code class="fe lp lq lr ls b">app-root</code>中的一个按钮。您应该会看到控制台中记录了完整的<code class="fe lp lq lr ls b">data</code>对象。不错。</p><p id="480e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完成文章的这一步，我们只需要编辑<code class="fe lp lq lr ls b">modal</code>的HTML，这样它显示的文本就是来自<code class="fe lp lq lr ls b">data</code>的内容。因为我们现在可以将<code class="fe lp lq lr ls b">data</code>视为组件的另一个变量，名为<code class="fe lp lq lr ls b">modalData</code>，所以HTML的变化微不足道。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">modal.component.html(最终版本)</figcaption></figure><p id="17a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将硬编码文本替换为保存在<code class="fe lp lq lr ls b">modalData</code>中的属性，瞧，同一个模态对话框组件现在显示不同的信息，这取决于在<code class="fe lp lq lr ls b">app-root</code>中哪个按钮调用了它。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/8a7ee88d24dab0bdaf9035bd8d4950d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZHNx3Dk-N2ZjRUMcx8UYw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">注销确认的模式组件</figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/db37f2246b4da5e4c5e2221f6b6aa42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dUvBAFxwEPygxln_fH7Ag.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">产品删除确认的模式组件</figcaption></figure><p id="f2d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从视觉上看，模型现在是可重用的。技术上来说，不是。我们仍然需要使动作按钮在模态中工作。为此，我们需要编写服务。</p><p id="d519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们转到将连接<code class="fe lp lq lr ls b">modal</code>组件和实现操作的服务<code class="fe lp lq lr ls b">modal-actions</code>的服务。</p><h1 id="cfbb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤3:编写外观服务(模态动作服务)</h1><p id="89b3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在，我们将最终完成<code class="fe lp lq lr ls b">modal</code>组件，并开始编写<code class="fe lp lq lr ls b">modal-actions</code>服务。在这一步中，它将不起作用，因为我们需要其他服务来完成这项工作。相反，在这一步结束时，服务将使用<code class="fe lp lq lr ls b">console.log()</code>将模态的名称记录到控制台。</p><p id="02ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，如果我们想写<code class="fe lp lq lr ls b">modal-actions</code>，我们必须创建它。返回终端并输入:</p><pre class="lu lv lw lx gt mk ls ml mm aw mn bi"><span id="1e36" class="mo kn iq ls b gy mp mq l mr ms">ng generate service services\modal-actions</span></pre><p id="b4c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lp lq lr ls b">modal-actions</code>服务现在存在于<code class="fe lp lq lr ls b">services</code>文件夹中(它是与服务一起创建的)。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">modal-actions.service.ts(第一版)</figcaption></figure><p id="cce5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您所看到的非常接近于<code class="fe lp lq lr ls b">modal-actions</code>的最终版本，它只缺少对其他服务的调用。</p><p id="95af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，它有三种方法:<code class="fe lp lq lr ls b">modalAction()</code>、<code class="fe lp lq lr ls b">logout()</code>和<code class="fe lp lq lr ls b">deleteProduct()</code>。第一个方法是应用程序中其他类唯一可用的方法(没有访问修饰符默认为公共访问，即任何类都可以访问它)。<code class="fe lp lq lr ls b">logout()</code>和<code class="fe lp lq lr ls b">deleteProduct()</code>只能由定义它们的类使用，以帮助将数据从<code class="fe lp lq lr ls b">modal-actions</code>发送到完成用户所需操作的服务。顾名思义，前者用于用户注销，后者用于产品删除。将它们的访问修饰符设置为<code class="fe lp lq lr ls b">private</code>会使代码更干净，并确保服务只公开需要公开的内容，仅此而已。</p><p id="9524" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lp lq lr ls b">modalAction()</code>是将<code class="fe lp lq lr ls b">modal</code>发送的信息重定向到执行用户操作的正确服务的关键。这是使用一个switch语句完成的，该语句根据模态的名称选择要调用的服务(在<code class="fe lp lq lr ls b">data</code>中传递的<code class="fe lp lq lr ls b">name</code>属性)。</p><p id="b29a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我们可以直接在交换机中调用服务，但是如果需要修改传递给服务的内容，私有方法(<code class="fe lp lq lr ls b">logout()</code>和<code class="fe lp lq lr ls b">deleteProduct()</code>)可能会很有帮助。例如，代替发送完整的<code class="fe lp lq lr ls b">data</code>对象，您可以在这些方法中创建一个仅包含所需信息的新对象，并将该对象发送给服务。</p><p id="4d31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在进入下一步之前，我们需要在<code class="fe lp lq lr ls b">modal</code>组件中注入<code class="fe lp lq lr ls b">modal-actions</code>服务并调用它。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">modal.component.ts(最终版本)</figcaption></figure><p id="67c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，我们完成了<code class="fe lp lq lr ls b">modal</code>组件。当在模型内部单击action按钮时，也就是说，用户确认了他们的意图，组件将调用facade服务，<code class="fe lp lq lr ls b">modal-actions</code>，该服务将操作分派给相应的服务。现在，当点击该按钮时，它只会向控制台记录一条消息。</p><p id="34af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们将了解这些服务，以完成演示！</p><h1 id="f05e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤4:编写模拟服务(模拟服务1和模拟服务2)</h1><p id="6d2f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">最后，我们需要创建那些模拟服务，它们代表负责执行用户操作的服务，然后在外观服务中调用它们。在我们的例子中，这些模拟服务分别表示注销用户的身份验证服务和与后端通信以删除数据库中产品的身份验证服务。</p><p id="8bed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次返回终端，输入:</p><pre class="lu lv lw lx gt mk ls ml mm aw mn bi"><span id="67f3" class="mo kn iq ls b gy mp mq l mr ms">ng generate service services\mock-serv-1<br/>ng generate service services\mock-serv-2</span></pre><p id="39ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个演示来说，每个服务都有一个方法:它接收<code class="fe lp lq lr ls b">data</code>对象作为参数，并用注销用户/删除产品的id创建一个警告对话框。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">mock-serv-1.service.ts</figcaption></figure><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">mock-serv-2.service.ts</figcaption></figure><p id="4405" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于选择<code class="fe lp lq lr ls b">any</code>作为传递给方法的参数类型的一个注意事项。在现实世界的应用程序中，因为<code class="fe lp lq lr ls b">data</code>对象可以有不同的属性，你可能最终会为该对象的每个用例创建一个接口，这样你就可以确保注销模式接收的信息不会少于它所需要的，或者产品删除<code class="fe lp lq lr ls b">data</code>对象的属性不会输入错误。关于TypeScript接口的更多信息，请参考关于此事的<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/interfaces.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="e8a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，对代码再做一次修改，我们今天就到此为止了:在<code class="fe lp lq lr ls b">modal-actions</code>中添加对模拟服务的调用。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">modal-actions.service.ts(最终版本)</figcaption></figure><p id="ef9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果您一直在本地编写代码，请打开终端，键入</p><pre class="lu lv lw lx gt mk ls ml mm aw mn bi"><span id="32c8" class="mo kn iq ls b gy mp mq l mr ms">ng serve --open</span></pre><p id="ec7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序将在您的浏览器中编译并打开。</p><p id="db9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当注销或产品删除操作在模态对话框中被确认时，这是它们各自的结果:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/b403e7b6fabd8191ad230cfc28142afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOuhJKkFP8obfM6921zCCA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">注销模式确认</figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/47761d88bb06fd75054d44e12b6c11f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IX12GyscTDFXYE3QAccdw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">产品删除模式确认</figcaption></figure><h1 id="01a5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="3274" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这就是这篇关于如何在Angular中创建一个可重用的模态对话框组件的文章。我们首先创建组件的一次性版本，然后在此基础上构建，以允许在不同的场景中重用它。</p><p id="2d9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你的阅读！我试图遵循最佳实践，并留下了一些关于如何在实际应用程序中实现这个组件的技巧。请让我知道你对这篇文章的想法、建议、批评或任何你想说的。</p><p id="9f8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的代码可以在GitHub <a class="ae kl" href="https://github.com/Ze1598/medium-articles/tree/master/Create%20a%20reusable%20Modal%20Dialog%20component%20in%20Angular%208/reusable-modal" rel="noopener ugc nofollow" target="_blank">这里</a>获得，你也可以在Stackblitz <a class="ae kl" href="https://stackblitz.com/edit/ng-reusable-modal" rel="noopener ugc nofollow" target="_blank">这里</a>使用代码的现场版本。</p><p id="6fa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这段代码对您的项目有所帮助:)</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><div class="lu lv lw lx gt nc"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">编写面试问题</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">技术开发</p></div></div><div class="nl l"><div class="nm l nn no np nl nq md nc"/></div></div></a></div></div></div>    
</body>
</html>