<html>
<head>
<title>How To Build a Color Picker with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React构建颜色选择器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-color-picker-5fbacc54f16c?source=collection_archive---------2-----------------------#2019-08-13">https://levelup.gitconnected.com/how-to-build-a-color-picker-5fbacc54f16c?source=collection_archive---------2-----------------------#2019-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="91f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我开始学习JavaScript T4时，制作一个颜色选择器是我尝试的第一个项目。如果我没记错的话，他们完全令人厌恶。最近，我的最新项目<a class="ae kp" href="https://benjaminadk.netlify.com/posts/how-to-build-a-color-picker/" rel="noopener ugc nofollow" target="_blank">调色板伙伴</a>需要一个简单的颜色选择器。本文将逐步介绍这一过程。</p><p id="dcb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文的目标读者可能有一些使用<em class="ko"> React </em>的经验，但绝不需要专业能力。我将尽力保持一个缓慢的进度，并解释组件组合背后的思想以及各个部分是如何配合的。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="f0fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您最终喜欢这篇文章，请查看续集<a class="ae kp" href="https://benjaminadk.netlify.com/posts/using-local-storage-to-persist-data/" rel="noopener ugc nofollow" target="_blank">https://Benjamin Brooke . me/posts/using-local-storage-to-persist-data/</a>，我们在其中添加了使用本地存储将颜色保存到调色板的功能。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><h1 id="ffb1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">入门指南</h1><p id="b58c" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">首先用<em class="ko"> React </em>模板创建一个新的<a class="ae kp" href="https://codesandbox.io/" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>。这是一个免费的服务，有一个现实的文件结构，能够以一种超级简单的方式添加依赖关系。本教程将使用<a class="ae kp" href="https://www.styled-components.com" rel="noopener ugc nofollow" target="_blank">样式的组件</a>，因此安装它并删除<code class="fe mh mi mj mk b">.css</code>文件及其<code class="fe mh mi mj mk b">import</code>语句。如果你不熟悉<em class="ko">风格的组件</em>不用害怕，90%都只是<em class="ko"> CSS </em>。为了简单起见，所有文件都将放在<code class="fe mh mi mj mk b">src</code>目录中。这里是一些基本的启动代码。</p><h2 id="2bdb" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">索引. js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="9835" class="ml lf it mk b gy nb nc l nd ne">import React from 'react'<br/>import ReactDOM from 'react-dom'<br/>import styled from 'styled-components'<br/>import Picker from './Picker'<br/>import { GlobalStyle } from './GlobalStyle'<br/><br/>const AppWrapper = styled.div`<br/>  height: 100vh;<br/>  display: grid;<br/>  align-items: center;<br/>  justify-items: center;<br/>`<br/><br/>function App() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;GlobalStyle /&gt;<br/>      &lt;AppWrapper&gt;<br/>        &lt;Picker /&gt;<br/>      &lt;/AppWrapper&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/><br/>const rootElement = document.getElementById('root')<br/>ReactDOM.render(&lt;App /&gt;, rootElement)</span></pre><h2 id="908e" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">GlobalStyle.js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="4fb4" class="ml lf it mk b gy nb nc l nd ne">import React from 'react'<br/>import { createGlobalStyle } from 'styled-components'<br/><br/>export const GlobalStyle = createGlobalStyle`<br/>html {<br/>  box-sizing: border-box;<br/>  font-size: 10px;<br/>}<br/>body {<br/>  font-family: monospace;<br/>  font-weight: bold;<br/>  margin: 0;<br/>}<br/>*, *:before, *:after {<br/>  box-sizing: inherit;<br/>}<br/>`</span></pre><h2 id="8df6" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">Picker.js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="25a2" class="ml lf it mk b gy nb nc l nd ne">import React, { useState, useRef, useEffect } from 'react'<br/>import styled from 'styled-components'<br/><br/>export const PickerWrapper = styled.div`<br/>  .swatch {<br/>    width: 100px;<br/>    height: 50px;<br/>    background: ${p =&gt; p.color};<br/>  }<br/>`<br/><br/>const Picker = () =&gt; {<br/>  const [color, setColor] = useState('#000000')<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;PickerWrapper color={color}&gt;<br/>        &lt;div className='swatch' /&gt;<br/>      &lt;/PickerWrapper&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/><br/>export default Picker</span></pre><p id="b4c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个样板文件应该会在屏幕中间产生一个黑色的矩形。目标是让颜色选择器在这个矩形被点击时出现，并根据用户输入动态设置它的背景颜色。首先需要的是某种容器来容纳颜色选择器，它的行为就像一个<em class="ko">模态</em>，当矩形被点击时打开，并且能够通过按钮或点击<em class="ko">选择器</em>外的屏幕来关闭。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="ca62" class="le lf it bd lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx nj lz ma mb bi translated">情态的</h1><h2 id="3e7d" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">Modal.js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="0785" class="ml lf it mk b gy nb nc l nd ne">import React from 'react'<br/>import styled, { keyframes } from 'styled-components'<br/><br/>const zoom = keyframes`<br/>  from {<br/>    transform: scale(0) translate(-50%, -50%);<br/>  }<br/>  to {<br/>    transform: scale(1) translate(-50%, -50%);<br/>  }<br/>`<br/><br/>export const Backdrop = styled.div`<br/>  position: fixed;<br/>  z-index: 1;<br/>  top: 0;<br/>  bottom: 0;<br/>  left: 0;<br/>  right: 0;<br/>  display: ${p =&gt; (p.show ? 'block' : 'none')};<br/>  background: rgba(0, 0, 0, 0.3);<br/>`<br/><br/>export const ModalWrapper = styled.div`<br/>  position: fixed;<br/>  top: 50%;<br/>  left: 50%;<br/>  z-index: 2;<br/>  transform: translate(-50%, -50%);<br/>  transform-origin: left top;<br/>  max-width: 100%;<br/>  height: auto;<br/>  display: ${p =&gt; (p.show ? 'block' : 'none')};<br/>  animation: ${zoom} 0.2s;<br/>`<br/>const Modal = ({ modal, show, onClose, children }) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Backdrop show={show} onClick={onClose} /&gt;<br/>      &lt;ModalWrapper ref={modal} show={show}&gt;<br/>        {children}<br/>      &lt;/ModalWrapper&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/><br/>export default Modal</span></pre><p id="1bf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">模态组件通过将背景和内部容器分层来工作。使用<code class="fe mh mi mj mk b">z-index</code>属性将背景固定在模态的后面。这允许背景监听点击并关闭整个组件，而前景可以被点击而不触发关闭。看起来滑稽的括号<code class="fe mh mi mj mk b">&lt;&gt;&lt;/&gt;</code>是<em class="ko">反应的简写。片段化</em>并允许组件返回兄弟元素。<code class="fe mh mi mj mk b">show</code>道具是由<em class="ko">拾取器</em>传下来的<code class="fe mh mi mj mk b">Boolean</code>来控制<code class="fe mh mi mj mk b">display</code>风格。当<code class="fe mh mi mj mk b">show</code>为<code class="fe mh mi mj mk b">false</code>时，风格设置为<code class="fe mh mi mj mk b">display: none</code>。<em class="ko">样式组件</em>还带有一个<code class="fe mh mi mj mk b">keyframes</code>辅助函数，当<em class="ko">拾取器</em>出现时，该函数与<code class="fe mh mi mj mk b">transform: scale()</code>一起使用以给出缩放效果。<code class="fe mh mi mj mk b">children</code> prop在<em class="ko"> React </em>中的所有组件上都可用，并允许<em class="ko">模态</em>成为可重用的包装器组件。最后，<code class="fe mh mi mj mk b">modal</code>支柱是一个<code class="fe mh mi mj mk b">ref</code>,稍后将在定位计算中使用。</p><p id="9ce6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便提一下，这个基本的<em class="ko">模式</em>可以用于任何东西——注册、表单、图像、视频等等。诀窍是50%的定位和转换，自动将内容居中。调整动画风格，变换原点和宽度以适应特定的使用情况。此外，将<code class="fe mh mi mj mk b">show</code>的值设置为true以加快开发速度。这将消除每次更新时点击样本的烦人步骤。</p><h2 id="7087" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">Picker.js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="189e" class="ml lf it mk b gy nb nc l nd ne">const Picker = () =&gt; {<br/>  const [show, setShow] = useState(false)<br/>  const [color, setColor] = useState("#000000")<br/><br/>  const modal = useRef(null)<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;PickerWrapper color={color}&gt;<br/>        &lt;div className="swatch" onClick={() =&gt; setShow(true)} /&gt;<br/>        &lt;Modal modal={modal} show={show} onClose={() =&gt; setShow(false)}&gt;<br/>          &lt;div&gt;😎&lt;/div&gt;<br/>        &lt;/Modal&gt;<br/>      &lt;/PickerWrapper&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="0310" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确保<code class="fe mh mi mj mk b">import</code>模态组件进入拾取器。用<code class="fe mh mi mj mk b">useState</code>创建<code class="fe mh mi mj mk b">show</code>和<code class="fe mh mi mj mk b">setShow</code>，用<code class="fe mh mi mj mk b">useRef</code>创建<code class="fe mh mi mj mk b">modal</code>。现在单击矩形将打开模式和😎应该会出现。<code class="fe mh mi mj mk b">&lt;div&gt;😎&lt;/div&gt;</code>成为上一步引用的<code class="fe mh mi mj mk b">children</code>道具。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="d912" class="le lf it bd lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx nj lz ma mb bi translated">配置</h1><p id="547e" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">在继续之前，创建一个<code class="fe mh mi mj mk b">config.js</code>文件来保存一些常量。</p><h2 id="a0ac" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">配置文件</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="29ac" class="ml lf it mk b gy nb nc l nd ne">export default {<br/>  squareSize: 200,<br/>  barSize: 20,<br/>  crossSize: 15,<br/>  inputSize: 40,<br/>  delay: 150<br/>}</span></pre><p id="c8e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mh mi mj mk b">squareSize</code>将是<em class="ko">饱和度</em> / <em class="ko">亮度</em>正方形的宽度和高度。<code class="fe mh mi mj mk b">barSize</code>是<em class="ko">色相</em>组件的高度，也是<em class="ko">手柄</em>的宽度和高度(用户拖动此项设置色相)。<code class="fe mh mi mj mk b">crossSize</code>是将用在<em class="ko">方块</em>上的可拖动图标的宽度和高度。<code class="fe mh mi mj mk b">inputSize</code>是一行输入的高度。<code class="fe mh mi mj mk b">delay</code>值将与<code class="fe mh mi mj mk b">lodash.throttle</code>一起使用，后者应作为依赖项添加。该组件将实现各种可以不断触发的鼠标事件监听器，这可能会降低应用程序的速度。回调函数将被节流，因此它们只能每<code class="fe mh mi mj mk b">delay</code>秒执行一次。现在理解一切并不重要，因为随着本文的进行，这些碎片将会组合在一起。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="5b58" class="le lf it bd lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx nj lz ma mb bi translated">顺化(越南城市)</h1><p id="867b" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">这种颜色选择器可以整合各种颜色格式，但目前<a class="ae kp" href="https://en.wikipedia.org/wiki/HSL_and_HSV" rel="noopener ugc nofollow" target="_blank"> HSL </a>或<em class="ko">色调、饱和度、亮度</em>最适合用户输入。<em class="ko">色调</em>组件是一个矩形条，显示从0到360度的全部色调。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/fc37fafb93c3675013a9b5c044488a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/0*wMoYYC_t2TpSMrjt.png"/></div></figure><p id="cfd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">色调</em>栏本身实际上是一个<em class="ko"> HTML画布</em>元素。当<em class="ko">拾取器</em>加载时，自定义<em class="ko">反应</em>钩用于绘制360度颜色。一个到底层<em class="ko"> DOM </em>节点的<code class="fe mh mi mj mk b">ref</code>被传递给钩子，这样就可以调用<code class="fe mh mi mj mk b">Canvas.getContext()</code>。钩子使用<code class="fe mh mi mj mk b">ctx.createLinearGradient()</code>和<code class="fe mh mi mj mk b">for</code>循环为渐变添加必要的颜色停止。使用<em class="ko"> HSL </em>颜色格式使这个过程变得容易。自定义挂钩不是必需的，但它确实可以分离关注点。</p><h2 id="7ba2" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">usePaintHue.js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="a09a" class="ml lf it mk b gy nb nc l nd ne">import React, { useEffect } from 'react'<br/>import config from './config'<br/><br/>const { squareSize, barSize } = config<br/><br/>const usePaintHue = canvas =&gt; {<br/>  useEffect(() =&gt; {<br/>    const ctx = canvas.current.getContext('2d')<br/>    ctx.rect(0, 0, squareSize, barSize)<br/><br/>    const gradient = ctx.createLinearGradient(0, 0, squareSize, 0)<br/>    for (let i = 0; i &lt;= 360; i += 30) {<br/>      gradient.addColorStop(i / 360, `hsl(${i}, 100%, 50%)`)<br/>    }<br/>    ctx.fillStyle = gradient<br/>    ctx.fill()<br/>  }, [canvas])<br/>}<br/><br/>export default usePaintHue</span></pre><p id="1f17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">拾取器</em>将记录更多受<em class="ko">色调</em>影响的状态。<code class="fe mh mi mj mk b">hue</code>值将是0到360之间的一个数字，<code class="fe mh mi mj mk b">hueX</code>是手柄的位置，<code class="fe mh mi mj mk b">offsetLeft/offsetTop</code>将来自<code class="fe mh mi mj mk b">modal</code> ref并帮助计算。注意当<em class="ko">模态</em>打开时<code class="fe mh mi mj mk b">useEffect</code>吊钩正在计算偏移量。它还为<code class="fe mh mi mj mk b">resize</code>事件附加了一个事件监听器。这些偏移量是<em class="ko">模态</em>和它最近的父体之间的距离，所以当窗口尺寸改变时，这些值也会改变。这种变化会渗透到头寸计算中，因此需要加以考虑。最后，添加另一个钩子来观察<code class="fe mh mi mj mk b">hue</code>值的变化。当<code class="fe mh mi mj mk b">hue</code>改变时，可以使用模板字符串更新<code class="fe mh mi mj mk b">color</code>状态。</p><h2 id="26b7" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">Picker.js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="bf8c" class="ml lf it mk b gy nb nc l nd ne">import React, { useState, useRef, useEffect } from 'react'<br/>import styled from 'styled-components'<br/>import Modal from './Modal'<br/>import Hue from './Hue'<br/>import config from './config'<br/><br/>const { squareSize, barSize } = config<br/><br/>export const PickerWrapper = styled.div`<br/>  user-select: none;<br/>  .swatch {<br/>    width: 100px;<br/>    height: 50px;<br/>    background: ${p =&gt; p.color};<br/>  }<br/>`<br/><br/>export const PickerOuter = styled.div`<br/>  width: ${squareSize + 20}px;<br/>  display: grid;<br/>  border-radius: 2px;<br/>  background: #ffffff;<br/>  box-shadow: 0 3px 3px rgba(0, 0, 0, 0.3);<br/>`<br/><br/>export const PickerInner = styled.div`<br/>  display: grid;<br/>  grid-template-rows: ${squareSize + 20}px 20px 1fr;<br/>  align-items: center;<br/>  justify-items: center;<br/>`<br/><br/>const Picker = () =&gt; {<br/>  const [show, setShow] = useState(true)<br/>  const [hue, setHue] = useState(180)<br/>  const [hueX, setHueX] = useState(() =&gt; squareSize / 2 - barSize / 2)<br/>  const [offsetTop, setOffsetTop] = useState(0)<br/>  const [offsetLeft, setOffsetLeft] = useState(0)<br/>  const [color, setColor] = useState(`hsla(180, 100%, 50%, 1)`)<br/><br/>  const modal = useRef(null)<br/><br/>  useEffect(() =&gt; {<br/>    function setOffsets() {<br/>      setOffsetTop(modal.current.offsetTop)<br/>      setOffsetLeft(modal.current.offsetLeft)<br/>    }<br/>    if (show) {<br/>      setOffsets()<br/>      window.addEventListener('resize', setOffsets)<br/>    } else {<br/>      window.removeEventListener('resize', setOffsets)<br/>    }<br/><br/>    return () =&gt; {<br/>      window.removeEventListener('resize', setOffsets)<br/>    }<br/>  }, [show])<br/><br/>  useEffect(() =&gt; {<br/>    setColor(`hsla(${hue}, 100%, 50%, 1)`)<br/>  }, [hue])<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;PickerWrapper color={color}&gt;<br/>        &lt;div className='swatch' onClick={() =&gt; setShow(true)} /&gt;<br/>        &lt;Modal modal={modal} show={show} onClose={() =&gt; setShow(false)}&gt;<br/>          &lt;PickerOuter&gt;<br/>            &lt;PickerInner&gt;<br/>              &lt;div&gt;sqaure&lt;/div&gt;<br/>              &lt;Hue hueX={hueX} offsetLeft={offsetLeft} setHueX={setHueX} setHue={setHue} /&gt;<br/>              &lt;div&gt;inputs&lt;/div&gt;<br/>            &lt;/PickerInner&gt;<br/>          &lt;/PickerOuter&gt;<br/>        &lt;/Modal&gt;<br/>      &lt;/PickerWrapper&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/><br/>export default Picker</span></pre></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="f4c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在色调部分有相当多的东西在进行。有一个包装器容纳<em class="ko">画布</em>和<em class="ko">手柄</em>组件。ref用于用<em class="ko"> usePaintHue </em>挂钩给<em class="ko">画布</em>上色。<em class="ko">句柄</em>使用绝对定位，特别是<code class="fe mh mi mj mk b">left</code>属性来确定其位置。该组件应用事件侦听器循环。一切都是由<code class="fe mh mi mj mk b">mousedown</code>事件引发的。这触发了另外两个事件监听器的分配，一个用于<code class="fe mh mi mj mk b">mouseup</code>，另一个用于<code class="fe mh mi mj mk b">mousemove</code>。这个想法是只在适当的时候监听需要的事件。换句话说，当鼠标被按下并移动时，用户正在移动<em class="ko">手柄</em>。</p><p id="24fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mh mi mj mk b">mousemove</code>事件监听器连接到<code class="fe mh mi mj mk b">document.body</code>元素，因为当拖动这样的句柄时，用户不太可能停留在<em class="ko">选择器</em>的范围内。事件处理器通过<code class="fe mh mi mj mk b">lodash.throttle</code>节流，所以它只能每<code class="fe mh mi mj mk b">delay</code>秒触发一次。尝试改变<code class="fe mh mi mj mk b">delay</code>和记录<code class="fe mh mi mj mk b">x</code>(<code class="fe mh mi mj mk b">computePosition</code>功能的结果)。正如您将看到的，节流会产生很大的不同。当<em class="ko">方形</em>组件被构建时，由于画布重画增加了处理器负载，这将变得更加重要。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/557e165716273accba0fba5fdbfa61f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4VaoeCnDu5mNCkpH.gif"/></div></div></figure><p id="149b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果有些计算看起来令人困惑，那是因为它们确实如此。使用<code class="fe mh mi mj mk b">barSize</code>是因为它也是与<em class="ko">手柄</em>的宽度和高度相同的值。在这种情况下，<em class="ko">手柄</em>的宽度是计算<code class="fe mh mi mj mk b">left</code>位置的一部分。让我们浏览一下触发<code class="fe mh mi mj mk b">mousemove</code>事件处理程序时发生的步骤。</p><ol class=""><li id="6cb4" class="ns nt it js b jt ju jx jy kb nu kf nv kj nw kn nx ny nz oa bi translated">事件对象被传递给<code class="fe mh mi mj mk b">computePosition</code></li><li id="d714" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn nx ny nz oa bi translated"><code class="fe mh mi mj mk b">Math.max</code>用于确保返回的最小值是<em class="ko">手柄</em>或<code class="fe mh mi mj mk b">(barSize / -2)</code>宽度的负一半。这是当<code class="fe mh mi mj mk b">hue</code>为0时的<code class="fe mh mi mj mk b">left</code>值。为了使UI在<code class="fe mh mi mj mk b">hue</code>为0时看起来合适，半个<em class="ko">手柄</em>应该悬挂在<em class="ko">外壳</em>的左侧。这是必需的，因为该函数使用的是页面上的x光标位置<code class="fe mh mi mj mk b">e.clientX</code>。还有其他选择——比如将<code class="fe mh mi mj mk b">mousemove</code>监听器应用到其他元素，但是我发现这种设置提供了最好的用户体验。</li><li id="9042" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn nx ny nz oa bi translated">从<code class="fe mh mi mj mk b">Math.min</code>产生的值确保返回的值不会大于<em class="ko">手柄</em>悬挂在<em class="ko">套筒</em>右端的一半。<code class="fe mh mi mj mk b">squareSize - barSize / 2</code>的值代表这个最大值。</li><li id="96c6" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn nx ny nz oa bi translated">当<em class="ko">手柄</em>位于<em class="ko">套筒</em>两端之间的任何位置时，表达式<code class="fe mh mi mj mk b">e.clientX - offsetLeft + squareSize / 2 - barSize / 2</code>用于计算<code class="fe mh mi mj mk b">left</code>。</li><li id="243c" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn nx ny nz oa bi translated"><code class="fe mh mi mj mk b">hueX</code>值用于插补<code class="fe mh mi mj mk b">hue</code>。表达式<code class="fe mh mi mj mk b">x + barSize / 2</code>获取<em class="ko">手柄</em>的中心值。记住<code class="fe mh mi mj mk b">x</code>是基于<em class="ko">手柄</em>左边缘的<code class="fe mh mi mj mk b">left</code>位置。360°与<em class="ko">套筒</em>宽度的简单比值乘以<code class="fe mh mi mj mk b">x</code>计算出<code class="fe mh mi mj mk b">hue</code>。</li></ol><h2 id="5688" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">色相. js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="5c1f" class="ml lf it mk b gy nb nc l nd ne">import React, { useRef, useEffect } from 'react'<br/>import styled from 'styled-components'<br/>import throttle from 'lodash.throttle'<br/>import Svg from './Svg'<br/>import usePaintHue from './usePaintHue'<br/>import config from './config'<br/><br/>const { squareSize, barSize, delay } = config<br/><br/>export const HueWrapper = styled.div`<br/>  position: relative;<br/>  width: ${squareSize + 'px'};<br/>  height: ${barSize + 'px'};<br/>  cursor: ew-resize;<br/>`<br/><br/>export const Canvas = styled.canvas.attrs(p =&gt; ({<br/>  width: squareSize,<br/>  height: barSize<br/>}))``<br/><br/>export const Handle = styled.div.attrs(p =&gt; ({<br/>  style: {<br/>    left: p.left + 'px',<br/>    transition: p.animate ? 'top .75s ease-out' : '0s'<br/>  }<br/>}))`<br/>  position: absolute;<br/>  top: 0px;<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: space-between;<br/>  width: ${barSize}px;<br/>  height: ${barSize}px;<br/>  pointer-events: none;<br/>  svg {<br/>    width: 100%;<br/>    height: 100%;<br/>  }<br/>`<br/><br/>const Hue = ({ hueX, offsetLeft, setHueX, setHue }) =&gt; {<br/>  const bar = useRef(null)<br/>  const canvas = useRef(null)<br/><br/>  usePaintHue(canvas)<br/><br/>  useEffect(() =&gt; {<br/>    function computePosition(e) {<br/>      return Math.max(<br/>        barSize / -2,<br/>        Math.min(e.clientX - offsetLeft + squareSize / 2 - barSize / 2, squareSize - barSize / 2)<br/>      )<br/>    }<br/><br/>    function computeHue(x) {<br/>      return Math.round((x + barSize / 2) * (360 / squareSize))<br/>    }<br/><br/>    const onMouseMove = throttle(e =&gt; {<br/>      const x = computePosition(e)<br/>      const hue = computeHue(x)<br/><br/>      setHueX(x)<br/>      setHue(hue)<br/>    }, delay)<br/><br/>    function onMouseUp(e) {<br/>      const x = computePosition(e)<br/>      const hue = computeHue(x)<br/>      setHueX(x)<br/>      setHue(hue)<br/>      document.body.removeEventListener('mousemove', onMouseMove)<br/>      document.body.removeEventListener('mouseup', onMouseUp)<br/>    }<br/><br/>    function onMouseDown(e) {<br/>      document.body.addEventListener('mousemove', onMouseMove)<br/>      document.body.addEventListener('mouseup', onMouseUp)<br/>    }<br/><br/>    const barRef = bar.current<br/>    barRef.addEventListener('mousedown', onMouseDown)<br/><br/>    return () =&gt; {<br/>      barRef.removeEventListener('mousedown', onMouseDown)<br/>      document.body.removeEventListener('mousemove', onMouseMove)<br/>      document.body.removeEventListener('mouseup', onMouseUp)<br/>    }<br/>  }, [offsetLeft, setHue, setHueX])<br/><br/>  return (<br/>    &lt;HueWrapper ref={bar}&gt;<br/>      &lt;Handle left={hueX}&gt;<br/>        &lt;Svg name='handle' /&gt;<br/>      &lt;/Handle&gt;<br/>      &lt;Canvas ref={canvas} /&gt;<br/>    &lt;/HueWrapper&gt;<br/>  )<br/>}<br/><br/>export default Hue</span></pre></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="4ebd" class="le lf it bd lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx nj lz ma mb bi translated">挽救（saving的简写）</h1><p id="7adf" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated"><em class="ko">色调</em>组件有一个手柄，它实际上是我用<a class="ae kp" href="https://boxy-svg.com/" rel="noopener ugc nofollow" target="_blank">方形Svg </a>制作的<em class="ko"> Svg </em>。关于我的<em class="ko"> Svg </em>工作流程的更多信息，请查看<a class="ae kp" href="http://benjaminadk.netlify.com/posts/svg-icons-with-no-artistic-ability/" rel="noopener ugc nofollow" target="_blank">没有艺术能力的Svg图标</a>。目前这个项目只需要几个Svg图标。只需导入<em class="ko"> Svg </em>组件，并传递一个与<code class="fe mh mi mj mk b">switch</code>语句中的字符串匹配的<code class="fe mh mi mj mk b">name</code>属性。</p><h2 id="50d8" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">SVG . j</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="f738" class="ml lf it mk b gy nb nc l nd ne">import React from 'react'<br/><br/>const Svg = ({ name, ...rest }) =&gt; {<br/>  const getPath = p =&gt; {<br/>    switch (p) {<br/>      case 'check':<br/>        return (<br/>          &lt;&gt;<br/>            &lt;path d='M2.2326 30.1008l3.7139-5.9333L23.072 34.8882l19.2522-30.41 5.914 3.744-23.001 36.3315-5.914-3.744.0037-.0067z' /&gt;<br/>          &lt;/&gt;<br/>        )<br/>      case 'cross':<br/>        return (<br/>          &lt;&gt;<br/>            &lt;path<br/>              d='M34.3656 3.0593000000000004A24.084 24.084 0 1 0 15.166 47.2354 24.084 24.084 0 1 0 34.3656 3.0593zM32.0123 8.474a18.18 18.18 0 0 1-14.493 33.3467A18.18 18.18 0 0 1 32.0123 8.474z'<br/>              fill='#dfdfdf'<br/>            /&gt;<br/>            &lt;path<br/>              d='M36.7852 11.4797A18.168 18.168 0 1 0 12.8026 38.777a18.168 18.168 0 1 0 23.9826-27.2973zM33.6263 15.0752a13.382 13.382 0 0 1-17.6649 20.1063 13.382 13.382 0 0 1 17.6649-20.1063z'<br/>              fill='#363636'<br/>            /&gt;<br/>          &lt;/&gt;<br/>        )<br/>      case 'handle':<br/>        return (<br/>          &lt;&gt;<br/>            &lt;path d='M34.736998 0v49.921h-5.578V0zm-16.737 49.921V0h5.578v49.921z' fill='#dfdfdf' /&gt;<br/>            &lt;path fill='#363636' d='M31.371873.078V50h-2.316V.078zM23.470873 0v49.922h-2.316V0z' /&gt;<br/>          &lt;/&gt;<br/>        )<br/><br/>      default:<br/>        throw new Error('must provide a name prop to Svg')<br/>    }<br/>  }<br/><br/>  return (<br/>    &lt;svg viewBox='0 0 50 50' xmlns='http://www.w3.org/2000/svg' {...rest}&gt;<br/>      {getPath(name)}<br/>    &lt;/svg&gt;<br/>  )<br/>}<br/><br/>export default Svg</span></pre></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="ec5a" class="le lf it bd lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx nj lz ma mb bi translated">平方</h1><p id="3d66" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">如果说<em class="ko">的色调</em>令人困惑，那么<em class="ko">的方形</em>会更糟糕！<em class="ko">方块</em>用于找到颜色的<em class="ko">饱和度</em>和<em class="ko">亮度</em>。<em class="ko">正方形</em>存在于二维空间中，而不是在一维空间中工作。<em class="ko">方块</em>会根据当前的<code class="fe mh mi mj mk b">hue</code>改变颜色，用户可以拖动十字准线来选择他们想要的颜色。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi og"><img src="../Images/74c2bd5a5ca058f70f19907950a28756.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/0*nKAOMuFAMBDxSAxn.png"/></div></figure><p id="dc74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次使用一个定制的钩子来填充<em class="ko">正方形</em>。不像<em class="ko">色调</em>绘画挂钩那样只在页面加载时触发，这个挂钩会在每次<code class="fe mh mi mj mk b">hue</code>改变时触发。这就是为什么节流很重要。每秒重新绘制<em class="ko">方块</em> 100次是不必要的，而且会降低应用程序的速度。</p><p id="6b7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">绘画过程从简单地用当前的<code class="fe mh mi mj mk b">hue</code>填充画布开始。下一步是从左到右添加白色到透明的线性渐变。最后一步从上到下添加一个透明到黑色的线性渐变。光标下方的颜色最终是所选的颜色。</p><h2 id="85ff" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">usePaintSquare.js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="346e" class="ml lf it mk b gy nb nc l nd ne">import React, { useEffect } from 'react'<br/>import config from './config'<br/><br/>const { squareSize } = config<br/><br/>const usePaintSquare = (canvas, hue) =&gt; {<br/>  useEffect(() =&gt; {<br/>    const ctx = canvas.current.getContext('2d')<br/>    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`<br/>    ctx.fillRect(0, 0, squareSize, squareSize)<br/>    const gradientWhite = ctx.createLinearGradient(0, 0, squareSize, 0)<br/>    gradientWhite.addColorStop(0, `rgba(255, 255, 255, 1)`)<br/>    gradientWhite.addColorStop(1, `rgba(255, 255, 255, 0)`)<br/>    ctx.fillStyle = gradientWhite<br/>    ctx.fillRect(0, 0, squareSize, squareSize)<br/>    const gradientBlack = ctx.createLinearGradient(0, 0, 0, squareSize)<br/>    gradientBlack.addColorStop(0, `rgba(0, 0, 0, 0)`)<br/>    gradientBlack.addColorStop(1, `rgba(0, 0, 0, 1)`)<br/>    ctx.fillStyle = gradientBlack<br/>    ctx.fillRect(0, 0, squareSize, squareSize)<br/>  }, [canvas, hue])<br/>}<br/><br/>export default usePaintSquare</span></pre><p id="5121" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们需要一种方法将光标在<em class="ko">正方形</em>中的位置转换为<em class="ko">饱和度</em>和<em class="ko">亮度</em>值。关于<em class="ko">画布</em>的酷的部分是我们可以使用<code class="fe mh mi mj mk b">imageData</code>来获得任何像素的颜色。不那么酷的部分是，这个数据是在<em class="ko"> RGB </em>格式，我们正在使用<em class="ko"> HSL </em>。这意味着在我们继续之前，我们需要一个转换函数。理解这个函数并不重要，但知道它的签名才重要。<code class="fe mh mi mj mk b">convertRGBtoHSL</code>函数接受一个表示颜色的红、绿、蓝值的整数数组，并将返回一个表示颜色的色调、饱和度和亮度的整数数组。简单的🤓！</p><h2 id="b876" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">实用工具</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="4378" class="ml lf it mk b gy nb nc l nd ne">export const convertRGBtoHSL = rgb =&gt; {<br/>  const r = rgb[0] / 255<br/>  const g = rgb[1] / 255<br/>  const b = rgb[2] / 255<br/>  const min = Math.min(r, g, b)<br/>  const max = Math.max(r, g, b)<br/>  const delta = max - min<br/>  let h<br/>  let s<br/><br/>  if (max === min) {<br/>    h = 0<br/>  } else if (r === max) {<br/>    h = (g - b) / delta<br/>  } else if (g === max) {<br/>    h = 2 + (b - r) / delta<br/>  } else if (b === max) {<br/>    h = 4 + (r - g) / delta<br/>  }<br/><br/>  h = Math.min(h * 60, 360)<br/><br/>  if (h &lt; 0) {<br/>    h += 360<br/>  }<br/><br/>  const l = (min + max) / 2<br/><br/>  if (max === min) {<br/>    s = 0<br/>  } else if (l &lt;= 0.5) {<br/>    s = delta / (max + min)<br/>  } else {<br/>    s = delta / (2 - max - min)<br/>  }<br/><br/>  return [Math.round(h), Math.round(s * 100), Math.round(l * 100)]<br/>}</span></pre><p id="aa0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了基础，就可以实现<em class="ko">方形</em>组件。<em class="ko"> Square </em>的工作方式与<em class="ko"> Hue </em>类似，但是计算其句柄的<code class="fe mh mi mj mk b">left</code>和<code class="fe mh mi mj mk b">top</code>值的位置，在这种情况下称为<em class="ko"> Cross </em>只是为了减少命名约定的混乱。额外的步骤发生在计算位置之后。<code class="fe mh mi mj mk b">x</code>和<code class="fe mh mi mj mk b">y</code>值是<em class="ko">十字</em>的位置，作为<code class="fe mh mi mj mk b">[x, y]</code>存储在<code class="fe mh mi mj mk b">sqaureXY</code>状态变量中。<code class="fe mh mi mj mk b">x1</code>和<code class="fe mh mi mj mk b">y1</code>是位于<em class="ko">十字</em>中心的像素坐标，与<code class="fe mh mi mj mk b">ctx.getImageData</code>一起使用，以获得该像素的<em class="ko"> RGB </em>值。通过转换函数输入<em class="ko"> RGB </em>值，并返回<em class="ko"> HSL </em>值。色调已知，<code class="fe mh mi mj mk b">s</code>和<code class="fe mh mi mj mk b">l</code>组合成<code class="fe mh mi mj mk b">square</code>状态，称为<code class="fe mh mi mj mk b">[s, l]</code>。</p><h2 id="ccc7" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">广场. js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="6932" class="ml lf it mk b gy nb nc l nd ne">import React, { useRef, useEffect } from 'react'<br/>import styled from 'styled-components'<br/>import throttle from 'lodash.throttle'<br/>import { convertRGBtoHSL } from './utils'<br/>import Svg from './Svg'<br/>import usePaintSquare from './usePaintSquare'<br/>import config from './config'<br/><br/>const { squareSize, crossSize, delay } = config<br/><br/>export const SquareWrapper = styled.div`<br/>  position: relative;<br/>  width: ${squareSize + 'px'};<br/>  height: ${squareSize + 'px'};<br/>  cursor: crosshair;<br/>  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);<br/>`<br/><br/>export const Canvas = styled.canvas.attrs(p =&gt; ({<br/>  width: squareSize,<br/>  height: squareSize<br/>}))``<br/><br/>export const Cross = styled.div.attrs(p =&gt; ({<br/>  style: {<br/>    top: p.top + 'px',<br/>    left: p.left + 'px',<br/>    width: crossSize + 'px',<br/>    height: crossSize + 'px',<br/>    transition: p.animate ? 'top .25s ease-out, left .25s ease-out' : '0s'<br/>  }<br/>}))`<br/>  position: absolute;<br/>  display: grid;<br/>  justify-items: center;<br/>  align-items: center;<br/>  svg {<br/>    width: 100%;<br/>    height: 100%;<br/>  }<br/>`<br/><br/>const Square = ({ hue, squareXY, setSquare, offsetTop, offsetLeft, setSquareXY }) =&gt; {<br/>  const square = useRef(null)<br/>  const canvas = useRef(null)<br/><br/>  usePaintSquare(canvas, hue)<br/><br/>  useEffect(() =&gt; {<br/>    const canvasRef = canvas.current<br/>    const ctx = canvasRef.getContext('2d')<br/><br/>    function computePosition(e) {<br/>      const x = Math.max(<br/>        crossSize / -2,<br/>        Math.min(<br/>          e.clientX - offsetLeft + squareSize / 2 - crossSize / 2,<br/>          squareSize - crossSize / 2<br/>        )<br/>      )<br/>      const y = Math.max(<br/>        crossSize / -2,<br/>        Math.min(e.clientY - offsetTop + squareSize / 2 + crossSize / 2, squareSize - crossSize / 2)<br/>      )<br/><br/>      return [x, y]<br/>    }<br/><br/>    function changeColor(e) {<br/>      const [x, y] = computePosition(e)<br/>      const x1 = Math.min(x + crossSize / 2, squareSize - 1)<br/>      const y1 = Math.min(y + crossSize / 2, squareSize - 1)<br/>      const [r, g, b] = ctx.getImageData(x1, y1, 1, 1).data<br/>      const [h, s, l] = convertRGBtoHSL([r, g, b])<br/>      setSquare([s, l])<br/>      setSquareXY([x, y])<br/>    }<br/><br/>    const onMouseMove = throttle(e =&gt; {<br/>      changeColor(e)<br/>    }, delay)<br/><br/>    function onMouseUp(e) {<br/>      changeColor(e)<br/>      document.body.removeEventListener('mousemove', onMouseMove)<br/>      document.body.removeEventListener('mouseup', onMouseUp)<br/>    }<br/><br/>    function onMouseDown(e) {<br/>      document.body.addEventListener('mousemove', onMouseMove)<br/>      document.body.addEventListener('mouseup', onMouseUp)<br/>    }<br/><br/>    canvasRef.addEventListener('mousedown', onMouseDown)<br/><br/>    return () =&gt; {<br/>      canvasRef.removeEventListener('mousedown', onMouseDown)<br/>    }<br/>  }, [offsetTop, offsetLeft, setSquare, setSquareXY])<br/><br/>  return (<br/>    &lt;SquareWrapper ref={square}&gt;<br/>      &lt;Cross top={squareXY[1]} left={squareXY[0]}&gt;<br/>        &lt;Svg name='cross' /&gt;<br/>      &lt;/Cross&gt;<br/>      &lt;Canvas ref={canvas} /&gt;<br/>    &lt;/SquareWrapper&gt;<br/>  )<br/>}<br/><br/>export default Square</span></pre></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="a38e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了来自<em class="ko">方块</em>的数值在手，<em class="ko">拾取器</em>组件可以输出一个完整的<em class="ko"> HSL </em>颜色。我调整了一些到初始状态，这样<em class="ko">拾取器</em>从<code class="fe mh mi mj mk b">hsla(180, 100%, 50%, 1)</code>开始。更新<code class="fe mh mi mj mk b">color</code>的<code class="fe mh mi mj mk b">useEffect</code>钩子现在监听<code class="fe mh mi mj mk b">square</code>值的变化。</p><h2 id="de7a" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">Picker.js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="6235" class="ml lf it mk b gy nb nc l nd ne">import React, { useState, useRef, useEffect } from 'react'<br/>import styled from 'styled-components'<br/>import Modal from './Modal'<br/>import Hue from './Hue'<br/>import Square from './Square'<br/>import config from './config'<br/><br/>const { squareSize, barSize, crossSize } = config<br/><br/>export const PickerWrapper = styled.div`<br/>  user-select: none;<br/>  .swatch {<br/>    width: 100px;<br/>    height: 50px;<br/>    background: ${p =&gt; p.color};<br/>  }<br/>`<br/><br/>export const PickerOuter = styled.div`<br/>  width: ${squareSize + 20}px;<br/>  display: grid;<br/>  border-radius: 2px;<br/>  background: #ffffff;<br/>`<br/><br/>export const PickerInner = styled.div`<br/>  display: grid;<br/>  grid-template-rows: ${squareSize + 20}px 20px 1fr;<br/>  align-items: center;<br/>  justify-items: center;<br/>`<br/><br/>const Picker = () =&gt; {<br/>  const [show, setShow] = useState(true)<br/>  const [hue, setHue] = useState(180)<br/>  const [hueX, setHueX] = useState(() =&gt; squareSize / 2 - barSize / 2)<br/>  const [square, setSquare] = useState([100, 50])<br/>  const [squareXY, setSquareXY] = useState(() =&gt; [squareSize - crossSize / 2, crossSize / -2])<br/>  const [offsetTop, setOffsetTop] = useState(0)<br/>  const [offsetLeft, setOffsetLeft] = useState(0)<br/>  const [color, setColor] = useState(`hsla(180, 100%, 50%, 1)`)<br/><br/>  const modal = useRef(null)<br/><br/>  useEffect(() =&gt; {<br/>    function setOffsets() {<br/>      setOffsetTop(modal.current.offsetTop)<br/>      setOffsetLeft(modal.current.offsetLeft)<br/>    }<br/>    if (show) {<br/>      setOffsets()<br/>      window.addEventListener('resize', setOffsets)<br/>    } else {<br/>      window.removeEventListener('resize', setOffsets)<br/>    }<br/><br/>    return () =&gt; {<br/>      window.removeEventListener('resize', setOffsets)<br/>    }<br/>  }, [show])<br/><br/>  useEffect(() =&gt; {<br/>    setColor(`hsla(${hue}, ${square[0]}%, ${square[1]}%, 1)`)<br/>  }, [hue, square])<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;PickerWrapper color={color}&gt;<br/>        &lt;div className='swatch' onClick={() =&gt; setShow(true)} /&gt;<br/>        &lt;Modal modal={modal} show={show} onClose={() =&gt; setShow(false)}&gt;<br/>          &lt;PickerOuter&gt;<br/>            &lt;PickerInner&gt;<br/>              &lt;Square<br/>                hue={hue}<br/>                squareXY={squareXY}<br/>                offsetTop={offsetTop}<br/>                offsetLeft={offsetLeft}<br/>                setSquare={setSquare}<br/>                setSquareXY={setSquareXY}<br/>              /&gt;<br/>              &lt;Hue hueX={hueX} offsetLeft={offsetLeft} setHueX={setHueX} setHue={setHue} /&gt;<br/>              &lt;div&gt;inputs&lt;/div&gt;<br/>            &lt;/PickerInner&gt;<br/>          &lt;/PickerOuter&gt;<br/>        &lt;/Modal&gt;<br/>      &lt;/PickerWrapper&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/><br/>export default Picker</span></pre></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="6b55" class="le lf it bd lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx nj lz ma mb bi translated">投入</h1><p id="afbe" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">各种各样的输入可以添加到这个颜色选择器中，以接收用户数据。对于这种实现，我们将为<em class="ko">色调</em>、<em class="ko">饱和度</em>和<em class="ko">亮度</em>提供单个输入。即使输入类型是<em class="ko">数字</em>，我们也将使用文本输入。我不喜欢默认的箭头。<em class="ko">输入</em>组件接收一个<code class="fe mh mi mj mk b">value</code>以及<code class="fe mh mi mj mk b">min</code>、<code class="fe mh mi mj mk b">max</code>和<code class="fe mh mi mj mk b">defaultValue</code>。当用户输入进来时，它被检查以确保它是一个数字。如果数值超出了<code class="fe mh mi mj mk b">min</code> / <code class="fe mh mi mj mk b">max</code>界限，则自动返回到<code class="fe mh mi mj mk b">defaultValue</code>。如果输入为空，一个<code class="fe mh mi mj mk b">onBlur</code>事件处理程序起到类似的作用。</p><h2 id="453a" class="ml lf it bd lg mm mn dn lk mo mp dp lo kb mq mr ls kf ms mt lw kj mu mv ma mw bi translated">输入. js</h2><pre class="kx ky kz la gt mx mk my mz aw na bi"><span id="8c0f" class="ml lf it mk b gy nb nc l nd ne">import React, { useRef } from 'react'<br/>import styled from 'styled-components'<br/><br/>export const InputWrapper = styled.div`<br/>  display: flex;<br/>  align-items: center;<br/>  user-select: none;<br/>  label {<br/>    font-size: 11px;<br/>    margin-right: 5px;<br/>  }<br/>  input {<br/>    width: 40px;<br/>    text-align: center;<br/>    border: 1px solid #ddd;<br/>    outline: 0;<br/>    font-family: monospace;<br/>    font-size: 10px;<br/>    padding: 4px 4px;<br/>    user-select: none;<br/>    &amp;:focus {<br/>      background: #fafafa;<br/>    }<br/>    &amp;::selection {<br/>      background: #ddd;<br/>    }<br/>  }<br/>`<br/><br/>const Input = ({ label, value, max, min, defaultValue, setValue }) =&gt; {<br/>  const input = useRef(null)<br/><br/>  function onBlur(e) {<br/>    if (e.target.value === '') {<br/>      setValue(defaultValue)<br/>    } else if (e.target.value &lt; min) {<br/>      setValue(min)<br/>    }<br/>  }<br/><br/>  function onChange(e) {<br/>    const isDigit = /^\d\*\$/<br/>    var newValue<br/>    if (isDigit.test(e.target.value)) {<br/>      if (Number(e.target.value) &gt; max) {<br/>        newValue = max<br/>      } else {<br/>        newValue = Number(e.target.value)<br/>      }<br/>    } else {<br/>      newValue = defaultValue<br/>    }<br/>    setValue(newValue)<br/>  }<br/><br/>  return (<br/>    &lt;InputWrapper&gt;<br/>      &lt;label&gt;{label}&lt;/label&gt;<br/>      &lt;input ref={input} value={value} onChange={onChange} onBlur={onBlur} autoFocus={false} /&gt;<br/>    &lt;/InputWrapper&gt;<br/>  )<br/>}<br/><br/>export default Input</span></pre><p id="e533" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要新的功能来设置<em class="ko">手柄</em>和<em class="ko">十字</em>的位置。您可能已经注意到一些组件中基于<code class="fe mh mi mj mk b">animate</code>道具的一些样式逻辑。本质上，当使用<em class="ko">输入</em>时，<em class="ko">手柄</em>和<em class="ko">十字</em>将动画显示到它们的新位置。当用户拖动时<code class="fe mh mi mj mk b">animate</code>将为假。<code class="fe mh mi mj mk b">animate</code>道具和<code class="fe mh mi mj mk b">setAnimate</code>必须传给<em class="ko">色相</em>和<em class="ko">方</em>。只需将<code class="fe mh mi mj mk b">setAnimate(false)</code>添加到<code class="fe mh mi mj mk b">mousedown</code>事件处理程序中。在<em class="ko">输入</em>周围还需要一个包装器。</p><p id="b877" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读！这篇文章比我最初打算的要长得多，而且只涉及了基础知识。如果你能走到这一步，恭喜你自己。我希望这足以让你走上正轨。仍然有许多额外的功能可以添加，以增强这个颜色选择器。以下是一些想法:</p><ul class=""><li id="977b" class="ns nt it js b jt ju jx jy kb nu kf nv kj nw kn oh ny nz oa bi translated">添加一个调色板，让用户保存颜色— <code class="fe mh mi mj mk b">localStorage</code>也许</li><li id="07ea" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn oh ny nz oa bi translated">添加色板以在拾色器中显示选定的颜色</li><li id="08ca" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn oh ny nz oa bi translated">添加确认按钮</li><li id="4d44" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn oh ny nz oa bi translated">以<em class="ko"> HSL </em>、<em class="ko"> RGB </em>、<em class="ko"> HEX </em>或其他格式添加颜色字符串的显示</li><li id="b533" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn oh ny nz oa bi translated">为其他颜色格式添加输入</li><li id="941a" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn oh ny nz oa bi translated">添加一个可以接受3或6位十六进制代码的解析器</li><li id="cc61" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn oh ny nz oa bi translated">添加alpha条来设定颜色的不透明度</li></ul></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="4e16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看本文续集<a class="ae kp" href="https://benjaminadk.netlify.com/posts/using-local-storage-to-persist-data/" rel="noopener ugc nofollow" target="_blank">https://Benjamin Brooke . me/posts/using-local-storage-to-persist-data/</a></p><p id="d828" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">原载于2019年8月13日</em><a class="ae kp" href="https://benjaminadk.netlify.com/posts/how-to-build-a-color-picker/" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://benjaminadk.netlify.com</em></a><em class="ko">。</em></p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><div class="kx ky kz la gt oi"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">React是一个现代JavaScript库，前端web开发人员使用它来构建用户界面(UI)。它用于…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">gitconnected.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow nl oi"/></div></div></a></div></div></div>    
</body>
</html>