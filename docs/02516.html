<html>
<head>
<title>Master RxJS: Frontend data stores in services using BehaviorSubject</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">主RxJS:使用BehaviorSubject在服务中存储前端数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/master-rxjs-data-stores-in-services-c1f553e5d48b?source=collection_archive---------2-----------------------#2020-03-19">https://levelup.gitconnected.com/master-rxjs-data-stores-in-services-c1f553e5d48b?source=collection_archive---------2-----------------------#2020-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="45e9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用BehaviorSubject而不触发不必要的重新渲染、内存问题和不必要的突变</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f81704111c8cde2b183cb07e4e6734c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z-iYqXHMc0H0FAJ7"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丘特尔斯纳普</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="d7ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着在向UI组件交付数据的服务中使用RxJS的流行，越来越多的人只使用RxJS <strong class="ky ir">而不是更专用的应用程序状态管理包，如NgRx、Redux、NGXS等。，尤其是有棱角的。</strong></p><p id="c012" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种常用的模式是让一个BehaviorSubject保存数据，并作为Http响应处理过程的一部分使用<code class="fe ls lt lu lv b">.next()</code>插入数据。让我们以此为起点，逐步改进，讨论每个步骤的问题和解决方案。</p><blockquote class="lw"><p id="2ea4" class="lx ly iq bd lz ma mb mc md me mf lr dk translated">重要！开始之前，请阅读以下内容！</p></blockquote><p id="aeaa" class="pw-post-body-paragraph kw kx iq ky b kz mg jr lb lc mh ju le lf mi lh li lj mj ll lm ln mk lp lq lr ij bi translated"><em class="ml">请注意，下面描述的许多方法，如深度冻结和简单对象比较</em> <strong class="ky ir"> <em class="ml">，对于某些数据类型</em> </strong> <em class="ml">将无法正常工作，例如不仅</em> <code class="fe ls lt lu lv b"><em class="ml">Map</em></code> <em class="ml">、</em> <code class="fe ls lt lu lv b"><em class="ml">Set</em></code> <em class="ml">、</em> <code class="fe ls lt lu lv b"><em class="ml">WeakMap</em></code> <em class="ml">和</em> <code class="fe ls lt lu lv b"><em class="ml">WeakSet</em></code> <em class="ml">，还有</em> <code class="fe ls lt lu lv b"><em class="ml">function</em></code> <em class="ml">。希望你没有在服务中的base </em> <code class="fe ls lt lu lv b"><em class="ml">BehaviorSubject</em></code> <em class="ml">中存储任何这些类型，但是如果你存储了，请注意你将不得不手动规避与这些相关的任何问题。</em></p><h1 id="d249" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">第一步:商店开门迎客</h1><p id="68ee" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">假设我们有一个为用户获取<code class="fe ls lt lu lv b">userData</code>的服务。我们忽略了如何识别用户，而只是简单地看一个没有返回用户的参数的get调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">消费者很容易改变其状态的商店</figcaption></figure><p id="07b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，变量<code class="fe ls lt lu lv b">USER_DATA_INIT</code>是一个匹配类型<code class="fe ls lt lu lv b">UserData</code>的初始化对象。除此之外，它非常简单。首先，让我们讨论并解决这个实现的两个突出问题。</p><h2 id="8a37" class="nl mn iq bd mo nm nn dn ms no np dp mw lf nq nr my lj ns nt na ln nu nv nc nw bi translated"><strong class="ak">公共用户数据$ </strong></h2><p id="527c" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">第一个大问题是，<code class="fe ls lt lu lv b">userData$</code>是<code class="fe ls lt lu lv b">public</code>，因此暴露在服务之外。这意味着任何使用<code class="fe ls lt lu lv b">UserService</code>的组件或其他服务都可以调用<code class="fe ls lt lu lv b">.next()</code>方法来覆盖存储服务中的任何内容。换句话说，什么数据可以存储在<code class="fe ls lt lu lv b">userData$</code>中的定义并不局限于这个类，可以在代码库中的任何地方任意修改。</p><p id="a876" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这个问题最简单的方法是将<code class="fe ls lt lu lv b">userData$</code>声明为私有的，并公开消费者可以利用的公共选择器函数。这些选择器函数是可观察的，要么返回整个对象，要么只返回特定的字段。一个例子是<code class="fe ls lt lu lv b">public userName$</code>，它只从<code class="fe ls lt lu lv b">userData$</code>中暴露<code class="fe ls lt lu lv b">userName</code>属性。</p><p id="89ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ml">(如果你想暴露整个</em> <code class="fe ls lt lu lv b"><em class="ml">BehaviorSubject</em></code> <em class="ml">你也可以把</em> <code class="fe ls lt lu lv b"><em class="ml">userData$.asObservable()</em></code> <em class="ml">暴露为一个公共变量。)</em></p><h2 id="4743" class="nl mn iq bd mo nm nn dn ms no np dp mw lf nq nr my lj ns nt na ln nu nv nc nw bi translated">可变用户数据</h2><p id="9753" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">尽管这取决于类型<code class="fe ls lt lu lv b">UserData</code>的结构，但是存储在<code class="fe ls lt lu lv b">dataStore$</code>中的对象在这一点上是完全可变的。虽然选择器将确保第一级道具不再是可变的，但是嵌套对象仍然可以被任何消费者改变。</p><p id="0c43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们有一个名为<code class="fe ls lt lu lv b">messages</code>的道具，它包含一个类型为<code class="fe ls lt lu lv b">Message</code>的数组。如果任何消费者订阅该服务并访问该属性，该消费者可以使用<code class="fe ls lt lu lv b">push</code>或<code class="fe ls lt lu lv b">pop</code>或任何其他改变数组的数组函数，存储在<code class="fe ls lt lu lv b">UserDataService</code>中的数据当然会改变，这意味着该服务的所有其他消费者将在各自的过程中使用改变后的数组。</p><p id="66de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于大多数Javascript开发人员来说，这个问题应该再熟悉不过了。虽然有无数的文章讨论如何处理可变性和冻结，但我倾向于使用一个递归的<code class="fe ls lt lu lv b">deepFreeze</code>函数来处理这个问题。我使用的实现如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">deepFreeze的一个可能实现</figcaption></figure><h1 id="92d6" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">第二步:嘈杂的商店</h1><p id="863f" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">实施上面讨论的更改，我们最终会得到以下结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">一家噪音很大的商店，比正常情况下排放的气体要多得多！</figcaption></figure><p id="470e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来好多了！对于大多数应用程序来说，这可能就足够了。但是在这一步，让我们看看如何减少由于对重复数据输入处理不当而导致的不必要的排放。关于这一点，我们可以解决两个具体问题:</p><h2 id="4ba1" class="nl mn iq bd mo nm nn dn ms no np dp mw lf nq nr my lj ns nt na ln nu nv nc nw bi translated"><strong class="ak">重复门店排放</strong></h2><p id="29c0" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">让我们假设用户浏览你的站点，并访问两个独立的页面，这两个页面都触发了对<code class="fe ls lt lu lv b">userData</code>的获取。这是有意义的:毕竟，当用户访问时，API上存储的数据很可能已经改变。但是，让我们假设用户收到的数据与前一次获取的数据完全相同。接下来会发生什么？</p><p id="d813" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从API获取数据，订阅函数使用重复数据调用<code class="fe ls lt lu lv b">userData$.next()</code>。<code class="fe ls lt lu lv b">userData$</code>然后发出这个数据，所有的订阅和选择器将再次触发。</p><p id="bf99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个简单的例子中，这不是一个很大的问题，但最近我在一个项目中使用提取的数据作为一些非常广泛的计算和处理前端的基础，用于计算各种变量和呈现给用户的图形。</p><p id="7b76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有人可能认为这可以在API中完成，但是由于计算完全与UI相关，并且只与我们的特定堆栈相关(API有许多消费者)，我们在前端执行这些操作。我们观察到，每隔一段时间，页面就会获取重复的值，这些重复的值会多次触发这些操作，从而降低页面的速度。</p><p id="6f3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们如何解决这个问题呢？那些熟悉RxJs的人可能会期待一个<code class="fe ls lt lu lv b">distinctUntilChanged</code>的引入，虽然我们稍后会这样做，但我们现在要做一些稍微不同的事情。但在此之前，我们需要一种方法来查看以前的数据和当前的数据是否相同。</p><p id="4c1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据对象的简单或复杂程度，编写一个定制的验证器可能是明智的。我喜欢使用一个我称之为<code class="fe ls lt lu lv b">naiveObjectComparison</code>的通用方法，但当然这不是我自己想出来的，因为大多数Javascript开发人员对此应该很熟悉。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">简单对象比较</figcaption></figure><p id="af17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，对于某些数据类型，例如<code class="fe ls lt lu lv b">Set</code>和<code class="fe ls lt lu lv b">Map</code>，这种方法不能正常工作。</p><p id="ea0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始工作吧。我们将创建一个名为<code class="fe ls lt lu lv b">Store</code>的新数据类型，它扩展了<code class="fe ls lt lu lv b">BehaviorSubject</code>。在很大程度上，它将像<code class="fe ls lt lu lv b">BehaviorSubject</code>一样工作，但是我们将覆盖下一个函数，以确保我们不会转发重复的函数。我们还将把传入数据的<code class="fe ls lt lu lv b">deepFreeze</code>直接合并到类型中。我们以下面的定义结束:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">解决冻结和过滤重复数据输入的自定义存储数据类型</figcaption></figure><p id="a72a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们用<code class="fe ls lt lu lv b">userDataService</code>中的<code class="fe ls lt lu lv b">Store</code>替换<code class="fe ls lt lu lv b">BehaviorSubject</code>，并删除Http订阅中的<code class="fe ls lt lu lv b">deepFreeze</code>调用。因此，作为我们的第一步，我们现在已经修复了重复的商店排放。</p><h2 id="b450" class="nl mn iq bd mo nm nn dn ms no np dp mw lf nq nr my lj ns nt na ln nu nv nc nw bi translated">重复选择器发射</h2><p id="72cb" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">即使我们的存储不再发出重复数据，我们的选择器可能仍然会这样做。你可能会想，<em class="ml">嘿，Lars，我们刚刚在基础级别解决了这个问题！这已经不是问题了，对吧？</em> <strong class="ky ir">错了。</strong></p><p id="a7a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果Http获取再次被触发，假设用户的年龄已经改变(在她生日前的午夜浏览！)，那么显然我们的<code class="fe ls lt lu lv b">Store.next()</code>函数会认为数据被改变并插入新的数据。这将依次向<strong class="ky ir">所有</strong>订户发送值，这意味着<strong class="ky ir">所有</strong>我们的选择器现在都将被触发，即使只有一个字段被更新。</p><p id="185c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次我们将使用前面提到的<code class="fe ls lt lu lv b">distinctUntilChanged</code>操作符。<code class="fe ls lt lu lv b">distinctUntilChanged</code>通过比较先前的排放和当前的排放，过滤掉与上一次相同的排放。</p><p id="836c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe ls lt lu lv b">userName$</code>和<code class="fe ls lt lu lv b">age$</code>，我们只需在<code class="fe ls lt lu lv b">map</code>操作符后添加<code class="fe ls lt lu lv b">distinctUntilChanged()</code>。</p><p id="8d9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意，这个顺序很重要</strong>；如果将<code class="fe ls lt lu lv b">distinctUntilChanged()</code>放在<code class="fe ls lt lu lv b">map</code>之前，它将比较<strong class="ky ir">输入</strong>而不是<strong class="ky ir">输出</strong>。我们想要停止相同的<strong class="ky ir">输出</strong>，意思是<code class="fe ls lt lu lv b">name</code>或<code class="fe ls lt lu lv b">age</code>，而不是相同的<strong class="ky ir">输入</strong>，意思是<code class="fe ls lt lu lv b">userData</code>对象本身。过滤重复的<code class="fe ls lt lu lv b">userData</code>输入在上一步已经解决。</p><p id="bc0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">遵循关注点分离原则，我们应始终假设选择器的输入已经过重复发射过滤程序。</strong></p><p id="4fad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这并不容易。注意<code class="fe ls lt lu lv b">messages$</code>不是一个原语，而是一个数组，因此是一个对象。默认情况下，<code class="fe ls lt lu lv b">distinctUntilChanged()</code>使用<code class="fe ls lt lu lv b">===</code>进行比较，这意味着它只比较引用，而不比较任何属性的实际值。</p><p id="e237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<code class="fe ls lt lu lv b">distinctUntilChanged</code>采用比较函数作为参数，允许用户手动比较以前和当前的排放量。在这种情况下，为已知结构的道具编写一个自定义函数通常是明智的，但是在这种情况下使用<code class="fe ls lt lu lv b">naiveObjectComparison</code>也是可以的。</p><h1 id="9f90" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">步骤3:选择器繁忙的内存泄漏存储</h1><p id="f72b" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">实现上述更改后，我们的服务现在看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">一家不断发展壮大的商店，选择器的工作太多了</figcaption></figure><p id="2e9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好多了！但是我们还可以做一个优化，它可能会产生相当大的影响。</p><p id="3601" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">向管道添加订阅时，RxJs的默认行为是为每个订阅创建该管道的新实例及其所有操作符。虽然这种行为在很多情况下是件好事，但对于数据存储的值选择器来说，这是不必要的，而且可能会占用大量资源。</strong></p><p id="f847" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设您有一个服务，它将数据映射为图形UI的现成数据。在UI中，有两个组件显示的图形略有不同，但它们都订阅了相同的选择器函数来进行数据映射。</p><p id="644f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在这种情况下，数据映射过程将运行<em class="ml">两次——每次订阅运行</em>一次——每次发出新数据。</strong></p><p id="abad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，随着订阅数量的增加，还存在内存泄漏的问题。您可能认为这不是问题，因为单个可观察对象的内存占用非常小。</p><p id="2073" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，随着应用程序变得越来越复杂，我们经常创建使用选择器的<strong class="ky ir">选择器，以及使用这些选择器的选择器，等等</strong>。至少在我工作过的堆栈中，有一些服务组合起来达到了<strong class="ky ir"> 20(！)</strong>选择器从应用程序的各个部分创建一个新的选择器，然后这个选择器在被UI访问之前被另一个级别订阅，在UI组件中，同一个选择器上可能有四个或五个订阅，它们做不同的事情。</p><p id="4429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的应用程序可能有<strong class="ky ir">千个</strong>重复的可观察对象，它们<strong class="ky ir">执行完全相同的任务并发出完全相同的值。</strong>你可能认为解决这个问题的方法是限制嵌套订阅的级别，<strong class="ky ir">但是我们希望开发者能够像鸟儿一样筑巢！</strong>嵌套选择器是最强大的工具之一，用于将数据从它们的基础逐渐转换成每个UI组件需要的数据。</p><p id="044d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，RxJs提供了一些操作符来帮助解决这些问题。第一个被称为<code class="fe ls lt lu lv b">share</code>，它的工作原理是<strong class="ky ir">确保只有一个管道实例存在并被所有订阅者使用。</strong>换句话说，它是一个无比强大的运营商。</p><p id="cf88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这本身是好的，但在使用任何<code class="fe ls lt lu lv b">BehaviorSubject</code>管道时有一个警告。默认情况下，当在<code class="fe ls lt lu lv b">BehaviorSubject</code>上创建订阅时，首先通过立即发出当前值来同步订阅，然后在发出任何后续发出时异步订阅。</p><p id="6495" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">share</code>将改变这种行为，因为从<code class="fe ls lt lu lv b">BehaviorSubject</code>的角度来看，每个选择器只有一个订阅。因此，<code class="fe ls lt lu lv b">share</code>将仅在第一次订阅时获得存储在<code class="fe ls lt lu lv b">BehaviorSubject</code>中的值，任何后续订阅者将仅从<code class="fe ls lt lu lv b">BehaviorSubject</code>获得异步发射。</p><p id="1910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，RxJs有另一个类似的操作符来解决这个问题。<code class="fe ls lt lu lv b">shareReplay</code>操作符基本上类似于<code class="fe ls lt lu lv b">share</code>，但是增加了同步返回最新值给任何新订户的行为。<code class="fe ls lt lu lv b">shareReplay</code>接受一个参数，即存储和转发多少排放，但是在我们的例子中，我们想要模拟<code class="fe ls lt lu lv b">BehaviorSubject</code>的默认行为，所以我们使用1。</p><h1 id="4642" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">步骤4:详细存储</h1><p id="00f2" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">我们当前的实现如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">一家需要花很长时间才能打印出来的商店。说真的，所有商店都应该这么啰嗦吗！？</figcaption></figure><p id="6dc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从功能上来说，我们的设置是可靠的，可以投入生产。我们出色的管道和工程解决了以下幼稚实现的问题:</p><ul class=""><li id="feeb" class="nx ny iq ky b kz la lc ld lf nz lj oa ln ob lr oc od oe of bi translated"><strong class="ky ir">消费者改写存储的数据</strong></li><li id="5810" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated"><strong class="ky ir">消费者对存储的数据进行变异</strong></li><li id="2c74" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated"><strong class="ky ir">重复的Http响应强制反应</strong></li><li id="73bc" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated"><strong class="ky ir">重复数据值强制反应</strong></li><li id="5cdf" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated"><strong class="ky ir">内存泄漏和冗余处理</strong></li></ul><p id="0ec9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们的解决方案开始变得有点冗长。每个选择器在其管道中至少需要一个<code class="fe ls lt lu lv b">map</code>、一个<code class="fe ls lt lu lv b">distinctUntilChanged</code>和一个<code class="fe ls lt lu lv b">shareReplay</code>操作符。因为我们希望所有的选择器至少有这三个操作符，我们可以做得比一遍又一遍地定义它们更好。</p><p id="f58a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一个问题是，如果类型是一个对象或数组，那么<code class="fe ls lt lu lv b">distinctUntilChanged</code>应该将<code class="fe ls lt lu lv b">naiveObjectComparison</code>作为一个参数，如果类型是一个原语，那么就没有参数，这种区别应该从开发人员那里抽象出来。除此之外，自定义的比较功能也应该被允许，由开发者在任何必要的时候决定。</p><p id="b703" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">换句话说，虽然当前的实现在功能上是正确的，并且大大提高了用户体验，但是开发人员的体验却受到了影响。让我们解决这个问题。</strong></p><p id="3a88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">选择$ </strong></p><p id="4c9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们引入一个叫做<code class="fe ls lt lu lv b">select$</code>的新函数。这个函数将返回一个可观察对象，包括我们当前在选择器管道中使用的所有操作符。它将一个源流和一个映射函数作为强制参数，并将一个<code class="fe ls lt lu lv b">memoizationFunction</code>作为可选参数。</p><p id="04aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">source$</code>是源流，通常会是我们的存储对象；在这种特殊情况下<code class="fe ls lt lu lv b">userData$</code>。</p><p id="0d04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">mapping</code>功能将成为<code class="fe ls lt lu lv b">map</code>操作器的参数。换句话说，它是一个描述我们如何从源发射中提取我们想要发射的道具的函数。<code class="fe ls lt lu lv b">age$</code>的一个例子是<code class="fe ls lt lu lv b">userData =&gt; userData.age</code>。</p><p id="a409" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe ls lt lu lv b">memoizationFunction</code>是用于确定我们之前和当前的排放量是否相等的函数。这是可选的，如果没有给出，我们使用默认的记忆功能，对对象运行<code class="fe ls lt lu lv b">naiveObjectComparison</code>，否则运行<code class="fe ls lt lu lv b">===</code>比较。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="232e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到我们已经在前面的章节中完成了实现，大部分代码应该是简单明了的。这里要考虑的重要事情是，我们希望基于是否返回一个对象的不同行为。</p><p id="c8a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们通过检查先前和当前值的类型来解决这个问题，如果它们是对象，我们使用<code class="fe ls lt lu lv b">naiveObjectComparison</code>，否则我们使用<code class="fe ls lt lu lv b">===</code>比较。</p><p id="3cde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以说，检查每次排放的类型并不太有效，但这优于替代解决方案:</p><ul class=""><li id="97dd" class="nx ny iq ky b kz la lc ld lf nz lj oa ln ob lr oc od oe of bi translated">使用Typescript和对<code class="fe ls lt lu lv b">R</code>的限制来解决这个问题。这将意味着创建两个函数(<code class="fe ls lt lu lv b">selectPrimitive$</code>和<code class="fe ls lt lu lv b">selectObject$</code>)，因为我们无法利用类型限制运行时，实现会有所不同。如果忽略类型警告，这会给开发人员带来复杂性和运行时错误。</li><li id="1bfc" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated">通过只检查一次类型来解决它。如果没有设置数据对象的属性，我们允许映射返回<code class="fe ls lt lu lv b">null</code>或<code class="fe ls lt lu lv b">undefined</code>，仅从这个事实我们不能确定映射函数在运行时通常是返回一个对象还是一个原语。换句话说，我们必须每次都检查类型。</li></ul><p id="137b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，对每次排放的先前和当前值进行类型检查是一个非常快速的操作，尤其是考虑到我们已经消除了来自任何输入源的重复排放，因此这应该不是什么大问题。</p><p id="88fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果任何读者对这个具体问题有更好的解决方案，请在下面留下评论，我很想知道！</p><h1 id="3c45" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">最终解决方案:一个完美的商店</h1><p id="dfc5" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">随着<code class="fe ls lt lu lv b">select$</code>功能的完成，我们将<code class="fe ls lt lu lv b">dataUserService</code>实现更改如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用select$ for选择函数的完整存储</figcaption></figure><p id="69a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，<code class="fe ls lt lu lv b">select$</code>也允许嵌套，没有任何问题。只要确保当你使用嵌套的<code class="fe ls lt lu lv b">select$</code>时，声明顺序遵循树的深度。换句话说，如果你在<code class="fe ls lt lu lv b">this.messages$</code>上使用<code class="fe ls lt lu lv b">select$</code>来获得<code class="fe ls lt lu lv b">dataUser.messages</code>的一个道具，确保<code class="fe ls lt lu lv b">this.messages$</code>被首先声明。</p><p id="76a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，我们现在已经完成了漂亮的基本商店服务。这样，您就可以在服务中存储数据，并将其分发给组件和其他服务了！不错！</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="8e81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唷！精通RxJs不仅需要理解相当多的操作符，有时还需要理解RxJs在基本层面上的行为。当我第一次尝试在<code class="fe ls lt lu lv b">BehaviorSubjects</code>上使用<code class="fe ls lt lu lv b">share() </code>时，我挣扎了很长时间才明白为什么它不能正确工作，因为我没有掌握一些关于<code class="fe ls lt lu lv b">BehaviorSubject</code>和管道如何工作的基本概念。</p><p id="fbcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">坚持下去，它最终会到来的，一如既往…继续为你的成功铺平道路！</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="8631" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多我关于专业RxJs和Angular的文章:</p><div class="os ot gp gr ou ov"><a href="https://medium.com/swlh/master-rxjs-handling-auth-related-events-frontend-with-rxjs-a10c396c6493" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">主RxJs:用RxJs处理授权相关事件前端</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">RxJs擅长处理异步操作。今天，我们将探讨如何解决一个更具挑战性的问题…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj kp ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://larsholdaas.medium.com/master-rxjs-debounce-all-but-first-223eb90089dd" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">主机RxJs:除第一个之外的所有去抖</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">随着反应式表单和其他输入设置接受用户输入作为一个可观察的流，它已经变得相当…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">larsholdaas.medium.com</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj kp ov"/></div></div></a></div></div></div>    
</body>
</html>