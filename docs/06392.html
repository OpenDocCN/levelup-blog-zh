<html>
<head>
<title>Using Termux to Synchronise with Remote Machines (Linux/MacOS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Termux与远程机器同步(Linux/MacOS)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-termux-to-synchronise-with-remote-machines-linux-macos-5826978a3328?source=collection_archive---------1-----------------------#2020-11-21">https://levelup.gitconnected.com/using-termux-to-synchronise-with-remote-machines-linux-macos-5826978a3328?source=collection_archive---------1-----------------------#2020-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5e154d1eef035db233d3e265253306bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gpKj8NpZDv51KriT_b97A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用SSH和rsync在移动中的机器之间轻松共享文件</figcaption></figure><p id="e51e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个想法是使用一个Android手机作为文件服务器，这样我们就可以一直带着我们的文件。我用的是LG G5，它有一个方便的SD卡插槽，我可以放一个128 Gb的卡来存储我每天在4台不同的机器上使用的文件。在本文中，我们将了解Termux、SSH、scp和rsync如何帮助我们在不依赖云的情况下改进工作流。</p><p id="1548" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，你必须确保通过F-Droid应用程序库或Google PlayStore安装所有与Termux相关的(附加组件),但不要混合两者的附加组件。</p><p id="321a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Termux只能读取外部存储器(SD卡)；但是使用下面的命令，它将创建一个Android/data/com.termux/files/目录，您可以在其中使用termux进行读写操作:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3f6f" class="lj lk iq lf b gy ll lm l ln lo">termux-setup-storage</span></pre><p id="952a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该命令还会在Android设备上的Termux文件夹中创建符号链接。</p><p id="fd11" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们更新Termux环境并安装SSH:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="5d24" class="lj lk iq lf b gy ll lm l ln lo">pkg up # or apt-get update<br/>pkg install openssh</span></pre><p id="d85f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们希望SSH服务器在Termux运行的任何时候都能运行。通过创建(如果不存在)和编辑<em class="lp">，您可以在每次登录Termux时运行命令。<em class="lp"> home </em>目录下的bash_profile </em>文件:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ef23" class="lj lk iq lf b gy ll lm l ln lo">nano ~/.bash_profile</span></pre><p id="b949" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里，我们添加了一个条件，只启动SSH服务器并只运行脚本一次，我们在临时目录中创建一个文件，每次Termux启动时都会清除该文件，并检查该文件是否存在，以便不再运行任务:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="a7cc" class="lj lk iq lf b gy ll lm l ln lo">#!/data/data/com.termux/files/usr/bin/bash</span><span id="6445" class="lj lk iq lf b gy lq lm l ln lo">if [ ! -e “$TMPDIR/termux-started” ]<br/>then<br/> sshd<br/> touch “$TMPDIR/termux-started”<br/>fi</span></pre><p id="6710" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我个人添加了另一行代码，将我工作的目录更改为Termux在SD卡上可以控制的目录。它应该在if条件之外，以便在我每次登录Termux时执行:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="4b3d" class="lj lk iq lf b gy ll lm l ln lo">cd ~/storage/external-1/</span></pre><p id="8f43" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们把重点放在无缝的SSH连接上(不需要密码)。<br/>要从Termux连接到您的远程机器，请在Termux中创建SSH公钥:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="e56e" class="lj lk iq lf b gy ll lm l ln lo">ssh-keygen -b 4096 -t rsa</span></pre><p id="8a32" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将密钥复制到远程计算机:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="0951" class="lj lk iq lf b gy ll lm l ln lo">ssh-copy-id -i ~/.ssh/id_rsa.pub <a class="ae lr" href="mailto:username@192.168.xx.xx" rel="noopener ugc nofollow" target="_blank">username@192.168.xx.xx</a></span></pre><p id="72b3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要从远程机器连接到Termux，请在远程机器上创建SSH公钥:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="196b" class="lj lk iq lf b gy ll lm l ln lo">ssh-keygen -b 4096 -t rsa</span></pre><p id="eb2b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将SSH公钥复制到Termux，以建立到Termux的SSH连接，同样使用<em class="lp"> ssh-copy-id </em>命令，您需要使用Termux监听端口8022:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d054" class="lj lk iq lf b gy ll lm l ln lo">ssh-copy-id -p 8022 -i ~/.ssh/id_rsa.pub <a class="ae lr" href="mailto:username@192.168.xx.xx" rel="noopener ugc nofollow" target="_blank">username@192.168.xx.xx</a></span></pre><p id="ea4f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从现在开始，要通过ssh连接到Termux实例，我们只需输入以下命令:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c0f4" class="lj lk iq lf b gy ll lm l ln lo">ssh -p 8022 192.168.xx.xx</span></pre><p id="3576" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用Termux，您可以访问您的Android设备的功能。您必须安装<em class="lp"> Termux:API </em>附加组件。<br/>在termux中安装以下软件包:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="825a" class="lj lk iq lf b gy ll lm l ln lo">pkg install termux-api</span></pre><p id="9da1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您可以访问您的电池信息，例如:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="5a06" class="lj lk iq lf b gy ll lm l ln lo">termux-battery-status</span></pre><p id="a7cb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了解析通过前面的命令获得的json格式的信息，安装json解析器(在macOS上“brew install jq”):</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="af69" class="lj lk iq lf b gy ll lm l ln lo">pkg install jq</span></pre><p id="2fc6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在你可以输入<em class="lp">jq-r’得到你需要的东西。'字典_关键字'。</em></p><p id="84d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们设置我们的<em class="lp"> RSYNC </em>工作流程，下面是它的工作方式:</p><p id="ba20" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然RSYNC脚本将持续运行，但我们需要每5分钟检查一次电池状态，并将结果写入文件。然后，我们使用设备的mac地址在网络上找到Android设备的IP地址(它可以作为热点或在本地网络上)，将文件从Android设备传输到远程机器，如果剩余空间足够大(阈值为20%)，则继续传输，或者如果接通电话，我们从Android设备传输到远程机器，然后反之亦然，检查文件夹或文件是否有更改。</p><p id="d660" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Termux上安装rsync:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="fd97" class="lj lk iq lf b gy ll lm l ln lo">pkg install rsync</span></pre><p id="bdb4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们使用以下代码执行脚本ad vitam aeternam:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="a13f" class="lj lk iq lf b gy ll lm l ln lo">while true<br/>do<br/>done</span></pre><p id="b62a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">获取电池状态并将<em class="lp"> JSON </em>响应写入<em class="lp">。json </em>文件备用。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="9d69" class="lj lk iq lf b gy ll lm l ln lo">echo $(termux-battery-status) &gt; ~/storage/external-1/battery/script/folder/battery.json</span></pre><p id="577e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">与大多数脚本相反，我们没有把脚本解释器#！/bin/bash ( <em class="lp"> #！/data/data/com . Termux/files/usr/bin/sh</em>in Termux)因为我们将把解释器放入命令中。</p><p id="3c4c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要创建一个后台运行脚本的守护进程。为此，首先使脚本可执行:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="581c" class="lj lk iq lf b gy ll lm l ln lo">chmod +x ~/path/to/battery/script.sh</span></pre><p id="60a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后运行以下命令:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="fe06" class="lj lk iq lf b gy ll lm l ln lo">daemonize -p $PREFIX/var/run/script.pid $PREFIX/bin/bash ~/path/to/battery/script.sh</span></pre><p id="d4d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您可以在每次使用相同的<em class="lp">登录Termux时运行一个命令。bash_profile </em>文件:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="813f" class="lj lk iq lf b gy ll lm l ln lo">nano ~/.bash_profile</span></pre><p id="54e5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并补充:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="2242" class="lj lk iq lf b gy ll lm l ln lo">#!/data/data/com.termux/files/usr/bin/bash</span><span id="9b43" class="lj lk iq lf b gy lq lm l ln lo">if [ ! -e “$TMPDIR/termux-started” ]<br/>then<br/> sshd<br/> daemonize -p $PREFIX/var/run/get-battery.pid $PREFIX/bin/bash ~/storage/external-1/development/get-battery.sh<br/> touch “$TMPDIR/termux-started”<br/>fi</span></pre><p id="2b2f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们得到远程机器的IP地址:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="8b97" class="lj lk iq lf b gy ll lm l ln lo">IP=`ifconfig en0 2&gt;/dev/null|awk ‘/inet / {print $2}’`</span></pre><p id="fe23" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，声明一个变量来记录IP字符串的最后一个字符:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d357" class="lj lk iq lf b gy ll lm l ln lo">LAST_IP=”${IP: -1}”</span></pre><p id="d537" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并执行一个循环，每次删除字符串的最后一个字符，在第一个“.”处停止这样我们就有了我们所在网络的IP配置。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="8961" class="lj lk iq lf b gy ll lm l ln lo">while [ “${LAST_IP}” != “.” ]<br/>do<br/> IP=${IP%?} # Here we remove the last character of the IP string<br/> LAST_IP=”${IP: -1}”<br/>done</span></pre><p id="b5c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">之后，我们通过ping扫描映射网络上的所有IP地址:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ef58" class="lj lk iq lf b gy ll lm l ln lo">echo $(nmap -sP “${IP}”0/24 &gt;/dev/null)</span></pre><p id="b88c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，我们得到与我们的Android设备的mac地址相匹配的IP地址:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="6f7e" class="lj lk iq lf b gy ll lm l ln lo">IP_ADDRESS=`arp -an | grep mac:address:android:device | awk ‘{print $2}’ | sed ‘s/[()]//g’`</span></pre><p id="5e5f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的远程机器将使用<em class="lp"> scp </em>通过ssh将电池文件复制到当前文件夹:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="adb5" class="lj lk iq lf b gy ll lm l ln lo">scp -P 8022 192.168.xx.xx:~/storage/external-1/path/to/battery/script/folder/battery.json /path/to/remote/machine/folder/</span></pre><p id="4cd2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们从<em class="lp"> battery.json </em>文件中获取电池状态:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="620a" class="lj lk iq lf b gy ll lm l ln lo">PLUGGED=`cat battery.json | jq -r ‘.plugged’`<br/>PERCENTAGE=`cat battery.json | jq -r ‘.percentage’`</span></pre><p id="18e9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">检查设备是否接通电源，或者百分比是否足够高(这里我们将其设置为20%电量):</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3a36" class="lj lk iq lf b gy ll lm l ln lo">OPERATIONAL=”false”<br/>if [[ “$PLUGGED” | jq -r ‘.plugged’ == *”PLUGGED_AC”* ]]<br/>then<br/> OPERATIONAL=”true”<br/>elif [[ “$PERCENTAGE” -ge “20” ]]<br/>then<br/> OPERATIONAL=”true”<br/>fi</span></pre><p id="3567" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果其中一个条件为真，我们使用rsync开始同步:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="b72b" class="lj lk iq lf b gy ll lm l ln lo">if [ “${OPERATIONAL}” == “true” ]<br/>then<br/> rsync -avr -e ‘ssh -p 8022’ — exclude-from=’/path/to/rsync-exclude.txt’ $IP_ADDRESS:~/storage/external-1 /path/to/remote/machine/folder<br/> fi</span></pre><p id="69e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将文件从Android手机同步到远程机器。我们使用选项<em class="lp"> — exclude-from= </em>来使用一个文件，在该文件中我们声明我们不想同步哪些文件和文件夹。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ddd8" class="lj lk iq lf b gy ll lm l ln lo">#!/bin/bash</span><span id="f0f0" class="lj lk iq lf b gy lq lm l ln lo">while true<br/>do<br/>    IP=`ifconfig en0 2&gt;/dev/null|awk ‘/inet / {print $2}’`<br/>    LAST_IP=”${IP: -1}”<br/>    while [ “${LAST_IP}” != “.” ]<br/>    do<br/>        IP=${IP%?}<br/>        LAST_IP=”${IP: -1}”<br/>    done<br/>    echo $(nmap -sP “${IP}”0/24 &gt;/dev/null)<br/>    IP_ADDRESS=`arp -an | grep mac:address:android:device | awk ‘{print $2}’ | sed ‘s/[()]//g’`</span><span id="7b0b" class="lj lk iq lf b gy lq lm l ln lo">scp -P 8022 “${IP_ADDRESS}”:~/storage/external-1/development/battery.json .<br/>    PLUGGED=`cat battery.json | jq -r '.plugged'`<br/>    echo "${PLUGGED}"<br/>    PERCENTAGE=`cat battery.json | jq -r '.percentage'`<br/>    echo "${PERCENTAGE}"<br/>    OPERATIONAL=”false”<br/>    if [[ $PLUGGED == *”PLUGGED_AC”* ]]<br/>    then<br/>        OPERATIONAL=”true”<br/>    elif [[ “$percentage” -ge “20” ]]<br/>    then<br/>        OPERATIONAL=”true”<br/>    fi</span><span id="132c" class="lj lk iq lf b gy lq lm l ln lo">    if [ “${OPERATIONAL}” == “true” ]<br/>    then<br/>        rsync -avr -e ‘ssh -p 8022’ — exclude-from=’/path/to/rsync-exclude.txt’ $IP_ADDRESS:~/storage/external-1/ /path/to/remote/machine/folder<br/>    fi<br/>    echo “sleep”<br/>    sleep 60s<br/>done</span></pre><p id="8fe2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们想从MacOS同步到Android时，我们使用类似的方法，除了我们首先检查文件和文件夹是否在我们同步的目录中被修改或添加。<br/>首先，我们用<em class="lp"> touch </em>命令创建一个日志文件来记录rsync的结果，这样我们可以很容易地看到过去的同步是否成功。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7470" class="lj lk iq lf b gy ll lm l ln lo">LOGFILE=/path/to/remote/machine/folder/rsync_logs.txt<br/>if [ ! -f “$LOGFILE” ]<br/>then<br/> touch “$LOGFILE”<br/>fi</span></pre><p id="fe43" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们创建另一个文件来记录rsync成功运行的日期和时间；因为该脚本是第一次运行，所以我们创建了一个last_sync.txt文件来写入上次同步的日期和时间。我们创建变量<em class="lp"> FILES </em>，它将在运行rsync之前用于修改文件的条件检查。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="78af" class="lj lk iq lf b gy ll lm l ln lo">LASTSYNC=/path/to/remote/machine/folder/last_sync.txt<br/>if [ ! -f "$LASTSYNC" ]<br/>then<br/>    touch "$LASTSYNC"<br/>    FILES="first time"<br/>else<br/>    LASTDATE=`cat "${LASTSYNC}"`<br/>    echo "${LASTDATE}"<br/>    LASTDATE=`date -r "$LASTDATE" +"%s"`<br/>    echo "${LASTDATE}"<br/>    now=`date +%s`<br/>    echo ${NOW}<br/>    PERIOD=$(( ($NOW - $LASTDATE) / 60 ))<br/>    echo ${PERIOD}<br/>    FILES=`find /path/to/remote/machine/folder -mmin -"${PERIOD}" | sort -n -r`<br/>fi</span></pre><p id="8f44" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果文件已经存在，我们使用“cat”从文件中获取最后的日期和时间，然后将日期解析为unix纪元时间。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ec4d" class="lj lk iq lf b gy ll lm l ln lo">LASTDATE=`cat “${FILE}”`<br/>LASTDATE=`date -r “$LASTDATE” +”%s”`</span></pre><p id="ab20" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们用最近的日期和时间减去当前的unix纪元时间，得到分钟数:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="36a3" class="lj lk iq lf b gy ll lm l ln lo">PERIOD=$(( ($now — $last_date) / 60 ))</span></pre><p id="694f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们使用“查找”命令来检查同步文件夹中的更改。下面的命令将返回一个列表，列出文件夹中所有的修改，以及同步文件夹中所有按大小排序的文件。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="f04e" class="lj lk iq lf b gy ll lm l ln lo">FILES=`find ~/remote_machine_sync_folder -type f -mmin -”${period}”`<br/></span></pre><p id="8e73" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果files变量不为null，我们运行rsync，然后检查命令是否成功(当我们写入日期和时间时),并将结果记录到rsync_logs.txt文件中:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="f32a" class="lj lk iq lf b gy ll lm l ln lo">if [[ $SYNCING -eq 0 ]]<br/>then<br/>    echo “${SYNCING}” &gt; “${LOGFILE}”<br/>    echo `date +%s &gt; “${LASTSYNC}”`<br/>    echo “success and sleep”<br/>    sleep 10s<br/>else<br/>    echo “${SYNCING}” &gt; “${LOGFILE}”<br/>    echo “fail and sleep”<br/>    sleep 10s<br/>fi</span></pre><p id="9527" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们将日期和时间写入last_sync.txt文件。</p><p id="283c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将文件从MacOS同步到Android</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="acb5" class="lj lk iq lf b gy ll lm l ln lo">#!/bin/bash</span><span id="5fdb" class="lj lk iq lf b gy lq lm l ln lo">while true<br/>do<br/>    LOGFILE=/path/to/remote/machine/folder/rsync_logs.txt<br/>    if [ ! -f “$LOGFILE” ]<br/>    then<br/>          touch “$LOGFILE”<br/>    fi<br/>    LASTSYNC=/path/to/remote/machine/folder/last_sync.txt<br/>    if [ ! -f “$LASTSYNC” ]<br/>    then<br/>        touch “$LASTSYNC”<br/>        FILES=”first time”<br/>    else<br/>        LASTDATE=`cat “${LASTSYNC}”`<br/>        echo “${LASTDATE}”<br/>        LASTDATE=`date -r “$last_date” +”%s”`<br/>        echo “${LASTDATE}”<br/>        NOW=`date +%s`<br/>        echo ${NOW}<br/>        period=$(( ($NOW — $LASTDATE) / 60 ))<br/>        echo ${period}<br/>        FILES=`find /path/to/remote/machine/folder -mmin -”${period}” | sort -n -r`<br/>    fi<br/>    if [ “${FILES}” ]<br/>    then<br/>        IP=`ifconfig en0 2&gt;/dev/null|awk ‘/inet / {print $2}’`<br/>        LAST_IP=”${IP: -1}”<br/>        while [ “${LAST_IP}” != “.” ]<br/>        do<br/>            IP=${IP%?}<br/>            LAST_IP=”${IP: -1}”<br/>        done<br/>        echo $(nmap -sP “${IP}”0/24 &gt;/dev/null)<br/>        IP_ADDRESS=`arp -an | grep mac:address:android:device | awk ‘{print $2}’ | sed ‘s/[()]//g’`</span><span id="0633" class="lj lk iq lf b gy lq lm l ln lo">scp -P 8022 “${IP_ADDRESS}”:~/storage/external-1/development/battery.json /path/to/remote/machine/folder/<br/>        PLUGGED=`cat battery.json | jq -r '.plugged'`<br/>        echo "${PLUGGED}"<br/>        PERCENTAGE=`cat battery.json | jq -r '.percentage'`<br/>        echo "${PERCENTAGE}"<br/>        OPERATIONAL=”false”<br/>        if [[ $PLUGGED == *”PLUGGED_AC”* ]]<br/>        then<br/>            OPERATIONAL=”true”<br/>        elif [[ “$percentage” -ge “20” ]]<br/>        then<br/>            OPERATIONAL=”true”<br/>        fi</span><span id="468c" class="lj lk iq lf b gy lq lm l ln lo">        if [ “${OPERATIONAL}” == “true” ]<br/>        then<br/>            rsync -avr -e ‘ssh -p 8022’ — exclude-from=’/path/to/rsync-exclude.json’ /path/to/remote/machine/sync/folder $IP_ADDDRESS:~/storage/external-1<br/>            SYNCING=$?<br/>            if [[ $SYNCING -eq 0 ]]<br/>            then<br/>                echo “${SYNCING}” &gt; “${LOGFILE}”<br/>                echo `date +%s &gt; “${LASTSYNC}”`<br/>                echo “success and sleep”<br/>                sleep 10s<br/>            else<br/>                echo “${SYNCING}” &gt; “${LOGFILE}”<br/>                echo “fail and sleep”<br/>                sleep 10s<br/>            fi<br/>        fi<br/>    fi<br/>done</span></pre><p id="dbf0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了在远程机器上运行这些脚本，我们也可以使用<em class="lp"> daemonize </em>，或者我们可以使用crontab，它将在给定的时间或时间段为我们执行脚本。</p><p id="2db4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先删除脚本中的while循环集。在Linux和macOS中，授予脚本权限:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="fc91" class="lj lk iq lf b gy ll lm l ln lo">chmod u+x /path/to/remote_to_android.sh</span></pre><p id="f012" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<em class="lp"> cron </em>调度脚本，在终端中键入:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="b20c" class="lj lk iq lf b gy ll lm l ln lo">crontab -e</span></pre><p id="19f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后键入<em class="lp"> i </em>来编辑文件:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="28a3" class="lj lk iq lf b gy ll lm l ln lo">10 * * * * /path/to/remote_to_android.sh</span></pre><p id="93e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每个<em class="lp"> * </em>对应于:<br/> <strong class="ke ir">分钟小时天月工作日<br/> </strong>通过编写<em class="lp"> 10 * * * * </em>脚本将在每小时的第十分钟运行。<br/>通过编写<em class="lp"> */10 * * * * </em>脚本将每隔十分钟运行一次。</p><p id="90f7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您想从我们在脚本中创建的回显中获取日志。日志将在<em class="lp"> /tmp/ </em>、<em class="lp"> stdout.log </em>中找到，以获取回显命令，并在<em class="lp"> stderr.log </em>中找到错误:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="0d69" class="lj lk iq lf b gy ll lm l ln lo">10 * * * * /path/to/remote_to_android.sh &gt;/tmp/stdout.log 2&gt;/tmp/stderr.log</span></pre></div></div>    
</body>
</html>