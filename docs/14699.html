<html>
<head>
<title>Maximize Code Security in Your NestJS Applications (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最大化NestJS应用程序中的代码安全性(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/maximize-code-security-in-your-nestjs-applications-part-1-b7abb99fa048?source=collection_archive---------3-----------------------#2022-12-19">https://levelup.gitconnected.com/maximize-code-security-in-your-nestjs-applications-part-1-b7abb99fa048?source=collection_archive---------3-----------------------#2022-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3367" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">NestJS开发人员的顶级安全代码最佳实践</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a491e333586fb1abd246f8dda84b0552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aN4-CbCjgxdmgjs_U6UqEw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由DALL-E生成</figcaption></figure><p id="1366" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为开发人员，我们都知道代码安全性有多重要。最近发生在Optus和T2的数据泄露事件再次凸显了代码安全的重要性。因此，问题是:我们如何编写安全的代码来防止web应用程序中的各种类型的攻击？遵循最佳实践来编写安全代码至关重要，这样我们的应用程序才能免受漏洞和威胁的侵害。</p><p id="2e92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们深入探讨如何防范安全风险之前？让我们首先来看看最常见的安全风险类型。这将让我们更好地理解保持应用安全所面临的挑战。</p><p id="f42e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">OWASP Top 10是一个被广泛接受的web应用程序最关键的安全风险列表，由行业专家共同决定。以下是2017年和2021年十大风险列表。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lf"><img src="../Images/5c6a7aef0ad6a6c8920c875e36946bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ObUHh3Z9GbA8jFlBoTHaXg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来源:https://owasp.org/www-project-top-ten/<a class="ae le" href="https://owasp.org/www-project-top-ten/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="68c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前10名中有许多对web应用的安全性至关重要。</p><p id="2b5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为本文的第1部分，我将介绍一些风险和防止风险的最佳实践。</p><p id="2e16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们包括:</p><ul class=""><li id="f783" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated"><a class="ae le" href="#4d65" rel="noopener ugc nofollow">破坏访问控制</a></li><li id="04a1" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><a class="ae le" href="#3fb4" rel="noopener ugc nofollow">服务器端请求伪造(SSRF) </a></li><li id="e572" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><a class="ae le" href="#2dac" rel="noopener ugc nofollow">批量分配</a></li><li id="4061" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><a class="ae le" href="#ffd8" rel="noopener ugc nofollow">敏感信息曝光</a></li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="4d65" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">中断的访问控制</h2><p id="1129" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">函数访问中断是最常见的风险之一。当攻击者能够访问未经授权的功能或资源时，就会发生这种情况。一个真实的例子是2014年1月发生的Snapchat事件。</p><p id="777e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了防止这种风险，遵循<strong class="js iu">最小特权</strong>的原则非常重要。这意味着默认情况下应该总是拒绝访问，并且应该只在需要的基础上授予特权。</p><p id="19ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用基于角色的访问控制(RBAC)或访问控制列表(ACL)等访问控制机制，根据用户的角色或权限来限制对功能或资源的访问。</p><p id="ea0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个RBAC在NestJS应用程序中使用<a class="ae le" href="https://docs.nestjs.com/guards" rel="noopener ugc nofollow" target="_blank">保护</a>的例子:</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="c74c" class="ne mc it na b be nf ng l nh ni">import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';<br/><br/>@Injectable()<br/>export class AdminRoleGuard implements CanActivate {<br/>  canActivate(context: ExecutionContext): boolean {<br/>    const request = context.switchToHttp().getRequest();<br/>    const user = request.user;<br/>    return user.role === 'admin';<br/>  }<br/>}<br/><br/>@Controller('cats')<br/>export class CatsController {<br/>  @UseGuards(AdminRoleGuard)<br/>  @Get()<br/>  async findAll(): Promise&lt;Cat[]&gt; {<br/>    return this.catsService.findAll();<br/>  }<br/>}</span></pre><p id="5d2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码片段中，我们创建了一个<code class="fe nj nk nl na b">AdminRoleGuard</code>，它实现了由NestJS提供的<code class="fe nj nk nl na b">CanActivate</code>接口。它检查当前用户的角色，当用户是管理员时返回<code class="fe nj nk nl na b">true</code>。然后，我们使用<code class="fe nj nk nl na b">@UseGuards</code>装饰器将<code class="fe nj nk nl na b">AdminRoleGuard</code>应用于<code class="fe nj nk nl na b">findAll</code>方法，这将限制仅具有<code class="fe nj nk nl na b">admin</code>角色的用户对端点的访问。</p><p id="784d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应使用成熟框架中的集中功能来应用访问控制机制，以确保其安全且易于维护。</p><p id="7900" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还建议进行单元测试，测试控制器上应用的必要保护。因此，如果防护被意外移除，单元测试将捕获它。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="3fb4" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">服务器端请求伪造(SSRF)</h2><p id="346b" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">SSRF是一种网络攻击，攻击者诱使服务器代表他们发出非故意的请求。这些请求可用于从内部网络访问受限资源。</p><p id="e9c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了防止SSRF，正确验证用户输入是至关重要的。以下是易受SSRF风险攻击的终端示例。</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="5670" class="ne mc it na b be nf ng l nh ni">import { Controller, Get, Res, HttpStatus, Query } from '@nestjs/common';<br/><br/>@Controller()<br/>export class CatsController {<br/>  @Get()<br/>  async getData(@Query('url') url: string, @Res() res) {<br/>    const response = await fetch(url);<br/>    return await response.json();<br/>  }<br/>}</span></pre><p id="03c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，应用程序向来源于<code class="fe nj nk nl na b">url</code>查询参数的URL发出请求，并将响应数据返回给客户端。显然，它很容易受到SSRF攻击，因为攻击者可以通过恶意URL向服务器发送请求，从内部网络访问受限资源。</p><p id="87f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们应该验证URL参数以防止如下风险。</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="0ffb" class="ne mc it na b be nf ng l nh ni">import { Controller, Get, Res, HttpStatus, Query } from '@nestjs/common';<br/>import { isURL } from 'validator';<br/><br/>@Controller()<br/>export class CatsController {<br/>  @Get()<br/>  async getData(@Query('url') url: string, @Res() res) {<br/>    if (!isURL(url)) {<br/>      return res.status(HttpStatus.BAD_REQUEST).send('Invalid URL');<br/>    }<br/><br/>    const response = await fetch(url);<br/>    return await response.json();<br/>  }<br/>}</span></pre><p id="57fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了进一步提高安全性，我们不应该允许用户直接在查询参数中传递URL。相反，我们应该使用现有的服务从可信的API中检索数据。</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="1311" class="ne mc it na b be nf ng l nh ni">@Controller()<br/>export class CatsController {<br/>  @Get()<br/>  async getData(@Query('name') dataName: string, @Res() res) {<br/>    const response = await dataService.GetDataByName(dataName);<br/>    return await response.json();<br/>  }<br/>}</span></pre><p id="ebab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有其他方法可以防止SSRF袭击:</p><ul class=""><li id="64f0" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">仅向可信来源(即已知的API或服务)发出请求</li><li id="8eb2" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">实施安全标头(如“<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" rel="noopener ugc nofollow" target="_blank"> X-Frame-Options </a>”)以防止点击劫持攻击和其他类型的恶意请求。</li><li id="b2c4" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">使用内容安全策略(CSP)来指定允许哪些源代表您的应用程序发出请求。</li></ul><p id="6e2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在NestJS中，您可以使用<a class="ae le" href="https://docs.nestjs.com/security/helmet" rel="noopener ugc nofollow" target="_blank">头盔</a>轻松设置安全头和内容安全策略。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="2dac" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">批量分配</h2><p id="4a6d" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">批量分配是一个漏洞，攻击者能够通过向您的应用程序发送恶意请求来修改多个对象属性。</p><p id="42f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的示例中，基于来自请求主体的数据创建了一个新用户。它容易受到批量分配攻击，因为攻击者可以发送一个带有恶意数据的请求，覆盖<code class="fe nj nk nl na b">Client </code>对象中的敏感字段(即角色或密码)。</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="d46c" class="ne mc it na b be nf ng l nh ni">import { Controller, Post, Body } from '@nestjs/common';<br/><br/>@Controller("client")<br/>export class ClientController {<br/>  @Post()<br/>  create(@Body() body) {<br/>    const client = new Client(body);<br/>    return await client.save();<br/>  }<br/>}</span></pre><p id="c81d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了防止大量分配，我们可以为每个对象定义一个允许属性的白名单。在下面的例子中，我们实现了一个属性白名单来防止敏感字段被覆盖。</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="f27d" class="ne mc it na b be nf ng l nh ni">import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';<br/><br/>@Entity()<br/>export class Client{<br/>  @PrimaryGeneratedColumn()<br/>  id: number;<br/><br/>  @Column()<br/>  name: string;<br/><br/>  @Column()<br/>  role: string;<br/><br/>  @Column()<br/>  password: string;<br/><br/>  @Column(})<br/>  email: string;<br/>}<br/><br/>@Controller('client')<br/>export class ClientController {<br/>  constructor(private clientService: ClientService) {}<br/><br/>  @Post()<br/>  async create(@Body() client: Pick&lt;User, 'name' | 'email'&gt;) {<br/>    return await this.clientService.create(client);<br/>  }<br/>}</span></pre><p id="a959" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们使用TypeScript <code class="fe nj nk nl na b">Pick</code>类型为<code class="fe nj nk nl na b">User</code>实体定义一个属性白名单。然后使用<code class="fe nj nk nl na b">@Body</code>装饰器将请求体绑定到<code class="fe nj nk nl na b">user</code>参数，该参数将只包含允许的属性。这可以防止攻击者通过批量赋值来修改<code class="fe nj nk nl na b">User</code>实体的其他属性。</p><p id="67a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">防止批量分配的其他方法包括:</p><ul class=""><li id="184b" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">使用简化的DTO，而不是一般的DTO。例如，创建一个<code class="fe nj nk nl na b">InsertClientEntity </code>和<code class="fe nj nk nl na b">UpdateClientEntity.</code>这些dto只包含插入和更新操作中允许的属性。</li><li id="9fc6" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">避免直接绑定到来自客户端的对象。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="d225" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">敏感信息暴露</h2><p id="e3a1" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">敏感信息包括密码、API密钥和其他机密数据。任何包含个人信息或支付相关信息的数据都是敏感的。</p><p id="0874" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，在设计web API时，会向客户端返回过多的数据。</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="af88" class="ne mc it na b be nf ng l nh ni">import { Controller, Get, Param } from '@nestjs/common';<br/>import { Client} from './client/client.entity';<br/><br/>@Controller()<br/>export class ClientController {<br/>  @Get('clients/:id')<br/>  async getClient(@Param('id') id: string): Promise&lt;Client&gt; {<br/>    // Return all fields for the client<br/>    return await Client.findById(id);<br/>  }<br/>}</span></pre><p id="0494" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，<code class="fe nj nk nl na b">getClient</code>方法返回客户端的所有字段，包括敏感数据，如<code class="fe nj nk nl na b">role </code>或<code class="fe nj nk nl na b">password</code>。尽管这些数据不会被客户端使用或显示，但它们仍然可能被攻击者截获和暴露。</p><p id="6bac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了防止敏感的个人数据暴露，我们应该只返回客户端的必要数据，在本例中是<code class="fe nj nk nl na b">name</code>和<code class="fe nj nk nl na b">email</code>字段。简而言之，我们应该只公开最少量的数据。</p><pre class="kp kq kr ks gt mz na nb bn nc nd bi"><span id="258a" class="ne mc it na b be nf ng l nh ni">import { Controller, Get, Param, UseGuards } from '@nestjs/common';<br/>import { Client} from './client/client.entity';<br/><br/>@Controller()<br/>export class ClientController {<br/>  @Get('clients/:id')<br/>  async getClient(@Param('id') id: string): Promise&lt;Client&gt; {<br/>    // Only return the name and email<br/>    return await Client.findById(id).map(c =&gt; {c.name, c.email});<br/>  }<br/>}</span></pre><p id="82cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为防止敏感数据泄露，以下是其他应遵循的准则:</p><ul class=""><li id="9d53" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">不要将敏感信息存储到版本控制中。这些信息包括环境变量或配置文件</li><li id="a996" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">识别您系统中的敏感信息(<a class="ae le" href="https://gdpr-info.eu/" rel="noopener ugc nofollow" target="_blank"> GDPR </a>、<a class="ae le" href="https://www.pcisecuritystandards.org/" rel="noopener ugc nofollow" target="_blank"> PCI、</a>和<a class="ae le" href="https://www.cyber.gov.au/acsc/view-all-content/glossary/personally-identifiable-information-pii" rel="noopener ugc nofollow" target="_blank"> PII数据</a>)，并通过加密保护。</li><li id="a2c2" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">确保您的应用程序在客户端和服务器之间使用HTTPS。这将防止敏感数据在传输过程中被截获。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="36f2" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">摘要</h2><p id="4b36" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">在本文中，我们将介绍4种常见风险以及在NestJS环境中防范这些风险的最佳实践。</p><p id="44bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过遵循这些最佳实践，您可以编写安全的代码来确保您的NestJS应用程序尽可能地安全。</p><p id="7cc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文的第2部分中，我们继续讨论其他主要的OWASP风险。</p><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/maximize-code-security-in-your-nestjs-applications-part-2-be707466b7ea"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">最大化NestJS应用程序中的代码安全性(第2部分)</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">通过真实世界的例子来保护代码的最佳实践</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ky np"/></div></div></a></div></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="de85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您还不是Medium，<a class="ae le" href="https://sunnysun-5694.medium.com/membership" rel="noopener"> <strong class="js iu">的付费会员，您可以通过访问此链接</strong> </a>进行注册。你可以无限制地阅读媒体上的所有报道。我会收你一部分会员费作为介绍费。</p><p id="d2c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编程快乐！</p></div></div>    
</body>
</html>