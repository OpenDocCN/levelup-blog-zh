<html>
<head>
<title>This Trick Changed the Way I Access Nested Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这个技巧改变了我在JavaScript中访问嵌套对象的方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/this-trick-changed-the-way-i-access-nested-objects-in-javascript-bc8ead3a7015?source=collection_archive---------1-----------------------#2020-08-24">https://levelup.gitconnected.com/this-trick-changed-the-way-i-access-nested-objects-in-javascript-bc8ead3a7015?source=collection_archive---------1-----------------------#2020-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/653840173d7bdd4fefe8af19db3efb04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D8tUoIOcvsc5yR9p"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@_miltiadis_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米尔蒂亚迪斯·弗拉基迪斯</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="d9d8" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">一个简单却超级有用的技巧</h2></div><p id="9a8b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">了解JavaScript书中的所有技巧几乎是不可能的。我就是活生生的例子。当我最近翻阅一些JavaScript文档来阅读某个主题时，我偶然发现了JavaScript中一个我以前从未见过的非常有趣的特性。</p><p id="5598" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然我知道JavaScript因其许多技巧而闻名——其中一些技巧比另一些更为人所知。我可能不是唯一一个不知道这个技巧的人，所以我想和你分享一下。它完全改变了我访问嵌套对象的方式。</p><p id="af74" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望这个技巧对你和对我一样有帮助。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8452" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">诀窍是</h1><p id="f29e" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这一招叫做<em class="my">可选链接</em>。其实是一个运营商。可选的链接操作符的写法类似于<code class="fe mz na nb nc b">?.</code>。</p><p id="9fd6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我听到你在想:<em class="my">“好的，太好了。是什么，我为什么要用这个？”</em></p><p id="9505" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据Mozilla web文档，这就是可选链接操作符的作用:</p><blockquote class="nd ne nf"><p id="de15" class="ky kz my la b lb lc kk ld le lf kn lg ng li lj lk nh lm ln lo ni lq lr ls lt im bi translated">可选的链接操作符允许读取位于连接对象链深处的属性值，而不必明确验证链中的每个引用是否有效。</p></blockquote><p id="8dd9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，可选的链接操作符极大地简化了访问嵌套值的方式。</p><p id="d921" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们直接进入一个例子，帮助您更好地理解可选链接操作符的作用。</p><p id="2d95" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个名为<em class="my"> house </em>的对象，看起来像这样:</p><pre class="nj nk nl nm gt nn nc no np aw nq bi"><span id="d630" class="nr mc jj nc b gy ns nt l nu nv">const house = {<br/>  price: 1000000,<br/>  currency: 'USD',<br/>  address: {<br/>    city: 'New York',<br/>    street: 'Main street',<br/>    postal_code: '1234 AB',<br/>    state: {<br/>      name: 'New York',<br/>      abbreviation: 'N.Y.'<br/>    }<br/>  },<br/>  owner: {<br/>    name: "John Doe"<br/>  }<br/>}</span></pre><p id="bf9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，我们会通过以下方式访问该对象的属性:</p><pre class="nj nk nl nm gt nn nc no np aw nq bi"><span id="1ad9" class="nr mc jj nc b gy ns nt l nu nv">const currency = house.currency<br/>const price = house.price<br/>const owner = house.owner.name</span></pre><p id="e91e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是从对象中读取值的基础。但是房子没有主人会怎么样呢？最后一行代码会触发一个错误，因为我们无法读取undefined的属性名称。</p><p id="4f9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，您应该这样做:</p><pre class="nj nk nl nm gt nn nc no np aw nq bi"><span id="85d0" class="nr mc jj nc b gy ns nt l nu nv">const owner = house.owner ? house.owner.name : null</span></pre><p id="d212" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者，如果您真的很喜欢，您可以使用无效合并运算符:</p><pre class="nj nk nl nm gt nn nc no np aw nq bi"><span id="5ccc" class="nr mc jj nc b gy ns nt l nu nv">const owner = house.owner.name ?? null</span></pre><p id="ff0a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码的问题是，一旦房子对象没有所有者，它就不起作用。看看下面的例子。</p><pre class="nj nk nl nm gt nn nc no np aw nq bi"><span id="5f58" class="nr mc jj nc b gy ns nt l nu nv">const house = {<br/>  price: 1000000,<br/>  currency: 'USD',<br/>  address: {<br/>    city: 'New York',<br/>    street: 'Main street',<br/>    postal_code: '1234 AB',<br/>    state: {<br/>      name: 'New York',<br/>      abbreviation: 'N.Y.'<br/>    }<br/>  },<br/>  owner: null<br/>}</span></pre><p id="f87d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用nullish合并运算符将导致错误，因为它无法读取属性<em class="my">名称</em>的<em class="my"> null </em>。</p><p id="64b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用三元运算符的第一个示例仍然有效。虽然它非常冗长，如果您必须检查一个或两个更深层次的属性，代码会变得非常不可读——因为您必须检查每个属性是否存在。</p><p id="b995" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，检查州名如下:</p><pre class="nj nk nl nm gt nn nc no np aw nq bi"><span id="45dd" class="nr mc jj nc b gy ns nt l nu nv">const state = house.address &amp;&amp; house.address.state ? house.address.state.name : null</span></pre><p id="d328" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，这段代码太长了，很快就变得不可读了。</p><p id="2bc2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是可选的链接操作符发挥作用的地方。有了这个操作符，就不需要检查某些属性是否存在，这将保持代码的整洁和易于理解。如果一个属性不存在，<em class="my">未定义的</em>将被返回。这是操作者在运行时的样子。</p><pre class="nj nk nl nm gt nn nc no np aw nq bi"><span id="c461" class="nr mc jj nc b gy ns nt l nu nv">const city = house?.address?.city // "New York"<br/>const nonExisting = house?.roof?.material // Undefined<br/>const houseNumber = house?.address?.number // Undefined<br/>const state = house?.address?.state?.abbreviation // "N.Y."</span></pre><p id="aaf5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看到这段代码有多干净了吗？！</p><p id="b240" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第一个例子中，我们试图从存储在<em class="my">地址</em>属性中的<em class="my">城市</em>属性中获取值。因为这个属性存在，所以返回城市属性的值。就像使用<code class="fe mz na nb nc b">house.address.city</code>来获取值一样。</p><p id="4918" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第二个例子中，我们试图得到屋顶的材质。但是，<em class="my">房屋</em>对象上没有<em class="my">屋顶</em>属性，导致<em class="my">未定义</em>被返回。对于<em class="my">门牌号</em>房产也是如此。虽然<em class="my">房子</em>对象有一个<em class="my">地址</em>属性，但是这个属性不包含一个<em class="my">号码</em>属性——这就是为什么<em class="my">未定义</em>也会在这里返回。</p><p id="be8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以使用可选的chaining运算符以动态方式检查属性。为了做到这一点，你必须使用括号符号:</p><pre class="nj nk nl nm gt nn nc no np aw nq bi"><span id="faec" class="nr mc jj nc b gy ns nt l nu nv">const someProperty = obj?.['property-' + propertyName]</span></pre><p id="7b08" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用可选链接操作符的最后一种方法是与nullish合并操作符结合使用。例如，当必须为变量设置默认值时。</p><pre class="nj nk nl nm gt nn nc no np aw nq bi"><span id="ef32" class="nr mc jj nc b gy ns nt l nu nv">const ownerName = house?.owner?.name ?? "Unknown owner"</span></pre><h1 id="66c3" class="mb mc jj bd md me nw mg mh mi nx mk ml kp ny kq mn ks nz kt mp kv oa kw mr ms bi translated">功能</h1><p id="e345" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">到目前为止，我们只在对象中使用了可选的链接操作符。但是也可以将这个操作符与函数结合使用。</p><p id="356d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当试图调用可能不存在的方法时，可以使用chaining运算符。看起来是这样的:</p><pre class="nj nk nl nm gt nn nc no np aw nq bi"><span id="95ad" class="nr mc jj nc b gy ns nt l nu nv">const result = someObject.customMethod?.();</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="171b" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">和睦相处</h1><p id="8aac" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">与任何现代JavaScript特性一样，一些旧浏览器(比如Internet Explorer)不支持可选的链接特性。现代浏览器如Chrome、Firefox、Opera和Safari都支持可选链接。</p><p id="980d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不应该阻止你使用可选的链接。在旧浏览器中使用可选链接时，您可以添加聚合填充。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/06d74edc2abedc4ffb61422668c6da05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZdBKSxurQmA9eD4BjPzKmw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="00da" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">包装它</h1><p id="545a" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">可选的chaining操作符允许您访问深度嵌套的对象，而不必验证每个嵌套引用是否有效。可选的链接操作符最好的地方在于它以优雅的方式完成了这项工作。这不仅适用于对象。您还可以使用可选的链接操作符来尝试调用可能不存在的方法。</p><p id="a4c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，你应该记住，可选链接在Internet Explorer中并不是开箱即用的，就像许多其他现代JavaScript特性一样。这些旧的浏览器需要一个多填充来使可选的链接工作。</p><p id="9f33" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码快乐！</p></div></div>    
</body>
</html>