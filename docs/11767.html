<html>
<head>
<title>Data Scientist in Management Consulting: How to Solve the Technical Homework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理咨询中的数据科学家:如何解决技术作业</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/data-scientist-in-management-consulting-how-to-solve-the-technical-homework-3cc51115103?source=collection_archive---------11-----------------------#2022-04-14">https://levelup.gitconnected.com/data-scientist-in-management-consulting-how-to-solve-the-technical-homework-3cc51115103?source=collection_archive---------11-----------------------#2022-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6496" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">MBB典型的数据科学和咨询技术作业(麦肯锡、贝恩、BCG)是什么样子的？让我们开始着手解决问题吧。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/235689762e1e588f688455953485faed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWHGAlJJIxD_6doSnNNYGA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">波罗的海美景(作者拍摄)</figcaption></figure><p id="f7bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">麦肯锡、贝恩或波士顿咨询集团等公司是许多求职者的梦想。他们的招聘过程是出了名的艰难、漫长，而且成功率很低。在这篇文章中，我想分享(并解答)我从一位MBB那里得到的一份课后作业，它包含在三轮技术面试的第一步中。但事不宜迟，让我们开始吧！</p><p id="9349" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">小注意:第一步通过了本文中共享的解决方案</p><h1 id="a797" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">简介:</h1><p id="1b3b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">因为不可能分享最初的家庭作业，所以我准备了一份总结，并更改了一些变量。</p><p id="fd86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我是旨在提高ABC Telco ARPU的转型计划的一部分。分配给我的任务是通过高级分析提高ABC Telco营销活动的有效性，特别是，分配给我的最终目标是从营销活动中获得最大利润，利润定义为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/79dac5c702f359bb5a5a7546405f266e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4E4rz2t5RByqtux00eOKFg.png"/></div></div></figure><p id="537f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">pilot.csv</code>包含过去进行的一项研究的信息，每一行代表一位客户及其特征，以及购买/不购买该服务的最终决定。除此之外，还联系了A/B测试，可见于列<code class="fe ms mt mu mv b">treatment</code>。该文件可用作算法的训练集，该算法旨在预测在给定一组特征的情况下，哪些来自<code class="fe ms mt mu mv b">CustomerBase.csv</code>的客户可能会购买该服务。</p><h1 id="499f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">限制和细微差别:</h1><ul class=""><li id="f8e3" class="mw mx it la b lb mm le mn lh my ll mz lp na lt nb nc nd ne bi translated">联系一个用户的平均价格是5个单位</li><li id="fcd7" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">该算法的输出是提供二元决策</li><li id="01ff" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">购买该服务将产生100个单位的增量折扣客户终身价值</li><li id="343c" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">处理-&gt; 0代表对照组，1代表接触人群</li><li id="849c" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">通话次数被限制在整个客户群的1/4</li></ul><h1 id="d9f0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">任务:</h1><ul class=""><li id="b9fd" class="mw mx it la b lb mm le mn lh my ll mz lp na lt nb nc nd ne bi translated">从营销活动中获取最大利润</li><li id="e524" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">开发至少两个模型(其中一个是集合模型),并根据我选择的标准进行比较</li></ul><h1 id="7f8a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">攻击计划:</h1><p id="0605" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了执行这项任务，使用了典型的数据科学框架，整个分析包括以下步骤:</p><ul class=""><li id="7c1a" class="mw mx it la b lb lc le lf lh nk ll nl lp nm lt nb nc nd ne bi translated">1.0探索性数据分析(EDA)</li><li id="3f99" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">2.0数据准备</li><li id="db47" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">3.0建模和评估</li><li id="b5d0" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">4.0结论</li></ul><h1 id="9926" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1.0探索性数据分析(EDA)</h1><p id="d3fa" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">本节旨在理解<code class="fe ms mt mu mv b">pilot</code>数据集和<code class="fe ms mt mu mv b">CustomerBase</code>中包含的数据。它首先探索以前的数据集，进行不同的基本统计和分析，评估A/B测试的影响，并提供支持性的可视化。</p><p id="375f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，由于数据量允许，使用<code class="fe ms mt mu mv b">pandas_profiling</code>包生成了两份报告，这是一个非常有用的包，可以对pandas数据框架进行快速探索性数据分析。</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="8fa2" class="nr lv it mv b gy ns nt l nu nv">pilot = pd.read_csv(‘../data/pilot.csv’)<br/>customer_base = pd.read_csv(‘../data/CustomerBase.csv’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/33f8c613ea64482a3f9e675a1b0d25c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yn4u4Q3-S3wWOzTVIUhiRQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">飞行员数据集的视图</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/97c590370a191ed6f9d8466773b6faf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7YAix5Dg3-VJrmu1qqxYw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">customerBase数据集的视图</figcaption></figure><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="0669" class="nr lv it mv b gy ns nt l nu nv"># Check for differences in purchase between control and treatment<br/>control = pilot[pilot[‘treatment’] == 0]<br/>treatment = pilot[pilot[‘treatment’] == 1]</span><span id="fc7a" class="nr lv it mv b gy ny nt l nu nv"># Calculate total percentage (in relative terms) of customer who purchased for both groups<br/>control_pct = (len(control[control[‘purchase’] == 1]) / len(control) * 100)</span><span id="1fa2" class="nr lv it mv b gy ny nt l nu nv">treatment_pct = (<br/> len(treatment[treatment[‘purchase’] == 1]) / len(treatment) * 100)</span><span id="113a" class="nr lv it mv b gy ny nt l nu nv">print(f'The pilot consists of {len(pilot)} customers')<br/>print(<br/>    f'The total amount of customers contacted in treatment is {len(treatment)} customers')<br/>print(f'The total amount of customers in control is {len(control)} customers')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/5973601b162c2a6773c1a0ecec182439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmyIlXzL-zL6xMGzvUvu0A.png"/></div></div></figure><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="4c91" class="nr lv it mv b gy ns nt l nu nv">print(<br/> f’Absolute percentage of customer who purchased in pilot: {(len(pilot[pilot[“purchase”] == 1]) / len(pilot)) * 100}%’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/694c04a0a17f47eb5fa8f3fb8c738b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INeIVowlgOJXEnZwH9NytA.png"/></div></div></figure><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="6e5c" class="nr lv it mv b gy ns nt l nu nv">conversion_rates = pilot.groupby(‘treatment’)[‘purchase’]<br/># Std. deviation of the proportion<br/>def std_p(x): return np.std(x, ddof=0)</span><span id="1e9c" class="nr lv it mv b gy ny nt l nu nv"># Std. error of the proportion (std / sqrt(n))</span><span id="6f66" class="nr lv it mv b gy ny nt l nu nv">def se_p(x): return stats.sem(x, ddof=0)</span><span id="a822" class="nr lv it mv b gy ny nt l nu nv">conversion_rates = conversion_rates.agg([np.mean, std_p, se_p])<br/>conversion_rates.columns = [‘conversion_rate’, ‘std_deviation’, ‘std_error’]<br/>conversion_rates.style.format(‘{:.3f}’)</span><span id="40e6" class="nr lv it mv b gy ny nt l nu nv">print(conversion_rates)</span><span id="9226" class="nr lv it mv b gy ny nt l nu nv">plt.figure(figsize=(8, 6))<br/>sns.barplot(x=pilot[‘treatment’], y=pilot[‘purchase’], ci=False)<br/>plt.ylim(0, 0.17)<br/>plt.title(‘Conversion rate by group’)<br/>plt.xlabel(‘Group’)<br/>plt.ylabel(‘Converted (proportion)’)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/b32cf2c9fa639c62416fdf618fa4847e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZuYAoKl3bmaUBJ7MqmE4A.png"/></div></div></figure><p id="f265" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据一些基本统计数据，在治疗组购买的客户似乎略有增加，但是，为了证实这一点，应进行更合适的测试，如Z-test。</p><p id="304e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">试点项目的总成本、收入和利润:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="135b" class="nr lv it mv b gy ns nt l nu nv"># cost of contacting a customer:<br/>total_costs = len(treatment) * 5</span><span id="56f9" class="nr lv it mv b gy ny nt l nu nv"># discounted (future) revenues for all customer who purchased<br/>total_revenues = len(pilot[pilot[‘purchase’] == 1]) * 100</span><span id="916f" class="nr lv it mv b gy ny nt l nu nv">profit = total_revenues — total_costs</span><span id="2db8" class="nr lv it mv b gy ny nt l nu nv">print(f’Total cost of contacting customer is {total_costs} units’)<br/>print(<br/> f’Total revenues (incremental discounts) will be of {total_revenues} units’)<br/>print(<br/> f’Total profit for pilot is: {profit} units, based on {len(pilot)} customers of which {len(pilot[pilot[“purchase”] == 1])} purchased’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/7d2e03738cfe011efa3bcb97b5f5ac31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1c5MENPNh4OqXdUDiXGlUw.png"/></div></div></figure><p id="ce81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<code class="fe ms mt mu mv b">customerBase</code>，考虑到约束条件，最大可能总利润为:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="2183" class="nr lv it mv b gy ns nt l nu nv">max_amount_contactable_customers = (len(customer_base) * 0.25)<br/>cost_of_contact = 5<br/>profit = 100</span><span id="4f47" class="nr lv it mv b gy ny nt l nu nv">max_profit = max_amount_contactable_customers * \<br/> profit — (max_amount_contactable_customers * 5)<br/>print(<br/> f’Maximum possible profit (assuming 100% of contacted customers purchase): {max_profit} units’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/d984f7fbd6b791c66aea737aecfc3e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7_WGQJpcscNw5AOVaSOyw.png"/></div></div></figure><p id="0ff9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，使用<code class="fe ms mt mu mv b">pandas_profiling</code>创建一个报告，这有助于在数据中寻找有趣的模式。</p><p id="81f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从报告中可见的诊断结果来看，<code class="fe ms mt mu mv b">V19</code>列中的不同值存在差异:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="2e06" class="nr lv it mv b gy ns nt l nu nv">pilot[‘V19’].value_counts().sort_values(ascending=False).plot(kind=’bar’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/a914a20300842aab8c9b2794ab343ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IyZQ3jtEMiXf-aR46eRs3w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">试点数据集中的大多数观察值属于V19列的A类</figcaption></figure><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="600b" class="nr lv it mv b gy ns nt l nu nv">customer_base[‘V19’].value_counts().sort_values(<br/> ascending=False).plot(kind=’bar’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/65029e4aaf580d97af5c79d5585e4d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ka1GThi4YyfHygeYjfYfHw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">客户基础数据集也存在非常相似的模式</figcaption></figure><p id="71bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种差异可能是由不同的因素造成的，例如，试点仅针对一组特定的客户(例如，拥有特定设备的客户类别，或属于特定类别的客户类别)。</p><p id="45b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了了解如何处理这种情况，有必要量化客户群中有多少记录受到影响:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="4cf1" class="nr lv it mv b gy ns nt l nu nv">print(f’Customer base contains {len(customer_base)} records.’)</span><span id="b538" class="nr lv it mv b gy ny nt l nu nv">affected_records = len(<br/> customer_base[customer_base[‘V19’].isin(pilot[‘V19’].unique())])</span><span id="55ed" class="nr lv it mv b gy ny nt l nu nv">print(f’Number of record affected by category mismatch is: {affected_records}’)</span><span id="785a" class="nr lv it mv b gy ny nt l nu nv">print(f’{100 — (affected_records / len(customer_base) * 100)}%’)<br/>print(f’count of affected records: {len(customer_base) — affected_records}’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/d880d81f90693ec9d044288cff1ce757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qEimbqo1vI52Mzk4G8wBNg.png"/></div></div></figure><p id="10e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于该任务中受影响的记录数量很少(59条),是否决定根据<code class="fe ms mt mu mv b">V19</code>变量下试点数据集中的相同类别跳过并过滤客户群。</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="13e8" class="nr lv it mv b gy ns nt l nu nv">customer_base = customer_base[customer_base[‘V19’].isin(pilot[‘V19’].unique())]</span></pre><p id="9c0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理解数据的另一个重要步骤是绘制每个变量的分布图，这次是通过重叠两个决策的数据:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="6e7b" class="nr lv it mv b gy ns nt l nu nv"># distribution of features<br/>features = sorted(<br/> [i for i in pilot.columns if pilot.dtypes[i] != ‘object’])</span><span id="284d" class="nr lv it mv b gy ny nt l nu nv">plt.figure(figsize=(12, 28*4))<br/>gs = gridspec.GridSpec(28, 1)</span><span id="6217" class="nr lv it mv b gy ny nt l nu nv">for i, cn in enumerate(pilot[features]):<br/> ax = plt.subplot(gs[i])<br/> sns.distplot(pilot[cn][pilot.purchase == 1], bins=50, label=’Purchased’)<br/> sns.distplot(pilot[cn][pilot.purchase == 0],<br/> bins=50, label=’Not purchased’)<br/> ax.set_xlabel(‘’)<br/> ax.legend()<br/> ax.set_title(‘histogram of feature: ‘ + str(cn))<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/ba1d8088ebfe2724e2298c55c07f6e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7mRdWmaaPAcZdjlE9d3GA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者的图表</figcaption></figure><p id="1355" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据图表，一些变量，如<code class="fe ms mt mu mv b">V7</code>、<code class="fe ms mt mu mv b">V20</code>、<code class="fe ms mt mu mv b">V10</code>看起来有点像高斯，这表明了一种可能性，例如，尝试使用具有RBF核的支持向量机建模。</p><p id="bc79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此任务的目标是拟合一个二元分类器，这有助于检查目标变量中的类别不平衡:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="facb" class="nr lv it mv b gy ns nt l nu nv">pilot[‘purchase’].value_counts().plot(kind=’bar’)<br/>print(pilot[‘purchase’].value_counts())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/7ed0ea4007d480c71fe07c9282607bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1BLrCp9-czRf48c9JBORg.png"/></div></div></figure><p id="6d94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目标变量具有非常强的不平衡，大约为9:91。</p><h1 id="d554" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论:</h1><p id="7d9e" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">根据这种探索性的数据分析，有可能得出以下结论:</p><ul class=""><li id="8bc5" class="mw mx it la b lb lc le lf lh nk ll nl lp nm lt nb nc nd ne bi translated">在治疗组和对照组之间存在约2.3%的差异</li><li id="2792" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">除了连续变量外，数据集还包含两个分类变量和一个二元变量。出于建模目的，需要记住这一点</li><li id="e87d" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">最大(可行)利润为2，256，250单位</li><li id="93dc" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">目标变量中存在强烈的不平衡</li></ul></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><div class="kj kk kl km gt oq"><a href="https://relentless-creator-2481.ck.page/68d9def351" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">5-bullet数据科学与技术📡</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">编辑描述</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">无情-创造者-2481.ck.page</p></div></div></div></a></div></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="d0ca" class="lu lv it bd lw lx oz lz ma mb pa md me jz pb ka mg kc pc kd mi kf pd kg mk ml bi translated">2.0数据准备</h1><p id="5d6a" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">本节旨在拟合第一个模型(随机梯度推进集合)之前准备数据。</p><p id="14b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于模型拟合的目的，正在使用飞行员数据集。然而，不会使用<code class="fe ms mt mu mv b">treatment</code>列，因为它不是给定用户的固有特性，而是随机分配的组。</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="9c95" class="nr lv it mv b gy ns nt l nu nv">pilot = pilot.drop(‘treatment’, axis=1)</span></pre><p id="9799" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前一节所述，在目标变量<code class="fe ms mt mu mv b">purchase</code>中可以观察到强烈的阶级不平衡。有许多方法来处理类不平衡(过采样、欠采样、Tomek链接、SMOTE...)，并且考虑二进制分类器，仅仅通过预测多数类来获得相当高的准确度是常见的，而它未能捕获少数类，这通常是首先创建模型的目的。</p><p id="3843" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，从商业角度来看，具有更保守的分类器具有经济意义，这意味着相对于假阴性具有高比率的真阳性的分类器。这一选择背后的基本原理是，联系潜在客户是有成本的，我们只对有高购买机会的潜在客户感兴趣。</p><p id="2966" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这项任务，使用的采样技术是SMOTE。该技术的工作原理是从少数类中随机选取点，并计算该点的k-最近邻。</p><p id="0660" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，为了实现该算法，在需要将数据集分割成特征和目标，并通过获取虚拟变量对分类变量进行编码之前，需要使用<code class="fe ms mt mu mv b">imblearn</code>库:</p><p id="a067" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种选择背后的基本原理是，这种方法不会导致信息损失(过采样)，但是，有必要注意，过采样或欠采样并不总是最佳选择:在处理真实世界的数据时，一些现象本质上是不平衡的，因此，操纵目标类会扭曲数据的真实性质(即欺诈检测、流失、信用违约……)</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="ee3d" class="nr lv it mv b gy ns nt l nu nv"># get dummies of categorical variables for both datasets</span><span id="4e18" class="nr lv it mv b gy ny nt l nu nv">pilot = pd.get_dummies(pilot, columns=[‘V2’, ‘V19’], drop_first=True)</span><span id="576b" class="nr lv it mv b gy ny nt l nu nv">customer_base = pd.get_dummies(customer_base, columns=[<br/> ‘V2’, ‘V19’], drop_first=True)</span><span id="9c42" class="nr lv it mv b gy ny nt l nu nv"># set aside 150 random records from pilot and remove them<br/>test_set = pilot.groupby('purchase').apply(<br/>    lambda x: x.sample(frac=0.035, random_state=42))<br/># get list of indices to drop<br/>drop_indices = [i[1] for i in test_set.index]</span><span id="0341" class="nr lv it mv b gy ny nt l nu nv"># reset index and shuffle<br/>test_set = test_set.reset_index(drop=True)<br/>test_set = test_set.sample(frac=1)</span><span id="b78f" class="nr lv it mv b gy ny nt l nu nv"># drop indices from original dataset (to avoid training on them)<br/>pilot = pilot.drop(drop_indices)</span><span id="3f98" class="nr lv it mv b gy ny nt l nu nv"># shuffle data<br/>pilot = pilot.sample(frac=1)</span><span id="f6ea" class="nr lv it mv b gy ny nt l nu nv"># select all columns but purchase<br/>features = pilot.loc[:, pilot.columns != 'purchase']<br/>targets = pilot['purchase']</span><span id="ae2a" class="nr lv it mv b gy ny nt l nu nv"># make sure input data has the same shape as customer base</span><span id="ffa0" class="nr lv it mv b gy ny nt l nu nv">assert len(features.columns) == len(customer_base.columns)</span></pre><p id="1829" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">预处理中一个常见的，但并不总是必要的步骤是标准化，当操作决策树时，它并不总是必要的，但它确实是支持向量机的推荐步骤</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="a53a" class="nr lv it mv b gy ns nt l nu nv">from sklearn.preprocessing import StandardScaler</span><span id="6c39" class="nr lv it mv b gy ny nt l nu nv">scaler = StandardScaler()<br/>features_scaled = scaler.fit_transform(features.values)</span><span id="3f35" class="nr lv it mv b gy ny nt l nu nv"># get a list of categorical columns indexes to fit SMONTENC<br/>cat_columns = [features.columns.get_loc(i)<br/>               for i in features.columns if '_' in i]</span><span id="7866" class="nr lv it mv b gy ny nt l nu nv">from imblearn.over_sampling import SMOTENC</span><span id="c79c" class="nr lv it mv b gy ny nt l nu nv">sm = SMOTENC(categorical_features=cat_columns, k_neighbors=10)<br/>X, y = sm.fit_resample(features_scaled, targets)</span></pre><h1 id="7e5a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.0建模和评估</h1><p id="c5ca" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了训练/验证的目的，使用k-fold交叉验证来分割数据集，此外，应用网格搜索来搜索最佳参数，这些参数然后用于在整个训练数据上拟合模型。这个策略是根据<a class="ae pe" href="https://stats.stackexchange.com/questions/11602/training-on-the-full-dataset-after-cross-validation" rel="noopener ugc nofollow" target="_blank">这个</a>问题和引用的论文选择的。</p><p id="4af8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在没有应用任何过采样(或欠采样)的情况下，更有意识的选择将被分层k倍。</p><h1 id="9760" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.1建模— SVM</h1><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="4b97" class="nr lv it mv b gy ns nt l nu nv"># get test data (unseen by the algorithm)</span><span id="a3d4" class="nr lv it mv b gy ny nt l nu nv">X_test = scaler.transform(test_set.drop([‘purchase’], axis=1).values)<br/>y_test = test_set[‘purchase’].values</span></pre><p id="ad9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了便于拟合多个模型，快速迭代返回最佳参数的专用函数变得非常有用:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="3461" class="nr lv it mv b gy ns nt l nu nv">def fit_gs_model_w_report(model, scores, param_grid, X_train, y_train, X_test, y_test, n_jobs):<br/> ‘’’<br/> Fit a model, generate classification report, and return best model params.<br/> ‘’’</span><span id="e07b" class="nr lv it mv b gy ny nt l nu nv">for score in scores:<br/> print(“# Tuning hyper-parameters for %s” % score)<br/> print()</span><span id="341b" class="nr lv it mv b gy ny nt l nu nv">model = GridSearchCV(model, param_grid, scoring=score, n_jobs=n_jobs)<br/> model.fit(X_train, y_train)</span><span id="d99c" class="nr lv it mv b gy ny nt l nu nv">print(“Best parameters set found on development set:”)<br/> print()<br/> print(model.best_params_)<br/> print()<br/> print(“Grid scores on development set:”)<br/> print()<br/> means = model.cv_results_[“mean_test_score”]<br/> stds = model.cv_results_[“std_test_score”]<br/> for mean, std, params in zip(means, stds, model.cv_results_[“params”]):<br/> print(“%0.3f (+/-%0.03f) for %r” % (mean, std * 2, params))<br/> print()</span><span id="7ddb" class="nr lv it mv b gy ny nt l nu nv">print(“Detailed classification report:”)<br/> print()<br/> print(“The model is trained on the full development set.”)<br/> print(“The scores are computed on the full evaluation set.”)<br/> print()<br/> y_true, y_pred = y_test, model.predict(X_test)<br/> print(classification_report_imbalanced(y_true, y_pred,<br/> target_names=[‘Not purchased’, ‘Purchased’]))<br/> print()</span><span id="672c" class="nr lv it mv b gy ny nt l nu nv">return model.best_params_</span></pre><p id="20a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用网格搜索拟合第一个模型，并解释输出结果:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="32ac" class="nr lv it mv b gy ns nt l nu nv">scores = [“roc_auc”]</span><span id="a4ff" class="nr lv it mv b gy ny nt l nu nv">param_grid_svc = {“kernel”: [“rbf”],<br/> “gamma”: [1e-2, 1e-3, 1e-4],<br/> “C”: [1000, 10000],<br/> “class_weight”: [‘balanced’]<br/> }<br/>svc_best_params = fit_gs_model_w_report(model=SVC(),<br/> scores=scores,<br/> param_grid=param_grid_svc,<br/> X_train=X,<br/> y_train=y,<br/> X_test=X_test,<br/> y_test=y_test,<br/> n_jobs=-1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/64cdf8e3a0f70b5de4581047740eb41e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKDo6QILPOopdN5D9MUppg.png"/></div></div></figure><p id="70ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据<code class="fe ms mt mu mv b">Purchased</code>类别的精确度和召回分数，当模型声称观察确实是购买时，它有29%的时间是正确的，并且它能够检测到40%的购买，但是重要的是要注意测试集中有很大的不平衡(160个阴性样本，只有15个阳性样本)</p><p id="2b42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，使用整个数据集拟合具有最佳参数的最终SVC模型:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="ad4d" class="nr lv it mv b gy ns nt l nu nv">best_svc = SVC(probability=True)<br/>best_svc.set_params(**svc_best_params)</span><span id="4852" class="nr lv it mv b gy ny nt l nu nv">best_svc.fit(X, y)</span><span id="dd21" class="nr lv it mv b gy ny nt l nu nv">y_scores_svc = cross_val_predict(<br/>    best_svc, X, y, cv=10, method='predict_proba', n_jobs=-1)</span><span id="1279" class="nr lv it mv b gy ny nt l nu nv"># since predict_proba returns predictions for each class, we need to focus on the positive class<br/>y_scores_svc = y_scores_svc[:, 1]</span><span id="8adc" class="nr lv it mv b gy ny nt l nu nv">precisions_svc, recall_svc, thresholds_svc = precision_recall_curve(<br/>    y, y_scores_svc)</span></pre><p id="55a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了将该分类器与另一个模型进行比较，可以使用F1分数，但是，F1分数倾向于具有相似精度和召回率的分类器。</p><p id="cdbe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理想情况下，对于此任务，最好使用召回率稍低但精确度较高的分类器，这意味着ABC Telco联系的客户购买该计划的可能性较高。</p><p id="6869" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了进一步调整这一点，可以访问模型的决策得分，然后可以选择适当的阈值:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="770e" class="nr lv it mv b gy ns nt l nu nv">def plot_precision_recall_vs_threshold(precisions, recall, thresholds):<br/> plt.plot(thresholds, precisions[:-1], “b — “,<br/> label=”Precision”, linewidth=2)</span><span id="5ae2" class="nr lv it mv b gy ny nt l nu nv">plt.plot(thresholds, recall[:-1], “g-”, label=”Recall”, linewidth=2)<br/> plt.xlabel(“Threshold”, fontsize=16)<br/> plt.legend(loc=”upper left”, fontsize=16)<br/> plt.ylim([0, 1])<br/> plt.grid()<br/> plt.legend()</span><span id="05de" class="nr lv it mv b gy ny nt l nu nv">plot_precision_recall_vs_threshold(precisions_svc, recall_svc, thresholds_svc)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/c619b16f771ed4893dcd2660975b74ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjEjgqIDhc-zCKrN31LhUQ.png"/></div></div></figure><p id="1547" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从图中可以看出，在阈值约为0.70时，精度会下降到90%以下。</p><p id="f6e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一种选择最合适阈值的常用方法是直接绘制精度与召回率的关系图:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="97d1" class="nr lv it mv b gy ns nt l nu nv">plt.plot(precisions_svc, recall_svc)<br/>plt.grid()<br/>plt.xlabel(‘Precision’)<br/>plt.ylabel(‘Recall’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/248144d9be03c09ff398c9f8b29433ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlDxrtPEHtlSZZ071R5DNg.png"/></div></div></figure><p id="5a09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从图表中可以看出，在大约90%的召回率时，准确率开始急剧下降。这意味着，对于这个任务，将选择在该投放之前的精度/召回折衷。</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="7b75" class="nr lv it mv b gy ns nt l nu nv"># get the threshold at which precision is 90%<br/>threshold_90_precision_svc = thresholds_svc[np.argmax(precisions_svc &gt;= 0.9)]</span><span id="4ef9" class="nr lv it mv b gy ny nt l nu nv">ps_svc = precision_score(y, y_scores_svc &gt; threshold_90_precision_svc)<br/>print(f’Precision: {ps_svc * 100}%’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/d5cbe8c5e64e4e8f72016c62575abf83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*LX0GROiW4-5vsMjY6zGhiw.png"/></div></figure><p id="b396" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，召回分数太低的分类器也不是很有用，这就是为什么在调整之后还需要评估召回分数的原因:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="9b59" class="nr lv it mv b gy ns nt l nu nv">rs_svc = recall_score(y, y_scores_svc &gt; threshold_90_precision_svc)<br/>print(f’Recall: {rs_svc * 100}%’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/45aabc68c09ba36db6d23b91231c3d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*gg1M7dOV16jSeKxJ5j6zfQ.png"/></div></figure><h1 id="8c6e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.2梯度提升分类器</h1><p id="2668" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">本节试图拟合第二个(理想情况下性能更好的)模型。拟合的模型是基于LightGBM库的梯度提升分类器。正在进行网格搜索，以找到最佳参数，特别是添加了<code class="fe ms mt mu mv b">reg_alpha</code>、<code class="fe ms mt mu mv b">reg_lambda</code>、<code class="fe ms mt mu mv b">min_data_in_leaf</code>和<code class="fe ms mt mu mv b">num_leaves</code>，试图防止过度拟合(在基于树的方法中非常常见)</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="26e4" class="nr lv it mv b gy ns nt l nu nv">scores = [“roc_auc”]</span><span id="49af" class="nr lv it mv b gy ny nt l nu nv">param_grid_lgbm = {<br/> ‘learning_rate’: [0.5],<br/> ‘n_estimators’: [96],<br/> ‘num_leaves’: [64, 128],<br/> ‘boosting_type’: [‘gbdt’],<br/> ‘objective’: [‘binary’],<br/> ‘max_bin’: [416],<br/> ‘random_state’: [500],<br/> ‘colsample_bytree’: [0.32],<br/> ‘min_data_in_leaf’: [50],<br/> ‘subsample’: [0.3],<br/> ‘class_weight’: [‘balanced’],<br/> ‘reg_alpha’: [0.01, 0.05],<br/> ‘reg_lambda’: [0.01],<br/> ‘feature_fraction’: [0.2, 0.4]<br/>}</span><span id="e01c" class="nr lv it mv b gy ny nt l nu nv">lgbm_best_params = fit_gs_model_w_report(model=lgbm.LGBMClassifier(n_jobs=1), <br/> scores=scores,<br/> param_grid=param_grid_lgbm, <br/> X_train=X, <br/> y_train=y,<br/> X_test=X_test, <br/> y_test=y_test,<br/> n_jobs=-1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/bf8ec9269fc53d0982336272df8737b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmuvCEAUlPYsm42xT0uu4Q.png"/></div></div></figure><p id="ac25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，使用来自网格搜索的最佳参数来拟合最终模型:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="d8f8" class="nr lv it mv b gy ns nt l nu nv">best_lgbm = lgbm.LGBMClassifier()<br/>best_lgbm.set_params(**lgbm_best_params)</span><span id="b07a" class="nr lv it mv b gy ny nt l nu nv">best_lgbm.fit(X, y)</span></pre><p id="bdc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据精度和召回指标，该模型似乎执行得更好，但是，必须记住，使用该算法家族可能导致严重的过度拟合。</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="8540" class="nr lv it mv b gy ns nt l nu nv">y_scores_lgbm = cross_val_predict(<br/> best_lgbm, X, y, cv=10, method=’predict_proba’, n_jobs=-1)</span><span id="d56e" class="nr lv it mv b gy ny nt l nu nv"># since predict_proba returns predictions for each class, we need to focus on the positive class<br/>y_scores_lgbm = y_scores_lgbm[:, 1]</span><span id="bcb2" class="nr lv it mv b gy ny nt l nu nv">precisions_lgbm, recall_lgbm, thresholds_lgbm = precision_recall_curve(<br/> y, y_scores_lgbm)</span><span id="19fb" class="nr lv it mv b gy ny nt l nu nv">plot_precision_recall_vs_threshold(<br/>    precisions_lgbm, recall_lgbm, thresholds_lgbm)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/61f0ffa951a9cc60f3441819f23493c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qN_PahqvcfH6wl7TNPbqwA.png"/></div></div></figure><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="aaa6" class="nr lv it mv b gy ns nt l nu nv">plt.plot(precisions_lgbm, recall_lgbm)<br/>plt.grid()<br/>plt.xlabel(‘Precision’)<br/>plt.ylabel(‘Recall’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/a36f1e5bca5531fb3024d4a924aefad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PpyUeHzuVNfssRWaNh3q8Q.png"/></div></div></figure><p id="9600" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用与SVC相同的方法选择模型的阈值。</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="c050" class="nr lv it mv b gy ns nt l nu nv"># get the threshold at which precision is 90%<br/>threshold_90_precision_lgbm = thresholds_lgbm[np.argmax(<br/> precisions_lgbm &gt;= 0.90)]</span><span id="b3b6" class="nr lv it mv b gy ny nt l nu nv">ps_lgbm = precision_score(y, y_scores_lgbm &gt; threshold_90_precision_lgbm)<br/>print(f’Precision lgbm model: {ps_lgbm * 100}%’)</span><span id="2d23" class="nr lv it mv b gy ny nt l nu nv">rs_lgbm = recall_score(y, y_scores_lgbm &gt; threshold_90_precision_lgbm)<br/>print(f’Recall: {rs_lgbm * 100}%’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi gj"><img src="../Images/5529b37320957c704a7380fbd477fc7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-a64w3p93QkLW0OFX3oow.png"/></div></div></figure><h1 id="f1e0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.3模型评估</h1><p id="5bfe" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">本节根据评估集评估这两个模型，讨论它们之间的差异和细微差别，选择最终模型，并根据客户群计算预测。</p><h1 id="5cd1" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">SVC:</h1><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="0aa1" class="nr lv it mv b gy ns nt l nu nv"># get test data</span><span id="0519" class="nr lv it mv b gy ny nt l nu nv">X_test = scaler.transform(test_set.drop([‘purchase’], axis=1).values)<br/>y_test = test_set[‘purchase’].values</span><span id="2831" class="nr lv it mv b gy ny nt l nu nv"># scale data in the customer base<br/>customer_base_scaled = scaler.transform(customer_base)</span><span id="29dd" class="nr lv it mv b gy ny nt l nu nv">y_scores_svc = best_svc.predict_proba(X_test)</span><span id="05a0" class="nr lv it mv b gy ny nt l nu nv"># without threshold manipulation<br/>evs_cm_svc = confusion_matrix(y_test, y_scores_svc[:, 1] &gt; 0.5)<br/>ConfusionMatrixDisplay(evs_cm_svc).plot()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/6639aed1b4597de00c31f988f2267ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*gASdkQgggn3ieH3AswsDww.png"/></div></figure><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="a798" class="nr lv it mv b gy ns nt l nu nv">evs_cmt_svc = confusion_matrix(<br/> y_test, y_scores_svc[:, 1] &gt; threshold_90_precision_svc)<br/>ConfusionMatrixDisplay(evs_cmt_svc).plot()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/897484dc372560f1f3c507a3c531e88e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_fRrsLCDh3j8yffnQdbiPw.png"/></div></div></figure><p id="5655" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从混淆矩阵可以看出，根据期望的目标调整阈值可以减少假阳性的数量，从而导致成本的降低。</p><p id="6277" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看这些预测是如何针对客户群的:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="19ce" class="nr lv it mv b gy ns nt l nu nv">final_predictions_svc = best_svc.predict_proba(customer_base_scaled)</span><span id="9539" class="nr lv it mv b gy ny nt l nu nv">constraint = int(len(customer_base) * 0.25)</span><span id="fb7f" class="nr lv it mv b gy ny nt l nu nv">final_predictions_svc_df = pd.DataFrame(<br/>    {'prediction': final_predictions_svc[:, 1] &gt; threshold_90_precision_svc, 'probability': final_predictions_svc[:, 1]})</span><span id="ed5b" class="nr lv it mv b gy ny nt l nu nv"># sort final prediction by score to then apply the 1/4 constraint in a safe way<br/>final_predictions_svc_df = final_predictions_svc_df.sort_values(<br/>    by='probability', ascending=False)</span><span id="223a" class="nr lv it mv b gy ny nt l nu nv">final_predictions_svc_df = final_predictions_svc_df[final_predictions_svc_df['prediction'] == True]<br/>print(<br/>    f'The SVC model would decide to contact {len(final_predictions_svc_df)} customers out of a maximum of {constraint}')</span><span id="76ff" class="nr lv it mv b gy ny nt l nu nv">The SVC model would decide to contact 11618 customers out of a maximum of 23735</span></pre><p id="16b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SVC模型将建议联系呼叫中心可行的多个客户。</p><p id="058b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了模拟估计有多少客户在接触后会实际购买该计划，假设概率为50%，从分布中抽取一个二项式随机变量:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="4040" class="nr lv it mv b gy ns nt l nu nv">buy_decision_svc = binom.rvs(1, .5, size=len(final_predictions_svc_df))<br/>final_predictions_svc_df[‘buy_decision_svc’] = buy_decision_svc</span><span id="e760" class="nr lv it mv b gy ny nt l nu nv"># cost of contacting a customer:<br/>total_positive_predictions_svc = len(final_predictions_svc_df)</span><span id="1873" class="nr lv it mv b gy ny nt l nu nv">total_buying_decisions_svc = len(<br/>    final_predictions_svc_df[final_predictions_svc_df['buy_decision_svc'] == 1])</span><span id="d027" class="nr lv it mv b gy ny nt l nu nv">total_costs_svc = total_positive_predictions_svc * 5</span><span id="74ab" class="nr lv it mv b gy ny nt l nu nv"># discounted revenues for all customer who purchased<br/>total_revenues_svc = total_buying_decisions_svc * 100</span><span id="a35e" class="nr lv it mv b gy ny nt l nu nv">profit_svc = total_revenues_svc - total_costs_svc</span><span id="58e9" class="nr lv it mv b gy ny nt l nu nv">print(<br/>    f'Total total cost of contacting selected customers is {total_costs_svc} units')<br/>print(<br/>    f'Total revenues (incremental discounts) will be of {total_revenues_svc} units')<br/>print(<br/>    f'Total profit for this scenario is: {profit_svc} units, based on {len(final_predictions_svc_df)} customers of which {len(final_predictions_svc_df[final_predictions_svc_df["buy_decision_svc"] == 1])} purchased')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/9e0e20b5b73a3d6c2075deccea5df8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BvWSI_j5qv0VYhtPq2l2RA.png"/></div></div></figure><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="5b5e" class="nr lv it mv b gy ns nt l nu nv"># save business result to a table<br/>final_business_results = pd.DataFrame({<br/> ‘model’: ‘SVC’,<br/> ‘total_cost_contacting_customers’: total_costs_svc,<br/> ‘total_customer_base’: len(customer_base),<br/> ‘contacted customers’: len(final_predictions_svc_df),<br/> ‘amount_of_customers_who_purchased’: len(final_predictions_svc_df[final_predictions_svc_df[“buy_decision_svc”] == 1]),<br/> ‘total_revenues’: total_revenues_svc,<br/> ‘profit’: profit_svc<br/>}, index=[0])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/07ab2f97cde0faaf853f53f91f2f91ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSO7cdWOSEUykC5YLJ48aw.png"/></div></div></figure><h1 id="a041" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">LGBM:</h1><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="526f" class="nr lv it mv b gy ns nt l nu nv"># get test data</span><span id="f796" class="nr lv it mv b gy ny nt l nu nv">X_test = scaler.transform(test_set.drop([‘purchase’], axis=1).values)<br/>y_test = test_set[‘purchase’].values</span><span id="7db2" class="nr lv it mv b gy ny nt l nu nv"># scale data in the customer base<br/>customer_base = scaler.transform(customer_base)</span><span id="dcfb" class="nr lv it mv b gy ny nt l nu nv">evs_pred_lgbm = best_lgbm.predict_proba(X_test)</span><span id="a8c7" class="nr lv it mv b gy ny nt l nu nv"># without threshold manipulation</span><span id="bbb9" class="nr lv it mv b gy ny nt l nu nv">evs_cm_lgbm = confusion_matrix(y_test, evs_pred_lgbm[:, 1] &gt; 0.5)<br/>ConfusionMatrixDisplay(evs_cm_lgbm).plot()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/bc53ad2d15d33e4fb78e81efa3464dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6EVmN6Y7N8rkDU8DkMZkg.png"/></div></div></figure><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="7548" class="nr lv it mv b gy ns nt l nu nv">evs_cmt_lgbm = confusion_matrix(<br/> y_test, evs_pred_lgbm[:, 1] &gt; threshold_90_precision_lgbm)<br/>ConfusionMatrixDisplay(evs_cmt_lgbm).plot()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/2b844c4e3899f37b65fafb905062b48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5jxTC4laE9ejqsTuXSjNQ.png"/></div></div></figure><p id="a013" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比较最终的精度和召回指标(调整阈值后)显示，第二个模型在召回方面显著增加，而精度保持不变。另一方面，在这个阶段，将两个模型的混淆矩阵放在一起绘图可能是有意义的:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="2eb2" class="nr lv it mv b gy ns nt l nu nv">fig, axs = plt.subplots(nrows=1, ncols=2, figsize=(18, 4))</span><span id="39cc" class="nr lv it mv b gy ny nt l nu nv">fig.suptitle(‘SVC VS LGBM — Confusion matrix’)<br/>ConfusionMatrixDisplay(evs_cmt_lgbm).plot(ax=axs[0])<br/>axs[0].set_title(‘LGBM’)</span><span id="145e" class="nr lv it mv b gy ny nt l nu nv">ConfusionMatrixDisplay(evs_cmt_svc<br/> ).plot(ax=axs[1])<br/>axs[1].set_title(‘SVC’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/eccecd944b44021b27b3e623f1069bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4b1AHfKhAN6Vm5Jtadxpdw.png"/></div></div></figure><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="5cc0" class="nr lv it mv b gy ns nt l nu nv">final_predictions_lgbm = best_lgbm.predict_proba(customer_base_scaled)</span></pre><p id="aed0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从图中可以观察到，LGBM模型在捕捉真阳性方面确实更好，而假阴性的数量从12个减少到了9个。另一方面，假阳性的数量略有增加。然而，从商业角度来看，联系4个额外的潜在客户肯定会增加20个单位的成本，但从长远来看，瞄准3个实际购买该计划的潜在客户会带来更高的利润。</p><p id="a8c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么LGB模型被用作最终模型。</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="fac6" class="nr lv it mv b gy ns nt l nu nv">final_predictions_lgbm_df = pd.DataFrame(<br/> {‘prediction’: final_predictions_lgbm[:, 1] &gt; threshold_90_precision_lgbm, ‘probability’: final_predictions_lgbm[:, 1]})</span><span id="7d98" class="nr lv it mv b gy ny nt l nu nv"># sort final prediction by score to then apply the 1/4 constraint in a safe way<br/>final_predictions_lgbm_df = final_predictions_lgbm_df.sort_values(<br/> by=’probability’, ascending=False)</span><span id="de68" class="nr lv it mv b gy ny nt l nu nv">final_positive_predictions_lgbm_df = final_predictions_lgbm_df[<br/> final_predictions_lgbm_df[‘prediction’] == True]<br/>print(<br/> f’The LGBM model would decide to contact {len(final_positive_predictions_lgbm_df)} customers out of a maximum of {constraint}’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/bd7e31bc94bb3189dc61f050246f133a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6ZIPfqcgSGI-WRCuY0lZA.png"/></div></div></figure><p id="bb48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显然，LGBM模型比SVC模型更慷慨。</p><p id="f455" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据二项式分布模拟最终决策:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="3e9d" class="nr lv it mv b gy ns nt l nu nv">buy_decision_lgbm = binom.rvs(<br/> 1, .5, size=len(final_positive_predictions_lgbm_df))<br/>final_positive_predictions_lgbm_df[‘buy_decision_lgbm’] = buy_decision_lgbm</span><span id="2704" class="nr lv it mv b gy ny nt l nu nv"># cost of contacting a customer:<br/>total_positive_predictions_lgbm = len(<br/> final_positive_predictions_lgbm_df[final_positive_predictions_lgbm_df[‘prediction’] == True])</span><span id="9eab" class="nr lv it mv b gy ny nt l nu nv">total_buying_decisions_lgbm = len(<br/> final_positive_predictions_lgbm_df[final_positive_predictions_lgbm_df[‘buy_decision_lgbm’] == True])</span><span id="1624" class="nr lv it mv b gy ny nt l nu nv">total_costs_lgbm = total_positive_predictions_lgbm * 5</span><span id="b5d1" class="nr lv it mv b gy ny nt l nu nv"># discounted revenues for all customer who purchased<br/>total_revenues_lgbm = total_buying_decisions_lgbm * 100</span><span id="5d07" class="nr lv it mv b gy ny nt l nu nv">profit_lgbm = total_revenues_lgbm — total_costs_lgbm</span><span id="0e93" class="nr lv it mv b gy ny nt l nu nv">print(<br/> f’Total total cost of contacting selected customers is {total_costs_lgbm} units’)<br/>print(<br/> f’Total revenues (incremental discounts) will be of {total_revenues_lgbm} units’)<br/>print(<br/> f’Total profit for this scenario is: {profit_lgbm} units, based on {len(final_positive_predictions_lgbm_df)} customers of which {len(final_positive_predictions_lgbm_df[final_positive_predictions_lgbm_df[“buy_decision_lgbm”] == 1])} purchased’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/356ea2785c44c5d377dc2ec319b798a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KF02UIesOiXc7L7TjT9uYQ.png"/></div></div></figure><p id="4eef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在可以创建一个最终表来比较业务相关数据:</p><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="5030" class="nr lv it mv b gy ns nt l nu nv"># save business result to a table<br/>final_business_results = final_business_results.append({<br/> ‘model’: ‘LGBM’,<br/> ‘total_cost_contacting_customers’: total_costs_lgbm,<br/> ‘total_customer_base’: len(customer_base),<br/> ‘contacted customers’: len(final_positive_predictions_lgbm_df),<br/> ‘amount_of_customers_who_purchased’: len(final_positive_predictions_lgbm_df[final_positive_predictions_lgbm_df[“buy_decision_lgbm”] == 1]),<br/> ‘total_revenues’: total_revenues_lgbm,<br/> ‘profit’: profit_lgbm<br/>}, ignore_index=True)</span></pre><p id="3d25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重要的是要知道，由于最终的购买决策是由随机函数模拟的，所以上面的估计值可能会有细微的变化(尽管出于再现性目的声明了一个种子)。</p><p id="00cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下表列出了预计的成本、收入和利润:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/39cc365cfa4ed7c24137b769d2f65ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*feb1o4Rpph5mq_c7Cztrow.png"/></div></div></figure><p id="a08f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个任务的目标是从这个活动中获得最大利润，因此LGBM模型被选为最终模型。</p><h1 id="696e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">4.0结论</h1><p id="85da" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">考虑到这个任务是在笔记本电脑上完成的，我不想使用任何计算量太大的技术，比如更广泛的网格搜索。我相信提高这个模型准确性的关键在于更高级的数据预处理。在迭代不同的预处理技术时，我几乎立即注意到了规范化是如何提高模型输出的。</p><p id="09eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，获得更多数据(+100K标记的观察值)将使前面提到的技术更加强大。</p><p id="e239" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">提高产量的可能方法:</p><ul class=""><li id="ee1b" class="mw mx it la b lb lc le lf lh nk ll nl lp nm lt nb nc nd ne bi translated">获得更多的计算能力将使超参数优化更快、更容易实现</li><li id="3382" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">了解特性的商业意义将有助于变量选择/解释</li><li id="3c0e" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">更广泛的预处理试验和错误(以及快速迭代的计算能力)</li><li id="dab5" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">更多训练数据</li></ul></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nn mv no np aw nq bi"><span id="4b4f" class="nr lv it mv b gy ns nt l nu nv"><strong class="mv iu">I have a newsletter 📩.</strong> </span><span id="3f64" class="nr lv it mv b gy ny nt l nu nv">Every week I’ll send you a brief findings of articles, links, tutorials, and cool things that caught my attention. If tis sounds cool to you subscribe. </span><span id="0f06" class="nr lv it mv b gy ny nt l nu nv"><em class="pw">That means </em><strong class="mv iu"><em class="pw">a lot</em></strong><em class="pw"> for me.</em></span></pre><div class="px py gp gr pz oq"><a href="https://relentless-creator-2481.ck.page/68d9def351" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">5-bullet数据科学与技术📡</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">编辑描述</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">无情-创造者-2481.ck.page</p></div></div></div></a></div></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="3b77" class="lu lv it bd lw lx oz lz ma mb pa md me jz pb ka mg kc pc kd mi kf pd kg mk ml bi translated">分级编码</h1><p id="d4c5" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="d643" class="mw mx it la b lb lc le lf lh nk ll nl lp nm lt nb nc nd ne bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="8879" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">📰查看<a class="ae pe" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="6f0f" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">🔔关注我们:<a class="ae pe" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae pe" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae pe" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="981c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">🚀👉<a class="ae pe" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>