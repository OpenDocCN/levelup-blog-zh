<html>
<head>
<title>React 18: What You Need to Know and What’s Changing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应18:你需要知道的和正在改变的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-18-what-you-need-to-know-and-whats-changing-55acfa5bb0e3?source=collection_archive---------14-----------------------#2022-03-30">https://levelup.gitconnected.com/react-18-what-you-need-to-know-and-whats-changing-55acfa5bb0e3?source=collection_archive---------14-----------------------#2022-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b55aba123e6491d8858f2258dbc13788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0B3XG3xGSf0-lM1G-dqlsw.jpeg"/></div></div></figure><p id="42a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于开发者来说，这是一个激动人心的时刻。不断变化和不断更新是游戏的名字。这个悬崖笔记帖子之所以成为可能，是因为React拥有<a class="ae kw" href="https://reactjs.org/blog/2022/03/29/react-v18.html" rel="noopener ugc nofollow" target="_blank">令人敬畏的文档</a>。因此，让我们一起来了解一下新的和改进的React。在你过于恐慌之前，要知道更新React通常不会破坏你现有的代码。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/4b6e49554c0a1c173e559e064691705b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*EBxQQ7sV86lnwZNddGHRmQ.jpeg"/></div></div></figure><h1 id="da30" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">如何更新？</strong></h1><p id="5a36" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">要安装React的最新版本:</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="ee87" class="mk ld iq mg b gy ml mm l mn mo">npm install react react-dom</span></pre><p id="ce70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者如果你用的是纱线:</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="8150" class="mk ld iq mg b gy ml mm l mn mo">yarn add react react-dom</span></pre><p id="f664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您第一次安装或更新React 18时，预计会在您的控制台中看到以下警告:</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="e923" class="mk ld iq mg b gy ml mm l mn mo">ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it’s running React 17. Learn more: <a class="ae kw" href="https://reactjs.org/link/switch-to-createroot" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/link/switch-to-createroot</a></span></pre><p id="663d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于React 18引入了一个新的根API，您需要做一个重要的改变来利用所有的新特性。<br/>转到根入口文件(通常是<strong class="ka ir"> index.js </strong>)。在这个文件中，您需要进行以下更新。根据<a class="ae kw" href="https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="acda" class="mk ld iq mg b gy ml mm l mn mo">// Before<br/>import { render } from 'react-dom';<br/>const container = document.getElementById('app');<br/>render(&lt;App tab="home" /&gt;, container);</span><span id="bbaf" class="mk ld iq mg b gy mp mm l mn mo">// After<br/>import { createRoot } from ‘react-dom/client’;<br/>const container = document.getElementById(‘app’);<br/>const root = createRoot(container);<br/>root.render(&lt;App tab=”home” /&gt;);</span></pre><p id="4ac4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用React 18，需要调用<strong class="ka ir"> createRoot </strong>并将根元素传递给<strong class="ka ir"> createRoot </strong>。这将返回根对象，在其上您将调用<strong class="ka ir"> render </strong>来呈现您的根组件。词根这个词用得太多了。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/2867a9008af240a61dc3229593ee128e.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*PQ-UCt2UD_muqS0VcDYkSA.jpeg"/></div></div></figure><h1 id="2095" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">有什么变化？</strong></h1><p id="efb5" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">通过使用这种语法，您可以选择幕后的更新和新特性，最显著的是:<em class="mq">并发:</em></p><blockquote class="mr ms mt"><p id="0a4f" class="jy jz mq ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">“这是一种新的幕后机制，使React能够同时准备多个版本的UI。您可以将并发性视为一个实现细节——它的价值在于它所释放的特性。React在其内部实现中使用了复杂的技术，如优先级队列和多重缓冲。”</p></blockquote><p id="56b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React 18之前，更新是通过同步呈现来处理的，因此是通过单个不间断的事务来处理的。</p><p id="8c54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在渲染是可中断的。尽管在用户看到页面上的最终结果之前不能中断更新，但react呈现可以暂停，稍后继续。但是关键是:用户界面看起来是无缝的和一致的。在幕后，react基本上是在不阻塞任何用户输入或应用程序流的情况下准备屏幕。Concurrent React可以实现可重用的状态来帮助用户体验。例如，如果用户跳开，然后返回到一个屏幕，React将“从屏幕上删除UI的某些部分，然后在重用之前的状态时将它们添加回去。”</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ff2917e5941ca19882b88c82fa9546cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*u7Nvf2h_xPSehkZKB7kyWg.jpeg"/></div></figure><p id="b52b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个重要的提示: <br/>慢慢来，逐渐适应这些变化。文档称“React 18中的新渲染行为仅在应用程序中使用新功能的部分启用。”目的是在不破坏现有代码的情况下运行React 18，但是因为更新是可中断的，所以当启用并发渲染时，组件的行为会有轻微的变化。使用<strong class="ka ir"> &lt; StrictMode &gt; </strong>也可能有所帮助，因为它将有助于在开发过程中捕获bug，并记录额外的警告，这有望拦截错误。</p><p id="0c76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">接下来还会有哪些新功能？</strong></p><ol class=""><li id="7421" class="my mz iq ka b kb kc kf kg kj na kn nb kr nc kv nd ne nf ng bi translated">自动批处理或默认分组多个状态更新(相对于以前的版本，以前的版本只在事件处理程序中分组更新)到一个单独的重新呈现中。更多信息:<a class="ae kw" href="https://github.com/reactwg/react-18/discussions/21" rel="noopener ugc nofollow" target="_blank">自动配料</a></li><li id="7e5a" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">转换允许一种新的方式来区分更新，即它们是紧急的(与直接用户交互相关，例如点击或键入)还是非紧急的(例如转换更新，其中用户不期望看到立即的物理变化)。为了利用这一点，您将在转换API中包装更新，例如<strong class="ka ir"> startTransition() </strong>和<strong class="ka ir"> useTransition() </strong>。更多信息:<a class="ae kw" href="https://reactjs.org/docs/react-api.html#transitions" rel="noopener ugc nofollow" target="_blank">过渡文件</a></li><li id="5a14" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">用于声明组件树加载状态的暂挂特性，当与转换API结合使用时效果很好。更多信息:<a class="ae kw" href="https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md" rel="noopener ugc nofollow" target="_blank">React 18中的悬念</a></li><li id="e8aa" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">新的客户端和服务器渲染API，它与新的方法createRoot有关，用于渲染(和卸载)，但请阅读更多关于<a class="ae kw" href="https://reactjs.org/docs/react-dom-client.html" rel="noopener ugc nofollow" target="_blank"> React DOM客户端</a>和<a class="ae kw" href="https://reactjs.org/docs/react-dom-server.html" rel="noopener ugc nofollow" target="_blank"> React DOM服务器</a></li><li id="f6af" class="my mz iq ka b kb nh kf ni kj nj kn nk kr nl kv nd ne nf ng bi translated">也许值得你花时间好好谷歌一下严格模式的行为变化。还有…新的钩子！我不兴奋，你才兴奋。<br/><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#useid" rel="noopener ugc nofollow" target="_blank">useId</a><br/>T5】use transition和start transition<br/><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usedeferredvalue" rel="noopener ugc nofollow" target="_blank">useDeferredValue</a><br/><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore" rel="noopener ugc nofollow" target="_blank">useSyncExternalStore</a><br/><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#useinsertioneffect" rel="noopener ugc nofollow" target="_blank">useInsertionEffect</a></li></ol><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4b50388a2a2060647d6f9cece759322f.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*YGZEDUv9YQRLTgMbM6XflA.jpeg"/></div></figure></div></div>    
</body>
</html>