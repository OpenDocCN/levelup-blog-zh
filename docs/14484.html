<html>
<head>
<title>How to Get Smart Contract Creation Block Number</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何获取智能合同创建块编号</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-get-smart-contract-creation-block-number-7f22f8952be0?source=collection_archive---------9-----------------------#2022-12-01">https://levelup.gitconnected.com/how-to-get-smart-contract-creation-block-number-7f22f8952be0?source=collection_archive---------9-----------------------#2022-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f11f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用二分搜索法算法获得智能合同创建块</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ef9e07687c0a08628ec5f43a1d99a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RX4BZcB9jKwOvpcj"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@thoughtcatalog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">思想目录</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="27a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在StackOverflow上有很多关于如何获得智能合约的创建块的讨论。</p><ul class=""><li id="cfd7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://ethereum.stackexchange.com/questions/36173/how-to-get-the-birth-block-of-a-contract" rel="noopener ugc nofollow" target="_blank">如何获得一份合同的“出生块”？</a></li><li id="4b8e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://ethereum.stackexchange.com/questions/53322/how-to-get-erc20-contract-deploy-time-block-number" rel="noopener ugc nofollow" target="_blank">如何获取erc20合同部署区块号？</a></li><li id="dc1d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://ethereum.stackexchange.com/questions/45300/how-to-find-the-block-when-contract-was-deployed" rel="noopener ugc nofollow" target="_blank">部署合同时如何找到区块</a></li><li id="14af" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/72489211/how-to-find-the-creation-block-number-for-a-given-contract-address-using-web3-py?rq=1" rel="noopener ugc nofollow" target="_blank">如何使用web3.py找到给定合同地址的创建块号</a></li></ul><p id="c24b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它们中的大多数都没有提供详细的解决方案。在本文中，我将向您展示如何使用Go和以太坊获得智能合约的创建块。</p><p id="5d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是完整的<a class="ae ky" href="https://gist.github.com/jerryan999/56ffce6571cfd8ef06e96d580b252b32" rel="noopener ugc nofollow" target="_blank">代码</a></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ebaa" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">怎么</h1><p id="06c7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">没有直接获得智能合同创建块的方法。我们需要从头到尾扫描每个块，以找到创建契约的块。</p><p id="df0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这种线性扫描太慢，更可行的方法是使用<strong class="lb iu">二分搜索法</strong>找到创建合同的块号。</p><p id="8013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个问题是如何确定一个区块是合同的创建区块。</p><p id="b305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用合同代码的长度来帮助。如果代码长度大于2，则合同已经创建。否则，它还没有被创建。</p><p id="87a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是代码时间！</p><h1 id="4a65" class="mq mr it bd ms mt nn mv mw mx no mz na jz np ka nc kc nq kd ne kf nr kg ng nh bi translated">什么</h1><h2 id="35d4" class="ns mr it bd ms nt nu dn mw nv nw dp na li nx ny nc lm nz oa ne lq ob oc ng od bi translated">实例化</h2><p id="cc80" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">下面是<code class="fe oe of og oh b">ContractFinder</code>的核心<strong class="lb iu">结构</strong>以及如何实例化它:</p><pre class="kj kk kl km gt oi oh oj bn ok ol bi"><span id="c501" class="om mr it oh b be on oo l op oq">type ContractFinder struct {<br/>    client      *ethclient.Client<br/>    latestBlock int64<br/>}<br/><br/>func NewContractFinder(provider string) (*ContractFinder, error) {<br/>    conn, err := ethclient.Dial(provider)<br/>    if err != nil {<br/>        return nil, err<br/>     }<br/> <br/>    // get latest block number for reuse later<br/>    latestBlock, err := conn.BlockByNumber(context.Background(), nil)<br/>    if err != nil {<br/>        return nil, err<br/>     }<br/><br/>    return &amp;ContractFinder{<br/>        client:      conn,<br/>        latestBlock: latestBlock.Number().Int64(),<br/>        }, nil<br/>}</span></pre><p id="f2be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要知道最新的块号才能使用二分搜索法。可以通过调用客户端的<code class="fe oe of og oh b">BlockNumber</code>方法从提供者处获得。</p><p id="5dd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意，我们将这个数字存储在<code class="fe oe of og oh b">ContractFinder</code>结构中，以便在某个时间段内不需要进一步的请求。</p><h2 id="408f" class="ns mr it bd ms nt nu dn mw nv nw dp na li nx ny nc lm nz oa ne lq ob oc ng od bi translated">履行</h2><pre class="kj kk kl km gt oi oh oj bn ok ol bi"><span id="c2fe" class="om mr it oh b be on oo l op oq">func (c *ContractFinder) codeLen(contractAddr string, blockNumber int64) int {<br/>    ctx := context.Background()<br/>    data, err := c.client.CodeAt(ctx, common.HexToAddress(contractAddr), big.NewInt(blockNumber))<br/>    if err != nil {<br/>        log.Fatal("Whoops something went wrong!", err)<br/>     }<br/><br/>    return len(data)<br/>}<br/><br/><br/>func (c *ContractFinder) GetContractCreationBlock(contractAddr string) int64 {<br/>     return c.getCreationBlock(contractAddr, 0, c.latestBlock)<br/>}<br/><br/><br/>// binary search<br/>func (c *ContractFinder) getCreationBlock(contractAddr string, startBlock int64, endBlock int64) int64 {<br/>    if startBlock == endBlock {<br/>       return startBlock<br/>     }<br/>   <br/>    midBlock := (startBlock + endBlock) / 2<br/>    codeLen := c.codeLen(contractAddr, midBlock)<br/> <br/>    if codeLen &gt; 2 {<br/>       return c.getCreationBlock(contractAddr, startBlock, midBlock)<br/>    } else {<br/>       return c.getCreationBlock(contractAddr, midBlock+1, endBlock)<br/>    }<br/>}</span></pre><p id="6ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og oh b">GetContractCreationBlock</code>是界面！</p><h2 id="ab5a" class="ns mr it bd ms nt nu dn mw nv nw dp na li nx ny nc lm nz oa ne lq ob oc ng od bi translated">客户端部分</h2><p id="d226" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">下面是如何使用上面的代码。</p><pre class="kj kk kl km gt oi oh oj bn ok ol bi"><span id="28ec" class="om mr it oh b be on oo l op oq">func main() {<br/><br/>   cttFinder, err := NewContractFinder("https://mainnet.infura.io/v3/[yourkey]")<br/>   if err != nil {<br/>      log.Fatal("Whoops something went wrong!", err)<br/>   }<br/><br/>   contracts := []string{<br/>    "0x3a4f40631a4f906c2bad353ed06de7a5d3fcb430",<br/>    "0xa4991609c508b6d4fb7156426db0bd49fe298bd8",<br/>   }<br/> <br/>   for _, contract := range contracts {<br/>      creationBlock := cttFinder.GetContractCreationBlock(contract)<br/>      log.Println(contract, creationBlock)<br/>   }<br/>}</span></pre><h1 id="88fb" class="mq mr it bd ms mt nn mv mw mx no mz na jz np ka nc kc nq kd ne kf nr kg ng nh bi translated">其他提示</h1><h2 id="c869" class="ns mr it bd ms nt nu dn mw nv nw dp na li nx ny nc lm nz oa ne lq ob oc ng od bi translated">限速</h2><p id="48aa" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">有时，您的节点RPC提供程序有一个速率限制策略。你需要添加一个限速器组件来避免被禁止。</p><pre class="kj kk kl km gt oi oh oj bn ok ol bi"><span id="0d5d" class="om mr it oh b be on oo l op oq">type ContractCreationFinder struct {<br/>     client *ethclient.Client<br/>     rl     ratelimit.Limiter   // rate limit component<br/>}<br/><br/>func (c *ContractCreationFinder) GetCodeLen(contractAddr string, blockNumber int64) int {<br/>     // ...<br/><br/>     c.rl.Take()<br/>     //...<br/><br/>}</span></pre><h2 id="276b" class="ns mr it bd ms nt nu dn mw nv nw dp na li nx ny nc lm nz oa ne lq ob oc ng od bi translated">同时找到创建块</h2><p id="4247" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果我们想找到1000个契约的创建块，也许我们必须同时进行。</p><p id="428a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随时查看<a class="ae ky" href="https://gist.github.com/jerryan999/56ffce6571cfd8ef06e96d580b252b32" rel="noopener ugc nofollow" target="_blank"> Github </a>上的完整代码</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="5f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢读这篇文章😄。如果你想支持我☕作为一个作家，考虑注册<a class="ae ky" href="https://jerryan.medium.com/membership" rel="noopener">成为一个媒体成员</a>。你还可以无限制地访问媒体上的每个故事。</p></div></div>    
</body>
</html>