<html>
<head>
<title>Learning Go: Object-Oriented Programming Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Go:面向对象编程第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-object-oriented-programming-part-1-e8da5c91488e?source=collection_archive---------12-----------------------#2020-03-27">https://levelup.gitconnected.com/learning-go-object-oriented-programming-part-1-e8da5c91488e?source=collection_archive---------12-----------------------#2020-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7e24bce5462a5f9fae6b45b6b0afbd01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q88ooVnhBb-tD_5-"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图为<a class="ae kf" href="https://unsplash.com/@toddquackenbush?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托德·夸肯布什</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="e3f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每一种现代计算机编程语言，或者至少是自20世纪80年代中期以来开发的语言，都提供了一些执行面向对象编程(OOP)的方法。虽然这些类中有许多是通过类来实现这一点的，但在Go OOP中，是通过定义在结构范围内调用的结构和方法的组合来实现的。在这篇文章中，我将介绍OOP是如何在Go中执行的，包括定义方法和组合的基础知识。</p><h1 id="31cf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结构的快速概述</h1><p id="e2da" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">OOP是通过封装数据和行为实现的。在许多编程语言中，完成封装的方法是创建一个类。围棋没有课。相反，在Go中封装数据的方法是使用struct。如果你想了解更多关于结构的知识，这里的<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/learning-go-structs-ca4074dff40d">是我的关于在Go中使用结构的文章的链接。</a></p><p id="90f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我将通过演示如何创建一个结构来跟踪几何点来提供一个简要的概述:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="302c" class="mq lf it mm b gy mr ms l mt mu">type Point struct {<br/>  x, y int<br/>}</span></pre><p id="0613" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用结构文字来定义结构:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="223f" class="mq lf it mm b gy mr ms l mt mu">p1 := Point{1,2}</span></pre><p id="63f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用点符号来访问结构中的数据:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ffaa" class="mq lf it mm b gy mr ms l mt mu">fmt.Printf("x: %d, y: %d\n", p1.x, p1.y)</span></pre><h1 id="aeff" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用方法定义对象行为</h1><p id="7782" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">上一节演示了我们如何在对象中定义和使用数据。下一步是定义一个对象的行为，我们用<em class="mv">方法</em>来完成。</p><p id="3958" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法是一个函数，它被定义为由一个结构<em class="mv">接收</em>。方法定义看起来像函数定义，但是它包括一个额外的参数来引用作为方法定义的接收者的结构。</p><p id="1844" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面是一种计算两点之间距离的方法:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c64d" class="mq lf it mm b gy mr ms l mt mu">package main</span><span id="64e1" class="mq lf it mm b gy mw ms l mt mu">import (<br/>  "fmt"<br/>  "math"<br/>)</span><span id="08a0" class="mq lf it mm b gy mw ms l mt mu">type Point struct {<br/>  x, y float64<br/>}</span><span id="5f84" class="mq lf it mm b gy mw ms l mt mu">func (p1 Point) Distance(p2 Point) float64 {<br/>  return math.Sqrt(math.Pow((p2.x-p1.x),2) +<br/>                   math.Pow((p2.y-p1.y),2))<br/>}</span><span id="9e23" class="mq lf it mm b gy mw ms l mt mu">func main() {<br/>  p1 := Point{3,5}<br/>  p2 := Point{1,2}<br/>  dist := p1.Distance(p2)<br/>  fmt.Println(p1)<br/>  fmt.Println(p2)<br/>  fmt.Printf("Distance between the two points is %.2f.\n", dist)<br/>}</span></pre><p id="2cdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们用struct调用方法时，我们调用的是一个<em class="mv">选择器</em>，这个表达式被称为选择器表达式— <code class="fe mx my mz mm b">p1.Distance(p2)</code>。</p><p id="b963" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看另一个使用指针的例子。如果我们想写一个直接修改<code class="fe mx my mz mm b">Point</code>的函数，或者，正如我之前讨论结构时所说的，我们想有效地将结构传递给函数，我们希望<code class="fe mx my mz mm b">Point </code>参数是一个指针。这里有一个函数和一个程序来完成这个任务，将一个点从一个地方移动到另一个地方:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="044f" class="mq lf it mm b gy mr ms l mt mu">func (p *Point) MoveTo(x, y float64) {<br/>  p.x = x<br/>  p.y = y<br/>}</span><span id="89cf" class="mq lf it mm b gy mw ms l mt mu">func main() {<br/>  p1 := Point{3,5}<br/>  fmt.Println(p1) // {3, 5}<br/>  pp1 := &amp;p1<br/>  pp1.MoveTo(1,2)<br/>  fmt.Println(*pp1) // {1, 2}<br/>  fmt.Println(p1) // {1, 2}<br/>}</span></pre><p id="b088" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了提高程序的效率，应该始终将结构作为指针传递给函数。</p><h1 id="8dd0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">通过结构嵌入构建对象</h1><p id="85ea" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Go语言没有继承，但是创建复杂类型的一种方法是通过结构嵌入。这只是意味着通过在定义中嵌入其他结构类型来构建一个类型。</p><p id="9141" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过嵌入其他类型来构建类型模型<em class="mv">有-a </em>关系。例如，汽车“有”方向盘；一个人“有”名字；一个形状“有”一个原点。这种类型构建被称为<em class="mv">组合</em>，是Go使用继承从其他类型创建类型的答案。</p><p id="5349" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我们的第一个复合示例，我们将通过在其中嵌入一个<code class="fe mx my mz mm b">Point </code>类型来构建一个圆形类型。代码如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="725b" class="mq lf it mm b gy mr ms l mt mu">type Point struct {<br/>  x, y float64<br/>}</span><span id="7305" class="mq lf it mm b gy mw ms l mt mu">type Circle struct {<br/>  origin Point<br/>  radius float64<br/>}</span><span id="bd8b" class="mq lf it mm b gy mw ms l mt mu">func main() {<br/>  var c1 Circle<br/>  c1.origin = Point{1,2}<br/>  c1.radius = 5<br/>  fmt.Println(c1)<br/>}</span></pre><p id="b897" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">熟悉OOP的人会注意到，这些结构的数据是公共的，可以直接访问。这意味着我们的数据没有被恰当地封装，至少没有按照正常的OOP标准封装。结果是Go在包级别封装了数据，我将在下一篇关于Go中OOP的文章中介绍如何实现这一点。</p><h1 id="c333" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Go中的构造函数</h1><p id="9cb9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Go中没有构造函数这种东西，所以如果你想要一个构造函数，你必须通过一个方法创建一个，并把结构体作为接收者。下面是一个使用<code class="fe mx my mz mm b">Student</code>结构定义的例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c514" class="mq lf it mm b gy mr ms l mt mu">type Student struct {<br/>  name string<br/>  id int<br/>  major string<br/>}</span><span id="10f7" class="mq lf it mm b gy mw ms l mt mu">func (st *Student) Create (stuName string, stuId int, <br/>                           stuMajor string) {<br/>  st.name = stuName<br/>  st.id = stuId<br/>  st.major = stuMajor<br/>}</span><span id="11be" class="mq lf it mm b gy mw ms l mt mu">func main() {<br/>  var student1 Student<br/>  student1.Create("David Horton", 123, "History")<br/>  fmt.Println(student1)<br/>}</span></pre><p id="515c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mx my mz mm b">Create</code>方法作为一个构造函数工作，因为它为<code class="fe mx my mz mm b">Student</code>结构的所有字段设置值。</p><h1 id="292e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">涵盖的Go OOP特性摘要</h1><p id="c06b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">下面是我们在这篇文章中学到的内容的总结。Go不像其他OOP语言那样有类，所以你必须使用一个struct。Go允许您创建被称为方法的函数，可以从结构变量中调用这些函数。这些方法是用点运算符访问的，就像访问结构字段一样。Go没有继承，但是您可以使用组合来创建将其他结构作为字段的结构。最后，你不能在Go中创建构造函数，但是你可以创建方法来执行与其他OOP语言中的构造函数相同的任务。</p><p id="c996" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的下一篇文章中，我将介绍更多在Go中实现OOP的方法，通过包级封装和创建接口来实现继承。</p><p id="b3c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。</p></div></div>    
</body>
</html>