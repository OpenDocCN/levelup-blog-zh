<html>
<head>
<title>How and When to Write MySQL Subqueries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以及何时编写MySQL子查询</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-and-when-to-write-mysql-subqueries-8d5d580b1729?source=collection_archive---------6-----------------------#2020-02-23">https://levelup.gitconnected.com/how-and-when-to-write-mysql-subqueries-8d5d580b1729?source=collection_archive---------6-----------------------#2020-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="593e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">FROM和WHERE语句中的实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/e123b7da2264703a32601ec0e0b1b849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*_LCBl-Mff92NCGHoEOrN1g.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae kr" href="https://www.sqlservertutorial.net/sql-server-basics/sql-server-subquery/" rel="noopener ugc nofollow" target="_blank">图片来自sqlservertutorial.net</a></figcaption></figure><p id="f6b8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我的朋友JP最近发表了一篇优秀的<a class="ae kr" href="https://medium.com/@jprinfret/the-mysql-functions-used-in-almost-every-etl-pipeline-d2007d6f5086" rel="noopener">文章</a>，概述了ETL管道的基本MySQL函数，最后略微提到了子查询的主题。鉴于子查询在执行多步操作时非常有用，我想详细说明子查询并提供一些技巧和窍门。</p><p id="7c3a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">子查询是嵌套查询，允许用户获取需要多次操作的数据。<strong class="ku ir"> </strong>例如，如果我们有一个包含产品信息的表，我们可能希望找到不同类别产品的最高价格，然后取每个类别价格的平均值。为此，我们需要分别执行每个聚合。让我们用一个示例数据库来看看这是如何工作的，<code class="fe lo lp lq lr b">production</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/ac7d027fee62db8d99292a096538876b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*IeBPYBHQXfdleT2XzWO_UA.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated"><code class="fe lo lp lq lr b">Production databse </code>模式</figcaption></figure><p id="68c4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以在一个查询中的多个地方调用子查询，但是我们将只看如何在<code class="fe lo lp lq lr b">FROM</code>和<code class="fe lo lp lq lr b">WHERE</code>语句中使用它们来了解这是如何工作的。</p><h2 id="0633" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">FROM语句中的子查询</h2><p id="1e33" class="pw-post-body-paragraph ks kt iq ku b kv mm jr kx ky mn ju la lb mo ld le lf mp lh li lj mq ll lm ln ij bi translated">我们可以在<code class="fe lo lp lq lr b">FROM</code>语句后插入一个子查询来选择列并聚合一个单独查询的结果！让我们从一个简单的例子开始，感受一下语法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">示例1</figcaption></figure><p id="c242" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里的语法非常简单。在<code class="fe lo lp lq lr b">FROM</code>语句之后，我们将子查询放在括号内，它遵循与任何普通查询完全相同的语法。在右括号之外，我在第10行指定了别名<code class="fe lo lp lq lr b">sub</code>，因为根据MySQL，“每个派生表都必须有自己的别名。”</p><p id="6e60" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">只检查4–9中的子查询，我们看到我们简单地选择了所有<code class="fe lo lp lq lr b">model_year</code>为2018的列。然后，外部查询只返回子查询中的所有列。最终，我们知道没有子查询也可以得到同样的结果，但是我以这种方式介绍它是为了说明语法。</p><p id="1b94" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们看一个稍微复杂一点的例子。假设我们想知道每年发布的产品的平均数量。我们将创建以下查询:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">示例2</figcaption></figure><p id="8928" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了理解发生了什么，我们先来看看第4–10行的子查询。该查询通过聚合<code class="fe lo lp lq lr b">model_year</code>返回每年生产的产品数量。子查询的结果是:</p><pre class="kg kh ki kj gt mt lr mu mv aw mw bi"><span id="6acc" class="lt lu iq lr b gy mx my l mz na">+--------------------+<br/>| count | model_year |<br/>|--------------------|<br/>| 26    | 2016       |<br/>| 85    | 2017       |<br/>| 204   | 2018       |<br/>| 6     | 2019       |<br/>+--------------------+</span></pre><p id="ae09" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后，外部查询计算出上述<code class="fe lo lp lq lr b">counts</code>列的平均值为80.25。不错！</p><p id="1cb6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，对于一个更高级的例子，我将演示如何在子查询中使用窗口函数。在本例中，我们希望找出每个<code class="fe lo lp lq lr b">brand_id</code>最贵的前3种产品，以及关于<code class="fe lo lp lq lr b">product_id</code>、<code class="fe lo lp lq lr b">product_name</code>等产品的信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">示例3</figcaption></figure><p id="85c8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">第9行中的window函数做的和它所说的几乎完全一样:它对每个<code class="fe lo lp lq lr b">brand_id</code>按<code class="fe lo lp lq lr b">list_price</code>降序排序，并创建一个新列<code class="fe lo lp lq lr b">price_rank</code>，为每行分配一个整数排名。想了解更多关于窗口函数的信息，请查看这篇很棒的教程。</p><p id="5dc0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一旦我们从第4–12行的子查询中得到我们的表，我们选择所有列，其中<code class="fe lo lp lq lr b">price_rank&lt; 4</code>，这将我们限制到每个品牌id的前3个最昂贵的产品。</p><p id="183b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们在上面看到了如何在<code class="fe lo lp lq lr b">FROM</code>语句中实现子查询，有时甚至不需要子查询。仅仅因为你<em class="nb">能</em>做并不意味着你<em class="nb">就应该</em>！接下来让我们看看子查询的另一个应用，在我看来，它更有用一些。</p><h2 id="9aff" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">WHERE语句中的子查询</h2><p id="6502" class="pw-post-body-paragraph ks kt iq ku b kv mm jr kx ky mn ju la lb mo ld le lf mp lh li lj mq ll lm ln ij bi translated">我们还能够在条件逻辑中实现子查询。如果我们被要求提供两个可能品牌的产品的平均价格，会怎么样？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">实例4</figcaption></figure><p id="361d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们创建了一个子查询(第6–13行),该子查询隔离了相关品牌名称的品牌id。然后我们编写一个外部查询，查找品牌id与子查询结果相匹配的所有价格的平均值。相当整洁！</p><p id="b2c9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您可能已经注意到，我在这里没有为子查询使用别名。这是因为子查询被视为单个值或一组值，如这里使用<code class="fe lo lp lq lr b">IN</code>的情况，而不是一个表。</p><p id="e1bb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们更进一步…我们可以获得任何与“Strider”和“Trek”产品的平均价格一样贵或更便宜的产品名称和价格吗？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">实例5</figcaption></figure><p id="23e0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">答案是肯定的，我所做的只是将示例4包装在另一个通过<code class="fe lo lp lq lr b">list_price</code>过滤的查询中。</p><h2 id="4553" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">最后</h2><p id="168d" class="pw-post-body-paragraph ks kt iq ku b kv mm jr kx ky mn ju la lb mo ld le lf mp lh li lj mq ll lm ln ij bi translated">在MySQL中有很多方法可以编写有用的子查询，包括这里没有讨论的其他方法，比如连接子查询。我们讲述了如何在<code class="fe lo lp lq lr b">FROM</code>和<code class="fe lo lp lq lr b">WHERE</code>语句中编写子查询，了解了如何将窗口函数与子查询结合使用，甚至在其他子查询中嵌套子查询。</p><p id="e1ee" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">可能性几乎是无限的。您只需要决定在什么情况下您的查询会变得计算量过大并降低运行时间。也就是说，如果你有兴趣学习更多关于子查询和SQL或数据科学的知识，我推荐你查看Mode.com的<a class="ae kr" href="https://mode.com/sql-tutorial/sql-sub-queries/" rel="noopener ugc nofollow" target="_blank">上的资源，因为它们是这篇文章的灵感来源。</a></p></div></div>    
</body>
</html>