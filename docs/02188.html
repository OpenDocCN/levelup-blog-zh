<html>
<head>
<title>Type Signatures — Functional Programming for JavaScript Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型签名—面向JavaScript开发人员的函数式编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/type-signatures-functional-programming-for-javascript-developers-28ea03dc1192?source=collection_archive---------9-----------------------#2020-02-25">https://levelup.gitconnected.com/type-signatures-functional-programming-for-javascript-developers-28ea03dc1192?source=collection_archive---------9-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d480e86315e3e41e607602d6c76dbcdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wp2A9xFW7LbCKFA_X2-sw.png"/></div></div></figure><p id="9be2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果有一种不用理解每一行就能推理出彼此代码的方法，那不是很好吗？如果有一个对所有函数式程序员通用的系统呢？似乎好得难以置信？</p><p id="1848" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将探讨Hindley-Milner型系统。一个帮助你在你的函数上写简单注释的系统，它将提供我们理解正在发生的事情所需要的所有信息。</p><p id="2645" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">欢迎来到面向JavaScript开发人员的函数式编程的第六部分。我们已经非常接近将FP应用到现实世界的水平了。理解本文中提出的概念非常重要，因为您将立即在程序中使用它。类型签名是代码作者和读者之间的纽带。不管你是在一个更大的团队中，还是你既是读者又是作者。</p><h1 id="d145" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">类型</h1><p id="e000" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们从思考什么是<em class="mc">类型</em>开始，以及为什么我们在像JavaScript这样的动态语言中关心它们。重要的是要记住，本系列不是专门针对JavaScript的教程，而是关于函数式编程的。JavaScript是一个很好的学习工具，因为很多人都熟悉它。</p><p id="22c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，请记住，您可以将这些概念带入任何语言。当然，有些语言比其他语言更适合，但是FP仍然是一个全球性的东西。这是关于<em class="mc">如何</em>编码的思维模式。在FP中，<em class="mc">类型</em>对于帮助你推理你的程序非常重要。所以从现在开始，即使你正在编写像JavaScript这样的动态语言，也是时候开始关心类型了。我保证你不会开始使用TypeScript或其他操纵语言的东西。如果你愿意，当然可以，但是我在这里教你的东西都不需要。</p><p id="ffc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不管怎样，什么是<em class="mc">类型？嗯，你已经知道不少了。比如<code class="fe md me mf mg b">String</code>、<code class="fe md me mf mg b">Integer</code>和<code class="fe md me mf mg b">Boolean</code>。同样，如果你读过<a class="ae mh" rel="noopener ugc nofollow" target="_blank" href="/safe-containers-in-javascript-functional-programming-for-javascript-developers-67a32838e9d9">上一篇文章</a>，你就已经了解了<code class="fe md me mf mg b">Maybe</code>和<code class="fe md me mf mg b">Either</code>。一旦它们与另一个类型组合，它们也是类型。例如<code class="fe md me mf mg b">Maybe String</code>是一种<em class="mc">类型。</em>注意，我们写的第一个字母大写。按照惯例，这有助于我们看到我们正在使用一个具体的<em class="mc">类型，</em>而不是更一般的类型。您可能已经猜到，<em class="mc">类型</em>可能是语言中已经存在的类型，或者是我们自己创建的类型。</em></p><h1 id="a46d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我们的第一个签名</h1><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="b878" class="mq la it mg b gy mr ms l mt mu">// myAwesomeVariable :: String<br/>const myAwesomeVariable = 'Time for Type Signatures'</span></pre><p id="012e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嗯，你看看那个美女！这是我能想到的最简单的类型签名。</p><p id="77d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe md me mf mg b">::</code>的左边是变量名，右边是<em class="mc">类型</em>。但是<code class="fe md me mf mg b">::</code>是什么意思呢？它们是“是……的成员”的缩写。所以当你读取这个类型签名的时候，可以翻译成“myAwesomeVariable是String类型的成员”。看，这并不难，对吧？</p><p id="08a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来看下一个。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="70fb" class="mq la it mg b gy mr ms l mt mu">// toUpper :: String -&gt; String<br/>const toUpper = s =&gt; s.toUpperCase();</span></pre><p id="4a70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们介绍箭头<code class="fe md me mf mg b">-&gt;</code>。箭头代表一个函数，左边是输入，右边是输出。注意，我们不关心函数是如何实现的。我们只关心输入和输出。你同意一个名为<code class="fe md me mf mg b">toUpper</code>的函数接受一个<code class="fe md me mf mg b">String</code>并返回一个<code class="fe md me mf mg b">String</code>告诉我们足够开始使用它吗？</p><p id="1dc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再看几个例子:</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="9ff4" class="mq la it mg b gy mr ms l mt mu">// capitalize :: String -&gt; String<br/>const capitalize = s =&gt;<br/>    s.replace (/^./, c =&gt; c.toUpperCase ());</span><span id="a0a1" class="mq la it mg b gy mv ms l mt mu">// add :: Integer -&gt; Integer -&gt; Integer<br/>const add = a =&gt; b =&gt; a + b;</span></pre><p id="16d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看一看<code class="fe md me mf mg b">capitalize</code>。它的实现可能看起来很复杂。但是你真的需要理解那部分才能开始使用它吗？类型签名告诉你，你所需要担心的就是给它传递一个<code class="fe md me mf mg b">String</code>。还有签名承诺你会拿回一个<code class="fe md me mf mg b">String</code>。这个函数的名字至少应该给你一个提示，告诉你这个<code class="fe md me mf mg b">String</code>会是什么样子。</p><p id="70db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们做更高级的签名，<code class="fe md me mf mg b">add</code>。这里我们有两个箭头。让我们来看看我们已经知道的。箭头代表一个函数，左边是输入，右边是输出。现在，关注第一个<code class="fe md me mf mg b">-&gt;</code>。看到<code class="fe md me mf mg b">Integer</code>是输入很容易。但是产量是多少呢？也许如果我把它放在括号里，它会变得更清楚。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="898e" class="mq la it mg b gy mr ms l mt mu">// add :: Integer -&gt; (Integer -&gt; Integer)</span></pre><p id="ccbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你现在明白了吗？第一个函数返回一个新函数，它将一个<code class="fe md me mf mg b">Integer</code>作为输入并返回一个<code class="fe md me mf mg b">Integer</code>。这些括号在开始时可能有用，但是随着你获得更多的经验，你会发现你不需要它们来解释它。至少不是在<code class="fe md me mf mg b">add</code>这么简单的事情上。值得注意的是<code class="fe md me mf mg b">add</code>是一个<a class="ae mh" rel="noopener ugc nofollow" target="_blank" href="/functional-programming-for-javascript-developers-currying-2d16766909e9">化的</a>函数。这是函数式编程中一个非常重要的概念，这样我们就可以<a class="ae mh" rel="noopener ugc nofollow" target="_blank" href="/functional-programming-for-javascript-developers-compose-508d71b4e7b8">组合</a>并部分应用函数。</p><h1 id="d9d3" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">一般类型</h1><p id="6d99" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">有时，我们有一个函数，它适用于任何类型。让我们来看看函数<code class="fe md me mf mg b">head</code>，它接受一个<code class="fe md me mf mg b">Array</code>，并返回那个<code class="fe md me mf mg b">Array</code>中的第一项。这里是<code class="fe md me mf mg b">head</code>的不安全版本(数组为空会崩溃)。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="689c" class="mq la it mg b gy mr ms l mt mu">const head = arr =&gt; arr[0];</span></pre><p id="1735" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回的项目是什么类型的？什么都有可能，对吧？我们如何表达这一点？</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="d159" class="mq la it mg b gy mr ms l mt mu">// head :: Array a -&gt; a</span></pre><p id="ef2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通常使用小写字母来表示任何类型。注意，<code class="fe md me mf mg b">a</code>、<code class="fe md me mf mg b">b</code>、<code class="fe md me mf mg b">c</code>等等很常见。如果你仔细看，这个签名告诉我们一些别的东西。因为我们对输入和输出使用了相同的字母，我们知道我们返回的是<code class="fe md me mf mg b">Array</code>中相同类型的项。太好了，现在我们有了更多的信息。总而言之，通过查看<code class="fe md me mf mg b">head</code>的签名，我们知道它接受<em class="mc"> any type </em>的一个<code class="fe md me mf mg b">Array</code>，并返回一个与<code class="fe md me mf mg b">Array</code>包含的类型相同的单个项目。有了这个名字<code class="fe md me mf mg b">head</code>，我现在对这个函数的功能有了一个很好的直觉。</p><p id="4b86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为参考，让我们也为安全版本写签名。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="82ab" class="mq la it mg b gy mr ms l mt mu">// head :: Array a -&gt; Maybe a</span></pre><p id="7c7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个版本告诉我，我现在可以安全地调用这个函数了，我要么得到一个<code class="fe md me mf mg b">Just(a)</code>要么得到一个<code class="fe md me mf mg b">Nothing</code>返回。如果你不知道我现在在说什么。请阅读关于<a class="ae mh" rel="noopener ugc nofollow" target="_blank" href="/safe-containers-in-javascript-functional-programming-for-javascript-developers-67a32838e9d9">安全容器</a>的文章。</p><p id="05b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请记住，有些函数可以返回与输入完全不同的内容。以<code class="fe md me mf mg b">Array</code>的长度为例。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="57be" class="mq la it mg b gy mr ms l mt mu">// length :: Array a -&gt; Integer</span></pre><p id="6e5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">试着看看这个签名，看看你能不能自己写这个函数。</p><h1 id="14ca" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">类型约束和函子</h1><p id="e33d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">为了教你关于类型签名的下一部分，我需要介绍一个新的可能很难的单词。在之前的一篇文章中，我谈到了<code class="fe md me mf mg b">map</code>以及它可以在许多不同的<em class="mc">类型上工作的事实，</em>不仅仅是数组。嗯，有一个数学词汇可以用来描述可以被映射的<em class="mc">类型</em>。这些<em class="mc">类型</em>的例子有<code class="fe md me mf mg b">Array</code>、<code class="fe md me mf mg b">Either</code>和<code class="fe md me mf mg b">Maybe</code>。这个词就是<code class="fe md me mf mg b">Functor</code>。将它称为<code class="fe md me mf mg b">mappable</code>或类似的东西很有诱惑力，但我们真的想忠于已经建立的数学术语。所以请原谅我。这些词我会在后面的文章里多教你一些(有不少)。</p><p id="413f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，为了简单起见，我们假设<code class="fe md me mf mg b">Array</code>是一个<code class="fe md me mf mg b">Functor</code>(这种说法不完全正确，但是现在不用担心这个)。为什么知道这一点很重要？嗯，因为现在你知道你可以安全地克服它。没有这些知识，我不可能为<code class="fe md me mf mg b">map</code>函数写出一个好的签名。</p><p id="2c8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想想吧。不写很多字，我们如何表达可以被映射的东西？</p><p id="07cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个签名的例子，如果它只对数组有效的话(请注意，这是我们在以前的文章中定义的<code class="fe md me mf mg b">map</code>函数)。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="7e2b" class="mq la it mg b gy mr ms l mt mu">//    map :: (a -&gt; b) -&gt; Array a -&gt; Array b<br/>const map = f =&gt; xs =&gt; xs.map(x =&gt; f(x));</span><span id="726a" class="mq la it mg b gy mv ms l mt mu">// The function is used like this:<br/>map (item =&gt; item + 1) ([1, 2, 3]) // [2, 3, 4] </span></pre><p id="5113" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我用一张图来解释一下这个。因为乍一看它相当复杂。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/4a3d47174f8555cec378e7954c123e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_rhWaDUNhMw7L7dvfKYFw.png"/></div></div></figure><p id="fba8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请花点时间真正理解这个签名。一旦你理解了这一点，你就非常接近阅读签名的专家了。</p><p id="7d95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我真的希望你明白这一点。因为现在我们要制作一个适用于所有<code class="fe md me mf mg b">Functors</code>的签名，而不仅仅是<code class="fe md me mf mg b">Array</code>。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="9c0a" class="mq la it mg b gy mr ms l mt mu">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></pre><p id="305d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以左边的粗箭头<code class="fe md me mf mg b">=&gt;</code>是为了给你更多关于右边的字母是什么意思的提示。为了真正把它注入你的大脑，让我们用一些<code class="fe md me mf mg b">Functors</code>代替<code class="fe md me mf mg b">f</code>。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="f2aa" class="mq la it mg b gy mr ms l mt mu">// map :: Functor Array =&gt; (a -&gt; b) -&gt; Array a -&gt; Array b</span><span id="fb26" class="mq la it mg b gy mv ms l mt mu">// map :: Functor Maybe =&gt; (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</span></pre><p id="196e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这有道理吗？记住，最后两个只是你如何在头脑中转换类型约束的例子。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="8b8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，这基本上是你现在需要知道的关于类型签名的全部内容。我建议你立即开始使用它们。这需要一点时间来适应。如果您不确定自己的某个函数的正确签名是什么样子，请随时问我。我很乐意帮忙。</p><p id="6d22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们试图推理代码时，类型签名是我们首先要考虑的。有些人说很难理解功能代码。好吧，开始为他们解释类型签名。这将表明，它不必像最初看起来那么复杂。</p><p id="0c15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本系列的其余部分，我将使用类型签名。对我来说，在这之前没有用完它们真的很痛苦。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="60fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哇，你已经走了很长一段路。你应该拍拍自己的背。仍然想知道这个词是什么意思。在下一篇文章中，我将尝试进一步澄清这一点。下次见！快乐的函数式编程！</p></div></div>    
</body>
</html>