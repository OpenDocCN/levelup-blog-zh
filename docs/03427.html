<html>
<head>
<title>An Introduction to Regression in Python with statsmodels and scikit-learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用statsmodels和scikit-learn介绍Python中的回归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-introduction-to-regression-in-python-with-statsmodels-and-scikit-learn-9f75c748f56e?source=collection_archive---------1-----------------------#2020-05-08">https://levelup.gitconnected.com/an-introduction-to-regression-in-python-with-statsmodels-and-scikit-learn-9f75c748f56e?source=collection_archive---------1-----------------------#2020-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jp jq jr js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi jo"><img src="../Images/4f32d09a8265bb4fe40f253e72362ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PF7y6A90LOhInv2f"/></div></div><figcaption class="jz ka gj gh gi kb kc bd b be z dk translated">瑞安·塞尔在<a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="7ead" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">介绍</h1><p id="878f" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我第一次用Python探索回归时，一头扎进了<a class="ae kd" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> <em class="ma"> scikit-learn </em> </a>，这是一个为开发预测模型提供了许多有用工具的包。我运行了一个简单的线性回归模型，并输出了截距、系数和模型拟合指标。作为Python的新手，我的背景主要是统计推断，还没有完全掌握统计学和数据科学之间的区别，于是我花了大量时间寻找输出回归权重的标准误差、置信区间和p值的方法。</p><p id="62fb" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">在我搜索多个来源的信息时，我得到了一致的回应:使用<a class="ae kd" href="https://www.statsmodels.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="ma"> statsmodels </em> </a>包进行统计假设检验。果然，当使用来自<em class="ma"> statsmodels </em>的适当工具运行我的模型时，我能够看到回归权重以及相关的标准误差、置信区间和p值。哎呀！在看到结果的兴奋中，我忽略了文档中显示截距需要显式添加到<em class="ma"> statsmodels </em>中的模型的部分。</p><p id="80bc" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">回想起这段经历，我决定写这篇文章来概述一下<em class="ma"> statsmodels </em>和<em class="ma"> scikit-learn、</em>以及<em class="ma"> </em>作为<em class="ma"> </em>的一些“我希望我开始时就知道的事情”的帖子。</p><h1 id="9b73" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">statsmodels和scikit概述-学习</h1><p id="13fb" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma"> statsmodels </em>被描述为“一个Python模块，它为许多不同的统计模型的估计，以及进行统计测试和统计数据探索提供了类和函数。”scikit-learn提供了“简单高效的预测数据分析工具”从这些描述中可以明显看出，<em class="ma"> statsmodels </em>和<em class="ma"> scikit-learn </em>旨在满足不同的需求。<em class="ma"> statsmodels </em>更强调统计推断和统计假设检验，而<em class="ma"> scikit-learn </em>非常适合预测未观测值是关键的项目。</p><h1 id="af58" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">数据</h1><p id="e707" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这篇文章中的所有例子都使用了皮马印第安人的糖尿病数据，可以从这里下载<a class="ae kd" href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener ugc nofollow" target="_blank"/>。该数据来自一个更大的数据集合，最初由<a class="ae kd" href="https://www.niddk.nih.gov/" rel="noopener ugc nofollow" target="_blank">国家糖尿病、消化和肾脏疾病研究所</a>收集，并提供了768名21岁或以上皮马印第安血统女性的诊断数据。请注意，本文中的分析旨在说明使用Python进行线性回归建模的不同方法，不应用于得出生物医学病理学的实质性结论。</p><p id="e7b3" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">让我们通过导入<em class="ma"> pandas </em>库并加载数据来开始编码过程。出于本文的目的，为了简单起见，我们只保留列<code class="fe mg mh mi mj b">Age </code>和<code class="fe mg mh mi mj b">Glucose</code>。</p><figure class="mk ml mm mn gt js"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a9b6" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">如果您正在执行本文中显示的分析，您需要将数据下载到当前工作目录中名为<code class="fe mg mh mi mj b">data</code>的子目录中，或者在上面的代码块中更改CSV文件的路径。</p><p id="9b9a" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated"><code class="fe mg mh mi mj b">Age </code>栏提供了每个参与者的年龄，以年为单位。<code class="fe mg mh mi mj b">Glucose </code>是通过口服葡萄糖耐量试验测量每个参与者在2小时时的血浆葡萄糖浓度。在目前的分析中，我们将使用年龄来预测参与者的血糖浓度。</p><p id="7602" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">运行<code class="fe mg mh mi mj b">diab.head()</code>可以显示前五行数据。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/e5571744c8571acdcc2c6ac3faa2df00.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*bgli_iF8KxS_wF9esPp9IA.png"/></div></figure><p id="ed76" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">让我们也来看看每个带有<code class="fe mg mh mi mj b">diab.describe()</code>的列的汇总统计数据。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/2a72e05aef300ab2f7cad5e5432e558c.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*H05v_cejekGonkm32LxDpQ.png"/></div></figure><p id="6a34" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">请注意，最小葡萄糖浓度为零。如果你更深入地研究这个数据，你会发现有五个葡萄糖值为零；下一个最小值是44。让我们假设这些零值应被视为缺失数据，并将其从分析中排除。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="eec6" class="mw kf iq mj b gy mx my l mz na">diab = diab.loc[diab["Glucose"] != 0, :]</span></pre><figure class="mk ml mm mn gt js gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/bbc06bf40935759ea8bcc16df82bbd70.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*W1aZxXLNSvFHbBwIIvpSpg.png"/></div></figure><p id="9b72" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">到目前为止，一切顺利。</p><h1 id="62a4" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">探索性数据分析</h1><p id="c292" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们先来看看年龄和血糖的相关性。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="0f9c" class="mw kf iq mj b gy mx my l mz na">diab[["Age", "Glucose"]].corr()</span></pre><figure class="mk ml mm mn gt js gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c930526726a0bb0a49ad4a9b357a24ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*RnLfSEbtU4XUDmRh0Ua4Iw.png"/></div></figure><p id="3568" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">年龄和葡萄糖浓度之间的相关性为0.27，表明适度的正相关关系。这意味着，平均而言，相对于年轻参与者，年长参与者往往具有更高的葡萄糖浓度。我们可以用散点图来显示这种关系，以便更好地了解年龄和血糖水平之间的关系。</p><figure class="mk ml mm mn gt js"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="mk ml mm mn gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi nd"><img src="../Images/2bf48834cbc0e9afac89b232a4e1b0e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6IU_tKyjkUtBievXmiU2w.png"/></div></div></figure><p id="2fa2" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">该散点图显示了随着年龄的增长，血糖水平略微升高的趋势。为了更简洁地说明年龄和葡萄糖之间的关系，我们可以通过散点图中的数据点拟合一条直线，该直线最好地最小化所述直线和各个数据点之间的距离。我们将使用线性回归模型生成这条线。</p><p id="5363" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated"><strong class="le ir">线性回归</strong></p><p id="a070" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">现在简单介绍一下线性回归模型的背景。假设我们有一些数据，在这些数据中我们有一个我们有兴趣预测的结果，让我们称之为<em class="ma"> Y </em>。我们还有另一个变量，我们称之为<em class="ma"> x </em>，我们想用它来预测<em class="ma"> Y </em>。线性模型公式可以写成如下形式。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/98d78d76e5767c6138745876e08c43d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*LyT9fi_FR0hAyuZZq_Sucg.png"/></div></figure><p id="b229" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">等号左边的项是我们对每个单独观察的感兴趣结果的预测值(用下标字母<em class="ma"> i </em>表示)。<em class="ma"> Y </em>上的脱字符号或“帽子”仅仅意味着由相应项表示的值是根据该项右边的等式计算的预测值(与实际观察值相反)。α代表截距，它是当预测值<em class="ma"> x，</em>的值为零时<em class="ma"> Y </em>的预测值。β是回归权重，可以解释为<em class="ma"> Y </em>的预测变化，其中<em class="ma"> x </em>增加一个单位。当预测的结果值被绘制时，它们可以被连接形成一条直线。让我们看看一个线性函数的例子，以便更好地理解。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9c4613fcdb89d93434f7dd197b0153bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ly9y4iTs6iDcfmZL0SST9Q.png"/></div></figure><p id="943a" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">上面画出了函数<strong class="le ir"> Y=10 + 5*x </strong>。直线连接的蓝点代表<em class="ma"> Y </em>在<em class="ma"> x </em>不同值时的预测值。我们的截距(α)是<strong class="le ir"> 10 </strong>。这意味着当<em class="ma"> x </em>的值为零时，<em class="ma"> Y </em>的预测值为10。我们的回归权重(β)是5。图左下方的灰色虚线有助于说明回归权重的作用。随着<em class="ma"> x </em>的值从0变到1(即，我们从左向右水平移动一个空格)，预测值<em class="ma"> Y </em>增加5。因此，当<em class="ma"> x </em>等于1时，<em class="ma"> Y </em>的预测值为<strong class="le ir"> 15 </strong>，因为<strong class="le ir"> 10 + 5*1 = 15 </strong>。或者说，当<em class="ma"> x </em>等于3时，<em class="ma"> Y </em>的预测值为<strong class="le ir"> 25，</strong>因为<strong class="le ir"> 10 + 5*3 = 25 </strong>。</p><p id="bdc4" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">等式中的最后一项ϵ是残差，它是单个观察结果值与观察的相关预测结果之间的差值。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d836960881189c9d9eeec45e314ae573.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*mFtSGX_i3ywJTf-zVmzgmQ.png"/></div></figure><p id="ab3a" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">下图显示了通过一组10个生成的数据点绘制的回归线。每个数据点和回归线之间的垂直线是残差的直观表示。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi nd"><img src="../Images/70e6ca3d6d10ba9b2938f23b43bdfcbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGKqK6G-dleRTVKNW70uyw.png"/></div></div></figure><p id="b440" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">在拟合线性回归模型时，我们希望最小化观察到的结果和预测的结果之间的距离，从而生成一个可以生成尽可能接近实际结果值的预测值的模型。在实践中，通常通过检查基于残差平方和的度量来评估模型与数据点的拟合程度，例如残差平方和的平均值(<a class="ae kd" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_squared_error.html" rel="noopener ugc nofollow" target="_blank"> <em class="ma">均方误差</em> </a>或<a class="ae kd" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.r2_score.html" rel="noopener ugc nofollow" target="_blank"> R </a>)。通过对残差求平方，在给定值<em class="ma"> x </em>下，与预测结果具有相同绝对距离的正负残差值不会相互抵消。事实上，线性回归通常被称为<em class="ma">普通最小二乘(OLS) </em>，反映了对最小化回归直线的平方偏差的重视。</p><p id="b9b3" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">请注意，这里没有讨论线性回归模型的几个基本假设。如果您对使用线性回归模型得出有实质意义的解释感兴趣，我建议您评估您的数据满足这些假设的程度。这个建议已经过时了，现在让我们继续来看看使用<em class="ma"> statsmodels </em>进行回归。</p><h1 id="c416" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">统计模型</h1><p id="5019" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们从用<code class="fe mg mh mi mj b">import statsmodels.api as sm </code>导入<em class="ma"> statsmodels </em>开始。<code class="fe mg mh mi mj b">statsmodels.api</code>有一个<code class="fe mg mh mi mj b">OLS</code>类，允许用户运行线性回归模型。在我们继续之前，回想一下上一节，截距表示预测值为0时结果的预测值。然而，在我们的数据中，最小年龄值是21。</p><p id="3f7e" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">为了确保我们模型的截距值有助于解释与观察到的数据一致，通过从每个年龄值中减去最小值21来重新编码年龄是一个好主意。否则，截距值将外推至年龄为零时的观测值，这在该数据集中不存在(但无论是否从每个观测年龄值中减去最小值，回归权重和模型拟合度量都将相同)。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="e6f2" class="mw kf iq mj b gy mx my l mz na">diab["Age"] = diab["Age"] - diab["Age"].min()</span></pre><p id="1c4d" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">下面的代码创建了一个名为<code class="fe mg mh mi mj b">smOLS</code>的线性回归模型，将葡萄糖浓度作为结果，年龄作为预测值。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="ee18" class="mw kf iq mj b gy mx my l mz na">smOLS = sm.OLS(diab["Glucose"], diab["Age"])</span></pre><p id="757f" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated"><code class="fe mg mh mi mj b">smOLS</code>只包含我们模型的结构信息。因此，如果您在Python shell或Jupyter notebook单元中运行<code class="fe mg mh mi mj b">smOLS</code>，您将得到以下输出:<code class="fe mg mh mi mj b">&lt;statsmodels.regression.linear_model.OLS at 0x1a27daa990&gt; </code>。在这一点上，我们仍然需要使模型符合我们的数据，这可以通过将<code class="fe mg mh mi mj b">fit</code>方法应用于<code class="fe mg mh mi mj b">sm.OLS</code>来实现。所以，让我们用拟合的模型覆盖<code class="fe mg mh mi mj b">smOLS</code>。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="a944" class="mw kf iq mj b gy mx my l mz na">smOLS = sm.OLS(diab["Glucose"], diab["Age"]).fit()</span></pre><p id="d01b" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">即使在使用了<code class="fe mg mh mi mj b">fit</code>之后，运行<code class="fe mg mh mi mj b">smOLS</code>本身仍然不会提供任何输出。要查看拟合模型的完整结果，我们可以使用<code class="fe mg mh mi mj b">smOLS</code>上的<code class="fe mg mh mi mj b">summary</code>。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="580b" class="mw kf iq mj b gy mx my l mz na">smOLS.summary()</span></pre><p id="5529" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">终于有结果了！</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi nh"><img src="../Images/0371ad4467733e9575bf42fcdaa0a0d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkTlUyaS3EwSBeu3GxGgdQ.png"/></div></div></figure><p id="b029" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">这里发生了很多事情，所以我只想关注几个输出。首先，<code class="fe mg mh mi mj b">R-squared (uncentered)</code>的值为0.555。如果我们将R解释为我们的模型所解释的结果中方差的比例，这个值告诉我们，我们的模型——只有一个自变量——解释了血糖水平方差的大约56%。我们一会儿将回到这一点。其次，<code class="fe mg mh mi mj b">Age</code>行中<code class="fe mg mh mi mj b">coef</code>列下的值5.4991为我们的预测因子年龄提供了回归权重。我们可以将该值解释为年龄每增加一年，预测的葡萄糖浓度增加大约5.50。因此，年龄比最小年龄高一岁(即22岁)的参与者预期具有比最小年龄(即21岁)的参与者高约5.50个单位的葡萄糖浓度。</p><p id="d2a4" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated"><code class="fe mg mh mi mj b">std err</code>、<code class="fe mg mh mi mj b">P&gt;|t|</code>、<code class="fe mg mh mi mj b">0.025</code>和<code class="fe mg mh mi mj b">0.975</code>列分别提供标准误差、p值、95%置信区间的下限和95%置信区间的上限。p值0.000告诉我们，在常规显著性水平下，年龄对葡萄糖的影响具有统计学显著性(统计学显著性也是显而易见的，因为95%置信区间没有过零)。我们不久将更详细地考虑统计显著性的概念。</p><p id="fe23" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">注意<em class="ma"> statsmodels </em>也提供了查看特定输出片段的方法。例如，如果我们只想从我们的模型中看到回归权重系数，我们将运行<code class="fe mg mh mi mj b">smOLS.param</code>。运行<code class="fe mg mh mi mj b">dir(smOLS)</code>提供了<code class="fe mg mh mi mj b">smOLS</code>可用的所有特定结果的列表。</p><p id="4ac6" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">现在有了适合数据的模型，我们可以使用<code class="fe mg mh mi mj b">predict</code>在观察值的散点图上绘制模型的回归线。</p><figure class="mk ml mm mn gt js"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="mk ml mm mn gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi nd"><img src="../Images/be2ab5455bbebe21afabb154195917e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjqec_vytG0Wh4Pa4YqC0Q.png"/></div></div></figure><p id="100b" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">查看输出和图，您可能会注意到我们的模型不包括截距项。这是因为<code class="fe mg mh mi mj b">OLS</code>默认排除了拦截。要添加截距，我们可以重写我们的模型，用<code class="fe mg mh mi mj b">add_constant</code>显式地将截距添加到预测器中。</p><figure class="mk ml mm mn gt js"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1d02" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">这是包含截距的输出。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi ni"><img src="../Images/5810002616e23f5ba6a74658eb68fc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7WYemHtd9XpCPX5XB8cJWA.png"/></div></div></figure><p id="34ed" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">此输出中的R值为0.071，远小于模型中的R值0.555(不包括截距)。这里的教训是，当截距从线性回归模型中排除时，R被人为地夸大了(这里的<a class="ae kd" href="https://stats.idre.ucla.edu/other/mult-pkg/faq/general/faq-why-are-r2-and-f-so-large-for-models-without-a-constant/" rel="noopener ugc nofollow" target="_blank">很好地解释了为什么会发生这种情况)。</a></p><p id="0b0b" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">转到输出的中间，我们现在有了一组额外的结果。也就是标记为<code class="fe mg mh mi mj b">const</code>的行，它提供了截取的结果。<code class="fe mg mh mi mj b">const</code>的<code class="fe mg mh mi mj b">coef</code>值113.1837意味着在最小年龄值时，从该模型预测的葡萄糖浓度值大约为113。<code class="fe mg mh mi mj b">Age</code>的<code class="fe mg mh mi mj b">coef</code>值0.6929意味着年龄每增加一岁，葡萄糖浓度预计会增加0.6929。我们可以将来自<em class="ma"> statsmodels </em>输出的截距和回归权重估计值插入到幸福的预测方程中。</p><p id="a577" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated"><strong class="le ir">葡萄糖= 113.1837+ 0.6929*(年龄-21) </strong></p><p id="e9d8" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">基于这个公式，例如，31岁的参与者被预测具有大约120的葡萄糖浓度。</p><p id="e70b" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated"><strong class="le ir">120.1127 = 113.1837+0.6929 *(31–21)</strong></p><p id="4048" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">现在让我们来看看有截距和没有截距的回归线图。</p><figure class="mk ml mm mn gt js"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="mk ml mm mn gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi nd"><img src="../Images/bbc327ddef8a16ae5193189db299713a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VlaB1FF6Oi1ADXCWaLuLg.png"/></div></div></figure><p id="849c" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">来自具有截距的模型的预测线由实线表示，虚线绘出来自没有截距的模型的预测线。包括截距在内，最小年龄时的预测葡萄糖水平约为113；如果没有截距，预测的葡萄糖水平在相同的年龄为零。这两条线也清楚地说明了年龄的不同回归权重。包括截距时，权重为0.6929，但不包括截距时，回归权重为5.4991。因此，当包含截距时，预测线的斜率不像没有截距时那样陡。</p><p id="1268" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">回到<code class="fe mg mh mi mj b">smOLS_int.summary()</code>的输出，<code class="fe mg mh mi mj b">Age</code>的p值仍然小于0.001，表明年龄对葡萄糖的影响具有统计学意义。这一具有统计学意义的结果告诉我们，如果年龄确实对样本人群中的葡萄糖没有影响，那么我们不可能观察到年龄对葡萄糖的影响至少与我们样本中观察到的影响一样大。换句话说，基于我们的研究结果，如果年龄和血糖在我们感兴趣的人群中实际上是不相关的，这将是非常令人惊讶的。因此，我们可以确信，观察到的年龄对葡萄糖的影响不仅仅是我们所拥有的特定样本的人为产物。</p><h1 id="aa5e" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">sci kit-学习</h1><p id="6975" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在<em class="ma"> scikit上-学习</em>。我们将从scikit-learn中的<code class="fe mg mh mi mj b">linear_model</code>模块导入<code class="fe mg mh mi mj b">LinearRegression</code>类开始。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="3d71" class="mw kf iq mj b gy mx my l mz na">from sklearn.linear_model import LinearRegression</span></pre><p id="a682" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">鉴于结果和预测值在<code class="fe mg mh mi mj b">sm.OLS</code>中被指定为参数，在<em class="ma"> scikit-learn </em>中，结果和预测值需要在<code class="fe mg mh mi mj b">fit</code>中指定。需要注意的重要一点是，<code class="fe mg mh mi mj b">LinearRegression</code>默认包含截距，因此我们将能够从符合<code class="fe mg mh mi mj b">LinearRegression</code>的模型中获得截距值，而无需任何额外的工作。</p><p id="1bf1" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">现在，让我们用下面的代码给<code class="fe mg mh mi mj b">sklOLS</code>分配一个合适的模型，看看会发生什么。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="0d16" class="mw kf iq mj b gy mx my l mz na">sklOLS = LinearRegression().fit(diab["Age"], diab["Glucose"])</span></pre><p id="284e" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">啊哦！我们得到一个错误。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="e7eb" class="mw kf iq mj b gy mx my l mz na">ValueError: Expected 2D array, got 1D array instead:</span></pre><p id="5adc" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">在此错误消息的底部，我们看到以下内容。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="975c" class="mw kf iq mj b gy mx my l mz na">Reshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample.</span></pre><p id="e9c9" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">scikit-learn 中的线性回归模型期望我们的预测值包含在一个二维数组中。如果我们用<code class="fe mg mh mi mj b">diab["Age"].shape </code>检查<code class="fe mg mh mi mj b">Age</code>的形状，我们就能发现问题。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="dd16" class="mw kf iq mj b gy mx my l mz na">(763,)</span></pre><p id="c6c2" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">这个输出告诉我们<code class="fe mg mh mi mj b">diab["Age"]</code>有763行没有列，但是我们需要763行和一列。解决方案是将<code class="fe mg mh mi mj b">diab["Age"]</code>转换成一个二维<em class="ma"> NumPy </em>数组。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="356b" class="mw kf iq mj b gy mx my l mz na">X = diab["Age"].to_numpy().reshape(-1, 1)</span></pre><p id="8695" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">在<code class="fe mg mh mi mj b">reshape(-1, 1)</code>中，值-1意味着将从输入中推断行数。值1指定生成的形状必须有一列。让我们用<code class="fe mg mh mi mj b">X.shape</code>来看看<code class="fe mg mh mi mj b">X</code>的形状</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="7fb1" class="mw kf iq mj b gy mx my l mz na">(763, 1)</span></pre><p id="6b06" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">酷豆。763行和一列；现在我们可以重试运行我们的线性回归模型。</p><pre class="mk ml mm mn gt ms mj mt mu aw mv bi"><span id="cba7" class="mw kf iq mj b gy mx my l mz na">sklOLS = LinearRegression().fit(X, diab["Glucose"])</span></pre><p id="f6fa" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">成功！然而，我们无法像在<em class="ma"> statsmodels </em>和<code class="fe mg mh mi mj b">summary</code>中那样获得详细输出的完整表格。要查看截距、权重和R的值，我们需要分别使用<code class="fe mg mh mi mj b">intercept_</code>、<code class="fe mg mh mi mj b">coef</code>和<code class="fe mg mh mi mj b">score</code>。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ca864844e6fc6ed373fc2d5d2f242ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*t_VzsuPHFsGrHSBbVQ_A9w.png"/></div></figure><p id="abe8" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated"><code class="fe mg mh mi mj b">skOLS.intercept_</code>给我们的值是113.1837 <strong class="le ir"> </strong>，<code class="fe mg mh mi mj b">skOLS.coef_</code>返回0.6929，这两个值都与<em class="ma"> statsmodels </em>结果<code class="fe mg mh mi mj b">smOLS_int</code>中的截距和系数值一致。<code class="fe mg mh mi mj b">score</code>返回值0.0714，这也与我们之前从<em class="ma"> statsmodels </em>获得的结果一致。</p><p id="1903" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">如前所述，<em class="ma"> scikit-learn </em>面向预测，因此<em class="ma"> scikit-learn </em>中建模的最终目标很可能是为新数据点生成预测。该任务可以使用<code class="fe mg mh mi mj b">predict</code>完成。回到我们之前预测31岁个体的葡萄糖水平的例子，当输入值为10时，我们可以使用<code class="fe mg mh mi mj b">predict</code>来生成预测(记住，我们需要减去最小年龄值21)。确保首先用<code class="fe mg mh mi mj b">import numpy as np</code>导入<em class="ma"> NumPy </em>来重新创建我在下面用<code class="fe mg mh mi mj b">np.array</code>创建的数组。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi nk"><img src="../Images/f6a9e9d8fe5429c833ed4ee4276fbed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUvJcrnS_6sG9nQQbUl0cQ.png"/></div></div></figure><p id="c9e3" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">如果我们想预测多个值，我们可以在数组中包含更多的值。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi nl"><img src="../Images/fbca4b83196d8a87a57cc73de54ffe76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vWTFk7ptsPIdgKhEp5wOzQ.png"/></div></div></figure><p id="6601" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">请注意，我将数组重新整形为二维数组，因为我们的<em class="ma"> scikit-learn </em>模型仍然期望任何输入都有两行和至少一列。</p><h2 id="3a4a" class="mw kf iq bd kg nm nn dn kk no np dp ko ln nq nr ks lr ns nt kw lv nu nv la nw bi translated">培训和测试数据</h2><p id="05d2" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果我们的目标是使用<em class="ma"> scikit-learn </em>开发高质量的预测，那么我们可以通过评估模型在从未遇到过的数据上的表现来评估我们的模型的预测能力。例如，对于当前的情况，假设我们想要评估我们的模型能够多好地预测PIMA遗传的成年女性的葡萄糖浓度。</p><p id="12a4" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">在这里，我们可以将可用数据随机分为训练和测试数据集，以评估我们的模型的预测性能。训练数据是我们用来寻找实际回归公式的数据的子集。然后，可以将该公式应用于测试数据，我们可以检查得到的R，以了解模型在未用于训练模型的数据上的表现。因此，测试数据作为观察到年龄而未观察到葡萄糖的新数据点的代理。</p><p id="d849" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">我们的原始数据可以通过<em class="ma"> scikit-learn </em>中的<code class="fe mg mh mi mj b">train_test_split</code>函数方便地分成训练集和测试集。以下代码使用<code class="fe mg mh mi mj b">train_test_split</code>返回以下内容:一个名为<code class="fe mg mh mi mj b">X_train</code>的预测值训练数据集，一个名为<code class="fe mg mh mi mj b">X_test</code>的预测值测试数据集，以及分别名为<code class="fe mg mh mi mj b">y_train</code>和<code class="fe mg mh mi mj b">y_test</code>的结果值训练和测试数据集。</p><figure class="mk ml mm mn gt js"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1802" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">所示示例将原始数据的80%采样到训练集中，20%采样到测试集中。如果我们想要一个不同的分割，比如说10%进入测试集，我们可以将<code class="fe mg mh mi mj b">test_size</code>参数的值从0.2更改为0.1。<code class="fe mg mh mi mj b">random_state</code>参数为<code class="fe mg mh mi mj b">train_test_split</code>中使用的随机发生器设置种子。如果您为随机种子设置不同的数字，您将获得不同的结果，因为<code class="fe mg mh mi mj b">train_test_split</code>将随机抽取不同的值到训练集和测试集中。</p><p id="c9a8" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">让我们对训练数据拟合线性回归模型，并评估得到的R。</p><figure class="mk ml mm mn gt js"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="mk ml mm mn gt js gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5822a282c6c9af7fa933d8849c2abb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yi6AguPOLvJX8lEQVzP6dw.png"/></div></figure><p id="2c02" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">我们得到R为0.0764。但是这个模型在测试数据上表现如何呢？我们可以通过对测试数据运行<code class="fe mg mh mi mj b">sklOLS_train.score</code>来找出答案。</p><figure class="mk ml mm mn gt js gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/ae954a37062e04949d9b66176a185801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*4s7TigUZj8lvHd5F2E8gGg.png"/></div></figure><p id="3071" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">发生了什么事？来自训练数据的R不是很大，但是来自测试数据的R甚至更小。这是一种过度拟合的情况，意味着模型在新数据上的表现不如在用于拟合模型的数据上的表现。这并不奇怪。我们拥有的模型是一个过程的结果，该过程旨在为训练数据中的观察值提供最佳预测，因此我们可以预计该模型不会很好地适合它以前从未“见过”的数据。虽然超出了本文的范围，但值得注意的是，有一些方法可以减少过度拟合，从而提高模型的泛化能力。例如，重采样技术，如<a class="ae kd" href="https://scikit-learn.org/stable/modules/cross_validation.html#cross-validation" rel="noopener ugc nofollow" target="_blank"><em class="ma">k</em>-折叠交叉验证</a>，可以用作模型评估过程的一部分。当然，我们还想看看是否可以在训练和测试数据中获得更高的R，也许是通过在模型中包括更多的预测因子和/或拟合不同类型的模型。</p><h1 id="e94a" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">结论</h1><p id="a859" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">statsmodels 和<em class="ma"> scikit-learn </em>都是非常有用的软件包，但是每一个都更适合不同的任务。<em class="ma"> statsmodels </em>为统计假设测试提供了便利的工具，而<em class="ma"> scikit-learn </em>提供的功能则面向生成能够做出有用预测的模型。因此，选择使用一个包还是另一个包应该由给定项目的需求来决定。我希望这篇文章对你有所帮助，如果你处在我的位置，也就是刚刚开始数据科学和Python编程之旅，我特别希望这篇文章有助于让你的旅程更加顺利。</p><p id="6f88" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">感谢你阅读这篇文章。如果你喜欢这篇文章，请跟我来，期待更多的文章即将到来。如果你不喜欢这篇文章…请跟我来，期待更多的文章即将到来。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="d62b" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">本文中的例子假设您对Python的基本概念有所了解。</p><p id="0bf6" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">简介-stats模型。(未注明)。检索于2020年3月1日，来自<a class="ae kd" href="https://www.statsmodels.org/stable/index.html" rel="noopener ugc nofollow" target="_blank">https://www.statsmodels.org/stable/index.html</a></p><p id="d4ee" class="pw-post-body-paragraph lc ld iq le b lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv mf lx ly lz ij bi translated">sci kit-learn:Python中的机器学习。(未注明)。检索于2020年3月1日，来自<a class="ae kd" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/stable/</a></p></div></div>    
</body>
</html>