<html>
<head>
<title>Using TypeScript — Extending Generic Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript —扩展泛型类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-typescript-extending-generic-types-2c18459934ea?source=collection_archive---------0-----------------------#2020-06-19">https://levelup.gitconnected.com/using-typescript-extending-generic-types-2c18459934ea?source=collection_archive---------0-----------------------#2020-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2ba75e92beff8cbeb699185b7ccf58de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vvEFIAXBkgZ-laAb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">鲍里斯·斯莫克罗维奇在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ddb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript是JavaScript的自然扩展，在许多项目中取代了JavaScript。</p><p id="cc57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，并不是每个人都知道它实际上是如何工作的。</p><p id="ec06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何在TypeScript中扩展泛型类型。</p><h1 id="390c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">扩展泛型类</h1><p id="9aa9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以给现有的类添加额外的特性。</p><p id="f756" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6749" class="mq lf it mm b gy mr ms l mt mu">class Collection&lt;T extends { name: string }&gt; {<br/>  protected items: T[] = [];<br/>  constructor(items: T[]) {<br/>    this.items.push(...items);<br/>  }<br/>  add(items: T) {<br/>    this.items.push(items);<br/>  }<br/>  remove(index: number) {<br/>    this.items.splice(index, 1);<br/>  }<br/>  getItem(index: number): T {<br/>    return this.items[index];<br/>  }<br/>}</span><span id="09b9" class="mq lf it mm b gy mv ms l mt mu">class SearchableCollection&lt;T extends { name: string }&gt; extends Collection&lt;T&gt; {<br/>  find(name: string): T | undefined {<br/>    return this.items.find(item =&gt; item.name === name);<br/>  }<br/>}</span></pre><p id="fea7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们有<code class="fe mw mx my mm b">T</code>必须匹配的<code class="fe mw mx my mm b">{ name: string }</code>类型。</p><p id="922d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至少我们需要<code class="fe mw mx my mm b">name</code>字符串属性。</p><p id="63d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="80dc" class="mq lf it mm b gy mr ms l mt mu">interface Person {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="0b2a" class="mq lf it mm b gy mv ms l mt mu">const persons: SearchableCollection&lt;Person&gt; = new SearchableCollection&lt;Person&gt;([<br/>  {<br/>    name: "james",<br/>    age: 1<br/>  }<br/>]);</span></pre><p id="be6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">Person</code>有<code class="fe mw mx my mm b">name</code>字符串属性和<code class="fe mw mx my mm b">age</code>数字属性，但是我们仍然可以使用它。</p><p id="6ae2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只要对象有<code class="fe mw mx my mm b">name</code>属性，并且它的值是字符串，我们就可以使用它。</p><h1 id="b5c7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">限制泛型类型参数</h1><p id="3cf1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以指定一个比type参数中指定的更严格的类型。</p><p id="593c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6161" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  name: string;<br/>  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="9cfd" class="mq lf it mm b gy mv ms l mt mu">class Owner extends Person {<br/>  name: string;<br/>  age: number;<br/>  constructor(name: string, age: number) {<br/>    super(name);<br/>    this.age = age;<br/>  }<br/>}</span><span id="4348" class="mq lf it mm b gy mv ms l mt mu">class Collection&lt;T extends Person | Owner&gt; {<br/>  private items: T[] = [];<br/>  constructor(items: T[]) {<br/>    this.items.push(...items);<br/>  }</span><span id="8c76" class="mq lf it mm b gy mv ms l mt mu">  add(items: T) {<br/>    this.items.push(items);<br/>  }</span><span id="f731" class="mq lf it mm b gy mv ms l mt mu">  remove(index: number) {<br/>    this.items.splice(index, 1);<br/>  }</span><span id="66b8" class="mq lf it mm b gy mv ms l mt mu">  getItem(index: number): T {<br/>    return this.items[index];<br/>  }<br/>}</span></pre><p id="42f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过编写以下代码将其用于更具限制性的类型:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cb3a" class="mq lf it mm b gy mr ms l mt mu">const items: Collection&lt;Owner&gt; = new Collection&lt;Owner&gt;([new Owner("james", 1)]);</span></pre><p id="1d65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">Owner</code>比<code class="fe mw mx my mm b">Person</code>更严格，因为它是<code class="fe mw mx my mm b">Person</code>的子类。</p><p id="fa02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们试图将一个<code class="fe mw mx my mm b">Person</code>实例添加到我们传递给构造函数的数组中，我们会得到一个错误。</p><p id="40ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4c61" class="mq lf it mm b gy mr ms l mt mu">const items: Collection&lt;Owner&gt; = new Collection&lt;Owner&gt;([<br/>  new Owner("james", 1),<br/>  new Person("jane")<br/>]);</span></pre><p id="8776" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到错误“Person”类型中缺少“age”属性，但“Owner”类型中需要该属性。</p><h1 id="73e5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">泛型类的静态方法</h1><p id="4259" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在泛型类中定义一个静态方法。</p><p id="4c4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a549" class="mq lf it mm b gy mr ms l mt mu">class Collection&lt;T extends Person | Owner&gt; {<br/>  private items: T[] = [];<br/>  constructor(items: T[]) {<br/>    this.items.push(...items);<br/>  }</span><span id="481b" class="mq lf it mm b gy mv ms l mt mu">  add(items: T) {<br/>    this.items.push(items);<br/>  }</span><span id="767d" class="mq lf it mm b gy mv ms l mt mu">  remove(index: number) {<br/>    this.items.splice(index, 1);<br/>  }</span><span id="db3b" class="mq lf it mm b gy mv ms l mt mu">  static getItem(items: any[], index: number) {<br/>    return items[index];<br/>  }<br/>}</span></pre><p id="db69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用了关键字<code class="fe mw mx my mm b">static</code>来表示<code class="fe mw mx my mm b">getItem</code>是一个静态方法。我们不能用静态方法引用任何泛型类型参数。静态方法是一个类的所有实例之间的共享。</p><p id="da24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以<code class="fe mw mx my mm b">getItem</code>通过写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2ca3" class="mq lf it mm b gy mr ms l mt mu">const item: number = Collection.getItem([1, 2, 3], 1);</span></pre><p id="08a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想给静态方法添加泛型类型参数，那么我们必须添加类没有使用的类型参数。</p><p id="2805" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a173" class="mq lf it mm b gy mr ms l mt mu">class Collection&lt;T extends Person | Owner&gt; {<br/>  private items: T[] = [];<br/>  constructor(items: T[]) {<br/>    this.items.push(...items);<br/>  }</span><span id="9c90" class="mq lf it mm b gy mv ms l mt mu">  add(items: T) {<br/>    this.items.push(items);<br/>  }</span><span id="9390" class="mq lf it mm b gy mv ms l mt mu">  remove(index: number) {<br/>    this.items.splice(index, 1);<br/>  }</span><span id="a0f3" class="mq lf it mm b gy mv ms l mt mu">  static getItem&lt;A&gt;(items: A[], index: number) {<br/>    return items[index];<br/>  }<br/>}</span></pre><p id="f1a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加了<code class="fe mw mx my mm b">A</code>数据类型占位符，它没有在其他地方使用。</p><p id="98e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过编写以下代码来调用该方法:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="edd2" class="mq lf it mm b gy mr ms l mt mu">const item: number = Collection.getItem&lt;number&gt;([1, 2, 3], 1);</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/7e6ef282591cd496fa0213fb244db170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NknUm1BkAGMJfl_G"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@meric?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅里达勒</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="17d9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">通用接口</h1><p id="c4ef" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以定义通用接口。</p><p id="4efb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="68a8" class="mq lf it mm b gy mr ms l mt mu">type Person = {<br/>  name: string;<br/>};</span><span id="3ca2" class="mq lf it mm b gy mv ms l mt mu">interface Collection&lt;T extends Person&gt; {<br/>  add(...members: T[]): void;<br/>}</span></pre><p id="8ef0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以创建一个类或一个对象，它具有接受一个数组的<code class="fe mw mx my mm b">add</code>方法，该数组包含具有<code class="fe mw mx my mm b">Person</code>成员的<code class="fe mw mx my mm b">T</code>类型的对象。</p><p id="2ec6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦有了这些，我们就可以如下使用接口:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="44b5" class="mq lf it mm b gy mr ms l mt mu">class DataCollection implements Collection&lt;Person&gt; {<br/>  members: Person[] = [];<br/>  add(...members: Person[]) {<br/>    this.members.push(...members);<br/>  }<br/>}</span></pre><p id="4ab0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe mw mx my mm b">T</code>设置为<code class="fe mw mx my mm b">Person</code>，然后使用<code class="fe mw mx my mm b">Collection</code>接口来执行我们的实现。</p><h1 id="22da" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="4fb1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以向类方法、静态方法和接口添加泛型类型参数。</p><p id="ee2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以扩展泛型类来创建它们的子类，这些子类也是泛型的。</p><p id="2bb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，接口也可以扩展。</p></div></div>    
</body>
</html>