<html>
<head>
<title>Single-File Executables in .NET Core 3.1 and the Quest for a Sub-50MB Docker Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中的单文件可执行文件。NET Core 3.1和对低于50MB Docker容器的追求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/single-file-executables-in-net-core-3-1-and-the-quest-for-a-sub-50mb-docker-container-f44cb1274121?source=collection_archive---------8-----------------------#2020-07-29">https://levelup.gitconnected.com/single-file-executables-in-net-core-3-1-and-the-quest-for-a-sub-50mb-docker-container-f44cb1274121?source=collection_archive---------8-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/59ded1952b8264c4a51fc6f385e99d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDNRDYHq2hhc34iEU7qBUQ.png"/></div></div></figure><p id="b26c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回购:<a class="ae kw" href="https://github.com/atkinsonbg/netcore-small-docker-image" rel="noopener ugc nofollow" target="_blank">https://github.com/atkinsonbg/netcore-small-docker-image</a></p><p id="cee3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我一直在建造。NET Core Web API微服务已经有一段时间了，我一直很喜欢它。然而，就Docker图像大小而言，它无法与使用SCRATCH base图像的Golang API相提并论。我的一些作品图片是用。NET Core 2.0通常在200-300 MB左右。虽然Go速度很快，编译起来也非常好，但我发现语言和工具还有待改进，有时我仍然渴望Visual Studio和它所有的语法。随着的发布。NET Core 3.1 LTS去年，我决定是时候重新使用它来构建一个小型WebAPI容器了。</p><p id="4674" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这趟旅程有几个要求。这些是我为自己设定的目标，目的是挑战极限。在这个实验中。</p><ul class=""><li id="484e" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">仅Linux环境</strong>:这些微服务将部署在Kubernetes上的Docker容器中，因此Linux环境是必须的。</li><li id="8aa3" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">微小的集装箱足迹</strong>:突突。NET Core降到10MB以下很可能是不可能的，但目标是50MB。</li><li id="98fb" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">没有多级Dockerfile </strong>:大部分的在线例子。容器中的. NET核心API使用多阶段docker文件。我不想把这个要求作为项目的一部分。多阶段Docker构建非常好，但是会带来复杂性和时间。另外。NET Core 3.0，不再需要这个了。</li><li id="ad9d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> MacOS开发环境</strong>:我的开发环境是MacOS，所以这个对我来说是硬性要求。</li></ul></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="f4f9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">搭建WebAPI</h1><p id="dbb1" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">让我们开始建造一个基地。Visual Studio核心WebAPI。我们将使用“新建项目”向导，并从。网络核心应用“左手导航。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/8cf9961a68f875487c35e4ecf5b389fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzeGXNdakgeouPWowGJrSA.png"/></div></div></figure><p id="2465" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将选择我们的运行时”。网芯3.0”当然。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/52822b806acb702be7224f9e36d29c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8WJM49Vr_gWEAOb6zaHtQ.png"/></div></div></figure><p id="9def" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为参考，我将我的解决方案命名为“Singlefile ”,将我的WebAPI项目命名为“Medium ”,这在Visual Studio中产生了以下结构。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6eb898d7e9f9ec6c1c0a370c14aee332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*VX17WnIH6ilA0vzlyy9QOw.png"/></div></figure><p id="dc05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将为我们提供一个具有单个控制器(WeatherForecastController)和GET端点的基本WebAPI框架。如果你不熟悉。NET Core WebAPI，默认的现成API是返回天气数据的单端点API。这对于本教程来说已经足够了。此时，您可以构建并运行API，以确保一切都正确连接。如果一切正常，您应该会获得一些不错的天气数据。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/7a153b188c595173f3115bff5bac7e75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zC2e80RJ1zxs3ICyb5QDfw.png"/></div></div></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="42eb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">修改。csproj文件</h1><p id="3133" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们需要修改我们的。csproj项目文件使用<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#assembly-linking" rel="noopener ugc nofollow" target="_blank">程序集链接</a>，通过指定“PublishTrimmed”属性。这个属性将导致<a class="ae kw" href="https://github.com/mono/linker" rel="noopener ugc nofollow" target="_blank"> IL链接器</a>工具在您发布API时运行。该工具扫描您的代码，检测任何没有被利用的库，并将它们从您发布的API中移除。这极大地减小了项目的大小，并保持了较小的容器大小。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="c8d1" class="ng lt iq nc b gy nh ni l nj nk">&lt;PropertyGroup&gt;<br/>    &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework<br/>    &lt;PublishTrimmed&gt;true&lt;/PublishTrimmed&gt;<br/>    &lt;CrossGenDuringPublish&gt;false&lt;/CrossGenDuringPublish&gt; &lt;/PropertyGroup&gt;</span></pre><p id="3369" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还包括“CrossGenDuringPublish”属性，并将其设置为false。</p><p id="b14b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nl">关于这个财产的免责声明，我在另一个博客</em>  <em class="nl">上发现了它，目前它还没有在任何地方被记录。也就是说，它是IL链接器的一个标志，基本上告诉它在发布时只关注目标运行时。例如，如果我们发布的是“linux-x64 ”,只针对这个目标，不要担心ARM或macOS。我倾向于把它留在家里，因为我不确定是否还需要它，但把它放在那里也不会有什么坏处。</em></p><p id="d728" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些是我们将在中设置的唯一属性。这项工作的csproj文件。我们需要指定的其他属性将通过“dotnet publish”命令来完成。这样做的原因是我们希望能够从Visual Studio中调试API，我们将讨论的下一个属性使这成为不可能，并且我们可以通过CLI轻松地传递它们。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="30eb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">。网络发布命令</h1><p id="3699" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">接下来，我们将检查进一步减小API大小所需的发布命令:</p><p id="f0b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">" dot net publish-r Linux-musl-x64-p:PublishSingleFile = true-c Release-o ./deploy "</strong></p><p id="6367" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们解包这个命令:</p><ul class=""><li id="c4c9" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir"> -r linux-musl-x64 </strong>:为构建设置<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish?tabs=netcore21#options" rel="noopener ugc nofollow" target="_blank">运行时标识符(RID) </a>。关注这些标识符非常重要。在本文中，我们的目标是Linux x64 Alpine Docker映像，因此我们必须使用“Linux-musl-x64”RID。如果您只是将“Linux-x64”RID作为目标，那么API将无法在容器中启动。阿尔卑斯山的图像很小，我们想要小的！</li><li id="b548" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">-p:PublishSingleFile = true</strong>:该参数将API打包成一个特定于平台的<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#single-file-executables" rel="noopener ugc nofollow" target="_blank">单文件可执行文件</a>。拥有一个单文件可执行文件有很多好处。例如，您可以指定要从包中排除的文件。对于这篇文章，它将简化我们的docker文件，这很好。</li><li id="1143" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> -c发布</strong>:如果你有经验。你已经知道这个了。如果没有，它是一个标志，指示使用哪个构建配置，在本例中是发布或生产。</li><li id="b5ae" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> -o ./deploy </strong>:这是输出标志，我们希望发布的工件进入一个特定的文件夹。</li></ul><p id="8fec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行这个publish命令将构建我们的API，并在我们指定的“deploy”文件夹中输出一个可执行文件。对于这个项目，可执行文件被命名为“Medium ”,这是我们的解决方案中项目的名称。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/7fc22257d7c83d0ed7654444626496fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TRqFV6Z-MgF96pGKwbjxg.png"/></div></div></figure><p id="b4fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会注意到，在发布过程中，文件夹中放置了一些额外的文件。您确实可以控制将哪些文件放在输出文件夹以及可执行文件中。虽然我们不会在本帖中涉及它们，但也许改天，你可以在这里阅读更多关于<a class="ae kw" href="https://github.com/dotnet/designs/blob/master/accepted/single-file/design.md#the-bundler" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="9cb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以查看可执行文件的属性，并看到我们即将达到惊人的55.8MB！</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e78f21ba17474d7b3d5d403cef997a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*yrc9_AQfElZ47RG6ZEEsdg.png"/></div></figure><p id="6b1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你一直在和。无论多少时间，这个数字都会让你很开心。虽然有可能制造小型的独立装置。NET核心应用程序，分别使用像<a class="ae kw" href="https://github.com/mono/linker" rel="noopener ugc nofollow" target="_blank"> IL链接器</a>和<a class="ae kw" href="https://github.com/dgiagio/warp" rel="noopener ugc nofollow" target="_blank"> Warp </a>这样的工具，将所有这些都包装在。NET CLI让它变得如此简单。</p><p id="be14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经有了可执行文件，让我们集中精力让它在Docker容器中运行。就像publish命令中的运行时标识符一样，我们也必须密切注意我们使用的基本Docker映像。例如，如果你去<a class="ae kw" href="https://hub.docker.com/_/microsoft-dotnet-core" rel="noopener ugc nofollow" target="_blank">。Docker Hub上的NET Core页面</a>你会发现很多选项:。NET核心SDK，ASP.NET核心运行时，。NET核心运行时等。因为我们是为Alpine Linux容器编译的，所以我们需要关注<a class="ae kw" href="https://hub.docker.com/_/microsoft-dotnet-core-runtime-deps/" rel="noopener ugc nofollow" target="_blank">。NET核心运行时依赖关系</a>基础镜像。该页面上的描述说明了一切:<em class="nl">“该映像包含。网芯。它不包括。网芯。它适用于独立的应用程序。”</em></p><p id="1f43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使在这个页面上，仍然有许多标签可供选择:3 . 1 . 0-巴斯特-苗条，3 . 1 . 0-仿生，等等。同样，我们的目标是Alpine，以便获得尽可能最小的容器，所以我们将选择<strong class="ka ir"> 3.1.0-alpine3.10 </strong>标签。Docker Hub给你一个链接，链接到图片的Docker文件，如果你<a class="ae kw" href="https://github.com/dotnet/dotnet-docker/blob/dcb185a49e2ed8e7a40cf4bbce522853ba5f1b8d/3.0/runtime-deps/alpine3.10/amd64/Dockerfile" rel="noopener ugc nofollow" target="_blank">仔细看</a>你会发现里面没有很多。他们基本上安装了一些。NET Core来运行，并设置到端口80的绑定。作为参考，您可以看到基本图像大小变化很大。NET核心运行时依赖Alpine标签是明显的赢家:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/31014f3049a0bcf3b66b9a8ad02530ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S2VWSMZDXuFvFT2Z4hcMNw.png"/></div></div></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="9727" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">Dockerfile —错误的方式</h1><p id="2f96" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">现在我们准备编写Dockerfile并运行这个API。对于单个可执行文件，这再简单不过了:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="a231" class="ng lt iq nc b gy nh ni l nj nk">FROM mcr.microsoft.com/dotnet/core/runtime-deps:3.1.0-alpine3.10<br/>COPY deploy/Medium medium<br/>CMD [“./medium”]</span></pre><p id="d3cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们甚至不需要解压缩这个文件，它是如此简单和直接，但我们还是要这样做。拉底座。NET核心运行时依赖Docker镜像，复制我们发布的可执行文件，然后运行它。我们可以使用标准的Docker build命令"<strong class="ka ir"> docker build -t medium来构建这个映像。</strong>“生成的图像只有65.5MB！</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/07bab06b44aab5b4d9f1c8defff1e3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0I6rYieoLQZX4PqYFSEQg.png"/></div></div></figure><p id="dfb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们发出一个Docker run命令，看看是否一切正常，" docker run -p 80:5000 medium "</p><blockquote class="no np nq"><p id="3fee" class="jy jz nl ka b kb kc kd ke kf kg kh ki nr kk kl km ns ko kp kq nt ks kt ku kv ij bi translated">仅供参考，在Linux中，只有根用户可以在低于1024的端口上启动进程。现在，我们的API被配置为在端口5000上运行，所以我们很好。但是当你继续你的码头之旅时，请记住这一点。</p></blockquote><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/35e0e3e69b6d0fc312ee3cf1b6197dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NCDEPRELbs1hO7PXUvh4QQ.png"/></div></div></figure><p id="2717" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该看到API启动时没有任何问题，然后您可以通过Postman或任何其他REST客户端调用它。这很简单，但不一定是制作docker文件的最佳方式。这里的主要问题是API是由root用户运行的。Docker的最佳实践是在容器中以非特权用户的身份运行您的流程。为了实现这一点，我们需要对API和Dockerfile做一些简单的修改。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="5473" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">Dockerfile —正确的方式</h1><p id="81c2" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">让我们把docker文件改得更安全一点:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="1086" class="ng lt iq nc b gy nh ni l nj nk">FROM mcr.microsoft.com/dotnet/core/runtime-deps:3.1.0-alpine3.10 WORKDIR /api <br/>RUN addgroup -S mediumgroup &amp;&amp; \     <br/>    adduser -S mediumuser USER mediumuser <br/>COPY --chown=mediumuser:mediumgroup deploy/Medium medium <br/>ENV ASPNETCORE_URLS=http://+:5000 <br/>CMD ["./medium"]</span></pre><p id="bd02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个docker文件中还有很多东西需要解开，让我们开始吧:</p><ul class=""><li id="9f60" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">FROM</strong>——就像之前我们把Docker形象建立在。NET核心运行时依赖库。</li><li id="2588" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">工作目录</strong> —我们在做任何事情之前都会设置一个工作目录。这很好，因为它将我们复制的任何内容都移动到它自己的目录中。如果我们需要“执行”容器中的任何内容，这样会更干净。</li><li id="5dbe" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">运行</strong>添加组&amp;添加用户——接下来我们创建一个新的组和用户，供API运行。</li><li id="ac59" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">USER</strong>—USER命令设置运行映像时使用的用户帐户，以及docker文件中其后的任何指令。此时，我们不再以root用户身份运行。这是一个关键的安全问题。如果攻击者能够获得对容器的访问权限，他们就处于“mediumuser”的上下文中，而不是根用户。</li><li id="9bd8" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">复制</strong> —我们使用“— chown”命令复制API可执行文件，使我们的新“mediumuser”成为文件的所有者。</li><li id="b22e" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> ENV ASPNETCORE_URLS </strong> —我们必须将ASPNETCORE_URLS环境变量更新为在“appsettings.json”文件中定义的新端口。如果你看一下。NET核心运行时依赖项Dockerfile，它被设置为端口80。我们需要覆盖它。</li><li id="b8f4" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> CMD </strong> —最后，我们可以用RUN命令启动我们的可执行程序。</li></ul><p id="c11d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们发出一个Docker run命令，看看是否一切正常，这次使用我们新的端口映射，"<strong class="ka ir">Docker run-p 80:5000 medium "</strong></p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/f252d087d0c75f6f854fd3454a5dd1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThD0SCr6X-ImwhlLIaQECw.png"/></div></div></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="8563" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">容器资源足迹</h1><p id="5560" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">到目前为止，我们已经构建了一个运行. NET Core WebAPI的容器，它只有65.5MB。仅此一点就令人印象深刻，但是它的资源占用呢？运行这个容器需要多少RAM和CPU？当您的API在Docker中运行时，发出“docker container ls”命令来列出正在运行的容器。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/98851cbb21d90d885b049145261416e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XixdcPHUIrSIwQGmqHiFjw.png"/></div></div></figure><p id="a2fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会看到所有正在运行的容器的列表。接下来，我们可以发出一个“docker stats”命令，传入容器ID的前三个字符。在我的例子中，这个命令看起来像“docker stats 3eb”。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/dc516d0fed1ead433261838a6003b5e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_WuVY0xUsRZ9GBilSERzQ.png"/></div></div></figure><p id="1d1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你在屏幕截图中看到的，这个容器运行在23.88兆字节和0.14%的CPU上！再说一次如果你和。网过去，这些数字会让你很开心。这些数字确实代表了容器的空闲状态，一旦有负载，它们就会上下跳动，所以不能全信。也就是说，这些数字，加上集装箱的整体尺寸，比以往任何一次都要小。我构建的NET核心容器。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="9a8b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="ef24" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在这篇文章的开始，我为这一努力定义了一个个人目标列表:</p><ul class=""><li id="4eff" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">仅限Linux环境</li><li id="f120" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">微小的集装箱占地面积</li><li id="a524" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">没有多级Dockerfile文件</li><li id="e59c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">macOS开发环境</li></ul><p id="270d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了50MB容器大小之外，所有这些都得到满足。然而，最终的容器只有65.5MB，比我以前构建的任何容器都要小得多，所以我称之为成功。请记住，这个API目前没有任何真正的功能，所以默认情况下它<em class="nl">应该</em>很小。一旦你开始添加更多的类、依赖项、文件等，你会希望留意你的容器的大小，因为它可能会增长。</p><p id="7590" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我确实添加了一些依赖项，看看它会给容器增加多少。我引入了Newtonsoft并添加了一个利用HttpClient的类。在我看来，这是每一个API都有的两个特点。NET很可能会有。我还添加了几个模型类，并连接了一个HTTP GET调用。全部实现后，容器的大小增加了1MB以上。这让我对真实世界的API在大小上不会增加太多抱有希望。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="e2a0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">更新</h1><p id="c82d" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">自从我最初写了这篇文章，我已经走到了关于多阶段构建的争论的另一边。为此，我将Dockerfile文件更新为多阶段版本:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="d025" class="ng lt iq nc b gy nh ni l nj nk">FROM mcr.microsoft.com/dotnet/core/sdk as BUILD<br/>WORKDIR /api<br/>COPY . .<br/>RUN dotnet publish -r linux-musl-x64 -p:PublishSingleFile=true -c Release -o ./deploy</span><span id="009a" class="ng lt iq nc b gy nw ni l nj nk">FROM mcr.microsoft.com/dotnet/core/runtime-deps:3.1.0-alpine3.10<br/>WORKDIR /api<br/>RUN addgroup -S mediumgroup &amp;&amp; \<br/>    adduser -S mediumuser<br/>USER mediumuser<br/>COPY --from=BUILD --chown=mediumuser:mediumgroup api/deploy/Medium medium<br/>ENV ASPNETCORE_URLS=http://+:5000<br/>CMD ["./medium"]</span></pre></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="3b51" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">参考资料:</h1><ul class=""><li id="5e7d" class="kx ky iq ka b kb mq kf mr kj nx kn ny kr nz kv lc ld le lf bi translated">中的新功能。NET Core 3.0:<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot NET/Core/whats-new/dot NET-Core-3-0</a></li><li id="4937" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">dot net publish:<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish?tabs=netcore21" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/core/tools/dot net-publish？tabs=netcore21 </a></li><li id="0d72" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">。网芯RID目录:<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/core/rid-catalog" rel="noopener ugc nofollow" target="_blank">https://docs.microsoft.com/en-us/dotnet/core/rid-catalog</a></li><li id="96d2" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">单一文件发布:<a class="ae kw" href="https://github.com/dotnet/designs/blob/master/accepted/single-file/design.md" rel="noopener ugc nofollow" target="_blank">https://github . com/dot net/designs/blob/master/accepted/single-File/design . MD</a></li><li id="5389" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">怎么跑。NET Core 2在Docker中的应用在Linux上作为非root:<a class="ae kw" href="https://stackoverflow.com/questions/53544469/how-to-run-net-core-2-application-in-docker-on-linux-as-non-root/53544813" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/53544469/how-to-run-NET-Core-2-application-in-Docker-on-Linux-as-non-root/53544813</a></li><li id="4aed" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">chmod/chown/mv在你Dockerfile中的反冲:<a class="ae kw" href="https://medium.com/@lmakarov/the-backlash-of-chmod-chown-mv-in-your-dockerfile-f12fe08c0b55" rel="noopener">https://medium . com/@ lmakarov/the-backlash-of-chmod-chown-mv-in-your-docker file-f 12 Fe 08 c 0 b 55</a></li><li id="d21a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">优化。NET Docker Image Size:<a class="ae kw" href="https://medium.com/@mafshin/optimizing-asp-net-core-image-size-5e763602b29e" rel="noopener">https://medium . com/@ MAF shin/optimizing-ASP-NET-core-Image-Size-5e 763602 b29e</a></li><li id="1003" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">一个完整的集装箱。尽可能小的. NET核心应用微服务:<a class="ae kw" href="https://www.hanselman.com/blog/ACompleteContainerizedNETCoreApplicationMicroserviceThatIsAsSmallAsPossible.aspx" rel="noopener ugc nofollow" target="_blank">https://www . hanselman . com/blog/acompletecontainerizednetcoreapplicationmicroservicethathisassmallaspossible . aspx</a></li></ul></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><figure class="mw mx my mz gt jr gh gi paragraph-image"><a href="https://ko-fi.com/O5O63ENS7"><div class="gh gi oa"><img src="../Images/3515ab52cb6fb5e74c27c7a2e06d3811.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5imNjCtY48Wh3owQyPv6Cw.png"/></div></a></figure></div></div>    
</body>
</html>