<html>
<head>
<title>Pointers and Iterators: Three Stacks Using One Linked-List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">指针和迭代器:使用一个链表的三个堆栈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pointers-and-iterators-three-stacks-using-one-linked-list-bda0459b76cd?source=collection_archive---------9-----------------------#2021-02-08">https://levelup.gitconnected.com/pointers-and-iterators-three-stacks-using-one-linked-list-bda0459b76cd?source=collection_archive---------9-----------------------#2021-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8c436c40741e8c3131fa292458befb22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynBOiidxv0ip7LqO4aFwxQ.png"/></div></div></figure><div class=""/></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="14dc" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">数据结构操作在编程面试问题中经常出现。这篇文章讨论了操纵链表来设计堆栈。这个问题是微软在一次编程采访中问到的。</p><p id="da84" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这篇文章还通过使用C++语言支持(迭代器和模板)增加了实现的健壮性。掌握标准语言结构会让你的面试脱颖而出，并在招聘过程中给你额外的优势！</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="9d48" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">问题:</h1><p id="1182" class="pw-post-body-paragraph ki kj je kk b kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb mj ld le lf im bi translated">使用一个链表实现三个栈。</p><h1 id="636c" class="lh li je bd lj lk mk lm ln lo ml lq lr ls mm lu lv lw mn ly lz ma mo mc md me bi translated">解决方案1:指针管理</h1><p id="5478" class="pw-post-body-paragraph ki kj je kk b kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb mj ld le lf im bi translated">基本算法想一想应该就容易了。下面是解释它的图表！</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0ccfb9055cf27dc4b72a3aa2e4e5aa7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*yJtUqxf-r45Ht807Iu_CVA.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">带有stack_successor指针的双向链表</figcaption></figure><p id="a7f4" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">该图显示了一个包含几个元素的双向链表:<code class="fe my mz na nb b">(2, 4, 3, 1, 100, 10)</code>。列表的头部在元素<code class="fe my mz na nb b">2</code>处。<strong class="kk jf"> <em class="lg">在每一个节点，我们还保留了一个指针，指向堆栈中具有相同堆栈id的下一个元素！。</em> </strong>当前栈顶被移除时(例如通过<code class="fe my mz na nb b">Pop</code>方法)，这个下一个栈指针，或<code class="fe my mz na nb b">stack_successor</code>允许我们快速跳转到栈顶。我们还需要在一个指针数组中跟踪所有堆栈的顶部。</p><p id="9ee2" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">此时，在给定一个节点指针的情况下，您应该可以轻松地在双向链表中实现<code class="fe my mz na nb b">Insert</code>和<code class="fe my mz na nb b">Delete</code>方法。下面是我们如何使用<code class="fe my mz na nb b">Insert</code>和<code class="fe my mz na nb b">Delete</code>修改<code class="fe my mz na nb b">Push</code>和<code class="fe my mz na nb b">Pop</code>方法</p><ol class=""><li id="5cc5" class="nc nd je kk b kl km kp kq kt ne kx nf lb ng lf nh ni nj nk bi translated"><code class="fe my mz na nb b">Push</code>:</li></ol><ul class=""><li id="d177" class="nc nd je kk b kl km kp kq kt ne kx nf lb ng lf nl ni nj nk bi translated">叫<code class="fe my mz na nb b">Insert</code>榜头。</li><li id="43e4" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nl ni nj nk bi translated">更新新插入节点的<code class="fe my mz na nb b">stack_successor</code>指针</li><li id="9d86" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nl ni nj nk bi translated">更新<code class="fe my mz na nb b">tops</code>数组，用新创建的节点替换现有节点(具有匹配的stack_id)。</li></ul><p id="6af8" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><code class="fe my mz na nb b">2. Pop</code>:</p><ul class=""><li id="fef1" class="nc nd je kk b kl km kp kq kt ne kx nf lb ng lf nl ni nj nk bi translated">从链表中删除带有给定<code class="fe my mz na nb b">stack_id</code>的顶层节点。节点指针可以从<code class="fe my mz na nb b">tops</code>数组中获得。</li><li id="ab57" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nl ni nj nk bi translated">用被删除节点的<code class="fe my mz na nb b">stack_successor</code>更新<code class="fe my mz na nb b">tops</code>数组。</li><li id="f8cf" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nl ni nj nk bi translated">不要忘记通过调用节点指针上的<code class="fe my mz na nb b">Delete</code>来释放内存。</li></ul><p id="bd03" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">下面是使用双向链表实现三个堆栈。</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">三个带链表和指针操作的堆栈</figcaption></figure><h1 id="badd" class="lh li je bd lj lk mk lm ln lo ml lq lr ls mm lu lv lw mn ly lz ma mo mc md me bi translated">解决方案2:迭代器和类模板</h1><p id="aa5a" class="pw-post-body-paragraph ki kj je kk b kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb mj ld le lf im bi translated">上面的解决方案很棒，大部分考生(还有面试官！)会对它满意的。然而，有几件事可以进一步改进:</p><ul class=""><li id="0e9d" class="nc nd je kk b kl km kp kq kt ne kx nf lb ng lf nl ni nj nk bi translated">初始解决方案中没有异常处理。我们需要处理两种类型的异常:</li><li id="fb58" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nl ni nj nk bi translated">当<code class="fe my mz na nb b">stack_id</code>大于堆栈数量时，出现超出范围异常</li><li id="5f35" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nl ni nj nk bi translated">当相应的堆栈为空时，<code class="fe my mz na nb b">Pop</code>和<code class="fe my mz na nb b">Top</code>出现超范围异常。</li><li id="355a" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nl ni nj nk bi translated">该解决方案使用了太多的低位指针操作。指针操作容易出错，任何现代C++都应该使用更高级的抽象。(这里是<strong class="kk jf"> <em class="lg">迭代器</em> </strong>！)</li><li id="b656" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nl ni nj nk bi translated">该解决方案没有留下任何空间来扩展堆栈的数量或所提供的数据类型。当然，我们可以简单地使用栈的数量作为类构造函数的参数。但是我们可以做得更好——通过使用另一种C++语言结构— <em class="lg">模板。</em></li></ul><p id="33ca" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们将使用<a class="ae nt" href="https://www.cplusplus.com/reference/iterator/" rel="noopener ugc nofollow" target="_blank"> std::iterator </a>接口而不是指针来跟踪堆栈后继者。根据定义，</p><blockquote class="nu nv nw"><p id="d56b" class="ki kj lg kk b kl km kn ko kp kq kr ks nx ku kv kw ny ky kz la nz lc ld le lf im bi translated"><em class="je">迭代器</em>是一个指向容器的对象(比如std::list)，能够遍历容器的元素。它定义了两个操作符:(1) *用于解引用，以及(2 ++用于遍历容器。</p></blockquote><p id="7494" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因此，为了使用迭代器，我们将</p><ol class=""><li id="3eb0" class="nc nd je kk b kl km kp kq kt ne kx nf lb ng lf nh ni nj nk bi translated">维护一个<code class="fe my mz na nb b">std::list</code>元素，而不是定义我们自己的<code class="fe my mz na nb b">Node</code>结构。</li><li id="1dec" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nh ni nj nk bi translated">使用<code class="fe my mz na nb b">std::list&lt;&gt;::iterator</code>作为<code class="fe my mz na nb b">stack_successor</code>的数据类型，而不是节点指针。</li><li id="6156" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nh ni nj nk bi translated">使用<em class="lg"> std::list方法、</em>尤、<a class="ae nt" href="https://en.cppreference.com/w/cpp/container/list/push_front" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> push_front </em> </a>、<a class="ae nt" href="http://front" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> front </em> </a>、<a class="ae nt" href="https://en.cppreference.com/w/cpp/container/list/erase" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> erase </em> </a>代替指针操作。所有这些方法都使用迭代器。</li></ol><p id="e105" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">下面的清单说明了我们如何使用<em class="lg">模板、std::list和迭代器</em>来避免低级指针操作，同时提供三个栈的通用实现。这段代码还处理两种类型的异常:</p><ol class=""><li id="d12d" class="nc nd je kk b kl km kp kq kt ne kx nf lb ng lf nh ni nj nk bi translated"><code class="fe my mz na nb b">stack_id_out_of_bound</code>:当<code class="fe my mz na nb b">Push</code>、<code class="fe my mz na nb b">Pop</code>或<code class="fe my mz na nb b">Top</code>方法中传递的stack_id超过堆栈数时。</li><li id="7114" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nh ni nj nk bi translated"><code class="fe my mz na nb b">empty_stack</code>:当<code class="fe my mz na nb b">Pop</code>或<code class="fe my mz na nb b">Top</code>在一个空栈上被调用时，对应的栈id。</li></ol><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">使用std::list、迭代器和模板的三个堆栈</figcaption></figure><h1 id="965a" class="lh li je bd lj lk mk lm ln lo ml lq lr ls mm lu lv lw mn ly lz ma mo mc md me bi translated">测试</h1><p id="9ec7" class="pw-post-body-paragraph ki kj je kk b kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb mj ld le lf im bi translated">以下是一些测试案例:</p><ol class=""><li id="ad01" class="nc nd je kk b kl km kp kq kt ne kx nf lb ng lf nh ni nj nk bi translated">异常:<code class="fe my mz na nb b">stack_id_out_of_bound</code>和<code class="fe my mz na nb b">empty_stack</code>异常</li><li id="659b" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nh ni nj nk bi translated">单个堆栈上的单个<code class="fe my mz na nb b">Push</code>、<code class="fe my mz na nb b">Top</code>和<code class="fe my mz na nb b">Pop</code>序列</li><li id="46f0" class="nc nd je kk b kl nm kp nn kt no kx np lb nq lf nh ni nj nk bi translated">单个堆栈上的多个<code class="fe my mz na nb b">Push</code>、<code class="fe my mz na nb b">Top</code>和<code class="fe my mz na nb b">Pop</code>序列</li></ol><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="703d" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><em class="lg">原载于2021年2月8日</em><a class="ae nt" href="https://cppcodingzen.com/?p=2651" rel="noopener ugc nofollow" target="_blank"><em class="lg">https://cppcodingzen.com</em></a><em class="lg">。</em></p></div></div>    
</body>
</html>