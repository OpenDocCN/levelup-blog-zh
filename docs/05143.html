<html>
<head>
<title>Applying Open-Closed Principle with Decorator Pattern in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Decorator模式下开闭原则在打字稿中的应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/applying-open-closed-principle-with-decorator-pattern-in-typescript-79c71aa90494?source=collection_archive---------14-----------------------#2020-08-06">https://levelup.gitconnected.com/applying-open-closed-principle-with-decorator-pattern-in-typescript-79c71aa90494?source=collection_archive---------14-----------------------#2020-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/0e0f13951f1564f4999b31b67e8489f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*8hDuvtmgwSvK9-MeI8ZO4A.jpeg"/></div></figure><p id="ce50" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是我第一次用英语写帖子，所以你给我的任何反馈都非常重要。我会很感激的。</p><h1 id="618b" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">前言</h1><p id="1f8c" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">最近几天，我的一些研究重点是坚实的原则，干净的架构和一些相关的主题，如设计模式，我需要承认，自从大学以来，我一直在以错误的方式使用OOP技术，我意识到我所写的只是用类和方法分隔在不同文件中的过程代码，这样使用OOP没有任何好处，所以我决定改变。</p><h1 id="b745" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">设计原则</h1><p id="1fb5" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">每种范式都有自己的原则，在OOP世界中，这些原则是坚实的(还有一些，但这些是最著名和最常用的)。那么这意味着什么，这些坚实的关键词？它们代表:</p><ul class=""><li id="aa38" class="ly lz it jz b ka kb ke kf ki ma km mb kq mc ku md me mf mg bi translated">单一责任；</li><li id="e90b" class="ly lz it jz b ka mh ke mi ki mj km mk kq ml ku md me mf mg bi translated"><strong class="jz iu"> O </strong>笔-关闭；</li><li id="6fc7" class="ly lz it jz b ka mh ke mi ki mj km mk kq ml ku md me mf mg bi translated"><strong class="jz iu"> L </strong>伊斯科夫换人；</li><li id="c9c7" class="ly lz it jz b ka mh ke mi ki mj km mk kq ml ku md me mf mg bi translated"><strong class="jz iu"> I </strong>界面偏析；</li><li id="8a46" class="ly lz it jz b ka mh ke mi ki mj km mk kq ml ku md me mf mg bi translated"><strong class="jz iu"> D </strong>依赖倒置；</li></ul><p id="ab02" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">基本上，如果你遵循所有这些原则来构建你的应用程序，你的代码库将会更加灵活、抽象和可维护，软件的发展将会更少痛苦和昂贵，给你更多的时间去实现新事物。</p><h1 id="8bbd" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">开闭原理</h1><p id="61fa" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">开闭原则认为，我们的类必须对扩展开放，对变化封闭。基本上，我们必须能够在执行时改变实现行为，为了达到这一点，我们不需要改变类代码库，我们只需要组合的帮助。</p><p id="6bbd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有一个著名的口授说，我们需要优先于继承作文，这是非常重要的。当我们决定使用继承时，会有一些问题，首先是我们打破了封装的OOP基础，因为孩子知道关于父母的一切。第二个是静态继承，即使在执行时，我们也不能改变子进程的行为，我们需要改变代码库本身才能改变行为，打破了开闭原则。</p><p id="d095" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当我们有了组合，我们不再有“是”关系(例如:SavingsAccount <strong class="jz iu">是一个帐户</strong>并且我们传递了“有”关系(例如:AuthorizationClient <strong class="jz iu">有一个HttpClient</strong>),因此，按照这个例子，AuthorizationClient的行为就像一个普通的http client，但是他可以改变您的默认行为，例如添加一个authorization头。</p><h1 id="3deb" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">例子</h1><p id="5c0b" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">想象以下场景，假设我们有一个用React编写的前端客户端应用程序，我们正在使用一个API，并且需要传递一个身份验证令牌(例如一个jwt)。我们决定创建一个负责发送HTTP请求的接口，因此，在数据层我们创建了HttpPostClient协议(只有post请求，遵循接口分离原则，主题为另一个POST)。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">HttpPostClient协议</figcaption></figure><p id="fb96" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">之后，我们基于axios库为该协议创建了一个实现。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">AxiosHttpClient具体类</figcaption></figure><p id="09e7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们有了我们的协议(HttpPostClient)和我们的实现(AxiosHttpClient)，为什么不能只是在方法调用中正常传递授权头呢？我们需要考虑这个头需要在许多请求中传递，并且总是相同的:从localStorage或另一个服务中捕获令牌，并传递给执行请求的方法。如果我们只是复制和粘贴这个实现，我们将打破干燥(不要重复自己)的原则，所以我们需要想一个聪明的方法来做到这一点。这就是装饰模式的由来。</p><p id="d405" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">装饰模式基本上是一个对象的包装器。这个包装器必须具有相同类型的被包装对象，即实现相同的接口，因此，它们可以以客户端类不会注意到这种变化的方式进行交换(Liskov替换)。</p><p id="a8e6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个模式的目标是给装饰对象添加一个行为。</p><p id="b33e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">回到我们的例子，我们需要一个Decorator来实现HttpPostClient接口，并在不改变类实现的情况下向AxiosHttpClient添加所需的行为。</p><p id="fb4e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个装饰类将被称为AuthorizationHttpPostClientDecorator。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">授权HttpPostClientDecorator</figcaption></figure><p id="1e6f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一些需要注意的重要事项:</p><ul class=""><li id="2602" class="ly lz it jz b ka kb ke kf ki ma km mb kq mc ku md me mf mg bi translated">我们的Decorator类具有与被修饰对象相同的接口。</li><li id="2ec8" class="ly lz it jz b ka mh ke mi ki mj km mk kq ml ku md me mf mg bi translated">他在构造函数上接收被包装的对象(依赖倒置原则)</li><li id="8144" class="ly lz it jz b ka mh ke mi ki mj km mk kq ml ku md me mf mg bi translated">运行一些逻辑，然后从被修饰的对象调用方法</li></ul><p id="7c71" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是一个如何在不改变实现代码情况下向类添加行为的例子。</p><h1 id="b733" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论</h1><p id="8666" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">每当我们选择一个新的编程范例时，我们都需要了解他的基础和原则，只有了解了这些知识，我们才能深刻理解如何正确地使用那个范例并充分利用它。</p><p id="a47f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个例子中，我试图用一种简单的方式，用一个简单的例子来演示开闭原理，这样你就能意识到它的重要性。我选择decorator模式是因为你的开-闭应用是最常见的模式之一，但是我也可以实现Proxy模式，他也是一个结构化的模式，工作方式非常相似。</p></div></div>    
</body>
</html>