<html>
<head>
<title>GitHub Actions — How To Share Data Between Jobs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitHub操作——如何在作业间共享数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/github-actions-how-to-share-data-between-jobs-fc1547defc3e?source=collection_archive---------0-----------------------#2021-01-25">https://levelup.gitconnected.com/github-actions-how-to-share-data-between-jobs-fc1547defc3e?source=collection_archive---------0-----------------------#2021-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b1d3a78323cf9038bab70b088fc84237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsnMM_oB5_50LyCtszO-xg.png"/></div></div></figure><p id="aeae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我有机会使用GitHub Actions，我不得不在多个工作之间共享我的前端项目构建。我做了调查，发现了所有的选择和实现它的方法，我很乐意分享它！</p><p id="3b30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于那些不熟悉<a class="ae kw" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> GitHub动作</strong> </a> <strong class="ka ir">，</strong>的人来说，这是一种通过简单地添加一个YML文件，在GitHub存储库中使用CI/CD来自动化工作流的方法。</p><p id="3804" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将主要关注如何在作业之间共享数据，因此如果您想要了解一些基本知识，您可以在这里找到:<a class="ae kw" href="https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="1fc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在GitHub操作中，有两种主要的方法在作业之间共享数据:</p><ol class=""><li id="f388" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">隐藏物</li><li id="569a" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">史前古器物</li></ol><h1 id="2f35" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">隐藏物</h1><p id="e4fe" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">GitHub给你提供了一个动作叫做:<code class="fe mv mw mx my b">actions/cache</code> ( <a class="ae kw" href="https://github.com/actions/cache" rel="noopener ugc nofollow" target="_blank"> GitHub Repo </a>)，我们可以用它来上传缓存，然后在不同的作业中下载(<a class="ae kw" href="https://docs.github.com/en/actions/guides/caching-dependencies-to-speed-up-workflows" rel="noopener ugc nofollow" target="_blank"> Docs </a>)。</p><p id="dce8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个活生生的例子，然后再看一遍:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a076" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，它使用起来非常简单，动作本身有3个参数:</p><ul class=""><li id="fb46" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv nf lk ll lm bi translated"><strong class="ka ir"> path </strong>(必选):运行程序上要缓存或恢复的文件路径。路径可以是绝对路径，也可以是相对于工作目录的路径。</li><li id="572e" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv nf lk ll lm bi translated"><strong class="ka ir"> key </strong>(必选):保存缓存时创建的密钥，也是搜索缓存时使用的密钥。它可以是任何组合。</li><li id="1ee3" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv nf lk ll lm bi translated"><strong class="ka ir"> restore-keys </strong>(可选):如果<code class="fe mv mw mx my b">key</code>没有发生缓存命中，则用于查找缓存的可选键的有序列表。</li></ul><p id="3462" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个动作输出一个<code class="fe mv mw mx my b">cache-hit</code>，我们也可以用它来运行这样的动作:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bf9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，它非常简单，开箱即用，让我们继续第二个。</p><h1 id="15be" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">工件上传/下载</h1><p id="308b" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">工件是GitHub Actions提供给你的一种持久化文件的方式，在运行结束后使用它们，或者在作业之间共享它们(<a class="ae kw" href="https://docs.github.com/en/actions/guides/storing-workflow-data-as-artifacts" rel="noopener ugc nofollow" target="_blank">文档</a>)。</p><p id="2e78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建一个工件并使用它，您需要不同的操作:<a class="ae kw" href="https://github.com/actions/upload-artifact" rel="noopener ugc nofollow" target="_blank">上传</a>和<a class="ae kw" href="https://github.com/actions/download-artifact" rel="noopener ugc nofollow" target="_blank">下载</a>。</p><p id="be2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要上传文件或目录，您只需像这样使用它:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="23d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里您只需要提供2个参数:</p><ul class=""><li id="4de3" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv nf lk ll lm bi translated"><strong class="ka ir"> name </strong>:您想要用来识别工件的名称。</li><li id="c6f6" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv nf lk ll lm bi translated"><strong class="ka ir">路径</strong>:文件或目录的路径。</li></ul><p id="6b60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后下载神器来使用它:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7e42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里你只需要提供以前上传的名字:<code class="fe mv mw mx my b">my-artifcat</code>就可以了！</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="4c09" class="ls lt iq bd lu lv ng lx ly lz nh mb mc md ni mf mg mh nj mj mk ml nk mn mo mp bi translated">差异</h1><p id="4212" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">既然我们知道了这两种方法，让我们回顾一下它们之间最重要的区别(<a class="ae kw" href="https://docs.github.com/en/actions/guides/caching-dependencies-to-speed-up-workflows#comparing-artifacts-and-dependency-caching" rel="noopener ugc nofollow" target="_blank"> Docs </a>):</p><p id="40a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两者都是用来在GitHub上存储文件的，但是每一个都有不同的用途，最主要也是最大的区别是:</p><p id="d709" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缓存</strong>用于在作业或工作流程之间重用数据/文件，而<strong class="ka ir">工件</strong>用于在工作流程结束后保存文件。</p><p id="77a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果您想要在几个不同的作业之间共享一个构建，您会选择缓存，因为使用缓存只需几秒钟，而上传/下载工件则需要时间，这取决于文件的大小，很容易就会浪费很多时间。</p><p id="0f20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，如果你想:日志，测试结果，报告等。你肯定会想用神器。</p><h1 id="d6ae" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">比较</h1><p id="f6e9" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">下面是一个使用缓存和工件来共享NextJS空项目构建的工作流:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/28f3f456a89f70ef58955a6b3265f274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGPaZ2YJ2fB9wwYKSemnbw.png"/></div></div></figure><p id="122e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到缓存流和工件流之间的微小差异，因为这只是一个示例，项目的构建非常小，因为它实际上是空的，这种差异非常小，但是想象一下您有一个真实的项目，所以时间差将变得非常大，我已经看到了上传(5+-分钟)和下载(2+-分钟)时间与缓存秒的对比，但是在工件上传之后，您可以下载它:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/f4cd5cf9c29e15a10647295df6671c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWyQKs17dbWCu7yOlU3GQQ.png"/></div></div></figure><p id="48ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您也可以同时使用两者，例如:如果您不想等待构建上传，但是拥有构建对您来说仍然很重要，您可以使用缓存，然后在其他作业正在运行时异步上传构建，而不是等待上传。</p><h1 id="02a1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="8f63" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我希望你喜欢这篇文章，如果有人会研究这个话题，这篇文章将帮助他们很容易地快速理解，如果这篇文章对你有帮助，请随意鼓掌！:)</p><ul class=""><li id="11ef" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv nf lk ll lm bi translated"><a class="ae kw" href="https://github.com/stolenng/github-actions-sharing-data" rel="noopener ugc nofollow" target="_blank">回购示例</a></li><li id="66d4" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv nf lk ll lm bi translated"><a class="ae kw" href="https://github.com/stolenng/github-actions-sharing-data/actions/runs/510223214" rel="noopener ugc nofollow" target="_blank">动作用法示例</a></li><li id="5311" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv nf lk ll lm bi translated"><a class="ae kw" href="https://github.com/stolenng/github-actions-sharing-data/blob/main/.github/workflows/pull_request.yml" rel="noopener ugc nofollow" target="_blank"> YML文件示例</a></li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="6ae1" class="ls lt iq bd lu lv ng lx ly lz nh mb mc md ni mf mg mh nj mj mk ml nk mn mo mp bi translated">分级编码</h1><p id="955d" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">感谢您成为我们社区的一员！<a class="ae kw" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae kw" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Skilled.dev编码面试课程</strong> </a>。</p><div class="nn no gp gr np nq"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">编写面试问题+获得开发工作</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">掌握编码面试的过程</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">技术开发</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe jw nq"/></div></div></a></div></div></div>    
</body>
</html>