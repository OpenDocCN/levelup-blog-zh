<html>
<head>
<title>Use Regex and JavaScript to Improve Search Results</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用正则表达式和JavaScript改进搜索结果</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-regex-and-javascript-to-improve-search-results-870932050d08?source=collection_archive---------1-----------------------#2019-08-27">https://levelup.gitconnected.com/use-regex-and-javascript-to-improve-search-results-870932050d08?source=collection_archive---------1-----------------------#2019-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2f4e1e59b00d44174e1c7842c442238d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gxjnhiUMq9fsJkbK0YXjqg.gif"/></div></div></figure><p id="dd0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">能够根据用户输入准确高效地过滤搜索结果对于确保积极有效的用户体验至关重要。在这篇文章中，我们将使用JavaScript、HTML和CSS创建一个搜索栏。给定一个姓名列表，我们应该能够根据用户的输入过滤出姓名。</p><p id="54ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实现这一点的常见方法是简单地使用JavaScript的<code class="fe kz la lb lc b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">.filter()</a></code>函数，并检查是否有任何元素<code class="fe kz la lb lc b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes" rel="noopener ugc nofollow" target="_blank">.includes()</a></code>是用户输入的。</p><pre class="le lf lg lh gt li lc lj lk aw ll bi"><span id="8600" class="lm ln it lc b gy lo lp l lq lr">filterFunction = (userInput) =&gt;{<br/>   var filteredNames = names.filter((x)=&gt;{ <br/>       return x.includes(userInput)<br/>   }</span><span id="77d7" class="lm ln it lc b gy ls lp l lq lr">   return filteredNames<br/>}</span></pre><p id="ee5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个函数检查用户的输入是否与数组中的任何一个名字相匹配。如果我们的名称数组包含“Tom”、“Jerry”、“Larry”、“Barry”，并且用户在“T”中键入，则过滤后的列表将只包含一个名称，因为“Tom”是列表中唯一包含字母“T”的名称。</p><p id="0346" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法非常有效，但是有一点限制，因为用户必须键入字母的准确顺序，否则将不会返回任何结果。假设用户想从我们的名字列表中找到Larry，但是不小心输入了“Lrary”。尽管事实上字母是正确的，顺序只差一个字母，但搜索结果将会是空的。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/be5f42f2a59d94232edd7e9875612c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*NRwtwCzyf4bqwqO2Ms4TkA.gif"/></div></figure><p id="c4b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以在这篇文章中，我们除了使用<code class="fe kz la lb lc b">.includes()</code>之外，还将使用正则表达式，以便更好地返回更方便的结果，而不会影响搜索的准确性。首先，让我们准备好HTML和CSS。见下面的HTML。</p><pre class="le lf lg lh gt li lc lj lk aw ll bi"><span id="0e07" class="lm ln it lc b gy lo lp l lq lr">&lt;div class="containerDiv"&gt;</span><span id="27bc" class="lm ln it lc b gy ls lp l lq lr">   &lt;input type='text' onkeyup="onChange();"/&gt;</span><span id="c0ff" class="lm ln it lc b gy ls lp l lq lr">   &lt;div id="nameContainer"&gt;&lt;/div&gt;</span><span id="1fd5" class="lm ln it lc b gy ls lp l lq lr">&lt;/div&gt;</span></pre><p id="31d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有我们的CSS。</p><pre class="le lf lg lh gt li lc lj lk aw ll bi"><span id="8fb2" class="lm ln it lc b gy lo lp l lq lr">.containerDiv{<br/>    display: block; <br/>    margin: auto; <br/>    width: 300px;<br/>}</span><span id="8f95" class="lm ln it lc b gy ls lp l lq lr">#nameContainer &gt; p {<br/>    display: inline-block;<br/>    margin: 20px;<br/>}</span><span id="cde7" class="lm ln it lc b gy ls lp l lq lr">input{<br/>   width: 200px;<br/>   font-size: 20px;<br/>}</span></pre><p id="b690" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用了<code class="fe kz la lb lc b"><a class="ae ld" href="https://www.w3schools.com/jsref/event_onkeyup.asp" rel="noopener ugc nofollow" target="_blank">onkeyup</a></code>事件而不是<code class="fe kz la lb lc b">onchange</code>,因为<code class="fe kz la lb lc b">onchange</code>只有在填写完输入后提交/按enter键时才会触发。<code class="fe kz la lb lc b">onkeyup</code>打字后一抬手指就触发。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/087cfd5327bd88a0dd38e0a50055c790.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*8NN6ZW-2BRr91ArMulRqsA.gif"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">是的，又一个办公室。原因如下:</figcaption></figure><p id="8a5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，转到JavaScript。</p><p id="307c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将要使用的数组包含了一个角色的名字列表，这些角色来自于历史上最伟大的电视剧之一《办公室》。</p><pre class="le lf lg lh gt li lc lj lk aw ll bi"><span id="b4ca" class="lm ln it lc b gy lo lp l lq lr">const office = ['Kelly', 'Creed', 'Stanley', 'Oscar', 'Michael', 'Jim', 'Darryl', 'Phyllis', 'Pam', 'Dwight', 'Angela', 'Andy', 'William', 'Ryan', 'Toby', 'Bob']</span></pre><p id="2e93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看一下将在容器中呈现所有结果的函数，<code class="fe kz la lb lc b">appendNodes</code>。</p><pre class="le lf lg lh gt li lc lj lk aw ll bi"><span id="9bec" class="lm ln it lc b gy lo lp l lq lr">appendNodes = (filteredOffice) =&gt; {<br/>   var container = document.getElementById('nameContainer');</span><span id="95e2" class="lm ln it lc b gy ls lp l lq lr">   if (filteredOffice != "no results"){<br/>        container.innerText = ""<br/>        filteredOffice.map((name)=&gt;{<br/>           var p = document.createElement("P")<br/>           p.innerText = name<br/>           container.appendChild(p)<br/>        })<br/>    } else {<br/>        container.innerText = "no results"<br/>    }<br/>}</span></pre><p id="e0a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">向该函数传递一个数组作为参数。我们遍历数组并使用JavaScript的<code class="fe kz la lb lc b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement" rel="noopener ugc nofollow" target="_blank">createElement</a></code>函数为数组中的每一项创建一个<code class="fe kz la lb lc b">p</code>标签。然后，我们将该迭代中的名称添加到那个<code class="fe kz la lb lc b">p</code>标签的<code class="fe kz la lb lc b">innerText</code>中，这将表示搜索结果。</p><p id="6036" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们创建了<code class="fe kz la lb lc b">p</code>标签并添加了<code class="fe kz la lb lc b">innerText</code>，我们就可以使用JavaScript的<code class="fe kz la lb lc b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild" rel="noopener ugc nofollow" target="_blank">appendChild</a></code>函数将创建的<code class="fe kz la lb lc b">p</code>标签及其内容追加到<code class="fe kz la lb lc b">nameContainer</code>。我们可以用<code class="fe kz la lb lc b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event" rel="noopener ugc nofollow" target="_blank">document.onDOMContentLoaded</a></code>中的office数组调用这个函数来初始化我们的结果。</p><pre class="le lf lg lh gt li lc lj lk aw ll bi"><span id="4c4f" class="lm ln it lc b gy lo lp l lq lr">document.addEventListener("DOMContentLoaded", () =&gt; {<br/>    appendNodes(office)<br/>});</span></pre><p id="8472" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在所有这些之后，我们有了自己的网页。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/40902e15893c6ec105bf760ba59b2df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdyuAp6EIUZR8U6lwxTcug.png"/></div></div></figure><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lz"><img src="../Images/b719589efe05f0da4795950122c18c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/1*SdKa26UoyNkoky4-xahwBA.gif"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">是的。</figcaption></figure><p id="4642" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，看看我们的过滤函数。</p><pre class="le lf lg lh gt li lc lj lk aw ll bi"><span id="cb92" class="lm ln it lc b gy lo lp l lq lr">onKeyUp = () =&gt; {<br/>    var str = event.target.value.toLowerCase()</span><span id="f015" class="lm ln it lc b gy ls lp l lq lr">    var filteredArr = office.filter((x)=&gt;{<br/>        return x.toLowerCase().includes(str)){<br/>    })</span><span id="7284" class="lm ln it lc b gy ls lp l lq lr">    if (arr.length &gt; 0){<br/>        appendNodes(arr)<br/>    } else {<br/>        appendNodes("no results")<br/>    }<br/>}</span></pre><p id="8d25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该函数根据任何字符名称是否包含用户输入来过滤office数组。我们还使用<code class="fe kz la lb lc b">toLowerCase()</code>来改进输入验证。请记住，“pam”不等于“pam”，因此如果不将数组中的字符名称和用户输入都改为小写，用户键入“Pam”将不会产生任何搜索结果。如果没有结果，该函数将“没有结果”传递给我们的<code class="fe kz la lb lc b">appendNodes()</code>函数。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/538252407b4a0d918a6776705aabdabd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*P5aCMyopSzKZpR-TP284tw.gif"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">该死的。</figcaption></figure><p id="765d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">即使在将姓名和输入转换成小写字母之后，这种功能仍然存在不足。如果用户键入“apm ”,他们将不会产生任何搜索结果。如果用户输入“mcihael”，情况也是一样的。这两个输入很可能是“pam”和“michael”。那么，我们如何解释这样的小拼写错误，并相应地纠正我们的搜索结果呢？</p><p id="1f3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">介绍，<a class="ae ld" href="https://www.regular-expressions.info/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> Regex </strong> </a>。</p><p id="cdaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Regex是“正则表达式”的缩写，是描述搜索模式的特殊文本字符串。我们将使用regex实现一个搜索模式，它获取字符名称的前三个字母，并将其与输入的前三个字母进行比较。为什么不将整个名称与整个输入进行比较呢？</p><p id="00f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然这似乎是一个好主意，但在某一点上，辅助搜索将开始通过压倒性的结果来与自己作对。见下文。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/b0c6bb1415f1173704b947bef0c1fa61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxKDeA7qxQBhjpjKzDW7qQ.png"/></div></div></figure><p id="233c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它仍然有助于我们的搜索，但“an”更接近于“Angela”或“Andy”的意外拼写错误，而不是“Ryan”或“Stanley”。通过包含更多的字母进行比较，你增加了建立匹配的可能性，在某一点上可能会适得其反。当我们只使用输入和字符名称的前三个字母时，将上面的结果与下面的结果进行比较。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/1869a6f4b92645bcdac9380a90fd39e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*P2sgpK8qKE6UwUOTJNFGzQ.png"/></div></figure><p id="87c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，这些搜索结果更加精确。我们已经减少了50%的搜索结果，当你考虑我们的列表有多小时，这可能会真正影响搜索结果的大小。我们改进的结果可以归功于函数<code class="fe kz la lb lc b">checkName()</code>。</p><pre class="le lf lg lh gt li lc lj lk aw ll bi"><span id="d26e" class="lm ln it lc b gy lo lp l lq lr">checkName = (name, str) =&gt; {<br/>    var pattern = str.split("").map((x)=&gt;{<br/>        return `(?=.*${x})`<br/>    }).join("");</span><span id="276f" class="lm ln it lc b gy ls lp l lq lr">    var regex = new RegExp(`${pattern}`, "g")</span><span id="cf8b" class="lm ln it lc b gy ls lp l lq lr">    return name.match(regex);<br/>}</span></pre><p id="daa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来分析一下。</p><p id="b74e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">?=</code>是一个<a class="ae ld" href="https://www.regular-expressions.info/lookaround.html" rel="noopener ugc nofollow" target="_blank">正向前瞻</a>。</p><p id="19ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">.</code>匹配除换行符以外的任何字符。</p><p id="bb45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">*</code>匹配一个字符的零个或多个实例。</p><p id="12ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">()</code>是一个捕获组，用于在正则表达式中将字符组合在一起，以便我们可以应用其他运算符(<code class="fe kz la lb lc b">?=.*</code>)。</p><p id="c6d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">g</code>是全局修饰符，它执行字符串的全局搜索来寻找匹配。您也可以将<code class="fe kz la lb lc b">i</code>添加到<code class="fe kz la lb lc b">g</code>中，使其成为一个不敏感的(不区分大小写)搜索，但是在我的例子中，我已经将输入和字符名称转换成小写字母，所以<code class="fe kz la lb lc b">g</code>修饰符就足够了。</p><p id="61b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个函数分割我们的用户输入，遍历字符并使用字符串插值将每个字母添加到星号后面的<code class="fe kz la lb lc b">(?=.*)</code>正则表达式中。一旦我们有了一个正则表达式模式的数组，我们就将数组中的所有项连接起来，创建一个包含所有字母的更大的正则表达式模式。由此，我们可以使用<code class="fe kz la lb lc b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" rel="noopener ugc nofollow" target="_blank">new RegExp</a></code>从连接的模式中创建一个正则表达式。</p><p id="2f6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们为每个字母创建的单独模式将匹配包含该字母的任何字符串。组合它们会将所有单个捕获组应用到整体模式，使它们都成为字符串的可匹配模式。这将弥补<code class="fe kz la lb lc b">.includes(str)</code>的不足。</p><p id="745e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果用户试图找到“Kelly ”,但是错误地键入了“e”作为第一个字母。<code class="fe kz la lb lc b">x.toLowerCase().includes(str)</code>会起作用，但是如果用户继续输入，然后输入‘k ’,前面的检查就不起作用了。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi md"><img src="../Images/a164da9748fdf1c849775a29e982cec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*hrjN19ckiQM0LTnG0GLjyQ.png"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">总有一个主题。</figcaption></figure><p id="ab04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们将‘ek’传递给<code class="fe kz la lb lc b">checkName()</code>，我们可以创建正则表达式<code class="fe kz la lb lc b">(?=.*e)(?=.*k)</code>，它将匹配包含‘e’和‘k’的字符串，而不考虑顺序。我们将该正则表达式应用于“kelly”的前三个字母，这三个字母也被传递给函数<code class="fe kz la lb lc b">name</code>。如果满足正则表达式，那么<code class="fe kz la lb lc b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match" rel="noopener ugc nofollow" target="_blank">.match()</a></code>将返回true。否则将返回false。</p><p id="e5c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们知道了我们想要完成什么，以及如何去做，让我们看看修改后的<code class="fe kz la lb lc b">onKeyUp()</code>函数。</p><pre class="le lf lg lh gt li lc lj lk aw ll bi"><span id="2152" class="lm ln it lc b gy lo lp l lq lr">onKeyUp = () =&gt; {<br/>   var str = event.target.value.toLowerCase().substring(0, 3)</span><span id="e0d9" class="lm ln it lc b gy ls lp l lq lr">   var filteredArr = office.filter((x)=&gt;{<br/>      var xSub = x.substring(0, 3).toLowerCase()<br/>      return x.toLowerCase().includes(str) || checkName(xSub, str)<br/>   })</span><span id="1796" class="lm ln it lc b gy ls lp l lq lr">    if (filteredArr.length &gt; 0){<br/>      appendNodes(filteredArr)<br/>    } else {<br/>      appendNodes("no results")<br/>    }<br/>}</span></pre><p id="e86a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<code class="fe kz la lb lc b"><a class="ae ld" href="https://www.w3schools.com/jsref/jsref_substring.asp" rel="noopener ugc nofollow" target="_blank">substring()</a></code>获取输入的前三个字母和角色的名字。然后我们检查<code class="fe kz la lb lc b">x.toLowerCase().includes(str)</code>是否为真。如果是，我们跳过正则表达式验证，因为<code class="fe kz la lb lc b">.includes()</code>是一个更准确的匹配，因为它实际上是字符名称、顺序和字符方式的一部分。如果<code class="fe kz la lb lc b">x.toLowerCase().includes(str)</code>为假，我们使用<code class="fe kz la lb lc b">checkName()</code>来应用我们的正则表达式验证。这将改善用户的搜索结果，而不会过于严格，也不会损害整体搜索的准确性。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/fd39b71d9dfd622b52e869d89ea4096f.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/1*Bhca_BKFc1CIixRcVWvziA.gif"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="2f70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这篇文章或者需要澄清任何提到的事情，请在评论中告诉我。请随意分享和留下掌声！</p><h1 id="21d7" class="mm ln it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">参考</h1><div class="nj nk gp gr nl nm"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">Array.prototype.filter()</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">filter()方法创建一个新数组，其中所有元素都通过了由提供的函数实现的测试。var…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">developer.mozilla.org</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jz nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://www.w3schools.com/jsref/jsref_replace.asp" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">JavaScript字符串替换()方法</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">返回一个字符串，其中“Microsoft”替换为“W3Schools”:Try it Yourself“更多“Try it Yourself”示例…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">www.w3schools.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa jz nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">Document.createElement()</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">在HTML文档中，document.createElement()方法创建由tagName或…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">developer.mozilla.org</p></div></div><div class="nv l"><div class="oc l nx ny nz nv oa jz nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">Node.appendChild()</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">方法将一个节点添加到指定父节点的子节点列表的末尾。如果给定的…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">developer.mozilla.org</p></div></div><div class="nv l"><div class="od l nx ny nz nv oa jz nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">文档:DOMContentLoaded事件</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">DOMContentLoaded事件在初始HTML文档被完全加载和解析后触发，无需等待…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">developer.mozilla.org</p></div></div><div class="nv l"><div class="oe l nx ny nz nv oa jz nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://www.regular-expressions.info/" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">正则表达式. info —正则表达式教程、示例和参考—正则表达式模式</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">正则表达式(简称regex或regexp)是描述搜索模式的特殊文本字符串。你可以…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">www.regular-expressions.info</p></div></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://www.regular-expressions.info/lookaround.html" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">前视和后视零长度断言</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">Lookahead和look ahead统称为“lookaround ”,是零长度断言，就像…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">www.regular-expressions.info</p></div></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">正则表达式</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">RegExp构造函数创建一个正则表达式对象来匹配文本和模式。对…的介绍</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">developer.mozilla.org</p></div></div><div class="nv l"><div class="of l nx ny nz nv oa jz nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">String.prototype.match()</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">方法检索字符串与正则表达式匹配的结果。正则表达式对象。如果一个…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">developer.mozilla.org</p></div></div><div class="nv l"><div class="og l nx ny nz nv oa jz nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://www.w3schools.com/jsref/jsref_substring.asp" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">JavaScript字符串substring()方法</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">下面有更多“自己尝试”的例子。substring()方法从字符串中提取两个…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">www.w3schools.com</p></div></div><div class="nv l"><div class="oh l nx ny nz nv oa jz nm"/></div></div></a></div></div></div>    
</body>
</html>