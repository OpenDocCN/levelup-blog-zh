<html>
<head>
<title>Demystifying Asynchronous JavaScript — Event Loop, Call stack, Task Queue, and More!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开异步JavaScript的神秘面纱——事件循环、调用堆栈、任务队列等等！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/demystifying-asynchronous-javascript-event-loop-call-stack-task-queue-and-more-51fb748a4bd4?source=collection_archive---------2-----------------------#2020-08-26">https://levelup.gitconnected.com/demystifying-asynchronous-javascript-event-loop-call-stack-task-queue-and-more-51fb748a4bd4?source=collection_archive---------2-----------------------#2020-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9e5db7d4975e98e287386a118b1973ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWwvUgRJPIRjkL7AvgyICA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">JavaScript并发模型</figcaption></figure><p id="282c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">JavaScript是一种单线程编程语言。这意味着一次只能有一段代码在<strong class="kh iu">单个主线程</strong>上运行，其他的都被<strong class="kh iu">阻塞</strong>直到一个操作完成。</p><p id="ef05" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是我们不希望<strong class="kh iu">等待</strong>或<strong class="kh iu">被阻塞</strong>来完成某个异步任务！想象一下，在Instagram上滚动，直到某个特定的feed被完全加载后才能真正滚动。那真的太可怕了！</p><p id="b4f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，JavaScript是一种<strong class="kh iu">非阻塞</strong>语言，这篇文章是关于事情如何在幕后工作的。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><h1 id="6e00" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">目录</h1><ol class=""><li id="4bd9" class="mh mi it kh b ki mj km mk kq ml ku mm ky mn lc mo mp mq mr bi translated">执行上下文</li><li id="3610" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">调用栈</li><li id="4fba" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">任务排队</li><li id="d8d5" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">作业队列</li><li id="b5b8" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">事件循环——所有这些是如何协同工作的！</li></ol><h1 id="0d57" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">执行上下文</h1><p id="805e" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">在我们进入JavaScript如何处理异步任务之前，我们应该知道JavaScript代码到底是如何执行的。</p><blockquote class="na nb nc"><p id="d85a" class="kf kg nd kh b ki kj kk kl km kn ko kp ne kr ks kt nf kv kw kx ng kz la lb lc im bi translated"><strong class="kh iu">执行上下文</strong>是一个抽象概念，它保存了<em class="it">关于当前代码正在其中执行的环境</em>的信息。</p></blockquote><ul class=""><li id="c7fa" class="mh mi it kh b ki kj km kn kq nh ku ni ky nj lc nk mp mq mr bi translated">每当JavaScript文件第一次加载到浏览器中时，<strong class="kh iu">就会创建一个全局执行上下文</strong>。</li><li id="6a97" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc nk mp mq mr bi translated">每次我们调用一个函数，<strong class="kh iu">一个新的执行上下文</strong>被创建。</li><li id="50fc" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc nk mp mq mr bi translated">当我们从一个函数返回或者函数体被完全执行时，该函数的执行上下文被<strong class="kh iu">销毁并被垃圾回收</strong>。</li></ul><p id="b1cb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">基本上，每当一个JavaScript代码在一个给定的执行环境中执行的时候，两件事情会同时发生</p><ol class=""><li id="f74d" class="mh mi it kh b ki kj km kn kq nh ku ni ky nj lc mo mp mq mr bi translated"><strong class="kh iu">线程化— </strong> JavaScript线程以程序化的方式一次执行一行代码。</li><li id="b368" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated"><strong class="kh iu">内存</strong> — JavaScript创建新标签，并将给定执行上下文的所有变量/函数声明<strong class="kh iu">存储在内存中</strong></li></ol><h1 id="4e3a" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">调用栈</h1><blockquote class="na nb nc"><p id="f5c9" class="kf kg nd kh b ki kj kk kl km kn ko kp ne kr ks kt nf kv kw kx ng kz la lb lc im bi translated"><strong class="kh iu">调用堆栈</strong>是一种解释器(就像web浏览器中的JavaScript解释器)跟踪其在调用多个函数的脚本中的位置的机制——当前正在运行什么函数，以及从该函数中调用了什么函数，等等。</p></blockquote><p id="3118" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">更准确地说，<strong class="kh iu">调用栈帮助我们知道我们的主线程当前在哪个执行上下文中</strong>！让它深入人心。</p><p id="5c95" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要记住一些事情——</p><ol class=""><li id="01bb" class="mh mi it kh b ki kj km kn kq nh ku ni ky nj lc mo mp mq mr bi translated">将<em class="nd">推送到</em>调用栈的第一件事是全局执行上下文。</li><li id="b273" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">每当一个新的函数被调用时，即<strong class="kh iu">当一个新的执行上下文被创建</strong>时，它被<em class="nd">推到</em>调用堆栈上</li><li id="c674" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">每当一个函数完成执行时，也就是说，当执行上下文被销毁时，它就会从调用堆栈中弹出(移除)。</li><li id="b328" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">当完整的JavaScript代码已经被执行时，即当全局执行被破坏时，调用栈被清空。</li></ol><h1 id="c234" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">任务排队</h1><p id="c917" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">为了执行异步任务，JavaScript利用了<a class="ae nl" href="https://developer.mozilla.org/en-US/docs/Web/API" rel="noopener ugc nofollow" target="_blank">webapi</a></p><p id="d4c3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">WebAPIs是浏览器的一部分，而不是JavaScript运行时的一部分。因此，JavaScript运行时与WebAPIs接口，使我们能够执行异步任务，同时不会阻塞主线程！</p><p id="9f22" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">任务队列是一个DS，当我们使用任何WebAPI时，它就会发挥作用。</p><p id="8f53" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在大多数情况下，当我们启动一个异步任务时，我们提供一个回调<strong class="kh iu">函数</strong>，它在耗时的异步任务完成时执行。这个回调函数需要返回到调用堆栈才能被执行。现在问题来了，我们到底什么时候把这个回调函数推送到调用栈？</p><p id="bf9d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">基本上，</p><blockquote class="na nb nc"><p id="57cf" class="kf kg nd kh b ki kj kk kl km kn ko kp ne kr ks kt nf kv kw kx ng kz la lb lc im bi translated">每当异步任务完成时，与该异步任务相关联的回调函数被推送到任务队列。</p></blockquote><p id="a59b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，考虑下面的<code class="fe nm nn no np b">setTimeout</code>示例—</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="nq li l"/></div></figure><ol class=""><li id="35fe" class="mh mi it kh b ki kj km kn kq nh ku ni ky nj lc mo mp mq mr bi translated">值得注意的是<code class="fe nm nn no np b">sayHello</code>和<code class="fe nm nn no np b">sayBye</code>都是回调函数。</li><li id="71a2" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">我们触发了两个setTimeout函数，它们触发了浏览器中的一个定时器。</li><li id="c687" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">根据<code class="fe nm nn no np b">setTimeout</code>的第二个参数，以毫秒为单位的时间，定时器完成，回调函数被推送到任务队列。</li><li id="1179" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">因此，上面例子中的任务队列看起来像这样— [ <code class="fe nm nn no np b">sayHello</code>，<code class="fe nm nn no np b">sayBye</code> ]</li></ol><h1 id="94ba" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">作业队列</h1><p id="61d3" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">ES6引入了作业队列的概念，<strong class="kh iu">由Promises </strong>使用(也在ES6中引入)。这是一种尽可能快地执行异步函数<strong class="kh iu">的结果的方法</strong>，而不是将结果放在调用堆栈的末尾。</p><blockquote class="na nb nc"><p id="b031" class="kf kg nd kh b ki kj kk kl km kn ko kp ne kr ks kt nf kv kw kx ng kz la lb lc im bi translated">因此，每当我们对异步任务使用promise时，在解析promise之后，与Promise相关联的回调被推送到作业队列。</p></blockquote><p id="dfbc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，如果一个承诺被解析，并且我们的调用堆栈不为空，也就是说，我们的主线程在某个执行上下文中，那么在当前的执行上下文被销毁，并且没有更多的同步代码被留下来执行之后，下一个将被推送到我们的调用堆栈的东西将来自我们的作业队列。</p><h1 id="bb09" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">事件循环</h1><p id="cd7c" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">是时候把我们在上面学到的所有东西放在一起，理解JavaScript的完整并发模型了。</p><blockquote class="na nb nc"><p id="3b83" class="kf kg nd kh b ki kj kk kl km kn ko kp ne kr ks kt nf kv kw kx ng kz la lb lc im bi translated">事件循环监视回调队列和作业队列，并决定什么需要被推送到调用堆栈。</p></blockquote><p id="3f46" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">基本上遵循一些简单的规则，这些规则决定了什么需要被推到调用堆栈中，以及以什么样的顺序</p><ol class=""><li id="ded7" class="mh mi it kh b ki kj km kn kq nh ku ni ky nj lc mo mp mq mr bi translated">当JavaScript文件第一次加载到浏览器中时，<strong class="kh iu">全局上下文被推送到调用栈</strong>，即JavaScript的主函数被执行。</li><li id="3ee3" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">按顺序，同步代码被执行，<strong class="kh iu">任何同步函数都被推送到调用栈，按顺序它被找到</strong>。</li><li id="bb21" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">每当使用WebAPIs执行异步任务时，当异步任务完成时，与该任务相关联的回调被推送到任务队列<strong class="kh iu">。</strong></li><li id="309c" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">每当使用Promise执行异步任务时，当Promise得到解析时，与Promise相关联的回调被推送到作业队列<strong class="kh iu">!</strong></li><li id="6964" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">如果我们在调用堆栈中存在当前执行上下文，并且没有更多的同步代码要执行，如果作业队列不为空，则从作业队列中取出下一个函数。</li><li id="90fe" class="mh mi it kh b ki ms km mt kq mu ku mv ky mw lc mo mp mq mr bi translated">如果我们在调用堆栈中有一个当前执行上下文，并且没有更多的同步代码要执行，那么<strong class="kh iu">如果作业队列为空，则从任务队列中取出下一个函数。</strong></li></ol><p id="f3e2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们看看下面的例子和它的调用堆栈图，总结一下我们到目前为止学到的东西</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="nq li l"/></div></figure><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/902aa9f5ae9b16591c26dc32c929a194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jf9ZjoLt0vTuP1RUtfIXzg.png"/></div></div></figure><p id="7fc1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，上面代码的输出是—</p><pre class="ld le lf lg gt ns np nt nu aw nv bi"><span id="bfdb" class="nw lk it np b gy nx ny l nz oa">Me first!<br/>*data from twitter*<br/>Hello</span></pre><p id="dc6d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望您现在对JavaScript中的并发模型有了很好的了解！</p><p id="571b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">谢谢你花时间滚动到最后😊</p><h1 id="ec7b" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">资源</h1><div class="ob oc gp gr od oe"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">并发模型和事件循环</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">JavaScript有一个基于事件循环的并发模型，它负责执行代码，收集和…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">developer.mozilla.org</p></div></div><div class="on l"><div class="oo l op oq or on os jz oe"/></div></div></a></div><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="ot li l"/></div></figure></div></div>    
</body>
</html>