<html>
<head>
<title>Path aliases with TypeScript in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中带有TypeScript的路径别名</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/path-aliases-with-typescript-in-node-js-230803e3f200?source=collection_archive---------2-----------------------#2020-01-17">https://levelup.gitconnected.com/path-aliases-with-typescript-in-node-js-230803e3f200?source=collection_archive---------2-----------------------#2020-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/11ee1bfcded60f97e740adbe73b6dd95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZI0LIunbOr-_8sfsJiPq_Q.jpeg"/></div></div></figure><p id="a124" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将指导您在TypeScript项目中设置路径别名，并向您展示如何清理代码。</p><h2 id="aa9f" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">问题是</h2><p id="7afc" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在Node.js(或一般的TS/JS)中，您可以将模块导入到代码中。这可能如下所示:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3b9f" class="kw kx iq lz b gy md me l mf mg">import { User } from '../../user/model';<br/>import { Article } from '../../article/model';</span><span id="4371" class="kw kx iq lz b gy mh me l mf mg">import { Cache } from '../../../../cache';<br/>import { MongoDB } from '../../../../mongodb';</span></pre><p id="4eed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意这些点<code class="fe mi mj mk lz b">../../</code>来访问父目录。</p><p id="501b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们这里的问题是，你的项目树越深，就需要越多的<code class="fe mi mj mk lz b">../</code>来访问更高层的模块。老实说，这看起来不太干净，很难理解，并且会使任何代码重组都非常痛苦。幸运的是，我们可以改变这种情况。</p><p id="cf3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决方案:<strong class="ka ir">路径别名</strong></p><h2 id="1ca9" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">什么是路径别名？</h2><p id="fbe3" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在TypeScript中，您可以借助路径别名来避免这些看起来“糟糕”的导入。使用路径别名，您可以声明映射到应用程序中某个绝对路径的别名。</p><p id="7b5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个简单的例子:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9f44" class="kw kx iq lz b gy md me l mf mg">import { User } from '@components/user/model';<br/>import { Article } from '@conponents/article/model';</span><span id="7849" class="kw kx iq lz b gy mh me l mf mg">import { Cache } from '@services/cache';<br/>import { MongoDB } from '@services/mongodb';</span></pre><p id="8707" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，这两个别名是</p><ul class=""><li id="4dde" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated"><code class="fe mi mj mk lz b">@components</code>那就映射到<code class="fe mi mj mk lz b">‘./src/api/components’</code></li><li id="2608" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe mi mj mk lz b">@services</code>映射到<code class="fe mi mj mk lz b">‘./src/services’</code></li></ul><h2 id="55d3" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">设置</h2><p id="bae8" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">让我们深入了解一下，并设置一些路径别名。假设我们有一个Node.js应用程序，其项目结构如下:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="32d5" class="kw kx iq lz b gy md me l mf mg">my-node-app<br/>└───src<br/>   │<br/>   └───api<br/>   │   │<br/>   │   └───components<br/>   │   │   │<br/>   │   │   └───article<br/>   │   │   │<br/>   │   │   └───user<br/>   │   │<br/>   │   │   server.ts<br/>   │<br/>   │<br/>   └───services<br/>   │   │    cache.ts<br/>   │   │    mongodb.ts<br/>   │    <br/>   │   index.ts</span></pre><h2 id="56ce" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">第一步:更新tsconfig.json </strong></h2><p id="398b" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">首先，我们必须在tsconfig.json文件中声明路径别名:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9b2f" class="kw kx iq lz b gy md me l mf mg">"baseUrl": "./src",<br/>"paths": {<br/>    "<a class="ae mz" href="http://twitter.com/modules" rel="noopener ugc nofollow" target="_blank">@c</a>omponents/*": ["api/components/*"],<br/>    "<a class="ae mz" href="http://twitter.com/services" rel="noopener ugc nofollow" target="_blank">@services</a>/*": ["services/*"]<br/>}</span></pre><p id="16d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以在应用程序中为模块导入使用新的路径别名。在你的IDE /编辑器(在我的例子中是VSC)中，或者在你编译代码的时候，不应该出现任何错误。</p><p id="163c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我们还没有完成。正如我所说的，当你试图将TS代码编译成JS时，你不会看到任何错误。但是一旦运行编译好的JS代码，就会出现错误。例如:</p><blockquote class="na nb nc"><p id="c5d4" class="jy jz nd ka b kb kc kd ke kf kg kh ki ne kk kl km nf ko kp kq ng ks kt ku kv ij bi translated">错误:找不到模块“@components/user”</p></blockquote><p id="5fce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为JS不能为声明的路径别名解析模块。</p><h2 id="af74" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">第二步:安装模块别名包</strong></h2><p id="c4f6" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">接下来，我们将安装一个名为<a class="ae mz" href="https://www.npmjs.com/package/module-alias" rel="noopener ugc nofollow" target="_blank"> module-alias </a>的npm包。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="93d6" class="kw kx iq lz b gy md me l mf mg">npm i --save module-alias</span></pre><p id="7aae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个模块在编译的JS文件中注册路径别名。因此，我们需要对我们的package.json进行一些更改:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ec87" class="kw kx iq lz b gy md me l mf mg">"_moduleAliases": {<br/>    "<a class="ae mz" href="http://twitter.com/modules" rel="noopener ugc nofollow" target="_blank">@c</a>omponents": "dist/api/components",<br/>    "<a class="ae mz" href="http://twitter.com/services" rel="noopener ugc nofollow" target="_blank">@services</a>": "dist/services"<br/>  }</span></pre><p id="8b5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意‘dist’是编译后的JS文件所在的文件夹。</p><p id="6654" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，我们必须在应用程序中注册路径别名。<br/>将下面一行添加到启动文件的顶部:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ac5f" class="kw kx iq lz b gy md me l mf mg">import 'module-alias/register';</span></pre><p id="bec8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！最后，当您编译和执行代码时，您不应该看到任何导入错误。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="76e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">本文最初发表在我的博客上。看一看。</strong></p><div class="no np gp gr nq nr"><a href="https://larswaechter.dev/blog/nodejs-ts-path-aliases/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">Node.js中带有TypeScript的路径别名</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">2019 . 02 . 06几天前，我在我的TypeScript Node.js项目中包含了路径别名。因为他们制定了代码…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">拉斯瓦切特.德夫</p></div></div></div></a></div></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="3a56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我目前正在做一个兼职项目，在这里你可以看到路径别名的作用。</p><div class="no np gp gr nq nr"><a href="https://github.com/Aionic-Apps/aionic-core" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">Aionic-Apps/aionic-core</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Aionic为项目管理和协作提供开源应用程序。我们的重点是简化和…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jw nr"/></div></div></a></div></div></div>    
</body>
</html>