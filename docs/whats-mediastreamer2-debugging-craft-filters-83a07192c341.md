# 什么是 Mediastreamer2。调试精心制作的过滤器

> 原文：<https://levelup.gitconnected.com/whats-mediastreamer2-debugging-craft-filters-83a07192c341>

![](img/12a83b61623358045d23e6557024dbff.png)

(上一篇文章[什么是 Mediastreamer2。数据移动机制](/whats-mediastreamer2-data-movement-mechanism-29444d22d36b)

在前一章我们研究了数据移动机制之后，再来讨论其中潜藏的危险也就顺理成章了。“数据流”原则的一个特点是，从堆中分配内存发生在位于数据流源头的过滤器中，位于数据流末端的过滤器已经释放了内存并将其返回到堆中。此外，新数据的创建和销毁可能发生在中间的某个地方。一般来说，数据块的内存分配和释放是由不同的过滤器完成的。

从透明地监控存储器的角度来看，过滤器在接收到输入块之后，在处理之后，立即通过释放存储器来破坏它，并且将具有输出数据的新创建的块暴露给输出是合理的。在这种情况下，过滤器中的内存泄漏很容易被跟踪——如果分析器发现过滤器中有泄漏，那么下一个过滤器没有正确地销毁传入的块，错误就在其中。但是从保持高性能的角度来看，这种处理数据块的方法效率不高，它会导致大量为数据块分配/释放内存的操作，而没有任何有用的浪费。

由于这个原因，mediastreamer 过滤器为了不减慢数据处理，在复制消息时使用了创建轻拷贝的函数(我们在前一章中讨论过)。这些函数仅通过从复制的“旧”消息中“附加”一个数据块来创建消息头的新实例。结果，两个报头被绑定到一个数据块，并且数据块中的引用计数器递增。但是它看起来像两条信息。对于这样一个“共享”数据块，可以有更多的消息，例如，MS_TEE 过滤器一次生成一打这样的轻拷贝，将它们分发给它的输出。如果链中的所有过滤器都正常工作，那么这个引用计数应该在流水线结束时达到零，并且释放内存的函数将被调用: *ms_free()* 。如果调用没有发生，那么这部分内存将不会返回到堆中，也就是说，它将“泄漏”。使用轻量级副本的代价是失去了轻松确定(就像常规副本一样)哪个图形过滤器正在泄漏内存的能力。

由于 mediastreamer 开发人员有责任在本机过滤器中查找内存泄漏，所以您可能不需要调试它们。但是有了你的工艺过滤器，你自己就是自己快乐的铁匠，你花在寻找代码漏洞上的时间将取决于你的准确性。为了减少您的调试麻烦，我们应该在过滤器设计期间考虑泄漏定位技术。此外，可能发生的情况是，只有当过滤器应用于实际系统时，泄漏才会显现出来，其中“可疑”的数量可能是巨大的，并且调试的时间是有限的。

# 内存泄漏是如何表现出来的？

合乎逻辑的假设是, *top* 程序输出将显示您的应用程序正在使用的增加的内存百分比。

外在的表现是，在某一点上，系统会对鼠标的移动做出缓慢的反应，缓慢地重绘屏幕。也有可能系统日志会增长，耗尽硬盘空间。这将导致您的应用程序行为异常，不响应命令，无法打开文件等。

为了识别泄漏的事实，我们将使用内存分析器(以下简称分析器)。它可能是 *Valgrind* 或者编译器内置的 *gcc 内存初始化器*或者其他什么东西。如果分析器显示在一个图形过滤器中发生了泄漏，那么是时候应用下面描述的方法之一了。

# 6.1 三棵松树法

如上所述，如果发生内存泄漏，分析器将指向从堆中请求内存分配的过滤器。但是他无法说出是哪一个过滤器“忘记”归还它，也就是泄漏的罪魁祸首。因此，分析者只能确认我们的担忧，而不能指出它们的根源。

要找出图中“坏”过滤器的位置，可以通过将图减少到分析器仍能检测到泄漏的最小节点数，并将问题过滤器定位在剩余的“三棵松树”中。

但是，通过减少图中过滤器的数量，您可能会破坏过滤器与系统其他元素的正常交互过程，泄漏将不再出现。在这种情况下，您将不得不使用全尺寸的图形，并使用下面概述的方法。

# 6.2 滑动绝缘子
方法

为了简化演示，我们将使用一个由一系列过滤器组成的图表。如图 6.1 所示。

![](img/d8a65e42ac2f772049ac2ac0afe3c0a2.png)

图 6.1:典型的数据处理图

一个普通的图表，其中与媒体流的现成过滤器一起，应用了四个工艺过滤器 F1 … F4，四个不同的类型，这是你很久以前制作的，并且不怀疑它们的正确性。但是，假设其中一个或多个内存泄漏。当我们运行程序来监视分析器时，我们从它的报告中了解到，某个过滤器请求了一定量的内存，并且第 N 次没有将它返回到堆中。你可以很容易地猜到 MS_VOID_SOURCE 类型的内部过滤函数会显示什么。他的任务是从堆中取出内存。其他过滤器应该会将它返回到那里。那些。在这种情况下，对我们有用的信息是泄漏的检测。

为了确定链中的哪个元素存在导致内存泄漏的不活动，建议引入一个附加的过滤器，该过滤器简单地将消息从输入转移到输出，但同时创建输入消息的正常的“重”副本(而不是轻的)，完全删除在其入口处接收的原始消息。我们将把这样的过滤器称为“绝缘体”。我们认为，由于过滤器简单，泄漏被排除。还有一个积极的特性，如果我们将它添加到图表中的任何位置，它都不会以任何方式影响电路的工作。我们将滤波器-隔离器表示为一个具有双重轮廓的圆。

在*真空源*过滤器之后，我们立即打开隔离器，如图 6.2 所示。

![](img/1e71ae22086e9346619b405d6ed807ba.png)

图 6.2:包含隔离滤波器的电路

我们再次用分析器运行程序，我们将会看到，这一次，分析器将会责怪隔离器，而不是 *voidsource* 。毕竟，现在是过滤器创建了数据块，这些数据块随后会被一个(或多个)未知的粗心过滤器丢失。下一步是将隔离器沿链向右移动一个滤波器，然后再次运行分析。因此，一步一步地向右移动绝缘体，我们会得到一种情况，即分析器下一次报告中“泄漏”的内存块的数量将会减少。这意味着在这一步，隔离器就在问题滤波器之后的链中结束。如果只有一个“坏”的过滤器，泄漏将完全消失。因此，我们已经定位了有问题的过滤器(或几个过滤器中的一个)。“修复”过滤器后，我们可以继续沿着链条向右移动绝缘体，直到完全克服泄漏。

## 滤波器隔离器实现

隔离器的实现看起来像一个常规滤波器。头文件:

清单 6.1:隔离过滤器头

```
/* File iso_filter.h  Description of the isolating filter. */#ifndef iso_filter_h
#define iso_filter_h/* Set the filter identifier. */
#include <Mediastreamer2/msfilter.h>#define MY_ISO_FILTER_ID 1024extern MSFilterDesc iso_filter_desc;#endif
```

过滤器本身:

清单 6.2:隔离过滤器源代码

```
/* File iso_filter.c  Description of the isolating filter. */#include "iso_filter.h" static void
iso_init (MSFilter * f)
{
}
    static void
iso_uninit (MSFilter * f)
{
} static void
iso_process (MSFilter * f)
{
    mblk_t *im; while ((im = ms_queue_get (f->inputs[0])) != NULL)
    {
        ms_queue_put (f->outputs[0], copymsg (im));
        freemsg (im);
    }
}static MSFilterMethod iso_methods[] = {
    {0, NULL}
};MSFilterDesc iso_filter_desc = {
    MY_ISO_FILTER_ID,
    "iso_filter",
    "A filter that reads from input and copy to its output.",
    MS_FILTER_OTHER,
    NULL,
    1,
    1,
    iso_init,
    NULL,
    iso_process,
    NULL,
    iso_uninit,
    iso_methods
};MS_FILTER_DESC_EXPORT (iso_desc)
```

# 6.3 替换
内存管理功能的方法

对于更微妙的研究，mediastreamer 提供了用您自己的功能替换内存访问功能的能力，除了主要工作之外，它还将记录“谁、在哪里以及为什么”三个功能被覆盖。这是按如下方式完成的:

清单 6.3:内存管理函数的替代

```
OrtpMemoryFunctions reserv;
OrtpMemoryFunctions my;reserv.malloc_fun = ortp_malloc;
reserv.realloc_fun = ortp_realloc;
reserv.free_fun = ortp_free;my.malloc_fun = &my_malloc;
my.realloc_fun = &my_realloc;
my.free_fun = &my_free;ortp_set_memory_functions(&my);
```

这一特性有助于防止分析仪降低滤波器速度，导致构建电路的系统中断。在这种情况下，你必须放弃分析器，使用内存函数的替代。

我们已经考虑了不包含分支的简单图形的动作算法。但是这种方法可以应用于其他情况，当然，有并发症，但想法是一样的。

在下一章中，我们将研究如何估计跑马灯的负载，以及如何处理媒体流中过多的计算负载。

(下一篇文章[什么是 Mediastreamer2。跑马灯负载管理](/whats-mediastreamer2-ticker-load-management-62d0efc9a9f0)