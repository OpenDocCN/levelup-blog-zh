<html>
<head>
<title>Create a Serverless App on AWS using TypeScript — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript在AWS上创建一个无服务器应用程序—第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-simple-serverless-application-using-typescript-and-aws-part-2-2f9192717015?source=collection_archive---------5-----------------------#2021-02-07">https://levelup.gitconnected.com/creating-a-simple-serverless-application-using-typescript-and-aws-part-2-2f9192717015?source=collection_archive---------5-----------------------#2021-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6f2944de3dc56420c2b1846cbfb65eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7lRFOL4KsktJxHLj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Philipp Katzenberger 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从我们在第一部分<a class="ae kc" href="https://sidneyb231.medium.com/creating-a-simple-serverless-application-using-typescript-and-aws-part-1-be2188f5ff93" rel="noopener"> <strong class="kf ir">如何创建一个简单的无服务器应用</strong> </a>中停止的地方继续，我们将关注如何在API Gateway中实现授权，并确保只有经过身份验证的请求才能访问我们的Lambda函数。要了解更多关于授权机制和既定实践的信息，请参见<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-control-access-to-api.html" rel="noopener ugc nofollow" target="_blank">在API网关</a>中控制和管理对REST API的访问。对于这个应用程序，我选择使用Lambda授权器来控制对本文前面部分创建的Lambda函数的访问。</p><h2 id="8b8b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">API网关Lambda授权器</h2><p id="deff" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html" rel="noopener ugc nofollow" target="_blank"> API Gateway Lambda授权器</a>是Lambda函数，由API Gateway调用以控制对我们函数的访问。有了Lambda授权器，我们可以允许一个请求继续我们的API，或者拒绝这个未经授权的请求。这意味着我们可以控制谁可以访问我们的API。</p><p id="2d66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Lambda authorizer的一个优点是，我们可以将身份验证逻辑集中在一个函数中，而不是打包在每个单独的函数中。这意味着我们能够轻松地更新和部署我们的单个auth功能，而不需要重新部署每个使用身份验证的功能。使用Lambda授权器的另一个优点是，我们能够用进行远程调用的auth逻辑缓存响应。进行这样的远程调用会给每个运行检查的函数增加不必要的延迟。Lambda authorizers还允许我们集成第三方身份提供者来控制对API Gateway中资源的访问，而不必配置诸如<a class="ae kc" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank"> Amazon Cognito </a>之类的服务。它还为我们定制授权逻辑提供了灵活性。</p><p id="28ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，使用Lambda authorizers也有一些缺点，包括API网关调用中增加的延迟。AWS Lambda有一个<a class="ae kc" href="https://hackernoon.com/cold-starts-in-aws-lambda-f9e3432adbf0" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">冷启动问题</strong> </a>，使用Lambda授权器意味着我们可能要付出两次代价——在我们的授权器函数和核心函数中。此外，如果没有缓存策略，我们将不得不处理请求流中的额外网络跳跃。使用Lambda授权器的另一个缺点是，使用授权器的每个端点都必须包含授权信息。在某些情况下，这被证明是不灵活的。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/55c0d9a417fa534394bb9aefbab72c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JcANmAzXDnePkDZYY6nJnQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Lambda授权者授权工作流— AWS</figcaption></figure><h2 id="321e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">履行</h2><p id="6d82" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">就访问控制和保护我们的基础设施而言，我们将实施如下所示的架构:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/0eb6008143b293f5eadc7035704c7dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COn8KJsXz7VQPNEm2foJpg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">认证API架构</figcaption></figure><p id="35b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单地说，当用户向我们的API网关端点发出HTTP请求时，请求必须在HTTP授权头中包含访问令牌。这将被转发到Lambda Authorizer函数，该函数使用第三方身份提供者对令牌进行身份验证。然后，它执行授权逻辑，并将身份管理策略返回给API Gateway。API Gateway使用该策略来评估是否允许用户调用所请求的API，并允许或拒绝该请求。如果允许，API Gateway会将请求转发给Lambda函数。您可以找到更多关于如何<a class="ae kc" href="https://aws.amazon.com/blogs/security/use-aws-lambda-authorizers-with-a-third-party-identity-provider-to-secure-amazon-api-gateway-rest-apis/" rel="noopener ugc nofollow" target="_blank">使用AWS Lambda授权器和第三方身份提供者来保护API Gateway REST API</a>的信息。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/f8ada83746961921d318bbbd2bb59620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ccqmmAJbbsTHkzQa"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@tolga__?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托尔加·乌尔坎</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0583" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在对于我们的应用程序，我们需要使用第三方身份提供者<a class="ae kc" href="https://auth0.com" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>创建一个基于令牌的Lambda授权器。</p><p id="caa0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://auth0.com/signup?&amp;signUpData=%7B%22category%22%3A%22docs%22%7D" rel="noopener ugc nofollow" target="_blank">免费注册auth 0</a>，在仪表盘上，点击左侧边栏菜单上的api，然后点击仪表盘上的<strong class="kf ir"> CREATE API </strong>按钮，为新项目设置API。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/d80c074a6c92dea52c85c1132a99f026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iovUUcfl7BkuFZtWdRQM0w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Auth0仪表板</figcaption></figure><p id="9fa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要为我们的API输入一个名称和标识符</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/67363814b6d30cfea9f5d0f387047f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vK9yNgivdmn06AkyQxd9JA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">新的API表单— Auth0</figcaption></figure><p id="8ee8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单击CREATE按钮创建一个新的API。</p><p id="ec35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，在API快速入门选项卡中，向下滚动并记下<code class="fe mi mj mk ml b"><strong class="kf ir">jwksUri</strong></code></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/a544472c5c6b6f0d26c1a9acf6e35afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j19LmEFlxCD1wcisi8bJ6A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Auth0 API页面</figcaption></figure><p id="4400" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及<code class="fe mi mj mk ml b">issuer</code>和<code class="fe mi mj mk ml b">audience</code>值</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/939e680c899b01604c83f962143a17c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ra48ynCDhe8y5k5lN4bwQ.png"/></div></div></figure><p id="d452" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要从我们的API页面获取<strong class="kf ir">客户端ID </strong>和<strong class="kf ir">客户端秘密</strong>:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/d3ef6467ec66b895ce59954609043d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKfzVthXTrprX6K7Ujeqig.png"/></div></div></figure><p id="2f50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要将这些值作为环境变量添加到项目中。修改<code class="fe mi mj mk ml b"><strong class="kf ir">.env</strong></code>文件并添加以下内容:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="b0fc" class="lb lc iq ml b gy mt mu l mv mw"><strong class="ml ir">// </strong>.env</span><span id="5bc1" class="lb lc iq ml b gy mx mu l mv mw"><strong class="ml ir">JWKS_URI</strong>="&lt;JWKS-VA&gt;"<br/><strong class="ml ir">AUDIENCE</strong>="&lt;AUDIENCE-VALUE&gt;"<br/><strong class="ml ir">TOKEN_ISSUER</strong>="&lt;ISSUER-VALUE&gt;"<br/><strong class="ml ir">AUTH0_CLIENT_ID</strong>="&lt;CLIENT-ID&gt;"<br/><strong class="ml ir">AUTH0_CLIENT_SECRET</strong>="&lt;CLIENT-SECRET&gt;"</span></pre><p id="845b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要创建我们的认证服务。首先，我们安装一些依赖项:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="0856" class="lb lc iq ml b gy mt mu l mv mw">$ yarn add jsonwebtoken @types/jsonwebtoken jwks-rsa</span></pre><p id="201a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建我们的<code class="fe mi mj mk ml b"><strong class="kf ir">auth.service.ts</strong></code>:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="7194" class="lb lc iq ml b gy mt mu l mv mw">$ touch src/services/auth.service.ts</span></pre><p id="01c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并更新如下:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5eb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的<code class="fe mi mj mk ml b"><strong class="kf ir">authenticate</strong></code>方法处理我们令牌认证的所有逻辑。首先，它使用<code class="fe mi mj mk ml b"><strong class="kf ir">_getToken</strong></code>方法从请求中检索令牌。这个令牌然后被<code class="fe mi mj mk ml b"><strong class="kf ir">jwt</strong></code>解码，然后我们检索<code class="fe mi mj mk ml b"><strong class="kf ir">kid</strong></code>。这个<code class="fe mi mj mk ml b"><strong class="kf ir">kid</strong></code>然后被用于使用<code class="fe mi mj mk ml b"><strong class="kf ir">_getSigningKey</strong></code>方法检索Auth0签名密钥。这个<code class="fe mi mj mk ml b"><strong class="kf ir">key</strong></code>被验证，然后我们返回策略文档。</p><p id="2b31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要创建我们的Lambda授权函数:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="b035" class="lb lc iq ml b gy mt mu l mv mw">$ mkdir src/actions/auth<br/>$ touch src/actions/auth/jwt-auth.action.ts</span></pre><p id="5fc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并更新如下:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d580" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数调用我们的认证服务<code class="fe mi mj mk ml b"><strong class="kf ir">authenticate</strong></code>方法。我们将它包装在一个try catch块中，这样任何错误都会作为一个<code class="fe mi mj mk ml b"><strong class="kf ir">Unauthorized</strong></code> <strong class="kf ir"> </strong>请求返回。</p><p id="29d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现我们新的Lambda authorizer，我们需要在我们的<code class="fe mi mj mk ml b"><strong class="kf ir">handler.ts</strong></code> <strong class="kf ir"> </strong>文件中导出我们的函数:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="0c1c" class="lb lc iq ml b gy mt mu l mv mw">// handler.ts</span><span id="bd87" class="lb lc iq ml b gy mx mu l mv mw"><em class="na">// Custom API Gateway Authorizer<br/></em>export { <em class="na">jwtAuth </em>} from './src/actions/auth/jwt-auth.action';</span></pre><p id="6908" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后更新<code class="fe mi mj mk ml b"><strong class="kf ir">functions.ts</strong></code>:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="d4c0" class="lb lc iq ml b gy mt mu l mv mw">// resources/functions.ts</span><span id="a6cd" class="lb lc iq ml b gy mx mu l mv mw">export default {<br/>    jwtAuth: {<br/>        handler: 'handler.jwtAuth',<br/>    },<br/>    ..........<br/>}</span></pre><p id="3d70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在函数中使用授权者，我们需要通过添加带有我们的授权者值的<code class="fe mi mj mk ml b"><strong class="kf ir">authorizer</strong></code>属性来更新<code class="fe mi mj mk ml b"><strong class="kf ir">http</strong></code>对象:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="7adf" class="lb lc iq ml b gy mt mu l mv mw">http: {<br/>    method: '&lt;METHOD&gt;',<br/>    path: '&lt;ENDPOINT-URI&gt;',<br/>    authorizer: {<br/>        name: 'jwtAuth'<br/>    },<br/>    cors: true<br/>}</span></pre><p id="4463" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们更新所有端点以使用授权器，这样我们的端点将不再接受没有正确授权令牌的请求:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e297" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在没有有效认证令牌的情况下向我们的端点发送请求应该会返回一个<code class="fe mi mj mk ml b"><strong class="kf ir">Unauthorized</strong></code>响应:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/bafb6b2086937354e3fc229f0e77f692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXA6Rp03MV-icfBhx3Qssg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">邮递员—失败的未授权请求</figcaption></figure><p id="5ca5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要在请求头中包含一个有效的令牌。</p><p id="6d2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要获得有效的令牌来测试我们的端点，请转到Auth0中的应用程序页面，并单击<code class="fe mi mj mk ml b"><strong class="kf ir">Quick Start</strong></code>选项卡:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/c21676872104b62cd0cd78be00aafde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jklvk0VgeL6FSxVnrvGeQ.png"/></div></div></figure><p id="01d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向下滚动到<strong class="kf ir">发送令牌API </strong>部分，复制头<code class="fe mi mj mk ml b"><strong class="kf ir">authorization</strong></code>属性的值，包括<em class="na">持有者</em></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/512a5ae90651ef073a5a0a648ab345ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jH53CEHKlwYmSh3jjYASHQ.png"/></div></div></figure><p id="aa68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要在我们的请求<code class="fe mi mj mk ml b"><strong class="kf ir">Authorization</strong></code>头中使用这个<code class="fe mi mj mk ml b"><strong class="kf ir">Bearer token</strong></code>值:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/c064a4c8e856449d95d92ce8e9f38f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAVctEkI1MhXd4JPv9HL4A.png"/></div></div></figure><p id="0c74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保<code class="fe mi mj mk ml b"><strong class="kf ir">Bearer</strong></code>和<code class="fe mi mj mk ml b"><strong class="kf ir">access_token</strong></code>之间有空间。单击Send按钮，我们应该会收到一个成功的响应:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/f2b50a3fa0dbb8067bb3cfe11ce745f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMIrCMUsjCEWkZXLVCH2wA.png"/></div></div></figure><p id="d3e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们有了安全的端点，我们还需要更新我们的<code class="fe mi mj mk ml b"><strong class="kf ir">feature</strong></code>测试。</p><p id="734e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先安装<code class="fe mi mj mk ml b"><a class="ae kc" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">dotenv</strong></a></code>，这样我们就可以将环境变量从我们的<code class="fe mi mj mk ml b"><strong class="kf ir">.env</strong></code>文件加载到<code class="fe mi mj mk ml b"><a class="ae kc" href="https://nodejs.org/docs/latest/api/process.html#process_process_env" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">process.env</strong></a></code>中，并在我们的测试处理程序中使用</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="907f" class="lb lc iq ml b gy mt mu l mv mw">$ yarn add dotenv @types/dotenv</span></pre><p id="a57c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们更新我们的<code class="fe mi mj mk ml b"><strong class="kf ir">package.json</strong></code>脚本:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="77c1" class="lb lc iq ml b gy mt mu l mv mw">"scripts": {<br/>  ....<br/>  "feature-test": "./node_modules/.bin/mocha \"tests/feature/**/*.ts\" --require ts-node/register  --require dotenv/config "<br/>},</span></pre><p id="34f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要用我们的<code class="fe mi mj mk ml b"><strong class="kf ir">BASE_URL</strong></code>变量更新我们的<code class="fe mi mj mk ml b"><strong class="kf ir">.env</strong></code>文件:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="2fbe" class="lb lc iq ml b gy mt mu l mv mw">BASE_URL=”http://localhost:3000/dev/"</span></pre><p id="0cc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们更新我们的测试处理程序<code class="fe mi mj mk ml b"><strong class="kf ir">tests/lib/actions/handler</strong></code>:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4ad7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe mi mj mk ml b"><strong class="kf ir">post</strong></code>函数从向Auth0发出客户端凭证请求开始，如果成功，返回一个<code class="fe mi mj mk ml b"><strong class="kf ir">access_token</strong></code>。有了这个<strong class="kf ir">访问令牌</strong>，我们就可以向我们的端点发出另一个请求。我在<code class="fe mi mj mk ml b">post</code>函数中添加了一个<code class="fe mi mj mk ml b"><strong class="kf ir">authorized</strong></code>参数，这样我们也可以测试对我们的API的<strong class="kf ir">未授权的</strong>请求。</p><p id="56a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们为未授权的请求创建一个测试:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="07d8" class="lb lc iq ml b gy mt mu l mv mw">$ touch tests/feature/list/create-list/unauthorized.test.ts</span></pre><p id="8e6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并添加我们的测试:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8625" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们再次运行我们的测试<code class="fe mi mj mk ml b"><strong class="kf ir">yarn run feature-test</strong></code>:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/241c4d45f5ddc50c7aa28d46b63571d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QlUOsg7huUf-BwyLXsNJGQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">功能测试</figcaption></figure><p id="b9dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要在您的工作目录中运行以下命令，将更新后的应用程序部署到默认的AWS概要文件中:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="5021" class="lb lc iq ml b gy mt mu l mv mw">$ serverless deploy</span></pre><p id="c4e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者通过运行以下命令来设置特定的配置文件:</p><pre class="ma mb mc md gt mp ml mq mr aw ms bi"><span id="cb9c" class="lb lc iq ml b gy mt mu l mv mw">$ serverless deploy --stage dev</span></pre><p id="3ae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以参考我的文章<a class="ae kc" href="https://sidneyb231.medium.com/configure-aws-for-development-and-deployment-ad822097fc22" rel="noopener">如何为本地开发和部署</a>创建AWS凭证。就是这样。</p><h1 id="2c4e" class="nh lc iq bd ld ni nj nk lg nl nm nn lj no np nq lm nr ns nt lp nu nv nw ls nx bi translated">结论</h1><p id="5a26" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">无服务器允许开发人员快速创建和部署可按需扩展且运行成本更低的微服务应用。这意味着我们获得了效率；然而，在控制和可见性方面存在权衡。无服务器缩短了开发时间，这意味着我们失败得更快。快速失败意味着我们也学得更快。</p><p id="c32c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经部署了我们的应用程序，我们可以创建一个客户端应用程序来使用我们的API。然而，我不会在这篇文章中讨论这个问题。</p><p id="5b02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文旨在演示如何创建和部署一个简单的无服务器应用程序，它使用了<a class="ae kc" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a>，<a class="ae kc" href="https://docs.aws.amazon.com/lambda/latest/dg/welcome.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">AWS Lambda</strong></a><strong class="kf ir"/>和<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> API网关</strong> </a>。我们还学习了如何使用<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">API Gateway Lambda authorizer</strong></a>来管理和控制对我们资源的访问。我们还可以通过实现一些功能来进一步改进我们的应用程序，例如使用平台<a class="ae kc" href="https://travis-ci.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">【TravisCI】</strong></a><a class="ae kc" href="https://app.circleci.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">circle ci</strong></a>或<a class="ae kc" href="https://concourse-ci.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">concoursci</strong></a>进行监控、持续集成和部署，甚至使用服务添加自定义域，例如<a class="ae kc" href="https://aws.amazon.com/route53/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">Amazon Route 53</strong></a>。AWS还提供了<a class="ae kc" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Cloudwatch </strong> </a>，实时监控我们在平台上运行的资源和应用。</p><p id="95f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章有助于您理解如何开始创建简单的无服务器应用程序和管理对这些服务的控制。我还希望，在我们继续为未来设计解决方案时，它能以某种方式激励您。</p><p id="784b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在下面包含了一个GitHub库的链接。如果对您有帮助，请随意克隆、派生或开始使用它:</p><div class="ny nz gp gr oa ob"><a href="https://github.com/s-barrah/serverless-todo" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">s-barrah/无服务器-todo</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">简单的无服务器todo应用程序您需要在本地安装以下软件包，然后再启动本地…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op jw ob"/></div></div></a></div><h1 id="88d7" class="nh lc iq bd ld ni nj nk lg nl nm nn lj no np nq lm nr ns nt lp nu nv nw ls nx bi translated">进一步阅读</h1><ul class=""><li id="9e5a" class="oq or iq kf b kg lu kk lv ko os ks ot kw ou la ov ow ox oy bi translated"><a class="ae kc" href="https://www.serverless.com/framework/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">开始使用无服务器框架</a></li><li id="70bb" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://www.serverless.com/learn/manifesto/" rel="noopener ugc nofollow" target="_blank">无服务器宣言</a></li><li id="78a1" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://www.serverless.com/learn/comparisons/" rel="noopener ugc nofollow" target="_blank">无服务器架构vs其他</a></li><li id="56c0" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://serverless.com/learn/" rel="noopener ugc nofollow" target="_blank">无服务器架构初级读本</a></li><li id="03f6" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://read.acloud.guru/our-serverless-journey-part-2-908d76d03716" rel="noopener ugc nofollow" target="_blank">我们如何将创业迁移到无服务器</a></li><li id="f3a4" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://serverless.com/blog/why-we-switched-from-docker-to-serverless/" rel="noopener ugc nofollow" target="_blank">为什么我们从Docker转向无服务器</a></li><li id="38b1" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://serverless.com/blog/serverless-faas-vs-containers/" rel="noopener ugc nofollow" target="_blank">无服务器(FaaS)与集装箱——何时选择哪个？</a></li><li id="f762" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://www.serverless.com/framework/docs/providers/aws/guide/intro/" rel="noopener ugc nofollow" target="_blank">AWS无服务器框架指南</a></li><li id="64b3" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html" rel="noopener ugc nofollow" target="_blank">IAM中的安全最佳实践</a></li><li id="8ce6" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://www.serverless.com/blog/abcs-of-iam-permissions" rel="noopener ugc nofollow" target="_blank">IAM基础知识:无服务器管理权限</a></li><li id="cfc5" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-control-access-to-api.html" rel="noopener ugc nofollow" target="_blank">在API网关中控制和管理对REST API的访问</a></li><li id="e2eb" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html" rel="noopener ugc nofollow" target="_blank">亚马逊认知用户池</a></li><li id="07e8" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html" rel="noopener ugc nofollow" target="_blank">亚马逊DynamoDB是什么？</a></li><li id="fb7e" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html" rel="noopener ugc nofollow" target="_blank">使用DynamoDB中的表格和数据</a></li><li id="96a4" class="oq or iq kf b kg oz kk pa ko pb ks pc kw pd la ov ow ox oy bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html" rel="noopener ugc nofollow" target="_blank">使用API网关λ授权器</a></li></ul></div></div>    
</body>
</html>