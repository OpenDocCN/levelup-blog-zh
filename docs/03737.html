<html>
<head>
<title>Redux Hooks with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript还原挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/redux-hooks-with-typescript-4fba08f160ad?source=collection_archive---------3-----------------------#2020-05-25">https://levelup.gitconnected.com/redux-hooks-with-typescript-4fba08f160ad?source=collection_archive---------3-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/60fd18282da9ba916dc246df98404c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ecqh5hT2nZ_QslKc"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@wasdrew?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安朵斯·瓦斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="9116" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">简介:</h1><p id="f0f3" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">本教程假设您对NPM、JavaScript、React、Redux和TypeScript有基本的了解，主要是为了帮助那些想将新的Redux挂钩集成到React TypeScript项目中的人。</p><p id="6a43" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">它旨在对初学者相对友好，所以如果您已经熟悉使用create-react-app启动一个新的React项目，或者建立一个Redux商店，请随意跳过。</p><h1 id="6193" class="kn ko it bd kp kq mo ks kt ku mp kw kx ky mq la lb lc mr le lf lg ms li lj lk bi translated">开始使用:</h1><p id="1ad6" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">通过键入以下命令，使用TypeScript创建一个新的React项目:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="c35e" class="nc ko it my b gy nd ne l nf ng">npx create-react-app redux-hooks-with-typescript --template typescript</span></pre><p id="5b79" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">通过导航到新创建的目录并运行以下命令，检查以确保所有内容都已正确安装:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="78cf" class="nc ko it my b gy nd ne l nf ng">cd redux-hooks-with-typescript<br/>npm start</span></pre><p id="1e9a" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">如果你的浏览器打开一个新的标签到localhost:3000，你会看到旋转的React标志，那么我们就可以开始了。</p><h1 id="6a19" class="kn ko it bd kp kq mo ks kt ku mp kw kx ky mq la lb lc mr le lf lg ms li lj lk bi translated">依赖关系:</h1><p id="0f2a" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">要安装我们将需要的所有依赖项，请在您的终端中键入以下行:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="6b90" class="nc ko it my b gy nd ne l nf ng">npm install redux react-redux @types/react-redux redux-devtools-extension</span></pre><p id="b641" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">每个人都有自己喜欢的文件夹结构，所以很明显你可以按照自己的想法来组织东西，但一般来说，我的方法通常是这样的:</p><p id="4588" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我会在<em class="nh"> src </em>文件夹里做一个<em class="nh"> redux </em>文件夹，把我所有的redux东西放在同一个地方。然后在那个<em class="nh"> redux </em>文件夹中，我将创建三个新文件夹，分别命名为<em class="nh"> actions </em>、<em class="nh"> reducers </em>和<em class="nh"> store </em>。所以它看起来会像这样:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="3819" class="nc ko it my b gy nd ne l nf ng">--src<br/>    --redux<br/>        --actions<br/>        --reducers<br/>        --store</span></pre><h1 id="8d28" class="kn ko it bd kp kq mo ks kt ku mp kw kx ky mq la lb lc mr le lf lg ms li lj lk bi translated">1)商店:</h1><p id="09de" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在<em class="nh"> store </em>文件夹中，触摸一个名为<strong class="ln iu"> store.ts </strong>的新文件，打开它并键入以下代码:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="1f0f" class="nc ko it my b gy nd ne l nf ng">import { createStore } from 'redux'<br/>import rootReducer from '../reducers/rootReducter'<br/>import { devToolsEnhancer } from 'redux-devtools-extension'</span><span id="ed7d" class="nc ko it my b gy ni ne l nf ng">const store = createStore(rootReducer, devToolsEnhancer({}));</span><span id="95c0" class="nc ko it my b gy ni ne l nf ng">export default store;</span></pre><p id="d1c7" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">不要担心<em class="nh"> rootReducer </em> <strong class="ln iu"> </strong>，我们马上就要创建它了。</p><p id="0203" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我们现在做的是使用“redux”包中的<em class="nh"> createStore </em>函数来设置我们的redux商店。我们还将<em class="nh"> devToolsEnhancer </em>添加到商店中，这样我们就可以在浏览器中看到所有可爱的Redux devtools。</p><blockquote class="nj nk nl"><p id="6d9f" class="ll lm nh ln b lo mj lq lr ls mk lu lv nm ml ly lz nn mm mc md no mn mg mh mi im bi translated">你需要在chrome中安装Redux dev工具，以便在浏览器中使用它们。您可以在此处安装它们:</p><p id="f88e" class="ll lm nh ln b lo mj lq lr ls mk lu lv nm ml ly lz nn mm mc md no mn mg mh mi im bi translated"><a class="ae kf" href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en" rel="noopener ugc nofollow" target="_blank">https://chrome . Google . com/web store/detail/redux-dev tools/lmhkpmbekcpmnklioeibfkpmmfibljd？hl=en </a></p></blockquote><p id="2ba9" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我们传递给<em class="nh"> devToolsEnhancer </em>的空对象只是表明我们没有为redux开发工具使用任何特定的选项。我们只需要传递一些东西给它，因为函数需要一个对象，否则就不能工作。</p><p id="90a9" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">下一步是向我们的React应用程序提供对该商店的访问。</p><h1 id="f948" class="kn ko it bd kp kq mo ks kt ku mp kw kx ky mq la lb lc mr le lf lg ms li lj lk bi translated">2)提供商:</h1><p id="f70d" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">打开src目录中的<strong class="ln iu"> index.tsx </strong>文件，从“react-redux”包中导入提供者组件，以及我们刚刚创建的新的<strong class="ln iu"> store.ts </strong>文件。</p><blockquote class="nj nk nl"><p id="4586" class="ll lm nh ln b lo mj lq lr ls mk lu lv nm ml ly lz nn mm mc md no mn mg mh mi im bi translated">如果您想避免“商店/商店”导入，只需键入，您也可以将<strong class="ln iu">商店. ts </strong>文件重命名为<strong class="ln iu">索引. ts </strong>。/redux/store '</p></blockquote><p id="a262" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">然后用<Provider/>组件包装<App/>组件，并将我们刚刚创建的<strong class="ln iu">存储</strong>传递给&lt;提供者/ &gt;组件需要的存储参数。</p><p id="0392" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">您的代码应该如下所示:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="e155" class="nc ko it my b gy nd ne l nf ng">import { Provider } from 'react-redux'<br/>import store from './redux/store/store'</span><span id="9c63" class="nc ko it my b gy ni ne l nf ng">...</span><span id="ecb7" class="nc ko it my b gy ni ne l nf ng">&lt;Provider store={store}&gt;<br/>    &lt;App/&gt;<br/>&lt;/Provider&gt;</span><span id="decf" class="nc ko it my b gy ni ne l nf ng">...</span></pre><h1 id="c9fe" class="kn ko it bd kp kq mo ks kt ku mp kw kx ky mq la lb lc mr le lf lg ms li lj lk bi translated">3)减速器:</h1><p id="2cb5" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在<em class="nh"> reducers </em>文件夹中，我们继续创建三个不同的文件，这样我们就可以看到如何将reducers合并成一个<em class="nh"> rootReducer。</em>分别命名为<strong class="ln iu"> nameReducer.ts </strong>、<strong class="ln iu"> countReducer.ts、</strong>和<strong class="ln iu"> rootReducer.ts </strong>。</p><p id="20a5" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在<strong class="ln iu"> nameReducer.ts </strong>中输入以下代码:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="f449" class="nc ko it my b gy nd ne l nf ng">import { NameActions } from "../actions/nameActions"</span><span id="4ce0" class="nc ko it my b gy ni ne l nf ng">type NameState = {<br/>name: string;<br/>}</span><span id="abeb" class="nc ko it my b gy ni ne l nf ng">const initialState: NameState = {<br/>name: '',<br/>}</span><span id="1c67" class="nc ko it my b gy ni ne l nf ng">const NameReducer = (state: NameState = initialState, action: NameActions) =&gt; {<br/>    switch(action.type) {<br/>        case 'SET_NAME':<br/>            return {<br/>                ...state,<br/>                name: action.payload,<br/>            }<br/>        default:<br/>            return state;<br/>    }<br/>}</span><span id="333e" class="nc ko it my b gy ni ne l nf ng">export default NameReducer;</span></pre><p id="c303" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在<strong class="ln iu"> countReducer.ts </strong>中输入以下代码:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="97db" class="nc ko it my b gy nd ne l nf ng">import { CountActions } from "../actions/countActions";</span><span id="dcdd" class="nc ko it my b gy ni ne l nf ng">type CountState = {<br/>    count: number;<br/>}</span><span id="e396" class="nc ko it my b gy ni ne l nf ng">const initialState: CountState = {<br/>    count: 0,<br/>}</span><span id="cd30" class="nc ko it my b gy ni ne l nf ng">const countReducer = (state: CountState = initialState, action: CountActions) =&gt; {<br/>    switch(action.type) {<br/>        case 'DECREMENT':<br/>            return {<br/>                ...state,<br/>                count: state.count - 1,<br/>            }<br/>        case 'INCREMENT':<br/>            return {<br/>                ...state,<br/>                count: state.count + 1,<br/>            }<br/>        default:<br/>            return state;<br/>    }<br/>}</span><span id="3668" class="nc ko it my b gy ni ne l nf ng">export default countReducer;</span></pre><p id="3d06" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在前两个代码块中，我们刚刚设置了两个非常基本的Redux reducers。你会注意到它们都有非常相似的结构:我们在顶部声明TypeScript类型，后面是用于每个特定reducer的实际初始状态对象，然后reducer函数本身只是一个接受两个参数的函数——一个<strong class="ln iu">状态</strong>对象(我们刚刚在上面定义了)和一个<strong class="ln iu">动作</strong>对象。</p><blockquote class="nj nk nl"><p id="ab82" class="ll lm nh ln b lo mj lq lr ls mk lu lv nm ml ly lz nn mm mc md no mn mg mh mi im bi translated">当我们分派动作时，action对象被提供给reducer，您将在下面看到。我们还将为下面的操作定义TypeScript类型。我保证，一切都会联系起来的！</p></blockquote><p id="2562" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">然后我们在<strong class="ln iu">动作上运行一个switch语句，并根据我们匹配的案例返回一个新的对象。该新对象将替换先前保存在<strong class="ln iu">状态</strong>变量中的对象。这就是Redux更新状态的方式。这也是我们通常做逻辑计算之类的地方。只要我们从每个case中返回一个对象，Redux就会很高兴。</strong></p><p id="aebc" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">接下来，我们只需要制作一个reducer来将所有的reducer连接成一个，因为这是Redux喜欢的方式(还记得我们在设置<strong class="ln iu"> store.ts </strong>文件时—<em class="nh">createStore()</em>函数只接受一个reducer的单个参数)。我们将称这个新的减速器为<strong class="ln iu"> rootReducer。</strong></p><p id="1959" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">打开<strong class="ln iu"> rootReducer.ts </strong>并输入以下代码:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="af14" class="nc ko it my b gy nd ne l nf ng">import { combineReducers } from 'redux'<br/>import countReducer from './countReducer'<br/>import nameReducer from './nameReducer';</span><span id="a7f3" class="nc ko it my b gy ni ne l nf ng">const rootReducer = combineReducers({<br/>    count: countReducer,<br/>    name: nameReducer,<br/>})</span><span id="c825" class="nc ko it my b gy ni ne l nf ng">export type AppState = ReturnType&lt;typeof rootReducer&gt;</span><span id="9690" class="nc ko it my b gy ni ne l nf ng">export default rootReducer;</span></pre><p id="5c20" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在这个代码块中，我们使用了<em class="nh"> combineReducers() </em>函数将缩减器组合成一个单独的<strong class="ln iu"> rootReducer </strong>。我们只是给这个函数传递一个带有键的对象，我们希望用这些键来标识每个缩减器。我选择用“计数”来表示<strong class="ln iu"> countReducer </strong>，用“名称”来表示<strong class="ln iu"> nameReducer，</strong>，但是您可以随意使用任何对您有意义的名称。</p><p id="eae3" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">然后我们还定义了一个名为<strong class="ln iu"> AppState </strong>的新TypeScript类型，并将其定义为新的<strong class="ln iu"> rootReducer的返回类型。</strong>这只是定义<strong class="ln iu"> AppState </strong>的一种简单方法，当我们将来添加更多的reducers时，AppState 会自动更新。</p><h1 id="fa46" class="kn ko it bd kp kq mo ks kt ku mp kw kx ky mq la lb lc mr le lf lg ms li lj lk bi translated">4)行动:</h1><p id="28c0" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在<em class="nh"> actions </em>文件夹中，添加两个名为<strong class="ln iu"> countActions.ts </strong>和<strong class="ln iu"> nameActions.ts </strong>的文件</p><p id="86f4" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">打开<strong class="ln iu"> countActions.ts </strong>，输入以下代码:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="2d13" class="nc ko it my b gy nd ne l nf ng">export interface IIncrementCountAction {<br/>    readonly type: 'INCREMENT';<br/>}</span><span id="a0eb" class="nc ko it my b gy ni ne l nf ng">export interface IDecrementCountAction {<br/>    readonly type: 'DECREMENT';<br/>}</span><span id="a505" class="nc ko it my b gy ni ne l nf ng">export type CountActions =<br/>| IIncrementCountAction<br/>| IDecrementCountAction</span></pre><p id="dc50" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">打开<strong class="ln iu"> nameActions.ts </strong>并输入以下代码:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="84e4" class="nc ko it my b gy nd ne l nf ng">export interface ISetNameAction {<br/>    readonly type: 'SET_NAME';<br/>    payload: string;<br/>}</span><span id="bab4" class="nc ko it my b gy ni ne l nf ng">export type NameActions =<br/>| ISetNameAction</span></pre><p id="fdcd" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在这里，我们只是定义了可以分派给我们的reducer的所有动作类型(当我们分派一个动作时，您将在下面看到，<strong class="ln iu"> action </strong>对象被传递给我们的每个reducer)。这是我们定义物体形状的地方。</p><blockquote class="nj nk nl"><p id="10cd" class="ll lm nh ln b lo mj lq lr ls mk lu lv nm ml ly lz nn mm mc md no mn mg mh mi im bi translated">每个动作都必须有一个“type”键，因为我们设置的reducers将使用这个“type”作为switch语句，来决定采取哪个动作。(希望事情现在开始变得更有意义了！)</p></blockquote><p id="d8e6" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我们还将所有的动作接口合并成一个单一的类型脚本类型。当我们开始分派动作时，这将非常方便，您将在下一节看到这一点。</p><blockquote class="nj nk nl"><p id="8f7f" class="ll lm nh ln b lo mj lq lr ls mk lu lv nm ml ly lz nn mm mc md no mn mg mh mi im bi translated">对于熟悉Redux的人来说，您会注意到我没有创建任何动作创建器或动作常量——这是有意的。通过使用TypeScript类型，您可以确保redux动作类型总是被正确使用，并且不包含任何拼写错误，您甚至可以访问它们的IntelliSense完成功能！所以动作创建器和常量有些不必要，但是，如果你真的喜欢动作创建器的工作流程，可以像往常一样随意合并它们。</p></blockquote><h1 id="54f0" class="kn ko it bd kp kq mo ks kt ku mp kw kx ky mq la lb lc mr le lf lg ms li lj lk bi translated">5)连接一切:</h1><p id="5e96" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">打开<em class="nh"> src </em>文件夹中的<strong class="ln iu"> App.tsx </strong>组件，将文件中的所有代码替换为以下代码:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="f531" class="nc ko it my b gy nd ne l nf ng">import React, { Dispatch } from 'react';<br/>import { useSelector, useDispatch } from 'react-redux';<br/>import { AppState } from './redux/reducers/rootReducter';<br/>import { CountActions } from './redux/actions/countActions';<br/>import { NameActions } from './redux/actions/nameActions';</span><span id="57fd" class="nc ko it my b gy ni ne l nf ng">function App() {<br/>    const { count } = useSelector((state: AppState) =&gt; state.count);<br/>    const { name } = useSelector((state: AppState) =&gt; state.name);<br/>    const countDispatch = useDispatch&lt;Dispatch&lt;CountActions&gt;&gt;();<br/>    const nameDispatch = useDispatch&lt;Dispatch&lt;NameActions&gt;&gt;();</span><span id="9421" class="nc ko it my b gy ni ne l nf ng">    const handleIncrement = () =&gt; {<br/>        countDispatch({type: 'INCREMENT'});<br/>    }</span><span id="15f6" class="nc ko it my b gy ni ne l nf ng">    const handleDecrement = () =&gt; {<br/>        countDispatch({type: 'DECREMENT'});<br/>    }</span><span id="a691" class="nc ko it my b gy ni ne l nf ng">    const handleSetName = <br/>        (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {<br/>        nameDispatch({type: 'SET_NAME', payload: e.target.value})<br/>    }</span><span id="9f70" class="nc ko it my b gy ni ne l nf ng">    return (<br/>        &lt;div&gt;<br/>            &lt;div&gt;<br/>                &lt;button onClick={handleIncrement}&gt;+&lt;/button&gt;<br/>                {count}<br/>                &lt;button onClick={handleDecrement}&gt;-&lt;/button&gt;<br/>            &lt;/div&gt;<br/>            &lt;div&gt;<br/>                &lt;input type="text" onChange={handleSetName}/&gt;<br/>                {name}<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span><span id="b29c" class="nc ko it my b gy ni ne l nf ng">export default App;</span></pre><p id="8bef" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">所以，我们终于到了Redux挂钩！</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h2 id="ff93" class="nc ko it bd kp np nq dn kt nr ns dp kx lw nt nu lb ma nv nw lf me nx ny lj nz bi translated">使用选择器:</h2><p id="2491" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">首先，我们使用<strong class="ln iu"> useSelector </strong>钩子从Redux获取<strong class="ln iu"> AppState </strong>。它使用对象析构语法，很像其他React钩子。</p><p id="c347" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><strong class="ln iu"> useSelector </strong>钩子期待一个回调函数，并将来自<strong class="ln iu"> rootReducer </strong>的<strong class="ln iu">状态</strong>对象提供给那个回调函数(这就是我们在<strong class="ln iu"> rootReducer.ts </strong>文件中定义的<strong class="ln iu"> AppState </strong>类型派上用场的地方)。</p><p id="426d" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">回调函数非常简单——它只返回那个<strong class="ln iu">状态</strong>对象，或者在我们的例子中，返回对<strong class="ln iu"> countReducer中的<strong class="ln iu">状态</strong>对象的引用的<strong class="ln iu"> state.count，</strong>。</strong></p><p id="09e1" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">因此，我们只需从返回的对象中析构计数<strong class="ln iu">并像平常一样在组件中使用它。</strong></p><blockquote class="nj nk nl"><p id="b3c0" class="ll lm nh ln b lo mj lq lr ls mk lu lv nm ml ly lz nn mm mc md no mn mg mh mi im bi translated">记得我们在<strong class="ln iu"> rootReducer </strong>中将<strong class="ln iu"> countReducer </strong>重命名为“计数”。</p></blockquote><p id="1384" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我们以非常相似的方式从<strong class="ln iu">名称缩减器</strong>中访问<strong class="ln iu">名称</strong>。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h2 id="c533" class="nc ko it bd kp np nq dn kt nr ns dp kx lw nt nu lb ma nv nw lf me nx ny lj nz bi translated">使用补丁:</h2><p id="bdbe" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">接下来，我们使用<strong class="ln iu"> useDispatch </strong>钩子来设置我们的动作调度程序。没有TypeScript，这个钩子的语法简单得令人难以置信:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="0c3d" class="nc ko it my b gy nd ne l nf ng">const dispatch = useDispatch();</span></pre><p id="b039" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">但是——通过使用TypeScript，我们获得了Redux操作的类型检查和智能感知自动完成的全部能力！TypeScript语法如下所示:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="c9c7" class="nc ko it my b gy nd ne l nf ng">const countDispatch = useDispatch&lt;Dispatch&lt;CountActions&gt;&gt;();<br/>const nameDispatch = useDispatch&lt;Dispatch&lt;NameActions&gt;&gt;();</span></pre><p id="2bfa" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><strong class="ln iu">分派</strong>类型实际上来自React，所以我们不用担心那个，然后<strong class="ln iu"> CountActions </strong>来自我们上面在<strong class="ln iu"> countActions.ts </strong>中定义的动作类型。</p><p id="a596" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">要使用分派，我们只需传入一个我们在<strong class="ln iu"> countActions.ts </strong>和<strong class="ln iu"> nameActions.ts </strong>文件中定义的action对象(在这里，您还可以使用action creator函数和常量，如老派的Redux，但使用TypeScript，这有点多余)。该语法如下所示:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="3742" class="nc ko it my b gy nd ne l nf ng">...</span><span id="71df" class="nc ko it my b gy ni ne l nf ng">countDispatch({type: "INCREMENT"});</span><span id="5c1b" class="nc ko it my b gy ni ne l nf ng">...</span><span id="d0cd" class="nc ko it my b gy ni ne l nf ng">nameDispatch({type: "SET_NAME", payload: e.target.value})</span><span id="4eea" class="nc ko it my b gy ni ne l nf ng">...</span></pre><p id="b5a2" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">现在一切终于都应该设置好了！运行npm start并查看结果。打开开发者工具窗口中的<em class="nh"> Redux </em>选项卡，查看所有工作。</p><h1 id="f543" class="kn ko it bd kp kq mo ks kt ku mp kw kx ky mq la lb lc mr le lf lg ms li lj lk bi translated">结论:</h1><p id="55d4" class="pw-post-body-paragraph ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我希望这能帮助你更好地理解带有TypeScript的Redux挂钩！我知道这看起来像是做了很多准备工作，但是你做得越多，事情就越简单，Redux为大型项目提供的便利是绝对难以置信的，TypeScript添加的类型检查和智能感知使整个事情感觉更加直观。我已经完全爱上了这个工作流程，我希望你也一样！</p><p id="8860" class="pw-post-body-paragraph ll lm it ln b lo mj lq lr ls mk lu lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我相信这篇文章有很多方法可以改进或扩展，所以请随意分享任何想法/问题/顾虑。我和其他人一样喜欢学习新东西！</p></div></div>    
</body>
</html>