<html>
<head>
<title>A new state management for React: Recoil</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种新的反应状态管理:反冲</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-new-state-management-for-react-recoil-53ad7480faa4?source=collection_archive---------5-----------------------#2020-05-15">https://levelup.gitconnected.com/a-new-state-management-for-react-recoil-53ad7480faa4?source=collection_archive---------5-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/aa8e3be3e2e6dfe22c6e1afecb0b9200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zlZ5hsmGgEfe-ohv"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">费伦茨·阿尔马西在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0af0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你肯定知道Redux最著名的中间件:Saga和Thunk。您最近还了解了新的上下文API。但是你听说过<a class="ae kf" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">后座力</a>吗？</p><p id="fa3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还是在实验层面，<a class="ae kf" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>对于状态管理来说是一个惊人的改进。</p><p id="c3d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">请记住，Redux或反冲都不是React的官方状态管理。它们都是库，都是为React设计的。但是它们都不是React核心的一部分</strong></p><p id="bbb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想要一个关于后坐力的完整解释。我强烈建议你去看它的创作者制作的原始视频</p><p id="1ced" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.youtube.com/watch?v=fb3cOMFkEzs" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=fb3cOMFkEzs</a></p><p id="8a0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但总结这段视频，现有状态管理的主要缺点要么是它们的可扩展性，要么是它们的实现方式。</p><h2 id="f4dd" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">Redux</h2><p id="181f" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Redux当然是最有名的。许多公司都使用它，它允许有一个全局状态，注册组件，每次注册的值改变时，组件会自己重新呈现。</p><p id="081e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，Redux应该只用于UI值。你应该<strong class="ki iu">永远不要</strong>使用Redux来管理输入的值。原因很简单:每次你在做Redux store的更新。在后台，存储的完整副本正在执行，然后应用新值，只有在此之后，以前的存储才会被擦除。现在假设我们有一个包含100多个值的大型商店？对于你输入的每一个字母，商店都会被复制。它会导致内存泄漏和非常糟糕性能。</p><h2 id="de13" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">上下文API</h2><p id="0fad" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">上下文API表现为组件之间的公共状态。它不是用来取代Redux的，因为滥用它们会使你的代码很难维护。在视频的例子中，我们有一个正方形的绘图应用程序(比如Draw.io ),边上有组件来管理它们的宽度和高度。在使用上下文API的情况下，为了避免每次方块改变时都重新呈现所有方块，您必须为每个方块创建一个上下文。这是可行的，但调试将是一场噩梦。</p><h2 id="1591" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">报应</h2><p id="3e37" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">反冲就是用所谓的<strong class="ki iu">原子</strong>来管理每个组件的状态。它们非常容易创建，甚至更容易使用，因为它们使用的是与useState完全相同的API。此外，原子可以非常容易地创建，因为它们可以通过id来识别。然后，您只需向每个原子的键添加一个动态值，就可以轻松管理每个组件的阶段</p><p id="7f90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开始编写代码之前，让我们先看看什么是原子。</p><p id="77b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过调用函数<code class="fe mc md me mf b">atom</code>对原子进行初始化</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="1a0f" class="le lf it mf b gy mo mp l mq mr">export const counterAtom = atom({<br/>  key: 'counter',<br/>  default: 0<br/>})</span></pre><p id="a93e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们声明了原子<code class="fe mc md me mf b">counterAtom</code> <br/>每个原子必须有一个唯一的标识符<code class="fe mc md me mf b">key</code>和一个值<code class="fe mc md me mf b">default</code></p><p id="65bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当原子被声明时，我们可以用一个特定的钩子来得到它</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="1eb8" class="le lf it mf b gy mo mp l mq mr">const [counter, setCounter] = useRecoilState(counterAtom);</span></pre><p id="6acf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经准备好使用它了！</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="fa59" class="mz lf it bd lg na nb nc lj nd ne nf lm ng nh ni lp nj nk nl ls nm nn no lv np bi translated">我们来编码吧！</h1><p id="89e4" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">首先，让我们创建一个新的react项目。创建-反应-应用是快速做到这一点的最佳选择</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2fdf" class="le lf it mf b gy mo mp l mq mr">npx create-react-app recoil-test</span></pre><p id="8c9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Npx是npm中包含的一个命令，允许在不安装cli的情况下运行CLI</p><p id="41cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一切完成后，跳进它(<code class="fe mc md me mf b">cd recoil-test</code>)并安装反冲库</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="167c" class="le lf it mf b gy mo mp l mq mr">npm install --save recoil</span></pre><p id="2df2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者用纱线</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="20ab" class="le lf it mf b gy mo mp l mq mr">yarn add recoil</span></pre><p id="b886" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一切都已安装完毕，可以运行了。您可以使用<code class="fe mc md me mf b">npm start</code>启动您的开发环境，一个新的浏览器选项卡将在<code class="fe mc md me mf b">http://localhost:3000</code>打开</p><p id="cbf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在为了测试的目的，我们将递增和递减一个计数器。我们需要三种成分。第一个只会递增，第二个只会递减，最后，第三个只会显示计数器值。</p><p id="3e1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建两个文件:<code class="fe mc md me mf b">ComponentIncrement</code>和<code class="fe mc md me mf b">ComponentValue</code>第一个文件将增加值，第二个文件只显示它。我们仍然希望第一个组件显示更好理解的值。</p><p id="65f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在相应的文件中添加以下代码(参见注释)</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="f1e7" class="le lf it mf b gy mo mp l mq mr">// <!-- -->ComponentIncrement<!-- -->.js<br/>import React from "react";<br/><br/>export default function ComponentIncrement() {<br/><br/>  function onIncrementClick() {}<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;Component 1&lt;/p&gt;<br/>      &lt;input onClick={onIncrementClick} type="submit" value="Increment"/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="b6e5" class="le lf it mf b gy nq mp l mq mr">// ComponentValue.js<br/>import React from "react";<br/><br/>export default function ComponentValue() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;Component Value Only&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="2066" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，结果可能不是很有趣。我们现在要创建我们的<code class="fe mc md me mf b">Atom</code>。</p><p id="9e87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建一个<code class="fe mc md me mf b">Atoms.js</code>文件，并将下面的代码粘贴到其中</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="cedf" class="le lf it mf b gy mo mp l mq mr">import { atom } from 'recoil';<br/><br/>export const counterAtom = atom({<br/>  key: 'counter',<br/>  default: 0<br/>})</span></pre><p id="aac5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，我们正在创建一个新的<code class="fe mc md me mf b">counterAtom</code>，它有一个键<code class="fe mc md me mf b">counter</code>，它的默认值是<code class="fe mc md me mf b">0</code></p><p id="34b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在拥有了分享这种状态所需的一切！回到我们最初创建的文件，让我们通过以下方式更改我们的<code class="fe mc md me mf b">ComponentIncrement.js</code>的代码</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="4ddb" class="le lf it mf b gy mo mp l mq mr">import React from "react";<br/>import {counterAtom} from "./Atoms";<br/>import {useRecoilState} from "recoil";<br/><br/>export default function ComponentIncrement() {<br/>// As useState, we are calling the hook useRecoilState and give as parameter the counterAtom we created<br/>const [counter, setCounter] = useRecoilState(counterAtom);<br/><br/>  function onIncrementClick() {<br/>    setCounter(counter + 1);<br/>  }<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;Component 1&lt;/p&gt;<br/>      &lt;p&gt;{counter}&lt;/p&gt;<br/>      &lt;input onClick={onIncrementClick} type="submit" value="Increment"/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="e33a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这个组件通过使用<code class="fe mc md me mf b">useRecoilState</code>钩子从原子获取值，并赋予它<code class="fe mc md me mf b">counterAtom</code></p><p id="58f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，输出与<code class="fe mc md me mf b">useState</code>一模一样，非常容易理解！</p><p id="b9fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能在这段代码中发现了一个错误。这会导致无效的增量。确实！如果单击次数过多，计数器可能无法正确递增。<code class="fe mc md me mf b">setCounter</code>将会，因为与<code class="fe mc md me mf b">useState</code>中setter的行为方式相同，这意味着它是异步的！由于点击次数太快，您可能会得到一个过时的值或<code class="fe mc md me mf b">counter</code></p><p id="5602" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们把<code class="fe mc md me mf b">onIncrementClick</code>里面的代码改成这样:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="b57b" class="le lf it mf b gy mo mp l mq mr">setCounter((current) =&gt; current + 1);</span></pre><p id="bdb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开始了。这样，您就可以确保使用最新的<code class="fe mc md me mf b">counter</code>值，因此每次点击都会正确递增。</p><p id="18df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是第二个文件。让我们把代码改成<code class="fe mc md me mf b">ComponentValue.js</code>这样:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="4c3b" class="le lf it mf b gy mo mp l mq mr">import React from "react";<br/>import {useRecoilState, useRecoilValue} from "recoil";<br/>import {counterAtom} from "./Atoms";<br/><br/>export default function ComponentValue() {<br/>  const counter = useRecoilValue(counterAtom);<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;Component Value Only&lt;/p&gt;<br/>      &lt;p&gt;{counter}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="e56a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在这里使用了另一个钩子<code class="fe mc md me mf b">useRecoilValue</code>，这个钩子只返回值。您可以将它用于不需要更改值的组件。</p><p id="f73c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要忘记在您的<code class="fe mc md me mf b">App.js</code>中调用这些组件</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="7bdc" class="le lf it mf b gy mo mp l mq mr">import React from 'react';<br/>import ComponentIncrement from "./ComponentIncrement";<br/>import ComponentValue from "./ComponentValue";<br/><br/>function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ComponentIncrement/&gt;<br/>      &lt;ComponentValue/&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default App;</span></pre><p id="4df8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在它工作之前的最后一件事是，你必须用一个<code class="fe mc md me mf b">Provider</code>包装你的应用程序，就像Redux或Context所做的那样。</p><p id="7907" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">打开您的<code class="fe mc md me mf b">index.js</code>文件并应用这些更改</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="166a" class="le lf it mf b gy mo mp l mq mr">...<br/>import { RecoilRoot } from 'recoil';<br/>...</span><span id="9113" class="le lf it mf b gy nq mp l mq mr">&lt;RecoilRoot&gt;<br/>  &lt;App /&gt;<br/>&lt;/RecoilRoot&gt;</span></pre><p id="421b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保存您的代码并转移到您的react应用程序！单击增量按钮，您将看到两个值都在变化！很棒，不是吗？实现起来真的很简单，也不需要太多维护！</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="ff2d" class="mz lf it bd lg na nb nc lj nd ne nf lm ng nh ni lp nj nk nl ls nm nn no lv np bi translated">使用相同原子的多个组件</h1><p id="e4d1" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">举例来说，可能(将会)发生这样的情况，你有一个列表，而这个列表使用相同的原子。在这种情况下，您希望每个列表都有自己的原子状态。</p><p id="c083" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们改变我们的代码，使之与之兼容。让我们在名为<code class="fe mc md me mf b">CountersWrapper.js</code>的文件中创建一个新组件</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="9607" class="le lf it mf b gy mo mp l mq mr">import React from "react";<br/>import ComponentIncrementWithId from "./ComponentIncrementWithId";<br/>import ComponentValueWithId from "./ComponentValueWithId";<br/><br/>export default function CountersWrapper(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h2&gt;Wrapper with id {props.id}&lt;/h2&gt;<br/>      &lt;div style={{display: 'flex', flexDirection: 'row'}}&gt;<br/>        &lt;ComponentIncrementWithId id={props.id}/&gt;<br/>        &lt;ComponentValueWithId id={props.id} /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="f7c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">复制<code class="fe mc md me mf b">ComponentIncrement.js</code>和<code class="fe mc md me mf b">ComponentValue.js</code>并在每一个的末尾添加<code class="fe mc md me mf b">WithId</code>。我们将改变一些内容，以便能够使用我们通过道具提供的新<code class="fe mc md me mf b">id</code>。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="939b" class="le lf it mf b gy mo mp l mq mr">// ComponentIncrementWithId.js<br/>import React from "react";<br/>import {counterWithId} from "./Atoms";<br/>import {useRecoilState} from "recoil";<br/><br/>export default function ComponentIncrementWithId(props) {<br/>  const [counter, setCounter] = useRecoilState(counterWithId(props.id));<br/><br/>  function onIncrementClick() {<br/>    setCounter((current) =&gt; current + 1);<br/>  }<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;Component 1&lt;/p&gt;<br/>      &lt;p&gt;{counter}&lt;/p&gt;<br/>      &lt;input onClick={onIncrementClick} type="submit" value="Increment"/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="02ac" class="le lf it mf b gy nq mp l mq mr">// ComponentValueWithId.js<br/>import React from "react";<br/>import {useRecoilValue} from "recoil";<br/>import {counterWithId} from "./Atoms";<br/><br/>export default function ComponentValueWithId(props) {<br/>  const counter = useRecoilValue(counterWithId(props.id));<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;Component Value Only&lt;/p&gt;<br/>      &lt;p&gt;{counter}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="79a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，我们正在调用一个名为<code class="fe mc md me mf b">counterWithId</code>的新函数，它将<code class="fe mc md me mf b">props.id</code>作为参数。让我们实现这个函数。<br/>跳转到<code class="fe mc md me mf b">Atoms.js</code>文件并添加以下代码</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="22d3" class="le lf it mf b gy mo mp l mq mr">export const counterWithId = (id) =&gt; atom({<br/>  key: `counter${id}`,<br/>  default: 0<br/>})</span></pre><p id="0d5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原理和第一个一样。但是我们通过添加作为参数传递的<code class="fe mc md me mf b">id</code>来使这个键动态化。</p><p id="a9e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，只需将<code class="fe mc md me mf b">App.js</code>的返回改为</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="088f" class="le lf it mf b gy mo mp l mq mr">return (<br/>  &lt;div&gt;<br/>    &lt;CountersWrapper id={1}/&gt;<br/>    &lt;CountersWrapper id={2}/&gt;<br/>    &lt;CountersWrapper id={3}/&gt;<br/>  &lt;/div&gt;<br/>);</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi gj"><img src="../Images/c7d501fae4111ae932889044e86c642b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NpLtMIB1tUlC-aPpADdGw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">3种不同状态的最终结果</figcaption></figure><p id="9c8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们到了！我们可以“动态地”创建3个不同的原子，每个包装器都有自己的状态！</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="3077" class="mz lf it bd lg na nb nc lj nd ne nf lm ng nh ni lp nj nk nl ls nm nn no lv np bi translated">结论</h1><p id="6d09" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">反冲是实验性的，您绝对不应该在生产环境中尝试它！但这是非常有希望的，我希望不久之后，我们将能够在react应用程序中更容易地维护状态，让我们的生活更轻松！</p><p id="2e1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你当然可以在<a class="ae kf" href="https://github.com/psyycker/recoil-test" rel="noopener ugc nofollow" target="_blank">我的回购</a>上找到最终代码</p><p id="36ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读！</p><p id="b6d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">雷米</p></div></div>    
</body>
</html>