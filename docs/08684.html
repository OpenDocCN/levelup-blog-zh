<html>
<head>
<title>Kotlin Makes Lombok Obsolete</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林让龙目岛过时了</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kotlin-makes-lombok-obsolete-9ed3318596cb?source=collection_archive---------3-----------------------#2021-05-25">https://levelup.gitconnected.com/kotlin-makes-lombok-obsolete-9ed3318596cb?source=collection_archive---------3-----------------------#2021-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8530" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何从龙目岛迁移到科特林</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/97b49b45d4bbaf6742f8ae53a2678218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rA32DY40hZFTvfnj39uP9w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯·布里格斯在<a class="ae kv" href="https://unsplash.com/s/photos/migrating?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8c38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的团队喜欢用Kotlin编码。事实上，我们非常喜欢它，我们正在将现有的Java项目转换成Kotlin。这些Java项目大多使用Lombok。我们认为这将是一个很好的实验，看看我们是否可以用惯用的Kotlin代码替换我们所有的Lombok注释Java类。</p><p id="bf83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">标题泄露了我们的实验结果。Kotlin的内置特性几乎覆盖了所有的Lombok注释。本文将研究Kotlin对Lombok注释的替换，并讨论这些替换与Lombok注释的不同之处。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9dd9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">@数据和@值</h1><p id="4c4c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们经常需要以保存数据为主要目的的类。这些课程包括编写样板代码。编写样板方法，比如<code class="fe mw mx my mz b">getters</code>、<code class="fe mw mx my mz b">setters</code>、<code class="fe mw mx my mz b">toString</code>、<code class="fe mw mx my mz b">equals</code>和<code class="fe mw mx my mz b">hashCode</code>，可能会很繁琐。Lombok通过为可变类提供<code class="fe mw mx my mz b">@Data</code>和为不可变类提供<code class="fe mw mx my mz b">@Value</code>来解决这个问题。这些注释为您生成样板方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="0aa9" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">数据类别</h2><p id="27d8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Kotlin承认需要以保存数据为主要目的的类，并提供了数据类来解决这个问题。数据类从主构造函数中的属性派生样板方法。我们可以使用<code class="fe mw mx my mz b">var</code>和<code class="fe mw mx my mz b">val</code>关键字来创建可变或不可变的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="2490" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">特定的样板方法</h2><p id="7093" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">除了<code class="fe mw mx my mz b">@Data</code>和<code class="fe mw mx my mz b">@Value</code>之外，Lombok还有注释生成具体的样板方法，如<code class="fe mw mx my mz b">@Getter</code>、<code class="fe mw mx my mz b">@Setter</code>、<code class="fe mw mx my mz b">@ToString</code>、<code class="fe mw mx my mz b">@EqualsAndHashCode</code>。科特林不太灵活。没有办法生成特定的样板方法。对我们来说，这不成问题，因为我们从不在代码库中使用这些注释。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="888a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">@Builder</h1><p id="479a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">构建器是Java中最常用的设计模式之一。<code class="fe mw mx my mz b">@Builder</code>生成实现构建器所需的所有样板代码。尽管它很受欢迎，但在Kotlin中对构建器模式的需求较少。这与Kotlin支持默认和命名参数这一事实有关。</p><h2 id="c0c4" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">默认和命名参数</h2><p id="03e8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Kotlin允许函数参数使用默认值。如果指定了默认值，则可以在函数调用中省略该参数。Kotlin还允许在函数调用中命名参数。命名参数使得以任何顺序提供参数成为可能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="7bbd" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">构建器模式不是没有用的</h2><p id="c22e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">默认和命名参数在大多数情况下是一个很好的替代品，但是它们不能取代构建器模式。例如，您可以在不同的方法之间传递一个构建器，在每个方法中设置几个字段。也许这是一个糟糕的做法，但在使用构造函数创建对象时是不可能的。如果你需要更复杂的构建器，我建议你看看关于如何在Kotlin中创建类型安全构建器的官方文档。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="aac3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">@NonNull</h1><p id="f2b5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Lombok为每个用<code class="fe mw mx my mz b">@NonNull</code>标注的字段和参数生成空检查语句。在Kotlin中，默认情况下类型是不可空的，可以使用问号来声明可空类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="96df" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">对立面</h2><p id="0673" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">科特林和龙目岛是对立的。使用Lombok可以声明不可空的字段，而在Kotlin中可以声明可空的字段。对我来说，Kotlin的方法似乎更符合逻辑，因为字段通常是不可空的，而不是可空的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5f07" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">@与</h1><p id="4467" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">要更新不可变类中的字段，您可以用您想要更改的字段的新值来克隆该类。Lombok提供了<code class="fe mw mx my mz b">@With</code>来生成<code class="fe mw mx my mz b">withFieldName(newValue)</code>方法。这些方法为关联字段生成一个具有新值的克隆。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="abd5" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">复制</h2><p id="c074" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">数据类通过提供一个<code class="fe mw mx my mz b">copy()</code>函数支持现成的克隆。命名参数使得通过这个函数为多个字段设置新值成为可能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="b1e5" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">复制包括所有字段</h2><p id="680f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">@With</code>和<code class="fe mw mx my mz b">copy()</code>有两个关键区别。通过在类或字段级别设置<code class="fe mw mx my mz b">@With</code>,你可以为特定的字段生成<code class="fe mw mx my mz b">withFieldName(newValue)</code>方法。<code class="fe mw mx my mz b">copy()</code>功能总是包括所有字段。另一个区别是<code class="fe mw mx my mz b">copy()</code>允许一次设置多个字段，而<code class="fe mw mx my mz b">@With</code>只允许通过链接<code class="fe mw mx my mz b">withFieldName(newValue)</code>方法来更新多个字段。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1cb5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">@清理</h1><p id="bff6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Lombok生成一个try/finally构造来清理当前作用域末尾用<code class="fe mw mx my mz b">@Cleanup</code>注释的局部变量声明。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="8eda" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">使用</h2><p id="7f06" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">use</code>是Kotlin的<a class="ae kv" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html" rel="noopener ugc nofollow" target="_blank">标准库</a>的一部分。它在一个资源上执行一个阻塞函数，并为您关闭它。即使函数抛出异常，资源也会被关闭。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cded" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">@ SneakyThrows</h1><p id="44d2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Lombok的<code class="fe mw mx my mz b">@SneakyThrows</code>允许你抛出检查过的异常，而不用在你的方法的<code class="fe mw mx my mz b">throws</code>子句中声明它们。Kotlin没有检查异常，所以不需要这个注释。<a class="ae kv" href="https://kotlinlang.org/docs/exceptions.html#checked-exceptions" rel="noopener ugc nofollow" target="_blank">官方文档</a>解释了为什么Kotlin没有检查异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2a8a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">@日志</h1><p id="1688" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Lombok提供了这种注释的许多变体。使用哪一种取决于所选择的日志框架。通过用<code class="fe mw mx my mz b">@Slf4J</code>注释您的类，Lombok在静态final <code class="fe mw mx my mz b">log</code>字段中初始化一个<code class="fe mw mx my mz b">Slf4J</code>记录器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="4c21" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">kot Lin-日志框架</h2><p id="8cf8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Kotlin对于<code class="fe mw mx my mz b">@Log</code>没有内置的替代品。这意味着我们必须自己进行初始化。与Kotlin配合良好的日志框架是<a class="ae kv" href="https://github.com/MicroUtils/kotlin-logging" rel="noopener ugc nofollow" target="_blank"> kotlin-logging </a>。它是一个具有更好的本地Kotlin支持的<code class="fe mw mx my mz b">Slf4J</code>包装器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="754b" class="nc ma iq bd mb nd ne dn mf nf ng dp mj lf nh ni ml lj nj nk mn ln nl nm mp nn bi translated">一致性是关键</h2><p id="4038" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我感觉Lombok的<code class="fe mw mx my mz b">@Log</code>的主要目的不是让你不用写一行初始化记录器的代码，而是统一初始化记录器。大多数记录器在初始化时需要一个类名。由于复制和粘贴错误，很容易用错误的类名初始化记录器。因为kotlin-logging在初始化时不需要类名，所以不容易出现复制和粘贴错误。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b06b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="cd85" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有时科特林的方法不够灵活。一个数据类将总是实现样板函数，而Lombok提供了创建一个特定样板方法的选项。在其他领域，科特林更强大。例如，<code class="fe mw mx my mz b">copy()</code>允许您在一次调用中设置多个字段。要用Lombok的<code class="fe mw mx my mz b">@With</code>做同样的修改，你必须多次克隆这个对象。</p><p id="851b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Lombok的注释和Kotlin的替代方法之间的细微差别可能意味着您不太可能摆脱Lombok。对我们来说，差异不是问题。最后，我们可以在所有项目中毫无问题地用惯用的Kotlin代码替换Lombok注释。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="4590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。我希望这有所帮助。如果您有问题或反馈，请随时回复。</p></div></div>    
</body>
</html>