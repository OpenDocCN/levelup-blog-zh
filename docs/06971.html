<html>
<head>
<title>Recreating the Strava Activity Graph in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中重新创建Strava活动图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/recreating-the-strava-activity-graph-in-swiftui-9db271a2dd66?source=collection_archive---------5-----------------------#2021-01-15">https://levelup.gitconnected.com/recreating-the-strava-activity-graph-in-swiftui-9db271a2dd66?source=collection_archive---------5-----------------------#2021-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f27" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让-马克·布里安内</h2></div><p id="f251" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本周的SwiftUI教程主要关注一款流行的跑步和骑行应用Strava。在本教程中，我将介绍如何重新创建显示在Strava应用程序中的活动历史图表。像往常一样，我将把它分成小块，一路解释。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/3bb58057a0d8813e27dc958c7a470d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H0Op7Egt4HS4WviE.jpg"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Strava活动历史视图</figcaption></figure><blockquote class="lu lv lw"><p id="50f0" class="ki kj lx kk b kl km ju kn ko kp jx kq ly ks kt ku lz kw kx ky ma la lb lc ld im bi translated">如果你觉得这个教程有帮助，请考虑使用这个<a class="ae mb" href="https://trailingclosure.com/signup/?utm_source=trailing_closure&amp;utm_medium=blog_post&amp;utm_campaign=strava_view" rel="noopener ugc nofollow" target="_blank">链接</a>订阅，如果你没有在<a class="ae mb" href="https://trailingclosure.com/?utm_source=trailing_closure&amp;utm_medium=blog_post&amp;utm_campaign=strava_view" rel="noopener ugc nofollow" target="_blank">TrailingClosure.com</a>上阅读这篇文章，请随时来看看我们！</p></blockquote><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mc md l"/></div></figure><h2 id="be9f" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">概观</h2><p id="dce1" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">我们将把这篇文章分成几个不同的部分。你可以随意点击某个部分的链接，在你空闲的时候跳过或跳过去。</p><ul class=""><li id="791c" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated"><a class="ae mb" href="#model" rel="noopener ugc nofollow">型号— </a> <code class="fe nl nm nn no b"><a class="ae mb" href="#model" rel="noopener ugc nofollow">ActivityLog</a></code></li><li id="0837" class="nc nd it kk b kl np ko nq kr nr kv ns kz nt ld nh ni nj nk bi translated"><a class="ae mb" href="#graph" rel="noopener ugc nofollow">构建活动图</a></li><li id="58c2" class="nc nd it kk b kl np ko nq kr nr kv ns kz nt ld nh ni nj nk bi translated"><a class="ae mb" href="#grouping-graph" rel="noopener ugc nofollow">按周分组日志</a></li><li id="fa2c" class="nc nd it kk b kl np ko nq kr nr kv ns kz nt ld nh ni nj nk bi translated"><a class="ae mb" href="#grid" rel="noopener ugc nofollow">绘制网格</a></li><li id="51da" class="nc nd it kk b kl np ko nq kr nr kv ns kz nt ld nh ni nj nk bi translated"><a class="ae mb" href="#gradient" rel="noopener ugc nofollow">绘制活动线的坡度</a></li><li id="7ed4" class="nc nd it kk b kl np ko nq kr nr kv ns kz nt ld nh ni nj nk bi translated"><a class="ae mb" href="#line" rel="noopener ugc nofollow">画活动线</a></li><li id="ab56" class="nc nd it kk b kl np ko nq kr nr kv ns kz nt ld nh ni nj nk bi translated"><a class="ae mb" href="#points" rel="noopener ugc nofollow">画点</a></li><li id="67e0" class="nc nd it kk b kl np ko nq kr nr kv ns kz nt ld nh ni nj nk bi translated"><a class="ae mb" href="#interaction" rel="noopener ugc nofollow">添加用户交互</a></li><li id="97df" class="nc nd it kk b kl np ko nq kr nr kv ns kz nt ld nh ni nj nk bi translated"><a class="ae mb" href="#text" rel="noopener ugc nofollow">构建活动统计文本</a></li></ul><h2 id="0bca" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">型号— <code class="fe nl nm nn no b">ActivityLog</code></h2><p id="ab2e" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">如果我们要重新创建一个显示活动历史的视图，那么我们需要一些方法来组织和存储数据。下面是<code class="fe nl nm nn no b">ActivityLog</code>的结构定义。我们将使用它来存储我们的活动数据，我们将在图形和文本中显示这些数据。(在本教程中，我们不会实现单位转换)</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="c00d" class="me mf it no b gy ny nz l oa ob">struct ActivityLog {<br/>    var distance: Double // Miles<br/>    var duration: Double // Seconds<br/>    var elevation: Double // Feet<br/>    var date: Date<br/>}</span></pre><p id="6395" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经定义了模型，我们可以转移注意力，开始创建自定义SwiftUI视图。</p><h2 id="8006" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">构建图表</h2><p id="4510" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">我们将首先创建一个新的SwiftUI <code class="fe nl nm nn no b">View</code>文件，并将其命名为<code class="fe nl nm nn no b">ActivityGraph</code>。它将接受一个<code class="fe nl nm nn no b">ActivityLog</code>数组以及当前所选周索引的绑定。Strava只显示了过去的12周，所以这就是我们的指数将涵盖的范围(0-11)。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="21bd" class="me mf it no b gy ny nz l oa ob">struct ActivityGraph: View {<br/>    <br/>    var logs: [ActivityLog]<br/>    @Binding var selectedIndex: Int<br/>    <br/>    init(logs: [ActivityLog], selectedIndex: Binding&lt;Int&gt;) {<br/>        self._selectedIndex = selectedIndex<br/>        self.logs = logs // Temporary, we'll group logs next<br/>    }<br/>    <br/>    var body: some View {<br/>        // Nothing yet...<br/>    }<br/>}</span></pre><h2 id="9914" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">按周对日志分组</h2><p id="4a36" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">如果你回想一下我们的模型，<code class="fe nl nm nn no b">ActivityLog</code>结构只代表一个单独的活动(比如跑步、散步、远足等等)。).但是，我们也可以使用它将一周的统计数据汇总到一个<code class="fe nl nm nn no b">ActivityLog</code>中。我们将在<code class="fe nl nm nn no b">ActivityGraph</code>的<code class="fe nl nm nn no b">init()</code>里做同样的事情。这允许我们通过将<code class="fe nl nm nn no b">logs</code>数组压缩到只有12个实例来简化图形的创建。请看下面是如何做到的。</p><blockquote class="lu lv lw"><p id="4b68" class="ki kj lx kk b kl km ju kn ko kp jx kq ly ks kt ku lz kw kx ky ma la lb lc ld im bi translated">注意，这是历史的滚动视图。统计数据不会从每周开始进行分组，而是从当天开始以7天为增量进行分组。</p></blockquote><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="16a9" class="me mf it no b gy ny nz l oa ob">init(logs: [ActivityLog], selectedIndex: Binding&lt;Int&gt;) {<br/>    self._selectedIndex = selectedIndex<br/>    <br/>    let curr = Date() // Today's Date<br/>    let sortedLogs = logs.sorted { (log1, log2) -&gt; Bool in<br/>        log1.date &gt; log2.date<br/>    } // Sort the logs in chronological order<br/>    <br/>    var mergedLogs: [ActivityLog] = []<br/><br/>    for i in 0..&lt;12 { // Loop back for the past 12 weeks<br/><br/>        var weekLog: ActivityLog = ActivityLog(distance: 0, duration: 0, elevation: 0, date: Date())<br/><br/>        for log in sortedLogs {<br/>            // If log is within specific week, then add to weekly total<br/>            if log.date.distance(to: curr.addingTimeInterval(TimeInterval(-604800 * i))) &lt; 604800 &amp;&amp; log.date &lt; curr.addingTimeInterval(TimeInterval(-604800 * i)) {<br/>                weekLog.distance += log.distance<br/>                weekLog.duration += log.duration<br/>                weekLog.elevation += log.elevation<br/>            }<br/>        }<br/><br/>        mergedLogs.insert(weekLog, at: 0)<br/>    }<br/><br/>    self.logs = mergedLogs<br/>}</span></pre><h2 id="d92b" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">绘制网格</h2><p id="ec98" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">目前<code class="fe nl nm nn no b">body</code>代码为空。让我们从为图表绘制网格开始。我将为图形的每一部分编写函数，使<code class="fe nl nm nn no b">body</code>代码更容易阅读。例如:</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="d4cd" class="me mf it no b gy ny nz l oa ob">var body: some View {<br/>    drawGrid()<br/>        //.opacity(0.2)<br/>        //.overlay(drawActivityGradient(logs: logs))<br/>        //.overlay(drawActivityLine(logs: logs))<br/>        //.overlay(drawLogPoints(logs: logs))<br/>        //.overlay(addUserInteraction(logs: logs))<br/>}</span></pre><p id="e29d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是<code class="fe nl nm nn no b">body</code>代码的样子。我们将首先编写<code class="fe nl nm nn no b">drawGrid</code>函数，在编写后面的函数时取消对它们的注释。<code class="fe nl nm nn no b">drawgrid()</code>函数相当简单。我们有两条水平黑线包围着一组垂直黑线。您可以看到，我让SwiftUI完成了所有正确分隔行的繁重工作。我们需要确保做的唯一事情是设置线条的宽度或高度。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="e6d6" class="me mf it no b gy ny nz l oa ob">func drawGrid() -&gt; some View {<br/>    VStack(spacing: 0) {<br/>        Color.black.frame(height: 1, alignment: .center)<br/>        HStack(spacing: 0) {<br/>            Color.clear<br/>                .frame(width: 8, height: 100)<br/>            ForEach(0..&lt;11) { i in<br/>                Color.black.frame(width: 1, height: 100, alignment: .center)<br/>                Spacer()<br/><br/>            }<br/>            Color.black.frame(width: 1, height: 100, alignment: .center)<br/>            Color.clear<br/>                .frame(width: 8, height: 100)<br/>        }<br/>        Color.black.frame(height: 1, alignment: .center)<br/>    }<br/>}</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oc"><img src="../Images/f95c1017129e0e8cccfa7493ffed93ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IaxRWi4_Js5PJEvb.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">图表的网格</figcaption></figure><h2 id="cc9c" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">绘制线条的渐变</h2><p id="f444" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">接下来，我们将编写<code class="fe nl nm nn no b">drawActivityGradient(logs:)</code>函数。这将为图表添加一些样式，以更好地展示数据的高/低。该函数背后的思想是创建一个矩形的<code class="fe nl nm nn no b">LinearGradient</code>，然后使用图形数据将其屏蔽掉。让我们看一下代码。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="52a1" class="me mf it no b gy ny nz l oa ob">func drawActivityGradient(logs: [ActivityLog]) -&gt; some View {<br/>    LinearGradient(gradient: Gradient(colors: [Color(red: 251/255, green: 82/255, blue: 0), .white]), startPoint: .top, endPoint: .bottom)<br/>        .padding(.horizontal, 8)<br/>        .padding(.bottom, 1)<br/>        .opacity(0.8)<br/>        .mask(<br/>            GeometryReader { geo in<br/>                Path { p in<br/>                    // Used for scaling graph data<br/>                    let maxNum = logs.reduce(0) { (res, log) -&gt; Double in<br/>                        return max(res, log.distance)<br/>                    }<br/><br/>                    let scale = geo.size.height / CGFloat(maxNum)<br/><br/>                    //Week Index used for drawing (0-11)<br/>                    var index: CGFloat = 0<br/><br/>                    // Move to the starting y-point on graph<br/>                    p.move(to: CGPoint(x: 8, y: geo.size.height - (CGFloat(logs[Int(index)].distance) * scale)))<br/><br/>                    // For each week draw line from previous week<br/>                    for _ in logs {<br/>                        if index != 0 {<br/>                            p.addLine(to: CGPoint(x: 8 + ((geo.size.width - 16) / 11) * index, y: geo.size.height - (CGFloat(logs[Int(index)].distance) * scale)))<br/>                        }<br/>                        index += 1<br/>                    }<br/><br/>                    // Finally close the subpath off by looping around to the beginning point.<br/>                    p.addLine(to: CGPoint(x: 8 + ((geo.size.width - 16) / 11) * (index - 1), y: geo.size.height))<br/>                    p.addLine(to: CGPoint(x: 8, y: geo.size.height))<br/>                    p.closeSubpath()<br/>                }<br/>            }<br/>        )<br/>}</span></pre><p id="0d35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您现在取消注释在您的<code class="fe nl nm nn no b">body</code>代码中绘制渐变的调用，您应该会看到类似下图的内容。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="fad7" class="me mf it no b gy ny nz l oa ob">var body: some View {<br/>    drawGrid()<br/>    .opacity(0.2)<br/>    .overlay(drawActivityGradient(logs: logs))<br/>    //.overlay(drawActivityLine(logs: logs))<br/>    //.overlay(drawLogPoints(logs: logs))<br/>    //.overlay(addUserInteraction(logs: logs))<br/>}</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi od"><img src="../Images/6d746ba4b22c29a7a17025e2b2f7243c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DJ4UeCJD4UCLt69t.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">添加了渐变的图形</figcaption></figure><h2 id="aca7" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">绘制活动线</h2><p id="aeeb" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">线条绘制功能的工作方式与渐变功能类似。唯一的区别是，我们不会关闭路径，并把它作为一个面具。我们将简单地画一条线，并给它一些颜色。<code class="fe nl nm nn no b">drawActivityLine(logs:)</code>功能见下。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="ccac" class="me mf it no b gy ny nz l oa ob">func drawActivityLine(logs: [ActivityLog]) -&gt; some View {<br/>    GeometryReader { geo in<br/>        Path { p in<br/>            let maxNum = logs.reduce(0) { (res, log) -&gt; Double in<br/>                return max(res, log.distance)<br/>            }<br/><br/>            let scale = geo.size.height / CGFloat(maxNum)<br/>            var index: CGFloat = 0<br/><br/>            p.move(to: CGPoint(x: 8, y: geo.size.height - (CGFloat(logs[0].distance) * scale)))<br/><br/>            for _ in logs {<br/>                if index != 0 {<br/>                    p.addLine(to: CGPoint(x: 8 + ((geo.size.width - 16) / 11) * index, y: geo.size.height - (CGFloat(logs[Int(index)].distance) * scale)))<br/>                }<br/>                index += 1<br/>            }<br/>        }<br/>        .stroke(style: StrokeStyle(lineWidth: 2, lineCap: .round, lineJoin: .round, miterLimit: 80, dash: [], dashPhase: 0))<br/>        .foregroundColor(Color(red: 251/255, green: 82/255, blue: 0))<br/>    }<br/>}</span></pre><p id="21f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦您取消了对<code class="fe nl nm nn no b">body</code>变量中的行的注释，您应该会在预览画布中看到类似下图的内容。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oe"><img src="../Images/841e5032ce764f38618bbfa2668fd8f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V4luGBAEyu4_1UEG.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">添加线条的图形</figcaption></figure><h2 id="af23" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">画出要点</h2><p id="9426" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">我们的下一个函数<code class="fe nl nm nn no b">drawLogPoints(logs:)</code>将再次像前面的函数一样工作，除了我们将在图上放置<code class="fe nl nm nn no b">Circle</code>点作为覆盖。请参见下面的代码:</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="dba7" class="me mf it no b gy ny nz l oa ob">func drawLogPoints(logs: [ActivityLog]) -&gt; some View {<br/>    GeometryReader { geo in<br/><br/>        let maxNum = logs.reduce(0) { (res, log) -&gt; Double in<br/>            return max(res, log.distance)<br/>        }<br/><br/>        let scale = geo.size.height / CGFloat(maxNum)<br/><br/>        ForEach(logs.indices) { i in<br/>            Circle()<br/>                .stroke(style: StrokeStyle(lineWidth: 4, lineCap: .round, lineJoin: .round, miterLimit: 80, dash: [], dashPhase: 0))<br/>                .frame(width: 10, height: 10, alignment: .center)<br/>                .foregroundColor(Color(red: 251/255, green: 82/255, blue: 0))<br/>                .background(Color.white)<br/>                .cornerRadius(5)<br/>                .offset(x: 8 + ((geo.size.width - 16) / 11) * CGFloat(i) - 5, y: (geo.size.height - (CGFloat(logs[i].distance) * scale)) - 5)<br/>        }<br/>    }<br/>}</span></pre><p id="0f9b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过取消注释<code class="fe nl nm nn no b">body</code>变量中的行来绘制点，您应该在画布预览中获得以下结果。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi of"><img src="../Images/50b35d5e1ddd99ffe33d65020170bb61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_JQVqsRSWnXekr3y.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">对数点重叠的图表</figcaption></figure><h2 id="0a20" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">向图形添加用户交互</h2><p id="f372" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">我们现在已经到了构建图表的最后一步。我们将为用户添加跨图形拖动的功能。这将沿图形显示一条垂直线，描述他们的选择。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi og"><img src="../Images/793e58e10669cb4aca0258670aeb7aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QDWjg3gi8yIq6red.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">通过在图形上拖动进行用户交互</figcaption></figure><p id="a122" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其工作方式是在视图中添加一个<code class="fe nl nm nn no b">DragGesture</code>，在这个视图中我们将获得用户触摸位置的位置。使用该位置，我们将放置一条垂直线以及一个点，该点将沿着图表的活动线。</p><p id="9905" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们将编写一个返回名为<code class="fe nl nm nn no b">addUserInteraction(logs:)</code>的<code class="fe nl nm nn no b">View</code>的函数。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="e56e" class="me mf it no b gy ny nz l oa ob">func addUserInteraction(logs: [ActivityLog]) -&gt; some View {<br/>    GeometryReader { geo in<br/><br/>        let maxNum = logs.reduce(0) { (res, log) -&gt; Double in<br/>            return max(res, log.distance)<br/>        }<br/><br/>        let scale = geo.size.height / CGFloat(maxNum)<br/><br/>        ZStack(alignment: .leading) {<br/>            // Line and point overlay<br/><br/>            // Future Drag Gesture Code<br/>            <br/>        }<br/><br/>    }<br/>}</span></pre><p id="8332" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先让我们设计垂直线和圆圈覆盖。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="b685" class="me mf it no b gy ny nz l oa ob">func addUserInteraction(logs: [ActivityLog]) -&gt; some View {<br/>    GeometryReader { geo in<br/><br/>        let maxNum = logs.reduce(0) { (res, log) -&gt; Double in<br/>            return max(res, log.distance)<br/>        }<br/><br/>        let scale = geo.size.height / CGFloat(maxNum)<br/><br/>        ZStack(alignment: .leading) {<br/>            // Line and point overlay<br/>            Color(red: 251/255, green: 82/255, blue: 0)<br/>                .frame(width: 2)<br/>                .overlay(<br/>                    Circle()<br/>                        .frame(width: 24, height: 24, alignment: .center)<br/>                        .foregroundColor(Color(red: 251/255, green: 82/255, blue: 0))<br/>                        .opacity(0.2)<br/>                        .overlay(<br/>                            Circle()<br/>                                .fill()<br/>                                .frame(width: 12, height: 12, alignment: .center)<br/>                                .foregroundColor(Color(red: 251/255, green: 82/255, blue: 0))<br/>                        )<br/>                    , alignment: .bottom) // Aligned to bottom in order to accurately offset the circle.<br/><br/>            // Future Drag Gesture Code<br/>            <br/>        }<br/><br/>    }<br/>}</span></pre><p id="f820" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让视图跟随用户的触摸，我们需要偏移视图，包括垂直线和圆圈覆盖。为此，我们需要添加一些新的<code class="fe nl nm nn no b">@State</code>变量。目的是让垂直线在被选中时吸附到用户的触摸位置，但在用户抬起手指时又吸附到最近的记录点。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="3302" class="me mf it no b gy ny nz l oa ob">@State var lineOffset: CGFloat = 8 // Vertical line offset<br/>@State var selectedXPos: CGFloat = 8 // User X touch location<br/>@State var selectedYPos: CGFloat = 0 // User Y touch location<br/>@State var isSelected: Bool = false // Is the user touching the graph</span></pre><p id="008c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在定义了这些变量，我们可以添加代码来偏移视图。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="0d8b" class="me mf it no b gy ny nz l oa ob">func addUserInteraction(logs: [ActivityLog]) -&gt; some View {<br/>    GeometryReader { geo in<br/><br/>        let maxNum = logs.reduce(0) { (res, log) -&gt; Double in<br/>            return max(res, log.distance)<br/>        }<br/><br/>        let scale = geo.size.height / CGFloat(maxNum)<br/><br/>        ZStack(alignment: .leading) {<br/>            // Line and point overlay<br/>            Color(red: 251/255, green: 82/255, blue: 0)<br/>                .frame(width: 2)<br/>                .overlay(<br/>                    Circle()<br/>                        .frame(width: 24, height: 24, alignment: .center)<br/>                        .foregroundColor(Color(red: 251/255, green: 82/255, blue: 0))<br/>                        .opacity(0.2)<br/>                        .overlay(<br/>                            Circle()<br/>                                .fill()<br/>                                .frame(width: 12, height: 12, alignment: .center)<br/>                                .foregroundColor(Color(red: 251/255, green: 82/255, blue: 0))<br/>                        )<br/>                        .offset(x: 0, y: isSelected ? 12 - (selectedYPos * scale) : 12 - (CGFloat(logs[selectedIndex].distance) * scale))<br/>                    , alignment: .bottom)<br/><br/>                .offset(x: isSelected ? lineOffset : 8 + ((geo.size.width - 16) / 11) * CGFloat(selectedIndex), y: 0)<br/>                .animation(Animation.spring().speed(4))<br/><br/>            // Future Drag Gesture Code<br/><br/>    }<br/>}</span></pre><p id="a374" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这些，我们就可以添加<code class="fe nl nm nn no b">DragGesture</code>代码了。我们要补充的是，这是一个几乎完全透明的图形视图，可以捕捉用户输入。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="7d86" class="me mf it no b gy ny nz l oa ob">func addUserInteraction(logs: [ActivityLog]) -&gt; some View {<br/>    GeometryReader { geo in<br/><br/>        let maxNum = logs.reduce(0) { (res, log) -&gt; Double in<br/>            return max(res, log.distance)<br/>        }<br/><br/>        let scale = geo.size.height / CGFloat(maxNum)<br/><br/>        ZStack(alignment: .leading) {<br/>            // Line and point overlay code from before<br/>            // ....<br/>            <br/>            // Drag Gesture Code<br/>            Color.white.opacity(0.1)<br/>                .gesture(<br/>                    DragGesture(minimumDistance: 0)<br/>                        .onChanged { touch in<br/>                            let xPos = touch.location.x<br/>                            self.isSelected = true<br/>                            let index = (xPos - 8) / (((geo.size.width - 16) / 11))<br/><br/>                            if index &gt; 0 &amp;&amp; index &lt; 11 {<br/>                                let m = (logs[Int(index) + 1].distance - logs[Int(index)].distance)<br/>                                self.selectedYPos = CGFloat(m) * index.truncatingRemainder(dividingBy: 1) + CGFloat(logs[Int(index)].distance)<br/>                            }<br/><br/><br/>                            if index.truncatingRemainder(dividingBy: 1) &gt;= 0.5 &amp;&amp; index &lt; 11 {<br/>                                self.selectedIndex = Int(index) + 1<br/>                            } else {<br/>                                self.selectedIndex = Int(index)<br/>                            }<br/>                            self.selectedXPos = min(max(8, xPos), geo.size.width - 8)<br/>                            self.lineOffset = min(max(8, xPos), geo.size.width - 8)<br/>                        }<br/>                        .onEnded { touch in<br/>                            let xPos = touch.location.x<br/>                            self.isSelected = false<br/>                            let index = (xPos - 8) / (((geo.size.width - 16) / 11))<br/><br/>                            if index.truncatingRemainder(dividingBy: 1) &gt;= 0.5 &amp;&amp; index &lt; 11 {<br/>                                self.selectedIndex = Int(index) + 1<br/>                            } else {<br/>                                self.selectedIndex = Int(index)<br/>                            }<br/>                        }<br/>                )<br/>        }<br/><br/>    }<br/>}</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d18285df1d1ef437f8626401f8a222f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*hMhOJxtyxjtPF4an.gif"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">图形上的用户交互</figcaption></figure><h2 id="b099" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">构造活动统计文本</h2><p id="ff16" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">现在我们已经有了图表，我们可以转移到项目中更简单的部分，即显示活动统计数据。我创建了一个名为<code class="fe nl nm nn no b">ActivityStatsText</code>的新SwiftUI视图，并传入了与图表相同的参数。我不会在这里做太多深入的讨论，但是我将日志按周分组，就像图表一样，并在视图中显示这些周的里程、持续时间和海拔统计数据。<code class="fe nl nm nn no b">selectedIndex</code>变量绑定在父视图上，该视图与提供给图形的视图相同。这样，当用户点击图表时，统计文本会根据用户选择的活动日志而变化。</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="2365" class="me mf it no b gy ny nz l oa ob">struct ActivityHistoryText: View {<br/>    <br/>    var logs: [ActivityLog]<br/>    var mileMax: Int<br/>    <br/>    @Binding var selectedIndex: Int<br/>    <br/>    var dateFormatter: DateFormatter {<br/>        let formatter = DateFormatter()<br/>        formatter.dateFormat = "MMM dd"<br/>        return formatter<br/>    }<br/>    <br/>    init(logs: [ActivityLog], selectedIndex: Binding&lt;Int&gt;) {<br/>        self._selectedIndex = selectedIndex<br/>        <br/>        let curr = Date() // Today's Date<br/>        let sortedLogs = logs.sorted { (log1, log2) -&gt; Bool in<br/>            log1.date &gt; log2.date<br/>        } // Sort the logs in chronological order<br/>        <br/>        var mergedLogs: [ActivityLog] = []<br/><br/>        for i in 0..&lt;12 {<br/><br/>            var weekLog: ActivityLog = ActivityLog(distance: 0, duration: 0, elevation: 0, date: Date())<br/><br/>            for log in sortedLogs {<br/>                if log.date.distance(to: curr.addingTimeInterval(TimeInterval(-604800 * i))) &lt; 604800 &amp;&amp; log.date &lt; curr.addingTimeInterval(TimeInterval(-604800 * i)) {<br/>                    weekLog.distance += log.distance<br/>                    weekLog.duration += log.duration<br/>                    weekLog.elevation += log.elevation<br/>                }<br/>            }<br/><br/>            mergedLogs.insert(weekLog, at: 0)<br/>        }<br/><br/>        self.logs = mergedLogs<br/>        self.mileMax = Int(mergedLogs.max(by: { $0.distance &lt; $1.distance })?.distance ?? 0)<br/>    }<br/>    <br/>    var body: some View {<br/>        VStack(alignment: .leading, spacing: 16) {<br/>            Text("\(dateFormatter.string(from: logs[selectedIndex].date.addingTimeInterval(-604800))) - \(dateFormatter.string(from: logs[selectedIndex].date))".uppercased())<br/>                .font(Font.body.weight(.heavy))<br/>            <br/>            HStack(spacing: 12) {<br/>                VStack(alignment: .leading, spacing: 4) {<br/>                    Text("Distance")<br/>                        .font(.caption)<br/>                        .foregroundColor(Color.black.opacity(0.5))<br/>                    Text(String(format: "%.2f mi", logs[selectedIndex].distance))<br/>                        .font(Font.system(size: 20, weight: .medium, design: .default))<br/>                }<br/>                <br/>                Color.gray<br/>                    .opacity(0.5)<br/>                    .frame(width: 1, height: 30, alignment: .center)<br/>                    <br/>                VStack(alignment: .leading, spacing: 4) {<br/>                    Text("Time")<br/>                        .font(.caption)<br/>                        .foregroundColor(Color.black.opacity(0.5))<br/>                    Text(String(format: "%.0fh", logs[selectedIndex].duration / 3600) + String(format: " %.0fm", logs[selectedIndex].duration.truncatingRemainder(dividingBy: 3600) / 60))<br/>                        .font(Font.system(size: 20, weight: .medium, design: .default))<br/>                }<br/>                <br/>                Color.gray<br/>                    .opacity(0.5)<br/>                    .frame(width: 1, height: 30, alignment: .center)<br/>                <br/>                VStack(alignment: .leading, spacing: 4) {<br/>                    Text("Elevation")<br/>                        .font(.caption)<br/>                        .foregroundColor(Color.black.opacity(0.5))<br/>                    Text(String(format: "%.0f ft", logs[selectedIndex].elevation))<br/>                        .font(Font.system(size: 20, weight: .medium, design: .default))<br/>                }<br/>                <br/>                Spacer()<br/>            }<br/>            <br/>            VStack(alignment: .leading, spacing: 5) {<br/>                Text("LAST 12 WEEKS")<br/>                    .font(Font.caption.weight(.heavy))<br/>                    .foregroundColor(Color.black.opacity(0.7))<br/>                Text("\(mileMax) mi")<br/>                    .font(Font.caption)<br/>                    .foregroundColor(Color.black.opacity(0.5))<br/>            }.padding(.top, 10)<br/>            <br/>            <br/>        }<br/>    }</span></pre><h2 id="ae01" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">活动统计视图</h2><p id="c1d4" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">这是父视图，包含图形和文本视图</p><pre class="lf lg lh li gt nu no nv nw aw nx bi"><span id="b3b0" class="me mf it no b gy ny nz l oa ob">struct ActivityHistoryView: View {<br/>    <br/>    @State var selectedIndex: Int = 0<br/>    <br/>    var body: some View {<br/>        VStack(spacing: 16) {<br/>            // Stats<br/>            ActivityHistoryText(logs: ActivityTestData.testData, selectedIndex: $selectedIndex)<br/>            <br/>            // Graph<br/>            ActivityGraph(logs: ActivityTestData.testData, selectedIndex: $selectedIndex)<br/>            <br/>        }.padding()<br/>    }<br/>}</span></pre><h2 id="e9cf" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">喜欢这个教程？</h2><h2 id="d94e" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">让我们看看你做了什么！</h2><p id="df43" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">给我们发照片！给我们一个链接！任何事！在推特<a class="ae mb" href="https://twitter.com/TrailingClosure" rel="noopener ugc nofollow" target="_blank"> @TrailingClosure </a>、insta gram<a class="ae mb" href="https://www.instagram.com/trailingclosure/" rel="noopener ugc nofollow" target="_blank">上找到我们，或者发邮件到howdy@TrailingClosure.com<!-- --><!-- -->联系我们。</a></p></div></div>    
</body>
</html>