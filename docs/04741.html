<html>
<head>
<title>Rethinking Unit Testing in Software Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件开发中单元测试的再思考</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rethinking-unit-testing-in-software-development-11b948483ed?source=collection_archive---------10-----------------------#2020-07-12">https://levelup.gitconnected.com/rethinking-unit-testing-in-software-development-11b948483ed?source=collection_archive---------10-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1b44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">说到单元测试，硬币总是有两面的。单元测试有回报吗？值得吗？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/198174c8748b686b87a174856f897fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*G7s61tFPaLI9JRxWYpRNLw.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">来源:https://github.com/egonelbre/gophers</figcaption></figure><blockquote class="lb lc ld"><p id="f6f5" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">对你的单元测试所能达到的目标要谦虚，除非你对被测试的单元有外在的需求。在一个合理的测试周期内，单元测试不太可能测试超过任何给定方法的万亿分之一的功能。</p><p id="48f4" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">—James O . Coplien关于“为什么大多数单元测试都是浪费”</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi li"><img src="../Images/3af579408d173638221aa639c362b47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PhB5QUwck4hAlJcq"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">由<a class="ae la" href="https://unsplash.com/@nbb_photos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的</a>拉齐·斯莱扎克的照片。单元测试可能会让你像这位女士一样感到压力。她扔掉了所有的TDD书籍，因为TDD有时会很累。</figcaption></figure><p id="8fbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章谈到了我对单元测试的想法。如果你想亲自动手，我很快会有一个Go语言教程“<em class="le"> Gorm for SQL in Go </em>”。如果您是单元测试的新手，我建议您阅读其中的一些内容，然后尝试两种不同的练习:</p><ul class=""><li id="623f" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn ls lt lu lv bi translated">尝试构建一个简单的项目，并在任何可测试的时候添加单元测试。例如建立停车场系统。这里有一个简单的问题，overkilled solution +在<a class="ae la" href="https://github.com/iqDF/Parking-Lot-OOP" rel="noopener ugc nofollow" target="_blank"> my github </a>中的单元测试。此处不允许第三方库。</li><li id="d390" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated">尝试构建应用程序。比如用极简的web框架+ ORM /数据库连接器库构建一个web应用。现在记住，单元测试是关于隔离测试的，但是你的代码现在依赖于其他组件。如何添加单元测试？它给你带来了什么好处？</li></ul><h1 id="2b99" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">目录</h1><p id="05c7" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated"><strong class="js iu">一、单元测试— </strong>什么是单元测试，什么不是单元测试？</p><p id="76ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">二。单元测试的优势— </strong>一个写得好的单元测试有多大价值？</p><p id="dc4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">三。对单元测试优势的误解——它永远不会给你什么。</strong></p><p id="4453" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">四。单元测试的成本— </strong>单元测试的成本和编写糟糕单元的风险。</p><p id="8b38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么什么时候单元测试有价值呢？— 然后你应该做其他种类的测试吗？</p><h2 id="e6d3" class="ne mc it bd md nf ng dn mh nh ni dp ml kb nj nk mp kf nl nm mt kj nn no mx np bi translated">这篇文章是关于什么的？</h2><p id="0850" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">我要谈一点关于单元测试的内容，因为我认为值得停下来思考一下:</p><ul class=""><li id="c996" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn ls lt lu lv bi translated">单元测试是必须的吗？我看到过许多不值得做的事情，而跳过功能测试是非常值得的。这也不是一种规范，尽管许多书籍和资源鼓励单元测试甚至TDD。作为一名软件工程师，你不能盲目地跟随书本、导师或者你的技术领导所说的。</li><li id="4130" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated">但这只是单元测试，对吗？不是很简单快捷吗？答案是一个很大的<strong class="js iu">否</strong>但是当然这要看情况。对于我的大多数后端应用程序来说，这是一个很大的<strong class="js iu"> NO </strong>并且编写一个写得很好的单元测试是很乏味的。我说的只是单元测试，还不是功能或集成测试。</li></ul><h2 id="c193" class="ne mc it bd md nf ng dn mh nh ni dp ml kb nj nk mp kf nl nm mt kj nn no mx np bi translated">这不是为了什么？</h2><ul class=""><li id="131e" class="ln lo it js b jt mz jx na kb nq kf nr kj ns kn ls lt lu lv bi translated">这是<strong class="js iu">不是</strong>反单元测试，我也不建议你删除你的测试代码。</li><li id="6e1f" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated">这是关于如何编写测试的教程。</li></ul><h1 id="c0c4" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">单元测试</h1><p id="d16a" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">我认为迟早我们将不得不谈论单元测试以及为什么它非常困难。单元测试并不像我想的那么容易。它需要一个模块与其外部依赖项(如数据库层或API客户端)隔离开来。</p><p id="8c57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我采访过的许多开发人员误解了什么是单元测试，什么是单元测试。对于其中的一些人来说，单元测试被描述为“只是测试一个单一的功能”，这与事实相差甚远，而且一旦你创建了一个相当复杂的应用程序，这并不容易。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nt"><img src="../Images/9e23ef6e854718b91628bc8034af145b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4GAee_Hl4umtq30f"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">Jon Flobrant 在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。当单元测试让你紧张时，穿着比基尼沉思有助于减轻你的思想负担。但是你知道还有什么帮助吗？</figcaption></figure><p id="5d8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有许多正式的定义和文章解释了什么是集成测试和单元测试。以下是我用自己的语言总结的内容:</p><ul class=""><li id="7697" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn ls lt lu lv bi translated"><em class="le">集成测试:</em>测试多个组件以及它们如何一起工作。例如，另一个系统如何与您的系统交互，或者数据库如何与您的数据抽象层交互。通常这需要一个完全安装的系统，尽管在最纯粹的形式中并不需要。</li><li id="e239" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated"><em class="le">单元测试</em>:是软件<strong class="js iu">测试</strong>的一个层次，测试软件的单个<strong class="js iu">单元</strong> /组件。目的是验证软件的每个<strong class="js iu">单元</strong>是否按设计执行。单元是任何软件中最小的部分。它通常有一个或几个输入和一个输出，我们称之为函数或方法。</li></ul><p id="9816" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，单元测试需要三个要点:</p><ul class=""><li id="5bd6" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn ls lt lu lv bi translated"><strong class="js iu">白盒测试</strong>。这意味着对于已知的输入和边缘情况，代码会按预期执行。例如，如果您正在测试应用程序的数据层，您需要测试由ORM生成的SQL或查询。然后看看在使用ORM库时，查询是否与您想要的完全一样。</li><li id="f864" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated"><strong class="js iu">极度模块化和代码拆分</strong>。这与做白盒测试齐头并进。单元测试是关于测试任何软件中可能的最小单元。当您可以从最小的、可重用的单元开始构建更复杂的功能时，模块化代码可以提高可测试性。然而，代码分割可能会破坏您之前设计的软件架构。</li><li id="3009" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn ls lt lu lv bi translated"><strong class="js iu">孤立和嘲弄</strong>。任何对其他组件的依赖，无论是外部的还是内部的，都应该被嘲笑。这是TDD开发者的强硬路线。在我看来，嘲讽是最难的部分。您的代码必须结构良好，并遵循坚实的原则。你的<em class="le">类</em>和<em class="le">模块</em>的<em class="le">范围</em>必须被很好地定义，这样当它们被测试时，你就可以模拟依赖关系，反之亦然。</li></ul><h1 id="ffa4" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">良好实现的单元测试的优势</h1><p id="c44d" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">努力工作一定会有回报，不是吗？嗯，这要视情况而定，但我可以肯定的是，测试更少，但可以说是一个大脑难题，更多的是艰苦的工作。那么你从这些单元测试中得到什么呢？</p><p id="77b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我看来，从长远来看，单元测试有两个主要优点。多久才算长？取决于你的冲刺，但对我来说，从第二个冲刺周期开始，我已经感受到了以下好处:</p><ol class=""><li id="d2b0" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn nu lt lu lv bi translated"><em class="le">自动捕捉bug</em>。我不认为这是一个惊喜，也不需要解释。代码冲刺中的团队协作意味着大量的代码被推送，大量的变更，因此需要在合并新功能、修复bug、重构、配置变更等之前进行自动化测试。</li><li id="fa91" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated"><em class="le">可解释、可解释的错误调试</em>。这是我认为最有价值的部分。对我来说，做单元测试的成本只有在它让我从几天的调试中解脱出来时才是值得的。写得好的代码可以立即查明错误发生的确切原因，在哪个模块的哪个特定函数/方法中。然而，这个特性要求你设计好你的单元测试并开发好测试代码，包括结果记录和测试标签。</li><li id="e903" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated"><em class="le">非官方指南或文件</em>。好的测试也可以作为使用界面的非正式指南。这个好处实际上适用于任何类型的测试。写得好的测试清楚地展示了如何使用你的API以及预期的结果是什么。</li></ol><h1 id="2bba" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">对单元测试优势的误解</h1><ol class=""><li id="db59" class="ln lo it js b jt mz jx na kb nq kf nr kj ns kn nu lt lu lv bi translated"><em class="le">更多报道！=提高代码质量</em>。一个设计良好的测试，最多，提供了一个当前实现缺少什么来实现理想系统的洞察力。另一方面，好的系统设计和编程可以做到。</li><li id="cac6" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated"><em class="le">先写考卷让人思路更清晰。</em>相反，在编写实现时，在增加复杂性之前执行TDD或编写测试。似乎测试中的信息比代码中的信息要多。我已经实践TDD年了，在成为后端工程师之前，我是测试自动化的软件工程师，编写了100个单元测试和67个端到端集成测试。我可以肯定，TDD训练不会让一个人成为更好的程序员。实践好的设计和编程！</li><li id="7ddf" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated"><em class="le">故障更少，更安全</em>。如果您有全面的单元测试，但是在系统测试中仍然有很高的失败率，或者在现场的质量很低。或许是时候重新思考你的设计方案了，而不是增加更多的单元测试和错误修复。我不能强调一个好的设计比到处进行测试有多重要。</li></ol><h1 id="0021" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">单元测试的成本和黑暗面</h1><blockquote class="lb lc ld"><p id="00b3" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">…程序能做什么在某种程度上与开始执行时磁带上的位数有关。如果你想彻底地测试那个程序，你需要一个至少有相同信息量的测试…</p><p id="1403" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">—James O . Coplien关于“为什么大多数单元测试都是浪费”</p></blockquote><ol class=""><li id="1231" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn nu lt lu lv bi translated"><em class="le">时间</em>。单元测试通常比实际实现花费更多的时间。在我作为后端开发人员的情况下，我平均花费了两倍的时间来实现一个应用程序，尽管我已经熟悉了测试套件或我正在使用的web应用程序框架。对一些人来说，这可能需要</li><li id="772e" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated"><em class="le">强制重构和代码拆分</em>。大多数时候，单元测试需要分割你的算法，仅仅是为了满足单元测试的一致性，而不是为了模块化。这可能意味着破坏您的系统架构和代码理解，以更好的粒度进行测试。</li><li id="3775" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated">糟糕的笔试让人困惑。写得不好的测试会导致混乱，并给进一步的改变制造不必要的障碍。糟糕的测试也有在你的软件中引入错误的风险，如果测试(逻辑、结果记录等)设计得不好，可能会污染测试结果。有多少次你执行单元测试，但是当测试失败时，你仍然需要执行英勇的调试？</li><li id="361d" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated"><em class="le">又一堆干草</em>。如果写得不好，你的单元测试只会告诉你的代码是否在某个地方出了问题，但是这个地方是你的测试代码引入的一堆hays加上另一堆hays中的一根针。你将会看到一堆被追踪的错误，而没有任何关于是什么破坏了你的代码的提示。</li></ol><h1 id="3684" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">什么时候单元测试达到最大收益呢？</h1><blockquote class="lb lc ld"><p id="8576" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">…一些系统具有关键算法，如网络路由算法，可针对单个API进行测试。正如我在上面所说的，有一个正式的oracle来派生这种API的测试。所以那些单元测试是有价值的。</p><p id="61f7" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">—James O . Coplien关于“为什么大多数单元测试都是浪费”<em class="it">(第11页)</em></p></blockquote><p id="e44a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">复杂的算法从单元测试中受益匪浅。算法程序有明确定义的步骤和输入输出，但同时它们可能有复杂的边缘情况需要处理。您希望尽可能地确保您的实现完全符合纸上设计的算法，并处理所有预期的边缘情况。</p><h2 id="9652" class="ne mc it bd md nf ng dn mh nh ni dp ml kb nj nk mp kf nl nm mt kj nn no mx np bi translated">给我举个例子！</h2><p id="d927" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">现在，让我们说已经很好地理解了算法，你准备实施部分。该算法可以分解成几个部分，每个部分的实现可以从添加一个简单的测试开始，然后是实现。</p><p id="fdaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果你正在实现Dijkstra算法，你这个算法可以分解成五个步骤:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ol class=""><li id="f1b3" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn nu lt lu lv bi translated">入门:初始化相关数据结构:PriorityQueue(最小堆)和距离表</li><li id="b91e" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated">初始化距离关联表，StartNode的距离为零，其他的为无穷大(例如MAX_INT)</li><li id="855a" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated">广度优先搜索，但是有点扭曲:使用MinHeap(优先级队列)代替普通的队列结构</li></ol><p id="65b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.检查是否到达目的节点，返回并退出</p><p id="2f66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.当没有到达目的节点时，如果我们发现一个更短的距离，则将下一个节点推到优先队列。</p><h2 id="9694" class="ne mc it bd md nf ng dn mh nh ni dp ml kb nj nk mp kf nl nm mt kj nn no mx np bi translated">我们怎么做迪杰斯特拉？</h2><p id="7e57" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">您可以为这些步骤实现TDD，并添加一个相当简单的测试用例来确保它们的行为符合您的算法设计，很好地处理所有边缘情况。我建议进行参数化测试。Elliot Chance写了一篇关于go 中<a class="ae la" href="http://elliot.land/post/go-data-driven-or-parameterized-tests" rel="noopener ugc nofollow" target="_blank">参数化测试的博客。</a></p><ol class=""><li id="8d09" class="ln lo it js b jt ju jx jy kb lp kf lq kj lr kn nu lt lu lv bi translated"><code class="fe nx ny nz oa b">TestMinHeapPop()</code>:确保<code class="fe nx ny nz oa b">minHeap.Pop()</code>总是将数组中的最后一个元素排队的测试。堆推送操作确保最后一个元素是堆中所有节点中距离最小的元素。</li><li id="3c07" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated"><code class="fe nx ny nz oa b">TestMinHeapPush()</code>:确保<code class="fe nx ny nz oa b">minHeap.Push()</code>添加了项目并重组堆的测试，使得堆数组中的最后一个项目是包含离节点最小距离的项目。</li><li id="bbf5" class="ln lo it js b jt lw jx lx kb ly kf lz kj ma kn nu lt lu lv bi translated"><code class="fe nx ny nz oa b">TestEnqueueNextNode()</code>:<code class="fe nx ny nz oa b">TestEnqueueNextNode()</code>是独立的，孤立的。如果您碰巧使用其他库中的实现来实现<code class="fe nx ny nz oa b">MinHeap</code>，您可能也想模仿它</li></ol><p id="8648" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你完成一个实现时，将边缘案例测试添加到你的软件中，并构建更复杂的算法部分，直到一切都完成。您可能希望确保单元测试涵盖一些重要的步骤。</p><p id="e3ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后功能测试可以在你完成后添加到上面。在任何类似CP或LeetCode的实践中，您的功能测试可以像sphere online judge一样工作。他们将整个算法作为一个组件进行测试。</p><p id="6e6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个组件测试，但是很适合添加到你的测试中。用参数化测试来测试你的dijkstra算法。把你能想到的边缘案例也放进去。</p><p id="df17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="le">提示:</em>我还建议在开发期间将<code class="fe nx ny nz oa b">TestDijkstra()</code>标记为对<code class="fe nx ny nz oa b">TestEnqueueNextNode()</code>的依赖测试，这样如果<code class="fe nx ny nz oa b">TestEnqueueNextNode()</code>失败，这个测试将被跳过，直到你首先修复了依赖测试。这样做的目的是让你的测试结果不那么混乱，并且更容易找到导致错误的原因。</p></div></div>    
</body>
</html>