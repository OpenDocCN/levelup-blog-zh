<html>
<head>
<title>Why you should migrate your apps to Kotlin if you haven’t already</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果你还没有把你的应用程序迁移到Kotlin，为什么要这样做</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-you-should-migrate-your-apps-to-kotlin-if-you-havent-already-30fec1b05be9?source=collection_archive---------11-----------------------#2020-10-05">https://levelup.gitconnected.com/why-you-should-migrate-your-apps-to-kotlin-if-you-havent-already-30fec1b05be9?source=collection_archive---------11-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/1296aad53752ed116a5ea056013d0fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*92O1VZbBLOZAb2tqCyQl_g.png"/></div></figure><p id="509b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">三年后，Kotlin作为一种新的官方Android开发语言首次在Google I/O上推出，我决定我需要写这篇文章，因为尽管Google已经宣布Kotlin是主要的Android开发语言，而且大多数公司已经在他们的大多数项目上从<strong class="jw ir"> Java </strong>转向<strong class="jw ir"> Kotlin </strong>， 我在不同公司的项目中分享了尚未进行迁移的情况，在一些更糟糕的情况下，经理们甚至不想听到Kotlin迁移，因为对他们来说“这似乎是浪费时间，因为应用程序在Java中运行得一样好”。</p><p id="a161" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我一直是Kotlin Android开发的倡导者，自从我还是一名初级开发人员，Kotlin刚刚起步时，我就一直与我的同事和导师谈论我对Kotlin和可能的迁移有多么兴奋。<strong class="jw ir">主要原因</strong>是:</p><ol class=""><li id="2261" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><strong class="jw ir">这是新事物，我总是很兴奋，渴望学习新东西，提高我的开发技能</strong></li><li id="2de8" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">Kotlin开发似乎比Java Android开发有更多的好处。</li></ol><p id="0798" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文讲的是第二个原因。但是首先…</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ln"><img src="../Images/47b14111fe1904abb26293e9957597aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQWhrio1nbQCr2HipCGR5Q.png"/></div></div></figure><h1 id="a967" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated"><strong class="ak">什么是科特林？</strong></h1><p id="232c" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">这一切都始于2011年夏天，当时提供最令人惊叹的IDE的公司<strong class="jw ir"> Jetbrains </strong>首次公布了<strong class="jw ir">kot Lin项目。Kotlin背后的想法是开发一种语言，提供其他语言无法提供的好处。</strong></p><p id="7d6e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然这种新语言的主要目标之一是促进IntelliJ IDEA在T21的销售，但主要的里程碑是在2017年谷歌宣布他们在Android上为Kotlin提供一流支持。而在2019年谷歌宣布Kotlin编程语言成为其安卓应用开发者的<strong class="jw ir">首选语言</strong>时。</p><p id="e273" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kotlin主要针对<strong class="jw ir"> JVM </strong>，但也编译为<strong class="jw ir"> Javascript </strong>，它甚至可以用于在<strong class="jw ir"> Android </strong>和<strong class="jw ir"> iOS应用</strong>之间共享业务逻辑。对于跨平台开发<strong class="jw ir"/>来说，我们能离一种伟大而全能的语言更近一步吗？我们只能回避它。</p><figure class="lo lp lq lr gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="0d89" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated"><strong class="ak">为什么Java Android已经不够用了？</strong></h1><p id="8a31" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">其中一个主要原因是，与<strong class="jw ir">科特林</strong>相比，<strong class="jw ir"> Java </strong>没能达到它最初的目的。最初，Java的本意是<strong class="jw ir">简单易懂</strong>，并且由于其<strong class="jw ir">简单性</strong>而成为一种突破性的语言。很长一段时间Java都是这么做的。然而，与Java相比，Kotlin使开发变得更简单，更容易理解。你可以用Kotlin做任何Java能做的事情，只是更快更容易。</p><p id="e2e4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第二个原因是百万美元的错误。没错，在我们自己面对palm之前，我们要看到的一件事是:<strong class="jw ir">空指针异常</strong></p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nb"><img src="../Images/3a156d70635afc56ae72eb49ef2aa1e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxNVBiYeTTzbFUpO0PSJdA.jpeg"/></div></div></figure><p id="6772" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Java中，你需要手动空检查所有的东西。嗯…几乎所有的事情。关键是，你花了很多时间调试你的应用程序为什么会崩溃，等着遇到挑战你智力的复杂问题，结果只是为了阅读</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="0a22" class="nh lx iq nd b gy ni nj l nk nl">java.lang.NullPointerException</span></pre><p id="974f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一个原因是Java for Android还停留在Java 8 上，而且看起来不会很快改变，因为由于甲骨文对谷歌提起诉讼，谷歌与甲骨文<strong class="jw ir">关系不太好。甲骨文仍然提供对Java 8的支持，但只到2030年，对Java 7的支持只到2022年。所以从技术上来说，在Java 8不再受益于扩展支持之前，我们只有大约10年的时间，如果你问我，当你希望使用它作为你的Android开发的主要语言时，这是一种交易破坏者</strong></p><p id="aaca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在有了Kotlin，Java对于Android开发来说已经过时了，还有很多其他原因。然而，让我们把重点放在两者之间的明显差异上。</p><h1 id="13f4" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated"><strong class="ak"> Kotlin VS Java </strong></h1><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nm"><img src="../Images/9c66816e2d7956376f6bf44e5a269c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUpcucbU6z2hlhrvyScBaA.jpeg"/></div></div></figure><p id="a00d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">扩展功能</strong></p><p id="ae07" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设你需要对一个"<strong class="jw ir"> Date </strong>"类型的对象做很多操作。在<strong class="jw ir"> Java </strong>中你要做的主要事情是创建一个<strong class="jw ir">DateUtil.java</strong>类，每当你需要对一个“<strong class="jw ir">日期</strong>类型的对象执行操作时，你将注入并调用这个类</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="d485" class="nh lx iq nd b gy ni nj l nk nl">public class DateUtil {<br/>     public boolean isATuesday(Date date) {<br/>          return date.getDay() == 2;<br/>     }<br/>}</span><span id="7bf6" class="nh lx iq nd b gy nn nj l nk nl">....</span><span id="1a3f" class="nh lx iq nd b gy nn nj l nk nl">public void doSomething(Date date) {<br/>     if (dateUtil.isATuesday(date)) {<br/>          // Do something<br/>     }<br/>}</span></pre><p id="26e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Kotlin中，我们可以通过使用<strong class="jw ir">扩展函数</strong>来避免这种情况。您可以为任何<strong class="jw ir">数据类型</strong>创建一个自定义方法，这样您就不再需要那个Util类，并且当涉及到<strong class="jw ir">封装</strong>和<strong class="jw ir">数据隐藏时，您会得到更多的帮助。</strong>此外，扩展函数提高了<strong class="jw ir">表达能力</strong>并给了我们<strong class="jw ir">私有的、上下文特定的类型视角</strong>。</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="f6fd" class="nh lx iq nd b gy ni nj l nk nl">fun Date.isATuesday(): Boolean {<br/>     return day == 2<br/>}</span><span id="a6b2" class="nh lx iq nd b gy nn nj l nk nl">....</span><span id="d94d" class="nh lx iq nd b gy nn nj l nk nl">fun doSomething(date: Date) {<br/>     if (date.isATuesday()) {<br/>          // Do something<br/>     }<br/>}</span></pre><p id="efae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> POJO vs数据类</strong></p><p id="46a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我认为没有一个项目不需要创建或修改一个<strong class="jw ir"> POJO </strong>。这个过程本身在难度上非常简单，但是在编写拥有一个干净良好的POJO所需的所有代码时却非常复杂。你需要声明<strong class="jw ir">参数</strong>，可能需要创建一个<strong class="jw ir">构造器</strong>来初始化所有这些参数，<strong class="jw ir">getter</strong>，<strong class="jw ir">setter</strong>，<strong class="jw ir"> hashCode </strong>方法，<strong class="jw ir"> toString </strong>方法，<strong class="jw ir"> equals </strong>方法，而没有意识到你有一个超过100行代码的类，只需要成为一个</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="638d" class="nh lx iq nd b gy ni nj l nk nl">public class Person {<br/>     private String name;<br/>     private int age;<br/>     private String email;</span><span id="d343" class="nh lx iq nd b gy nn nj l nk nl">     public Person(String name, int age, String email) {<br/>          this.name = name;<br/>          this.age = age;<br/>          this.email = email;<br/>     }</span><span id="7e30" class="nh lx iq nd b gy nn nj l nk nl">     public String getName() {<br/>          return name;<br/>     }</span><span id="fb38" class="nh lx iq nd b gy nn nj l nk nl">     public void setName(String name) {<br/>          this.name = name;<br/>     }</span><span id="89b3" class="nh lx iq nd b gy nn nj l nk nl">     public String getEmail() {<br/>          return email;<br/>     }</span><span id="2649" class="nh lx iq nd b gy nn nj l nk nl">     public void setEmail(String email) {<br/>          this.email = email;<br/>     }</span><span id="3153" class="nh lx iq nd b gy nn nj l nk nl">     public int getAge() {<br/>          return age;<br/>     }</span><span id="d3ec" class="nh lx iq nd b gy nn nj l nk nl">     public void setAge(int age) {<br/>          this.age = age;<br/>     }</span><span id="3af8" class="nh lx iq nd b gy nn nj l nk nl">     // toString ...</span><span id="8c12" class="nh lx iq nd b gy nn nj l nk nl">     // hashCode ...</span><span id="bee5" class="nh lx iq nd b gy nn nj l nk nl">     // equals ...</span></pre><p id="1dcc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我告诉你我们可以用Kotlin只用一行代码就完成上面用Java写的所有事情，会怎么样？我们可以在Kotlin中使用<strong class="jw ir">数据类</strong>来实现。在Kotlin中声明类定义时，数据类由关键字<strong class="jw ir"> data </strong>指定，这就像在Java中定义pojo类一样。<strong class="jw ir">不同的是，Kotlin会为你处理所有这些getter和setter以及equals和hashCode方法。</strong></p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="4485" class="nh lx iq nd b gy ni nj l nk nl">data class Person(val name: String, val age: Integer, val email: String)</span></pre><p id="ea14" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">不再有NPE症？</strong></p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/02ff4cb74843dffeedffccd55d74fe17.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*QbVwVxPlkOd4h8mBsUUGVg.jpeg"/></div></figure><p id="0115" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是的，你没看错。Kotlin的目标是<strong class="jw ir">从我们的代码中消除</strong> <code class="fe np nq nr nd b">NullPointerException</code>，让我们几乎没有办法真正得到这个异常。唯一的方法是:</p><ul class=""><li id="1c09" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr ns ky kz la bi translated">显式调用<code class="fe np nq nr nd b">throw NullPointerException()</code>；</li><li id="e10f" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr ns ky kz la bi translated">在错误的情况下使用<code class="fe np nq nr nd b">!!</code>操作符；</li><li id="c23d" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr ns ky kz la bi translated">关于初始化的一些数据不一致，例如在构造函数中泄漏“this”</li><li id="f38c" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr ns ky kz la bi translated">java互操作</li></ul><p id="8581" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认情况下，<strong class="jw ir"> Kotlin假设没有一个值可以为null </strong>。用“null”赋值也会导致编译错误。唯一的方法是将该变量声明为可空的变量。</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="44d4" class="nh lx iq nd b gy ni nj l nk nl">var value: String = null           //compilation error<br/>var value: String? = null          // works</span></pre><p id="de83" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们想要<strong class="jw ir">访问</strong>一个可空的引用时，我们必须显式地处理<strong class="jw ir">空</strong>的情况，以避免编译错误，因为Kotlin知道这个变量可以是空的。</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="ebb5" class="nh lx iq nd b gy ni nj l nk nl">value.toUpper()               // compilation error</span><span id="1768" class="nh lx iq nd b gy nn nj l nk nl">if (value != null) {<br/>     value.toUpper()         // works<br/>}                        </span></pre><p id="532e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kotlin内置的空安全系统极大地减少了任何可能的NPE，因为如果它认为您可能访问空对象，它甚至不会让您通过编译状态。</p><h1 id="346c" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated"><strong class="ak">统计数据</strong></h1><p id="809e" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">Kotlin有比我描述的更多的优势，许多开发者看到了这些优势，并认为它们值得<strong class="jw ir">从Java转换到Kotlin。如果您是这些开发人员中的一员，并且想要说服您的经理或老板，迁移到Kotlin对业务最有利，那么下一节将会做到这一点。</strong></p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nt"><img src="../Images/8a8043b48dd8b91ceb47d498b3b5fced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*jV4-88UsTESx4rjryV8Wtg.jpeg"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">由Jetbrains提供</figcaption></figure><p id="96d4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果说在Android为Kotlin提供全面支持一年后，Kotlin应用的数量几乎与Java应用持平，那么在2019年，当谷歌宣布Kotlin作为Android应用开发的主要编程语言时，Kotlin应用的数量飙升至惊人的90%。在这种节奏下，Java Android应用将成为<strong class="jw ir">灭绝</strong>。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ny"><img src="../Images/06de761d7cf82eef58629794ceeadab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53RZJrRAwogy85zDLnvV_Q.png"/></div></div></figure><p id="e0db" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kotlin的受欢迎程度在不断增长，而Java的受欢迎程度在慢慢下降。如果你的应用程序仍然是Java的，你获得<strong class="jw ir">新人才</strong>来开发这些应用程序的机会正在变得越来越低<strong class="jw ir"/>。统计数据显示，Android开发人员更有可能选择以Kotlin为主要编程语言的工作，而不是Java。你不仅很难找到新的开发人员来开发你的Java应用，而且你现在的开发人员可能会想开始使用Kotlin，而把留给那些要求是标准的项目。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nz"><img src="../Images/8a92f7e121d8ff097f07006efbca9dce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSAkqIkk71zC2MmUOIM-IQ.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">优步的好意</figcaption></figure><p id="81a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">科特林以用更少的代码做更多的事情而闻名，优步也想在他们的应用上测试这一点。对于这个实验，<strong class="jw ir">优步</strong>测量了每个项目每种语言的代码、空白和注释行的平均数量，并确定对于功能相当的代码，<strong class="jw ir"> Kotlin项目比Java项目小40%左右</strong>。更少的行数意味着花在编码上的时间更少，这导致更快的产品交付，从而为公司带来更多利润。</p><h1 id="a765" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">从Java迁移到Kotlin既简单又安全</h1><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/308333d6d0c6b3b0cabef0dd510b4560.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*c4n1quAG8sthuSVmiQsAIw.jpeg"/></div></figure><p id="179b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果到目前为止你所读到的一切使你确信你想迁移到Kotlin，但是你害怕这会极大地影响你的发展，或者这非常困难，那你就大错特错了！从Java迁移到Kotlin是<strong class="jw ir">容易</strong>和<strong class="jw ir">安全</strong>。</p><p id="da22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Kotlin代码</strong>与<strong class="jw ir"> Java代码</strong>兼容，这意味着你可以在一个<strong class="jw ir">项目</strong>中同时拥有Kotlin和Java类，而且由于Kotlin和Java都面向<strong class="jw ir"> JVM </strong>，你可以通过从Kotlin类调用Java方法让它们协同工作，反之亦然，没有任何问题。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/f42c9bafadb5a29441b3652105f1c31e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*rlnOLLfhyHn_zfqCD26CMQ.gif"/></div></figure><p id="cb0b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，Android Studio现在有一个内置工具，可以自动将Java类转换为Kotlin类。这不是一个最佳实践，因为它在准确性方面有点像谷歌翻译，但在你这样做之后，你可以在这里和那里调整新转换的Kotlin类，以使用Kotlin的最大容量</p><h1 id="0bcd" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated"><strong class="ak">开始迁移！</strong></h1><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2986304f293ad5c8de730a282bc162b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*NzFIEslXWAM377EODzf16g.jpeg"/></div></figure><p id="32b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你还在等什么？开始吧！开始这一令人敬畏的旅程，你会发现这将是你职业生涯或事业的一个惊人的决定。</p></div></div>    
</body>
</html>