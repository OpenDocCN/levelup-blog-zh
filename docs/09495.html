<html>
<head>
<title>2D Collision Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2D碰撞检测</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/2d-collision-detection-8e50b6b8b5c0?source=collection_archive---------4-----------------------#2021-08-16">https://levelup.gitconnected.com/2d-collision-detection-8e50b6b8b5c0?source=collection_archive---------4-----------------------#2021-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="92ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想用JavaScript制作一个操作起来和感觉上像超级马里奥世界的游戏。这些游戏中屏幕上的角色的物理和运动简单而优雅。处理这种2d碰撞检测的最基本的方法是利用一个被称为<strong class="jp ir">轴对齐边界框</strong>的概念。</p><p id="84f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">轴对齐边界框</strong>，或<strong class="jp ir"> AABB </strong>，检测两个非旋转多边形是否相互重叠。典型的<strong class="jp ir"> AABB </strong>算法是这样运行的:</p><p id="6433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有两个多边形，每个都有一个X(左)和一个Y(上)位置，以及宽度和高度属性。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/95751a7dfadefff9329ace5f259dd459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yLbbs2q9vWbZpD-GkcXJsw.png"/></div></figure><p id="3e42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们比较X和Y位置以及宽度和高度，看它们是否重叠。</p><p id="3226" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们测试四个条件语句，如果都为真，那么我们知道我们是重叠的。让我们打破各自的条件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi kt"><img src="../Images/3094ed0cb23fe455b9940d4a5623d5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-W506cjZogra51PFEyqSQ.png"/></div></div></figure><p id="c34c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">线2 — A的左边在B的右边的左边。</p><p id="963b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第3行——A的右边在B的左边的右边。</p><p id="4333" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第4行——A的顶部在B的底部之上。</p><p id="9826" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第5行— A的底部比B的顶部低。</p><p id="8652" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们插入马里奥和他的硬币的真实值，用黄色和红色多边形表示。每个多边形的X和Y位置来自距视口左边缘和上边缘的像素距离。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ky"><img src="../Images/0f4cf5e0b9f1d7405ce30576d201b17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGKFPz5x-F4r_XH4DyuYzg.png"/></div></div></figure><p id="e372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种算法有一个强大的应用范围。它可以用来检测你的玩家是否在一个可收集的物品上，触摸一个坏人，在游戏结束时在门口或者只是站在一个固体物体上。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="3234" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">游戏组件</h1><p id="1b9a" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我的项目是一个简单的基于图块的2d平台游戏，由玩家对象、名为“Cubio”的32×32像素红色正方形、三种类型的“坏人”和游戏世界的图块地图组成。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mj"><img src="../Images/9117c21413ee8d58ee6c6c0f61635807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Gs5KWJGQXZGRNcZM9sViA.png"/></div></div></figure><h1 id="5faa" class="lg lh iq bd li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz mo mb mc md bi translated">瓷砖</h1><p id="54f9" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">整个地图仅由四种类型的图块组成。尺寸为80乘80像素，每个都有自己的数值和特定的规则集，这些规则集决定了玩家在碰撞时如何与它们进行交互。</p><h2 id="f26d" class="mp lh iq bd li mq mr dn lm ms mt dp lq jy mu mv lu kc mw mx ly kg my mz mc na bi translated">0:天空</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f2d21ecd8139eb19e7a8b46612b17c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:160/format:webp/0*9RIIGlYaBo0bvt1E.png"/></div></figure><p id="428a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">玩家可以自由地通过这个方块。</p><h2 id="772d" class="mp lh iq bd li mq mr dn lm ms mt dp lq jy mu mv lu kc mw mx ly kg my mz mc na bi translated">1:地球</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/603a43abc4d3319b7f90eb33f573c844.png" data-original-src="https://miro.medium.com/v2/resize:fit:160/format:webp/0*IT-hmrI9iJk-6tC5.png"/></div></figure><p id="9dcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果玩家落在瓷砖的顶部，玩家的垂直移动停止，它停留在瓷砖的顶部，否则它可以从每个其他方向穿过这个瓷砖。</p><h2 id="7cb9" class="mp lh iq bd li mq mr dn lm ms mt dp lq jy mu mv lu kc mw mx ly kg my mz mc na bi translated">2:板条箱</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/58ffda50c57bd8b9c5db111944cea099.png" data-original-src="https://miro.medium.com/v2/resize:fit:160/format:webp/0*hiqkDfi1Lxuo5YZ7.png"/></div></figure><p id="744d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果玩家与该牌的任何一面发生碰撞，其位置将位于该牌之外。</p><h2 id="9b6e" class="mp lh iq bd li mq mr dn lm ms mt dp lq jy mu mv lu kc mw mx ly kg my mz mc na bi translated">3:天空岛</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/ad959096dac65909adbacc16b2e706b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:160/format:webp/1*LWYyaU1rcUibgw_D1rNnzQ.png"/></div></figure><p id="9fe8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果玩家落在瓷砖的顶部，玩家的垂直移动停止，它停留在瓷砖的顶部，否则它可以从每个其他方向穿过这个瓷砖。</p><h1 id="7ace" class="lg lh iq bd li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz mo mb mc md bi translated">地图</h1><p id="a6ec" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">此处不涉及太多细节，图块映射由图块类型在它们被分配的列和行中的数组来表示，因此该数组:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/d176028a0ee583e5628062c48ee2c0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cyo85mQTL5BeaNl9aPSMMw.png"/></div></div></figure><p id="8f1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…显示为:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mj"><img src="../Images/82f0200b477610f2f1dca42610616d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nij-kCkhte7izbeV.png"/></div></div></figure></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="da1f" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">互动和行为</h1><p id="5145" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">无论是天空还是地球，我的玩家总是在每一帧中与至少一个瓷砖发生碰撞，所以没有必要运行aabb()函数。我的collision_detection()函数首先定位玩家每个角的位置。然后，它检索角落碰撞的瓷砖类型。然后，它将瓷砖的类型和角的x和y位置传递给collide()函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mj"><img src="../Images/ecd112c1918ca5eabac05a16cf64934d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4Zjl188aE8y0BGVn.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mj"><img src="../Images/06904c859126ef67314fa13dedfa332e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Us4GaNkK-_8rMZGf.png"/></div></div></figure><p id="22db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">collide()函数使用一个switch语句来根据图块类型选择要运行的适当代码块。正如你所看到的，类型“0”(天空)没有效果，类型“2”(箱子)与所有四个边碰撞。如果你想知道为什么我在collision_detection()中定义了这些点两次，那是因为每次我调用collide()时，它都有可能移动玩家。所以每次调用collide()后，每个点都要重新定义。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mj"><img src="../Images/9850747202c34e4e86de10e3346e2619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9WKjucFte_JuIHmN.png"/></div></div></figure><p id="8531" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这些不同的瓷砖碰撞功能，你可以看到球员的旧位置进行比较，以及瓷砖。这允许你确定玩家前进的方向。</p><p id="976a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数需要知道玩家要去的方向，以获得正确的响应。否则，如果玩家与板条箱瓷砖的底部碰撞，它的顶部现在在板条箱底部之上。然后，当我们运行<strong class="jp ir"> collide() </strong>时，<strong class="jp ir"> collide_top() </strong>首先启动，并将玩家放置在磁贴的顶部。对用户来说，玩家似乎直接穿过板条箱的底部，落在顶部。这种负面效应被称为“隧道效应”。因此，建立玩家方向给了我们一个更好的表现正在发生的事情。</p><p id="9149" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到，当编写一个<strong class="jp ir">坏人_碰撞_检测()</strong>函数时，它与此非常相似，只是我们可以修改<strong class="jp ir">碰撞_顶()</strong>来杀死坏人，所有其他碰撞杀死接触的玩家。</p><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="5517" class="mp lh iq ne b gy ni nj l nk nl">function baddyCollideTopMortal(player, bad){</span><span id="37f0" class="mp lh iq ne b gy nm nj l nk nl">    if (player.getBottom() &gt; bad.getTop() &amp;&amp; player.getOldBottom() &lt;= bad.getTop()){<br/>      <br/>        player.setBottom(bad.getTop() - 0.01);<br/>        <br/>        player.y_velocity = -27;<br/>        player.jumping = false;<br/>        let dead_index = currentGame.alive_baddies.indexOf(bad);<br/>        currentGame.alive_baddies.splice(dead_index, 1);<br/>        return true;<br/>    } return false;<br/>  }<br/>  <br/>  function baddyCollideLeft(player, bad){<br/>  <br/>    if (player.getRight() &gt; bad.getLeft() &amp;&amp; player.getOldRight() &lt;= bad.getLeft()){<br/>        player.setRight(bad.getLeft() - 1);<br/>        player.x_velocity = 0;<br/>        player_dead = true;<br/>        return true;<br/>    } return false;<br/>    <br/>  }</span></pre><h1 id="eb73" class="lg lh iq bd li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz mo mb mc md bi translated">AABB、硬币和坏人的效率</h1><p id="8189" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">一旦你所有的牌、硬币和坏人都与你的玩家正确互动，你会注意到在引擎循环的每个周期对每个硬币和坏人进行碰撞测试是非常昂贵和不必要的。</p><p id="cd47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是将碰撞测试分为两个阶段的地方，广义和狭义。</p><h1 id="56ad" class="lg lh iq bd li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz mo mb mc md bi translated">辽阔的</h1><p id="65bc" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">在广义阶段，创建一个附近的实体(硬币，坏人)阵列。遍历实体的完整列表，检查对象的x位置以查看它是否靠近玩家，然后将该实体推入附近列表。这比在每个实体上运行整个碰撞测试的成本要低得多。</p><h1 id="9847" class="lg lh iq bd li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz mo mb mc md bi translated">狭窄的</h1><p id="d3d5" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">一旦创建了一个小得多的邻近对象列表，我们就用<strong class="jp ir"> aabb() </strong>函数和/或运行适当的代码块来迭代每个碰撞测试。</p><p id="935c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">碰撞检测是让你的游戏栩栩如生的机制。每一步都很容易理解，可以用许多不同的方式重新想象，但一旦实施，就会变得强大。编码快乐！</p></div></div>    
</body>
</html>