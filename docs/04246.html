<html>
<head>
<title>Simple Svelte Micro Frontends with Podium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单纤薄的微型前端，带讲台</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/easy-svelte-micro-frontends-with-podium-34aa949bed02?source=collection_archive---------14-----------------------#2020-06-16">https://levelup.gitconnected.com/easy-svelte-micro-frontends-with-podium-34aa949bed02?source=collection_archive---------14-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3f7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想要直接进入代码吗？</p><div class="kp kq gp gr kr ks"><a href="https://github.com/Jozzeh/podium-svelte-example" rel="noopener  ugc nofollow" target="_blank"><div class="kt ab fo"><div class="ku ab kv cl cj kw"><h2 class="bd iu gy z fp kx fr fs ky fu fw is bi translated">jozzeh/讲台-苗条-示例</h2><div class="kz l"><h3 class="bd b gy z fp kx fr fs ky fu fw dk translated">一个迷你苗条微前端架构使用服务器端组成与讲台。讲台文件…</h3></div><div class="la l"><p class="bd b dl z fp kx fr fs ky fu fw dk translated">github.com</p></div></div><div class="lb l"><div class="lc l ld le lf lb lg lh ks"/></div></div></a></div><p id="f8b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Podium使微前端的服务器端组合变得容易。某种程度上，Podium和Svelte有点像——Svelte是一个编译器，生成纯HTML、CSS和JS(没有虚拟dom)。Podium将来自不同来源(微前端)的HTML、CSS和JS编译/组合成一个页面。</p><p id="ee96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文是系列文章的一部分。其他文章有… <br/> <a class="ae li" href="https://medium.com/@jozzeh/podium-easy-server-side-micro-frontends-385f3a4cd346" rel="noopener"> <em class="ko">指挥台:服务器端组成的微前端简介</em> </a> <em class="ko"> <br/> </em> <a class="ae li" href="https://medium.com/@jozzeh/react-micro-frontends-with-podium-dd832075d924" rel="noopener"> <em class="ko">反应微前端与指挥台</em></a><em class="ko"><br/></em><a class="ae li" href="https://medium.com/@jozzeh/vue-micro-frontends-with-podium-7d4d96b36596" rel="noopener"><em class="ko">微前端与VueJS &amp;指挥台<br/> </em> </a> <a class="ae li" href="https://medium.com/@jozzeh/react-vue-svelte-on-one-page-with-micro-frontends-f740b3ee6979" rel="noopener"> <em class="ko">结合多个前端库与指挥台</em> </a></p><p id="b454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用讲台在一个页面上组成2个基本的苗条应用程序。微前端独立工作，但如果应用程序需要在运行时共享一些数据，我们将使用讲台事件总线。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/3a8c2120573adb796c0137a91a38e778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fhmGU2BXW-AlopjzXXpktg.gif"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">代码的结果</figcaption></figure><h2 id="cf66" class="ly lz it bd ma mb mc dn md me mf dp mg kb mh mi mj kf mk ml mm kj mn mo mp mq bi translated">纤细的微型前端(吊舱)</h2><p id="2d22" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">我们需要3个文件夹… 1个用于基本应用程序，2个用于苗条的微前端。在每个微前端，运行“npx degit sveltejs/template”命令。</p><p id="a0e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在创建了这两个苗条的应用程序之后，我们需要对模板代码做一些小的修改。这些变化将确保苗条的应用程序在放在一个页面上时能够很好地工作。</p><p id="a275" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">渲染div </strong></p><p id="4132" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Svelte呈现应用程序的div应该是唯一的。</p><p id="1834" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在标准安装中，两个瘦应用程序都在de“body”元素中呈现App组件。当我们将两个苗条的应用程序结合在一个页面上时，我们不能让两个应用程序覆盖身体的innerHTML。我们需要向index.html添加一个具有唯一名称的div，然后将该div作为渲染目标。</p><p id="2aef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">public/index.html</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="204b" class="ly lz it mx b gy nb nc l nd ne">&lt;body&gt;<br/>  &lt;div id="svelte-message"&gt;&lt;/div&gt;<br/>&lt;/body&gt;</span></pre><p id="50dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在body标记中添加一个具有唯一ID的新div。<br/>打开src/main.js文件</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="9e11" class="ly lz it mx b gy nb nc l nd ne">import App from './App.svelte';<br/>const app = new App({<br/>  target: document.querySelector( '#svelte-message' )<br/>});<br/>export default app;</span></pre><p id="ee59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将querySelector函数中的ID作为目标，以匹配public/index.html文件中的div ID。</p><p id="f0f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就这样…现在，你可以开发苗条的应用程序了。</p><p id="b666" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">提示:CSS方法论</strong></p><p id="44fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当两个或更多的应用程序走到一起时，应用程序的CSS也被添加和加载。如果在不同的应用程序中使用相同的CSS类名，组件CSS将被覆盖。</p><p id="7580" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">苗条应用程序中的CSS是有作用域的，所以作为开发人员，我们被宠坏了…然而，一些CSS文件可能不是特定于组件的。(模板中有一个全局CSS文件。)</p><p id="c9ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建议使用<a class="ae li" href="https://en.bem.info/methodology/" rel="noopener ugc nofollow" target="_blank"> BEM方法</a>或为这些非组件CSS文件的每个CSS类使用额外的前缀。前缀可以是应用程序的名称，用于“限定范围”或“命名空间”CSS类。</p><h2 id="8deb" class="ly lz it bd ma mb mc dn md me mf dp mg kb mh mi mj kf mk ml mm kj mn mo mp mq bi translated">创建讲台脚架</h2><p id="67d5" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">讲台布局(页面)需要3样东西来组合微前端:</p><ol class=""><li id="3f7a" class="nf ng it js b jt ju jx jy kb nh kf ni kj nj kn nk nl nm nn bi translated">超文本标记语言</li><li id="8029" class="nf ng it js b jt no jx np kb nq kf nr kj ns kn nk nl nm nn bi translated">CSS文件</li><li id="564a" class="nf ng it js b jt no jx np kb nq kf nr kj ns kn nk nl nm nn bi translated">JS文件</li></ol><p id="4060" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Podlet生成一个manifest.json文件，该文件规定了布局可以从哪里获取文件。</p><p id="d6af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，添加所需的包</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="1f8c" class="ly lz it mx b gy nb nc l nd ne">npm install express @podium/podlet @podium/browser</span></pre><p id="1f7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，在项目的根目录下创建一个文件(我称之为mine podlet.js ),导入必要的包并从podlet的定义开始。</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="a106" class="ly lz it mx b gy nb nc l nd ne">const express = require("express");<br/>const Podlet = require("@podium/podlet");<br/>const fs = require("fs");</span><span id="484f" class="ly lz it mx b gy nt nc l nd ne">const app = express();</span><span id="874c" class="ly lz it mx b gy nt nc l nd ne"><em class="ko">// Basic definition of the podlet<br/></em>const podlet = new Podlet({<br/>  name: "svelteMessagePod", <em class="ko">// required<br/>  </em>version: "0.1.0", <em class="ko">// required<br/>  </em>pathname: "/", <em class="ko">// required<br/>  </em>manifest: "/manifest.json", <em class="ko">// optional<br/>  </em>development: true, <em class="ko">// optional, defaults to false<br/></em>});</span></pre><p id="4cd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Svelte将捆绑的JS和CSS文件放在公共文件夹中的一个build文件夹中。通过使用NodeJS的文件系统模块，我们可以读取目录内容并将JS和CSS文件添加到Podlet中。</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="2aba" class="ly lz it mx b gy nb nc l nd ne"><em class="ko">// All css and js files in the build folder should be added to the podlet definition.<br/></em>let svelteassets = fs.readdirSync('public/build');</span><span id="1b1b" class="ly lz it mx b gy nt nc l nd ne">svelteassets.forEach((element, index) =&gt; {<br/>  if(<br/>  element.indexOf('.css') !== -1 &amp;&amp; element.indexOf('.css.map') === -1<br/>  ){<br/>  podlet.css({ value: "http://localhost:7100/build/" + element });<br/>  }else if(<br/>  element.indexOf('.js') !== -1 &amp;&amp; element.indexOf('.js.map') === -1<br/>  ) {<br/>  podlet.js({ value: "http://localhost:7100/build/" + element, defer: true });<br/>  }<br/>});</span><span id="45c2" class="ly lz it mx b gy nt nc l nd ne"><em class="ko">// create a static link to the files for demo purposes.<br/>// In production the localhost URL should be a URL going to a CDN or static file hosting.<br/></em>app.use("/build", express.static("public/build/"))</span></pre><p id="ecb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如评论所说，静态文件的CDN是必要的。出于演示的目的，我从本地服务器提供文件。</p><p id="8e96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">脚本以HTML的定义和清单的生成结束。</p><pre class="lk ll lm ln gt mw mx my mz aw na bi"><span id="5eb3" class="ly lz it mx b gy nb nc l nd ne"><em class="ko">// add HTML to send. This is the div ID in public/index.html<br/></em>app.get(podlet.content(), (req, res) =&gt; {<br/>  res.status(200).podiumSend('&lt;div id="svelte-message"&gt;&lt;/div&gt;');<br/>});</span><span id="ade3" class="ly lz it mx b gy nt nc l nd ne"><em class="ko">// generate the podlet manifest<br/></em>app.get(podlet.manifest(), (req, res) =&gt; {<br/>  res.status(200).send(podlet);<br/>});</span><span id="ddaa" class="ly lz it mx b gy nt nc l nd ne"><em class="ko">//start the app at port 7100<br/></em>app.listen(7100);</span></pre><h2 id="619e" class="ly lz it bd ma mb mc dn md me mf dp mg kb mh mi mj kf mk ml mm kj mn mo mp mq bi translated">讲台布局——结合苗条的应用程序</h2><p id="2739" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">组合苗条的应用程序不是苗条的特定…它只是创建一个布局的讲台方式(包含微前端的页面)。</p><p id="30fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是创建布局的文档:【https://podium-lib.io/docs/layout/getting_started T2】</p><p id="2b86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">NodeJS代码注册了这两个podlets，并将它们呈现在一个页面上。<br/>(基础app/layout.js)</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="bc8e" class="ly lz it bd ma mb mc dn md me mf dp mg kb mh mi mj kf mk ml mm kj mn mo mp mq bi translated">结论</h2><p id="f409" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">不需要太多的改变，我们可以完全独立地开发苗条的应用程序。<br/>讲台Podlet层完全独立于应用程序。作为一名开发者，你可以自由地以你喜欢的方式创建你苗条的微前端。</p><div class="kp kq gp gr kr ks"><a href="https://github.com/Jozzeh/podium-svelte-example" rel="noopener  ugc nofollow" target="_blank"><div class="kt ab fo"><div class="ku ab kv cl cj kw"><h2 class="bd iu gy z fp kx fr fs ky fu fw is bi translated">jozzeh/讲台-苗条-示例</h2><div class="kz l"><h3 class="bd b gy z fp kx fr fs ky fu fw dk translated">一个迷你苗条微前端架构使用服务器端组成与讲台。讲台文件…</h3></div><div class="la l"><p class="bd b dl z fp kx fr fs ky fu fw dk translated">github.com</p></div></div><div class="lb l"><div class="lc l ld le lf lb lg lh ks"/></div></div></a></div><p id="981e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">一些外卖</strong></p><p id="eeab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">微前端架构还是需要团队互相沟通的。尤其是当一个新项目开始的时候。新团队/项目应该与其他团队保持一致，在HTML或CSS中没有冲突。</p><p id="b70d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果开发人员在项目之间切换，公共文件夹结构和包会非常方便。在所有微前端中保持一致的用户界面是一个挑战。开源组件库或定制设计系统可能是UI不一致的解决方案。</p><p id="e8dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文是关于流行框架和库的微前端系列文章的一部分。以下是其他文章:</em></p><p id="f7e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae li" href="https://medium.com/@jozzeh/podium-easy-server-side-micro-frontends-385f3a4cd346" rel="noopener"> <em class="ko">指挥台:服务器端组成微前端</em> </a> <em class="ko"> <br/> </em> <a class="ae li" href="https://medium.com/@jozzeh/react-micro-frontends-with-podium-dd832075d924" rel="noopener"> <em class="ko">反应微前端与指挥台</em></a><em class="ko"><br/></em><a class="ae li" href="https://medium.com/@jozzeh/vue-micro-frontends-with-podium-7d4d96b36596" rel="noopener"><em class="ko">微前端与VueJS &amp;指挥台<br/> </em> </a> <a class="ae li" href="https://medium.com/@jozzeh/react-vue-svelte-on-one-page-with-micro-frontends-f740b3ee6979" rel="noopener"> <em class="ko">结合多个前端框架&amp;库与指挥台</em> </a></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nw"><img src="../Images/86706a614cca3adc7262d342a3bedb5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OMuGmRDj_mHsUmXvsZwufg.jpeg"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">多个细长徽标，中间有一个领奖台徽标</figcaption></figure></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><div class="lk ll lm ln gt ks"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="kt ab fo"><div class="ku ab kv cl cj kw"><h2 class="bd iu gy z fp kx fr fs ky fu fw is bi translated">编写面试问题</h2><div class="kz l"><h3 class="bd b gy z fp kx fr fs ky fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="la l"><p class="bd b dl z fp kx fr fs ky fu fw dk translated">技术开发</p></div></div><div class="lb l"><div class="oe l ld le lf lb lg lh ks"/></div></div></a></div></div></div>    
</body>
</html>