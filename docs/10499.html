<html>
<head>
<title>Understanding Cryptography</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解密码学</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-cryptography-f91fabd749ef?source=collection_archive---------14-----------------------#2021-12-14">https://levelup.gitconnected.com/understanding-cryptography-f91fabd749ef?source=collection_archive---------14-----------------------#2021-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e240" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解加密、解密、散列和数字签名的工作原理，以及Python中的实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3dc98b997cfd38c11a8f756ddefd9f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEMSRQWekQJj4Wc_6r6RNQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">公共领域，<a class="ae ky" href="https://commons.wikimedia.org/w/index.php?curid=226312" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=226312</a></figcaption></figure><p id="296d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您是试图构建一个存储用户凭证的web应用程序，还是编写一个安全传输加密消息的网络应用程序，甚至是试图创建自己的区块链，您都需要了解一个特别重要的主题— <em class="lv">密码术</em>。</p><p id="1192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，密码学(或密码学)就是隐藏信息的实践和研究。这是一门试图保持信息秘密和安全的科学。</p><p id="c62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您解释加密函数的主要类型，以及如何在日常工作中使用它们。为了演示，我将使用Python。</p><h1 id="b6e0" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">密码术的类型</h1><p id="c0ab" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">有三种主要类型的加密技术:</p><ul class=""><li id="79cb" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">散列法</li><li id="3967" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">对称密码术</li><li id="0ee6" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">不对称密码术</li></ul><p id="56ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的几节中，我将更详细地介绍上述每一种类型。</p><h1 id="aa82" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">散列法</h1><p id="d227" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">哈希是将任意大小的数据块转换为固定大小值的过程。执行散列的函数被称为<em class="lv">散列函数</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/db38437f1e082f0287891113d704a177.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*dw5VFI0wkX9wn6qxbLEf5w.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="1826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常见的哈希函数是<strong class="lb iu"> SHA256。</strong></p><blockquote class="ni nj nk"><p id="1b94" class="kz la lv lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated"><strong class="lb iu"> SHA </strong>代表安全哈希算法</p></blockquote><p id="4b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<strong class="lb iu"> SHA256 </strong>散列函数将一个文本块转换成一个256位散列。结果散列通常以十六进制编写，由于每个十六进制占用4位，所以256位散列将有64个字符。要体验哈希是如何工作的，请进入<a class="ae ky" href="https://emn178.github.io/online-tools/sha256.html" rel="noopener ugc nofollow" target="_blank">https://emn178.github.io/online-tools/sha256.html</a>，键入一个句子并观察结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/f038b70b97666c1212e124223f088c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxKvEio2dxg7lSg93KpaEQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="bd8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希具有以下重要属性:</p><ul class=""><li id="dc03" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><em class="lv">抗原像</em> —基于哈希，您无法获得原始文本块</li><li id="ed0f" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><em class="lv">确定性</em> —相同的文本块将总是产生相同的散列</li><li id="c8cb" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><em class="lv">防冲突</em> —很难找到两个不同的文本块会产生相同的散列</li></ul><p id="88bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希的另一个重要特性是，原始文本中的一个变化将导致生成一个完全不同的哈希。例如，以下输入中的单个字符的变化将产生完全不同的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/1dbcf3570567f83c9d4cb425df761aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAH1miiZvWFXkb17w5iDiw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><h2 id="b59d" class="nq lx it bd ly nr ns dn mc nt nu dp mg li nv nw mi lm nx ny mk lq nz oa mm ob bi translated">哈希的使用</h2><p id="6d45" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">哈希在计算中扮演着一些非常重要的角色。首先，网站使用散列法来存储你的密码，而不是以明文形式存储。存储您的密码哈希值可以防止黑客逆转哈希值并获取您的原始密码(其他网站也很可能使用该密码)。此外，网站会采用一些技术，比如在散列之前在你的输入中加盐，来进一步保护你存储的密码。</p><p id="b270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希在区块链中也起着非常关键的作用，每个区块都使用前一个区块的哈希链接到前一个区块。对一个块的任何修改将使存储在下一个块中的散列无效，并且剩余的块将因此无效。</p><h2 id="c57d" class="nq lx it bd ly nr ns dn mc nt nu dp mg li nv nw mi lm nx ny mk lq nz oa mm ob bi translated">在Python中实现散列</h2><p id="b0e2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Python中，可以使用<strong class="lb iu"> hashlib </strong>模块来执行散列。以下代码片段使用<code class="fe oc od oe of b">sha256()</code>函数对字符串执行哈希运算:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="0af7" class="nq lx it of b gy ok ol l om on">import hashlib</span><span id="347f" class="nq lx it of b gy oo ol l om on">result = <strong class="of iu">hashlib.sha256</strong>(<br/>    bytes("The quick brown fox jumps over the lazy dog",'utf-8'))</span><span id="4a84" class="nq lx it of b gy oo ol l om on">print(result.hexdigest())</span></pre><p id="1e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，要散列的字符串必须作为字节数组传递给<code class="fe oc od oe of b">sha256()</code>函数。所以你可以使用<code class="fe oc od oe of b">bytes()</code>函数将字符串转换成一个字节数组。或者，在Python中，可以在字符串前面加上一个'<code class="fe oc od oe of b">b</code>'来表示一个<em class="lv">字节的字符串文字</em>:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="77c8" class="nq lx it of b gy ok ol l om on">result = hashlib.sha256(<br/>    <strong class="of iu">b'The quick brown fox jumps over the lazy dog'</strong>)</span></pre><p id="27ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">sha256()</code>函数返回一个<code class="fe oc od oe of b">sha256</code>散列对象。要获得十六进制的结果散列，可以调用<code class="fe oc od oe of b">sha256</code>散列对象的<code class="fe oc od oe of b">hexdigest()</code>函数。上述字符串的哈希如下:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="8cbb" class="nq lx it of b gy ok ol l om on">d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592</span></pre><p id="45cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您要对原始字符串做一点小小的更改，输出将与之前的散列截然不同:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="62bf" class="nq lx it of b gy ok ol l om on">result = hashlib.sha256(<br/>    b'The quick brown fox jumps over the lazy <strong class="of iu">dag</strong>')<br/>print(result.hexdigest())<br/><strong class="of iu"># 559cc2cb0e1998182b4b6343e38611b3757e8a6279d43e9914d74dfb7e7089e6</strong></span></pre><h1 id="5861" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">对称密码术</h1><p id="afe8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在对称加密中，明文加密和密文解密使用同一个密钥。下图显示了共享密钥在加密和解密中的使用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/fc6c152c8a86ad556c45fb3bb1c5ba24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sb5fI3IdMcO7cDy0qaFRXQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="e178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对称加密快速简单，但主要问题是如何保证密钥保密。例如，如果Tom想要发送一个秘密消息给Susan，Tom可以使用共享密钥加密该消息，Susan可以使用相同的共享密钥解密该加密的消息。这里的问题是汤姆如何将共享密钥发送给苏珊？汤姆能给苏珊发电子邮件吗？通过短信发送，还是用WhatsApp？通过传统邮局给她邮寄怎么样？所有这些方法都不是绝对安全的，并且容易被窃听。而且，有这样一句流行的话:</p><blockquote class="ni nj nk"><p id="6383" class="kz la lv lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">"如果三个人中有两个已经死了，他们还可以保守秘密."</p></blockquote><p id="3c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">意思是，只要不止一个人知道这个秘密，它就不再是秘密了。</p><h2 id="9a67" class="nq lx it bd ly nr ns dn mc nt nu dp mg li nv nw mi lm nx ny mk lq nz oa mm ob bi translated">生成共享密钥</h2><p id="350e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Python中，可以使用<strong class="lb iu">密码术</strong>模块进行对称和非对称密码术。要使用<strong class="lb iu">加密</strong>模块，请使用<code class="fe oc od oe of b">pip</code>进行安装:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="4c63" class="nq lx it of b gy ok ol l om on">$ <strong class="of iu">pip install cryptography</strong></span></pre><p id="4b6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用Python生成一个共享密钥。为此，使用<code class="fe oc od oe of b">Fernet</code>类:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="5965" class="nq lx it of b gy ok ol l om on">from cryptography.fernet import Fernet</span><span id="4af2" class="nq lx it of b gy oo ol l om on"># generate the shared key<br/>shared_key = Fernet.generate_key()<br/>print(shared_key)    # base64 encoded, binary format</span><span id="f8e0" class="nq lx it of b gy oo ol l om on"># A new key is generated each time you run this block of code<br/># e.g. b'ixXEfrz2NTJlxy1OhxXlsCiFf0Ycg_GL0Cy0MlgTv4U='</span></pre><blockquote class="ni nj nk"><p id="cb7c" class="kz la lv lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated"><strong class="lb iu"> Fernet </strong>类是对称(也称为“秘密密钥”)认证加密的实现。Fernet在CBC模式下使用<strong class="lb iu"> AES </strong>算法，使用128位密钥进行加密。更多详情，请参考<a class="ae ky" href="https://github.com/fernet/spec/blob/master/Spec.md" rel="noopener ugc nofollow" target="_blank">https://github.com/fernet/spec/blob/master/Spec.md</a>。</p></blockquote><p id="77e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">generate_key()</code>函数返回二进制格式的共享密钥，它是base64编码的。</p><h2 id="d343" class="nq lx it bd ly nr ns dn mc nt nu dp mg li nv nw mi lm nx ny mk lq nz oa mm ob bi translated">执行对称加密</h2><p id="8ad4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了使用共享密钥加密您的数据，您首先使用共享密钥创建一个<code class="fe oc od oe of b">Fernet</code>类的实例:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="bfa6" class="nq lx it of b gy ok ol l om on"># create an instance of the Fernet class<br/>fernet = Fernet(shared_key)</span></pre><p id="4b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以使用<code class="fe oc od oe of b">encrypt()</code>功能来加密您的数据:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="85fe" class="nq lx it of b gy ok ol l om on"># encrypt the message with the shared key<br/>ciphertext = <strong class="of iu">fernet.encrypt</strong>(<br/>    bytes("Secret message!",'utf-8'))  # remember to pass in a bytes <br/>                                       # array</span></pre><p id="45d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将加密数据保存到文件中:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="2ca4" class="nq lx it of b gy ok ol l om on"># write the encrypted message to file<br/>with open('message.encrypted', 'wb') as f:<br/>    f.write(ciphertext)</span></pre><p id="2aba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及将共享密钥保存到文件:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="fd37" class="nq lx it of b gy ok ol l om on"># write the shared key to file<br/>with open('symmetric_key.crypt', 'wb') as f:<br/>    f.write(shared_key)</span></pre><h2 id="e4c6" class="nq lx it bd ly nr ns dn mc nt nu dp mg li nv nw mi lm nx ny mk lq nz oa mm ob bi translated">执行对称解密</h2><p id="2109" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">解密类似于加密。首先，从文件(我们之前保存的)中加载共享密钥:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="da0f" class="nq lx it of b gy ok ol l om on">with open('symmetric_key.crypt', 'rb') as f:<br/>    shared_key = f.read()<br/>print(shared_key)</span></pre><p id="4316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，使用共享密钥创建一个<code class="fe oc od oe of b">Fernet</code>类的实例，并调用<code class="fe oc od oe of b">decrypt()</code>函数来解码密文:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="998a" class="nq lx it of b gy ok ol l om on"># create an instance of the Fernet class<br/>fernet = Fernet(shared_key)</span><span id="1c28" class="nq lx it of b gy oo ol l om on"># decrypt the encrypted message read from file<br/>with open('message.encrypted', 'rb') as f:<br/>    print(<strong class="of iu">fernet.decrypt</strong>(f.read()).decode("utf-8"))</span></pre><h1 id="e3c1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">不对称密码术</h1><p id="52a9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">与使用单个共享密钥的对称加密不同，非对称加密使用一个密钥对—一个公钥和一个私钥。</p><blockquote class="ni nj nk"><p id="e4e4" class="kz la lv lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">非对称加密也称为公钥加密</p></blockquote><p id="c6bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公钥算法生成两个数学上相关联的密钥</p><ul class=""><li id="60d0" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">一个公钥和一个私钥——公钥，顾名思义，应该是公开的。另一方面，私钥必须绝对保密。</li><li id="a8fa" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">您可以用公钥加密数据，用私钥解密。例如，如果汤姆想给苏珊发送一条秘密消息，汤姆可以用苏珊的公钥加密这条消息，而只有苏珊可以用她的私钥解密这条秘密消息。</li><li id="5fb9" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">您可以用私钥加密数据，用公钥解密。起初，这听起来违背直觉。如果一个人可以使用公钥(应该是公开的)解密，这有什么意义呢？其实这个是有用的。假设汤姆用他自己的私钥加密一条消息并发送给苏珊。当Susan收到消息时，她可以尝试使用Tom的公钥对其进行解密。如果该消息可以被解密，这意味着该消息没有被篡改，并且确实来自Tom。另一方面，如果消息已经被篡改，Susan将无法使用Tom的公钥解密该消息。该技术用于创建数字签名。</li></ul><blockquote class="ni nj nk"><p id="096b" class="kz la lv lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">公钥算法的一个例子是RSA(Rivest–sha mir–ad leman)</p></blockquote><p id="6aff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了第一种方法—使用公钥加密数据，然后使用私钥解密。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/bfb62be849fcbb929095aef479768a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMN6_SCCOr7N32Jitp_Kew.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="e670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了第二种方法—使用私钥加密数据，然后使用公钥解密数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/af36920ae45f18d698a05f08939fcdcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*020fW0EfaoHRLyG1D1n1lQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><h2 id="a535" class="nq lx it bd ly nr ns dn mc nt nu dp mg li nv nw mi lm nx ny mk lq nz oa mm ob bi translated">生成并保存公钥/私钥对</h2><p id="23d5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在让我们使用<strong class="lb iu">密码术</strong>模块和一些常用参数来生成公钥/私钥对:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="4ffd" class="nq lx it of b gy ok ol l om on">from cryptography.hazmat.backends import default_backend<br/>from cryptography.hazmat.primitives.asymmetric import rsa</span><span id="7a34" class="nq lx it of b gy oo ol l om on"># generate the private key<br/>private_key = <strong class="of iu">rsa.generate_private_key</strong>(<br/>    public_exponent=65537,<br/>    key_size=2048,<br/>    backend=default_backend()<br/>)</span><span id="eb62" class="nq lx it of b gy oo ol l om on"># derive the public key from the private key <br/>public_key = <strong class="of iu">private_key.public_key()</strong></span></pre><p id="943c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我使用RSA算法首先生成一个私钥。使用私钥，我可以导出相应的公钥。生成密钥后，将它们序列化到文件中会很有用:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="f107" class="nq lx it of b gy ok ol l om on">from cryptography.hazmat.primitives import serialization</span><span id="4fca" class="nq lx it of b gy oo ol l om on">#---serialize the private key as bytes---<br/>pem = private_key.private_bytes(<br/>    encoding = serialization.Encoding.PEM,<br/>    format = serialization.PrivateFormat.PKCS8,<br/>    encryption_algorithm = serialization.NoEncryption()<br/>)<br/>with open('private_key.pem', 'wb') as f:<br/>    f.write(pem)<br/>        <br/>#---serialize the public key as bytes---<br/>pem = public_key.public_bytes(<br/>    encoding = serialization.Encoding.PEM,<br/>    format = serialization.PublicFormat.SubjectPublicKeyInfo<br/>)<br/>with open('public_key.pem', 'wb') as f:<br/>    f.write(pem)</span></pre><p id="54b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要能够从文件中加载它们:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="8213" class="nq lx it of b gy ok ol l om on">with open('private_key.pem', 'rb') as f:<br/>    private_key = serialization.load_pem_private_key(<br/>        f.read(),<br/>        password = None,<br/>        backend = default_backend()<br/>    )</span><span id="ea8e" class="nq lx it of b gy oo ol l om on">with open('public_key.pem', 'rb') as f:<br/>    public_key = serialization.load_pem_public_key(<br/>        f.read(),<br/>        backend = default_backend()<br/>    )</span></pre><h2 id="e5dc" class="nq lx it bd ly nr ns dn mc nt nu dp mg li nv nw mi lm nx ny mk lq nz oa mm ob bi translated">使用公钥加密</h2><p id="b92e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们现在准备使用<em class="lv">公共</em>密钥执行加密:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="7acf" class="nq lx it of b gy ok ol l om on">from cryptography.hazmat.primitives import hashes<br/>from cryptography.hazmat.primitives.asymmetric import padding</span><span id="1658" class="nq lx it of b gy oo ol l om on">plaintext = bytes("This message is secret.",'utf-8')</span><span id="f386" class="nq lx it of b gy oo ol l om on"># encrypt the message using the public key<br/>ciphertext = <strong class="of iu">public_key.encrypt</strong>(<br/>    plaintext,<br/>    padding.OAEP(<br/>        mgf = padding.MGF1(algorithm = hashes.SHA256()),<br/>        algorithm = hashes.SHA256(),<br/>        label = None<br/>    )<br/>)</span></pre><blockquote class="ni nj nk"><p id="d623" class="kz la lv lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">加密的密文是一个字节数组</p></blockquote><h2 id="56ff" class="nq lx it bd ly nr ns dn mc nt nu dp mg li nv nw mi lm nx ny mk lq nz oa mm ob bi translated">使用私钥解密</h2><p id="355d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">有了密文，您可以使用<em class="lv">私有</em>密钥进行解密:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="0363" class="nq lx it of b gy ok ol l om on"># decrypt using the private key<br/>plaintext = <strong class="of iu">private_key.decrypt</strong>(<br/>    ciphertext,<br/>    padding.OAEP(<br/>        mgf = padding.MGF1(algorithm = hashes.SHA256()),<br/>        algorithm = hashes.SHA256(),<br/>        label = None<br/>    )<br/>)<br/>print(plaintext.decode('utf-8'))<br/># This message is secret.</span></pre><blockquote class="ni nj nk"><p id="d862" class="kz la lv lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">解密后的明文是一个字节数组</p></blockquote><h2 id="8df3" class="nq lx it bd ly nr ns dn mc nt nu dp mg li nv nw mi lm nx ny mk lq nz oa mm ob bi translated">数字签名—使用私钥签名</h2><p id="d14b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">前面我提到过，在<em class="lv">数字签名</em>中，您使用私钥执行加密，然后使用公钥解密。那么这到底是如何工作的，它又是如何有用的呢？让我们来看看下面的事件流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/7a81155b532f8921b59e094780692835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ct8n41PAmZCJRUzkkFcOw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><ul class=""><li id="834f" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">首先，使用哈希函数对要发送的文本进行哈希处理</li><li id="4376" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">然后使用<em class="lv">私有</em>密钥对散列进行加密，并将其转换为<em class="lv">数字签名</em>(这也包括所使用的散列算法的信息)</li><li id="724b" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">然后，将原始文本与数字签名一起发送给收件人。这被称为<em class="lv">签名消息</em>。</li></ul><p id="ca05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了收件人收到签名邮件时的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/840c927658d0889e10311447c96e6a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Kiv0cMRcfN44xiBu_h6fQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><ul class=""><li id="8928" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">当收到签名的邮件时，接收方将使用发送方的公钥从数字签名中解密哈希</li><li id="b1ff" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">接收者还将对接收到的文本进行哈希处理，然后将其与上一步中解密的哈希进行比较</li><li id="4d19" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">如果两个哈希匹配，这意味着文本没有被篡改</li></ul><p id="f668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如您所见，数字签名是一种数学技术，用于验证消息、软件或数字文档的真实性和完整性。</strong></p><p id="e13a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看如何使用私钥创建数字签名。从技术上讲，您不能执行以下操作:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="2bb6" class="nq lx it of b gy ok ol l om on"><strong class="of iu">private_key.encrypt</strong>(...)    # ERROR<br/># AttributeError: '_RSAPrivateKey' object has no attribute 'encrypt'</span></pre><p id="72b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，您调用<code class="fe oc od oe of b">sign()</code>函数:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="9666" class="nq lx it of b gy ok ol l om on">import base64</span><span id="fd91" class="nq lx it of b gy oo ol l om on">plaintext = bytes("This message is public.",'utf-8')</span><span id="47b5" class="nq lx it of b gy oo ol l om on"># sign the message using the private key<br/>signed = <strong class="of iu">private_key.sign</strong>(<br/>    plaintext,<br/>    padding.PSS(<br/>        mgf = padding.MGF1(algorithm=hashes.SHA256()),<br/>        salt_length = padding.PSS.MAX_LENGTH<br/>    ),<br/>    hashes.SHA256()<br/>)</span><span id="8b6a" class="nq lx it of b gy oo ol l om on"># print out the digital signature using base64 encoding<br/>signed_base64 = base64.b64encode(signed).decode('utf-8')<br/>print(signed_base64)</span></pre><p id="8b5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面，我使用了<em class="lv">私有</em>密钥来<em class="lv">签署</em>消息。<code class="fe oc od oe of b">sign()</code>函数返回字符串的数字签名。它以字节数组的形式返回数字签名，在上面的代码片段中，我使用base64编码对其进行了编码，然后将其转换为string。输出如下所示:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="5a7d" class="nq lx it of b gy ok ol l om on">aNUZixxLUiRRpDjm+nqkcaZo5URklvIA/hiSECR+DoLmS+oVb650Ic5/vg6ADmCvi91CSwiXRYkknDBEr2qTWaK+Fe9UPqukDFx8WwyW7K2NacjS8TiKqAfPPSH4t2l9ohexwTqfih9oZXli57zfZ4LKaY63iQxXlWKE9S5OZ0hWyGUfygEInY8OZerGKWFnmxuXHjWNCpDmzSngP04MYBBnfoPVpsDg7vgKL0gpaz1dn2Qg+Ra2GFLmznqjYKq2qP43zLrdYSmzH3MmPAkO0AIh8XaRnHc+q0XYyUGhTBm9iIa7rS8eYaB7MD9G18j0HA7lWWVQjqujnFCQNm8Npg==</span></pre><p id="4292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你传输信息(<code class="fe oc od oe of b">plaintext</code>)时，你也要发送数字签名。</p><h2 id="e04a" class="nq lx it bd ly nr ns dn mc nt nu dp mg li nv nw mi lm nx ny mk lq nz oa mm ob bi translated">使用公钥验证数字签名</h2><p id="2f2a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当接收者收到带有数字签名的消息时，他可以通过调用<em class="lv"> public </em>键上的<code class="fe oc od oe of b">verify() </code>函数来简单地验证消息没有被篡改:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="2835" class="nq lx it of b gy ok ol l om on">from cryptography.exceptions import InvalidSignature</span><span id="82ec" class="nq lx it of b gy oo ol l om on"># decode the digital signature from base64<br/>signed = base64.b64decode(signed_base64)</span><span id="bec9" class="nq lx it of b gy oo ol l om on">try:<br/>    <strong class="of iu">public_key.verify</strong>(<br/>        signed,<br/>        plaintext,    # from the previous section<br/>        padding.PSS(<br/>            mgf = padding.MGF1(hashes.SHA256()),<br/>            salt_length = padding.PSS.MAX_LENGTH<br/>        ),<br/>        hashes.SHA256()<br/>    )<br/>    print('Signature is valid!')<br/>except InvalidSignature:<br/>    print('Signature is invalid!')</span></pre><p id="c3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，您必须捕获由<code class="fe oc od oe of b">verify()</code>函数引发的异常。如果没有异常，签名被认为是正确的，否则是无效的。</p><h1 id="65d7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">摘要</h1><p id="0866" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是关于开发应用程序时通常会遇到的三种加密函数的旋风式讨论。我希望这个解释是清楚的，并且你现在有一个坚实的基础来处理更有趣的开发项目！</p><div class="ou ov gp gr ow ox"><a href="https://weimenglee.medium.com/membership" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">加入媒介与我的介绍链接-李伟孟</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">weimenglee.medium.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>