<html>
<head>
<title>Python: The unacceptable except</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:不可接受的例外</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-the-unacceptable-except-fd633c85c3ae?source=collection_archive---------0-----------------------#2022-09-07">https://levelup.gitconnected.com/python-the-unacceptable-except-fd633c85c3ae?source=collection_archive---------0-----------------------#2022-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f88566ff204eee55021a31fdf9a5903a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbqeFprFEOHALnvjBPFswA.png"/></div></div></figure><div class=""/><div class=""><h2 id="1940" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">还有一个关于铁路和星球大战的故事</h2></div><p id="6aee" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是我的“<a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/python-why-none-is-not-nothing-bb3de55dd471">Why None not Nothing</a>”故事的后续文章，在这篇文章中，我触及了一元编程的表面。虽然“一元”这个词已经引起了一些人的反感，但它在生成更干净、更简洁的代码方面非常有用，同时不会因为样板错误处理逻辑而污染代码。</p><p id="d0be" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">实际上，每个计算机程序都遵循相同的原则:它接收一些输入，对输入进行一系列转换，并产生一些输出。沿着这些转换链，错误可能到处发生，其中之一是“异常”，而正确的“异常处理”被证明是最复杂的规程之一，尤其是因为异常打破了自然的控制流。</p><h2 id="c62c" class="ln lo jb bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">目标受众</h2><p id="566c" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">Pythonistas对从不同的角度看待异常处理感兴趣，并对函数式编程原则有所了解。</p><h2 id="d72b" class="ln lo jb bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">放弃</h2><p id="93a5" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">本文提出的解决方案并不意味着要取代异常处理。这只是在保持自然控制流的同时，以功能风格处理异常情况的不同方式。</p><h2 id="6dd6" class="ln lo jb bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">入门指南</h2><p id="9e60" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">让我们深入星球大战领域做一些调查。为了便于说明，我们将使用<a class="ae lm" href="https://swapi.dev/" rel="noopener ugc nofollow" target="_blank">星球大战API </a>。考虑以下下载函数(您可以简单地将其粘贴到您的REPL中):</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ebe9" class="ln lo jb mq b gy mu mv l mw mx">import requests</span><span id="9d58" class="ln lo jb mq b gy my mv l mw mx">def download(path: str) -&gt; list[dict]:<br/>    response = requests.get(f"https://swapi.dev/api/{path}")<br/>    return response.json()["results"]</span></pre><p id="2cac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个2-liner进入Star Wars API，根据我们提供的路径获取一些信息，并在HTTP响应的JSON主体中返回“results”元素(我们希望是一个字典列表)。我们现在可以检索行星数据(只要您连接到互联网):</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="68ae" class="ln lo jb mq b gy mu mv l mw mx">&gt;&gt;&gt; from pprint import pprint<br/>&gt;&gt;&gt; p = download("planets")<br/>&gt;&gt;&gt; pprint(p)<br/>[{'climate': 'arid',<br/>  'created': '2014-12-09T13:50:49.641000Z',<br/>  'diameter': '10465',<br/>  'edited': '2014-12-20T20:58:18.411000Z',<br/>  'films': ['<a class="ae lm" href="https://swapi.dev/api/films/1/'" rel="noopener ugc nofollow" target="_blank">https://swapi.dev/api/films/1/'</a>, ...],<br/>  'gravity': '1 standard',<br/>  'name': 'Tatooine',<br/>  'orbital_period': '304',<br/>  'population': '200000',<br/>  'residents': ['<a class="ae lm" href="https://swapi.dev/api/people/1/'" rel="noopener ugc nofollow" target="_blank">https://swapi.dev/api/people/1/'</a>, ...],<br/>  'rotation_period': '23',<br/>  'surface_water': '1',<br/>  'terrain': 'desert',<br/>  'url': '<a class="ae lm" href="https://swapi.dev/api/planets/1/'" rel="noopener ugc nofollow" target="_blank">https://swapi.dev/api/planets/1/'</a>},<br/>...<br/>]</span></pre><p id="33ad" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在想想我们的2条线可能会出什么问题:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6c38" class="ln lo jb mq b gy mu mv l mw mx">p = download("planets/1")<br/>...<br/>KeyError: 'results'</span></pre><p id="1b97" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们得到一个KeyError异常，告诉我们响应JSON主体显然不包含“results”元素。</p><p id="d4da" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下一次尝试:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="cb11" class="ln lo jb mq b gy mu mv l mw mx">p = download("insects")<br/>...<br/>requests.exceptions.JSONDecodeError: Expecting value: line 2 column 1 (char 1)</span></pre><p id="2d18" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">JSONDecodeError意味着响应体不是有效的JSON，可能是因为我们请求了一个不存在的实体(昆虫)。</p><p id="b959" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最后，断开网络连接(不要忘记之后重新连接),并执行以下操作:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="079d" class="ln lo jb mq b gy mu mv l mw mx">p = download("planets")<br/>...<br/>requests.exceptions.ConnectionError:</span></pre><p id="938d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">ConnectionError显然表明网络层存在问题。</p><p id="f9a4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通过提供不正确的输入(不存在的路径)或依赖不正确的假设(“结果”元素总是存在)，或者通过模拟外部系统(如网络或远程系统)上的故障，我们很容易使我们的函数失败并引发不同种类的异常。</p><p id="d07d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你看，错误的来源数不胜数，甚至有更多的例外可以打击我们，只要看看这个令人印象深刻的列表:<a class="ae lm" href="https://requests.readthedocs.io/en/latest/api/#exceptions" rel="noopener ugc nofollow" target="_blank">https://requests.readthedocs.io/en/latest/api/#exceptions</a></p><p id="d693" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">看起来我们的2行函数有一些潜在的不良行为，对吗？现在我们可以开始提问了:</p><ul class=""><li id="0f8b" class="mz na jb ks b kt ku kw kx kz nb ld nc lh nd ll ne nf ng nh bi translated">我们如何优雅地处理这种失败？</li><li id="2bcb" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">我们应该在本地捕获异常还是让它们在堆栈中向上传播？其他人可能会觉得有责任。</li><li id="ae53" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">但是，外部作用域中的异常处理程序如何知道它可以预期哪些类型的异常，以及它如何知道要应用哪些补救措施？</li><li id="9aa3" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">如果我们在离异常最近的地方捕获它，我们返回什么？没有吗？一个错误代码(必须有人再次解释)？或者，我们只是记录到stderr并再次“引发”它？</li><li id="2481" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">我们应该根据异常类型做出改变吗？</li><li id="e146" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">我们应该根据异常的超类型对异常进行分组吗？</li><li id="2dab" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">我们程序中的其他函数是如何处理类似情况的？是否有一致的异常处理概念？</li><li id="4a2e" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">我们如何记录我们的异常处理层次结构？</li><li id="6546" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">更重要的是:我们如何测试所有潜在的异常？</li><li id="1008" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi">…</li></ul><p id="2dad" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请记住，异常会破坏控制流。如果一个异常在一个函数中被引发，那么这个函数就不再返回值，而是异常终止。一个例外是我们所说的“副作用”，可能是所有副作用中最无情的一种:-)副作用</p><p id="d478" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在函数式编程环境中，我们希望尽可能避免副作用。他们使函数“不纯”,这意味着他们使函数行为不确定。问题是操作系统经常没有其他传播致命错误的方法(想想运行时错误，比如被零除，或者使用大于数组大小的索引)。</p><h2 id="4f5f" class="ln lo jb bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">最好请求原谅？</h2><p id="bd98" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">底线是，在Python中，我们必须以某种方式处理异常。我们都知道惯用的方法:“请求原谅比请求允许更好”:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="cf52" class="ln lo jb mq b gy mu mv l mw mx">import requests</span><span id="14fd" class="ln lo jb mq b gy my mv l mw mx">def download(path: str) -&gt; list[dict] | None:<br/>    try:<br/>        response = requests.get(f"https://swapi.dev/api/{path}")<br/>        return response.json()["results"]<br/>    except Exception as ex:<br/>        print(f"exception occurred: {ex}")<br/>        return None</span></pre><p id="7332" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“改进的”版本现在只捕捉每一种异常类型，打印一条日志消息，并且不返回任何异常。但是，我们深感满意吗？恐怕，我们不是？我们的修改使我们的程序变得更好了吗？实际上没有。</p><p id="a0c8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为现在我们必须问这个问题:“如果我们的函数不返回任何值，这意味着什么？”。外部函数如何知道如何处理这个问题？不幸的是，他们不知道None是什么意思，因为它根本没有语义。我们不应该更好地返回一个包含错误代码和消息的元组吗？</p><h2 id="a51e" class="ln lo jb bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">进入铁路</h2><p id="de6c" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">如果我告诉你有另一个更安全的选择呢？</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2ec5" class="ln lo jb mq b gy mu mv l mw mx">import requests<br/><strong class="mq jc">from returns.result import safe</strong></span><span id="397a" class="ln lo jb mq b gy my mv l mw mx"><strong class="mq jc">@safe</strong><br/>def download(path: str) -&gt; list[dict]:<br/>    response = requests.get(f"https://swapi.dev/api/{path}")<br/>    return response.json()["results"]</span></pre><p id="57b7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有一个很棒的Python包叫做<a class="ae lm" href="https://returns.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc"> returns </strong> </a>，它可以让你编写无异常代码(如果你想的话)。请安装返回(pip install returns)并再次运行下载命令，首先是成功案例:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="167d" class="ln lo jb mq b gy mu mv l mw mx">&gt;&gt;&gt; p = download("planets")<br/>&gt;&gt;&gt; p<br/>&lt;Success: [{'name': 'Tatooine', 'rotation_period': '23'...}]&gt;<br/>&gt;&gt;&gt; type(p)<br/>&lt;class 'returns.result.Success'&gt;<br/>&gt;&gt;&gt; p.__class__.__bases__<br/>(&lt;class 'returns.result.Result'&gt;,)</span></pre><p id="1b1f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">漂亮的小<em class="nn"> @safe </em> decorator已经将我们的函数“转换”为返回<strong class="ks jc"> returns.result.Result </strong>对象的函数，在成功的情况下，它看起来是子类型<strong class="ks jc"> returns.result.Success </strong>而在失败的情况下，它看起来是子类型<strong class="ks jc"> returns.result.Failure </strong>:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="7810" class="ln lo jb mq b gy mu mv l mw mx">&gt;&gt;&gt; p = download("planets/1")<br/>&gt;&gt;&gt; p<br/>&lt;Failure: 'results'&gt;<br/>&gt;&gt;&gt; type(p)<br/>&lt;class 'returns.result.Failure'&gt;<br/>&gt;&gt;&gt; p.__class__.__bases__<br/>(&lt;class 'returns.result.Result'&gt;,)</span><span id="1e59" class="ln lo jb mq b gy my mv l mw mx">&gt;&gt;&gt; download("insects")<br/>&lt;Failure: Expecting value: line 2 column 1 (char 1)&gt;</span><span id="8ff3" class="ln lo jb mq b gy my mv l mw mx">&gt;&gt;&gt; download("planets")<br/>&lt;Failure: HTTPSConnectionPool(host='swapi.dev', port=443): Max retries exceeded with url: /api/planets (Caused by NewConnectionError('&lt;urllib3.connection.HTTPSConnection object at 0x101b72e90&gt;: Failed to establish a new connection: [Errno 8] nodename nor servname provided, or not known'))&gt;</span></pre><p id="3b82" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有趣的是，我们现在有了一个返回单一数据类型的函数。原始返回值将被保留在Success对象中。装饰器还会捕捉每个异常，并将异常“提升”到一个失败对象中。现在，我们可以用这个结果对象做什么呢？</p><p id="3b6c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通常，我们想要在我们的行星列表上执行一些转换。假设我们想过滤所有温带气候的行星，最后我们想按字母顺序得到这些行星的名称。为此，我们将定义一个基于值过滤属性的通用函数。然后，我们使用partial()创建一个接受单个参数的函数:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d25e" class="ln lo jb mq b gy mu mv l mw mx">from returns.curry import partial</span><span id="14ac" class="ln lo jb mq b gy my mv l mw mx">@safe<br/>def entity_names(<br/>    attribute: str, value: str, entities: list[dict]<br/>) -&gt; list[dict]:<br/>    return [e["name"] for e in entities if value in e[attribute]]</span><span id="461f" class="ln lo jb mq b gy my mv l mw mx"># we need a function taking a single parameter for bind()/map()<br/>temperate_planets = partial(entity_names, "climate", "temperate")</span></pre><p id="9a16" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们必须知道<strong class="ks jc">结果</strong>是一个<strong class="ks jc">单子</strong>，因为它有一个bind()方法，所以我们可以这样编写我们的转换管道:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ab85" class="ln lo jb mq b gy mu mv l mw mx">&gt;&gt;&gt; p = download("planets").bind(temperate_planets).map(sorted)<br/>&gt;&gt;&gt; p<br/>&lt;Success: ['Alderaan', 'Bespin', 'Coruscant', 'Endor', 'Kamino', 'Naboo', 'Yavin IV']&gt;</span></pre><p id="f63d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不错！我们的管道完成了任务！我们得到一个排序后的行星名称列表，打包到一个成功对象中。但是之前的失败案例呢？</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4f0f" class="ln lo jb mq b gy mu mv l mw mx">&gt;&gt;&gt; download("planets/1").map(temperate_planets).map(sorted)<br/>&lt;Failure: 'results'&gt;</span><span id="160b" class="ln lo jb mq b gy my mv l mw mx">&gt;&gt;&gt; download("insects").map(temperate_planets).map(sorted)<br/>&lt;Failure: Expecting value: line 2 column 1 (char 1)&gt;</span><span id="3b1e" class="ln lo jb mq b gy my mv l mw mx">&gt;&gt;&gt; download("planets").map(temperate_planets).map(sorted)<br/>&lt;Failure: HTTPSConnectionPool(host='swapi.dev', port=443): Max retries exceeded with url: /api/planets (Caused by NewConnectionError('&lt;urllib3.connection.HTTPSConnection object at 0x101b71ff0&gt;: Failed to establish a new connection: [Errno 8] nodename nor servname provided, or not known'))&gt;</span></pre><p id="026e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">太酷了，再也不会出现异常了！它来自一元类型的力量。秘方在bind()和map()的实现中，对于<strong class="ks jc">成功</strong>和<strong class="ks jc">失败</strong>是不同的。让我们想象一下这个概念:</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/8931eae38a65833e4a5cd8cbc2a3cf05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2cbZTu4ETdidGo22qese3w.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">转型步骤</figcaption></figure><p id="5a82" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在开头有一个函数safe_func()，它返回一元结果类型(具体地说，要么成功要么失败)，包装在“a”类型的某个值周围(“a”可以是任何类型)。为了能够对这个值进行转换，我们必须使用bind()或map()。</p><p id="c12f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果转换函数返回另一个结果(f: a -&gt; Result[b])，则必须使用bind()，而如果转换函数只返回非一元类型(f: a -&gt; b)，则使用map()。同样，“b”可以是任何类型，甚至与“a”相同！</p><p id="4537" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">值得注意的是，转换函数只应用在快乐路径上。如果传递给bind()的函数返回一个失败，就会发生从快乐路径到错误路径的切换。而那应该是一条不归路！对失败对象调用bind()或map()，只会再次返回失败对象，而不会应用任何转换，无论您如何努力。</p><blockquote class="nt nu nv"><p id="cb00" class="kq kr nn ks b kt ku kc kv kw kx kf ky nw la lb lc nx le lf lg ny li lj lk ll ij bi translated">重要提示:请注意，只有bind()能够执行从成功到失败的切换，map()不能！</p></blockquote><p id="b36b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">还记得玩铁路模型的日子吗？那时你把几段铁轨连接在一起，组成一条新的轨道。我们可以对我们的转换步骤做同样的事情，因为一个步骤的输出与下一个步骤的输入兼容。总是类型结果！</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/727f13b21968c3dadb36bbf8398d9e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4buQLiZWG9_krBhhGHF8kA.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">转换链</figcaption></figure><blockquote class="nt nu nv"><p id="3202" class="kq kr nn ks b kt ku kc kv kw kx kf ky nw la lb lc nx le lf lg ny li lj lk ll ij bi translated">这种风格有时被称为“面向铁路的编程”，这个术语是由Scott Wlaschin创造的。查看他众多类似这样的演讲中的一个(<a class="ae lm" href="https://www.youtube.com/watch?v=fYo3LN9Vf_M" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=fYo3LN9Vf_M</a>)来更深入地了解这个概念！</p></blockquote><h2 id="2bbc" class="ln lo jb bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">打开还是不打开</h2><p id="7ecd" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">剩下的问题是:我们将如何处理加工链的结果？怎么才能释放原来的价值？我们有必要这么做吗？</p><p id="2d97" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">也许我们的管道位于web API之后，我们希望在成功时生成200响应，如果出现异常，则生成500响应。比方说，作为后端，我们对失败的根本原因并不感兴趣，我们只想将信息传播回客户端。</p><p id="cf50" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这意味着，当我们的链完成时，我们必须从结果对象中提取真正的值，这样我们就可以创建一个普通的JSON响应体。为此，我们使用unwrap()方法:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="be67" class="ln lo jb mq b gy mu mv l mw mx">&gt;&gt;&gt; result = download("planets").bind(temperate_planets).map(sorted)<br/>&gt;&gt;&gt; <strong class="mq jc">result.unwrap()</strong><br/>['Alderaan', 'Bespin', 'Coruscant', 'Endor', 'Kamino', 'Naboo', 'Yavin IV']</span></pre><p id="fab4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是等等，如果结果是失败呢？嗯，展开一个失败会导致最初的异常被抛出，这是我们实际上想要避免的结果。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8e4a" class="ln lo jb mq b gy mu mv l mw mx">&gt;&gt;&gt; result = download("planets/1").bind(temperate_planets).map(sorted)<br/>&gt;&gt;&gt; result.unwrap()<br/>Traceback ...<br/>KeyError: 'results'</span></pre><p id="8992" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">眼熟吗？异常没有丢失，它只是在等待再次释放:-)所以我们需要找到一种破坏性更小的方法来解开成功和失败</p><p id="adf5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在函数式编程中，“模式匹配”的概念是必由之路，从Python 10开始，我们拥有了这种非常强大的语言特性(不，它不仅仅是switch-case语句):</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="68b4" class="ln lo jb mq b gy mu mv l mw mx">match result:<br/>    case Success(planets):<br/>       print(planets) # or do whatever has to be done<br/>    case Failure(detail):<br/>       print(detail)  # or fail however you want to fail</span></pre><blockquote class="nt nu nv"><p id="2ef4" class="kq kr nn ks b kt ku kc kv kw kx kf ky nw la lb lc nx le lf lg ny li lj lk ll ij bi translated">我不会详细介绍结构模式匹配是如何工作的，我强烈推荐阅读<a class="ae lm" href="https://peps.python.org/pep-0636/" rel="noopener ugc nofollow" target="_blank"> PEP-636 </a>(在这方面，也要注意__match_args__这就是为什么代码片段可以工作！)</p></blockquote><p id="c756" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用模式匹配，如果结果是一个成功对象(不是构造函数调用语法！)，否则我们将异常消息映射到“detail”变量。</p><p id="bf0e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在早期的Python版本中，我们必须使用更“传统”的命令式方法:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="bf2a" class="ln lo jb mq b gy mu mv l mw mx">from returns.pipeline import is_successful</span><span id="f990" class="ln lo jb mq b gy my mv l mw mx">if is_successful(result):<br/>    print(result.unwrap())<br/>else:<br/>    print(result.failure())</span></pre><blockquote class="nt nu nv"><p id="8229" class="kq kr nn ks b kt ku kc kv kw kx kf ky nw la lb lc nx le lf lg ny li lj lk ll ij bi translated">请注意，如果对Success对象调用p.failure()将引发异常！此外，注意模式匹配的声明性(“你是成功(行星)还是失败(细节)的对象？”)与命令式实现(“如果您是一个成功对象，那么打开包装的值，否则打开失败消息”)</p></blockquote><h2 id="5d8c" class="ln lo jb bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">一个完整的例子</h2><p id="839e" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">让我们以一个工作示例来结束。我组装了一个小而简单的<a class="ae lm" href="https://fastapi.tiangolo.com/tutorial/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a> web服务器应用程序来展示面向铁路的风格:</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">swapi.py与FastAPI一起运行</figcaption></figure><p id="9095" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所有的魔法都从第79行开始。我们正在调用不会抛出异常的管道，所以我们可以直接将它用作match语句的参数。“sorted()”是标准的非一元内置函数，所以我们可以只使用map()。</p><p id="8696" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果管道返回看起来成功的东西(实体)，那么我们只返回一个普通的字典。否则，我们会引发一个包含异常消息的HTTPException(如FastAPI所要求的)。</p><p id="6404" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">除了结果类型和它提供的方法，我们从来不需要处理其他任何东西。只有在最后，我们使用模式匹配来访问封装的值，我们需要在HTTP响应中返回它们。</p><p id="4cb7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您可以随意地将代码存储在一个名为swapi.py的文件中，安装FastAPI并进行测试…</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ebdd" class="ln lo jb mq b gy mu mv l mw mx">pip install fastapi "uvicorn[standard]" httpie<br/>uvicorn swapi:app --reload</span></pre><p id="1038" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">质疑一些蓝眼睛的英雄:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6147" class="ln lo jb mq b gy mu mv l mw mx">http "localhost:8000/names/people?attr=eye_color&amp;value=blue"</span></pre><p id="72c3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">或者质疑其他一些物种:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="bd24" class="ln lo jb mq b gy mu mv l mw mx">http "localhost:8000/names/species?attr=classification&amp;value=mammal"</span></pre><p id="e8ef" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">或者产生错误:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8d81" class="ln lo jb mq b gy mu mv l mw mx">http "localhost:8000/names/insects?attr=size&amp;value=huge"</span></pre><p id="43b0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">诚然，我们的异常的字符串表示不是很有意义，但出于演示的目的，它应该是可以接受的。</p><h1 id="f56e" class="oc lo jb bd lp od oe of ls og oh oi lv kh oj ki ly kk ok kl mb kn ol ko me om bi translated">结果</h1><ul class=""><li id="d2c2" class="mz na jb ks b kt mg kw mh kz on ld oo lh op ll ne nf ng nh bi translated">不再需要异常处理，因为异常会立即变成失败对象。保持自然的控制流。</li><li id="799c" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">以面向铁路的方式实现的转换管道总是端到端的。这意味着在错误跟踪上可能会有一些额外的NOOP函数调用，引入很少的计算开销。</li><li id="6ec1" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">端到端方面也与必须快速失败的情况相矛盾。在这种情况下，铁路方向可能不适用。</li><li id="f94a" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">一元风格需要一定的经验，并熟悉一元和函子的概念，但实际上它归结为如何使用bind()和map()将操作组合在一起。</li></ul><h1 id="3809" class="oc lo jb bd lp od oe of ls og oh oi lv kh oj ki ly kk ok kl mb kn ol ko me om bi translated">结论</h1><p id="4b16" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">本文介绍了一种异常处理方法，作为传统异常处理的替代方法。这并不意味着完全取代异常，事实上有一些<a class="ae lm" href="https://fsharpforfunandprofit.com/posts/against-railway-oriented-programming/" rel="noopener ugc nofollow" target="_blank">合理的论据</a>在某些情况下一般不使用它。我试图保持简单，然而<a class="ae lm" href="https://returns.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">返回</a>提供了许多额外的奇特功能(甚至是一种从错误轨道切换回快乐路径的方式)。如果你愿意，请不要犹豫，继续深入挖掘。</p><p id="ad55" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">顺便说一句:<a class="ae lm" href="https://github.com/orgs/dry-python/repositories" rel="noopener ugc nofollow" target="_blank"> dry-python Github站点</a>有一些更有趣的回复，2个值得注意的是</p><ul class=""><li id="c5f2" class="mz na jb ks b kt ku kw kx kz nb ld nc lh nd ll ne nf ng nh bi translated"><a class="ae lm" href="https://github.com/dry-python/classes" rel="noopener ugc nofollow" target="_blank">https://github.com/dry-python/classes</a></li><li id="409a" class="mz na jb ks b kt ni kw nj kz nk ld nl lh nm ll ne nf ng nh bi translated">https://github.com/dry-python/lambdas<a class="ae lm" href="https://github.com/dry-python/lambdas" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="0e0d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">也许你想看看他们！</p><p id="21c9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">像往常一样，使用概念不仅仅是为了使用概念，而是为了使软件更简单、更可靠、更合理、更可读、可测试、可维护。请不要停止使用异常，通常它们会使意图更加清晰:-)</p><p id="abde" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你觉得这篇文章很有用，请给它一个掌声，随时分享并留下你的评论、问题和改进建议。</p><p id="669c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">谢谢，保重！</p></div></div>    
</body>
</html>