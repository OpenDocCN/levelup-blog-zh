# 角度与反应形式

> 原文：<https://levelup.gitconnected.com/angular-vs-react-forms-e2c6cc0270da>

![](img/d7d21d7794a3231a4eaec7ac5827c46e.png)

许多开发人员在实现 web 应用程序时会问自己使用哪个框架/库。大多是有棱角的，有反应的，有问题的。

因为许多 web 应用程序都基于表单(大多数是复杂的表单)，所以了解每个框架/库如何处理和支持构建表单是至关重要的。我希望这篇文章能够回答许多关于表单的问题。

# 挑战🔥

实现表单时最大的挑战是什么？

## 表单模型和验证

表单模型的定义方式和位置，以及如何处理验证。

## 动态表单和可重用表单

如何动态添加表单并使其可重用？子表单及其验证器是如何与父表单连接的。

## 表单状态

如何定义以及在哪里定义。确定表单及其控件是否被触摸很重要，例如启用/禁用提交按钮。还需要跟踪值的变化、状态的变化、获取值等

## 更复杂的验证

通常，某些特性会推动对更复杂验证的需求，如交叉验证、异步验证、正则表达式验证和任何其他自定义验证。例如，一旦一个复选框被选中，就会显示一个新的表单，或者一个字段的值决定了另一个字段允许的值。

## 正式安排

表单控件的聚合器和容器。例如项目列表。

# 应用✍️

# 有角的

## 表单模型和验证

Angular 提供了两种不同形式的方法:

👉**模板驱动的表单**

👉**反应形式**

他们实际上做什么？它们捕获基本上所有的用户输入事件，验证它们，并提供一种跟踪所有变化的方法。

这两种方法的主要区别是管理表单数据。

总的来说:

👉**反应形式**更强大，更好测试和扩展(围绕可观察的流构建)。它们是同步的，这就是为什么它们更容易预测。

👉**模板驱动表单**将整个逻辑封装在一个模板(html)中。它们主要适用于简单的场景(比如注册表单)。与反应型相比，扩展和测试它们更加困难。它们是**异步**。

因为反应式表单是同步的，而模板驱动的是异步的，所以这两种方法不应该混合使用(在一个模板中),因为这会导致一些不可预知的结果和行为。

**免责声明:**我在我的应用程序中只使用**反应式表单**，我不会描述验证和其他机制是如何在模板驱动的表单中解决和设计的。

下面是一个如何定义表单模型的例子。

组件中的表单模型

*表单组*基本上是一个*表单控件*的容器，并跟踪其所有控件的状态和变化。

模板中的表单模型

该模板还包含一个*表单组*。它在组件中的模型和包含输入的 html 模板中的表单之间进行通信。

*FormControlName* 绑定 *FormGroup* (组件中)*中定义的每个 *FormControl* 输入。*

## 表单状态

反应式表单控件基于 [*抽象控件*](https://gist.github.com/enestoro/ab518ce2139bb3a0258171d42e284076) 类。它包含以下字段:

👉*值、错误、有效、禁用、触摸、…*

和方法，例如:

👉 *valueChanges 和 statusChanges* (两者都返回一个[可观察值](https://www.learnrxjs.io/))，*禁用、启用、设置错误、设置验证器、设置值、重置、标记关闭、…*

## 动态表单和可重用表单

为了创建可重用的表单[*ControlValueAccessor*](https://angular.io/api/forms/ControlValueAccessor)*【CVA】*进场。它充当了 Angular Forms API 和原生 DOM 元素之间的桥梁。它可以用于许多不同的表单控件，如输入、单选、选择、范围……但也可以用于可重用的表单，如下例所示:a*address 组件*。**

**在我的应用程序中，如果帐单和送货地址不同，可以动态添加一个新地址。**

**控制值存取器**

**为了能够将组件用作 CVA，您需要从其接口实现方法并正确注册它:**

**👉 *writeValue* 向元素写入新值(model = > view)**

**👉 *registerOnChange* 注册一个回调函数，当输入元素发生变化事件时调用该函数(view = > model)**

**👉*register intouched*到注册一个回调函数，当输入元素上发生模糊事件时调用该函数(view = > model)**

**👉 *NG_VALUE_ACCESSOR* 和 *NG_VALIDATORS***

***NG_VALUE_ACCESSOR* 注册一个组件，并将一个自定义表单控件集成到反应角度表单*。***

***NG_VALIDATORS* 集成对控制值访问器的验证。例如，有一个父表单需要顶层的 CVA 子表单状态来启用/禁用提交按钮。CVA 的状态是封装的，所以父节点看不到是否没有提供 *NG_VALIDATORS* 以及是否没有实现 *validate* 方法。**

## **验证&更复杂的验证**

**Angular 提供了两种类型的验证函数:**

**👉同步验证器，返回一组错误或空值(如果没有错误)**

**👉**异步验证器**，它返回一个发出一组错误或空值的可观察对象或承诺**

> **出于性能原因，Angular 只在所有同步验证器都通过的情况下运行异步验证器。每个都必须在设置错误之前完成。**

**Angular 有一套内置的[验证器](https://angular.io/api/forms/Validators)，例如:必选、最小/最大、电子邮件、模式、最小长度/最大长度、…**

**内置角度验证器的使用示例:**

**也可以定义自定义验证器，就像我所做的那样:**

## **形成数组**

**Angular 提供了[形式数组](https://angular.io/api/forms/FormArray)来支持表单控件数量动态变化的用例。想象一个巨大的表单，您可以在其中的一个列表中输入任意数量的递送地址:**

**👉*控制，长度，at(索引)***

**👉 *push，insert(index，control)，removeAt(index)，patchValue，setValue，clear，…***

**有一篇关于表单数组的非常好的文章:[https://net basal . com/angular-reactive-forms-the-ultimate-guide-to-formarray-3 adbe 6b 0 b 61 a](https://netbasal.com/angular-reactive-forms-the-ultimate-guide-to-formarray-3adbe6b0b61a)**

# **反应**

## **表单模型和验证**

**在 React 中，三个最流行的表单库是:**

**👉[反应挂钩形式](https://react-hook-form.com/)**

**👉[福米克](https://jaredpalmer.com/formik/)**

**👉[还原形式](https://redux-form.com)**

**在我的应用中，我使用了**反应钩子形式**。我选择这个非常强大的库的一些原因:**

**👉API 非常简单和直观**

**👉非常**小**库**没有任何依赖****

**👉**非常好的性能**(避免了不必要的重新渲染周期；非常短的安装时间)**

**👉**减少了**要写的代码量**

**👉**易于适配**和**将** **与任何框架或 UI 库**集成**

**详细的对比检查[请点击](https://blog.logrocket.com/react-hook-form-vs-formik-a-technical-and-performance-comparison/)。**

**下面是一个如何定义表单模型的例子。**

**我使用[是的](https://github.com/jquense/yup)进行[基于模式的表单验证](https://react-hook-form.com/api#validationSchema)。Yup 允许对复杂的验证和值转换进行建模。这种形式与角形完全相同。**

**[](https://react-hook-form.com/api/#useForm)**方法一旦被调用，就会提供很多有用的方法，如:`register`、`unregister`、`errors`、`watch`、`handleSubmit`、`reset`、`setError`、`clearError`、`setValue`、`getValues`、`triggerValidation`、`control`和`formState.`****

***我设置了一些可选参数，如*模式*和*验证模式*。***

**👉*模式*定义何时触发验证( *onSubmit* 、 *onBlur* 、 *onChange* )**

**👉*验证模式 a* 用`Yup`应用表单验证规则**

***InputRef* 是[material-ui](https://material-ui.com/)[*FormControlLabel*](https://material-ui.com/api/form-control-label/)组件(带标签的复选框)的一部分。它将一个 **ref** 传递给 *input* 元素，这样就可以注册一个表单控件。**

## **表单状态**

**如前所述， *useForm* 提供了一个[*formState*](https://react-hook-form.com/api/#formState)*对象，其中包含了关于表单状态的信息。***

***它包含以下信息:***

***👉*脏，脏字段，已提交，已触摸，有效，正在提交，提交计数****

## **动态表单和可重用表单**

**AddressDataForm 是一个动态的、可重用的表单。**

**为了将该表单与父表单 OrderDataForm 连接起来，我在子表单中使用了[表单上下文](https://react-hook-form.com/advanced-usage#ConnectForm):**

**在父表单中，我使用了 *FormContext* 并传递了*表单:***

## **验证&更复杂的验证**

**我使用 yup 作为验证模式。也可以使用任何其他外部验证，如 [joi](https://github.com/hapijs/joi) 或 [Superstruct](https://github.com/ianstormtaylor/superstruct) 。**

**以下是如何定义验证模式以及如何定义其消息错误的示例:**

**并且在父表单中，父表单的模式包含子表单的模式:**

**因为 billingAddress 表单是有条件地添加的(在复选框上)，所以它的验证将被有条件地添加和激活。**

**是非常强大的，使添加交叉验证成为可能，见*之一:***

## **形成数组**

**React-Hook-Form 支持[形式数组](https://react-hook-form.com/advanced-usage#FieldArrays)(字段数组)也非常类似于 Angular。**

**👉字段*，…***

**👉*追加、前置、移除、交换、移动、插入……***

# **摘要😎**

**看到了最相关的外形特征:这两种解决方案的优点和缺点分别是什么？**

## ****有角度的****

## **表单模型和验证**

**✅ **两种表单类型**:反应式/模板驱动及其模式，这些都有很好的文档记录(如何使用它们，有什么区别)。**

## **动态表单和可重用表单**

**✅ **定制表单控件:** ControlValueAccessors API，用于构建定制表单控件或具有许多字段的可重用表单。**

## **表单状态**

**✅ **表单状态和表单模型**:包含(几乎😉)一切——表单控件、表单数组、表单组。还有:表单状态、流(值改变、状态改变)和非常重要👉所有这些都在表单级别和**表单控制**级别。**

**🔴对于现场状态(反应式)来说，没有什么比监听器更好的了**

## **更复杂的验证**

**✅ **内置验证器和定制验证器**:实现和附加定制验证器是可能的。**

## **正式安排**

**完全支持✅表单容器。**

## **🎁测试**

**Angular 有一个很好的测试设置，并提供了很多单元和集成测试的技巧和技术。**反应式表单**非常容易测试(在组件级)和定制验证器。**

## **反应**

## **表单模型和验证**

**✅表单模型包含所有需要的信息。**

**✅ / 🔴不同的库(例如 *material-ui* )提供了其他方法来添加表单控件到模型中。有时需要使用某种类似 [*控制器*](https://react-hook-form.com/api#Controller) 的桥接器。**

## **动态表单和可重用表单**

**✅使用 React Hook 表单可以构建可重用的表单，并将它们连接到父表单及其验证。**

## **表单状态**

**✅表单状态也包含所有需要的信息。**

**🔴我在文档中找不到类似 Angular 的 *statusChange* 这样的东西。我觉得真的很有用。也没有什么比表单控件状态改变了:*感动，质朴，…***

## **更复杂的验证**

**✅:有很多模式和验证器，比如支持更复杂验证的 Yup。**

**🔴因为有很多可能性，并且不是每个外部验证器都支持我们需要的，所以需要有一个很好的概述，应该使用哪一个，哪一个最适合我们的用例。**

## **正式安排**

**完全支持✅形式的安排。**

## **🎁测试**

**测试是可能的，但不像 Angular 那样容易和有据可查。**

****Angular** 它的模式、内置特性和开箱即用的文档对我来说似乎更强大💪。然而，如果您更看重灵活性，并且愿意花一些时间来构建一个更定制的解决方案，那么 React 可能更适合您的用例。**