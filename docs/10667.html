<html>
<head>
<title>TypeScript Compiler and Compiler API (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本编译器和编译器API(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-compiler-and-compiler-api-part-2-c71f90a1b313?source=collection_archive---------6-----------------------#2021-12-31">https://levelup.gitconnected.com/typescript-compiler-and-compiler-api-part-2-c71f90a1b313?source=collection_archive---------6-----------------------#2021-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">介绍语言服务器服务和编译器API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f2033628b71d4702d9461bae44d43ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppOuKQlcnqdgIs9K9GD4oA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文章的第1部分<a class="ae ky" href="https://medium.com/gitconnected/typescript-compiler-and-compiler-api-part-1-4bb0d24a565e" rel="noopener">中，我们讨论了TypeScript编译器的内部过程。</a></p><p id="dd2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用从第1部分学到的知识，让我们看看TypeScript编译器API的更实际的用法。在第2部分中，我们将讨论语言服务器服务以及VSCode如何使用它。我们还将带着示例浏览TypeScript编译器API。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f390" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">语言服务器服务</h2><p id="78b6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">语言服务器协议(LSP)最初是由微软在2015年开发的，作为一种通信标准，在VS代码中提供自动完成、代码导航等语言支持功能。它旨在以分散的方式公开语言支持服务。</p><p id="9119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在LSP之前，语言支持特性是在每个IDE中单独实现的。这种方法会导致重复劳动、性能低下和维护问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/e384e24b88eae1dfa42a2792312adbfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rY5oF8AWa9nfhnZ4C74epQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"><strong class="bd me">https://code.visualstudio.com/</strong></a></figcaption></figure><p id="6485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过LSP，语言服务标准化了语言工具和IDE之间的通信。它可以用任何语言实现，并在自己的进程中运行，以避免性能成本。任何实现LSP的IDE都可以从中受益。</p><p id="74e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LSP定义了客户端和服务器之间的通信协议。客户端通常是一个IDE插件，而服务器作为一个单独的进程运行。客户端和服务器使用<a class="ae ky" href="https://en.wikipedia.org/wiki/JSON-RPC#:~:text=JSON%2DRPC%20is%20a%20remote%20procedure%20call%20protocol%20encoded%20in%20JSON.&amp;text=JSON%2DRPC%20allows%20for%20notifications,which%20may%20be%20answered%20asynchronously." rel="noopener ugc nofollow" target="_blank"> JSON-RPC </a>协议进行通信。示例请求和响应消息如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/8609b30ab92807145f72145309dc9b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0n2288hjsq36tYvwqkW-w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://microsoft.github.io//language-server-protocol/overviews/lsp/overview/" rel="noopener ugc nofollow" target="_blank">https://Microsoft . github . io//language-server-protocol/overviews/LSP/overview/</a></figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="c23a" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">LSP和VSCode</h2><p id="8217" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在VSCode中，通过内置的TypeScript插件提供现成的TypeScript语言支持。语法高亮特性是通过<code class="fe nc nd ne nf b">TypeScript Language Basics</code>插件提供的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ba269fc27397b5d7c9186d299bf8a9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fd-P-5Vgh7azQvw8tTL0ng.png"/></div></div></figure><p id="86be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">智能感知特性是由<code class="fe nc nd ne nf b">TypeScript and JS language features </code>插件提供的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/faad8defe40bb1e2d85ebf38d5112f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFMQWXkEgOAJy_wiVtD5MA.png"/></div></div></figure><p id="e4b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个插件都利用语言服务器来提供这些特性。该插件监听VSCode事件，通过LSP调用语言服务器，并将结果发送回VSCode。</p><p id="ed1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VSCode中的TypeScript语言服务器称为独立服务器(tsserver.js)。独立服务器侦听从客户端(插件)发送的消息，并将消息发送到typescript-core进行处理。</p><p id="071c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VS代码附带了TypeScript语言服务的最新稳定版本。它可以是与工作区TypeScript版本(在package.json中定义)不同的版本。如果您点击屏幕底部状态栏上的“TypeScript ”,将会显示一个弹出窗口，允许您在两个版本之间切换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/30dec6fd5f7636295e1e7e9cb794aad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*jJRPUZxbHYQLe8fNWDveEg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">当类型脚本版本不同时</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="81a6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">编译器API</h2><p id="5a8a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">TypeScript编译器API是一块隐藏的宝石。编译器API公开了极其强大的工具来以编程方式处理TypeScript代码，并使构建自动化工具或创建您自己的自定义linter变得简单明了。</p><p id="b9c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始使用编译器API，您需要安装“typescript”模块。</p><pre class="kj kk kl km gt nj nf nk nl aw nm bi"><span id="0371" class="mc md it nf b gy nn no l np nq">npm install -g typescript<br/>npm install -D @types/node</span></pre><p id="deae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如文章的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/typescript-compiler-and-compiler-api-part-1-4bb0d24a565e">第1部分所解释的，编译器API的几个关键概念是:</a></p><ul class=""><li id="032b" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">Program:表示应用程序，它包含所有源文件和类型定义文件。</li><li id="f088" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">源文件:包含源代码文本的表示，我们也可以从中提取抽象语法树(AST)。</li><li id="bd48" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">CompilerHost:代表操作系统，使用API访问外部资源，即读取文件。</li><li id="ab62" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">TypeChecker:从AST中的节点提取类型信息。</li></ul><p id="48a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API" rel="noopener ugc nofollow" target="_blank">官方维基页面</a>上，有许多例子说明了API提供的丰富特性。</p><p id="2175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了对编译器API有一个基本的了解，下面显示了几个简单的任务。</p><p id="4fc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">从代码</strong>中获取源文件</p><pre class="kj kk kl km gt nj nf nk nl aw nm bi"><span id="62c8" class="mc md it nf b gy nn no l np nq">import * as ts from "typescript";</span><span id="bc99" class="mc md it nf b gy og no l np nq">const filename = "test.ts";<br/>const code = `console.log('hello');`;<br/>const sourceFile = ts.createSourceFile(<br/>   filename, code, ts.ScriptTarget.Latest<br/>);</span></pre><p id="db1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">从源文件中获取程序</strong></p><pre class="kj kk kl km gt nj nf nk nl aw nm bi"><span id="ee31" class="mc md it nf b gy nn no l np nq">const defaultCompilerHost = ts.createCompilerHost({});<br/>const program = ts.createProgram(<br/>   ["test.ts"], {}, defaultCompilerHost<br/>);</span></pre><p id="bf5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编译器API中，转换器API是最强大的工具之一。让我们来看看如何使用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b1bc" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">使用编译器转换器API修改源代码</h2><p id="db0b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Transformer API允许开发人员将ts文件转换为js文件。它还可以在编译时操作源代码。</p><p id="2945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转换器API的核心是<code class="fe nc nd ne nf b">TransformerFactory </code>和<code class="fe nc nd ne nf b">transformer </code>类型。<code class="fe nc nd ne nf b">Transformer</code>类型只是一个接受<code class="fe nc nd ne nf b">Node</code>并返回<code class="fe nc nd ne nf b">Node</code>的函数。<code class="fe nc nd ne nf b">TransformerFactory </code>返回一个<code class="fe nc nd ne nf b">Transformer</code>回调。</p><pre class="kj kk kl km gt nj nf nk nl aw nm bi"><span id="fc57" class="mc md it nf b gy nn no l np nq">export type TransformerFactory&lt;T extends Node&gt; = (context: TransformationContext) =&gt; Transformer&lt;T&gt;;</span><span id="0a34" class="mc md it nf b gy og no l np nq">export type Transformer&lt;T extends Node&gt; = (node: T) =&gt; T;</span></pre><p id="d2ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们用一个虚构的例子来说明transformer API的用法。在下面的源文件中，我们有一个条件类型<code class="fe nc nd ne nf b">petType</code>。我们还基于<code class="fe nc nd ne nf b">petType</code>衍生了两种类型。我们的目标是推断类型值，并使用transformer API添加到后面的注释中。</p><pre class="kj kk kl km gt nj nf nk nl aw nm bi"><span id="9926" class="mc md it nf b gy nn no l np nq">// test.ts<br/>type petType&lt;T&gt; = T extends { sound: 'wang' } ? 'dog': 'cat';</span><span id="74a7" class="mc md it nf b gy og no l np nq">type pet1 = petType&lt;{ sound: 'wang' }&gt;;<br/>type pet2 = petType&lt;{ sound: 'mio' }&gt;;</span></pre><p id="b98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们定义一个<code class="fe nc nd ne nf b">TransformerFactory</code>如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="3b6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变压器功能的要点是:</p><ul class=""><li id="b489" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe nc nd ne nf b">ts.visitNode(node, visitor)</code> -用于访问根节点，即<code class="fe nc nd ne nf b">SourceFile</code></li><li id="1ecb" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nc nd ne nf b">ts.visitEachChild(node, visitor, context)</code> -用于访问节点的每个子节点</li><li id="7a4f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">我们将上下文传递给<code class="fe nc nd ne nf b">TransformerFactory</code>函数，并返回源文件。</li><li id="895f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nc nd ne nf b">visit </code>函数被定义为遍历源文件AST的每个节点</li></ul><p id="00da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在visit函数中，我们添加了以下逻辑来推断类型值</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="416a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe nc nd ne nf b">typeCheker </code>用于检索节点的类型，然后我们使用<code class="fe nc nd ne nf b">addSyntheticTrailingComment </code>添加尾部注释。</p><p id="b41a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的源代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="1785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的输出显示了添加了正确推断类型的尾部注释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/eee1f5f75fda6335b8b7124ae9bbaaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*-pgZGqGI-EFlfbQXoPzbRQ.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="4bc4" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">摘要</h2><p id="6ae9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本文中，我们介绍了语言服务和TypeScript编译器API。我们还通过一个虚构的例子来演示transformer API。</p><p id="5f02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然它只是触及了TypeScript编译器API的表面，但我希望它能激发您的兴趣，进一步探索它并将其应用到您的工作中。</p><p id="d7d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="of">如果您还不是Medium的付费会员，</em> <a class="ae ky" href="https://sunnysun-5694.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="of">您可以访问此链接</em> </strong> </a> <em class="of">。你可以无限制地阅读媒体上的所有报道。我会收你一部分会员费作为介绍费。</em></p></div></div>    
</body>
</html>