<html>
<head>
<title>Greedy Algorithms.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">贪婪的算法。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/greedy-algorithms-438eff5c303a?source=collection_archive---------9-----------------------#2021-07-23">https://levelup.gitconnected.com/greedy-algorithms-438eff5c303a?source=collection_archive---------9-----------------------#2021-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd7b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们是什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/181cd600aa4d6cd2113de160555daaff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*baG4yYVt-fodLBnx"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@madebyjens?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">延斯·勒列</a>拍摄</figcaption></figure><h1 id="0388" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简单的定义</h1><p id="7223" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">根据<a class="ae ky" href="https://brilliant.org/wiki/greedy-algorithm/" rel="noopener ugc nofollow" target="_blank">辉煌</a>的说法，贪婪算法是:</p><blockquote class="mn mo mp"><p id="2e16" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated">“一种算法，当它试图找到解决整个问题的整体最优方法时，在每一步都做出最优选择。”</p></blockquote><p id="76a7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在，这可能会使贪婪算法看起来是一个复杂和错综复杂的算法，但事实并非如此！</p><p id="adb8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们来看一个例题，看看情况如何！</p><h1 id="0720" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">糖果</h1><p id="e4f7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">来自<a class="ae ky" href="https://www.hackerrank.com/challenges/candies/problem" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> HackerRank </strong> </a>:</p><h2 id="3c7d" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">声明:</h2><p id="59e3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">爱丽丝是一名幼儿园老师。她想给班上的孩子们一些糖果。所有的孩子坐成一排，根据他们在班上的表现，每个孩子都有一个评分。爱丽丝想给每个孩子至少一颗糖。如果两个孩子坐在一起，那么得分高的那个孩子肯定会得到更多的糖果。爱丽丝想尽量减少她必须买的糖果总数。</p><h2 id="dd3a" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">示例:</h2><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8179" class="mz la it nm b gy nq nr l ns nt"><strong class="nm iu"># Input</strong><br/>students = <strong class="nm iu">[4, 6, 4, 5, 6, 2]</strong></span><span id="ca2a" class="mz la it nm b gy nu nr l ns nt"><strong class="nm iu"># Output<br/></strong>She gives the students candy in the following minimal amounts: <br/><strong class="nm iu">[1, 2, 1, 2, 3, 1]</strong>. </span><span id="46b5" class="mz la it nm b gy nu nr l ns nt">She must buy a minimum of 10 candies.</span></pre><h1 id="e902" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">说明</h1><p id="f57a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因为这个问题只要求老师给两人中表现更好的学生更多的糖果，所以分配糖果的最佳方式是给表现更好的学生更多的糖果。</p><p id="f20f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这使得多次查看数组这一看似复杂的搜索变成了一项简单的任务。</p><p id="309a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们只需要从数组的两边遍历数组两次，以确保我们考虑了每一对。</p><p id="e3c7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">因为每个学生必须从一颗糖开始，我们可以在课程开始时预先分配。</p><p id="080e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们可以从存储一个列表来跟踪每个学生的糖果开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d89a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">接下来，开始从前到后遍历列表，并为表现更好的学生调整糖果的数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6fea" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">执行另一个迭代，这次包括一个额外的检查，看看表现较好的学生比表现较差的学生得到的糖果少还是相等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6254" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在，我们完成了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/6504d5dacd67faeb4652ff5de341071f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWVxgXjCNZVvmosvxqVspg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">通过所有测试案例！| <a class="ae ky" href="https://www.hackerrank.com/challenges/candies/problem" rel="noopener ugc nofollow" target="_blank">来源:HackerRank </a></figcaption></figure><p id="9079" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">时间复杂度是O(N ),因为我们只计算两次迭代中最差的一次。</p><h1 id="a398" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="34b2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我希望你喜欢读这篇文章，并且你学到了新的东西！如果你有任何问题，建议，或一般的反馈，请随时在评论中提出来！</p><p id="2394" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">编程快乐！</p></div></div>    
</body>
</html>