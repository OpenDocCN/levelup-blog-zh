<html>
<head>
<title>Advanced Regex: Find and Replace Every Second Instance Of A Character</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级正则表达式:查找并替换每两个字符实例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/advanced-regex-find-and-replace-every-second-instance-of-a-character-c7d97a31516a?source=collection_archive---------0-----------------------#2019-09-03">https://levelup.gitconnected.com/advanced-regex-find-and-replace-every-second-instance-of-a-character-c7d97a31516a?source=collection_archive---------0-----------------------#2019-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eb405bf8ceb87e8a62b9cc333759f5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4dhPHE_9QKgljgdZ-a_Yw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我拍的照片。大黄蜂得到蜂蜜，布鲁克林植物园。</figcaption></figure><p id="2891" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我正在做一个个人项目，其中一部分涉及一些实验性的分号插入。虽然这个功能可以应用于任何字符，但我将使用反勾号作为参考点。参见下面的字符串。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="f1c6" class="lm ln it li b gy lo lp l lq lr">var str = `HERE IS A</span><span id="2624" class="lm ln it li b gy ls lp l lq lr">MULTILINE</span><span id="e596" class="lm ln it li b gy ls lp l lq lr">COMMENT` </span></pre><p id="eafc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">目标是在第二个反勾号后插入一个分号。为什么？因为如果我们在每个反勾号后面加上分号，我们的字符串将会这样结束:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="d8b6" class="lm ln it li b gy lo lp l lq lr">`;HERE IS A</span><span id="0b41" class="lm ln it li b gy ls lp l lq lr">MULTILINE</span><span id="4734" class="lm ln it li b gy ls lp l lq lr">COMMENT`;</span></pre><p id="e5ab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将改变字符串的内容，最终通过在字符串值后添加分号来改变含义。这里是我的字符串‘不一样’；这是我的线。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lt"><img src="../Images/804781d5908e44253850445f92613ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5yWCBj6SrAoAn3sBRXRIQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由Medium的仪表盘提供。</figcaption></figure><p id="4450" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过只查找第二个反勾号，我们可以确保分号只放在字符串的末尾，而不是放在每个反勾号之后——包括第一个反勾号。那么，我们如何找到并替换反勾号的每一个<strong class="kh iu">秒</strong>实例呢？</p><p id="c18e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用正则表达式，我们可以通过写<code class="fe lu lv lw li b">/`/g</code>来识别反勾号。这一小段将匹配字符串中的每个反勾号。在您的控制台中尝试下面的代码。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="d184" class="lm ln it li b gy lo lp l lq lr">var str = "`HERE IS A COMMENT (with back ticks)`"<br/>var newStr = str.replace(/`/g, '`;')<br/>console.log(newStr)</span><span id="b7f2" class="lm ln it li b gy ls lp l lq lr">&gt; "`;HERE IS A COMMENT (with back ticks)`;"</span></pre><p id="1178" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们使用JavaScript的<code class="fe lu lv lw li b">replace()</code>函数替换并传递我们的正则表达式作为第一个参数，传递<code class="fe lu lv lw li b">'`;'</code>作为第二个参数。这些参数告诉我们的<code class="fe lu lv lw li b">replace()</code>函数，它应该找到<code class="fe lu lv lw li b">`</code>的每个实例，然后用反勾号和分号替换它。</p><p id="0fa9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">既然我们知道了如何查找和替换每一个反勾号，我们就可以改进我们的正则表达式，使之能够每隔一个就查找一次。为此，我<a class="ae lx" href="https://stackoverflow.com/questions/57444177/use-regex-to-find-and-replace-every-second-backtick-in-a-string" rel="noopener ugc nofollow" target="_blank">询问了堆栈溢出社区</a>。一个小时内，我的问题被<a class="ae lx" href="https://stackoverflow.com/users/5424988/the-fourth-bird" rel="noopener ugc nofollow" target="_blank"> <em class="ly">第四只鸟</em> </a>回答了。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/d8e9fa4cbae8e54dc79efff0bf80a50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/1*D-CArUrVIEn4p4Al4NK9Iw.gif"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">*不是真正的第四只鸟。</figcaption></figure><p id="a927" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">他们推荐使用<a class="ae lx" href="https://javascript.info/regexp-groups" rel="noopener ugc nofollow" target="_blank">捕获组</a>，它将模式的一部分括在括号中。这使我们能够分开比赛的一部分。当使用替换时，捕获组也是有帮助的，但是我们一会儿会讲到。</p><p id="5f7d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在您的控制台中尝试下面的正则表达式。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="3e81" class="lm ln it li b gy lo lp l lq lr">let str = "abcabcabcabc"<br/>let matchedArr = <!-- -->str.match(/(abc)+/g)<br/>console.log(matchedArr)</span><span id="a726" class="lm ln it li b gy ls lp l lq lr">&gt; ["abcabcabcabc"]</span></pre><p id="ef31" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">该正则表达式将<code class="fe lu lv lw li b">+</code>修饰符应用于“abc ”,因此它将匹配任何后跟一个或多个“abc”实例的“abc”实例。如果没有捕获组，它将只对“c”应用修饰符，匹配“abc”后跟一个或多个“c”实例。有道理吗？</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/b9000b95bb151893a12a7882440776c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*0BbGiaEUUxACd6hwpdVBFg.gif"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">太棒了。让我们继续前进。</figcaption></figure><p id="fe19" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将使用捕获组来包含我们的否定字符表达式。在我们的否定字符表达式中，我们在括号外有一个反勾。然后我们在克拉后面的括号里有一个反勾号，以及其后的<code class="fe lu lv lw li b">*</code>。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="ce09" class="lm ln it li b gy lo lp l lq lr">(`[^`]*)</span></pre><p id="b1dd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将查找一个模式，该模式包括一个左反勾号，后跟除反勾号之外的任何字符的0个或多个实例。我们就要到了，但是我们还需要一个字符来完成我们的模式:一个结束的反勾号！为什么？我们希望将第一个反勾号之后的任何内容与第二个反勾号分开。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="5a6a" class="lm ln it li b gy lo lp l lq lr">(`[^`]*)`</span></pre><p id="62b6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将我们带到替换函数的最后一部分，<a class="ae lx" href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/substitutions-in-regular-expressions" rel="noopener ugc nofollow" target="_blank">替换</a>。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/4dc58115b7a0bc65b175a866ade9330e.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/1*-5cQ1L9HsGHI1g_cfhWpZw.gif"/></div></figure><p id="f7fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种替换用美元符号和数字来标识。因为我们只有一个捕获组，所以我们将使用数字1。我们替换的目的是匹配与我们的捕获组最近匹配的文本相同的文本。我们将使用它来捕获第一个反勾号之后的内容，然后将其恢复到原始形式。这对我们的事业有什么帮助？嗯，我们可以在替换中添加其他东西，比如，哦，我不知道，也许是一个<strong class="kh iu">反勾和一个分号</strong>？</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/03d16dd056bd8adf4783f161e5f19b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/1*_pGj3DixmBImxcAl_HWWdA.gif"/></div></figure><p id="eca9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过在我们的<code class="fe lu lv lw li b">$1</code>后面添加<code class="fe lu lv lw li b">`;</code>，我们有效地将第一个反勾号之后的所有内容替换为它本身，然后用一个反勾号和一个分号替换第二个反勾号(在捕获组之外)。尝试下面的代码，看看它是如何工作的。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="53ad" class="lm ln it li b gy lo lp l lq lr">let str = <!-- -->"`HERE IS A COMMENT (with back ticks)`"<br/>let final = str.replace(/(`[^`]*)`/g,'$1`;')<br/>console.log(final)</span><span id="358d" class="lm ln it li b gy ls lp l lq lr">&gt; "`HERE IS A COMMENT (with back ticks)`;"</span></pre><h1 id="868e" class="md ln it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><strong class="ak">总结</strong></h1><p id="bef0" class="pw-post-body-paragraph kf kg it kh b ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky ne la lb lc im bi translated">我们使用一个<strong class="kh iu">捕获组</strong>隔离第一个反勾号之后的所有内容。捕捉组以一个反勾号开始，后面是<strong class="kh iu">被否定的字符类</strong>。这个求反的字符类查找除了反勾号以外的任何字符。我们在此之后使用一个<strong class="kh iu">星号</strong>来捕获第一个反勾号之后的任意字符的0个或多个实例(而不是另一个反勾号)。在捕获组的外部，我们有一个闭合的反勾号，因此它与捕获组匹配的内容是分开的。一个<strong class="kh iu">替换</strong>将允许我们的replace函数用它自己替换第一个反勾号和后面的内容。由于我们的模式中的反勾号位于捕获组之外，所以这个反勾号不会被替换为它本身，而是在替换的末尾用附加的反勾号和分号替换。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="9d59" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你喜欢这篇文章或者需要澄清任何提到的事情，请在评论中告诉我。请随意分享和留下掌声！</p><p id="c2b8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在此  <em class="ly">将您的免费媒体会员升级为付费会员，每月只需5美元，您就可以收到来自各种出版物上数千名作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h1 id="95f4" class="md ln it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">参考</h1><div class="nm nn gp gr no np"><a href="https://stackoverflow.com/questions/57444177/use-regex-to-find-and-replace-every-second-backtick-in-a-string" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">使用regex查找并替换字符串中的每一个反勾号</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">stackoverflow.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od jz np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://javascript.info/regexp-groups" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">捕获组</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">模式的一部分可以用括号括起来(...).这被称为“捕获组”。这有两个影响:它…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">javascript.info</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od jz np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://www.regular-expressions.info/charclass.html#negated" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">字符类或字符集</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">使用“字符类”，也称为“字符集”，您可以告诉正则表达式引擎只匹配几个字符中的一个…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.regular-expressions.info</p></div></div></div></a></div><div class="nm nn gp gr no np"><a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/substitutions-in-regular-expressions" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">正则表达式中的替换</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">替换是只能在替换模式中识别的语言元素。他们使用正则表达式…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">docs.microsoft.com</p></div></div></div></a></div></div></div>    
</body>
</html>