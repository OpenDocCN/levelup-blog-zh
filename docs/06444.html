<html>
<head>
<title>The Factory Pattern In Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的工厂模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-factory-pattern-in-go-a584a9467ffd?source=collection_archive---------3-----------------------#2020-11-25">https://levelup.gitconnected.com/the-factory-pattern-in-go-a584a9467ffd?source=collection_archive---------3-----------------------#2020-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f85e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">惊讶吧——你已经知道如何实现一个简单的工厂了！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/9ff840145c80faf6387b64a0952c2a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SwBDhYVPXwXxd807"/></div></figure><p id="366f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi kw translated">工厂设计模式是贯穿软件工程的一种灵活且常用的技术。以制造汽车为例。汽车的基本定义是，它需要车架、车轮、发动机等。汽车可以有很大的不同，从苏丹到卡车，到电动发动机和汽油发动机。工厂模式给一个对象的<em class="lf">通用</em>行为一个契约，然后这个对象可以有各种具体的实现。</p><p id="82d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将研究真实世界用例中的工厂模式、它的UML图以及它在Go中的实现。</p><p id="65ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们开始吧！</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="b71b" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">真实世界的例子</h1><p id="9f0d" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">可以应用工厂模式的例子数不胜数。虽然其他模式(如Decorator或Strategy)向现有对象添加了额外的行为或属性，但工厂模式定义了对象本身的创建。</p><p id="4f45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是一些使用案例示例:</p><ul class=""><li id="b5b8" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><strong class="js iu">数据库</strong> —假设您的应用程序当前使用一个数据库，比如SQL，但是您需要换一个不同类型的数据库。如果已经有了工厂模式，那么为保持程序正常运行而需要修改的代码量将会大大减少。</li><li id="ee8e" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">银行业务 —不同的银行账户，如支票账户、储蓄账户或商业账户，不仅可以有不同的属性，还可以有不同的行为。因为它们仍然是某种形式的银行帐户，所以工厂模式可以用来轻松地为用户分配不同的帐户类型。</li><li id="8b52" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">电脑</strong> —你可以定义电脑的基本类型，如Windows或Mac，它们使用的处理器类型，屏幕宽度等等。</li></ul><p id="df18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，当您需要一些依赖于其他对象的对象时，您应该考虑使用工厂模式。本地化复杂对象的逻辑是工厂模式的另一个理想情况，但是重要的是要确保你不要过度抽象你的程序，我们将在后面看到这一点。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="833f" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">UML图</h1><p id="5d4b" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">工厂模式出奇的简单，因为它能给你的程序带来很大的灵活性。我们的主要目标是以这样一种方式编排抽象，即我们可以轻松地创建对象，而不必知道具体细节是如何实现的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/31cfc155c48a856db36cbedac4446245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*1yJ8yPTyp_Bgr1bM.jpg"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">来自<a class="ae nj" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="a9b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从左上角开始，Creator对象的目标是为工厂模式定义最高级别的契约。本质上，它需要一些具体的Creator对象来实现<code class="fe nk nl nm nn b">factoryMethod()</code>以便创建产品，同时还需要产品接口由最终创建的对象 <code class="fe nk nl nm nn b">Product1</code>来实现<em class="lf">。</em></p><p id="8823" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我们创建了一个从<code class="fe nk nl nm nn b">Creator</code>接口开始的依赖循环。因为Go本身没有类，所以我们在这里关心的主要问题是，我们需要一个对象接口来创建其他对象，还需要一个接口来创建对象。这就是为什么工厂模式在某种程度上是复杂对象和类型的创建和使用之间的桥梁。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="5870" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">Go中的实现</h1><p id="bf14" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">实际上有三种通用类型的工厂实现。简单工厂、工厂方法以及抽象工厂是抽象出对象创建细节的各种方式。在本文中，我们将关注简单工厂，因为它实际上经常在Go和工厂方法模式中使用。也许我们会定义一个工厂模式的工厂？</p><p id="d188" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">严肃地说，简单工厂就是我们给定一些参数实例化新对象的能力。我们在Go中一直这样做，因为没有类，因此没有构造函数方法。例如:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b62c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看似琐碎，但<code class="fe nk nl nm nn b">newDog()</code>方法是一个简单的工厂！</p><p id="e395" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于Go中工厂模式的例子，让我们看看创建不同类型的鸟的例子。让我们首先创建我们的项目文件:</p><pre class="kp kq kr ks gt nq nn nr ns aw nt bi"><span id="7c50" class="nu lo it nn b gy nv nw l nx ny">$ mkdir factory-pattern-go<br/>$ cd factory-pattern-go<br/>$ touch main.go bird.go birdFactory.go osprey.go ostrich.go</span></pre><p id="2e17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nk nl nm nn b">bird.go</code>文件将包括一个通用bird的接口和实现，如下所示。</p><h2 id="881e" class="nu lo it bd lp nz oa dn lt ob oc dp lx kb od oe mb kf of og mf kj oh oi mj oj bi translated">小鸟，去吧</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d4be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很简单。接下来，我们需要特定类型的鸟类来推迟它们的行为。我们将创造两种我最喜欢的鸟，鸵鸟和鱼鹰！</p><h2 id="6119" class="nu lo it bd lp nz oa dn lt ob oc dp lx kb od oe mb kf of og mf kj oh oi mj oj bi translated">鸵鸟。去吧</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="33ca" class="nu lo it bd lp nz oa dn lt ob oc dp lx kb od oe mb kf of og mf kj oh oi mj oj bi translated">鱼鹰，走</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e91a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所看到的,<code class="fe nk nl nm nn b">osprey</code>和<code class="fe nk nl nm nn b">ostrich</code>都扩展了<code class="fe nk nl nm nn b">bird</code>结构，并具有不同类型的行为。现在我们只需要一个工厂来制造鸟的物体！</p><h2 id="addd" class="nu lo it bd lp nz oa dn lt ob oc dp lx kb od oe mb kf of og mf kj oh oi mj oj bi translated">birdFactory .走</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1121" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了工厂模式设置，我们可以简单地通过我们的主go文件调用我们的对象。</p><h2 id="d7f1" class="nu lo it bd lp nz oa dn lt ob oc dp lx kb od oe mb kf of og mf kj oh oi mj oj bi translated">main.go</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="784f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们使用<code class="fe nk nl nm nn b">go run *.go</code>运行程序，我们将得到</p><pre class="kp kq kr ks gt nq nn nr ns aw nt bi"><span id="6ce4" class="nu lo it nn b gy nv nw l nx ny">What kind of bird is that?<br/>The Common Ostrich cannot fly.<br/>The Western Osprey is flying!</span></pre></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><p id="aa9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你有它！构建工厂模式主要是为了抽象出创建对象背后的细节。这就是为什么它与其他模式(如Decorator或Strategy)配合得很好，这样我们就可以扩展我们创建的对象。我鼓励您扩展这个例子，进行自己的探索。感谢阅读！</p></div></div>    
</body>
</html>