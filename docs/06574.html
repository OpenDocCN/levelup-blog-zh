<html>
<head>
<title>Dependency Injection Containers in Swift — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的依赖注入容器—第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-containers-in-swift-part-2-5b24f1c4238a?source=collection_archive---------2-----------------------#2020-12-08">https://levelup.gitconnected.com/dependency-injection-containers-in-swift-part-2-5b24f1c4238a?source=collection_archive---------2-----------------------#2020-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6022" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解析时如何配置和传递参数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8e53093433b724557192520a17c6b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CpZA07exXupbJshdRCmgLg.jpeg"/></div></div></figure><p id="6798" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上一篇文章<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/dependency-injection-container-in-swift-b4d7e139338c">Swift中的依赖注入容器</a>中，我们探讨了什么是依赖注入容器(DIC ),以及如何创建一个简单的依赖注入容器。在本文中，我们将探讨如何向DIC传递参数。</p><p id="83da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前，当从DIC解析对象时，我们不传递任何参数，我们只使用默认配置。对于某些情况来说，这可能已经足够好了，但是很多时候我们想要配置被解析的对象。让我们看一个例子，在使用DIC时会出现什么问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="68b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lt lu lv lw b">ServiceThree</code>取决于<code class="fe lt lu lv lw b">ServiceOneProtocol</code>和一些参数。这完全没问题，但是如果我们试图用我们的DIC注册这个类，我们将不能从调用者那里设置参数。我们来看看为什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="8bf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用默认值注册<code class="fe lt lu lv lw b">ServiceThree</code>,因为注册方法是一个通用方法，不知道参数。这意味着当<code class="fe lt lu lv lw b">ServiceThree</code>被解析时，它将始终以无法更改的默认值初始化。这显然是一个需要解决的问题<em class="lx">(双关)。</em></p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="1a99" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">高层规划</h1><p id="cad7" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">有许多方法可以解决这个问题，但是我想提出一个利用泛型能力的解决方案。要记住的要求是</p><ul class=""><li id="3c66" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated"><strong class="kw iu">可扩展性</strong> —当添加更多具有不同参数的对象时，DICs基本方法不应增长。</li><li id="1510" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><strong class="kw iu">类型安全</strong> —应在编译时检测到传递的错误参数。</li><li id="3eb0" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><strong class="kw iu">可用性</strong> —易于使用和理解。</li></ul><p id="7fa7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们回忆一下我们的DICs接口</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="b097" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前我们有一个解析方法，它根据我们注册对象的方式来解析对象。如果我们可以用自定义参数调用resolve方法，那不是很好吗？嗯，我们可以利用泛型的力量，花一点时间来思考我们如何才能做到这一点…</p><p id="78ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从高层次来看，我们希望能够配置被解析的对象。让我们来看看它会是什么样子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="6ab6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意新的resolve方法，它采用了一个配置参数。一开始可能看起来有点混乱，我们一步一步来讨论。在前面的resolve方法中，<code class="fe lt lu lv lw b">Service</code>类型没有约束，这意味着可以使用任何类或协议。在新方法中，我们添加了一个强制<code class="fe lt lu lv lw b">Service</code>类型符合<code class="fe lt lu lv lw b">Configurable</code>协议的约束。</p><p id="f611" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lt lu lv lw b">Configurable</code>协议的目标是添加一种方法，使对象能够被配置，但不定义配置类型是什么。这是因为不同配置的类可以符合它。让我们来看看<code class="fe lt lu lv lw b">Configurable</code>协议</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="1507" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lt lu lv lw b">Configurable</code>协议增加了configure方法，采用通用配置。在协议中将类型声明为泛型的方法是使用<code class="fe lt lu lv lw b">associatedtype</code>。在我们的例子中，<code class="fe lt lu lv lw b">associatedtype</code>将<code class="fe lt lu lv lw b">Configuration</code>声明为泛型。符合该协议的服务将定义具体的配置类型。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="be8e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">运行中的可配置协议</h1><p id="7784" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">既然我们已经声明了新的配置方法和协议，让我们重构<code class="fe lt lu lv lw b">ServiceThree</code>以符合<code class="fe lt lu lv lw b">Configurable</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="ec88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们一步一步地检查这些变化。</p><ol class=""><li id="2a42" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nq ni nj nk bi translated"><code class="fe lt lu lv lw b">ServiceThreeConfigurable</code>符合<code class="fe lt lu lv lw b">Configurable</code>。</li><li id="5749" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nq ni nj nk bi translated">我们定义了<code class="fe lt lu lv lw b">Configuration</code>类型，这个类型将包含我们所有的配置。</li><li id="b998" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nq ni nj nk bi translated">将配置移出init方法需要我们将参数改为变量。</li><li id="2405" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nq ni nj nk bi translated">我们实现了<code class="fe lt lu lv lw b">Configurable</code>协议。注意配置类型不再是通用的<code class="fe lt lu lv lw b">Configuration</code>，而是我们在这个类中定义的<code class="fe lt lu lv lw b">ServiceThreeConfiguration</code>。这是我们定义<code class="fe lt lu lv lw b">Configurable</code> <code class="fe lt lu lv lw b">associatedtype</code>为自定义配置的地方，让编译器知道使用哪一个。</li></ol><p id="9b9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经重构了<code class="fe lt lu lv lw b">ServiceThree</code>以符合<code class="fe lt lu lv lw b">Configurable</code>，让我们看看如何在我们的DIC中注册和解析它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><ol class=""><li id="6f38" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nq ni nj nk bi translated">我们像以前一样注册<code class="fe lt lu lv lw b">ServiceThreeConfigurable</code>。</li><li id="b70b" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nq ni nj nk bi translated">我们用自定义值创建配置。</li><li id="a326" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nq ni nj nk bi translated">我们用创建的配置解决<code class="fe lt lu lv lw b">ServiceThreeConfigurable</code>。</li></ol><p id="716c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们希望我们的解析对象能够用我们的配置来配置，让我们看看如何用我们的DIC来实现这一点</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><ol class=""><li id="cd2b" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nq ni nj nk bi translated">我们使用原始的resolve方法来解析服务，注意服务将符合<code class="fe lt lu lv lw b">Configurable</code>，因为它是这个方法中被传递的一个约束。</li><li id="32f3" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nq ni nj nk bi translated">在初始化之后，我们用我们的定制配置来配置服务。</li></ol></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="626e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="bafc" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">通过在使用它们的类中定义配置类型，而不是包含它们的知识的DIC，使用通用配置使我们的DIC能够向上扩展。</p><p id="dbc0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">配置类型是在编译时检测的，这样就不容易出错，因为传递错误的配置是不会编译的。这也使得它易于使用和理解。</p><p id="4f96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你喜欢这个教程，如果你有任何见解或改进的想法，请留下评论。</p><h1 id="4975" class="mf mg it bd mh mi nr mk ml mm ns mo mp jz nt ka mr kc nu kd mt kf nv kg mv mw bi translated">我的应用</h1><p id="eef7" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated"><a class="ae lq" href="https://apps.apple.com/us/app/koala-nap-snore-solution/id1478157024?source=responses-----f5f046350fc9----0-----------------respond_sidebar--------------" rel="noopener ugc nofollow" target="_blank">www.koalanap.com</a></p></div></div>    
</body>
</html>