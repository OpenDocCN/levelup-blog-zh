<html>
<head>
<title>First time Svelte development for web3 and NFTs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">web3和NFTs的第一次苗条开发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/svelte-development-bc08fda343e8?source=collection_archive---------24-----------------------#2022-08-18">https://levelup.gitconnected.com/svelte-development-bc08fda343e8?source=collection_archive---------24-----------------------#2022-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eb4e1a1cd542e0b7f223d479c0cfe7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FmwAO0vws21_8URm"/></div></div></figure><p id="e196" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近偶然发现了这种编程语言，Svelte，用于开发web3的前端应用程序。我的目标是能够读取令牌和上传NFT文件</p><figure class="kz la lb lc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f58b29563a35ec8d873b8ee5cab4298b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m0wNK1ojIXR2PwMr"/></div></div></figure><p id="0458" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我比较这种反应时，设置要快得多。其他前端框架允许您创建声明性的状态驱动代码，使用这些，浏览器必须做很多额外的工作来将这些声明性结构转换成DOM活动。苗条的语言将会节省你很多时间，并且将会帮助你在你的应用上得到高性能。</p><p id="ac30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我是从React背景开始开发的，状态的处理方式可能会有点混乱。我还在学习，但是我已经能够很容易地用道具和回调函数组装一个模型了。</p><p id="7813" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">他们的在线文档非常容易阅读和使用。我发现浏览例子并理解它们非常容易。它也很容易与函数联系起来，这是我在示例中寻找的特性。例如，在这里你可以拼凑不同类型的模态示例<a class="ae ld" href="https://svelte.dev/repl/033e824fad0a4e34907666e7196caec4?version=3.46.2" rel="noopener ugc nofollow" target="_blank">https://svelte.dev/repl/033e824fad0a4e34907666e7196caec4?版本=3.46.2 </a>我能够将一个带有关闭函数的定制模型作为参数，如下所示。</p><figure class="kz la lb lc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ff6d3d16f80278685348d5ecdb58bb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_Fs991qKrjaO1K28"/></div></div></figure><p id="906f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能会在第10行看到以下内容，这就是如何使用键来检索状态</p><pre class="kz la lb lc gt le lf lg lh aw li bi"><span id="fb2f" class="lj lk it lf b gy ll lm l ln lo">const { open } = getContext(‘simple-modal’);</span></pre><p id="7cc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我会采取以下功能，并根据我的需要重写它</p><pre class="kz la lb lc gt le lf lg lh aw li bi"><span id="5843" class="lj lk it lf b gy ll lm l ln lo">showPopupCustom</span></pre><p id="6f68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我打算将一个动态标题、一些内容和要处理的函数传递到这个模型中，所以最终结果将是</p><pre class="kz la lb lc gt le lf lg lh aw li bi"><span id="9127" class="lj lk it lf b gy ll lm l ln lo">const showPopupCustom = () =&gt; { open(Popup, { title: “Some title”, content: “body content”, button_text: “Pending…”, callback: close, }); };</span></pre><p id="c886" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数close是从上下文中提取的，如下所示</p><pre class="kz la lb lc gt le lf lg lh aw li bi"><span id="a93b" class="lj lk it lf b gy ll lm l ln lo">const { open, close } = getContext(‘simple-modal’);</span></pre><p id="5862" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个函数可以在Svelte提供的示例repo中找到</p><pre class="kz la lb lc gt le lf lg lh aw li bi"><span id="ebe8" class="lj lk it lf b gy ll lm l ln lo">const close = (callback = {}) =&gt; {<br/> if (!Component) return;<br/> onClose = callback.onClose || onClose;<br/> onClosed = callback.onClosed || onClosed;<br/> Component = null;<br/> enableScroll();<br/> };</span><span id="4437" class="lj lk it lf b gy lp lm l ln lo">const open = (NewComponent, newProps = {}, options = {}, callback = {}) =&gt; {<br/>    Component = bind(NewComponent, newProps);<br/>    state = { ...defaultState, ...options };<br/>    updateStyleTransition();<br/>    disableScroll();<br/>    onOpen = (event) =&gt; {<br/>      if (callback.onOpen) callback.onOpen(event);<br/>      dispatch('open');<br/>      dispatch('opening'); // Deprecated. Do not use!<br/>    };<br/>    onClose = (event) =&gt; {<br/>      if (callback.onClose) callback.onClose(event);<br/>      dispatch('close');<br/>      dispatch('closing'); // Deprecated. Do not use!<br/>    };<br/>    onOpened = (event) =&gt; {<br/>      if (callback.onOpened) callback.onOpened(event);<br/>      dispatch('opened');<br/>    };<br/>    onClosed = (event) =&gt; {<br/>      if (callback.onClosed) callback.onClosed(event);<br/>      dispatch('closed');<br/>    };<br/>  };</span></pre></div></div>    
</body>
</html>