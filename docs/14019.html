<html>
<head>
<title>Using Redis for Caching (2023)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redis进行缓存(2023)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-redis-for-caching-2023-42602603dc8a?source=collection_archive---------7-----------------------#2022-10-25">https://levelup.gitconnected.com/using-redis-for-caching-2023-42602603dc8a?source=collection_archive---------7-----------------------#2022-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2aa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">使用Redis进行缓存(2023) </em></p><p id="b836" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将简要介绍:</p><ol class=""><li id="e1fa" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">使用Redis缓存API(Go)</li><li id="219c" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用发布/订阅的Redis订阅</li><li id="4082" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">使用React调用API</li></ol><blockquote class="ld le lf"><p id="606b" class="jq jr ko js b jt ju jv jw jx jy jz ka lg kc kd ke lh kg kh ki li kk kl km kn im bi translated">注意:本文假设读者了解缓存的概念</p></blockquote><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">使用Redis进行缓存</figcaption></figure><h1 id="fb57" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">Redis是什么？</h1><p id="cb4f" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">Redis代表<strong class="js iu">Re</strong>mote<strong class="js iu">Di</strong>dictionary<strong class="js iu">S</strong>server，是一个快速、开源、内存中的键值数据存储。它提供了亚毫秒级的响应时间，支持每秒数百万个实时应用请求。</p><p id="82d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis是一个基于键值的<a class="ae mx" href="https://databasecamp.de/en/data/nosql-databases" rel="noopener ugc nofollow" target="_blank"> NoSQL </a>数据库，它将数据存储在内存中，即RAM中。</p><p id="7bf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">Redis的使用案例</strong></p><ul class=""><li id="a0c5" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">贮藏</li><li id="e618" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">地理空间的</li><li id="6209" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">聊天、消息和队列</li><li id="24d9" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">游戏排行榜</li></ul><p id="25bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">Redis的优势</strong></p><ul class=""><li id="130c" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">简单、快速且易于使用</li><li id="6421" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">支持多种<a class="ae mx" href="https://redis.io/docs/data-types/tutorial/" rel="noopener ugc nofollow" target="_blank">数据结构</a></li><li id="9555" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">允许存储最大<code class="fe mz na nb nc b">512 MB</code>的键和值对</li><li id="a0c4" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">使用<a class="ae mx" href="https://redis.io/topics/sentinel" rel="noopener ugc nofollow" target="_blank"> Redis Sentinel </a>的高可用性</li></ul><p id="af4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">Redis的缺点</strong></p><ul class=""><li id="629c" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">需要巨大的RAM(尽管取决于应用程序的类型)</li><li id="3935" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">如果主设备至少有<code class="fe mz na nb nc b">1</code>个从设备，就会发生故障转移</li><li id="64d8" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">数据只能通过密钥访问</li></ul><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/05bc1cfc04ba1fba9f167e84b75ad0cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4SVL4ukO9nWSm0DJRy39ZA.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">使用Redis进行缓存</figcaption></figure><h2 id="0b7b" class="nk lv it bd lw nl nm dn ma nn no dp me kb np nq mi kf nr ns mm kj nt nu mq nv bi translated">设置Redis</h2><p id="269c" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">我们将使用<a class="ae mx" href="https://hub.docker.com/_/redis/" rel="noopener ugc nofollow" target="_blank"> Docker </a>设置<a class="ae mx" href="https://redis.io/download/" rel="noopener ugc nofollow" target="_blank"> Redis </a></p><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="fd97" class="nk lv it nc b gy oa ob l oc od">docker run -d -p 6379:6379 --name redis redis</span></pre><p id="31da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如今有一些主机提供商，如<a class="ae mx" href="https://aws.amazon.com/redis/" rel="noopener ugc nofollow" target="_blank"> AWS </a>、<a class="ae mx" href="https://redislabs.com/" rel="noopener ugc nofollow" target="_blank"> Redis Labs </a>或<a class="ae mx" href="https://upstash.com/?utm_source=goredis" rel="noopener ugc nofollow" target="_blank"> Upstash </a>在云上提供Redis。</p><p id="4446" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">连接<a class="ae mx" href="https://redis.io/docs/clients/" rel="noopener ugc nofollow" target="_blank"> Redis </a>的方式有很多种。在我们的例子中，我们将使用<code class="fe mz na nb nc b"><a class="ae mx" href="https://redis.io/topics/rediscli" rel="noopener ugc nofollow" target="_blank">RedisCLI</a></code>,因为我们已经准备好docker设置，让我们连接。</p><p id="cb49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个使用<code class="fe mz na nb nc b">RedisCLI</code>工具从Redis数据库中设置、获取和删除值的例子。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><p id="67f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些其他有用的命令</p><p id="a6f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">keys</code> *:寻找所有的钥匙</p><p id="2b08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">FLUSHALL</code>:删除所有数据库中的所有密钥。<br/> <code class="fe mz na nb nc b">FLUSHDB</code>:删除当前选中DB中的所有密钥。</p><p id="deb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">EXPIRE</code>按键120:按键将在<code class="fe mz na nb nc b">120</code>秒后被删除</p><h1 id="37a6" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">使用Redis缓存API(Go)</h1><p id="7cfe" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated"><a class="ae mx" href="https://redis.io/docs/clients/#go" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Go </strong> </a>中有多个客户端可以实现Redis。然而，在本文中，我们将使用<code class="fe mz na nb nc b"><a class="ae mx" href="https://github.com/go-redis/redis" rel="noopener ugc nofollow" target="_blank">Go-redis</a></code></p><p id="9c42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Go-Redis </strong></p><ul class=""><li id="75df" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">Go-Redis是一个用于Go的类型安全的Redis客户端库。</li><li id="457c" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">它是一个Redis客户端，能够支持Redis集群，旨在随着集群的变化自动存储和更新插槽信息。</li><li id="ac00" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">它支持类似<code class="fe mz na nb nc b"><a class="ae mx" href="https://redis.uptrace.dev/guide/go-redis-pubsub.html" rel="noopener ugc nofollow" target="_blank">Pub/Sub</a></code> <code class="fe mz na nb nc b"><a class="ae mx" href="https://redis.uptrace.dev/guide/go-redis-sentinel.html" rel="noopener ugc nofollow" target="_blank">Sentinel</a></code>和流水线的特性</li></ul><p id="1002" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用Gorilla Mux创建API</strong></p><ul class=""><li id="dc63" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">我们将使用<a class="ae mx" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> Gorilla Mux </a>在本地创建API</li><li id="1dcf" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">它实现了一个请求路由器和调度程序来匹配传入的请求。</li></ul><p id="aaee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用安装它</p><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="2691" class="nk lv it nc b gy oa ob l oc od">go get -u github.com/gorilla/mux</span></pre><ul class=""><li id="e7f5" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">我们将注册以下端点:</li></ul><p id="2473" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">GET /users/:id</code> —根据id获取用户信息。样本响应</p><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="f471" class="nk lv it nc b gy oa ob l oc od">[<br/>   {<br/>      "id":"116c24b1-9425-4fe4-aec2-86ba7384733e",<br/>      "name":"Bob",<br/>      "age":29,     <br/>      "source":""<br/>   },<br/>   {<br/>      "id":"a3fa13d4-67a9-4ae6-9713-dce7043844d7",<br/>      "name":"Alice",<br/>      "age":29,<br/>      "source":""<br/>   }<br/>]</span></pre><p id="732a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">GET /users</code> —返回数据库中存在的用户。样本响应</p><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="d2cd" class="nk lv it nc b gy oa ob l oc od">{<br/>   "id":"116c24b1-9425-4fe4-aec2-86ba7384733e",<br/>   "name":"Bob",<br/>   "age":29,<br/>   "source":""<br/>}</span></pre><ul class=""><li id="04d2" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">接下来，我们使用<code class="fe mz na nb nc b">mux.NewRouter()</code>创建路由器实例，并将上面创建的路由分配给各自的处理程序</li><li id="4793" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">将ResponseWriter和Request作为参数传递给每个相应的处理程序，这有助于将所需的响应返回给客户端。</li><li id="e51a" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">然后，我们使用<code class="fe mz na nb nc b">http.Server</code>来指定运行HTTP服务器的服务器细节</li></ul><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><p id="23ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">Handler</code>:这是响应传入HTTP请求的对象(我们在上面创建的)</p><p id="4c19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">Addr</code>:指定服务器监听的TCP地址，默认为<code class="fe mz na nb nc b">80</code></p><p id="df08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">WriteTimeout</code>:响应写入超时前的最大持续时间</p><p id="eff8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">ReadTimeout</code>:读取整个传入请求的最大持续时间</p><ul class=""><li id="b6f9" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">最后，我们使用<code class="fe mz na nb nc b">ListenAndServe</code>运行服务器，它监听<code class="fe mz na nb nc b">Addr</code>中指定的网络地址，并基于<code class="fe mz na nb nc b">Handler</code>服务请求</li></ul><h2 id="89d7" class="nk lv it bd lw nl nm dn ma nn no dp me kb np nq mi kf nr ns mm kj nt nu mq nv bi translated">设置Postgres</h2><p id="cd8e" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">我们将使用Postgres作为我们的数据库。使用docker安装它，如下所示</p><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="8bf6" class="nk lv it nc b gy oa ob l oc od">docker run \<br/>  -d \                                     <br/>  -e POSTGRES_HOST_AUTH_METHOD=trust \<br/>  -e POSTGRES_USER=user \<br/>  -e POSTGRES_PASSWORD=password \<br/>  -e POSTGRES_DB=dbname \<br/>  -p 5432:5432 \<br/>  postgres</span></pre><ul class=""><li id="44ad" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">验证新容器是否已创建并运行在0.0.0.0:5432 <br/> <code class="fe mz na nb nc b">docker ps -a</code>上，以便从浏览器管理数据库，安装<a class="ae mx" href="https://www.pgadmin.org/download/" rel="noopener ugc nofollow" target="_blank"> pgAdmin </a>并使用上述凭证连接到它，如果一切正常，您应该会看到</li></ul><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi of"><img src="../Images/8a771f00d87e7d221fcd70d2560f77c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*CazxSZgKc64-lbsmCw5C0Q.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Postgres数据库</figcaption></figure><p id="d2b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将创建一个名为<code class="fe mz na nb nc b">users</code>的表，它将具有以下模式</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi og"><img src="../Images/dbc07ef0d8b11def48acc05e0eee939e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sx3U9aMu4V2wtT2vFoCVtQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">用户表</figcaption></figure><p id="1aba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们插入一些虚拟数据，使用</p><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="c4c4" class="nk lv it nc b gy oa ob l oc od">INSERT INTO public.users(<br/> id, created_time, name, updated_time, age)<br/> VALUES (uuid_generate_v4(), NOW(), 'alice', NOW(), 29);</span><span id="087f" class="nk lv it nc b gy oh ob l oc od">// IN CASE ANY ERROR RUN THIS<br/>CREATE EXTENSION IF NOT EXISTS "uuid-ossp"</span></pre><p id="69d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使用<code class="fe mz na nb nc b">Go</code>连接到Postgres，我们将安装<a class="ae mx" href="github.com/jackc/pgx/v4" rel="noopener ugc nofollow" target="_blank">这个</a>下面是代码片段</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><p id="0df7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是<code class="fe mz na nb nc b">users</code>的结构</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><p id="c1d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦创建了get users API和get users by id API，我们将使用Gorilla Mux创建一个<code class="fe mz na nb nc b">localhost</code>服务器并监听端点</p><h2 id="2e64" class="nk lv it bd lw nl nm dn ma nn no dp me kb np nq mi kf nr ns mm kj nt nu mq nv bi translated">缓存API</h2><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/2948de76928d459d53aa8d8961fe4537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*jI76sdMEWFSYzPI4bt_Ftg.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">数据库和客户端之间的Redis</figcaption></figure><p id="b014" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了连接到<code class="fe mz na nb nc b">Redis</code>，我们使用<code class="fe mz na nb nc b"><a class="ae mx" href="https://github.com/go-redis/redis/blob/v8.11.5/redis.go#L546" rel="noopener ugc nofollow" target="_blank">NewClient</a></code>创建一个Redis客户端，我们指定Redis所在的地址</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><ul class=""><li id="0305" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">配置选项可通过<code class="fe mz na nb nc b">redis.Options</code>参数获得。</li></ul><p id="6355" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">Addr</code>:主机和端口地址的字符串，因为我们在本地托管Redis，所以值为<code class="fe mz na nb nc b">127.0.0.1</code>，默认情况下，Redis在端口<code class="fe mz na nb nc b">6379</code>上运行</p><p id="9961" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">DB</code>:连接到服务器后选择的数据库。选择<code class="fe mz na nb nc b">0</code>意味着使用默认数据库。</p><p id="d029" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">DialTimeout</code>:如果我们与Redis服务器的连接中断，我们指定建立新连接的超时时间</p><p id="eca7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">ReadTimeout</code>:这允许设置套接字读取超时。如果任何Redis服务器请求达到这个超时，调用它的命令将失败，而不是阻塞服务器。</p><ul class=""><li id="94d4" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">为了检查我们是否连接到服务器，我们使用上面创建的客户端调用<code class="fe mz na nb nc b"><a class="ae mx" href="https://pkg.go.dev/github.com/go-redis/redis/v8#Client.Ping" rel="noopener ugc nofollow" target="_blank">Ping</a></code>。如果没有错误，这意味着我们连接到Redis服务器。</li><li id="a1f7" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">最后，我们返回Redis客户机，它在内部可能有零个或多个连接。</li></ul><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="ed12" class="nk lv it nc b gy oa ob l oc od">if _, err := client.Ping().Result(); err != nil {<br/> return nil, err<br/>}</span><span id="06e3" class="nk lv it nc b gy oh ob l oc od">return &amp;Client{<br/> client: client,<br/>}, nil</span></pre><p id="3bbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">获取和设置密钥</strong></p><ul class=""><li id="de29" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">我们将遵循的用例是，每当前端请求特定用户的详细信息时，我们将从API中获取它，然后缓存它。</li><li id="12dc" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">特定用户的后续请求将由缓存提供服务，直到缓存键过期(我们将其设置为<code class="fe mz na nb nc b">20 seconds</code>)</li><li id="876f" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">我们将利用<code class="fe mz na nb nc b"><a class="ae mx" href="https://github.com/go-redis/redis/blob/v8.11.5/commands.go#L890" rel="noopener ugc nofollow" target="_blank">Set</a></code>来设置缓存中的值</li></ul><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><blockquote class="ld le lf"><p id="2ede" class="jq jr ko js b jt ju jv jw jx jy jz ka lg kc kd ke lh kg kh ki li kk kl km kn im bi translated">注意:这里我们将<code class="fe mz na nb nc b">user</code>结构作为输入。然后我们将Go结构转换成JSON(又名封送处理),因为JSON是一种独立于语言的数据格式。</p></blockquote><ul class=""><li id="4ef3" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">我们用可选的过期参数<code class="fe mz na nb nc b">20 seconds</code>来设置密钥对，这意味着密钥将在给定的持续时间内自动过期。</li><li id="8b60" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">如果没有过期参数，则表示<code class="fe mz na nb nc b">Zero expiration</code>表示密钥没有过期时间。</li></ul><p id="c138" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">获取钥匙</strong></p><ul class=""><li id="8294" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">我们将利用<code class="fe mz na nb nc b"><a class="ae mx" href="https://github.com/go-redis/redis/blob/v8.11.5/commands.go#L784" rel="noopener ugc nofollow" target="_blank">Get</a></code>来检索键值</li></ul><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><ul class=""><li id="0436" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">响应是字符串的形式，然后我们将字节数据转换成原始的<code class="fe mz na nb nc b">user</code>结构(也称为解组)</li><li id="6afb" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">在这个函数中，我们另外添加了一个Redis publisher(我们将在下一节中看到)。</li></ul><p id="03a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">调用API</strong></p><p id="64f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有这个本地托管的API端点<code class="fe mz na nb nc b">GET /users/:id</code>——根据id获取用户信息。</p><ul class=""><li id="6fba" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">一旦客户端调用了这个端点，我们首先检查这个请求的值是否可以从缓存中提供。</li></ul><blockquote class="ld le lf"><p id="207c" class="jq jr ko js b jt ju jv jw jx jy jz ka lg kc kd ke lh kg kh ki li kk kl km kn im bi translated">注意:如果数据存在于缓存中，我们设置<code class="fe mz na nb nc b">source: "cache"</code></p></blockquote><ul class=""><li id="fc34" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">从逻辑上讲，第一个请求总是命中服务器，因此获得响应的时间会更长。</li></ul><blockquote class="ld le lf"><p id="89a0" class="jq jr ko js b jt ju jv jw jx jy jz ka lg kc kd ke lh kg kh ki li kk kl km kn im bi translated">注意:为了从服务器获取值，我们设置了<code class="fe mz na nb nc b"><em class="it">source: "API"</em></code></p></blockquote><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><ul class=""><li id="8936" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">正如我们在上面的代码片段中看到的，我们首先调用<code class="fe mz na nb nc b">redis.GetUser</code>来检查缓存。</li><li id="6dad" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">该函数检查缓存中的id，如果id存在，则返回值。</li><li id="a00d" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">如果结果失败，函数返回null，我们继续调用API <code class="fe mz na nb nc b">GetUserByID</code>,它命中我们的Postgres数据库</li></ul><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="419d" class="nk lv it nc b gy oa ob l oc od">{<br/>   "id":"116c24b1-9425-4fe4-aec2-86ba7384733e",<br/>   "name":"Bob",<br/>   "age":29,<br/>   "source":"API"<br/>}</span></pre><p id="b856" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是当Redis中没有这个键时的样子</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/d39fe05a636ef0684c97030be422d68c.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*ST5YLQ6W1fmUkL52fBeiMQ.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Redis中不存在密钥</figcaption></figure><ul class=""><li id="7bad" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">然后，来自API的结果被缓存在Redis中，因此后续请求现在由缓存提供服务(直到<code class="fe mz na nb nc b">20 seconds</code>,这是密钥到期的持续时间)</li></ul><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="332d" class="nk lv it nc b gy oa ob l oc od">{<br/>   "id":"116c24b1-9425-4fe4-aec2-86ba7384733e",<br/>   "name":"Bob",<br/>   "age":29,<br/>   "source":"cache"<br/>}</span></pre><p id="2cf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是Redis中存在密钥时的外观</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ok"><img src="../Images/f220202a1c59fad6d332bd3aadad4b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6MOmVp3Y1CFqgjKCUSMCw.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Redis中存在的密钥</figcaption></figure></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><h2 id="e55c" class="nk lv it bd lw nl nm dn ma nn no dp me kb np nq mi kf nr ns mm kj nt nu mq nv bi translated">使用发布/订阅的Redis订阅</h2><ul class=""><li id="6820" class="kp kq it js b jt ms jx mt kb os kf ot kj ou kn my kv kw kx bi translated">在软件工程领域，发布-订阅是一种模式，其中发送者(发布者)将消息分类到通道中，而不知道是否有任何订阅者。</li><li id="c629" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">另一方面，订阅者对一个或多个频道感兴趣，并且只接收感兴趣的消息，而不知道是否有任何发布者。</li><li id="ddd1" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">发布者和订阅者的这种分离增强了更大的可伸缩性。</li></ul><p id="7a8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Redis发布/订阅</strong></p><ul class=""><li id="3728" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">我们将使用Redis发布/订阅，但是，还有各种其他的替代方案，如Apache Kafka、Google cloud发布/订阅等</li><li id="e88c" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">为了订阅频道，例如，<code class="fe mz na nb nc b">foo</code>和<code class="fe mz na nb nc b">bar</code>，客户使用<code class="fe mz na nb nc b"><a class="ae mx" href="https://redis.io/commands/subscribe" rel="noopener ugc nofollow" target="_blank">SUBSCRIBE</a></code>提供频道名称:</li></ul><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="bd1d" class="nk lv it nc b gy oa ob l oc od">SUBSCRIBE foo bar</span></pre><p id="f65b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他客户端发送到这些通道的消息将由Redis推送到所有订阅的客户端。</p><ul class=""><li id="aac2" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">一旦Redis客户端订阅了一个频道，该客户端就不能再执行任何其他操作，只能取消订阅当前频道或订阅更多频道。</li></ul><p id="ec98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Go-Redis发行商</strong></p><p id="258b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">Go-redis</code>允许发布消息和订阅频道。当出现网络错误时，它还会自动重新连接到Redis服务器。</p><ul class=""><li id="6dd0" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">在我们的get user函数中，我们将使用<code class="fe mz na nb nc b"><a class="ae mx" href="https://github.com/go-redis/redis/blob/v8.11.5/commands.go#L3172" rel="noopener ugc nofollow" target="_blank">redis.Publish(</a>)</code>创建一个发布者。这个函数有两个参数，我们要向其发送消息的<strong class="js iu">通道</strong>的名称和<strong class="js iu">消息</strong>。</li><li id="011c" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">在我们的例子中，我们将通道名设置为<code class="fe mz na nb nc b">send-user-name</code>，有效载荷是来自<code class="fe mz na nb nc b">redis.GetUser</code>的响应(见上文)</li><li id="7d76" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">我们使用<code class="fe mz na nb nc b">Publish</code>将整理的有效载荷发送到通道，这是因为它允许像<code class="fe mz na nb nc b">[]byte</code>一样传输数据</li><li id="7fb3" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">因为我们使用的是用户结构，所以它可以被编码成一个<code class="fe mz na nb nc b">[]byte</code></li></ul><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><p id="4912" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Go-Redis用户</strong></p><ul class=""><li id="5cca" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">我们使用<code class="fe mz na nb nc b"><a class="ae mx" href="https://github.com/go-redis/redis/blob/v8.11.5/redis.go#L686" rel="noopener ugc nofollow" target="_blank">redis.Subscribe()</a></code>函数创建一个订户。</li><li id="8969" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">我们将有一个参数，我们想要订阅的<strong class="js iu">频道</strong>，在我们的例子中是<code class="fe mz na nb nc b">send-user-name</code>。</li><li id="b70e" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">Subscribe为客户端订阅指定的频道。因为这个方法不等待Redis的响应，所以订阅可能不会立即激活。</li><li id="5277" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">我们创建一个连接到同一个Redis实例的新文件，并调用以下代码</li></ul><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><ul class=""><li id="b804" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated"><code class="fe mz na nb nc b">subscribe</code>的结果是一个<code class="fe mz na nb nc b">PubSub</code>，我们从这个对象中提取频道属性</li><li id="e0ed" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">此通道返回一个Go通道，用于并发接收消息。如果信道已满30秒，则消息被丢弃。</li><li id="bc53" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">我们在通道上循环，并从中提取数据，数据的类型是每个消息对象包含的<code class="fe mz na nb nc b">Message</code></li></ul><p id="e884" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">Channel</code>:这是频道名称</p><p id="a3e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">Payload</code>:通道接收到的编组数据</p><p id="043b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">Pattern</code>:消息的模式</p><ul class=""><li id="5cc2" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">消息中收到的数据可以使用<code class="fe mz na nb nc b">msg.Payload</code>获取，因为它已经被封送，我们将使用<code class="fe mz na nb nc b">UnmarshalBinary</code>解封它，并转换回<code class="fe mz na nb nc b">User</code> struct。</li><li id="2ec1" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">最后，我们可以访问struct属性并在控制台内部打印。我们还打印消息的频道名称，只是为了好玩！！</li></ul><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ov"><img src="../Images/d12bb00131ab1904d55454ff66b74f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*lTOAAsbWv6_FAvcXgBuJMA.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Redis订户</figcaption></figure><p id="70de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们获得了消息通道名称<code class="fe mz na nb nc b">send-user-name</code>和<code class="fe mz na nb nc b">Bob</code>的用户详细信息</p><h2 id="398c" class="nk lv it bd lw nl nm dn ma nn no dp me kb np nq mi kf nr ns mm kj nt nu mq nv bi translated">使用React调用API</h2><p id="b6e7" class="pw-post-body-paragraph jq jr it js b jt ms jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj mw kl km kn im bi translated">在上面的部分中，我们使用<a class="ae mx" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> Gorilla Mux </a>在本地创建并托管了API。我们现在将使用React从前端使用这些API</p><p id="47ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用Axios来调用API。让我们安装这个依赖项。</p><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="1a43" class="nk lv it nc b gy oa ob l oc od">npm install axios</span></pre><ul class=""><li id="1a8b" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">Axios是一个轻量级HTTP客户端，它使得调用请求非常直观。它类似于JavaScript <code class="fe mz na nb nc b">Fetch API</code></li><li id="7616" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">它可以很好地处理JSON数据，并完成设置请求头的繁重工作。</li><li id="631c" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">它对访问响应有更好的错误处理，并与async-await语法很好地集成。</li><li id="6f1f" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">它既可以在服务器上使用，也可以在客户端使用。</li></ul><p id="9a86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">融入反应堆</strong></p><p id="f6be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用钩子<code class="fe mz na nb nc b">useEffect</code>和<code class="fe mz na nb nc b">useState</code>。钩子<code class="fe mz na nb nc b">hook</code>是一个特殊的函数，可以让你“钩住”React特性。</p><p id="4934" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用效果</strong></p><ul class=""><li id="022d" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">使用这个钩子，我们指示React我们的组件在渲染后需要做一些事情。默认情况下，<code class="fe mz na nb nc b">useEffect</code>在组件每次渲染后运行。</li><li id="7be0" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">这个钩子的一个常见用途是获取数据并显示它。</li><li id="5da0" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">React会记住您传递的函数，并在DOM更新后调用它。</li></ul><blockquote class="ld le lf"><p id="ada7" class="jq jr ko js b jt ju jv jw jx jy jz ka lg kc kd ke lh kg kh ki li kk kl km kn im bi translated">注意:我们在useEffect钩子的末尾有一个空数组，以确保内部函数只渲染一次。</p></blockquote><ul class=""><li id="039a" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">如果我们希望我们的效果运行得不那么频繁，我们提供第二个参数(这是一个值数组)。这些可以被认为是效果的依赖关系，如果有任何变化(自上次以来)，效果将再次运行。</li></ul><p id="abb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用状态</strong></p><ul class=""><li id="e28f" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">它是一种给组件添加状态的方式和<code class="fe mz na nb nc b">preserve</code>函数调用之间的一些值。</li><li id="1a74" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">通常，当函数退出时，变量会“消失”,但是状态变量会被React保留。</li><li id="9f31" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">这种状态可以是数组、对象、数字、布尔值等。</li><li id="02ec" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">传递给<code class="fe mz na nb nc b">useState()</code>的参数是初始状态。</li></ul><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="oe lp l"/></div></figure><ul class=""><li id="6283" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn my kv kw kx bi translated">为了使用Axios发出一个<code class="fe mz na nb nc b">GET</code>请求，我们使用了<code class="fe mz na nb nc b">.get()</code>方法。响应作为对象返回。</li><li id="1be0" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn my kv kw kx bi translated">我们使用响应中的<code class="fe mz na nb nc b">.data</code>属性来获取请求的数据，并使用<code class="fe mz na nb nc b">setFetchedData</code>在钩子内部设置它</li></ul><p id="b583" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">请求响应:</strong></p><p id="b67c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当页面第一次加载时，API访问我们的后端。结果<code class="fe mz na nb nc b">fetchedData</code>随后显示在页面上。</p><blockquote class="ld le lf"><p id="965e" class="jq jr ko js b jt ju jv jw jx jy jz ka lg kc kd ke lh kg kh ki li kk kl km kn im bi translated">注意，来源:API</p></blockquote><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/7f113e0c0fe65aad9bb55fd5eb45e40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*SlPKGGzgF8GVq0ZoCdEcNg.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">资料来源:API</figcaption></figure><p id="f0f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一个请求中，API命中我们的缓存，显示为<code class="fe mz na nb nc b">source:cache</code></p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="ab gu cl ox"><img src="../Images/c1ccd56ce1ab7de1f91ce41d64ed6161.png" data-original-src="https://miro.medium.com/v2/format:webp/1*mY3AfhgxZeApZ3VAUwmc1w.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">来源:缓存</figcaption></figure><p id="59ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">结论</strong></p><p id="a60c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们使用Postgres数据库存储用户数据。我们使用gorilla mux创建了端点。在这些端点之上，我们还集成了Redis来缓存从React应用程序调用的API响应。记住Redis是一个强大的工具，我们所涉及的只是冰山一角。此外，考虑阅读<a class="ae mx" href="http://redis.io/" rel="noopener ugc nofollow" target="_blank"> redis.io </a>上的文档。</p><p id="72c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">网址:</em><a class="ae mx" href="https://flatteredwithflutter.com/using-redis-for-caching-2022%ef%bf%bc/" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://flatteredwithflutter.com/using-redis-for-caching/</em></a></p><pre class="lj lk ll lm gt nw nc nx ny aw nz bi"><span id="c729" class="nk lv it nc b gy oa ob l oc od"><a class="ae mx" href="https://github.com/AseemWangoo/golang-programs" rel="noopener ugc nofollow" target="_blank"><br/>Source Code for Go</a></span><span id="1edb" class="nk lv it nc b gy oh ob l oc od"><a class="ae mx" href="https://github.com/AseemWangoo/expriments_with_react" rel="noopener ugc nofollow" target="_blank">Source Code for React</a></span></pre><p id="7187" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他文章:</p><div class="oy oz gp gr pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/unit-testing-in-react-7301989565f2"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">React中的单元测试</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">react中的单元测试</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ni pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/deploy-lambda-using-serverless-a44a66f3d603"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">使用无服务器部署lambda</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">使用无服务器部署lambda</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">使用serverlesslevelup.gitconnected.com部署lambda</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp ni pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/using-kafka-in-2022-f22602830e09"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">在2022年使用卡夫卡</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">在2022年使用卡夫卡</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">在2022levelup.gitconnected.com使用卡夫卡</p></div></div><div class="pk l"><div class="pr l pm pn po pk pp ni pb"/></div></div></a></div></div></div>    
</body>
</html>