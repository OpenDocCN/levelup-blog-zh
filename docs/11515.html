<html>
<head>
<title>Road to Go Pro — Special Edition: Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">专业版之路-特别版:仿制药</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/road-to-go-pro-special-edition-generics-88d6ac2b5b6c?source=collection_archive---------18-----------------------#2022-03-22">https://levelup.gitconnected.com/road-to-go-pro-special-edition-generics-88d6ac2b5b6c?source=collection_archive---------18-----------------------#2022-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5e13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">在我们开始之前，你可以在这个</em> <a class="ae kp" href="https://github.com/songx23/RoadToGoPro" rel="noopener ugc nofollow" target="_blank"> <em class="ko">资源库</em> </a> <em class="ko">中找到本教程使用的代码。你可以在这里</em>  <em class="ko">找到Road to Go Pro </em> <a class="ae kp" href="https://medium.com/@songx/road-to-go-pro-f9d1f8a51fad" rel="noopener"> <em class="ko">的全部内容。如果你错过了最后一个，你可以通过这个</em> </a><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/road-to-go-pro-async-part-3-locks-8bf60c476b12"> <em class="ko">链接</em> </a> <em class="ko">找到。</em></p><p id="842d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">欢迎来到Road to Go Pro特别版。我开始这个新的Go stories分支是因为Go 1.18终于发布了。这个版本带来了一些令人兴奋的新功能，我迫不及待地想与你分享。我将创建3个故事来回顾1.18中的主要特性，即泛型、模糊化和工作空间。让我们从泛型开始。</p><h1 id="4b84" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">无商标消费品</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/2b6d5e67f93d4520145bb17c218a6efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KemVjg8sJcfA_S1M"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@jiaweizhao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">赵家伟</a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="611d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi me translated">在Go于2012年发布后，开发者们只花了30分钟就请求将泛型作为一种语言特性包含进来。10年后，这一期待已久的功能终于推出。尽管这是最受欢迎的特性之一，但我并不希望Go能支持更多的通用代码。我们在没有它的情况下生存了10年，所以我们可以再这样做10年？开玩笑的。</p><p id="1fcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">泛型仍然很有价值，它解决了Go中的一个常见问题。在我的日常工作中，我编写了一个简单的函数来多次检查一个字符串片段是否包含一个特定的字符串。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">该函数检查字符串片段是否包含特定的字符串</figcaption></figure><p id="8c94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能是最容易编写的函数之一。由于函数参数中指定的类型，我们只能使用这个函数来检查字符串切片。如果我们需要检查整数切片，我们就不走运了。由于Go不支持泛型，我们必须编写另一个函数。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">该函数检查int切片是否包含特定的int</figcaption></figure><p id="169a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哎哟，这里有很多重复，这让“懒惰”的工程师很不舒服。这两个函数的函数体<strong class="js iu">完全</strong>相同。唯一的区别是函数参数的类型。想象一下，如果我们需要对floats或任何其他结构做同样的事情，我们将会写一堆“重复的”函数。没有人喜欢做那件事。</p><p id="cd02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">泛型可以帮助我们解决这个问题。它有助于从函数中去掉类型因素。我们只需要编写一个通用函数，它可以处理我们想要的任何类型。听起来很棒。现在，让我们看看Go中的泛型语法是什么样子的。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">通用包含函数</figcaption></figure><p id="3910" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">泛型函数体仍然和它的非泛型表亲完全一样。我们改变函数签名，使其通用。</p><p id="9402" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了正常的函数参数，通用函数需要额外的类型约束(可以有一个或多个)，这些约束用方括号<code class="fe mp mq mr ms b">[]</code>括起来。</p><h2 id="b004" class="mt kr it bd ks mu mv dn kw mw mx dp la kb my mz le kf na nb li kj nc nd lm ne bi translated">类型约束</h2><p id="7b1a" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">与函数参数类似，声明类型约束需要类型名和约束类型。有两种方法可以指定约束类型。</p><p id="dc46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi me translated">最简单的方法是内联指定它。由于这是一个类型约束，我们需要为通用函数指定所有可接受的类型，并用<code class="fe mp mq mr ms b">|</code>将它们连接起来。例如，如果我们想编写一个通用的<code class="fe mp mq mr ms b">contains</code>函数来检查<code class="fe mp mq mr ms b">int</code>和<code class="fe mp mq mr ms b">string</code>类型，我们可以将其类型约束声明为<code class="fe mp mq mr ms b">[TypeName int | string]</code>。一个约束中的类型数量可以从一个到多个不等。如果列表太长，最好使用另一种方式来获得更好的可读性。</p><p id="cd03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi me translated">另一种方法是将约束声明为一个<code class="fe mp mq mr ms b">interface{}</code>。如上面的示例代码所示，我们可以将内联约束声明移动到一个接口中。然后使用这个接口作为函数签名中的类型。它不仅可以使代码更容易阅读，还可以使类型约束可重用。</p><p id="e7e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以使用普通接口(用函数签名代替链式类型)作为约束类型。这意味着泛型函数接受任何实现该接口的结构。这里有一个例子:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">接口类型约束</figcaption></figure><p id="6346" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mp mq mr ms b">Magic</code>和<code class="fe mp mq mr ms b">CustomError</code>结构都实现了<code class="fe mp mq mr ms b">Stringer</code>接口。因此，它们都被<code class="fe mp mq mr ms b">GenericsToString</code>函数接受。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用接口约束调用通用函数</figcaption></figure><p id="f270" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行main函数后，我们可以看到程序正确地打印出了咒语和客户错误。“昂贵的石油”！哦，对不起，我的意思是“期待守护神”！</p><pre class="lp lq lr ls gt nk ms nl nm aw nn bi"><span id="b68f" class="mt kr it ms b gy no np l nq nr">This is a Protection Spell. Repeat after me: Expecto Patronum<br/>This is a meme. Repeat after me: Expensive Petroleum<br/>Error: status code 501, error message Panic! Your code is on fire!</span></pre><p id="04f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望以上解释了如何声明泛型函数以及如何使用它们。当我在写示例函数的时候，一个问题突然出现在我的脑海里。泛型功能比它的非泛型表亲慢吗？当上帝打开一扇窗时，他会关上一扇门。泛型是好的，但它可能会带来性能损失。</p><h2 id="04f9" class="mt kr it bd ks mu mv dn kw mw mx dp la kb my mz le kf na nb li kj nc nd lm ne bi translated">表演</h2><p id="43d0" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">在这个<a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/road-to-go-pro-async-part-2-channels-12645a160f73">之前的故事</a>中，我们学习了Go基准测试工具。在这里，我们也可以用它来测试泛型函数和非泛型函数的性能。我们将使用<code class="fe mp mq mr ms b">contains</code>函数作为我们的目标。下面的测试函数用字符串类型对<code class="fe mp mq mr ms b">contains</code>函数进行了基准测试。为了公平竞争，我们给他们同样的参数。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">通用和非通用函数的基准函数</figcaption></figure><p id="84b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是在M1 Macbook上运行的结果。</p><pre class="lp lq lr ls gt nk ms nl nm aw nn bi"><span id="5b13" class="mt kr it ms b gy no np l nq nr"># Non-generic function<br/>BenchmarkStringSliceContains-10     145600888          8.138 ns/op</span><span id="5d9d" class="mt kr it ms b gy ns np l nq nr"># Generic function<br/>BenchmarkSliceContains_String-10     145776253          8.228 ns/op</span></pre><p id="75aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我很高兴看到这两个函数的性能结果非常相似。我想当上帝打开一扇窗时，他也能打开一扇门。泛型在不牺牲性能的情况下增加了泛型代码支持。向Go开发团队致敬。</p><p id="94e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你对这个新功能有什么看法？你喜欢还是不喜欢？请在下面留下评论，我很想听听你的看法。</p><h1 id="14a9" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">下一步是什么？</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nt"><img src="../Images/3228c2c2651ca66f20e5c36b04c737b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AR-eGJLs0OzXr-xg"/></div></div></figure><p id="1852" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个故事中，我们探索了Go 1.18闪亮的新泛型特性。我敢肯定，相当多的开发人员都在庆祝这一功能终于来了。对于下一个特别版的故事，我们将检查另一个新功能:起毛。这是添加到已经很棒的测试工具包中的一个方便的测试工具。敬请期待！</p><p id="c479" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果你遇到任何问题或者需要帮助，请在下面留下你的评论。随时欢迎反馈。感谢您的阅读！</strong></p><p id="adf9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想支持我，你可以通过这个推荐链接成为一个中等会员。谢谢你。</p><div class="nu nv gp gr nw nx"><a href="https://songx.medium.com/membership" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">用我的推荐链接加入Medium宋x。</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">songx.medium.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ly nx"/></div></div></a></div></div></div>    
</body>
</html>