<html>
<head>
<title>JavaScript Design Patterns : Singleton Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式:单例模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-design-patterns-singleton-pattern-7ada98be9a10?source=collection_archive---------6-----------------------#2022-10-23">https://levelup.gitconnected.com/javascript-design-patterns-singleton-pattern-7ada98be9a10?source=collection_archive---------6-----------------------#2022-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f2892c534612c1303efe644bcc83691d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPs_SnyrypZ0IkWXX3Ulvg.png"/></div></div></figure><p id="1559" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Singleton模式:将类实例化的次数限制为一次，一个类只有一个实例，并提供一个全局访问点来访问它。</p><p id="0773" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单体模式是一种创造性的设计模式。对于全局只需要一个对象的场景，比如线程池、全局缓存、窗口对象等。</p><h2 id="d47a" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">特征</h2><ol class=""><li id="5548" class="ls lt it kd b ke lu ki lv km lw kq lx ku ly ky lz ma mb mc bi translated">类只有一个实例</li><li id="6a5e" class="ls lt it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">该实例是全局可访问的</li><li id="cb1d" class="ls lt it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">自我实例化(主动实例化)</li><li id="7d86" class="ls lt it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">延迟初始化，即延迟执行(不同于静态类/对象)</li></ol><p id="74a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JavaScript是一种非正式的面向对象语言，没有类定义。单例模式需要一个“唯一的”和“全局可访问的”对象，类似于JavaScript中的一个全局对象，只是为了满足单例模式的两个特征:“唯一的”和“全局可访问的”。虽然它不是正式的单例模式，但不可否认的是，它确实具有类单例模式的特征。</p><p id="f3f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">//全局对象</p><p id="b8fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mi mj mk ml b">var globaObj = {}<em class="mm">;</em></code></p><p id="7efa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用全局变量有以下问题:</p><ol class=""><li id="7f6a" class="ls lt it kd b ke kf ki kj km mn kq mo ku mp ky lz ma mb mc bi translated">命名空间污染(变量名冲突)</li><li id="2318" class="ls lt it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">维护时不便于控制(容易意外覆盖)</li></ol><p id="ace2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">全局变量问题的折衷解决方案:</p><ol class=""><li id="d572" class="ls lt it kd b ke kf ki kj km mn kq mo ku mp ky lz ma mb mc bi translated">使用名称空间</li><li id="8e5a" class="ls lt it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">闭包封装私有变量(使用函数作用域)</li><li id="3b5b" class="ls lt it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">ES6 <code class="fe mi mj mk ml b">const</code> / <code class="fe mi mj mk ml b">symbol</code></li></ol><p id="09b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然全局变量可以实现singleton，但是由于其自身的问题，在实际项目中不建议将其作为singleton模式使用，尤其是在中大型项目的应用中。维护全局变量应该被认为是一种成本。</p><h2 id="77d9" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">实现</h2><p id="4115" class="pw-post-body-paragraph kb kc it kd b ke lu kg kh ki lv kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">使用一个变量来存储类实例对象(最初的值是<code class="fe mi mj mk ml b">null</code> / <code class="fe mi mj mk ml b">undefined </code>)。实例化一个类时，判断该类实例对象是否存在，如果存在则返回实例。如果不存在，则创建并返回类实例。多次调用类生成实例方法会返回同一个实例对象。</p><p id="728f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单例模式的“简单版本”:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c8da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码定义了一个<code class="fe mi mj mk ml b">Singleton </code>函数，它是JavaScript中的“一等公民”，可以为它定义属性方法。因此，我们可以在函数<code class="fe mi mj mk ml b">Singleton </code>中定义一个<code class="fe mi mj mk ml b">getInstance()</code>方法来管理singleton，并创建一个返回的类实例对象，而不是通过传统的new运算符创建一个类实例对象。</p><p id="a212" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mi mj mk ml b">this.instance</code>存储创建的实例对象。每次接收到创建的实例对象时，判断<code class="fe mi mj mk ml b">this.instance</code>中是否有实例对象，并返回。最终只会返回同一个Singleton类实例对象。</p><p id="dc14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">存在的问题:</p><ol class=""><li id="24af" class="ls lt it kd b ke kf ki kj km mn kq mo ku mp ky lz ma mb mc bi translated">用new实例化一个类不够“透明”，需要约束类实例化的调用方法:<code class="fe mi mj mk ml b">Singleton.getInstance(…)</code></li><li id="cecf" class="ls lt it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">管理单例的操作与对象创建和功能代码的操作相耦合，这不符合“单一责任原则”</li></ol><p id="05ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">“透明”单例模式:</strong></p><p id="e605" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实现singleton模式的“透明版”，意图是解决:统一使用new运算符得到singleton对象，而不是<code class="fe mi mj mk ml b">Singleton.getInstance(…)</code></p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b5c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“透明版”singleton模式解决了“透明性”不足的问题，我们可以使用<code class="fe mi mj mk ml b">new </code>操作符来创建实例对象。</p><h2 id="7dca" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">“代理版本”单例模式</h2><p id="9a53" class="pw-post-body-paragraph kb kc it kd b ke lu kg kh ki lv kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">通过“代理”的形式，意图是解决:将管理单体操作从对象创建操作中拆分出来，实现更小粒度的划分，符合“单一责任原则”</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="6abf" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">懒惰单例模式</h2><p id="0e1f" class="pw-post-body-paragraph kb kc it kd b ke lu kg kh ki lv kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">惰性单例，意在解决:只在需要的时候创建类实例对象。前端开发者对懒加载性能优化并不陌生。懒惰的单例也解决了“按需加载”的问题。</p><blockquote class="mz na nb"><p id="f1a9" class="kb kc mm kd b ke kf kg kh ki kj kk kl nc kn ko kp nd kr ks kt ne kv kw kx ky im bi translated">要求:页面弹窗提示，多次调用，只有一个弹窗对象，但显示的信息内容不同。</p></blockquote><p id="fc71" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要开发这样一个全局弹出对象，我们可以应用单例模式。为了提高它的性能，我们可以让它在需要调用时生成实例并创建DOM节点。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="224a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码中的演示是一个通用的“懒惰单例”创建方法。如果还需要<code class="fe mi mj mk ml b">createLoginLayer</code>登录框、<code class="fe mi mj mk ml b">createFrame </code>框架框，可以调用<code class="fe mi mj mk ml b">getSingleton(…) </code>方法生成相应的实例对象。</p><h2 id="8fca" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">适用场景</h2><p id="8da5" class="pw-post-body-paragraph kb kc it kd b ke lu kg kh ki lv kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">singleton模式的特点，旨在解决:维护一个全局实例对象。</p><ol class=""><li id="1c07" class="ls lt it kd b ke kf ki kj km mn kq mo ku mp ky lz ma mb mc bi translated">对第三方库的引用(多个引用将只使用一个库引用，如jQuery)</li><li id="867e" class="ls lt it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">弹出窗口(登录框、信息推广框)</li><li id="9eda" class="ls lt it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">购物车(每个用户一辆购物车)</li><li id="c5bf" class="ls lt it kd b ke md ki me km mf kq mg ku mh ky lz ma mb mc bi translated">全局状态管理存储(Vuex / Redux)</li></ol><p id="112a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当项目中引入第三方库，库文件重复加载时，只会全局实例化一个库对象，如jQuery、lodash、moment……其实它们的实现理念也是一种singleton模式的应用:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="9db3" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">优点和缺点</h2><p id="7c85" class="pw-post-body-paragraph kb kc it kd b ke lu kg kh ki lv kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated"><strong class="kd iu">优点</strong>:适用于单个对象，只生成一个对象实例，避免频繁创建和销毁实例，减少内存占用。</p><p id="9af8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缺点</strong>:不适合动态扩展对象，或者需要创建多个相似对象的场景。</p><p id="8512" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">提示:在多线程编程语言中，单例模式涉及到同步锁的问题。由于JavaScript是单线程编程语言，所以这个问题暂时可以忽略。</p></div></div>    
</body>
</html>