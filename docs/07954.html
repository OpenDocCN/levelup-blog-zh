<html>
<head>
<title>Manipulating DataFrames with Python | Part 2 (Pivoting, Stacking and Melting)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python处理数据帧|第2部分(旋转、堆叠和融合)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/manipulating-dataframes-with-python-part-2-pivoting-stacking-and-melting-99e4aa7f5507?source=collection_archive---------20-----------------------#2021-03-23">https://levelup.gitconnected.com/manipulating-dataframes-with-python-part-2-pivoting-stacking-and-melting-99e4aa7f5507?source=collection_archive---------20-----------------------#2021-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2595b26c602e891d66da434db8d64c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BARzL1NTx-Cz6xG0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卢克·切瑟在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2fde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我上一篇文章的延续。在深入这些话题之前，你必须先阅读这篇文章。这是到它的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/manipulating-dataframes-with-python-part-1-slicing-filtering-and-indexing-486c6411ba8">链接</a>。</p><p id="c17f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在使用Python操作数据帧的第2部分中，我们将介绍以下一些技术:</p><ol class=""><li id="96a2" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="#82f1" rel="noopener ugc nofollow">旋转数据框</a></li><li id="bc91" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#b7d8" rel="noopener ugc nofollow">堆叠和拆分数据帧</a></li><li id="ff47" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#2d08" rel="noopener ugc nofollow">熔化数据帧</a></li></ol><p id="89f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lp">这些帖子将成为如何开始使用DataFrame的指南。这些主题本身就值得为它们中的每一个写一篇文章。不过，我会给出对它们的基本理解，如果你想更深入地挖掘，我会附上关于这些主题的深入教程的链接。</em></p><h1 id="82f1" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">旋转数据框架</h1><p id="0073" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">当您希望根据某些列排列索引的数据集，或者分离特定列的值，或者两者兼有时，就需要这样做。</p><p id="292b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在给出的例子的基础上更好地理解这一点:</p><p id="5826" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个如下的试算表</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/ef07f12e2f7b67b02c229e838ca7dd68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1aFlfwmmm4DEgp43gmMVSQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">初始表</figcaption></figure><p id="fc95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">pivot方法基于三个参数。</p><p id="005c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">索引—设置新数据帧的索引。</p><p id="835a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列-根据列值划分行。</p><p id="d688" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值-告知用于填充值的列。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/762c3405f676588531859f6a571dde37.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*Bun_1zd0NGiTRuQPnzpsyA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">旋转工作台1</figcaption></figure><pre class="mu mv mw mx gt mz na nb nc aw nd bi"><span id="d966" class="ne lr iq na b gy nf ng l nh ni">trials.pivot(index=’treatment’, columns=’gender’, values=’response’)</span></pre><p id="0cf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该语句产生如左图所示的数据帧。</p><p id="b3b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不设置values列，形成的表将如下所示。它将根据传入的列划分所有列中的值。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/e3accba14786f2f022cdb049d59a12dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*Q66kx1Q2z0ynRFs2wP-djQ.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">旋转工作台2</figcaption></figure><pre class="mu mv mw mx gt mz na nb nc aw nd bi"><span id="ebd8" class="ne lr iq na b gy nf ng l nh ni">trials.pivot(index=’treatment’, columns=’gender’)</span></pre><blockquote class="nk nl nm"><p id="6e1a" class="kd ke lp kf b kg kh ki kj kk kl km kn nn kp kq kr no kt ku kv np kx ky kz la ij bi translated">要编制索引的列不应包含重复条目。</p></blockquote><h1 id="b7d8" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">堆叠和取消堆叠数据帧</h1><p id="e073" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">堆叠是基于一列或多列对数据帧进行分组的一种形式。拆分与堆叠相反，前者得到的数据帧与堆叠前相同。</p><p id="3846" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">堆叠过程如下:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9d8a7eb491b3a92dcedd1ca366c675c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*9BZW5f5EZ_SzBAncPJjGwg.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">堆叠数据帧</figcaption></figure><pre class="mu mv mw mx gt mz na nb nc aw nd bi"><span id="8ff7" class="ne lr iq na b gy nf ng l nh ni">trials.stack(['treatment', 'gender'])</span></pre><p id="c5bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将给定的列标签设置为数据帧的索引。</p><p id="e8d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以传递“dropna=True”来删除缺少的值。</p><p id="dcf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了拆分数据帧，我们提供列名作为函数的级别参数。它定义了要拆分的列。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/842971115ed8e97402cd4bdd2bf6a626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*lePmeLa2jYuMXOLoNAlLjA.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">非堆叠数据帧</figcaption></figure><pre class="mu mv mw mx gt mz na nb nc aw nd bi"><span id="2818" class="ne lr iq na b gy nf ng l nh ni">trials.unstack(level = gender)</span></pre><p id="f1a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以将数字传递到定义要拆分的列的级别。-1表示最后一个堆叠的列，0表示第一个堆叠的列，依此类推。<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.unstack.html#pandas.DataFrame.unstack" rel="noopener ugc nofollow" target="_blank">这里指的是</a></p><h1 id="2d08" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">熔化数据帧</h1><p id="6ca5" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">融化熊猫数据帧将表格从宽格式变成长格式，只保留两列。一个是变量名，另一个是值。</p><p id="e921" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们以下面的数据框架“new_trails”作为参考</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/581f55b2f51c7be785c90ff7aca4df07.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*bhf-9EHakLsA5aY554KHvQ.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">熔化数据帧初始表</figcaption></figure><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/31fc9d1f8044045b715cfa1cbee11304.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*XC3iTFpTe3IObOJT6PAXgg.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">熔化的数据帧1</figcaption></figure><pre class="mu mv mw mx gt mz na nb nc aw nd bi"><span id="2d05" class="ne lr iq na b gy nf ng l nh ni">import pandas as pd<br/>pd.melt(new_trails)</span></pre><p id="26b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将把所有列作为变量水平堆叠，并把它们的值放在一起。我们还可以指定id变量和其他参数来修改熔化行为。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1c6a8529715c3a118dd72d9d976fe395.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*CmaOqP4BumlaP1xCYRf1JQ.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">熔化的数据帧2</figcaption></figure><pre class="mu mv mw mx gt mz na nb nc aw nd bi"><span id="70cc" class="ne lr iq na b gy nf ng l nh ni">pd.melt(new_trials, id_vars=['treatment'])</span></pre><p id="4bd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在id_vars中指定列会将它们设置为标识符变量。同样，您也可以设置其他参数来熔化数据帧。这在<a class="ae kc" href="https://www.geeksforgeeks.org/python-pandas-melt/#:~:text=melt()%20function%20is%20useful,identifier%20columns%2C%20variable%20and%20value." rel="noopener ugc nofollow" target="_blank">这篇文章</a>中解释得很好。</p><p id="bdaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个故事的下一部分将很快发表，链接将添加到本文中。快乐学习到那时。保持联系:)</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="b85a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lp">我们连线上</em><a class="ae kc" href="https://www.linkedin.com/in/ankita-prasad-5a0156137/" rel="noopener ugc nofollow" target="_blank"><em class="lp">LinkedIn</em></a><em class="lp">。你也可以通过ankita2108prasad@gmail.com联系我。</em></p></div></div>    
</body>
</html>