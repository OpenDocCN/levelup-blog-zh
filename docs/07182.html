<html>
<head>
<title>Counting Stars</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数星星</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/counting-stars-86a168c9d14d?source=collection_archive---------12-----------------------#2021-01-29">https://levelup.gitconnected.com/counting-stars-86a168c9d14d?source=collection_archive---------12-----------------------#2021-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fae7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用大O分析编写高效代码</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/01d3fa30abb5f91a4aad3ce1157bc16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WE9W3rRNZXzCEJsYKWkCA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在外层空间，有数十亿颗恒星</figcaption></figure><h2 id="3df6" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">什么是大O分析？</h2><p id="c385" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">程序员的主要任务是编写代码，执行一系列旨在产生某种期望输出的动作。随着每一段新代码的编写，程序员可能必须评估通过代码解决特定问题的不同方法。</p><p id="3a35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果有许多不同的方法来编写代码以产生期望的结果，我们如何客观地确定一个代码块是否比另一个更好呢？这就是<strong class="jp ir">大O </strong>分析发挥作用的地方。</p><blockquote class="lz ma mb"><p id="a2ce" class="jn jo mc jp b jq jr js jt ju jv jw jx md jz ka kb me kd ke kf mf kh ki kj kk ij bi translated">大O分析是通过查看代码执行的<strong class="jp ir">效率</strong>来客观地比较产生相同结果的不同代码块。正因为如此，大O分析允许程序员识别和缓解瓶颈，并且<strong class="jp ir">编写更高效的代码</strong>，即<strong class="jp ir">更快</strong>并且<strong class="jp ir">消耗更少的资源</strong>。</p></blockquote><p id="bffa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大O关心的是通过看两个因素来描述代码<strong class="jp ir">效率</strong>:时间<strong class="jp ir">和空间<strong class="jp ir">空间</strong>。时间是指特定代码块执行所花费的持续时间。空间是指块使用的内存量。在这篇文章中，我将关注时间。</strong></p><p id="6f31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有的计算机都是不同的，一些比另一些更快或者有更大的内存。正因为如此，在对代码进行分类时，大O分析并不关心具体的单位(比如毫秒或字节)。让我们能够使用Big O在不同环境中进行比较的是，它关注的是当事情扩展时会发生什么，或者当遇到大量输入时块的表现如何。大O分析迫使程序员考虑最坏的情况，并考虑诸如…</p><blockquote class="lz ma mb"><p id="5720" class="jn jo mc jp b jq jr js jt ju jv jw jx md jz ka kb me kd ke kf mf kh ki kj kk ij bi translated">“当这个函数接收到一百万个输入时会发生什么？十亿怎么样？”😖</p></blockquote><p id="0349" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当考虑与Big O相关的代码时，我们希望<strong class="jp ir">在情况最糟糕的时候优化代码</strong>。这样，我们可以确保代码在正常情况下运行良好。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="df38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，现在我们知道大O是关于代码效率的分类，它是如何工作的呢？让我们考虑下面简化的<strong class="jp ir">大O符号</strong>图。这三行表示三个不同代码块的时间效率。我们可以把代码块想象成算法。在x轴上跟踪算法的输入数量，在y轴上跟踪完成算法的持续时间。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/35c499fcf50efcf2498501abb3ce57b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsc7gjEmWXjUbqPTEJUehw.png"/></div></div></figure><p id="1705" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到快速算法在绿色区域执行。那些表现在橙色波段的人需要更长的时间，最后，那些表现在红色波段的人需要最多的时间。请注意，随着输入数量的增加，红色的算法线实际上是向上陡峭弯曲的，标记为<strong class="jp ir"> O(n ) </strong>。如果输入数量大幅增加，像这样执行的算法可能会特别成问题，这也是这条线出现红色的原因。</p><p id="a5ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这三条线标有<strong class="jp ir"> O(1) </strong>、<strong class="jp ir"> O(n) </strong>和<strong class="jp ir"> O(n ) </strong>。每一个都是线所代表的算法的大O符号。</p><p id="912c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> O(1) </strong> <br/>以这种方式执行的算法被称为具有<strong class="jp ir">恒定复杂度</strong>，因为算法完成所需的时间与输入的大小无关。分类为<strong class="jp ir"> O(1) </strong>的算法是最快的，因为不管向算法提供多少输入，它仍将在恒定的时间内运行。</p><p id="e03b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> O(n) <br/> </strong>以这种方式执行的算法被称为具有<strong class="jp ir">线性复杂度</strong>，因为算法完成所需的时间与算法的输入数量(n)直接相关。分类为<strong class="jp ir"> O(n) </strong>的算法随着输入数量的增加而花费更长的时间，但不是以指数方式。</p><p id="d62f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> O(n ) <br/> </strong>以这种方式执行的算法被称为具有<strong class="jp ir">平方复杂度</strong>，因为算法完成的时间以n的速度增加。</p><p id="a0a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了这些，还有更多大的O分类，但是为了简单起见，我将把重点放在具有O(1)、O(n)和O(n)符号的算法例子上。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="9687" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为大O关心的是<em class="mc">算法在规模上如何执行，宇宙中的</em> <strong class="jp ir">恒星</strong>是一个合适的<strong class="jp ir">模型</strong>进行实验。毕竟，宇宙中有数十亿颗恒星，如果我们开始研究许多许多恒星，这听起来像是一个潜在的缩放问题。不知道这么多明星怎么把<strong class="jp ir">命名为</strong>？</p><p id="eabc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过一些快速的研究，<a class="ae mo" href="https://www.space.com/57-stars-formation-classification-and-constellations.html" rel="noopener ugc nofollow" target="_blank">Space.com</a>告诉我们恒星是以下列方式命名的:</p><blockquote class="lz ma mb"><p id="3200" class="jn jo mc jp b jq jr js jt ju jv jw jx md jz ka kb me kd ke kf mf kh ki kj kk ij bi translated">由于宇宙中有如此多的恒星，大多数恒星的名字都是由一个代表恒星类型的缩写或一个列出恒星信息的目录组成，后跟一组符号。例如，PSR j 1302–6350是一颗脉冲星，因此是PSR。J揭示了被称为J2000的坐标系统正在被使用，而1302和6350是类似于地球上使用的纬度和经度代码的坐标。</p></blockquote><p id="bb9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个逻辑，下面是一个简单的函数，它返回一个随机的星名。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">star name生成器</figcaption></figure><p id="b67c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此函数返回的名称示例可能是:psrj 18–93、psrj 26–74或psrj 88–13等，其中数字是随机的。另外，在上面描述的逻辑中，数字是4位数，但是在starNameGenerator函数中，我把它们变成了2位数,这样这个函数就有更好的机会产生一个重复的名称(稍后会详细介绍)。</p><p id="54f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们做一些明星，也许从大量开始，但我们不要疯狂。请给我100颗星星。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">造星</figcaption></figure><p id="9c5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行后，我的随机星名数组如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7b16922a9cc12b47226508a2a819dbc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*1zIzp4JTZJQP_5Eo2bEa4g.png"/></div></figure><p id="3770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，现在我们有办法生成一些数据(如果我们愿意，这可能会增长到数十亿颗恒星)。接下来，我们可以考虑针对不同的数组大小(输入数)编写函数，并根据大o来分析它们。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="1a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们考虑<strong class="jp ir"> O(1)常数复杂性。</strong>记住，<strong class="jp ir"> O(1) </strong>的意思是，无论输入多少次，算法每次都要在大致相同的时间内返回一个结果。</p><p id="917b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比方说，我们需要一个函数来返回传入的星星数组的最后一个元素。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fe35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">returnLast函数为上面的100个列表正确地返回了<strong class="jp ir">psrj 75–12</strong>。</p><p id="1e3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们希望增加数字输入，以查看该函数对于Big O的执行情况。我添加了开始和结束时间戳，以确定该函数执行以下长度递增的随机星形数组(达到100万)所需的毫秒数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4e3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为每个输入数组长度记录的迭代时间如下…</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/4f43485ff78fd86ed749a6df7f242113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pDzCgmU3ghe9KuYwyv9OQ.png"/></div></div></figure><p id="e2d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来非常非常快，不到1毫秒，<strong class="jp ir"> returnLast(array) </strong>函数就返回一个结果，不管传入的数组有多大，即使是100万颗恒星。当迭代时间相对于输入量作图时，我们得到一条平坦的线。这个功能确实是<strong class="jp ir"> O(1) </strong>，绿色快速。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/052f0eac459d6f297eb046ddfda7d4ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUN7-YI73B7gWDaM_ekxFQ.png"/></div></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="e870" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> O(n) </strong></p><p id="c187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们考虑<strong class="jp ir"> O(n)线性复杂度。</strong>记住，一个线性复杂算法完成的时间与算法的输入数(n)直接相关。</p><p id="6c76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们无法控制<strong class="jp ir"> starNameGenerator </strong>()函数，比方说这个名字列表可能来自API调用或我们无法控制的其他地方。此外，假设我们不喜欢函数在名称psrj 18<strong class="jp ir">–</strong>93中插入的破折号(-)，例如，我们希望在将它们保存到数据库之前删除它。所以我们想出了一个<strong class="jp ir"> removeDashesFrom(数组)</strong>函数，在保存之前运行这些名字。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看一下这个函数，我们可以看到我们正在遍历星星数组<strong class="jp ir">一次。</strong>所以，如果将n定义为传递的数组长度，那么循环将迭代n次。<strong class="jp ir"> </strong>替换所有破折号的迭代次数<strong class="jp ir">与输入数组</strong>的长度直接相关。让我们再次绘制时间图，从1到1，000，000表示数组的长度。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/cfc4109de841f43e5dd66161bdbbed0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9f4WytsKZJwNJYU9C1q3w.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/42335965dacd4d17a352fccf3be0044a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnPlGQCi0CI_wJDZBxPB0A.png"/></div></div></figure><p id="2bcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这条线绝对看起来像<strong class="jp ir"> O(n) </strong>的形状，这个函数在黄色里。在一百万次输入的情况下，这个函数只需要半秒钟。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="a959" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们考虑一下<strong class="jp ir"> O(n)二次复杂度。</strong>记住，如果n被定义为输入数，二次复数算法完成的时间以n的速度增加。</p><p id="9089" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们发现<strong class="jp ir"> starNameGenerator </strong>函数可能会返回重复的名字，我们需要一个函数从我们的星名数组中删除重复的名字。这是一个函数，它将生成去掉重复项的星星数组。这不是最有效的功能，也许是最差的，但它能产生预期的结果。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="08c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经<strong class="jp ir">故意</strong>把这个函数写得尽可能<strong class="jp ir">低效</strong><strong class="jp ir">。</strong>该函数的逻辑构建一个唯一的星名数组，通过对照每个其他星名检查数组中的每个星名来返回<em class="mc">，除了它当前正在检查的星名之外</em> <strong class="jp ir"> <em class="mc">通过数组循环的每次迭代</em> </strong> <em class="mc">。</em>如果没有找到重复项，它将把星名称推入返回数组。更糟糕的是，如果发现了一个重复项，它会被记录下来，但是循环并没有停止寻找更多的重复项，而是在已经找到一个重复项之后继续检查数组中的后续项。</p><p id="2ec2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数被归类为<strong class="jp ir"> O(n ) </strong>是因为由于嵌套循环的原因，它将遍历长度为n，n次的输入数组。这使得迭代次数为n * n，或者n，如果n是输入的次数。</p><p id="7b52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是为这个低效函数记录的时间。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/22301981be9b88f75c1ee7fb9ca790be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xlfVosRun_jodIMn44bU8g.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/f5094c483b28e5d18f16335f22560c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5tLLIrE-uqoWeUq91I2qg.png"/></div></div></figure><p id="755f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这条线看起来类似于上图中的<strong class="jp ir"> O(n ) </strong>线，我们可以看到曲率向上，告诉我们输入增加越多，时间以n的加速步伐增加。</p><p id="702e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，如果数组长度达到100万，函数完成的时间几乎需要1000万毫秒，或者说<strong class="jp ir">154分钟</strong>！事实上，这个函数是一个潜在的<strong class="jp ir">瓶颈</strong>，是重构的候选对象。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="b396" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，如何提高该函数的性能呢？我们知道问题在于<strong class="jp ir">嵌套循环</strong>，其中迭代<strong class="jp ir">依赖于输入数组</strong>的长度。</p><p id="3228" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们不使用数组来跟踪返回的元素，而是使用一个名为arrayMap的对象，会怎么样呢？考虑这个版本:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1151" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们只遍历输入数组一次，arrayMap对象用它的每个键的星名称填充，每个键的值是该项在输入数组中出现的所有索引的数组。如果名称在数组中出现多次，则值数组会随着每次重复而增长。</p><p id="a5a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，假设我们的星形输入数组如下所示(注意重复的星形，<strong class="jp ir">psrj 33–50):</strong></p><pre class="km kn ko kp gt my mz na nb aw nc bi"><span id="bde8" class="lb lc iq mz b gy nd ne l nf ng">['PSRJ73–98', '<strong class="mz ir">PSRJ33–50</strong>', 'PSRJ64–81', '<strong class="mz ir">PSRJ33–50</strong>', 'PSRJ21–13']</span></pre><p id="90be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这是输入数组，那么在removeDuplicatesFast(array)函数中，arrayMap构建如下:</p><pre class="km kn ko kp gt my mz na nb aw nc bi"><span id="8e45" class="lb lc iq mz b gy nd ne l nf ng">{<br/> 'PSRJ73–98': [ 0 ],<br/> 'PSRJ33–50': [ 1, 3 ],<br/> 'PSRJ64–81': [ 2 ],<br/> 'PSRJ21–13': [ 4 ]<br/>}</span></pre><p id="188f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">psrj 33–50键的值为[1，3]。这是因为该值在输入数组的索引1和索引3处重复。</p><p id="4731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方便的是，现在我们已经有了填充的arrayMap对象，我们可以使用<strong class="jp ir"> Object.keys(arrayMap) </strong>返回给定对象自己的可枚举属性<strong class="jp ir"> names </strong>的数组，按照普通循环的顺序进行迭代。该函数现在移除没有嵌套循环的重复<strong class="jp ir">。</strong></p><p id="339a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是<strong class="jp ir">removeDuplicatesFast(array)</strong>函数记录的时间:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/6ade3caae0afdd50e5b0703e9c740745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8eSeD4t1xAEkeTkHwoWO9w.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/25aedf73fdb5925c4bfbcf0531843d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2I1vrk4Dt82avdJwm9NyhQ.png"/></div></div></figure><p id="ad3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，removeDuplicatesFast(array)函数的执行速度为<strong class="jp ir"> O(n)，</strong>，从一个包含100万颗恒星的数组中删除重复项大约需要半秒钟，比上一个函数执行的154分钟要好得多！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="7dc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用大O分析，我们可以识别代码瓶颈或性能不佳的代码，重构有问题的算法并生成健壮的代码。</p><p id="624d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博文的代码可以在:<a class="ae mo" href="https://github.com/FergusDevelopmentLLC/countingStars" rel="noopener ugc nofollow" target="_blank">https://github.com/FergusDevelopmentLLC/countingStars</a>找到</p><p id="99ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考文献:</strong> <br/> <a class="ae mo" href="https://www.youtube.com/watch?v=HfIH3czXc-8" rel="noopener ugc nofollow" target="_blank">大O符号完全指南&amp;算法的复杂性分析</a> <br/> <a class="ae mo" href="https://medium.com/analytics-vidhya/big-o-notation-time-complexity-in-javascript-f97f356de2c4" rel="noopener">大O符号Javascript中的时间复杂性</a> <br/> <a class="ae mo" href="https://www.space.com/57-stars-formation-classification-and-constellations.html" rel="noopener ugc nofollow" target="_blank">恒星事实:恒星名称和恒星演化的基础知识</a></p></div></div>    
</body>
</html>