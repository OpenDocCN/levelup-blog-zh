<html>
<head>
<title>Recursion to Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划的递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/recursion-to-dynamic-programming-6f7125e07436?source=collection_archive---------4-----------------------#2020-09-24">https://levelup.gitconnected.com/recursion-to-dynamic-programming-6f7125e07436?source=collection_archive---------4-----------------------#2020-09-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a4d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解决任何动态规划问题的逐步方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/38fb2d2adb9e2eac0b7c5d16274a5f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*miNYDYa4_BtgiMTu"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@veeterzy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> veeterzy </a>拍摄的照片</figcaption></figure><p id="f29e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多文章解释了动态编程的概念以及使用自顶向下和自底向上的动态编程方法解决问题的方法。如果你没有读过，我建议你读一读我的文章，它涵盖了<a class="ae ky" href="https://medium.com/swlh/dynamic-programming-made-easy-32b2ec0d018e" rel="noopener">动态编程</a>的基础知识。</p><p id="9e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有多少人知道递归是动态编程解决方案的父。除非他/她知道如何解决递归问题，否则他/她无法解决动态编程解决方案。</p><p id="93cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">找到递归关系就是导出动态规划解决方案。在本文中，我们将从<a class="ae ky" href="https://leetcode.com/problems/longest-common-subsequence/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>中选取一个名为<strong class="lb iu">最长公共子序列</strong>的示例问题，然后通过递归、自顶向下的方法(记忆化)以及自底向上的方法来解决它。</p><h1 id="1c5e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题陈述:</h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="3ec0" class="ms lw it mo b gy mt mu l mv mw"><strong class="mo iu">Given two strings str</strong><strong class="mo iu">1</strong><strong class="mo iu"> and </strong><strong class="mo iu">str2</strong><strong class="mo iu">, return the length of their longest common subsequence.</strong></span><span id="adfb" class="ms lw it mo b gy mx mu l mv mw"><strong class="mo iu">Input:</strong> str1 = "abcde", str2 = "ace" <br/><strong class="mo iu">Output:</strong> 3  <br/><strong class="mo iu">Explanation:</strong> The longest common subsequence is "ace" and its length is 3.</span></pre><h1 id="9774" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">递归解决方案:</h1><p id="ef79" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">递归问题有两个重要元素:</p><ol class=""><li id="973e" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">寻找基本案例</li><li id="2c54" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">寻找递归关系</li></ol><p id="e2d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最长公共子序列问题中，基本情况或最小可能解是当任意一个字符串为空时。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2bc0" class="ms lw it mo b gy mt mu l mv mw"><strong class="mo iu">if</strong> <!-- -->m <strong class="mo iu">==</strong> <!-- -->0<!-- --> <strong class="mo iu">or</strong> <!-- -->n <strong class="mo iu">==</strong> <!-- -->0:</span><span id="b5fb" class="ms lw it mo b gy mx mu l mv mw"><strong class="mo iu">return</strong> <!-- -->0;</span></pre><p id="6db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归关系很容易找到。如果m和n的值相等，那么我们加1，找到字符串剩余部分的最长公共子序列。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2ac6" class="ms lw it mo b gy mt mu l mv mw">if<!-- --> str1<!-- -->[m-1] ==<!-- --> str2<!-- -->[n-1]:</span><span id="803c" class="ms lw it mo b gy mx mu l mv mw">return<!-- --> <!-- -->1<!-- --> <!-- -->+<!-- --> <!-- -->lcs(str1, str2, m-1, n-1);</span><span id="bb47" class="ms lw it mo b gy mx mu l mv mw">else:</span><span id="1c02" class="ms lw it mo b gy mx mu l mv mw">return<!-- --> <!-- -->max(lcs(str1, str2, m, n-1), lcs(str1, str2, m-1, n))</span></pre><p id="3640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果它们不相等，我们必须调用如上所示的两个函数调用，并将最大值作为结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="90df" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">自上而下的方法(记忆化):</h1><p id="33b4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果我们为递归解画一个递归树，我们会发现许多函数调用被重复调用。这是被称为重叠子问题的动态规划问题的特性之一。</p><p id="7cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个重叠的问题通过内存化来解决，在内存化中，一旦函数调用的结果被处理，我们就将结果存储在内存中，当用相同的输入再次调用函数时，我们返回缓存的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的解决方案中，结果存储在一个名为l的二维表中。</p><h1 id="e395" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">自下而上的方法:</h1><p id="501d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在自底向上方法中，我们使用迭代方法从底部解决动态规划问题。我们从初始化表中的基本案例开始，并使用先前计算的结果向前推进。</p><p id="fd31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个字符串长度为行和列的二维表</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6a29" class="ms lw it mo b gy mt mu l mv mw">L <strong class="mo iu">=</strong> <!-- -->[[None]<strong class="mo iu">*</strong>(n<strong class="mo iu">+</strong>1) <strong class="mo iu">for</strong> <!-- -->i <strong class="mo iu">in</strong> <!-- -->range(m<strong class="mo iu">+</strong>1)]</span></pre><p id="0aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用两个for循环，方法类似于递归，当两个字符相似和不相似时，我们有两个条件</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="09d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">时间复杂度分析:</strong></p><ol class=""><li id="556e" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu">递归解:</strong>最坏情况下的递归解具有O(2^N).的指数时间复杂度</li><li id="d9b4" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">自顶向下法(Memoization ): </strong>自顶向下法在O(mn)时间内解决问题，其中m是字符串1的长度，n是字符串2的长度。</li><li id="b7b6" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">自底向上的方法:</strong>它需要两个循环，因此它的时间复杂度为O(mn ),类似于自顶向下的方法。</li></ol><p id="a62d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自顶向下和自底向上方法具有相同的时间复杂度，但是由于自顶向下方法是使用递归实现的，因此有可能由于过多的递归调用而导致堆栈溢出。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="0b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="oa">感谢您把文章看完，希望这篇文章对您的编码准备有所帮助。请关注我，获取更多此类文章。</em>T11】</strong></p><h1 id="ebc8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">资源:</h1><div class="ob oc gp gr od oe"><a href="https://medium.com/swlh/dynamic-programming-made-easy-32b2ec0d018e" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">动态编程变得简单</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">通过解决一个流行的LeetCode问题来理解动态编程</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://leetcode.com/problems/longest-common-subsequence/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">最长公共子序列- LeetCode</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">给定两个字符串text1和text2，返回它们的最长公共子序列的长度。一个字符串的子序列是…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">leetcode.com</p></div></div><div class="on l"><div class="ot l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">最长公共子序列| DP-4 - GeeksforGeeks</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">我们已经分别在集合1和集合2中讨论了重叠子问题和最优子结构性质。我们也…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="on l"><div class="ou l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>