<html>
<head>
<title>Asynchronous Programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的异步编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-programming-in-javascript-27c554d5a718?source=collection_archive---------8-----------------------#2020-08-01">https://levelup.gitconnected.com/asynchronous-programming-in-javascript-27c554d5a718?source=collection_archive---------8-----------------------#2020-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cf81168aab6d2b7449a039e43567a8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3a9XnpQyQUTneMW_8Qd7w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">eberhard grossgasteiger 在<a class="ae kf" href="https://unsplash.com/s/photos/bulb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4420" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个程序被处理器执行时，它直接运行，一次只发生一件事。有许多程序与处理器之外的东西进行交互，比如网络请求、从硬盘读取的数据。在这个计算机拥有多个处理器内核的时代，当您可以让另一个任务在另一个处理器内核上执行并让您知道它何时完成时，坐在那里等待是没有意义的。</p><p id="cec3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这让我们可以同时完成其他工作，这是<strong class="ki iu">异步编程的基础。</strong>由我们使用的编程环境(在我们的例子中是web浏览器/节点)为我们提供API，允许我们异步运行这些任务。</p><p id="1550" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript代码中可以遇到两种主要类型的异步代码风格:旧式回调和新式承诺式代码。让我们依次回顾一下这些问题。</p><p id="8d20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">回调:</strong></p><p id="379c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调是一个在另一个函数完成执行后执行的函数，因此被称为“回调”。</p><p id="93c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是作为参数传递给另一个函数的函数，稍后执行。</p><p id="d548" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将回调函数作为参数的函数称为高阶函数。</p><p id="52b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调是一种确保某个代码在另一个代码完成执行之前不会执行的方法。</p><p id="8397" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理想情况下，执行异步操作的函数需要一个额外的参数，一个<em class="le">回调函数</em>。当操作完成时，回调函数被调用并得到结果。</p><p id="4dcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个例子:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="61c2" class="lo lp it lk b gy lq lr l ls lt">fs.readFile('/input.json', function (error, data) {<br/>  if(error) {<br/>    //handle error logic<br/>    console.log(error);<br/>    return;<br/>  }</span><span id="3673" class="lo lp it lk b gy lu lr l ls lt">//no error process data<br/>  console.log(data);<br/>})</span></pre><p id="6d77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码片段中，我们使用了fs类中的readFile方法(作为节点API提供)。此方法异步读取文件。它接受一个回调函数作为参数(这里是第二个参数),当文件读取完成或者过程中有错误时，调用这个函数。</p><p id="5906" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有当一个回调函数将另一个回调函数作为参数创建了一个嵌套的回调结构(称为“<strong class="ki iu"> Callback Hell </strong>”)时，回调的问题才会出现。随着嵌套数量的增加，管理和理解变得越来越困难。它看起来像这样。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="3653" class="lo lp it lk b gy lq lr l ls lt">firstFunction(args, function() {<br/>  secondFunction(args, function() {<br/>    thirdFunction(args, function() {<br/>      // And so on…<br/>    });<br/>  });<br/>});</span></pre><p id="0cb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">承诺:</strong></p><p id="9170" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">承诺是未来可能实现的价值的第一代表。</p><p id="438d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它允许我们将处理程序与异步操作的最终成功值或失败原因相关联。</p><p id="d7fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得异步方法像同步方法一样返回值:异步方法不是立即返回最终值，而是返回一个在未来某个时间提供该值的承诺。</p><p id="d7e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个很好的例子是fetch() API，它是基于回调的旧XMLHttpRequest的现代版本。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e154" class="lo lp it lk b gy lq lr l ls lt">fetch('<a class="ae kf" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>)<br/>  .then(response =&gt; response.json())<br/>  .then(json =&gt; console.log(json))<br/>  .catch(function(error) {<br/>    console.log('Fetch problem: ' + error.message);<br/>  });</span></pre><p id="7114" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的fetch()将我们希望从网络上获取的资源的URL作为单个参数，并返回一个承诺。只有当我们从服务器获得响应时，才会执行then块中的代码。</p><p id="0064" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个承诺在任何时候都可以有三种状态中的任何一种:</p><p id="2c04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">待定:</strong>初始状态，既不履行也不拒绝。</p><p id="c7f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">完成:</strong>表示操作成功完成。(然后执行then块中的代码)</p><p id="ac44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">拒绝:</strong>表示操作失败(执行catch块内的代码)</p><p id="e5ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用<strong class="ki iu"> Promise </strong>构造函数在JavaScript中创建自己的Promise对象。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="abd2" class="lo lp it lk b gy lq lr l ls lt">function squareNumberAsync(input) {<br/>    return new Promise((resolve, reject) =&gt; {<br/>      setTimeout(() =&gt; {<br/>       if (input) {<br/>         resolve(input * input);<br/>        } else {<br/>         reject("Please provide an input.");<br/>        }<br/>      }, 3000);<br/>    });<br/> }</span></pre><p id="d3ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在squareNumberAsync函数中，我们确保返回一个新的承诺。Promise构造函数将一个名为executor的函数作为输入。执行器函数需要两个参数(这里是resolve和reject)</p><p id="7bff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果异步代码已经成功执行，我们将调用<em class="le"> resolve </em>。这使得承诺状态被<strong class="ki iu">解析</strong>并在消费站点执行<strong class="ki iu">然后</strong> <strong class="ki iu">块</strong>中的代码。</p><p id="2a05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果出现错误，我们将调用<em class="le">剔除</em>功能。这使得承诺状态为<strong class="ki iu">拒绝</strong>并在消费站点执行<strong class="ki iu"> catch块</strong>内的代码。</p><p id="c103" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当承诺被解决(解决/拒绝)时，finally块被调用。</p><p id="b252" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">消费网站:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="ad60" class="lo lp it lk b gy lq lr l ls lt">squareNumberAsync(50)<br/> .then((result) =&gt; {<br/>    console.log(result);<br/> })<br/> .catch((error) =&gt; {<br/>    console.log(error);<br/> })<br/> .finally(() =&gt; {<br/>    console.log("Completed");<br/> });</span></pre><p id="c176" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">异步/等待</strong></p><p id="42b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">async和await关键字使异步的、基于承诺的行为能够以更简洁的方式编写，避免了显式配置承诺链的需要。</p><p id="868d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">async/await的目的是简化使用基于承诺的API所需的语法。</p><p id="80a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">异步函数总是返回一个<strong class="ki iu">承诺</strong>。如果异步函数的返回值不是显式的承诺，它将被隐式地包装在承诺中。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="42e2" class="lo lp it lk b gy lq lr l ls lt"><em class="le">async function foo() <br/>{ return 1}</em></span><span id="2920" class="lo lp it lk b gy lu lr l ls lt"><em class="le">//The above function works same as the below<br/>function foo()<br/>{ return Promise.resolve(1) }</em></span></pre><p id="ddc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">异步函数可以包含零个或多个await表达式。</p><p id="ed4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">await关键字只在异步函数中有效。如果你在一个异步函数体之外使用它，你会得到一个语法错误。</p><p id="ecf2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键字await让JavaScript一直等到承诺完成并返回结果。</p><p id="7c15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们有两个网络API调用。第二个API调用依赖于第一个API调用的响应。</p><p id="59ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不使用async/await来编写它，它看起来会像下面这样。我使用Axios HTTP客户端库来处理网络API请求。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="36a6" class="lo lp it lk b gy lq lr l ls lt">function fetchFirstUserDetails() {<br/>  axios.get('<a class="ae kf" href="https://jsonplaceholder.typicode.com/users'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users'</a>)<br/>    .then((usersResponse) =&gt; {<br/>      //passing the first user id to second api call<br/>         axios.get(`<a class="ae kf" href="https://jsonplaceholder.typicode.com/users/${usersResponse.data[0].id}`" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users/${usersResponse.data[0].id}`</a>)<br/>        .then((userResponse) =&gt; console.log(userResponse.data))<br/>        .catch((error) =&gt; console.log(error));<br/>    })<br/>    .catch((error) =&gt; console.log(error));<br/>};</span></pre><p id="1990" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要将第二个API调用嵌套在第一个API调用的then块中。</p><p id="6c6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用async/await，它会使我们的代码看起来更简单，如下所示。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="5b6c" class="lo lp it lk b gy lq lr l ls lt">async function fetchFirstUserDetails() {<br/>  try {<br/>    let usersResponse = await     axios.get('<a class="ae kf" href="https://jsonplaceholder.typicode.com/users'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users'</a>);<br/>    let userResponse = await axios.get(`<a class="ae kf" href="https://jsonplaceholder.typicode.com/users/${usersResponse.data[0].id}`" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users/${usersResponse.data[0].id}`</a>);<br/>    console.log(userResponse.data);<br/>  } catch (error) {<br/>    console.log(error);<br/>  }<br/>}</span></pre><p id="c5ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">异步函数中的await表达式等待一个承诺被解决。</p><p id="baf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果承诺实现了，它就继续执行。</p><p id="21e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果承诺被拒绝，await表达式将抛出被拒绝的值。</p><p id="22e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该始终确保在try-catch块中编写await表达式，以便捕获被拒绝的值。</p><p id="e33e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">暂时就这些了…谢谢。</p><h2 id="6686" class="lo lp it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated"><strong class="ak">参考文献:</strong></h2><p id="34b6" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing</a></p></div></div>    
</body>
</html>