# 如何以及为什么在 Golang 中使用函数来配置 New()

> 原文：<https://levelup.gitconnected.com/how-and-why-to-use-a-function-to-configure-new-in-golang-f042b52ca99>

![](img/ef76f9162dbd5663373eb0330bce290b.png)

照片由 [Chinmay Bhattar](https://unsplash.com/@geekgunda?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/s/photos/golang?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

## 因为对象太主流？

当实现返回某个`struct`的新实例的方法`New()`时，我最近喜欢传递配置新实例的函数，而不是传递配置值的对象/映射，让`New`方法处理一切。

原因如下。

# 定义我们的目标

考虑我们简单命名的类`objectInstance`:

# 使用配置对象

现在考虑以下使用配置对象初始化新的`objectInstance`的实现:

这导致使用者代码如下所示:

# 使用配置功能

实现上面的方法，我们使用一个函数来初始化这个`objectInstance`,看起来像这样:

消费代码现在看起来像这样:

# 为什么以及何时使用这种模式

我很确定有一个我没有听说过的模式名称，所以我不会给它命名。

首先，这种模式显然不适合用于只传递一两个参数的情况。在这种情况下，遵从保持简单的原则！

在必须传递多个参数来配置一个对象实例的情况下，这种模式是一种更简洁的替代方式，该对象的设计目的是向消费者隐藏复杂性。想象一个标准化的 HTTP 服务器实例，其中你可能必须定义各种超时值、主体大小限制、绑定接口、监听端口等等。

因此，我发现这种做事方式非常好:

## 封装配置范围

所有与配置`objectInstance`相关的代码都可以封装在一个函数的作用域中。这通过允许您在自己的配置函数中定义仅在`objectInstance`的初始化中使用的变量，提高了作用域的健康性。

如果不需要使用来自父作用域的值，您甚至可以将其完全抽象出来，这也提高了可测试性:

## 避免混乱的值检查

Golang 在错误处理方面极其冗长。你已经有足够的`error`要检查，所以减少你必须做的其他检查的数量。

使用一个函数来配置初始化器类允许我们减少圈复杂度，当有一些事情需要检查时，圈复杂度会迅速增加:

现在看起来像这样:

## 避免配置对象中的代码重复

当使用一个对象配置返回另一个对象的函数时，在大多数情况下，返回的对象实例具有许多与其配置对象相似的属性:

使用配置功能可以通过以下方式完全避免这种情况:

1.  允许使用者直接访问对象实例的属性，而
2.  支持在消费者配置后运行验证检查

总之，试一试，看看它如何改变您的代码！下次见-

如果你发现以上有用，考虑给一些👏这对你来说是免费的，它将激励我在我的工程旅程中继续分享类似的概念。或者，我刚刚创建了[这个推荐页面](https://hi.joeir.net/other-things/my-referral-codes)，如果你愿意为我使用的服务给我一个推荐奖励(在大多数情况下，你也会得到一些东西)。