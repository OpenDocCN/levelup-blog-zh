<html>
<head>
<title>Practical DDD in Golang: Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗实用DDD:模块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-ddd-in-golang-module-51edf4c319ec?source=collection_archive---------2-----------------------#2021-09-12">https://levelup.gitconnected.com/practical-ddd-in-golang-module-51edf4c319ec?source=collection_archive---------2-----------------------#2021-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="cec3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">领域驱动设计</h2><div class=""/><div class=""><h2 id="8f28" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">围棋中关于DDD的旅程把我们带到了高度内聚的结构群——模块。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6d5f0585a67c9695a45772b4b93e3326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*beoeCcYfS-mnEd43"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@amosbarzeev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿莫斯·巴泽夫</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="04b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">乍一看，这个模块看起来不像一个模式，至少，我们认为是软件开发中的<a class="ae lh" href="https://refactoring.guru/design-patterns" rel="noopener ugc nofollow" target="_blank">模式</a>。这是可以理解的，因为有人可能更多地将模块视为项目结构，而不是模式。</p><p id="56ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们考虑<a class="ae lh" href="https://go.dev/blog/using-go-modules" rel="noopener ugc nofollow" target="_blank"> Go模块</a>时，额外的麻烦就来了。他们将<a class="ae lh" href="https://www.callicoder.com/golang-packages/" rel="noopener ugc nofollow" target="_blank"> Go包</a>的集合耦合在一起，一起版本化并发布。我们使用这些模块作为Go中的依赖管理。</p><p id="0a9b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，如果Go模块和包都影响项目结构，那么它们似乎应该与DDD模式模块有一些联系。事实也的确如此。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="b553" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="ed2b" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="ec6f" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="ada2" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mf jd">Practical DDD in Golang: Domain Service</strong></a></span><span id="7530" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-event-de02ad492989"><strong class="mf jd">Practical DDD in Golang: Domain Event</strong></a></span></pre><h1 id="07cf" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">该结构</h1><p id="5c03" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">在Go中，我们使用包对代码进行分组。包遵循我们项目中的文件夹结构，尽管它们在命名上可能有所不同。这些变化是因为我们可以用不同于实际文件夹的方式调用我们的包。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">文件夹名和包名之间的区别</figcaption></figure><p id="3da7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们可以看到文件夹和包命名之间的细微差别。有时，如果我有很多<code class="fe no np nq mf b">model</code>包，我会给它们加上我的DDD模块的前缀，以便容易地引用同一个文件中的多个<code class="fe no np nq mf b">model</code>包。</p><p id="201f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们可能已经对前面例子中的DDD模块有了一些了解。在这里，模块是<code class="fe no np nq mf b">access</code>包，以及它所有的子包。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="efd9" class="mj mk it mf b gy ml mm l mn mo">project<br/>|--cmd<br/>   |--main.go<br/>|--internal<br/>   |--module1<br/>      |--infrastructure<br/>      |--presentation<br/>      |--application<br/>      |--domain     <br/>         |--service    <br/>         |--factory    <br/>         |--repository    <br/>         |--model  <br/>      |--module1.go<br/>   |--module2<br/>      |--...<br/>   |--...<br/>|--pkg<br/>   |--module3<br/>      |--...<br/>   |--module4<br/>      |--...<br/>   |--...<br/>|--go.mod<br/>|--...</span></pre><p id="9bb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面方案中的文件夹结构代表了我最喜欢的项目结构，它在Go中实现了领域驱动设计。有时我会对一些文件夹做不同的改动，但我总是试图让DDD模块保持相同的形式。</p><p id="0605" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我的项目中，每个模块最多有四个基础包:<code class="fe no np nq mf b">infrastructure</code>、<code class="fe no np nq mf b">presentation</code>、<code class="fe no np nq mf b">application</code>和<code class="fe no np nq mf b">domain</code>。如你所见，我喜欢遵循<a class="ae lh" href="https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html" rel="noopener ugc nofollow" target="_blank">分层架构</a>的原则。</p><p id="ad33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，我将<code class="fe no np nq mf b">infrastructure</code>包放在顶部。这是因为通过遵循鲍勃大叔的T21依赖性反转原则，我的来自T1层的低级服务实现了来自其他层的高级接口。</p><p id="8b3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用这种方法，我确保将端口定义为<code class="fe no np nq mf b">domain</code>层上的<code class="fe no np nq mf b">UserRepository</code>接口。实际的实现在<code class="fe no np nq mf b">infrastructure</code>层，它可以是多个适配器，比如<code class="fe no np nq mf b">UserDBRepository</code>，或者<code class="fe no np nq mf b">UserFakeRepository</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">端口和适配器</figcaption></figure><p id="6329" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">关于端口和适配器的故事并不新鲜，它属于<a class="ae lh" href="https://medium.com/ssense-tech/hexagonal-architecture-there-are-always-two-sides-to-every-story-bc0780ed7d9c" rel="noopener">六边形架构</a>的原理。这是我在设计DDD模块时使用的第二个原则，对我来说，这是至关重要的一个原则。</p><p id="ad97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">回到模块内部的包的结构，每一层都知道下面所有层的一切，没有人知道它们的任何事情。因此，<code class="fe no np nq mf b">infrastructure</code>层可以依赖于所有层，而<code class="fe no np nq mf b">domain</code>层不依赖于任何层。</p><p id="0361" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<code class="fe no np nq mf b">infrastructure</code>层的正下方是<code class="fe no np nq mf b">presentation</code>层。我们也可以称之为<code class="fe no np nq mf b">interface</code>层，但它是Go中的保留字，所以<code class="fe no np nq mf b">presentation</code>看起来没问题。最后，在<code class="fe no np nq mf b">presentation</code>和<code class="fe no np nq mf b">domain</code>之间，还有<code class="fe no np nq mf b">application</code>层。</p><p id="0032" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Go中这种分层的好处在于，它帮助我们避免了循环依赖，循环依赖会在编译时破坏我们的代码。通过遵循这些分层规则和依赖性方向，我们可以将自己从痛苦的代码重构中拯救出来。</p><p id="496d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，你注意到了<code class="fe no np nq mf b">domain</code>层里面的一些文件夹(或者包):<code class="fe no np nq mf b">model</code>、<code class="fe no np nq mf b">service</code>等。我偶尔会把它们放在那里，以使我的包尽可能简单。</p><p id="0e49" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时，我在<code class="fe no np nq mf b">domain</code>中使用那个子结构来避免Go中的循环依赖。我选择将<code class="fe no np nq mf b">model</code>放在底部，将<code class="fe no np nq mf b">service</code>放在顶部，但这取决于个人选择他们喜欢的方式。</p><h1 id="5052" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">逻辑集群</h1><p id="2019" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">DDD模块不仅仅是一些文件和文件夹的组合。这些文件和文件夹中的代码必须代表某种内聚的结构。不仅如此，两个不同的模块应该是松散耦合的，它们之间的依赖性最小。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="df76" class="mj mk it mf b gy ml mm l mn mo">project<br/>|--...<br/>|--pkg<br/>   |--access<br/>      |--infrastructure<br/>         |--...<br/>      |--presentation<br/>         |--...<br/>      |--application<br/>         |--service<br/>            |--authorization.go<br/>            |--registration.go<br/>      |--domain     <br/>         |--repository<br/>            |--user.go<br/>            |--group.go<br/>            |--role.go    <br/>         |--model<br/>            |--user.go<br/>            |--group.go<br/>            |--role.go<br/>      |--access.go<br/>   |--shopping<br/>      |--infrastructure<br/>         |--...<br/>      |--presentation<br/>         |--...<br/>      |--application<br/>         |--service<br/>            |--session_basket.go<br/>      |--domain     <br/>         |--service <br/>            |--shopping.go <br/>         |--factory <br/>            |--basket.go <br/>         |--repository<br/>            |--order.go   <br/>         |--model<br/>            |--order.go<br/>            |--basket.go<br/>      |--shopping.go<br/>   |--customer<br/>      |--infrastructure<br/>         |--...<br/>      |--presentation<br/>         |--...<br/>      |--application<br/>         |--...<br/>      |--domain <br/>         |--repository<br/>            |--customer.go <br/>            |--address.go    <br/>         |--model<br/>            |--customer.go <br/>            |--address.go <br/>      |--customer.go<br/>   |--...<br/>|--...</span></pre><p id="e821" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的文件夹结构是DDD模块的一个简单例子。在那里，我们有三个模块(可能更多)，叫做<code class="fe no np nq mf b">access,</code> <code class="fe no np nq mf b">shopping,</code>和<code class="fe no np nq mf b">customer</code>。它们都有自己的层和子层。</p><p id="5a7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq mf b">access</code>模块与授权和注册过程相关。它包含了在会话中处理一个<code class="fe no np nq mf b">User</code>的全部逻辑。此外，它拥有每个用户的访问权限，并决定他们是否可以访问特定的对象。</p><p id="4d7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq mf b">customer</code>模块包含关于<code class="fe no np nq mf b">Customers</code>及其<code class="fe no np nq mf b">Addresses</code>的信息。尽管它可能看起来与<code class="fe no np nq mf b">User</code>相同，但它代表了生成<code class="fe no np nq mf b">Orders</code>的业务实体，其中<code class="fe no np nq mf b">User</code>是会话中的一个实体。另外，一个<code class="fe no np nq mf b">User</code>可以有多个<code class="fe no np nq mf b">Customers</code>进行交付，就像我们已经在很多平台上做的那样。</p><p id="2181" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，<code class="fe no np nq mf b">shopping</code>模块是一个完整逻辑的集群，包括<code class="fe no np nq mf b">Basket</code>的创建和保持会话状态，以及<code class="fe no np nq mf b">Orders</code>的进一步创建。这个<code class="fe no np nq mf b">shopping</code>模块看起来比其他两个更复杂，事实上，它依赖于这两个模块。</p><p id="fee2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">而且，就像层一样，我们也应该跟踪模块之间的依赖关系，并确保它们是单向的。否则编译器可能会哭。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/dea5e1095bb7083e7d340e6a619a2e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJ16eT7veJ2374I8Q4tyLQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">模块依赖图</figcaption></figure><p id="36bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上图所示，<code class="fe no np nq mf b">shopping</code>模块使用<code class="fe no np nq mf b">customer</code>模块找出<code class="fe no np nq mf b">Order</code>的主人是谁。从那里，它可以使用<code class="fe no np nq mf b">Address</code>来定义交付。它还依赖于<code class="fe no np nq mf b">access</code>模块来检查特定<code class="fe no np nq mf b">Baskets</code>和<code class="fe no np nq mf b">Items</code>的访问权限。</p><p id="411d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq mf b">customer</code>模块只依赖于<code class="fe no np nq mf b">access</code>模块。它为会话中的用户提供了一个连接，并提供了一个已分配的<code class="fe no np nq mf b">Customers</code>列表，以决定将<code class="fe no np nq mf b">Order</code>发送给谁。</p><p id="97e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq mf b">customer</code>和<code class="fe no np nq mf b">shopping</code>可以一起定义一个单一的<a class="ae lh" href="https://martinfowler.com/bliki/BoundedContext.html" rel="noopener ugc nofollow" target="_blank">有界上下文</a>。单个模块不需要表示一个有界的上下文。我喜欢将一个有界的上下文分割成多个模块。</p><p id="e94b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq mf b">access</code>模块可能看起来像一个不同的有界上下文的候选者，将来，我们可以考虑把它放在别的地方。稍后，其他有界上下文可能依赖于访问有界上下文。</p><p id="c8dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然<code class="fe no np nq mf b">shopping</code>和<code class="fe no np nq mf b">customer</code>可能看起来是耦合在一起的，但是在我们的应用程序中，我们决定将它们分开。原因是作为一个<code class="fe no np nq mf b">Customer</code>，我们可能会独立于<code class="fe no np nq mf b">Orders</code>做很多不同的事情。</p><p id="fece" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可能会更改我们的<code class="fe no np nq mf b">Addresses</code>，查看我们的历史，跟踪我们的交付，联系客户支持。<code class="fe no np nq mf b">Customer</code>细节的变化不应影响一个订单。此外，一个<code class="fe no np nq mf b">Order</code>的变化不会影响<code class="fe no np nq mf b">Customer</code>。我们可以独立地与他们合作。</p><h1 id="d354" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">命名</h1><p id="7caa" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">谈论命名可能看起来令人惊讶，但不幸的是，事实并非如此。根据我的经验，我见过DDD模块糟糕的名字，我还创造过更糟糕的名字。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="1530" class="mj mk it mf b gy ml mm l mn mo">project<br/>|--...<br/>|--pkg<br/>   |--shoppingAndCustomer<br/>      |--...<br/>   |--utils<br/>      |--...<br/>   |--events<br/>      |--...<br/>   |--strategy<br/>      |--...<br/>   |--...<br/>|--...</span></pre><p id="5baa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子包含许多不同的坏名字。我总是避免在模块名中使用“和”这个词，就像这里的<code class="fe no np nq mf b">shoppingAndCustomer</code>。如果我不能避免“和”这个词，可能我是在处理两个独立的模块。</p><p id="8ec9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">“utils”这个词是软件开发中最糟糕的名字。我不能忍受它作为结构名、文件名、函数名、包或模块名。“垃圾收集器”这个名字可能更合适，因为它最恰当地描述了存储在<code class="fe no np nq mf b">utils</code>模块中的代码。</p><p id="8115" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">拥有一个包含来自任何地方的小部件的模块也是没有用的。<code class="fe no np nq mf b">events</code>模块就是这样一个例子——它包含来自整个应用程序的域事件。</p><p id="55fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以某种设计模式命名一个模块也不是很好的做法，比如<code class="fe no np nq mf b">strategy</code>模块。也许我们应该在应用程序的很多地方使用<a class="ae lh" href="https://refactoring.guru/design-patterns/strategy" rel="noopener ugc nofollow" target="_blank">策略</a>模式，所以制作多个<code class="fe no np nq mf b">strategy</code>模块是没有意义的。</p><p id="9238" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的模块应该有来自真实商业世界的名字。它应该是<a class="ae lh" href="https://martinfowler.com/bliki/UbiquitousLanguage.html" rel="noopener ugc nofollow" target="_blank">无处不在的语言</a>的一部分，属于商业和软件开发领域的一些术语，描述了同样的事情。它应该是该业务逻辑集群的唯一名称。</p><h1 id="4292" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">依赖注入</h1><p id="4133" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">您可能会注意到，第一个项目结构在每个DDD模块的根中引入了单独的Go文件。我总是把它们的名字放在<code class="fe no np nq mf b">module.go</code>或者与模块相同的地方。</p><p id="789f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这些文件中，我定义了模块中的依赖项，以及端口的不同适配器(如果有的话)。在许多情况下，我编写简单的Go容器，存储我在应用程序中使用的对象。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">具有依赖关系的简单模块</figcaption></figure><p id="96c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我已经创建了<code class="fe no np nq mf b">AccessModule</code>结构。在初始化过程中，它接受配置，该配置定义了它是否应该依赖于数据库或某些用于<code class="fe no np nq mf b">UserRepository</code>的虚假实现。稍后，所有其他模块都可以使用这个容器来获取它们的依赖项。</p><p id="01c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还可以通过使用我们现有的许多框架中的一个来解决Go中的依赖注入。其中使用最多的是一个名为<a class="ae lh" href="https://github.com/google/wire" rel="noopener ugc nofollow" target="_blank"> Wire </a>的库，但我个人最好的是<a class="ae lh" href="https://github.com/i-love-flamingo/dingo" rel="noopener ugc nofollow" target="_blank"> Dingo </a>。</p><p id="2f7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Dingo库依赖于反射，这对于许多go开发者来说是一个痛苦的话题。虽然我不喜欢Go中的反射，但根据我的经验，Dingo被证明是一个简单而稳定的解决方案，提供了许多不同的特性。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Dingo库的例子</figcaption></figure><h1 id="d481" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">结论</h1><p id="c63a" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">DDD模块是我们代码的逻辑簇。它将许多结构耦合在一起，形成一个共享一些业务规则的有凝聚力的团体。在模块内部，我们可以引入不同的层。</p><p id="11bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">层和模块都应该遵循单向通信，以避免循环依赖。模块的名称应该代表商业领域的术语。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="a549" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="c53f" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="6044" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="86d9" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mf jd">Practical DDD in Golang: Domain Service</strong></a></span><span id="903d" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-event-de02ad492989"><strong class="mf jd">Practical DDD in Golang: Domain Event</strong></a></span></pre><div class="ns nt gp gr nu nv"><a href="https://blog.ompluscator.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jd gy z fp oa fr fs ob fu fw jc bi translated">通过我的推荐链接加入媒体——马尔科·米洛耶维奇</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">blog.ompluscator.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj lb nv"/></div></div></a></div><h1 id="4237" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">有用的资源:</h1><ul class=""><li id="99fc" class="ok ol it lk b ll nh lo ni lr om lv on lz oo md op oq or os bi translated"><a class="ae lh" href="https://martinfowler.com/" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/</a></li><li id="d261" class="ok ol it lk b ll ot lo ou lr ov lv ow lz ox md op oq or os bi translated">【https://www.domainlanguage.com/ T2】号</li></ul></div></div>    
</body>
</html>