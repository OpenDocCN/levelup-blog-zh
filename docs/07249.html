<html>
<head>
<title>pop and push: Learning Javascript’s Array Methods by Building Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">pop和push:通过构建学习Javascript的数组方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pop-and-push-learning-javascripts-array-methods-by-building-them-fed7096cf6f0?source=collection_archive---------8-----------------------#2021-02-03">https://levelup.gitconnected.com/pop-and-push-learning-javascripts-array-methods-by-building-them-fed7096cf6f0?source=collection_archive---------8-----------------------#2021-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dc72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在本系列的第五篇文章中探讨实现pop和push。具体来说，我们如何在不使用push的情况下添加一个项目，或者在不使用pop的情况下删除一个项目？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/fd608cb51e80ac14899055cc594394fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2rnHEi0_Fc_zG19tx6bVg.png"/></div></div></figure><p id="cd3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我在本系列中介绍的数组方法都是为了某种目的而循环遍历数组:对每一项做一些事情，获取每一项的修改版本，或者获取数组的一部分。这包括查看<code class="fe kx ky kz la b">forEach</code>、<code class="fe kx ky kz la b">filter</code>和<code class="fe kx ky kz la b">map</code>。</p><p id="64b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将重点介绍使用数组的另一种方式。具体来说，<code class="fe kx ky kz la b">pop</code>和<code class="fe kx ky kz la b">push</code>，用于在数组中添加和删除条目。</p><p id="15ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像我以前的文章一样，我将介绍如何实现您自己版本的<code class="fe kx ky kz la b">pop</code>和<code class="fe kx ky kz la b">push</code>。也就是说，90%的情况下，您会希望使用这些内置方法。查看如何实现您自己的功能的目的是了解在无法使用<code class="fe kx ky kz la b">pop</code>和<code class="fe kx ky kz la b">push</code>的情况下如何获得相同的功能。例如，在构建React应用程序的部分中，状态是不可变的(不能被改变)。</p><h1 id="d435" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">它们是如何工作的</h1><p id="f767" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">使用<code class="fe kx ky kz la b">push</code>向数组末尾添加一个项目，使用<code class="fe kx ky kz la b">pop</code>从数组末尾删除一个项目:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="a8be" class="mi lc iq la b gy mj mk l ml mm">const numbers = [1, 2, 3, 4]</span><span id="1ba8" class="mi lc iq la b gy mn mk l ml mm">// Add an item to the end:<br/>numbers.push(5) // [1, 2, 3, 4, 5]</span><span id="ff07" class="mi lc iq la b gy mn mk l ml mm">// Removethe last item:<br/>numbers.pop() // [1, 2, 3, 4 ]</span></pre><p id="8097" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我取一个数组(<code class="fe kx ky kz la b">numbers</code>)，用<code class="fe kx ky kz la b">push</code>在末尾加一个条目(<code class="fe kx ky kz la b">5</code>)。然后，我马上用<code class="fe kx ky kz la b">pop</code>把它去掉。</p><p id="f5f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从数组开始处添加和移除有单独的、对应的方法。这些是<code class="fe kx ky kz la b">shift</code>和<code class="fe kx ky kz la b">unshift</code>，我将在以后的文章中介绍它们。</p><h1 id="005b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不使用<code class="fe kx ky kz la b">push</code>添加</h1><p id="5806" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如何在不使用<code class="fe kx ky kz la b">push</code>方法的情况下将一个项目添加到数组的末尾？</p><p id="27cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最简单的方法是给数组中的索引位置赋值:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="4067" class="mi lc iq la b gy mj mk l ml mm">const numbers = [1, 2, 3, 4]<br/>numbers[ numbers.length ] = 5</span></pre><p id="858e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不是每种编程语言都允许这样做。一般来说，数组的长度是固定的，实际上你必须用新值创建一个新的更长的数组。比如围棋就是如此。</p><p id="8016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript会让你在大多数情况下做到这一点。但是，这种方法有两个限制。首先，您现在手动管理这个数组的索引。仔细检查你的代码，确保你没有遗漏某处的索引或者有任何一个问题。第二，正如我前面提到的，有时候你想要(或者需要)创建一个新的数组。</p><p id="6990" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以使用spread操作符创建一个新的数组，我在我的实现<code class="fe kx ky kz la b"><a class="ae mo" href="https://zkf.io/js-array-methods-concat/" rel="noopener ugc nofollow" target="_blank">concat</a></code>中提到过。使用spread操作符，我可以实现我自己版本的模拟相同行为的<code class="fe kx ky kz la b">push</code>。</p><p id="e5fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我需要定义一个函数，它接受一个数组和新项作为参数。然后，它需要返回一个新数组，其中包含原始数组的所有值，以及新的项。大概是这样的:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="e140" class="mi lc iq la b gy mj mk l ml mm">function push(array, item) {<br/>  return [<br/>    ...array,<br/>    item<br/>  ]<br/>}</span></pre><p id="038e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，用我原来的<code class="fe kx ky kz la b">numbers</code>数组，我可以这样做:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="925a" class="mi lc iq la b gy mj mk l ml mm">let numbers = [1, 2, 3, 4]</span><span id="b670" class="mi lc iq la b gy mn mk l ml mm">numbers = push(numbers, 5) // [1, 2, 3, 4, 5]</span></pre><p id="f7c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个实现缺少一样东西:内置的<code class="fe kx ky kz la b">push</code>方法允许您一次添加多个值:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="e186" class="mi lc iq la b gy mj mk l ml mm">let numbers = [1, 2, 3, 4]</span><span id="023a" class="mi lc iq la b gy mn mk l ml mm">numbers.push(5, 6, 7) // [1, 2, 3, 4, 5, 6, 7]</span></pre><p id="7709" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用spread和rest操作符修改我的实现来适应这一点实际上相当简单:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="20d5" class="mi lc iq la b gy mj mk l ml mm">function push(array, ...items) {<br/>  return [<br/>    ...array,<br/>    ...items<br/>  ]<br/>}</span></pre><p id="f7cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第1行，我在初始数组后获取任意数量的参数，并使用rest操作符将它们合并到一个名为<code class="fe kx ky kz la b">items</code>的数组中。然后，我使用<code class="fe kx ky kz la b">spread</code>操作符将这些项目和传入数组中的项目一起放入新数组中。</p><p id="34b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(请注意，当<code class="fe kx ky kz la b">...</code>执行展开操作和静止操作时，可能会有点混乱。更令人困惑的是，这个操作符也可以处理对象！)</p><p id="6d2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我的实现可以在原始数组后接受任意数量的参数:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="39c2" class="mi lc iq la b gy mj mk l ml mm">let numbers = [1, 2, 3, 4]</span><span id="f562" class="mi lc iq la b gy mn mk l ml mm">// Adding one new item:<br/>numbers = push(numbers, 5) // [1, 2, 3, 4, 5]</span><span id="6358" class="mi lc iq la b gy mn mk l ml mm">// Adding more than one:<br/>numbers = push(numbers, 6, 7, 8) // 1, 2, 3, 4, 5, 6, 7, 8]</span></pre><h1 id="678c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">移除时不弹出</h1><p id="84fb" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">不使用<code class="fe kx ky kz la b">pop</code>从数组中移除最后一项有点棘手。最佳方法将取决于您的环境，并且可能涉及另一个数组方法。我将向您展示一种不如您想象的那样有效的方法，一种有效的方法，然后是我认为最好的方法。</p><p id="3bd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你在JavaScript中遇到过<code class="fe kx ky kz la b">delete</code>，你可能会把它作为一种方法。不过，我通常会建议避免使用<code class="fe kx ky kz la b">delete</code>。在这种情况下，它将从数组中删除该项，但是您可能没有预料到的行为是数组的长度将保持不变，并且在末尾会留下一个空项(或槽):</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="9ffc" class="mi lc iq la b gy mj mk l ml mm">let numbers = [1, 2, 3, 4]</span><span id="cd31" class="mi lc iq la b gy mn mk l ml mm">// The original length:<br/>numbers.length // 4</span><span id="b3e6" class="mi lc iq la b gy mn mk l ml mm">// Delete the last item:<br/>delete numbers[ numbers.length - 1]</span><span id="54b9" class="mi lc iq la b gy mn mk l ml mm">// The new length:<br/>numbers.length // 4</span><span id="3ecc" class="mi lc iq la b gy mn mk l ml mm">numbers // [1, 2, 3, &lt;1 empty slot&gt;]</span></pre><p id="869f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您稍后循环这个数组，长度将不会对应于数组中实际值的数量，并且您会得到一些奇怪的、难以调试的行为:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="86f1" class="mi lc iq la b gy mj mk l ml mm">for (let i = 0; i &lt; numbers.length; i++) {<br/>  console.log(numbers[i])<br/>}<br/>// 1<br/>// 2<br/>// 3<br/>// undefined</span></pre><p id="de88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种方法是编写一个创建新数组的<code class="fe kx ky kz la b">for</code>循环。我可以在一个函数中模仿<code class="fe kx ky kz la b">pop</code>的行为:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="15d1" class="mi lc iq la b gy mj mk l ml mm">function pop(array) {<br/>  let res = []<br/>  for (let i = 0; i &lt; array.length - 1; i++) {<br/>    res[i] = array[i]<br/>  }<br/>  <br/>  return res<br/>}</span></pre><p id="19db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的<code class="fe kx ky kz la b">pop</code>方法中，我把原始数组作为一个参数。然后，我立即创建一个新的空数组，最终返回给调用者。然后，我遍历原始数组，但是跳过最后一项(<code class="fe kx ky kz la b">i &lt; array.length -1</code>)，这实际上删除了它。在这个循环体内，我将传入数组的当前位置的值赋给新数组的位置(<code class="fe kx ky kz la b">res[i] = array[i]</code>)。</p><p id="8604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这工作得很好:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="0c89" class="mi lc iq la b gy mj mk l ml mm">let numbers = [1, 2, 3, 4]</span><span id="ba3b" class="mi lc iq la b gy mn mk l ml mm">numbers = pop(numbers) // [1, 2, 3]</span></pre><p id="ad64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这继续支持了我的理论，即每个数组方法都可以用一个<code class="fe kx ky kz la b">for</code>循环来实现。但是，正如我之前在本系列中说过的，你通常希望避免<code class="fe kx ky kz la b">for</code>循环，而是使用命名方法，这样你的代码更容易阅读。这里也是如此，但是有一个小小的警告。</p><p id="2376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我可以使用<code class="fe kx ky kz la b">slice</code>完成同样的目标，并跳过循环。需要注意的是，很多人很难记住<code class="fe kx ky kz la b">slice</code>和<code class="fe kx ky kz la b">splice</code>之间的区别。我发现学习围棋对我有帮助。Go中的切片是一种数据结构，相当于JavaScript中的数组，其中Go中的数组的行为类似于更传统的数组类型。Go中的数组有一个固定的长度，在初始化后不能改变。不然我还没听过好的记住区别的助记法。</p><p id="0bc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论如何，我可以通过使用<code class="fe kx ky kz la b">slice</code>来简化我的<code class="fe kx ky kz la b">pop</code>方法的实现:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="184b" class="mi lc iq la b gy mj mk l ml mm">function pop(array) {<br/>  return array.slice(0, array.length - 1)<br/>}</span></pre><p id="f570" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本系列的后续文章将介绍如何实现<code class="fe kx ky kz la b">slice</code>和<code class="fe kx ky kz la b">splice</code>。同时，您需要知道传入的参数是切片的开始和结束位置。<code class="fe kx ky kz la b">slice</code>然后返回数组这一部分的浅表副本。</p><p id="15fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用我的<code class="fe kx ky kz la b">pop</code>方法的新版本，我可以得到相同的结果:</p><pre class="km kn ko kp gt me la mf mg aw mh bi"><span id="e6ff" class="mi lc iq la b gy mj mk l ml mm">let numbers = [1, 2, 3, 4]</span><span id="1d06" class="mi lc iq la b gy mn mk l ml mm">numbers = pop(numbers) // [1, 2, 3]<br/>numbers = pop(numbers) // [1, 2]<br/>numbers = pop(numbers) // [1]</span></pre><p id="1997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在解决这个问题的三种方法中，使用<code class="fe kx ky kz la b">slice</code>是最好的选择。不过，我写了一个关于每个数组方法的完整系列，所以我可能对它们有偏见。</p><h1 id="ad04" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="30e4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这是介绍JavaScript中每个内置数组方法的系列文章的第四篇。如果您还没有看过，一定要看看本系列的其他文章:</p><ul class=""><li id="2456" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated"><code class="fe kx ky kz la b"><a class="ae mo" href="https://zkf.io/js-array-methods-foreach/" rel="noopener ugc nofollow" target="_blank">forEach</a></code></li><li id="340f" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><code class="fe kx ky kz la b"><a class="ae mo" href="https://zkf.io/js-array-methods-map/" rel="noopener ugc nofollow" target="_blank">map</a></code></li><li id="e1e7" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><code class="fe kx ky kz la b"><a class="ae mo" href="https://zkf.io/js-array-methods-concat/" rel="noopener ugc nofollow" target="_blank">concat</a></code></li><li id="0018" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><code class="fe kx ky kz la b"><a class="ae mo" href="https://zkf.io/js-array-methods-filter/" rel="noopener ugc nofollow" target="_blank">filter</a></code></li></ul><p id="6570" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将解释并实现每个内置方法。如果你对此感兴趣，我鼓励你在<a class="ae mo" href="https://twitter.com/ZFleischmann" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，这样你就不会错过本系列未来的文章。</p></div></div>    
</body>
</html>