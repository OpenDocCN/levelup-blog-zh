<html>
<head>
<title>React Router Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应路由器游戏攻略</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-router-introduction-8ee330524853?source=collection_archive---------2-----------------------#2019-03-08">https://levelup.gitconnected.com/react-router-introduction-8ee330524853?source=collection_archive---------2-----------------------#2019-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ed2f711f79ce2dc6fb0612d03a3c5a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJXVFjUciDD51I3c3cbtMQ.png"/></div></div></figure><p id="45bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> React Router </a>是为解决React app中路由问题而创建的第三方库。它包装了浏览器历史API，并负责保持React应用程序UI与浏览器的URL同步。</p><p id="cd9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React路由器有两个包:<code class="fe kx ky kz la b">react-router-dom</code>用于React和<code class="fe kx ky kz la b">react-router-native</code>用于React Native。既然你正在学习制作网络应用程序，你只需要安装<code class="fe kx ky kz la b">react-router-dom</code>:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="469e" class="lj lk iq la b gy ll lm l ln lo">npm install react-router-dom</span></pre><p id="c180" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最小导航中常用的React路由器基本组件有3个，分别是<code class="fe kx ky kz la b">BrowserRouter</code>、<code class="fe kx ky kz la b">Route</code>和<code class="fe kx ky kz la b">Link</code>。先来探讨一下<code class="fe kx ky kz la b">BrowserRouter</code>和<code class="fe kx ky kz la b">Route</code>:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="6c38" class="lj lk iq la b gy ll lm l ln lo">import { BrowserRouter as Router, Route } from 'react-router-dom'</span><span id="be0b" class="lj lk iq la b gy lp lm l ln lo">class RouterNavigationSample extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;Router&gt;<br/>      &lt;&gt;<br/>        &lt;NavigationComponent /&gt;<br/>        &lt;Route exact path="/" component={Home} /&gt;<br/>        &lt;Route path="/about" component={About} /&gt;<br/>      &lt;/&gt;<br/>      &lt;/Router&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="5763" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为<code class="fe kx ky kz la b">Router</code>导入的<code class="fe kx ky kz la b">BrowserRouter</code>充当父组件，包装所有React组件。它将截取浏览器请求URL，并将其路径与相应的<code class="fe kx ky kz la b">Route</code>组件匹配。因此，如果浏览器URL是<code class="fe kx ky kz la b">localhost:3000/about</code>,<code class="fe kx ky kz la b">Router</code>将获取该信息，然后寻找具有<code class="fe kx ky kz la b">/about</code>的<code class="fe kx ky kz la b">path</code>属性的<code class="fe kx ky kz la b">Route</code>组件。</p><p id="02f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将通过将<code class="fe kx ky kz la b">component</code>属性添加到<code class="fe kx ky kz la b">Route</code>来决定要呈现的内容。</p><p id="b17b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的示例中，一个<code class="fe kx ky kz la b">exact</code>属性被添加到默认的<code class="fe kx ky kz la b">Route</code>路径(<code class="fe kx ky kz la b">/</code>，因为如果没有它，任何带有<code class="fe kx ky kz la b">/</code>的路线也会呈现<code class="fe kx ky kz la b">Home</code>组件，导致导航不一致。</p><p id="8522" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三个组件<code class="fe kx ky kz la b">Link</code>用于导航，代替HTML的常规<code class="fe kx ky kz la b">&lt;a&gt;</code>标签。这是因为常规的HTML锚标记会在点击时完全刷新浏览器，这不适合React应用程序。React应用程序只需更新URL、浏览器历史和组件，无需刷新浏览器:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="df54" class="lj lk iq la b gy ll lm l ln lo">import { Link } from "react-router-dom";</span><span id="ab9e" class="lj lk iq la b gy lp lm l ln lo">class NavigationComponent extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;ul&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to="/"&gt;Home&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to="/about"&gt;About page&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>        &lt;/ul&gt;<br/>        &lt;hr /&gt;<br/>      &lt;/&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="a621" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以试试这里的工作演示。</p><p id="a231" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意如何使用浏览器导航栏的“上一页”和“下一页”按钮，url会随着后续导航更新，而无需加载浏览器。这就是React路由器的强大之处。</p><h1 id="2884" class="lq lk iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">制作动态路由</h1><p id="fc20" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">您已经看到了如何使用React路由器创建简单导航，但是大多数web应用程序需要比这更高级的功能。您可能需要一个动态路由，您可以在其中放置类似于<code class="fe kx ky kz la b">/user/:id</code>的东西，其中React需要根据<code class="fe kx ky kz la b">:id</code>的值呈现一些东西。</p><p id="df61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">旧链接也可能是死的，需要重定向到新的链接。</p><p id="d93a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，如果浏览器URL不匹配任何现有的路由，您需要显示404页面。</p><p id="cf90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是为什么你需要学习另外两个组件，<code class="fe kx ky kz la b">Switch</code>和<code class="fe kx ky kz la b">Redirect</code>。<code class="fe kx ky kz la b"><a class="ae kw" href="https://reacttraining.com/react-router/web/api/Switch" rel="noopener ugc nofollow" target="_blank">Switch</a></code>是一个独特的组件，它将渲染第一个匹配的<code class="fe kx ky kz la b">Route</code>，然后停止。为了说明这个例子:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="8f11" class="lj lk iq la b gy ll lm l ln lo">import { Route } from 'react-router'</span><span id="a1bd" class="lj lk iq la b gy lp lm l ln lo">&lt;Route path="/about" component={About}/&gt;<br/>&lt;Route path="/:user" component={User}/&gt;<br/>&lt;Route component={NoMatch}/&gt;</span></pre><p id="2040" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，一个浏览器URL<code class="fe kx ky kz la b">/about</code>将匹配所有三个路由，导致它们都被渲染并堆叠在彼此之下。现在通过使用<code class="fe kx ky kz la b">Switch</code>组件，React Router将渲染<code class="fe kx ky kz la b">About</code>组件路线，然后停止。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="7f41" class="lj lk iq la b gy ll lm l ln lo">import {Switch, Route} from 'react-router';</span><span id="de7d" class="lj lk iq la b gy lp lm l ln lo">&lt;Switch&gt;<br/>  &lt;Route path='/about' component={About} /&gt;<br/>  &lt;Route path='/:user' component={User} /&gt;<br/>  &lt;Route component={NoMatch} /&gt;<br/>&lt;/Switch&gt;;</span></pre><p id="2675" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">Switch</code>中的<code class="fe kx ky kz la b">Route</code>组件的顺序很重要，所以确保在用url参数和404 route声明路由之前先声明所有静态路由。</p><p id="e857" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在对于<code class="fe kx ky kz la b">Redirect</code>，组件非常简单。您只需要添加声明旧URL的<code class="fe kx ky kz la b">from</code>属性和指定要链接的新URL的<code class="fe kx ky kz la b">to</code>属性。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="5901" class="lj lk iq la b gy ll lm l ln lo">import {Redirect} from 'react-router';</span><span id="8adc" class="lj lk iq la b gy lp lm l ln lo">&lt;Redirect from='/old-match' to='/will-match' /&gt;;</span></pre><h1 id="7b86" class="lq lk iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">嵌套路由</h1><p id="63dc" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">为了创建嵌套的route，您需要在父组件中声明另一个<code class="fe kx ky kz la b">Route</code>。例如，假设您有<code class="fe kx ky kz la b">/users</code>将呈现给用户组件。</p><p id="36fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们做一个小练习。首先，创建一个存储用户数据的对象数组，如下所示:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="30fb" class="lj lk iq la b gy ll lm l ln lo">const users = [<br/>  {<br/>    id: '1',<br/>    name: 'Nathan',<br/>    role: 'Web Developer',<br/>  },<br/>  {<br/>    id: '2',<br/>    name: 'Johnson',<br/>    role: 'React Developer',<br/>  },<br/>  {<br/>    id: '3',<br/>    name: 'Alex',<br/>    role: 'Ruby Developer',<br/>  },<br/>];</span></pre><p id="c1a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在应用程序中创建一个简单的路由:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="4e7a" class="lj lk iq la b gy ll lm l ln lo">class RouterNavigationSample extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;Router&gt;<br/>        &lt;&gt;<br/>          &lt;NavigationComponent /&gt;<br/>          &lt;Route exact path='/' component={Home} /&gt;<br/>          &lt;Route path='/about' component={About} /&gt;<br/>          &lt;Route path='/users' component={Users} /&gt;<br/>        &lt;/&gt;<br/>      &lt;/Router&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="d1f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">NavigationComponent是您编写用于导航应用程序的<code class="fe kx ky kz la b">Link</code>组件的地方:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="6a64" class="lj lk iq la b gy ll lm l ln lo">class NavigationComponent extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;ul&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to='/'&gt;Home&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to='/about'&gt;About page&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to='/users'&gt;Users page&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>        &lt;/ul&gt;<br/>        &lt;hr /&gt;<br/>      &lt;/&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="3f03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是时候创建要在特定路线上呈现的组件了。<code class="fe kx ky kz la b">Home</code>和<code class="fe kx ky kz la b">About</code>组件将呈现一个div，而<code class="fe kx ky kz la b">Users</code>将有另一个<code class="fe kx ky kz la b">Link</code>和<code class="fe kx ky kz la b">Route</code>组件。</p><p id="2c73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Users组件中，您将呈现一个用户列表，通过ID将一个<em class="ms">嵌套路由</em>提供给单个用户，如<code class="fe kx ky kz la b">/users/:id</code>:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="a19e" class="lj lk iq la b gy ll lm l ln lo">const Home = () =&gt; {<br/>  return &lt;div&gt;This is the home page&lt;/div&gt;;<br/>};</span><span id="3cf0" class="lj lk iq la b gy lp lm l ln lo">const About = () =&gt; {<br/>  return &lt;div&gt;This is the about page&lt;/div&gt;;<br/>};</span><span id="88bb" class="lj lk iq la b gy lp lm l ln lo">const Users = () =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;ul&gt;<br/>        {users.map(({name, id}) =&gt; (<br/>          &lt;li key={id}&gt;<br/>            &lt;Link to={`/users/${id}`}&gt;{name}&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>      &lt;Route path='/users/:id' component={User} /&gt;<br/>      &lt;hr /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="f0b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码没有什么新内容。所以现在您可以编写<code class="fe kx ky kz la b">User</code>组件了:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="a8e2" class="lj lk iq la b gy ll lm l ln lo">const User = ({match}) =&gt; {<br/>  const user = users.find((user) =&gt; user.id === match.params.id);</span><span id="1f59" class="lj lk iq la b gy lp lm l ln lo">return (<br/>    &lt;div&gt;<br/>      Hello! I'm {user.name} and I'm a {user.role}<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="da92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在有一些我没告诉过你的新东西。每当一个组件被渲染到一个特定的路由中，该组件从React路由器接收路由属性。有3个路线道具被传入组件:<code class="fe kx ky kz la b">match</code>、<code class="fe kx ky kz la b">location</code>、<code class="fe kx ky kz la b">history</code>。</p><p id="394c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过打开React开发人员工具来查看props，并突出显示匹配的组件路径:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/28f936b603839191d3f3d169dbfec9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QMCvEPU7w_br40oj.png"/></div></div></figure><p id="a0c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(如果您从Codesandbox打开，您可以在一个新的单独窗口中打开演示以启用React DevTool)</p><p id="c321" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意如何在<code class="fe kx ky kz la b">Users</code>组件嵌套路由中添加<code class="fe kx ky kz la b">/:id</code> URL参数。这个id通过<code class="fe kx ky kz la b">match.params.id</code>对象属性传递给<code class="fe kx ky kz la b">User</code>组件。如果您将URL参数作为<code class="fe kx ky kz la b">/:userId</code>传递，它将作为<code class="fe kx ky kz la b">match.params.userId</code>传递。</p><p id="e188" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您已经了解了路由属性，让我们稍微重构一下<code class="fe kx ky kz la b">Users</code>组件:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="4a27" class="lj lk iq la b gy ll lm l ln lo">const Users = ({ match }) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;ul&gt;<br/>        {users.map(({ name, id }) =&gt; (<br/>          &lt;li key={id}&gt;<br/>            &lt;Link to={`${match.url}/${id}`}&gt;{name}&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>      &lt;Route path={`${match.url}/:id`} component={User} /&gt;<br/>      &lt;hr /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="8f57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一如既往，<a class="ae kw" href="https://codesandbox.io/s/nrm107nvxp" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个工作演示。</p><h1 id="ce55" class="lq lk iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">将属性传递给路由组件</h1><p id="c511" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">您可能认为将属性传递给Route组件与传递给regular组件是一样的:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="7256" class="lj lk iq la b gy ll lm l ln lo">&lt;Route path="/about" component={About} user='Jelly'/&gt;</span></pre><p id="3695" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，React Router不会将进入<code class="fe kx ky kz la b">Route</code>组件的道具转发到<code class="fe kx ky kz la b">component</code>道具中，所以你必须使用另一种方法。</p><p id="5a67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，React Router提供了一个<a class="ae kw" href="https://reacttraining.com/react-router/web/api/Route/render-func" rel="noopener ugc nofollow" target="_blank"> render </a>属性，该属性接受在URL位置匹配时调用的函数。该道具也接收与<code class="fe kx ky kz la b">component</code>道具相同的<code class="fe kx ky kz la b">route props</code>:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="db14" class="lj lk iq la b gy ll lm l ln lo">&lt;Route<br/>  path="/about"<br/>  render={props =&gt; &lt;About {...props} admin="Bean" /&gt;}<br/>/&gt;</span><span id="1551" class="lj lk iq la b gy lp lm l ln lo">// the component<br/>const About = props =&gt; {<br/>  return &lt;div&gt;This is the about page {props.admin}&lt;/div&gt;;<br/>};</span></pre><p id="04df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，您从React Router获取给定的<code class="fe kx ky kz la b">props</code>并将其传递给组件，以便组件可以在必要时使用<code class="fe kx ky kz la b">match</code>、<code class="fe kx ky kz la b">location</code>或<code class="fe kx ky kz la b">history</code>道具。然后你把你自己的额外道具加进去。上面的例子使用任意的<code class="fe kx ky kz la b">admin</code>道具作为例子。</p><p id="6c63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里可以看到完整的代码<a class="ae kw" href="https://codesandbox.io/s/2vrx41m6jn" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="f605" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你已经了解了React路由器，试着在你的React应用中实现它！</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="24c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你在努力学习React吗？ <a class="ae kw" href="https://sebhastian.com/react-distilled/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">本书</em> </a> <em class="ms">或许能帮到你！</em></p><p id="e023" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ms">最初发表于</em><a class="ae kw" href="https://sebhastian.com/react-router-introduction" rel="noopener ugc nofollow" target="_blank"><em class="ms">sebhastian.com</em></a><em class="ms">。</em></p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><figure class="lb lc ld le gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nb"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="nc nd gp gr ne nf"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">gitconnected.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt jw nf"/></div></div></a></div></div></div>    
</body>
</html>