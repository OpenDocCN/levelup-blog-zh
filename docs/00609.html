<html>
<head>
<title>Scala journals— data manipulation continued</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala期刊—数据操作(续)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-part-4-data-manipulation-continued-99622b13c14a?source=collection_archive---------1-----------------------#2019-06-01">https://levelup.gitconnected.com/scala-journals-part-4-data-manipulation-continued-99622b13c14a?source=collection_archive---------1-----------------------#2019-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ec4756ac9cf20f6fd2b2ca62f36baa26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6E_VPpj0EV66KKdEQrI4w.jpeg"/></div></div></figure><p id="6790" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将通过展示聚集/累积方法——折叠和减少来继续数据操作。在大数据的背景下，您可能听说过“映射并减少”，您已经知道什么是<code class="fe kz la lb lc b">map</code>，现在是时候了解一下<code class="fe kz la lb lc b">reduce</code>了。</p><p id="bd99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在之前的一篇文章中，我展示了<code class="fe kz la lb lc b">map</code>和<code class="fe kz la lb lc b">flatMap</code>——将函数应用于给定集合并返回该集合的两种方法。但是，如果我们想聚集或积累一些东西，而不一定要改变我们的收藏呢？换句话说，如果我们想要，例如，得到一个给定集合中所有整数的和，该怎么办？<code class="fe kz la lb lc b">fold</code>和<code class="fe kz la lb lc b">reduce</code>派上了用场。让我们开始吧。</p><h1 id="fc47" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">reduce和fold有什么区别？</h1><p id="c703" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">一个简单的答案是:<code class="fe kz la lb lc b">reduce</code>累加一个结果，<code class="fe kz la lb lc b">fold</code>用一个起始值累加一个结果。如果我们在一个列表上调用<code class="fe kz la lb lc b">reduce</code>,我们需要提供一个函数——这个函数将被计算前两个元素，这个结果将被用作下一次计算的第一个参数。调用<code class="fe kz la lb lc b">fold</code>是相同的，不同之处在于我们提供了一个起始值，该值将用于第一个元素的第一次评估。</p><p id="47fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用句子来解释有点复杂，所以在实践中看起来是这样的，请注意说明评估如何发生的注释:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="8410" class="mo le it lc b gy mp mq l mr ms">val list = List(1, 2, 3, 4, 5)<br/> <br/> list.reduce(_ + _) // 15<br/> // 1 + 2 (first and second element)<br/> // 3 + 3 (result of above + third element)<br/> // 6 + 4 (result of above + fourth element)<br/> // 10 + 5 (result of above + fifth (last) element)<br/> // 15<br/> <br/> list.fold(0)(_ + _) // 15<br/> // 0 + 1 (start value + first element)<br/> // 1 + 2 (result of above + second element)<br/> // 3 + 3 (result of above + third element)<br/> // 6 + 4 (result of above + fourth element)<br/> // 10 + 5 (result of above + fifth (last) element)<br/> // 15<br/> <br/> list.fold(1)(_ + _) // 16<br/> // 1 + 1 (start value + first element)<br/> // 2 + 2 (result of above + second element)<br/> // 4 + 3 (result of above + third element)<br/> // 7 + 4 (result of above + fourth element)<br/> // 11 + 5 (result of above + fifth (last) element)<br/> // 16</span></pre><p id="7f5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然，函数<code class="fe kz la lb lc b">_ + _</code>可以是对给定集合的两个元素有效的任何函数，这里是:对类型<code class="fe kz la lb lc b">Integer</code>的两个元素有效的任何函数。</p><p id="1d22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另外，提醒一下，<code class="fe kz la lb lc b">_ + _</code>是元组<code class="fe kz la lb lc b">(a, b) =&gt; a + b</code>上匿名函数的语法糖</p><h1 id="1966" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么时候减，什么时候折？</h1><p id="6d6c" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">知道何时持有，何时弃牌。</p><p id="5977" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我看到<code class="fe kz la lb lc b">reduce</code>旁边的<code class="fe kz la lb lc b">fold</code>时，我的前两个问题是:</p><ol class=""><li id="17dd" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">如果他们做几乎一样的事情，他们之间真正的区别是什么??我怎么知道什么时候用哪个？</li><li id="213e" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><strong class="kd iu">为什么我需要一个“起始值”？</strong></li></ol><p id="dc66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我试着解释一下。</p><p id="b0e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用一个简单的术语来回答第一个问题——当您的结果与集合中的元素类型相同时，使用<code class="fe kz la lb lc b">reduce</code>。例如:</p><ul class=""><li id="7d19" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nh mz na nb bi translated">得到一个<code class="fe kz la lb lc b">List[Int]</code>中所有元素的总和——结果将是<code class="fe kz la lb lc b">Int</code></li><li id="54a7" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nh mz na nb bi translated">获取一个<code class="fe kz la lb lc b">List[Int]</code>中所有元素的最大值——结果将是<code class="fe kz la lb lc b">Int</code></li></ul><p id="b7e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您的结果与集合中的元素类型不同时，或者如果您希望将一个起始值作为第一个元素传递时，请使用<code class="fe kz la lb lc b">fold</code>。例如:</p><ul class=""><li id="bcc2" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nh mz na nb bi translated">将整数列表转换为字符串。(<code class="fe kz la lb lc b">reduce</code>在这里不起作用，因为它期望最终结果是<code class="fe kz la lb lc b">Int</code>，而不是上面提到的<code class="fe kz la lb lc b">String</code>)</li></ul><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="0e94" class="mo le it lc b gy mp mq l mr ms">val list = List(1, 2, 3, 4, 5)<br/>list.fold("")(_.toString + _.toString) // "12345" (*)<br/>list.fold("0")(_.toString + _.toString) // "012345"</span></pre><p id="64a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至于关于“起始值”的第二个问题——正如你在上面看到的，在集合中它将被用来告诉编译器我们期望什么类型。如果我们将上面的内容改为:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="9d0c" class="mo le it lc b gy mp mq l mr ms">val list = List(1, 2, 3, 4, 5) <br/>list.fold(0)(_.toString + _.toString) <br/>// start value is Int but elements in the function are String. Start value type dictates the return type <br/>// error: type mismatch; found   : String // required: Int</span></pre><p id="4003" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…代码无法编译。</p><h1 id="7655" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">向左折叠和向右折叠</h1><p id="604f" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">无需深入细节，有两种<code class="fe kz la lb lc b">fold</code>变体:</p><p id="9f11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b"><strong class="kd iu">foldLeft</strong></code>从左到右“遍历”你的收藏，是<em class="ni">尾递归</em>和<code class="fe kz la lb lc b"><strong class="kd iu">foldRight</strong></code>从右到左“遍历”，是<em class="ni">头递归</em>。(还记得尾递归vs头递归吗？现在你知道<code class="fe kz la lb lc b">foldRight</code>可能会在一个大集合上爆炸！)</p><p id="ab75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">foldLeft</code>在实践中:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="87fe" class="mo le it lc b gy mp mq l mr ms">val list = List(1, 2, 3, 4, 5)<br/>list.foldLeft(0){ (a, b) =&gt; {<br/>    println(s"a ($a) + b ($b)")<br/>    a + b<br/>}} <br/><br/>// a (0) + b (1)<br/>// a (1) + b (2)<br/>// a (3) + b (3)<br/>// a (6) + b (4)<br/>// a (10) + b (5)<br/>// res19: Int = 15</span></pre><p id="9a0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">foldRight</code>在实践中:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="f44b" class="mo le it lc b gy mp mq l mr ms">val list = List(1, 2, 3, 4, 5)<br/>list.foldRight(0){ (a, b) =&gt; {<br/>    println(s"a ($a) + b ($b)")<br/>    a + b<br/>}} <br/><br/>// a (5) + b (0)<br/>// a (4) + b (5)<br/>// a (3) + b (9)<br/>// a (2) + b (12)<br/>// a (1) + b (14)<br/>// res20: Int = 15</span></pre><p id="5f79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以看到结果是一样的。现在花点时间想想如果我们的函数不是加法而是减法，结果会有什么不同——结果肯定会不同！此外，知道了头尾递归之间的区别，你能明白如何使用<code class="fe kz la lb lc b">foldLeft</code>来尝试并充分利用折叠会更有意义吗？</p><h1 id="0bfd" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">实际上，你多久使用一次？</h1><p id="06f6" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">尽你所能，这是一种快速、无痛苦的计算累积的方法，它可以用来以一种聪明、快捷的方式解决一些众所周知的问题。除了在集合上的工作，<code class="fe kz la lb lc b">fold</code>和<code class="fe kz la lb lc b">reduce</code>可以作为一种错误处理的形式，因为它可以取代模式匹配(更多关于错误处理的内容在另一篇文章中):</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="fcfe" class="mo le it lc b gy mp mq l mr ms">Some(12).fold(0)(_ + 10) // 22 None.fold(0)(_ + 10) // 0 List().fold(0)(_ * _) // 0</span></pre><p id="4166" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，你可以看到折叠一个<code class="fe kz la lb lc b">None</code>或一个空列表会导致“起始值”的返回。</p><p id="f4ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你也可以使用<code class="fe kz la lb lc b">fold</code>来变换<code class="fe kz la lb lc b">Either</code>，不管它是<code class="fe kz la lb lc b">Left</code>还是<code class="fe kz la lb lc b">Right</code>。<code class="fe kz la lb lc b">fold</code>在<code class="fe kz la lb lc b">Either</code>上的实现方式是模式匹配的捷径:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="5905" class="mo le it lc b gy mp mq l mr ms">val eitherRight: Either[String, Int] = Right(2) <br/>val eitherLeft: Either[String, Int] = Left("problem")  </span><span id="17f6" class="mo le it lc b gy nj mq l mr ms">eitherRight.fold(l =&gt; "left", r =&gt; r.toString) // "2" eitherLeft.fold(l =&gt; "left", r =&gt; r.toString) // "left"</span></pre><p id="a60b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">把上面的折叠想成“如果这是左的，那么计算我传递的第一个函数，但是如果这是右的，那么计算我传递的第二个函数”。</p><p id="fd27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里也有一些关于如何使用我今天解释的方法解决一些简单问题的想法，在你的头脑中把它们与不使用<code class="fe kz la lb lc b">fold</code>或<code class="fe kz la lb lc b">reduce</code>的解决方案进行比较。</p><h2 id="920f" class="mo le it bd lf nk nl dn lj nm nn dp ln km no np lr kq nq nr lv ku ns nt lz nu bi translated">从整数列表中获取最大值</h2><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="b07d" class="mo le it lc b gy mp mq l mr ms">val list = List(1, 2, 3, 4, 8) </span><span id="e5da" class="mo le it lc b gy nj mq l mr ms">list.reduce(_ max _)</span></pre><h2 id="a3fa" class="mo le it bd lf nk nl dn lj nm nn dp ln km no np lr kq nq nr lv ku ns nt lz nu bi translated">获得句子中最短的单词</h2><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="abc8" class="mo le it lc b gy mp mq l mr ms">val sentence = "Which word is the shortest?" </span><span id="bf71" class="mo le it lc b gy nj mq l mr ms">sentence.split(" ").reduce{<br/>   (one, two) =&gt; if (one.length &lt; two.length) one<br/>                 else two<br/>   }    // "is"</span></pre><h2 id="47d3" class="mo le it bd lf nk nl dn lj nm nn dp ln km no np lr kq nq nr lv ku ns nt lz nu bi translated">还原列表</h2><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="4d82" class="mo le it lc b gy mp mq l mr ms">val list = List("anna", "brad", "aga", "steve") </span><span id="9db4" class="mo le it lc b gy nj mq l mr ms">list.foldLeft(List[String]()){<br/>    (one, two) =&gt; two :: one<br/> } <br/>// List[String] = List(steve, aga, brad, anna)<!-- --> </span></pre><h1 id="d86e" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">最后一个音符</h1><p id="85b3" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">我怎么强调在小代码任务上练习都不为过，比如在<a class="ae nv" href="http://codewars.com" rel="noopener ugc nofollow" target="_blank">codewars.com</a>上练习，或者在<code class="fe kz la lb lc b">fold</code>和<code class="fe kz la lb lc b">reduce</code>上练习。这是思考问题的另一种方式——不用深入细节，我可以保证，随着时间的推移，你会发现它们是函数式编程中非常重要的概念。也就是说，有时你会注意到你可以用一个看起来更简单的图案来代替你的<code class="fe kz la lb lc b">fold</code>或<code class="fe kz la lb lc b">reduce</code>——然后这完全取决于你。就我自己而言，如果我的<code class="fe kz la lb lc b">fold</code>或<code class="fe kz la lb lc b">reduce</code>看起来过于复杂，我可能会选择看起来更简单的解决方案来提高可读性。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="6922" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ni"> (*)在这种情况下</em> <code class="fe kz la lb lc b"><em class="ni">"”</em></code> <em class="ni">是用于连接操作的字符串的标识元素。</em></p><p id="88b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ni">当identity元素通过操作与任何元素配对时，它返回该元素。</em></p><p id="2810" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ni">在实践中:对于整数的加法，因为1 + 0 = 1，所以恒等式为0。对于乘法来说是1，因为4 * 1 = 4。对于字符串来说，使用标识可能是一个有问题的选择，但是对于我们这个简单的例子来说，它是有效的。</em></p></div></div>    
</body>
</html>