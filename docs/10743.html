<html>
<head>
<title>Get GraqhQL Playground up and running in NextJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让GraqhQL Playground在NextJS中运行起来</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/get-graqhql-playground-up-and-running-in-nextjs-2da7a2105713?source=collection_archive---------6-----------------------#2022-01-07">https://levelup.gitconnected.com/get-graqhql-playground-up-and-running-in-nextjs-2da7a2105713?source=collection_archive---------6-----------------------#2022-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我最近开始涉足NextJS，我惊讶地发现，除了它对React组件和特性的常规包装之外，它还提供了对API开发的支持。在进入NextJS一周之前，它一直很棒，我已经对它为快速开发和测试所提供的东西感到兴奋。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="6c11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就理解其架构而言，NextJS非常简单。神奇之处在于<code class="fe ks kt ku kv b">pages</code>目录。该目录下的文件被映射为客户端或前端编译。在<code class="fe ks kt ku kv b">pages</code>目录中的<code class="fe ks kt ku kv b">api</code>目录保存了所有的服务器端代码。维护项目和编写一些次要的服务器端脚本变得非常容易。</p><p id="6e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想从一个查询我的scraper服务器的小项目开始。我认为最好从客户端的graphQL服务器开始，它将处理所有后端网络服务，这也将增加安全性，并提供对实际服务器的抽象。nextJS Github上的示例项目似乎不适合我。我深入研究了一个示例代码是如何引起问题的<strong class="jp ir">。</strong></p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="a82e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">调试</strong></p><p id="adda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自nextJS的样板文件在这里是<a class="ae kw" href="https://github.com/vercel/next.js/tree/canary/examples/api-routes-graphql" rel="noopener ugc nofollow" target="_blank"/>。这是非常基本的，看起来这里的代码应该工作。那问题是什么？</p><p id="0ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看这里的一部分代码，找出问题所在。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/0bdd81a9e882eec327ec9734761015bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzWrJ9CmyOOM4_EFIUAEPQ.png"/></div></div></figure><ol class=""><li id="00db" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">我们使用阿波罗服务器微包，它为我们提供了一个精简版的阿波罗服务器。这对于保持优化的应用包大小是有效的。</li><li id="4ebf" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe ks kt ku kv b">handler</code>函数是服务器的默认入口点函数。NextJS将对此进行解析，并用文件名创建一个路由。在这种情况下，这个文件被命名为<code class="fe ks kt ku kv b">graphql.js</code>。所以这里的路线是<code class="fe ks kt ku kv b">localhost:3000/graphql</code></li></ol><p id="794b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我试图运行这段代码时，您会看到graphQL服务器开始运转，但是请求失败了。现在让我们用Playground调试一下。根据最新的Apollo更新，GraphQL Playground作为一个独立的插件被转移。为了做到这一点，现在让我们看看修改后的代码，看看我们是如何包括操场的。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi lx"><img src="../Images/fbb76b692a62a9e22ee4eb12f073e0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEP0w6qT6dkeeDi5AB9xWg.png"/></div></div></figure><p id="8133" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对这段代码的一些补充。我们来分析一下。</p><ol class=""><li id="7be3" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">如前所述，插件被转移到阿波罗核心。我们从<code class="fe ks kt ku kv b">apollo-server-core</code>导入操场插件</li><li id="16e6" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">我们也从<code class="fe ks kt ku kv b">micro-cors</code>导入Cors。我们一会儿会谈到这个。</li><li id="6274" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">我们将插件定义添加到<code class="fe ks kt ku kv b">ApolloServer</code>的插件列表选项中。</li><li id="d9db" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">我们现在用在文件顶部创建的<code class="fe ks kt ku kv b">cors</code>函数包装整个处理程序。</li></ol><p id="33c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为什么是cors？</strong></p><p id="3bd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，Apollo Playground只将<code class="fe ks kt ku kv b">https://studio.apollographql.com</code>域列入白名单。当您在本地主机上运行playground时，服务器会拒绝请求。为了满足请求，我们使用cors函数包装服务器。这类似于在开发<code class="fe ks kt ku kv b">expressjs</code> web应用程序时使用<code class="fe ks kt ku kv b">cors</code>中间件。</p><p id="1aec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就对了，现在使用<code class="fe ks kt ku kv b">npm run dev</code>运行应用程序，在小路上看到操场。注意，我们已经改变了路径，它的<code class="fe ks kt ku kv b">/api/graphql</code></p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ly"><img src="../Images/ff6c91ce40ee713a29df6061e175eb77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VN_qJ7BbCEc93-eWcoWnw.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">本地主机上的GraphQL操场</figcaption></figure><p id="3db4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想马上使用样板文件，这里有<a class="ae kw" href="https://github.com/adityak74/nextjs-graphql-playground-boilerplate" rel="noopener ugc nofollow" target="_blank"> Github repo </a>。</p><div class="md me gp gr mf mg"><a href="https://github.com/adityak74/nextjs-graphql-playground-boilerplate" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">GitHub-adityak 74/nextjs-graph QL-playground-boilerplate</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">这是一个用create-next-app引导的Next.js项目。首先，运行开发服务器:打开…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">github.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu lh mg"/></div></div></a></div><p id="a084" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关注我更多这样有趣的文章，如果这有助于你，然后给它一个大胖子👏。</p></div></div>    
</body>
</html>