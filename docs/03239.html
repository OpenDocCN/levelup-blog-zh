<html>
<head>
<title>Node.js Best Practices — Security Attacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—安全攻击</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-best-practices-security-attacks-999a82fe5c36?source=collection_archive---------7-----------------------#2020-04-27">https://levelup.gitconnected.com/node-js-best-practices-security-attacks-999a82fe5c36?source=collection_archive---------7-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f8a6e66dac8d76d1188669145f0a452b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4qbpavKmzNlumQir"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0423" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js是编写应用程序的流行运行时。这些应用程序通常是许多人使用的生产质量应用程序。为了使维护它们变得更容易，我们必须为人们设定一些准则来遵循。</p><p id="d668" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解编写节点应用程序时需要注意的一些基本安全实践。</p><h1 id="5348" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用ORM/ODM库防止查询注入漏洞</h1><p id="3438" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该将用户输入的字符串直接传入我们的应用程序，以防止SQL或NoSQL注入攻击。在将输入传递给数据库查询之前，应该对其进行验证和清理。</p><p id="c6d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有著名的数据访问库，如Sequelize、Knex和Mongoose，都有针对脚本注入攻击的内置保护。</p><p id="c532" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不进行排序，未排序的字符串很容易破坏数据，并暴露给未授权方。</p><h1 id="1f23" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">通用安全最佳实践的集合</h1><p id="3169" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该与一般的安全最佳实践保持同步，以便在开发和运行应用程序时实施它们。</p><h1 id="143e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">调整HTTP响应头以增强安全性</h1><p id="4ab7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用像<code class="fe mh mi mj mk b">helmet</code>这样的模块来保护头部，以防止攻击使用常见的攻击，如跨站点脚本与我们的应用程序。</p><p id="d1ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了添加<code class="fe mh mi mj mk b">helmet</code>并使用它，我们运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="af95" class="mt lf it mk b gy mu mv l mw mx">npm i helmet</span></pre><p id="ae85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后按如下方式使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1fde" class="mt lf it mk b gy mu mv l mw mx">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const helmet = require('helmet');<br/>const app = express();<br/>app.use(helmet());</span><span id="cfad" class="mt lf it mk b gy my mv l mw mx">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="8007" class="mt lf it mk b gy my mv l mw mx">app.get('/', (req, res) =&gt; {<br/>  res.send('hello');<br/>});</span><span id="2bca" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="fc14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">头盔自动保护我们免受跨站点脚本，实现严格的传输安全，并防止客户端从响应中嗅探MIME类型。</p><p id="9f2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">X-Powered-By</code>头也被从响应中移除，这样攻击者就不会知道我们的应用是一个Express应用。</p><h1 id="c17d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不断自动检查易受攻击的依赖项</h1><p id="57eb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在投入生产之前，我们可以使用<code class="fe mh mi mj mk b">npm audit</code>或snyk来检查具有易受攻击的依赖项的包。否则，攻击者可能会利用这些漏洞实施攻击。</p><h1 id="98d6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免使用Node.js加密库来处理密码，请使用Bcrypt</h1><p id="57a5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">bcrypt</code>提供哈希和盐功能。因此，它比内置的加密库更适合处理秘密。也更快。</p><p id="2cd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不希望攻击者能够通过字典攻击来暴力破解密码和令牌。</p><h1 id="c3be" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">转义HTML、JS和CSS输出</h1><p id="5614" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该避开这些类型的代码，这样攻击就不能用我们的应用程序运行恶意的客户端代码。专用库可以明确地将数据标记为纯内容，永远不应该执行。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/5cd3aa7a58347c5ae844e33cc4f80a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TK7Q7tU_myNde62t"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@badshah05?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">侯赛因·巴德沙阿</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="5f21" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">验证传入的JSON模式</h1><p id="2bb8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">应该对JSON模式进行验证，以确保传入请求负载包含有效数据。例如，我们可以使用<code class="fe mh mi mj mk b">jsonschema</code>库来验证发送的JSON的结构和值。</p><p id="1b9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过快速应用程序使用<code class="fe mh mi mj mk b">jsonschema</code>库，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1c77" class="mt lf it mk b gy mu mv l mw mx">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const Validator = require('jsonschema').Validator;<br/>const v = new Validator();<br/>const app = express();</span><span id="13ef" class="mt lf it mk b gy my mv l mw mx">const addressSchema = {<br/>  "id": "/SimpleAddress",<br/>  "type": "object",<br/>  "properties": {<br/>    "address": { "type": "string" },<br/>  },<br/>  "required": ["address"]<br/>};</span><span id="7751" class="mt lf it mk b gy my mv l mw mx">const schema = {<br/>  "id": "/SimplePerson",<br/>  "type": "object",<br/>  "properties": {<br/>    "name": { "type": "string" },<br/>    "address": { "$ref": "/SimpleAddress" },<br/>  },<br/>  "required": ["name", "address"]<br/>};</span><span id="93b4" class="mt lf it mk b gy my mv l mw mx">v.addSchema(addressSchema, '/SimpleAddress');<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="85a5" class="mt lf it mk b gy my mv l mw mx">app.post('/person', (req, res) =&gt; {  <br/>  if (v.validate(req.body, schema).errors.length) {<br/>    return res.send(400)<br/>  }<br/>  res.send('success');<br/>});</span><span id="6bcb" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="83a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们需要<code class="fe mh mi mj mk b">jsonschema</code>库并使用它的验证器。然后我们定义了被<code class="fe mh mi mj mk b">/SimplePerson</code>模式引用的<code class="fe mh mi mj mk b">/SimpleAddress</code>模式。</p><p id="f070" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用以下内容添加了<code class="fe mh mi mj mk b">/SimpleAddress</code>模式:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="21b2" class="mt lf it mk b gy mu mv l mw mx">v.addSchema(addressSchema, '/SimpleAddress');</span></pre><p id="cd14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">/SimplePerson</code>中引用。</p><p id="b779" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以根据我们的模式检查我们的请求体:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8699" class="mt lf it mk b gy mu mv l mw mx">v.validate(req.body, schema).errors.length</span></pre><p id="0eae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果请求体验证失败，我们就停止请求的处理。</p><h1 id="01b8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">支持将jwt列入黑名单</h1><p id="86f8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">用于恶意用户活动的JSON Web令牌(jwt)应该被撤销。因此，我们的应用程序需要一种方法来撤销这些令牌。</p><h1 id="384d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="8189" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该通过检查漏洞和撤销用于恶意目的的令牌来保护我们的应用程序。此外，我们需要采取措施，通过净化任何地方的数据来防止恶意软件在客户端和服务器端运行。</p><p id="e259" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们应该验证请求体，以确保有效的数据被提交到我们的应用程序。</p></div></div>    
</body>
</html>