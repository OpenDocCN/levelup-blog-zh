<html>
<head>
<title>An Elegant Way to Mock DateTime.Now in Your C# Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种模仿日期时间的优雅方式。现在，在您的C#应用程序中</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-elegant-way-to-mock-datetime-now-in-your-c-application-a81e59e62836?source=collection_archive---------3-----------------------#2022-05-12">https://levelup.gitconnected.com/an-elegant-way-to-mock-datetime-now-in-your-c-application-a81e59e62836?source=collection_archive---------3-----------------------#2022-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1834" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你武器库中的另一种编码技术。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6967c6af69a55e6889b28d5042d9ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D3AM_fbHUF_DkoQN"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sonjalangford?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sonja Langford </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的一篇<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/5-ways-to-mock-datetime-now-for-unit-testing-in-c-bf0438eab032">文章</a>中，我展示了5种模拟<code class="fe lv lw lx ly b">DateTime.Now</code>属性进行单元测试的方法，其中4种基于不同的包装类。今天我们将探索另一种在测试中使用委托模仿<code class="fe lv lw lx ly b">DateTime</code>的技术。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3cdc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">有什么问题？</h1><p id="c1c4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在开始探索解决方案之前，让我们快速回忆一下通过在应用程序代码中直接使用<code class="fe lv lw lx ly b">DateTime.Now</code>可以得到的所有问题。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="dcfe" class="nh mh it ly b gy ni nj l nk nl">public class Service<br/>{<br/>    private readonly ILogger&lt;Service&gt; _logger;</span><span id="ae0b" class="nh mh it ly b gy nm nj l nk nl">    public Service(ILogger&lt;Service&gt; logger)<br/>        =&gt; _logger = logger;</span><span id="f6bd" class="nh mh it ly b gy nm nj l nk nl">    public void LogNow()<br/>    {<br/>        _logger.LogInformation($"Current time is {<strong class="ly iu">DateTime.Now</strong>}");<br/>    }<br/>}</span></pre><p id="c3db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用程序的不同地方直接使用<code class="fe lv lw lx ly b">DateTime.Now</code>或<code class="fe lv lw lx ly b">DateTime.UtcNow</code>属性有几个缺点:</p><ul class=""><li id="ef26" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">当从代码中的不同位置直接调用这些属性时，开发人员无法快速地将整个应用程序从<code class="fe lv lw lx ly b">DateTime.Now</code>切换到<code class="fe lv lw lx ly b">DateTime.UtcNow</code>，反之亦然。</li><li id="2dfe" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">在上面的例子中，<code class="fe lv lw lx ly b">DateTime</code>对象是<code class="fe lv lw lx ly b">Service</code>类的隐式依赖。这意味着开发人员需要从上到下查看该类的整个代码，以了解该类是否使用了<code class="fe lv lw lx ly b">DateTime</code>。另一方面，<code class="fe lv lw lx ly b">ILogger&lt;Service&gt;</code>是一个显式依赖(注入到构造函数中)，这要容易揭示得多。</li><li id="4f9b" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果不使用第三方库，比如<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/5-ways-to-mock-datetime-now-for-unit-testing-in-c-bf0438eab032"> Pose </a>，那么<code class="fe lv lw lx ly b">DateTime.Now</code>不能简单地在单元测试中被模仿。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e5ff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">解决方法是什么？</h1><p id="3873" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">DateTime.Now</code>上面描述的问题可以通过实现你自己的包装类或者使用第三方库来解决，正如我在这里<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/5-ways-to-mock-datetime-now-for-unit-testing-in-c-bf0438eab032">所描述的</a>。但是我们可以走得更远，使用委托以更少的努力实现相同的目标。</p><p id="fabe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要定义一个返回<code class="fe lv lw lx ly b">DateTime</code>类型且不带参数的委托:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="659a" class="nh mh it ly b gy ni nj l nk nl">public delegate DateTime <strong class="ly iu">CurrentTime</strong>();</span></pre><p id="b1cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是在依赖注入容器中为我们的委托注册一个lambda表达式。lambda表达式应该根据您的需要返回一个<code class="fe lv lw lx ly b">DateTime.Now</code>到<code class="fe lv lw lx ly b">DateTime.UtcNow</code>的实例:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4815" class="nh mh it ly b gy ni nj l nk nl">builder.Services.AddSingleton&lt;<strong class="ly iu">CurrentTime</strong>&gt;(() =&gt; <strong class="ly iu">DateTime.Now</strong>);</span></pre><p id="92a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万事俱备，开始在应用服务中注入<code class="fe lv lw lx ly b">CurrentTime</code>实例并使用它:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="89a9" class="nh mh it ly b gy ni nj l nk nl">public class Service<br/>{<br/>    private readonly <strong class="ly iu">CurrentTime _currentTime</strong>;<br/>    private readonly ILogger&lt;Service&gt; _logger;</span><span id="1c3b" class="nh mh it ly b gy nm nj l nk nl">    public Service(<strong class="ly iu">CurrentTime currentTime</strong>, ILogger&lt;Service&gt; logger)<br/>    {<br/>        <strong class="ly iu">_currentTime = currentTime;</strong><br/>        _logger = logger;<br/>    }</span><span id="d6ab" class="nh mh it ly b gy nm nj l nk nl">    public void LogNow()<br/>    {<br/>        _logger.LogInformation($"Current time is {_<strong class="ly iu">currentTime()</strong>}");<br/>    }<br/>}</span></pre><p id="0b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们分析一下管理<code class="fe lv lw lx ly b">DateTime.Now</code>属性的基于委托的方法的优缺点。</p><h2 id="9bf2" class="nh mh it bd mi ob oc dn mm od oe dp mq li of og ms lm oh oi mu lq oj ok mw ol bi translated">优点:</h2><ul class=""><li id="72ae" class="nn no it lb b lc my lf mz li om lm on lq oo lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">CurrentTime</code>委托是一个显式依赖，因为它被注入到类构造函数中。</li><li id="5a98" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">要将整个应用程序从<code class="fe lv lw lx ly b">DateTime.Now</code>切换到<code class="fe lv lw lx ly b">DateTime.UtcNow</code>，只需要在一个地方修改lambda表达式。</li><li id="1ea6" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">在单元测试中，可以用返回预定义时间戳的lambda表达式轻松模拟<code class="fe lv lw lx ly b">CurrentTime</code>委托。</li></ul><h2 id="52d9" class="nh mh it bd mi ob oc dn mm od oe dp mq li of og ms lm oh oi mu lq oj ok mw ol bi translated">缺点:</h2><ul class=""><li id="c30b" class="nn no it lb b lc my lf mz li om lm on lq oo lu ns nt nu nv bi translated">现在可以在应用程序中混合使用这两种方法——使用<code class="fe lv lw lx ly b">CurrentTime</code>,在某些情况下仍然可以直接调用<code class="fe lv lw lx ly b">DateTime.Now</code>属性。为了确保只使用<code class="fe lv lw lx ly b">CurrentTime</code>，开发人员应该在代码审查清单中描述该规则，或者/和用新的定制规则扩展静态代码分析器。</li></ul><p id="eb59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="7761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你所读到的，看看下面这个故事:</p><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/top-misconceptions-about-dependency-injection-in-asp-net-core-c6a7afd14eb4"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">ASP.NET核心中关于依赖注入的主要误解</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">这甚至会导致错误。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>