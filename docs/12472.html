<html>
<head>
<title>NgRx Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NgRx解释道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ngrx-explained-3891da35eeea?source=collection_archive---------3-----------------------#2022-06-13">https://levelup.gitconnected.com/ngrx-explained-3891da35eeea?source=collection_archive---------3-----------------------#2022-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/776c220fff4230cb76b717be470652b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jy5YjwMi66J4ZIr1.png"/></div></div></figure><p id="b76a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多时候，当我们的角度应用程序增长时，我们的代码变得很难理解。我们有多个组件，引用无数的服务，我们需要创建各种通道，以便在子组件和父组件之间传递数据。这使得我们所谓的用户界面前端应用程序被逻辑污染，代码变得更加难以理解。</p><p id="949e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像IT解决方案一样，将所有数据的管理外包给一个框架是很自然的事情。这样做，我们不再将任何服务直接注入到我们的组件中，并且我们不会仅仅为了传递数据而在我们的父子组件之间创建不必要的事件发射器和输入。相反，我们只是关注我们的UI中需要什么，当我们需要数据时，我们只是引用框架。因此，我们有效地将“后端”部分从前端应用程序中分离出来。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/905e433c5248dd9829931b9d7dbb3788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qZhQs7KHu8TSHixQ.png"/></div></div></figure><p id="3d29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这代表了我们开发前端应用程序的模式转变。我们没有让单个组件管理它们自己的数据，而是将整个应用程序中所有组件所需的所有数据组合起来，通过一个<code class="fe lb lc ld le b">store</code>引用。我们称这些数据为<code class="fe lb lc ld le b">state</code>。</p><p id="6a05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个用angular编写的简单CRUD应用程序来管理书籍，它应该在一个表格中显示书籍列表，并且当用户想要创建新书或更新任何现有书籍时，它应该显示一个弹出窗口来显示书籍的详细信息。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lf"><img src="../Images/b0dfb7570e6d595df8b127be9cce632f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9JNa7s9BzBCwem-d.png"/></div></div></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lf"><img src="../Images/c0c38ba087c0fc3549fbaf4b2bd02b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s3H7A8z3yM9FhZmb.png"/></div></div></figure><p id="2bf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过运行<code class="fe lb lc ld le b">npm install @ngrx/store --save</code>将ngrx添加到应用程序中。</p><p id="fdfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们做的第一步是定义我们的状态，我们将需要哪些数据，以及它们各自的数据类型。它就像我们前端应用程序的<code class="fe lb lc ld le b">database</code>。所以我们创建一个名为<code class="fe lb lc ld le b">state</code>的文件夹，并在新创建的文件夹中创建一个新文件<code class="fe lb lc ld le b">books.state.ts</code>。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="fff8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和所有数据库一样，我们不直接访问数据，但是我们创建getter方法来访问<code class="fe lb lc ld le b">state</code>。为了确保我们的组件总是拥有最新的<code class="fe lb lc ld le b">state</code>，而不是静态的getter方法，我们创建了<code class="fe lb lc ld le b">selectors</code>来返回各个状态的<code class="fe lb lc ld le b"><a class="ae li" href="https://rxjs.dev/guide/observable" rel="noopener ugc nofollow" target="_blank">Observables</a></code>，并让我们的组件订阅它。通过这种方式，<code class="fe lb lc ld le b">state</code>变更将自动更新到我们的组件中，并且它们可以相应地对其做出反应。因此创建了一个新的<code class="fe lb lc ld le b">books.selector.ts</code>来合并选择器。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="2940" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ngrx提供了<code class="fe lb lc ld le b">createFeatureSelector</code>方法来帮助我们通过名称和泛型参数类型直接选择状态。这就是为什么我们在一个<code class="fe lb lc ld le b">AppState</code>下创建了实际的状态<code class="fe lb lc ld le b">bookStore</code>，这样我们就可以选择一个名称。<code class="fe lb lc ld le b">createSelector</code>方法在第一个参数中接受其他选择器，然后最后一个参数接受一个方法，该方法将使用传入的选择器到达较低层次中的状态。尽管示例中没有，但是请注意，如果您的选择器依赖于多个选择器来确定要获得哪个状态，那么您可以在参数中传递多达8个选择器。</p><p id="8f9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从不使用setter方法直接更新<code class="fe lb lc ld le b">state</code>。相反，<code class="fe lb lc ld le b">state</code>只会基于某些规定的事件而改变。所以我们有<code class="fe lb lc ld le b">actions</code>来定义可能发生的事件。然后我们有<code class="fe lb lc ld le b">reducers</code>，它定义了应用程序的初始状态，以及状态将如何根据发生的动作和动作发生前的状态而改变。</p><p id="becc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">动作由一个字符串标识，它的有效负载将被传递给reducer。Ngrx提供了<code class="fe lb lc ld le b">createAction</code>方法，该方法接受动作的标识字符串，以及泛型参数中有效负载的数据类型。和往常一样，创建一个<code class="fe lb lc ld le b">books.actions.ts</code>来合并操作。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="1736" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给定动作和当前状态，Reducers是返回新状态的纯函数。所以为了有一个状态来处理，它需要一个在ngrx提供的<code class="fe lb lc ld le b">createReducer</code>方法的第一个参数中定义的初始状态。然后是每个动作的后续<code class="fe lb lc ld le b">on</code>方法。然后会创建一个<code class="fe lb lc ld le b">books.reducer.ts</code>。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="536a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，这只会降低<code class="fe lb lc ld le b">bookStore</code>状态，而不会降低最高级别<code class="fe lb lc ld le b">AppState</code>。因此，如果在此<code class="fe lb lc ld le b">bookStore</code>的同一级别有其他状态，则可以创建不同的reducer文件。这有助于保持代码的整洁和易读。那么问题来了——<code class="fe lb lc ld le b">how then do we map the reducer to the state?</code>。当我们导入StoreModule - <code class="fe lb lc ld le b">StoreModule.forRoot({bookStore: booksReducer})</code>时，我们在<code class="fe lb lc ld le b">forRoot</code>中添加链接。所以这个模块看起来会像这样。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="53f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要注意，并不是所有的动作都有一个缩减器，例如，<code class="fe lb lc ld le b">loadBooks</code>动作就缺少一个缩减器。这是因为缩减器的目的仅仅是更新状态，如果动作不改变状态，就不需要缩减器。</p><p id="8768" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，您可能已经注意到缺少了一些东西，我们在哪里调用我们的服务来获取、更新、创建、删除数据呢？这将由副作用来处理。是的，副作用！因为无论何时发生任何事情，我们的reducer都应该提供最新的状态，并且我们有订阅它的组件，所以我们不能在reducer中运行异步流程。这就是为什么我们分别有一个<code class="fe lb lc ld le b">loadData</code>和一个<code class="fe lb lc ld le b">dataLoaded</code>动作。就像我们如何定义每个动作的缩减器一样，我们也可以定义基于哪个动作被触发而运行的副作用。这些副作用将处理异步作业来调用服务，当作业完成时，它将触发另一个动作。然后新动作的缩减器可以再次更新状态。</p><p id="f233" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要有副作用，需要和<code class="fe lb lc ld le b">npm install @ngrx/effects --save</code>分开安装。像往常一样，我们创造了<code class="fe lb lc ld le b">books.effects.ts</code>。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="efa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们为效果导入了一个新的模块，我们需要将它添加到ngModule的<code class="fe lb lc ld le b">imports</code>数组中，并且我们必须在forRoot - <code class="fe lb lc ld le b">EffectsModule.forRoot([BooksEffects])</code>中传递效果类的列表。所以我们更新后的模块会变成这样。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="33b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经为我们的部分创建了所有的后端，现在让我们来看看如何使用它。首先，我们需要将<code class="fe lb lc ld le b">@ngrx\store</code>导入到我们的组件中，并将其注入到构造函数中。</p><pre class="kx ky kz la gt lj le lk ll aw lm bi"><span id="a247" class="ln lo iq le b gy lp lq l lr ls">import {Store} from "@ngrx/store";</span><span id="dafa" class="ln lo iq le b gy lt lq l lr ls">constructor(private store: Store) {<br/>}</span></pre><p id="c6a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们在<code class="fe lb lc ld le b">ngOnInit</code>中订阅组件中需要的所有选择器。注意，我们使用<code class="fe lb lc ld le b">this.store.select(&lt;selector&gt;)</code>来引用我们之前创建的选择器。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="cd85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有什么被触发，比如当点击add按钮时，我们不发出事件或处理逻辑，而是简单地调用<code class="fe lb lc ld le b">this.store.dispatch(&lt;action&gt;)</code>来触发动作。</p><pre class="kx ky kz la gt lj le lk ll aw lm bi"><span id="b286" class="ln lo iq le b gy lp lq l lr ls">addBook(): void {<br/>  this.store.dispatch(BookStoreActions.newBook())<br/>}</span></pre><p id="3cff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果动作是用有效负载定义的，我们只需在动作的参数中传递数据。</p><pre class="kx ky kz la gt lj le lk ll aw lm bi"><span id="1ea9" class="ln lo iq le b gy lp lq l lr ls">showBook(book: Book): void {<br/>  this.store.dispatch(BookStoreActions.showBook({book}))<br/>}</span></pre><p id="815b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，当动作被触发时，reducer更新状态，因为我们已经通过选择器订阅了状态更改，所以只要有状态更改，我们的组件就会被更新。从<code class="fe lb lc ld le b">Selector.showDetail</code>的订阅中可以看出，当<code class="fe lb lc ld le b">showDetail</code>状态改变时，应用程序将运行<code class="fe lb lc ld le b">showPopup()</code>或<code class="fe lb lc ld le b">dismissPopup()</code>。</p><p id="f328" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序的数据流在视觉上也是如此。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/6daac0dadb7009067d264dec054b279c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WlAfiTpZvwqC1mwH.png"/></div></div></figure><p id="7093" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文中描述的示例应用程序可以在https://github.com/thecodinganalyst/bookstore的<a class="ae li" href="https://github.com/thecodinganalyst/bookstore" rel="noopener ugc nofollow" target="_blank">上获得。</a></p><p id="d758" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lv">本文原载于</em><a class="ae li" href="https://thecodinganalyst.github.io/knowledgebase/ngrx-explained/" rel="noopener ugc nofollow" target="_blank"><em class="lv">https://the coding analyst . github . io/knowledge base/ngrx-explained/</em></a></p></div></div>    
</body>
</html>