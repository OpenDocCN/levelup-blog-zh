<html>
<head>
<title>Creating a Modular Waypoint System for AI in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Unity中为AI创建一个模块化的航点系统</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-modular-waypoint-system-for-ai-in-unity-78ecc1c567d2?source=collection_archive---------13-----------------------#2021-08-24">https://levelup.gitconnected.com/creating-a-modular-waypoint-system-for-ai-in-unity-78ecc1c567d2?source=collection_archive---------13-----------------------#2021-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/59663620f6ed4d4ac7b61a4aed8bb171.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*NNsii8qsjO8GCRmrARlaHQ.gif"/></div></figure><p id="dd8e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们的游戏中，我们有3个守卫可以偷偷溜过去。目前他们是静止的，让我们写一个模块化的脚本来创建巡逻路线。</p><p id="8c3d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">给我们的每个守卫增加<strong class="jw ir">导航代理组件</strong>，将允许他们像玩家穿越<strong class="jw ir">设定的目的地一样穿越环境。</strong>不同之处在于，它们不会离开用户输入。</p><p id="f4f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了创建“路点”，我们可以创建空的<strong class="jw ir">游戏对象</strong>，并将它们的<strong class="jw ir">变换</strong>存储在一个<strong class="jw ir">列表中。</strong>每个保护对象现在可以包含不同大小的<strong class="jw ir">列表</strong>和各种空的<strong class="jw ir">变换</strong>目标，或者根本没有。<strong class="jw ir"> </strong>我们使用一个<strong class="jw ir">列表</strong>而不是一个<strong class="jw ir">数组</strong>来给我们机会在需要的时候通过代码动态地更新路点。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ks"><img src="../Images/339aea694d3f650bca5ad3bb19dacc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iG8TZ-Gx_UqsCIqxyKvdgg.png"/></div></div></figure><p id="c1a0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着每个守卫和他们各自的路点的建立，我们也可以创建一个<strong class="jw ir">动画树</strong>，类似于<strong class="jw ir">玩家的</strong>，在<strong class="jw ir">空闲</strong>和<strong class="jw ir">行走之间通过<strong class="jw ir"> bool </strong>设置过渡。</strong></p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lb"><img src="../Images/c7f837cc44641213d1972ab7c6ed2d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djnIlORun0zJgWpfEhSAGw.png"/></div></div></figure><p id="ce47" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在说说代码。我们首先需要引用我们的<strong class="jw ir"> NavMeshAgent </strong>和我们的<strong class="jw ir"> Animator。</strong>然后在<strong class="jw ir">更新中，</strong>我连续调用一个名为<strong class="jw ir"> WayPointMovement的方法。</strong></p><p id="3a81" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在该方法中，我们首先需要检查航路点列表<strong class="jw ir">是否包含任何转换。这可以防止警卫出现任何错误，因为他们可能还没有航路点，或者只是保持静止。</strong></p><p id="e381" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们有一个<strong class="jw ir"> int </strong>值，存储我们当前想要访问的<strong class="jw ir">列表</strong>的编号，如果这是访问一个存在的<strong class="jw ir">转换</strong>，我们可以<strong class="jw ir">将目的地</strong>设置为那个<strong class="jw ir">转换。</strong>然后我们也可以设置<strong class="jw ir">动画师行走布尔</strong>为真。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lc"><img src="../Images/ee3a54caad106c748ee533ccd6814106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V93SzRASDlb60aF5s7gYAg.png"/></div></div></figure><p id="018d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了检测何时到达目的地，我们可以使用<strong class="jw ir"> Vector3模仿我们的<strong class="jw ir">玩家代码</strong>。距离</strong></p><p id="f8c1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果距离小于1个单位，我们可以停止<strong class="jw ir">导航代理</strong>，然后启动一个<strong class="jw ir">协同程序</strong>以在选择下一个目标之前启用一些空闲时间。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lc"><img src="../Images/75d4ff700a74fa6f3c1675df49542aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcSymJHgDBhgXV7KzRekCQ.png"/></div></div></figure><p id="9c9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个<strong class="jw ir">协程</strong>中，我们可以将target reached bool设置为true，以防止上面的代码多次调用它。接下来，我们将<strong class="jw ir"> Walk bool </strong>设置为false。</p><p id="70e7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我只希望我的守卫在第一个和最后一个航路点空闲，因此，我们可以在等待随机的秒数之前检查是否有这种情况。接下来，我们调用一个方法来<strong class="jw ir">设置</strong><strong class="jw ir">的下一个目标。</strong></p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lc"><img src="../Images/d11001364b7151bf42d1c3c2891f32a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55-iu2CYapdBImzSdViHfA.png"/></div></div></figure><p id="68a9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了设置下一个目标，我们需要能够双向遍历<strong class="jw ir">列表</strong>，因此，可以使用名为reverse的bool来检查和设置方向。我们根据这个布尔值来增加或减少<strong class="jw ir">列表</strong>的<strong class="jw ir"> int值</strong>。然后，我们做一个检查，看看我们是在开始还是结束，并翻转布尔。</p><p id="5733" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们可以将<strong class="jw ir">目标达成布尔</strong>设置为假，以便让<strong class="jw ir">距离计算</strong>和<strong class="jw ir">空闲协程</strong>重新运行，并另外将<strong class="jw ir">导航代理</strong>的<strong class="jw ir">停止</strong>功能设置为假。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lc"><img src="../Images/91145e8a575b38049025c3e23e92cc23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqnZeZxqwu5U-6gU5Fy27g.png"/></div></div></figure><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lb"><img src="../Images/7a63a51b939913aa8f4bc3e0ba520294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TthKopRZ9UbjBaUUwlGVVg.gif"/></div></div></figure><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lb"><img src="../Images/bf1e8ac43a0227f5584f5e7c427908bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3oTpvcE9OAaP9NDEhsZlUw.gif"/></div></div></figure></div></div>    
</body>
</html>