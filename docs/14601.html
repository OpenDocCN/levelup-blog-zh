<html>
<head>
<title>Declarative RxJS with Custom Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有自定义运算符的声明性RxJS</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/declarative-rxjs-with-custom-operators-2d1892bb1b4b?source=collection_archive---------1-----------------------#2022-12-11">https://levelup.gitconnected.com/declarative-rxjs-with-custom-operators-2d1892bb1b4b?source=collection_archive---------1-----------------------#2022-12-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/32d04690ac9df4b9330458a675e5cf1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdiF04r1PZS_YF34o7bHhQ.png"/></div></div></figure><p id="5185" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，当需要大量管道操作符时，RxJS流会变得有点混乱和不可读。这种不可读取性的一个原因是这些RxJS流的命令性。因此，通过使用自定义操作符使它们成为声明性的，会使您的流更加清晰易读。</p><p id="9d36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文原帖<a class="ae kz" href="http://ng-journal.com" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">ng-journal.com</strong>T3】</a></p><div class="la lb gp gr lc ld"><a href="https://ng-journal.com/blog/2022-12-12-declarative-rxjs/" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">带有自定义运算符的声明性RxJS</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">通常，当需要大量管道操作符时，RxJS流会变得有点混乱和不可读。…的一个原因</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">ng-journal.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jz ld"/></div></div></a></div><h1 id="4010" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">声明式编程与命令式编程</h1><p id="21b6" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">不一定专门针对Angular或Typescript，关于声明式编程与命令式编程的讨论是所有编程语言的普遍讨论。其核心是让代码更自然地可读，缺点是提取更多的代码。一般来说，声明式方法被认为更简洁，因为它可读性更好。它基本上通过函数提取隐藏了许多底层细节，并定义了非常明确和易读的函数名。</p><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="0153" class="ne lt it na b be nf ng l nh ni">// Imperative<br/><br/>const arr = [1, 2, 3, 4, 5, 6];<br/>const even = [];<br/><br/>for (const item of arr) {<br/>  if (item % 2 === 0) {<br/>    even.push(item);<br/>  }<br/>}<br/><br/>console.log(even); // 2, 4, 6</span></pre><pre class="nj mz na nb bn nc nd bi"><span id="2638" class="ne lt it na b be nf ng l nh ni">// Declarative<br/><br/>const arr = [1, 2, 3, 4, 5, 6];<br/><br/>const even = arr.filter(item =&gt; isEven(item));<br/><br/>console.log(even); // 2, 4, 6<br/><br/>function isEven(value: number): boolean {<br/>  return value % 2 === 0;<br/>}</span></pre><p id="8167" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个例子都是完全有效且可执行的代码，但后者在可读性方面更好，因为它将许多低级功能提取到具有显式命名的不同函数中。但是这个概念怎么翻译成RxJS呢？所有RxJS代码本质上不都是声明性的吗？是的，但也不是…</p><p id="3f23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用管道操作符，并以任意顺序将它们链接起来，这本身就是声明性的，但是当在操作符中添加更多的逻辑时，它往往更具有命令性。为了防止命令式范式，我们可以创建自定义管道操作符，并将逻辑提取到其中。</p><h1 id="2227" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">自定义管道操作符</h1><p id="0a49" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">编写自定义操作符比人们想象的要容易得多。最简单的算子就是得到一个可观测值并返回一个可观测值的函数。因此，我们可以简单地返回传递的可观察值，然后通过管道传递并添加一些操作符。但更准确地说，我们应该写一个高阶函数，它返回一个函数，然后这个函数得到一个可观测值，并返回一个新的可观测值。这一句话包含了很多意思，但不要担心，因为下面的代码会对此做更好的解释:</p><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="2e26" class="ne lt it na b be nf ng l nh ni">export function log&lt;T&gt;(): (source$: Observable&lt;T&gt;) =&gt; Observable&lt;T&gt; {<br/>  return (source$) =&gt; source$.pipe(tap(console.log));<br/>}</span></pre><p id="1cda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用泛型，这样就不会通过我们的自定义管道操作符改变类型。然后我们返回一个匿名函数来获取source$，它基本上只是外部的可观察对象，然后返回它的一个管道。</p><h1 id="7fee" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">例子</h1><p id="2658" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">这个例子包含了一个表单控件，用户可以在其中输入计算数字的命令。这样的命令可能如下所示:</p><ul class=""><li id="3c5d" class="nk nl it kd b ke kf ki kj km nm kq nn ku no ky np nq nr ns bi translated">添加，1，2，3，4</li><li id="85f1" class="nk nl it kd b ke nt ki nu km nv kq nw ku nx ky np nq nr ns bi translated">减去，1，1，1，2</li><li id="cbb5" class="nk nl it kd b ke nt ki nu km nv kq nw ku nx ky np nq nr ns bi translated">相乘，3，4，5</li></ul><p id="943d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在重构之前，result$ stream非常大，在一个地方包含了所有的逻辑。因此，不仔细看就不容易开始阅读。重构之后，result$ stream更具声明性，因为自定义管道操作符隐藏了实现细节，只告诉它们的名字，操作符在做什么。因此，直接阅读很简单，无需处理底层实现细节。</p><h1 id="f3f4" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">一.以前</h1><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="8937" class="ne lt it na b be nf ng l nh ni">result$ = this.control.valueChanges.pipe(<br/>  debounceTime(800),<br/>  distinctUntilChanged(),<br/>  filter((v): v is string =&gt; !!v &amp;&amp; typeof v === 'string'),<br/>  map((v) =&gt; v.split(',')),<br/>  filter((v) =&gt; v.length &gt;= 1),<br/>  map((v) =&gt; {<br/>    if (v[0] === 'add') {<br/>      return v<br/>        .slice(1)<br/>        .map((v) =&gt; +v)<br/>        .reduce((acc: number, current: number) =&gt; {<br/>          return acc + current;<br/>        }, 0);<br/>    } else if (v[0] === 'subtract') {<br/>      return v<br/>        .slice(1)<br/>        .map((v) =&gt; +v)<br/>        .reduce((acc: number, current: number) =&gt; {<br/>          return acc - current;<br/>        }, 0);<br/>    } else if (v[0] === 'multiply') {<br/>      return v<br/>        .slice(1)<br/>        .map((v) =&gt; +v)<br/>        .reduce((acc: number, current: number) =&gt; {<br/>          return acc * current;<br/>        }, 1);<br/>    }<br/>    return null;<br/>  })<br/>);</span></pre><h1 id="ebdc" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">二。在...之后</h1><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="c08f" class="ne lt it na b be nf ng l nh ni">import {<br/>  assertNumber,<br/>  assertString,<br/>  command,<br/>  lookAhead,<br/>  split,<br/>} from './custom-operators';<br/><br/>[...]<br/><br/>result$ = this.control.valueChanges.pipe(<br/>  lookAhead(),<br/>  assertString(),<br/>  split(),<br/>  command(),<br/>  assertNumber()<br/>);</span></pre><pre class="nj mz na nb bn nc nd bi"><span id="40f5" class="ne lt it na b be nf ng l nh ni">export function lookAhead&lt;T&gt;(): (source$: Observable&lt;T&gt;) =&gt; Observable&lt;T&gt; {<br/>    return (source$) =&gt; source$.pipe(debounceTime(800), distinctUntilChanged());<br/>  }<br/>  <br/>  export function assertString(): (<br/>    source$: Observable&lt;unknown&gt;<br/>  ) =&gt; Observable&lt;string&gt; {<br/>    return (source$) =&gt;<br/>      source$.pipe(<br/>        filter((value): value is string =&gt; !!value &amp;&amp; typeof value === 'string')<br/>      );<br/>  }<br/>  <br/>  export function assertNumber(): (<br/>    source$: Observable&lt;unknown&gt;<br/>  ) =&gt; Observable&lt;number&gt; {<br/>    return (source$) =&gt;<br/>      source$.pipe(<br/>        filter((value): value is number =&gt; !!value &amp;&amp; typeof value === 'number')<br/>      );<br/>  }<br/>  <br/>  export function split(): (source$: Observable&lt;string&gt;) =&gt; Observable&lt;string[]&gt; {<br/>    return (source$) =&gt;<br/>      source$.pipe(<br/>        map((v) =&gt; v.split(',')),<br/>        filter((v) =&gt; v.length &gt;= 1)<br/>      );<br/>  }<br/>  <br/>  export function command(): (<br/>    source$: Observable&lt;string[]&gt;<br/>  ) =&gt; Observable&lt;number | null&gt; {<br/>    return (source$) =&gt;<br/>      source$.pipe(<br/>        map((v) =&gt; {<br/>          if (v[0] === 'add') {<br/>            return v<br/>              .slice(1)<br/>              .map((v) =&gt; +v)<br/>              .reduce((acc: number, current: number) =&gt; {<br/>                return acc + current;<br/>              }, 0);<br/>          } else if (v[0] === 'subtract') {<br/>            return v<br/>              .slice(1)<br/>              .map((v) =&gt; +v)<br/>              .reduce((acc: number, current: number) =&gt; {<br/>                return acc - current;<br/>              }, 0);<br/>          } else if (v[0] === 'multiply') {<br/>            return v<br/>              .slice(1)<br/>              .map((v) =&gt; +v)<br/>              .reduce((acc: number, current: number) =&gt; {<br/>                return acc * current;<br/>              }, 1);<br/>          }<br/>          return null;<br/>        })<br/>      );<br/>  }<br/></span></pre><h1 id="066a" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">GitHub知识库</h1><p id="3c6e" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">您可以在页面底部找到GitHub Repo链接:</p><div class="la lb gp gr lc ld"><a href="https://ng-journal.com/blog/2022-12-12-declarative-rxjs/" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">带有自定义运算符的声明性RxJS</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">通常，当需要大量管道操作符时，RxJS流会变得有点混乱和不可读。…的一个原因</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">ng-journal.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jz ld"/></div></div></a></div><h1 id="fa88" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">谢谢你🤗</h1><p id="ce42" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">感谢您阅读本文！我希望你喜欢它，并能学到一些新的和有趣的东西。如果你还有任何问题，请不要犹豫，通过<a class="ae kz" href="https://twitter.com/StefanvHaas" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae kz" href="https://www.linkedin.com/in/stefan-haas-686a921b4/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我进行讨论。</p><div class="la lb gp gr lc ld"><a href="https://medium.com/@stefan.haas.privat/membership" rel="noopener follow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">通过我的推荐链接-斯特凡·哈斯加入媒体</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">阅读斯特凡·哈斯的每一个故事(以及媒体上成千上万的其他作家)。您的会员费直接支持…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">medium.com</p></div></div><div class="lm l"><div class="ny l lo lp lq lm lr jz ld"/></div></div></a></div></div></div>    
</body>
</html>