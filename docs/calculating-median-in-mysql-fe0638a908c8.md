# 在 MySQL 中计算中位数

> 原文：<https://levelup.gitconnected.com/calculating-median-in-mysql-fe0638a908c8>

![](img/cee9f1dad1fa4853ea6695868fc41e7e.png)

照片由[hello queue](https://unsplash.com/@helloquence?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在网上磨砺我的 SQL 技能时，有人让我用蛮力(my SQL)计算 MySQL 表中一列的中值。通常情况下，我会将这些数据放入熊猫，然后很快完成，但我认为这个挑战会很有趣，也很有启发性。不出所料，的确如此，而且我在这个过程中学到了一些有趣的东西，这些东西对那些想提高自己技能的人来说很有用！

## 中位数

我们先来概述一下中值的逻辑。为了找到一组数字的中间值，我们必须:

1.  对数组进行排序。
2.  找出数组中间项的值。

第二步。可以通过两种方式之一进行:

1.  如果数组包含奇数个项目，中值就是中间值。
2.  如果数组包含偶数个项目，则中位数是中间两个值的平均值。

我们以某种聪明的方式使用上面的定义来解决这个问题。我在 [EverSQL](https://www.eversql.com/how-to-calculate-median-value-in-mysql-using-a-simple-sql-query/) 上找到了一个解决方案，我将对其进行调整并详细分解，因为当我第一次通读他们的解决方案时，我感到非常困惑。

## 设置

我有一个 AWS MySQL RDS 实例，它有一个名为`google_maps`的数据库，其中存储了`trips`表。在`trips`中有一个名为`trip_duration`的列，它以整数形式存储以分钟为单位的旅行时间。我要去查询`trip_duration`的中位数。

# 解决方案 1

这里是第一个解决方案。它可以用几种不同的方式编写，但是我选择使用 CTE ( `WITH/AS`语法)来分隔子查询，以提高可读性。请看:

解决方案 1

记住，我们使用上面的逻辑作为解决这个问题的框架。

1.  生成一个添加了行索引的排序数组，以跟踪数组的长度(第 1-10 行)。
2.  从数组的中间两个元素返回平均行程持续时间(代码的其余部分)。如果数组的长度是偶数，我们对两个中间的索引取平均值。如果数组的长度是奇数，那么中间的两个指数实际上是相等的，所以两者的平均值就是中间值本身。

如果您很好地理解了代码，那么我向您致敬，并建议您跳到下一个解决方案。这个特殊的解决方案花了我一段时间来完全理解，所以我想提出另一个更详细的解释。

首先，在第 1 行中，我们定义了变量`@rowindex`,该变量将用于为每一行分配一个升序整数。

接下来，第 3–10 行包含一个子查询，该子查询返回排序后的升序数据，行索引伴随每个旅行持续时间。细分一下，我们知道数据是按照`ORDER BY trip_duration`子句排序的。我们还知道，由于第 1 行的原因，`@rowindex`从-1 开始。第 5 行告诉我们，第一个(也是由于排序而最小的)旅行持续时间被分配了一个索引

```
@rowindex + 1 
= -1 + 1
= 0
```

从而使列`rowindex`从 0 开始。由于第 5 行，每个后续行的索引增加 1。我们最终得到一个旅行持续时间的排序数组，每个数组都有一个唯一的行索引。整个子查询被打包到别名`i`中，以便在下一段代码中引用，并增加可读性。

到最后一点。第 13-18 行是奇迹发生的地方。在 13–16 中，我们从子查询`i`的结果中查询平均行程持续时间。然而，我们在 17-18 中增加了约束条件，即我们只取与具有中间两个指数的条目相对应的平均行程持续时间。此时，`@rowindex`等于从`i`获得的最高索引。因此，如果我们做`@rowindex / 2`的下限和上限划分，那么我们应该能够考虑所有的可能性。让我们看两个例子来说明这一点。

## **示例 1 —偶数个元素**

考虑这样一种情况，我们有偶数个数据点，比如 10 个。这意味着`@rowindex`将是 9，因为第一个索引是 0。为了找到中间值，我们需要第 5 和第 6 个元素的平均值，这将是`@rowindex in (4, 5)`的旅行持续时间。为了对此进行编码，我们利用了`CEIL`和`FLOOR`函数:

```
CEIL(@rowindex/2) = 5
FLOOR(@rowindex/2) = 4
```

现在，回头看看 13-18。我们取旅行持续时间的平均值，其中行索引在(4，5)中。正是我们想要的！

## **示例 2 —奇数个元素**

现在让我们考虑另一种选择。我们有奇数个数据点，比如说 9 个。这意味着`@rowindex`将是 8，因为第一个索引是 0。中间值是第 5 个元素，意味着我们需要`rowindex = 4`的旅行持续时间。这意味着上限和下限划分将产生相同的结果。

```
CEIL(@rowindex/2) = FLOOR(@rowindex/2) = 4
```

因此，我们的`WHERE`子句将遵循`i.rowindex IN (4, 4)`的 constriant，这在本质上与说`rowindex = 4`相同。这也正是我们想要的。

对**解决方案 1** 的说明到此结束。如果您仍然有疑问，我强烈建议您修改代码以适合您自己的表，并查看每个查询的结果。让我们转向另一个可能的解决方案。

# 解决方案 2

同样，有多种方式来写出这一切。我选择了我认为最清晰的。

解决方案 2

这个解决方案中的概念与第一个类似，主要区别是我使用窗口函数`ROW_NUMBER()`来生成索引。下面是一般性的概述，再次供参考，虽然这段代码的主要区别在于步骤 1。

1.  生成一个添加了行索引的排序数组，以跟踪数组的长度(第 1–11 行)。
2.  从数组的中间两个元素返回平均行程持续时间(代码的其余部分)。

首先，在第 1–4 行中，我们创建了变量`@rowindex`,它存储了数组+ 1 的长度。这是因为`ROW_NUMBER()`的工作方式，我将在下面解释。

7–11 中的子查询使用`ROW_NUMBER()`窗口函数为排序后的数组生成行索引。这个`rowindex`列和解决方案 1 中的唯一区别是，现在我们的索引从 1 开始。这就是为什么`@rowindex`需要是数组的长度+ 1！如果你需要复习一下`ROW_NUMBER()`是如何工作的，看看我关于窗口功能的[帖子](https://medium.com/@marcosanchezayala/how-and-when-to-use-mysql-window-functions-910635f7c83d)。

第 14-19 行与解决方案 1 中的相同，所以如果您是第一次加入，请检查该解释！

# 我学到了什么

这是一个将子查询与用户定义的变量结合起来的有趣练习。到目前为止，我实际上从未使用用户定义的变量运行过任何查询！当我第一次看到解决方案 1 的修改版本时，我真的很困惑，因为我不明白`@rowindex`是如何在主查询中操作的。我猜 EverSQL 上的解释假设您理解了这段代码，但我并不理解。

为了解决这个问题，我重写了代码以适应`trips`表。然后，我只是处理了查询的每一部分，一次只运行一小部分来理解每一行。一旦我掌握了所有的概念，我立即想到用`ROW_NUMBER()`代替解决方案 1 中的方法来尝试索引。这让我想到了解决方案 2！

总的来说，这是一次愉快的学习经历，我相信在 MySQL 中有更多的方法来计算中位数。你有其他的解决方法吗？你能想出更好或更有效的方法让我写代码吗？请在评论中告诉我！