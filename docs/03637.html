<html>
<head>
<title>Good Parts of JavaScript — Recursion and Scope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的优点——递归和作用域</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/good-parts-of-javascript-recursion-and-scope-c7a462a6f94?source=collection_archive---------3-----------------------#2020-05-20">https://levelup.gitconnected.com/good-parts-of-javascript-recursion-and-scope-c7a462a6f94?source=collection_archive---------3-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3a0da3138d7170e6d57fe81edf9ae442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uv2IUtgFMAL69eOB"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@shotaspot?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Frank Albrecht </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="b45c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是世界上最流行的编程语言之一。它可以做很多事情，并且有一些领先于许多其他语言的功能。</p><p id="d034" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究函数调用本身的方法和函数的作用域。</p><h1 id="5ff4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">递归</h1><p id="054d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">递归函数是调用自身的函数。</p><p id="455d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用它把一个问题分成一组子问题，每个子问题都有一个简单的解决方案。</p><p id="48b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以创建如下递归函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="aca3" class="mq lf it mm b gy mr ms l mt mu">const count = (i) =&gt; {<br/>  if (i === 10) {<br/>    return;<br/>  }<br/>  console.log(i);<br/>  count(i + 1);<br/>}</span><span id="ccdc" class="mq lf it mm b gy mv ms l mt mu">count(0);</span></pre><p id="ccbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个简单的递归函数，它在<code class="fe mw mx my mm b">i</code>达到10时停止。</p><p id="fd7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe mw mx my mm b">i</code>的每个值，我们将<code class="fe mw mx my mm b">i</code>的值记录到控制台。</p><p id="adae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该确保我们有一个基本情况来停止函数。</p><p id="520f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果函数返回递归运行自身的结果，JavaScript不会通过用循环替换它来优化它。</p><p id="6324" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8f13" class="mq lf it mm b gy mr ms l mt mu">const factorial = (i, a = 1) =&gt; {<br/>  if (i &lt; 2) {<br/>    return a;<br/>  }<br/>  return factorial(i - 1, a * i)<br/>}</span><span id="5d53" class="mq lf it mm b gy mv ms l mt mu">const result = factorial(10);</span></pre><p id="71fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后JavaScript会把它变成一个循环，所以如果我们调用它太多次，调用堆栈就会满了。</p><h1 id="8f05" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">范围</h1><p id="e247" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">编程语言中的作用域控制变量和参数的可见性。</p><p id="ac2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，我们有一个函数和块范围的变量。</p><p id="893e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">let</code>和<code class="fe mw mx my mm b">const</code>是块范围的，<code class="fe mw mx my mm b">var</code>是函数范围的。</p><p id="6beb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，为了减少混乱，我们应该使用<code class="fe mw mx my mm b">let</code>和<code class="fe mw mx my mm b">const</code>来声明数据。</p><p id="a6d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c4f9" class="mq lf it mm b gy mr ms l mt mu">if (condition) {<br/>  let x = 1;<br/>  const y = 2;<br/>  //...<br/>}</span></pre><p id="0d0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">x</code>和<code class="fe mw mx my mm b">y</code>是块范围的，所以它们只在<code class="fe mw mx my mm b">if</code>块中可用。</p><p id="cf85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该忘记<code class="fe mw mx my mm b">var</code>，只使用<code class="fe mw mx my mm b">let</code>或<code class="fe mw mx my mm b">const</code>。</p><p id="54ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量应该尽可能晚地声明，这样它们的生命周期就很短。</p><p id="9549" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这减少了我们在阅读代码时在许多行代码中使用变量的需要。</p><h1 id="4494" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">关闭</h1><p id="a33d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">内部函数可以访问函数中定义的参数和变量。</p><p id="4693" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以利用这一点使值私有，并在内部函数中使用它们。</p><p id="67a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9269" class="mq lf it mm b gy mr ms l mt mu">const obj = (() =&gt; {<br/>  let value = 0;<br/>  return {<br/>    increment(val) {<br/>      value += val;<br/>    },<br/>    getValue() {<br/>      return value;<br/>    }<br/>  };<br/>})();</span></pre><p id="28d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">value</code>是私有的，所以我们可以通过增加<code class="fe mw mx my mm b">val</code>来更新<code class="fe mw mx my mm b">value</code>。</p><p id="d874" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们安全地更新了<code class="fe mw mx my mm b">value</code>而没有暴露给外界。</p><p id="6e32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在上面使用了一个生命，我们可以返回一个使用私有变量的对象。</p><p id="3062" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以通过去掉括号把它变成一个工厂函数。</p><p id="3928" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="847f" class="mq lf it mm b gy mr ms l mt mu">const createName = (name) =&gt; {<br/>  return {<br/>    getName() {<br/>      return name;<br/>    }<br/>  };<br/>};</span><span id="9f4e" class="mq lf it mm b gy mv ms l mt mu">const name = createName('foo').getName();</span></pre><p id="82b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们返回一个返回参数<code class="fe mw mx my mm b">name</code>值的对象。</p><p id="31dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它不是一个构造函数，所以我们不能将它与<code class="fe mw mx my mm b">new</code>操作符一起使用。</p><p id="caf0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">内部函数可以访问变量本身，而不是变量产生时的值。</p><p id="c087" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b0f3" class="mq lf it mm b gy mr ms l mt mu">const addHandlers = (nodes) =&gt; {<br/>  for (var i = 0; i &lt; nodes.length; i += 1) {<br/>    nodes[i].onclick = () =&gt; {<br/>      alert(i);<br/>    }<br/>  }<br/>}</span><span id="9811" class="mq lf it mm b gy mv ms l mt mu">addHandlers(document.querySelectorAll('button'))</span></pre><p id="6d2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，无论我们点击哪个按钮，警告框总是显示3。</p><p id="378f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为在创建函数时，循环体是针对变量<code class="fe mw mx my mm b">i</code>而不是变量<code class="fe mw mx my mm b">i</code>的。</p><p id="2b04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，我们可以用<code class="fe mw mx my mm b">let</code>代替<code class="fe mw mx my mm b">var</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ffea" class="mq lf it mm b gy mr ms l mt mu">const addHandlers = (nodes) =&gt; {<br/>  for (let i = 0; i &lt; nodes.length; i += 1) {<br/>    nodes[i].onclick = () =&gt; {<br/>      alert(i);<br/>    }<br/>  }<br/>}</span><span id="559b" class="mq lf it mm b gy mv ms l mt mu">addHandlers(document.querySelectorAll('button'))</span></pre><p id="c635" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">let</code>是块范围的，因此当循环结束时，<code class="fe mw mx my mm b">onclick</code>处理程序将获得<code class="fe mw mx my mm b">i</code>的当前值，而不是<code class="fe mw mx my mm b">i</code>的值。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/12498cc7c72e69fcbeecf236cf4dfab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kUBYmZRm9Iv3kakC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@reo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Emre Gencer </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="34ed" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="38fb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">递归函数是直接或间接调用自身的函数。</p><p id="2c57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这有助于将问题分成琐碎的子问题。</p><p id="6cf1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量的范围取决于我们如何声明它们。如果我们用<code class="fe mw mx my mm b">let</code>或<code class="fe mw mx my mm b">const</code>来声明它们，那么它们就是块范围的。</p><p id="90c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们用<code class="fe mw mx my mm b">var</code>声明它们，那么它们就是函数范围的。</p><p id="a58c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">闭包允许我们访问私有变量。</p></div></div>    
</body>
</html>