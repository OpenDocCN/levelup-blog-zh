# 异步 Javascript 第 3 部分:回调队列

> 原文：<https://levelup.gitconnected.com/asynchronous-javascript-part-3-85390632dd1a>

*本文是关于异步 Javascript 的四篇系列文章的第 3 部分。我强烈推荐您阅读第一部分* *和第二部分*[](https://medium.com/@kabir4691/asynchronous-javascript-part-2-26ac20fc5ad7)**，以便从本文中获得最大收益。**

*![](img/bbbab6fc99628470add15052bb51d73c.png)*

*在之前的文章中，我们已经讨论了 Javascript 的单线程执行和调用堆栈的工作方式。我们了解了 Javascript 中同步函数的执行方式。在本文中，我们实际上将开始研究异步函数是如何操作的，以及在 Javascript 中是如何按照执行顺序放置的。*

*当我们被要求想到 Javascript 中最简单的异步函数之一时，大多数人会想到内置`setTimeout`函数。让我们看一个简单的例子*

*上述代码在 1000 毫秒(1 秒)的延迟后将“Hello”打印到控制台上。听起来很简单，对吧？现在让我们稍微修改一下代码。*

*以上代码将在延迟 0 秒后在控制台上打印“Hello”。这意味着它会立即打印出来。我们在`setTimeout`函数后添加一些代码怎么样？*

*上面的代码应该打印出“Hello”然后打印出“World”吧？从我们已经看到的调用堆栈来看，第 1 行的`setTimeout`函数应该首先进入调用堆栈，然后是第 5 行的 *console.log* 函数。但是让我们看看实际的产量*

```
*Output:
World
Hello* 
```

*我们看到“世界”印在“你好”之前。这意味着第 5 行的控制台语句在`setTimeout`函数之前执行。这怎么可能呢？这是可能的，因为`setTimeout`函数从未进入调用堆栈。只有第 5 行的 *console.log* 语句被发送到调用堆栈并被执行。*

*但是我们看到`setTimeout`函数最终也被执行了。这是因为`setTimeout`函数被传递给了 Javascript 中称为**回调队列**的东西。*

# *回调队列*

*在我们研究回调队列之前，让我们了解一些关于`setTimeout`函数的事情。我们需要知道的第一件事是`setTimeout`不是 Javascript 的一部分。它不在 ECMAScript 规范中，也不是 Javascript 引擎的一部分。这个功能实际上是由运行 Javascript 的 web 浏览器提供的。更准确地说，它是浏览器中`window`对象的一部分。因此，`setTimeout`函数将在浏览器上正常运行，但不能在其他类似于节点的 Javascript 环境中运行。还有其他功能，比如`setTimeout`，它是浏览器的一部分，但不是 Javascript 本身，比如`console`(打印日志)、`document`(访问 HTML 元素)、`localStorage`(允许在浏览器内存中保存键/值对)等等。*

*当像`setTimeout`这样的异步函数被调用时，它不会被添加到调用堆栈中。而是被添加到回调队列中。回调队列，顾名思义，就是队列。因此，添加到其中的功能按照[先进先出](https://www.geeksforgeeks.org/fifo-first-in-first-out-approach-in-programming/)的顺序进行处理。当 Javascript 中的事件循环被触发时，它首先检查调用堆栈以查看它是否非空。如果是，它执行堆栈顶部的函数。但是，如果发现调用堆栈为空，程序会继续执行。一旦程序结束，事件循环被触发，通常，它首先检查调用堆栈，看它是否为非空。如果不是，它就从栈顶开始一个接一个地执行函数。一旦调用堆栈为空，事件循环就会检查回调队列，看它是否也为非空。如果是，那么它就从队列头开始逐个执行队列中的函数。请记住，回调队列中的函数只有在*

1.  *我们已经到达了节目的结尾*
2.  *调用堆栈中没有要执行的函数*

*起初，上面的流程听起来可能有点难以理解。让我们借助一个例子来更好地理解它。*

*在上面的代码中，我们创建了一个函数 *blockThreadFor1Sec。*让我们假设它包含一些运行时间大约为 1 秒的代码，例如循环了十亿次的 for 循环。当循环结束时，该函数会在控制台上显示“1 秒已过”。*

*在程序开始时，调用堆栈和回调队列都是空的。让我们也注意一下每一步的时间戳。目前，它为 0 毫秒*

```
*Timestamp: 0 ms|               |
|               |
|               |
|               |
|               |
|_______________|

   Call stack|               |
|               |  
|               |
|               |
|               |
|               |

  Callback queue*
```

*在第 1 行，程序只定义了函数 *block1Second* 。然后程序运行到第 6 行，假设我们的时间戳是 1 ms(这不是准确的时间戳，只是为了简单起见取的一个粗略的值)。程序调用`setTimeout`函数，由于它是一个异步函数，Javascript 将这个函数放入回调队列。*

```
*Timestamp: 1 ms|               |
|               |
|               |
|               |
|               |
|_______________|

   Call stack|               |
|               |  
|               |
|               |
| setTimeout()  |
|               |

  Callback queue*
```

*当触发事件循环时，它会看到调用堆栈为空。然后，它查看回调队列，发现它不是空的，头部有`setTimeout`函数。但是它不会立即执行它，因为该函数被设置为仅在延迟 1000 毫秒后执行。因此，在我们的示例中，该函数仅在时间戳为(1 + 1000) = 1001 毫秒时执行。因此，setTimeout 函数中的代码还没有被调用。*

*然后程序移动到第 10 行，在这一点上，假设我们的时间戳是 2 ms。调用了 *block1Second* 函数，因为它是一个普通的同步函数，所以它被添加到调用堆栈中。*

```
*Timestamp: 2 ms|               |
|               |
|               |
|               |
| block1Second()|
|_______________|

   Call stack|               |
|               |  
|               |
|               |    Scheduled to
| setTimeout()  | -> execute at
|               |    1001 ms

  Callback queue*
```

*当事件循环被触发时，它看到调用堆栈是非空的。因此，它执行堆栈顶部的函数，即 *block1Second* 。这个函数大约需要 1 秒或 1000 毫秒来执行。因此，当它的执行完成时，我们应该在时间戳(2 + 1000) = 1002 毫秒。*

*这就是事情变得有趣的地方。正如我们之前看到的，`setTimeout`函数被安排在 1001 毫秒的时间戳执行。因此，当事件循环在 1001 毫秒的时间戳被触发时，回调队列中的`setTimeout`函数还没有被调用，因为上面提到的条件#2 需要首先满足。即调用堆栈需要为空。当 *block1Second* 函数执行完毕并从调用堆栈中移除时，调用堆栈仅在 1002 ms 时变空。*

*现在让我们看看在时间戳为 1002 ms 时发生了什么。 *block1Second* 函数执行完毕，控制台上会显示“1 second elapsed”并从调用堆栈中删除该函数。*

```
*Timestamp: 1002 ms|               |
|               |
|               |
|               |
|               |
|_______________|

   Call stack|               |
|               |  
|               |
|               |    Scheduled to
| setTimeout()  | -> execute at
|               |    1001 ms

  Callback queue*
```

*既然调用堆栈是空的，人们可能会认为`setTimeout`函数已经准备好在下一次触发事件循环时被调用。然而，情况并非如此，因为上述条件#1 没有被满足。也就是说，我们还没有到达节目的结尾。因此，程序继续执行，而不执行`setTimeout`功能。*

*在第 12 行，我们的时间戳是 1003 毫秒。程序调用了 *console.log* 语句，该语句被添加到调用堆栈中，因为它是同步的。*

```
*Timestamp: 1003 ms|               |
|               |
|               |
|               |
| console.log() |
|_______________|

   Call stack|               |
|               |  
|               |
|               |    Scheduled to
| setTimeout()  | -> execute at
|               |    1001 ms

  Callback queue*
```

*当事件循环被触发时，它看到调用堆栈对于单个函数是非空的。因此， *console.log* 函数被执行(它将“世界”打印到控制台上),然后从调用堆栈中移除。我们现在已经到达了程序的末尾，时间戳是 1004 毫秒。*

```
*Timestamp: 1004 ms|               |
|               |
|               |
|               |
|               |
|_______________|

   Call stack|               |
|               |  
|               |
|               |    Scheduled to
| setTimeout()  | -> execute at
|               |    1001 ms

  Callback queue*
```

*当事件循环现在被触发时，它看到调用堆栈是空的。它还看到程序已经结束。现在两个条件都满足了，事件循环终于准备好移动到回调队列，从那里开始执行函数。它看到回调队列是非空的。因此，它执行队列头的函数，也就是我们的`setTimeout`函数。该函数在控制台上打印“Hello ”,之后该函数到达其执行终点，并从回调队列中移除。*

```
*Timestamp: 1005 ms|               |
|               |
|               |
|               |
|               |
|_______________|

   Call stack|               |
|               |  
|               |
|               |
|               |
|               |

  Callback queue*
```

*当事件循环再次被触发时，它看到调用堆栈是空的，程序已经到达其结尾，回调队列也是空的。因此，该程序最终被终止。*

*我们还需要学习一个异步 Javascript 的概念，它处理承诺和微任务队列。我们将在本系列的最后一篇[文章](https://medium.com/@kabir4691/asynchronous-javascript-part-4-promises-6bc04d5acd0c)中了解它。*