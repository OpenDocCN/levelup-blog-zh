<html>
<head>
<title>GraphQL with Go — server with signups, logins and data subscriptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL with Go —具有注册、登录和数据订阅功能的服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-with-go-simple-server-tutorial-8678dbba20b9?source=collection_archive---------2-----------------------#2020-05-06">https://levelup.gitconnected.com/graphql-with-go-simple-server-tutorial-8678dbba20b9?source=collection_archive---------2-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/eefe011872c0af87defb0bfcf007680f.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*vzYIMVLp579pUCvs7xhyvg.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk translated">https://github.com/graph-gophers/graphql-go<a class="ae jc" href="https://github.com/graph-gophers/graphql-go" rel="noopener ugc nofollow" target="_blank">的标志</a></figcaption></figure><div class=""/><p id="bd56" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">NodeJS中有一个关于GraphQL入门的<a class="ae jc" href="https://www.howtographql.com/graphql-js/0-introduction/" rel="noopener ugc nofollow" target="_blank">优秀教程</a>，但是Go入门可能会比较棘手。有一些GraphQL实现，但是没有很多指导。因此，在本文中，我们将创建一个(几乎)与上面的NodeJS教程相同的服务器，但是使用Go。</p><p id="a844" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Go中有许多GraphQL实现:出于可读性考虑，我将选择<a class="ae jc" href="https://github.com/graph-gophers/graphql-go" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="a442" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">本教程不会是盲目的复制粘贴跟随；它更像是一系列带注释的片段。在我们进行的过程中，请随意将您的代码分成文件和包。</p><p id="7159" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">必备知识:</strong>了解这些Go概念:结构、结构上的方法、指针和通道(用于订阅)。以及如何在你的go项目中安装和使用其他包。浏览一下GraphQL查询和模式语言也会有所帮助。</p><h2 id="3fb6" class="la lb jf bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">使用查询和突变读取和写入数据</h2><p id="0b71" class="pw-post-body-paragraph kc kd jf ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz im bi translated">从以下项目结构开始:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="834b" class="la lb jf md b gy mh mi l mj mk">hackernews-go/<br/>  main.go<br/>  schema.graphql</span></pre><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="de58" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这是模式；它显示了我们服务器上所有端点的签名。我们服务器唯一的工作就是执行！</p><p id="fabb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在我们从一个查询开始，它返回一个消息字符串。这个模式语言的语法可以在这里<a class="ae jc" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">看到</a>。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="1b48" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">所有解析器(实现模式中声明的操作的Go函数)都是这个<code class="fe mn mo mp md b">RootResolver</code>结构的方法。</p><p id="5336" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe mn mo mp md b">Info()</code>函数对应于模式中的<code class="fe mn mo mp md b">info</code>查询。名称必须与模式中的内容相匹配，不区分大小写。</p><p id="82d3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">它返回一个字符串和一个错误。<code class="fe mn mo mp md b">graph-gophers</code>库将获取解析器返回的任何内容，将其打包成HTTP响应，并发送给客户端。</p><p id="2437" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这里<code class="fe mn mo mp md b">graph-gophers</code>将尝试用你的根解析器和模式构建一个服务器。</p><p id="8622" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在使用<code class="fe mn mo mp md b">go run main.go</code>运行您的服务器，通过在终端中发出POST请求来测试您的服务器:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a586" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你应该看到<code class="fe mn mo mp md b">{"data" : {"info" : "this is a thing"}}</code>还给了你！<code class="fe mn mo mp md b">graph-gophers</code>解析我们请求中的查询，并根据<a class="ae jc" href="https://graphql.org/learn/serving-over-http/" rel="noopener ugc nofollow" target="_blank">规范</a>格式化响应。尝试从我们的Go resolver返回一个错误，用<code class="fe mn mo mp md b">errors.New("some error")</code>替换<code class="fe mn mo mp md b">nil</code>，看看新的响应格式。</p><p id="d7dc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">关于测试服务器的一个注意事项:发送查询并从服务器获得响应的一个快速方法是使用Prisma的<a class="ae jc" href="https://github.com/prisma-labs/graphql-playground" rel="noopener ugc nofollow" target="_blank"> GraphQL playground </a>。在操场上，连接到URL端点<code class="fe mn mo mp md b"><a class="ae jc" href="http://localhost:8080/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/graphql</a></code>，输入如下查询</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="7b49" class="la lb jf md b gy mh mi l mj mk">query {<br/>    info<br/>}</span></pre><p id="9681" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">为了熟悉GraphQL查询语言，请看这里的。</p><p id="e5b3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">或者，您可以像浏览器一样使用JavaScript通过http发送您自己的查询:有关示例，请查看本教程末尾的附录。</p><p id="5383" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在让我们添加另一个查询操作，并让它返回一个自定义类型:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3d3d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">扩展模式后，我们现在有了一个链接类型。用户将能够创建和获取这些。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3e7c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们的链接有字段；我们需要告诉<code class="fe mn mo mp md b">graph-gophers</code>如何解决这些问题。我们添加这个<code class="fe mn mo mp md b">opts</code>对象，所以它只返回一个相应的struct字段。</p><p id="ced8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们还将定义一个全局数组来存储链接对象。</p><p id="772d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Go类型映射到模式语言类型。这意味着我们可以从解析器中返回它们。</p><p id="1a31" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">关于从解析器返回对象和指针的注意事项:如果模式中的字段可为空，则对应的Go数据类型必须是指针。因为在模式中，<code class="fe mn mo mp md b">feed</code>的返回类型是<code class="fe mn mo mp md b">[Link!]!</code>(即列表本身及其内容都不能为空)，所以我们能够返回对象而不是指针。</p><p id="4ebd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">使用上面定义的选项在我们的<code class="fe mn mo mp md b">parseSchema</code>函数中返回结构字段。</p><p id="c148" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在，类似这样的查询将起作用:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f1e7" class="la lb jf md b gy mh mi l mj mk">query {<br/>   info<br/>   feed {<br/>      id<br/>      description<br/>   }<br/>}</span></pre><p id="a9dc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">添加突变:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="00d0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">扩展架构…</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk translated">突变解析器</figcaption></figure><p id="c310" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">…实施它。输入参数从<code class="fe mn mo mp md b">args</code>结构中解包。</p><p id="ce76" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在我们可以像这样添加链接:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9fea" class="la lb jf md b gy mh mi l mj mk">mutation {<br/>  post(description: "hello", url: "<a class="ae jc" href="http://www.abc.com" rel="noopener ugc nofollow" target="_blank">www.abc.com</a>") {<br/>    id   <br/>  }<br/>}</span></pre><h2 id="a9ac" class="la lb jf bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">用jwt注册和登录</h2><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7bed" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">使用注册函数、用户对象和任意AuthPayload对象扩展模式，以封装身份验证细节。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="aa87" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">用户将在成功注册或登录时收到一个令牌，该令牌可以附加到需要授权的后续请求中。</p><p id="82d8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">根据最佳实践，我们将存储密码的散列，而不是直接存储。我们正在使用<code class="fe mn mo mp md b">golang.org/x/crypto/bcrypt </code>库。</p><p id="74d0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在我们的解析器中，我们可以随时停止并向客户端返回一个错误。正如我们已经看到的，<code class="fe mn mo mp md b">graph-gophers</code>将格式化错误响应。</p><p id="79d1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你现在可以注册用户！</p><p id="bb16" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">要生成令牌，我们可以使用如下函数:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="2984" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">使用<a class="ae jc" href="https://github.com/dgrijalva/jwt-go" rel="noopener ugc nofollow" target="_blank">这个库</a>，我们可以创建一个这样的JWT。</p><p id="a932" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">它将对用户ID进行编码。如果令牌与请求一起传递，解析器将能够解码ID，从而确定请求发送方。</p><p id="518e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">要发送带有请求的令牌，请添加以下标头，用您自己的来自服务器的令牌替换“Bearer”之后的所有内容:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="b422" class="la lb jf md b gy mh mi l mj mk">"Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJRCI6IjAtdXNlciJ9.6149FwAsxB7onXVyNzuT0U34PeT0bZyeIZkaJCSzfaQ"</span></pre><p id="54a1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">为了实现登录功能，我们再次扩展了模式:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9300" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">登录功能需要检查用户的密码是否与他们在注册时设置的相匹配。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8304" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">检查所有用户，并将密码与第一个电子邮件匹配的用户进行比较。</p><p id="b150" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">您现在可以注册并登录。</p><p id="712a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们现在将使用新生成的JWT在创建链接时自动添加作者。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c516" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">首先，我们在模式中添加author字段。</p><p id="fcbb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们需要将来自请求的JWT传递给我们的解析器。为此，我们需要重构我们的主函数:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="ede3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">解析器通过上下文对象访问任何请求信息，这是一个键值存储，我们需要填充它。Relay的ServeHTTP实现将把这个上下文传递给我们的解析器。</p><p id="c9c9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们需要在创建链接时填写链接的<code class="fe mn mo mp md b">postedBy</code>字段；也就是在<code class="fe mn mo mp md b">post</code>突变。为了访问<code class="fe mn mo mp md b">Post</code>中的令牌，我们需要稍微修改一下实现:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="bec6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe mn mo mp md b">graph-gophers</code>向所有解析器传递一个<code class="fe mn mo mp md b">ctx</code>参数，我们可以用它来访问我们的令牌。只要您的请求在其“Authorization”头中有一个令牌，服务器现在就应该将它打印到控制台。</p><p id="27e6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们将从一个单独的函数中的令牌获取用户:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a4ae" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">使用<code class="fe mn mo mp md b">jwt</code>库解码我们的令牌并提取用户ID，然后返回一个ID匹配的用户。</p><p id="a2a1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">完整的<code class="fe mn mo mp md b">Post</code>实施:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="0678" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">获取作者并将其分配给一个新链接。</p><p id="2d58" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在，如果您<code class="fe mn mo mp md b">post</code>一个链接，然后请求一个<code class="fe mn mo mp md b">feed</code>，您将能够检查该链接的<code class="fe mn mo mp md b">postedBy</code>用户对象。</p><h2 id="de2b" class="la lb jf bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">通过Go频道订阅数据</h2><p id="78f8" class="pw-post-body-paragraph kc kd jf ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz im bi translated">GraphQL支持订阅，允许客户端订阅服务器上的事件。在幕后，订阅使用WebSocket连接，而不是我们一直用于查询和变异的HTTP请求和响应。我们将对发布新链接的事件进行订阅。</p><p id="a397" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">和往常一样，第一步是在模式中声明新的订阅操作:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="20d4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们正在定义一个新的操作，它将在服务器上每次创建一个链接时返回一个Link对象。</p><p id="5652" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">下一步是为我们的服务器添加WebSocket支持。这需要对main进行重构:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8bbd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe mn mo mp md b">graph-gophers</code>提供了一个可以处理web socket连接以及http的包。</p><p id="457d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们用这个新的<code class="fe mn mo mp md b">wshandler</code>代替了<code class="fe mn mo mp md b">handler</code>。</p><p id="9369" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">订阅操作可以按如下方式实现:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="cd23" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们给我们的<code class="fe mn mo mp md b">RootResolver</code>对象添加一个通道。当数据从我们的解析器推送到it部门时，<code class="fe mn mo mp md b">graph-gophers</code>会将数据转发给客户端。</p><p id="a4b5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">订阅解析程序应该返回充当客户端数据源的通道。</p><p id="e397" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果您使用以下内容进行测试:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="a9e9" class="la lb jf md b gy mh mi l mj mk">subscription {<br/>  newLink {<br/>    id<br/>  }<br/>}</span></pre><p id="2c80" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你应该会看到操场上显示的<code class="fe mn mo mp md b">Listening…</code>:准备接收数据。当然还不会出现任何数据，因为我们没有向频道推送任何内容！让我们来解决这个问题:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a12a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">首先，稍微重构main，这样可以用<code class="fe mn mo mp md b">make</code>初始化通道。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk">.</figcaption></figure><p id="dc80" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">然后，在Post中，一旦你创建了一个链接，就把它推送到<code class="fe mn mo mp md b">NewLinks</code>频道。</p><p id="79c8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">select语句的存在使得通道插入操作不会阻塞<code class="fe mn mo mp md b">Post</code>的执行。</p><p id="bb35" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">就是这样！为了在playground中进行测试，在一个新的选项卡中添加了一个链接，您应该会看到一些数据出现在您执行订阅的选项卡中。</p><p id="3e66" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke jg">重要警告:</strong>这种订阅实现只对一个订阅者有效。这是因为我们的订阅操作返回一个通道；一旦从其中读取了一个值，该值将被传递给第一个订阅者，而不是其他订阅者。为了使多个订阅有效，需要为每个订户创建一个专用通道。创建新链接时，应该将其推送到所有订户通道。这种机制的示例实现可以在<a class="ae jc" href="https://github.com/matiasanaya/go-graphql-subscription-example" rel="noopener ugc nofollow" target="_blank">这里</a>看到。</p><h2 id="5953" class="la lb jf bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">结论</h2><p id="9875" class="pw-post-body-paragraph kc kd jf ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz im bi translated">在本教程中，我们创建了一个服务器，客户端可以在服务器上注册、登录、创建对象、读取对象和订阅事件。一个好的下一步是实现将数据存储在数据库中，而不是保存在内存中。</p><h2 id="d9f3" class="la lb jf bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">附录—用JavaScript测试您的服务器</h2><p id="ece1" class="pw-post-body-paragraph kc kd jf ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz im bi translated">在浏览器中运行这个(替换您在<code class="fe mn mo mp md b">fetch</code>中的端点)来测试您的查询:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div></div>    
</body>
</html>