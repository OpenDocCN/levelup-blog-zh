<html>
<head>
<title>Understanding React Higher-Order Components by Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过示例了解React高阶组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-react-higher-order-components-by-example-95e8c47c8006?source=collection_archive---------0-----------------------#2018-03-13">https://levelup.gitconnected.com/understanding-react-higher-order-components-by-example-95e8c47c8006?source=collection_archive---------0-----------------------#2018-03-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7018" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">逐步构建React高阶组件，以了解如何实现特设模式</h2></div><p id="b144" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本教程中，我们将涵盖构建您自己的高阶组件(HOC)所需的概念。我们将实现一个HOC来将React状态保存到<code class="fe le lf lg lh b">localStorage</code>，称为<code class="fe le lf lg lh b">withStorage</code>，这将允许您将功能注入到组件中，而无需在整个应用程序中复制逻辑。</p><div class="li lj gp gr lk ll"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab fo"><div class="ln ab lo cl cj lp"><h2 class="bd iu gy z fp lq fr fs lr fu fw is bi translated">编写面试问题</h2><div class="ls l"><h3 class="bd b gy z fp lq fr fs lr fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="lt l"><p class="bd b dl z fp lq fr fs lr fu fw dk translated">技术开发</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz ma ll"/></div></div></a></div><blockquote class="mb mc md"><p id="2a97" class="ki kj me kk b kl km ju kn ko kp jx kq mf ks kt ku mg kw kx ky mh la lb lc ld im bi translated">如果你有兴趣在渲染道具中看到同样的例子，请查看本文</p></blockquote><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/3970d71eb62f189183ea365fb44cd6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gond0DGQrdi8BN_h7aLxMQ.jpeg"/></div></div></figure><h1 id="eec7" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">HOC简介</h1><p id="ba53" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">React中的高阶组件是一种用于在组件之间共享公共功能而无需重复代码的模式。高阶分量实际上不是一个分量，而是一个函数。特殊函数将组件作为参数，并返回一个组件。它将一个组件转换成另一个组件，并添加额外的数据或功能。简而言之:</p><pre class="mk ml mm mn gt nr lh ns nt aw nu bi"><span id="784c" class="nv mv it lh b gy nw nx l ny nz">const NewComponent = (BaseComponent) =&gt; {<br/>  // ... create new component from old one and update<br/>  return UpdatedComponent<br/>}</span></pre><p id="7826" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在React生态系统中，您可能熟悉的两个HOC实现是来自Redux的<code class="fe le lf lg lh b">connect</code>和来自React路由器的<code class="fe le lf lg lh b">withRouter</code>。Redux的<code class="fe le lf lg lh b">connect</code>函数用于让组件访问Redux存储中的全局状态，并将这些值作为道具传递给组件。<code class="fe le lf lg lh b">withRouter</code>函数将路由器信息和功能注入到组件中，使开发人员能够访问或更改路由。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi oa"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><p id="c0da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建和维护一份简历并不有趣。相反，让我们为你生成一份令人敬畏的简历:)<a class="ae mi" href="https://gitconnected.com/resume-builder" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">简历生成器&gt; </strong> </a></p><div class="li lj gp gr lk ll"><a href="https://gitconnected.com/resume-builder" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab fo"><div class="ln ab lo cl cj lp"><h2 class="bd iu gy z fp lq fr fs lr fu fw is bi translated">软件工程师简历生成器和示例| gitconnected</h2><div class="ls l"><h3 class="bd b gy z fp lq fr fs lr fu fw dk translated">使用您的个人资料中的详细信息构建一份有价值的简历模板。从你的投资组合网站链接到你的简历或…</h3></div><div class="lt l"><p class="bd b dl z fp lq fr fs lr fu fw dk translated">gitconnected.com</p></div></div><div class="lu l"><div class="ob l lw lx ly lu lz ma ll"/></div></div></a></div><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi oa"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><h1 id="7266" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">高阶组件模式</h1><p id="a348" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">高阶分量是以分量作为自变量并返回分量的函数。这意味着特设将始终具有类似如下的形式:</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0505" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">higherOrderComponent</code>是一个将名为<code class="fe le lf lg lh b">WrappedComponent</code>的组件作为参数的函数。我们创建一个名为<code class="fe le lf lg lh b">HOC</code>的新组件，它从其<code class="fe le lf lg lh b">render</code>函数中返回<code class="fe le lf lg lh b">&lt;WrappedComponent/&gt;</code>。虽然在这个简单的例子中，这实际上没有增加任何功能，但是它描述了每个特设函数都将遵循的通用模式。我们可以如下调用特设:</p><pre class="mk ml mm mn gt nr lh ns nt aw nu bi"><span id="55a7" class="nv mv it lh b gy nw nx l ny nz">const SimpleHOC = <!-- -->higherOrderComponent<!-- -->(MyComponent);</span></pre><h1 id="47fb" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">一个基本的例子</h1><p id="3a53" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">现在，我们将扩展我们的基本高阶组件模式，将数据注入我们的包装。</p><p id="8473" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的团队实际上已经算出了<code class="fe le lf lg lh b">secretToLife</code>，结果是数字<code class="fe le lf lg lh b">42</code>。我们的一些组件需要共享这些信息，我们可以创建一个名为<code class="fe le lf lg lh b">withSecretToLife</code>的特设来将它作为道具传递给我们的组件。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="10f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，这个特设几乎与我们的基本模式相同。我们所做的就是添加一个prop <code class="fe le lf lg lh b">secretToLife={42}</code>，它允许被包装的组件通过调用<code class="fe le lf lg lh b">this.props.secretToLife</code>来访问值。</p><p id="9edc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个补充是，我们将传递给组件的道具分散开来。这确保了传递给包装组件的任何其他属性都可以通过<code class="fe le lf lg lh b">this.props</code>访问，就像组件没有通过我们的高阶组件函数传递时调用它们一样。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a08f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe le lf lg lh b">WrappedComponent</code>，只是<code class="fe le lf lg lh b">&lt;DisplayTheSecret/&gt;</code>的增强版，将允许我们作为道具访问<code class="fe le lf lg lh b">secretToLife</code>。</p><h1 id="e711" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">一个实用的例子</h1><p id="6b77" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">既然我们已经对HOC的基本模式有了很好的理解，我们就可以构建一个实际的应用程序了。高阶组件可以访问所有默认的React API，包括<code class="fe le lf lg lh b">state</code>和生命周期方法。</p><p id="9f02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe le lf lg lh b">withStorage</code> HOC的功能将是保存/加载组件的状态，允许我们在页面加载时快速访问和呈现它。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="2216" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">withStorage</code>的顶部，我们在组件的状态中有一个单独的项目，它跟踪<code class="fe le lf lg lh b">localStorage</code>在给定的浏览器中是否可用。我们使用<code class="fe le lf lg lh b">componentDidMount</code>生命周期挂钩，它将检查本地存储是否存在于<code class="fe le lf lg lh b">checkLocalStorageExists</code>函数中。在这里，它将测试保存一个项目，如果成功，将状态设置为true。</p><p id="171d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还为我们的HOC添加了三个函数— <code class="fe le lf lg lh b">load</code>、<code class="fe le lf lg lh b">save</code>和<code class="fe le lf lg lh b">remove</code>。这些用于直接访问<code class="fe le lf lg lh b">localStorage</code> API，如果它可用的话。我们在HOC上的三个函数被传递给我们包装的组件，以便在那里使用。</p><p id="86b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们将创建一个新的组件来包装我们的<code class="fe le lf lg lh b">withStorage</code> HOC。它将用于显示用户的用户名和最喜欢的电影。然而，获取这些信息的API调用需要很长时间。我们也可以假设这些值一旦设定就永远不会改变。</p><p id="591e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了确保我们有一个很好的用户体验，我们将只在值没有被保存的时候调用这个API。然后每次用户返回页面时，他们可以立即访问数据，而不是等待我们的API返回。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="df0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们包装的组件的<code class="fe le lf lg lh b">componentDidMount</code>内部，我们首先尝试从<code class="fe le lf lg lh b">localStorage</code>访问<code class="fe le lf lg lh b">username</code>和<code class="fe le lf lg lh b">favoriteMovie</code>。如果这些值不存在，我们就调用昂贵的名为<code class="fe le lf lg lh b">this.props.reallyLongApiCall</code>的API。一旦这个函数返回，我们将用户名和收藏夹保存到<code class="fe le lf lg lh b">localStorage</code>，并更新组件的状态以在屏幕上显示它们。</p><h1 id="aec7" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">高阶元件考虑因素</h1><ul class=""><li id="4dd9" class="oe of it kk b kl nm ko nn kr og kv oh kz oi ld oj ok ol om bi translated">特设应该是一个没有副作用的纯功能。它不应该做任何修改，而只是通过将原始组件包装在另一个组件中来组合它。</li><li id="f355" class="oe of it kk b kl on ko oo kr op kv oq kz or ld oj ok ol om bi translated">不要在组件的render方法中使用HOC。在组件定义之外访问特设。</li><li id="c86d" class="oe of it kk b kl on ko oo kr op kv oq kz or ld oj ok ol om bi translated">静态方法必须被复制才能访问它们。一个简单的方法是<code class="fe le lf lg lh b">hoist-non-react-statics</code>包。</li><li id="b6f4" class="oe of it kk b kl on ko oo kr op kv oq kz or ld oj ok ol om bi translated">引用不通过。</li></ul></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="d3d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="me">如果您觉得本文有帮助，请点击👏。</em> <a class="ae mi" href="https://medium.com/@treyhuffine" rel="noopener"> <em class="me">关注我</em> </a> <em class="me">获取更多关于区块链、React、JavaScript和开源软件的文章！你也可以在</em><a class="ae mi" href="https://twitter.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="me">Twitter</em></a><em class="me">或者</em><a class="ae mi" href="https://gitconnected.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="me">git connected</em></a><em class="me">上找到我。</em></p></div></div>    
</body>
</html>