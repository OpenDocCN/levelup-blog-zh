<html>
<head>
<title>Local Setup For Fast Airflow Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速气流发展的本地设置</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/local-setup-for-fast-airflow-development-ca26c478f4b5?source=collection_archive---------2-----------------------#2022-05-31">https://levelup.gitconnected.com/local-setup-for-fast-airflow-development-ca26c478f4b5?source=collection_archive---------2-----------------------#2022-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f5018ba6834b10f0b0e3be0bbb739fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50AVjUT4w-B1WgjI8pDACg.png"/></div></div></figure><p id="5c33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经在Airflow平台上开发了一段时间，用它来调度和编排数据工程工作负载。对于这项工作，我投入了大量时间来确保它有一个优秀的开发人员工具链，允许工程师快速构建Dag和插件，并在将包部署到生产环境之前在本地测试工作。</p><p id="99d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将讨论如何设置Airflow repo，以允许您通过适当的repo结构更快地构建和测试Dag和操作符，并使用Docker更容易地定义和编排我们的Airflow运行时，以便您可以继续编写代码，而不是在本地Airflow堆栈上运行ops来测试您的更改。对于这个示例设置，<a class="ae kz" href="https://github.com/Aaron-K-T-Berry/airflow-docker-boilerplate" rel="noopener ugc nofollow" target="_blank">我已经在这里创建了一个git repo，</a>因此，如果您想在它的基础上扩展您的Airflow项目，您可以派生或克隆它，并将其作为一个起点。</p><h1 id="44ce" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">回购结构</h1><p id="8db3" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">对于回购结构，你需要平衡两个主要因素。将您的Dag拆分到每个项目并在Dag之间共享公共操作符的能力，无论它们是耦合到单个项目还是分离的公共设施。我发现基本的回购结构采取以下形式，以支持按项目分组，并鼓励代码共享。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1137" class="mm lb it mi b gy mn mo l mp mq">├───config<br/>|   |   airflow.cfg<br/>├───dags<br/>│   ├───project_1<br/>│   │     example_dag.py<br/>│   └───project_2<br/>│         example_dag.py<br/>├───plugins<br/>│   ├───hooks<br/>│   │      hello_hook.py<br/>│   ├───sensors<br/>│   │      hello_sensor.py<br/>│   ├───operators<br/>│   │      hello_operator.py<br/>│   ├───scripts<br/>│       ├───project_1<br/>|       |      transform_cases.py<br/>│       ├───common<br/>|             helper.py<br/>|             aws.py<br/>| Dockerfile<br/>| docker-compose.yml<br/>| requirements.txt</span></pre><p id="7f49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一点需要注意的是，任何<strong class="kd iu"> <em class="mr">。py </em> </strong>文件在我们的repo中的DAGs文件夹下找到，当我们将它安装到Docker堆栈时，它会被气流拾取。这意味着您可以创建文件夹，并拥有任何您想要的结构来组织您的DAG代码，但是在编写时，Airflow UI无法在UI中表示该文件夹结构。所有DAG都显示在一个表中，但是描述<a class="ae kz" href="https://github.com/Aaron-K-T-Berry/airflow-docker-boilerplate/blob/master/dags/project_bar/example_dag.py#L16-L19" rel="noopener ugc nofollow" target="_blank">DAG之间所有权的有效方法是为每个DAG </a>配置所有者和标签。在DAG docs字符串中记录此信息也可能是有效的。<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/airflow-dag-and-task-markdown-docs-2c00c72152b4">更多详情在下面的文章</a>。</p><p id="360d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于插件文件夹，当它被装载到Airflow中时，它将被添加到python sys路径中，因此该文件夹中的任何内容都可以像常规python模块一样作为DAG代码的一部分导入。这样，你可以使用你的打包模式来划分你的python工具、操作符、钩子等等，无论你需要什么样的公共文件夹、项目文件夹或者客户文件夹。对于示例repo，插件文件夹是按照<a class="ae kz" href="https://www.astronomer.io/guides/" rel="noopener ugc nofollow" target="_blank"> Astronears社区</a>的建议设置的，为您可能想要定制或扩展的每个气流资源提供一个文件夹。</p><h1 id="277b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Docker撰写</h1><p id="ebc2" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了更容易地在本地和生产中运行我们的气流堆栈，我倾向于在运行时使用Docker容器来运行气流，并使用Docker Compose来定义和编排堆栈。通过这种设置，我们可以清楚地区分pip和apt包等气流依赖项和Dag形式的气流应用程序代码、操作符和插件代码，它们都是用python编写的。</p><p id="9524" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的repo现在将包含如何运行我们的Airflow堆栈的明确定义，以及在该堆栈上运行所需的内容，通过明确的职责分离和我们用来管理它们的工具，使一切都变得更加可移植和易于修改。通过这个docker文件，您还应该受益于在机器之间拥有一个可再现的环境，这为调试省去许多麻烦。</p><p id="fa89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面的docker文件显示了一个基本设置，它扩展了官方的Airflow映像，以安装我们的DAG代码所需的依赖项。您可以参考以下来自Airflow的文档，了解关于根据您的项目需求扩展基本Airflow Docker图像的<a class="ae kz" href="https://airflow.apache.org/docs/docker-stack/build.html#extending-the-image" rel="noopener ugc nofollow" target="_blank">的一些细节。</a></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f913" class="mm lb it mi b gy mn mo l mp mq"># Extend over the airflow base image<br/>FROM apache/airflow:2.3.1</span><span id="7e00" class="mm lb it mi b gy ms mo l mp mq">USER root</span><span id="788d" class="mm lb it mi b gy ms mo l mp mq"># Install any root level apt packages<br/>RUN apt-get update &amp;&amp; \<br/>  apt-get install -y --no-install-recommends build-essential</span><span id="6251" class="mm lb it mi b gy ms mo l mp mq"># Run remaining commands as the airflow runtime user<br/>USER airflow</span><span id="9ec3" class="mm lb it mi b gy ms mo l mp mq"># Install airflow related files onto the host<br/>COPY ./config/airflow.cfg /opt/airflow/airflow.cfg<br/>COPY ./plugins /opt/airflow/plugins<br/>COPY ./dags /data/airflow/dags</span><span id="a091" class="mm lb it mi b gy ms mo l mp mq"># Install pip packages into the container that DAG code needs<br/>COPY ./requirements.txt /tmp/requirements.txt<br/>RUN pip install -r /tmp/requirements.txt</span></pre><p id="44d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了操作我们的栈，我们将使用Docker Compose来声明我们的气流栈的公共配置。我们基于Airflow提供的配置作为他们<a class="ae kz" href="https://github.com/apache/airflow/blob/main/docs/apache-airflow/start/docker-compose.yaml" rel="noopener ugc nofollow" target="_blank">推荐的配置</a>，并在示例报告中做了一些细微的修改。配置了这个Dockerfile和docker-compose.yml之后，我们可以使用下面的命令快速调出和删除docker-compose堆栈。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="493c" class="mm lb it mi b gy mn mo l mp mq"># Build the local extended Airflow container using the local Dockerfile<br/>docker-compose build</span><span id="47c5" class="mm lb it mi b gy ms mo l mp mq"># Run all of the containers used in the stack<br/>docker-compose up</span><span id="1a61" class="mm lb it mi b gy ms mo l mp mq"># Take down the airflow stack gracefully<br/>docker-compose down</span></pre><p id="5042" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦您运行了您的应用程序，您就可以像往常一样访问位于<strong class="kd iu"> <em class="mr"> localhost:8080 </em> </strong>的UI，并开始操作和监控Dag。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/b2424720b285ed463bd0e76e5e319a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bgbv6aN6uUOrKISoGhjXlg.png"/></div></div></figure><p id="8a24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">需要注意的一点是我们如何为本地Dag和python插件文件配置挂载。查看Docker compose配置中的卷块，我们已经将其配置为挂载本地DAG和插件目录。这允许我们在本地更新文件时，让所有的气流服务更新运行的Dag，以加快我们的开发时间，因为我们可以很快看到我们的Dag或操作代码中是否有任何中断的逻辑，而无需同步我们的文件和更新每个代码都改变的整个气流堆栈。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="19a5" class="mm lb it mi b gy mn mo l mp mq">---<br/>version: '3'<br/>x-airflow-common:<br/>  &amp;airflow-common<br/>  build: .<br/> # .... other parts excluded in example <br/>  volumes:<br/>  # Mount the local folders into the running Airflow containers<br/>    - ./dags:/opt/airflow/dags<br/>    - ./plugins:/opt/airflow/plugins</span></pre><h1 id="ae47" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">本地编辑器配置</h1><p id="4b72" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">当你开发python来描述你的Airflow DAG或插件时，你可能想在你的编辑器中得到一些代码完成的建议来更快地编写和理解你的代码。因为我们已经为Dockerfile和附带的requirements.txt文件定义了python运行时，所以我们可以使用它来创建我们的python虚拟环境，然后我们的编辑器可以引用它来访问我们安装的模块，例如代码完成。我们可以像normal一样创建和获取python venv，并安装包含的requiremnts.txt文件，以使用我们的代码编辑器中可用的所有依赖项，就像Airflow在运行时在我们的本地堆栈中使用的容器中使用的一样。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="a3b0" class="mm lb it mi b gy mn mo l mp mq"># Create a venv<br/>python -m venv venv</span><span id="b304" class="mm lb it mi b gy ms mo l mp mq"># Add the venv to your path<br/>source venv/bin/activate</span><span id="6718" class="mm lb it mi b gy ms mo l mp mq"># Install all of the python modules that are used in the Docker container<br/>pip install -r requirements.txt</span></pre><p id="4342" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于我的代码编辑器，我使用VS代码，我可以为它设置python环境，以用于代码自动完成和建议的源模块。创建venv后，我将编辑器指向repo中的本地venv。我们将获得基于我们创建的本地venv中安装的任何东西的自动完成，这使得在使用气流模块时发现您需要的所有参数变得容易得多。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/bd81853e5d3351cbfe21598344afd26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJVhBoEIgnRSbjIafF0UTQ.png"/></div></div></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b2e6958360cf642b953a867d43fdbae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*mHAMD2TWpSh7itQbiWwf-w.png"/></div></figure><p id="b1a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您使用的是另一个代码编辑器，那么您需要配置它的python解释器，使其指向您创建的repo中的本地venv，以便安装在那里的所有模块可供您的编辑器搜索。一些关于<a class="ae kz" href="https://www.jetbrains.com/help/idea/creating-virtual-environment.html" rel="noopener ugc nofollow" target="_blank"> IntelliJ </a>和<a class="ae kz" href="https://www.jetbrains.com/help/pycharm/creating-virtual-environment.html" rel="noopener ugc nofollow" target="_blank"> PyCharm </a>的文档可以在这里找到。</p><h1 id="c5dc" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">包扎</h1><p id="7c34" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">希望这篇文章能给你一些提示，告诉你如何在本地机器上更好地使用气流。我使用这个设置已经有一段时间了，它帮助我通过使用本地容器更快地开发操作符和Dag，并且您可以在运行的气流环境中很快看到这些变化。这些容器还提供了一种非常简单的方法来更新DAG的运行时依赖项，例如apt或pip包。你也不能否认这样一个事实，你运行的airflow实例将总是使用你的文件的本地版本，因此你不应该试图更新当前的airflow文件时遇到这些奇怪的问题，并且它不会被组件拾取。</p><h1 id="5dd6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">进一步连接</h1><ul class=""><li id="2cdc" class="mw mx it kd b ke ly ki lz km my kq mz ku na ky nb nc nd ne bi translated">如果你正在考虑购买一份中等订阅，你可以通过我的推荐链接来帮我。</li><li id="2442" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">查看我在<a class="ae kz" href="https://medium.com/@aaron-kt-berry" rel="noopener">媒体</a>上的其他文章，如果你想了解最新消息，请通过<a class="ae kz" href="https://aaron-kt-berry.medium.com/subscribe" rel="noopener">电子邮件</a>订阅。</li><li id="3fa7" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">如果你想聊天，请在Twitter或LinkedIn上联系我，如果你想雇佣我，我在Codementor上。</li></ul></div></div>    
</body>
</html>