<html>
<head>
<title>LeetCode Problems with Rust: Add Two Numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">锈病的LeetCode问题:添加两个数字</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/leetcode-problems-add-two-numbers-6a4045ce146c?source=collection_archive---------6-----------------------#2020-04-28">https://levelup.gitconnected.com/leetcode-problems-add-two-numbers-6a4045ce146c?source=collection_archive---------6-----------------------#2020-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e581b9b5ed29251bc2c2d2cbf36eb5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H2WUc3LU4EUTOupFUmrNQ.png"/></div></div></figure><h1 id="00d0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题</h1><p id="8104" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">给你两个非空链表，代表两个非负整数。这些数字以相反的顺序存储，并且它们的每个节点都包含一个数字。将两个数相加，并以链表的形式返回。</p><p id="e06f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可以假设这两个数字不包含任何前导零，除了数字0本身。</p><h1 id="3fb7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">例子</h1><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d10c" class="mi jz iq me b gy mj mk l ml mm">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) <br/>Output: 7 -&gt; 0 -&gt; 8 <br/>Explanation: 342 + 465 = 807.</span></pre><h1 id="8e4d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">初始设置</h1><p id="0f87" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在解决这个问题之前，我们需要谈谈数据结构。如果您已经熟悉链表以及如何在Rust中实现它们，请随意跳到下一节。</p><p id="fec6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">链表是由节点组成的数据结构。一个基本节点包含一个数据字段和对下一个节点的引用。引用充当链接，以便可以从根节点开始按顺序遍历节点。</p><p id="3b48" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">链表的许多变体超出了本文的范围。如果您想了解更多，这篇<a class="ae mn" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">文章</a>是一个不错的起点。</p><p id="4929" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在Rust中，我们可以使用一个简单的结构来定义我们的链表。我将首先列出代码，然后讨论重要的部分。</p><p id="6ddb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">结构定义包含两个字段。第一个，<code class="fe mo mp mq me b">val</code>非常简单。只是节点包含的数据。第二个领域更有趣。</p><p id="d371" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">字段<code class="fe mo mp mq me b">next</code>首先被包装在一个<code class="fe mo mp mq me b">Option</code>类型中。如果一个节点的<code class="fe mo mp mq me b">next</code>字段是<code class="fe mo mp mq me b">None</code>，那么这就是链表的结尾。在<code class="fe mo mp mq me b">Option</code>型里面，我们用的是<code class="fe mo mp mq me b">Box</code>型。<code class="fe mo mp mq me b">Box</code>类型是一个智能指针，它允许您在堆上而不是堆栈上存储数据，而没有任何实际的性能开销。在这种情况下，我们用它来存储一个<code class="fe mo mp mq me b">ListNode</code>。要更详细地了解智能指针，请看一下<a class="ae mn" href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html" rel="noopener ugc nofollow" target="_blank"> Rust Book </a>。</p><p id="7fcf" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">实现块中的<code class="fe mo mp mq me b">new</code>函数相当简单。传入一个值，并返回一个包含该值的<code class="fe mo mp mq me b">ListNode</code>和<code class="fe mo mp mq me b">next</code>字段的默认值<code class="fe mo mp mq me b">None</code>。</p><p id="8ff7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们已经建立了数据结构，我们可以继续实际解决问题。</p><h1 id="317f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">方法1:迭代</h1><p id="0552" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">解决这个问题的一种方法是迭代两个链表，并将两个节点值相加。如果两个值之和大于或等于10，则有一个进位值被加到下一次迭代的和中。如果一个链表在另一个之前到达末尾，那么我们可以忽略它，直到另一个也完成。</p><h1 id="97d9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">算法</h1><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="582f" class="mi jz iq me b gy mj mk l ml mm">initialize values `l1_current` and `l2_current` as the root of their respective linked lists</span><span id="dccd" class="mi jz iq me b gy mr mk l ml mm">create a dummy node that will be the root of the resulting linked list</span><span id="ffc9" class="mi jz iq me b gy mr mk l ml mm">initialize `current` node to the dummy node</span><span id="193a" class="mi jz iq me b gy mr mk l ml mm">initialize `carry` to 0</span><span id="ec2a" class="mi jz iq me b gy mr mk l ml mm">while `l1_current` or `l2_current` contain nodes</span><span id="6678" class="mi jz iq me b gy mr mk l ml mm">    initialize sum to the carry of the previous operation</span><span id="49a9" class="mi jz iq me b gy mr mk l ml mm">    if `l1_current` contains a node<br/>        add the node value to sum<br/>        set `l1_current` to its `next` value</span><span id="9d96" class="mi jz iq me b gy mr mk l ml mm">    if `l2_current` contains a node<br/>        add the node value to sum<br/>        set `l2_current` to its `next` value</span><span id="0b19" class="mi jz iq me b gy mr mk l ml mm">    set `carry` to `sum` / 10 (floor division)</span><span id="6c27" class="mi jz iq me b gy mr mk l ml mm">    create new node with value of `sum` mod 10 (modulo division)</span><span id="70b9" class="mi jz iq me b gy mr mk l ml mm">    set `current.next` to the new node</span><span id="8485" class="mi jz iq me b gy mr mk l ml mm">    set `current` to `current.next`</span><span id="d985" class="mi jz iq me b gy mr mk l ml mm">if `carry` is not zero<br/>    create a new node with the value of `carry`<br/>    set `current.next` to the new node</span><span id="a8cb" class="mi jz iq me b gy mr mk l ml mm">return the next value of the dummy node</span></pre><h1 id="8c87" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">履行</h1><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/725380a2e624467ba891e47212a34dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8mIaTa515cF0A5f0.png"/></div></div></figure><h1 id="ddb1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">复杂性</h1><ul class=""><li id="6cbe" class="mt mu iq ky b kz la ld le lh mv ll mw lp mx lt my mz na nb bi translated">时间复杂度:O(max(m，n))其中<code class="fe mo mp mq me b">m</code>是<code class="fe mo mp mq me b">l1</code>中的节点数，<code class="fe mo mp mq me b">n</code>是<code class="fe mo mp mq me b">l2</code>中的节点数</li><li id="c975" class="mt mu iq ky b kz nc ld nd lh ne ll nf lp ng lt my mz na nb bi translated">空间复杂度:O(max(m，n))，因为我们要创建一个新的链表来返回</li></ul><h1 id="b611" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">方法2:递归</h1><p id="2468" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">解决这个问题的另一种方法是使用递归。这种方法的逻辑与迭代方法相同，只是它递归地将下一个数字添加到链表中。好处是代码看起来更整洁，但是缺点是由于递归函数调用而增加了空间需求。</p><h1 id="330d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">算法</h1><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="98e7" class="mi jz iq me b gy mj mk l ml mm">initialize sum to the value of carry from the previous recursive call</span><span id="0e5f" class="mi jz iq me b gy mr mk l ml mm">if `l1` contains a node<br/>    add node value to sum<br/>    advance `l1` to `l1.next1`</span><span id="d912" class="mi jz iq me b gy mr mk l ml mm">if `l2` contains a node<br/>    add node value to sum<br/>    advance `l2` to `l2.next`</span><span id="4a2f" class="mi jz iq me b gy mr mk l ml mm">create a new node `result` with the value of sum mod 10 (modulo division)</span><span id="3322" class="mi jz iq me b gy mr mk l ml mm">if `l1` or `l2` contain a node or sum is greater then or equal to 10<br/>    set `result.next` to the return value of the recursive function</span><span id="2398" class="mi jz iq me b gy mr mk l ml mm">return result</span></pre><h1 id="22df" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">履行</h1><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/358563bb9b6d8e647f9b5efe65edc51d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MzZoojTNZXtIRhnR.png"/></div></div></figure><h1 id="4839" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">复杂性</h1><ul class=""><li id="eb24" class="mt mu iq ky b kz la ld le lh mv ll mw lp mx lt my mz na nb bi translated">时间复杂度:O(max(m，n))，其中<code class="fe mo mp mq me b">m</code>是<code class="fe mo mp mq me b">l1</code>中的节点数，<code class="fe mo mp mq me b">n</code>是<code class="fe mo mp mq me b">l2</code>中的节点数</li><li id="bc19" class="mt mu iq ky b kz nc ld nd lh ne ll nf lp ng lt my mz na nb bi translated">空间复杂度:O(max(m，n))，因为我们要创建一个新的链表来返回</li></ul><h1 id="3c14" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">回顾</h1><p id="f3a7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这种情况下，我更喜欢迭代方法而不是递归方法。显然，递归是一个非常强大的编程特性，但对于这个问题，它带来了更多的资源开销，而没有任何时间改进。随意看一下<a class="ae mn" href="https://github.com/andrewleverette/leetcode_problems/blob/master/add_two_numbers/src/lib.rs" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="b64a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="np">原载于2020年4月28日</em><a class="ae mn" href="https://andrewleverette.github.io/add-two-numbers/" rel="noopener ugc nofollow" target="_blank"><em class="np">https://andrewleverette . github . io</em></a><em class="np">。</em></p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/2ee1ea256190d57f75331cb76d9d3339.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*jLGtQ-ldYIEs8X6UUxL5Pg.jpeg"/></div></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><div class="lz ma mb mc gt nr"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">编写面试问题</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">掌握编码面试的过程</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">技术开发</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jw nr"/></div></div></a></div></div></div>    
</body>
</html>