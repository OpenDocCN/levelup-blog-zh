<html>
<head>
<title>How To Write a Custom useFetch Hook For API Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为API调用编写自定义的useFetch挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-a-custom-usefetch-hook-for-api-calls-4f8ea9b5a5e8?source=collection_archive---------3-----------------------#2020-08-17">https://levelup.gitconnected.com/how-to-write-a-custom-usefetch-hook-for-api-calls-4f8ea9b5a5e8?source=collection_archive---------3-----------------------#2020-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8ed7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">演示React的使用状态、使用效果和使用回调</strong></p><p id="45f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在现代web应用程序中，经常可以通过REST APIs访问数据和功能。听起来很简单，发送请求会很快从一行代码变成几十行代码:</p><ol class=""><li id="7cf9" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">使用fetch()函数调用API端点</li><li id="3148" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">检查响应状态代码(例如，200 =成功，404 =未找到，…)</li><li id="5901" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">从响应中提取json正文</li><li id="2369" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">捕捉try/catch块中的潜在错误</li><li id="a8eb" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">将所有这些放入一个useEffect钩子中(解决useEffect只接受同步函数而fetch是异步函数的问题……)</li></ol><p id="8b60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你可以想象的那样，坚持应用所有这些步骤需要一些努力。有时我会忽略捕捉错误，有时会忘记在提取之前检查响应代码，等等。所以我开始编写一个自定义钩子来执行所有这些步骤。在前进的道路上有几个挑战。寻找解决方案教会了我很多关于钩子的知识。在这篇博文中，我想分享我遇到的问题以及如何解决它们。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/8b0d448e6139d717c76e62076b8fc57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*el6CwKbutZMnxX46"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">照片由<a class="ae ls" href="https://unsplash.com/@jannesglas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jannes Glas </a>在<a class="ae ls" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="a578" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">出发点</h1><p id="ac9e" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">在我开始将功能提取到钩子之前，类似的代码在几个组件中重复出现:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d2e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将在整篇博文中使用这个例子，并解释各个块的用途(一般来说，应该熟悉状态挂钩、效果挂钩和反应)。由于API对任何人开放，您可以跟随并复制每个步骤。该组件将从奇妙的<a class="ae ls" href="https://dog.ceo/dog-api/" rel="noopener ugc nofollow" target="_blank"> Dog API </a>返回一个随机图像🐶：</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi my"><img src="../Images/68e408811989070b51cf3dd63210ed8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zu0OBqTi_3-Kvf_WFXSa_Q.png"/></div></div></figure><p id="1a9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我使用的是TypeScript——如果您喜欢JavaScript，请去掉类型定义(例如，<code class="fe mz na nb nc b">string</code>、<code class="fe mz na nb nc b">interface</code>块等等)。为了方便起见，最终的钩子存储在TypeScript 和JavaScript 中的<a class="ae ls" href="https://gist.github.com/simicd/02ce79612d0971441b33b7c816930d8e" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="7bf8" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">步骤1:定义一个自定义挂钩</h1><p id="4626" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">第一步是创建一个新文件(如<code class="fe mz na nb nc b">useFetch.ts</code>)并定义一个接受URL和请求参数作为输入的函数。按照惯例，钩子的前缀是<em class="nd">使用:</em></p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8b8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里需要注意一些事情:</p><ul class=""><li id="97a4" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn ne ku kv kw bi translated"><code class="fe mz na nb nc b">RequestProps</code>界面表示钩子的所有输入。<code class="fe mz na nb nc b">RequestInfo</code>和<code class="fe mz na nb nc b">RequestInit</code>是由<code class="fe mz na nb nc b">fetch()</code>函数定义的类型</li><li id="3d57" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated"><code class="fe mz na nb nc b">DogImageType</code>是API返回的类型(在本例中是一条带有图片url和状态消息的消息)</li><li id="2d20" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">自定义挂钩使用状态挂钩—更新状态将重新呈现调用者组件</li><li id="545f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">useEffect挂钩意味着副作用，即与React组件之外的功能的交互。例如保存到浏览器本地存储或调用API。</li><li id="8d28" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">在效果挂钩中，<code class="fe mz na nb nc b">fetch()</code>函数提交一个API请求。如果成功(状态码200)，数据被传递给状态设置器；否则，控制台中会显示一个错误。</li><li id="14c4" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">钩子只运行一次，因为第二个参数是一个空数组</li></ul><p id="f987" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你运行上面的代码，你会遇到一个错误。useEffect不接受异步函数！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nf"><img src="../Images/96d773e8cd58c8549c4cd89ca0d6018c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ValbxncMNjMxQEjasOr2eA.png"/></div></div></figure><p id="4eff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">广为接受的解决方法是:在同步函数中定义异步函数，并立即调用它:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c26f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">定制钩子现在应该可以工作了&amp;可以在组件中调用了。干净多了！</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="f99b" class="ng lu it bd lv nh ni dn lz nj nk dp md kb nl nm mh kf nn no ml kj np nq mp nr bi translated">指定依赖关系</h2><p id="aad4" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">第一个问题解决了，但是下一个问题已经在等着我们了。编译器将返回一个警告:<code class="fe mz na nb nc b">url</code>和<code class="fe mz na nb nc b">init</code>必须被指定为依赖项。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ns"><img src="../Images/9c1355980761b21a2f614c0846c5ec0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4W6EDZtSUm1yk49JzQqWZA.png"/></div></div></figure><p id="3dac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是为什么呢？效果挂钩中的<code class="fe mz na nb nc b">fetch()</code>功能取决于这两个参数。但是，它们不是在钩子的范围内创建的。对于空数组，它将在组件初始化时运行一次，然后不再运行。但是如果<code class="fe mz na nb nc b">url</code>或者<code class="fe mz na nb nc b">init</code>变了呢？</p><p id="2c46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能成为潜在的错误来源。显然，如果这两个参数中的任何一个发生变化，我们都希望钩子能够重新运行。因此，两者都应添加到数组<code class="fe mz na nb nc b">[url, init]</code>:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="e6d1" class="ng lu it bd lv nh ni dn lz nj nk dp md kb nl nm mh kf nn no ml kj np nq mp nr bi translated">作为依赖项的对象</h2><p id="51b7" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">一切都好吗？不完全是…</p><p id="2735" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我使用下面的例子调用钩子时，钩子被调用了一次，一次，一次…在我注意到之前，我在几分钟内结束了20，000次调用。为什么？<code class="fe mz na nb nc b">url</code>和<code class="fe mz na nb nc b">init</code>都没变？！</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="547e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过反复试验，我发现:</p><ul class=""><li id="38fd" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn ne ku kv kw bi translated">作为依赖变量的原始类型(字符串、数字、布尔)——没问题</li><li id="ebc6" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">依赖数组中的对象—无限循环(即使是空对象<code class="fe mz na nb nc b">{}</code></li></ul><p id="9998" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">useEffect似乎不执行对象的内容检查。相反，它将每个对象视为新的实例，即使它们具有相同的内容。在上例中，是<code class="fe mz na nb nc b">init: {}</code>导致了问题。潜在解决方案:</p><ul class=""><li id="caaa" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn ne ku kv kw bi translated">明确检查对象的各个键(例如<code class="fe mz na nb nc b">init.headers</code>、<code class="fe mz na nb nc b">init.body</code>，...).有十几个键，其中一些键本身就是对象。行不通。</li></ul><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nt"><img src="../Images/5c25a2374eddce4e9b2c906b460b8b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMnWicYTVpifCcKv--joHg.png"/></div></div></figure><ul class=""><li id="2c89" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn ne ku kv kw bi translated">使用<code class="fe mz na nb nc b">Object.values(init)</code>提取一个对象的所有值。这比前一个选项好，因为不需要输入所有的<code class="fe mz na nb nc b">init</code>键。但是，并不是所有的<code class="fe mz na nb nc b">init</code>值都是原始类型。这仍然会导致无限循环。</li></ul><p id="ab29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方法:带有<code class="fe mz na nb nc b">JSON.stringify(init)</code>的细长物体。如果对象没有改变，stringify将产生相同的字符串，并且不会重新运行。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="91f3" class="ng lu it bd lv nh ni dn lz nj nk dp md kb nl nm mh kf nn no ml kj np nq mp nr bi translated">没有复杂的评估</h2><p id="464f" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">下一个问题:linter抛出一个警告，在依赖列表中不允许复杂的求值。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nu"><img src="../Images/8c3406d7c526b15605bb5b2fc8fdeae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTVRzavS2FM2_4wYmvrDEA.png"/></div></div></figure><p id="fa6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将求值移到effect hook之前，并将两个字符串存储为变量，再次弹出一个熟悉的警告:<code class="fe mz na nb nc b">url</code>和<code class="fe mz na nb nc b">init</code>是依赖项，需要成为依赖数组的一部分。显然棉绒不知道<code class="fe mz na nb nc b">stringifiedInit</code>属于<code class="fe mz na nb nc b">init</code> …</p><p id="35fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我有意识地决定不发出警告，因为我知道有一个适当的依赖检查。为此，在依赖列表上方的行中添加<code class="fe mz na nb nc b">// eslint-disable-next-line react-hooks/exhaustive-deps</code>就足以消除警告。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><blockquote class="nv nw nx"><p id="ee06" class="jq jr nd js b jt ju jv jw jx jy jz ka ny kc kd ke nz kg kh ki oa kk kl km kn im bi translated"><em class="it"> ❓如果你有解决这个问题的替代方法的建议，我将非常感谢你的投入</em></p></blockquote><h1 id="5774" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">步骤2:处理响应的可选回调函数</h1><p id="284e" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">通常，API响应必须经过处理才能显示给用户。因此，我希望有可能传递一个函数(这里称为<code class="fe mz na nb nc b">processData</code>)，该函数获取json主体并将其重塑为所需的格式。</p><p id="6a71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为回调函数是可选的，所以它可能是未定义的。在这种情况下，一个简单的arrow函数将接受json主体并强制转换类型。</p><p id="98c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">const processJson = processData || ((jsonBody: any) =&gt; jsonBody as DogImageType);</code></p><p id="07b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里是迄今为止的完整代码:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="989c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…又是一个无限循环！</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e72f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原因:现在arrow函数的初始化是在每次渲染时创建一个新的实例。useEffect挂钩认为依赖关系已经改变，应该再次执行。</p><p id="ae03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，React提供了一个很好的方法:使用回调钩子。这个钩子接受一个函数作为输入，并返回相同的函数作为输出。唯一的区别是:返回的函数被缓存。</p><p id="879b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与效果挂钩类似，回调挂钩有一个依赖数组作为第二个参数。如果提供了一个空数组，那么React将只声明该函数一次——这正是我们需要的！</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="a98f" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">步骤3:泛型类型</h1><p id="5c6e" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">最后，钩子没有无限循环，也没有警告！然而，如果钩子应该是广泛适用的，那么返回类型可以是任何形式的数据。现在，钩子将总是返回一个对象<code class="fe mz na nb nc b">DogImageType</code>(即带有消息字段和状态字段)。</p><p id="49e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方案:<a class="ae ls" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型类型</a>。<strong class="js iu">泛型</strong>是一个存在于许多类型化编程语言中的概念。简而言之，它允许用占位符类型(通常用<code class="fe mz na nb nc b">T</code>表示)替换具体类型(例如<code class="fe mz na nb nc b">DogImageType</code>)。当函数最终被调用时，占位符被具体类型填充。</p><p id="729e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何把挂钩变成通用的？</p><ul class=""><li id="16c7" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn ne ku kv kw bi translated">在接口中，在接口名称后追加一个<code class="fe mz na nb nc b">&lt;T&gt;</code>→通用接口</li><li id="93f3" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">在函数声明中，在参数括号部分前加上<code class="fe mz na nb nc b">&lt;T&gt;(...)</code> →通用函数</li><li id="ac23" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">将函数或界面中的任何<code class="fe mz na nb nc b">DogImageType</code>替换为<code class="fe mz na nb nc b">T</code>(例如<code class="fe mz na nb nc b">useState&lt;DogImageType&gt;()</code> → <code class="fe mz na nb nc b">useState&lt;T&gt;()</code>)</li></ul><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ul class=""><li id="8781" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn ne ku kv kw bi translated">最后，调用函数时，传递具体类型(如<code class="fe mz na nb nc b">useFetch&lt;DogImageType&gt;(...)</code>)。在底层，获取挂钩现在将把<code class="fe mz na nb nc b">T</code>替换为<code class="fe mz na nb nc b">DogImageType</code>，并将数据返回为<code class="fe mz na nb nc b">DogImageType</code></li></ul><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="82ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，useFetch钩子现在也可以接受<code class="fe mz na nb nc b">fetch(...)</code>函数会接受的任何参数。它能够通过回调处理数据，最棒的是:调用API只需要一行代码！</p><h1 id="f28c" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">摘要📝</h1><blockquote class="nv nw nx"><p id="ca7b" class="jq jr nd js b jt ju jv jw jx jy jz ka ny kc kd ke nz kg kh ki oa kk kl km kn im bi translated"><em class="it">📦你可以在这里找到完整的</em> <a class="ae ls" href="https://gist.github.com/simicd/02ce79612d0971441b33b7c816930d8e" rel="noopener ugc nofollow" target="_blank"> <em class="it">打字码</em> </a> <em class="it">。关于</em> <a class="ae ls" href="https://gist.github.com/simicd/bbf37fe119c7b344634e4d47d2709fea" rel="noopener ugc nofollow" target="_blank"> <em class="it">的JavaScript版本请参见此处</em> </a>的链接</p></blockquote><p id="6c88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文中使用的钩子和挑战的总结:</p><h2 id="bcdd" class="ng lu it bd lv nh ni dn lz nj nk dp md kb nl nm mh kf nn no ml kj np nq mp nr bi translated">重新盖上内置挂钩</h2><ul class=""><li id="7477" class="ko kp it js b jt mr jx ms kb ob kf oc kj od kn ne ku kv kw bi translated">useState:状态挂钩存储信息，并在调用setter函数更新信息时触发重新呈现。</li><li id="f296" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">useEffect:每当React组件与组件之外的功能交互时(所谓的副作用)，都应该使用效果挂钩。示例:调用API。从磁盘读取文件。</li><li id="01c3" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">useCallback:如果在组件中定义了函数，React将在每次重新渲染时初始化它们。通常这在性能方面可以忽略不计。如果声明本身代价很高，回调钩子将缓存函数，并在后续的渲染中重用它。</li></ul><h2 id="884c" class="ng lu it bd lv nh ni dn lz nj nk dp md kb nl nm mh kf nn no ml kj np nq mp nr bi translated"><strong class="ak">问题&amp;解决方案💡</strong></h2><ul class=""><li id="8b62" class="ko kp it js b jt mr jx ms kb ob kf oc kj od kn ne ku kv kw bi translated">对象作为效果钩子中的依赖参数导致无限循环<br/> →用<code class="fe mz na nb nc b">JSON.stringfiy</code>变成字符串</li><li id="7dfc" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">函数在效果挂钩中作为依赖参数导致无限循环<br/> →使用回调挂钩仅实例化函数一次</li><li id="e1ca" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn ne ku kv kw bi translated">一般化函数返回类型<br/> →使用<a class="ae ls" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>用占位符类型替换具体类型</li></ul><h1 id="2ec6" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">后续步骤🚀</h1><p id="fd1d" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">如果API请求发生在初始化时，钩子将成功运行。但是，如果您想在按钮点击(或任何其他事件)时发送请求呢？这个话题会在下一篇博文中涉及！</p><h1 id="770d" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">在Twitter上关注我🌠</h1><p id="e08e" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">我定期分享关于Python、React和Azure Cloud的技巧——如果你感兴趣，我很乐意在推特<a class="ae ls" href="https://twitter.com/simicdds" rel="noopener ugc nofollow" target="_blank">✨与你见面</a></p></div></div>    
</body>
</html>