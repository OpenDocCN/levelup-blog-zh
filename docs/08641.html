<html>
<head>
<title>Introduction to Parallel Computing in Big Data Analysis (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大数据分析中的并行计算介绍(第二部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-parallel-computing-in-big-data-analysis-part-2-62f761c9efcf?source=collection_archive---------5-----------------------#2021-05-20">https://levelup.gitconnected.com/introduction-to-parallel-computing-in-big-data-analysis-part-2-62f761c9efcf?source=collection_archive---------5-----------------------#2021-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f98a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Dask运行并行和分布式人工智能任务</h2></div><p id="6b68" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人工智能(AI)任务通常涉及来自多个输入源的大量数据。这些数据集通常太大、太多样化，以至于单台机器无法正确有效地处理。因此，通常通过并行化和批处理这些任务来寻求机器集群。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/59e74dd96d03837b3aeb98221c2fe869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AJHnZVUQf6H9hiFB"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">莫里茨·金德勒在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e455" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，这篇文章将向您介绍由Pangeo使用Dask(一个用于并行计算的Python库)标准化的并行计算。此外，我们将使用一个气候科学的例子来说明本文中讨论的一些要点。事不宜迟，我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2cb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注意:</strong>这是我致力于探索大数据分析中的并行计算，尤其是新兴的地理信息领域的两部分系列文章的第二篇。在继续之前，请确保您已经阅读了下面的第一部分！</p><div class="mc md gp gr me mf"><a rel="noopener  ugc nofollow" target="_blank" href="/introduction-to-parallel-computing-in-big-data-analysis-part-1-959024183b73"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">大数据分析中的并行计算简介(第1部分)</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">使用Dask运行并行和分布式人工智能任务</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt lo mf"/></div></div></a></div><h1 id="fd25" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">目录:</h1><ol class=""><li id="c19a" class="nm nn it kk b kl no ko np kr nq kv nr kz ns ld nt nu nv nw bi translated">概述</li><li id="e9a2" class="nm nn it kk b kl nx ko ny kr nz kv oa kz ob ld nt nu nv nw bi translated">Dask阵列</li><li id="948f" class="nm nn it kk b kl nx ko ny kr nz kv oa kz ob ld nt nu nv nw bi translated">复变函数</li><li id="8f72" class="nm nn it kk b kl nx ko ny kr nz kv oa kz ob ld nt nu nv nw bi translated">Dask归约</li><li id="6a35" class="nm nn it kk b kl nx ko ny kr nz kv oa kz ob ld nt nu nv nw bi translated">Dask延迟</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3438" class="mu mv it bd mw mx oc mz na nb od nd ne jz oe ka ng kc of kd ni kf og kg nk nl bi translated">概述</h1><p id="8f26" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">在前一篇文章中，我们讨论了并行计算的基本原理、建立集群的方法以及如何并行化数据帧操作。</p><p id="3b99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将通过理解除了数据集之外，函数如何被减少和延迟以实现并行性来更深入地挖掘这一思想。</p><p id="2726" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f0dc" class="mu mv it bd mw mx oc mz na nb od nd ne jz oe ka ng kc of kd ni kf og kg nk nl bi translated">Dask阵列</h1><p id="240e" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">dask数组看起来和感觉起来很像numpy数组。然而，dask数组不直接保存任何数据，而是充当占位符，直到最终计算需要它。这种类型的操作被称为“懒惰”，因为它允许在将复杂的计算发送给调度程序执行之前象征性地构造这些计算。</p><p id="d437" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们首先创建一个形状为(1000，4000)的dask数组。</p><pre class="lf lg lh li gt ok ol om on aw oo bi"><span id="1cb8" class="op mv it ol b gy oq or l os ot">import dask.array as da</span><span id="7bed" class="op mv it ol b gy ou or l os ot">shape = (1000, 4000)<br/>ones = da.ones(shape)</span><span id="0729" class="op mv it ol b gy ou or l os ot">ones</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/95b8c0e7dafc63a9abd23d6f8a1097b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*zD9HEHveLO4dcv2G8vEPTQ.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Dask阵列</figcaption></figure><p id="cfba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与dataframe中的分区类似，我们也可以使用指定的形状在dask数组中创建“块”,如下所示:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/5d83508cc8740a105eb5ed9c2a736e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*iWpn4PuG3-26oZoxYchcGw.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Dask数组块(来源:<a class="ae lu" href="http://gallery.pangeo.io/repos/pangeo-data/pangeo-tutorial-gallery/dask.html#Dask-Arrays" rel="noopener ugc nofollow" target="_blank">pangeo.org</a>)</figcaption></figure><pre class="lf lg lh li gt ok ol om on aw oo bi"><span id="0fcf" class="op mv it ol b gy oq or l os ot">chunk_shape = (1000, 1000)<br/>ones = da.ones(shape, chunks=chunk_shape)</span><span id="7690" class="op mv it ol b gy ou or l os ot">ones</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/caca79b50a5839640345be6eee150875.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*Fo01E3zQYzr2EK2mf7-8eQ.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">分块dask阵列</figcaption></figure><p id="451a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们试着总结一下数组的元素，并想象分块是如何帮助我们并行的。</p><pre class="lf lg lh li gt ok ol om on aw oo bi"><span id="6019" class="op mv it ol b gy oq or l os ot">sum_of_ones = ones.sum()<br/>sum_of_ones.visualize(format='png')</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/fc1f0e19d84e48fbf7e5bf4fc8e2fcb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*qNdHSECGJSHv64zsH0lXzw.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">按区块排列的Dask阵列并行度</figcaption></figure><p id="2912" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与dask数据帧中的分区类似，dask阵列中的并行性包括:</p><ol class=""><li id="31b9" class="nm nn it kk b kl km ko kp kr oz kv pa kz pb ld nt nu nv nw bi translated">将1的数组分成四个块，</li><li id="ee23" class="nm nn it kk b kl nx ko ny kr nz kv oa kz ob ld nt nu nv nw bi translated">对每个组块执行求和，</li><li id="4beb" class="nm nn it kk b kl nx ko ny kr nz kv oa kz ob ld nt nu nv nw bi translated">总结他们，和</li><li id="983a" class="nm nn it kk b kl nx ko ny kr nz kv oa kz ob ld nt nu nv nw bi translated">输出结果</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6016" class="mu mv it bd mw mx oc mz na nb od nd ne jz oe ka ng kc of kd ni kf og kg nk nl bi translated">复变函数</h1><p id="aa44" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">现在，您已经熟悉了如何使用Dask并行化数据集(数据帧和数组),让我们构建一个复杂的函数，看看如何让它并行运行。</p><pre class="lf lg lh li gt ok ol om on aw oo bi"><span id="7f61" class="op mv it ol b gy oq or l os ot">complex_fn = (ones * ones[::-1, ::-1]).sum()<br/>complex_fn.visualize(format='png')</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/8cff19ae6f5fe1c0faa33273c34d0419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*UapEb0Te083y8KJ4vAyC8g.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">复杂函数的任务图</figcaption></figure><p id="d990" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的任务图看起来很复杂。我甚至不会试图跟踪并行任务中完成的单个操作。尽管如此，这就是Dask的美妙之处:您能够定义一些复杂的函数，并且该库将处理实际的并行性如何在幕后工作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="476c" class="mu mv it bd mw mx oc mz na nb od nd ne jz oe ka ng kc of kd ni kf og kg nk nl bi translated">Dask归约</h1><p id="a438" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">归约将预定义的函数应用于数组。例如，让我们定义一个函数如下:</p><pre class="lf lg lh li gt ok ol om on aw oo bi"><span id="42ea" class="op mv it ol b gy oq or l os ot">import numpy as np</span><span id="bcf2" class="op mv it ol b gy ou or l os ot">ones_reduce = (np.cos(ones)**2).mean(axis=1)<br/>ones_reduce</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/07cac7f17a5b8bca851772a759b8fee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*ntfItBJGTJKGyu_sWwarcg.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">数组的简化</figcaption></figure><p id="b4dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">dask中的归约方法仍然遵循一种“懒惰”模式，在这种模式下，数组不保存任何值，直到在计算过程中真正需要时才保存。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="609a" class="mu mv it bd mw mx oc mz na nb od nd ne jz oe ka ng kc of kd ni kf og kg nk nl bi translated">Dask延迟</h1><p id="620d" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">如果您想控制任务图表的外观，该怎么办？Dask delayed通过授予您对并行任务的完全控制权来实现这一点。</p><p id="b8e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看一组简单的除法、乘法和加法函数:</p><pre class="lf lg lh li gt ok ol om on aw oo bi"><span id="cba0" class="op mv it ol b gy oq or l os ot">import time</span><span id="0109" class="op mv it ol b gy ou or l os ot">def div(x, y):<br/>    time.sleep(0.1)<br/>    return x / y </span><span id="9e6a" class="op mv it ol b gy ou or l os ot">def mul(x, y):<br/>    time.sleep(0.1)<br/>    return x * y</span><span id="039c" class="op mv it ol b gy ou or l os ot">def add(x, y):<br/>    time.sleep(0.2)<br/>    return x + y</span></pre><p id="54a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会注意到，上面的三个函数彼此独立，通过巧妙的设计，它们可以很容易地并行化。</p><p id="3cef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们在dask中设置这些函数的延迟版本:</p><pre class="lf lg lh li gt ok ol om on aw oo bi"><span id="bc20" class="op mv it ol b gy oq or l os ot">import dask</span><span id="4e0b" class="op mv it ol b gy ou or l os ot">div = dask.delayed(div)<br/>mul = dask.delayed(mul)<br/>add = dask.delayed(add)</span></pre><p id="4f66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们依次调用这些函数:</p><pre class="lf lg lh li gt ok ol om on aw oo bi"><span id="ccad" class="op mv it ol b gy oq or l os ot">x = div(4,2)<br/>y = mul(2,3)<br/>z = add(x, y)</span><span id="1874" class="op mv it ol b gy ou or l os ot">z</span></pre><p id="828a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Dask将在幕后执行并行处理。您可以直观地观察任务图的外观。</p><pre class="lf lg lh li gt ok ol om on aw oo bi"><span id="c705" class="op mv it ol b gy oq or l os ot">z.visualize(format='png', rankdir='LR')</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/78b9bca9ade13f74a963ce8aafa9ab15.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*y5tZlfCRllGbL-xkK9L8lA.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Dask中的函数并行性</figcaption></figure><p id="f3ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上图中，我们可以看到，在执行最后的加法运算之前，除法和乘法函数是并行运行的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9152" class="mu mv it bd mw mx oc mz na nb od nd ne jz oe ka ng kc of kd ni kf og kg nk nl bi translated">结论</h1><p id="e3bc" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr oh kt ku kv oi kx ky kz oj lb lc ld im bi translated">就是这样！现在，您可以在更大的集群集中执行更复杂的并行任务。你现在怎么看待排比？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0a84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="pf">做订阅我的邮件简讯:</em></strong><a class="ae lu" href="https://tinyurl.com/2npw2fnz" rel="noopener ugc nofollow" target="_blank"><em class="pf">【https://tinyurl.com/2npw2fnz】</em></a><em class="pf"/><strong class="kk iu"><em class="pf">在这里我定期用通俗易懂的语言和漂亮的可视化总结AI研究论文。</em>T13】</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="016e" class="mu mv it bd mw mx oc mz na nb od nd ne jz oe ka ng kc of kd ni kf og kg nk nl bi translated">进一步阅读</h1><div class="mc md gp gr me mf"><a href="https://towardsdatascience.com/geopandas-hands-on-building-geospatial-machine-learning-pipeline-9ea8ae276a15" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">Geopandas实践:构建地理空间机器学习管道</h2><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="pg l mq mr ms mo mt lo mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://towardsdatascience.com/interactive-geospatial-ai-visualization-in-jupyter-notebook-f3223f534327" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">Jupyter笔记本中的交互式地理空间人工智能可视化</h2><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="ph l mq mr ms mo mt lo mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="http://gallery.pangeo.io/repos/TomAugspurger/pangeo-dask-gateway/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">Pangeo &amp; Dask网关。— Pangeo画廊文件</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">如何在Pangeo Hubs和Binders上使用Dask Gateway进行可扩展计算。</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">gallery.pangeo.io</p></div></div><div class="mo l"><div class="pi l mq mr ms mo mt lo mf"/></div></div></a></div></div></div>    
</body>
</html>