<html>
<head>
<title>GraphQLock: Secure your GraphQL application with ease</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQLock:轻松保护您的GraphQL应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphqlock-secure-your-graphql-application-with-ease-e7bc3b85baaa?source=collection_archive---------7-----------------------#2022-03-09">https://levelup.gitconnected.com/graphqlock-secure-your-graphql-application-with-ease-e7bc3b85baaa?source=collection_archive---------7-----------------------#2022-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6a07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发产品时，时间既宝贵又有限，这意味着开发人员希望能够专注于实际构建他们的应用程序，而不是担心如何保护它。</p><p id="0cda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了帮助开发人员专注于他们<em class="kl">希望</em>关注的事情，我们与OSLabs合作构建了GraphQLock，这是一个npm安全包，允许开发人员将基于角色的授权无缝集成到他们的GraphQL应用程序中。</p><h1 id="8626" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">授权和图表QL</h1><p id="9fe7" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">虽然GraphQL整合查询和端点的能力肯定有其优势，但它也带来了开发人员必须牢记的安全问题。其中最大的问题之一是授权——验证用户有权访问哪些特定数据的过程。GraphQL的单一端点很难实现有效的授权，这种授权足够灵活，可以处理前端可能抛出的每个查询。即使开发人员设法建立了完美的授权，向数据库中添加新表或修改现有的授权可能会既费时又容易出错。对于那些只想回到应用程序功能上的工程师来说，这是一件非常令人沮丧的事情。</p><h1 id="409e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">解决方案:GraphQLock</h1><p id="621f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">GraphQLock将所有这些繁琐的实现抽象为三个函数和一个JSON文件。</p><p id="234a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">创建角色和权限</strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/86e82cadebe5b4494c1d5ac6a82ebe78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*hiuB8NWwnoFLvKrduU2_Ig.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">graphqlock.json</figcaption></figure><p id="1cc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置graph lock的第一步(在您的终端中运行“<em class="kl">NPM I graph lock”</em>之后)是定义您的角色及其各自的权限。您可以在应用程序根目录下的一个名为<em class="kl"> graphqlock.json </em>的文件中这样做。角色被分配给他们可以执行的查询和变异，用“.”以表示对所有字段的访问。任何由在这个json文件中没有被授予该权限的角色执行的查询都将从服务器收到一个403状态。参考上面的例子，试图查询<em class="kl"> "animals" </em>的<em class="kl">承包商</em>或试图执行<em class="kl"> addCharacter </em>变异的<em class="kl">只读</em>角色都将返回<em class="kl"> 403禁止。</em></p><p id="530c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">设置图表锁功能</strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/4e6410661166511632cad1c648cb81cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bxgRNQcW8b-8jDkmU0Lrxg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">在GraphQLock的三个函数中需要</figcaption></figure><p id="eda4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，将这三个函数导入/要求到您的应用程序中。根据应用程序的体系结构，可能需要将这些功能放在单独的文件中。</p><p id="4888" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于第一个函数，只需在应用程序的主文件中调用<em class="kl"> createSecrets() </em>。</p><p id="79cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于第二个函数<em class="kl"> loginLink </em>，您需要将它作为中间件插入您的服务器登录路径。函数<em class="kl"> loginLink </em>要求前面的中间件函数分配<em class="kl"> res.locals.username </em>和<em class="kl"> res.locals.role </em>(在下面的例子中，这将是<em class="kl">user controller . verify log in</em>)。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/7402077cab3c9482eaa91563f3845ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*yz2q2t-14WwkjpxKa2HKDw.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">loginLink作为服务器登录路由中的中间件</figcaption></figure><p id="61fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于第三个函数<em class="kl"> validateToken </em>，只需将其插入到GraphQL端点的中间件中。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/e69c855b75712fada27ab0f7cb630e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*sm-TEw4R7Y_LewEsOgAHhw.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">验证GraphQL端点中作为中间件的令牌</figcaption></figure><p id="0ba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在应用程序的根目录下创建一个<em class="kl"> process.env </em>文件。在这个文件中把<em class="kl">蒙戈_URI </em>分配给你的蒙戈URI。</p><p id="c245" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序现在配备了全功能授权。开发人员不必担心授权问题，除非他们希望添加新的角色或更改权限，但即使这样，GraphQLock也会自动适应对<em class="kl"> graphqlock.json </em>文件所做的任何更改！</p><h1 id="ce4b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">它是如何工作的？</h1><p id="4646" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">GraphQLock利用存储在cookies中的JSON Web令牌(jwt)进行授权。jwt需要秘密，这由<em class="kl"> createSecrets </em>函数<em class="kl">处理。</em>这个函数为<em class="kl"> graphqlock.json </em>文件中定义的每个角色在<em class="kl"> process.env </em>文件中写入一个秘密，如果还没有的话。</p><p id="f87b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后loginLink中间件为每次登录创建两个jwt(一个访问令牌和一个刷新令牌)。然后，刷新令牌存储在Mongo DB中(GraphQLock仅通过URI将您连接到该数据库)，然后令牌存储在cookies中并发送回客户端。这些令牌是用生成到<em class="kl"> process.env </em>文件中的对应于其角色的随机秘密构建的。</p><p id="419c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，validateToken中间件检查访问令牌。如果不存在，它将检查有效的刷新令牌。如果存在有效的刷新令牌，则给予客户端新的刷新令牌以及新的访问令牌。然后在数据库中更新刷新令牌。如果这些步骤中的任何一步失败，请求将被拒绝，并返回403状态。如果没有抛出403状态，令牌将通过验证，然后从JSON文件中检查权限，以确定是否允许用户完成请求。</p><h1 id="137c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">为什么要使用存储在cookies中的jwt？</h1><p id="4c26" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">jwt简化了一些授权措施，同时也提供了可靠的安全性。因为我们可以在jwt上存储信息，所以服务器不需要保存任何关于分发给用户的令牌的信息(除了一个简单的刷新令牌数据库)。此外，jwt有很少的弱点，这些弱点主要源于不良实践，而不是内部的不安全感。JWTs最大的问题是保护您的秘密，这样令牌就不会被泄露。<em class="kl"> createSecrets </em>函数通过写入<em class="kl">来处理这个问题。env </em>文件，这将使它变得非常困难，因为一个恶意的参与者将不得不访问主机(如<em class="kl">)。env </em>文件应该在你的<em class="kl"> gitignore </em>上。</p><p id="3c7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与存储在本地存储相比，利用cookies来存储jwt给我们带来了一些好处。从可用性的角度来看，cookies是由浏览器自动管理的，维护跨站点子域的会话，并且大到足以舒适地存储jwt。从安全角度来看，这些令牌不受XSS攻击的影响，因为客户端JS无法读取仅支持HTTP的cookies。通过确保仅当请求来自发出它们的相同站点时cookies才被验证，CSRF攻击也变得无用。此外，没有服务器的秘密，MITM攻击是无害的。作为额外的保护层，GraphQLock甚至为每个角色提供了秘密，这使得授权更加强大。</p><h1 id="c148" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">介入</h1><p id="48f6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我在哪里可以拿到这个包裹？随着技术的不断发展，我们一直在寻求不断改进，并希望收到您的反馈！在Github上Fork GraphQLock，提交任何问题，或者为开源项目做贡献。请访问网站了解更多信息。</p><p id="fe86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GraphQLock工程师:</p><ul class=""><li id="4a0b" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">德雷克·威廉姆斯<a class="ae mr" href="https://github.com/DRWilliams527" rel="noopener ugc nofollow" target="_blank">Github</a>|<a class="ae mr" href="http://www.linkedin.com/in/williamsdrake" rel="noopener ugc nofollow" target="_blank">Linkedin</a></li><li id="9e1f" class="mi mj iq jp b jq ms ju mt jy mu kc mv kg mw kk mn mo mp mq bi translated">查理·黄，<a class="ae mr" href="https://github.com/huangcharlie" rel="noopener ugc nofollow" target="_blank">Github</a>|<a class="ae mr" href="https://www.linkedin.com/in/huangcharlie" rel="noopener ugc nofollow" target="_blank">Linkedin</a></li><li id="cb8e" class="mi mj iq jp b jq ms ju mt jy mu kc mv kg mw kk mn mo mp mq bi translated">Github  | <a class="ae mr" href="https://www.linkedin.com/in/jchung07/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a></li><li id="7280" class="mi mj iq jp b jq ms ju mt jy mu kc mv kg mw kk mn mo mp mq bi translated">凤凰纽曼，<a class="ae mr" href="https://github.com/phoeN24" rel="noopener ugc nofollow" target="_blank">Github</a>|<a class="ae mr" href="https://www.linkedin.com/in/phoenixnewman/" rel="noopener ugc nofollow" target="_blank">Linkedin</a></li></ul></div></div>    
</body>
</html>