<html>
<head>
<title>8 Ways to Measure Execution Time in C/C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C/C++中测量执行时间的8种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/8-ways-to-measure-execution-time-in-c-c-48634458d0f9?source=collection_archive---------0-----------------------#2020-04-29">https://levelup.gitconnected.com/8-ways-to-measure-execution-time-in-c-c-48634458d0f9?source=collection_archive---------0-----------------------#2020-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4338" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不幸的是，没有放之四海而皆准的解决方案。在这里你会找到一些可用的选项。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3dba3ce050a85229ea0e981f0759e7b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nx9lqwLHaiK0ik29wY2CuA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@agebarros?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿格巴洛斯</a>拍摄的照片。</figcaption></figure><p id="48e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测量一个C/C++程序或它的一部分的执行时间有时比它应该的要困难，因为许多方法通常不能移植到其他平台。选择正确的方法很大程度上取决于您的操作系统、编译器版本，以及您所说的“时间”的含义。</p><p id="d0ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文包括一个全面的列表，列出了当前可用的一些最佳选项，以及每种选项的局限性。希望在这里你能找到一个或多个可以用于你的程序的选项。</p><h2 id="48ad" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">墙时间与CPU时间的关系</h2><p id="3bba" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，定义和区分这两个在测量执行时间时经常使用的术语是很重要的。</p><ol class=""><li id="cbbb" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><em class="mz">挂钟时间</em>(也称为<em class="mz">时钟时间</em>或<em class="mz">挂钟时间)</em>就是测量过程中经过的总时间。这是你可以用秒表测量的时间，假设你能够在你想要的执行点开始和停止它。</li><li id="ec23" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><em class="mz"> CPU时间</em>则是指CPU忙于处理程序指令的时间。等待其他事情完成(如I/O操作)所花费的时间不包括在CPU时间内。</li></ol><p id="1bfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该使用这些定义中的哪一个取决于您为什么首先测量程序的执行时间。在下面的列表中，大多数方法只能计算其中一种时间，而只有少数方法可以同时计算两种时间。同样重要的是，有些对Linux和Windows用户都可用，但有些只限于特定的操作系统。为了让读者更容易理解，我在每一节的开头明确列出了每种方法测量哪种时间，以及它在哪些系统上可用。</p><h2 id="74ad" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">代码示例注释</h2><p id="08f3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">下面包含的代码示例基于计算无限和1/2⁰ + 1/2 + 1/2 + 1/2 + … = 2的近似值的程序。虽然循环的100次迭代足以得到精确的总和(至少在我的机器上——结果可能在其他平台上有所不同),但这些程序执行10亿次迭代以获得大量的时间来测量。</p><p id="652b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在那些程序中，CPU几乎100%的时间都很忙，所以墙时间和CPU时间几乎没有什么区别。如果你想在实验过程中让CPU空闲一段时间，你可以用函数<code class="fe nf ng nh ni b">sleep()</code>(在<code class="fe nf ng nh ni b">&lt;unistd.h&gt;</code>中可用)轻松实现。</p><p id="9068" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们开始我们的列表。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="ac70" class="nq lt iq bd lu nr ns nt lx nu nv nw ma jw nx jx md jz ny ka mg kc nz kd mj oa bi translated">1.使用“time”Linux命令</h1><p id="bb4f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><strong class="ky ir"> <em class="mz">上的作品:</em> </strong> <em class="mz">仅限Linux。(这实际上可以用于任何可以从终端执行的程序。)<br/> </em> <strong class="ky ir"> <em class="mz">措施:</em> </strong> <em class="mz">既墙时间又CPU时间。</em></p><p id="9c71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，这不是真正的C/C++代码。但是，因为它可能对许多运行Linux的人来说已经足够了，所以我决定在更复杂的选项之前包含这个选项。如果你只是想测量整个程序的CPU和/或墙时间，你真的不需要为此修改你的代码。只要在你通常从终端命令行运行你的程序之前写<code class="fe nf ng nh ni b">time</code>。然后，当你的程序执行完毕，测得的时间会显示在屏幕上。像这样:</p><pre class="kg kh ki kj gt ob ni oc od aw oe bi"><span id="4334" class="ls lt iq ni b gy of og l oh oi">$ time ./MyProgram<br/>Result: 2.00000000000000000000 <br/> <br/>real 0m5.931s <br/>user 0m5.926s <br/>sys 0m0.005s</span></pre><p id="901c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在输出中,' real '表示墙时间,' user '表示CPU时间，因此您可以在不更改一行代码的情况下获得整个程序的两个测量值。然而，如果你想测量程序的<em class="mz">独立部分</em>所花费的时间，那么你需要下面的一个选项。</p><p id="5a77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注:</strong>在写这篇文章之前，我一直以为Windows有自己版本的<code class="fe nf ng nh ni b">time</code>命令作为它的命令提示符，所以当我发现它没有时，我真的很惊讶。如果感兴趣的话，你可以在网上找到一些替代方案，但是我认为将时间测量直接嵌入到你的C/c++代码中会更容易移植。</p><h1 id="fd27" class="nq lt iq bd lu nr oj nt lx nu ok nw ma jw ol jx md jz om ka mg kc on kd mj oa bi translated">2.使用<chrono/></h1><p id="748b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><strong class="ky ir"> <em class="mz">工作于:</em></strong><em class="mz">Linux&amp;Windows，</em> <strong class="ky ir"> <em class="mz">但要求C++11或更高版本。</em></strong><em class="mz"><br/></em><strong class="ky ir"><em class="mz">措施:</em> </strong> <em class="mz">墙时间。</em></p><p id="597a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能是现今最好也是最便携的测量墙时间的方法，但它只在C++11和更高版本上可用。如果您的项目/编译器不支持C++11，您将需要本文中列出的其他选项之一。</p><p id="e1e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个库可以访问你机器中的一些不同的时钟，每个时钟都有不同的目的和特性。如果你愿意，你可以在这里获得每种时钟<a class="ae kv" href="https://en.cppreference.com/w/cpp/chrono" rel="noopener ugc nofollow" target="_blank">的更多细节。但是，除非你真的需要一个不同的时钟，我会推荐简单地使用<code class="fe nf ng nh ni b">high_resolution_clock</code>。这一个使用最高分辨率的时钟，所以对大多数人来说可能是足够的。下面是它的使用方法:</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a1bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在第19行看到的，我们选择将测量的时间转换为纳秒(尽管后来我们将其转换为秒)。如果您愿意，您可以修改代码来使用您选择的另一个单元，使用<code class="fe nf ng nh ni b">chrono::hours</code>、<code class="fe nf ng nh ni b">chrono::minutes</code>、<code class="fe nf ng nh ni b">chrono::seconds</code>、<code class="fe nf ng nh ni b">chrono::milliseconds</code>或<code class="fe nf ng nh ni b">chrono::microseconds</code>。</p><p id="002a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>我看到有人提到，与其他C/C++方法相比，用这个库测量执行时间可能会增加相当大的开销，尤其是在一个循环中多次使用时。老实说，我自己没有测试过或体验过这个，所以我不能说太多。如果你觉得这是一个问题，也许你应该考虑下面的其他选项之一。</p><h1 id="95f1" class="nq lt iq bd lu nr oj nt lx nu ok nw ma jw ol jx md jz om ka mg kc on kd mj oa bi translated">3.用<sys>和gettimeofday()</sys></h1><p id="454c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><strong class="ky ir"> <em class="mz">工作于:</em></strong><em class="mz">Linux&amp;Windows。<br/> </em> <strong class="ky ir"> <em class="mz">措施:</em> </strong> <em class="mz">墙时间。</em></p><p id="db43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<code class="fe nf ng nh ni b">gettimeofday()</code>返回自1970年1月1日00:00:00 UTC起经过的时间(通常称为<em class="mz">纪元时间</em>)。棘手的是，该函数在单独的<code class="fe nf ng nh ni b">long int</code>变量中返回秒数和微秒数，因此要获得包括微秒数在内的总时间，您需要相应地将两者相加。以下是如何做到这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="9781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注1: </strong>如果不在乎秒的分数，可以通过计算<code class="fe nf ng nh ni b">end.tv_sec - begin.tv_sec</code>直接得到经过的时间。<br/> <strong class="ky ir">注2:T</strong><code class="fe nf ng nh ni b">gettimeofday()</code>的第二个参数用于指定当前时区。因为我们正在计算经过的时间，所以时区是不相关的，只要对<code class="fe nf ng nh ni b">begin</code>和<code class="fe nf ng nh ni b">end</code>使用相同的值。因此，我们对两个调用都使用了0。</p><h1 id="b979" class="nq lt iq bd lu nr oj nt lx nu ok nw ma jw ol jx md jz om ka mg kc on kd mj oa bi translated">4.用<time.h>和时间()</time.h></h1><p id="d5ef" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><strong class="ky ir"> <em class="mz">工作于:</em></strong><em class="mz">Linux&amp;Windows。<br/> </em> <strong class="ky ir"> <em class="mz">措施:</em> </strong> <em class="mz">壁时间，</em> <strong class="ky ir"> <em class="mz">但仅措施满秒。</em> </strong></p><p id="4c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<code class="fe nf ng nh ni b">time()</code>类似于<code class="fe nf ng nh ni b">gettimeofday()</code>，因为它返回从纪元时间开始经过的时间。但是有两个主要区别:首先，您不能指定时区，所以它总是UTC。第二，也是最重要的，它只返回<em class="mz">整秒</em>。因此，只有当测量的时间间隔超过几秒钟时，用这种方法测量时间才有意义。如果毫微微秒或微秒对您的测量很重要，您应该使用其他方法之一。这是如何使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="90a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注:</strong> <code class="fe nf ng nh ni b">time_t</code>其实和<code class="fe nf ng nh ni b">long int</code>是一样的，可以直接用<code class="fe nf ng nh ni b">printf()</code>或者<code class="fe nf ng nh ni b">cout</code>打印，也可以很容易的将其转换成自己选择的另一种数值类型。</p><h1 id="157b" class="nq lt iq bd lu nr oj nt lx nu ok nw ma jw ol jx md jz om ka mg kc on kd mj oa bi translated">5.使用<time.h>和时钟()</time.h></h1><p id="3cf5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><strong class="ky ir"> <em class="mz">工作于:</em></strong><em class="mz">Linux&amp;Windows。<br/> </em> <strong class="ky ir"> <em class="mz">度量:</em></strong><em class="mz">Linux上的CPU时间和Windows上的wall时间。</em></p><p id="8018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<code class="fe nf ng nh ni b">clock()</code>返回程序开始执行以来的时钟周期数。如果你用常数<code class="fe nf ng nh ni b">CLOCKS_PER_SEC</code>除它，你将得到程序已经运行了多长时间，以秒为单位。不过这根据操作系统的不同会有不同的含义:<strong class="ky ir">在Linux上你会得到CPU时间，而在Windows上你会得到wall时间。所以你在使用这个的时候必须非常小心。代码如下:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="982b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong> <code class="fe nf ng nh ni b">clock_t</code>也是一个<code class="fe nf ng nh ni b">long int</code>，所以需要先将其强制转换为浮点类型，然后再用<code class="fe nf ng nh ni b">CLOCKS_PER_SEC</code>除，要不然就会得到整数除法。</p><h1 id="9000" class="nq lt iq bd lu nr oj nt lx nu ok nw ma jw ol jx md jz om ka mg kc on kd mj oa bi translated">6.用<time.h>和clock_gettime()</time.h></h1><p id="4963" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><strong class="ky ir"> <em class="mz">作品上:</em> </strong> <em class="mz"> </em> <strong class="ky ir"> <em class="mz">只有Linux。</em></strong><em class="mz"><br/></em><strong class="ky ir"><em class="mz">措施:</em> </strong> <em class="mz">既墙时间又CPU时间。</em></p><p id="2852" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个工具的好处是你可以用它来测量墙时间和CPU时间。但是，它仅在Unix系统中可用。下面的例子测量了墙壁时间，但是您可以简单地通过用<code class="fe nf ng nh ni b">CLOCK_PROCESS_CPUTIME_ID</code>替换常量<code class="fe nf ng nh ni b">CLOCK_REALTIME</code>来修改它以测量CPU时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="7029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注1: </strong>除了<code class="fe nf ng nh ni b">CLOCK_REALTIME</code>和<code class="fe nf ng nh ni b">CLOCK_PROCESS_CPUTIME_ID</code>之外，还有其他的时钟可以配合此功能使用。你可以查看本页以获得更完整的列表。<br/> <strong class="ky ir">注2: </strong>该函数使用的结构<code class="fe nf ng nh ni b">timespec</code>与<code class="fe nf ng nh ni b">gettimeofday()</code>使用的非常相似(上面的方法#3)。但是，它包含纳秒而不是微秒，所以在转换单位时要小心。</p><h1 id="14c0" class="nq lt iq bd lu nr oj nt lx nu ok nw ma jw ol jx md jz om ka mg kc on kd mj oa bi translated">7.用<sysinfoapi.h>和GetTickCount64()</sysinfoapi.h></h1><p id="5386" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><strong class="ky ir"> <em class="mz">作品上:</em> </strong> <em class="mz"> </em> <strong class="ky ir"> <em class="mz">只有Windows。</em></strong><em class="mz"><br/></em><strong class="ky ir"><em class="mz">措施:</em> </strong> <em class="mz">墙时间。</em></p><p id="bcc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<code class="fe nf ng nh ni b">GetTickCount64()</code>返回系统启动后的毫秒数。也有32位版本(<code class="fe nf ng nh ni b">GetTickCount()</code>)，但是限定在49.71天，所以用64位的安全一点。下面是它的使用方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="5377" class="nq lt iq bd lu nr oj nt lx nu ok nw ma jw ol jx md jz om ka mg kc on kd mj oa bi translated">8.用<processthreadsapi.h>和GetProcessTimes()</processthreadsapi.h></h1><p id="632b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><strong class="ky ir"> <em class="mz">作用于:</em> </strong> <em class="mz"> </em> <strong class="ky ir"> <em class="mz">只适用于Windows。</em></strong><em class="mz"><br/></em><strong class="ky ir"><em class="mz">措施:</em> </strong> <em class="mz"> CPU时间。</em></p><p id="1d61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是目前列表中最复杂的方法，但是它是唯一可以用来测量Windows上CPU时间的方法。我不会详细说明它是如何工作的，因为它过于复杂，我自己也从未使用过，但是你可以看看<a class="ae kv" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesstimes" rel="noopener ugc nofollow" target="_blank">官方文档</a>了解更多细节。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="aaf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注:</strong>我改编了一个<a class="ae kv" href="https://stackoverflow.com/a/17440673" rel="noopener ugc nofollow" target="_blank">栈溢出答案</a>的代码，所以我想把所有的功劳归于在那里发布答案的用户Alexander Yee。事实上，他在那里介绍了一种很好的便携方法，用<code class="fe nf ng nh ni b">#ifdef</code>宏计算Linux和Windows机器上的墙和CPU时间，所以你可能也想在那里查看完整的答案。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="58bd" class="nq lt iq bd lu nr ns nt lx nu nv nw ma jw nx jx md jz ny ka mg kc nz kd mj oa bi translated">最后的想法</h1><p id="e897" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好了，现在你知道了:在C/C++中有很多方法可以测量执行时间。正如你所看到的，没有一个放之四海而皆准的解决方案:上述所有方法都有局限性，没有一个方法能够同时计算<em class="mz"/>墙时间和CPU时间<em class="mz">和</em><em class="mz"/>适用于Linux和Windows。然而，我希望这些方法中至少有一个对你的代码和你的目标有用。感谢您的阅读。</p><h1 id="6735" class="nq lt iq bd lu nr oj nt lx nu ok nw ma jw ol jx md jz om ka mg kc on kd mj oa bi translated"><strong class="ak">建议文献</strong></h1><ul class=""><li id="1bf6" class="mq mr iq ky b kz ml lc mm lf oq lj or ln os lr ot mw mx my bi translated"><a class="ae kv" href="https://www.amazon.com/gp/product/0321563840/ref=as_li_tl?ie=UTF8&amp;tag=chaulio0b-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0321563840&amp;linkId=47d5056be0a1d80224ce6562c24b6820" rel="noopener ugc nofollow" target="_blank">c++编程语言</a>，作者比雅尼·斯特劳斯特鲁普。</li><li id="bda2" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr ot mw mx my bi translated"><a class="ae kv" href="https://www.amazon.com/gp/product/1839216549/ref=as_li_tl?ie=UTF8&amp;tag=chaulio0b-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=1839216549&amp;linkId=259341cc8501281fe93f136a6ce0d098" rel="noopener ugc nofollow" target="_blank"> C++高性能:掌握优化C++代码功能的艺术</a>，比约恩·安德里斯特和维克多·瑟尔著。</li></ul><h1 id="9c45" class="nq lt iq bd lu nr oj nt lx nu ok nw ma jw ol jx md jz om ka mg kc on kd mj oa bi translated">更多由同一作者</h1><div class="ou ov gp gr ow ox"><a rel="noopener  ugc nofollow" target="_blank" href="/what-big-o-really-means-e5f15044c9d2"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">“大O”的真正含义是什么</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">大多数时候，大O符号的用法都有点不正确。</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl kp ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://towardsdatascience.com/the-math-behind-big-o-and-other-asymptotic-notations-64487889f33f" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">“大O”和其他渐近符号背后的数学</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">像“大O”、“大ω”和“大θ”这样的符号的正式定义。</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl kp ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://towardsdatascience.com/version-control-with-git-get-started-in-less-than-15-minutes-696b4ce7ce92" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">使用Git进行版本控制:不到15分钟即可开始</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">完全初学者的循序渐进教程。</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="pn l pi pj pk pg pl kp ox"/></div></div></a></div><h1 id="0c5f" class="nq lt iq bd lu nr oj nt lx nu ok nw ma jw ol jx md jz om ka mg kc on kd mj oa bi translated">资源</h1><p id="15c0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果您需要更多信息，您可以在下面找到本文中列出的每种方法的更详细的文档:</p><ol class=""><li id="2ceb" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><a class="ae kv" href="http://man7.org/linux/man-pages/man1/time.1.html" rel="noopener ugc nofollow" target="_blank">‘时间’Linux命令</a></li><li id="1201" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><a class="ae kv" href="https://en.cppreference.com/w/cpp/chrono" rel="noopener ugc nofollow" target="_blank"> &lt;计时</a> &gt;</li><li id="5a35" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><a class="ae kv" href="http://man7.org/linux/man-pages/man2/gettimeofday.2.html" rel="noopener ugc nofollow" target="_blank"> gettimeofday() </a></li><li id="6000" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><a class="ae kv" href="http://man7.org/linux/man-pages/man2/time.2.html" rel="noopener ugc nofollow" target="_blank">时间()</a></li><li id="8aa3" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><a class="ae kv" href="http://man7.org/linux/man-pages/man3/clock.3.html" rel="noopener ugc nofollow" target="_blank">时钟()</a></li><li id="6ef7" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><a class="ae kv" href="https://linux.die.net/man/2/clock_gettime" rel="noopener ugc nofollow" target="_blank"> clock_gettime() </a></li><li id="87fc" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><a class="ae kv" href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount64" rel="noopener ugc nofollow" target="_blank"> GetTickCount64() </a></li><li id="42d2" class="mq mr iq ky b kz na lc nb lf nc lj nd ln ne lr mv mw mx my bi translated"><a class="ae kv" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesstimes" rel="noopener ugc nofollow" target="_blank"> GetProcessTimes() </a></li></ol></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="54d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mz">披露:此帖子包含一个或多个来自亚马逊服务有限责任公司协会计划的链接。作为代销商，我从通过这些链接购买的商品中获得佣金，客户无需支付额外费用。</em></p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="6122" class="nq lt iq bd lu nr ns nt lx nu nv nw ma jw nx jx md jz ny ka mg kc nz kd mj oa bi translated">分级编码</h1><p id="9489" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">感谢您成为我们社区的一员！升级正在改变技术招聘。<a class="ae kv" href="https://jobs.levelup.dev/talent" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">在最好的公司找到你的完美工作</strong></a><strong class="ky ir"/>。</p><div class="ou ov gp gr ow ox"><a href="https://jobs.levelup.dev/talent" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">提升——改变招聘流程</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">🔥让软件工程师找到他们热爱的完美角色🧠寻找人才是最痛苦的部分…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">作业. levelup.dev</p></div></div><div class="pg l"><div class="po l pi pj pk pg pl kp ox"/></div></div></a></div></div></div>    
</body>
</html>