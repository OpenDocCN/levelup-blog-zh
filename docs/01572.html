<html>
<head>
<title>Protecting JavaScript Microservices on Node.js with JSON Web Tokens and Twilio Authy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JSON Web令牌和Twilio Authy保护Node.js上的JavaScript微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/protecting-javascript-microservices-on-node-js-with-json-web-tokens-and-twilio-authy-90d8ed780f5e?source=collection_archive---------15-----------------------#2020-01-13">https://levelup.gitconnected.com/protecting-javascript-microservices-on-node-js-with-json-web-tokens-and-twilio-authy-90d8ed780f5e?source=collection_archive---------15-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5c0ca65a62dba270d4b3b36b02b39807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rPDcSqUvVD20SsKi.png"/></div></div></figure><p id="e02b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用微服务架构在Node.js上构建JavaScript应用程序可以让您扩展应用程序:您可以通过添加和删除服务实例来响应不同的负载水平。当一个服务的多个实例访问相同的数据时，您的应用程序可以使用一个公共的持久层(数据库)在实例之间共享信息，并保持它们之间的一致性。</p><p id="0c00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在许多应用程序中，您还希望限制特定用户对某些数据和功能的访问。虽然您可以直接在您的服务API中这样做，但是有一个更好的方法。</p><p id="9ce5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章将向您展示如何使用Twilio Authy和一个使用<a class="ae kz" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank"> JSON web令牌</a> (JWTs)的授权Web服务添加双因素身份验证(2FA)，这是一个安全存储和传输敏感数据的标准。</p><h1 id="61b4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用Twilio Authy进行身份验证</h1><p id="0e7e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae kz" href="https://www.twilio.com/authy" rel="noopener ugc nofollow" target="_blank"> Twilio Authy </a>使用推送认证来验证用户的身份。推送认证优于密码，因为它们要求用户能够访问已知与用户相关联的第二因素设备。Authy还可以配置为使用通过SMS或语音传输的软令牌和一次性密码。</p><h1 id="75e9" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用JSON Web令牌(jwt)进行授权</h1><p id="3aff" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">jwt使您的服务能够使用公钥/私钥加密来传输关于用户和其他数据对象的信息，以提供数据<em class="md">安全性</em>和令牌签名来确保数据<em class="md">完整性</em>。因为jwt可以携带关于用户及其授权声明的信息，所以它们可以通过启用服务来避免重复调用授权服务，从而提高应用程序的性能。授权服务可以将用户的授权声明存储在JWT的有效负载中。接收带有令牌的API调用的服务可以对令牌进行评估，从而确定调用者是否可以访问服务的数据或方法。</p><p id="3b27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，你将学习如何使用一个<em class="md">签名的</em> JWT，它由JSON对象结构的三部分组成:</p><ul class=""><li id="69a4" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">标头—用于加密令牌的算法的标识</li><li id="113a" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">有效负载—存储在令牌中的信息</li><li id="d86a" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">签名—报头和有效负载的加密签名</li></ul><p id="38f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这三个部分是Base64Url <strong class="kd iu">编码的</strong>，由点分隔符(<code class="fe ms mt mu mv b">.</code>)分隔，这使得令牌可以作为字符串值与其他系统和应用程序轻松交换，如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="4ec8" class="ne lb it mv b gy nf ng l nh ni">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span></pre><p id="71a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果能够访问令牌的公钥，其他系统可以轻松解码令牌并读取其内容。如果服务或应用程序可以访问公钥(由用于标记令牌的私钥生成)，它可以通过检查签名是否匹配来验证内容是否被修改。</p><p id="7f4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">拥有<em class="md">公钥</em>的实体不能对令牌进行签名，因此不能改变令牌内容；如果有效负载内容发生变化，签名将不会匹配。签名证明只有持有私钥的一方签署了令牌。JWT规范的完整描述可以在<a class="ae kz" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>文件中找到。</p><p id="5d77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章中的代码使用了<a class="ae kz" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> OpenSSL </a>中的密码库来生成加密和解密的密钥，但是使用它并不需要你对这个库或者密码有太多的了解。您也不需要执行复杂的安装或构建过程来使用加密技术。</p><h1 id="ec49" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">先决条件</h1><p id="5a5c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了完成这篇文章中的任务，你需要:</p><ul class=""><li id="e74f" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated"><a class="ae kz" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js和npm</a>(node . js安装也会安装NPM。)</li><li id="56ea" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae kz" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank"> Git </a>(对于Windows用户，Git安装还会安装一个OpenSSL可执行文件。)</li><li id="fef8" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae kz" href="https://www.java.com/en/download/" rel="noopener ugc nofollow" target="_blank"> Java SE运行时环境</a></li><li id="3316" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae kz" href="https://cloud.mongodb.com/user" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas账户</a>(选择自由层集群。)</li><li id="8fea" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">Twilio账户(有一个免费的开发者账户。)</li><li id="5792" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">一个<a class="ae kz" href="https://www.twilio.com/authy" rel="noopener ugc nofollow" target="_blank"> Twilio Authy </a> API密钥和一个注册用户(也是免费的，参见下面的说明。)</li></ul><p id="f761" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要从这篇文章中最有效地学习，你应该具备以下条件:</p><ul class=""><li id="934b" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">JavaScript、Node.js和数据库的工作知识</li><li id="6924" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">对HTTP协议的一些暴露</li><li id="3d07" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae kz" href="https://medium.com/swlh/building-javascript-microservices-with-node-js-d88bf0bb2b92" rel="noopener">微服务架构的基础知识</a></li></ul><p id="d24b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章是建立在关于使用Node.js微服务构建生产就绪型应用程序的前三篇文章的代码和概念之上的:</p><p id="b933" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://medium.com/swlh/building-javascript-microservices-with-node-js-d88bf0bb2b92" rel="noopener">用Node.js构建JavaScript微服务</a> —介绍微服务的概念，并向您展示如何在Node.js上用JavaScript构建微服务应用</p><p id="5cd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/implementing-eureka-and-zuul-for-service-discovery-and-dynamic-routing-in-javascript-microservices-45a7ac18837a" rel="noopener">在Node.js上运行的JavaScript微服务中为服务发现和动态路由实现Eureka和Zuul</a>—演示如何将网飞Eureka服务注册中心和网飞Zuul的动态路由和负载平衡集成到微服务应用中。</p><p id="4e44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/scaling-node-js-javascript-microservices-on-shared-mongodb-atlas-cloud-persistence-layers-620bf975ebfd" rel="noopener"> Scaling Node.js JavaScript微服务共享一个MongoDB Atlas Cloud持久层</a> —展示如何跨多个服务实例共享数据以实现一致性和同步。</p><p id="e71c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您已经阅读了之前的帖子并遵循了项目的构建，您可以继续使用您现有的代码，或者从GitHub上的<a class="ae kz" href="https://github.com/maciejtreder/introduction-to-microservices" rel="noopener ugc nofollow" target="_blank">配套库</a>重新开始。</p><p id="cd41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您不熟悉这些文章标题中的概念，您可能希望阅读它们并一步一步地构建项目。</p><p id="b267" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您熟悉微服务，并且希望专注于学习实现授权服务和JSON Web令牌，那么配套的资源库中有您开始这篇文章所需的代码。下面的说明将向您展示如何编写本系列前三篇文章中的代码。</p><h1 id="7133" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">微服务项目的架构</h1><p id="82af" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">案例研究项目由四个服务和一个作为持久层的MongoDB数据库组成。Node.js上运行着两个JavaScript服务:</p><p id="57b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">维护超级英雄的列表、他们的属性以及他们的忙/闲状态。</p><p id="235c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mv b">threats-service</code>–维护一个危险情况列表，以及负责应对各种威胁的英雄。</p><p id="9ae1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些服务使用一个助手函数<code class="fe ms mt mu mv b">registerWithEureka</code>，这使得它们能够方便地连接到服务发现系统。这些组件共同构成了应用程序的功能方面。</p><p id="2835" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有两个Java服务为Node.js服务提供基础设施支持:</p><p id="d524" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">网飞尤里卡</strong> —是一个服务注册和发现工具，使服务能够找到其他服务，而不需要知道它们在哪里运行。</p><p id="5368" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">网飞·祖尔是一个负载平衡器和动态路由服务，它从尤里卡获得每个服务的可用实例列表，在服务之间路由请求，并在服务器实例之间平衡负载。</p><p id="1c5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些Java服务是在Java归档文件中提供的。jar)文件:一旦安装了Java SE运行时环境，您需要做的就是运行它们。它们是打包的，所以您可以在自己的项目中使用它们，无需修改。</p><p id="1ec2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该项目的架构如下所示:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/6674e7ddb3d3ce33676b6d819f9eb35f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M6BoAhgEk90hb8sJ.jpg"/></div></div></figure><h1 id="1fb9" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置微服务项目</h1><p id="009b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">通过在您想要创建项目目录的目录中执行以下命令，从<a class="ae kz" href="https://github.com/maciejtreder/introduction-to-microservices" rel="noopener ugc nofollow" target="_blank">伴随库</a>中克隆代码:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c7c9" class="ne lb it mv b gy nf ng l nh ni">git clone <a class="ae kz" href="https://github.com/maciejtreder/introduction-to-microservices.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/introduction-to-microservices.git</a><br/>cd introduction-to-microservices<br/>git checkout step5<br/>cd heroes-v2<br/>npm install<br/>cd ../threats-v2<br/>npm install<br/>cd ../eureka-helper<br/>npm install<br/>cd ..</span></pre><p id="500a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，这些步骤包括在适当的目录中安装所需的npm软件包。</p><p id="c12a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您没有按照上一篇文章中的步骤构建项目，那么您需要创建MongoDB数据库实例并向其中插入数据。如果你<em class="md">一直在关注此事——并为此感到高兴——你可以跳过以下部分。</em></p><h1 id="a135" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置MongoDB持久层数据库</h1><p id="4c03" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">导航至<a class="ae kz" href="https://cloud.mongodb.com/user" rel="noopener ugc nofollow" target="_blank">https://cloud.mongodb.com/user</a>并登录您的账户。要注册新集群，请点击<em class="md">构建新集群</em>，然后选择最合适的地区和云基础设施提供商。(您可以选择“可用的免费层”区域，以避免运营费用。)</p><p id="869c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您的集群准备就绪时，单击<strong class="kd iu"> Connect </strong>按钮，并按照<em class="md"> Connect to Cluster() </em>面板上的提示:1)将您的连接IP地址列入白名单，2)创建一个MongoDB用户。</p><p id="7a87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">提示:</strong>创建密码时，避免使用在系统命令行中输入时必须进行URL编码的字符。请务必将您的MongoDB用户名和密码保存在安全的地方。</p><p id="21c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="md">选择连接方式</em>步骤中，选择<em class="md">与Mongo Shell </em>连接。按照适当的说明下载、安装和配置MongoDB Shell，以便在您的系统上运行。</p><p id="c78e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您将MongoDB Shell配置为在您的系统上运行时，将提供的命令行指令复制到一个安全的地方。在<em class="md">连接到集群()</em>对话框打开的情况下，保持该选项卡打开；你很快就会回来。</p><p id="5770" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在控制台窗口中执行命令行指令来启动shell。您需要输入刚刚创建的用户密码。</p><p id="7943" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">Windows用户提示:</strong>在PowerShell窗口中执行下面的MongoDB命令行指令；这将使您能够在一个步骤中粘贴并执行整个指令块。</p><p id="0e05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">成功连接到MongoDB实例后，通过执行以下MongoDB命令行指令向其添加数据:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9bd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让这个MongoDB控制台窗口保持打开，您稍后将会使用它。</p><p id="60a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到你的MongoDB Atlas账户控制台，点击集群旁边的<strong class="kd iu">连接</strong>按钮。在<em class="md">选择连接方法</em>步骤中，选择<strong class="kd iu">连接您的应用程序</strong>。在<em class="md">选择您的驱动程序版本</em>下，选择的值应该是:</p><p id="fb47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">驱动程序:Node.js</p><p id="12aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">版本:3.0或更高版本</p><p id="508b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅选择<strong class="kd iu">连接字符串</strong>并点击<strong class="kd iu">复制</strong>按钮。保存连接字符串；稍后您将使用它将Node.js服务连接到MongoDB Atlas数据库。</p><p id="6246" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据您选择的云服务，连接字符串应该如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f8b1" class="ne lb it mv b gy nf ng l nh ni">mongodb+srv://&lt;userid&gt;:&lt;password&gt;@cluster0-se0aa.azure.mongodb.net/test?retryWrites=true</span></pre><p id="d612" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在代码编辑器中打开<em class="md">/微服务简介</em>目录。找到<em class="md"> threats-v2/threats.js </em>和<em class="md"> heroes-v2/heroes.js </em>文件，并在每个文件中查找以下代码行:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b431" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用从MongoDB Atlas<em class="md">Connect to Cluster</em>对话框中获得的连接字符串的URL部分替换<code class="fe ms mt mu mv b">dbUrl</code>赋值的占位符文本。</p><p id="89b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将<code class="fe ms mt mu mv b">&lt;password&gt;</code>占位符替换为与您在MongoDB Atlas控制面板中创建的用户名相对应的密码(<a class="ae kz" href="https://cloud.mongodb.com/" rel="noopener ugc nofollow" target="_blank">https://cloud.mongodb.com</a>)。请注意，您不应该硬编码密码。这里这样做是为了简单起见，并使您的调试更容易。</p><p id="4cc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最佳实践是将密码存储为环境变量。使用这种技术，您的MongoDB连接URL将类似于:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="3d31" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">启动微服务应用程序</h1><p id="5b1c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">通过在应用程序的根目录中执行以下命令行指令来启动Eureka。这将是<em class="md">微服务简介</em>目录，除非您在克隆存储库时更改了目标目录。</p><p id="6915" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Windows用户应该在Windows命令提示符(cmd.exe)窗口而不是PowerShell窗口中执行以下指令以及所有后续指令，除非另有说明。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="bde8" class="ne lb it mv b gy nf ng l nh ni">java -jar eureka-service-0.0.1-SNAPSHOT.jar</span></pre><p id="e146" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在应用程序的根目录中打开第二个控制台窗口，通过执行以下命令行指令启动Zuul服务。这将是您打开的第二个控制台窗口:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="ec72" class="ne lb it mv b gy nf ng l nh ni">java -jar zuul-0.0.1-SNAPSHOT.jar --eureka.instance.leaseRenewalIntervalInSeconds=30</span></pre><p id="60b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意启动Zuul时使用的参数。它减少了Zuul从Eureka检索服务信息的时间间隔。这在开发环境中很有用，但是在生产环境中，您应该坚持使用默认设置。Spring文档提供了为什么注册服务的过程相对<a class="ae kz" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_why_is_it_so_slow_to_register_a_service" rel="noopener ugc nofollow" target="_blank">缓慢</a>的背景。</p><p id="8d99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在项目根目录中打开第三个控制台窗口，并执行以下命令行指令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="4cd2" class="ne lb it mv b gy nf ng l nh ni">node threats-v2/threats.js 5000</span></pre><p id="31e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在项目根目录中打开第四个控制台窗口，并执行以下命令行指令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c4c4" class="ne lb it mv b gy nf ng l nh ni">node heroes-v2/heroes.js 5001</span></pre><p id="3a24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过在一个新的控制台窗口(第五个窗口)中从项目根目录执行以下curl命令，检查是否一切正常:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="31c6" class="ne lb it mv b gy nf ng l nh ni">curl -i --request POST --header "Content-Type: application/json" --data "{\"heroId\": 1, \"threatId\": 1}" localhost:8080/threats-service/assignment</span></pre><p id="fd92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果服务运行正常，您应该会看到类似于curl的以下控制台输出的结果:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3d57" class="ne lb it mv b gy nf ng l nh ni">HTTP/1.1 202 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"79-ER1WRPW1305+Eomgfjq/A/Cgkp8"<br/>Date: Fri, 05 Apr 2019 18:05:54 GMT<br/>Content-Type: application/json;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="9ff0" class="ne lb it mv b gy nm ng l nh ni">{"id":1,"displayName":"Pisa tower is about to collapse.","necessaryPowers":["flying"],"img":"tower.jpg","assignedHero":1}</span></pre><h1 id="38c8" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实现基于JWT的授权服务</h1><p id="775e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">应用程序的<em class="md">授权</em>部分决定一个经过身份验证的用户是否有权访问一个API的端点。</p><p id="69b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要在这个应用程序中实现授权服务，您需要向数据库添加几个管理员。在下一节将要学习的身份验证和授权过程中，您将检索到关于它们的信息。</p><p id="607f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用您之前打开的MongoDB CLI控制台窗口，执行以下命令:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="19fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让此控制台窗口保持打开，您稍后将会使用它。</p><p id="c983" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个记录<code class="fe ms mt mu mv b">id:1</code>的密码数据元素是字符串<code class="fe ms mt mu mv b">abc1234!</code>的阿沙-3散列，它是<code class="fe ms mt mu mv b">admin1</code>用户的密码，第二个记录的密码数据元素是密码<code class="fe ms mt mu mv b">1234!abc</code>的散列。不要在数据库或其他地方以纯文本的形式存储密码。相反，应将密码存储为哈希值。您可以使用<a class="ae kz" href="https://www.browserling.com/tools/sha3-hash" rel="noopener ugc nofollow" target="_blank"> SHA-3散列生成器</a>来生成散列。</p><p id="0624" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到你的代码编辑器(或者，如果你是现代人，回到你的IDE)。</p><p id="481b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在项目的根目录<em class="md">/微服务简介</em>下，新建一个目录<em class="md"> auth </em>，并在其中新建一个文件<em class="md"> auth.js </em>。</p><p id="3df5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="md"> /auth </em>目录中打开一个控制台窗口，通过执行以下命令行指令初始化npm项目并安装必要的依赖项:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="bc0d" class="ne lb it mv b gy nf ng l nh ni">npm init -y<br/>npm install body-parser express mongodb jsonwebtoken authy</span></pre><p id="ea13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为您将使用JSON Web令牌在服务之间交换关于授权用户的数据，所以您需要一对私有和公共密钥。要使用OpenSSL生成它们，请在项目根目录中执行以下命令。</p><p id="5ccf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Windows用户注意:如果你已经安装了Git，你可以在<em class="md">C:\ Program Files \ Git \ usr \ bin</em>目录中找到<em class="md">openssl.exe</em>可执行文件。注意，这个目录可能不包含在您的路径中，所以您需要将它添加到命令行指令中。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f338" class="ne lb it mv b gy nf ng l nh ni">openssl genrsa -out ./auth/private.key 2048<br/>openssl rsa -pubout -in ./auth/private.key -out ./public.key</span></pre><p id="1044" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将<code class="fe ms mt mu mv b">private.key</code>放在了<em class="md"> /auth </em>目录中，因为它将只被<code class="fe ms mt mu mv b">auth-service</code>用来签署令牌。<code class="fe ms mt mu mv b">public.key</code>文件存储在根目录中，因为它将被所有其他需要用这个公钥检查令牌签名的服务使用。</p><p id="ce29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过将以下JavaScript代码插入到<em class="md"> auth.js </em>文件中来实现授权服务:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9ac9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mv b">auth-service</code>有几个方面需要特别注意。还有一行你需要修改。</p><p id="64f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在文件的顶部，就在导入所需的模块之后，常量<code class="fe ms mt mu mv b">port</code>被分配给这个服务将要运行的端口号，这个端口号是在服务启动时在命令行上设置的。</p><p id="1d47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，<code class="fe ms mt mu mv b">app</code>常量初始化<a class="ae kz" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>应用程序。</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="530e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mv b">auth-service</code>使用持久层来获取管理员组中用户的信息，因此它需要访问云数据库。MongoDB连接的初始化方式与其他服务相同。</p><p id="60ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将下面代码行中的占位符替换为您在其他服务代码中相同位置使用的连接字符串，并将<code class="fe ms mt mu mv b">&lt;password&gt;</code>占位符替换为您在MongoDB Atlas控制面板中为用户创建的密码:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="abf1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">连接字符串用于创建MongoDB客户端的新实例，如果有连接问题，就会抛出一个错误，如下所示:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="81d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mv b">auth-service</code>的本质是<em class="md"> /auth </em>端点:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3869" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">常量<code class="fe ms mt mu mv b">privateKey</code>被设置为您用OpenSSL创建的文件中的值。它是用来签署代币的。</p><p id="a468" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码使用由用户提交并在HTTP POST请求中传递的<code class="fe ms mt mu mv b">userId</code>和<code class="fe ms mt mu mv b">password</code>在数据库中查找用户。如果值不匹配，服务将返回HTTP响应代码403未授权。否则，服务将构建一个包含三个声明的JSON Web令牌:</p><p id="d499" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mv b">exp</code>(expiration)——这是一个<em class="md">注册的</em>声明，表明令牌应该有效多长时间(上面的代码将其设置为10分钟有效)。)</p><p id="1f98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mv b">privileges</code>–这是一个<em class="md">私有</em>声明，用一个字符串数组表示用户被授予了什么特权</p><p id="2133" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mv b">iat</code>(<strong class="kd iu">I</strong>issued<strong class="kd iu">at</strong>)–这是由库自动生成的<em class="md">注册的</em>声明，用于标识令牌生成的时间。</p><p id="d3ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在<a class="ae kz" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank"> jwt.io简介</a>页面上对声明类型之间的差异进行简要概述，或者在RFC 7519的<a class="ae kz" href="https://tools.ietf.org/html/rfc7519#section-4" rel="noopener ugc nofollow" target="_blank">第4节中了解更多关于注册声明和公开声明的确切定义。</a></p><p id="4e5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe ms mt mu mv b">auth-service</code>代码中有两个最后的步骤:</p><ol class=""><li id="e319" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky nn mk ml mm bi translated">通过调用<code class="fe ms mt mu mv b">eureka-helper</code>服务向Eureka服务注册中心注册服务，这是项目基线代码的一部分，以及</li><li id="2629" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky nn mk ml mm bi translated">启动服务时，在命令行上指定的端口上启动Express应用程序:</li></ol><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7d6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一点上，你应该仍然有<code class="fe ms mt mu mv b">heroes-service</code>和<code class="fe ms mt mu mv b">threats-service</code>运行。您之前在单独的控制台窗口中启动了它们。</p><p id="8270" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开一个新的控制台窗口，在项目根目录下执行以下命令行指令启动<code class="fe ms mt mu mv b">auth-service</code>:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d4e4" class="ne lb it mv b gy nf ng l nh ni">node auth/auth.js 5004</span></pre><p id="94c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过向<em class="md"> /auth </em>端点发送以下否定测试来测试它(该测试将导致授权失败):</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="aa19" class="ne lb it mv b gy nf ng l nh ni">curl -i --request POST --header "Content-Type: application/json" --data "{\"userId\": \"admin2\", \"password\": \"bad_pass\"}" localhost:8080/auth-service/auth</span></pre><p id="6e7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">卷曲输出应类似于:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="cc7a" class="ne lb it mv b gy nf ng l nh ni">HTTP/1.1 401 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"f-gnkbM9TfQtU2OeaokCx158AlciA"<br/>Date: Fri, 10 May 2019 13:10:42 GMT<br/>Content-Type: text/html;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="b0e1" class="ne lb it mv b gy nm ng l nh ni">Unauthorized.</span></pre><p id="5caa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">HTTP 401响应代码表明<code class="fe ms mt mu mv b">userId:admin2</code>和<code class="fe ms mt mu mv b">password:bad_pass</code>未能通过数据库验证。如果测试产生了预期的结果，则服务处于活动状态，并且正在检查凭据。</p><p id="0e49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用存储在MongoDB数据库中的值执行正面测试:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c47e" class="ne lb it mv b gy nf ng l nh ni">curl -i --request POST --header "Content-Type: application/json" --data "{\"userId\": \"admin2\", \"password\": \"6015ee55ebac72d737fcec8327e40445dbf6c4cb2dde092e00c72becfa8bb827bdfe09d0490ed58666f098eb925f5aa64cf2676ca39758f445356c39b6964e45\"}" localhost:8080/auth-service/auth</span></pre><p id="d354" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">卷曲输出应类似于:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="b752" class="ne lb it mv b gy nf ng l nh ni">HTTP/1.1 200 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"1e1-0CxrLFqDII6JbKBtGcpBZtNElbU"<br/>Date: Thu, 02 May 2019 20:05:37 GMT<br/>Content-Type: application/json;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="780e" class="ne lb it mv b gy nm ng l nh ni">{"jwtToken":"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NTY4MzExMzcsInByaXZpbGVnZXMiOlsiQVNTSUdOX0hFUk8iXSwiaWF0IjoxNTU2ODI3NTM3fQ.AixOGTxHvL503gselDc9SF4NNXp_7Ypg1D65dyMa__z54dzoQ3-G8Dw83DcDK_7SVM8P0mY24pceumM9JanlFaYVgUSwJpue1waCG1E_i-0bsOjHlMYIaW9LoHDLT8_d_3THOX4IFgDoXpBj0kIyRUIjGSNI1QKted-zPy2V0mOKAgHvTyUg5xq_5ziS8I2W8pjILjJRfpb_a9Djuv9h0qIkHoyaFX11sANrfF68B8Ha3SOIzDLjgd31LR-8ymFODMpQv79XP6JU7nbeMnyothCG-CFLxnuPxSoefSAoAs2O_fA9GddqUntLZdzQcSdRzk-h_vkJorvuM_vovGcVOA"}</span></pre><p id="9f8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">HTTP 200响应代码表示在数据库中成功找到了用户的凭据。端点返回一个JWT，其中包含提供用户信息的声明以及两个标准声明。</p><p id="904c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以解码令牌并使用<a class="ae kz" href="https://jwt.io/#debugger-io" rel="noopener ugc nofollow" target="_blank"> jwt.io调试器</a>检查其内容。将<code class="fe ms mt mu mv b">jwtToken</code>有效负载的内容(JSON数据元素的value部分中双引号之间的所有内容，但不包括双引号)粘贴到Encoded textbox中。您应该在解码部分看到令牌的内容，如下面的屏幕截图所示:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/76dc9897afff39001542291c1055e730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PwCBpVfNqIgDVMmM.jpg"/></div></div></figure><p id="170b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以通过粘贴项目根目录中的<em class="md"> public.key </em>文件的全部内容，在VERIFY SIGNATURE下的第一个文本框中粘贴<em class="md">introduction-to-micro services</em>来验证令牌的签名。用户界面应自动更新以显示“签名已验证”。</p><p id="a714" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想使用GitHub上的配套资源库将您的<em class="md">代码</em>更新到这一步，请在您想要创建项目目录的目录中执行以下命令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6847" class="ne lb it mv b gy nf ng l nh ni">git clone <a class="ae kz" href="https://github.com/maciejtreder/introduction-to-microservices.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/introduction-to-microservices.git</a><br/>cd introduction-to-microservices<br/>git checkout step6<br/>cd eureka-helper<br/>npm install<br/>cd ../threats-v2<br/>npm install<br/>cd ../heroes-v2<br/>npm install<br/>cd ../auth<br/>npm install<br/>cd ..</span></pre><p id="d6a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，您仍然需要设置MongoDB数据库，并根据上面的说明向其中添加数据，包括每个数据操作命令，以使应用程序正常工作。如果替换正在运行的服务的和的代码，则需要停止并重新启动该服务。</p><h1 id="18dd" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">用JWTs保护API端点</h1><p id="a805" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在，您已经成功地利用JSON web令牌实现了授权服务，您可以使用它来保护应用程序的其他服务。有了<code class="fe ms mt mu mv b">auth-service</code>，你将能够保护<code class="fe ms mt mu mv b">heroes-service</code>和<code class="fe ms mt mu mv b">threats-service</code>免受未经授权的访问，帮助超级英雄战胜黑暗势力。</p><p id="8cd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从给<code class="fe ms mt mu mv b">heroes service</code>添加授权开始。在可用的控制台窗口中，切换到<em class="md"> heroes-v2 </em>目录，并安装所需的依赖项:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="887e" class="ne lb it mv b gy nf ng l nh ni">npm install jsonwebtoken</span></pre><p id="0701" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在可以将新的依赖项和公钥导入到<em class="md"> /heroes-v2/heroes.js </em>文件中。</p><p id="8ec6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="md">heroes-v2</em>/<em class="md">heroes . js</em>文件顶部的现有<code class="fe ms mt mu mv b">const</code>声明的正下方添加以下JavaScript代码:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2728" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实现一个新的端点，<em class="md"> /hero </em>，它将侦听POST请求，请求的有效负载包含对新英雄的描述。</p><p id="d6e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="md"> /hero/** </em>端点的<code class="fe ms mt mu mv b">app.post</code>方法上方的<em class="md"> heroes-v2/heroes.js </em>文件中添加以下JavaScript代码。请注意，以下代码实现了不同的端点，并且<strong class="kd iu">而非</strong>不会替换<em class="md"> /hero/id </em> ( <code class="fe ms mt mu mv b">hero/**</code>)端点的代码:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a032" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">修改更新现有英雄的<em class="md"> /hero/:id </em>端点(<code class="fe ms mt mu mv b">/hero/**</code>)，以使用JWT授权令牌。在<em class="md"> heroes-v2/heroes.js </em>文件中，在方法的开头添加以下代码:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6793" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="md"> hero/:id </em> ( <code class="fe ms mt mu mv b">/hero/**</code>)端点被<code class="fe ms mt mu mv b">threats-service</code>用来给一个威胁分配一个英雄，所以你也需要修改<em class="md"> threats-v2/threats.js </em>文件。</p><p id="a6d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">找到下面所示的<code class="fe ms mt mu mv b">app.post</code>方法的现有代码:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9039" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用下面一行替换<code class="fe ms mt mu mv b">headers:</code>参数:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0582" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">处理赋值是基于<code class="fe ms mt mu mv b">heroes-service</code>的响应，所以不需要给<code class="fe ms mt mu mv b">threats-service</code>增加JWT验证；通过<code class="fe ms mt mu mv b">heroes-service</code>检查授权。如果授权失败，该方法的最后一行将返回一个错误。</p><h1 id="a3e6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">测试修改后的端点</h1><p id="67a5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">您可以通过添加新的hero来测试对端点的修改。</p><p id="3337" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在项目根目录下创建一个<em class="md"> new-hero-payload.json </em>文件，并插入以下json代码:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a528" class="ne lb it mv b gy nf ng l nh ni">{<br/>   "type": "flying-dog",<br/>   "displayName": "Rex",<br/>   "powers": [1, 2, 3]<br/>}</span></pre><p id="e23a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在运行<em class="md"> /threats-v2/threats.js </em>和<em class="md">/heroes-v2/heroes . js</em>node . js应用程序的控制台窗口中，从项目根目录停止并重新启动应用程序。这些命令与您之前使用的命令相同，您可以在相同的控制台窗口中重新执行它们:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3688" class="ne lb it mv b gy nf ng l nh ni">node threats-v2/threats.js 5000<br/>node heroes-v2/heroes.js 5001</span></pre><p id="a35c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您的JSON Web令牌可能已经过期，因此可以通过在可用的控制台窗口中执行以下curl命令来获取一个新的令牌:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="1d53" class="ne lb it mv b gy nf ng l nh ni">curl -i --request POST --header "Content-Type: application/json" --data "{\"userId\": \"admin2\", \"password\": \"6015ee55ebac72d737fcec8327e40445dbf6c4cb2dde092e00c72becfa8bb827bdfe09d0490ed58666f098eb925f5aa64cf2676ca39758f445356c39b6964e45\"}" localhost:8080/auth-service/auth</span></pre><p id="ccfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将结果复制并粘贴到文本编辑器中。您将在接下来的步骤中使用它。</p><p id="0bc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将以下curl命令复制到您的文本编辑器中:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="ab15" class="ne lb it mv b gy nf ng l nh ni">curl -i --request POST --header "auth:token-obtained-from-auth-service" --header "Content-type: application/json" --data @new-hero-payload.json localhost:8080/heroes-service/hero</span></pre><p id="aa69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用先前复制到文本编辑器的<code class="fe ms mt mu mv b">jwtToken</code>元素中的数据替换<code class="fe ms mt mu mv b">token-obtained-from-auth-service</code>。它是下面示例中“jwtToken”的值(您的实际数据会有所不同):</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="0778" class="ne lb it mv b gy nf ng l nh ni">{"jwtToken":"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NTgzNzA2MDcsInByaXZpbGVnZXMiOlsiQVNTSUdOX0hFUk8iXSwiaWF0IjoxNTU4MzY3MDA3fQ.fPvDrn8UZ1no5NGBEVvRgOV9LxoCSQtHsf-K609928haKDR76jNuUqidcbFwZ07uBxxDTOa4p9GYl-PSCcoS3aU98GmYOgNMS0jUyOkuvjXI4LV-x1QqJR-u-5ESVpk3L6gs1Iky6Uc4AjAmB2TnofQF5nVeXRx_woJ26mcWbCxLcnU7jf13RcHWFTVd2cS2JIhs-pqr482jViufZrT-sGorpbRWkuqB94xvQ6ctu3vfalQ21Djaq07FZQbY59GIbqSDUROSMHAF6FItkGM_J3zC7S6InIbJQ2tkhE9i5AesVoe4_8Z3x7Xqe-TkGWp_gqO4q58PSFjlirk0UPj_5A"}</span></pre><p id="6c19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">生成的curl命令将如下所示(您的实际JWT数据会有所不同):</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d178" class="ne lb it mv b gy nf ng l nh ni">curl -i --request POST --header "auth:eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NTgzNzA2MDcsInByaXZpbGVnZXMiOlsiQVNTSUdOX0hFUk8iXSwiaWF0IjoxNTU4MzY3MDA3fQ.fPvDrn8UZ1no5NGBEVvRgOV9LxoCSQtHsf-K609928haKDR76jNuUqidcbFwZ07uBxxDTOa4p9GYl-PSCcoS3aU98GmYOgNMS0jUyOkuvjXI4LV-x1QqJR-u-5ESVpk3L6gs1Iky6Uc4AjAmB2TnofQF5nVeXRx_woJ26mcWbCxLcnU7jf13RcHWFTVd2cS2JIhs-pqr482jViufZrT-sGorpbRWkuqB94xvQ6ctu3vfalQ21Djaq07FZQbY59GIbqSDUROSMHAF6FItkGM_J3zC7S6InIbJQ2tkhE9i5AesVoe4_8Z3x7Xqe-TkGWp_gqO4q58PSFjlirk0UPj_5A" --header "Content-type: application/json" --data @new-hero-payload.json localhost:8080/heroes-service/hero</span></pre><p id="1779" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在项目根目录中执行这个HTTP POST请求，<em class="md">微服务简介</em>(或者您已经找到的<em class="md"> new-hero-payload.json </em>文件)。您还可以用<a class="ae kz" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>或PowerShell<a class="ae kz" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest?view=powershell-6" rel="noopener ugc nofollow" target="_blank">Invoke-WebRequest</a>来执行这个请求，方法是使用示例curl命令中的数据在这些工具中构造一个适当的查询。</p><p id="69dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该命令的输出应该类似于:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6615" class="ne lb it mv b gy nf ng l nh ni">HTTP/1.1 403 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"e-HWewxoOBFxgXa6ofj0mOIS8mvQc"<br/>Date: Thu, 02 May 2019 14:14:31 GMT<br/>Content-Type: text/html;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="d3aa" class="ne lb it mv b gy nm ng l nh ni">Access Denied.</span></pre><p id="bbb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您收到了HTTP 403响应，因为用户admin2没有创建新英雄的权限。您可以在运行<em class="md"> heroes-v2/heroes.js </em>的控制台窗口的<code class="fe ms mt mu mv b">heroes-service</code>输出中验证这一点。输出应该如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f146" class="ne lb it mv b gy nf ng l nh ni">Heroes v2: Adding new hero<br/>{ type: 'flying-dog', displayName: 'Rex', powers: [ 1, 2, 3 ] }<br/>Heroes v2: Token decoded, privileges:<br/>[ 'ASSIGN_HERO' ]<br/>Heroes v2: Requesting user does not have the CREATE_HERO privilege.</span></pre><p id="18f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尝试通过向<em class="md"> /assignment </em>端点发送HTTP POST请求，为threat分配一个英雄。如上所述，用之前获得的JWT令牌替换下面curl命令中的令牌占位符:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="596e" class="ne lb it mv b gy nf ng l nh ni">curl -i --request POST --header "auth:token-obtained-from-auth-service" --header "Content-Type: application/json" --data "{\"heroId\": 1, \"threatId\": 1}" localhost:8080/threats-service/assignment</span></pre><p id="cb40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该命令的输出应该类似于下面的代码片段:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="cfdb" class="ne lb it mv b gy nf ng l nh ni">HTTP/1.1 202 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"79-ER1WRPW1305+Eomgfjq/A/Cgkp8"<br/>Date: Thu, 02 May 2019 14:23:38 GMT<br/>Content-Type: application/json;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="ca18" class="ne lb it mv b gy nm ng l nh ni">{"id":1,"displayName":"Pisa tower is about to collapse.","necessaryPowers":["flying"],"img":"tower.jpg","assignedHero":1}</span></pre><h1 id="9d68" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">验证JSON Web令牌验证</h1><p id="ecd2" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">您可以验证授权服务是否保护应用程序免受格式错误的jwt的影响。为此，您可以更改JWT中包含授权数据的部分，将其替换为一个不同的值，赋予admin1用户更高的权限，然后重新提交请求。</p><p id="13a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">执行以下步骤来测试对提升权限攻击的防护:</p><p id="62e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">拷贝您一直使用的JWT的有效负载部分，该部分之前已存储到文本编辑器窗口中。在下面的示例中，有效负载是第一个点(<code class="fe ms mt mu mv b">.</code>)之后和第二个点之前的字符串(您的实际数据会有所不同):</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="63c8" class="ne lb it mv b gy nf ng l nh ni">{"jwtToken":"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NTgzNzA2MDcsInByaXZpbGVnZXMiOlsiQVNTSUdOX0hFUk8iXSwiaWF0IjoxNTU4MzY3MDA3fQ.fPvDrn8UZ1no5NGBEVvRgOV9LxoCSQtHsf-K609928haKDR76jNuUqidcbFwZ07uBxxDTOa4p9GYl-PSCcoS3aU98GmYOgNMS0jUyOkuvjXI4LV-x1QqJR-u-5ESVpk3L6gs1Iky6Uc4AjAmB2TnofQF5nVeXRx_woJ26mcWbCxLcnU7jf13RcHWFTVd2cS2JIhs-pqr482jViufZrT-sGorpbRWkuqB94xvQ6ctu3vfalQ21Djaq07FZQbY59GIbqSDUROSMHAF6FItkGM_J3zC7S6InIbJQ2tkhE9i5AesVoe4_8Z3x7Xqe-TkGWp_gqO4q58PSFjlirk0UPj_5A"}</span></pre><p id="2fe3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用浏览器从Google 页面导航到<a class="ae kz" href="https://toolbox.googleapps.com/apps/encode_decode/" rel="noopener ugc nofollow" target="_blank">编码/解码工具，将字符串粘贴到文本框中，选择<em class="md"> Base64解码</em>并点击<strong class="kd iu">提交</strong>。您应该会看到类似如下的文本:</a></p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f103" class="ne lb it mv b gy nf ng l nh ni">{"exp":1557865493,"privileges":["ASSIGN_HERO"],"iat":1557861893}</span></pre><p id="64fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用解码后的字符串替换文本框中的编码字符串，用<code class="fe ms mt mu mv b">"ASSIGN_HERO","CREATE_HERO"</code>替换<code class="fe ms mt mu mv b">"ASSIGN_HERO"</code>。选择<em class="md"> Base64编码</em>并点击<strong class="kd iu">提交</strong>。</p><p id="f675" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将结果复制到文本编辑器窗口。</p><p id="0027" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您花了将近10分钟才到达这一步，您可能需要在继续之前生成一个新令牌。使用与上面相同的过程，将内容放在文本窗口中。如果你速度很快，你可以使用你已经存储在文本窗口中的令牌。</p><p id="9966" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用从Base64编码器中检索到的文本替换有效令牌的有效负载部分，即第一个点(<code class="fe ms mt mu mv b">.</code>)之后的部分。现在你有一个畸形的JWT。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/77b9d5fa437978b10c0c5190f8abcec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DsdeBhhut0J-7k0M"/></div></div></figure><p id="0562" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用你新的畸形JWT，尝试用admin1用户ID创建一个新的英雄，它没有创建用户的权限。在下面的curl命令中，用您的畸形JWT替换占位符:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6819" class="ne lb it mv b gy nf ng l nh ni">curl -i --request POST --header "auth: malformed-token-goes-here" --header "Content-type: application/json" --data @new-hero-payload.json localhost:8080/heroes-service/hero</span></pre><p id="6703" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您应该会收到一个HTTP <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> 401未授权</a>响应，因为<code class="fe ms mt mu mv b">auth-service</code>检测到一个格式错误的令牌。仔细看看<code class="fe ms mt mu mv b">heroes-service</code>控制台输出:您应该看到应用程序检测到了格式错误的JWT并拒绝了它，如<em class="md"> heroes-v2/heroes.js </em>控制台窗口中输出的最后一行所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="e127" class="ne lb it mv b gy nf ng l nh ni">Heroes v2: Adding new hero<br/>{ type: 'flying-dog', displayName: 'Rex', powers: [ 1, 2, 3 ] }<br/>{ JsonWebTokenError: invalid signature<br/>    at Object.module.exports [as verify] (/Users/mtreder/introduction-to-microservices/heroes-v2/node_modules/jsonwebtoken/verify.js:75:17)<br/>    at app.post (/Users/mtreder/introduction-to-microservices/heroes-v2/heroes.js:45:27)<br/>    at Layer.handle [as handle_request] (/Users/mtreder/introduction-to-microservices/heroes-v2/node_modules/express/lib/router/layer.js:95:5)<br/>    at next (/Users/mtreder/introduction-to-microservices/heroes-v2/node_modules/express/lib/router/route.js:137:13)<br/>    at Route.dispatch (/Users/mtreder/introduction-to-microservices/heroes-v2/node_modules/express/lib/router/route.js:112:3)<br/>    at Layer.handle [as handle_request] (/Users/mtreder/introduction-to-microservices/heroes-v2/node_modules/express/lib/router/layer.js:95:5)<br/>    at /Users/mtreder/introduction-to-microservices/heroes-v2/node_modules/express/lib/router/index.js:281:22<br/>    at Function.process_params (/Users/mtreder/introduction-to-microservices/heroes-v2/node_modules/express/lib/router/index.js:335:12)<br/>    at next (/Users/mtreder/introduction-to-microservices/heroes-v2/node_modules/express/lib/router/index.js:275:10)<br/>    at /Users/mtreder/introduction-to-microservices/heroes-v2/node_modules/body-parser/lib/read.js:130:5 name: 'JsonWebTokenError', message: 'invalid token' }</span></pre><p id="6bba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为<em class="md"> /auth </em>服务检测到包含用户权限声明的JWT有效负载部分与签名不匹配，所以您的应用程序不会被坏人操纵。</p><p id="d5cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想使用GitHub上的配套资源库中的代码将您的<em class="md">代码</em>捕获到这一步，您可以在您想要创建项目目录的目录中执行以下命令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="1e68" class="ne lb it mv b gy nf ng l nh ni">git clone <a class="ae kz" href="https://github.com/maciejtreder/introduction-to-microservices.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/introduction-to-microservices.git</a><br/>cd introduction-to-microservices<br/>git checkout step7<br/>cd eureka-helper<br/>npm install<br/>cd ../threats-v2<br/>npm install<br/>cd ../heroes-v2<br/>npm install<br/>cd ../auth<br/>npm install<br/>cd ..</span></pre><p id="f64c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您没有按照创建和填充数据库的说明进行操作，那么您需要构建数据库并向其中添加数据，这样项目才能完全正常运行。如果你替换正在运行的服务的任何代码，你必须停止并重新启动它们。</p><h1 id="4b37" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实施双因素身份认证(2FA)</h1><p id="a922" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">应用程序现在有一个安全的授权系统。但是它依赖于一个单一的认证因素，即用户拥有的用户ID和密码。这是用户<em class="md">知道</em>的一个因素。众所周知，这些凭证很容易受到各种方式的破坏和滥用，那么如何使应用程序更加安全呢？</p><p id="5741" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最好的方法之一是实现第二认证因子。</p><p id="86bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了用户<em class="md">知道</em>的东西，双因素认证还需要用户<em class="md">拥有</em>(占有)或者<em class="md">是</em>(继承)的东西。</p><p id="13d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以使用<a class="ae kz" href="https://www.twilio.com/authy" rel="noopener ugc nofollow" target="_blank"> Twilio Authy </a>提供第二个因素，通过<em class="md">拥有</em>，通过几乎每个用户<em class="md">都有的东西</em>:手机(或其他设备)。如果你想了解更多关于用Twilio Authy实现2FA的信息，你可以参考本系列的前一篇文章:<a class="ae kz" href="https://www.twilio.com/blog/two-factor-authentication-angular-twilio-authy" rel="noopener ugc nofollow" target="_blank">用Twilio Authy在Angular中构建双因素认证</a>。</p><p id="3ed1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该项目的这一部分将向您展示如何使用Authy快速将2FA添加到Angular应用程序。您需要一个Twilio帐户来完成这些步骤。几分钟就可以注册一个<a class="ae kz" href="https://www.twilio.com/try-twilio" rel="noopener ugc nofollow" target="_blank">免费试用账号</a>。</p><p id="e132" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">拥有Twilio帐户后，登录并导航至<a class="ae kz" href="https://www.twilio.com/console" rel="noopener ugc nofollow" target="_blank"> Twilio控制台</a>的Authy部分，然后完成以下步骤。(几分钟就好了。)</p><ol class=""><li id="b7aa" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky nn mk ml mm bi translated">在Twilio控制台的Authy部分，创建一个新的应用程序</li><li id="7839" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky nn mk ml mm bi translated">将应用程序的<strong class="kd iu">生产API密钥</strong>复制到安全的地方。(如果您放错了，可以在应用程序的设置中找到密钥。)</li><li id="ed9c" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky nn mk ml mm bi translated">在您创建的应用程序中，使用您首选的电子邮件地址和手机号码将自己注册为新用户。</li><li id="6b87" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky nn mk ml mm bi translated">将您刚刚创建的用户的<strong class="kd iu">授权ID </strong>复制到一个安全的地方。</li><li id="a5a5" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky nn mk ml mm bi translated">在手机上安装Authy应用程序。您应该会收到一条文本通知，其中包含获取代码以完成安装的链接。</li></ol><p id="3a7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">成功完成上述步骤后，您可以实施双因素身份认证。</p><p id="1d3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将Authy ID添加到用户admin1的数据库记录中。</p><p id="22ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回到您之前打开的MongoDB CLI控制台窗口，执行以下指令，用您刚刚获得的Authy ID替换<code class="fe ms mt mu mv b">AUTH_ID</code>占位符:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6ba9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果更新操作成功，MongoDB控制台应该返回以下结果:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="844f" class="ne lb it mv b gy nf ng l nh ni">WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })</span></pre><p id="c256" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">需要更新<code class="fe ms mt mu mv b">auth-service</code>代码以使用双因素身份验证因子。</p><p id="9057" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用以下JavaScript代码替换<em class="md"> /auth/auth.js </em>文件的内容:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="70c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">分别用您的MongoDB连接字符串和Twilio Authy API键替换<code class="fe ms mt mu mv b">dbUrl</code>和<code class="fe ms mt mu mv b">API_KEY</code>常量的占位符。</p><p id="7f9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">新代码包括三个新功能:</p><p id="16a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mv b">authenticateWithAuthy(authyId)</code>–使用数据库中给定的认证ID向Twilio Authy API发送认证请求，并返回一个<code class="fe ms mt mu mv b">authyToken</code>。</p><p id="411a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mv b">checkAuthyStatus(authyToken)</code><em class="md"/>–检查特定<code class="fe ms mt mu mv b">authyToken</code>的身份验证请求的状态，如果请求成功通过身份验证，则返回null或与<code class="fe ms mt mu mv b">authyToken</code>的值相关联的身份验证ID。</p><p id="3a4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ms mt mu mv b">retrieveUserByAuthyId(authyId)</code>–使用授权ID从数据库中检索用户。</p><p id="18f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">新代码还修改了<em class="md"> /auth </em>端点。如果用户将标志<em class="md"> enabledSecondFactor </em>设置为true，基于数据库中的值，端点将使用Authy令牌而不是JSON Web令牌进行响应。然后，Authy令牌与新的端点<em class="md"> /auth/status </em>，<em class="md"> </em>一起使用，如果用户在他们的二次元设备上使用Authy应用程序验证了身份验证请求，该端点将返回一个JSON Web令牌。</p><p id="e9a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要运行修改后的<code class="fe ms mt mu mv b">auth-service</code>代码，您需要停止并重启服务。您可以使用相同的控制台窗口来启动修改后的服务，使用您之前在应用程序根目录中使用的相同命令行指令，<em class="md">微服务简介</em>:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6806" class="ne lb it mv b gy nf ng l nh ni">node auth/auth.js 5004</span></pre><p id="f275" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下图说明了整个应用程序的实现:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/0bf4dbb649ba7131659895d331c6d44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jV5rHbo9wynKb0Zh"/></div></div></figure><h1 id="6f6a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">测试双因素身份验证</h1><p id="3643" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">您可以通过尝试认证<code class="fe ms mt mu mv b">admin1</code>来验证2FA是否正常工作。</p><p id="771f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在控制台窗口中执行以下curl命令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="2c03" class="ne lb it mv b gy nf ng l nh ni">curl -i --request POST --header "Content-Type: application/json" --data "{\"userId\": \"admin1\", \"password\": \"fa786e94a24b297105a09f9a5673c4b2df9a11b6d9dfe229fde94124995b499f89cfbaa4974f55b0efeb6dfad6be6d9ecac591dd317e139a618e4217f728af78\"}" localhost:8080/auth-service/auth</span></pre><p id="6126" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输出应该类似于以下内容:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="1f26" class="ne lb it mv b gy nf ng l nh ni">HTTP/1.1 200 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"35-fSJXazE8F/LKWVqPBvpYn/6l5DI"<br/>Date: Thu, 02 May 2019 19:26:34 GMT<br/>Content-Type: application/json;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="290e" class="ne lb it mv b gy nm ng l nh ni">{"authyToken":"1ec53af0-4f3e-0137-eed6-1212da1336e0"}</span></pre><p id="793a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面显示的成功请求返回了一个Authy令牌。如果您遇到错误，请检查<code class="fe ms mt mu mv b">auth-service</code>的控制台输出，并检查您用于授权生产API密钥(<code class="fe ms mt mu mv b">API_KEY</code>)和您用户的授权ID的值，这些值可在<a class="ae kz" href="https://www.twilio.com/console/authy" rel="noopener ugc nofollow" target="_blank"> Twilio授权控制台</a>中找到。</p><p id="4edf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过执行以下curl命令，使用<code class="fe ms mt mu mv b">authyToken</code>的值向<em class="md"> /auth/status </em>端点发出请求，用执行上一个命令时返回的实际<code class="fe ms mt mu mv b">authyToken</code>值替换<code class="fe ms mt mu mv b">authyToken-goes-here</code>占位符的值:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d1fa" class="ne lb it mv b gy nf ng l nh ni">curl -i --request GET --header "authytoken: authyToken-goes-here" localhost:8080/auth-service/auth/status</span></pre><p id="75c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">响应应该是HTTP <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> 401未授权</a>响应，如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="4ee3" class="ne lb it mv b gy nf ng l nh ni">HTTP/1.1 401 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"f-gnkbM9TfQtU2OeaokCx158AlciA"<br/>Date: Fri, 10 May 2019 13:06:45 GMT<br/>Content-Type: text/html;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="4fab" class="ne lb it mv b gy nm ng l nh ni">Unauthorized.</span></pre><p id="413b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还应该在安装了Authy应用程序的设备上收到Authy身份验证请求。</p><p id="83cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接受身份验证请求。</p><p id="e1a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:根据您的设备及其通知设置，您可能不会收到通知消息；如果您没有收到设备通知，请检查应用程序。要检查身份验证请求，请打开应用程序，选择您在身份验证控制台中创建的身份验证应用程序的名称，选择钟形图标，然后选择Pending选项卡。任何未回答的身份验证请求都会出现在那里。</p><p id="b832" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用在之前的API请求中使用的相同的<code class="fe ms mt mu mv b">authyToken</code>值，重复对<em class="md">/auth-service/auth/status</em>的请求。这一次，API应该返回一个HTTP 200 OK响应以及JSON Web令牌，如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5e09" class="ne lb it mv b gy nf ng l nh ni">HTTP/1.1 200 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"1f3-BIwlgrvtXgzgfN+ZvMJgccDH95g"<br/>Date: Fri, 10 May 2019 13:07:27 GMT<br/>Content-Type: application/json;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="e34c" class="ne lb it mv b gy nm ng l nh ni">{"jwtToken":"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NTc0OTcyNDcsInByaXZpbGVnZXMiOlsiQVNTSUdOX0hFUk8iLCJDUkVBVEVfSEVSTyJdLCJpYXQiOjE1NTc0OTM2NDd9.pMHL37_Vmk2kNsZ4pAf9WIoN1mVEFCYBezT5AVYuOWCBQpLjauUCfKEfd4nZtzJ5LqTdCOuxkvE5q6d2hYXuTmkv4EFFG78tgb36mqVJwfxZ1U9KdB6Kp4RN1HtjREXYzICv14h9pVWZ6NGl-n1zF1VZsxEnJU-MaeqyRvxYNbMk2k3KPEekjzhCyw8kRltmYDk6X_vzG3O6NmuHpN4xSQk5ZO7cuniDyc6Z9zlsanwbtJupi2pgcwGsMo9YE0uswrHCED5W9b-lp3hXBptDom1mgeButsleZv1vS6mFQoYUOrvIdzfcmrOpb4yCH0B6bejL_tJmz9PBt8K_7uNPYg"}</span></pre><p id="e3f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尝试通过执行以下curl命令添加一个新的英雄，用上面返回的<code class="fe ms mt mu mv b">jwtToken</code>的值替换<code class="fe ms mt mu mv b">token-obtained-from-auth-service</code>占位符:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a71d" class="ne lb it mv b gy nf ng l nh ni">curl -i --request POST --header "auth: token-obtained-from-auth-service" --header "Content-type: application/json" --data @new-hero-payload.json localhost:8080/heroes-service/hero</span></pre><p id="4295" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">API应该返回一个HTTP 201创建的响应，如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="8494" class="ne lb it mv b gy nf ng l nh ni">HTTP/1.1 201 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"6f-0nI8erL/vblCtFwnl+JDjQeOQKM"<br/>Date: Fri, 10 May 2019 13:09:37 GMT<br/>Content-Type: application/json;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="5d90" class="ne lb it mv b gy nm ng l nh ni">{"id":6,"type":"flying-dog","displayName":"Rex","powers":[1,2,3],"busy":false,"_id":"5cd5781159491ad121e0a1c4"}</span></pre><p id="07e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该响应包括hero 6的新分配，表明您成功使用Authy对用户进行了身份验证，使用用户的Authy身份验证令牌获得了包含用户安全声明的JWT，并使用JWT访问微服务API对持久层进行了更改。</p><p id="f279" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于一个教程来说，这是一个很好的工作。祝贺您成功完成项目。</p><p id="9b88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想进行更多的试验，可以通过在MongoDB CLI中执行以下命令来恢复您在测试双因素身份验证时所做的数据库更改:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1b17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想要将您的<em class="md">代码</em>赶上这一步，您可以通过在您想要创建项目目录的目录中执行以下命令，从GitHub存储库中克隆代码:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="e4e6" class="ne lb it mv b gy nf ng l nh ni">git clone <a class="ae kz" href="https://github.com/maciejtreder/introduction-to-microservices.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/introduction-to-microservices.git</a><br/>cd introduction-to-microservices<br/>git checkout step8<br/>cd eureka-helper<br/>npm install<br/>cd ../threats-v2<br/>npm install<br/>cd ../heroes-v2<br/>npm install<br/>cd ../auth<br/>npm install<br/>cd ..</span></pre><p id="0507" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，您还需要根据上面的说明来设置数据库和Twilio Authy，以便项目能够完全正常运行。</p><h1 id="130d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="9e50" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在这篇文章中，您学习了如何使用授权服务来保护Node.js微服务，以控制哪些<em class="md">已验证的</em>和<em class="md">已授权的</em>用户可以访问特定的资源。您了解了如何使用JSON Web令牌减少授权服务的流量，JSON Web令牌是一种以易于解码和阅读的编码字符串形式发送信息的标准方式，但受到加密签名的保护。公钥所有者可以验证签名，但只有私钥所有者可以更改令牌值并再次签名。当令牌有效负载与最初从有效负载生成的签名不匹配时，令牌无效。</p><p id="93ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还了解了如何使用Twilio Authy实现双因素身份验证。您已经看到了如何将Authy和jwt结合起来，形成一个健壮的系统来验证和授权您的JavaScript APIs。</p><h1 id="cfa2" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">额外资源</h1><p id="b1e6" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae kz" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" rel="noopener ugc nofollow" target="_blank">架构风格和基于网络的软件架构的设计</a>，罗伊·托马斯·菲尔丁，2000——菲尔丁的博士论文描述了表述性状态转移(第五章)和其他架构风格。</p><p id="1df3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank">微服务</a> —尽管有缺陷，维基百科的文章是一个很好的起点，可以找到更多关于微服务架构和实现的信息。</p><p id="77cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://nodejs.org/en/docs/" rel="noopener ugc nofollow" target="_blank"> Node.js </a> —为应用服务器提供参考文档。</p><p id="7cae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a> — JSON Web Token文档。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="c589" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="md">我是Maciej Treder，请通过</em><a class="ae kz" href="mailto:contact@maciejtreder.com" rel="noopener ugc nofollow" target="_blank"><em class="md">【contact@maciejtreder.com】</em></a><em class="md"/><a class="ae kz" href="https://www.maciejtreder.com/" rel="noopener ugc nofollow" target="_blank"><em class="md">https://www.maciejtreder.com</em></a><em class="md">或@ maciejtreder on</em><a class="ae kz" href="http://github.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="md">GitHub</em></a><em class="md"/><a class="ae kz" href="https://twitter.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="md">Twitter</em></a><em class="md">和</em> <a class="ae kz" href="https://www.linkedin.com/in/maciej-treder/" rel="noopener ugc nofollow" target="_blank"> <em class="md"> LinkedIn </em></a></p><p id="1a07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="md">本帖原载于</em> <a class="ae kz" href="https://www.twilio.com/blog/protecting-javascript-microservices-node-js-json-web-tokens-twilio-authy" rel="noopener ugc nofollow" target="_blank"> <em class="md"> Twilio博客</em> </a> <em class="md">。</em></p></div></div>    
</body>
</html>