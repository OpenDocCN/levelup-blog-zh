<html>
<head>
<title>Top 4 Jest Tricks to Put On Your Cheatsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">放在你的备忘单上的4个笑话</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/top-4-jest-tricks-to-put-on-your-cheatsheet-db7c2359756c?source=collection_archive---------15-----------------------#2022-02-07">https://levelup.gitconnected.com/top-4-jest-tricks-to-put-on-your-cheatsheet-db7c2359756c?source=collection_archive---------15-----------------------#2022-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d2b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过这些简单的技巧，测试不一定是痛苦的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67d7f99fbedf8a9a9faf8542f1fac60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nPZJz5TN7YuXr0Sr"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="030b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最讨厌的过去之一是用Javascript进行测试。没有什么比摸索模拟、处理错误和试图弄清楚我的代码到底怎么了更让我兴奋的了。</p><p id="6e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管非常不喜欢测试，但它还是有极大的价值，尤其是在开发风格中，比如测试驱动开发(TDD)。测试驱动开发是通过测试用例充实软件规范，并通过使用所述测试用例进行持续测试来跟踪开发进度的过程。</p><p id="4adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助你最小化痛苦，我已经编辑了四个必要的有用的提示来克服测试中那些讨厌的错误和痛点<em class="lv">(它也可以作为每当我必须重新测试时的提醒)</em>。</p><h2 id="9021" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">模仿类模块</h2><p id="9a73" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">Javascript类非常适合使用，它们有助于模块化和封装您的数据。</p><p id="e46b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设一个用户类管理一个软件应用程序的单个用户实例。每个实例都用名称、年龄和电子邮件进行初始化。在演示中，让我们将name、age和email类变量设为私有，id类变量设为公共，并且只通过getter方法返回这些信息。</p><p id="2940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">getter方法接受一个可选参数<code class="fe mu mv mw mx b"><em class="lv">publicOnly</em></code> <em class="lv">。</em>如果<code class="fe mu mv mw mx b"><em class="lv">publicOnly </em></code>为真，那么只返回用户的姓名和年龄。但是，如果是<em class="lv"> false </em>，则返回用户的所有信息。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="a57d" class="lw lx it mx b gy nc nd l ne nf">/src/services/user.service</span><span id="432e" class="lw lx it mx b gy ng nd l ne nf">class User {</span><span id="7b3e" class="lw lx it mx b gy ng nd l ne nf">  id<br/>  private name<br/>  private age<br/>  private email</span><span id="2a51" class="lw lx it mx b gy ng nd l ne nf">  constructor(fullName, userAge, userEmail) {<br/>    this.name = fullName<br/>    this.age = userAge<br/>    this.email = userEmail<br/>  }<br/>  <br/>  getUser(publicOnly = true) {<br/>    if (publicOnly) return { name: this.name, age: this.age }<br/>    return { id: this.id, name: this.name, age: this.age, email: this.email }<br/>  }<br/>}</span></pre><p id="0d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对这个模块进行单元测试或多或少非常简单。然而，如果这只是您的应用程序流程的一部分，会发生什么呢？如何模拟这个类来测试应用程序流中更重要的部分？</p><p id="ff77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以模拟整个类，并模拟您的测试需要使用<code class="fe mu mv mw mx b">jest.mock</code>进行交互的特定方法。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="e7aa" class="lw lx it mx b gy nc nd l ne nf"><strong class="mx iu">jest.mock</strong>('../../src/services/user.service', () <em class="lv">=&gt;</em> {<br/>    <em class="lv">return</em> <strong class="mx iu">jest.fn().mockImplementation</strong>(() <em class="lv">=&gt;</em> {<br/>        <em class="lv">return</em> { <em class="lv">getUser</em>: jest.fn().mockReturnValue(<br/>          { name: 'Test User',<br/>            age: 28,<br/>            email: 'test-email@gmail.com'}) }<br/>    })<br/>})</span></pre><p id="4c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有与API交互或与其他下游服务通信的类方法，这种模仿方式是有益的。我们可以绕过所有额外的通信，为我们的测试提供正确执行所需的精确值。</p><h2 id="1eb4" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">处理承诺</h2><p id="7648" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当我们与API或其他下游服务通信时，我们经常会遇到令人生畏的<em class="lv">承诺</em>。但是，我向你保证，他们没有你想的那么可怕！如果你不熟悉Jest丰富的库，测试承诺可能会有点混乱，但是嘲笑和处理它们并没有那么糟糕！</p><p id="a216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要模拟一个本质上异步的模块，例如HTTP请求库<code class="fe mu mv mw mx b">axios</code>，您可以使用两种方法<code class="fe mu mv mw mx b">mockRejectedValue</code>和<code class="fe mu mv mw mx b">mockResolvedValue</code>中的一种</p><p id="38bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<code class="fe mu mv mw mx b">mockReturnValue</code>，<code class="fe mu mv mw mx b">mockRejectedValue</code>和<code class="fe mu mv mw mx b">mockResolvedValue</code>处理承诺的拒绝和解决途径。</p><p id="2213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加上一个例子中的用户服务，并添加一个使用<code class="fe mu mv mw mx b">axios</code>向下游服务发送用户数据请求的方法。如果post请求成功，它将返回我们刚刚添加的客户的标识符，我们将用该标识符更新我们的类</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="f2e2" class="lw lx it mx b gy nc nd l ne nf">async upsertUser() {<br/>    try {<br/>       const { data } = await axios.post('/user', <br/>         { name: this.name, age: this.age, email: this.email })</span><span id="ee36" class="lw lx it mx b gy ng nd l ne nf">       const { customerID } = data<br/>       this.id = customerID</span><span id="708c" class="lw lx it mx b gy ng nd l ne nf">    } catch (e) {<br/>       throw new "Cannot fulfill request at this time"</span><span id="0062" class="lw lx it mx b gy ng nd l ne nf">    }</span><span id="fc10" class="lw lx it mx b gy ng nd l ne nf">}</span></pre><p id="ca53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下这个方法是否正确地设置了标识符。</p><p id="bcf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用jest mock函数直接初始化<code class="fe mu mv mw mx b">axios.post</code>，然后用<code class="fe mu mv mw mx b">mockResolvedValue</code>将它链接起来，设置一个测试返回值。然后，我们调用这个模拟函数，而不是调用实际的<code class="fe mu mv mw mx b">/user</code>端点。我们不关心客户id的值，我们希望确保<code class="fe mu mv mw mx b">upsertUser </code>方法在POST成功时设置ID类变量。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="55b4" class="lw lx it mx b gy nc nd l ne nf">test('Upsert user and set id', <strong class="mx iu">async </strong>() =&gt; {<br/>   <strong class="mx iu"> axios.post = jest.fn().mockResolvedValue(<br/>         { data: { customerID : 18920 } })</strong></span><span id="9783" class="lw lx it mx b gy ng nd l ne nf">    const userA = new User('Cory', 19, 'cory@gmail.com')<br/>    await userA.upsertUser()<br/>    <br/>    expect(userA.id).toEqual(18920)</span><span id="1e67" class="lw lx it mx b gy ng nd l ne nf">}) </span></pre><h2 id="dc58" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">测试路线</h2><p id="4b0f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">测试API端点不是我经常遇到的事情，所以这个测试领域对我来说很新，我想它对你们中的一些人来说也是如此。所以为了减轻你的担心，我建议你去NPM图书馆。</p><p id="bcf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你和我一样，你可能会想，<em class="lv">“难道没有另一种不使用外部库来测试路由的方法吗？”</em></p><p id="96c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的回答是:<em class="lv">不太会。</em></p><p id="2222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发的时候，通常你的服务器都是启动的，所以你可以很容易地在你的浏览器，邮差，或者卷曲它们。但是，在测试环境中，您的服务器是离线的。所以端点还没有真正“存在”。那么你如何解决这个问题呢？</p><p id="e7c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.npmjs.com/package/supertest" rel="noopener ugc nofollow" target="_blank"> Supertest </a>是一个NPM软件包，允许您</p><blockquote class="nh ni nj"><p id="ab03" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">为测试HTTP提供一个高级抽象，同时仍然允许您下降到较低级别的API——Supertest</p></blockquote><p id="b1bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您不必担心您的服务器运行或者您的测试将如何与您的服务器通信；相反，您可以专注于您已经创建的端点以及上游服务将如何与它们通信。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="4b50" class="lw lx it mx b gy nc nd l ne nf">describe('User Route', () =&gt; {<br/>  test('/ returns successfully', async () =&gt; {<br/>    const response = <strong class="mx iu">await</strong> <strong class="mx iu">request(app)<br/>      .get('/api/v1/users')<br/>      .set('Authorization', 'Bearer testing1234')</strong><br/>    <br/>    expect(response.status).toEqual(200)<br/>    expect(response.body).toEqual({ success: true, data: [] })<br/>  })<br/>})</span></pre><p id="e133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在这个例子中没有显示，但是您也希望在模拟路由时模拟路由与之通信的下游服务。这确保了您不会受到其他服务的连接和通信的妨碍，并且您可以将测试集中在路由处理程序中的逻辑上。</p><h2 id="75dd" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">测试异步错误</h2><p id="555c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这最后一个技巧可能是我存在的祸根，因为我花了很长时间才弄明白它是如何工作的！此外，如果做得不正确，你的测试会产生假阳性。</p><p id="ba2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于我们在前面的例子中所涉及的，我们可以利用<code class="fe mu mv mw mx b">mockRejectedValue</code>来帮助测试错误。如果您的服务在任何时候抛出一个错误，它将遵循一个承诺的拒绝路径，因此我们可以使用这个方法来模拟该行为。</p><p id="a4a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这些例子，我将使用<code class="fe mu mv mw mx b">http-errors</code>库来帮助呈现您可以捕获的不同类型的HTTP错误，但是请记住这适用于所有的Javascript错误。</p><p id="19f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想要模拟一个失败的POST请求。也许你想模拟一个未经授权的请求。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="0007" class="lw lx it mx b gy nc nd l ne nf">const error = <em class="lv">new </em>CreateError.Unauthorized('You are unauthorized')<br/>axios.post = <strong class="mx iu">jest.fn().mockRejectedValue(error)</strong></span></pre><p id="7423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建错误的新实例，但不要抛出它！将该错误实例传递给<code class="fe mu mv mw mx b">mockRejectedValue</code>方法，类似于我们在使用<code class="fe mu mv mw mx b">mockResolvedValue</code>的示例中所做的。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2118" class="lw lx it mx b gy nc nd l ne nf">await expect(service.upsertUser()).rejects.toThrowError(error)</span></pre><p id="7724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，为了测试正在进行下游调用的服务，将关键字<code class="fe mu mv mw mx b">await</code>添加到expect语句的<strong class="lb iu">前面</strong>处(不在语句内),并将<code class="fe mu mv mw mx b">expect</code>与<code class="fe mu mv mw mx b">rejects.toThrowError(error)</code>链接起来</p><p id="515e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个链检查expect方法<code class="fe mu mv mw mx b">service.upsertUser()</code>中调用的方法是否返回了一个被拒绝的承诺，当所述承诺被解除时，它将抛出一个错误。</p><p id="033d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最大的错误是在<code class="fe mu mv mw mx b">service.upsertUser()</code>调用前面添加了<code class="fe mu mv mw mx b">await</code>关键字。但是，通过这样做，即使控制台显示函数的预期/实际返回值有差异，如果抛出任何错误，测试也会通过。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="07f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这些技巧对您有用，请记得关注并订阅更多的编码技巧和技巧！✌️</p><p id="8c7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>