<html>
<head>
<title>Elegantly Consuming APIs using Data Transfer Objects in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PHP中的数据传输对象优雅地使用API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/elegantly-consuming-apis-using-data-transfer-objects-in-php-38ac4d8225a8?source=collection_archive---------4-----------------------#2021-02-09">https://levelup.gitconnected.com/elegantly-consuming-apis-using-data-transfer-objects-in-php-38ac4d8225a8?source=collection_archive---------4-----------------------#2021-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3c89" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过正确解析API响应来清理代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d9b39a6cfc346589b4245ec1e75663be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cMuDJP_S9V0nARtC"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@goran_ivos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戈兰·艾沃斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="7708" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API是现代互联网的基石。您可以使用它们在前端和后端之间进行通信，从第三方资源获取信息，触发事件，验证和授权您的用户，等等。</p><p id="fed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从PHP使用API很容易。然而，由于从API返回的数据通常是JSON格式的，处理返回的数据可能会变得相当混乱。在本文中，我将展示如何以一种非混乱的方式使用从API返回的数据，方法是将响应自动存储在格式正确的对象中，这些对象允许以一种良好的、结构化的方式处理数据。</p><p id="fbfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将从查看一个示例API开始，看看如何使用它，以及我们希望用使用的数据实现什么。之后，我们将引入一些<em class="ls">数据传输对象</em>来清理我们的代码，使API数据的处理更加优雅。我们开始吧！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="15a4" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">示例API</h1><p id="b5c5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">对于本文，我们将使用来自<a class="ae kv" href="http://jsonplaceholder.typicode.com" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>的API，该服务为web开发人员提供了一些示例API。从可用的API来看，我们将关注于<a class="ae kv" href="http://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank"> /users </a>端点，它以如下所示的格式为一组10个用户提供服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f9d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用这些数据打印出用户的ID、命名的电子邮件地址(姓名和电子邮件地址的组合)和居住地址的简单概述。对于上面的API结果，我们的输出如下所示。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a9d9" class="ne mb iq na b gy nf ng l nh ni">User 1, Leanne Graham &lt;<a class="ae kv" href="mailto:Sincere@april.biz" rel="noopener ugc nofollow" target="_blank">Sincere@april.biz</a>&gt; lives at:<br/>Kulas Light, Apt. 556<br/>92998-3874 Gwenborough</span></pre><p id="82df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的例子，但是它需要使用嵌套数据来实现我们的结果。此外，您可以注意到，我们并没有利用从API返回的所有数据——请记住这一点，以后再说。首先，让我们设置一个简单的应用程序来实际使用这个API。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f88d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">使用API</h1><p id="886c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了展示API的使用，我们将使用Composer包和<a class="ae kv" href="https://getcomposer.org/doc/04-schema.md#psr-4" rel="noopener ugc nofollow" target="_blank"> PSR-4自动加载</a>构建一个简单的PHP应用程序，这样我们就不用担心自己需要文件了。我们将在<code class="fe nj nk nl na b">app/src</code>文件夹的<code class="fe nj nk nl na b">App</code>名称空间中添加我们的类，所以我们将下面的条目添加到我们的<code class="fe nj nk nl na b">composer.json</code>文件中:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="d7d5" class="ne mb iq na b gy nf ng l nh ni">"autoload": {<br/>  "psr-4": {<br/>    "App\\": "app/src"<br/>  }<br/>}</span></pre><p id="6532" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置好自动加载路径后，我们可以专注于使用API了。为此，我们将使用使用Composer ( <code class="fe nj nk nl na b">composer require guzzlehttp/guzzle</code>)安装的<a class="ae kv" href="https://docs.guzzlephp.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> Guzzle </a>库。我们将创建一个非常简单的存储库类，用于从API获取JSON解码的数据。这个类将包含一个静态函数，该函数将使用Guzzle库获取数据并解码返回的JSON字符串。</p><p id="29a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们在这里创建了一个简单的例子，所以我们将高效的类设计和错误处理排除在范围之外。我们最终的存储库类将如下所示，并且应该在<code class="fe nj nk nl na b">app/src/Repository/UsersRepository.php</code>创建。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8c3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个简单的存储库来从API获取数据，我们可以处理它了。我们从<code class="fe nj nk nl na b">UsersRepository::get()</code>函数接收到一个解析过的用户数组，我们可以通过迭代来显示我们想要显示的信息。这可能看起来像这样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="75ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">呀呀</em>。</p><p id="71ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们的API调用的结果是带有预定义属性的漂亮对象，那就更好了。这样，IDE就能够自动完成属性，我们会被警告任何我们犯的错误。所以，这正是我们要做的。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6108" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">使用数据传输对象</h1><p id="3d18" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们不是将用户对象解析成匿名的<code class="fe nj nk nl na b">stdClass</code>对象，而是创建一个漂亮的<code class="fe nj nk nl na b">User</code>对象，它包含我们想为用户获取的正确类型提示的属性。我们不会手动填充这些属性，但是我们将使用Spatie的<a class="ae kv" href="https://github.com/spatie/data-transfer-object" rel="noopener ugc nofollow" target="_blank">数据传输对象</a>包来完成这个任务(<code class="fe nj nk nl na b">composer require spatie/data-transfer-object</code>)。</p><p id="1630" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个库通过提供一组抽象类来工作，您可以使用这些抽象类来扩展您的数据类。主类被恰当地称为<code class="fe nj nk nl na b">DataTransferObject</code>，它将数组元素映射到数据类的(公共)属性。</p><p id="ad9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<code class="fe nj nk nl na b">DataTransferObject</code>有一个属性对我们来说是个问题——它想将数组中的所有<em class="ls">元素映射到对象属性。正如我们之前看到的，我们不想消耗API中的所有元素，因此我们不想用我们永远不会使用的属性来扩展我们的数据对象。这就是<code class="fe nj nk nl na b">FlexibleDataTransferObject</code>发挥作用的地方:这个抽象类实际上等同于<code class="fe nj nk nl na b">DataTransferObject</code>，除了它将忽略没有数据对象属性可用的数组元素。完美！</em></p><p id="97bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看我们的<code class="fe nj nk nl na b">User</code>对象的数据对象可能是什么样子。这个类存在于<code class="fe nj nk nl na b">app/src/Model/User.php</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f5a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要太担心这里的<code class="fe nj nk nl na b">Address</code>类——我们稍后会谈到它。我们为姓名和电子邮件地址创建了两个字符串属性，为ID创建了一个整数属性。这起到了类型安全的作用，因为如果接收到的数据与预期的数据类型不匹配，就会抛出一个<code class="fe nj nk nl na b">DataTransferObjectError</code>。</p><p id="6d70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还创建了两个助手函数。一种是根据姓名和电子邮件地址格式化命名的电子邮件地址，这样我们就不必再在数据类之外格式化它了。另一个辅助函数是静态的<code class="fe nj nk nl na b">fromApiResult</code>函数，它接受一组数据，并很好地将它映射到<code class="fe nj nk nl na b">User</code>类的一个实例。请记住，如果数组中的数据不适合这个类，这个函数可能会抛出！</p><p id="7aa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着<code class="fe nj nk nl na b">User</code>类的退出，让我们来看看<code class="fe nj nk nl na b">Address</code>类。这个类存在于<code class="fe nj nk nl na b">app/src/Model/UserProperty/Address.php</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里做了更多相同的事情:我们使用了一个<code class="fe nj nk nl na b">FlexibleDataTransferObject</code>，因为我们没有使用API响应数据中的所有属性，我们只是将街道、套房、城市和邮政编码数据放在公共字符串成员中。</p><p id="6a79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，我们还添加了神奇的<code class="fe nj nk nl na b">__toString()</code>函数，所以我们可以简单地将这个<code class="fe nj nk nl na b">Address</code>类的一个实例转换成一个格式正确的字符串。</p><p id="6f04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很好。</p><p id="360f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在<code class="fe nj nk nl na b">User</code>对象中看到的，我们需要用一个数据数组而不是一个<code class="fe nj nk nl na b">stdClass</code>实例来调用<code class="fe nj nk nl na b">User::fromApiResult</code>函数，所以我们需要对<code class="fe nj nk nl na b">UsersRepository::get()</code>函数做一些调整。我们将把API响应JSON解码成一个关联数组，并将数组中的每个条目映射到一个<code class="fe nj nk nl na b">User</code>对象，这样我们就返回了一个<code class="fe nj nk nl na b">User</code>对象的数组。那看起来如下(看第17行！).</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8290" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经更新了我们的存储库，让我们看看如何使用<code class="fe nj nk nl na b">UsersRepository::get()</code>函数的结果来获得与之前相同的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9682" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个看起来干净多了。我们可以直接打印<code class="fe nj nk nl na b">$user-&gt;address</code>属性，因为我们实现了<code class="fe nj nk nl na b">Address::__toString()</code>函数，格式化指定的电子邮件地址是由数据对象处理的。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b631" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">使用可选属性</h1><p id="ad3a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">尽管我们的API为所有用户返回了一个良好且一致的格式，但对于您正在使用的实际API来说，情况可能并非如此。假设我们的数据集中可能有没有居住地址集的用户。如果没有我们的<code class="fe nj nk nl na b">User</code>和<code class="fe nj nk nl na b">Address</code>对象，通过使用本文顶部的例子，您可能必须检查属性是否存在，并根据结果打印两种不同的格式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="736b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以称这种实现不太理想。</p><p id="daa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，通过我们在前面步骤中所做的设置，我们可以简单地使<code class="fe nj nk nl na b">User::$address</code>属性为空，以达到我们想要的结果:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a812" class="ne mb iq na b gy nf ng l nh ni"><em class="ls">/**<br/> * </em><strong class="na ir"><em class="ls">@var </em></strong><em class="ls">\App\Model\UserProperty\Address|null<br/> */<br/></em>public ?Address $address;</span></pre><p id="962b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以更新上一步的<code class="fe nj nk nl na b">users.php</code>脚本，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6ca4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那看起来好多了。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="177b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p><h1 id="c1bb" class="ma mb iq bd mc md nm mf mg mh nn mj mk jw no jx mm jz np ka mo kc nq kd mq mr bi translated">资源</h1><p id="d6ca" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">PSR-4自动装弹使用作曲:【https://getcomposer.org/doc/04-schema.md#psr-4 T4】</p><p id="7582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GuzzleHTTP库文档:<a class="ae kv" href="https://docs.guzzlephp.org/en/stable/" rel="noopener ugc nofollow" target="_blank">https://docs.guzzlephp.org/en/stable/</a></p><p id="186a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据传输对象库:<a class="ae kv" href="https://github.com/spatie/data-transfer-object" rel="noopener ugc nofollow" target="_blank">https://github.com/spatie/data-transfer-object</a></p></div></div>    
</body>
</html>