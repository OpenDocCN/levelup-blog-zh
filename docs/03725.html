<html>
<head>
<title>A* algorithm — Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">A*算法— Ruby</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-algorithm-with-visualization-ruby-24f7f8b27e6e?source=collection_archive---------17-----------------------#2020-05-24">https://levelup.gitconnected.com/a-algorithm-with-visualization-ruby-24f7f8b27e6e?source=collection_archive---------17-----------------------#2020-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d2d6b49e8584f8c7575ef15be84ebe86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7o52a96h2K6IGY4DvVo3TA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">算法中间过程</figcaption></figure></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="c23a" class="km kn it bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">形象化</h1><figure class="lk ll lm ln gt ju"><div class="bz fp l di"><div class="lo lp l"/></div></figure></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="6584" class="km kn it bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">什么是A*？</h1><p id="e1ff" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">像大多数算法和数据结构一样，它有许多使用案例和用途，但在大多数情况下，它是一种流行的寻路算法，对加权和非加权结构都有效。</p><p id="9506" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">它不总是最快或最有效的方法，但它几乎总是比Lee的算法更快和更有效，Lee的算法是实现最佳路径的最直接的强力方法。</p><p id="d319" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">A*很重要，因为它就像现代最佳路径应用的面包和黄油。80%的情况下，它是最快和最有效的路径方法，同时对于开发人员来说也是相对直接的构建方法。</p></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="17b1" class="km kn it bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">路径比你想象的更容易接近</strong></h1><p id="38de" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">当我们走过迷宫时，其中的过程和决策并不复杂。我们有一个起点和一个终点。我们从起点开始，移动到相邻的单元。重复这个过程，直到我们到达终点。</p><p id="72fc" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在这些步骤中的任何一点，我们都可以决定如何继续。如果我们将相邻的选项放入一个队列中，我们可以强制进行广度优先搜索。</p><p id="cac6" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">如果我们将相邻的单元放入一个堆栈中，我们可以使用它进行系统的或深度优先的搜索。</p><p id="a121" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">或者，我们可以根据一些观察或计算，启发式地对相邻选项进行排序。改进的潜力是无限的。毫无疑问，即使是最好的算法也可以进一步改进，所需要的只是一颗好奇的心，投入到推动我们认为可能的边界上。</p></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="ce96" class="km kn it bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">A*是如何工作的？</h1><p id="c321" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">简而言之，A*的工作原理是基于以下等式对下一个可能的步骤进行启发式排序:</p><h1 id="5ac6" class="km kn it bd ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf mx lh li lj bi translated"><strong class="ak"> F = H+ G </strong></h1><p id="d89f" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">其中<strong class="ls iu"> G </strong>是从起点到当前像元的精确距离成本。</p><p id="5d24" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">并且<strong class="ls iu"> H </strong>是从当前单元到终点的估计成本。</p><p id="0179" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">F 是在路径中的每一点继续进入任何特定单元的近似成本。</p><p id="e2dc" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">该算法将每个相邻的选项按其价格顺序推入堆栈，最贵的选项放在最前面。这样，当执行搜索时，从堆栈顶部弹出的项总是开销最小的选项。</p><p id="474f" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">如果阻力最小的途径陷入僵局，它只会回到更昂贵的选择。</p><p id="9545" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">有几种不同的方法可以计算每个变量。并不是所有的方法都非常有效。一些方法包括丢弃空间和时间效率以获得每个单独单元的精确试探法，这将改进搜索时间，减少设置时间。</p><p id="07d5" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在这个演示中，我传递G到当前单元格的准确距离，然后计算h的曼哈顿距离。</p></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="c998" class="km kn it bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">例如</strong></h1><p id="20b0" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">假设我从这个网格开始，红色是起点，蓝色是终点。</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/12da1277fbc201a13d6db918ab2bb704.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*tssjHNmUmjEWInP18I7wug.jpeg"/></div></figure><p id="61f0" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">第一步，相邻单元格是我的选项。</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/60d2af45ea6d47e226fdbe3743a39c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5c-nqvmTn17L3GGushIvHA.jpeg"/></div></div></figure><p id="1338" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在第一步中，我的两个选项有相同的<strong class="ls iu"> G </strong>值，因为除了像这样将一个步骤移动到另一个步骤之外，没有其他选项。</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/a4c4e83c26d72509720a40dc56c2013d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0yxqFj8YQAzmOu4GjVmSbQ.jpeg"/></div></div></figure><p id="e7d2" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">由于我的网格使用了4个方向的限制，我将使用曼哈顿距离方程来获得每个选项的T2 H T3值。简而言之，(x1 — x2)和(y1 — y2)加在一起的绝对值。</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/e5adeb1bc5b08d53ee1ada74d825f360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnMQ_5l5U_dItCS0hea40A.jpeg"/></div></div></figure><p id="e5d6" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">如果你使用8个方向的限制，你必须使用欧几里德距离公式来计算每个选项的<strong class="ls iu"> H </strong>值。</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/88d2522e57568a2a1a32e8079333bf8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z326emL-Rl0AbiR4yT_j8w.jpeg"/></div></div></figure></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><p id="527a" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我的选项1的坐标为[1，0]，终点为[4，4]，我的选项2的坐标为[0，1]，终点仍为[4，4]，因此我的选项成本如下:</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/bb48a36cbc31004ef3d503ca226b545a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMr6zlb6gHiWRJwDx2KQIQ.jpeg"/></div></div></figure><p id="c066" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">因为我们的选项都有相同的值，所以它们都将被推入堆栈，程序将取出最上面的一个并从那里继续。由于我们的迷宫没有障碍，并且是一个完美的立方体，因此任何一条路径都将是最佳路径，但是由于我们已经试探性地将项目放入堆栈，算法将只在其中一条路径上继续，而不会像这样回溯:</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/034d349aa9f90eec7b849d454756b27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUaUMHNxQWU2X1w09DPJfQ.jpeg"/></div></div></figure></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><p id="3a6b" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在每一步中，它仍然会考虑相邻的选项，但是由于我们的迷宫是一个没有障碍的完美正方形，途中的每个选项都将继续具有相同的<strong class="ls iu"> F </strong>值，因此它将以直接的方式继续。</p><p id="6324" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">当我们引入障碍时，积极的结果变得更加明显(见上面的视频)，但即使在这个小网格中，我们至少可以确定我们的算法确实找到了几个等价的最佳路径之一，并且它采取了直接的路线到达那里，而没有检查整个网格(这是Lee算法会做的)</p></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="187e" class="km kn it bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">结论</strong></h1><p id="566a" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">A*是一种高效、有效且实用的最佳寻路方法，它通过在每一步做出小决策来实现。</p><p id="7961" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我认为一个明显的改进方向是，如果迷宫中的检查点可以有效地确定，我们可以对每个检查点分段运行A*算法，这将导致更有效的搜索。</p><p id="501e" class="pw-post-body-paragraph lq lr it ls b lt mo lv lw lx mp lz ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">好了，这就是我今天的全部时间。快乐学习。</p><div class="nf ng gp gr nh ni"><a href="https://github.com/Clashbuster/A-star-algorithm-visualized" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">碰撞克星/星形算法-可视化</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">a星算法可视化。通过创建帐户，为Clashbuster/A-star算法可视化开发做出贡献…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jz ni"/></div></div></a></div><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/6bf6888777a27ee5197a7bded15a9afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJSCPEt7kseeLtlFB2rzMg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">计算</figcaption></figure></div></div>    
</body>
</html>