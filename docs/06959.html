<html>
<head>
<title>The Simplest Explanation of Adapter Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适配器设计模式的最简单解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-simplest-explanation-of-adapter-design-pattern-cd37f02bfecd?source=collection_archive---------2-----------------------#2021-01-14">https://levelup.gitconnected.com/the-simplest-explanation-of-adapter-design-pattern-cd37f02bfecd?source=collection_archive---------2-----------------------#2021-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91a1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">C#中的真实世界示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/629cdeafd83d31176f54d7d6c89b0bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HFVCRnTtYpp3O-xa"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@kumpan_electric?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kumpan Electric </a>拍摄的照片</figcaption></figure><p id="fb0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">前面我描述了</em> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/5-ways-to-clone-an-object-in-c-d1374ec28efa"> <em class="lv"> 5种方式来实现原型设计模式</em> </a> <em class="lv">，现在轮到适配器了。</em></p><p id="057d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">适配器设计模式的目的是将一个类的接口转换成客户端期望的另一个接口。</p><p id="329f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">适配器设计模式最初是在Erich Gamma写的书<em class="lv">Design Patterns:Elements of Reusable Object-Oriented Software，</em> <strong class="lb iu"> <em class="lv"> </em> </strong>中描述的… <strong class="lb iu">停！看来我答应给你的是模式最简单的解释，而不是无聊的理论。我会努力为你信守承诺。</strong></p><p id="ec7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个简单的例子开始我们的旅程。</p><p id="af43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您的应用程序可以使用ILogger接口:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8ba1" class="mb mc it lx b gy md me l mf mg">public interface ILogger<br/>{<br/>    void Log(LogEntry entry);<br/>}</span><span id="46ff" class="mb mc it lx b gy mh me l mf mg">public class LogEntry<br/>{<br/>    public string Text { get; set; }<br/>    public DateTime Time { get; set; }<br/>}</span></pre><p id="147b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序有许多ILogger接口的实现，其中之一是FileLogger。您的所有日志都可以保存到文件系统上的一个文件中。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1a58" class="mb mc it lx b gy md me l mf mg">public class FileLogger : ILogger<br/>{<br/>    public void Log(LogEntry entry)<br/>    {<br/>        //log {entry.Text} and {entry.Time} to file<br/>    }<br/>}</span></pre><p id="5742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有向消息代理发送日志的新需求，您应该简单地创建一个名为MessageBrokerLogger的新类，并像FileLogger那样实现ILogger接口。你应该做的另一件事是在你的应用程序的<strong class="lb iu">复合根</strong>中注册一个MessageBrokerLogger实例，而不是file logger(DI容器被配置的地方)。</p><p id="6aa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能还需要将消息记录到数据库中。突然，您发现您的系统已经包含了一个名为DatabaseLogger的对应类，它满足了所有新的需求。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="a63f" class="mb mc it lx b gy md me l mf mg">public class DatabaseLogger<br/>{<br/>    public void Log(string text)<br/>    {<br/>        //log {text} to database table<br/>    }<br/>}</span></pre><p id="4ff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，DatabaseLogger类的实现相当复杂，因此您应该重用它，以避免从头开始编写数据库记录器的耗时工作。但是即使你从头开始写，你的系统中也会有两个类做同样的工作。第一类的变化应该反映在第二类中，反之亦然。这令人沮丧，因为:</p><ul class=""><li id="8dad" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated">同样的工作必须做两次。</li><li id="176f" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">两个实现之间有可能存在不一致。</li></ul><p id="a6cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有所谓的<a class="ae ky" href="https://esashamathews.medium.com/technical-debt-management-best-practices-for-software-engineers-871a315ac812" rel="noopener">技术债</a>，总是导致可维护性差。</p><p id="66e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们需要重用DatabaseLogger类来避免不必要的麻烦。为此，我们需要在DatabaseLogger上实现ILogger接口并执行重构。这是它理想的样子:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="a2bf" class="mb mc it lx b gy md me l mf mg">public class DatabaseLogger : ILogger<br/>{<br/>    <em class="lv">//public void Log(string text)</em></span><span id="37d2" class="mb mc it lx b gy mh me l mf mg">    <strong class="lx iu">public void Log(LogEntry entry)</strong><br/>    {<br/>        //adjust the logic to work with {entry} parameter<br/>    }<br/>}</span></pre><p id="f7ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您不能总是更改现有的代码。想象一下，DatabaseLogger类在您的应用程序的遗留部分中被大量使用，日志方法签名中的每一个变化都会导致数小时的返工和回归问题。此外，DatabaseLogger可以是一个单独的库的一部分，您不能访问它的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/cfc6e1774eb25d1d314a67a7cf8f29cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*M_BXIHOMshERY3zJ27ckwA.png"/></div></figure><p id="667e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是适配器设计模式可以帮助我们的地方！</p><p id="18bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建一个名为DatabaseLoggerAdapter的类，并实现ILogger接口。接下来，我们需要将DatabaseLogger类注入DatabaseLoggerAdapter。最后一部分是将LogEntry对象转换为字符串，并在DatabaseLogger实例上调用Log方法。</p><p id="2928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="d536" class="mb mc it lx b gy md me l mf mg">public class DatabaseLoggerAdapter : ILogger<br/>{<br/>    private DatabaseLogger _databaseLogger = new DatabaseLogger();</span><span id="fcde" class="mb mc it lx b gy mh me l mf mg">    public void Log(LogEntry entry)<br/>    {<br/>        string text = $"{entry.Text} logged at {entry.Time}.";</span><span id="4e8c" class="mb mc it lx b gy mh me l mf mg">        _databaseLogger.Log(text);<br/>    }<br/>}</span></pre><p id="73e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们取得的成果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/356d3ac1a9662ec58414d18c389c2d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*oqQw5u617jWb6McRqP_2cQ.png"/></div></figure><p id="9a36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们解决了代码重用的设计问题，而不需要发明复杂繁琐的东西。通常，所有好的解决方案都很简单，这个故事很快证明了这一点。</p><h1 id="a11c" class="mx mc it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">摘要</h1><ul class=""><li id="66f7" class="mi mj it lb b lc no lf np li nq lm nr lq ns lu mn mo mp mq bi translated">适配器解决了接口不兼容的问题。</li><li id="0d9f" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">适配器类充当需要重用的对象的包装器。</li><li id="e72a" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">适配器有助于遵循开放封闭原则，因为开发人员不需要修改现有代码(DatabaseLogger)，而只需扩展其行为(DatabaseLoggerAdapter)。</li><li id="ed7e" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">适配器有助于遵循单一责任原则，因为开发人员将转换逻辑保存在一个单独的类中(DatabaseLoggerAdapter)。</li><li id="cf7d" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">如果有办法调整类(DatabaseLogger)使其与代码的其余部分相匹配，就不应该使用适配器模式。否则，模式滥用将导致冗余的适配器类，甚至适配器多于适配器。</li></ul></div></div>    
</body>
</html>