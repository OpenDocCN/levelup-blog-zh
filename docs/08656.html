<html>
<head>
<title>Complete Vue Router 4 Guide: Basics, Programmatic Routing, Navigation Guards, Transition Effects and Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完整的Vue路由器4指南:基础知识、编程路由、导航保护、过渡效果和合成API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/complete-vue-router-4-guide-basics-programmatic-routing-navigation-guards-transition-effects-31b21a2f444d?source=collection_archive---------0-----------------------#2021-05-22">https://levelup.gitconnected.com/complete-vue-router-4-guide-basics-programmatic-routing-navigation-guards-transition-effects-31b21a2f444d?source=collection_archive---------0-----------------------#2021-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4a39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看完整的视频课程:</p><p id="1dee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://www.udemy.com/course/complete-vuejs-3-course/?referralCode=75F591E320BC4EA22188" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/course/complete-vuejs-3-course/?referral code = 75f 591 e 320 BC 4 ea 22188</a></p><h1 id="9c97" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">基础知识介绍</h1><p id="39b0" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">Vue程序是一个单页应用程序。Vue页面由一个或几个Vue组件组成。为了给用户呈现不同的页面，我们只需要把不同的Vue组件堆叠在一起。</p><p id="5e7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">管理组件最简单的方法是使用动态组件。<code class="fe ls lt lu lv b">is</code> <em class="lw"> </em>属性决定安装哪个组件。我们用v-bind指令给<em class="lw"> </em> <code class="fe ls lt lu lv b">is</code> <em class="lw"> </em>属性加前缀，并给它分配一个动态值。通过改变分配给<code class="fe ls lt lu lv b">is</code> <em class="lw"> </em>属性的值，我们可以切换组件。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/6f9ab60632c60ce9a1770dfcf86a8a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8nTsjsmMA_I2IxISPASKw.png"/></div></div></figure><p id="6d0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正在显示的内容发生了变化，但实际上，我们从未离开过当前页面。地址框中的URL从未改变。我们所做的只是通过组件标签切换显示的组件。这就是为什么浏览器的前进和后退按钮仍然被禁用。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mj"><img src="../Images/d68200bcfe3075d892e80055db5609bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPTLGAHRNAhbeGd39zmMIw.png"/></div></div></figure><p id="ffd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是从用户的角度来看，他们访问了三个不同的页面。这三个按钮就像普通的导航按钮一样。每当他们点击一个按钮，就会出现一个新的页面。</p><p id="b2d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是与真实的网页不同,“关于”和“用户”页面不能共享或保存，因为它们没有自己的URL。它们只是同一页面的不同状态。显然，这在许多情况下并不理想，甚至是不可接受的。</p><p id="75b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Vue路由器是一个官方的Vue插件，致力于帮助我们管理组件。它使我们能够为每个组件组合分配一个URL，这样单页面应用程序就可以像普通的多页面网站一样运行。每个虚拟页面都可以有自己的URL。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/b3ad7a9d663bb2047aacd06c27bc7196.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*1vPiDy-gMC1u-c7spRpqxA.png"/></div></figure><p id="118e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们用的是Vue 3，匹配的Vue路由器版本是4。这里的手动地址是<a class="ae ko" href="http://next.router.vuejs.org" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="92e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装和卸载组件并不是Vue路由器唯一要做的事情。它为我们提供许多其他服务。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ml"><img src="../Images/e6f8db47118403fbfa777804da6ac8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jpk1mORsAIf_X2a2v3WZ4A.png"/></div></div></figure><p id="19b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之，Vue Router使构建单页应用程序变得更加容易。</p><p id="e177" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们来安装Vue路由器。我们仍然会在一个HTML文件上运行整个Vue程序。稍后我们将向您展示如何将Vue路由器与单文件组件集成在一起。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mm"><img src="../Images/e9a1708551e3dff7ada9bc11e505ea2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0D7qJzGbTSxSWSFfOJEpA.png"/></div></div></figure><p id="4eac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们复制这个地址并粘贴到一个脚本标签中。</p><p id="dee1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经完成了Vue路由器的安装。如果您检查窗口对象，您会发现全局api: VueRouter。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mn"><img src="../Images/2e9a3fe8ec799f2f75ff1b0892532c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGA866VYZpZqBQcBrU4hWA.png"/></div></div></figure><p id="efca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VueRouter为我们提供了许多内置组件:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mo"><img src="../Images/341631c56c5e2d0c24edc7b612673099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCMXFy9zQiXwmadjiQVFkg.png"/></div></div></figure><p id="118f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">RouterLink是一个内置组件。我们用它来生成导航按钮。作为一个组件，它仍然主要依靠道具从外部组件获取信息。</p><p id="8e88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">RouterLink总共有六个道具。<em class="lw">到</em>道具是最重要的一个。也是唯一的强制道具。至于其他道具，我们会在后面的课中处理。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mp"><img src="../Images/9e9943f37342b0fcee220a9192f88cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngJ5EXEMTNIQpzbCR0KPdA.png"/></div></div></figure><p id="47df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> RouterView </em>是另一个内置组件。这是Vue路由器用来显示组件的窗口。它有两个道具:名字和路线。默认名称值为default。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mq"><img src="../Images/7cb9521e1193794e4430cd39ead35991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA10Uvdp6_91SJQyb5Hlbw.png"/></div></div></figure><p id="36a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<em class="lw"> createRouter </em>方法来创建一个新的Vue路由器实例。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mr"><img src="../Images/eddf443f69fc0d1825cc2956e84e16e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKxlO7cMPetrBhErwgqIGA.png"/></div></div></figure><p id="7ca7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个演示程序有四个组件:root、home、about和user。这三个子组件共享同一个模板。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ms"><img src="../Images/a136df89aab58bcfccd0fcd8efd90ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1P0iRH60C4apxVrCVoQ1Q.png"/></div></div></figure><p id="d716" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Vue路由器管理的组件不需要提前创建。我们只需要定义选项对象。我们移除app.component()方法，并将每个options对象分配给一个变量。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mt"><img src="../Images/4d33b34ba295844a63782f0eaff476aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWQtSbAzAbaD1w2Kd46NBQ.png"/></div></div></figure><p id="8943" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变量名至少应该反映组件名。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mu"><img src="../Images/fa45851098456e2a883bf5cf040b6314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGf-tOf0WQL71eJ9qT0xvw.png"/></div></div></figure><p id="e957" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们创建一个变量，并将其命名为routes。不要选择其他名字。我们给它分配一个数组。这个数组是我们定义路由规则的地方。每个元素都是一个对象，代表一个路由规则。</p><p id="008d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们创建另一个变量，并将其命名为router。也不要选择其他名字。我们使用createRouter方法设置它的值。createRouter方法将一个对象作为其参数值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mv"><img src="../Images/85ea5f5abf12782805e9a2220071aea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrZxtSG7c4gk2k69T_kllw.png"/></div></div></figure><p id="54aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在对象内部，我们设置了两个属性。第一个是历史。它记录了我们传递给地址栏的每个URL，从而启用了浏览器的前进和后退按钮。</p><p id="e8f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了创建历史记录，我们有两个选项:createWebHashHistory和createWebHistory。第二种方法更适合SEO，因为它没有在URL中放置强制标签。但是缺点是它需要一个服务器环境。在这里，我们将使用createWebHashHistory。我们不需要向这个方法传递任何东西。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mw"><img src="../Images/9a8ffc5f6cf22ba8b15d555fbc4f2913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65fA9M2veKiBk4wJ-D8hgg.png"/></div></div></figure><p id="9ee7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个属性名是<em class="lw"> routes </em>。它的值是routes数组。我们特意将数组命名为routes，这样我们就可以使用快捷语法。我们只需要把单词routes放在这里。它将自动扩展为路由冒号路由。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mx"><img src="../Images/5e862eeb1954d6e4a59b93d808376a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6vY666R6aKWxAqKkhp5jhA.png"/></div></div></figure><p id="a043" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，路由器已经创建好了。我们使用app点使用方法将其添加到vue程序中。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi my"><img src="../Images/4e356bf1c5e0bc6d1d5504611a158927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zcqJk3q_wYY3h9I9QjJdrw.png"/></div></div></figure><p id="f27c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们回到routes数组来定义路由规则。每个路由都是使用对象定义的。我们有三个虚拟页面，所以我们至少需要三个路由规则。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mz"><img src="../Images/627d811d641ec9860f79ff0e3a6c2b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOAYOFX85RrO2IMLH5GY5w.png"/></div></div></figure><p id="c48f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> path </em>属性控制将在地址栏中显示的URL地址。斜杠表示根路径。我们用它来显示主页。</p><p id="4bfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw">组件</em>属性决定在访问由path属性指定的URL时将使用哪个组件。为了便于维护，路径名和选项对象名应该相同或至少相似。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi na"><img src="../Images/02415bdcdb1628749cf3ca499e0d5970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guOqM91Ph5hfuusPwqmqUg.png"/></div></div></figure><p id="fdc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，整个Vue路由器完成了。我们已经定义了路由规则，创建了一个新路由器，并将这个新路由器添加到应用程序实例中。让我们刷新页面并检查Vue实例。</p><p id="2974" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以找到一个名为美元符号路由器的新属性。它的值是一个普通的JS对象。它包含使我们能够以编程方式操作Vue路由器的方法。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nb"><img src="../Images/be28d9d23e226be479032bc9d9ad5b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gZPc4aaD4koYPQQlYNpEw.png"/></div></div></figure><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nc"><img src="../Images/52478c3a21d59b872dc38f0149210bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d9N-ae58ttL6Ugjl2jbVDQ.png"/></div></div></figure><p id="1536" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们转到根组件的模板。我们用routerView组件替换了动态组件。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nd"><img src="../Images/d4fe45dfccc5a8259bfc3536ffca526b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_HUJ8g_WZMjV7C9ZjO863A.png"/></div></div></figure><p id="aa24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们用routerLink标签替换这三个按钮标签。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ne"><img src="../Images/36e3157a3e873d19d33c626afdd71243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSrMc_phDcFyFa-4XA-noA.png"/></div></div></figure><p id="de8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用To属性来指定目标URL。我们在这里设置的URL必须与我们在routes数组中定义的URL相匹配。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nf"><img src="../Images/1e9f7e7de3e7de544570ca4bfe8a8edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-KosAvwTQ0WN09IZyQLUSg.png"/></div></div></figure><p id="0655" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，所有三个路由器链接都设置好了。</p><p id="35e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每当我们点击一个路由器链接，我们将添加一个新的历史记录。我们可以使用后退和前进按钮在记录之间来回切换。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ng"><img src="../Images/4e3384f0c60f226c33bc260360997c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6wWNXQjnjBt5hUvhF92wA.png"/></div></div></figure><p id="5e06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，routerLink标记将被呈现为A标记。这就是我们每次点击routerLink时，地址栏中的URL更新的方式。To属性的值将以hashtag为前缀，并用作A标记的href值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nh"><img src="../Images/095a62cd1dd5471064d5d4d9ca936ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrC1KGwAzBDYfBJwbC5ifQ.png"/></div></div></figure><h1 id="18b7" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">历史模式</h1><p id="8c3d" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">哈希历史模式很容易使用。我们可以直接在浏览器中测试我们的Vue程序。但是这种模式也有一个很大的问题:URL中的hashtag。我们不能移除它。这不仅让URL看起来很糟糕，对SEO也很不利。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ni"><img src="../Images/f157b544f7369fd9cb43f8866e63071e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCQgG0ZvTgj2ODWUq1u4wQ.png"/></div></div></figure><p id="e055" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> createWebHistory </em>方法启用HTML5模式。在这种模式下，标签不会出现在URL中。但是，这种模式需要服务器环境。我们不能直接在浏览器中打开文件。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nj"><img src="../Images/436f384a1f18960b73e523bf24f6fa4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3s1ICUA98JEfWcqC28Dmw.png"/></div></div></figure><p id="e110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">createWebHistory方法将baseURL作为其参数。默认值是slash，这意味着createWebHistory方法假定Vue程序是从服务器的根目录托管的。</p><p id="a663" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的实际项目中，我们可能会将Vue程序放在一个子目录中。我们可以将子目录的路径发送给createWebHistory方法。这样，Vue路由器将知道从哪里提供服务。</p><p id="129c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">HTML5模式的问题是你只能刷新主页。如果刷新其他页面，将会出现404错误。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nk"><img src="../Images/75d39d87510b4cef7a62815db09e4162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aj3Sn_5gUevqZ4fmL3_nHA.png"/></div></div></figure><p id="adf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为我们的Vue程序还是单页程序。只有一个HTML文件。</p><p id="daaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像<em class="lw">斜杠关于</em>和<em class="lw">斜杠用户</em>这样的URL部分并不指向任何实际的文件。它们只是VueRouter的命令，告诉它应该安装哪个组件。</p><p id="2334" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题很容易解决。只需给你的服务器添加一个全面的后备。如果一个URL不匹配任何现有的文件，服务器应该加载你的Vue应用程序所在的索引文件。VueRouter将再次从该URL运行命令。这就是我们刷新非主页的方式。</p><h1 id="ebfd" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">命名路线</h1><p id="02d4" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本节中，我们将讨论命名路由。我为今天的课程创建了一个新程序，并将在接下来的课程中继续使用这个程序。总之，我创建了五个路由规则。每个路由规则管理一个组件。</p><p id="442b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主组件有自己的模板。其余四个组件共享同一个模板。我还为五个路由规则创建了五个routerLinks。<em class="lw">到</em>属性的值与routes数组中的路径值相同。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nj"><img src="../Images/eaeb8787ab0d13971c58f89777cbaa7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*paMQXobz0yk94p91TFmKNg.png"/></div></div></figure><p id="757f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些路由器链接可以工作，但是有一个缺点。To属性的值必须与对应的路径值相同。如果我们需要更改路由路径，我们还需要更新routerLink端的属性。这是不可取的。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nl"><img src="../Images/110858e42beb2660f50d18e4ebbf00aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKfgsYaTb39sOQwBeBXFZQ.png"/></div></div></figure><p id="08fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更好的解决方案是使用命名路由。在每个路由规则中，我们添加一个新的属性:name。现在，每个路由规则都有一个名称，可以通过它的名称来引用。</p><p id="febc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在routerLink中，我们用v-bind为<em class="lw">到</em>属性添加前缀，并为其分配一个对象。在对象内部，我们设置name属性。它的值应该与相应的路由名称相同。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nm"><img src="../Images/ddc82af54446f7ab0f8fa796b145f17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPDv9elAve7TlwpFZFV71g.png"/></div></div></figure><p id="e15c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">RouterLinks和路由规则通过name属性连接。当我们更改路由路径时，我们不需要担心路由链接。</p><h1 id="b6a0" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">名称视图</h1><p id="5623" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们已经尝试了命名路由，现在让我们尝试命名路由视图。</p><p id="3a16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">RouterView是VueRouter的内置组件。它有两个道具:名字和路线。名称prop帮助我们区分RouterViews，使我们能够同时使用多个RouterViews。默认名称值为default。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nn"><img src="../Images/aac54c47dba55dc8a57826adf0a9a739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vs0Mw6Kl-CMg8YCdd-3KKg.png"/></div></div></figure><p id="1bd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">routes数组中的component属性连接到默认的RouterView。为了使用命名视图，我们将组件切换到组件中，并为其分配一个对象。在对象内部，我们使用RouterView名称作为属性名称。您可以设置多个RouterViews。这里，我们将home指定为default。这将给出与将<em class="lw">家</em>分配给<em class="lw">组件</em>相同的结果。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi no"><img src="../Images/1766acb52cb8b4242873dbfad63d4763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qw2TCgBryd1vdLyHjbNNLg.png"/></div></div></figure><p id="db5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们制作routerView组件的另外四个副本，并以其他四个子组件的名称命名它们。现在，模板部分完成了。它可以同时显示多个组件。接下来，我们准备路由规则。</p><p id="201b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望显示主路线上的所有子组件。组件属性可以帮助我们做到这一点。对于home组件，我们仍然使用默认的RouterView。我们将客厅组件分配给客厅RouterView。如果RouterView名称与组件名称完全相同，我们将能够在这里使用快捷语法。因此，让我们修改RouterView名称，使它们与相应的组件名称相同。</p><p id="c44c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根组件有五个RouterView，归属路由将为每个router view分配一个组件。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi np"><img src="../Images/87959694edb984961147d297f22ca6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0j12uM53dISpUAk5VJWJg.png"/></div></div></figure><p id="9429" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果routerView没有被分配组件，它将不会被呈现，因此不会在页面上留下任何痕迹。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nq"><img src="../Images/f0e0546fc415523586406f95ef3d570e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DiEetGif5OoZx5XybgxfhA.png"/></div></div></figure><h1 id="7217" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">嵌套视图</h1><p id="4e1f" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">假设我们有一个Vue程序。在其根组件中，我们有一个RouterView。我们希望根路由显示home组件。</p><p id="8782" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在route <em class="lw"> slash kitchen </em>中，我们想要显示home组件中的厨房组件。怎么会这样？</p><p id="40d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">厨房组件显示在home组件中，由URL中的一个部分控制，我们需要在home组件中安装一个RouterView。</p><p id="7285" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">home组件本身通过安装在根组件中的RouterView显示。所以我们实际上是将一个RouterView嵌套在另一个router view中。这称为嵌套RouterView。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nr"><img src="../Images/5cbf6ce2fad3ad173e2a01a201f193be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEQFugO06UGrnqf2sMnXQA.png"/></div></div></figure><p id="6ceb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们在上节课中使用的程序。我已经从根组件中删除了所有命名的RouterViews。</p><p id="76c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在home组件的模板中，我添加了一个DIV并为它设置了一个边框。在这个DIV中，我添加了一个RouterView。我还没有给嵌套的RouterView分配任何组件，所以不会呈现它。其他路线也不会受到影响。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ns"><img src="../Images/c04ffb61d5300bf2ba9ba8589b129272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IK7FjlN7aSQRu0kJTknU8w.png"/></div></div></figure><p id="7917" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们回到routes数组。</p><p id="3d33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们删除了除第一条以外的所有路由规则。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nt"><img src="../Images/e6d18093e4c18b8536d0bebc1d7d7d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iAi4doB_m1LoL5ABjWUPsA.png"/></div></div></figure><p id="987a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第一个路由规则中，我们添加了一个新属性:children。它的值仍然是一个路由数组。它为当前路由定义子路由。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nu"><img src="../Images/65ad14e69180f40c0e86474cc1d16474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*131DLeUwpahaoFUn41eFoA.png"/></div></div></figure><p id="9d20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的语法和以前一样。我们可以在这里粘贴以前的路线。这些路由将被视为slash的子路由。多亏了命名路由，我们不需要对RouterLinks做任何修改。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nv"><img src="../Images/db13d3c86b84eea315b437ba131d3565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lOJWLiniCh_Fi0fooFOe7A.png"/></div></div></figure><p id="8a53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们测试这个程序。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nw"><img src="../Images/9a03c72c1889b7255d300bf84b483866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzMyj2BiSEAjAIsEOMAA5A.png"/></div></div></figure><p id="3671" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们单击home按钮时，我们将返回到根路由slash。不包括子路由，因此Home组件中的RouterView不会被分配任何组件。当嵌套的RouterView没有显示任何组件时，我们不希望看到外部的DIV。有办法藏起来吗？</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nx"><img src="../Images/0c6b93ec78615521c30b836d11be5c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fENzYQKJylLba71EXyspWQ.png"/></div></div></figure><p id="878a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们转到控制台表，检查一个非常重要的变量:$route。我们通过根组件实例检查它。每个挂载的组件实例都会自动拥有它，而不仅仅是根组件实例。</p><p id="4369" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里注意，它的名字是route，不是router。此变量包含当前路线的重要信息。在我们的实际项目中，我们会经常使用这个变量。</p><p id="e79a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开它，我们会发现一个名为<em class="lw">的属性与</em>匹配。它的值是一个数组。我们在回家的路上，只有一条匹配的路径。所以匹配的数组只有一个元素。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ny"><img src="../Images/1a417f5e54c147c5f4254b91332988e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c58R5X9bH87KvRnC5zWZHw.png"/></div></div></figure><p id="a1b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们转到客厅路线，再次检查匹配的数组。这一次，我们有两个要素。子路线也被视为匹配。通过检查匹配数组的长度，我们可以知道home组件的RouterView是否被分配了一个组件。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nz"><img src="../Images/1566de92d91dffd36d5dc29da8dce4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLosvTJrVuiRTHTXpvmH2A.png"/></div></div></figure><p id="30a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在外部DIV中，我们添加了一个V-IF指令。我们检查匹配数组的长度。如果是1，则表示没有子路由。那么就不再需要呈现外部DIV了。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oa"><img src="../Images/a5c7fa4b07f2e9ad4bd63d6bab95fc2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRnsLzutk7DXD1OtrEGDog.png"/></div></div></figure><p id="cf1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">后四条路由都有子路由。将呈现外部DIV。当我们回到主页时，外部的DIV消失了，因为没有子路由。V-IF指令已经删除了它。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ob"><img src="../Images/33fa45530ad25eed824aabbb530d7e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIRjeiJmXHfjfDkb4PIwzQ.png"/></div></div></figure><h1 id="9a3c" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">动态路线</h1><p id="aaaf" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">动态路由使我们能够通过URL将信息传递到组件中。URL的动态部分将被视为一条信息。通过当前路径安装的所有组件都可以访问它。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oc"><img src="../Images/c0918c1034cbcacafa9b5b0c7a594be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gitxKO7h3aGHkLglJFvTBA.png"/></div></div></figure><p id="8b0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">区分静态部分和动态部分是不可能的，因为你永远不知道动态值是多少。因此，建议您在每个动态部分前添加一个专用的静态部分。</p><p id="53f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，在实际的城市名称前，我们加上斜线city。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi od"><img src="../Images/c2b9a5b07a3f9180846c40f9f4b7e7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAGQr64-9x76zz2oK5UEtQ.png"/></div></div></figure><p id="314e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个静态部分也可以与多个动态部分一起工作。但是仍然建议在每个动态部分前面加上一个静态部分。一条路线可以有多个动态路段。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oe"><img src="../Images/59e790f71076ceede62d89314cdda795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OkY2YVlLWBbxcLQvwvabZg.png"/></div></div></figure><p id="c173" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开$route，您会发现一个名为params的属性。这是我们访问URL的动态部分的地方。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi of"><img src="../Images/481d4f9226807e39517b1f699ebcf433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sldk4hniXo6W61cIarwzzA.png"/></div></div></figure><p id="ba02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使用动态路由，我们必须首先声明它们。在城市路线中，我们将动态路段添加到路径值中。这个动态部分实际上是一个参数名。每个动态部分都被视为URL的一个参数。</p><p id="df2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用冒号来声明参数。这里，我们将参数命名为cityName。冒号告诉vue router city name是一个变量，而不是一个实际的URL部分。CityName将用作params对象中的属性名。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi og"><img src="../Images/d4024f6b0d94f873917f72374112df79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kSJfm5lGZ2xIxZjQ5fsFw.png"/></div></div></figure><p id="a520" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在city链接中，我们添加了一个params属性。它的值是一个对象。属性名应该与我们在城市路线中定义的参数名相同。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oh"><img src="../Images/2719995633de719759ffee8dd12cd529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zuIZXwvdRsjYkoM6kP5EAg.png"/></div></div></figure><p id="3d21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以通过＄store . params . ci ity _ name在组件模板中访问city_name参数。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oi"><img src="../Images/b07d0dea82dff94a8843d4329a2b91e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4tXukDNMBYNonkBW9s6QA.png"/></div></div></figure><p id="2b30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">params对象现在有一个名为<em class="lw"> cityName </em>的属性。它的价值是伦敦。params对象中的属性是反应性的。如果我们更改URL中的城市名称，城市组件将自动更新城市名称。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oj"><img src="../Images/2f4e7a2302a3cbf7c1a1599a8361d91f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8AEJNZhSTYwvPnL5PJIrkw.png"/></div></div></figure><p id="a27a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们添加第二个参数。我们把它命名为nationName。最好给每个动态部分加上静态部分的前缀。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ok"><img src="../Images/82fb74b7216b23177e9f09dc1f8049c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MDHfA0YIGviQzrx8uIBwjw.png"/></div></div></figure><p id="36ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的实际项目中，我们经常使用param属性查询后端程序。一旦它们的值发生变化，我们需要进行新的查询。因此，我们能够监控参数值的变化并对其做出反应是非常重要的。</p><p id="97ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">观察器是监控参数变化的最佳方式。我们不使用两个更新挂钩的原因是它们只监视显示在模板中的属性。</p><p id="8744" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在city组件中，我们添加了一个beforeCreate挂钩。在您的实际项目中，设置观察器的最佳位置是创建的钩子。这里，我们选择beforeCreate钩子向您展示，在组件完全创建之前，params值已经准备好了。</p><p id="4efa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<em class="lw">安装观察器。$手表</em>。</p><p id="aaf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个参数是受监控属性的名称。这里我们需要设置一个回调函数，返回<em class="lw">这个点美元符号点params点城市名</em>在里面。</p><p id="be41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个参数是接收新的和以前的城市名的回调。这也是我们查询后端程序的地方。</p><p id="1a14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，cityName属性的监视程序已经完成。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ol"><img src="../Images/f7c2e5e4a2ecd751902f6ef4411d0199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6ZLIEZMsTJ_f_EylzN-jw.png"/></div></div></figure><p id="a68b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们复制了一个观察器，并将城市名切换为国家名。</p><p id="1fc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，城市和国家名称都被监视，不管它们是否在模板中使用。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi om"><img src="../Images/18055be231267dc232ac9a6776f33580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olaH_w_mJyP798QSLfUoKQ.png"/></div></div></figure><p id="2fe4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们测试这个程序。</p><p id="754a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们先改国名。</p><p id="bfdf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到监视器被触发了。它向我们展示了新的和以前的国家名称。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi on"><img src="../Images/6bd85b732460b9c6afe062d1aa54911a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtRnGISYT1G1O0DQO0-rZQ.png"/></div></div></figure><p id="10c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们离开城市页面时，城市和国家名称都将变得不确定。这些变化也受到了关注。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oo"><img src="../Images/76f1ac9ef2ac854d08f7340b23d14fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC0lg8Rb558sFGVCljJCJg.png"/></div></div></figure><p id="f2b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们进入城市页面时，城市和国家名称应该从未定义更改为当前值。但这些变化并没有被关注。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi op"><img src="../Images/9a6312e87a07bf1c5f40548e5d152d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93Dz4wrnhpGf9eV8TsChOw.png"/></div></div></figure><p id="6b0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您需要在我们第一次进入页面时对初始参数值的变化做出反应，那么您需要向观察器传递一个config对象。</p><p id="3ab8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们以第二个观察者为例。我们将一个配置对象作为第三个参数传递给它。我们将immediate设置为true。</p><p id="f0e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当我们刷新或进入城市页面时，国家观察者将被触发。这是一个非常有用的功能。如果我们使用国家名称查询后端程序，刷新页面使我们能够重复前面的查询。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi on"><img src="../Images/9efcc6e0d7582c7e5692a3a8e3eea6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxKkV6l6aKbWWrsDt1pjmQ.png"/></div></div></figure><h1 id="effa" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">正则表达式</h1><p id="64ce" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在用户页面中，我们希望显示用户名和ID。这两条信息是通过URL传递的。在用户路由器中，我们设置了两个参数:名称和ID。最好给动态部分加上静态部分的前缀。在这里，我们用用户名作为名称的前缀，用UID作为id的前缀。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oq"><img src="../Images/c6417dd7693c1dc608bd32fda14bc5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KKsm4nOSqt3ymgLy_UivA.png"/></div></div></figure><p id="8113" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们转到用户链接并设置params对象。我们设置了一个名字和一个ID。</p><p id="63af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，单击user按钮会将用户名和ID发送到URL。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi or"><img src="../Images/9df20b47dbe6963055e0c211f8d342f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MwBQ-3-sRAlxcWutaV8FA.png"/></div></div></figure><p id="84bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们转到用户组件的模板。我们通过route变量显示用户名和ID。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi os"><img src="../Images/fefa24bce2ad0bcef8382ba806021589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-UQnJJkiOC2_ABK5TUVGw.png"/></div></div></figure><p id="96c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用户可以对URL进行任何更改，并将其发送到我们的服务器。例如，他们可以设置各种ID值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ot"><img src="../Images/fdf1c8d52b9b0737b55f06503a95da7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0hco3TWwycOAIwmR3jX0A.png"/></div></div></figure><p id="b352" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显然，这是不可接受的。在挂载用户组件之前，用户路由必须验证用户名和ID值。</p><p id="c404" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">URL基本上是由斜线分开的字符串。通过在每个动态部分前面加上一个静态部分，我们可以很容易地分离出URL中嵌入的所有参数值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ou"><img src="../Images/c4a357ed201f97ed8b6477d164ea7200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*btex81iKb91xW6PnzE8fPQ.png"/></div></div></figure><p id="fcaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了验证参数值，我们使用正则表达式。我们不会使用本地正则表达式语法。Vue路由器开发了自己的自定义语法。</p><p id="9a81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们快速回顾一下基本的正则表达式语法。我们从选择器开始。</p><p id="adfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">插入符号匹配字符串的开头。<em class="lw">脱字符号A </em> (^a)表示字符串必须以字母a开头，Apple是匹配的。香蕉不匹配。</p><p id="cbce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">美元符号匹配字符串的结尾。<em class="lw"> A </em> <em class="lw">美元符号</em> (a$)表示字符串必须以字母A结尾。所以香蕉是匹配的，而苹果不是。</p><p id="dd88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点匹配单个字符，换行符或行结束符除外。</p><p id="4362" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">管道的意思是或者。它需要一个匹配字符串来指定至少一个替代项。</p><p id="59ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">括号和破折号允许我们设置一系列可接受的数字或字母。</p><p id="4416" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">括号表示子模式。比如我们把ab放在括号里。AB被认为是一个不可分割的实体。ABC是匹配的。ACB不是因为A和B必须在一起。</p><p id="f6cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">反斜杠用于转义特殊字符。</p><p id="3d58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">反斜杠小写D表示一个数字。</p><p id="9c69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">反斜杠小写W表示单词字符。</p><p id="a184" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">反斜杠小写S表示空白字符。</p><p id="f761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果将D、W和S大写，会得到相反的结果:非数字、非单词和非空格。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ov"><img src="../Images/04c94d1cf4f04163a0c967db50d68db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKFdHbEEpuaulPjIhpkd6Q.png"/></div></div></figure><p id="5eba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个选择器只匹配一个字符。他们需要使用量词。</p><p id="6165" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总共，我们有六个量词。</p><p id="92bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">星号表示零个或多个匹配项。</p><p id="888a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">加号表示至少有一个匹配项。</p><p id="eb94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问号表示零个或一个匹配。</p><p id="90dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">花括号用于设置特定的数字或范围。</p><p id="543d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个数字意味着正好有N个匹配。</p><p id="0533" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加逗号意味着至少有N个匹配项。</p><p id="6012" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两个数意味着N到M个匹配。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ow"><img src="../Images/394c2152ab44cb6c7dc155f9433b538b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DPDiHMV5RFHqdAvuQ7Vhg.png"/></div></div></figure><p id="38aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们看看为验证param值而开发的自定义语法Vue路由器。</p><p id="0979" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在参数名后面，我们放了一组括号。我们在这个括号中设置的正则表达式只验证一个参数值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ox"><img src="../Images/d1347f457e7a44a4e74c014739f5d279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EIHa8v-mHPpBxNUI16n5Dw.png"/></div></div></figure><p id="8994" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先为单个角色设定要求。我们可以要求它是任何字符，只有数字或单词字符。你可以设置更复杂的规则。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oy"><img src="../Images/a1b7318c4dee21c2d0b438bef11d7968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOYeOXGym4NBEVHu1FM2WA.png"/></div></div></figure><p id="52e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们添加一个量词来控制参数值的长度。</p><p id="51ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点星号表示匹配任意数量的任意字符。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oz"><img src="../Images/88458520a9266b182b72b93d634dd5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxFRQi9dBPkz5Mm9afWcAQ.png"/></div></div></figure><p id="d043" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在括号后面，可以放第二个量词。在这里，我们只能从星号、加号和问号中选择。不能使用花括号来指定范围。</p><p id="c75c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个限定符控制可以为被验证的参数提供多少个值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pa"><img src="../Images/bc1990374fd5ef002ffd906e7f924f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__VIofut-1NeQ-PYYT51Nw.png"/></div></div></figure><p id="59f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看这个例子，知道它是干什么的吗？</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pb"><img src="../Images/278df665594bc82c67436a63cfe56cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6ODTFRVUUEYbuAms0k-1Q.png"/></div></div></figure><p id="efdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">括号内的<em class="lw">点星号</em>表示参数值可以由任意数量的任意字符组成。换句话说，任何东西都会匹配。</p><p id="18e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个星号表示可以有任意数量的参数值。</p><p id="8cfb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此路由规则将匹配任何URL。我们用它作为一个安全网来捕捉所有无法识别的和非法的路线。换句话说，这就是404路线。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pc"><img src="../Images/3d9c9a22fdb008bbf1937f84b2d95abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGowxet6LGRawbrkMf8AcQ.png"/></div></div></figure><p id="03f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们回到本课开始时使用的Vue路由器程序。</p><p id="1bd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在ID参数后面，我们放了一组括号。我们要求所有的ID值都是数字。所以在括号里面，我们把反斜杠小写成d，我们需要一个额外的反斜杠来转义反斜杠。</p><p id="2b9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在字母D后面，我们放了一组花括号来控制合法ID值的位数。</p><p id="4112" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们把一和三。现在，合法的ID值必须包含至少一个数字，不超过三个数字。换句话说，合法ID的取值范围在0到999之间。</p><p id="bb9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在括号后面，我们不放任何量词。这意味着必须且只能有一个ID值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pd"><img src="../Images/9b159fbe83d225f1f0beb9130a2ac57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZuOKuACkUGW2-ErgGCgitA.png"/></div></div></figure><p id="44c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有非法路由将在控制台上留下一个空白页面和一个警告。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ob"><img src="../Images/ee95b9b516fcf0c3f89822352f11d5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dpyFe8Dfg4rc9vphg7dXSg.png"/></div></div></figure><p id="fa1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我们现实生活中的项目，我们通常会加载一个404页面来查找非法路线。</p><p id="456e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们返回到routes数组，添加一个新的路由规则。</p><p id="9ca1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将参数名设置在开始斜杠的后面。我们称之为ERR。在它后面，我们放了一组括号。在括号内，我们设置点<em class="lw">星号</em>。它匹配任何数量的任何字符。在括号后面，我们加上了另一个星号。它匹配任意数量的参数值。</p><p id="290e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有未定义和非法的路由将由最后一个路由规则处理。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pe"><img src="../Images/91c83e0348ca642c3960ff2d1b85457e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tu2QW9jzvraxOB_uYoNPEQ.png"/></div></div></figure><p id="1f2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们创建一个错误组件。</p><p id="33b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们复制了一份用户模板，并将其重命名为<em class="lw">错误模板</em>。</p><p id="4bdf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经预先为错误组件定义了一个类。</p><p id="0a50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在H2标签中，我们希望使用title属性显示第404页。</p><p id="8ef9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的H3标签中，我们想用消息属性显示<em class="lw">路径不能被识别</em>。</p><p id="f029" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了获得用户提交的路径，我们仍然使用route变量。它的fullPath或Path属性给了我们需要的信息。</p><p id="1ce8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的P标记中，我们添加了一个RouterLink，并使用它将我们带回到主页。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pf"><img src="../Images/8e6bab230f3f90cb4a5cbb9542c8d63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*muymxspejnFadgRDmwXREw.png"/></div></div></figure><p id="130c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们为错误组件定义一个选项对象。</p><p id="1bc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在数据选项中，我们将标题设置为<em class="lw">第404页</em>。</p><p id="4a17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">消息值需要包含当前路径。我们用计算机来设置它。</p><p id="b09f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过这个访问路由变量。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pg"><img src="../Images/86d54e29280aff8329782ce56c1b8c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjMe8pGX3ReyS2R0n-8cng.png"/></div></div></figure><p id="c0df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，误差部分完成了。我们来测试一下。</p><p id="7923" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任何非法或未定义的路线将加载它。路线将显示在组件模板中。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ny"><img src="../Images/135cce7e4b3b5dd65bdefa6b48cf4945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Orf7yDG3_9AwHFMKiJZ7uw.png"/></div></div></figure><p id="b070" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查控制台表上的路由变量。</p><p id="2909" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们打开params对象。</p><p id="f5e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到属性名是<em class="lw"> ERR </em>，这是我们在错误路径中设置的。</p><p id="4b7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它的值是一个数组。每个元素都是当前URL的一部分。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nz"><img src="../Images/039d89cad4f0087c51149fb546f5183e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zySj80RDFk9U4qlsY--O5Q.png"/></div></div></figure><p id="c05e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们删除第二个星号，那么整个URL将被视为一个整体，因为URL中的斜杠将被点选择器匹配。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ph"><img src="../Images/eb44825a673b0ab06c61f53f84d266dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EuzfIvoCrDEWhDIlYFiLKg.png"/></div></div></figure><p id="d158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仍将加载错误组件。但是参数值将变成一个字符串。这就是为什么建议您始终保留第二个星号。帮助Vue路由器更准确地分析非法路由。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pi"><img src="../Images/9236c38721c63f8c92a5d164bda2e103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Iz1m5kxC2V6qErf2vFlVw.png"/></div></div></figure><p id="2e63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">RouterLinks非常适合创建用户界面。但有时，我们可能需要以编程方式操作路由。</p><p id="ae46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开路由器属性，你会发现一系列可以帮助我们操作Vue路由器的方法。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pj"><img src="../Images/b2596a99af3686741d8df3fcfe007e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K7-kGvq7R6hxhc2jHE0YMw.png"/></div></div></figure><p id="c194" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> $router.push() </em>方法将我们移动到一个新的路由，并添加一个新的历史条目。它在编程上相当于routerLink。</p><p id="90ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> $router.replace() </em>方法也将我们带到一条新的路线，但不会创建新的历史条目。它取代了现在的，就像它的名字所暗示的那样。</p><p id="8483" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> $router.go() </em>方法帮助我们浏览历史记录。与浏览器的前进和后退按钮不同，我们可以控制跳过的历史记录的数量。</p><p id="47f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将一个整数传递给<em class="lw"> $router.go() </em>方法。该整数表示跳过的记录数。正整数意味着向前，负整数意味着向后。</p><p id="3175" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们只需要返回上一页，我们使用<em class="lw"> $router </em>。<em class="lw">背()</em>法。它等于将负1传递给<em class="lw"> go </em>方法。</p><p id="6702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们来试试这些方法。首先，我们通过单击导航按钮来创建一些历史记录。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pk"><img src="../Images/c1bd4c539797cb544888aba69aabb469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzsnlgVXjE1Z8sJEOzmp7A.png"/></div></div></figure><p id="4e8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查一下历史状态，它告诉我们在历史堆栈中的位置。可以通过$router.options.history.state检索历史状态。</p><p id="ed68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们目前在最新的一页。它的位置是6。如果我们在第一页，它的值将是0。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pl"><img src="../Images/277c0a3f21016c61382c3e5de5923ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86m0EbW4JD3-duNJ79z8Aw.png"/></div></div></figure><p id="eeaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<em class="lw">$路由器</em>。<em class="lw"> go() </em>方法，我们可以在历史堆栈中移动好几步。为了回到第一页，我们给它传递-6。</p><p id="7537" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">导航成功，<em class="lw"> $router.go() </em>方法返回<em class="lw">未定义的</em>。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pm"><img src="../Images/600c8ca6b1dd8d04ac739a943948f5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDO-DMHmJib8fWFouWfYBQ.png"/></div></div></figure><p id="672e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到我们已被发送到主页，后退按钮被禁用。它证明了我们处于零的位置。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pn"><img src="../Images/96e20ebc491a8add32bffc71087567d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoggTtyk2GrIflFvauNHzA.png"/></div></div></figure><p id="d2ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们继续倒退，<em class="lw"> $router.go() </em>方法将会无声地失败，仍然返回undefined。</p><p id="f016" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw">返回</em>的方法给我们同样的结果。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pl"><img src="../Images/3f990f47f947accdc8591e49fe3265da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_DEo_eF0zCbTov8vRJcZQ.png"/></div></div></figure><p id="589a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们运行<em class="lw"> $router.go() </em>方法而不向它传递任何东西，我们将重新加载整个页面。所以<em class="lw"> $router.go() </em>的作用和刷新按钮一样。如果需要重新加载整个页面，只需运行一个空的<em class="lw"> $router.go() </em>方法。</p><p id="86a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> go </em>方法是同步的。它返回给我们未定义的。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi po"><img src="../Images/362a2f6357a8d53cb074cec8913f000f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zogi2UBvsS5XPMD4q5rgEA.png"/></div></div></figure><p id="caea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，推送方法是异步的。它回报给我们一个承诺。让我们看看它的解析值和拒绝值是多少。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pp"><img src="../Images/3302f3f30ee51e7c83a160dfd8792224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYDrHsNVCmSdlmpDdw8vyw.png"/></div></div></figure><p id="58a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们删除了本地路由器链接。我们将使用<em class="lw"> $router.push() </em>方法手动导航。</p><p id="6b69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在home按钮标签中，我们添加了v on指令并监控click事件。我们触发了一个名为backHome的方法。</p><p id="7523" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们转到根组件来定义backHome方法。</p><p id="af0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们调用<em class="lw"> $router.go()方法</em>并将/传递给它。</p><p id="17e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> $router.push() </em>方法是异步的，如果您有在导航之后发生的操作，请记住在back_Home方法前面加上async，并“等待”<em class="lw"> $router.push() </em>方法。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pq"><img src="../Images/7036a1220b5530623d6142f3c779c98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r1lC-oOOOiTq9AK1cUKchg.png"/></div></div></figure><p id="d428" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查push方法的解析值。</p><p id="50b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们离开主页并返回。</p><p id="a3de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在home组件被安装后，我们得到了<em class="lw">未定义的</em>。这证明<em class="lw">推</em>方法的解析值为<em class="lw">未定义</em>。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pr"><img src="../Images/6f091792a9465d3a0fad5f3fada39b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d513mNpbg-DUk4wr8l5jeA.png"/></div></div></figure><p id="ebb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们再次点击主页按钮，我们将得到一个错误信息。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ps"><img src="../Images/797d92cb301c3385545566d85502627e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*faE0tuChwR97_1ROyroI1A.png"/></div></div></figure><p id="f1ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过检查返回值是否为<em class="lw">未定义的</em>，我们可以判断通过push方法导航是否成功。</p><p id="4f5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们删除城市链接。我们使用replace方法替换它。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pt"><img src="../Images/d3c9e842930a1904fafc3fd49fed2829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qYEwr0fwughJJxUM5RHpA.png"/></div></div></figure><p id="2a18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在backHome方法下面，我们创建了replaceCity方法。我们使用<em class="lw">替换</em>的方法进行导航。<em class="lw">替换</em>的方法也是异步的。</p><p id="152d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们向replace方法传递一个对象。在它里面，我们使用命名路由。我们使用params对象来提供城市和国家名称。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pu"><img src="../Images/d8d1dd05c462bd49a072ba978f01ea50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDAmXXSlVgPAIyQ5JxUm6g.png"/></div></div></figure><p id="9464" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们测试这个程序。目前，我们处于第4位。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ps"><img src="../Images/332b96051fadeba43d3752f3e1648e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9F6Ibb8HG_Qpr_RqD_hIQ.png"/></div></div></figure><p id="ab86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们点击城市按钮。</p><p id="5512" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经被送到城市页面。替换方法的旋转值也未定义。</p><p id="a856" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查一下历史状态。我们可以看到我们仍然在位置4。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pv"><img src="../Images/90df0c2d89fcb7b1485d2a468c97b59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUpoJ_PVXNSm7AqC2B91MQ.png"/></div></div></figure><p id="80f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们再次单击city按钮，我们将得到与push方法相同的错误消息。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pn"><img src="../Images/32b408f62aa41f2c7298fa75bc09c13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olJF3qkvNT1E3jjVF1kbJQ.png"/></div></div></figure><h1 id="9e7c" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">多方面的</h1><p id="936a" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">URL可以使用查询属性发送数据。在URL的末尾，我们添加了一个问号，并使用等号设置了一个键值对。如果您有多个键值对，请使用&amp;符号将它们连接起来。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pw"><img src="../Images/c42d1dc694401795a81e64eae6e06609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7tI_bl1QNMEWYDXevGnTw.png"/></div></div></figure><p id="75aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，URL包含一个消息属性。</p><p id="6ecd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有查询属性都将被发送到存储在查询对象中的route变量。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi px"><img src="../Images/abde1852c51145dd41be822b46b85cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eKHtL36XQm0jzb4c5nWcA.png"/></div></div></figure><p id="2660" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在组件模板中，我们可以使用双花括号显示消息属性，就像我们对param属性所做的那样。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oi"><img src="../Images/1945dd7833935fc54ce539586213cfd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhCEFkyKEcNvaarjFfGeuA.png"/></div></div></figure><p id="3e95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当没有查询属性时，我们希望隐藏H3标签。知道怎么做吗？</p><p id="52b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<em class="lw">对象点键</em>的方法。它返回一个给定对象属性名的数组。我们检查返回数组的长度。如果它是零，我们删除H3标签。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pi"><img src="../Images/3ae771fcecac3d857330f78b10382437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5zBm1p8NGnZ_W6Cg8GeEw.png"/></div></div></figure><p id="f798" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查询属性是反应性的，可以被观察器监视。</p><p id="a397" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们来谈谈重定向。</p><p id="aea3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们添加一个新的routerLink并设置一个新的path: /redirect。</p><p id="357f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">斜线重定向未定义。所以它触发了404页面。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi py"><img src="../Images/e005571f85f54c5aab66ce4ff4bab705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9xww2ksOIoxr1QjVBhf1g.png"/></div></div></figure><p id="5d89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在routes数组中，我们使用/redirect添加了一个新的路由规则。</p><p id="9ae8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们称之为重定向。我们没有设置组件属性，而是设置了<em class="lw">重定向</em>，并为其分配了一个对象。这个对象与我们分配给routerLink中的<em class="lw">到</em>属性的对象相同。我们重定向到归属路由，并向其发送查询消息。</p><p id="020e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，单击重定向按钮将我们带到主页。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pz"><img src="../Images/b2f634835dde056797303125cf2a8665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sb4Z1L3cwo9ObbBRxhMtrg.png"/></div></div></figure><p id="c396" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用函数语法设置重定向路由规则。</p><p id="114d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将<em class="lw">重定向</em>选项<em class="lw"> </em>定义为回调。这个回调接收重定向路由的路由对象。我们仍然将参数命名为<em class="lw">到</em>。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qa"><img src="../Images/ee65b1a9d3d5e9ce7e683d65ccce63c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jXNXzgg40MrnR7F5oLa9Q.png"/></div></div></figure><p id="8fea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw">重定向</em>路径是导航的真正目标。在我们到达重定向路径之后，发生到归属路由的重定向。</p><p id="092c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到<em class="lw">到</em>的值是<em class="lw">重定向</em>路线的路线对象。它使我们能够访问重定向路由自己的查询属性。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qb"><img src="../Images/644de6100df7028d19c16650efadadd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_CgmOpq6HhunocrTDM0S-Q.png"/></div></div></figure><p id="e3c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> redirect </em>方法需要返回一个对象来指定我们想要去的最终路线。这个对象与我们在routerLink标签中分配给<em class="lw">到</em>属性的对象相同。我们使用<em class="lw">名称</em>属性来指定目标路线。</p><p id="07a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在查询对象中，我们使用<em class="lw">设置消息值为. query.message </em>。这就是我们如何将重定向路由的查询属性中继到归属路由。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qc"><img src="../Images/10dfb577e0a17143899192da75419a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCiLwj6RrBQanhpYx5I9bw.png"/></div></div></figure><p id="0761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们测试这个程序。</p><p id="4945" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到家乡路由已经收到了我们在重定向链接中设置的消息属性。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi on"><img src="../Images/871db0980213ef32775f5695f2110ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArGHTCXFZanRXd6gxvIt6Q.png"/></div></div></figure><p id="2dfb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们来看看路由别名。</p><p id="71dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">别名不是第二个名字。这是另一条路。</p><p id="bca6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一条路线可以有多个别名。把它们列在一个数组里。</p><p id="ac61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">别名路径的工作方式与普通路径完全相同。它们还支持动态部分。您需要确保参数名称与原始路径中使用的名称相同。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pe"><img src="../Images/e314d19b19c3e4a02fb8a283cd131039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxk0kMGGlTV9c3_b62bZYA.png"/></div></div></figure><p id="3fc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还可以设置正则表达式来验证参数值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qd"><img src="../Images/b521090b6527aa5ada9e3516e68a8aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dc3t-EUbZ889UvuJfb5V6Q.png"/></div></div></figure><p id="8ad0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以为子路由设置别名。别名可以是相对的，也可以是绝对的。</p><p id="6396" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，对于厨房路径，我们将其别名设置为myKitchen，这是一个相对路径。</p><p id="9703" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以使用绝对路径作为别名。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qe"><img src="../Images/e96023dc7bb5164fb88624c6ffd9d9d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tgfK7BeE3xKy7T_mOL-tew.png"/></div></div></figure><h1 id="6f80" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">使用参数作为道具</h1><p id="f2f4" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">参数值可以作为属性值传递给组件。这样，我们可以跳过长前缀。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nq"><img src="../Images/2aebf9e9bc34c20b9d8ee4270db1b4f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khp5HE9HViqmz9bA4zMIyA.png"/></div></div></figure><p id="10f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们转到city组件的options对象，并将cityName和nationName声明为props。城市组件由vue路由器创建和安装。我们如何为它设置合适值呢？</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qf"><img src="../Images/d7123880348621131beed29e912563f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*soD5pe4_0pUCI7cZPfFx2w.png"/></div></div></figure><p id="be94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在城市路线中，我们增加了一个新的选项:道具。我们将其值设置为true。</p><p id="7042" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们传递给URL的国家和城市名称将被视为道具值，并自动分配给相应的道具。因此，保持正确名称与参数名称相同非常重要。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qg"><img src="../Images/16dde214329bc66e9c89b0ee2ddb4a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jgucXNZrjr4cBBcsvtDag.png"/></div></div></figure><p id="cca2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们测试这个程序。这两个道具已经从URL接收了它们的值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pl"><img src="../Images/36d6b8ff6765c2c3e34b58124d54a9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEdZxO5mlbvZFzuHJD7Sag.png"/></div></div></figure><p id="04fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还可以使用object语法设置props选项。对象语法允许我们设置默认的属性值。但是有一个问题:props值不再与来自URL的param值相关联。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qb"><img src="../Images/106d029f830e06e7ae6c09282d34db8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1SzV0-sZ0mv7kf3e-4DFg.png"/></div></div></figure><p id="2a85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">改变URL中的参数值不会影响这两个属性。因此，除非您想要设置固定值的props，否则不要使用props选项的对象语法。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qh"><img src="../Images/425de4f7f49ad123cb6e1807070b8577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJCGbLFkQex4LoQUceLzCw.png"/></div></div></figure><p id="3cc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">route对象存储了大量信息。有时，我们可能希望使用来自route对象的信息来设置属性值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qi"><img src="../Images/d5ad005fa457dc45f7e4fea8bf7c4431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFO8FjCervSeNzjMyiS4xQ.png"/></div></div></figure><p id="2105" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们需要使用函数语法设置props选项。我们将其设置为回调。回调接收当前的路由对象。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qj"><img src="../Images/6a242ccf3c53294d5b39dd9b6da8ffe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8pnauW7_Q5neby7LQ6bDA.png"/></div></div></figure><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qk"><img src="../Images/79f4bc6de657045066fbcfc513979bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yk2GP2M4kVbWNGs2c4Kpnw.png"/></div></div></figure><h1 id="c288" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">导航防护装置💂‍♀️</h1><p id="8817" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">从这一节开始，我们将学习如何设置导航卫士来过滤网址。</p><p id="bf81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">导航卫士只是在导航过程中的某个时刻触发的回调。它们都接收两个参数:<em class="lw">到</em>和到<em class="lw">。<em class="lw">到</em>是目标路线的路线对象。</em>中的<em class="lw">是当前路线对象。</em></p><p id="a4e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">导航防护有三种类型:全局、按路线和组件内。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ql"><img src="../Images/33ece71377eb70d8ba95b5b97af3502c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-jqT8fW2hCJvtziaFHBag.png"/></div></div></figure><p id="5b9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">全局防护在路由器级别工作，由每次导航触发。我们在路由器变量中定义它们。总共有三种类型的全局防护。</p><p id="f69d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每条路由的保护是在路由级别定义的。每个路由规则都有自己的防护。每条路线只有一种守卫。</p><p id="693d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">组件内防护是在组件级别定义的。我们在组件选项对象中定义了它们。还有三种类型的组件内防护装置。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qm"><img src="../Images/5b00665a086d29ac1968fc776892d1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2aT8g3u5i7ikKykhFFmh0g.png"/></div></div></figure><p id="e02a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们就来详细看看这些导航卫士。</p><p id="e607" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">全局防护是在路由器变量上定义的。它们会在每次导航时被触发。我们有三种类型的全局保护:beforeEach、beforeResolve和afterEach。每个保护都可以多次定义，并将按顺序执行。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qn"><img src="../Images/d29a7cc3a1e0b19f35e9bacb1917380d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_R02fzl_wxZxS4IXGyZwQ.png"/></div></div></figure><p id="bbe2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">三个守卫的回调都从接收<em class="lw">到</em>和<em class="lw">。</em></p><p id="9da7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个保护装置的<em class="lw">前有一个可选的下一种方法。</em></p><p id="778b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Vue路由器4正在尝试淡化<em class="lw">下一个</em>的方法。默认情况下，任何导航卫士都被视为成功。</p><p id="74ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使导航保护失败，只需显式返回一个falsy值。要通过一个守卫，你可以返回true或者干脆什么都不做。</p><p id="2ab6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每次我们开始一个新的导航或者更新当前路线时，比如改变参数或者查询属性值，都会触发<em class="lw"> beforeEach </em>保护。</p><p id="7c24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> BeforeResolve </em>稍后触发。它在导航被确认之前被触发。与beforeEach保护不同，beforeResolve会一直等到所有组件内保护都被执行并且所有异步组件都被解析。换句话说，当beforeResolve保护被执行时，当前路由使用的所有组件都准备好被挂载了。</p><p id="3816" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每次导航后保护触发<em class="lw">。它有一个可选的第三个参数，反映导航失败。后护板不能再影响航行了。我们主要用它来收集导航失败的信息。</em></p><p id="3d73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个routes元素内部都定义了PerRouter 保护。只有一种类型:beforeEnter。它会在我们进入定义它的路线之前触发。更改参数或查询值不会触发外围保护。</p><p id="1eea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您需要几个外围防护，请在输入前分配一个数组。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qo"><img src="../Images/dbed2ff6ddba16ed56fa38c61a30642a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qE9GDRituGofeGWpgjcaAQ.png"/></div></div></figure><p id="bcc9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">组件内防护是在选项对象内部定义的。有三种组件内防护装置。它们基本上是组件自己的钩子函数。</p><p id="e326" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个是<em class="lw"> beforeRouteEnter </em>。如果您需要几个beforeRouteEnter保护，请使用数组。</p><p id="edf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它在呈现其组件的路由被确认之前被调用。</p><p id="e658" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">beforeRouterEnter保护类似于beforeCreate挂钩，它在创建组件实例之前被调用，因此不能通过它访问组件实例。</p><p id="78ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外两种类型是<em class="lw">之前路由更新</em>和<em class="lw">之前路由更新</em>。</p><p id="2898" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> BeforeRouteUpdate </em>在呈现其组件的路由改变时被调用。更改参数或查询值将触发它。它指向组件实例。</p><p id="12ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> beforeRouterLeave </em>在呈现其组件的路线即将被导航离开时被调用。在导航还没有开始之前，它仍然指向组件实例。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qp"><img src="../Images/963ddeac23e52dfd88dc66fe36fdbf33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0x9CFwnbVVTkkJKJdCd_ng.png"/></div></div></figure><p id="0b6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们来试试导航挂钩。我们将从每条路线的守卫开始。</p><p id="199c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们找到城市路径，在进入之前安装一个<em class="lw">守卫。我们输出守卫名并输出它的THIS。进入</em>前的<em class="lw">守卫被安装在城市路线上。访问其他路线不会触发它。</em></p><p id="fb0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">beforeEnter在创建城市组件之前执行。它指向窗口对象。</p><p id="388d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">离开城市页面也不会触发beforeEnter保护。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qq"><img src="../Images/2f487b668fc2f83bea2adac6a2db64de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-oNspPGIDoF7jtjpsLuvdQ.png"/></div></div></figure><p id="e537" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们检查beforeEnter防护的两个参数。</p><p id="3299" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw">到</em>指向拥有beforeEnter防护的路线。<em class="lw">从</em>指向我们刚刚离开的路线。</p><p id="e1e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的浏览器已经在城市页面了。让我们保持这种方式，刷新城市页面。</p><p id="4e21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw">到</em>指向当前路线。</p><p id="5aa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从开始的<em class="lw">中的路径值是斜线，但它不是从点到回家的路径。名称值未定义，不是home。这只是一个占位符值，它不代表真正的主路径。</em></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi np"><img src="../Images/bbcbb0e007ceaf829713922bb2e14913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANt0H8mnS5PQvO5N8WxeTQ.png"/></div></div></figure><p id="9bb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们去主页，然后回来。</p><p id="329e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从首页转到城市页，<em class="lw">到</em>点城市路线，<em class="lw">从</em>点首页路线。home route的name属性是home，不是undefined，所以这里从开始的<em class="lw">才真正指向home route。</em></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qr"><img src="../Images/af3acc697840dbde1430afd164aa066c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qBI4aaWpTwj_jlKkI0HSrA.png"/></div></div></figure><p id="6539" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们转到用户页面，然后回来。<em class="lw">到</em>仍然指向城市路线，<em class="lw">从</em>指向用户路线。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qs"><img src="../Images/e3709d3063ce7496f02e1b49f72bf8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYybCIVx5mIhnDnHrjX1Ww.png"/></div></div></figure><p id="d517" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更改参数或查询属性值不会触发进入之前的<em class="lw">保护，因为我们从未重新进入城市路线。</em></p><p id="f062" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Vue Router 4中，默认情况下，所有导航防护都成功。我们不必显式返回true。但如果你愿意，你还是可以做到的。结果和什么都不做一样。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qt"><img src="../Images/c4cc00e6f2651e5485f56f1ff820777e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pUTBzA2dy73_y2Ock_-bg.png"/></div></div></figure><p id="08fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将true转换为false，beforeEnter防护将失效并阻止导航。</p><p id="68ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在在城市页面，让我们重新加载页面。我们可以看到应该安装城市组件的区域现在是空白的。控制台表上没有错误报告。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qu"><img src="../Images/1694698d9aaa4231c2e9020e7843e89c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMgMQbAWaMP7KRYrPoiP2Q.png"/></div></div></figure><p id="cb03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们转到主页，然后返回到城市页面。</p><p id="1d10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">beforeEnter防护已被触发并停止导航。我们仍然在主页上。</p><p id="498e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论我们点击城市按钮多少次，我们都不会离开当前页面。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qv"><img src="../Images/97bf0733f9e51ced07d55edaba2d2952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cpg13CAOCJeZvJ1kGlxvjQ.png"/></div></div></figure><p id="690b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以用beforeEnter守卫把我们引向另一条路线。</p><p id="061c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不是返回false，而是返回一个我们希望被重定向到的路径。在这里，我们返回斜杠。</p><p id="c7e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，点击城市按钮将我们带到主页。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qs"><img src="../Images/8a2aa0eb9ca11032335d34c40d1c78b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lo_tFpqFMeuxpDN4c0MeDg.png"/></div></div></figure><p id="b99f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以返回一个对象来设置更多的信息。这样，我们可以使用命名路由。</p><p id="1dc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们设置params选项，并设置名称和ID值。</p><p id="5dc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，单击city按钮将我们带到用户页面，并向它传递一个名称和一个ID值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qw"><img src="../Images/c6dd64f511debb46c8ad19fd89d96226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78aVCIkHCYhN8_RCocTWUg.png"/></div></div></figure><p id="3933" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前<em class="lw">进入</em>保护装置也支持<em class="lw">下一</em>方法。一旦我们将<em class="lw"> next </em>方法传递给beforeEnter防护，我们必须显式调用它。否则，beforeEnter保护将会失败。</p><p id="70e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，在单击城市按钮后，我们得到了一个警告和一个错误消息。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qq"><img src="../Images/bc8aadac2c26c3d42ea5b348fb4c0bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ln112r2f5nn--e94YpkrMQ.png"/></div></div></figure><p id="9408" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要解决这个问题，我们需要调用一个空的<em class="lw">下一个</em>方法。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qj"><img src="../Images/114713dabe5aa3748c0f427bdb17d980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tXr0Y0_TSZ17cZU8KxGkTw.png"/></div></div></figure><p id="be31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以将返回的路由对象传递给下一个方法。我们将被定向到由传递给下一个方法的<em class="lw">对象指定的路线。</em></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qx"><img src="../Images/6d36226cfbb9b29095eb510513c68222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNo3fSOCncH4PmCpgDTTKw.png"/></div></div></figure><p id="dab0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的建议是尽可能避免使用下一个方法。如果你需要阻止一个导航，只需返回false。要通过一个航海警卫，什么都不用做就行了。让默认设置为您工作。</p><p id="74ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们尝试为一条路线安装多个beforeEnter防护装置。我们以回家的路线为例。</p><p id="0eb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在home route中，我们设置了beforeEnter选项，并为其分配了一个数组。</p><p id="d66b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个元素都是一个回调。这些回调将按照创建顺序执行。执行完最后一次回调后，将加载受保护的路由。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pz"><img src="../Images/3b59f8cb001bc0ccc05cd5000ac96867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKgfzDNonFQ6ev0SVL1e3Q.png"/></div></div></figure><p id="37ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一个守卫返回假，它将停止导航。它后面定义的守卫不会被执行。守卫的路线将变得无法访问。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi np"><img src="../Images/7a32ef89026b24b19f0b2fc54dfbc951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnSGSnJsD4uE-gEGV4H1wQ.png"/></div></div></figure><p id="34c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们试过每条路线的守卫。只有一种类型:beforeEnter。它安装在路由级别，并在我们输入路由之前触发。</p><p id="ed14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们试试组件内防护。我们仍将使用城市组件作为示例。</p><p id="92c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有三种类型的组件内保护:beforeRouteEnter、beforeRouteUpdate和beforeRouteLeave。我们全部安装。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qy"><img src="../Images/65833411e2fc96fa788f30ad91e04876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUhNxfeqUrD8H0RoYjbdDg.png"/></div></div></figure><p id="9ac1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试试这个程序。我们刷新页面并点击城市按钮。</p><p id="f960" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到<em class="lw"> beforeEnter </em>守护在<em class="lw"> beforeRouteEnter </em>守护之前执行。这是有意义的，因为组件是由路由管理的。</p><p id="117a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还可以看到，在创建城市组件实例之前，执行了<em class="lw">before route enter</em>保护。因此，它不能访问城市组件实例。另外两个组件内的守卫可以通过这个访问城市组件实例。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qj"><img src="../Images/d8491fb23bc7fb7fc0bf2189c73e0317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUrnGUBJQ-dcKZM0eEa9YQ.png"/></div></div></figure><p id="9a41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们更改URL中的国家名称。</p><p id="fbb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到beforeRouteUpdate保护已被执行。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi np"><img src="../Images/a91532f819a78ddf2eff25feb76c00ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6WgHCfVleiVeAS5D4xcRqQ.png"/></div></div></figure><p id="f4f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更改城市名称也会触发beforeRouteUpdate保护。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qj"><img src="../Images/81b4f8bc53fbeaf863c9e8fb71896752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZIqI7ANIC7ZVwohcJwnkg.png"/></div></div></figure><p id="9c57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们单击用户按钮离开城市页面。</p><p id="096b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">beforeRouteLeave保护被触发。在卸载城市组件之前触发。这就是为什么它仍然可以通过这个访问城市组件。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qq"><img src="../Images/54fcb7ae42e58ee6d9e01ed2a32671a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AumBFMiLtJJPUCFKQIihug.png"/></div></div></figure><p id="35d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们检查三个组件内防护装置的参数中的<em class="lw">到</em>和<em class="lw">。</em></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qz"><img src="../Images/8f96eee1ae7dae4904c3c4170553a344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMkSqEbwm94ul5BEluquNg.png"/></div></div></figure><p id="5384" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们刷新程序，然后单击“城市”按钮。</p><p id="2e16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw">到</em>指向城市路线，<em class="lw">从</em>指向用户路线。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ra"><img src="../Images/d7835f04743262641e577a18e10ca50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZHluEsK8MoTC1lIJwbObQ.png"/></div></div></figure><p id="e749" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们尝试beforeRouteUpdate保护。我们改变国家名称来触发它。</p><p id="a03e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这次<em class="lw">到</em>和到<em class="lw">都指向城市路线。<em class="lw">到</em>指向带有新国家名称的更新路线。<em class="lw">从</em>指向原来的路线。</em></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rb"><img src="../Images/3e20eec2f7e647d0dbcf5419731569bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvYCbUEEN9Xvm0t04dWDVg.png"/></div></div></figure><p id="bf56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们单击home按钮离开城市路线。</p><p id="5916" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们是出市路线，所以<em class="lw">到</em>指向回家路线，<em class="lw">从</em>指向市路线。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qj"><img src="../Images/bc032b1406445a585d794f8fc35237f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCApQ5kPvaZ2s_aBzWYn2g.png"/></div></div></figure><p id="18d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的实际项目中，我们可以使用beforeRouteLeave设置一个弹出窗口，询问用户是否确定要离开当前页面。</p><p id="d735" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们定义一个常数，命名为answer。</p><p id="d673" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<em class="lw">窗口点确认</em>方法设置它的值。</p><p id="63ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们离开城市路线时，确认方法将被触发并生成一个带有<em class="lw">取消</em>和<em class="lw">确定</em>按钮的弹出窗口。</p><p id="963e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果用户点击<em class="lw"> ok </em>，确认方法返回true。如果他们点击<em class="lw">取消</em>，确认方法返回假。</p><p id="b5c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们检查答案值。如果不是，我们返回false来取消导航。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qk"><img src="../Images/c9ad69946af5483fabb4cbaf5cccab51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fbl5OjZ-cEmUgI9dx5weCw.png"/></div></div></figure><p id="c466" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">beforeRouteEnter guard支持<em class="lw"> next </em>方法。下一个方法中的<em class="lw">起着非常重要的作用。</em></p><p id="b7a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看<em class="lw"> next </em>方法回调的执行时间。它在创建的钩子之后执行。这意味着传递给下一个方法的回调可以访问城市组件实例。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qu"><img src="../Images/f081c2634fe48a295a98ae0e950ff9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fi_S5OlOvPv9OJ2wxkiK_Q.png"/></div></div></figure><p id="b892" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们唯一可以访问的组件实例是根组件。我们通过变量vm访问它。</p><p id="7fbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VM在传递给下一个方法的回调中可用。</p><p id="8575" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根组件实例可以通过引用访问其子组件。如果我们给city组件一个ref，那么我们将能够访问beforeRoutEnter守卫内部的city组件实例。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nq"><img src="../Images/8c24e76f968db14d30690a9a77d099da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_gUmPUkxTQ-o3tgIH-VYA.png"/></div></div></figure><p id="b2ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但问题是子组件是通过RouterView安装的。我们如何为它们设置ref值？现在只要记住这个问题。我们将在后面的课程中向您展示解决方案。如果您有空闲时间，请复习一下组件插槽。</p><p id="2a0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们来试试全球卫士。</p><p id="0ed6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">全局防护在路由器变量中注册。当我们输入或更新路线时，会触发全局防护。所有三个全球守卫一起触发。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qs"><img src="../Images/c7645deda0359d5bcf5eaf306e6cb86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiJp1HyfolELNTaUFVlNrg.png"/></div></div></figure><p id="bb84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们转到城市路线。</p><p id="7944" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">城市路线有每条路线和组件内的警卫。让我们检查一下这些卫兵的处决顺序。</p><p id="aea9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">进入城市路线后，已经触发了五个守卫。</p><p id="49b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个保护之前的全局<em class="lw">首先触发，然后是进入</em>之前的<em class="lw">，这是每条路线的保护。</em></p><p id="d02f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三个防护是<em class="lw"> beforeRouteEnter </em>，它是城市组件自己的组件内防护。</p><p id="6438" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外两个全球守卫最后被处决。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rc"><img src="../Images/b2746ba8a41bc03bf228534c938815a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBDagw8v0dDVmZ-MwuSeXQ.png"/></div></div></figure><p id="1764" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">综上所述，当我们输入一条路线时，守卫之前的三个<em class="lw">都会被执行。执行顺序是全局的、按路线的和组件内的。另外两个全球守卫最后被处决。</em></p><p id="a036" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们更改URL中的国家名称。</p><p id="68ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这次，我们有四个被触发的守卫。</p><p id="4804" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">三个全球守卫都被触发了。<em class="lw"> beforeRouteUpdate </em>防护正好在每个防护之前的全局<em class="lw">之后触发。</em></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rd"><img src="../Images/3a3d5bce11cf0a79a1ac874151aa8ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUuy8TgSHGfiCAZP5ciRzQ.png"/></div></div></figure><p id="15cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们单击用户按钮离开城市页面。我们转到用户页面。</p><p id="672d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">城市组件的<em class="lw"> beforeRouteLeave </em>守卫首先触发。</p><p id="7f0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在它后面，我们有三个before guards，按照全局、每个路由和组件内的顺序执行。</p><p id="c5ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在三个before守卫之后，我们有另外两个全局守卫:beforeResolve和afterEach。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rc"><img src="../Images/747e1d68eb103bc52266263a3ec1ab80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5iAY7r8JZ_sz3TNDgnK2Q.png"/></div></div></figure><p id="2a81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们回到主页。这是我们得到的结果:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rc"><img src="../Images/cfa5e478897f266ae696512f1d8a9914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c6NoJCK5sTKzJpNZBneVrQ.png"/></div></div></figure><p id="8c80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个触发的防护是用户组件的beforeRouteLeave防护。其次是三个全球警卫，这意味着主页。</p><p id="cd34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">全球【after每个守卫在导航被确认后触发。重定向已经太晚了。</p><p id="4038" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lw"> beforeResolve </em>防护在导航确认之前触发。导航还没有确认，所以它仍然可以重定向。</p><p id="06ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<em class="lw"> beforeResolve </em>保护被触发时，所有组件内保护和异步组件都已经被解析。换句话说，当一个<em class="lw"> beforeResolve </em>保护被执行时，目标路径所需的所有组件都准备好被安装。这使得<em class="lw"> beforeResolve </em> guard非常适合在用户无法进入页面的情况下获取数据或执行您希望避免的操作。</p><p id="2523" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在beforeEach保护中重定向，则必须添加If语句以确保目标路由不是当前路由。否则，你会得到一个无限循环。原因是在每个人在每条路线上工作之前，包括目标路线。</p><h1 id="1cae" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">过渡和保持活力</h1><p id="40e7" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">routerView组件为我们安装和移除组件。每次我们更改路由时，当前组件将被卸载。当我们移回来时，将再次创建卸载的组件。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi re"><img src="../Images/06d613c2dbed08251cb5e413494f5162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qfORkAiQ9V9qktLTjvEVOQ.png"/></div></div></figure><p id="f6da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用keepAlive组件，我们可以将未安装的组件保存在内存中，并在以后重用它们。</p><p id="7db3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是keepAlive能和routerView一起工作吗？让我们找出答案。我们直接把routerView包装在keepAlive里面。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rf"><img src="../Images/e6f3563788d419d931ae216b38ff8b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0JUl9KELEoLjBavd0C9Zw.png"/></div></div></figure><p id="bdee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主页已成功加载，但我们在控制台上收到一条警告。它说routerView不能直接在transition或keepAlive中使用。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rg"><img src="../Images/1a57a564de7231952af99b4729eea4fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fz_tNvxQ-c_zIL3IPKFROA.png"/></div></div></figure><p id="e9ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们切换到其他页面，将不会保存任何组件。所以keepAlive不起作用。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rh"><img src="../Images/9be07e84b306c640c5d7781acc9bfaa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-sI8WOL1IJiuh9ckfU6_Q.png"/></div></div></figure><p id="3f3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">警告也向我们展示了新的语法。我们需要做相反的事情:在routerView中包装keepAlive或transition。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ri"><img src="../Images/bfc00c5a91b244a71fd4a773506ca3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6l4Oa0tGtMoalOy8v-PW_w.png"/></div></div></figure><p id="f2c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在routerView组件中声明了一个命名槽，并使用动态组件来显示组件。这也使我们能够为routerView安装的组件设置<em class="lw"> ref </em>值。</p><p id="cedf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从警告中复制正确的代码并粘贴到我们的程序中。</p><p id="e7c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">V-slot传递两个属性。第一个是组件。它表示当前路线安装的组件。我们将其赋给组件标签的<em class="lw"> is </em>属性。</p><p id="8f98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个是路由。它是当前的路由对象。我们可以通过它访问查询和参数属性。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rj"><img src="../Images/d07cf13c09db9e4a6ed679ee28ffc79e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-UPN0BCMTR0TdzuyOgr-w.png"/></div></div></figure><p id="0f74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们测试这个程序。</p><p id="ebb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们切换页面时，我们可以看到没有组件被卸载。因此，每个组件只会被创建一次。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rk"><img src="../Images/307d750c7c8007b000101dcaa80c43f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KzOrhE9Ud0Vz0YuNBB0LgA.png"/></div></div></figure><p id="bb60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们尝试过渡。我们将<em class="lw"> keepAlive </em>切换到转换状态。我们在中将过渡模式设置为<em class="lw"> out。</em></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rl"><img src="../Images/58bf5ca1c8a0085a88af1c0b0984c2c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3r6sQuDrV3x9I1QeY3273g.png"/></div></div></figure><p id="e3a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用animate.css生成的过渡效果。我们要做的第一件事是安装animate.css。我们将链接标签复制到我们的程序中。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rm"><img src="../Images/4a9a49cab049502f287ad417c7ec778c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GHyO3Irsdw7lZujIoWJSjA.png"/></div></div></figure><p id="3636" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们选择一个过渡入和出的效果。</p><p id="4e67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用enterActiveClass将转换设置为有效。对于过渡效果，我们使用leaveActiveClass。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rn"><img src="../Images/10164273158d4c7b6a43c162e8c7f4cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyhVGjlkYxZ9vRDC-XWD-A.png"/></div></div></figure><p id="aea7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，已经添加了过渡效果。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ro"><img src="../Images/03a22f80ff61dc73b16f29182e1381a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-Kl88LDlU8oWNol8o7thg.png"/></div></div></figure><p id="4a1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想重用组件，只需用keepAlive包装动态组件。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rp"><img src="../Images/38679a8a10e7a29051c8c063554a5a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqslbuNjhZr95uN3zPi39A.png"/></div></div></figure><p id="ccd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用当前设置，每条路线都有相同的过渡效果。有时，我们可能希望为选定的路线设置特殊的过渡效果。知道怎么做吗？</p><p id="e0fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方案仍在美元符号路由变量中。</p><p id="7fa8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它有一个值为对象的元属性。我们可以用它来传递每条路线的定制信息。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rk"><img src="../Images/516f8659bb208046072bdaa2833e066d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1G2SUE7Cj-coEYmsLB-I3A.png"/></div></div></figure><p id="5a7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在设置路由规则时，我们可以为每条路由设置一个自定义元对象。此处设置的属性将全部发送到路由变量的元对象。</p><p id="af2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，在home路由中，我们在其元对象中设置了一个消息属性。此消息属性将被发送到归属路由的元对象。只有当我们在回家的路上时，它才是可见的。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi np"><img src="../Images/2bc4f129a9046173715114d32bb3d322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GIRFF0opbIN7_QBQ66U0Q.png"/></div></div></figure><p id="fd6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们给每个路由规则一个元对象，并使用路由名设置消息值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mu"><img src="../Images/75f906df124b5b9b5b0af56a11a4a908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuXaViu_CSLZJvQ3Hs0uqA.png"/></div></div></figure><p id="7345" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们在每个守卫前设置一个全局<em class="lw">。</em></p><p id="16cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过<em class="lw">到</em>点元来访问元对象。每次我们输入一个路由，beforeEnter guard都会输出该路由的元对象。这省去了我们手动检查meta值的麻烦。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rq"><img src="../Images/345a028ed8f88c97522cc21bafec24f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPTNE2OnQBAbB23x27JU9Q.png"/></div></div></figure><p id="8780" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们向上滚动并找到routerView组件。</p><p id="f2a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它的v-slot接收两个道具:组件和路由</p><p id="aa73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Route是当前路由对象。它使我们能够访问为每条路由设置的元属性。它在routerView标记中可用，这意味着transition标记可以访问它。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qr"><img src="../Images/d5d1029bde2950b2806e0bc25703a493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_RRMuYDL4Uxy9WXlOedWQ.png"/></div></div></figure><p id="91ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将转换类名移动到归属路由的元对象中。</p><p id="1657" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们创建两个属性:enterClass和leaveClass。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rr"><img src="../Images/c9f0b1b676234d31f0337b1521000d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEF6FYCD-GLHSImQ056MmQ.png"/></div></div></figure><p id="718b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们返回到转换标签，并在<em class="lw">输入</em>和<em class="lw">离开活动类</em>前加上v绑定指令。</p><p id="5db0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先检查路由元是否包含<em class="lw"> enterClass </em>属性。如果是，我们将值设置为<em class="lw"> route.meta.enterClass </em>。如果没有，我们从animate.css中选择一个不同的过渡效果。</p><p id="a595" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，回家的路线将会有它自己的转变——实际上。其他路由共享相同的过渡-实际上。</p><p id="2392" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于leaveActiveClass，我们以同样的方式设置它的值。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rs"><img src="../Images/c80757148dcaf5323fe1d9dc08c2272e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9YZ5WEiCY3nfS6ea4dSWg.png"/></div></div></figure><p id="a2db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">滑动转换效应仅在我们进入主页时出现，因为只有home route的meta具有自定义的enter和leave类。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rt"><img src="../Images/fd233e06cd1bd96dee31b09388ee9ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfgNC8_2MMxTEHn--8uFig.png"/></div></div></figure><h1 id="c51d" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">组合API</h1><p id="2a84" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">从本节开始，我们将向您展示如何在Vue设置功能中预定义Vue路由器。设置功能在创建组件实例之前执行。所以我们不能通过它访问$router或$route对象。</p><p id="7879" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决方法是创建我们自己的路由器和路由对象，如下所示:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ru"><img src="../Images/64440ca38132148be4f6df4fca3f719f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCfwa2BSOKoAbUbiRjJPxg.png"/></div></div></figure><p id="2442" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Route为我们提供当前路线的信息。路由器帮助我们获得路由方法。</p><p id="448d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在设置功能中，我们只能访问两个路由守卫:onBeforeRouteUpdate和onBeforeRouteLeave。这两个保护直接来自VueRouter API。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rv"><img src="../Images/215434aa748adbcd462cc90ba5fe4176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7P4PFPRXsSkrzEyZP_yHw.png"/></div></div></figure><p id="93a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们更新param值时，onBeforeRouteUpdate保护会触发。</p><p id="9af1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">onBeforeRouteLeave警卫</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rw"><img src="../Images/f739307cd7434bbe68b1bc62f5948a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9Vi9xGsae197aU6ZS2qyw.png"/></div></div></figure><h1 id="dfe0" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">自定义路由器链接</h1><p id="2eeb" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">默认情况下，routerLink标记将被呈现为A标记。<em class="lw">到</em>值控制被渲染标签的href值。有时，我们可能想要完全控制导航按钮的样式。我们不希望routerLink组件自动呈现在A标记中。</p><p id="1620" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还尝试了routerLink组件的一个属性。这是<em class="lw">习俗</em>。将它添加到routerLink组件中允许我们完全定制导航按钮。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi np"><img src="../Images/9e0c81610e4e5e9f70b1cc54050b948c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_urucL30Uh5SN2pC0yUUQg.png"/></div></div></figure><p id="de50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装了自定义属性的RouterLink组件不会再呈现在标签中，因此我们可以完全控制导航按钮的样式。我们选择主页链接，并在其中添加<em class="lw">自定义</em>。</p><p id="0f21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到主页链接现在只是一个B标签。包装标签不见了。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rx"><img src="../Images/c771e24bbc4038284892dc9f0f1ae4ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ycpEaYj-zQN2qAqjGCPcg.png"/></div></div></figure><p id="c35c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为A标签没了，home键再也不能带我们去首页了。</p><p id="dbb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我们需要使用命名槽。我们将vSlot属性添加到routeLink标记中。</p><p id="374f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总共，我们可以发送五个属性。它们是navigate、href、route、isActive和isExactActive。这些属性允许我们在起始和结束routerLink标记之间重新创建一个功能导航按钮。该区域属于根组件，而不是routerLink组件。</p><p id="6130" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在B标签中，我们添加了v on指令，并监视click事件。我们给它分配导航属性。</p><p id="845a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，B标签可以作为一个导航按钮。点击它会将我们带回主页。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qj"><img src="../Images/2050d7a2d5d14d77e6b525b5579f94df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jU4KlfCz4WNPqG_LaFQDA.png"/></div></div></figure><p id="3e04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果出于某种原因，您需要自己创建一个A标签，只需使用HREF属性创建A标签的HREF属性。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qb"><img src="../Images/052261f205bfcec0e90d18ac2e8c3002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mzbMKkJ5UuAUbRSd3oUGog.png"/></div></div></figure><p id="6781" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">route属性相当于$route。它存储当前路线的基本信息。我们可以通过它访问路径、参数和查询属性。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi rw"><img src="../Images/05b0dc139c099f0ceb7c9cf01b356159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlGN-JgbmKiFScBNR07J0Q.png"/></div></div></figure><p id="78cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们自己的A标签不会自动接收这两个活动类。我们需要手动设置它们。isActive和isExactActive属性都是布尔值。当当前链接处于活动状态时，它们将变为真。</p><p id="82f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用对象语法设置class属性。我们使用预定义的类作为属性名。这两个活动道具决定了该类是否会被添加。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ry"><img src="../Images/b0752222cff1fe99dc62d5dee1c4a780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXBXIIz0VPpMKkwZtRA3Bg.png"/></div></div></figure><h1 id="4025" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">UseLink:创建我们自己的RouterLink Comp。</h1><p id="972d" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本节中，我们将创建自己的<em class="lw"> routerLink </em>组件。</p><p id="94b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VueRouter API有三种使用方法。我们已经尝试了其中的两种。第三个是<em class="lw"> useLink </em>。它使我们能够在设置功能中创建路由器链接。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi rz"><img src="../Images/17a86f20dc636f17b7abca9453a94622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*g1XrZdcEBUyESyZ4C7XMTQ.png"/></div></figure><p id="3030" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本地routerLink组件通过六个属性获取外部信息。因为我们正在创建自己的routerLink组件，所以不再需要自定义属性。这两个activeClass属性由活动链接自动设置。我们不需要手动设置它们。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi sa"><img src="../Images/983546ffd93cb9559112f42af0ffd307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vweP2suBQi5D_3Lubn8Duw.png"/></div></div></figure><p id="bb83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将自己的链接组件命名为<em class="lw"> myLink </em>。myLink是我们自己安装的普通组件，不是VueRouter。所以要小心字母的大小写。坚持使用小写字母。</p><p id="69ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们仍然使用与routerLink组件中相同的语法来设置<em class="lw">到</em>属性。然后我们设置ariaCurrentValue属性。将大写字母换成小写字母，并在前面加一个破折号。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi sb"><img src="../Images/117a6124e4e7c299f307189f29d95ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*72c2CmKtz24y-DuL-nkT3g.png"/></div></div></figure><p id="7b64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们为<em class="lw"> myLink </em>创建一个新模板。我已经预定义了一个myLink类来设计my-link组件的样式。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi sc"><img src="../Images/b479d452959d7691f773d6684474355b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uAa1DInwS51RMjkLGimUJw.png"/></div></div></figure><p id="0ed0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们创建一个span标记，并为它分配myLink类。我们将稍后设置它的内容。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi sd"><img src="../Images/e31a2fdc82df02fd161cc9997792fc7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEEa8yQ-hKu7bu56cY59mA.png"/></div></div></figure><p id="b06d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们声明myLink组件。我的链接不由VueRouter管理。我们需要使用app.component方法自己创建它。</p><p id="45ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用spread操作符来声明它的属性。我们直接从RouterLink组件扩展props对象。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi se"><img src="../Images/69f5b66383084baf068560a758d581b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2iWeTqJECguZOP3S94Reg.png"/></div></div></figure><p id="184e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们添加设置功能。该设置自动接收传递给组件的道具。我们控制台记录它并检查程序。</p><p id="4e00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有四个myLink组件。所以我们总共有四个输出。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oi"><img src="../Images/d4be949a870cb62641e1088377fb48d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3175jD9lw0gwFMiK7UhUvA.png"/></div></div></figure><p id="8f9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个myLink组件都有四个道具。不包括这两个活动类。自定义和替换值都为假。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi sf"><img src="../Images/4d9ee67ae83b005b5d5d2124539ef9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZ503xwiYPuZPK_6sCaLXA.png"/></div></div></figure><p id="e081" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设置myLink的模板与创建自定义routerLink组件非常相似。我们使用公开的routerLink APIs进行导航。</p><p id="8d38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在自定义路由器链接中，我们使用v slot来公开API。这里，我们使用设置功能。</p><p id="8d0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在setUp函数中，我们调用userLink方法并将props对象传递给它。</p><p id="1c38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">useLink方法返回我们五个属性。它们是HREF、导航、路线、isActive和isExactActive。它们与我们在自定义路由器链接中分配给v slot的属性相同。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ok"><img src="../Images/0a972ea791269959445339bc90ac52e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wR-MMJVBD7YRmMeuETBtw.png"/></div></div></figure><p id="3d6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们返回这五个属性，以便将它们添加到myLink组件实例中，从而在myLink组件中可见。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi sg"><img src="../Images/e104ae2850d20925f18b966b615acdc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRe20auXmxt5dwMjVaeF6A.png"/></div></div></figure><p id="92f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在myLink模板中，我们首先检查我们是在主页还是在城市页面。我们可以通过由setUp函数返回的route属性来访问当前的路由信息。如果我们在一个城市页面，我们显示城市名称。否则，我们会显示一个主页图标。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi sh"><img src="../Images/ea7b499c7f059042d73d16bbacde8be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhrDY8S6bNfNguDa7Go6ag.png"/></div></div></figure><p id="fbc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在SPAN标记中，我们添加了v on指令来监视click事件，并为其分配navigate方法。navigate方法也由setUP函数返回。现在，span标签可以导航了。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi si"><img src="../Images/00b0eeed30fb895769a3244cd59644d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LozlbYCMoz1_tL8h54Qlpw.png"/></div></div></figure><p id="9d75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们突出显示活动按钮。</p><p id="4134" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们回到SPAN标签。我们添加class属性并使用object语法设置它的值。</p><p id="bb1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任何激活的按钮都将接收两个激活的类。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nq"><img src="../Images/a35dfcb2702f325518a4c720c65bdfdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjqDhb-8o1JDJwZkEQOlYw.png"/></div></div></figure><p id="0999" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">HREF值存储当前路径。我们可以用它来创建我们自己的标签。在这里，我将HREF属性赋给了SPAN标记的title属性。</p><p id="3e94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们运行程序，检查HREF值。</p><p id="9066" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到HREF值是当前路径。你可以用它来创建你自己的标签。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qj"><img src="../Images/b220012c79a399f54481fa7bdcb5ecce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BScckZXTjPoayxflApptFQ.png"/></div></div></figure><h1 id="2bb7" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">导航失败</h1><p id="9190" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在这一节中，我们将向您展示如何处理导航故障。</p><p id="b893" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像<em class="lw">推送</em>和<em class="lw">替换</em>这样的导航方法是异步的。让我们检查它们的解析值。</p><p id="5b81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在导航成功完成后，我们可以看到push和replace返回undefined。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qj"><img src="../Images/b220012c79a399f54481fa7bdcb5ecce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BScckZXTjPoayxflApptFQ.png"/></div></div></figure><p id="4c40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果导航失败，我们将得到一个错误消息。以下是一个示例:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi sj"><img src="../Images/70cc29308e9a98001b684b497ea99081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kz-UOEiqox0LKaU2SJKRZg.png"/></div></div></figure><p id="6e66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">VueRouter为我们提供了一种检测故障类型的方法。有三种类型的失败:中止、取消和重复。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi pl"><img src="../Images/b3c24dcee6ff336fc04a0b298e7c23a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOs1_uDkknHpq7HyiK4tGw.png"/></div></div></figure><p id="2b5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用isNavigationFailure方法，我们可以检查故障类型。但是语法相当独特。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi sk"><img src="../Images/47faf1fa037c09e8b73ec98d93a060ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-I6bFBIygOL7vezYCgEIQ.png"/></div></div></figure><p id="ec83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将以<em class="lw">推</em>法为例。</p><p id="3c84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将返回值传递给isNavigationFailure方法。正如它的名字所暗示的那样，这个方法只告诉我们导航是否失败。它不返回失败类型。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi sl"><img src="../Images/5c6107ae354b769928809838c639f9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cHIVj9JpkKinX5pRp6wyA.png"/></div></div></figure><p id="6deb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果导航成功，则返回false。否则，它返回true。</p><p id="725a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了检查失败类型，我们向它传递第二个参数。第二个参数值来自navigationFailureType属性。我们需要在附录中附上建议的故障类型。</p><p id="e6fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果失败与我们建议的失败类型匹配，则返回true。如果不是，则返回false。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi qk"><img src="../Images/495661e266742f44e353048b335dfd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcXY_UC0QE6hWYOl4GpzcQ.png"/></div></div></figure></div></div>    
</body>
</html>