<html>
<head>
<title>Scheduled Cron Jobs with Render</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用渲染调度Cron作业</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scheduled-cron-jobs-with-render-92ae3d6cfc8f?source=collection_archive---------13-----------------------#2022-03-30">https://levelup.gitconnected.com/scheduled-cron-jobs-with-render-92ae3d6cfc8f?source=collection_archive---------13-----------------------#2022-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bb46e4187fa6dd61ed3709d913093112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9u9KyN5whdKwhY_zGN12w.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@abdullishere?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿卜杜勒·阿</a>在<a class="ae jg" href="https://unsplash.com/@abdullishere?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="9020" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">咖啡店里的编码</h2><div class=""/><div class=""><h2 id="0063" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">云托管和计划作业都在一个地方</h2></div><p id="85da" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">程序员经常需要在固定的时间间隔或特定的时间自动运行一些循环过程。这个问题的一个常见解决方案是使用cron作业。当您拥有对自己的服务器的完全访问权时，配置cron作业就非常简单了。然而，当您使用应用程序托管服务时，配置cron作业有多难呢？谢天谢地，有些服务为你提供了这样做的方法。</p><p id="7dce" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我们将通过一个小型项目展示如何在<a class="ae jg" href="https://render.com/" rel="noopener ugc nofollow" target="_blank"> Render </a>上轻松设置和部署cron作业。</p><h1 id="79bc" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">核心概念</h1><h2 id="0987" class="mv me jj bd mf mw mx dn mj my mz dp mn lq na nb mp lu nc nd mr ly ne nf mt jp bi translated">什么是Cron工作？</h2><p id="3946" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">cron作业是一个Unix命令，<code class="fe nl nm nn no b">cron</code>按照由<a class="ae jg" href="https://en.wikipedia.org/wiki/Cron#CRON_expression" rel="noopener ugc nofollow" target="_blank"> Cron表达式</a>确定的时间表作为后台进程运行。通常，cron通过crontab配置文件来确定要运行的作业，crontab配置文件由成对的cron表达式和相应的命令组成。</p><h2 id="6492" class="mv me jj bd mf mw mx dn mj my mz dp mn lq na nb mp lu nc nd mr ly ne nf mt jp bi translated">什么是渲染？</h2><p id="8796" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">Render是一个云应用程序托管服务，提供各种web服务托管解决方案，比如静态站点、web服务器、数据库，是的，甚至是cron作业！Render为您处理托管和部署的麻烦，以便您可以将所有时间用于构建项目。</p><h2 id="c494" class="mv me jj bd mf mw mx dn mj my mz dp mn lq na nb mp lu nc nd mr ly ne nf mt jp bi translated">什么是渲染Cron作业？</h2><p id="86ba" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">Render提供了cron作业托管服务，简化了在云中部署和维护cron作业的过程。要设置Render cron作业服务，只需链接一个GitHub repo，选择一个运行时，并提供要运行的命令和cron表达式来确定时间表。</p><h1 id="5d51" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">我们的小型项目概述</h1><p id="f1d8" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">我们的项目将是一个简单的服务，让我们创建和存储笔记。该服务还每小时运行一次cron作业，通过电子邮件向我们发送上一小时创建的所有笔记。该应用程序由三部分组成:</p><ol class=""><li id="56e3" class="np nq jj lj b lk ll ln lo lq nr lu ns ly nt mc nu nv nw nx bi translated">处理创建便笺请求的Express web服务器</li><li id="33f8" class="np nq jj lj b lk ny ln nz lq oa lu ob ly oc mc nu nv nw nx bi translated">存储注释的PostgreSQL数据库</li><li id="33ac" class="np nq jj lj b lk ny ln nz lq oa lu ob ly oc mc nu nv nw nx bi translated">发送notes digest电子邮件的cron作业</li></ol><p id="d697" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将为每个组件使用渲染服务。我们还将使用<a class="ae jg" href="https://www.mailjet.com/" rel="noopener ugc nofollow" target="_blank"> Mailjet </a>作为发送邮件的服务。对于我们的Node.js应用程序，我们将添加以下依赖包:</p><ul class=""><li id="eeee" class="np nq jj lj b lk ll ln lo lq nr lu ns ly nt mc od nv nw nx bi translated"><code class="fe nl nm nn no b">pg</code>与数据库交互</li><li id="28c2" class="np nq jj lj b lk ny ln nz lq oa lu ob ly oc mc od nv nw nx bi translated">作为生活质量的升级，允许我们使用异步函数作为我们的快速处理程序</li><li id="5bef" class="np nq jj lj b lk ny ln nz lq oa lu ob ly oc mc od nv nw nx bi translated"><code class="fe nl nm nn no b">node-mailjet</code>，它是与Mailjet API交互的官方客户端库</li></ul><p id="a292" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们假设您已经在开发机器上安装了node . js。在我们的演示代码中，我们将使用<a class="ae jg" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank"> Yarn </a>作为我们的包管理器。</p><h1 id="bf5a" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">设置项目回购</h1><p id="bc65" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">让我们首先在Render上设置我们的项目repo和web服务。我们可以将Render的<a class="ae jg" href="https://github.com/render-examples/express-hello-world" rel="noopener ugc nofollow" target="_blank"> Express Hello World repo </a>作为初始Express server样板代码。</p><p id="8ae9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在Render中，我们<a class="ae jg" href="https://dashboard.render.com/web/new" rel="noopener ugc nofollow" target="_blank">创建了一个使用分叉repo的web服务页面</a>。</p><figure class="of og oh oi gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f62b2bef367a950b807c3f007b0cd82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*Ceryh5q7EVosFQ6jYm4HEQ.png"/></div></figure><p id="f059" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们为我们的web服务输入一个名称，然后继续使用所有的默认值。Render完成部署后，我们会看到一个服务URL。我们可以在浏览器中访问该URL，以验证一切设置是否正确。</p><p id="c82c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们可以将分叉回购克隆到我们的开发机器上，然后添加我们的依赖项:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="3cf6" class="mv me jj no b gy on oo l op oq">~/project$ yarn add pg express-async-handler node-mailjet</span></pre><p id="48b3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">随着我们最初的项目回购设置，让我们继续设置我们的数据库。</p><h1 id="7b0a" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">设置数据库</h1><p id="3e29" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">我们的数据库非常简单，只包含一个名为notes的表。该表将有一列存储注释文本，另一列存储注释创建时的时间戳。</p><p id="4224" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将<a class="ae jg" href="https://dashboard.render.com/new/database" rel="noopener ugc nofollow" target="_blank">在Render上创建一个PostgreSQL数据库服务</a>。</p><figure class="of og oh oi gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/5b5bfdf4c5e274a0cbb5272cf183a24e.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*tXGFU0T-6MvM35m2n_4zfA.png"/></div></figure><p id="9cf7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们为数据库服务提供一个名称，然后对所有其他选项使用默认值。创建数据库后，我们可以从本地机器连接到它，并创建<code class="fe nl nm nn no b">notes</code>表。从数据库仪表板中复制<strong class="lj jt">外部</strong>连接字符串，然后在本地项目目录中启动一个<code class="fe nl nm nn no b">node</code> <a class="ae jg" href="https://nodejs.dev/learn/how-to-use-the-nodejs-repl" rel="noopener ugc nofollow" target="_blank"> REPL </a>。我们将使用一个<a class="ae jg" href="https://node-postgres.com/features/pooling" rel="noopener ugc nofollow" target="_blank">连接池</a>来查询我们的数据库，所以我们需要导入<code class="fe nl nm nn no b">Pool</code>类，并用我们的外部连接字符串创建一个<code class="fe nl nm nn no b">Pool</code>对象:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="9b5e" class="mv me jj no b gy on oo l op oq">const { Pool } = require('pg');<br/>const pool = new Pool(<br/>  { connectionString: '&lt;External Connection String&gt;?ssl=true'}<br/>);</span></pre><p id="d8cb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意，因为我们在<code class="fe nl nm nn no b">node</code> REPL中通过SSL连接，所以我们需要将<code class="fe nl nm nn no b">?ssl=true</code>附加到连接字符串的末尾。创建了池对象后，我们可以执行查询来创建表:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="e9de" class="mv me jj no b gy on oo l op oq">pool.query(<br/>  'CREATE TABLE notes (text text, created timestamp);',<br/>  console.log<br/>);</span></pre><p id="f7ca" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">瞧啊。我们的数据库是用我们的<code class="fe nl nm nn no b">notes</code>表建立的！</p><h1 id="b7e1" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">在渲染中设置环境组</h1><p id="7c5a" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">在我们向web服务添加功能以开始填充表之前，让我们确保我们的web服务能够访问我们的数据库。事实上，因为我们的web服务和cron作业都需要连接到数据库，所以我们可以利用Render的环境组来创建一个共享的环境变量组，供两个服务使用。</p><p id="9451" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为此，我们需要来自数据库仪表板的<strong class="lj jt">内部</strong>连接字符串，因为web服务和cron作业都将通过Render的内部网络与数据库通信。点击主渲染导航中的<strong class="lj jt">环境组</strong>。</p><figure class="of og oh oi gt iv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f750775ba4642a5c28ddc6eb606b1c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*cib_cDFc6Qy7Xo-ht4Htlg.png"/></div></figure><p id="7b61" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，点击<strong class="lj jt">新环境组</strong>。</p><figure class="of og oh oi gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/7e1747fa0b33b369bab1793a55778fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*i4uSCTRmWb66ADAearWzIQ.png"/></div></figure><p id="dc07" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为您的环境组选择一个名称。然后添加一个新变量，键为<code class="fe nl nm nn no b">CONNECTION_STRING</code>，粘贴内部连接字符串作为值(这次不需要<code class="fe nl nm nn no b">ssl=true</code>)。</p><p id="2160" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦您创建了这个组，您就可以返回到web服务的<strong class="lj jt">环境</strong>设置。在<strong class="lj jt">链接的环境组</strong>部分，您可以选择刚刚创建的环境组，并点击<strong class="lj jt">链接</strong>。现在，我们的Node.js代码可以通过全局<code class="fe nl nm nn no b">process.env</code>对象访问我们在这个组中定义的任何变量。当我们开始构建我们的Express应用程序时，我们将看到一个这样的例子。让我们现在就做吧！</p><h1 id="41e1" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">创建快速应用程序</h1><p id="a884" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">我们的Express应用程序只有一个端点<code class="fe nl nm nn no b">/notes</code>，在这里我们将处理<code class="fe nl nm nn no b">POST</code>和<code class="fe nl nm nn no b">GET</code>请求。</p><p id="c921" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当我们收到一个<code class="fe nl nm nn no b">POST</code>请求时，我们在数据库中创建一个新的注释行。我们希望请求的<code class="fe nl nm nn no b">Content-Type</code>是<code class="fe nl nm nn no b">application/json</code>，请求体的格式是<code class="fe nl nm nn no b">{"note": "&lt;note text&gt;"}</code>。我们还将记录请求的时间，并将该时间戳存储为注释的<code class="fe nl nm nn no b">created</code>值。</p><p id="9256" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当我们收到一个<code class="fe nl nm nn no b">GET</code>请求时，我们将在数据库中查询所有的注释，并将它们作为JSON响应返回。</p><p id="e07c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们从去除样板文件中所有不必要的代码开始。我们只需要保留下面几行，我们稍微改变一下<code class="fe nl nm nn no b">app.listen</code>回调:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="34d2" class="mv me jj no b gy on oo l op oq">const express = require('express');<br/>const app = express();<br/>const port = process.env.PORT || 3001;</span><span id="3baf" class="mv me jj no b gy ov oo l op oq">app.listen(port, () =&gt; console.log(`Notes server listening on port ${port}!`));</span></pre><p id="9dbe" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，让我们添加我们需要的所有导入。同样，我们将使用连接<code class="fe nl nm nn no b">Pool</code>来连接数据库:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="0f26" class="mv me jj no b gy on oo l op oq">const { Pool } = require('pg');</span></pre><p id="b4b0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此外，我们将使用<code class="fe nl nm nn no b">express-async-handler</code>包:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="0053" class="mv me jj no b gy on oo l op oq">const asyncHandler = require('express-async-handler');</span></pre><p id="ec9e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们用<code class="fe nl nm nn no b">CONNECTION_STRING</code>环境变量实例化我们的<code class="fe nl nm nn no b">Pool</code>:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="3fa3" class="mv me jj no b gy on oo l op oq">const connectionString = process.env.CONNECTION_STRING;<br/>const pool = new Pool({connectionString});</span></pre><p id="1b96" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因为我们期待一个JSON <code class="fe nl nm nn no b">POST</code>请求，所以让我们也使用来自Express 的<a class="ae jg" href="http://expressjs.com/en/api.html#express.json" rel="noopener ugc nofollow" target="_blank"> JSON中间件，它将把请求体解析成一个我们可以在<code class="fe nl nm nn no b">req.body</code>访问的JavaScript对象:</a></p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="a207" class="mv me jj no b gy on oo l op oq">app.use(express.json());</span></pre><h2 id="f02d" class="mv me jj bd mf mw mx dn mj my mz dp mn lq na nb mp lu nc nd mr ly ne nf mt jp bi translated">处理<code class="fe nl nm nn no b">GET /notes</code>请求</h2><p id="5c60" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">现在我们可以进入应用程序的核心部分:请求处理程序。我们将从我们的<code class="fe nl nm nn no b">GET</code>处理程序开始，因为它稍微简单一些。我们先展示代码，然后解释我们做了什么。</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="1598" class="mv me jj no b gy on oo l op oq">app.get('/notes', asyncHandler(async (req, res) =&gt; {<br/>  const result = await pool.query('SELECT * FROM notes;');<br/>  res.json({ notes: result.rows });<br/>}));</span></pre><p id="cd74" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，我们使用<code class="fe nl nm nn no b">app.get</code>在<code class="fe nl nm nn no b">/notes</code>端点用<code class="fe nl nm nn no b">asyncHandler</code>注册一个异步函数。在回调的主体中，我们希望使用<code class="fe nl nm nn no b">pool.query</code>选择数据库中的所有笔记。我们返回一个JSON响应，其中包含从数据库中收到的所有行。</p><p id="e905" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这就是我们所需要的<code class="fe nl nm nn no b">GET</code>处理器！</p><p id="6406" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此时，我们可以提交并推动这些变更。Render自动构建和重新部署我们更新的应用程序。我们可以验证我们的<code class="fe nl nm nn no b">GET</code>处理程序工作正常，但是现在，我们看到的只是一个悲伤的空notes对象。</p><h2 id="297e" class="mv me jj bd mf mw mx dn mj my mz dp mn lq na nb mp lu nc nd mr ly ne nf mt jp bi translated">处理<code class="fe nl nm nn no b">POST /notes</code>请求</h2><p id="60e2" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">让我们继续我们的<code class="fe nl nm nn no b">POST</code>处理程序，这样我们可以开始用一些注释填充我们的数据库！我们的代码如下所示:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="a9a0" class="mv me jj no b gy on oo l op oq">app.post('/notes', asyncHandler(async (req, res) =&gt; {<br/>  const query = {<br/>    text: 'INSERT INTO notes VALUES ($1, $2);',<br/>    values: [req.body.note, new Date()],<br/>  };<br/>  await pool.query(query);<br/>  res.sendStatus(200);<br/>}));</span></pre><p id="e69d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，我们用注释文本和创建时间戳在数据库中插入一个新行。我们从<code class="fe nl nm nn no b">req.body.note</code>获取注释文本，并使用<code class="fe nl nm nn no b">new Date()</code>获取当前时间。通过使用<a class="ae jg" href="https://node-postgres.com/features/queries#parameterized-query" rel="noopener ugc nofollow" target="_blank">参数化查询</a>，将<code class="fe nl nm nn no b">Date</code>对象转换为PostgreSQL数据类型。我们发送插入查询，然后返回一个<code class="fe nl nm nn no b">200</code>响应。</p><h2 id="11c0" class="mv me jj bd mf mw mx dn mj my mz dp mn lq na nb mp lu nc nd mr ly ne nf mt jp bi translated">部署和测试</h2><p id="5b29" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">在推送我们的代码并进行Render redeploy之后，我们可以通过发送一些测试请求来测试我们的服务器。在命令行，我们使用<code class="fe nl nm nn no b">curl</code>:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="8862" class="mv me jj no b gy on oo l op oq">curl -X POST &lt;INSERT WEB SERVICE URL&gt;/notes \<br/>     -H 'Content-Type: application/json' \<br/>     -d '{"note": "&lt;INSERT NOTE TEXT&gt;"}'</span></pre><p id="620c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，您可以在浏览器中访问<code class="fe nl nm nn no b">/notes</code>端点，查看所有新创建的笔记！</p><h1 id="9ded" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">创建Cron作业</h1><p id="9df5" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">将我们的项目联系在一起的最后一个组件是cron作业。这个cron作业将在每小时开始时运行，通过电子邮件向我们发送上一小时创建的所有笔记。</p><h2 id="f4cd" class="mv me jj bd mf mw mx dn mj my mz dp mn lq na nb mp lu nc nd mr ly ne nf mt jp bi translated">设置Mailjet</h2><p id="4ea8" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">我们将使用Mailjet作为我们的电子邮件递送服务。你可以在这里注册一个免费账户。</p><p id="4919" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您需要从API密钥管理页面获得Mailjet API密钥和秘密密钥。让我们将这些键添加到我们之前创建的环境组中。添加以下环境变量:</p><ul class=""><li id="20b6" class="np nq jj lj b lk ll ln lo lq nr lu ns ly nt mc od nv nw nx bi translated"><code class="fe nl nm nn no b">MAILJET_APIKEY</code></li><li id="3a3e" class="np nq jj lj b lk ny ln nz lq oa lu ob ly oc mc od nv nw nx bi translated"><code class="fe nl nm nn no b">MAILJET_SECRET</code></li><li id="30c3" class="np nq jj lj b lk ny ln nz lq oa lu ob ly oc mc od nv nw nx bi translated"><code class="fe nl nm nn no b">USER_NAME</code>:邮件收件人的名字(你的名字)</li><li id="bc6b" class="np nq jj lj b lk ny ln nz lq oa lu ob ly oc mc od nv nw nx bi translated"><code class="fe nl nm nn no b">USER_EMAIL</code>:收件人的邮件地址(您的邮件地址)</li></ul><h2 id="ab05" class="mv me jj bd mf mw mx dn mj my mz dp mn lq na nb mp lu nc nd mr ly ne nf mt jp bi translated">实施Cron作业脚本</h2><p id="3100" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">现在让我们编写我们将作为cron作业运行的脚本，我们可以称之为<code class="fe nl nm nn no b">mail_latest_notes.js</code>。同样，我们将使用一个<code class="fe nl nm nn no b">Pool</code>来查询我们的数据库，我们还想用我们的环境变量来初始化我们的Mailjet客户机:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="3b1a" class="mv me jj no b gy on oo l op oq">const { Pool } = require('pg');<br/>const mailjet = require ('node-mailjet')<br/>  .connect(process.env.MAILJET_APIKEY, process.env.MAILJET_SECRET);<br/>const connectionString = process.env.CONNECTION_STRING;<br/>const pool = new Pool({connectionString});</span></pre><p id="0954" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，让我们在数据库中查询最近一个小时创建的所有笔记。由于这将是一个异步操作，我们可以将脚本的其余部分包装在一个<a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">async life</a>中，这将允许我们使用<code class="fe nl nm nn no b">await</code>关键字使其更容易使用:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="c738" class="mv me jj no b gy on oo l op oq">(async () =&gt; {<br/>  // all remaining code will go here<br/>})();</span></pre><p id="155d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们使用另一个带有<code class="fe nl nm nn no b">new Date()</code>的参数化查询来捕获当前时间，并使用它来过滤笔记。然而，这一次，我们希望获得比当前时间早一个小时的时间，这可以使用<code class="fe nl nm nn no b">setHours</code>和<code class="fe nl nm nn no b">getHours</code> Date方法来实现，这样我们就可以过滤该时间戳之后的所有笔记:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="5544" class="mv me jj no b gy on oo l op oq">const timestamp = new Date();<br/>timestamp.setHours(timestamp.getHours() - 1);<br/>const query = {<br/>  text: 'SELECT * FROM notes WHERE created &gt;= $1;',<br/>  values: [timestamp],<br/>};<br/>const result = await pool.query(query);</span></pre><p id="864e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们检查返回了多少行，如果没有要发送的注释，我们就不会发送电子邮件。</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="4c92" class="mv me jj no b gy on oo l op oq">if (result.rows.length === 0) {<br/>  console.log('No latest notes');<br/>  process.exit();<br/>}</span></pre><p id="b3b8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果有行，那么我们用检索到的注释创建电子邮件。我们用<code class="fe nl nm nn no b">map</code>从每个注释行中提取文本，并使用HTML进行一些简单的格式化，用<code class="fe nl nm nn no b">&lt;br&gt;</code>标签连接所有注释文本:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="b6a9" class="mv me jj no b gy on oo l op oq">const emailMessage = result.rows.map(note =&gt; note.text).join('&lt;br&gt;');</span></pre><p id="3e01" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，我们使用Mailjet客户端向<a class="ae jg" href="https://dev.mailjet.com/email/guides/send-api-v31/#send-a-basic-email" rel="noopener ugc nofollow" target="_blank">发送一封电子邮件</a>，其中包含我们刚刚创建的消息和我们之前设置的环境变量。我们还可以记录从Mailjet返回的响应，以确保我们的电子邮件已发送:</p><pre class="of og oh oi gt oj no ok ol aw om bi"><span id="f40e" class="mv me jj no b gy on oo l op oq">const mailjetResponse = mailjet<br/>  .post('send', {'version': 'v3.1'})<br/>  .request({<br/>    'Messages':[{<br/>      'From': {<br/>        'Email': process.env.USER_EMAIL,<br/>        'Name': process.env.USER_NAME<br/>      },<br/>      'To': [{<br/>        'Email': process.env.USER_EMAIL,<br/>        'Name': process.env.USER_NAME<br/>      }],<br/>      'Subject': 'Latest Notes',<br/>      'HTMLPart': `&lt;p&gt;${emailMessage}&lt;/p&gt;`<br/>    }]<br/>  });</span><span id="8bc8" class="mv me jj no b gy ov oo l op oq">console.log(mailjetResponse);</span></pre><p id="259d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这就是我们的剧本所需要的！</p><h1 id="5afa" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">设置渲染Cron作业服务</h1><p id="7601" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">最后，让我们在Render上创建cron作业服务。</p><figure class="of og oh oi gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/5a3da7dc018a408821ed12a2db81c6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*qXzkDWMy3cBUROAlOFAJaQ.png"/></div></figure><p id="b61e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们给我们的cron作业服务命名，并将环境设置为<code class="fe nl nm nn no b">Node</code>。然后，我们将命令字段设置为<code class="fe nl nm nn no b">node mail_latest_notes.js</code>。为了每小时运行一次脚本，我们将schedule字段设置为cron表达式<code class="fe nl nm nn no b">0 * * * *</code>。Render在输入下面有一个漂亮的标签，用简单的英语显示了cron表达式的意思。我们创建cron作业。</p><p id="3874" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我们转到cron作业服务的<strong class="lj jt">环境</strong>选项卡，并链接我们之前创建的环境组。剩下要做的就是等待Render完成构建我们的cron作业服务。然后，我们可以测试它！在构建完成之前，您可以创建更多注释，以确保脚本发送电子邮件。最后，您可以单击cron仪表板上的<strong class="lj jt"> Trigger Run </strong>按钮来手动运行脚本，并检查您的收件箱以确保您收到了那封电子邮件。</p><p id="4f15" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">至此，我们完成了notes项目！</p><h1 id="e49e" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">结论</h1><p id="1e1b" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">像<code class="fe nl nm nn no b">cron</code>这样的任务调度器是强大的工具，它提供了一个简单的接口来按照严格的时间表运行自动化流程。一些应用程序托管服务——如Render——使您可以轻松地在web和数据库服务的同时设置cron作业服务。在本文中，我们通过构建一个小型项目来实现这一点，该项目保存笔记，然后由cron作业每小时发送一次电子邮件摘要。有了Render，协调各种组件之间的通信和设置cron作业变得简单明了。</p><p id="76c7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">编码快乐！</p><p id="d3af" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">【本文原载<a class="ae jg" href="https://dzone.com/articles/scheduled-cron-jobs-with-render" rel="noopener ugc nofollow" target="_blank">此处</a>。]</p></div></div>    
</body>
</html>