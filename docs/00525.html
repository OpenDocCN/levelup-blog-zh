<html>
<head>
<title>Building a Simple JavaScript App with Solid — The Best JavaScript UI Library You’ve Never Heard Of</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Solid构建一个简单的JavaScript应用——你从未听说过的最好的JavaScript UI库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-simple-javascript-app-with-solid-ff17c8836409?source=collection_archive---------2-----------------------#2019-04-09">https://levelup.gitconnected.com/building-a-simple-javascript-app-with-solid-ff17c8836409?source=collection_archive---------2-----------------------#2019-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10adde80b9778afc4e03f30f3ced4f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRJmXJ3SBv2auxZT7GcpSg.png"/></div></div></figure><p id="8291" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里没有惊喜。向某人介绍一个新的UI库的最简单的方法是组装一个简单的应用程序。TodoMVC 多年来一直致力于前端JavaScript库的比较。其中一个好处是它有一个清晰的功能集，它把CSS从等式中去掉了。今天我们不会看到Solid令人难以置信的表现。所以让我们只关注JavaScript并开始吧。</p><p id="ceaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过创建用于状态管理的商店来开始构建我们的Todo应用程序。接下来，我们将使用JSX为UI构建可靠的组件，并将其连接到商店以创建一个工作的Todo应用程序。</p><h1 id="045e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">配置</h1><p id="84cb" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在深入研究代码之前，还有一些设置。Solid还没有CLI或类似的功能，所以它确实需要一些配置。对于TodoMVC来说，这意味着一个简单的WebPack配置，包括运行<a class="ae kw" href="https://github.com/ryansolid/babel-preset-solid" rel="noopener ugc nofollow" target="_blank"> babel-preset-solid </a>的<a class="ae kw" href="https://github.com/babel/babel-loader" rel="noopener ugc nofollow" target="_blank"> babel-loader </a>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b936" class="mj ky iq mf b gy mk ml l mm mn">rules: [{<br/>  test: /\.jsx?$/,<br/>  use: {<br/>    loader: 'babel-loader',<br/>    options: {<br/>      presets: ['solid']<br/>    }<br/>  }<br/>}]</span></pre><p id="6169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使用了<a class="ae kw" href="https://github.com/ryansolid/babel-plugin-jsx-dom-expressions" rel="noopener ugc nofollow" target="_blank"> JSX DOM表达式</a>插件，它是专门设计来将JSX标签转换成真正的DOM语句，并将JSX表达式转换成属性赋值和细粒度计算的。因为Solid不使用虚拟DOM，一个典型的HyperScript JSX编译器是不够的。</p><p id="67b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的。可以开始了…</p><h1 id="3e1c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">体系结构</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/f96949d7235396a8933e1ca69f51481a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2YOeZaXqDoIwdfCllQNd4w.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">照片由来自<a class="ae kw" href="https://www.pexels.com/photo/moss-87153/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kw" href="https://www.pexels.com/@mcore?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Martinus </a>拍摄</figcaption></figure><p id="761b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个库和框架都以不同的方式处理这个问题，这是这里要做的第一个决定。因为Solid处理数据更新与您如何分解组件无关，所以我们可以灵活地用几种不同的方式来实现这个应用程序。然而，保持MVC精神的最惯用的方法是将数据管理抽象成一个存储(模型),并将视图分割成几个小组件。这远不是解决这个问题的唯一方法，因为您可以将整个应用程序放在一个或十几个组件中，而不会真正看到任何性能差异。</p><p id="cf71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是Solid的主要优势之一。这是一个为重构而设计的库。这并不是说没有原则性的惯用方法。只是它并不像你被教导的那样完全是(同质的)组件库。它更像是整个应用程序是由相同的物质组成的，根据你看得多近或多远，它可以看起来像一个或多个有机体。有点重，我知道。让我们看看那是什么样子。</p><h1 id="87a0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">商店</h1><p id="3655" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在构建组件之前，我们首先要构建的是商店。通常从数据开始更简单。我们将把它写成类似于React中的自定义钩子。简单地包装一个状态对象并公开它和预定义的更新方法。第一部分是TodoMVC的一个要求是将数据存储在<code class="fe mt mu mv mf b">localStorage</code>中。让我们创建一个可重用的方法。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7591" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码片段所做的是从<code class="fe mt mu mv mf b">localStorage</code>创建一个新的状态对象，或者从调用者传入的默认值创建一个新的状态对象。下一个块创建了一个新的副作用，每当状态更新时，它就更新<code class="fe mt mu mv mf b">localStorage</code>。虽然Solid甚至要求在视图中显式声明效果，但依赖项跟踪是默认完成的(尽管有第二个可选参数来显式设置它们)。</p><p id="5d5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的是，状态本身不能被跟踪，只能访问它的属性，但是<code class="fe mt mu mv mf b">JSON.stringify</code>在这里做了大量的工作，迭代可枚举的属性并设置依赖关系。最后，该函数只是赤裸裸地返回来自<code class="fe mt mu mv mf b">createState</code>的输出，供您按预期使用。</p><p id="d827" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以用<code class="fe mt mu mv mf b">createLocalState</code>来组成我们的<code class="fe mt mu mv mf b">createTodosStore</code>。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c254" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，这里发生了相当多的事情。这主要是展示了许多<code class="fe mt mu mv mf b">setState</code>的模式。但一会儿会有更多的讨论。首先，我们初始化我们的<code class="fe mt mu mv mf b">localState</code>对象。然后，我们设置一个效果，计算todos的已完成和剩余计数，并将其反馈给状态对象。</p><p id="e1f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Solid的<code class="fe mt mu mv mf b">setState</code>借鉴了ImmutableJS和FalcorJS的一些东西，它既允许深度设置，也允许对多个更新进行排队。原因是每个<code class="fe mt mu mv mf b">setState</code> evocation会立即同步地批量处理由于它而发生的所有更新。是的，这意味着所有的更新都发生在下一行执行之前。不要担心你的状态是否是最新的。确实是。</p><p id="7c37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Solid也有一个类似于MobX的动作(冻结)的机制来批量处理多个<code class="fe mt mu mv mf b">setState</code>调用，但是在一个单独的调用中完成通常要干净得多。您总是可以像处理不可变数据那样更新状态，但是因为Solid对于深度嵌套的更新是细粒度的，所以只设置发生了什么变化会有性能上的好处。仔细想想，很有道理。很可能你已经知道发生了什么变化，但是你必须沿着树一直克隆，直到发生变化，然后让渲染器在渲染时沿着树一直引用检查。Solid只是跳过了这种低效率。让我们来看几个例子。</p><p id="b7e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mt mu mv mf b">addTodo</code>是一个通过传递数组作为参数进行多次更新的例子。首先，我们深度设置todos，然后是计数器。这是完全可能的，因为更新是顶级的，所以您可以使用单个对象以React的方式来完成，但这让我输入单词state的次数减少了3倍，并演示了这种方法。</p><p id="3758" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mt mu mv mf b">editTodo</code>是一个做更深层次路径设置的例子，其中只有找到的索引处的todo被更新。传入的todo是一个对象，因此更改将与已在该位置的项合并，而不是被替换。这与classic React <code class="fe mt mu mv mf b">setState</code>处理对象的方式一致。</p><p id="3b77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mt mu mv mf b">toggleAll</code>在路径上使用条件方法。数组中任何符合条件的项都会被更新。在这种情况下，所有不等于复选框当前状态的项目都将更改为该状态。</p><h1 id="7fef" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">应用</h1><p id="0c61" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我想你现在已经很了解国务院了，所以让我们看看我们能在另一方面做些什么。从上到下开始，让我们创建我们的应用程序。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="06c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序从底部开始，我们为应用程序创建一个计算根。它设定了细粒度执行和内存处置的界限。所有的固体应用都以此为应用起点。在中，您可以将JSX的返回值用作普通的dom节点，如图所示，TodoApp被插入到主体中。</p><p id="abc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的TodoApp组件中，我们创建了一个store析构实例，构造出所需的状态和更新方法，并且我们设置了一个简单的事件处理程序来监听<code class="fe mt mu mv mf b">hashchange</code>以执行一些简单的路由。<code class="fe mt mu mv mf b">onCleanup</code>确保在释放根时将其处理掉。</p><p id="7b4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会问为什么这个没有被包装成一个效果？这就是固体和反应的区别。这个函数只执行一次。不需要显式的创建/挂载挂钩，因为组件执行是设置步骤。你只需要更新的东西的效果。没有依赖关系的效果没有意义。</p><p id="0af8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从那里返回的JSX看起来很正常，除了一件事:控制流元素<code class="fe mt mu mv mf b">Show</code>。当处理动态插入的某些部分的记忆和协调时，细粒度的库确实会带来一些复杂性。包装在预构建的组件中使其更易于使用。Solid还有更多的这些，包括<code class="fe mt mu mv mf b">For</code>、<code class="fe mt mu mv mf b">Switch</code>、<code class="fe mt mu mv mf b">Portal</code>和<code class="fe mt mu mv mf b">Suspense</code>。</p><p id="2604" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你还在吗？我知道有相当多的东西需要消化，因为表面上你认为你可能在处理类似React的东西，但它的工作方式奇怪地不同。事实是我们还没有完全完成。</p><h1 id="bd8b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">页眉和页脚</h1><p id="b53d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在下一个代码块中，我们将最终处理一些真正的DOM元素。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d4d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两个是经典所谓的哑组件。<code class="fe mt mu mv mf b">TodoHeader</code>组件非常简单。它正在等待一个<code class="fe mt mu mv mf b">Enter</code>键来添加新的<code class="fe mt mu mv mf b">Todo</code>。页脚看起来同样简单，直到你发现一个小东西，<code class="fe mt mu mv mf b">classList</code>。这是处理多类包含的一种常见情况，通过一个内置了布尔值的对象来管理它们。</p><h1 id="d90f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">待办事项列表</h1><p id="3b46" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我将Todo列表本身分成两个部分，一个用于列表，一个用于每个项目。列表本身维护一些不在存储中的附加状态，比如当前正在编辑的Todo的状态。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cb56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于如何处理列表，有两种方法，但是以上面显示的方式处理它有性能上的好处。像许多现代库一样，Solid.js使用隐式事件委托，所以在父库中声明一次函数并传递它实际上减少了每个Todo的开销。对于构建一个简单的应用程序来说，这可能是不必要的，但是我发现很难避免自然地进行这种性能优化。这是一些你不需要考虑太多的类组件，比如你在React中发现的经典组件，因为Todos会共享一个原型，但一旦你转向Hooks，它们就真实存在了。model属性类似于React中的键，但它接受对象，不用于协调。只是为了将数据附加到委托的事件和指令。</p><h1 id="fcae" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="e0e2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">仅此而已。TodoMVC本身并不是最有趣的例子，但在这一点上，它是如此标准化，我觉得你已经知道会发生什么了。这里还有一些其他的选择。用一个缩减器或者至少使用一个单一的调度函数来设置存储，可以清理一些传递的函数，但是我觉得这是查看Solid的最自然的方式。</p><p id="f8ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文涵盖的整个项目源代码可从以下网址获得:</p><div class="my mz gp gr na nb"><a href="https://github.com/ryansolid/solid-todomvc" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">ryansolid/solid-todomvc</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">TodoMVC的可靠实现。</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np jw nb"/></div></div></a></div><p id="91dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一如既往地检查固体:</p><div class="my mz gp gr na nb"><a href="https://github.com/ryansolid/solid" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">瑞安固体/固体</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">一个用于构建用户界面的声明式、高效且灵活的JavaScript库。-瑞安固体/固体</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np jw nb"/></div></div></a></div></div></div>    
</body>
</html>