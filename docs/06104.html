<html>
<head>
<title>Let’s build a single binary gRPC server-client with Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用Rust构建一个二进制gRPC服务器-客户端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-build-a-single-binary-grpc-server-client-with-rust-498c1cb900d3?source=collection_archive---------18-----------------------#2020-10-26">https://levelup.gitconnected.com/lets-build-a-single-binary-grpc-server-client-with-rust-498c1cb900d3?source=collection_archive---------18-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c48bed6647d390d1ee0ccb54d77f4a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*qXRmF5qKYrKlQX2b.png"/></div></figure><p id="eb55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于Rust和协议缓冲区+ gRPC的基础知识有很多资源，所以我不想浪费你的时间去做太多的介绍。我想让你尽快采取行动。</p><p id="a461" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你在这里，我会对你做一些假设。</p><ul class=""><li id="e9dc" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">你可以用另一种语言写代码，但是你对Rust感兴趣</li><li id="aaa9" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">您已经基本熟悉了简单任务的命令行(比如用<code class="fe lg lh li lj b">ls</code>列出文件)</li><li id="bc5f" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">您在自己编写的代码中使用了REST、GraphQL或gRPC等web服务API</li><li id="09f6" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">你已经<em class="lk">浏览过</em>至少一次<a class="ae ll" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank">官方协议缓冲区(v3)文档</a></li><li id="554a" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">您正在寻找一些可以复制/粘贴和修改的示例代码</li></ul><h1 id="7441" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">岗位目标</h1><p id="f209" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">我的目标是编写一个小型异步Rust CLI应用程序。它将从客户端获取用户输入，将其发送到远程gRPC服务器，并将输出返回给客户端。</p><p id="4e61" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完成的代码在我的<a class="ae ll" href="https://github.com/tjtelan/rust-examples" rel="noopener ugc nofollow" target="_blank"> rust-examples repo </a>中可用，名为<a class="ae ll" href="https://github.com/tjtelan/rust-examples/tree/main/cli-grpc-tonic-blocking" rel="noopener ugc nofollow" target="_blank"> cli-grpc-tonic-blocking </a>。但是我鼓励你们跟着做，因为我会在做改变的时候叙述它们。</p><h1 id="9ca3" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">我们在写什么？</h1><p id="54d2" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">在这个例子中，我将编写一个远程命令行服务器/客户机。</p><p id="124d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">客户端将接受一个命令行命令，并将其发送给服务器，服务器将执行该命令，并将标准输出的内容发送回来。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d382d08a38cc71b31206e5f717d4b0ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*OGtTecr2RwsFtOqX.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">我们将要使用的交互框图</figcaption></figure><p id="46a0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了简单起见，这个例子将在返回输出之前等待执行在服务器端完成。在以后的文章中，我将演示如何将输出流回客户端。</p><p id="14b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我将向您展示如何:</p><ol class=""><li id="c765" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mx ky kz la bi translated">解析命令行用户输入</li><li id="6fe8" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mx ky kz la bi translated">编写协议缓冲区消息类型和服务接口</li><li id="424c" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mx ky kz la bi translated">将协议缓冲区编译成Rust代码</li><li id="3a39" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mx ky kz la bi translated">实现gRPC客户端</li><li id="0ab0" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mx ky kz la bi translated">实施gRPC服务器(非流式)</li><li id="bfa1" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mx ky kz la bi translated">使用基本的异步/等待模式</li></ol><h2 id="1d4a" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">更大的目标</h2><p id="e687" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">这不仅仅是一个简单的Hello World。</p><p id="c6db" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我想提供一个有现实应用作为基础的例子。它有可能被用于一些有用的东西，但请记住，这个例子只是一个基本的脚本运行程序，并不安全。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/43cb7c456a00e93db418da67f4b32417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*1f2NzP9gYmOh4YcE.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">这种配置是可能的，但超出了范围</figcaption></figure><p id="aee2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">人们可以在多台主机上运行该服务器的多个实例，并使用客户端在每台主机上运行shell命令，类似于jenkins、puppet或ansible等持续集成工具。(热门话题:CI只是一个花哨的shell脚本)</p><p id="8044" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我不建议在任何重要的环境中按原样运行这段代码。仅用于演示和教育目的！</p><h1 id="62d0" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">编写命令行界面</h1><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/8c3f82db0bb811b9c5e25317162f5a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*jX3UJZVCkMqznaM8.png"/></div></figure><p id="d3e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">命令行界面是允许我们将gRPC服务器和客户机打包到同一个二进制文件中的基础。我们将首先使用CLI启动我们的新板条箱。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ee77" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将使用一个名为<a class="ae ll" href="https://crates.io/crates/structopt" rel="noopener ugc nofollow" target="_blank"> StructOpt </a>的板条箱。StructOpt利用了功能强大的命令行解析器<a class="ae ll" href="https://crates.io/crates/clap" rel="noopener ugc nofollow" target="_blank"> Clap </a> crate。但是Clap使用起来可能有点复杂，所以StructOpt额外提供了许多方便的功能Rust a<a class="ae ll" href="https://doc.rust-lang.org/reference/attributes/derive.html" rel="noopener ugc nofollow" target="_blank">#[derive]attribute</a>，这样我们就不用写那么多代码了。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Cargo.toml —刚刚开始</figcaption></figure><p id="a505" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了将我们的客户机和服务器捆绑在一起，我们需要使用CLI在作为客户机运行和作为服务器运行之间切换。</p><h1 id="36db" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">CLI的一些用户界面设计</h1><p id="8b4b" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">注意:当我们在开发的时候，你可以使用<code class="fe lg lh li lj b">cargo run --</code>来运行我们的cli二进制文件，并且在<code class="fe lg lh li lj b">--</code>之后的任何参数都作为参数传递给我们的二进制文件</p><h2 id="2aff" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">启动服务器</h2><p id="d457" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">当我们启动服务器时，我们想传入子命令<code class="fe lg lh li lj b">server</code></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="07bf" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">服务器的可选参数</h2><p id="c204" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">大多数时候，我们的服务器会监听一个默认的地址和端口，但我们想给用户选择不同的东西。</p><p id="9ecd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将在标志<code class="fe lg lh li lj b">--server-addr-listen</code>中提供服务器监听地址的选项</p><h2 id="3136" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">使用客户端</h2><p id="4b59" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">当用户从我们的客户端运行一个命令时，我们想要使用子命令<code class="fe lg lh li lj b">run</code>。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="04b4" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">客户端所需的位置参数</h2><p id="bb51" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated"><code class="fe lg lh li lj b">subcommand run</code>之后的任何内容都将是我们传递给服务器执行的命令。一个命令有一个可执行名称，也可以有参数。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="dc6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">或者举例说明如何在没有货物的情况下使用这个命令，如果它被命名为<code class="fe lg lh li lj b">remotecli</code>:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="9f89" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">客户端的可选参数</h2><p id="c447" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">就像我们的服务器将有一个默认的监听地址和端口一样，我们的客户机将假设连接到默认地址。我们只是想为用户提供连接到不同服务器的选项。</p><p id="6002" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将在标志<code class="fe lg lh li lj b">--server-addr</code>中提供服务器地址的选项</p><h1 id="7183" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">到目前为止的CLI代码</h1><p id="4077" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">我将把当前的<code class="fe lg lh li lj b">main.rs</code>分解成它们的结构、枚举和函数来描述StructOpt是如何被利用的。</p><p id="a522" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">如果你想在一个代码块中查看这个文件，跳到下一节</strong> <code class="fe lg lh li lj b"><a class="ae ll" href="#9cbb" rel="noopener ugc nofollow"><strong class="jw ir">All together</strong></a></code> <strong class="jw ir">。</strong></p><h1 id="6021" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">部分</h1><h2 id="5b65" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">应用程序参数</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">应用程序参数— main.rs</figcaption></figure><ul class=""><li id="8835" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">正如注释所说，这将是您用来解析来自用户输入的参数的主要结构。</li><li id="70ea" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">我们在这个结构上使用<code class="fe lg lh li lj b">derive(StructOpt)</code>来让编译器知道要生成命令行解析器。</li><li id="52e6" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">structopt(name)</code>属性反映在生成的CLI帮助中。Rust将使用这个名字代替板条箱的名字，也就是<code class="fe lg lh li lj b">cli-grpc-tonic-blocking</code>。这纯粹是装饰性的。</li><li id="7f1f" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">structopt(flatten)</code>属性用于<code class="fe lg lh li lj b">ApplicationArguments</code>结构字段。结果实际上是用<code class="fe lg lh li lj b">SubCommand</code>类型的内容替换了这个字段，我们接下来会讲到。</li></ul><p id="6623" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们不使用flatten，那么用户需要像这样使用CLI:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">没有子命令展平的CLI调用—非常冗长</figcaption></figure><p id="4458" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是通过展平，我们得到了一个没有文字的简化形式。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">子命令扁平化的CLI调用—无需键入</figcaption></figure><p id="d8eb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种模式的原因是允许将子命令分组到我们可以进行模式匹配的类型中，这对于开发人员来说很好。但同时，我们为用户保持最小的CLI层次结构。</p><h2 id="3193" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">子命令</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">子命令— main.rs</figcaption></figure><ul class=""><li id="a681" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">这次我们用的是枚举。但是同样，最重要的部分是<code class="fe lg lh li lj b">derive(StructOpt)</code>属性。</li><li id="16da" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">使用枚举的原因是为了提供一些开发便利。枚举中的每个字段都接受一个结构，当选择子命令时，会在该结构中进行额外的解析。但是这种模式使我们能够不在这个枚举中混淆，使代码不集中，难以阅读。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="eb66" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">第二个最重要的细节是注意带有3个斜线<code class="fe lg lh li lj b">///</code>的注释。</li><li id="4e73" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">这些是<a class="ae ll" href="https://doc.rust-lang.org/reference/comments.html#doc-comments" rel="noopener ugc nofollow" target="_blank">文档注释</a>，它们的放置是有意的。Rust将在生成的帮助命令中使用这些注释。这两个斜线注释只是给你(开发人员)的注释，用户看不到。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="8962" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">对于第一个子命令，我承认我将这个字段命名为<code class="fe lg lh li lj b">StartServer</code>,这样我就可以使用<code class="fe lg lh li lj b">structopt(name)</code>属性来展示了。</li></ul><p id="bb28" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果没有该属性，用户将会体验到默认情况下被转换成“kebab-case”形式的子命令<code class="fe lg lh li lj b">start-command</code>。使用StartServer字段上定义的<code class="fe lg lh li lj b">name</code>,我们告诉Rust我们希望用户使用<code class="fe lg lh li lj b">server</code>来代替。</p><p id="941c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(您可以用<code class="fe lg lh li lj b">structopt(rename_all)</code>属性配置这种行为。我不会报道的。<a class="ae ll" href="https://docs.rs/structopt/0.3.16/structopt/#specifying-argument-types" rel="noopener ugc nofollow" target="_blank">在文档中阅读更多关于rename_all的信息</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="20a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第二个子命令<code class="fe lg lh li lj b">Run</code>...你得原谅我的👋挥手👋。</p><ul class=""><li id="411a" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">请记住，StructOpt是建立在<a class="ae ll" href="https://crates.io/crates/clap" rel="noopener ugc nofollow" target="_blank"> Clap </a>机箱之上的。</li><li id="1b31" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">Clap相当灵活，但我认为它很难使用。StructOpt提供了将配置传递给Clap的能力，我们只针对这个子命令的解析行为设置了一个配置设置。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="5efc" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们希望从客户机向服务器传递一个完整的命令。但是我们不一定知道这个命令有多长，也不希望完整的命令被解析。</li><li id="072e" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">在这种情况下，这种CLI参数的技术描述是“可变长度参数”或VarArg。这是一个如何解析最后一个参数的提示，因此您不需要定义结束长度——它只是变短了。</li><li id="126f" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">我们正在配置<code class="fe lg lh li lj b">Run</code>子命令，告诉Rust它使用了一个VarArg。请参见<a class="ae ll" href="https://docs.rs/clap/2.33.1/clap/enum.AppSettings.html#variant.TrailingVarArg" rel="noopener ugc nofollow" target="_blank">Clap文档</a>了解更多关于这个和其他AppSettings的信息。</li></ul><h2 id="1090" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">服务器选项</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">ServerOptions — main.rs</figcaption></figure><ul class=""><li id="1302" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们的<code class="fe lg lh li lj b">server</code>子命令有一个可配置的选项。</li><li id="a6bd" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">structopt(long)</code>属性指定这是一个选项，用户将使用双连字符模式指定该选项的名称，默认情况下是kebab-case。因此，用户会将其用作<code class="fe lg lh li lj b">--server-listen-addr</code>。</li><li id="1cdf" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">structopt(default_value)</code>很有希望不言自明。如果用户没有覆盖，将使用默认值。默认的值类型是一个字符串片<code class="fe lg lh li lj b">&amp;str</code>，但是structopt在默认情况下将它转换成一个<code class="fe lg lh li lj b">String</code>。</li></ul><h2 id="d7d1" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">RemoteCommandOptions</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">RemoteCommandOptions — main.rs</figcaption></figure><p id="6cfa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的<code class="fe lg lh li lj b">run</code>子命令有两个可能的参数。</p><ol class=""><li id="ae97" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr mx ky kz la bi translated">第一个参数<code class="fe lg lh li lj b">server_addr</code>是可选的<code class="fe lg lh li lj b">structopt(long)</code>参数，其默认值与<code class="fe lg lh li lj b">server</code>默认值一致。</li><li id="14d2" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr mx ky kz la bi translated">第二个<code class="fe lg lh li lj b">command</code>是必需的位置参数。注意这里没有<code class="fe lg lh li lj b">structopt</code>属性。可变长度参数的结果向量。解析器拆分每个单词的空格，并在Vec &lt;字符串&gt;中按顺序提供它们。(在我们的情况下，匹配的引号被解释为一个单词)。</li></ol><p id="4153" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="lk">主()</em> </strong></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">main() — main.rs</figcaption></figure><p id="ca98" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的<code class="fe lg lh li lj b">main()</code>短小精悍。</p><ul class=""><li id="e0fa" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们的返回类型是一个<code class="fe lg lh li lj b">Result</code>。我们在情况良好时返回<code class="fe lg lh li lj b">()</code>，并返回一个实现了<code class="fe lg lh li lj b">std::error::Error</code>特征的装箱<a class="ae ll" href="https://doc.rust-lang.org/reference/types/trait-object.html" rel="noopener ugc nofollow" target="_blank">特征对象</a>作为我们的错误(返回的特征对象是装箱的，因为Rust不知道分配多少空间)。</li><li id="28a3" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">我们使用StructOpt定制的带有<code class="fe lg lh li lj b">from_args()</code>的<code class="fe lg lh li lj b">ApplicationArguments</code>结构来解析用户输入。最棒的是无效输入得到了处理，因此我们不需要花费任何时间偏离这条快乐的道路。</li><li id="459c" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">解析之后，我们需要知道下一步要采取什么行动。我们要么采取服务器动作，要么采取客户端动作。</li><li id="8152" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">我们对我们的<code class="fe lg lh li lj b">SubCommand</code>结构进行模式匹配，并且<a class="ae ll" href="https://doc.rust-lang.org/rust-by-example/flow_control/match/destructuring/destructure_enum.html" rel="noopener ugc nofollow" target="_blank">析构枚举的内部结构</a>以获得额外的参数。</li><li id="fd98" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">我们最终将调用相应的服务器或客户机来传递参数。然而现在我们调用<code class="fe lg lh li lj b">println!()</code>来显示这些值。</li></ul><h2 id="9cbb" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">一起</h2><p id="b8d9" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated"><strong class="jw ir">T29】main . RST31】</strong></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">到目前为止，完成main.rs</figcaption></figure><p id="9522" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是我们目前所做的。对于这个例子来说，这将是命令行解析功能的全部范围，但是我们稍后将再次讨论<code class="fe lg lh li lj b">main()</code>函数。</p><p id="a511" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您正在跟进，这段代码将与本节顶部提供的<code class="fe lg lh li lj b">cargo.toml</code>一起工作。使用<code class="fe lg lh li lj b">cargo</code>四处玩耍。</p><p id="0bd0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，尝试以下命令:</p><ul class=""><li id="9de2" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><code class="fe lg lh li lj b">cargo run --</code></li><li id="68b8" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">cargo run -- server</code></li><li id="aeca" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">cargo run -- server -h</code></li><li id="28cf" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">cargo run -- run</code></li><li id="a551" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">cargo run -- run ls -al</code></li><li id="12d0" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">cargo run -- run -h</code></li><li id="d09f" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">cargo run -- blahblahblah</code></li></ul><h1 id="0a69" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">协议缓冲区</h1><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/221d8ffac62bb28ba8308072323ff2c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*eSahN0ivXv38bjd1.png"/></div></figure><h1 id="4d27" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">什么是协议缓冲区？</h1><p id="db28" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated"><a class="ae ll" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a> (protobufs)是一种定义数据架构的方式，用于定义数据的结构，以及如何定义程序如何以独立于语言的方式就数据进行交互。</p><p id="ed85" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是通过以protobuf格式编写数据并将其编译成您选择的支持语言来实现的，如<a class="ae ll" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>。</p><p id="0ba5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">编译的结果会生成大量样板代码。</p><p id="be0a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不仅仅是对语言的本地数据类型具有相同形状和命名约定的数据结构。而且为发送这些生成的数据结构的客户机或接收这些数据结构的服务器生成gRPC网络代码。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="21bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于它的价值，一个额外的好处是服务器和客户端有可能实现在不同的语言和互操作没有问题，由于。但是在这个例子中，我们将继续完全在Rust中工作</p><h1 id="9d2b" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">protobuf应该在代码库中的什么位置？</h1><p id="cd5e" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">在进入protobuf之前，我想提一下我在保存文件本身的地方的实践。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e80d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我喜欢将protobuf保存在一个名为<code class="fe lg lh li lj b">proto</code>的目录中，通常与<code class="fe lg lh li lj b">Cargo.toml</code>在同一层，因为我们很快就会看到，编译时构建脚本需要引用protobuf的路径。文件名本身是任意的，给事物命名是困难的，所以尽你所能用有意义的名字来支持你未来的自我。</p><h1 id="243f" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">示例protobuf</h1><p id="a7bf" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated"><strong class="jw ir"> <em class="lk"> cli.proto </em> </strong></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="da02" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们通过声明我们正在使用的语法的特定版本来开始文件。<code class="fe lg lh li lj b">proto3</code>。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="ec90" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们需要提供一个包名。</li><li id="eb6f" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://developers.google.com/protocol-buffers/docs/overview#packages" rel="noopener ugc nofollow" target="_blank"> proto3文档</a>说这是可选的，但是我们的protobuf Rust代码生成器<a class="ae ll" href="https://crates.io/crates/prost" rel="noopener ugc nofollow" target="_blank"> Prost </a>要求为模块命名空间和命名结果文件定义它。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="455e" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">定义了两种数据结构，称为<code class="fe lg lh li lj b">message</code>。</li><li id="5c8a" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">字段的顺序是有编号的，当它们被序列化/反序列化用于gRPC通信时，对于识别有线协议中的字段是很重要的。</li><li id="d56d" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">消息中的数字必须是唯一的，最佳做法是一旦使用就不要更改。</li></ul><p id="1deb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(更多详情，请阅读文档中关于字段编号<a class="ae ll" href="https://developers.google.com/protocol-buffers/docs/proto3#assigning_field_numbers" rel="noopener ugc nofollow" target="_blank">的更多内容。)</a></p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="0099" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><code class="fe lg lh li lj b">CommandInput</code>消息有2个<code class="fe lg lh li lj b">string</code>字段——一个是单数，另一个是<code class="fe lg lh li lj b">repeated</code>。</li><li id="0b04" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">主可执行文件，我们称之为<code class="fe lg lh li lj b">command</code>用户输入的第一个单词。</li><li id="c955" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">剩下的用户输入留给<code class="fe lg lh li lj b">args</code>。</li><li id="35d3" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">这种分离意味着为Bash这样的命令解释器定义命令的方式提供结构。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="e909" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><code class="fe lg lh li lj b">CommandOutput</code>消息不需要太多的结构。运行命令后，标准输出将作为单个文本块返回。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="bcb0" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">最后，我们用一个端点<code class="fe lg lh li lj b">Shell</code>定义一个服务<code class="fe lg lh li lj b">RemoteCLI</code>。</li><li id="8a44" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">Shell</code>取一个<code class="fe lg lh li lj b">CommandInput</code>，返回一个<code class="fe lg lh li lj b">CommandOutput</code>。</li></ul><h1 id="f87c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">用补品编译Rust代码中的protobuf</h1><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e469309e70627e38960efdf0c9fb567a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*dsRIOWJmuXbguL42.png"/></div></figure><p id="8f29" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们有了protobuf，当我们需要使用生成的代码时，如何在Rust程序中使用它呢？</p><p id="e915" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">嗯，我们需要配置构建，首先将protobuf编译成Rust。</p><p id="0f75" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们实现的方法是使用<a class="ae ll" href="https://doc.rust-lang.org/stable/rust-by-example/cargo/build_scripts.html" rel="noopener ugc nofollow" target="_blank">构建脚本</a>(惊喜！用Rust编写)但是在其余的编译发生之前被编译和执行。</p><p id="5a23" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您的项目根目录中有一个名为<code class="fe lg lh li lj b">build.rs</code>的文件，Cargo将运行您的构建脚本。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8c5e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">T22T24】</strong></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">用Rust构建脚本编译proto buf—build . RS</figcaption></figure><p id="b3d1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">构建脚本只是一个带有<code class="fe lg lh li lj b">main()</code>功能的小Rust程序。</p><p id="0c93" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们使用<code class="fe lg lh li lj b">tonic_build</code>将我们的原型编译成Rust。在我们余下的gRPC旅程中，我们将很快看到更多<code class="fe lg lh li lj b"><a class="ae ll" href="https://crates.io/crates/tonic" rel="noopener ugc nofollow" target="_blank">tonic</a></code>。</p><p id="2f1a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是现在我们只需要将这个机箱作为构建依赖添加到我们的<code class="fe lg lh li lj b">Cargo.toml</code>中。</p><p id="3c3d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="lk"> Cargo.toml </em> </strong></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">添加构建依赖项— Cargo.toml</figcaption></figure><p id="24c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">构建依赖项列在它自己的章节<code class="fe lg lh li lj b">[build-dependencies]</code>下。如果您不知道，您的构建脚本只能使用本节中列出的箱子，反之亦然。</p><p id="b278" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当您执行<code class="fe lg lh li lj b">cargo build</code>时，您可以在您的<code class="fe lg lh li lj b">target</code>目录中查看生成的Rust代码。</p><p id="0c4f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于构建脚本输出，您将有多个目录，其中包含您的包名和额外生成的字符。因此，您可能需要查看多个目录。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5ab2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我将把生成代码的内容留给后面的人，因为有很多代码和相关信息要么来自原型，要么将在服务器和客户机实现中涉及。</p><p id="e42c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这段代码只会生成一次。或者除非你改变<code class="fe lg lh li lj b">build.rs</code>。因此，如果您对原型进行了更改，并且想要重新生成代码，那么您可以使用<code class="fe lg lh li lj b">touch</code>强制代码重新生成。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="8028" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">计算机网络服务器</h1><p id="129d" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">现在我们可以使用protobuf生成的代码了，继续编写我们的服务器。我们将在一个新的模块中编写服务器(和客户机)。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="6773" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated"><strong class="ak"> <em class="nv"> Cargo.toml </em> </strong></h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Cargo.toml —最终版本</figcaption></figure><p id="910d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="lk">这是我们将对Cargo.toml进行的最后一次更改</em></p><p id="8c74" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们实现gRPC服务器/客户端时，我们添加了<code class="fe lg lh li lj b">tonic</code>和<code class="fe lg lh li lj b">prost</code>。<a class="ae ll" href="https://crates.io/crates/prost" rel="noopener ugc nofollow" target="_blank"> Prost </a>是Rust中协议缓冲区的实现，当我们将它包含到包的其余部分时，需要它来编译生成的代码。</p><p id="cc02" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Tokio是我们正在使用的异步运行时。gRPC服务器/客户端是<code class="fe lg lh li lj b">async</code>，我们将需要调整我们的<code class="fe lg lh li lj b">main()</code>来在我们现在调用的异步函数中进行更多的通信..</p><h1 id="77e2" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">remotecli/mod.rs</h1><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="28c0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了保持实现的组织性，我们将把服务器和客户机代码进一步分离到它们自己的模块中。从服务器开始。</p><h1 id="ff5d" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">remotecli/server.rs</h1><p id="a7dd" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">与前端CLI演练类似，我将把这个文件分成几个部分，并查看它们。</p><p id="19a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="lk">在这个文件的</em> </strong>  <strong class="jw ir"> <em class="lk">部分底部的</em> </strong> <a class="ae ll" href="#bacb" rel="noopener ugc nofollow"> <strong class="jw ir"> <em class="lk">我会把完整的文件放在那里，以便复制/粘贴。</em> </strong></a></p><p id="6e25" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="lk">进口</em> </strong></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Imports — server.rs</figcaption></figure><ul class=""><li id="0927" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">在文件的顶部，我们声明了一个模块<code class="fe lg lh li lj b">remotecli_proto</code>，它的作用域只在这个文件中。名称<code class="fe lg lh li lj b">remotecli_proto</code>是任意的，并且是为了清晰的目的。</li><li id="0914" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">tonic::include_proto!()</code>宏有效地将我们的protobuf翻译的Rust代码(根据protobuf包名)复制/粘贴到模块中。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="aeb8" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">protobuf翻译的命名约定一开始可能会有点混乱，但是都是一致的。</li><li id="c2d8" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">我们的protobuf的<code class="fe lg lh li lj b">RemoteCLI</code>服务使用<a class="ae ll" href="https://en.wikipedia.org/wiki/Snake_case" rel="noopener ugc nofollow" target="_blank"> snake case </a> + <code class="fe lg lh li lj b">_server</code>或<code class="fe lg lh li lj b">_client</code>生成独立的客户端和服务器模块。而生成的特征定义使用<a class="ae ll" href="https://en.wikipedia.org/wiki/Camel_case" rel="noopener ugc nofollow" target="_blank"> Pascal大小写</a>(首字母大写的camel大小写的一种特殊形式)。</li><li id="36b5" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">从特定于服务器的生成代码中，我们导入了一个特征<code class="fe lg lh li lj b">RemoteCli</code>，它要求我们用相同的函数签名实现gRPC端点<code class="fe lg lh li lj b">Shell</code>。</li><li id="899b" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">此外，我们导入了<code class="fe lg lh li lj b">RemoteCliServer</code>，这是一个生成的服务器实现，它处理所有的gRPC网络语义，但是要求我们用一个实现了<code class="fe lg lh li lj b">RemoteCli</code>特征的结构进行实例化。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="e2ab" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">gRPC代码的最后一个导入是我们的protobuf消息<code class="fe lg lh li lj b">CommandInput</code>和<code class="fe lg lh li lj b">CommandOutput</code></li><li id="d58b" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">从我们的前端，我们正在导入<code class="fe lg lh li lj b">ServerOptions</code>结构，因为我们将为服务器监听地址传递用户输入。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="b3d8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们从<code class="fe lg lh li lj b">std::process</code>导入。<code class="fe lg lh li lj b">Command</code>和<code class="fe lg lh li lj b">Stdio</code> -用于执行命令和捕捉输出。</p><h2 id="b8fd" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">RemoteCli特征实现</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">RemoteCli特征— server.rs</figcaption></figure><ul class=""><li id="6d22" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们声明我们自己的结构<code class="fe lg lh li lj b">Cli</code>，因为我们需要<code class="fe lg lh li lj b">impl RemoteCli</code>。</li><li id="c8f7" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">我们生成的代码使用了一个<code class="fe lg lh li lj b">async</code>方法。我们将<code class="fe lg lh li lj b">#[tonic::async_trait]</code>添加到我们的trait impl中，这样服务器就可以在我们的方法中使用<code class="fe lg lh li lj b">async fn</code>。我们只有一个方法来定义，<code class="fe lg lh li lj b">async fn shell()</code>。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="bdbb" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我是👋挥动我的双手👋这里是函数签名，但我最初学习如何编写它们的方法是进入生成的代码，浏览<code class="fe lg lh li lj b">remote_cli_server</code>模块中的代码并修改板条箱路径。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="0c2e" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们进入<code class="fe lg lh li lj b">shell</code>后做的第一件事就是用<code class="fe lg lh li lj b">.into_inner()</code>剥掉<code class="fe lg lh li lj b">request</code>上的<code class="fe lg lh li lj b">tonic</code>包装。我们进一步将数据的所有权分成<code class="fe lg lh li lj b">command</code>和<code class="fe lg lh li lj b">args</code>变量。</li><li id="6095" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">我们将<code class="fe lg lh li lj b">process</code>构建为<code class="fe lg lh li lj b">std::process::Command</code>结构，这样我们就可以生成用户进程并捕获标准输出。</li><li id="07e3" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">然后我们等待<code class="fe lg lh li lj b">process</code>退出并用<code class="fe lg lh li lj b">.wait_with_output()</code>收集输出。我们只是想要<code class="fe lg lh li lj b">stdout</code>,所以我们进一步获得了那个句柄的所有权。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="9939" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">最后，我们构建一个<code class="fe lg lh li lj b">tonic::Response</code>，当我们实例化我们的<code class="fe lg lh li lj b">CommandOutput</code>时，将流程stdout转换成一个<code class="fe lg lh li lj b">String</code>。最后将<code class="fe lg lh li lj b">Response</code>包装在<code class="fe lg lh li lj b">Result</code>中并返回给客户端。</li></ul><h2 id="6db0" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">启动服务器</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">start_server() — server.rs</figcaption></figure><ul class=""><li id="3122" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">前端将使用该函数来启动服务器。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="036e" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">监听地址通过<code class="fe lg lh li lj b">opts</code>传入。它是作为<code class="fe lg lh li lj b">String</code>传入的，但是编译器会根据我们稍后使用它的方式来判断我们调用<code class="fe lg lh li lj b">.parse()</code>时所指的类型。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="784f" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们用作为protobuf特征<code class="fe lg lh li lj b">RemoteCli</code>实现的<code class="fe lg lh li lj b">Cli</code>结构来实例化<code class="fe lg lh li lj b">cli_server</code>。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="e527" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><code class="fe lg lh li lj b">tonic::Server::builder()</code>创建我们的gRPC服务器实例。</li><li id="c28d" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">.add_service()</code>方法使用<code class="fe lg lh li lj b">RemoteCliServer::new(cli_server)</code>创建一个gRPC服务器，通过<code class="fe lg lh li lj b">RemoteCliServer</code>生成端点，通过<code class="fe lg lh li lj b">cli_server</code>生成特征impl。</li><li id="7c92" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">serve()</code>方法接受我们解析的监听地址，提供编译器推断所需类型所需的提示，并返回一个<code class="fe lg lh li lj b">async Result&lt;T&gt;</code>给我们<code class="fe lg lh li lj b">.await</code> on。</li></ul><h1 id="3852" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">main.rs —目前为止</h1><p id="6c39" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">我们正在对<code class="fe lg lh li lj b">main.rs</code>做一些小改动，以插入服务器模块。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">main.rs —添加服务器模块后。第47–50行</figcaption></figure><ul class=""><li id="e270" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们现在导入我们的<code class="fe lg lh li lj b">remotecli</code>模块。</li><li id="c2f4" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe lg lh li lj b">main()</code>功能也略有变化。首先，我们将函数改为<code class="fe lg lh li lj b">async</code>。</li><li id="1382" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">我们添加了<code class="fe lg lh li lj b">#[tokio::main]</code>属性来标记要执行的异步函数。</li><li id="9d3e" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">当用户运行<code class="fe lg lh li lj b">server</code>子命令时，我们调用新的<code class="fe lg lh li lj b">start_server()</code>来实际启动服务器。</li></ul><h1 id="bacb" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">remotecli/server.rs一起</h1><p id="8961" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">这是服务器模块的最终形式。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">server.rs —最终版本</figcaption></figure><p id="917b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是服务器实现和启动服务器的前端代码。这是令人惊讶的少量代码。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="66b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以通过运行以下命令来启动服务器实例:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="8e5c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">客户</h1><p id="f9a0" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">我们正处于最后冲刺阶段。实现客户端。我们将在<code class="fe lg lh li lj b">remotecli</code>中创建一个名为<code class="fe lg lh li lj b">client.rs</code>的新模块，它将遵循我们为服务器建立的相同模式。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="8e2d" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">remotecli/mod.rs</h1><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d5c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将在<code class="fe lg lh li lj b">mod.rs</code>中声明客户端模块</p><h1 id="1ce3" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">remotecli/client.rs</h1><p id="9b52" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">我们的委托人要简单得多。但是为了描述的目的，将模块分成几个部分。</p><p id="475f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="lk">又来了，满档是在</em> </strong> <a class="ae ll" href="#5ac1" rel="noopener ugc nofollow"> <strong class="jw ir"> <em class="lk">一节的末尾</em> </strong> </a> <strong class="jw ir"> <em class="lk">。</em> </strong></p><p id="c12b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="lk">进口</em> </strong></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">导入—客户端. rs</figcaption></figure><ul class=""><li id="f4c0" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">就像在我们的服务器中一样，我们创建一个模块<code class="fe lg lh li lj b">remotecli_proto</code>，并使用<code class="fe lg lh li lj b">tonic::include_proto!()</code>宏将我们生成的代码复制/粘贴到这个模块中。</li><li id="a539" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">然后我们包含生成的<code class="fe lg lh li lj b">RemoteCliClient</code>来连接，以及<code class="fe lg lh li lj b">CommandInput</code>结构，因为这是我们发送给服务器的内容。</li><li id="0a5d" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">最后一个include是来自前端的<code class="fe lg lh li lj b">RemoteCommandOptions</code>结构，因此我们可以传入我们想要连接的服务器地址。</li></ul><p id="ced7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="lk">客户端_运行</em> </strong></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">client_run() —客户端. rs</figcaption></figure><ul class=""><li id="57ac" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">助手函数<code class="fe lg lh li lj b">client_run()</code>和我们的服务器一样是一个<code class="fe lg lh li lj b">async</code>函数。前端为服务器地址信息以及我们的原始用户命令传入一个<code class="fe lg lh li lj b">RemoteCommandOptions</code>结构。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="da34" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">我们做的第一件事是创建<code class="fe lg lh li lj b">client</code>并用<code class="fe lg lh li lj b">RemoteCliClient::connect</code>连接到服务器并执行<code class="fe lg lh li lj b">.await</code>。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="885b" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">然后我们通过用我们的<code class="fe lg lh li lj b">CommandInput</code>创建一个<code class="fe lg lh li lj b">tonic::Request</code>结构来构建我们的请求。</li><li id="6c83" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">用户命令是原始的，需要分割以适应服务器期望的形状。用户命令的第一个词是shell命令，其余的是参数。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><ul class=""><li id="9a3c" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">最后，我们使用<code class="fe lg lh li lj b">client</code>并用我们的请求和<code class="fe lg lh li lj b">.await</code>调用我们的端点以完成执行。</li></ul><h2 id="0b4b" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">main.rs</h2><p id="fbc4" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">这就是<code class="fe lg lh li lj b">main.rs</code>的最终形态。我们对<code class="fe lg lh li lj b">main.rs</code>做的最后一件事是插入我们的<code class="fe lg lh li lj b">client_run()</code>函数。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">main.rs —添加客户端模块后。第51–54行。最终版</figcaption></figure><h1 id="5ac1" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">remotecli/client.rs一起</h1><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">client.rs —最终版本</figcaption></figure><h1 id="ec8e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">最终演示</h1><p id="9fac" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">为了端到端地查看这个服务器-客户端，我们需要打开两个终端窗口。一个是运行服务器，另一个是运行一个简单的<code class="fe lg lh li lj b">ls</code>命令。</p><h2 id="eaad" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">计算机网络服务器</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="00d4" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">客户</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="75e0" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">输出</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="84f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如我们所看到的，为了以更易于阅读的方式格式化输出，还有很多工作要做。但这是留给读者的练习。</p><h1 id="4651" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="3460" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">我们刚刚构建了一个CLI应用程序，它解析用户输入，并使用gRPC将命令从gRPC客户端发送到服务器，以便执行和返回命令输出。</p><p id="3121" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">基于我们如何使用<code class="fe lg lh li lj b">StructOpt</code>构建前端CLI，我们允许客户端和服务器编译成一个二进制文件。</p><p id="3e1e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">协议缓冲区(或protobufs)用于定义服务器的接口和所使用的数据结构。<code class="fe lg lh li lj b">Tonic</code>和<code class="fe lg lh li lj b">Prost</code>板条箱和货物构建脚本用于将protobufs编译成本地异步Rust代码。</p><p id="83b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢您和我一起了解细节。我希望这个演练能够满足对使用gRPC作为后端代码的一些好奇。也激起了你写一些Rust代码的兴趣。</p><h2 id="4b3b" class="my ln iq bd lo mz na dn ls nb nc dp lw kf nd ne ma kj nf ng me kn nh ni mi nj bi translated">资源</h2><ul class=""><li id="7a30" class="ks kt iq jw b jx mk kb ml kf nw kj nx kn ny kr kx ky kz la bi translated">【https://developers.google.com/protocol-buffers/docs/proto3 T4】</li><li id="25e9" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank">https://grpc.io/</a></li><li id="f302" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://github.com/tjtelan/rust-examples/tree/main/cli-grpc-tonic-blocking" rel="noopener ugc nofollow" target="_blank">https://github . com/tjtelan/rust-examples/tree/main/CLI-grpc-tonic-blocking</a></li><li id="0519" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://crates.io/crates/prost" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/prost</a></li><li id="cec2" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://crates.io/crates/tonic" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/tonic</a></li><li id="468b" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://crates.io/crates/structopt" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/structopt</a></li><li id="b7a9" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://tokio.rs/" rel="noopener ugc nofollow" target="_blank">https://tokio.rs/</a></li><li id="e5fa" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://doc.rust-lang.org/reference/attributes/derive.html" rel="noopener ugc nofollow" target="_blank">https://doc.rust-lang.org/reference/attributes/derive.html</a></li><li id="4657" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://doc.rust-lang.org/reference/comments.html#doc-comments" rel="noopener ugc nofollow" target="_blank">https://doc . rust-lang . org/reference/comments . html # doc-comments</a></li><li id="8582" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://docs.rs/structopt/0.3.16/structopt/#specifying-argument-types" rel="noopener ugc nofollow" target="_blank">https://docs . RS/struct opt/0 . 3 . 16/struct opt/#指定参数类型</a></li><li id="4d8e" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">【https://docs.rs/clap/2.33.1/clap/enum. T2】AppSettings.html#variant。TrailingVarArg </li><li id="3689" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://doc.rust-lang.org/rust-by-example/flow_control/match/destructuring/destructure_enum.html" rel="noopener ugc nofollow" target="_blank">https://doc . rust-lang . org/rust-by-example/flow _ control/match/destructing/destructure _ enum . html</a></li><li id="36e9" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://doc.rust-lang.org/reference/types/trait-object.html" rel="noopener ugc nofollow" target="_blank">https://doc.rust-lang.org/reference/types/trait-object.html</a></li><li id="5e93" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ll" href="https://doc.rust-lang.org/stable/rust-by-example/cargo/build_scripts.html" rel="noopener ugc nofollow" target="_blank">https://doc . rust-lang . org/stable/rust-by-example/cargo/build _ scripts . html</a></li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="4ad3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="lk">原载于</em><a class="ae ll" href="https://tjtelan.com/blog/lets-build-a-single-binary-grpc-server-client-with-rust-in-2020/" rel="noopener ugc nofollow" target="_blank"><em class="lk">https://tjtelan.com</em></a><em class="lk">。</em></p></div></div>    
</body>
</html>