# 了解节点模块的依赖性管理

> 原文：<https://levelup.gitconnected.com/understanding-dependency-management-with-node-modules-1c47bcdee98b>

## package.json 中的版本控制如何工作，以及锁文件如何防止对应用程序进行重大更改

![](img/d880999f34158e34155e9905dc4b6fbe.png)

Marcello Gennari 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

JavaScript 模块的兴起导致管理脚本文件的工具更加复杂。大多数现代 web 应用程序现在使用像 [webpack](https://webpack.js.org/) 这样的模块捆绑器来利用 JavaScript 模块和更复杂的库比如 [React](https://reactjs.org/) 的优势，而不是使用像[gupp](https://gulpjs.com/)这样的简单任务运行器来传输和连接资产。

这给 JavaScript 开发人员带来了一系列全新的挑战，包括依赖性管理。技术社区中有一个常见的术语叫做*依赖地狱*——指的是拥有不同或不兼容版本的共享依赖包所带来的挑战和困难。

我见过的开发人员面对节点模块的一些常见问题通常与缺乏对版本控制和包解析如何与[节点包管理器](https://www.npmjs.com/)一起工作的理解有关。这可能是意外地升级了引入了重大更改的包，不知道如何解决重复或冲突的依赖关系，不知道如何解决锁文件中的合并冲突，以及最终的错误—删除锁文件。

## 什么是 JavaScript 模块？

JavaScript 模块是简单的脚本文件，可以相互加载以共享功能。模块的主要好处之一是，它们允许我们将大型脚本分解成更小的、可重用的自包含代码片段。

一个模块或模块的集合可以作为*包*发布到公共或私有注册中心以供使用。JS 模块的主要公共注册中心是[节点包管理器](https://www.npmjs.com/) (NPM)。这使得开发人员能够在全球范围内共享代码，从而促进了 JS 社区的发展。

可以使用命令行包管理器(如`[npm](https://github.com/npm/cli)`或`[yarn](https://classic.yarnpkg.com/en/docs/install#mac-stable)`)将包安装到本地机器上的项目中，并添加到项目根目录下的`node_modules`文件夹中。

## package.json 和 lock 文件是什么？

`package.json`和锁文件(`yarn.lock`如果你使用`yarn`，和`package-lock.json`如果你使用`npm`)是配置文件，告诉安装程序要安装哪个版本的包。

将`package.json`视为*规范*——它列出了所有的包及其版本需求(例如，最低版本、最高版本等)。当您第一次安装软件包时，会创建一个锁文件。可以把这个看作是*契约*——它有一个在第一次安装时满足`package.json` *中规范的软件包的精确版本列表。*

通常情况下，一个项目不仅仅存在于单个开发人员的机器上，存储库由许多开发人员克隆和安装，甚至在 CI/CD 管道中，因此，确保软件包受到正确的版本控制是很重要的——这是锁文件的作用。任何时候模块随后被安装，安装程序将使用锁定文件中指定的版本，*而不是*的`package.json`。

如果你不熟悉包管理器的模块解析是如何工作的，如果你遇到安装问题，你可能会尝试删除所有内容(包括锁文件)并重新安装，但是你应该*永远不要删除锁文件*，因为这可能会由于意外升级依赖关系而引入破坏性的改变。为了更好地理解这一点，你需要知道[语义版本](https://semver.org/) (semver)在`package.json`中是如何使用的。

## 永远 101

semver 中的版本号由 3 组数字组成，用一个`.`隔开，例如`1.2.3`分别代表`major.minor.patch`。semver 文档解释了其中的每一项:

```
1\. MAJOR version when you make incompatible API changes,
2\. MINOR version when you add functionality in a backwards compatible manner, and
3\. PATCH version when you make backwards compatible bug fixes.
```

在`package.json`中，对于每个依赖项，您将看到一个相应的服务器号。有时这是前缀克拉`^`或波浪号`~`。

1.  `^1.2.3` —安装最新版本的`1.X.X`(不要超过指定的专业，只需更高的副专业和补丁号)。
2.  `~1.2.3` —安装最新版本的`1.2.X`(不要超过指定的主要或次要版本，只需更高的补丁号)。

如果您需要对版本范围进行更精细的控制，您可以使用[范围操作符](https://docs.npmjs.com/cli/v6/using-npm/semver#ranges)(例如`>=`)。

## 删除锁定文件会如何影响版本控制

假设我们的项目有一个依赖项，版本为`^1.0.0`的`example-package`。这是首次安装时可用的最新版本，并作为`1.0.0`添加到锁定文件中。一个月后，一个新版本的`example-package`出来了`1.1.0`。让我们假设一个新的开发人员加入了您的团队，克隆了项目存储库，并安装了项目。

`package.json`中的版本是`^1.0.0`(指最新的`1.X.X`)，所以你会以为`1.1.0`会安装在新开发者的机器上，但事实并非如此。当依赖项第一次添加到项目中时，`1.1.0`并不存在，所以锁文件中列出的版本是`1.0.0`。因此，尽管有符合`package.json`中 semver 规范的更新版本，仍将一直安装`1.0.0`。

如果您没有将锁定文件提交到您的库，或者删除锁定文件并重新安装您的节点模块，那么将安装版本`example-package`的`1.1.0`，因为它将被视为第一次安装。新的 bug 可能已经被引入到`1.1.0`中，或者可能包的依赖关系已经改变，并且与项目中的其他依赖关系不兼容。

这就是为什么删除锁文件会无意中导致依赖关系升级，从而导致应用程序崩溃。

## 版本锁定

您可能认为简单地从您的版本号中删除`^`或`~`来指定依赖项的确切版本就可以解决这个问题。不幸的是，即使您明确地将每个依赖项的确切版本放在您的`package.json`中，如果没有锁文件，您仍然可能意外地升级依赖项的依赖项。

请记住，包只是 JavaScript 模块，可以互换功能，这意味着它们可以从其他包中导入和使用模块。因此，锁文件不仅处理`package.json`中列出的依赖项的版本控制，还处理*依赖树*中的所有包。在下面的例子中，`example-package`在它自己的`package.json`版本`^1.0.0`中有一个依赖项`foobar`，而`foobar`在`~1.0.0`有它自己的依赖项`fizzbuzz`。

```
// Hierarchal representation of dependency treeroot
└─┬ example-package@1.0.0
  └─┬ foobar@^1.0.0
    └── fizzbuzz@~1.0.0
```

即使我们锁定了`example-package`的版本，我们仍然会遇到与`foobar`和`fizzbuzz`相同的意外升级问题，因为可能会发布一个有 bug 的新版本，并且它们的版本号没有被锁定。

如果没有锁文件，包管理器将更新任何依赖关系及其依赖关系等等，这可能会引入破坏性的更改。

## 处理重复或冲突的包版本

像 [React](https://www.npmjs.com/package/react) 这样的软件包要求只安装一个版本，如果有多个版本，就会抛出一个错误。如果您的项目中有两个不同的包，并且每个包都有不同版本的 React 作为依赖项，那么您最终可能会安装两个不同版本的 React。

您可以使用命令`yarn why`或`npm ls`后跟包名(如`yarn why example-package`)来检查依赖关系树。我个人更喜欢`npm ls`，因为它提供了依赖层次的可视化表示。

如果有符合`package.json`中指定版本的通用版本，`yarn`将在安装时自动进行重复数据删除，并解析为通用版本。如果你正在使用`npm`，你需要运行`[npm dedupe](https://docs.npmjs.com/cli/v6/commands/npm-dedupe)`。

如果安装程序找不到通用版本，那么您需要指定应该使用哪个版本。在您的`package.json`中添加一个 resolutions 字段来指定依赖项和应该使用的版本。当您安装`yarn`时，两个软件包中的版本将被您的分辨率字段中的版本覆盖。

```
// Example of resolutions field in the package.json{
  ...
  resolutions: {
    react: "17.0.1"
  }
}
```

虽然`npm`在`yarn`中没有等效的解决方案，但是您可以通过使用这个包的预安装钩子 [npm-force-resolutions](https://www.npmjs.com/package/npm-force-resolutions) 来指定版本。

解决方案非常有用，不仅可以用于对包进行重复数据删除，还可以修复子依赖版本可能导致的任何问题。例如，一个包可能有一个存在安全漏洞的依赖项，您可以使用`package.json`中的 resolutions 字段来强制它更新到一个修复了该漏洞的版本。

## 锁定文件中的冲突解决方案

我看到的另一个问题是，当合并分支时，如何解决锁文件中的冲突，特别是如果你的项目中不是所有的开发人员都是 JavaScript 开发人员或者习惯于使用`yarn`、`npm`或节点模块。这可能会让他们感到沮丧，因为如果他们需要同步分支，这可能会阻塞他们的工作流。

当多个 git 分支修改依赖项时(例如，添加新特性所需的新依赖项)，很可能会在锁文件中引入冲突。这是完全正常的，而且`yarn`和`npm`实际上使解决冲突变得非常简单。

首先，总是解决`package.json`中的冲突，并且不要*而不是*手动编辑锁文件。事实上，在`yarn.lock`中有一个警告，说明不要手动编辑它。如果您没有对分支中的依赖项进行任何更改(例如，添加了一个新的依赖项，或者显式升级了一个依赖项)，那么您应该从目标分支中进行更改。然后，只需运行`yarn`来运行软件包安装程序，这将自动修复`yarn.lock`中的所有冲突。如果使用`npm`，运行`npm install --package-lock-only`进行同样的操作。然后，存放`package.json`并锁定文件，继续用`git merge --continue`合并您的分支。

## **更新和删除未使用的依赖关系**

良好的内务管理是依赖性管理的关键部分。您应该定期更新您的依赖项，以便与最新的安全修补程序保持同步，但是这需要小心安全地完成，以防止破坏您的应用程序。

我曾见过依赖关系多年未更新的项目，解决所有安全漏洞的升级过程令人难以置信地痛苦，并引入了许多突破性的更改。

您可以使用命令`yarn outdated`或`npm outdated`检查哪些包已经过期，但是不要一次安装所有这些包的最新版本。以下是一些关于如何安全升级依赖项的提示。

1.  在功能分支上，一次仅升级一个包或一组相互依赖的相关包(例如 React 和 ReactDOM)。如果您的应用程序中断了，那么识别哪个包是违规的就容易多了，并且 pull 请求也可以很容易地恢复。
2.  确保您的应用程序有足够的测试覆盖率。如果您针对 CI/CD 管道中的 pull 请求运行您的测试套件，您可以自动捕捉到依赖项升级的特性分支上的重大更改。
3.  使用自动化的依赖管理器。像 [Snyk](https://snyk.io/) 、[dependent bot](https://dependabot.com/)和 [Greenkeeper](https://greenkeeper.io/) 这样的服务可以添加到您的 CI/CD 管道中。该机器人将自动检查一个新的分支，并提出一个拉请求，以升级过时的依赖关系或已知安全漏洞的依赖关系。

您还应该删除未使用的依赖项，因为这些依赖项可以释放空间并缩短安装时间，这对于您的应用程序构建过程来说会更有效。 [Depcheck](https://github.com/depcheck/depcheck) 是一个伟大的工具，它将分析你的项目，并确定你的`package.json`中缺少或未使用的依赖项。

## 结论

NPM 包的版本控制对于保持应用程序的稳定性非常重要。

应该有意识地、系统地升级依赖项，以保持最新的安全修复，而不是通过删除锁定文件来意外升级。我从开发人员朋友那里听说过应用程序崩溃的可怕故事，他们工作的公司在 CI/CD 管道中删除了锁文件，或者没有提交到存储库中。

理解语义版本化以及包管理器如何使用`package.json`和锁文件来解析版本对于良好的依赖关系管理是至关重要的，这将有助于防止您犯这些常见的错误，这些错误会将破坏性的更改引入到您的应用程序中。