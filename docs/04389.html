<html>
<head>
<title>Bypassing SSL Pinning on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绕过Android上的SSL锁定</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bypassing-ssl-pinning-on-android-3c82f5c51d86?source=collection_archive---------0-----------------------#2020-06-24">https://levelup.gitconnected.com/bypassing-ssl-pinning-on-android-3c82f5c51d86?source=collection_archive---------0-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="905b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用smali补丁规避Android上的证书锁定。</h2></div><p id="c943" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几乎所有的移动应用程序都与后端服务器通信，无论是传输应用程序数据、备份、分析；移动设备中的无线通信信道上存在某种形式的数据来回传输。</p><p id="11d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数开发者都知道他们需要使用HTTPS，毕竟现在是2020年，但在移动应用程序中，这还不够。如果您不检查您正在通信的服务器是否是您期望的服务器，那么您如何相信通信是安全的并且没有被拦截？</p><blockquote class="lb"><p id="5a55" class="lc ld iq bd le lf lg lh li lj lk la dk translated">如果你不验证服务器是合法的，你怎么知道用户通信是安全的？</p></blockquote></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="2f8c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题和解决方案</h1><p id="8be2" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">问题在于中间人(MitM)攻击，顾名思义，这指的是某种恶意行为者位于客户端(用户/应用程序)和服务器之间的通信中间。在这种情况下，可以截取、读取和修改两个终端设备之间的通信，从而影响用户的保密性和数据的完整性。MitM可以通过多种方式发生，这不仅限于智能设备，然而在移动环境中，最大的威胁之一是伪造的Android证书或iOS设备配置文件。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/fd773e774340509c2d9a24b18cf6d613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lLx9qp0i1jGZ-B7S"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">泰勒·维克在<a class="ae nf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0efb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，这个问题有一个解决方案，也就是通常所说的证书锁定或公钥锁定。Pinning是应用程序开发人员指定特定证书来验证应用程序连接的服务器的合法性，以确保它们是可信的。</p><blockquote class="lb"><p id="13a8" class="lc ld iq bd le lf lg lh li lj lk la dk translated">我们可以信任后端服务器使用证书/公钥锁定来提供验证。</p></blockquote><p id="faba" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">这种方法实际上是将证书或公钥的散列“固定”到应用程序中，并使用它来确定它所连接的服务器的信任度，服务器当然持有PKI密钥对的私钥。<br/>然而，我们是安全专业人士，虽然理解这些概念的理论很重要，但我们想知道如何打破这些安全保护，以便访问底层API调用。如果我们能够打破证书锁定，一般来说，就有可能进一步进入后端系统，以获得无数的用户数据，而不仅仅是一个用户的数据。</p><p id="6193" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将了解两个证书锁定实施的示例，它们在代码库中留下了缺陷，恶意用户可以利用这些缺陷来拦截通信并访问这些幕后API调用。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="cb65" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">锁定旁路</h1><p id="b55d" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们应该注意到SSL固定是一个难以回避的挑战；一个应用程序可以通过多种不同的方式来实现它，从标准的Java APIs到围绕它构建的整个库。一旦您确定了应用程序是如何实现锁定的，smali补丁可能会非常不同，在某些情况下可能会更容易或更复杂。我们将在示例中说明和讨论这一点。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="1c18" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">空信任链</h1><h2 id="4b2d" class="nl lt iq bd lu nm nn dn ly no np dp mc ko nq nr me ks ns nt mg kw nu nv mi nw bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><p id="8725" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在我们的第一个场景中，应用程序被部分混淆，并使用标准的Java SSL pin。这通常意味着该应用程序实现了一个名为“<em class="nx"> checkServerTrusted </em>()”的方法来验证后端，如果使用自定义信任管理器也需要客户端验证的话，可能还需要“<em class="nx"> checkClientTrusted </em>()”。</p><pre class="mq mr ms mt gt ny nz oa ob aw oc bi"><span id="c0a5" class="nl lt iq nz b gy od oe l of og">public void checkServerTrusted(X509Certificate[] cert, String str)</span></pre><p id="f6e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，该方法对连接的服务器端进行身份验证。应用程序提供证书作为输入，通常硬编码在应用程序中的某个位置，实现建立到服务器的证书链，如果可信，则返回正值，或者在负值的情况下，抛出异常。</p><p id="4205" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的方法采用X509 certificates '<em class="nx">X509 certificate earr</em>'的数组，然后遍历这些数组，提取颁发者和使用者的名称并将其附加到证书链字符串中，然后进行验证，如果出现“找不到固定”的情况，将引发异常。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oh"><img src="../Images/a63753352ddaf89e483a3562ff9e75dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZJyO-20Mt1u-xFZX1FTHw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">checkServerTrusted() Java固定代码</figcaption></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h2 id="a637" class="nl lt iq bd lu nm nn dn ly no np dp mc ko nq nr me ks ns nt mg kw nu nv mi nw bi translated">斯马利</h2><p id="18c5" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在这个代码块的小分解中，我们可以看到较低级别的表示，有一些相似之处，但也有一些细微差别需要注意。</p><p id="8ad3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法声明包含标准的smali，但是我们有:</p><ul class=""><li id="9371" class="oi oj iq kh b ki kj kl km ko ok ks ol kw om la on oo op oq bi translated"><em class="nx">[【T7]'表示输入参数的数组。</em></li><li id="b652" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated"><em class="nx"> L </em>'来表明下面的项目是一个实例或类，在本例中是X509Certificate。</li><li id="fbe0" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated"><em class="nx">；</em>'分隔参数</li><li id="ac43" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated">一个字符串实例，再次用'<em class="nx"> L </em>表示</li><li id="d2fe" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated">然后，该方法返回void。</li></ul><p id="68be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们可以在SSL固定和字符串构造完成之前简单地将“return void”语句移到。这意味着证书链永远不会被构建，也不会被验证；然而，这也表明了另一个问题和逻辑问题。没有错误检查来验证信任链是有效的或者甚至不是空的，它盲目地接受返回调用并继续通信。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ow"><img src="../Images/4f0717fce3308403ec8460935dadf986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6mTH7vNZgfrvu0Y4zo6hw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">第513行添加了smali语句的SSL pinning bypass。</figcaption></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="b181" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">存储证书的修改</h1><h2 id="dd8b" class="nl lt iq bd lu nm nn dn ly no np dp mc ko nq nr me ks ns nt mg kw nu nv mi nw bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><p id="1132" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">下一个场景涵盖了一个更复杂的实现，但同样，它创建证书链的方式存在缺陷，并引入了针对SSL锁定的漏洞。</p><p id="99a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发现SSL pinning使用了一个实现名为<em class="nx"> init() </em>的方法的类。</p><ol class=""><li id="acef" class="oi oj iq kh b ki kj kl km ko ok ks ol kw om la ox oo op oq bi translated">该方法的第一步包括调用另一个名为<em class="nx"> getCertificates </em>()的方法，如下面几行所示；第140行</li></ol><p id="f708" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.方法<em class="nx"> getcertificates </em>()，读取作为原始资源存储的CA证书，并在类型Certificate、<em class="nx">List&lt;Certificate&gt;</em>的Java列表中返回它们</p><p id="5c93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.回到<em class="nx"> init </em>()，实例化一个Java <em class="nx"> Keystore </em>并在列表中添加每个证书；第95–105行</p><p id="e9c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.一旦这个<em class="nx">密钥库</em>被构建，它就被交给一个Java <em class="nx">信任管理器</em>，后者将使用它来启动与Java SSL <em class="nx"> init </em>()方法的SSL协商；第105–107行</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oy"><img src="../Images/897beff8e8badd26cf455ef40907b65c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CVhITNM1dwhPLeRx5-LydA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">init()方法和getCertificates()方法的Java代码</figcaption></figure><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oz"><img src="../Images/d56263962cda4fa4d7c7ad762a45ae10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-59P6YSsvRC6b8k3RIZTw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">getCertificates()的返回值</figcaption></figure><blockquote class="lb"><p id="0c26" class="lc ld iq bd le lf pa pb pc pd pe la dk translated">该方法隐式信任它所提供的内容，无论是真实的证书，还是我们定制的假CA。</p></blockquote><p id="98b4" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">从安全的角度来看，这个<em class="nx"> init </em>()方法是易受攻击的，因为它完全信任提供给它的证书，但是当它被方法<em class="nx"> getCertificates </em>()返回时，并不实际验证这些证书的用途。因此，<em class="nx"> getCertificates </em>()可能会返回一个空值、一个空列表，或者，正如我们将要展示的，我们为代理工具定制的CA。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h2 id="9ffb" class="nl lt iq bd lu nm nn dn ly no np dp mc ko nq nr me ks ns nt mg kw nu nv mi nw bi translated">斯马利</h2><p id="5ca0" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在方法<em class="nx"> getCertificates </em>()的第一部分，我们可以观察到方法调用返回一个列表对象<em class="nx">Ljava/util/List</em>；在第354–358行创建名为<strong class="kh ir"> cf </strong>的CertificateFactory，然后在第362–367行创建并实例化<em class="nx"> ArrayList </em>。</p><ul class=""><li id="e841" class="oi oj iq kh b ki kj kl km ko ok ks ol kw om la on oo op oq bi translated">这里还需要注意的是，名为<strong class="kh ir">证书</strong>的证书列表存储在变量<strong class="kh ir"> v2 </strong>中，第367行。</li></ul><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi pf"><img src="../Images/1bdd5ed8e280cdd45097690559e12d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xq7bCwQaHzkKWv3eBwqBew.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">getCertificates()小代码</figcaption></figure><p id="069e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在代码的更深处，我们可以开始注意到代码正在做什么的模式。</p><ol class=""><li id="31e2" class="oi oj iq kh b ki kj kl km ko ok ks ol kw om la ox oo op oq bi translated">将资源ID放入局部变量。</li><li id="ee2c" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la ox oo op oq bi translated">使用此ID调用<em class="nx"> openRawResource </em>()的函数；对证书的引用。</li><li id="c348" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la ox oo op oq bi translated">使用<em class="nx"> InputStream() </em>读取</li><li id="0abb" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la ox oo op oq bi translated">附加到<strong class="kh ir">证书</strong>列表。</li><li id="a725" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la ox oo op oq bi translated">关闭<em class="nx"> InputStream() </em></li></ol><p id="2458" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对每个证书重复相同的模式，在方法结束时，返回存储在<strong class="kh ir"> v2 </strong>中的列表。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi pg"><img src="../Images/9bb583fa0d624023bbc52ea3f97116f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QS444EFMgG-hPmc1Npt4GA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">getCertificates()方法的返回值。v2是生成的证书列表</figcaption></figure><p id="a219" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，这个应用程序从resources文件夹中获取基于资源ID的外部输入，并构建一个有效的“可信”证书列表。如果我们用攻击者控制的证书替换其中一个证书会怎么样？</p><blockquote class="lb"><p id="cfe9" class="lc ld iq bd le lf lg lh li lj lk la dk translated">我们可以用自己的假CA替换这个“可信”证书的内容。</p></blockquote><figure class="pi pj pk pl pm mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ph"><img src="../Images/c3384673fce55108ceefd23a4921af85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUVQwokmsBNqZuf4rvvqXA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">证书从原始资源中打开并读入应用程序。</figcaption></figure><p id="8edf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用存储为常量的资源ID值，我们可以使用一个简单的命令行来找出它与哪个原始文件相关。一旦我们找到了资源名称，我们就可以定位原始资源，并用我们自己的证书文本替换这个证书文本。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/f7f7f007a0ae11bd4bf0f278999a9d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*hVLcKixXQH6MSb9X0pZ8QQ.png"/></div></figure><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi po"><img src="../Images/06b59f866da764d322f7cefd9d46bd8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*4VcvORtOzkbzEyY9E9tLgw.png"/></div></figure><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/4863da53e0515c23c743e7cde43a102f.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*9X4N-x4iaXEcE9PSdflX4A.png"/></div></figure><blockquote class="pq pr ps"><p id="3502" class="kf kg nx kh b ki kj jr kk kl km ju kn pt kp kq kr pu kt ku kv pv kx ky kz la ij bi translated">这里需要注意的是，证书可能会被调用。cer，但实际上是Base64编码的DER，也称为PEM而不是证书的原始二进制形式(DER或CER)。</p></blockquote><p id="53f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在原始二进制证书、<em class="nx"> cer </em>和<em class="nx"> der </em>之间转换成Base64编码证书、<em class="nx"> crt </em>或<em class="nx"> pem </em>，我们可以使用OpenSSL。一旦格式正确，我们就可以覆盖现有的证书。</p><pre class="mq mr ms mt gt ny nz oa ob aw oc bi"><span id="3711" class="nl lt iq nz b gy od oe l of og">openssl x509 -in proxyCert.der -inform DER -out proxyCertConvert.pem</span></pre><p id="818a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们有对我们的证书和真实代码的真实引用，所以我们需要做的就是调整smali的原始逻辑。我们只关心我们的证书被加载，我们可以忽略其他的。</p><ul class=""><li id="8e15" class="oi oj iq kh b ki kj kl km ko ok ks ol kw om la on oo op oq bi translated">我们的证书已经被打开并读入<em class="nx">InputStream</em><strong class="kh ir">v 0</strong>-389行</li><li id="b3e9" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated">使用<em class="nx"> CertificateFactory </em>方法<em class="nx"> generateCertificate </em>()生成证书，并将其移动到<strong class="kh ir">V5</strong>-390–392行</li><li id="af63" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated">将我们生成的证书<strong class="kh ir">，v5 </strong>添加到我们的<strong class="kh ir">证书</strong>列表，<strong class="kh ir">v2</strong>-第395行</li><li id="eda5" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated">关闭原来的<em class="nx">输入流</em> -行398</li><li id="2ef4" class="oi oj iq kh b ki or kl os ko ot ks ou kw ov la on oo op oq bi translated">将证书列表返回给调用方法-第400行。smali代码的其余部分在此之后继续，但是因为我们已经返回了我们的<strong class="kh ir"> certificates </strong> List对象，所以它变成了不可访问的代码。</li></ul><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi pw"><img src="../Images/f3653fba848be885fa37e56c6245d498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnc3ciJzgyTStvUCOX7lQw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">在只添加了假证书后返回证书列表，忽略其余的。</figcaption></figure><p id="c0cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在返回之前，应用程序将只读取包含我们修改内容的证书；文件名保持不变，我们只是交换了文本。由于它是隐式信任的，应用程序继续正常通信，同时由于接受我们的CA而通过我们的代理工具传递一切。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="aafa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经详细介绍了如何绕过证书锁定的不同实现的两个示例，这两个示例都在如何实现保护方面存在错误，但是显示了攻击者如何能够利用最小的缺陷来进一步进入系统并调查API调用。</p><p id="f747" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个示例演示了一种方法，其中信任链是隐式信任的，除了传递给该方法的内容之外，没有进一步的验证。没有错误处理或检查返回的内容，从而允许无效的返回调用。</p><p id="2483" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二种是在应用程序包中使用存储的应用程序证书，因为移动应用程序在恶意用户的个人设备上，这从来都不是一个好主意；因为正如所演示的，这些可以用完全不同的东西来替换，以利用代码的弱点。</p><p id="b03d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果使用正确，证书锁定是保护后端服务器以及客户端-服务器请求和响应中传递的通信的一种广泛方式。然而，不应完全依赖它，也不应将其用作接受API上不安全开发实践的理由，而是用作移动应用程序网络安全分层方法的一部分。</p></div></div>    
</body>
</html>