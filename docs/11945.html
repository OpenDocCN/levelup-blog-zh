<html>
<head>
<title>Typescript+Hapi+BullMQ === Elegant Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">typescript+哈比神+BullMQ ===优雅队列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-hapi-bullmq-elegant-queue-a41ddc2e4c3d?source=collection_archive---------3-----------------------#2022-05-02">https://levelup.gitconnected.com/typescript-hapi-bullmq-elegant-queue-a41ddc2e4c3d?source=collection_archive---------3-----------------------#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="07ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我引起你的注意了吗？我必须承认，也许“优雅的队列”有点夸张，但不管怎样，这是一个简单的队列。让我们直接进入它。</p><p id="bab1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated"><span class="l km kn ko bm kp kq kr ks kt di"> H </span>情况是这样的。当一个用户在你价值十亿美元的平台上注册时，你必须给他们发一封欢迎电子邮件，并附上优惠券代码，让他们在你这个神奇的网站上消费！让我们从头开始构建电子邮件发送服务，它将对作业进行排队，这样用户就不必在帐户注册期间等待。</p></div><div class="ab cl ku kv hu kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ij ik il im in"><p id="f849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始编码之前，让我们先安装所有必要的包。首先，创建一个新文件夹。我把我的文件夹命名为‘hapi-bull MQ’(感谢我的创造性思维！)，您应该选择自己的文件夹名称。然后进入该文件夹并运行npm init -y。这将创建一个package.json文件</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/59737856ca6084a4e8be28122e1033e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4vdG4ECjT0JQlrWBHcXcQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">创建一个文件夹，并在该文件夹中运行npm init</figcaption></figure><p id="ff45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在打开package.json文件，更新main和scripts部分，如下所示，</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/905c2d332dddbb58c841f7e43707b9f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bU9qE8dE1s9BhvMOV-_jKA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">package.json</figcaption></figure><p id="c89e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，运行以下命令来安装所有必需的节点模块及其依赖项</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lr"><img src="../Images/f138952ce1931c1f722de4dbd65da8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a2To7xXDF8mY3sSbe7pqQw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">npm安装命令</figcaption></figure><p id="6c22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们使用typescript，所以为了构建解决方案，我们需要tsconfig.json文件。您可以通过运行<code class="fe ls lt lu lv b">tsc --init</code>或手动创建来生成一个。相应地更新这些值</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lw"><img src="../Images/0fabe51ba74f9e3653a62ff2c8eb50e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUrYPa0wVFLoVmB1EbtRuw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">tsconfig.json</figcaption></figure><p id="b6c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将环境价值保持在。环境文件。所以让我们创造一个，</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/a0b81709f12540aedc890847579ddeda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SeuRGPdja0-_EaGZ5-U7Q.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">。包封/包围（动词envelop的简写）</figcaption></figure><p id="aeee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个解决方案使用<a class="ae lx" href="https://docs.bullmq.io/" rel="noopener ugc nofollow" target="_blank"> BullMQ </a>来构建队列。它是一个<a class="ae lx" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank"> Node.js </a>库，实现了一个构建在<a class="ae lx" href="https://redis.io" rel="noopener ugc nofollow" target="_blank"> Redis </a>之上的快速且健壮的队列系统。我将推荐每个人通读文档。</p><p id="7d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经使用Docker Compose在我的本地机器上安装了Redis。这是我的docker-compose文件的样子。您可以按照自己的方式安装Redis。但是，您需要更新。相应的env文件。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ly"><img src="../Images/5c03319addd72c9cf79303a84a962b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYAJS0Vbq6j5pguOSpqoTA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">docker-compose.yml</figcaption></figure><p id="e2e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经完成了设置部分，所以让我们开始编码。首先，创建一个src文件夹，所有的typescript文件都将存放在这个文件夹中。在src文件夹中，创建一个名为<strong class="jp ir"> queue </strong>的新文件夹，我们在其中保存所有与队列相关的代码，以及一个<strong class="jp ir"> utils </strong>文件夹，我们将在其中保存所有必要的小代码片段。</p><p id="8c31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们都同意，console.log是一个很好的日志工具。然而，对于后端系统，我更喜欢在中使用p <a class="ae lx" href="https://getpino.io/" rel="noopener ugc nofollow" target="_blank">。js，并将在这个项目中使用它。这是设置的样子。</a></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lz"><img src="../Images/7d454a9342d7b1d2e16211baf03bd025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-2METFHwUs7SvOweq6iPQA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">src/utils/logger.ts</figcaption></figure><p id="df12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们将所有与BullMQ和队列相关的配置保存在一个文件中，该文件位于<strong class="jp ir">队列</strong>文件夹中</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ma"><img src="../Images/fde0ee84d63b4383a07d882a4af5066c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRyJ6d7Xgrs5Wm9FhLlxdw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">src/queue/配置. ts</figcaption></figure><p id="53b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们系统中创造的所有工作岗位都遵循一个标准，这一点非常重要。这样，当worker系统处理作业时，它知道如何继续并相应地处理错误。因此，让我们创建一个工作蓝图。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mb"><img src="../Images/11e6c9e7212d9f48fc261c9df8e0cb5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7l0IcayKiQN-JHI-NxYo-Q.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">src/queue/jobs/job . definition . ts</figcaption></figure><p id="4613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了每个工作展示的定义，让我们创建一个欢迎电子邮件工作。每个作业都必须扩展<strong class="jp ir"> BaseJob </strong>类并实现<strong class="jp ir"> JobImp </strong>接口。这一部分至关重要，因为我们将在后面看到它是如何帮助工人的。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mc"><img src="../Images/c47853218f3727d6c8d7d3e99f049e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1E9OxW_MBpnajFyoJZz2g.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">src/queue/jobs/welcome-email . job . ts</figcaption></figure><p id="0816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当worker从Redis队列表中选择作业时，它不知道它是什么作业实例。因此，为了帮助工人解决这个问题，我实现了一个提供者，它跟踪我们系统中的所有作业。任何新创建的工作<strong class="jp ir">必须</strong>映射到这里。您可以在第6行看到，我是如何在provider.ts文件中注册WelcomeEmail作业类的</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mc"><img src="../Images/3137b534ab486880407595ec05deff36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BTEPglC9t5053hdhOh8ilw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">src/queue/jobs/provider.ts</figcaption></figure><p id="69f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到，为了在provider.ts文件中导入WelcomeEmail类，我没有调用完整的路径。如果你不知道诀窍，我已经使用了汇总出口的方法。只需在jobs文件夹中创建一个index.ts文件，然后导出所有作业类，如下所示</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi md"><img src="../Images/0919943a2392fb5bbf286d0ce98f0c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5qJUBZ_cu8MzBj0VRu7pA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">src/queue/作业/索引. ts</figcaption></figure><p id="e711" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经定义了“WelcomeEmail”工作。现在我们需要一个会处理这项工作的工人。让我们创建默认工人。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ma"><img src="../Images/c2f2760e1d2bbfe7ea19f006691c52b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdgUweskTZLlOhqBKWc5lA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">src/queue/worker.ts</figcaption></figure><p id="bb7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个工人独自一人什么也做不了。除非QueueScheduler帮助编排和管理队列的工作线程，否则这是没有用的。下面的代码创建了一个名为“default-queue”的队列，并为defaultQueue设置了一个调度器(如果没有将队列名作为函数参数传递的话)。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi me"><img src="../Images/2585274560d25765e4badf6251e683b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXqw7YQQJDR7l2fcwypRrA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">src/queue/queue.ts</figcaption></figure><p id="b221" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，是时候把所有东西放在一起了。在<strong class="jp ir"> src </strong>文件夹下创建一个<strong class="jp ir"> main.ts </strong>文件，并遵循下面的代码。代码可能看起来很复杂，但它做了三件事。首先，它使用<a class="ae lx" href="https://hapi.dev/" rel="noopener ugc nofollow" target="_blank">哈比神</a>启动一个Http服务器，然后设置<strong class="jp ir">队列</strong>，最后启动服务器。我想在第36到50行引起你的注意。<strong class="jp ir"> /register </strong> api调用负责将WelcomeEmail作业添加到队列中。这里，我为新创建的作业创建了一个唯一的名称。你可以给任何你想传的名字。对我来说，我想给每一份新的WelcomeEmail工作起一个独特的名字。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mf"><img src="../Images/0e9fe9c92d42eee24175c40bd412993b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRQ3MoJMVeQPoyVtQtV3VA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">src/main.ts</figcaption></figure><p id="227d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在是关键时刻了。按照所有的说明，这将工作或它是一个没有汉堡教程。</p><blockquote class="mg mh mi"><p id="77db" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">让我们运行npm运行dev，shell we。。。</p></blockquote></div></div>    
</body>
</html>