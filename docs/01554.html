<html>
<head>
<title>Flow Text Animation in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的流动文本动画</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flowtextmodifier-in-swiftui-using-a-custom-viewmodifier-887e48f0aece?source=collection_archive---------10-----------------------#2020-01-12">https://levelup.gitconnected.com/flowtextmodifier-in-swiftui-using-a-custom-viewmodifier-887e48f0aece?source=collection_archive---------10-----------------------#2020-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e76d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让-马克·布里安内</h2></div><p id="fa0e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速浏览一下我们今天要创建的内容。在本教程结束时，您将能够使用自定义的<code class="fe le lf lg lh b">ViewModifier</code>为SwiftUI应用程序中的任何文本添加这种“流动”效果。下面是一个例子。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="30de" class="lq lr it lh b gy ls lt l lu lv">Text("FlowTextModifier")<br/>    .modifier(FlowTextModifier(background: Image("TestImage")))</span></pre><p id="e5e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就这么简单！</p><p id="b7e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开始之前，请考虑使用<a class="ae lw" href="https://trailingclosure.com/signup/" rel="noopener ugc nofollow" target="_blank">这个链接</a>订阅，如果你没有在<a class="ae lw" href="https://trailingclosure.com/" rel="noopener ugc nofollow" target="_blank">TrailingClosure.com</a>上阅读这篇文章，请随时来看看我们。</p><figure class="li lj lk ll gt ly gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/1247424979c1c397bb14f5bc2ee7b6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*bsb6tHOg6sZIbdVo.gif"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">看看我们今天将创造什么</figcaption></figure><h2 id="8fdd" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">入门指南</h2><p id="1f8b" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">对于本教程，我们将只创建一个文件，所以请随意在当前项目或本教程的新项目中进行测试。</p><p id="a963" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，创建一个名为<code class="fe le lf lg lh b">FlowTextModifier</code>的新类，并确保它继承自<code class="fe le lf lg lh b">ViewModifier</code>类。还要确保实现<code class="fe le lf lg lh b">body</code>函数，并像现在一样返回<code class="fe le lf lg lh b">content</code>。</p><blockquote class="nb nc nd"><p id="cb6f" class="ki kj ne kk b kl km ju kn ko kp jx kq nf ks kt ku ng kw kx ky nh la lb lc ld im bi translated">关于<code class="fe le lf lg lh b">ViewModifier</code>类的更多信息，请点击查看苹果开发者文档<a class="ae lw" href="https://developer.apple.com/documentation/swiftui/viewmodifier" rel="noopener ugc nofollow" target="_blank">。它实际上是接受原始视图或内容，使用修饰符对其进行修改，然后返回修改后的内容。</a></p></blockquote><p id="a91d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们目前应该有的:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="2217" class="lq lr it lh b gy ls lt l lu lv">public struct FlowTextModifier: ViewModifier {<br/><br/>    public func body(content: Content) -&gt; some View {<br/>        content<br/>    }<br/><br/>}</span></pre><p id="4396" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe le lf lg lh b">ViewModifier</code>的工作方式是，我们将为它提供一个背景<code class="fe le lf lg lh b">Image</code>，它将在<code class="fe le lf lg lh b">content</code>的顶部从左向右移动。这将给它流动的动画。然后，为了确保我们保留传入的<code class="fe le lf lg lh b">content</code>的可见性，我们将屏蔽这个图像。</p><figure class="li lj lk ll gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/d293a539b345aba5ce7eeca6886e817f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pMgIIh2TLvTt3Wn3.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">“内容”上方的背景图像被遮罩。</figcaption></figure><p id="26c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们屏蔽一个<code class="fe le lf lg lh b">Image</code>之前，我们需要创建一个。因此，为<code class="fe le lf lg lh b">FlowTextModifier</code>创建一个<code class="fe le lf lg lh b">init</code>函数，并让它接收一个<code class="fe le lf lg lh b">Image</code>作为参数。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="1418" class="lq lr it lh b gy ls lt l lu lv">var image:Image<br/><br/>init(background: Image) {<br/>    self.image = background<br/>}</span></pre><h2 id="2562" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">修改<code class="fe le lf lg lh b">content</code></h2><p id="f407" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">我们将添加这个现在蒙版(在这个例子中非常丰富多彩)的图像作为叠加。让我们开始吧。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3606" class="lq lr it lh b gy ls lt l lu lv">public func body(content: Content) -&gt; some View {<br/>    content<br/>        .overlay(<br/>            // Masked Content Here<br/>        )<br/>}</span></pre><p id="ac24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将添加一个<code class="fe le lf lg lh b">GeometryReader</code>作为覆盖图中的根<code class="fe le lf lg lh b">View</code>。这将有助于我们稍后计算覆盖的移动...</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="1f81" class="lq lr it lh b gy ls lt l lu lv">public func body(content: Content) -&gt; some View {<br/>    content<br/>        .overlay(<br/>            GeometryReader { geo in<br/>                // Masked Content Here<br/>            }<br/>        )<br/>}</span></pre><p id="a037" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后包括我们之前定义的<code class="fe le lf lg lh b">image</code>。我们做这个<code class="fe le lf lg lh b">resizable()</code>是为了随着<code class="fe le lf lg lh b">content</code>的传入而成长。此外，我们已经用传入的<code class="fe le lf lg lh b">content</code>屏蔽了图像。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3867" class="lq lr it lh b gy ls lt l lu lv">public func body(content: Content) -&gt; some View {<br/>    content<br/>        .overlay(<br/>            GeometryReader { geo in<br/>                // Masked Content Here<br/>                self.image()<br/>                    .resizable()<br/>                    .mask(content)<br/>            }<br/>        )<br/>}</span></pre><h2 id="2918" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">运行这段代码会给我们…</h2><figure class="li lj lk ll gt ly gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/80d7a1f7bed1cd52bcd04d9b20717d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*eo7tcp3onMXogqai.png"/></div></figure><h2 id="c293" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">如果你想在你的模拟器上试一试，就使用这个代码和图片吧！</h2><p id="8895" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">该图像只是我为了测试的目的用草图做出来的。请随意使用您喜欢的任何图像:)</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="f0ef" class="lq lr it lh b gy ls lt l lu lv">import SwiftUI<br/><br/>struct FlowTextTest: View {<br/>    var body: some View {<br/>        Text("FlowTextModifier")<br/>        .font(Font.system(size: 45, weight: .bold, design: .rounded))<br/>        .modifier(FlowTextModifier(background: Image("FlowTextTestBackground")))<br/>    }<br/>}</span></pre><figure class="li lj lk ll gt ly gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e0db5c8e976dd06e7512e22ef16b2864.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*lfouRfkYq4joIgaG.png"/></div></figure><h2 id="3193" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">制作文本动画</h2><p id="6f60" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">接下来，我们将开始制作背景动画。我们要做的是创建一个计时器，每秒触发一次，改变图像的<code class="fe le lf lg lh b">offset</code>。</p><h2 id="e4a5" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">修改图像偏移</h2><p id="44d6" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">为了跟踪偏移量，我们需要创建一个<code class="fe le lf lg lh b">@State</code>变量来跟踪它。在定义了<code class="fe le lf lg lh b">image</code>变量的地方，继续为<code class="fe le lf lg lh b">offset</code>添加一个变量。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="8372" class="lq lr it lh b gy ls lt l lu lv">public struct FlowTextModifier: ViewModifier {<br/>    <br/>    var image:Image<br/>    @State var offset:CGPoint = .zero<br/>    <br/>    // Rest of the class...<br/>    <br/>}</span></pre><p id="1005" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后更新我们的图像来使用这个新的偏移…</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="e7a4" class="lq lr it lh b gy ls lt l lu lv">public func body(content: Content) -&gt; some View {<br/>    content<br/>        .overlay(<br/>            GeometryReader { geo in<br/>                // Masked Content Here<br/>                self.image()<br/>                    .resizable()<br/>                    .offset(x: self.offset.x, y: self.offset.y)<br/>                    .mask(content)<br/>            }<br/>        )<br/>}</span></pre><h2 id="b9aa" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">创建计时器</h2><p id="52c4" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">现在在类的顶部添加计时器。这将每秒发布更新，然后我们将使用它来改变我们的<code class="fe le lf lg lh b">image</code>的偏移量。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="18cf" class="lq lr it lh b gy ls lt l lu lv">public struct FlowTextModifier: ViewModifier {<br/>    <br/>    var image:Image<br/>    @State var offset:CGPoint = .zero<br/>    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()<br/><br/>    // Rest of the class...<br/>    <br/>}</span></pre><p id="e437" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在通过编辑你的图像代码来接收你身体内部的更新。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="0acf" class="lq lr it lh b gy ls lt l lu lv">public func body(content: Content) -&gt; some View {<br/>    content<br/>        .overlay(<br/>            GeometryReader { geo in<br/>                // Masked Content Here<br/>                self.image()<br/>                    .resizable()<br/>                    .offset(x: self.offset.x, y: self.offset.y)<br/>                    .mask(content)<br/>                    .onReceive(self.timer) { _ in<br/>                        // Update offset here<br/>                    }<br/>            }<br/>        )<br/>}</span></pre><h2 id="799f" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">计算偏移</h2><p id="d3ae" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">为了更容易计算偏移量，我们将创建一个函数，每次触发<code class="fe le lf lg lh b">Timer</code>时都会调用这个函数。我的看起来像这样。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="b712" class="lq lr it lh b gy ls lt l lu lv">func getNextOffset(size: CGSize, offset: CGPoint) -&gt; CGPoint {<br/>    var nextOffset = offset<br/><br/>    if nextOffset.x + (size.width / 10.0) &gt; size.width {<br/>        nextOffset.x = 0<br/>    } else {<br/>        nextOffset.x += size.width / 10.0<br/>    }<br/>    return nextOffset<br/>}</span></pre><p id="acba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它通过<code class="fe le lf lg lh b">GeometryReader</code>接收<code class="fe le lf lg lh b">content</code>的大小以及当前偏移量。然后，它将下一个偏移量推进视图宽度的1/10。您可以根据自己的喜好进行修改:)</p><blockquote class="nb nc nd"><p id="5e6c" class="ki kj ne kk b kl km ju kn ko kp jx kq nf ks kt ku ng kw kx ky nh la lb lc ld im bi translated">如果你的读者想修改你的动画的速度，方向等，这里是一个好地方。在测试时，我创建了自己的<code class="fe le lf lg lh b">FlowAnimationType</code> enum来玩其他动画。这个代码可以很容易地扩展，以支持垂直移动，以及任何其他类型的路径，你希望你的图像采取。</p></blockquote><h2 id="f5bd" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">使用<code class="fe le lf lg lh b">getNextOffset</code>功能</h2><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="85eb" class="lq lr it lh b gy ls lt l lu lv">public func body(content: Content) -&gt; some View {<br/>    content<br/>        .overlay(<br/>            GeometryReader { geo in<br/>                // Masked Content Here<br/>                self.image()<br/>                    .resizable()<br/>                    .offset(x: self.offset.x, y: self.offset.y)<br/>                    .mask(content)<br/>                    .onReceive(self.timer) { _ in<br/>                        // Update offset here<br/>                        let newOffset = self.getNextOffset(size: geo.size, offset: self.offset)<br/>                            <br/>                        if newOffset == .zero {<br/>                            self.offset = newOffset<br/>                            withAnimation(.linear(duration: 1)) {<br/>                                self.offset = self.getNextOffset(size: geo.size, offset: newOffset)<br/>                            }<br/>                        } else {<br/>                            withAnimation(.linear(duration: 1)) {<br/>                                self.offset = newOffset<br/>                            }<br/>                        }<br/>                    }<br/>            }<br/>        )<br/>}</span></pre><p id="2cbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们很快过一遍。在第一部分，我使用我们的<code class="fe le lf lg lh b">getNextOffset</code>函数获取新的偏移量。然后我们决定下一个偏移是否在<code class="fe le lf lg lh b">zero</code>。我们这样做是为了让我们可以选择是否动画化这个变化。如果你能想象当图像移动并到达内容的末尾时，它将需要快速回到开头来重放。我们不想将这种变化制作成动画，因为这样看起来就像动画在反过来播放。因此，我们在第一个<code class="fe le lf lg lh b">if</code>案例中将偏移量设置为<code class="fe le lf lg lh b">.zero</code>，然后获取下一个偏移量来继续动画。<code class="fe le lf lg lh b">else</code>的情况是简单的所有其他时候，当图像正在移动，将动画正常。</p><h2 id="44a6" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">测试我们目前所拥有的…</h2><p id="ed08" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">继续运行您的项目，查看我们的流动文本…</p><figure class="li lj lk ll gt ly gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/ab5b298ef934982bd1bfc66b056902e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*retJoNHcgnR1ILwJ.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">啊哦…</figcaption></figure><p id="50b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来我们就要成功了，但是有些事情不太对劲。我们的图像是动态的，但是，当它离开视图时，它会显示下面的文本。这是一个简单的修复方法。</p><h2 id="d60f" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">添加一份<code class="fe le lf lg lh b">Image</code></h2><p id="4ee3" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">用一个<code class="fe le lf lg lh b">ZStack</code>把你的图像包起来，然后在我们的原始图像上面放一个图像的副本。然后，我们将添加一个遮罩，并使其大小可调，就像第一个一样，只是我们不会使用完全相同的偏移量。我们将使它按照我们内容的宽度跟踪原始图像。代码见下文。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="7998" class="lq lr it lh b gy ls lt l lu lv">public func body(content: Content) -&gt; some View {<br/>    content<br/>        .overlay(<br/>            GeometryReader { geo in<br/>                ZStack(alignment: .center) {<br/>                    self.image<br/>                        .resizable()<br/>                        .offset(x: self.offset.x - geo.size.width, y: self.offset.y)<br/>                        .mask(content)<br/>                    self.image<br/>                        .resizable()<br/>                        .offset(x: self.offset.x, y: self.offset.y)<br/>                        .mask(content)<br/>                        .onReceive(self.timer) { _ in<br/>                            // Update Offset here<br/>                            let newOffset = self.getNextOffset(size: geo.size, offset: self.offset)<br/><br/>                            if newOffset == .zero {<br/>                                self.offset = newOffset<br/>                                withAnimation(.linear(duration: 1)) {<br/>                                    self.offset = self.getNextOffset(size: geo.size, offset: newOffset)<br/>                                }<br/>                            } else {<br/>                                withAnimation(.linear(duration: 1)) {<br/>                                    self.offset = newOffset<br/>                                }<br/>                            }<br/>                        }<br/>                }<br/>            }<br/>        )<br/>}</span></pre><h2 id="2497" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">有用！</h2><p id="6d97" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">现在你可以随意摆弄它，尝试不同的背景、文本或视图！</p><h2 id="d464" class="lq lr it bd mf mg mh dn mi mj mk dp ml kr mm mn mo kv mp mq mr kz ms mt mu mv bi translated">支持未来的帖子</h2><p id="7dc5" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">如果你喜欢这篇文章，请考虑使用<a class="ae lw" href="https://trailingclosure.com/signup/" rel="noopener ugc nofollow" target="_blank">这个链接</a>订阅我的网站，如果你没有在<a class="ae lw" href="https://trailingclosure.com/" rel="noopener ugc nofollow" target="_blank">TrailingClosure.com</a>上阅读这篇文章，请随时来看看我们！</p></div></div>    
</body>
</html>