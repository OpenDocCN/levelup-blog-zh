<html>
<head>
<title>Trace you Replicated cross-region data using AMQ Streams Mirror Maker and Jaeger operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AMQ流镜像制造商和耶格运营商跟踪您复制跨区域数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/trace-you-replicated-cross-region-data-using-amq-streams-mirror-maker-and-jaeger-operators-d1c63a9c251?source=collection_archive---------8-----------------------#2020-07-06">https://levelup.gitconnected.com/trace-you-replicated-cross-region-data-using-amq-streams-mirror-maker-and-jaeger-operators-d1c63a9c251?source=collection_archive---------8-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/ab2fddad16c90f1861833fb47bc3b2d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*YL2g1za-gXqzVbPMOSDafw.png"/></div></figure><p id="6e3e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着Apache Kafka的大量采用，企业正在寻找一种跨不同站点复制数据的方法。Kafka本身有自己的内部复制和自我修复机制，这些机制只与本地集群相关，不能容忍整个站点的故障。这个问题的解决方案是“镜像制作”功能，通过这个功能，您的本地Kafka集群可以异步复制到位于完全不同位置的不同外部/中央Kafka集群，以便持久化您的数据管道、日志收集和指标收集流程。</p><p id="9d0a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“镜像制造者”连接两个集群，因为其中一个是消费者集群，另一个是生产者集群。主题作为一个逻辑实体被复制，它们存储的所有内容都被复制到目标集群中，应用程序可以在目标集群中使用正在传输的数据。镜像生成器可以水平扩展，这意味着当它成为瓶颈时可以向外扩展。</p><p id="3b13" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我们将使用AMQ流操作符在一个扩展的Openshift集群上部署Kafka(其中的节点位于不同的站点上)，并且我们将使用“Mirror Maker”特性将正在写入源集群的所有消息镜像到目标集群中。此外，我们将使用OCS RBD来保存Kafka logDirs，以了解OCS是拓扑无关的，并且可以为同一集群中不同区域的节点提供服务。</p><p id="bcf3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们将使用Jaeger跟踪整个管道的响应时间，在这里我们可以看到复制管道中每个组件的响应时间。</p><p id="d968" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">游戏开始。</p><h1 id="1bd9" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">先决条件</h1><ul class=""><li id="5b5b" class="lq lr iq jw b jx ls kb lt kf lu kj lv kn lw kr lx ly lz ma bi translated">扩展的Openshift 4.4.6集群</li><li id="9260" class="lq lr iq jw b jx mb kb mc kf md kj me kn mf kr lx ly lz ma bi translated">充当存储平台的OCS 4.4集群</li><li id="eb81" class="lq lr iq jw b jx mb kb mc kf md kj me kn mf kr lx ly lz ma bi translated">OCS RBD作为默认存储类别</li></ul><p id="b372" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们首先为这个演示创建一个新项目:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="9708" class="mp kt iq ml b gy mq mr l ms mt">$ oc new-project amq-streams</span></pre><p id="95ad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们设置好项目之后，让我们在<code class="fe mu mv mw ml b">amq-streams</code>项目中安装AMQ操作符和耶格操作符来观察所有的集群名称空间:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/9266d1fb421b749dac66dc4ac4e44f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlGU9BpP4jMIJbDaNwMldg.png"/></div></div></figure><p id="5c95" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们已经安装了操作员，我们可以开始创建一些定制资源来部署我们的环境。首先，让我们创建两个集群，其中<code class="fe mu mv mw ml b">europe-cluster</code>是源集群，<code class="fe mu mv mw ml b">us-cluster</code>是目标集群。每个集群都将使用OCS RBD来保存其写入的数据。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="7019" class="mp kt iq ml b gy mq mr l ms mt">$ oc create -f - &lt;&lt;EOF<br/>apiVersion: kafka.strimzi.io/v1beta1<br/>kind: Kafka<br/>metadata:<br/>  name: europe-cluster<br/>spec:<br/>  kafka:<br/>    version: 2.4.0<br/>    replicas: 3<br/>    listeners:<br/>      plain: {}<br/>      tls: {}<br/>    config:<br/>      offsets.topic.replication.factor: 3<br/>      transaction.state.log.replication.factor: 3<br/>      transaction.state.log.min.isr: 2<br/>      log.message.format.version: "2.4"<br/>    storage:<br/>      type: persistent-claim<br/>      size: 20Gi<br/>      deleteClaim: true<br/>  zookeeper:<br/>    replicas: 3<br/>    storage:<br/>      type: persistent-claim<br/>      size: 10Gi<br/>      deleteClaim: true<br/>  entityOperator:<br/>    topicOperator: {}<br/>    userOperator: {}<br/>---<br/>apiVersion: kafka.strimzi.io/v1beta1<br/>kind: Kafka<br/>metadata:<br/>  name: us-cluster<br/>spec:<br/>  kafka:<br/>    version: 2.4.0<br/>    replicas: 3<br/>    listeners:<br/>      plain: {}<br/>      tls: {}<br/>    config:<br/>      offsets.topic.replication.factor: 3<br/>      transaction.state.log.replication.factor: 3<br/>      transaction.state.log.min.isr: 2<br/>      log.message.format.version: "2.4"<br/>    storage:<br/>      type: persistent-claim<br/>      size: 20Gi<br/>      deleteClaim: true<br/>  zookeeper:<br/>    replicas: 3<br/>    storage:<br/>      type: persistent-claim<br/>      size: 10Gi<br/>      deleteClaim: true<br/>  entityOperator:<br/>    topicOperator: {}<br/>    userOperator: {}<br/>EOF</span></pre><p id="d27c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们验证我们的群集确实已创建，并且他们已从我们的OCS群集申请了所需的存储:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6a33" class="mp kt iq ml b gy mq mr l ms mt">$ oc get pods<br/>                                                                                                                        <br/>NAME                                                  READY   STATUS    RESTARTS   AGE<br/>amq-streams-cluster-operator-v1.5.0-f9dc58f75-bqbm8   1/1     Running   0          3m23s<br/>europe-cluster-entity-operator-5b5f7d44f7-57dbj       3/3     Running   0          37s<br/>europe-cluster-kafka-0                                2/2     Running   0          87s<br/>europe-cluster-kafka-1                                2/2     Running   0          87s<br/>europe-cluster-kafka-2                                2/2     Running   0          87s<br/>europe-cluster-zookeeper-0                            1/1     Running   0          2m29s<br/>europe-cluster-zookeeper-1                            1/1     Running   0          2m29s<br/>europe-cluster-zookeeper-2                            1/1     Running   0          2m29s<br/>us-cluster-entity-operator-84fbbf445f-k5kjz           3/3     Running   0          35s<br/>us-cluster-kafka-0                                    2/2     Running   0          95s<br/>us-cluster-kafka-1                                    2/2     Running   0          95s<br/>us-cluster-kafka-2                                    2/2     Running   0          95s<br/>us-cluster-zookeeper-0                                1/1     Running   0          2m29s<br/>us-cluster-zookeeper-1                                1/1     Running   0          2m29s<br/>us-cluster-zookeeper-2                                1/1     Running   0          2m29s</span></pre></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><pre class="mk ml mm mn aw mo bi"><span id="8032" class="mp kt iq ml b gy nj nk nl nm nn mr l ms mt">$ oc get pvc                                                                                                                         <br/>NAME                              STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS                  AGE<br/>data-europe-cluster-kafka-0       Bound    pvc-c8a7da6c-ca61-4a4f-b26b-d2a3e6ec5f37   20Gi       RWO            ocs-storagecluster-ceph-rbd   2m8s<br/>data-europe-cluster-kafka-1       Bound    pvc-80ecaf91-cfbf-48d6-a37a-86c0737d2f06   20Gi       RWO            ocs-storagecluster-ceph-rbd   2m8s<br/>data-europe-cluster-kafka-2       Bound    pvc-6cb0e5ec-1362-40be-8dbc-b9e1c5265804   20Gi       RWO            ocs-storagecluster-ceph-rbd   2m8s<br/>data-europe-cluster-zookeeper-0   Bound    pvc-7993c0e1-1e2c-4c8f-ad34-51aaa104e6a8   10Gi       RWO            ocs-storagecluster-ceph-rbd   3m11s<br/>data-europe-cluster-zookeeper-1   Bound    pvc-ac0aab81-9f54-45d2-b88d-ff9fcaf9f9d9   10Gi       RWO            ocs-storagecluster-ceph-rbd   3m10s<br/>data-europe-cluster-zookeeper-2   Bound    pvc-5eb69362-a9c5-4248-bb15-253c0fa00c81   10Gi       RWO            ocs-storagecluster-ceph-rbd   3m10s<br/>data-us-cluster-kafka-0           Bound    pvc-2b854633-b6f9-48ac-84d5-487e439f44d9   20Gi       RWO            ocs-storagecluster-ceph-rbd   2m16s<br/>data-us-cluster-kafka-1           Bound    pvc-a1f62aa1-5718-47e9-831a-8a87515dcd0e   20Gi       RWO            ocs-storagecluster-ceph-rbd   2m16s<br/>data-us-cluster-kafka-2           Bound    pvc-deb520d1-e822-4954-80f9-126fd95f09d2   20Gi       RWO            ocs-storagecluster-ceph-rbd   2m16s<br/>data-us-cluster-zookeeper-0       Bound    pvc-6ca9d388-a037-471b-9e24-2d98d9125b33   10Gi       RWO            ocs-storagecluster-ceph-rbd   3m11s<br/>data-us-cluster-zookeeper-1       Bound    pvc-56c7cb8e-ac06-4da2-8378-56c3057863fc   10Gi       RWO            ocs-storagecluster-ceph-rbd   3m10s<br/>data-us-cluster-zookeeper-2       Bound    pvc-a99755a8-a3c5-44f2-b9fe-74d0c0a4bd0b   10Gi       RWO            ocs-storagecluster-ceph-rbd   3m10s</span></pre><p id="1e9d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们已经准备好了两个集群，让我们为将来要复制的源集群创建一个主题:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="fb17" class="mp kt iq ml b gy mq mr l ms mt">$ oc create -f - &lt;&lt;EOF<br/>apiVersion: kafka.strimzi.io/v1beta1<br/>kind: KafkaTopic<br/>metadata:<br/>  name: my-topic<br/>  labels:<br/>    strimzi.io/cluster: europe-cluster<br/>spec:<br/>  partitions: 12<br/>  replicas: 3<br/>  config:<br/>    retention.ms: 7200000<br/>    segment.bytes: 1073741824<br/>EOF</span></pre><p id="56d7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个主题有一个指向源集群的<code class="fe mu mv mw ml b">strimzi.io/cluster</code>标签。现在让我们检查这个主题是否确实被创建了:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="22d7" class="mp kt iq ml b gy mq mr l ms mt">$ oc get kt  <br/>                                                                                                                        <br/>NAME       PARTITIONS   REPLICATION FACTOR<br/>my-topic   12           3</span></pre><p id="cc24" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个主题有12个复制因子为3的分区，这意味着每个Kafka节点将是4个分区的主节点，也是8个其他分区的次节点。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="07d0" class="mp kt iq ml b gy mq mr l ms mt">$ oc create -f - &lt;&lt;EOF <br/>apiVersion: kafka.strimzi.io/v1beta1<br/>kind: KafkaUser<br/>metadata:<br/>  name: my-us-user<br/>  labels:<br/>    strimzi.io/cluster: us-cluster<br/>spec:<br/>  authentication:<br/>    type: tls<br/>  authorization:<br/>    type: simple<br/>    acls:<br/>      - resource:<br/>          type: topic<br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Read<br/>        host: "*"<br/>      - resource:<br/>          type: topic<br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Describe<br/>        host: "*"<br/>      - resource:<br/>          type: group<br/>          name: my-group<br/>          patternType: literal<br/>        operation: Read<br/>        host: "*"<br/>      - resource:<br/>          type: topic<br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Write<br/>        host: "*"<br/>      - resource:<br/>          type: topic<br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Create<br/>        host: "*"<br/>      - resource:<br/>          type: topic<br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Describe<br/>        host: "*"<br/>---<br/>apiVersion: kafka.strimzi.io/v1beta1<br/>kind: KafkaUser<br/>metadata:<br/>  name: my-europe-user<br/>  labels:<br/>    strimzi.io/cluster: europe-cluster<br/>spec:<br/>  authentication:<br/>    type: tls<br/>  authorization:<br/>    type: simple<br/>    acls:<br/>      - resource:<br/>          type: topic<br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Read<br/>        host: "*"<br/>      - resource:<br/>          type: topic<br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Describe<br/>        host: "*"<br/>      - resource:<br/>          type: group<br/>          name: my-group<br/>          patternType: literal<br/>        operation: Read<br/>        host: "*"<br/>      - resource:<br/>          type: topic<br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Write<br/>        host: "*"<br/>      - resource:<br/>          type: topic<br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Create<br/>        host: "*"<br/>      - resource:<br/>          type: topic<br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Describe<br/>        host: "*"<br/>EOF</span></pre><p id="d5ff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们验证我们已经使用<code class="fe mu mv mw ml b">KafkaUser</code>自定义资源创建了用户:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="2a6b" class="mp kt iq ml b gy mq mr l ms mt">$ oc get ku   </span><span id="6411" class="mp kt iq ml b gy no mr l ms mt">NAME             AUTHENTICATION   AUTHORIZATION<br/>my-europe-user   tls              simple<br/>my-us-user       tls              simple</span></pre><p id="50bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们看到，我们有两个用户，这两个用户已经创建，稍后将由应用程序使用。在创建了用于认证和授权的用户之后，让我们创建Jaeger实例。Jaeger是一个分布式跟踪工具，它将帮助我们跟踪整个复制过程中的响应时间。我们将创建一个<code class="fe mu mv mw ml b">Jaeger CR</code>，它将监视我们的名称空间，在我们的部署(镜像制造者和生产者/消费者)中，我们将添加requires env变量，以便JAeger可以跟踪这些服务。让我们创建Jaeger实例:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4f37" class="mp kt iq ml b gy mq mr l ms mt">$ oc apply -f - &lt;&lt;EOF <br/>apiVersion: jaegertracing.io/v1<br/>kind: Jaeger<br/>metadata:<br/>  name: my-jaeger<br/>spec:<br/>  strategy: allInOne<br/>  allInOne:<br/>    image: jaegertracing/all-in-one:latest<br/>    options:<br/>      log-level: debug<br/>  storage:<br/>    type: memory<br/>    options:<br/>      memory:<br/>        max-traces: 100000<br/>  ingress:<br/>    enabled: true<br/>  agent:<br/>    strategy: DaemonSet<br/>  annotations:<br/>    scheduler.alpha.kubernetes.io/critical-pod: ""<br/>EOF</span></pre><p id="cec7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个CR也将为Jaeger UI创建一个路径，在那里我们可以找到需要的信息。这个部署应该部署一个带有两个容器的pod，其中一个容器用于Jaeger实例，另一个用于OAuth。</p><p id="75a9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们创建镜像生成器CR，一旦我们将部署消费者和生产者，并且集群将有一些数据，数据将被复制到目标集群(在我们的例子中，是<code class="fe mu mv mw ml b">us-cluster</code>):</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="0903" class="mp kt iq ml b gy mq mr l ms mt">$ oc create -f - &lt;&lt;EOF<br/>apiVersion: kafka.strimzi.io/v1beta1<br/>kind: KafkaMirrorMaker<br/>metadata:<br/>  name: my-mirror-maker<br/>spec:<br/>  replicas: 1<br/>  consumer:<br/>    authentication:<br/>      certificateAndKey:<br/>        certificate: user.crt<br/>        key: user.key<br/>        secretName: my-europe-user<br/>      type: tls<br/>    bootstrapServers: europe-cluster-kafka-bootstrap:9093<br/>    tls:<br/>      trustedCertificates:<br/>      - certificate: ca.crt<br/>        secretName: "europe-cluster-cluster-ca-cert"<br/>    groupId: my-group<br/>  producer:<br/>    authentication:<br/>      certificateAndKey:<br/>        certificate: user.crt<br/>        key: user.key<br/>        secretName: my-us-user<br/>      type: tls<br/>    bootstrapServers: us-cluster-kafka-bootstrap:9093<br/>    tls:<br/>      trustedCertificates:<br/>      - certificate: ca.crt<br/>        secretName: "us-cluster-cluster-ca-cert"<br/>  whitelist: ".*"<br/>  tracing:<br/>    type: jaeger<br/>  template:<br/>    mirrorMakerContainer:<br/>      env:<br/>        - name: JAEGER_SERVICE_NAME<br/>          value: my-mirror-maker<br/>        - name: JAEGER_AGENT_HOST<br/>          value: my-jaeger-agent<br/>        - name: JAEGER_SAMPLER_TYPE<br/>          value: const<br/>        - name: JAEGER_SAMPLER_PARAM<br/>          value: "1"<br/>EOF</span></pre><p id="e3c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，我们告诉镜像创建者哪个集群是源集群，哪个集群是目标集群。我们使用TLS通过创建的证书来保护整个管道中的数据。在底部，你可以看到我们已经给了耶格参数，所以耶格可以为镜子制造商创建跟踪。</p><p id="f634" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们将一些数据写入集群:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="140c" class="mp kt iq ml b gy mq mr l ms mt">$ oc create -f - &lt;&lt;EOF                                                                                                                <br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: hello-world-producer<br/>  name: hello-world-producer<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: hello-world-producer<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: hello-world-producer<br/>    spec:<br/>      containers:<br/>      - name: hello-world-producer<br/>        image: strimzi/hello-world-producer:latest<br/>        env:<br/>          - name: CA_CRT<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: europe-cluster-cluster-ca-cert<br/>                key: ca.crt<br/>          - name: USER_CRT<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: my-europe-user<br/>                key: user.crt<br/>          - name: USER_KEY<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: my-europe-user<br/>                key: user.key<br/>          - name: BOOTSTRAP_SERVERS<br/>            value: europe-cluster-kafka-bootstrap:9093<br/>          - name: TOPIC<br/>            value: my-topic<br/>          - name: DELAY_MS<br/>            value: "1000"<br/>          - name: LOG_LEVEL<br/>            value: "INFO"<br/>          - name: MESSAGE_COUNT<br/>            value: "1000000"<br/>          - name: JAEGER_SERVICE_NAME<br/>            value: hello-world-producer<br/>          - name: JAEGER_AGENT_HOST<br/>            value: my-jaeger-agent<br/>          - name: JAEGER_SAMPLER_TYPE<br/>            value: const<br/>          - name: JAEGER_SAMPLER_PARAM<br/>            value: "1"<br/>EOF</span></pre><p id="d3ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们创建一个生产者，它将数据写入位于<code class="fe mu mv mw ml b">europe-cluster</code>的<code class="fe mu mv mw ml b">my-topic</code>。生产者使用创建的用户来保护使用TLS的数据摄取，我们有Jaeger参数，这样Jaeger也可以跟踪生产者。</p><p id="0f63" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">pod运行后，检查其日志以验证其确实向<code class="fe mu mv mw ml b">europe-cluster</code>写入了消息:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="39f3" class="mp kt iq ml b gy mq mr l ms mt">$ oc logs $(oc get pod -l app=hello-world-producer -o=jsonpath='{.items[0].metadata.name}') -f</span><span id="b222" class="mp kt iq ml b gy no mr l ms mt">2020-07-06 15:15:55 INFO  KafkaProducerExample:35 - Sending messages "Hello world - 1"<br/>2020-07-06 15:15:56 INFO  KafkaProducerExample:35 - Sending messages "Hello world - 2"<br/>2020-07-06 15:15:57 INFO  KafkaProducerExample:35 - Sending messages "Hello world - 3"<br/>2020-07-06 15:15:58 INFO  KafkaProducerExample:35 - Sending messages "Hello world - 4"<br/>2020-07-06 15:15:59 INFO  KafkaProducerExample:35 - Sending messages "Hello world - 5"<br/>2020-07-06 15:16:00 INFO  KafkaProducerExample:35 - Sending messages "Hello world - 6"</span></pre><p id="4130" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们看到源集群收到了消息。现在让我们对消费者做同样的事情，消费者将消费来自目标服务器<code class="fe mu mv mw ml b">us-cluster</code>的消息。让我们创建消费者部署:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="bd34" class="mp kt iq ml b gy mq mr l ms mt">$ oc create -f - &lt;&lt;EOF<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: hello-world-consumer<br/>  name: hello-world-consumer<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: hello-world-consumer<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: hello-world-consumer<br/>    spec:<br/>      containers:<br/>      - name: hello-world-consumer<br/>        image: strimzi/hello-world-consumer:latest<br/>        env:<br/>          - name: CA_CRT<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: us-cluster-cluster-ca-cert<br/>                key: ca.crt<br/>          - name: USER_CRT<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: my-us-user<br/>                key: user.crt<br/>          - name: USER_KEY<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: my-us-user<br/>                key: user.key<br/>          - name: BOOTSTRAP_SERVERS<br/>            value: us-cluster-kafka-bootstrap:9093<br/>          - name: TOPIC<br/>            value: my-topic<br/>          - name: GROUP_ID<br/>            value: my-group<br/>          - name: LOG_LEVEL<br/>            value: "INFO"<br/>          - name: MESSAGE_COUNT<br/>            value: "1000000"<br/>          - name: JAEGER_SERVICE_NAME<br/>            value: hello-world-consumer<br/>          - name: JAEGER_AGENT_HOST<br/>            value: my-jaeger-agent<br/>          - name: JAEGER_SAMPLER_TYPE<br/>            value: const<br/>          - name: JAEGER_SAMPLER_PARAM<br/>            value: "1"<br/>EOF</span></pre><p id="aa59" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">至于生产者，消费者也使用TLS，从它们那里消费<code class="fe mu mv mw ml b">us-cluster</code>并使用Jaeger参数，以便Jaeger可以跟踪它的响应时间。让我们检查它的日志，看看镜像是否工作:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a1de" class="mp kt iq ml b gy mq mr l ms mt">$ oc logs $(oc get pod -l app=hello-world-consumer -o=jsonpath='{.items[0].metadata.name}') -f</span><span id="3bfe" class="mp kt iq ml b gy no mr l ms mt">2020-07-06 15:17:42 INFO  KafkaConsumerExample:43 - Received message:<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:44 - 	partition: 0<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:45 - 	offset: 99<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:46 - 	value: "Hello world - 99"<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:43 - Received message:<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:44 - 	partition: 0<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:45 - 	offset: 100<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:46 - 	value: "Hello world - 100"<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:43 - Received message:<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:44 - 	partition: 0<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:45 - 	offset: 101<br/>2020-07-06 15:17:42 INFO  KafkaConsumerExample:46 - 	value: "Hello world - 101"</span></pre><p id="3001" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是啊！我们在目标集群中有我们的消息，这意味着镜像生成器完成了它的工作:)</p><p id="6caa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们开始跟踪响应时间，看看我们是否有任何性能问题，使用浏览器中的路线打开Jaeger UI:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="718e" class="mp kt iq ml b gy mq mr l ms mt">$ oc get route<br/>                                                                                                           <br/>NAME        HOST/PORT                                    PATH   SERVICES          PORT    TERMINATION   WILDCARD<br/>my-jaeger   my-jaeger-amq-streams.apps.ocp4.ocppaz.com          my-jaeger-query   &lt;all&gt;   reencrypt     None</span></pre><p id="5515" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在主页上，我们可以看到查询，它跟踪消费者服务的响应时间。可以对这些结果进行排序，以查看哪个响应花费的时间最长:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi np"><img src="../Images/2c04ef39e005fe4ad34003800102ebda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZh7Yy7nwR304u7xST14Zw.png"/></div></div></figure><p id="f170" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以单击最高点，获得一个带有响应时间的体系结构视图，在这里我们可以看到整个管道的运行情况:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/730c564510a8507fedd89c1453494d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fez5pAPoqrPN63RodkH0jg.png"/></div></div></figure><h1 id="0b72" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h1><p id="a4ad" class="pw-post-body-paragraph ju jv iq jw b jx ls jz ka kb lt kd ke kf nq kh ki kj nr kl km kn ns kp kq kr ij bi translated">我们看到了如何使用Kafka“Mirror Maker”跨站点复制数据，其中镜像过程将在源集群中创建的主题复制到目标集群。感谢OCS，我们已经为Kafka logDirs附加了PVs，以便使用OCS RBD块存储在本地保存我们的数据。最后，我们跟踪了复制管道从向源集群写入消息的生产者到消费来自目标集群的写入消息的消费者的响应时间，所有这些都是在Openshift容器平台上使用AMQ流操作符完成的。</p><p id="85b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">希望你喜欢这个演示，下次再见:)</p></div></div>    
</body>
</html>