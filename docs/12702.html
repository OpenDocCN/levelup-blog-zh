<html>
<head>
<title>.NET 6 Web API &amp; Entity Framework Core Jumpstart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。NET 6 Web API和实体框架核心快速启动</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/net-6-web-api-entity-framework-core-jumpstart-5c80ad340e97?source=collection_archive---------6-----------------------#2022-07-03">https://levelup.gitconnected.com/net-6-web-api-entity-framework-core-jumpstart-5c80ad340e97?source=collection_archive---------6-----------------------#2022-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6297" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Web API、EF Core和SQL Server Express立即构建. NET 6 web应用程序的后端！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7fe521a12a1bc097797b16ec31bb1ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8z6F-sYxp_EMVltl.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">矢量插图由<a class="ae ky" href="https://www.shutterstock.com/image-vector/rocket-launch-space-concept-flat-design-644386219" rel="noopener ugc nofollow" target="_blank"> practicuum/Shutterstock </a></figcaption></figure><h1 id="4c2a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="6c66" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">。NET变得越来越好，在当今的web开发世界中变得越来越重要。</p><p id="12f6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">几乎我收到的每一个新的web开发项目的请求都是<strong class="lt iu">在寻求知识。NET </strong>，包括Web API和实体框架核心。</p><p id="06d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，了解后端web开发的基础知识。网络对你的职业生涯大有裨益。这就是本系列教程的由来。</p><p id="e532" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在很短的时间内，<strong class="lt iu">将学会如何建立一个Web API </strong>，对这个Web API进行restful调用，并且<strong class="lt iu">用实体框架核心</strong>、<strong class="lt iu">代码优先迁移</strong>、一个<strong class="lt iu"> SQL Server &amp; SQLite数据库</strong>以及这个数据库中所有三种类型的<strong class="lt iu">关系</strong>持久保存数据。</p><p id="0211" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将开门见山，你将看到编写必要代码的每一个步骤，在本课程结束时，你将具备对所有人说<em class="ms">是</em>的能力。来自任何招聘人员的净项目请求。</p><p id="528a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">开始时你唯一需要的工具是<strong class="lt iu"> Visual Studio代码</strong>，它是免费的。</p><p id="3493" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将使用Visual Studio代码来实现，并在Swagger UI的帮助下调用Web API，Swagger UI是一个界面，它允许您使用现成的API，这得益于。NET框架。</p><p id="be1b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Visual Studio代码可用于Windows、Mac OS和Linux。自从。NET框架是跨平台的，你可以在这些操作系统上学习本课程。</p><p id="725c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">稍后，我们将利用免费的<strong class="lt iu"> SQL Server Express </strong>和<strong class="lt iu">SQL Server Management Studio</strong>来管理我们的数据库。我们还将快速浏览一下SQLite，这样你就知道如何使用你想要的任何数据库。</p><p id="7792" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们要构建的后端应用程序是一个小型的<strong class="lt iu">基于文本的角色扮演游戏</strong>，不同的用户可以注册(我们将使用<strong class="lt iu"> JSON web令牌进行身份验证</strong>)并创建他们自己的角色，如法师或骑士，添加一些技能和武器，还可以让角色互相战斗，看看谁是最好的。</p><p id="050a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以，我希望你为你的新技能和新项目做好准备。开始吧！</p><h1 id="73c7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">工具</h1><p id="275e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们现在唯一需要的工具是Visual Studio代码。除此之外，您还必须下载并安装。NET 6 SDK。</p><p id="458d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">VS代码可以在<a class="ae ky" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank">https://code.visualstudio.com/</a>上找到。</p><p id="1930" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">并且SDK可以在<a class="ae ky" href="https://dotnet.microsoft.com/download" rel="noopener ugc nofollow" target="_blank">https://dotnet.microsoft.com/download</a>下载。一定要下载。适用于您的操作系统的. NET 6。</p><h1 id="2118" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">创建新的Web API</h1><p id="25bd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦。NET SDK和Visual Studio代码已安装，我们已经可以创建我们的第一个。NET应用程序，它将很快成为一个Web API。</p><p id="b607" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我为“dotnet角色扮演游戏”创建了一个名为“dotnet-rpg”的新文件夹。在VS代码中打开文件夹。</p><p id="f571" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我假设您已经对Visual Studio代码有点熟悉了，如果还不熟悉，请随便看看。</p><p id="49f5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当你这么做的时候，安装某些扩展可能也是一个好主意。</p><p id="16f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">微软自己的第一个“<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp" rel="noopener ugc nofollow" target="_blank"> C# for Visual Studio代码</a>”。一旦创建了第一个C#应用程序，VS代码也会建议使用这个扩展。它包括编辑支持，语法突出，智能感知，去定义，找到所有的参考，只是看看，非常有用的东西。</p><p id="5996" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来是KreativJos的“<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=kreativ-software.csharpextensions" rel="noopener ugc nofollow" target="_blank"> C#扩展</a>”。正如描述所言，通过向上下文菜单添加一些条目，比如添加一个新的C#类或接口，它可能会加快开发工作流。</p><p id="5024" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后一个已经是我个人的最爱之一了，那就是“<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme" rel="noopener ugc nofollow" target="_blank">材质图标主题</a>”。这个只是提供了很多很多可爱的图标。</p><p id="bf24" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好的，但是现在让我们创建我们的Web API！我们打开一个新的终端窗口，然后让我们看看<code class="fe mt mu mv mw b">dotnet</code>命令提供了什么。</p><p id="dea8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过添加一个<code class="fe mt mu mv mw b">-h</code>，您可以看到所有可用的命令。我们现在感兴趣的是<strong class="lt iu"> new </strong>命令，它创建了一个新的。NET项目。</p><p id="9341" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是我们也得到<code class="fe mt mu mv mw b">run</code>命令来运行我们的应用程序，还有<code class="fe mt mu mv mw b">watch</code>命令，它可以和<code class="fe mt mu mv mw b">run</code>一起使用，一旦我们使用<em class="ms">热重装</em>对任何文件进行更改，就可以重启应用程序。非常有用，如果你不想每次做任何改变的时候都自己停下来重新开始项目的话。</p><p id="84f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过<code class="fe mt mu mv mw b">dotnet new</code>,我们可以看到一些可用的模板。要全部看到，可以输入<code class="fe mt mu mv mw b">dotnet new --list</code>。有很多，我们最终得到了<em class="ms"> Web API </em>。所以还是用起来吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/ac94c5f25ccd484985d85014af7f83e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcqA_iG6IS-xHPrzodBWdQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">可用应用程序模板</figcaption></figure><p id="055f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们输入<code class="fe mt mu mv mw b">dotnet new webapi</code>,然后按回车键。</p><p id="50f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以在浏览器中看到一些已经生成的文件。让我们快速浏览一遍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/c70c2e0c36c8e9419b41afea58cfc6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*k9ITXYBorWEnxkRsLU0vmg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">为Web API生成的文件</figcaption></figure><p id="9c77" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在底部，我们看到了<code class="fe mt mu mv mw b">WeatherForecast</code>类。这只是默认Web API项目的一部分。我们并不真的需要它，但是让我们马上用这个例子。</p><p id="00f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与此同时，我们得到一个小弹出窗口，告诉我们应该添加一些文件。当然，我们希望添加它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/62db89aa6a4116e8982048111cfbf7dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDsr4caBd3dopwS03zfyGA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Pop要求添加一些文件</figcaption></figure><p id="38b8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你现在应该看到，我们得到了带有<code class="fe mt mu mv mw b">launch.json</code>和<code class="fe mt mu mv mw b">tasks.json</code>的<code class="fe mt mu mv mw b">.vscode</code>文件夹。两者都是用于调试的配置文件、源代码格式化程序、捆绑程序等等，但是目前我们对此并不感兴趣。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/9ba07c131516d0781671a1c693f49c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*H-teoBWP_lK4ncMd0tqZVw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">补充道。vscode文件夹</figcaption></figure><p id="f3fa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以我们来看看<code class="fe mt mu mv mw b">Program</code>类。</p><p id="1ab5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms">这是新来的。NET 6。之前我们额外得到了</em> <code class="fe mt mu mv mw b"><em class="ms">Startup</em></code> <em class="ms">类用于配置事宜。现在一切都在</em> <code class="fe mt mu mv mw b"><em class="ms">Program.cs</em></code> <em class="ms">中处理。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Program.cs of。网络6</figcaption></figure><p id="6c43" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，在这里，我们配置应用程序的服务，这是一个提供应用程序功能的可重用组件。</p><p id="263a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将来会在这里注册服务，这样就可以通过<em class="ms">依赖注入</em>在我们的web服务中使用它们。</p><p id="5563" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请现在不要介意这些时髦的词语…</p><p id="dc53" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，这个类创建了应用程序的<em class="ms">请求处理管道</em>，这意味着我们指定了应用程序如何响应HTTP请求。</p><p id="8e8f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如你所见，我们使用了<code class="fe mt mu mv mw b">HttpsRedirection</code>、<code class="fe mt mu mv mw b">Authorization</code>等等。通过所有这些<code class="fe mt mu mv mw b">Use...</code>扩展方法，我们将中间件组件添加到请求管道中。</p><p id="052c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如<code class="fe mt mu mv mw b">UsesHttpRedirection</code>添加了中间件，用于将HTTP请求重定向到HTTPS。</p><p id="d3e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我还想提一下，自从。NET 5我们得到了SwaggerUI的开箱即用的配置。这样，我们就有了一个测试API的方便的解决方案。我们将在下一章中用到它。</p><p id="2aec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在<code class="fe mt mu mv mw b">.csproj</code>文件中，我们看到SDK，在我们的例子中是目标框架。NET 6和根命名空间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">。csproj文件</figcaption></figure><p id="c5ce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还看到了一个对SwaggerUI的<code class="fe mt mu mv mw b">Swashbuckle.AspNetCore</code>的包引用。</p><p id="0223" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">稍后，我们将在这个文件中找到类似于<em class="ms">实体框架核心</em>的附加包。</p><p id="a6f5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于<code class="fe mt mu mv mw b">appsettings.json</code>文件，我们只需要知道我们可以在这里添加和修改一些配置。</p><p id="91b4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在更有趣的是launchSettings.json文件，其中配置了当前环境和应用程序URL。通过这个URL，我们将找到我们正在运行的web服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">launchsettings.json的一部分</figcaption></figure><p id="24fd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在可以忽略<code class="fe mt mu mv mw b">obj</code>和<code class="fe mt mu mv mw b">bin</code>文件夹。我们在这里找到临时的目标和最终的二进制文件。</p><p id="5fce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">非常有趣并且在本系列教程中经常使用的是<code class="fe mt mu mv mw b">Controllers</code>文件夹。</p><p id="a743" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你在这里看到的第一个控制器是生成的<code class="fe mt mu mv mw b">WeatherForecast</code>演示控制器。我们稍后将讨论控制器的细节。现在，重要的是知道我们已经可以在这里调用<code class="fe mt mu mv mw b">Get()</code> Get()方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">天气预报控制器的Get()方法</figcaption></figure><h2 id="3f3e" class="nc la it bd lb nd ne dn lf nf ng dp lj ma nh ni ll me nj nk ln mi nl nm lp nn bi translated">第一次API调用</h2><p id="b2e3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在终端中，我们输入<code class="fe mt mu mv mw b">dotnet watch run</code>来启动我们的应用程序，并且已经使用了观察器和热重载。您的默认浏览器应该会自动打开，在您看到的终端中，这里已经有了我们在<code class="fe mt mu mv mw b">launchSettings.json</code>中看到的URL。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/294a77a9334b4fb4248869d7ec804376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*jCBCmeiAHr4P7brz2qTykg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行应用程序时显示的信息。端口可能因您的情况而异。</figcaption></figure><p id="5252" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们在这里看到的已经是Swagger UI了。它将帮助我们测试我们的Web API，但是让我们暂时忘记Swagger。这里已经可以看到<code class="fe mt mu mv mw b">WeatherForecast</code>控制器，但是我们也可以通过Chrome的地址栏访问控制器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/9b7977a2e44b9d83a364ba2663fe844c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*uqPNnvy9ARYGFKbXgvldWQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">斯瓦格瑞</figcaption></figure><p id="c96c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们回到VS代码时，我们看到控制器的名字(<code class="fe mt mu mv mw b">WeatherForecast</code> —没有“控制器”)。我们还看到路由属性(<code class="fe mt mu mv mw b">[Route("[controller]”)</code>)来定义如何访问这个控制器——我们将在下一章讨论路由是如何工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">天气预报控制器的顶部</figcaption></figure><p id="e60a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以我们只是复制名字— <em class="ms"> WeatherForecast </em> —回到Chrome，输入正确的路线，最后，我们得到结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/8b8a521cf41d6f9d8f4bebf64b4e7a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RW-SZnJb9K5uWWCDzpcYjw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用Chrome地址栏的天气预报控件的结果</figcaption></figure><p id="3838" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在回到大摇大摆。你可以在这里看到控制器和模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/9b7977a2e44b9d83a364ba2663fe844c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*uqPNnvy9ARYGFKbXgvldWQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">SwaggerUI中的天气预报控制器和模式</figcaption></figure><p id="1ff8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">模式实际上是<code class="fe mt mu mv mw b">WeatherForecast</code>类，它告诉我们Web API调用的结果会是什么样子。</p><p id="8b35" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，上面不仅是控制器，它实际上是Web API的<code class="fe mt mu mv mw b">GET</code>调用。我们可以看到可用的参数——在这个特殊的例子中没有参数——我们还可以看到预期的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/54a31934a373b0f47a6df0b1ef320aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NkFl5_aNwFh3Yekm29Wgg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">调用SwaggarUI的天气预报控制器</figcaption></figure><p id="6ed6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最棒的是，我们可以在这里尝试。就这么办吧！</p><p id="7ea4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们单击execute时，我们会看到请求URL(这与我们一分钟前在地址栏中输入的内容相同),并看到结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/9d416418c1301fe7a4bcf7fef36e1328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wsmUKWmKINA7v4h0x0-K3g.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在SwaggerUI中执行WeatherForecast控制器的GET调用</figcaption></figure><p id="3521" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们也可以在Chrome的<em class="ms">开发者工具</em>的网络标签中看到结果。只需按下键盘上的F12打开工具，进入<em class="ms">网络</em>选项卡，通过<em class="ms">XHR</em>——代表XML Http请求——进行过滤，然后再次执行调用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/a9b53690628d611fcc8fd30283332384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCcJ88L9Jxbb7S_uLPHoKg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">开发者工具的网络标签中天气预报获取调用的结果</figcaption></figure><p id="1069" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你看，结果本质上是一样的，只是随机值不一样。</p><p id="c2b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">太好了！这是可行的。现在让我们继续构建我们自己的web服务。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="98c0" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">Web API</h1><h2 id="449e" class="nc la it bd lb nd ne dn lf nf ng dp lj ma nh ni ll me nj nk ln mi nl nm lp nn bi translated">介绍</h2><p id="3307" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">到目前为止，您已经学习了如何在？NET以及如何进行第一次API调用。</p><p id="3e60" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在接下来的部分，我们将为我们的RPG(角色扮演游戏)角色创建一个新的控制器和模型。</p><p id="0597" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，我们将把我们的同步调用变成异步调用，利用数据传输对象(dto)并改变我们的Web API的结构，使其符合最佳实践。</p><p id="314f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是首先，让我们看看模型-视图-控制器(MVC)模式，这是所有这一切的基础。</p><h2 id="8c7c" class="nc la it bd lb nd ne dn lf nf ng dp lj ma nh ni ll me nj nk ln mi nl nm lp nn bi translated">模型-视图-控制器(MVC)模式</h2><p id="515f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">模型-视图-控制器或简称MVC是一种软件设计模式，它将相关的程序逻辑分成三个相互联系的元素。让我解释一下，这三个元素中的每一个都代表什么，以及它们是如何协作的。</p><p id="46bc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们从模型开始。你也可以说，数据。例如，我们角色扮演游戏中的一个角色是一个模特。它可以有一个Id，一个名字，生命值，属性，技能等等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">dotnet-rpg的字符类</figcaption></figure><p id="b71c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">作为开发人员，您知道您的模型的代码。但是用户看不到你的代码。这就是观点出现的地方。用户可能希望看到HTML、纯文本或令人惊叹的3D图形的角色表现——这取决于你的游戏。换句话说，视图就是(图形)用户界面或(G)UI。</p><p id="e513" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">综上所述，模型更新视图，用户看到视图。如果模型改变了，比如说我们的角色获得了另一个技能或者生命值降低了，那么视角也会改变。这就是为什么模型总是更新视图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/66f26a9125dca668f63ad5e854fce7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/0*d8ycwWX8VnWd3qHR.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">模型更新视图，用户看到视图。</figcaption></figure><p id="6c62" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，控制器怎么了？控制器做实际的工作。在那里你会发现你的大部分代码，因为它操纵你的数据或模型。在我们的例子中，是Web API创建、更新和删除你的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f0f3ae62b54a34cf85311e234ca1884d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*8QJ6kkkXN0qoUmei.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">控制器操纵你的数据。</figcaption></figure><p id="a0a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为除了在Postman中调用的结果之外，我们没有视图，所以我们将按照以下顺序构建我们的应用程序:首先是模型，然后是控制器。我们将永远在这两者之间来回跳跃。</p><p id="4f71" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不过，在视图的帮助下，用户可以操作数据，从而使用按钮、文本字段等操作RPG角色的属性。在一个浏览器游戏中，本质上可能是JavaScript代码——可能在Angular、React或VueJS等框架的帮助下——或<a class="ae ky" href="https://youtu.be/G04IYKORYy0" rel="noopener ugc nofollow" target="_blank"> Blazor WebAssembly </a>。</p><p id="d45d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个JavaScript代码反过来使用控制器进行操作，并将这些更改持久地保存在数据库中。被操纵的模型将更新视图，然后用户再次看到该视图，并且循环再次开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/efd30b91d2b884bd6131c1dcaf64f9d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*LcPMI1Sjazhi_146.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">MVC模式的完整循环。</figcaption></figure><p id="52f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">嗯，这总结了MVC模式。现在我们要建立我们的第一个模型。</p><h2 id="5708" class="nc la it bd lb nd ne dn lf nf ng dp lj ma nh ni ll me nj nk ln mi nl nm lp nn bi translated">新型号</h2><p id="a2f1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们首先需要的是新的模型。我们需要一个角色扮演角色本身的模型，也需要一个角色扮演角色<em class="ms">类型</em>的模型，例如野蛮人、僧侣、亡灵巫师等角色类别。</p><p id="3176" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我们创建一个<code class="fe mt mu mv mw b">Models</code>文件夹。</p><p id="b585" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于角色模型，我们将在Models文件夹中创建一个新类。如果你已经安装了“C#扩展”，你可以用鼠标右键添加一个新的C#类，否则，你只是创建一个新的文件。</p><p id="b925" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以右键单击Models文件夹，然后单击“New C# Class”并调用这个类<code class="fe mt mu mv mw b">Character</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/d935e1312412e2b8ed112fcd1e323034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1VA80zGxFo6RMa6IMI0PUQ.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建角色类</figcaption></figure><p id="d899" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们添加一些属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">没有RpgClass属性的字符类</figcaption></figure><p id="7670" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还将添加一个<code class="fe mt mu mv mw b">RpgClass</code>属性，即角色的<em class="ms">类型</em>。但首先，我们必须为此创建一个新的<code class="fe mt mu mv mw b">enum</code>。</p><p id="277a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以，在Models文件夹中，让我们添加一个新的C# <code class="fe mt mu mv mw b">enum</code>名为<code class="fe mt mu mv mw b">RpgClass</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b493fc5287ab7be653580e2a4e6ef5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ZccZR4MJKvoDJkANMfcxg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建新的枚举。</figcaption></figure><p id="7a54" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你可以在这里随意添加任何你想添加的角色扮演课程。在这个例子中，我使用了骑士、法师和牧师。我猜是你需要的最基本的角色。一些近战动作，一些魔法，当然永远不要忘记治疗者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">RpgClass枚举</figcaption></figure><p id="2884" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，当我们准备好<code class="fe mt mu mv mw b">RpgClass</code> <code class="fe mt mu mv mw b">enum</code>时，我们终于可以将它添加到<code class="fe mt mu mv mw b">Character</code>模型中了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有RpgClass属性的字符类</figcaption></figure><p id="4530" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我将默认设置为骑士，但同样，这完全取决于你。</p><p id="60da" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好了，第一批模型准备好了。现在让我们添加一个新的控制器，并进行一个<code class="fe mt mu mv mw b">GET</code>调用来接收我们的第一个角色扮演游戏角色。</p><h2 id="b29f" class="nc la it bd lb nd ne dn lf nf ng dp lj ma nh ni ll me nj nk ln mi nl nm lp nn bi translated">新控制器&amp;获得一个新角色</h2><p id="6f90" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了添加一个新的控制器，我们在Controllers文件夹中创建一个新的C#类。使用C#扩展，我们也可以创建一个准备好的“API控制器”类，但是让我们首先手动执行必要的步骤。</p><p id="ea91" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们姑且称这个类为<code class="fe mt mu mv mw b">CharacterController</code>。</p><p id="dbc8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们开始实现任何逻辑之前，我们必须让这个东西成为一个合适的控制器。为此，我们首先从<code class="fe mt mu mv mw b">ControllerBase</code>开始推导。为此，我们还必须添加适当的引用，<code class="fe mt mu mv mw b">Microsoft.AspNetCore.Mvc</code>。</p><p id="67a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是一个没有视图支持的MVC控制器<em class="ms">的基类。</em></p><p id="6541" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为我们在这里构建一个API，所以我们不需要<em class="ms">视图支持。然而，如果我们想要添加对观点的支持，我们可以从<code class="fe mt mu mv mw b">Controller</code>中获得。但在我们的例子中，只需确保添加<code class="fe mt mu mv mw b">ControllerBase</code>。</em></p><pre class="kj kk kl km gt ol mw om on aw oo bi"><span id="a9b7" class="nc la it mw b gy op oq l or os">public class CharacterController : ControllerBase</span></pre><p id="83ba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">之后，我们必须添加一些属性。第一个是<code class="fe mt mu mv mw b">[ApiController]</code>属性。此属性指示某个类型(以及所有派生类型)用于提供HTTP API响应。</p><p id="fea6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，当我们将这个属性添加到控制器中时，它会启用几个特定于API的特性，如<em class="ms">属性路由</em>和如果模型有问题时的自动HTTP 400响应。当我们利用这些特性的时候，我们将得到细节。</p><pre class="kj kk kl km gt ol mw om on aw oo bi"><span id="7519" class="nc la it mw b gy op oq l or os">[ApiController]<br/>public class CharacterController : ControllerBase</span></pre><p id="52ee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于<em class="ms">属性路由</em>，那已经是我们要添加的下一个东西了。</p><p id="f5ae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在<code class="fe mt mu mv mw b">[ApiController]</code>属性下面，我们添加了<code class="fe mt mu mv mw b">[Route]</code>属性。当我们想要进行web服务调用时，这就是我们能够找到这个特定控制器的方法。</p><p id="76b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们添加到<code class="fe mt mu mv mw b">[Route]</code>属性的字符串是<code class="fe mt mu mv mw b">("api/[controller]”)</code>(paranthesese中)。这意味着这个控制器可以被字符串“api”访问，然后是它的名字，在我们的例子中是“Character”——所以C#类的名字的一部分在“controller”之前。</p><pre class="kj kk kl km gt ol mw om on aw oo bi"><span id="7418" class="nc la it mw b gy op oq l or os">[ApiController]<br/>[Route("api/[controller]")]<br/>public class CharacterController : ControllerBase</span></pre><p id="f50a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，<code class="fe mt mu mv mw b">WeatherForecastController</code>没有“api”字符串。再说一次，这完全取决于你。</p><p id="6294" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好了，让我们进入C#类的主体。我想添加的第一件事是一个静态模拟字符，我们可以将它返回给客户端。为此，您必须添加<code class="fe mt mu mv mw b">dotnet_rpg.Models</code>参考。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有模拟角色的角色控制器</figcaption></figure><p id="dfe9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于我们在这里使用C# 10，我们也可以将“global”关键字添加到using指令中，并可能将这一行移到Program.cs中。现在，整个应用程序都知道了这个引用，我们再也不用添加using指令了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">程序. cs</figcaption></figure><p id="9112" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我们最终实现了<code class="fe mt mu mv mw b">Get()</code>方法来接收我们的游戏角色。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用Get()方法的字符控制器</figcaption></figure><p id="7447" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们返回一个<code class="fe mt mu mv mw b">IActionResult</code>,因为这使我们能够将特定的HTTP状态代码和实际请求的数据一起发送回客户机。在这个方法中，我们用<code class="fe mt mu mv mw b">Ok(knight)</code>将状态码<code class="fe mt mu mv mw b">200 OK</code>和我们的模拟角色发送回去。</p><p id="9913" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">其他选项将是一个<code class="fe mt mu mv mw b">BadRequest 400</code>状态码或一个<code class="fe mt mu mv mw b">404 NotFound</code>，如果没有找到请求的字符。</p><p id="6370" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好了，代码实现了。现在让我们通过使用<code class="fe mt mu mv mw b">dotnet watch run</code>再次启动应用程序来测试这一点。</p><p id="19a2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">打开SwaggerUI，我们首先看到一个错误！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/6db3188b55cbe30ec05f2fc3b8766cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*0KpEQzJbtDFesRp7-y7aHw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">SwaggerUI中的错误</figcaption></figure><p id="ed04" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">尽管如此，让我们尝试通过浏览器调用我们的web服务方法。类似于WeatherForecastController，我们必须将CharacterController的路线输入到浏览器的地址栏中。注意你的URL的端口，它可能是不同的。在我的例子中，完整的URL是<code class="fe mt mu mv mw b"><a class="ae ky" href="https://localhost:7298/api/character." rel="noopener ugc nofollow" target="_blank">https://localhost:7298/api/character</a></code> <a class="ae ky" href="https://localhost:7298/api/character." rel="noopener ugc nofollow" target="_blank">。这个网址应该会引导我们找到我们想要的结果。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/bc49060643feb8018041d45920a7a759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFeSj5qGw9TcAgSuZIUP8Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">接收单个RPG字符</figcaption></figure><p id="17cd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">回到Swagger，让我们打开开发者工具，看看网络选项卡。这里我们看到了实际的问题:<em class="ms">动作需要为Swagger </em>显式绑定HttpMethod。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/5d95a78bc8d83c6f67febaf2b8a00e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5JgDQY8d_GPw63pF"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Swagger中的错误:<em class="ow">操作需要为Swagger </em>显式绑定HttpMethod。</figcaption></figure><p id="c11c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">回到VS代码，注意添加到我们的<code class="fe mt mu mv mw b">Get()</code>方法中的属性。确切地说，有<em class="ms">无</em>。</p><p id="2ad3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们将其与<code class="fe mt mu mv mw b">WeatherForecastController</code>进行比较时，我们可以添加一个<code class="fe mt mu mv mw b">[HttpGet]</code>属性。</p><p id="0ca5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是对于<code class="fe mt mu mv mw b">CharacterController</code>来说这不是必须的，因为Web API支持<em class="ms">命名约定</em>，如果方法的名称以<code class="fe mt mu mv mw b">Get...()</code>开头，API会假设所使用的HTTP方法也是<code class="fe mt mu mv mw b">GET</code>。</p><p id="dc15" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">除此之外，到目前为止我们的控制器中只有一个<code class="fe mt mu mv mw b">Get()</code>方法，所以web服务确切地知道请求的是什么方法。</p><p id="efca" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，正如我们现在所知道的，为了帮助Swagger out，我们必须添加<code class="fe mt mu mv mw b">[HttpGet] </code>属性。让我们这样做，然后回到Chrome。</p><pre class="kj kk kl km gt ol mw om on aw oo bi"><span id="ac27" class="nc la it mw b gy op oq l or os">[HttpGet]<br/>public IActionResult Get()</span></pre><p id="6c60" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们现在看到了这个方法，但是没有看到任何模式或预期的返回类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/b0653cb6ecbb0320bb6431796c34bf26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*h0dMXIx5jbbgk6VGwkBDlA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">没有任何模式的字符控制器</figcaption></figure><p id="2ce9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们再一次回到VS代码，将返回类型改为类型为<code class="fe mt mu mv mw b">Character</code>字符的<code class="fe mt mu mv mw b">ActionResult</code>。</p><pre class="kj kk kl km gt ol mw om on aw oo bi"><span id="2423" class="nc la it mw b gy op oq l or os">[HttpGet]<br/>public ActionResult&lt;Character&gt; Get()</span></pre><p id="0dca" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在保存了这个更改之后，由于一个<em class="ms">粗鲁的编辑</em>，我们可能不得不重启我们的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/eabf28529a525addabd31120c96e0ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VOCe46lJ7e-bmB0K"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由于粗暴编辑，无法应用热重新加载。</figcaption></figure><p id="c056" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">那么，让我们这样做，最后，我们看到所有想要的信息。Swagger向我们展示了我们的<code class="fe mt mu mv mw b">Character</code>类和<code class="fe mt mu mv mw b">RpgClass</code>枚举。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/7d41a70ebbc356c1d37cf047cc2b92f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*lUKSZXAfQxS21u9PHIKC-w.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">SwaggerUI中的所有模式。</figcaption></figure><p id="7dbe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">还有一点我们可以补充的。</p><p id="73c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">查看enum，我们只看到了<code class="fe mt mu mv mw b">RpgClass</code>的<em class="ms">编号</em>而不是<em class="ms">名称</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/06675eeae4f30ab7bfabc79ebb3ac4b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/0*TssMYd1MbBbprCPl"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">SwaggerUI中带数字的RpgClass</figcaption></figure><p id="583e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以通过在enum文件中配置<code class="fe mt mu mv mw b">JsonConverter</code>来改变这一点。</p><p id="7fb2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们使用类<code class="fe mt mu mv mw b">JsonStringEnumConverter</code>将属性添加到枚举定义的上方，该类<em class="ms">将枚举值与字符串相互转换。</em>我们还必须为此添加适当的参考，即<code class="fe mt mu mv mw b">System.Text.Json.Serialization</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有JsonConverter属性的RpgClass枚举</figcaption></figure><p id="6e32" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms">如果您仍然看不到RPG类的名称，您可能需要手动重启应用程序。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/15f68c2a678659add9ec0c1e013241a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*3iutsrGBS5NjxFSrGEGi_A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带字符串的RpgClass枚举</figcaption></figure><p id="1bd3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是在那之后，我们看到了<code class="fe mt mu mv mw b">RpgClass</code>的名字，我们可以测试<code class="fe mt mu mv mw b">Get()</code>方法，没有任何问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/405ea16052e2712679fd69ce5cd35055.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/0*BPM1pi_A-fa9e_QY"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">SwaggerUI中Get()方法的结果</figcaption></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="e3b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这就是本系列教程的第一部分。我希望它已经对你有用了。非常感谢您的宝贵时间！要获得下一部分的通知，只需<a class="ae ky" href="https://mailchi.mp/364b891b448f/dotnetdev" rel="noopener ugc nofollow" target="_blank">订阅我的时事通讯</a>或<a class="ae ky" href="https://medium.com/@patrickgod" rel="noopener">通过媒体</a>关注我。你会是第一个知道的。</p><p id="124b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下次见！</p><p id="8791" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">保重，</p><p id="2a61" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">帕特里克(男子名)</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="2e0a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms">接下来:属性路由、HTTP方法、用POST添加一个新字符、异步调用等等！</em></p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="5bec" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">但是等等，还有呢！</h1><ul class=""><li id="0021" class="pd pe it lt b lu lv lx ly ma pf me pg mi ph mm pi pj pk pl bi translated"><a class="ae ky" href="https://emojipedia.org/play-button/" rel="noopener ugc nofollow" target="_blank"> ▶️ </a> ️Enjoy很多。NET &amp; Blazor教程上<a class="ae ky" href="https://www.youtube.com/patrickgod" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> YouTube上</strong> </a> <strong class="lt iu">。</strong></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pm"><img src="../Images/52165402fa87918dd8c4268ce47c4db0.png" data-original-src="https://miro.medium.com/v2/0*LaTI_3GosFXs-9Tb.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在YouTube上订阅编码教程</figcaption></figure><ul class=""><li id="e3e5" class="pd pe it lt b lu mn lx mo ma pn me po mi pp mm pi pj pk pl bi translated">❤️ ️Let's在<a class="ae ky" href="https://twitter.com/_PatrickGod" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">上连接Twitter </strong> </a>，<a class="ae ky" href="https://www.linkedin.com/in/patrickgod" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> LinkedIn </strong> </a>或<a class="ae ky" href="https://medium.com/@patrickgod" rel="noopener"> <strong class="lt iu">上连接媒体</strong> </a>。</li><li id="7501" class="pd pe it lt b lu pq lx pr ma ps me pt mi pu mm pi pj pk pl bi translated">📧<a class="ae ky" href="https://mailchi.mp/364b891b448f/dotnetdev" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">订阅我的简讯</strong> </a>提前获取即将推出的教程&amp;在线课程。NET，Blazor &amp;更！</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/12839e3ea45749be54ba9f269d4c74cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*qH6g7l6-vCX9KLXe.gif"/></div></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="ca1f" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">分级编码</h1><p id="8aa4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae ky" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。<br/>跟随:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae ky" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="lt iu">升一级正在转型理工大招聘➡️ </strong> <a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>