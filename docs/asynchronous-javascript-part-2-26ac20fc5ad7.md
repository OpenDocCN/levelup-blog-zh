# 异步 Javascript 第 2 部分:事件循环

> 原文：<https://levelup.gitconnected.com/asynchronous-javascript-part-2-26ac20fc5ad7>

本文是关于异步 Javascript 的四篇系列文章的第 2 部分。可以在这里查看 [*第一部*](https://medium.com/@kabir4691/asynchronous-javascript-part-1-b87f263a353a) *。*

![](img/bbbab6fc99628470add15052bb51d73c.png)

正如我们在上一篇文章中看到的，Javascript 总是跳转到调用堆栈顶部的函数执行。当一个新的函数被添加/移除到堆栈中时，Javascript 如何得到通知？它如何知道何时暂停当前函数的执行，并跳转到新函数的执行？所有这一切都是可能的，因为 Javascript 的一个组件叫做**事件循环**。

# 事件循环

事件循环是 Javascript 最重要的组件之一，我们需要了解它才能完全理解执行流程。顾名思义，它是一个反复运行的循环，检查调用堆栈中是否至少有一个函数，如果有，就将程序执行跳转到调用堆栈顶部的函数。

让我们通过一个例子来更好地理解事件循环

输出:

```
4
3
1
5
2
```

如果你对执行的顺序感到困惑，请继续阅读。正如您所看到的，我们有三个函数声明以及一些语句和函数调用。让我们一行一行地执行程序。在程序开始时，Javascript 的事件循环被创建并启动。事件循环首先检查调用堆栈中是否有任何函数。我们的调用堆栈目前如下所示:

```
|             |
|             |
|             |
|             |
|             |
|_____________|

  Call stack
```

由于调用栈是空的，程序继续执行到第 1 行，这里定义了函数 *sayOne* 。由于这只是一个定义，程序只是将函数的代码保存在一个名为 *sayOne* 的变量中，然后继续运行。此时，事件循环再次检查调用堆栈中是否有函数。因为调用栈仍然是空的，所以程序移动到下一行，即 6。这里，重复相同的操作步骤，保存 *sayTwo* 的函数定义，然后事件循环再次检查调用堆栈。然后程序移动到第 10 行，对功能 *sayThree* 重复相同的步骤。

然后程序运行到第 14 行，第一次遇到一条语句。请记住，在这个阶段，调用堆栈仍然是空的。在执行 console.log 语句将“4”打印到控制台之前，事件循环检查调用堆栈是否为空。既然是这样，程序就继续执行，并将 4 打印到控制台上。然后程序移动到第 15 行，在那里它看到 *sayOne* 函数已经被调用。因此，它立即将这个函数添加到调用堆栈中，现在看起来像这样。

```
|             |
|             |
|             |
|             |
|  sayOne()   |
|_____________|

  Call stack
```

在转到第 16 行之前，再次触发事件循环来检查调用堆栈是否非空。由于调用堆栈现在不为空，程序于是决定执行调用堆栈顶部的函数，即 *sayOne* 。当运行 *sayOne* 的代码时，在第 2 行，我们看到 *sayThree* 函数被调用，因此它被添加到调用堆栈中。

```
|             |
|             |
|             |
|  sayThree() |
|  sayOne()   |
|_____________|

  Call stack
```

在移动到 *sayOne* 函数中的第 3 行之前，事件循环被再次触发，以检查堆栈是否非空。当它发现它是，它在这个时候做两个动作。它首先检索堆栈顶部的函数，然后检查当前运行的函数是否与它相同。如果相同，则继续执行当前函数。如果它们不相同(在我们的例子中，它们不相同)，那么程序暂停当前函数的执行，并跳转到最顶层函数的执行(在这个例子中是 *sayThree* )。因此，在第 11 行，在执行 console.log 语句之前，事件循环再次检查非空堆栈，检索最顶层的函数，发现它与当前运行的函数相同，因此继续执行它的代码。调用第 11 行(这导致 console.log 语句在控制台上输出“3”。因为我们已经到达了函数 *sayThree* 的末尾，所以它现在被从调用堆栈中移除。

```
|             |
|             |
|             |
|             |
|  sayOne()   |
|_____________|

  Call stack
```

程序的执行现在返回到前一个函数，即 *sayOne* 函数。在这一点上，我们应该注意到这个函数的执行是从我们离开的地方恢复的，就在第 3 行之前。事件循环再次被触发，并发现堆栈非空。它发现堆栈中最顶层的函数与当前运行的函数 *sayOne* 相同，因此继续运行。调用第 3 行，将“1”打印到控制台上。我们已经到达函数 *sayOne* 的末尾，它会立即从调用堆栈中移除。

```
|             |
|             |
|             |
|             |
|             |
|_____________|

  Call stack
```

然后程序执行返回到它离开前一个函数的地方(在这种情况下是全局上下文)。所以，程序现在返回到第 16 行之前。现在事件循环再次被触发，它发现调用堆栈是空的。因此，它继续执行第 16 行，将“5”打印到控制台上。

程序的其余部分像我们到目前为止讨论的那样进行。在第 17 行， *sayTwo* 函数被添加到调用堆栈中。

```
|             |
|             |
|             |
|             |
|  sayTwo()   |
|_____________|

  Call stack
```

事件循环检查调用堆栈并运行 sayTwo 函数。这会将“2”打印到控制台上。然后从调用堆栈中移除 sayTwo 函数。

```
|             |
|             |
|             |
|             |
|             |
|_____________|

  Call stack
```

事件循环再次被触发，当它看到堆栈为空时，它会检查当前函数中是否还有要运行的代码。因为没有，程序最终终止。

到目前为止，本系列中，我们只讨论了 Javascript 中同步代码的执行。Javascript 为我们提供了异步函数，比如`setTimeout`函数，用来延迟一段代码的执行。我们将在本系列的第 3 部分中看到它是如何融入执行流程的。