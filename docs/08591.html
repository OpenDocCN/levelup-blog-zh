<html>
<head>
<title>UCL Winners Exploratory Data Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UCL获奖者探索性数据分析</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ucl-winners-exploratory-data-analysis-7dcf5a44736e?source=collection_archive---------15-----------------------#2021-05-14">https://levelup.gitconnected.com/ucl-winners-exploratory-data-analysis-7dcf5a44736e?source=collection_archive---------15-----------------------#2021-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9f9dd97851a29839435975a00727f806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Qx5t5excW6Gwzzjgguo6g.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://es.uefa.com/uefachampionsleague/news/0258-0e9533031260-37a6195f5f8a-1000--donde-ver-la-final-de-la-champions/" rel="noopener ugc nofollow" target="_blank">https://es . uefa . com/uefachampionsleague/news/0258-0e 9533031260-37a 6195 F5 f8a-1000-don de-ver-la-final-de-la-champions/</a></figcaption></figure><p id="5589" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们很快就能知道谁会是今年俱乐部级别的最负盛名的欧洲锦标赛——欧洲冠军联赛——的冠军，所以让我们来回顾一下历史上赢得最多冠军的球队。</p><p id="26c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用从<a class="ae kc" href="http://en.wikipedia.org/wiki/UEFA_Champions_League" rel="noopener ugc nofollow" target="_blank">维基百科</a>获得的数据进行分析，其中包含自1955年欧洲俱乐部锦标赛成立以来的决赛数据。我已经解析并处理了这些数据，也更新了当前记录，你可以在我的GitHub repo中找到<a class="ae kc" href="https://github.com/fvgm-spec/csv_files/blob/master/uefa_champions_winners.csv" rel="noopener ugc nofollow" target="_blank">数据</a>，以及这个分析的<a class="ae kc" href="https://github.com/fvgm-spec/Data_Science_Projects/blob/master/UEFA_winners_Analysis.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>。</p><h2 id="efec" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">数据采集</h2><p id="ea76" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">首先，我们将创建一个新的文件夹来存储我们的根设置中的数据集，如果路径不存在，我们将创建它，通过使用<em class="lz"> os </em>包。然后我们将使用<em class="lz"> urllib </em>包从<em class="lz"> base_url </em>下载csv文件。然后，我们将它存储在我们先前创建的文件夹中，在此之前，我们将确保该文件不存在。</p><p id="e618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦获得数据集，我们将使用<em class="lz"> read_csv </em>命令将其转换为数据帧</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/defe2bfacba09166bee5ff679f116c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*Nx3NNRiZolaUT1jqJd6P4w.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自作者</figcaption></figure><p id="bd74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在前面代码的输出中，我们得到了一个64行的DataFrame，显示了从皇家马德里赢得比赛开始到拜仁慕尼黑赢得最后一场比赛为止的所有冠军联赛决赛的数据。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/6160723039cd77fee47bfdb595e1f630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Ac2nbrIX0vZ6TUq9v9Gig.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自作者</figcaption></figure><h1 id="5af9" class="mg lc iq bd ld mh mi mj lg mk ml mm lj mn mo mp lm mq mr ms lp mt mu mv ls mw bi translated">用熊猫分组数据</h1><p id="2c41" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">group by子句是对数据帧的操作。序列是一个1D对象，因此对其执行group by操作没有太大用处。但是，它可用于获取系列的不同行。group by操作的结果不是数据帧，而是数据帧对象的字典。</p><p id="bd8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，上面看到的输出显示了赛季、冠军和亚军俱乐部所属的国家、分数、场地和上座率数字，假设我们想根据这些国家赢得的欧洲俱乐部锦标赛的数量对它们进行排名。我们可以通过使用group by来做到这一点。首先，我们对数据帧应用group by函数，并查看结果的类型:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/aafb0072d90814c04c51cbb337cc7746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*2qSTzVMSm1QK1sTxhqR2wA.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自作者</figcaption></figure><p id="1db4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们注意到<strong class="kf ir"> nationsGrp </strong>是一个名为<em class="lz">pandas . core . group by . data frame group by</em>的对象类型。我们使用groupby的列被称为键，对应于这些键的其余值是每个键内部的值，它只是一个名为<em class="lz"> dictionary </em>的对象。我们可以通过在生成的<em class="lz"> DataFrameGroupBy </em>对象上使用groups属性来查看这些组的样子:</p><p id="b280" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们之前所说的，这基本上是一个字典，显示了唯一的组和对应于每个组的轴标签——在本例中是行号。例如，我们可以获得DataFrame的第62个指数的完整信息，对应于2017-18赛季决赛，代表皇家马德里与利物浦有争议的第13个“奥雷乔纳”。</p><p id="6d5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用下面单元格中的<em class="lz"> len() </em>函数获得组数:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/230308d66ffb77d293a57059bf92cb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*-AnWkMurT2CArAEGQCo6_A.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自作者</figcaption></figure><p id="3060" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们对之前由<code class="fe mz na nb nc b">DataFrameGroupBy object</code>确定的数据进行分组，用变量名<em class="lz"> nationsGrp </em>标识，我们将使用它来显示一些表格，但首先我们需要将其转换为DataFrame，这样我们就可以创建一个新的度量并对其进行升序排序。</p><p id="b549" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在表格中，我们注意到赢得更多冠军的国家是西班牙，主要是因为皇家马德里和巴塞罗那的13 a 5 Trophys。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/bb4f7392b1d2bbeb1ee8d9d1f12c5587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*MI5knQN6DMkJdPGCBbDYTw.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自作者</figcaption></figure><p id="2b6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lz"> size() </em>函数返回一个以组名为索引的序列以及每个组的大小。<em class="lz"> size() </em>函数也是一个聚合函数。</p><p id="dbd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了按国家和俱乐部进一步细分获胜，我们应用了一个<strong class="kf ir">多列groupby函数</strong>，然后是size()和sort():</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e459d121dbac817a1f00cba8205b66f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*41uiS_8Iz25iiJisxzf35Q.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自作者</figcaption></figure><p id="9b85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kf ir">多列groupby </strong>通过将键列指定为一个列表来指定多个要用作键的列。因此，我们可以看到在这场比赛中最成功的俱乐部是西班牙的皇家马德里。</p><p id="0d59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过本教程，我们已经快速探索了使用数据分析技术的一些方法，特别是数据分析师之间众所周知的一种方法，即【T21集团】。你还可以在官方文档中找到更多其他的熊猫技巧来分析。</p></div></div>    
</body>
</html>