<html>
<head>
<title>Why Jotai is the Best Atomic-Based State Management Library for React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Jotai是React最好的基于原子的状态管理库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/jotai-atom-based-state-management-for-react-1ce8fd380296?source=collection_archive---------5-----------------------#2021-06-29">https://levelup.gitconnected.com/jotai-atom-based-state-management-for-react-1ce8fd380296?source=collection_archive---------5-----------------------#2021-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c87550cf3f9246fccc7d71255a8d6d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypzlNZe91A7RTjFErNwTzQ.png"/></div></div></figure><p id="e833" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在过去的几年里，国家管理有了很大的发展。在React应用程序中，有许多可以管理状态的库和方法。尽管Redux是使用最广泛的状态管理，但由于它带来的复杂性和样板代码，它的受欢迎程度已经随着时间的推移而下降。人们开始转向其他选项，如<a class="ae kz" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank">反应-查询</a>、<a class="ae kz" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>、<a class="ae kz" href="https://zustand.surge.sh/" rel="noopener ugc nofollow" target="_blank"> Zustand </a>、<a class="ae kz" href="https://hookstate.js.org/" rel="noopener ugc nofollow" target="_blank">钩子状态</a>、<a class="ae kz" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文-API </a>，因为它们非常小，易于维护。</p><p id="bf52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2020年，脸书引入了一种叫做“反冲”的管理国家的新方法。反冲采用了一种<strong class="kd iu">原子</strong>方法，就像一个附在你的反应树上的图，其中状态变化从这个图的根(称为<strong class="kd iu">原子</strong>)通过纯函数(称为<strong class="kd iu">选择器</strong>)和组件流动。由于应用程序会将状态拆分成原子，这将比redux中的存储空间小。本文主要关注状态管理领域的另一个竞争对手，叫做<strong class="kd iu"> Jotai，</strong>一个<strong class="kd iu">原子的</strong>，一种轻量级的、简单明了的React应用程序状态管理方式。</p><h1 id="f3b0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Jotai是什么</h1><p id="65b5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Jotai是一个简单的状态管理库，由<a class="ae kz" href="https://zustand.surge.sh/" rel="noopener ugc nofollow" target="_blank"> Zustand </a>的创建者开发。Jotai的灵感来自反冲，这是一种原子的状态管理方法。与反冲不同，Jotai不需要传递字符串密钥。Jotai提供了一个极简的API，具有类型脚本就绪性，并与<a class="ae kz" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">反应暂停</a>和<a class="ae kz" href="https://reactjs.org/docs/concurrent-mode-intro.html" rel="noopener ugc nofollow" target="_blank">并发模式</a>兼容。</p><h1 id="e355" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">是什么让它独一无二</h1><p id="e30a" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">与反冲相比，Atom相对较轻，反冲的束大小为14kb，而jotai仅为3.3 kb。Jotai有一个简单的API，由像<code class="fe md me mf mg b">Provider</code>、<code class="fe md me mf mg b">atom</code>和<code class="fe md me mf mg b">useAtom</code>这样的API方法组成。与反冲不同，它不需要钥匙来识别原子</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="ac5e" class="mp lb it mg b gy mq mr l ms mt">// Recoil's atom with a <strong class="mg iu">key</strong><br/>const counterState = atom({<br/> <strong class="mg iu">pokemon</strong>: {<br/>  pokemons: [],<br/>  pokemon: '',<br/>  isEditing: false<br/> }<br/>})</span><span id="8629" class="mp lb it mg b gy mu mr l ms mt">// Jotai's atom<br/>const <strong class="mg iu">pokemonAtom </strong>= atom({<br/> pokemons: [],<br/> pokemon: '',<br/> isEditing: false<br/>})</span></pre><p id="c023" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">状态可以通过传递一个接受另一个原子的函数来实现像选择器这样的选项。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="718b" class="mp lb it mg b gy mq mr l ms mt">const pokemonSelector = atom({<br/> (get) =&gt; get(<strong class="mg iu">pokemonAtom</strong>).filter((e) =&gt; e === id)<br/>})</span></pre><h1 id="6d16" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Jotai与反冲、Zustand和Redux的比较</h1><p id="2676" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">React now提供了许多状态管理工具，其中大多数都属于特定的类别。</p><ul class=""><li id="db77" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">通量(<a class="ae kz" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>，<a class="ae kz" href="https://zustand.surge.sh/" rel="noopener ugc nofollow" target="_blank"> Zustand </a></li><li id="1e32" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">代理(<a class="ae kz" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> Mobx </a>，<a class="ae kz" href="https://valtio-demo.pmnd.rs/" rel="noopener ugc nofollow" target="_blank"> Valtio </a>)</li><li id="b69f" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">原子(<a class="ae kz" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>，<a class="ae kz" href="https://jotai.pmnd.rs/" rel="noopener ugc nofollow" target="_blank">约泰</a>)</li></ul><p id="745c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Flux体系结构基于由订阅存储/状态的组件触发的动作所引起的变化。最著名的基于flux的状态管理是Redux，它仍然是react社区中使用最多的状态管理库。由于样板文件和高度复杂性等问题，像Zustand这样的库变得流行起来。Zustand维护了一个类似Redux的商店，但样板代码更少。</p><p id="5ad5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代理是一种利用可观察对象并使用订阅者来管理状态的模式，这意味着您不需要像选择器和区分这样的传统方法来识别和重新呈现状态的组件。代理模式不需要触发独特的动作，就像Redux或Zustand一样，它将订阅存储中的值。Mobx可以被认为是最著名的，因为这种特殊的模式和valtio是由<a class="ae kz" href="https://medium.com/@dai_shi" rel="noopener"> Daishi Kato </a>创造的，他也是Zustand和Jotai的作者。Flux和代理存储数据都不绑定到React树。因此，您甚至可以从React树外部使用它。</p><p id="200d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原子模式类似于React状态，它将状态存储在React树中。原子将保持应用程序状态，组件可以订阅这些独立的原子。脸书的反冲是使用原子方法的最著名的图书馆。Jotail是另一个利用原子结构来管理状态的库。</p><h1 id="4077" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Jotai API</h1><p id="7d2f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Jotai是最小的国家管理图书馆之一。Jotai包含3个主要的核心功能，它们是</p><h2 id="c8de" class="mp lb it bd lc nj nk dn lg nl nm dp lk km nn no lo kq np nq ls ku nr ns lw nt bi translated"><a class="ae kz" href="https://docs.pmnd.rs/jotai/api/core#atom" rel="noopener ugc nofollow" target="_blank">原子</a></h2><p id="c551" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">一个原子代表一段应用程序状态。原子可以是原始值，如数字或布尔值，并接受对象或数组。你可以任意定义原子。但由于它不使用任何类似反冲的键，所以使用起来相当容易。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="700d" class="mp lb it mg b gy mq mr l ms mt">import { <strong class="mg iu">atom </strong>} from '<strong class="mg iu">jotai</strong>'</span><span id="9696" class="mp lb it mg b gy mu mr l ms mt">const <strong class="mg iu">pokemonAtom </strong>= <strong class="mg iu">atom</strong>({<br/> pokemons: [],<br/> pokemon: '',<br/> isEditing: false<br/>})</span><span id="02bb" class="mp lb it mg b gy mu mr l ms mt">//Derived atom which uses <strong class="mg iu">pokemonAtom</strong><br/>const pokemonCountAtom = <strong class="mg iu">atom</strong>(<br/> (get) =&gt; get(<strong class="mg iu">pokemonAtom</strong>).pokemons.length<br/>)</span></pre><h2 id="d677" class="mp lb it bd lc nj nk dn lg nl nm dp lk km nn no lo kq np nq ls ku nr ns lw nt bi translated"><a class="ae kz" href="https://docs.pmnd.rs/jotai/api/core#use-atom" rel="noopener ugc nofollow" target="_blank">使用原子</a></h2><p id="2a13" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">useAtom方法的行为类似于React提供的<a class="ae kz" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> useState </a>方法。该方法用于从组件中读取存储/原子数据。useAtom返回两个值value和setter函数。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="b309" class="mp lb it mg b gy mq mr l ms mt">const {<strong class="mg iu">pokemonAtom</strong>} from "../atoms"<br/>const [pokemon,setPokemon] = <strong class="mg iu">useAtom</strong>(<strong class="mg iu">pokemonAtom</strong>);</span></pre><h2 id="d6e4" class="mp lb it bd lc nj nk dn lg nl nm dp lk km nn no lo kq np nq ls ku nr ns lw nt bi translated"><a class="ae kz" href="https://docs.pmnd.rs/jotai/api/core#provider" rel="noopener ugc nofollow" target="_blank">供应商</a></h2><p id="7b01" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">提供了一个高阶函数，使您能够从应用程序内部的任何地方访问原子。该提供者与React上下文提供者非常相似。</p><p id="a67e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了这些核心API之外，还有一些像<a class="ae kz" href="https://docs.pmnd.rs/jotai/api/utils#atom-with-storage" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> atomWithStorage </strong> </a>，<strong class="kd iu"> </strong>这样的实用API，它们将数据持久存储在浏览器的<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank"> localStorage </a>或<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage" rel="noopener ugc nofollow" target="_blank">session storage</a>中。<a class="ae kz" href="https://docs.pmnd.rs/jotai/advanced-recipes/large-objects#split-atom" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">split atom</strong></a><strong class="kd iu"/>这个util函数是在处理数组对象时使用的。这个函数将把数组中的每个对象转换成一个原子。</p><h1 id="eeba" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Jotai入门</h1><p id="901c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在这一节中，让我们看看如何在实际应用程序中使用Jotai。让我们构建一个小的口袋妖怪应用程序，它将维护你最喜欢的口袋妖怪的数据库。</p><h1 id="a14c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤01:安装</h1><p id="bb59" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">让我们通过下面的命令在React应用程序上安装Jotai。这些命令将安装所有必需的</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="a1ef" class="mp lb it mg b gy mq mr l ms mt">npx create-react-app jotai-pokemons<br/>cd jotai-pokemons<br/>yarn add <strong class="mg iu">jotai optics-ts</strong> semantic-ui-react semantic-ui-css</span></pre><h1 id="cd07" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤02:创建存储/原子</h1><p id="3288" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">当构建一个实际的工作应用程序时，我们将不得不处理原子中的大型对象。主要有三种方法。</p><ol class=""><li id="f6b8" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky nu nb nc nd bi translated">一个大原子把一个物体作为一个整体并创造出更小的衍生原子</li><li id="8b64" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky nu nb nc nd bi translated">标准化数据结构</li><li id="e09e" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky nu nb nc nd bi translated">创建微小的，并将它们与原子引用相结合</li></ol><h2 id="6912" class="mp lb it bd lc nj nk dn lg nl nm dp lk km nn no lo kq np nq ls ku nr ns lw nt bi translated">一个大原子和小衍生原子</h2><p id="9c23" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这种方法不是保存数据的最基本的方式，但是，这使得管理状态和将状态推送到服务器变得更容易，因为它不需要对数据进行任何规范化或调整。Jotai附带了一些实用函数，如<code class="fe md me mf mg b">selectAtom</code>、<code class="fe md me mf mg b">splitAtom</code>、<code class="fe md me mf mg b">focusAtom</code>，可以方便地访问它们。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="357c" class="mp lb it mg b gy mq mr l ms mt">const dataAtom = atom({<br/> pokemons: [<br/> { id:1,name: 'Pikachu', power: 'Lightning',description: 'Fluffy'},<br/> { id:2,name: 'Charizard', power: 'Fire',description: 'Brown'}<br/> ],<br/> pokemon: '',<br/> isEditing: false<br/>})</span><span id="c359" class="mp lb it mg b gy mu mr l ms mt">export const pokemonsAtom = <strong class="mg iu">focusAtom</strong>(dataAtom, (optic) =&gt; optic.prop('<strong class="mg iu">pokemons</strong>'))</span></pre><h2 id="2cfa" class="mp lb it bd lc nj nk dn lg nl nm dp lk km nn no lo kq np nq ls ku nr ns lw nt bi translated">标准化数据</h2><p id="e2f0" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在这里，我们可以规范化数据，使之更容易，并提高应用程序的性能。你可以使用像<a class="ae kz" href="https://github.com/paularmstrong/normalizr" rel="noopener ugc nofollow" target="_blank"> normalizr </a>这样的工具来实现。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="0a83" class="mp lb it mg b gy mq mr l ms mt">const pokemonMapAtom = atom({<br/>  p1: { name: 'Pikachu', power: 'Lightning',description: 'Fluffy'},<br/>  p2: { name: 'Charizard', power: 'Fire',description: 'Brown'},<br/>})</span></pre><h2 id="0b8a" class="mp lb it bd lc nj nk dn lg nl nm dp lk km nn no lo kq np nq ls ku nr ns lw nt bi translated">原子引用</h2><p id="7252" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这种方法有点混乱，但是它的工作原理是一样的，每一部分数据都用一个原子包装。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="428f" class="mp lb it mg b gy mq mr l ms mt">const dataAtom = atom({<br/>  pokemon: atom([<br/>    atom({ name: 'Pikachu', power: 'Lightning',description: 'Fluffy'}),<br/>    atom({ name: 'Charizard', power: 'Fire',description: 'Brown'}),<br/>  ]),<br/>}</span></pre><p id="abd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用atom.js文件中的大原子来创建一个全局存储</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">Store.js文件</figcaption></figure><h1 id="88bd" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤Jotai的实用程序和集成</h1><p id="c9c7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Jotai允许一些有用的插件来增强开发体验。下面是其中的几个。</p><ol class=""><li id="ba15" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky nu nb nc nd bi translated"><a class="ae kz" href="https://docs.pmnd.rs/jotai/api/utils#atom-with-storage" rel="noopener ugc nofollow" target="_blank"> atomWithStorage </a></li><li id="6669" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky nu nb nc nd bi translated"><a class="ae kz" href="https://docs.pmnd.rs/jotai/api/utils#atom-with-reset" rel="noopener ugc nofollow" target="_blank"> atomWithReset </a></li><li id="1ce2" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky nu nb nc nd bi translated"><a class="ae kz" href="https://docs.pmnd.rs/jotai/api/utils#use-reducer-atom" rel="noopener ugc nofollow" target="_blank">用户自定义</a></li></ol><p id="fb24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看如何使用<a class="ae kz" href="https://docs.pmnd.rs/jotai/api/utils#atom-with-storage" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">atomWithStorage</strong></a><strong class="kd iu"/>util函数将数据存储在浏览器的本地或会话存储中。让我们将下面几行添加到<strong class="kd iu"> store.js </strong>文件中。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="d227" class="mp lb it mg b gy mq mr l ms mt">import { <strong class="mg iu">atomWithStorage </strong>} from 'jotai/utils'</span><span id="9e29" class="mp lb it mg b gy mu mr l ms mt">export const darkModeAtom = <strong class="mg iu">atomWithStorage</strong>('darkMode', false)</span></pre><p id="3925" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们从组件中访问这个原子。让我们创建一个包含切换按钮的导航组件。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">Navigation.jsx文件</figcaption></figure><p id="7de6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以转到浏览器中的应用程序选项卡，查看其中存储的数据。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/0fada55657fb52b8023ff8872a4c9a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFqkRc-Jb7e37ptsZmDMUA.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">浏览器的本地存储</figcaption></figure><h1 id="c1ef" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤o4:处理异步状态</h1><p id="875e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在Jotail中处理异步状态更容易。只不过是传递那个回报你数据的承诺而已。让我们考虑一个从API获取数据的小例子。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="f797" class="mp lb it mg b gy mq mr l ms mt">export const getPokemonAtom = atom(<br/> <strong class="mg iu">async </strong>() =&gt; fetch(URL).then((resp) =&gt; resp.json())<br/>)</span></pre><p id="4040" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以通过这个<a class="ae kz" href="https://github.com/TRomesh/jotai-pokemon" rel="noopener ugc nofollow" target="_blank"> Github </a> repo来了解如何在React应用程序中配置和使用Jotai。</p><h1 id="4e8b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="2187" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">总之，Jotai图书馆是最轻的国家管理图书馆之一。它还通过与<a class="ae kz" href="https://immerjs.github.io/immer/" rel="noopener ugc nofollow" target="_blank"> Immer </a>、<a class="ae kz" href="https://github.com/akheron/optics-ts" rel="noopener ugc nofollow" target="_blank"> Optics </a>的集成提供了扩展其功能的灵活性，以增强开发体验。比如Jotai支持React DevTools，Persist，支持React钩子，TypeScript等。</p><p id="c95f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，Jotai看起来是一个优秀的国家管理候选人。该库的简单性也使它成为使用React进行状态管理的初学者的一个好选择。最后，感谢您花时间阅读本文。我想看看你下面的问题和评论。</p><p id="5005" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">干杯！</p><h1 id="0e5a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">了解更多信息</h1><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/build-your-own-self-hosted-ci-cd-workflow-with-github-actions-ec9ee1dcd800"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">使用GitHub操作构建您自己的自托管CI/CD工作流</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">GitHub引入了GitHub Actions，使开发人员能够直接从他们的GitHub库自动化工作流…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot jz of"/></div></div></a></div><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/hookstate-the-simplest-state-management-tool-b02f7d3b01a4"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">最简单的状态管理工具</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">小型、最小、简洁、可扩展、基于钩子的状态管理库</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot jz of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://medium.com/swlh/intro-to-recoil-d689a77c5f04" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">反冲介绍</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">反冲是一个反应的状态管理库，是由脸书的实验和开放源码…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot jz of"/></div></div></a></div></div></div>    
</body>
</html>