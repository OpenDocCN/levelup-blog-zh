<html>
<head>
<title>How to Cancel a Running Process in a Separate Request/Command in .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在单独的请求/命令中取消正在运行的进程。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-cancel-a-running-process-in-a-separate-request-command-in-net-c-2ca8fb733618?source=collection_archive---------5-----------------------#2021-12-19">https://levelup.gitconnected.com/how-to-cancel-a-running-process-in-a-separate-request-command-in-net-c-2ca8fb733618?source=collection_archive---------5-----------------------#2021-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c2f8" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">提示和技巧</h2><div class=""/><div class=""><h2 id="c958" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何在单独的请求中取消已经运行的进程。NET C#</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/bb7ddf4095ba8bdb9b2a0834fad7a075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBVFMB5U2OFShVOJ_AQVpA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">马库斯·温克勒在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="17ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我的一个朋友正在做一个独特的项目，他需要能够取消一个长时间运行的过程，但在一个单独的请求。奇怪吗？也许吧，但它已经发生了。让我告诉你更多…</p><p id="c24e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">他正在开发一个带有大量3D建模的Web应用程序。该应用程序应该用于为某个产品构建3D模型，最终用户应该能够以某种格式下载该模型。</p><p id="008c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，建模过程本身是如此繁重，需要大量的处理。这就是为什么最终用户应该提供一些输入，触发建模过程，并且在某个时候，当模型可以下载时，他应该收到一封电子邮件。</p><p id="b5ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，还可以。但是，如果最终用户决定对输入进行一些更改，他可以开始一个新的建模过程，但是已经运行的过程怎么办呢？让它在服务器上运行是明智的吗？？？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><div class="mf mg gp gr mh mi"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw lb mi"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mx"><img src="../Images/f2c0ce505a88bd39480d0200a127aca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oyEEAx1t-pdzP-HEl9cXVQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@tateisimikito?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jukan Tateisi </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c3f4" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">逐步地</h1><p id="a544" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">好了，我要在这里解释的不是火箭科学。不过，还是一步一步来吧。</p><p id="e083" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，让我指出以下几点:</p><ol class=""><li id="9914" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">一些最佳实践可能会被忽略/丢弃，以便将主要焦点转移到本文所涉及的其他概念上。</li><li id="7d3c" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">我们不会创建一个完整的Web应用程序，因为这会包含很多干扰。我们将只使用控制台和Windows窗体应用程序。</li><li id="bcd1" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">本文中包含的代码仅用于演示和解释。在进入生产代码之前，您需要应用一些重构和清理。</li><li id="cf77" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">我将在本文中解释的技术带来了一些挑战。我会在适当的时候告诉你更多关于这些挑战的信息。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="5277" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">当你无法控制的时候</h1><p id="c1ac" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">假设我们有一个简单的<strong class="lk jd">控制台应用程序</strong>。我们有一个<code class="fe oj ok ol om b">TooLongProcess</code>方法，完全执行起来需要一些时间。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="4502" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，我们通过循环10次来模拟这种情况，每次迭代我们等待一秒钟。</p><p id="40a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，调用这个<code class="fe oj ok ol om b">TooLongProcess</code>方法应该如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="9dea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行此命令，最终会得到以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/0a08e14e1b18fbfe9339bf929687c1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QkrMiRCdgaFiB903QvGQOA.png"/></div></div></figure><p id="1977" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很好，但是现在，让我问你，你对已经运行的<code class="fe oj ok ol om b">TooLongProcess</code>有控制力吗？</p><p id="d7fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">答案很简单，不。一旦<code class="fe oj ok ol om b">TooLongProcess</code>方法中的代码启动，我们就无法控制它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="9720" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">让我们来控制一下</h1><p id="f2e5" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">现在，我们想要做一些改变，以便我们获得对已经运行的<code class="fe oj ok ol om b">TooLongProcess</code>的控制。</p><p id="9756" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现这一点，我们将对<code class="fe oj ok ol om b">TooLongProcess</code>方法本身进行如下修改:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6f1e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如您所见，<code class="fe oj ok ol om b">TooLongProcess</code>方法现在需要一个传入的<code class="fe oj ok ol om b">CancellationToken</code>参数。在循环内部，我们检查传入的取消令牌是否被取消。如果是，我们就退出循环，并记录一条消息，说明该过程已被取消。</p><p id="0d18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，调用这个<code class="fe oj ok ol om b">TooLongProcess</code>方法应该如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="b4c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们必须通过一个<code class="fe oj ok ol om b">CancellationTokenSource</code>创建一个取消令牌，并将其传递给<code class="fe oj ok ol om b">TooLongProcess</code>方法。然后我们等待5秒钟，然后取消令牌。</p><p id="4197" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行此命令，最终会得到以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/13421ab407c2fec9568767c30ccef850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zlk-nz3iAX_T8ubls2vA4w.png"/></div></div></figure><p id="b433" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太好了，现在我们可以取消已经运行的<code class="fe oj ok ol om b">TooLongProcess</code>。然而，我们仍然在最初启动<code class="fe oj ok ol om b">TooLongProcess</code>的相同上下文/范围内这样做。</p><p id="daa8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我想从另一个范围取消已经运行的<code class="fe oj ok ol om b">TooLongProcess</code>该怎么办？</p><p id="a562" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果<code class="fe oj ok ol om b">TooLongProcess</code>驻留在一个Web API项目中，而最终用户在另一个时间做出了取消流程的决定，该怎么办？</p><p id="0fb1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可能是通过一个完全独立的请求。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="ab4c" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">新技术</h1><p id="5833" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">为了解释这种技术，我们不打算创建一个完整的Web API或Web应用程序项目，因为这会产生更多的干扰。</p><p id="733e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，我们将创建一个简单的Windows窗体应用程序。应用程序应该如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/0cfd3b08c2479b9c547493d65e841037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*woIuZ94IzI48QWL1fvygCQ.png"/></div></figure><p id="8707" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个简单的表单，有2个<code class="fe oj ok ol om b">ListBox</code>控件和4个<code class="fe oj ok ol om b">Button</code>控件。</p><p id="80ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">主要思想是，当我们单击“Start 1”按钮时，一个长时间运行的过程将开始，它将一直登录到第一个列表框中。每当我们点击“停止1”按钮，已经运行的进程将被取消。</p><p id="0285" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们模拟两个完全独立的请求的方式，就好像这些请求是从Web应用程序的UI触发的，而运行的进程实际上是一个托管在不同服务器上的Web API。</p><p id="fd87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这同样适用于“开始2”和“停止2”按钮。</p><p id="25f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行应用程序时，您应该会看到类似这样的内容:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/87136298bfde61cb7c138995098eb5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*dvZtsrvc_D_9Et6_8aOq9g.png"/></div></figure><p id="0f3c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里发生的是，我们几乎同时点击了“开始1”和“开始2”，然后在5秒钟后我们点击了“停止1”。因此，进程1提前停止，而进程2在10秒后成功结束。</p><p id="3007" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了能够跟进文章的其余部分，您可以访问这个库 上的<a class="ae lh" href="https://github.com/AhmedTarekHasan/ProcessCancellation" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">代码。</strong></a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="85ae" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">代码</h1><p id="efdf" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">现在，我们来看看如何实现这一点。为简单起见，所有代码都将包含在<code class="fe oj ok ol om b">Form</code>代码中，正如您所见。然而，在现实世界中，这并不是好的做法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="31ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我来解释一下主旨。</p><p id="72c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们之前商定的，当我们单击“Start 1”按钮时，应该会启动进程1。这里我们将传入一个我们所学过的<code class="fe oj ok ol om b">CancellationToken</code>,这样我们就可以控制这个过程。</p><p id="f333" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，即使在“开始1”逻辑的上下文/范围之外，我们仍然需要做一些事情来控制。</p><p id="4d99" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要做到这一点，保留对某些内容的引用是合乎逻辑的，这些内容使我们能够取消传入的令牌，即使是从另一个范围。</p><p id="dae5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，我们需要在“Start 1”和“Stop 1”之间有一些共同点，以便“Stop 1”知道如何访问我们为“Start 1”保留的引用。</p><p id="1f3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，我们需要记住，当使用Web应用程序时，我们保留的引用应该是我们可以序列化并通过HTTP请求来回传递的内容。</p><p id="de55" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，虽然<code class="fe oj ok ol om b">CancellationToken</code>(或<code class="fe oj ok ol om b">CancellationTokenSource</code>)本身就是我们需要的引用，但我们不能依赖它作为通过HTTP请求来回发送的东西。</p><p id="c4f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">话虽如此，最好的办法是在创建取消令牌的时候创建一些id，然后这个Id应该作为通过HTTP请求来回发送的密钥。并且，知道了Id，应该给我们提供访问实际的<code class="fe oj ok ol om b">CancellationToken</code>(或者<code class="fe oj ok ol om b">CancellationTokenSource</code>)的途径。</p><p id="8c0f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，现在，让我们检查一下代码，看看我们能注意到什么:</p><ol class=""><li id="2329" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">我们定义了<code class="fe oj ok ol om b">private Guid m_Process1</code>和<code class="fe oj ok ol om b">private Guid m_Process2</code>来保持<code class="fe oj ok ol om b">Guid</code>用于进程1和进程2。</li><li id="c973" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">这些现在是静态的，但是在现实世界中，这些<code class="fe oj ok ol om b">Guid</code>值应该被动态地创建并发送给API调用者，以便它们可以在以后需要时用于取消。</li><li id="2398" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">我们还定义了<code class="fe oj ok ol om b">private Dictionary&lt;Guid, CancellationTokenSource&gt; m_TokensCatalog</code>作为目录，我们将在其中保存每个<code class="fe oj ok ol om b">Guid</code>及其相关的<code class="fe oj ok ol om b">CancellationTokenSource</code>。</li><li id="971f" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">在现实世界中，这是应该在服务器上保存和维护的东西。我有一个关于这方面的笔记，我会在这篇文章的结尾告诉你。所以，确保你不会错过它。</li><li id="053e" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">在<code class="fe oj ok ol om b">BtnStart1_Click</code>事件处理程序中，我们正在创建<code class="fe oj ok ol om b">CancellationTokenSource</code>，在目录中添加一条记录，并调用<code class="fe oj ok ol om b">TooLongProcess</code>方法，传入创建的取消令牌。</li><li id="f9ae" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">同样的逻辑也适用于<code class="fe oj ok ol om b">BtnStart2_Click</code>事件处理程序。</li><li id="72bf" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">在<code class="fe oj ok ol om b">BtnStop1_Click</code>事件处理程序中，我们使用Id和目录来访问适当的<code class="fe oj ok ol om b">CancellationTokenSource</code>，然后在其上触发<code class="fe oj ok ol om b">Cancel</code>方法。</li><li id="9fd1" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">同样的逻辑也适用于<code class="fe oj ok ol om b">BtnStop2_Click</code>事件处理程序。</li></ol><p id="f0f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单吧？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="c994" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">挑战</h1><p id="c756" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">你可能会注意到一些你不喜欢的东西。</p><p id="9884" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们在上一节中所解释的，特别是在第4点上，我们保存<code class="fe oj ok ol om b">CancellationTokenSource</code>引用的目录保存在服务器上，以便我们以后可以使用它们来取消。</p><p id="5097" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可不好。为什么？因为现在我们的API不是无状态的，而是有状态的。</p><p id="4a14" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">换句话说，要实现的最佳目标是，每个请求都不应该拥有关于其他先前或后续请求的任何知识。这样，我们可以应用更多的增强和概念，比如使用<strong class="lk jd">负载平衡器</strong>。</p><p id="4a46" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，现在在服务器上保存了参考目录之后，这就不再有效了。</p><p id="9360" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，如果“开始1”请求被定向到“服务器1”，为了使取消起作用，“停止1”请求也应该被定向到“服务器1”，否则，它不起作用。</p><p id="8c16" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我现在要问你的问题是，你认为事情这样不符合逻辑吗？</p><p id="d901" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好吧，我来解释一下。首先，你的目标是我们有能力在某个服务器上取消一个已经运行的进程。所以，逻辑上应该和某个服务器有一些耦合。</p><p id="93e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，我们不喜欢的是，我们认为我们只有两个选择:</p><ol class=""><li id="190b" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">失去希望，放弃整个取消运行过程的事情。</li><li id="6822" class="nv nw it lk b ll oe lo of lr og lv oh lz oi md oa ob oc od bi translated">使整个应用程序有状态。</li></ol><p id="df65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，我认为这不是真的。我认为您仍然可以让您的应用程序保持无状态，并且能够取消正在运行的进程。然而，要做到这一点，您需要在负载平衡器上做更多的工作。</p><p id="e21b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您的负载平衡器应该负责保存和维护一个将请求Id映射到服务器Id的目录。然后，当带有某个请求Id的取消请求到来时，负载均衡器知道将取消请求定向到哪个服务器。最后，一旦某个服务器收到取消请求，其余的将和以前一样。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/3368e7185a53faa8655ad047c009bed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9amJZoenBeazTphx_tGXzg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@jingdachen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">陈京达</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="ce74" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">最后的话</h1><p id="7d05" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">好了，现在你知道我们在说什么了。不过，不知道大家怎么看。</p><p id="58d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我非常希望得到您的反馈，如果您以前遇到过同样的需求？你对此做了什么？你喜欢什么？你不喜欢什么？…</p><p id="9dfe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就这样，希望你觉得读这个故事和我写它一样有趣。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="9c1a" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="57d4" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">如果您还不是<strong class="lk jd">媒介</strong>的会员，您可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="lk jd">我的推荐链接</strong> </a>，这样我可以从<strong class="lk jd">媒介</strong>中获得您的一部分费用，您无需支付任何额外费用。<br/>▎订阅<a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"> <strong class="lk jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="6bc8" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">其他资源</h1><p id="5bc2" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">这些是你可能会发现有用的其他资源。</p><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/hierarchical-tree-form-data-in-net-c-d2a868fcb756"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">中的分层树形数据。NET C#</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">为分层树形数据及其相关操作设计一个数据结构。NET C#</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="ot l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/the-liskov-substitution-principle-explained-in-net-c-2a838b8a5155"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">里解释的利斯科夫替代原理。NET C#</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">真正理解中SO(L)ID原理的Liskov替换原理。NET C#</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="ou l mt mu mv mr mw lb mi"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure></div></div>    
</body>
</html>