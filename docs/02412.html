<html>
<head>
<title>What happens when you create a class instance in Node.js?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中创建一个类实例会怎么样？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-happens-when-you-create-an-class-instance-in-node-js-c4a2bb237bcb?source=collection_archive---------3-----------------------#2020-03-11">https://levelup.gitconnected.com/what-happens-when-you-create-an-class-instance-in-node-js-c4a2bb237bcb?source=collection_archive---------3-----------------------#2020-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/95c3c3f05024f383ae18a0f471fa775c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_N5Qub83eQhpSYwLxjT6w.jpeg"/></div></div></figure><p id="62e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从JavaScript ES6及更高版本开始，我们能够像在其他编程语言中那样编写类，因此，我们也可以使用<em class="kz"> new </em>关键字以同样的方式创建实例。与此同时，我们得到了一些OOP特性，比如继承。</p><p id="638f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也就是说，JavaScript要成为完全面向对象的语言还有很长的路要走——我们谈论的是普通的JavaScript，所以TypeScript不在讨论范围之内。</p><p id="7416" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，为了理解创建新实例时会发生什么。让我们考虑下面的例子:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="987b" class="lj lk it lf b gy ll lm l ln lo">class Animal{<br/>  species;<br/>  constructor(){}<br/>}<br/><br/>class Dog extends Animal{<br/>  name;<br/>  constructor(){<br/>    super();<br/>  }<br/>}<br/><br/>let max = new Dog();</span></pre><p id="ee63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们仔细看看上面的例子，想一想，当<em class="kz">新狗()</em>被调用时会发生什么？</p><p id="21f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，声明类属性，然后调用类的构造函数，并将必要的值存储在新创建的实例变量<em class="kz"> max </em>中。然后，函数<em class="kz"> super() </em>开始在继承线中上升到<em class="kz"> Animal </em>类，并运行其构造函数，但不运行属性和方法。这就是<em class="kz">扩展</em>关键字的工作，确保父类的所有属性和方法在子类中都是可访问的。</p><p id="5465" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这只是它如何工作的概述。让我们尝试一下，以便更深入地了解发生了什么。首先，我们将把值哺乳动物分配给物种，并把它放在子类中:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="a039" class="lj lk it lf b gy ll lm l ln lo">class Animal{<br/>  species;<br/>  constructor(){<br/>    this.species = 'mammal';<br/>  }<br/>}<br/><br/>class Dog extends Animal{<br/>  name;<br/>  constructor(){<br/>    super();<br/>    console.log(this.species);<br/>  }<br/>}<br/><br/>let max = new Dog();</span></pre><p id="00b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们运行这个程序，你会发现它会把‘哺乳动物’这个词打印到控制台上。这正是我们想要的。让我们看看发生了什么:</p><ol class=""><li id="f023" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky lu lv lw lx bi translated">声明了狗属性名。</li><li id="b4ec" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated">Dog构造函数被初始化，它调用声明父类<em class="kz"> Animal </em>的属性物种的<em class="kz"> super() </em>，并初始化父构造函数。</li><li id="b71e" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated">父构造函数将值哺乳动物赋给物种。</li><li id="7820" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated">Dog构造函数继续并在控制台记录该值。</li></ol><p id="2254" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们在调用super之前先控制日志种类，会发生什么情况:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="b512" class="lj lk it lf b gy ll lm l ln lo">constructor(){<br/>    console.log(this.species);<br/>    super();<br/>  }</span></pre><p id="7f15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当你运行程序时，你会得到一个引用错误，告诉你在使用<em class="kz">这个</em>关键字或者从派生构造函数返回之前，你需要调用<em class="kz"> super() </em>方法。这是有意义的，因为<em class="kz"> super() </em>的行为就好像你正在启动一个实例，但是不管它的父类是什么。超级功能:</p><ol class=""><li id="56cb" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky lu lv lw lx bi translated">启动一个新的父实例，例如，<em class="kz"> new Animal() </em>。</li><li id="268c" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated">用保留当前实例的关键字附加这个实例。</li></ol><p id="ea88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，让我们更疯狂一点。我们将在Dog类中给属性名赋值“max ”,然后在Animal类中给它赋值:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="79ae" class="lj lk it lf b gy ll lm l ln lo">class Animal{<br/>  species;<br/>  constructor(){<br/>    this.species = 'mammal';<br/>    console.log("Name", this.name);<br/>  }<br/>}<br/><br/>class Dog extends Animal{<br/>  name = 'max';<br/>  constructor(){<br/>    super();<br/>    console.log("Species", this.species);<br/>  }<br/>}<br/><br/>let max = new Dog();</span></pre><p id="a5b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在运行上面的代码之前，您能猜到输出会是什么吗？</p><p id="a6e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当你运行这个程序时，它不会中断。然而，虽然在Dog类中分配了<em class="kz"> name </em>属性，但输出将是<em class="kz"> Name undefined </em>。根据我们之前提到的行为，这将被认为是奇怪的，因为我们在类声明上赋值，这是Node中的一个新特性，只在现代浏览器上工作(以防它在您的机器上崩溃，然后您将知道为什么)。</p><p id="dc89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了理解发生了什么，我们需要使用<em class="kz"> console.dir() </em>将<em class="kz">这个</em>输出到控制台:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ee4f" class="lj lk it lf b gy ll lm l ln lo">constructor(){<br/>  this.species = 'mammal';<br/>  console.dir("Object", this); //this will show object details<br/>  console.log("Name", this.name);<br/>}</span></pre><p id="bf5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输出:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="e4af" class="lj lk it lf b gy ll lm l ln lo">//output<br/>'Object'<br/>Name undefined<br/>Dog { species: undefined, name: 'max' }</span></pre><p id="088a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您运行这个程序时，您会注意到两件事:</p><ul class=""><li id="5676" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky md lv lw lx bi translated">虽然您在name字段之前输出对象，但是首先它会显示object，然后Name字段会显示，最后实例细节会显示在最后。</li><li id="7cc3" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky md lv lw lx bi translated">名称在<em class="kz"> this </em>中被初始化，但是当你调用name时它是未定义的。</li></ul><p id="e90f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从中可以了解到的是<em class="kz"> console.dir </em>一直等到继承树构建完成，然后输出它的字段，这意味着在这个阶段对象还没有完全构建好。我们可以通过看到<em class="kz"> this.name </em>返回undefined来证明这一点。</p><p id="387e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的要点是，您不应该期望子类将值传递给其父类的构造函数。但是，您可以稍后在方法中或在新创建的实例中使用它:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="b95a" class="lj lk it lf b gy ll lm l ln lo">let max = new Dog();<br/>max.name;</span></pre><p id="ab3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Node.js的OOP很年轻。它仍然缺少许多特性，包括在封装中非常重要的接口和访问修饰符。为了探索所有Node的新特性，我构建了一个<a class="ae me" href="https://www.npmjs.com/package/oraios-queries" rel="noopener ugc nofollow" target="_blank"> npm包</a>以达到其当前的极限，本文揭开了其中一个奇怪的部分。我打算一有机会就分享更多。</p></div></div>    
</body>
</html>