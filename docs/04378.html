<html>
<head>
<title>Algebraic Data Types and Its Generic Presentation In Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的代数数据类型及其通用表示</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/algebraic-data-types-and-its-generic-presentation-in-scala-d2c1ce7740fe?source=collection_archive---------19-----------------------#2020-06-23">https://levelup.gitconnected.com/algebraic-data-types-and-its-generic-presentation-in-scala-d2c1ce7740fe?source=collection_archive---------19-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5e055853515bf5934285b9f8ec853cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nWJR-PES_WRWXUmQ"/></div></div></figure><p id="c41c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编程的本质是以一种有用的方式编码、解码和操作数据。因此，基于不同的编程理念，有多种方法来表示数据。在函数式编程中，数据表示通常是代数数据类型。</p><p id="7285" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我想简单解释一下在Scala中表示ADT的两种方式。首先是<code class="fe kw kx ky kz b">sealed trait</code>和<code class="fe kw kx ky kz b">case class</code>。另一种在描述数据时不常讨论，但如果您想进行更一般化的编程，它是一般化数据表示的一种替代方式。</p><h1 id="aaae" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">访问ADT(代数数据类型)</h1><p id="ae2e" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">代数数据类型(ADT)是函数式编程概念，对使用“与”和“或”的数据表示有一个好听的名字。</p><p id="19b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在ADT术语中，“ands”通常被命名为产品，“ors”是联产品。我们也可以说余积是和的类型。如果你有兴趣了解更多关于ADT的信息，可以看看我之前关于ADT的<a class="ae md" href="https://edward-huang.com/functional-programming/2019/12/30/what-is-an-adt-algebraic-data-types/" rel="noopener ugc nofollow" target="_blank">帖子。</a></p><p id="b89c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看一个如何表示以下描述的数据的示例:</p><ol class=""><li id="f3b7" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">支付方式可以是信用卡<strong class="ka ir">或</strong> Paypal</li><li id="f7f5" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">信用卡有前四个<strong class="ka ir">和后六个</strong></li><li id="434e" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">Paypal有一个用户名<strong class="ka ir">和</strong>密码</li></ol><h1 id="2ce8" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">用Case类封装特征表示</h1><p id="0a31" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在Scala中，我们将把乘积表示为<code class="fe kw kx ky kz b">case class</code>，并将其协积为<code class="fe kw kx ky kz b">sealed trait</code>，这意味着与<code class="fe kw kx ky kz b">case class</code>的“与”和与<code class="fe kw kx ky kz b">sealed trait</code>的“或”。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="bf82" class="na lb iq kz b gy nb nc l nd ne">sealed trait PaymentMethod<br/>case class CreditCard(name:String, expiryDate:Instant) extends PaymentMethod<br/>case class Paypal(username:String, password:String) extends PaymentMethod</span></pre><p id="1c8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ADT的优点是类型安全。这意味着，编译器完全知道数据类型是什么，使我们能够编写完整的、正确类型的方法，包括我们的类型(基本上更容易模式匹配):</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="713e" class="na lb iq kz b gy nb nc l nd ne">def derivePaymentMethod(paymentMethod:Payment): String =  paymentMethod match {<br/>  case CreditCard(name, expiryDate) =&gt; s"Creditcard name ${name}"<br/>  case Paypal(username, password) =&gt; s"Paypal user $username"<br/>}</span></pre><h1 id="41ae" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">替代数据编码</h1><p id="3e5b" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><code class="fe kw kx ky kz b">sealed trait</code>和<code class="fe kw kx ky kz b">case class</code>无疑是最方便的数据表示方式。一个是它更容易推理和理解，并且使编码数据类型安全。但是，在Scala中还有其他方法可以将数据编码到ADT中。在Scala标准库中，我们可以将乘积表示为<em class="nf">元组</em>，将余积表示为<em class="nf">或者</em>。</p><p id="5f1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们举一个上面的例子:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="82b7" class="na lb iq kz b gy nb nc l nd ne">type PaymentMethod2 = Either[CreditCard, Paypal]<br/><br/>type CreditCard = (String, Instant)<br/><br/>type Paypal = (String, String)<br/><br/>def derivePaymentMethod(paymentMethod: PaymentMethod): String = paymentMethod match {<br/>  case Right((username,password)) =&gt; s"Paypal user $username"<br/>  case Left((name, expiryDate)) =&gt; s"Creditcard name ${name}"<br/>}</span></pre><p id="0d92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<em class="nf">元组</em>和<em class="nf"/>比第一个例子中的<em class="nf"> case类</em>和<em class="nf"> sealed trait </em>可读性差，但是两者具有相同的理想属性。</p><p id="c1c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，<em class="nf">支付方式2 </em>比<em class="nf">支付方式</em>更通用。任何使用一对<code class="fe kw kx ky kz b">String</code>和<code class="fe kw kx ky kz b">Instant</code>操作的代码也可以使用<em class="nf">信用卡</em>，反之亦然。</p><h1 id="ece1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="88c2" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">作为scala开发人员，我们更喜欢用<em class="nf"> case class </em>和<em class="nf"> sealed trait </em>在语义上表示数据，而不是泛型的<em class="nf">元组</em>和<em class="nf">或者</em>。但是，在某些情况下，泛型是可取的。例如，如果我们想将数据序列化为HTML组件，我们不关心字符串或Paypal对。我们把这两个数字写成HTML格式，然后就完事了。通用编程还有助于用很少的代码解决各种类型的问题，避免各种类型之间的重复。</p><p id="fbcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">了解更多关于<a class="ae md" href="https://books.underscore.io/shapeless-guide/shapeless-guide.html" rel="noopener ugc nofollow" target="_blank">不成形的通用编程</a>。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="ae44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nf">原载于https://edward-huang.com</em><a class="ae md" href="https://edward-huang.com/scala/functional-programming/shapeless/2020/06/21/algebraic-data-types-and-its-generic-presentation-in-scala/" rel="noopener ugc nofollow" target="_blank"><em class="nf"/></a><em class="nf">。</em></p></div></div>    
</body>
</html>