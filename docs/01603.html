<html>
<head>
<title>Back to the Future in Clojure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Clojure中的回到未来</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/back-to-the-future-in-clojure-934b85a3d08e?source=collection_archive---------10-----------------------#2020-01-15">https://levelup.gitconnected.com/back-to-the-future-in-clojure-934b85a3d08e?source=collection_archive---------10-----------------------#2020-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c60e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个简单明了的使用期货进行并行处理的例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/07153bc3ac373f5a71a8bb5822291f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6CeBXCx1wBP0tO-9fO7Sg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jamie452?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰米街</a>在<a class="ae kv" href="https://unsplash.com/s/photos/parallel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="3019" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并行处理是一个令人兴奋的话题，尤其是当谈到可以被分割成更小的任务、独立执行、聚合并呈现为唯一结果的繁重流程时。</p><p id="f030" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Clojure提供了不同的方法来完成这种工作，而<em class="ls"> futures </em>是一种方便的方法，可以将一个大任务拆分成多个并行线程，这些线程最终将被启动它们的进程收集起来，允许它聚合结果，以更快的方式提供相同的结果。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8668" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">谈论未来</h1><p id="624a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">你可以把<em class="ls">未来</em>想象成一段在自己独立的线程上运行的代码。更具体地说，<em class="ls"> future </em>是一个Clojure宏，它接受一组表达式，以便在另一个线程中执行它们。宏返回内存中对已触发的<em class="ls">未来</em>的引用。这允许通过一些助手功能与它通信:</p><ul class=""><li id="12d4" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><a class="ae kv" href="https://clojuredocs.org/clojure.core/future_q" rel="noopener ugc nofollow" target="_blank">未来？</a>:验证所提供的参数是未来值。</li><li id="1e4e" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><a class="ae kv" href="https://clojuredocs.org/clojure.core/future-done_q" rel="noopener ugc nofollow" target="_blank">未来完成？</a>:以未来为自变量，验证是否已经完成。</li><li id="833a" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><a class="ae kv" href="https://clojuredocs.org/clojure.core/future-cancel" rel="noopener ugc nofollow" target="_blank">未来-取消</a>:试图取消给定的未来。</li><li id="2d98" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><a class="ae kv" href="https://clojuredocs.org/clojure.core/future-cancelled_q" rel="noopener ugc nofollow" target="_blank">未来-取消？</a>:验证作为参数传递的未来是否被取消。</li></ul><p id="7c9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> future </em>的结果存储在缓存中的某个地方，即使尚未完成，我们也可以通过调用<code class="fe nl nm nn no b">(deref my-future)</code>来尝试获取其结果。在这种情况下，尝试<code class="fe nl nm nn no b">deref</code>的线程将被阻塞，直到<em class="ls">未来</em>完成。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="7f53" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">从Github得到观星者</h1><p id="4f25" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们感兴趣的是获得<a class="ae kv" href="https://github.com/clojure" rel="noopener ugc nofollow" target="_blank"> Clojure </a>在Github上的明星总数。也就是说，属于Clojure帐户的每个存储库中的星的总和。</p><p id="4d7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些信息很容易被Github API获取。<code class="fe nl nm nn no b">GET /users/:username/repos</code> <a class="ae kv" href="https://developer.github.com/v3/repos/#list-user-repositories" rel="noopener ugc nofollow" target="_blank">端点</a>已经响应了每个存储库的星计数。我们可以遍历返回的JSON数组，得到星计数，并对它们求和。</p><p id="c623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于本文的考虑，让我们假设上面的端点不返回星计数，而是返回存储库的名称，这样我们就可以点击<code class="fe nl nm nn no b">GET /repos/:owner/:repo</code> <a class="ae kv" href="https://developer.github.com/v3/repos/#get" rel="noopener ugc nofollow" target="_blank">端点</a>来获得星计数。这意味着对于每个存储库名称，将会向<code class="fe nl nm nn no b">GET /repos/:owner/:repo</code>发出一个请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/ef6f4cc7528d76caee56cf4b0ff64132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*oKyNGafMFIi-EGsqlUyrbw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">同步聚合存储库</figcaption></figure><p id="c39e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上图所示，从每个存储库中获取恒星是一个连续的同步任务，完成每个请求可能需要相当长的时间。一旦所有的请求都被成功响应，那么<code class="fe nl nm nn no b">reduce</code>函数就会开始对所有的星星进行求和。</p><p id="a4cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的函数<code class="fe nl nm nn no b">get-star-count</code>同步执行HTTP请求以获取存储库细节，然后从响应中提取<code class="fe nl nm nn no b">stargazers-count</code>属性，该属性表示星计数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">获取星计数的HTTP请求</figcaption></figure><p id="5322" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们来看看<code class="fe nl nm nn no b">sum-stars</code>函数。它提供了两种算法，一种专门获取用户名，另一种需要一系列存储库名称:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">同步总星计数</figcaption></figure><p id="3fcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，第3行中的第一个arity调用2-arity函数，并将<code class="fe nl nm nn no b">github/repo-names</code>的结果作为第二个参数(<code class="fe nl nm nn no b">repos</code>)发送。这涉及到一个额外的HTTP调用，它阻止我们使用先前定义的序列手动输入repo名称。我们可以避免这个额外的HTTP调用干扰<code class="fe nl nm nn no b">sum-stars</code>，方法是提供一个包含存储库名称的已定义序列，或者将<code class="fe nl nm nn no b">github/repo-names</code>的结果存储在一个符号中，然后将其传递给函数。</p><p id="7f5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个存储库被传递给第6行的<code class="fe nl nm nn no b">get-star-count</code>，阻塞主线程，直到每个请求同步完成。然后由<code class="fe nl nm nn no b">reduce</code>汇总结果。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f5f3" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">行动中的未来</h1><p id="4540" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在我们将使用<em class="ls">期货</em>实现相同的功能。这一次，将为每个存储库启动一个执行<code class="fe nl nm nn no b">GET /repos/:owner/:repo</code>的<em class="ls">未来</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e72fbc32e5e66ffc19dea352c5d5a382.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*1jHR3i2Q1A4eqKyPwoBuUQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">异步聚合存储库</figcaption></figure><p id="24c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个HTTP请求都是并行工作的，如上图所示。使用<code class="fe nl nm nn no b">future</code>宏在A点触发<em class="ls">期货</em>。一旦他们都准备好了他们的回答，就可以利用<em class="ls">列表理解</em>使他们在B点相遇，以便简化为唯一的结果。</p><p id="beb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，有些请求可能比其他请求花费的时间长，因为它们取决于网络吞吐量、Github服务器的延迟，甚至是运行线程的处理器的速度。因此，这个场景的最坏情况是需要更多时间来完成的请求，因为那将是完成<code class="fe nl nm nn no b">sum-stars</code>的时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1-arity函数与同步版本中的基本相同。给定用户名的所有回复都被传递给2-arity函数。</p><p id="33c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的部分从第5行开始，用<code class="fe nl nm nn no b">for</code>语句创建了一个对<em class="ls">期货</em>的列表理解。也就是说，<em class="ls"> futures </em>(第6行)的序列表示独立工作的线程在内存中的位置。有了这个<em class="ls">未来</em>的序列，我们就可以使用之前解释过的帮助函数与它们交流，或者简单地尝试<code class="fe nl nm nn no b">deref</code>并得到结果。</p><p id="fc6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第7行中的管道展示了聚合每个结果的过程。使用<code class="fe nl nm nn no b">deref</code>将<em class="ls">期货</em>的序列传递给<code class="fe nl nm nn no b">map</code>。这将阻塞主线程，直到每个并行线程完成。一旦<code class="fe nl nm nn no b">deref</code>结束，对<em class="ls">未来</em>的列表理解就变成了一系列带有实际星星计数的响应。然后，它们被传递给<code class="fe nl nm nn no b">reduce</code>函数，该函数简单地对它们求和。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="70ab" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">标杆管理</h1><p id="628c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们看看同步和异步版本有多快。为了做到这一点，我们将使用方便的<code class="fe nl nm nn no b">time</code>函数，它是<code class="fe nl nm nn no b">clojure.core</code>的一部分。</p><h2 id="cac0" class="nt mb iq bd mc nu nv dn mg nw nx dp mk lf ny nz mm lj oa ob mo ln oc od mq oe bi translated">考虑</h2><ul class=""><li id="e3a3" class="mx my iq ky b kz ms lc mt lf of lj og ln oh lr nc nd ne nf bi translated">在MacBook Pro上执行，macOS Catalina 10.15.1，2.2GHz 6核Intel i7，16 GB 2400 MHz DDR4。</li><li id="5a2f" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">Github上的<a class="ae kv" href="https://github.com/clojure" rel="noopener ugc nofollow" target="_blank"> Clojure </a>帐户用于测试。</li><li id="0d30" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe nl nm nn no b">github/repo-names</code>被限制返回30个回购，尽管<a class="ae kv" href="https://github.com/clojure" rel="noopener ugc nofollow" target="_blank"> Clojure </a>拥有85+。</li><li id="d1e2" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">基于以上观点，测试考虑了来自<a class="ae kv" href="https://github.com/clojure" rel="noopener ugc nofollow" target="_blank"> Clojure </a>账户的30个存储库。</li></ul><pre class="kg kh ki kj gt oi no oj ok aw ol bi"><span id="4657" class="nt mb iq no b gy om on l oo op">user=&gt; (def username "clojure")<br/>user=&gt; (def repos (github/repo-names username))<br/>user=&gt;<br/>user=&gt; (time (core/sum-stars username repos))<br/>"Elapsed time: 13841.095288 msecs"<br/>20263<br/>user=&gt;<br/>user=&gt; (time (core/sum-stars-async username repos))<br/>"Elapsed time: 587.558128 msecs"<br/>20263<br/></span></pre><p id="4fcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看到，两个版本的结果是一样的<code class="fe nl nm nn no b">20263</code>，代表了Github上Clojure的前30个库的总星数。但是同步版本的运行时间几乎是14秒，不像异步调用的587.55毫秒。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e3ae" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="2f97" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">并行处理提供了一种强大的方法，可以将一项繁重的任务分解成更小的独立问题，这些问题一旦完成就可以聚合在一起。Clojure中的期货是完成这类任务的一种强大且易于使用的方法。</p><p id="fdff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次你在处理一个需要很长时间才能完成的函数时，考虑使用<em class="ls">期货。</em></p><p id="f320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘记克隆和使用本文的<a class="ae kv" href="https://github.com/jovannypcg/parallel-processing" rel="noopener ugc nofollow" target="_blank">代码。</a></p><p id="3fde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p></div></div>    
</body>
</html>