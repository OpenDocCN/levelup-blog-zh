<html>
<head>
<title>Using Protocols for separation of concerns in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用分离问题的协议</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-protocols-for-separation-of-concerns-in-swift-54c3c00d6bf5?source=collection_archive---------6-----------------------#2020-01-03">https://levelup.gitconnected.com/using-protocols-for-separation-of-concerns-in-swift-54c3c00d6bf5?source=collection_archive---------6-----------------------#2020-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bac8e6013e8fa820ca990d3bbda5913e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o5SJqb_neXmW-Ua8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">西蒙·瑞在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="47cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">当你想创建一个可维护的代码库时，关注点分离</strong>是一个非常重要的原则。在较低的层面上，它可以与来自<strong class="kf ir">固体</strong>缩写的<strong class="kf ir">单一责任原则(SRP) </strong>紧密相关。</p><h1 id="a1d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">定义</h1><p id="a867" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf ir">关注点分离(SoC) </strong> —是一个设计原则，告诉我们将一个程序分成不同的部分，每个部分负责一个单独的关注点。一个关注点是一组逻辑，或者影响所述问题领域的信息。使用<strong class="kf ir"> SoC </strong>的程序可以被认为是模块化的，当关注领域内的逻辑被良好定义的抽象封装时，就实现了模块化。(<a class="ae kc" href="http://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">http://en.wikipedia.org/wiki/Separation_of_concerns</a>)</p><p id="22e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">单一责任原则(SRP) </strong> —是<strong class="kf ir">固体</strong>首字母缩略词的一部分，声明每个类、模块或函数都应该对所讨论的功能的单一部分负责。这种责任应该由这个类来完成。(<a class="ae kc" href="http://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">http://en . Wikipedia . org/wiki/Single _ respons ibility _ principle</a></p><h1 id="97fa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么重要？</h1><blockquote class="me mf mg"><p id="b251" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">“[关注点分离]，即使不完全可能，也是我所知道的唯一有效整理一个人思想的技术。”埃德格·w·迪杰斯特拉</p></blockquote><p id="ccfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如Dijkstra所说，它是代码组织、可读性的关键元素，从架构的角度来看，它是构建分层应用的关键概念。除了分离模块之间的逻辑，关注点的分离允许开发人员以模块化的方式创建特性和组件，并将它们作为插件使用。</p><p id="353d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主要思想是应该避免在设计或代码中混合关注点。例如，表示层不应该关心如何接收数据来呈现，而应该关心如何格式化这些数据。</p><h1 id="ff52" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">敬代码！</h1><p id="6f45" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们假设您需要基于<a class="ae kc" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者</a>模式创建一个事件分派工具。</p><p id="f89b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的职责是发送和接收事件，所以实现可能是这样的:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是让我们想一想…</p><p id="48e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有处理事件的组件都需要发送和接收事件吗？</p><p id="d3e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不。有些人关心的是<strong class="kf ir">观察</strong>他们，有些人关心的是<strong class="kf ir">派遣</strong>，但是当然，有些人需要两者都做。</p><p id="a05d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Swift可以使用<strong class="kf ir">协议</strong>和<strong class="kf ir">协议组合</strong>帮助我们更好地分离这一点。让我们重写之前的代码:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="9b62" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用</h1><p id="b0d9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们假设我们有之前讨论过的那三个人:一个需要<strong class="kf ir">观察</strong>，一个需要<strong class="kf ir">分派</strong>事件，另一个需要两者都做。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="9d09" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e131" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">上面的技术在创建你的API的时候非常有用。不要创建包含所有需要公开的方法的大协议，可以创建包含更多定义的上下文和职责的小协议。</p><p id="e227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法可以使您的代码更加简洁易读。通过保持你的界面简单，只关注它真正需要的，你可能会得到一个更易测试和维护的系统。</p></div></div>    
</body>
</html>