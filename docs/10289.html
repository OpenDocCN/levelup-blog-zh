<html>
<head>
<title>Your Unit Test Coverage Metrics Lie</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的单元测试覆盖度量是错误的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/your-unit-test-coverage-metrics-lie-7c81bdece5eb?source=collection_archive---------17-----------------------#2021-11-17">https://levelup.gitconnected.com/your-unit-test-coverage-metrics-lie-7c81bdece5eb?source=collection_archive---------17-----------------------#2021-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb12" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何揭开真相</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/91f6dd7ae40a82df384bae2fd7bdf834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tXOMPKNuli4DZvokrzkRKQ.jpeg"/></div></div></figure><p id="5c58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为开发人员，我们非常信任我们的ide。这些应用程序在我们的工作流程中赢得了特殊的位置，这是有原因的。他们就像一匹可靠的骏马，带着我们走过作为工程师的各种旅程。</p><p id="f6ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，有时我们对这些工具过于自信，会把我们引入歧途。对于那些编写单元测试的人来说，你可能已经不知不觉地掉进了这个坑。尽管你的马尽了最大努力告诉你，但它能做的也就这么多了。</p><p id="1223" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当谈到提供关于你的单元测试覆盖的见解时，有时我们需要下马，独自踏上这段旅程。本文将重点讨论这个陷阱，以及我们如何能够并且应该保持警惕，以避免其潜在的危险后果。</p><h1 id="2ed2" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">暴露的陷阱</h1><p id="ca11" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">说实话，在我们的IDE中，太容易相信覆盖率度量报告了。出现在编辑栏中的红绿条对它所呈现的信息的假设往往过于简单和天真。</p><p id="0bfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用一个代码示例来支持这种说法。考虑这个用Kotlin编写的构造函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">一个简单的MVC实现，演示单元测试的脆弱性</figcaption></figure><p id="f68c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个好的单元测试套件将确保所有的输出(或者，在这种情况下，副作用)都被评估。然而，由于我们的IDE和覆盖率报告工具不是人类的，它们很容易被愚弄。考虑这个测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">一个错误的单元测试，只测试了一个副作用，给了我完整功能覆盖的荣誉</figcaption></figure><p id="5015" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，我只验证第一个属性是否已设置。然而，在IDE的阴沟里寻找给了我测试整个功能的信任。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/7643c0891de2d1d486b86dcf35fc3d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xCw-d3skaicFC2uT.jpg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Android Studio中的覆盖率报告错误地显示了具有完全覆盖率的构造函数</figcaption></figure><p id="4317" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了显示命中和未命中的信息，槽中的颜色实际上没有什么附加价值。它测量一行代码在执行过程中是否被触及，而不是测试是否令人满意。</p><p id="6b72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许我们被训练成知道这是真的，但是在平凡的unite测试中很容易忘记这一点。对此能做些什么呢？</p><h1 id="eed1" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">为你的报道创建一个心理地图</h1><p id="2d46" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">编写代码时，有必要改变您对工具的期望。这是我们从众所周知的骏马上下来把事情掌握在自己手中的时刻。</p><p id="acb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你为一个新的函数、类或者代码段编写测试时，通过在你的头脑中从上到下的迭代来创建一个你已经覆盖的内容的思维地图是有帮助的。当你编写一个新的测试来覆盖一个特定的场景时，在你的头脑中检查这些行，然后向下移动到下一个分支。</p><p id="7802" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使你在IDE gutter的覆盖报告中得到了警报解除，也要忍住放松警惕的冲动，直到你的心理地图完成。让这一点为你所用的一些技巧:</p><ul class=""><li id="0e20" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated">更小的、特别关注的函数更容易在你的头脑中测试和维护这种映射。</li><li id="0c2e" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">在构建你的思维地图时，记录下所有的返回值和副作用。这个事实是金钥匙。输入和返回值/副作用之间的一切都只是你需要模仿的噪音。</li><li id="2e3b" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">不要忘记测试视觉上紧凑的代码周围的边界情况，例如零合并操作符(也称为Elvis操作符<code class="fe ni nj nk nl b">?:</code>)和三元操作符。</li></ul><h1 id="4a63" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">利用你的优势</h1><p id="adbd" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">每个使用Git的人都见过一个diff，所以我不需要详细说明它提供的好处。虽然思维导图对新代码很有帮助，但Git可以帮助您清理旧代码中的变化。</p><p id="e145" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您向现有结构中插入新代码并准备单元测试时，请考虑保持Git diff打开，这样您就可以快速消除不需要新测试或思维导图的代码部分。我的偏好是使用<a class="ae nm" href="https://go.oliverspryn.com/vscode" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/26e70b48986ed70d4a13e80a5d08d1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-o2pAWWNWj8Ifb6W.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Visual Studio代码中的Git diff，来自GitHub 上的<a class="ae nm" href="https://go.oliverspryn.com/vs-code-git-diff" rel="noopener ugc nofollow" target="_blank">项目库</a></figcaption></figure><p id="7ddb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法将使关注您需要覆盖什么代码以及您应该如何最有效地完成它变得更加简单。这是一个可靠的方法，给了我丰厚的回报。</p><h1 id="d296" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">定期生成详细的覆盖率报告</h1><p id="37cc" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">如前所述，我对IDE生成的覆盖率报告的经验很少。当我真的需要更好地了解我的覆盖率时，我首先求助于分析代码的工具。</p><p id="94ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我指的是工具本身生成的详细的覆盖报告。对于我的日常开发，这将是JaCoCo对我的Kotlin应用程序的报告。虽然所有工具生成的指标都有相同的局限性，但是红绿条和详细指标之间的差异是惊人的。</p><p id="c0e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个例子，我有一个用Kotlin编写的Android应用程序，并由JaCoCo进行分析。这是我的应用程序覆盖健康状况的5000英尺视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/0ab05b7118638a7e25fc8c6641e0b7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pHFnEGjoU_QUr2cB.jpg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">JaCoCo为我的整个Android应用程序生成的全面覆盖报告</figcaption></figure><p id="b8bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法的真正优势是显而易见的，只要您深入到测试中的单元，并可视化每一个可能的覆盖度量。例如，在我的测试中，我遗漏了零合并操作符。JaCoCo指出这一行只有部分覆盖，而IDE将它标记为绿色。避免陷阱！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/9531aee4e3ea7aa59893f3f746569fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Lek8oGAVjfFWLU9L.jpg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">详细的覆盖报告在第100行显示了一个遗漏的分支</figcaption></figure><h1 id="0fe1" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="c9c9" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">每当我们工程师承担单元测试的责任时，我们都致力于更高的标准，并摒弃无忧无虑的编码实践。这项工作有时很有挑战性，我们会发现自己只能靠自己的手段来确保每个细节都得到正确处理。</p><p id="f738" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们必须保持在游戏的顶端，以实现单元测试的全部意图。虽然我们可以依靠可用的工具来帮助我们填补测试覆盖中的明显空白，但最终还是要靠我们对细节和记忆的关注来确保不遗漏任何一行或分支。</p><p id="39fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的工具尽了最大努力来帮助我们，但它们仍然倾向于在数字中加入一些善意的谎言。作为聪明的工程师，我们必须监管这些工具及其数量，以确保准确性。这样做，我们的应用程序将会从更好的测试中获益，并且我们可以对我们声称达到的覆盖率感到更好。</p><h1 id="9a31" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">喜欢你读的东西吗？</h1><p id="2f92" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">媒体上还有成千上万篇类似的文章。我是这个网站的付费会员，我完全认为这项投资是值得的。<a class="ae nm" href="https://go.oliverspryn.com/medium-membership" rel="noopener ugc nofollow" target="_blank">点击这里加入</a>，你将会用你的一部分会员资格来支持我的工作。</p><p id="3c93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文原载于https://oliverspryn.com/<a class="ae nm" href="https://go.oliverspryn.com/your-unit-test-coverage-metrics-lie" rel="noopener ugc nofollow" target="_blank">。</a><a class="ae nm" href="https://go.oliverspryn.com/medium-subscribe" rel="noopener ugc nofollow" target="_blank">加入我的邮件列表。</a></p></div></div>    
</body>
</html>