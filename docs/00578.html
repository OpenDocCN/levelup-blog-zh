<html>
<head>
<title>When To Use ‘unknown’ and ‘never’ Types in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时在TypeScript中使用“未知”和“从不”类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/when-to-use-unknown-and-never-types-in-typescript-6cd4a54b79b7?source=collection_archive---------1-----------------------#2019-05-15">https://levelup.gitconnected.com/when-to-use-unknown-and-never-types-in-typescript-6cd4a54b79b7?source=collection_archive---------1-----------------------#2019-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/23a270e71bd2cdeb4c69940f876ff946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hSszyRF6bsFBPPHQ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@maxcodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Nelson </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b9af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两种类型是使用TypeScript的人通常不知道的，或者知道但从未使用过的…你看到我在那里做了什么吗？这篇博客只是简单地解释了如何以及何时可以使用这些类型。</p><h1 id="692d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">这两种类型是</h1><ul class=""><li id="fa52" class="mc md it ki b kj me kn mf kr mg kv mh kz mi ld mj mk ml mm bi translated">未知的</li><li id="5e62" class="mc md it ki b kj mn kn mo kr mp kv mq kz mr ld mj mk ml mm bi translated">从不</li></ul><h2 id="c3e4" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my ls kv mz na lw kz nb nc ma nd bi translated">使用的先决条件</h2><ul class=""><li id="9b51" class="mc md it ki b kj me kn mf kr mg kv mh kz mi ld mj mk ml mm bi translated">TypeScript 3+为<code class="fe ne nf ng nh b">unknown</code>类型</li><li id="9557" class="mc md it ki b kj mn kn mo kr mp kv mq kz mr ld mj mk ml mm bi translated">TypeScript 2+为<code class="fe ne nf ng nh b">never</code>类型</li></ul><h1 id="2b30" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">未知类型</h1><p id="e8e5" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated"><code class="fe ne nf ng nh b">unknown</code>型通常用来避免<code class="fe ne nf ng nh b">any</code>型。我们不是没有类型或任何类型，而是将它分配给<code class="fe ne nf ng nh b">unknown</code>。分配给这种类型的所有内容都会导致错误，除非您在某个时候将它分配给另一种类型。</p><p id="9d39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以基本上我们一开始不知道类型，但是<strong class="ki iu">需要</strong>稍后将它分配给一个已知的类型。现在，您被迫键入check。</p><h2 id="88b7" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my ls kv mz na lw kz nb nc ma nd bi translated"><code class="fe ne nf ng nh b">unknown</code>类型的示例:</h2><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/6eab80b9e890edfd0e95b48bb6e82b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8JdjzrXBYlw1Gz5MFW3rA.png"/></div></div></figure><h1 id="1365" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从不型</h1><p id="e38e" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">使用<code class="fe ne nf ng nh b">never</code>类型，我们可以检测不可到达的代码，或者检查一个函数/方法是否在应该返回的时候没有返回任何东西。有三种使用方法；</p><ul class=""><li id="ddc4" class="mc md it ki b kj kk kn ko kr nq kv nr kz ns ld mj mk ml mm bi translated">当函数/方法有返回类型时，它从不返回值</li><li id="e8f9" class="mc md it ki b kj mn kn mo kr mp kv mq kz mr ld mj mk ml mm bi translated">函数/方法总是会抛出错误</li><li id="bfe9" class="mc md it ki b kj mn kn mo kr mp kv mq kz mr ld mj mk ml mm bi translated">分配给<code class="fe ne nf ng nh b">never</code>类型属性的函数/方法</li></ul><h2 id="34f2" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my ls kv mz na lw kz nb nc ma nd bi translated"><code class="fe ne nf ng nh b">never</code>型的例子:</h2><p id="3d32" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">如果我们不在<code class="fe ne nf ng nh b">neverEndingMethod</code>中传递一个字符串或布尔值作为参数，那么它总是会抛出一个错误。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/59fe1227b84426bc2ada186fc6a704c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRLIKSe3mWRh71HVq05GNQ.png"/></div></div></figure><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/32733d2384a67baad7e4aeb9910a9128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3X_icsOAC05Pjo4W4hL_w.png"/></div></div></figure><h2 id="0280" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my ls kv mz na lw kz nb nc ma nd bi translated">类型“never”与“void”不同</h2><p id="99ea" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">不同的是:</p><ul class=""><li id="7657" class="mc md it ki b kj kk kn ko kr nq kv nr kz ns ld mj mk ml mm bi translated">一个不返回任何东西的函数/方法，可以有返回类型:<code class="fe ne nf ng nh b">void</code>。也可以赋值。</li><li id="7662" class="mc md it ki b kj mn kn mo kr mp kv mq kz mr ld mj mk ml mm bi translated">一个函数/方法，当它应该返回某个东西时，从不返回值，或者总是抛出一个错误，那么它可以有返回类型:<code class="fe ne nf ng nh b">never</code>。它只能分配给另一个<code class="fe ne nf ng nh b">never</code>。</li></ul></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="a3c3" class="le lf it bd lg lh oc lj lk ll od ln lo lp oe lr ls lt of lv lw lx og lz ma mb bi translated">感谢您的阅读！我的<a class="ae kf" href="https://github.com/jeroenouw/" rel="noopener ugc nofollow" target="_blank"> Github </a>。如果你觉得这篇文章有用，可以考虑看看我的其他文章:</h1><div class="oh oi gp gr oj ok"><a href="https://medium.com/datadriveninvestor/angular-7-share-component-data-with-other-components-1b91d6f0b93f" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">角度10-与其他元件共享元件数据</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">使用Angular的输入、输出、EventEmitter和ViewChild共享组件数据。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy jz ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://medium.com/@jeroenouw/understand-async-await-in-typescript-in-only-a-few-minutes-dedb5a18a2c" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">理解TypeScript中的Async/Await——只需几分钟</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">让我们不要浪费时间，快速了解TypeScript中的async/await</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy jz ok"/></div></div></a></div></div></div>    
</body>
</html>