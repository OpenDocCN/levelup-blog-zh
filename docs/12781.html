<html>
<head>
<title>Testing complex mono projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试复杂的单声道项目</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-complex-mono-projects-ea06dc879f2?source=collection_archive---------3-----------------------#2022-07-08">https://levelup.gitconnected.com/testing-complex-mono-projects-ea06dc879f2?source=collection_archive---------3-----------------------#2022-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="593b" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">你不能强制要求生产力，你必须提供工具让人们成为最好的。</p><p id="652f" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">史蒂夫·乔布斯</p></blockquote><p id="e460" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">Monorepo是在单一代码空间中管理复杂项目的独立组件的一个很好的解决方案。</p><p id="0c9e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这极大地减少了在层和独立组件之间传播代码更改所需的时间，因此对开发人员的生产力有积极的影响，并减少了管理交叉依赖的痛苦。</p><p id="a77c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">但是只采用这种方法作为代码结构化模式就像额外证明了一句名言“<em class="js">如果我唯一的工具是锤子，那么每个问题都是钉子</em>”。</p><p id="0b08" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">将单一用途的项目和组件收集到一个可管理的工作空间中，可以更全面、更可靠地验证该工作空间的所有部分，以及作为完整解决方案的完整工作空间。</p><p id="d904" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">作为单个工作空间一部分的单一用途组件和项目的一个非常常见的例子是REST API服务应用程序，它由公司标准化的公共库和客户SPA组成，客户SPA是该REST API服务器的消费者，并且还与其共享公共元素，如传输对象、认证/安全组件等。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/760e6ed92911e26b30b69037549c69ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCg3G_Gc25e96OAr4BtSdQ.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">多项目解决方案</figcaption></figure><p id="2249" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在同一个monorepo中包含所有单独的组件和这些组件的主要消费者(APP和API项目)是高效代码结构的一个例子。每个单独的组件都可以拥有自己的<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/structuring-complex-projects-5a4cb3b80fe5">个性化构建上下文，以产生自给自足的工件供以后使用</a>。</p><p id="956a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">但是全局构建上下文呢？只对单个组件进行测试，我们能确保整个流程(在重新加载后按下UI上的按钮产生正确的网格数据)也能像预期的那样工作吗？</p><p id="8826" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">将根项目作为单个工作区的一部分，可以更好地验证完整的E2E行为，因为我们将所有部分逻辑地连接在一起，以启动用户点击、处理API请求并将响应绑定到用户表单。</p><p id="09af" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">因此，也许我们也可以将monorepo不仅视为一种代码结构模式，还可以视为一种具有逻辑连接的组件的上下文，这些组件用于单一目的？而“全局构建上下文”是将所有项目和模块作为一个完整的业务单元来管理和操作的一种方式？</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lj"><img src="../Images/fc92a14c4a9ae9bde1eda21396a8f9cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59QAE0iymG347MkAp5Oeqg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">有目标的多项目解决方案</figcaption></figure><p id="7cca" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">对于这个树中的所有依赖组件，所有的自动化设置都已经就绪，我们仍然在努力处理一个完整的端到端流程:API项目需要数据库访问来存储其数据，而APP项目需要一个工作的API服务器来使用。</p><p id="2003" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">因此，在检查过程中对所有需要的部分进行模拟并不能让我们对整体质量状态有充分的信心。</p><p id="30bc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">因此，采用monorepo模式的下一步不仅是加强解决方案结构以实现更好的代码重用，还要确保所有组件和根项目都可以作为一个涵盖完整端到端用户场景的单一平台进行管理和验证。</p><h1 id="878b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">实践经验</h1><p id="f8a1" class="pw-post-body-paragraph jq jr iq jt b ju mi jw jx jy mj ka kb kp mk ke kf kq ml ki kj kr mm km kn ko ij bi translated"><strong class="jt ir">已知:</strong> REST API服务和SPA项目(该API的消费者)是单个monorepo的一部分。演示解决方案可以在<a class="ae li" href="https://github.com/donvadicastro/medium-monorepo-testcontainsers" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="9dd1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">需求</strong>:确保完整的E2E检查(从浏览器到数据库)是CI验证的一部分，不需要单独的部署作为测试前提。</p><p id="7a89" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">工具集:</strong></p><ul class=""><li id="2c90" class="mn mo iq jt b ju jv jy jz kp mp kq mq kr mr ko ms mt mu mv bi translated"><a class="ae li" href="https://nx.dev" rel="noopener ugc nofollow" target="_blank"> NX monorepo框架</a></li><li id="a2ae" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated"><a class="ae li" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">SPA的角度</a></li><li id="7b45" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated"><a class="ae li" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank">后端API的NestJS </a></li><li id="7eb4" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated"><a class="ae li" href="https://github.com/testcontainers/testcontainers-node" rel="noopener ugc nofollow" target="_blank"> TestContainers </a>作为测试基础设施层提供者</li><li id="9837" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">测试用<a class="ae li" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank">小丑</a>和<a class="ae li" href="https://pptr.dev/" rel="noopener ugc nofollow" target="_blank">木偶师</a></li></ul><p id="1dfa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">设计要点:</strong></p><ul class=""><li id="8b6e" class="mn mo iq jt b ju jv jy jz kp mp kq mq kr mr ko ms mt mu mv bi translated">monorepo中的每个应用程序都有自己的构建上下文，作为一个完全独立的部分，它充分确保了应用程序的质量。此外，这个构建上下文足以生成一个可部署的工件。</li><li id="a519" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">有一个聚合的公共构建上下文，其主要目的是检查monorepo中连接在一起的所有项目的端到端流程。它也是充分的，足以确保解决方案的质量，而不需要应用任何嘲弄策略。</li></ul><p id="3c7d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">实施注意事项:</strong></p><p id="6f77" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">NX框架允许使用单个构建流程管理许多连接的部分，我们所需要的就是正确定义依赖顺序和任务执行顺序。我们在解决方案中有3个项目:</p><ul class=""><li id="6eca" class="mn mo iq jt b ju jv jy jz kp mp kq mq kr mr ko ms mt mu mv bi translated">API——NestJS REST API服务，它公开了<code class="fe nb nc nd ne b">users</code>端点以将用户负载加载和存储到Postgres数据库中</li><li id="0c68" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">APP-Angular前端项目，用于使用REST API并呈现存储的用户</li><li id="f279" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">APP-e2e——验证所有连接件作为一个完整单元的测试项目</li></ul><p id="1630" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">让我们保持API和APP项目独立，APP-E2E <a class="ae li" href="https://github.com/donvadicastro/medium-monorepo-testcontainsers/blob/main/apps/app-e2e/project.json#L35" rel="noopener ugc nofollow" target="_blank">依赖于这两个</a>:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nf"><img src="../Images/169c7f56cde4e063287296c14dab6177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJC79y3eG1S25-Y3NeQOow.png"/></div></div></figure><p id="355a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">同样，完整的E2E流程将要求构建工件在测试开始前准备好，所以也把它作为测试目标的<a class="ae li" href="https://github.com/donvadicastro/medium-monorepo-testcontainsers/blob/main/apps/app-e2e/project.json#L20" rel="noopener ugc nofollow" target="_blank">明确需求</a></p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ng"><img src="../Images/8515832b8745700f531c2c4fdca5c53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhFQbcSPoVBG5pDR70jHdQ.png"/></div></div></figure><p id="3d3d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">准备就绪后，运行<code class="fe nb nc nd ne b">npm test</code>命令查看执行顺序:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nh"><img src="../Images/0bb65db95f6bf6629230ea9737ae66a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7yvmE1QnFW1swo7y_ha2A.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">执行顺序</figcaption></figure><p id="1153" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">正如我们所看到的——依赖项目将首先被测试。如果一切顺利，那么构建工件就准备好了，完整的E2E流程验证也就执行了。目前一切都好。</p><p id="1741" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">下一步是描述基本的验证场景:将用户存储在真实的数据库中，并在用户页面上显示出来。最重要的是，这应该是一个完整的E2E测试(从API调用到存储在数据库中)。</p><p id="ee60" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">出于这个目的，我们可以使用<code class="fe nb nc nd ne b">testcontainers</code>——一个帮助提供docker组件作为单一测试执行的一部分的工具。我们可以把它作为一个<a class="ae li" href="https://github.com/donvadicastro/medium-monorepo-testcontainsers/blob/main/apps/app-e2e/jest.config.ts#L16" rel="noopener ugc nofollow" target="_blank">测试的预初始化阶段来做:</a></p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ni"><img src="../Images/ba0248b6f0b9a9645d1817ccd2715222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*meSpL1yL_r2WLy3D5A_BvQ.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">apps/app-e2e/jest.config.ts</figcaption></figure><p id="8942" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">和<a class="ae li" href="https://github.com/donvadicastro/medium-monorepo-testcontainsers/blob/main/apps/app-e2e/tests/globalSetup.ts" rel="noopener ugc nofollow" target="_blank">设置</a>来提供所需的组件:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nj"><img src="../Images/121798bafe06c5c132c609286c702b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZctAeluKn32qMMw1bBCIg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">应用程序/应用程序-e2e/测试/全局设置. ts</figcaption></figure><p id="54b0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">仔细看一下，我们可以看到启动脚本是这样做的:</p><ul class=""><li id="413a" class="mn mo iq jt b ju jv jy jz kp mp kq mq kr mr ko ms mt mu mv bi translated">使用正式的“postgres”映像启动PostgreSQL容器</li><li id="48df" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">从本地<a class="ae li" href="https://github.com/donvadicastro/medium-monorepo-testcontainsers/blob/main/apps/api/tests/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>构建“ApiContainer ”,然后启动它</li><li id="e746" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">通过env变量提升Postgres访问信息服务容器</li></ul><p id="5f5e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">最后一步是通过E2E测试管理用户<a class="ae li" href="https://github.com/donvadicastro/medium-monorepo-testcontainsers/blob/main/apps/app-e2e/tests/e2e/api.spec.ts" rel="noopener ugc nofollow" target="_blank">来涵盖这个场景</a></p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nk"><img src="../Images/a9e3b4b7ee18128ac359547626da6038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fob2pDK23F_-WrQUPUnPrw.png"/></div></div></figure><p id="74ee" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">该测试不言自明:</p><ul class=""><li id="b30d" class="mn mo iq jt b ju jv jy jz kp mp kq mq kr mr ko ms mt mu mv bi translated">服务作为容器启动，我们配置请求对象</li><li id="82b0" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">我们通过请求API端点来存储一些用户，进一步检查操作是否成功</li><li id="9426" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">最后检查是否所有存储的用户都可以从持久存储器(Postgres)中请求</li></ul><p id="ad85" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">下一步是<a class="ae li" href="https://github.com/donvadicastro/medium-monorepo-testcontainsers/blob/main/apps/app-e2e/tests/e2e/app.spec.ts" rel="noopener ugc nofollow" target="_blank">覆盖UI部分，并检查存储的用户是否被成功呈现</a> —这包括接下来的验证:</p><ul class=""><li id="d4a2" class="mn mo iq jt b ju jv jy jz kp mp kq mq kr mr ko ms mt mu mv bi translated">APP service已启动并作为Docker容器实例运行</li><li id="3eac" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">正确配置应用服务以访问API服务(也作为Docker容器实例启动)</li></ul><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nl"><img src="../Images/49648679bb5b1c5bdd6d08ff904d65fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHgvGpNS4UTUUHpazUMpXw.png"/></div></div></figure><p id="4836" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">让我们运行测试，并通过直接导航到所提供的docker实例的URL来检查结果(例如，在我的例子中是<a class="ae li" href="http://localhost:49164/" rel="noopener ugc nofollow" target="_blank"> http://localhost:49164/ </a>)。</p><p id="ed05" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们可以看到下一张图片——在测试执行页面之后，显示了所有用户。这些用户是从存储在live Postgres数据库中的live API服务请求的。所有这些都是作为测试运行的一部分完全隔离地进行检查的，没有实际推广到实际环境中。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nm"><img src="../Images/891e68fe904ddb729acec0d26b693430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4c3yQI7oXp1FqfwkUb20bA.png"/></div></div></figure><p id="b20a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">该解决方案有助于在将服务部署到集群之前执行更加强大和全面的验证，并在测试运行期间根据需要使用尽可能多的实时依赖项。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="74a0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">如果你喜欢阅读这篇文章，请看看其他与monorepo设计和研究相关的文章</p><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/structuring-complex-projects-5a4cb3b80fe5"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">构建复杂的项目</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">"简单是可靠的先决条件."埃德格·w·迪克斯特拉</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol lc nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/mutation-testing-as-a-more-robust-check-of-dependent-libraries-ca13af2a27ec"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">突变测试作为对依赖库的更健壮的检查</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">有效的测试金字塔形状和良好的测试覆盖率只是遵循TDD实践的副作用。这个主题是…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol lc nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/codex/what-i-was-doing-wrong-dependency-management-and-monorepo-816c698ab9f" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">我做错了什么—依赖管理和monorepo</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">在分布式架构中支持多重依赖是一个巨大的挑战，尤其是当康威定律…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol lc nx"/></div></div></a></div></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="3d30" class="lk ll iq bd lm ln oo lp lq lr op lt lu lv oq lx ly lz or mb mc md os mf mg mh bi translated">分级编码</h1><p id="7cef" class="pw-post-body-paragraph jq jr iq jt b ju mi jw jx jy mj ka kb kp mk ke kf kq ml ki kj kr mm km kn ko ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="c64d" class="mn mo iq jt b ju jv jy jz kp mp kq mq kr mr ko ms mt mu mv bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="0b15" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">📰更多内容请查看<a class="ae li" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="3afd" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">🔔关注我们:<a class="ae li" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae li" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae li" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li><li id="81e9" class="mn mo iq jt b ju mw jy mx kp my kq mz kr na ko ms mt mu mv bi translated">🚀👉<a class="ae li" href="https://jobs.levelup.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir">软件工程师的热门职位</strong> </a></li></ul></div></div>    
</body>
</html>