<html>
<head>
<title>A Simple PWA Template Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的PWA模板项目</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-simple-pwa-template-project-85ae4927d14e?source=collection_archive---------11-----------------------#2022-12-14">https://levelup.gitconnected.com/a-simple-pwa-template-project-85ae4927d14e?source=collection_archive---------11-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e606" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">渐进式Web应用程序的普通JavaScript模板项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7d6c9e990d62b45811800d89c94474eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s0Khxnj3mtDntLyS"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément Hélardot </a>拍摄</figcaption></figure><p id="7cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始一个新项目是令人兴奋的。</p><p id="469b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建模板项目不是。</p><p id="8b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从几年前我创建了我的第一个渐进式网络应用程序(PWA ),我就把这个代码库作为每个新的PWA项目的起点。随着越来越多的项目成为PWAs或单页应用程序(spa ),我开始质疑我五年前的代码，并决定仔细检查一切，为PWAs创建一个简单的模板项目<a class="ae ky" href="https://github.com/pingpoli/pwa-template-project" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="2c7b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">PWA要求</h1><p id="50e8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从讨论<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Installable_PWAs" rel="noopener ugc nofollow" target="_blank">使应用程序成为可安装PWA </a>的要求开始:</p><ul class=""><li id="6731" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">Web清单</li><li id="e2a9" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">经由HTTPS供应</li><li id="d333" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">应用程序图标</li><li id="7cc0" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">服务行业人员</li></ul><h2 id="5b8a" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">Web清单</h2><p id="37f0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">web manifest是一个简单的JSON文件，它定义了应用程序的一些元属性，如名称和图标列表。唯一必需的字段是<em class="ns">名称</em>和<em class="ns">图标</em>，但是还有一些额外的可选参数。</p><pre class="kj kk kl km gt nt nu nv bn nw nx bi"><span id="a46a" class="ny lw it nu b be nz oa l ob oc">{<br/>"name": "PWA Template",<br/>"short_name": "PWA Template",<br/>"start_url": "index.html",<br/>"display": "standalone",<br/>"icons": [<br/>    {<br/>    "src": "img/icon_120.png",<br/>    "sizes": "120x120",<br/>    "type": "image/png"<br/>    },<br/>    {<br/>    "src": "img/icon_180.png",<br/>    "sizes": "180x180",<br/>    "type": "image/png"<br/>    },<br/>    {<br/>    "src": "img/icon_192.png",<br/>    "sizes": "192x192",<br/>    "type": "image/png"<br/>    },<br/>    {<br/>    "src": "img/icon_512.png",<br/>    "sizes": "512x512",<br/>    "type": "image/png"<br/>    }<br/>],<br/>"background_color": "#ffffff",<br/>"theme_color": "#ffffff"<br/>}</span></pre><p id="399f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用清单文件，我们需要将它包含在主HTML文件中:</p><pre class="kj kk kl km gt nt nu nv bn nw nx bi"><span id="3359" class="ny lw it nu b be nz oa l ob oc">&lt;link rel="manifest" href="manifest.json"&gt;</span></pre><h2 id="8f76" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">应用程序图标</h2><p id="a40f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">PWA需要一个应用程序图标，用于在主屏幕或启动器上显示应用程序。图标是在web清单文件中定义的。可能的图像大小有一个很大的列表，但看起来iOS的最小尺寸是120x120和180x180像素，Android的最小尺寸是192x192和512x512像素，所以我将它们添加到了模板项目中。</p><h2 id="0fcb" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">HTTPS</h2><p id="e0e8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每个PWA都必须通过HTTPS进行安装。使用SSL总是一个好主意，考虑到获得证书是多么便宜(实际上是免费的，让我们加密一下吧)和容易，没有理由不使用它。不幸的是，SSL需求已经成为我最近一个项目中的一个问题。这是一个涉及一些敏感数据的个人项目，我不想把它暴露在互联网上。所以我在我的本地Raspberry Pi服务器上运行它，它的自签名证书不能与PWAs一起工作。</p><h1 id="4340" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">服务行业人员</h1><p id="532b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">可以说PWA最重要的方面是服务人员。它负责缓存、推送通知和其他功能。五年前的大部分旧代码看起来仍然很好，我只做了一些小的改动。我没有在模板项目中包含任何推送通知代码，因为大多数项目不需要它，并且以后很容易添加。</p><p id="472b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务工作者最有用的功能是缓存。这不仅使PWA能够在脱机模式下运行，而且大大加快了加载速度。</p><p id="4407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从服务人员开始:</p><pre class="kj kk kl km gt nt nu nv bn nw nx bi"><span id="1e4c" class="ny lw it nu b be nz oa l ob oc">self.importScripts( "config.js" );<br/><br/>// cache name for cache versioning<br/>var cacheName = "v"+serviceWorkerCacheVersion+":static";<br/><br/>// when the service is installed<br/>self.addEventListener( "install" , ( event ) =&gt;<br/>{<br/>    // cache all required files for offline use<br/>    event.waitUntil( caches.open( cacheName ).then( ( cache ) =&gt;<br/>    {<br/>        return cache.addAll( [<br/>            "/",<br/>            "config.js",<br/>            "index.html",<br/>            "manifest.json",<br/>            "style.css",<br/>            "src/App.js",<br/>            "src/main.js",<br/>            "img/favicon.png",<br/>            "img/icon_120.png",<br/>            "img/icon_180.png",<br/>            "img/icon_192.png",<br/>            "img/icon_512.png"<br/>        ] );<br/>    }));<br/>    console.log( "sw &gt; installed" );<br/>    // activate the new service worker version immediately<br/>    self.skipWaiting();<br/>});</span></pre><p id="400c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要关注的第一个事件是<em class="ns">安装</em>事件。可以想象，它是在安装服务人员时触发的。此时，我们可以将所有需要的文件添加到缓存中。这些只是一些文本文件和一些小图片。如果您的应用程序需要更大的文件，如音频、视频或大量图像，您可能需要采用更复杂的缓存策略。</p><pre class="kj kk kl km gt nt nu nv bn nw nx bi"><span id="bbc3" class="ny lw it nu b be nz oa l ob oc">// when a new version of the service worker is activated<br/>self.addEventListener( "activate" , ( event ) =&gt; <br/>{<br/>    // delete the old cache<br/>    event.waitUntil( caches.keys().then( ( keyList ) =&gt; Promise.all( keyList.map( ( key ) =&gt; <br/>    {<br/>        if ( key !== cacheName ) return caches.delete( key );<br/>    }))));<br/>    console.log( "sw &gt; activated" );<br/>});</span></pre><p id="9b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个事件是<em class="ns">激活</em>事件，该事件在服务人员被激活时触发。因为我们在<em class="ns"> install </em>事件中使用了<code class="fe od oe of nu b">self.skipWaiting()</code>函数，所以这将在安装服务人员后不久发生。每次我们更新服务工作者时，我们都应该增加版本号，以便为新版本生成一个新的缓存。正因为如此，我们应该很好地在新版本激活时删除旧版本的缓存。</p><pre class="kj kk kl km gt nt nu nv bn nw nx bi"><span id="fef4" class="ny lw it nu b be nz oa l ob oc">// when the browser fetches a URL<br/>self.addEventListener( "fetch" , ( event ) =&gt;<br/>{<br/>    // cache first caching - only go to the network if no cache match was found, other caching strategies can be used too<br/>    event.respondWith( caches.match( event.request ).then( ( response ) =&gt; <br/>    {<br/>        return response || fetch( event.request );<br/>    }));<br/>});</span></pre><p id="cb94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要实现当浏览器请求URL时调用的fetch事件。在这里，我们希望快速响应缓存的文件，如果在缓存中找不到它，只从网络加载它。这就是所谓的缓存优先缓存。根据您的使用情况，您可能想要采用不同的缓存策略。</p><p id="e4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得一提的是，服务人员过去无法处理范围请求。<a class="ae ky" href="https://chromestatus.com/feature/5648276147666944" rel="noopener ugc nofollow" target="_blank">这在大多数现代浏览器版本</a>中是固定的，但是如果您正在请求使用范围请求的大文件，并且需要支持广泛的平台，您可能需要研究这一点。我在旧的服务工作者代码中对此有一个解决方法，但是为了清晰起见，我选择在模板项目中删除它。</p><h1 id="1fec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">主JavaScript文件</h1><p id="efd6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">服务人员完成后，我们需要将它安装在应用程序的主JavaScript文件中。幸运的是，这很容易做到:</p><pre class="kj kk kl km gt nt nu nv bn nw nx bi"><span id="3138" class="ny lw it nu b be nz oa l ob oc">// service worker<br/>if ( "serviceWorker" in navigator ) <br/>{<br/>    // register the service worker<br/>    navigator.serviceWorker.register( "sw.js" ).then( ( reg ) =&gt;<br/>    {<br/>        console.log( "service worker has been registered successfully" );<br/>        serviceWorkerRegistration = reg;<br/>    }<br/>    ).catch( ( error ) =&gt;<br/>    {<br/>        console.log( "failed to register service worker" , error );<br/>    });<br/>}</span></pre><p id="0b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们还可以显示安装提示，要求用户将PWA添加到他们的主屏幕。但是，这在某些平台上可能行不通。我最近没有做任何测试，但我认为目前主要是针对Android上的Chrome。</p><pre class="kj kk kl km gt nt nu nv bn nw nx bi"><span id="fdaa" class="ny lw it nu b be nz oa l ob oc">// app install banner -- may not work on every platform<br/>window.addEventListener( "beforeinstallprompt" , ( event ) =&gt;<br/>{<br/>    event.userChoice.then( ( choiceResult ) =&gt;<br/>    {<br/>        console.log( choiceResult.outcome ); // either "accepted" or "dismissed"<br/>    });<br/>});</span></pre></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="5648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不擅长创建模板项目。大多数时候，我对一个新项目感到兴奋，我想尽快开始。所以我最终只是复制了一个相同类型的旧项目，做了一些调整，然后开始工作。这意味着来自第一个项目的混乱甚至可能不正确的代码被一遍又一遍地复制。</p><p id="82c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我即将开始另一个PWA项目时，我终于花时间清理了代码并创建了一个简单的模板项目，我可以用它作为将来的起点。你也可以在你的项目中随意使用这个项目，如果你注意到任何可以改进的地方，请告诉我。</p><p id="fa3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/pingpoli/pwa-template-project" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> PWA模板项目Github</strong>T3】</a></p></div></div>    
</body>
</html>