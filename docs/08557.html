<html>
<head>
<title>10 Handy Spring Batch Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10个简便的春季批处理技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/10-handy-spring-batch-tricks-24556cf549a4?source=collection_archive---------0-----------------------#2021-05-12">https://levelup.gitconnected.com/10-handy-spring-batch-tricks-24556cf549a4?source=collection_archive---------0-----------------------#2021-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a162" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">来解决现实生活中的问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9dffe461544ebf1fbe613e6a92f42ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjK9GBQq0w3deq3B4zOF_g.jpeg"/></div></div></figure><p id="d550" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">批处理作业并不特别令人兴奋，但它们在各种应用中仍然非常普遍，从计算每月账单到重新训练机器学习模型。如果您在Java/Spring生态系统中操作，Spring Batch是一个显而易见的选择，它是一个成熟的库，具有过多的功能和预构建的适配器。</p><p id="15b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Spring Batch的创建者显然已经考虑到了在创建批处理作业时试图解决的许多问题，并且已经找到了解决这些问题的方法。不幸的是，Spring Batch不太容易学习和使用，并且默认行为和文档经常无法解决一些相当常见的现实生活中的行为。</p><p id="a174" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章是为已经接触过Spring Batch的人写的。它将演示如何避开一些Spring批处理陷阱，以及如何解决一些相当常见的实际问题。</p><p id="cf0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查阅以下目录，找到您感兴趣的问题:</p><h1 id="42a5" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">目录</h1><p id="f2ef" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated"><a class="ae mk" href="#73aa" rel="noopener ugc nofollow"> 1。阻止作业在启动时运行</a> <br/> <a class="ae mk" href="#c8fc" rel="noopener ugc nofollow"> 2。初始化春季批处理模式</a> <br/> <a class="ae mk" href="#b35f" rel="noopener ugc nofollow"> 3。写一个没有读者或作者的作业</a> <br/> <a class="ae mk" href="#91d6" rel="noopener ugc nofollow"> 4。将运行时参数传递给作业</a> <br/> <a class="ae mk" href="#9bf2" rel="noopener ugc nofollow"> 5。使作业重新运行</a> <br/> <a class="ae mk" href="#f81d" rel="noopener ugc nofollow"> 6。读取文件时跳过不需要的字段</a> <br/> <a class="ae mk" href="#89df" rel="noopener ugc nofollow"> 7。地图自定义数据类型</a> <br/> <a class="ae mk" href="#2773" rel="noopener ugc nofollow"> 8。跳过错误实例而不使作业</a> <br/> <a class="ae mk" href="#c0a6" rel="noopener ugc nofollow"> 9失败。处理器</a> <br/> <a class="ae mk" href="#029b" rel="noopener ugc nofollow"> 10中的跳过与过滤。如何汇总项目处理器的结果</a></p><h1 id="73aa" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">1.阻止作业在启动时运行</h1><p id="b0a4" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当您启动Spring Boot应用程序时，您可能会惊讶地发现配置中的所有Spring批处理作业都会立即开始运行。这很少是想要的行为。大多数情况下，您会希望按需或根据某种计划启动作业。您可以通过在<em class="ml"> application.properties </em>中设置一个配置参数来禁用此默认行为:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="d598" class="mr lo iq mn b gy ms mt l mu mv"><em class="ml">#Do not auto start spring batch jobs<br/>spring.batch.job.enabled=false</em></span></pre><h1 id="c8fc" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">2.初始化Spring批处理模式</h1><p id="2a78" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Spring Batch将其状态存储在关系数据库的表中。假设您已经用一个关系数据库配置了Spring Boot，您可以很容易地让Spring Batch用一个属性创建这些表:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="892a" class="mr lo iq mn b gy ms mt l mu mv"><em class="ml">#Initialize schema<br/>spring.batch.initialize-schema=always</em></span></pre><p id="8757" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您更愿意自己生成模式，您可以从这里的<a class="ae mk" href="https://docs.spring.io/spring-batch/docs/3.0.x/reference/html/metaDataSchema.html" rel="noopener ugc nofollow" target="_blank">复制表定义，并将它们放入一个flyway脚本或类似的脚本中。</a></p><h1 id="b35f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">3.在没有读者或作者的情况下编写作业</h1><p id="49d9" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">标准的Spring批处理作业由一系列步骤组成。每个步骤由一个阅读器、一个可选的处理器和一个写入器组成。经常需要编写一个作业或一个步骤来执行一些逻辑，但不需要读取或写入任何数据。在这些情况下，您可以使用一个<strong class="kt ir">小任务</strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e751" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">执行小任务的步骤是这样配置的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="91d6" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">4.将运行时参数传递给作业</h1><p id="f82e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">运行作业时，您可以像这样传递运行时参数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0dc9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是作业如何知道如何处理这些参数呢？</p><p id="21f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有几种方法可以在作业定义中注入参数。</p><p id="3ee5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于微线程，可以直接从JobExecution中检索参数，访问方式如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="020d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要在bean定义中注入运行时参数，如读取器、处理器或写入器，可以使用“@Value”注释，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ce64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">重要提示</strong>:您<em class="ml">必须</em>使用“@StepScope”，以指示bean应该为每个新步骤重新创建。否则，bean将是一个全局单例，并且将不能看到参数。</p><h1 id="9bf2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">5.使作业可重新运行</h1><p id="fbea" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">默认情况下，Spring Batch不会两次执行相同的作业。spring batch认为“相同的作业”是具有相同参数的相同作业bean。因此，举例来说，如果我尝试使用不同的文件名运行上面示例中的<em class="ml"> executeScriptJob </em>，它将工作，但是如果我尝试使用相同的文件名重新运行它，它将抛出一个<em class="ml">JobInstanceAlreadyCompleteException</em>。</p><p id="41f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要使作业真正可重新运行，您必须传递一个因作业而异的运行时参数。例如，这可以通过传递当前时间戳来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="f81d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">6.读取文件时跳过不需要的字段</h1><p id="aaf2" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Spring Batch为构建平面文件读取器提供了一个灵活但相当冗长的框架。下面是设置标准阅读器以将CSV映射到Java beans的概述:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bd57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本例的输入文件如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fad9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我只对“金额”字段感兴趣，不想映射“trans_id”和“operation”。有几种方法可以排除不需要的字段。这里的方法是放置一个在这些beans中确实存在的属性，即“X”:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="95ef" class="mr lo iq mn b gy ms mt l mu mv">{"X", "transactionId", "accountId", "date", "type", "X", "amount"};</span></pre><p id="9018" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要做到这一点，要求FieldSetMapper不严格是很重要的，这样它就不会因为不存在的属性而失败:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="cfaf" class="mr lo iq mn b gy ms mt l mu mv">//Do not complain if properties don't exist    fieldSetMapper.setStrict(false);</span></pre><h1 id="89df" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">7.映射自定义数据类型</h1><p id="99bd" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">将平面文件映射到beans时，通常需要将字符串转换为自定义数据类型。Spring Batch提供了几种不同的方法来实现这一点。也许最直接的方法是在FieldSetMapper中使用一个<strong class="kt ir">属性编辑器</strong>。请注意，在上面的示例中，我包含了以下行:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="932f" class="mr lo iq mn b gy ms mt l mu mv">fieldSetMapper.setCustomEditors(getCustomEditors());</span></pre><p id="ef1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本例中，我想将一个字段映射到一个LocalDate。下面是实现过程:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="2773" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">8.跳过错误实例而不使作业失败</h1><p id="633e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在接收文件时，您希望数据采用特定的格式，但是您不能保证一定会是这样。某些行的格式可能不正确或包含无效信息。发生异常时，Spring Batch的默认行为是重试处理块几次，如果所有尝试都失败，整个作业就会失败。更糟糕的是，失败前处理的任何批处理都已提交，因此作业只是部分完成。</p><p id="2185" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这些类型的错误，重试不会成功，并且作业失败很少是我们想要的行为。我们需要的是跳过包含错误的行，以某种方式报告问题，并继续处理剩余的记录。</p><p id="8457" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了配置处理过程中遇到异常时的行为，我们将一个步骤定义为<strong class="kt ir">容错</strong>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="33d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的skip()指令指出了异常，如果发生异常，它们应该导致记录被跳过，而不是过程失败。在本例中，我们从一个平面文件中读取，任何未能正确解析和映射的记录都将导致FlatFileParseException。如果我们想要更好地控制跳过哪些异常，我们可以指定一个<a class="ae mk" href="https://docs.spring.io/spring-batch/docs/current/api/org/springframework/batch/core/step/skip/SkipPolicy.html" rel="noopener ugc nofollow" target="_blank"> SkipPolicy </a>来代替。</p><p id="4ff6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">skipLimit指定在实际引发错误之前可以跳过多少记录。这背后的基本原理是，如果出现太多异常，那么整个文件可能有问题。</p><p id="c2c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们需要一种方法来捕获发生的错误并以某种方式报告它们。这就是skip listener的作用。这里简单的SkipListener只记录错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="c0a6" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">9.处理器中的跳过与过滤</h1><p id="b14d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果一条记录通过了阅读器，它仍然会在处理器中遇到问题。处理器中的意外异常也会导致进程提前终止，因此对此加以防范非常重要。</p><p id="2f5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">处理器中的异常可以像在读取器中一样被跳过，方法是显式地列出它们或者将它们包含在跳过策略中。以这种方式引发的任何异常都将通知SkipListener，后者将广播该问题。</p><p id="e346" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有一种方法可以在不发出警报的情况下丢弃流程中的记录。这被称为<strong class="kt ir">过滤</strong>，它通过简单地为不需要的实例返回null来完成。跳过和过滤在语义上的区别在于，前者指的是输入数据中的错误，应该报告，而后者只是因为遇到了我们不感兴趣处理的记录。如果我们从允许条件查询的数据存储中读取，我们可以很容易地将这些实例作为查询的一部分删除，但是当我们从文件、流或键/值存储中读取时，我们无法控制我们得到什么，所以我们需要作为处理的一部分进行过滤。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8eec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的示例中，我们希望过滤掉来自波士顿银行(或BOB)的任何交易，但是如果我们收到一个金额为负的交易，我们希望引发一个错误。</p><h1 id="029b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">10.如何汇总项目处理者的结果</h1><p id="0f5d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">不可否认，这最后一个技巧是一个小技巧，我用它来说明记录过滤的创造性使用。Spring Batch是一个数据转换工具，不太适合计算复杂的聚合，这最好留给数据库或map/reduce框架。</p><p id="b3bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管如此，如果您决定将汇总项目处理器的结果作为工作的一部分，这里有一个方法:</p><ol class=""><li id="4c7e" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">确保读取器按照应该处理的顺序提供数据。</li><li id="81f2" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">编写一个维护状态的项处理器，以便它知道到目前为止已经处理了什么。</li><li id="1328" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">当聚合不完整时，继续返回null。这将导致结果被跳过，不发送到编写器。</li><li id="97a4" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">当聚合完成时，发送结果。</li></ol><p id="5ad0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下面的例子中，我使用这个方法将单个交易汇总成每月的现金流。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9bf4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">monthlyGroup列表用于收集同一个月内的所有交易。lastDate用于跟踪月份。只要月份不变，我们就一直收集列表中的交易并返回null，从而导致结果被无声地过滤掉。只有当月份发生变化时，我们才汇总交易并输出整月的单个记录。</p><h1 id="c28e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="42fe" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在本文中，我演示了如何使用Spring Batch解决一些实际的数据转换问题。这里展示的例子，以及其他现实问题的解决方案，可以在这个<a class="ae mk" href="https://github.com/algorythmist/fluid-spring-batch/tree/main/advanced-spring-batch" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p></div></div>    
</body>
</html>