<html>
<head>
<title>Intro to Challenges of Upgrading Smart Contracts in Ethereum with Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊智能合约升级挑战介绍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-ethereum-smart-contract-upgradability-with-solidity-789cc497c56f?source=collection_archive---------1-----------------------#2020-01-31">https://levelup.gitconnected.com/introduction-to-ethereum-smart-contract-upgradability-with-solidity-789cc497c56f?source=collection_archive---------1-----------------------#2020-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8ad24aed195d5c30ed384ded6bab795d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1mWjCXD5l7k3U-Wj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">福蒂斯·福托普洛斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="8707" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在开发软件时，我们经常需要发布新版本来添加新功能或错误修复。在智能合约开发方面没有什么不同。虽然，将智能合约更新到新版本通常不像更新同样复杂的其他类型的软件那样简单。</p><p id="a4b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数区块链，尤其是像以太坊这样的公共场所，都实现了固有的不变性概念，理论上，不允许任何人改变区块链的“过去”。不变性适用于区块链中的所有事务，包括用于部署智能合约和相关代码的事务。换句话说，一旦智能合约的代码被部署到区块链，它将永远“按原样”存在，没有人能够改变它。如果发现bug或需要添加新功能，我们不能替换已部署合同的代码。</p><p id="b4fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个智能合约是不可变的，那么如何将它升级到新的版本呢？答案在于在区块链部署新的智能合同。</p><p id="8a53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这种方法提出了一些需要解决的挑战。最基本和最常见的有:</p><ul class=""><li id="9c7e" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">所有使用智能合约的用户都需要引用新合约版本的地址</li><li id="127b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">应该禁用第一个合同的版本，强制每个用户使用新版本</li><li id="4743" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">通常，您需要确保旧版本的数据(状态)被迁移到新版本，或者以某种方式对新版本可用。在最简单的场景中，这意味着您需要将状态从旧版本复制/迁移到新契约的版本</li></ul><p id="4c1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下各节将更详细地描述这些挑战。为了更好地说明它，我们将使用下面两个版本的<code class="fe lp lq lr ls b">MySmartContract</code>作为参考:</p><p id="f811" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">版本1</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="fb24" class="mb mc iq ls b gy md me l mf mg">contract MySmartContract {<br/>  uint32 public counter;</span><span id="d4ce" class="mb mc iq ls b gy mh me l mf mg">  constructor() public {<br/>    counter = 0;<br/>  }</span><span id="f297" class="mb mc iq ls b gy mh me l mf mg">  function incrementCounter() public {<br/>    counter += 2; // This "bug" is intentional.<br/>  }<br/>}</span></pre><p id="d25f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">版本2</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="8457" class="mb mc iq ls b gy md me l mf mg">contract MySmartContract {<br/>  uint32 public counter;</span><span id="05ed" class="mb mc iq ls b gy mh me l mf mg">  constructor(uint32 _counter) public {<br/>    counter = _counter;<br/>  }</span><span id="4457" class="mb mc iq ls b gy mh me l mf mg">  function incrementCounter() public {<br/>    counter++;<br/>  }<br/>}</span></pre><h2 id="b77f" class="mb mc iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">用户引用新合同的地址</h2><p id="5565" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">部署到区块链时，智能合约的每个实例都被分配到一个唯一的地址。此地址用于引用智能协定的实例，以便调用其方法并从协定的存储(状态)中读取数据或向其写入数据。</p><p id="302c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您将协定的更新版本部署到区块链时，协定的新实例将部署到新地址。这个新地址不同于第一个合同的地址。这意味着与智能合约交互的所有用户、其他智能合约和/或dApps(分散式应用程序)将需要更新，以便它们使用更新版本的地址。剧透:有一些选项可以避免这个问题，你会在这一部分的结尾看到。</p><p id="2773" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们考虑以下场景:</p><p id="e19e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你用上面的代码<code class="fe lp lq lr ls b">Version 1</code>创建了<code class="fe lp lq lr ls b">MySmartContract</code>。它被部署到区块链的地址<code class="fe lp lq lr ls b">A1</code>(这不是一个真实的以太坊地址——仅用于说明目的)。所有想要与<code class="fe lp lq lr ls b">Version 1</code>交互的用户都需要使用地址<code class="fe lp lq lr ls b">A1</code>来引用它。</p><p id="434e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，过了一段时间，我们注意到方法<code class="fe lp lq lr ls b">incrementCounter</code>中的错误:它将计数器递增2，而不是递增1。实施了一个修复，导致了<code class="fe lp lq lr ls b">MySmartContract</code>的<code class="fe lp lq lr ls b">Version 2</code>。这个新合同的版本被部署到地址为<code class="fe lp lq lr ls b">D5</code>的区块链。此时，如果用户想要与<code class="fe lp lq lr ls b">Version 2</code>交互，需要使用地址<code class="fe lp lq lr ls b">D5</code>，而不是<code class="fe lp lq lr ls b">A1</code>。这就是为什么所有与<code class="fe lp lq lr ls b">MySmartContract</code>交互的用户都需要更新，以便他们引用新地址<code class="fe lp lq lr ls b">D5</code>的原因。</p><p id="65e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到更新智能合约的版本应该对使用它的用户尽可能透明，您可能同意强制用户更新不是最好的方法。</p><p id="afd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有不同的策略可以用来解决这个问题。一些设计模式如<a class="ae kc" href="https://consensys.github.io/smart-contract-best-practices/software_engineering/#upgrading-broken-contracts" rel="noopener ugc nofollow" target="_blank">注册表</a>，不同类型的<a class="ae kc" href="https://blog.openzeppelin.com/proxy-patterns/" rel="noopener ugc nofollow" target="_blank">代理</a>可以用来使升级更容易，并向用户提供透明性。另一个很好的选择是使用<a class="ae kc" href="https://ens.domains/" rel="noopener ugc nofollow" target="_blank">以太坊名称服务</a>并注册一个用户朋友名称，该名称可以解析为你的合同地址。使用这个选项，契约的用户不需要知道契约的地址，只需要知道它的用户友好的名称。因此，升级到新地址对您的合同用户来说是透明的。所采用的具体策略取决于智能合约的使用场景。</p><h2 id="be23" class="mb mc iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">禁用旧版本的合同</h2><p id="0e37" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我们在上一节中了解到，所有用户都需要更新才能使用<code class="fe lp lq lr ls b">Version 2</code>的地址(<code class="fe lp lq lr ls b">D5</code>)，或者我们的合同应该实现某种机制，使这个过程对用户透明。尽管如此，如果你是合同的所有者，你可能希望强制所有用户只使用最新版本的<code class="fe lp lq lr ls b">D5</code>。如果用户无意中或没有使用<code class="fe lp lq lr ls b">A1</code>，你要保证<code class="fe lp lq lr ls b">Version 1</code>是过时的和不可用的。</p><p id="dba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，您可以实现一种技术来停止<code class="fe lp lq lr ls b">MySmartContract</code>的<code class="fe lp lq lr ls b">Version 1</code>。这项技术是通过名为<a class="ae kc" href="https://consensys.github.io/smart-contract-best-practices/software_engineering/#circuit-breakers-pause-contract-functionality" rel="noopener ugc nofollow" target="_blank">断路器</a>的设计模式实现的。通常也称为<em class="ne">可中止合约</em>或<em class="ne">紧急停止</em>。</p><p id="2238" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，断路器会停止智能合同功能。此外，它可以启用仅在合同终止时才可用的特定功能。这种模式通常实现某种类型的<a class="ae kc" href="https://solidity.readthedocs.io/en/latest/common-patterns.html#restricting-access" rel="noopener ugc nofollow" target="_blank">访问限制</a>，因此只有被允许的参与者(如管理员或所有者)拥有触发断路器和终止合同所需的权限。</p><p id="16bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以使用这种模式的场景有:</p><ul class=""><li id="0f69" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">发现错误时停止合同的功能</li><li id="39db" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">达到某个状态后停止一些契约的功能(经常与<a class="ae kc" href="https://solidity.readthedocs.io/en/latest/common-patterns.html#state-machine" rel="noopener ugc nofollow" target="_blank">状态机</a>模式一起使用)</li><li id="b1d5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在升级过程中停止契约的功能，这样外部参与者就不能在升级过程中更改契约的状态；</li><li id="c882" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">部署新版本后，停止不推荐使用的合同版本</li></ul><p id="7871" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看如何实现一个断路器来停止<code class="fe lp lq lr ls b">MySmartContract</code>的<code class="fe lp lq lr ls b">incrementCounter</code>功能，这样<code class="fe lp lq lr ls b">counter</code>在迁移过程中就不会改变。当第一次部署时，这个修改需要在<code class="fe lp lq lr ls b">Version 1</code>中就位。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="61a0" class="mb mc iq ls b gy md me l mf mg">// Version 1 implementing a Circuit Breaker with access restriction to owner<br/>contract MySmartContract {<br/>  uint32 public counter;<br/>  bool private stopped = false;<br/>  address private owner;</span><span id="4502" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @dev Checks if the contract is not stopped; reverts if it is.<br/>  */<br/>  modifier isNotStopped {<br/>    require(!stopped, 'Contract is stopped.');<br/>    _;<br/>  }</span><span id="8e05" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @dev Enforces the caller to be the contract's owner.<br/>  */<br/>  modifier isOwner {<br/>    require(msg.sender == owner, 'Sender is not owner.');<br/>    _;<br/>  }</span><span id="87a8" class="mb mc iq ls b gy mh me l mf mg">  constructor() public {<br/>    counter = 0;<br/>    // Sets the contract's owner as the address that deployed the contract.<br/>    owner = msg.sender;<br/>  }</span><span id="e9ef" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @notice Increments the contract's counter if contract is active.<br/>  @dev It will revert if the contract is stopped. See modifier "isNotStopped"<br/>   */<br/>  function incrementCounter() isNotStopped public {<br/>    counter += 2; // This is an intentional bug.<br/>  }</span><span id="c65a" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @dev Stops / Unstops the contract.<br/>   */<br/>  function toggleContractStopped() isOwner public {<br/>      stopped = !stopped;<br/>  }<br/>}</span></pre><p id="e963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，你可以看到<code class="fe lp lq lr ls b">MySmartContract</code>的<code class="fe lp lq lr ls b">Version 1</code>现在实现了一个修饰符<code class="fe lp lq lr ls b">isNotStopped</code>。如果合同停止，此修改量将恢复事务处理。函数<code class="fe lp lq lr ls b">incrementCounter</code>被更改为使用修饰符<code class="fe lp lq lr ls b">isNotStopped</code>，所以它将只在合同没有停止时执行。</p><p id="d1c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这个实现，就在迁移开始之前，契约的所有者可以调用函数<code class="fe lp lq lr ls b">toggleContractStopped</code>并停止契约。注意，这个函数使用修饰符<code class="fe lp lq lr ls b">isOwner</code>来限制对合同所有者的访问。</p><p id="65b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解更多关于断路器的信息，请务必查看Consensys关于<a class="ae kc" href="https://consensys.github.io/smart-contract-best-practices/software_engineering/#circuit-breakers-pause-contract-functionality" rel="noopener ugc nofollow" target="_blank">断路器</a>和OpenZeppelin关于<a class="ae kc" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/lifecycle/Pausable.sol" rel="noopener ugc nofollow" target="_blank">暂停</a>合同的参考实现的帖子。</p><h2 id="04b3" class="mb mc iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">合同的数据(状态)迁移</h2><p id="5105" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">大多数智能合约需要在其内部存储中保存某种状态。每个契约所需的状态变量的数量根据用例的不同而有很大的不同。在我们的例子中，最初的<code class="fe lp lq lr ls b">MySmartContract</code>的<code class="fe lp lq lr ls b">Version 1</code>只有一个状态变量<code class="fe lp lq lr ls b">counter</code>。</p><p id="e040" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在考虑到<code class="fe lp lq lr ls b">MySmartContract</code>的<code class="fe lp lq lr ls b">Version 1</code>已经用了一段时间了。当你在<code class="fe lp lq lr ls b">incrementCounter</code>函数中发现bug的时候，<code class="fe lp lq lr ls b">counter</code>的值已经在<code class="fe lp lq lr ls b">100</code>了。这种情况会引起一些问题:</p><ul class=""><li id="ec16" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">你会怎么处理<code class="fe lp lq lr ls b">MySmartContract Version 2</code>的状态？</li><li id="8c4a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">您能否在<code class="fe lp lq lr ls b">Version 2</code>中将计数器重置为0(零),或者您是否应该从<code class="fe lp lq lr ls b">Version 1</code>迁移状态以确保<code class="fe lp lq lr ls b">counter</code>在<code class="fe lp lq lr ls b">Version 2</code>中用<code class="fe lp lq lr ls b">100</code>初始化？</li></ul><p id="4a23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些问题的答案将取决于用例。在本文的例子中，这是一个非常简单的场景，<code class="fe lp lq lr ls b">counter</code>没有重要的用法，如果<code class="fe lp lq lr ls b">counter</code>被重置为<code class="fe lp lq lr ls b">0</code>，你不会有任何问题。但是，在大多数情况下，这并不是理想的方法。</p><p id="234b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您无法将值重置为<code class="fe lp lq lr ls b">0</code>，需要在<code class="fe lp lq lr ls b">Version 2</code>中将<code class="fe lp lq lr ls b">counter</code>设置为<code class="fe lp lq lr ls b">100</code>。在像<code class="fe lp lq lr ls b">MySmartContract</code>这样的简单合同中，这并不困难。您可以更改<code class="fe lp lq lr ls b">Version 2</code>的构造函数来接收<code class="fe lp lq lr ls b">counter</code>的初始值作为参数。在部署时，您可以将值<code class="fe lp lq lr ls b">100</code>传递给构造函数，这将解决您的问题。</p><p id="7ea0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现这种方法后，<code class="fe lp lq lr ls b">MySmartContract Version 2</code>的构造函数将如下所示:</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="d06b" class="mb mc iq ls b gy md me l mf mg">constructor(uint32 _counter) public {<br/>    counter = _counter;<br/>  }</span></pre><p id="2071" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的用例像上面介绍的那样简单(或类似)，从数据迁移的角度来看，这可能是正确的方法。实现其他方法的复杂性不值得。但是，请记住，大多数生产就绪型智能合约并不像<code class="fe lp lq lr ls b">MySmartContract</code>那样简单，通常具有更复杂的状态。</p><p id="544d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在考虑一个使用多个<a class="ae kc" href="https://solidity.readthedocs.io/en/latest/types.html#structs" rel="noopener ugc nofollow" target="_blank">结构</a>、<a class="ae kc" href="https://solidity.readthedocs.io/en/latest/types.html#mapping-types" rel="noopener ugc nofollow" target="_blank">映射</a>和<a class="ae kc" href="https://solidity.readthedocs.io/en/latest/types.html#arrays" rel="noopener ugc nofollow" target="_blank">数组</a>的契约。如果您需要在具有如此复杂存储的合同版本之间拷贝数据，您可能会面临以下一个或多个挑战:</p><ul class=""><li id="6008" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">要在区块链上处理的一组事务，这可能需要相当长的时间，具体取决于数据集</li><li id="ae63" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">处理从"<code class="fe lp lq lr ls b">Version 1</code>"读取数据并将其写入"<code class="fe lp lq lr ls b">Version 2</code>"的附加代码(除非手动完成)</li><li id="c67c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">花大钱买汽油。请记住，在区块链进行交易时，您需要支付汽油费。根据<a class="ae kc" href="https://ethereum.github.io/yellowpaper/paper.pdf" rel="noopener ugc nofollow" target="_blank">以太网黄纸-附录g .费用计划表</a>，<code class="fe lp lq lr ls b">SSTORE</code>操作，用于向以太网写入数据的upcode花费20000 <a class="ae kc" href="https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#gas" rel="noopener ugc nofollow" target="_blank">气体单位</a> <em class="ne">“当存储值从零设置为非零时”</em>和5000 <a class="ae kc" href="https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#gas" rel="noopener ugc nofollow" target="_blank">气体单位</a> <em class="ne">“当存储值为零不变时”</em>。</li><li id="de94" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">通过使用某种机制(比如断路器)冻结<code class="fe lp lq lr ls b">Version 1</code>的状态，以确保在迁移过程中没有更多的数据被附加到<code class="fe lp lq lr ls b">Version 1</code>中。</li><li id="8d2c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">实施访问限制机制，避免外部方(与迁移无关)在迁移过程中调用<code class="fe lp lq lr ls b">Version 2</code>的功能。这将需要确保<code class="fe lp lq lr ls b">Version 1</code>的数据能够被复制/迁移到<code class="fe lp lq lr ls b">Version 2</code>而不会在<code class="fe lp lq lr ls b">Version 2</code>中被泄露和/或破坏；</li></ul><p id="d20c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在状态更复杂的合同中，执行升级所需的工作非常重要，在区块链复制数据可能会产生相当大的天然气成本。使用<a class="ae kc" href="https://solidity.readthedocs.io/en/latest/contracts.html#libraries" rel="noopener ugc nofollow" target="_blank">库</a>和<a class="ae kc" href="https://blog.openzeppelin.com/proxy-patterns/" rel="noopener ugc nofollow" target="_blank">代理</a>可以帮助您开发更容易升级的智能合同。采用这种方法，数据将保存在一个存储状态但没有逻辑的合同中(<em class="ne">状态合同</em>)。第二个契约或库实现了逻辑，但是没有状态(<em class="ne">逻辑契约</em>)。所以当发现逻辑中有bug时，只需要升级<em class="ne">逻辑契约</em>，不用担心迁移<em class="ne">状态契约</em>中存储的状态(见下面<em class="ne">注</em>)。</p><p id="70fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ne">注意:</em>这种方式一般使用<a class="ae kc" href="https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries" rel="noopener ugc nofollow" target="_blank"> Delegatecall </a>。<em class="ne">状态契约</em>使用<em class="ne"> delegatecall </em>调用<em class="ne">逻辑契约</em>中的函数。<em class="ne">逻辑契约</em>随后在<em class="ne">状态契约</em>的上下文中执行其逻辑，这意味着<em class="ne">“存储、当前地址和余额仍然引用调用契约，只是代码取自被调用地址。”</em>(来自上述提及的实体文件)。</p><h1 id="c1b8" class="nf mc iq bd mi ng nh ni ml nj nk nl mo nm nn no mr np nq nr mu ns nt nu mx nv bi translated">使<code class="fe lp lq lr ls b">MySmartContract</code>更容易升级</h1><p id="beee" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">下面你可以看到如果我们实现了本文中描述的改变，<code class="fe lp lq lr ls b">Version 1</code>和<code class="fe lp lq lr ls b">Version 2</code>会是什么样子。再次提及<code class="fe lp lq lr ls b">MySmartContract</code>使用的策略是可以接受的，因为它很简单:状态变量和逻辑。</p><p id="ed41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们看看<code class="fe lp lq lr ls b">Version 1</code>的变化:</p><p id="0c52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">版本1 —没有可升级的机制</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="6c16" class="mb mc iq ls b gy md me l mf mg">contract MySmartContract {<br/>  uint32 public counter;</span><span id="29ed" class="mb mc iq ls b gy mh me l mf mg">  constructor() public {<br/>    counter = 0;<br/>  }</span><span id="3ffb" class="mb mc iq ls b gy mh me l mf mg">  function incrementCounter() public {<br/>    counter += 2; // This "bug" is intentional.<br/>  }<br/>}</span></pre><p id="7bf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的代码中，<code class="fe lp lq lr ls b">Version 1</code>实现了一个带有<a class="ae kc" href="https://solidity.readthedocs.io/en/latest/common-patterns.html#restricting-access" rel="noopener ugc nofollow" target="_blank">访问限制</a>机制的<a class="ae kc" href="https://consensys.github.io/smart-contract-best-practices/software_engineering/#circuit-breakers-pause-contract-functionality" rel="noopener ugc nofollow" target="_blank">断路器</a>，一旦合同被否决，该机制允许所有者停止该合同。</p><p id="e190" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">版本1 —具有弃用机制</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="40b3" class="mb mc iq ls b gy md me l mf mg">contract MySmartContract {<br/>  uint32 public counter;<br/>  bool private stopped = false;<br/>  address private owner;</span><span id="9650" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @dev Checks if the contract is not stopped; reverts if it is.<br/>  */<br/>  modifier isNotStopped {<br/>    require(!stopped, 'Contract is stopped.');<br/>    _;<br/>  }</span><span id="806c" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @dev Enforces the caller to be the contract's owner.<br/>  */<br/>  modifier isOwner {<br/>    require(msg.sender == owner, 'Sender is not owner.');<br/>    _;<br/>  }</span><span id="7421" class="mb mc iq ls b gy mh me l mf mg">  constructor() public {<br/>    counter = 0;<br/>    // Sets the contract's owner as the address that deployed the contract.<br/>    owner = msg.sender;<br/>  }</span><span id="743b" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @notice Increments the contract's counter if contract is active.<br/>  @dev It will revert is the contract is stopped. See modifier "isNotStopped"<br/>   */<br/>  function incrementCounter() isNotStopped public {<br/>    counter += 2; // This is an intentional bug.<br/>  }</span><span id="ea74" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @dev Stops / Unstops the contract.<br/>   */<br/>  function toggleContractStopped() isOwner public {<br/>      stopped = !stopped;<br/>  }<br/>}</span></pre><p id="c831" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看<code class="fe lp lq lr ls b">Version 2</code>会是什么样子:没有升级机制的版本2</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="eaca" class="mb mc iq ls b gy md me l mf mg">contract MySmartContract {<br/>  uint32 public counter;</span><span id="0011" class="mb mc iq ls b gy mh me l mf mg">  constructor(uint32 _counter) public {<br/>    counter = _counter;<br/>  }</span><span id="d9e1" class="mb mc iq ls b gy mh me l mf mg">  function incrementCounter() public {<br/>    counter++;<br/>  }<br/>}</span></pre><p id="0152" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的代码中<code class="fe lp lq lr ls b">Version 2</code>实现了与<code class="fe lp lq lr ls b">Version 1</code>相同的<a class="ae kc" href="https://consensys.github.io/smart-contract-best-practices/software_engineering/#circuit-breakers-pause-contract-functionality" rel="noopener ugc nofollow" target="_blank">断路器</a>和<a class="ae kc" href="https://solidity.readthedocs.io/en/latest/common-patterns.html#restricting-access" rel="noopener ugc nofollow" target="_blank">访问限制</a>机制。此外，它实现了一个构造函数，允许在部署期间设置<code class="fe lp lq lr ls b">counter</code>的初始值。可以使用这种机制，在升级期间可以使用这种机制从旧版本复制数据。</p><p id="3341" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">版本2 —具有简单的可升级机制</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="c9c8" class="mb mc iq ls b gy md me l mf mg">contract MySmartContract {<br/>  uint32 public counter;<br/>  bool private stopped = false;<br/>  address private owner;</span><span id="c351" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @dev Checks if the contract is not stopped; reverts if it is.<br/>  */<br/>  modifier isNotStopped {<br/>    require(!stopped, 'Contract is stopped.');<br/>    _;<br/>  }</span><span id="844c" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @dev Enforces the caller to be the contract's owner.<br/>  */<br/>  modifier isOwner {<br/>    require(msg.sender == owner, 'Sender is not owner.');<br/>    _;<br/>  }</span><span id="7885" class="mb mc iq ls b gy mh me l mf mg">  constructor(uint32 _counter) public {<br/>    counter = _counter; // Allows setting counter's initial value on deployment.<br/>    // Sets the contract's owner as the address that deployed the contract.<br/>    owner = msg.sender;<br/>  }</span><span id="d347" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @notice Increments the contract's counter if contract is active.<br/>  @dev It will revert is the contract is stopped. See modifier "isNotStopped"<br/>   */<br/>  function incrementCounter() isNotStopped public {<br/>    counter++; // Fixes bug introduced in version 1.<br/>  }</span><span id="79f8" class="mb mc iq ls b gy mh me l mf mg">  /**<br/>  @dev Stops / Unstops the contract.<br/>   */<br/>  function toggleContractStopped() isOwner public {<br/>      stopped = !stopped;<br/>  }<br/>}</span></pre><p id="b490" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管上述更改实现了一些有助于升级智能合约的机制，但本文开头描述的第一个挑战，<em class="ne">用户引用新合约的地址</em>，并没有用这些简单的技术解决。需要更高级的模式，如<a class="ae kc" href="https://blog.openzeppelin.com/proxy-patterns/" rel="noopener ugc nofollow" target="_blank">代理</a>和<a class="ae kc" href="https://consensys.github.io/smart-contract-best-practices/software_engineering/#upgrading-broken-contracts" rel="noopener ugc nofollow" target="_blank">注册</a>，或者使用<a class="ae kc" href="https://ens.domains/" rel="noopener ugc nofollow" target="_blank"> ENS </a>为您的合同注册一个用户友好的名称，以避免所有用户升级到引用新地址<code class="fe lp lq lr ls b">Version 2</code>。</p><h1 id="bd51" class="nf mc iq bd mi ng nh ni ml nj nk nl mo nm nn no mr np nq nr mu ns nt nu mx nv bi translated">结论</h1><p id="c56d" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">以太坊白皮书的<a class="ae kc" href="https://github.com/ethereum/wiki/wiki/White-Paper#decentralized-autonomous-organizations" rel="noopener ugc nofollow" target="_blank"> DAO章节</a>中描述了可升级智能合约的原理，内容如下:</p><p id="d58e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">" *虽然代码在理论上是不可变的，但是通过将代码块放在单独的契约中，并将要调用的契约的地址存储在可修改的存储中，可以很容易地绕过这一点并具有事实上的可变性。*"</p><p id="ab4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这是可以实现的，但升级智能合约可能相当具有挑战性。区块链的不变性增加了smart contract升级的复杂性，因为它迫使您仔细分析使用smart contract的场景，了解可用的机制，然后决定哪些机制非常适合您的合同，这样潜在和可能的升级将会顺利进行。</p><p id="701f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">智能合同升级是一个活跃的研究领域。相关的模式、机制和最佳实践仍在不断的讨论和发展中。使用<em class="ne">库</em>和一些设计模式如<a class="ae kc" href="https://consensys.github.io/smart-contract-best-practices/software_engineering/#circuit-breakers-pause-contract-functionality" rel="noopener ugc nofollow" target="_blank">断路器</a>、<a class="ae kc" href="https://solidity.readthedocs.io/en/latest/common-patterns.html#restricting-access" rel="noopener ugc nofollow" target="_blank">访问限制</a>、<a class="ae kc" href="https://blog.openzeppelin.com/proxy-patterns/" rel="noopener ugc nofollow" target="_blank">代理</a>和<a class="ae kc" href="https://consensys.github.io/smart-contract-best-practices/software_engineering/#upgrading-broken-contracts" rel="noopener ugc nofollow" target="_blank">注册表</a>可以帮助你解决一些挑战。然而，在更复杂的场景中，单靠这些机制可能无法解决所有问题，您可能需要考虑更复杂的模式，如本文中没有提到的<a class="ae kc" href="https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88/" rel="noopener ugc nofollow" target="_blank">永久存储</a>。</p><p id="2059" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在这个<a class="ae kc" href="https://github.com/fodisi/solidity-design-patterns" rel="noopener ugc nofollow" target="_blank"> github资源库</a>中查看完整的源代码，包括相关的单元测试(为了简单起见，本文没有提及)。</p></div></div>    
</body>
</html>