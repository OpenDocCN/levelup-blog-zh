<html>
<head>
<title>Top Misconceptions About Dependency Injection in ASP.NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心中关于依赖注入的主要误解</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/top-misconceptions-about-dependency-injection-in-asp-net-core-c6a7afd14eb4?source=collection_archive---------0-----------------------#2021-10-02">https://levelup.gitconnected.com/top-misconceptions-about-dependency-injection-in-asp-net-core-c6a7afd14eb4?source=collection_archive---------0-----------------------#2021-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbd2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这甚至会导致错误。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/96330709bbd1abfb03f3bb3d8bc6a5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hej2LuqZ3ZYsI7Jo"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nublson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">努贝尔森·费尔南德斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的工作中，我经常注意到那些最近开始在ASP.NET核心中使用依赖注入的开发人员，或者那些对这个主题不够关注的人，有一系列的误解。</p><p id="b8fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些误解会导致bug，而另一些则会导致冗余编码。让我们来看看我发现最重复的那些。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="48f4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">每个Web请求仅创建一次作用域类</h1><p id="93bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在ASP.NET核心中使用依赖注入注册一个类时，开发人员可以从三种生命周期中选择一种:瞬态、限定作用域和单例。</p><p id="7f1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞬态意味着每次从DI容器请求该类时，都会创建一个新的实例。Singleton意味着将为整个应用程序生存期创建该类的单个实例。它将在web请求之间共享，并且只在应用程序关闭时释放。</p><p id="c93a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当应该为每个web请求创建一次类的实例时，开发人员使用限定范围的生存期:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4d80" class="ne md it na b gy nf ng l nh ni">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddScoped&lt;IUserRepository, UserRepository&gt;();<br/>}</span></pre><p id="ed61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，作用域生存期不能保证每个web请求只创建一次作用域类。限定了作用域的生存期意味着类在给定的作用域中只会被实例化<strong class="lb iu">一次，但是在一个web请求中可以创建多个作用域。</strong></p><p id="c652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，在ASP.NET核心中，范围是实例化一个<code class="fe nj nk nl na b">IServiceScope</code>类型和调用它的<code class="fe nj nk nl na b">Dispose</code>方法之间的代码区域。</p><p id="f1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">IServiceScope</code>实例包含用于解析在<code class="fe nj nk nl na b">ConfigureServices</code>方法中注册的实例的<code class="fe nj nk nl na b">ServiceProvider</code>属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ec03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个范围内的同一类型被解析多次，将总是返回相同的实例。</p><p id="56fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ASP。NET Core在web请求开始时创建一个范围，并在web请求结束时释放该范围。这就是为什么每个web请求只创建一次作用域实例，但并不总是如此。</p><p id="740e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有什么可以阻止开发人员创建子范围。从不同范围解析的相同类型的实例也将不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些情况下，手动创建作用域是获取应用程序服务实例的唯一正确方式，例如，从单例解析作用域服务。对作用域行为的认识可以保护您免受各种问题的困扰。</p><p id="ae1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔔<a class="ae ky" href="https://esashamathews.medium.com/subscribe" rel="noopener"> <strong class="lb iu">现订阅</strong> </a> <strong class="lb iu">，以免错过我的下一篇文章。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0fc1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">依赖注入框架始终验证强制依赖</h1><p id="6d05" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://blog.ploeh.dk/2014/06/02/captive-dependency/" rel="noopener ugc nofollow" target="_blank">强制依赖</a>是一种依赖注入反模式，可能会导致代码中的错误。</p><p id="5c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要解决强制依赖问题，您所要做的就是将生存期较短的类注入到生存期较长的类中。<strong class="lb iu">例如，将作用域服务注入到singleton </strong>中。在这种情况下，不会为每个web请求创建和释放一个作用域类。作用域类将具有与单例相同的生存期，并且实际上将成为单例。</p><p id="5894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么这真的是个问题？</p><p id="7011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在web应用程序中，具有类似于缓存的状态的单例实例被设计为线程安全的，以避免当多个请求访问同一个单例对象时出现并发错误。但是，作用域类不需要是线程安全的，除非开发人员在web请求中启动其他并发线程。</p><p id="799c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强制依赖问题延长了对象的生存期。如果不是线程安全的作用域类成为一个单一实例，app中就会存在并发错误。</p><p id="200e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ASP。NET Core通过验证强制依赖关系的依赖关系图并在发现异常时引发异常来保护开发人员免受此问题的影响。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5d96" class="ne md it na b gy nf ng l nh ni">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddSingleton&lt;UserService&gt;();<br/>    services.AddScoped&lt;IUserRepository, UserRepository&gt;();<br/>}</span><span id="27f7" class="ne md it na b gy no ng l nh ni">public class UserService<br/>{<br/>    public UserService(IUserRepository userRepository) <br/>    { <br/>    }<br/>}</span><span id="82df" class="ne md it na b gy no ng l nh ni">public class UserRepository : IUserRepository<br/>{<br/>}</span></pre><p id="7c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码将导致一个异常，说明作用域类<code class="fe nj nk nl na b">IUserRepository</code>不能从singleton <code class="fe nj nk nl na b">UserService.</code>使用</p><p id="1281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">误解是，强制依赖项的ASP.NET核心验证将始终有效。但是，在ASP.NET核心中，强制依赖关系验证默认仅在<strong class="lb iu">开发</strong>环境中完成。</p><p id="659e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果代码没有在本地进行良好的测试，则在开发以外的环境中不会出现异常。相反，服务的生存期将意外延长，从而导致潜在的并发性和其他问题。</p><p id="2cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要确保始终针对强制依赖关系验证代码，请在应用程序入口点将<strong class="lb iu"> ValidateScopes </strong>选项设置为true:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3d5c" class="ne md it na b gy nf ng l nh ni">public static IHostBuilder CreateHostBuilder(string[] args) =&gt;<br/>    Host.CreateDefaultBuilder(args)<br/>        .ConfigureWebHostDefaults(webBuilder =&gt;<br/>        {<br/>            webBuilder.UseStartup&lt;Startup&gt;();<br/>            <br/>        }).UseDefaultServiceProvider((context, options) =&gt; {<br/>            <strong class="na iu">options.ValidateScopes = true;</strong><br/>        });</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bce7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">依赖注入容器始终处置对象</h1><p id="3cd3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">依赖注入容器不仅负责实例化对象，还负责处置对象。</p><p id="e337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">暂态和作用域服务在作用域末尾(在ASP.NET Core中的web请求末尾)处置，而单例类在应用程序关闭之前处置。</p><p id="a138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入容器完全管理应用程序服务的生命周期。开发人员不需要记得在适当的时候调用<code class="fe nj nk nl na b">Dispose</code>方法。</p><p id="23ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在极少数情况下，开发人员可能需要自己实例化类，然后将实例提供给DI容器:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="de2d" class="ne md it na b gy nf ng l nh ni">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    <strong class="na iu">services.AddSingleton(new Service());</strong><br/>}</span></pre><p id="c307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，正如开发人员可能预料的那样，该对象不会在应用程序关闭时被释放。现在，他们需要记住自己释放实例，以避免由于未释放资源而可能出现的问题。</p><p id="e77d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，开发人员可能会错误地使用上面的语法来注册一个对象，而不是这个:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4d76" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">services.AddSingleton&lt;Service&gt;();</strong></span></pre><p id="5bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种语法，对象将被创建，然后由依赖注入容器处理，这是更好的选择。</p><p id="5a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两条线很像，很容易一不小心用错。小心点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6c5a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">依赖注入容器只接受带接口的类</h1><p id="937e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">构造函数依赖注入经常使用接口来实现。这就是为什么一些开发人员错误地认为类必须有一个接口才能在依赖注入容器中注册。</p><p id="4c1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种误解导致为并不真正需要接口的类提取接口。</p><p id="192c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的示例演示如何向阿迪容器注册没有接口的类:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="57e7" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">//Class without interface</strong><br/>public class SomeClass<br/>{<br/>}</span><span id="2f13" class="ne md it na b gy no ng l nh ni"><strong class="na iu">//Registering the class</strong><br/>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddScoped&lt;SomeClass&gt;();<br/>}</span><span id="03be" class="ne md it na b gy no ng l nh ni"><strong class="na iu">Injecting the class into some service</strong><br/>public class SomeService<br/>{<br/>   public SomeService(SomeClass someClass)<br/>   {<br/>   }<br/>}</span></pre><p id="3ab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口是一个很棒的特性，它允许你为类型定义一个契约，实现松散耦合，在运行时替换类型，促进可测试性等等。然而，在类之间的编译时依赖是可接受的情况下，最好不要用冗余接口污染代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="58a9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><ul class=""><li id="48fa" class="np nq it lb b lc mu lf mv li nr lm ns lq nt lu nu nv nw nx bi translated">如果开发人员创建额外的作用域，则在单个web请求中可以创建一个作用域类的许多实例。</li><li id="53ec" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">依赖注入容器仅在开发环境中验证受控依赖的依赖图。确保为所有环境启用验证。</li><li id="2024" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">DI容器只处理它创建的对象。在DI容器之外创建的对象必须由开发人员处理。</li><li id="8b30" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">类不需要在DI容器中注册接口。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6ae4" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">我的其他文章</h2><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/stop-using-meaningless-naming-in-your-code-121f4eaff6fd"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">停止在代码中使用无意义的命名</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">给事物起正确的名字很容易。</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-clone-an-object-in-c-d1374ec28efa"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">在C#中克隆对象的5种方法</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">各有利弊</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">如何专业地对Bug修复进行代码审查</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">审查bug修复时要问的几个重要问题。</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pa l"><div class="ph l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>