<html>
<head>
<title>Learning C++: The STL and Maps and Multimaps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL、地图和多重地图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-the-stl-and-maps-and-multimaps-993f5b931287?source=collection_archive---------14-----------------------#2020-04-14">https://levelup.gitconnected.com/learning-c-the-stl-and-maps-and-multimaps-993f5b931287?source=collection_archive---------14-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/86f7abca0c5dcf2a91b8465d9a67371b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5TFhBUniP0OOAVuq"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@pisitheng?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">皮斯特亨</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="fd45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多应用程序要求数据以键值关系与其他数据相关联。字典、电话列表和清单只是三个例子。标准模板库(STL)中存储关联数据的主要容器是<code class="fe le lf lg lh b">map</code>类。该类允许存储唯一键及其相关值。与map类相关联的是允许重复键的<code class="fe le lf lg lh b">multimap</code>类。在本文中，我将向您展示如何使用地图和多地图来处理关联数据。</p><h1 id="df98" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">地图和多地图类的基础</h1><p id="610b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用平衡二叉树实现了<code class="fe le lf lg lh b">map</code>和<code class="fe le lf lg lh b">multimap</code>类。每个键/值对是树中的一个节点，节点根据键值放入树中。这意味着映射(和多映射)被很好地排序，并且为了发现与它相关的值而搜索一个键是非常有效的。然而，这种结构也意味着，在不提供键的情况下搜索一个值是非常低效的，甚至没有真正在类中实现。</p><p id="b8d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对地图或多地图的另一个低效操作是更改键。你不能直接这样做；您必须删除键/值对，然后用修改后的键插入一个新对。这是因为就地修改键会使内部二叉树不平衡，并且作为修改操作的一部分，该树必须重新平衡自身。这种操作效率很低，实际上是不允许的。</p><h1 id="4181" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建地图</h1><p id="8301" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">为使用映射而输入的预处理器指令是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7fc0" class="mt lj it lh b gy mu mv l mw mx">#include &lt;map&gt;</span></pre><p id="5fca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<code class="fe le lf lg lh b">map </code>是一个模板类，它需要键和值的模板参数，按照这个顺序。以下是一些例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d2b8" class="mt lj it lh b gy mu mv l mw mx">map&lt;string, string&gt; phoneList;<br/>map&lt;string, int&gt; birthYears;<br/>map&lt;int, int&gt; grades; // where first int is id number</span></pre><p id="a63c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果要修改映射的排序顺序，可以提供第三个模板参数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2538" class="mt lj it lh b gy mu mv l mw mx">map&lt;int, int, greater&lt;int&gt;&gt; grades;</span></pre><p id="4aca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以提供一个初始化列表，用一些键/值对来初始化映射:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="38c6" class="mt lj it lh b gy mu mv l mw mx">map&lt;string, int&gt; grades = {{"Doe", 81}, {"Brown", 92},<br/>                           {"Smith", 88}};</span></pre><h1 id="7122" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">快速回顾配对结构</h1><p id="5967" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">您可能已经注意到在上面的初始化列表中，键/值对是以<em class="my"> {key，value} </em>的形式输入的。该表单用于定义一个<code class="fe le lf lg lh b">pair</code>，它是在<code class="fe le lf lg lh b">utility</code>库中找到的一个结构。<code class="fe le lf lg lh b">pair</code>结构有两个字段<code class="fe le lf lg lh b">first</code>和<code class="fe le lf lg lh b">second</code>。以下是如何在地图之外创建一个<code class="fe le lf lg lh b">pair</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0998" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;utility&gt;<br/>using namespace std;</span><span id="5a03" class="mt lj it lh b gy mz mv l mw mx">int main()<br/>{<br/>  pair&lt;string, int&gt; student;<br/>  student.first = "Brown";<br/>  student.second = 88;<br/>  cout &lt;&lt; "Name: " &lt;&lt; student.first &lt;&lt; ", Grade: "<br/>       &lt;&lt; student.second &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="58cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d61f" class="mt lj it lh b gy mu mv l mw mx">Name: Brown, Grade: 88</span></pre><p id="a717" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一些情况下，当您使用地图时会直接使用这些<code class="fe le lf lg lh b">pair</code>函数，因此了解配对是如何工作的是个好主意。</p><h1 id="c995" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">向地图添加数据</h1><p id="7758" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">insert</code>函数用于向地图添加新元素:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="53d8" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;map&gt;<br/>using namespace std;</span><span id="ea1e" class="mt lj it lh b gy mz mv l mw mx">int main()<br/>{<br/>  map&lt;string, int&gt; grades = {{"Doe", 81}, {"Brown", 92},<br/>                             {"Smith", 88}};<br/>  grades.insert({"Jones", 79});<br/>  return 0;<br/>}</span></pre><p id="e593" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不会再提供一个完整的程序，除非其中一个预处理器指令发生变化。</p><p id="c351" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">insert</code>函数返回一个<code class="fe le lf lg lh b">pair</code>作为返回值，包含一个指向<code class="fe le lf lg lh b">first</code>字段中插入点的迭代器和一个表示<code class="fe le lf lg lh b">second</code>字段中插入成功或失败的布尔值。这里有一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ea76" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;map&gt;<br/>#include &lt;utility&gt;<br/>using namespace std;</span><span id="b97e" class="mt lj it lh b gy mz mv l mw mx">int main()<br/>{<br/>  map&lt;string, int&gt; grades = {{"Doe", 81}, {"Brown", 92},<br/>                             {"Smith", 88}};<br/>  pair&lt;map&lt;string, int&gt;::iterator, bool&gt; success =<br/>    grades.insert({"Jones", 79});<br/>  if (success.second) {<br/>    cout &lt;&lt; "inserted at: " &lt;&lt; success.second &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="36ee" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">访问地图数据</h1><p id="a6e0" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果您试图访问与特定键相关的值，您可以使用<code class="fe le lf lg lh b">[]</code>操作符并将键放在括号内，或者使用<code class="fe le lf lg lh b">at</code>函数将键作为参数。下面是一个使用两种方法的示例:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b655" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  map&lt;string, int&gt; grades = {{"Doe", 81}, {"Brown", 92},<br/>                             {"Smith", 88}};<br/>  grades.insert({"Jones", 79});<br/>  string name = "Brown";<br/>  cout &lt;&lt; name &lt;&lt; "'s grade: " &lt;&lt; grades[name] &lt;&lt; endl;<br/>  name = "Doe";<br/>  cout &lt;&lt; name &lt;&lt; "'s grade: " &lt;&lt; grades.at(name) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="de62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0978" class="mt lj it lh b gy mu mv l mw mx">Brown's grade: 92<br/>Doe's grade: 81</span></pre><p id="1285" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想访问地图的所有元素，你可以使用一个range <code class="fe le lf lg lh b">for</code>循环，就像这样:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6ab9" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  map&lt;string, int&gt; grades = {{"Doe", 81}, {"Brown", 92},<br/>                             {"Smith", 88}};<br/>  grades.insert({"Jones", 79});<br/>  for(auto iter = grades.begin(); iter != grades.end();<br/>      iter++) {<br/>    cout &lt;&lt; iter-&gt;first &lt;&lt; ": " &lt;&lt; iter-&gt;second &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="69e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每次迭代返回一个指向pair结构的迭代器。要获取键，必须引用<code class="fe le lf lg lh b">first</code>字段，要获取值，必须引用<code class="fe le lf lg lh b">second</code>字段。要访问这些字段，必须使用箭头操作符<code class="fe le lf lg lh b">-&gt;</code>而不是点操作符。</p><h1 id="f98d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">从地图中移除元素</h1><p id="29b9" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用<code class="fe le lf lg lh b">erase</code>功能移除地图元素。该函数将一个键作为参数，并删除具有匹配键的元素。该函数返回移除的元素数量。</p><p id="efc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e792" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  map&lt;string, int&gt; grades = {{"Doe", 81}, {"Brown", 92},<br/>                             {"Smith", 88}};<br/>  string key = "Doe";<br/>  int numRemoved = grades.erase(key);<br/>  cout &lt;&lt; "Removed " &lt;&lt; numRemoved &lt;&lt; " elements." &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><h1 id="fcbe" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用多地图</h1><p id="6dd9" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">一个<code class="fe le lf lg lh b">multimap</code>只是一个允许重复键的映射。有时这是使用的正确容器，比如当你建立一个字典或者一个电话列表，列表上的人可以有相同的名字。下面的程序片段将演示如何使用multimap创建一个字典，其中同一个单词可以有多种含义:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5748" class="mt lj it lh b gy mu mv l mw mx">multimap&lt;string, string&gt; dictionary;<br/>dictionary.insert({"bark", "outer covering of a tree"});<br/>dictionary.insert({"bark", "sound a dog makes"});<br/>dictionary.insert({"nail", " as in toenail, fingernail"});<br/>dictionary.insert({"nail", "sharp sliver of metal"});<br/>dictionary.insert({"mine", "possesive adjective"});<br/>dictionary.insert({"mine", "place where minerals are located"});</span></pre><p id="17d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用range <code class="fe le lf lg lh b">for </code>循环遍历整个字典:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="59f8" class="mt lj it lh b gy mu mv l mw mx">for (const auto elem : dictionary) {<br/>  cout &lt;&lt; elem.first &lt;&lt; ": " &lt;&lt; elem.second &lt;&lt; endl;<br/>}</span></pre><p id="e810" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们遍历一个单词的定义。为此，我需要引入两个新函数，<code class="fe le lf lg lh b"> lower_bound</code>和<code class="fe le lf lg lh b">upper_bound</code>。这些函数将一个键作为参数。<code class="fe le lf lg lh b">lower_bound </code>函数返回插入新元素的第一个位置，或者找到匹配键的第一个元素的位置。<code class="fe le lf lg lh b">upper_bound</code>函数返回插入新元素的最后位置，或者找到匹配键的最后一个元素的位置。</p><p id="f67a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用这些函数返回一个单词的所有定义，如下例所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="63df" class="mt lj it lh b gy mu mv l mw mx">//find all definitions of one word<br/>string key("mine");<br/>cout &lt;&lt; "All definitions of the word mine: " &lt;&lt; endl &lt;&lt; endl;<br/>for (auto iter = dictionary.lower_bound(key);<br/>     iter != dictionary.upper_bound(key); iter++) {<br/>  cout &lt;&lt; iter-&gt;first &lt;&lt; ": " &lt;&lt; iter-&gt;second &lt;&lt; endl;<br/>}</span></pre><p id="408d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序片段的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="17ef" class="mt lj it lh b gy mu mv l mw mx">All definitions of the word mine:</span><span id="f09e" class="mt lj it lh b gy mz mv l mw mx">mine: possesive adjective<br/>mine: place where minerals are located</span></pre><h1 id="1ded" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用地图和多地图</h1><p id="4bc0" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">map </code>和<code class="fe le lf lg lh b">multimap</code>容器是专门的容器，应该只在处理关联数据时使用。当应用程序中的键需要唯一时使用<code class="fe le lf lg lh b">map</code>类，当应用程序中的键可以重复时使用<code class="fe le lf lg lh b">multimap</code>类。这些容器也是经过排序的，所以如果您希望您的键以非升序的顺序出现，您可以更改排序标准。</p><p id="4499" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>