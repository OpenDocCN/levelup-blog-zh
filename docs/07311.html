<html>
<head>
<title>Is Java Set ordered or not?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java集合是否有序？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/is-java-set-ordered-or-not-f5abc80a729f?source=collection_archive---------4-----------------------#2021-02-08">https://levelup.gitconnected.com/is-java-set-ordered-or-not-f5abc80a729f?source=collection_archive---------4-----------------------#2021-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2352d35a30086d94c8386901995aafc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kudzIsDgoYlrD_qGab_-ng.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作者拍摄于斯德哥尔摩的萨德马尔姆</figcaption></figure><p id="9b22" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">" Java集合是否有序？"是你面试Java开发人员职位时最常被问到的问题。许多人没有回答这个问题，我不得不承认我是其中之一。</p><p id="4fce" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我早就知道答案是“是和不是”。</p><ul class=""><li id="2189" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated"><strong class="kh iu">否</strong>。<code class="fe lm ln lo lp b">HashSet</code>不是命令。</li><li id="6f94" class="ld le it kh b ki lq km lr kq ls ku lt ky lu lc li lj lk ll bi translated"><strong class="kh iu">是</strong>。<code class="fe lm ln lo lp b">TreeSet</code>是命令。</li></ul><p id="193b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果面试官继续问一些后续问题，我不确定我知道答案。</p><ul class=""><li id="6a7c" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">为什么TreeSet是有序的？</li><li id="9319" class="ld le it kh b ki lq km lr kq ls ku lt ky lu lc li lj lk ll bi translated">还有其他有序集实现吗？</li></ul><p id="b802" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">作为一个总想进步的成长型开发者，有必要在阅读其源代码后，吸收JDK在设计和实现上的一些优秀思想，并总结相关资料。为了这个目的，我开始写这篇文章，并尽力解释集合的顺序。</p><p id="0069" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，我们来看一个简单的集合类图。</p><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lv"><img src="../Images/4c0872ac986b160cd2375c74a775cb14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDiO0SbAt6bivmabtzRTuw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">集合—设置类图</figcaption></figure><p id="4e9e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Set与List的唯一区别是<strong class="kh iu"> Set没有重复的元素</strong>！请记住这一点，无论Set实现是什么，它都是基于这个原则。</p><h1 id="9ebd" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">有序集合</h1><p id="7bf1" class="pw-post-body-paragraph kf kg it kh b ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky nc la lb lc im bi translated">我们可以从上面的类图中直观的找到答案。所有实现<code class="fe lm ln lo lp b">NavigableSet</code>接口的集合都是有序集合，如<code class="fe lm ln lo lp b">LinkedHashset</code>、<code class="fe lm ln lo lp b">EnumSet</code>等。</p><p id="a209" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe lm ln lo lp b">NavigableSet</code>对<code class="fe lm ln lo lp b">SortedSet</code>进行了扩展，在其基础上增加了一些界面功能。</p><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/9f820f2015af2a946974cb668faacfa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3QmxzieSEqau6Qdu1DQCg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">分类集合</figcaption></figure><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/63f94cb51a2dfb807a870947845ba7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*irAwNFF5mB2ChDxkk3A6MQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可导航集</figcaption></figure><pre class="lw lx ly lz gt nf lp ng nh aw ni bi"><span id="6bcc" class="nj mb it lp b gy nk nl l nm nn">E lower(E e);// Returns the greatest element in this set strictly less than the given element<br/>E floor(E e);<br/>E ceiling(E e);// Returns the least element in this set greater than or equal to the given element</span></pre><p id="24da" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这样，<code class="fe lm ln lo lp b">Set</code>实现类提供了各种外部可用的方法，比如顺序、逆序、第一个、最后一个。</p><p id="f9d9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，<code class="fe lm ln lo lp b">TreeSet</code>通过使用实现<code class="fe lm ln lo lp b">NavigableMap</code>的<code class="fe lm ln lo lp b">TreeMap</code>实现内部排序。但如果你真的了解它，你就知道为什么它被认为是糟糕的表现。</p><p id="8c6e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">并非所有有序集合都共享相同的排序逻辑，例如，<code class="fe lm ln lo lp b">LinkedHashSet</code>排序方式不同。一般来说，如果我们说集合元素是有序的，并且它们的顺序可以归类为两种不同的逻辑模式。</p><ul class=""><li id="d4cf" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">根据插入元素的顺序进行排序。</li><li id="bab8" class="ld le it kh b ki lq km lr kq ls ku lt ky lu lc li lj lk ll bi translated">按照<code class="fe lm ln lo lp b">Comparator</code>或<code class="fe lm ln lo lp b">Comparable</code>接口实现排序。</li></ul><p id="d8ec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe lm ln lo lp b">TreeSet</code>是后一种情况，而<code class="fe lm ln lo lp b">LinkedHashSet,</code>是第一种情况。而且你可以从它的名字大致推断出<code class="fe lm ln lo lp b">LinkedHashSet</code>的实现。</p><blockquote class="no np nq"><p id="2799" class="kf kg nr kh b ki kj kk kl km kn ko kp ns kr ks kt nt kv kw kx nu kz la lb lc im bi translated"><strong class="kh iu">Set接口</strong>的哈希表和链表实现，迭代顺序可预测。— LinkedHashSet</p></blockquote><p id="452b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它的底层是在<code class="fe lm ln lo lp b">LinkedHashMap</code>实现的基础上，通过1.8版本后的<code class="fe lm ln lo lp b">Spliterator.DISTINCT | Spliterator.ORDERED</code>迭代器来保证顺序。</p><p id="7014" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">除了实现<code class="fe lm ln lo lp b">NavigableSet</code>接口或者<code class="fe lm ln lo lp b">Spliterator</code>迭代器集合，还有其他选择实现集合排序吗？</p><p id="d722" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">是的。</strong></p><p id="f2a6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最简单的情况是一组“<code class="fe lm ln lo lp b">of(E)</code>方法”JDK9添加到set接口，支持构造包含0到10个元素的不变集，其真正的内部实现是<code class="fe lm ln lo lp b">ImmutableCollections</code>类。</p><p id="811e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这个工具类中有两种方法来实现这些集合。</p><ul class=""><li id="d6fb" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">包含少于两个元素的集合通过<code class="fe lm ln lo lp b">Set12</code>类实现。</li></ul><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/4a16addf1f507a14c15673ede42ef08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJZqxV_eMmUyVC3gZjbqyg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><code class="fe lm ln lo lp b">ImmutableCollections.Set12</code></figcaption></figure><ul class=""><li id="df7e" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">为了实现两个以上元素的集合，我们使用<code class="fe lm ln lo lp b">SetN</code>类。</li></ul><p id="ad28" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不仅<code class="fe lm ln lo lp b">SetN</code>类本身是不可变的，而且它还通过内部的最终数组和<code class="fe lm ln lo lp b">@Stable</code>注释的声明来确保元素的不变性。</p><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/4bb788cafe07a623b67a374a034b286b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D34MO90dC8_AxDBdrcj9AQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><code class="fe lm ln lo lp b">ImmutableCollections.SetN</code></figcaption></figure><p id="9397" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于它的不变性，它自己的实现只会集中在add(构造函数)和traverse ( <code class="fe lm ln lo lp b">SetNIterator</code>)两个方面。</p><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/bb207627f9389a681418b4d98fa896e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSe1HTHZ0SlS_qN82NzqzQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><code class="fe lm ln lo lp b">ImmutableCollections.SetN</code></figcaption></figure><p id="43ec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">用数组存储集合元素的最大特点是确定数组索引和元素hashcode的关系，这通常是保持集合高效率的关键因素。这里的实现是探针方法。</p><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/44f43e02672723728468acd4574e5b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QbqwB3o5Q2soiMQ37Pygbw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><code class="fe lm ln lo lp b">ImmutableCollections.SetN.probe</code></figcaption></figure><p id="aebb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">实际上，与这种实现类似的代码在早期的<code class="fe lm ln lo lp b">EnumSet</code>中已经有了，也是通过数组保存元素。</p><h1 id="c28c" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">哈希特</h1><p id="de0a" class="pw-post-body-paragraph kf kg it kh b ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky nc la lb lc im bi translated"><strong class="kh iu">HashSet为什么是无序的？</strong></p><p id="f133" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我想到的直接原因是<strong class="kh iu">性能</strong>和<strong class="kh iu">简单性</strong>。在语言设计的最初阶段，由于计算机的性能远远落后于目前的水平，所以快速和高效是非常重要的。</p><p id="c611" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在保持Set特性方面，hashcode显然比equals要高效得多。并且能够直接定位数组中的元素位置使得hashcode比iterate更有效。但是在这种情况下，很难保证元素的顺序。</p><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/94eab298c192063b650402631fbd6719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aX-_KkrY5sL5ZH1v1UMg0Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自https://en.wikipedia.org/wiki/Hash_table<a class="ae oa" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">的HashSet</a></figcaption></figure><p id="1750" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过计算hashcode，我们可以实现最快的重复数据删除。考虑到可能的哈希冲突，我们使用一个额外的数组来存储与哈希一致的元素。JDK一直在改进的高效散列算法是高效散列集的秘密。</p><p id="a00a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在JDK8之前，HashMap中的Java hash函数是这样实现的<a class="ae oa" href="http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/tip/src/share/classes/java/util/HashMap.java" rel="noopener ugc nofollow" target="_blank"> this </a>:</p><pre class="lw lx ly lz gt nf lp ng nh aw ni bi"><span id="bcd9" class="nj mb it lp b gy nk nl l nm nn">static int hash(int h) {<br/>    // This function ensures that hashCodes that differ only by<br/>    // constant multiples at each bit position have a bounded<br/>    // number of collisions (approximately 8 at default loadfactor).<br/>    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br/>    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br/>}</span></pre><p id="88cf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从<a class="ae oa" href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java" rel="noopener ugc nofollow" target="_blank"> JDK8 </a>开始改了。我不能很好地解释这个数学问题，如果你感兴趣，请参考<a class="ae oa" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank"> wiki页面</a>。</p><pre class="lw lx ly lz gt nf lp ng nh aw ni bi"><span id="7b88" class="nj mb it lp b gy nk nl l nm nn">static final int hash(Object key) {<br/>    int h;<br/>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br/>}</span></pre><p id="14a6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">除了修改hash算法，HashSet在JDK1.8版本中最大的进步是将保存重复元素顺序的列表改为使用<a class="ae oa" href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" rel="noopener ugc nofollow" target="_blank">红黑树</a>的列表，将重复元素搜索的效率从<code class="fe lm ln lo lp b">O(n) </code>提高到<code class="fe lm ln lo lp b">O(log n)</code>。</p><p id="3abd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">顺便说一句，<code class="fe lm ln lo lp b">HashSet</code>并不是为了性能而并发安全！</p><h1 id="e038" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">第三方设置</h1><p id="527b" class="pw-post-body-paragraph kf kg it kh b ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky nc la lb lc im bi translated">除了JDK的实现，许多开源框架提供了具有各种功能的集合。著名的有</p><ul class=""><li id="2981" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">番石榴套餐</li><li id="cb10" class="ld le it kh b ki lq km lr kq ls ku lt ky lu lc li lj lk ll bi translated"><a class="ae oa" href="https://www.eclipse.org/collections/" rel="noopener ugc nofollow" target="_blank">月食收藏</a></li><li id="3eac" class="ld le it kh b ki lq km lr kq ls ku lt ky lu lc li lj lk ll bi translated"><a class="ae oa" href="http://fastutil.di.unimi.it/" rel="noopener ugc nofollow" target="_blank"> Fastutil </a></li></ul><p id="31d4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在性能和存储方面，各种第三方工具的实现通常比JDK要好。下图是<a class="ae oa" href="https://www.eclipse.org/collections/" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>的UnifiedSet和HashSet的内存使用对比。</p><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/35fcee8025367b835a32adedf5fb3e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wGJC9-LfcrMoaabS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自<a class="ae oa" href="https://www.eclipse.org/collections/" rel="noopener ugc nofollow" target="_blank">日蚀收藏</a></figcaption></figure><p id="2e2a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae oa" href="https://github.com/google/guava" rel="noopener ugc nofollow" target="_blank">番石榴开源库</a>应该是除了<code class="fe lm ln lo lp b"><a class="ae oa" href="https://commons.apache.org/" rel="noopener ugc nofollow" target="_blank">apache.commons</a></code>之外，Java开发者最常用的第三方库。</p><p id="e148" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我写这篇文章的想法是在我的同事提出一个问题时引发的。</p><blockquote class="no np nq"><p id="7910" class="kf kg nr kh b ki kj kk kl km kn ko kp ns kr ks kt nt kv kw kx nu kz la lb lc im bi translated">"订购了番石榴，你知道吗？"“不，”我叹了口气，诚实地回答。</p></blockquote><p id="703d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了更加博学，我花了一些时间阅读了<code class="fe lm ln lo lp b"><a class="ae oa" href="https://guava.dev/releases/21.0/api/docs/com/google/common/collect/ImmutableSet.html" rel="noopener ugc nofollow" target="_blank">ImmutableSet</a></code>的源代码，以了解它是如何实现有序特性的。哇，多么出色的设计啊！</p><p id="0661" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">简而言之，ImmutableSet使用<code class="fe lm ln lo lp b">Array + HashSet</code>来实现有序集。因为它是不可变的，所以不需要实现任何修改方法。</p><p id="7fbe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">阅读起来并不难，只花了我大约5-10分钟。你可以从<code class="fe lm ln lo lp b">add</code>法中找到所有有趣的东西。同样，ImmutableSet的实现也依赖于底层数组。</p><ul class=""><li id="9725" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">计算哈希码</li><li id="4294" class="ld le it kh b ki lq km lr kq ls ku lt ky lu lc li lj lk ll bi translated">将项目添加到多个数据结构中，同时保持它们有序并支持快速获取。</li><li id="8100" class="ld le it kh b ki lq km lr kq ls ku lt ky lu lc li lj lk ll bi translated">调整大小。</li></ul><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/3048770dcdf960db2e958cf124f51d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2d--E1lvZ5A_GA39HS-KXQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自Guava com . Google . common . collect . immutableset</figcaption></figure><h1 id="d022" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">摘要</h1><p id="0e00" class="pw-post-body-paragraph kf kg it kh b ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky nc la lb lc im bi translated">当你阅读Java或第三方库的集合代码时，你是在开动脑筋。作为我们课堂上学到的各种基础算法的真实练习，无论是复制、排序、哈希，还是搜索，你总能在各个地方找到反映。还包括位运算、移位运算等。面试中的大部分算法题，当你真正理解的时候，就成了小菜一碟。</p><p id="26e1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Java Set是Java集合的一部分，是最常用的类之一，并且经常更新。理解和掌握它并密切关注第三方的实现有助于您编写优雅和高性能的代码。</p><p id="9afd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">感谢阅读！</p></div></div>    
</body>
</html>