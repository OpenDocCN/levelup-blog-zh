<html>
<head>
<title>Go and React Development with Docker pt.1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker pt.1进行开发并做出反应</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-and-react-development-with-docker-pt-1-9f734a5991fc?source=collection_archive---------3-----------------------#2020-06-05">https://levelup.gitconnected.com/go-and-react-development-with-docker-pt-1-9f734a5991fc?source=collection_archive---------3-----------------------#2020-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2cdd0eb800a63c92b4de23b51018727b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UbU7R7kigcrMMbTk.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">Go and React系列的一部分</em></figcaption></figure><h1 id="4567" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="308d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">最近，我一直在从Node迁移到Go。使用Node，我有了一个很棒的fullstack开发工作流，但是我很难在Go中实现。我想要的是在容器中实时重新加载Go API并使用断点调试它的能力。在本教程中，我们将使用Docker设置最终的Go和React开发设置。</p><p id="24f0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我希望你熟悉全栈开发。我不会教你如何创建一个React应用程序甚至Go API的每一个细节。如果你是Docker的新手，没关系。需要的时候我会解释基本的。所以放轻松，您将能够随时复制和粘贴代码。</p><p id="1041" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们专注于:</p><ul class=""><li id="03f0" class="mh mi it lg b lh mc ll md lp mj lt mk lx ml mb mm mn mo mp bi translated"><a class="ae mq" href="#a676" rel="noopener ugc nofollow">入门</a></li><li id="77e4" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="#d7f8" rel="noopener ugc nofollow">码头工人基础知识</a></li><li id="fd8d" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="#9b40" rel="noopener ugc nofollow">设置VSCode </a></li><li id="c136" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="#4c4e" rel="noopener ugc nofollow">多阶段构建</a></li><li id="1e8e" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="#5fdd" rel="noopener ugc nofollow"> Docker撰写</a></li><li id="a9c5" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="#2d2c" rel="noopener ugc nofollow">使用Traefik </a></li><li id="c6be" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="#8264" rel="noopener ugc nofollow">使用makefile</a></li><li id="fffa" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="#86c6" rel="noopener ugc nofollow">使用Postgres </a></li><li id="0f6e" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="#626f" rel="noopener ugc nofollow">实时重装Go API </a></li><li id="c789" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="#f500" rel="noopener ugc nofollow">钻研调试一个Go API </a></li><li id="3a2f" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="#4be6" rel="noopener ugc nofollow">测试</a></li></ul><h1 id="a676" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">入门指南</h1><h2 id="376a" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">要求</h2><ul class=""><li id="f634" class="mh mi it lg b lh li ll lm lp ni lt nj lx nk mb mm mn mo mp bi translated"><a class="ae mq" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VSCode </a></li><li id="f625" class="mh mi it lg b lh mr ll ms lp mt lt mu lx mv mb mm mn mo mp bi translated"><a class="ae mq" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank">码头工人</a></li></ul><p id="f665" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">克隆<a class="ae mq" href="https://github.com/ivorscott/go-delve-reload" rel="noopener ugc nofollow" target="_blank">项目回购</a>并检查<code class="fe nl nm nn no b">starter</code>分支。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2b0d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">项目启动程序是一个简单的mono repo，包含两个文件夹。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="7e2d" class="mw kh it no b gy nz oa l ob oc">├── README.md<br/>├── api/<br/>├── client/</span></pre><h1 id="d7f8" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">码头基础知识</h1><p id="3025" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Docker对操作人员、系统管理员、构建工程师和开发人员非常有用。</p><p id="7c9e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Docker允许你打包你的应用程序并在任何操作系统上托管它。这意味着不再有“它在我的机器上工作”的对话。</p><p id="fe89" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Docker支持从开发到生产的整个软件生命周期。有了Docker，软件交付不必是一个痛苦和不可预测的过程。</p><h1 id="4fea" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">3个基本概念</h1><p id="d540" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用Docker通常从创建Docker文件开始，然后构建映像，最后运行一个或多个容器。</p><p id="f734" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这里有一些你应该知道的术语。</p><p id="d499" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> 1。图像</strong></p><p id="5bcf" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Docker映像是包含在单个实体中的应用程序的二进制文件、依赖项和元数据，由缓存以供重用的多个静态层组成。</p><p id="4ab9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> 2。Dockerfiles </strong></p><p id="0918" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">docker文件是制作图像的指导方法。每条指令都形成自己的图像层。</p><p id="6c3a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> 3。容器</strong></p><p id="7e9d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Docker容器是从Docker映像派生的应用程序实例。容器不是虚拟机。它们之所以不同，是因为每个容器不需要自己的操作系统。单个主机上的容器实际上将共享一个操作系统。这使得它们非常轻便。容器需要更少的系统资源，允许我们在一台机器上运行许多应用程序或容器。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/eb938bdab17b7b33230fa80a61ddd092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*rJgmy0nos999rx5NvSijUQ.png"/></div></figure><h1 id="9b40" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">设置VSCode</h1><p id="73e2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">打开VSCode或<a class="ae mq" href="https://code.visualstudio.com/download" rel="noopener ugc nofollow" target="_blank">安装它</a>。</p><p id="f181" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">安装这三个扩展。</p><p id="6ee3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">1)<a class="ae mq" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.Go" rel="noopener ugc nofollow" target="_blank">Go扩展</a> <br/>为Go语言增加了丰富的语言支持。</p><p id="4cf4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">2)<a class="ae mq" href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker" rel="noopener ugc nofollow" target="_blank">Docker扩展</a> <br/>为Docker相关文件增加了语法高亮、命令、悬停提示和林挺。</p><p id="6975" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">3)<a class="ae mq" href="https://marketplace.visualstudio.com/items?itemName=exiasr.hadolint" rel="noopener ugc nofollow" target="_blank">Hadolint扩展</a> <br/>将<a class="ae mq" href="https://github.com/hadolint/hadolint" rel="noopener ugc nofollow" target="_blank">Hadolint</a>(docker file linter)集成到VS代码中。</p><h1 id="ff27" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Go模块</h1><p id="2c80" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当在mono repo中使用Go模块时，当我们的api不是项目根时，VSCode似乎会抱怨。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/25b5fcdf0b0f2d5eb5bd675d8699b9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-vc6uJBbqJJCsZzjNNMCw.png"/></div></div></figure><p id="0b9b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">右键单击侧边栏区域中项目树的下方来修复这个问题。点击“将文件夹添加到工作区”并选择<code class="fe nl nm nn no b">api</code>文件夹。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/a6c1c3450fe3e942888ad7b85bedbe54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofDBayL3DSfaeae2X1RHzw.png"/></div></div></figure><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/e4865b07b86b81964f8746e8f7eeb049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QksfpOlfELc4xViO6snmFw.png"/></div></div></figure><h1 id="d164" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">为Delve调试设置VSCode</h1><p id="9122" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">VSCode需要连接到go容器中的delve调试器。</p><p id="88fb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">创建一个名为<code class="fe nl nm nn no b">.vscode</code>的隐藏文件夹，并将<code class="fe nl nm nn no b">launch.json</code>添加到其中。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="7bad" class="mw kh it no b gy nz oa l ob oc">mkdir .vscode<br/>touch .vscode/launch.json</span></pre><p id="1882" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">将以下内容添加到<code class="fe nl nm nn no b">launch.json</code>。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="4c4e" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">多阶段构建</h1><h2 id="e956" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">创建Golang Dockerfile文件</h2><p id="3c17" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">添加一个新的<code class="fe nl nm nn no b">Dockerfile</code>到api文件夹并打开它。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="4c5d" class="mw kh it no b gy nz oa l ob oc">touch api/Dockerfile</span></pre><p id="7f94" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">添加以下内容:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="9094" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">演示</h2><p id="6d04" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在根目录中运行以下命令来构建api开发映像:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4752" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">docker build</code>命令参考我们的docker文件构建一个新的docker映像。</p><p id="ab69" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">--target</code>指定我们只想针对多阶段构建设置中的<code class="fe nl nm nn no b">dev</code>阶段。</p><p id="02b0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae mq" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>帮助我们应用关注点分离。在多阶段构建设置中，您可以定义单个Dockerfile文件的不同阶段。然后你参考后面的具体阶段。在我们的api Dockerfile文件中，我们声明了第一个阶段的名称<code class="fe nl nm nn no b">as base</code>。</p><p id="eff7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">--tag</code>指定一个<a class="ae mq" href="https://docs.docker.com/engine/reference/commandline/tag/" rel="noopener ugc nofollow" target="_blank">图像标签</a>。图像标签只是一个我们可以用来引用图像的名称，它被标记为<code class="fe nl nm nn no b">demo/api</code>。</p><p id="29f2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果你的目标是发布到<a class="ae mq" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>上，你可以制作私人或公共的图片。DockerHub期望的基本格式是用户名/图像名。因为我们在本教程中不发布图片，所以<code class="fe nl nm nn no b">demo</code>不必是你的真实用户名。</p><p id="1420" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">DOCKER_BUILDKIT=1</code>是一个新特性，支持并行构建处理，从而加快构建速度。你可以<a class="ae mq" href="https://brianchristner.io/what-is-docker-buildkit/" rel="noopener ugc nofollow" target="_blank">在这里</a>阅读更多。</p><p id="35a7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们的Dockerfiles利用Aqua Security的<a class="ae mq" href="https://github.com/aquasecurity/trivy" rel="noopener ugc nofollow" target="_blank"> trivy </a>图像扫描仪。Docker镜像偶尔会有漏洞。图像扫描仪可以通过提醒我们任何问题来提供帮助。与大多数图像扫描仪不同，trivy在检测图像中的漏洞方面没有问题。其他图像扫描仪会遇到问题，因为轻量级图像会消耗产生精确图像扫描所需的资源。观看此<a class="ae mq" href="https://youtu.be/UMtyHmu3_Do?t=211" rel="noopener ugc nofollow" target="_blank">视频</a>了解更多信息。</p><h2 id="c8b2" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">创建反应Dockerfile文件</h2><p id="3755" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">向客户端文件夹添加一个新的<code class="fe nl nm nn no b">Dockerfile</code>并打开它。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="77b8" class="mw kh it no b gy nz oa l ob oc">touch client/Dockerfile</span></pre><p id="d45d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">增加以下内容:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="4d60" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">演示</h2><p id="5cea" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在根目录下运行以下命令来构建客户端开发映像:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b356" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在这一节中，我们看到了如何使用Dockerfiles将我们的应用程序二进制文件与依赖项打包在一起。我们还使用多阶段构建在一个docker文件中定义不同的映像:用于开发、测试和生产。构建图像是通过运行<code class="fe nl nm nn no b">docker build</code>命令手动执行的，我们提供了<code class="fe nl nm nn no b">--target</code>标志来选择多阶段设置中的单个阶段。在下一节中，我们将使用<code class="fe nl nm nn no b">docker-compose</code>来构建映像和运行容器。</p><h1 id="5fdd" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Docker撰写</h1><h2 id="9624" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">运行容器</h2><p id="d9a8" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">随着Docker映像的成功构建，我们已经准备好运行我们的应用程序实例了。</p><p id="98aa" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">docker-compose</code>是运行容器的命令行工具和配置文件。您应该只将它用于本地开发和测试自动化。它从来不是为生产而设计的。对于生产，您最好使用Docker Swarm这样的生产级orchestrator】下面是原因。</p><p id="db10" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> <em class="og">注:</em></strong><em class="og"/><a class="ae mq" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"><em class="og">Kubernetes</em></a><em class="og">是另一个流行的制作级管弦乐手。在开发中，我通常不使用orchestrator。在以后的文章中，我会谈到Docker Swarm和Kubernetes的产品。</em></p><p id="83d2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">使用docker-compose 我们可以用一个命令运行一组容器。这使得运行多个容器变得更加容易，尤其是当容器之间有关系并且相互依赖时。</p><p id="3e85" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在项目根目录下，创建一个<code class="fe nl nm nn no b">docker-compose.yml</code>文件并打开它。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="e0c3" class="mw kh it no b gy nz oa l ob oc">touch docker-compose.yml</span></pre><p id="a1a7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">添加以下内容:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c6d8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在项目根目录下创建一个<code class="fe nl nm nn no b">secrets</code>文件夹。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="60a8" class="mw kh it no b gy nz oa l ob oc">mkdir secrets</span></pre><p id="641d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">添加以下秘密文件。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="ce7e" class="mw kh it no b gy nz oa l ob oc">└── secrets<br/>├── postgres_db<br/>├── postgres_passwd<br/>└── postgres_user</span></pre><p id="45e1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在每个文件中添加一些秘密值。</p><p id="c5e2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们的docker-compose.yml文件中的以下代码告诉docker-compose卷和网络将被预先(或外部)创建。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="970d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">所以我们需要提前创建它们。为此，请运行以下命令。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="83e0" class="mw kh it no b gy nz oa l ob oc">docker network create postgres-net<br/>docker network create traefik-public<br/>docker volume create postgres-db</span></pre><p id="72ee" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">导航到您的主机的<code class="fe nl nm nn no b">/etc/hosts</code>文件并打开它。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="e075" class="mw kh it no b gy nz oa l ob oc">sudo vim /etc/hosts</span></pre><p id="b1eb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">添加包含以下域的附加行。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="95e8" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">演示</h2><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="c644" class="mw kh it no b gy nz oa l ob oc">docker-compose up</span></pre><p id="114a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在两个单独的浏览器选项卡中，导航至<a class="ae mq" href="https://api.local/products" rel="noopener ugc nofollow" target="_blank">https://api.local/products</a>，然后导航至<a class="ae mq" href="https://client.local" rel="noopener ugc nofollow" target="_blank"> https://client.local </a></p><p id="28e8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> <em class="og">注:</em> </strong> <em class="og">在您的浏览器中，您可能会看到警告，提示您单击某个链接以继续访问所请求的页面。这在使用自签名证书时很常见，不应该成为关注的原因。</em></p><p id="37ae" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们首先使用自签名证书的原因是为了尽可能地复制生产环境。</p><p id="84ed" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您应该看到react应用程序中显示的产品，这意味着<code class="fe nl nm nn no b">traefik</code>、<code class="fe nl nm nn no b">api</code>、<code class="fe nl nm nn no b">client</code>和<code class="fe nl nm nn no b">db</code>容器正在成功通信。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/a4b7094c8654775899f11752f7433c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_c-eJ_40IgeXgdfqmopMA.png"/></div></div></figure><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/a5c229332413a4200cd74e65c41629ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDWXIqCrCD-K_ytta-_8ZA.png"/></div></div></figure><h2 id="3df1" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">清理</h2><p id="3ec5" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">运行<code class="fe nl nm nn no b">docker-compose down</code>停止并删除我们用<code class="fe nl nm nn no b">docker-compose up</code>命令创建的所有容器。此外，还要删除我们创建的外部卷和网络。在<em class="og">使用makefile</em>部分，makefile会为我们创建这些。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="c6c1" class="mw kh it no b gy nz oa l ob oc">docker-compose down<br/>docker network remove postgres-net<br/>docker network remove traefik-public<br/>docker volume remove postgres-db</span></pre><h1 id="2d2c" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">使用Traefik</h1><p id="ce14" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们的docker-compose.yml文件已经配置为使用Traefik生成自签名证书。</p><p id="fdde" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">你可能想知道什么是Traefik 。</p><p id="b924" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Traefik的文件指出:</p><blockquote class="oj"><p id="0055" class="ok ol it bd om on oo op oq or os mb dk translated"><em class="kf"> Traefik是一款开源边缘路由器，让发布您的服务变得轻松有趣。它代表您的系统接收请求，并找出哪些组件负责处理这些请求。</em></p><p id="9ea1" class="ok ol it bd om on oo op oq or os mb dk translated"><em class="kf">除了众多特性之外，Traefik的与众不同之处在于它能自动为您的服务发现正确的配置。当Traefik检查您的基础设施时，神奇的事情就发生了，它会找到相关的信息，并发现哪个服务服务于哪个请求。</em></p><p id="1c15" class="ok ol it bd om on oo op oq or os mb dk translated"><em class="kf">—</em><a class="ae mq" href="https://docs.traefik.io/#the-traefik-quickstart-using-docker" rel="noopener ugc nofollow" target="_blank"><em class="kf">https://docs . traefik . io/# the-traefik-quick start-using-docker</em></a></p></blockquote><p id="0567" class="pw-post-body-paragraph le lf it lg b lh ot lj lk ll ou ln lo lp ov lr ls lt ow lv lw lx ox lz ma mb im bi translated">在我们的撰写文件中重新访问<code class="fe nl nm nn no b">traefik</code>服务。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1270" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们利用DockerHub版本2.1.2的官方Traefik映像。我们可以使用命令行标志和标签来配置Traefik。</p><p id="f25a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> <em class="og">注意:</em> </strong> <em class="og">还可以使用TOML文件和YAML文件配置Traefik。</em></p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/8aeb8a542c12aff91ea3449454a719bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bEY58zc8H57hY0R1gf5Pxw.png"/></div></div></figure><p id="e5cb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我更喜欢使用CLI标志，因为我不想担心在生产中存储TOML文件。我也喜欢只依赖一个docker-compose.yml文件来设置一切的想法。</p><h2 id="d13b" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">一行一行:它是如何工作的</h2><p id="78e4" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们从命令行标志开始。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="5994" class="mw kh it no b gy nz oa l ob oc">--api.insecure=true</span></pre><p id="5cf9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">该API在traefik入口点(端口8080)上公开。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="9506" class="mw kh it no b gy nz oa l ob oc">--api.debug=true</span></pre><p id="9d79" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为调试和分析启用附加端点。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="b073" class="mw kh it no b gy nz oa l ob oc">--log.level=DEBUG</span></pre><p id="a823" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">将日志级别设置为调试。默认情况下，日志级别设置为错误。可选的日志记录级别有调试、紧急、致命、警告和信息。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="dc2b" class="mw kh it no b gy nz oa l ob oc">--providers.docker</span></pre><p id="cf64" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">有各种提供者可供选择，这一行明确选择了docker。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="fe5f" class="mw kh it no b gy nz oa l ob oc">--providers.docker.exposedbydefault=false</span></pre><p id="ae93" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">默认情况下，限制Traefik的路由配置不公开所有容器。只有贴有<code class="fe nl nm nn no b">traefik.enable=true</code>标签的容器才会暴露。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="05a9" class="mw kh it no b gy nz oa l ob oc">--providers.docker.network=traefik-public</span></pre><p id="0f71" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">定义用于连接所有容器的默认网络。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="e63b" class="mw kh it no b gy nz oa l ob oc">--entrypoints.web.address=:80</span></pre><p id="d0b6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在端口80上创建一个名为web的入口点来处理http连接。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="3fd6" class="mw kh it no b gy nz oa l ob oc">--entrypoints.websecure.address=:443</span></pre><p id="9f8d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在端口443上创建一个名为websecure的入口点来处理https连接。</p><p id="f9bf" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">接下来，我们将介绍traefik服务的标签。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="7b64" class="mw kh it no b gy nz oa l ob oc">- "traefik.enable=true"</span></pre><p id="5fe0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">告诉Traefik将该服务包含在其路由配置中。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="656b" class="mw kh it no b gy nz oa l ob oc">- "traefik.http.routers.traefik.tls=true"</span></pre><p id="99b9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">启用TLS证书。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="de78" class="mw kh it no b gy nz oa l ob oc">- "traefik.http.routers.traefik.rule=Host(`traefik.api.local`)"</span></pre><p id="299b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">设置主机匹配规则，将所有匹配此请求的流量重定向到容器。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="5685" class="mw kh it no b gy nz oa l ob oc">- "traefik.http.routers.traefik.service=api@internal"</span></pre><p id="7df6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果启用API，将创建一个名为api@internal的新的特殊服务，并且可以在路由器中引用。该标签附在Traefik的内部api上，因此我们可以访问仪表板。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oz"><img src="../Images/9782c65575578de9dc0237a6a1aa425d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMiynU7cqzgnP20HsLTSvw.png"/></div></div></figure><p id="f97e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">下一组标签创建了一个名为http-catchall的路由器，它将捕获所有http请求并将其转发给一个名为redirect-to-https的路由器。这具有将我们的流量重定向到https的额外好处。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="90ea" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在再来看一下<code class="fe nl nm nn no b">client</code>服务。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="98c1" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">一行一行:它是如何工作的</h2><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="544f" class="mw kh it no b gy nz oa l ob oc">- "traefik.enable=true"</span></pre><p id="8886" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">告诉Traefik将该服务包含在其路由配置中。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="4606" class="mw kh it no b gy nz oa l ob oc">- "traefik.http.routers.client.tls=true"</span></pre><p id="8b96" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为了更新自动附加到应用程序的路由器配置，我们添加了以下列开头的标签:</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="1c27" class="mw kh it no b gy nz oa l ob oc">traefik.http.routers.{router-name-of-your-choice}</span></pre><p id="5436" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">后跟您要更改的选项。在这种情况下，我们启用tls加密。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="6eee" class="mw kh it no b gy nz oa l ob oc">- "traefik.http.routers.client.rule=Host(`client.local`)"</span></pre><p id="fe33" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">设置主机匹配规则，将所有匹配此请求的流量重定向到容器。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="9607" class="mw kh it no b gy nz oa l ob oc">- "traefik.http.routers.client.entrypoints=websecure"</span></pre><p id="091d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">配置Traefik以在websecure入口点上公开容器。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="6105" class="mw kh it no b gy nz oa l ob oc">- "traefik.http.services.client.loadbalancer.server.port=3000"</span></pre><p id="7e39" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">告诉Traefik容器将在内部3000端口上公开。</p><p id="b306" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在Traefik之前，我从头开始配置nginx反向代理。每次我添加一个额外的服务，我必须更新我的nginx配置。这不仅不可扩展，而且很容易出错。使用Traefik，反向代理服务很容易。</p><h1 id="8264" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">使用Makefiles</h1><p id="ceb2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">键入各种docker命令可能会很麻烦。<a class="ae mq" href="https://www.gnu.org/software/make/" rel="noopener ugc nofollow" target="_blank"> GNU Make </a>是一个构建自动化工具，通过读取名为Makefiles的文件，自动从源代码构建可执行程序。</p><p id="0506" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">下面是一个makefile示例:</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="a885" class="mw kh it no b gy nz oa l ob oc">#!make<br/>hello: hello.c<br/>gcc hello.c -o hello</span></pre><p id="2670" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们关心的主要特征是:</p><blockquote class="oj"><p id="ab0a" class="ok ol it bd om on oo op oq or os mb dk translated"><em class="kf">【这种能力】构建和安装你的包，而不需要知道如何完成的细节——因为这些细节被记录在你提供的makefile中。</em></p><p id="f612" class="ok ol it bd om on oo op oq or os mb dk translated"><em class="kf">——</em><a class="ae mq" href="https://www.gnu.org/software/make/" rel="noopener ugc nofollow" target="_blank"><em class="kf">https://www.gnu.org/software/make/</em></a></p></blockquote><p id="e21f" class="pw-post-body-paragraph le lf it lg b lh ot lj lk ll ou ln lo lp ov lr ls lt ow lv lw lx ox lz ma mb im bi translated">语法是:</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="213d" class="mw kh it no b gy nz oa l ob oc">target: prerequisite prerequisite prerequisite ...<br/>(TAB) commands</span></pre><p id="b0e5" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> <em class="og">注意:</em> </strong> <em class="og">目标和先决条件不一定是文件。</em></p><p id="6ccc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在命令行中，我们将通过键入<code class="fe nl nm nn no b">make</code>或<code class="fe nl nm nn no b">make hello</code>来运行这个示例makefile。这两种方法都可行，因为当没有指定目标时，将执行makefile中的第一个目标。</p><h1 id="82b3" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">创建Makefile</h1><p id="fc65" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在您的项目根目录中创建一个<code class="fe nl nm nn no b">makefile</code>并打开它。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="8e21" class="mw kh it no b gy nz oa l ob oc">touch makefile</span></pre><p id="eb05" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">增加以下内容:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="0b54" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">演示</h2><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="00e0" class="mw kh it no b gy nz oa l ob oc">make</span></pre><p id="3625" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">当您执行一个目标时，目标的命令体中的每个命令都将以自我记录的方式打印到stdout，然后执行。如果您不想将某个命令输出到stdout，但希望执行该命令，可以在它前面添加“@”符号。Makefile注释前面有一个“#”符号。在一个命令前使用“@#”会隐藏它，使其不被输出，并且永远不会执行。</p><p id="75f0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我使用<code class="fe nl nm nn no b">echo</code>向每个目标添加文档来描述每个目标做什么。</p><p id="825e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">当我们运行<code class="fe nl nm nn no b">make</code>或<code class="fe nl nm nn no b">make api</code>时，我们的makefile创建了一个外部数据库卷和2个网络。我们不想再这样了。因此，我们需要一种方法来测试我们是否已经完成了这一步。</p><p id="0a81" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这是通过以下代码完成的:</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="e5d9" class="mw kh it no b gy nz oa l ob oc">ifeq (,$(findstring postgres-net,$(NETWORKS)))<br/>	<em class="og"># do something</em><br/>endif</span></pre><p id="6a08" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果我们在<code class="fe nl nm nn no b">$(NETWORKS)</code>变量中找到<code class="fe nl nm nn no b">postgres-net</code>网络，我们什么也不做，否则我们创建网络。这个条件语句可能看起来有点奇怪，因为条件中的第一个参数是空的，也许可以更好地理解为<code class="fe nl nm nn no b">ifeq (null,$(findstring A,$(B)))</code>，但实际上上面的代码是正确的语法。</p><h2 id="4cbd" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">变量</h2><p id="187b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">变量可以在Makefile的顶部定义，并在以后引用。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="5ad5" class="mw kh it no b gy nz oa l ob oc"><em class="og">#!make</em><br/>NETWORKS="$(shell docker network ls)"</span></pre><p id="083a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">使用语法<code class="fe nl nm nn no b">$(shell &lt;command&gt;)</code>是执行命令并将其值存储在变量中的一种方式。</p><h2 id="1b63" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">环境变量</h2><p id="a60f" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">只要将. env文件中的环境变量包含在makefile的顶部，就可以引用它。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="116e" class="mw kh it no b gy nz oa l ob oc"><em class="og">#!make</em><br/>include .env<br/><br/>target:<br/>    echo ${MY_ENV_VAR}</span></pre><h2 id="daef" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">虚假目标</h2><p id="1a8b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">makefile无法区分文件目标和虚假目标。</p><blockquote class="oj"><p id="4871" class="ok ol it bd om on oo op oq or os mb dk translated">虚假的目标是一个不是真正的文件名的目标；更确切地说，它只是当您发出明确请求时要执行的配方的名称。使用假目标有两个原因:避免与同名文件冲突，以及提高性能。</p><p id="1dd4" class="ok ol it bd om on oo op oq or os mb dk translated"><em class="kf">——</em><a class="ae mq" href="https://bit.ly/370xohe" rel="noopener ugc nofollow" target="_blank"><em class="kf">https://bit.ly/370xohe</em></a></p></blockquote><p id="b745" class="pw-post-body-paragraph le lf it lg b lh ot lj lk ll ou ln lo lp ov lr ls lt ow lv lw lx ox lz ma mb im bi translated">我们的每个命令都是<code class="fe nl nm nn no b">.PHONY:</code>目标，因为它们不代表文件。</p><h1 id="86c6" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">使用Postgres</h1><h2 id="fc34" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">在终端中调试Postgres</h2><p id="cbd7" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们还没有讨论如何与Postgres互动。最终，您会想要进入正在运行的Postgres容器进行查询或调试。</p><h2 id="4ed1" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">演示</h2><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="efe3" class="mw kh it no b gy nz oa l ob oc">make debug-db</span></pre><p id="208a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您应该会自动登录。运行几个命令来感受一下。</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="34e0" class="mw kh it no b gy nz oa l ob oc">\dt</span></pre><p id="b585" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">然后运行:</p><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="3b30" class="mw kh it no b gy nz oa l ob oc">select name, price from products</span></pre><p id="5bbd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">debug-db</code>目标使用Postgres的高级命令行接口，称为<a class="ae mq" href="https://www.pgcli.com/" rel="noopener ugc nofollow" target="_blank"> pgcli </a>。</p><p id="3f2e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这太棒了。我们现在有一个用户友好的终端体验，语法高亮和自动完成。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/62adb8dd7ebc75e28e27ba87917193fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-CHeA1TpMp3bG2a7z-VnA.png"/></div></div></figure><h2 id="0376" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">PGAdmin4:在浏览器中调试Postgres</h2><p id="05d5" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">不是每个人都喜欢使用Postgres时的终端体验。我们还有一个使用<a class="ae mq" href="https://www.pgadmin.org/download/pgadmin-4-container/" rel="noopener ugc nofollow" target="_blank"> pgAdmin4 </a>的浏览器选项。</p><p id="70e4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">要登录，电子邮件是<code class="fe nl nm nn no b">test@example.com</code>，密码是<code class="fe nl nm nn no b">SuperSecret.</code>，如果你想改变这些值，它们位于docker-compose.yml文件中。将环境变量<code class="fe nl nm nn no b">PGADMIN_DEFAULT_EMAIL</code>和<code class="fe nl nm nn no b">PGADMIN_DEFAULT_PASSWORD</code>更改为您想要的任何值。</p><h2 id="12da" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">演示</h2><p id="d234" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在浏览器中导航至<a class="ae mq" href="https://pgadmin.local" rel="noopener ugc nofollow" target="_blank"> https://pgadmin.local </a>并登录。</p><p id="d16e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">点击“添加新服务器”。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pa"><img src="../Images/caa9fd6eefb3aad7579d1b7ba4c943a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HYQQdnp9fqKc_3qtJzkgw.png"/></div></div></figure><p id="0f6d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您需要修改的两个选项卡是“常规”和“连接”。在常规下添加数据库的名称。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pa"><img src="../Images/9c2e66441152b02eb950bb96bd1e41e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1rvMsGvdKASfEdjzUDjLg.png"/></div></div></figure><p id="056e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在“连接”选项卡下，填写主机名，应该是<code class="fe nl nm nn no b">db</code>，除非你在docker-compose.yml文件中更改了它。然后添加您的用户名，密码，并检查保存密码。最后，点击“保存”。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pa"><img src="../Images/5c59aa3a64e022e3be32ade12d935eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84ar_Ji1vXbQ_GfYop27-Q.png"/></div></div></figure><p id="bca8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">要查看数据库表，必须首先层叠嵌套的树结构，以找到要选择的表。然后选择页面顶部的表格视图图标。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pb"><img src="../Images/857fd4a19928b497dbd7decf94e6d05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pmeye8CF-hFXM6kVdkY1AQ.png"/></div></div></figure><h2 id="6407" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">制作Postgres数据库备份</h2><p id="050c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对Postgres数据库进行数据库备份非常简单。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="ed07" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">演示</h2><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="32a7" class="mw kh it no b gy nz oa l ob oc">make dump</span></pre><p id="80ba" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您可能想知道Postgres数据库最初是如何播种数据的。</p><p id="1188" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">官方的Postgres图片显示:</p><blockquote class="oj"><p id="100a" class="ok ol it bd om on oo op oq or os mb dk translated"><em class="kf">如果您想在从此映像派生的映像中进行额外的初始化，请添加一个或多个*。sql、*.sql.gz或*。/docker-entrypoint-initdb.d下的sh脚本(必要时创建目录)。</em></p><p id="8288" class="ok ol it bd om on oo op oq or os mb dk translated"><em class="kf">entry point调用initdb创建默认postgres用户和数据库后，会运行any *。sql文件，运行任何可执行文件*。sh脚本，以及任何不可执行的源代码*。在该目录中找到的sh脚本在启动服务之前做进一步的初始化。</em></p><p id="5621" class="ok ol it bd om on oo op oq or os mb dk translated"><em class="kf">——</em><a class="ae mq" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank"><em class="kf">https://hub.docker.com/_/postgres</em></a></p></blockquote><p id="2ab6" class="pw-post-body-paragraph le lf it lg b lh ot lj lk ll ou ln lo lp ov lr ls lt ow lv lw lx ox lz ma mb im bi translated">位于<code class="fe nl nm nn no b">api/scripts/create-db.sh</code>下的数据库创建脚本用于播种数据库。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d92c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在我们的docker-compose.yml文件中，<code class="fe nl nm nn no b">create-db.sh</code>被绑定到db容器中:</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="be93" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">create-db.sh</code>仅在备份不存在时运行。这样，如果您制作了一个备份(它被自动放置在<code class="fe nl nm nn no b">api/scripts</code>目录中)，并且您删除了数据库卷，然后重新启动数据库容器，下一次，<code class="fe nl nm nn no b">create-db.sh</code>将被忽略，并且将只使用备份。</p><h1 id="626f" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">实时重新加载Go API</h1><p id="ffa6" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">由于docker-compose.yml文件中的这一行，我们的go api已经可以重载了。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="08a6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果你熟悉Node，<a class="ae mq" href="https://github.com/githubnemo/CompileDaemon" rel="noopener ugc nofollow" target="_blank">编译器守护进程</a>会监视你的。像nodemon一样运行文件并重启服务器。</p><p id="eac9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">--build</code>用于指定重建时我们要运行的命令(此标志是必需的)。</p><p id="05fe" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">--command</code>用于指定成功构建后运行的命令(该标志默认为nothing)。</p><h2 id="d529" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">演示</h2><p id="706f" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要看到这一点，请确保您的api正在运行。然后对任何api文件进行更改，查看它的重新构建。</p><h1 id="f500" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">调试一个Go API</h1><p id="c483" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Delve已经成为Go编程语言事实上的标准调试器。为了与VSCode一起使用，我们需要添加一个启动脚本，以便VSCode可以附加到go容器中的调试器。安装delve后，下面一行是我们如何在容器级别执行它的。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="35b0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们使用<code class="fe nl nm nn no b">dlv debug</code>来编译并开始调试位于<code class="fe nl nm nn no b">./cmd/api/</code>目录中的主包。</p><p id="5a20" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">--accept-multiclient</code>允许一个无头服务器接受多个客户端连接。</p><p id="0221" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">--continue</code>在启动时继续调试的进程，这不是默认设置。</p><p id="bc95" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">--headless</code>仅在无头模式下运行调试服务器。</p><p id="6267" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">--listen</code>设置调试服务器监听地址。</p><p id="0184" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">--api-version</code>当无头和时将指定API版本</p><p id="7dc8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nl nm nn no b">--log</code>启用调试服务器日志。</p><h2 id="a22a" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">演示</h2><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="9455" class="mw kh it no b gy nz oa l ob oc">make debug-api</span></pre><p id="d438" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">转到<code class="fe nl nm nn no b">api/internal/handlers.go</code>并在其中一个处理程序中放置一个断点。在VSCode中，单击调试器选项卡中的“启动远程”按钮。接下来，导航到触发处理程序的路由。您应该会看到编辑器在您放置断点的地方暂停。</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/3acfe8518db6a66d75ae08e475dd64c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tm-t0VkWFi_hyFDMvE30bw.png"/></div></div></figure><h1 id="4be6" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">测试</h1><p id="da47" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">没有测试，我们的开发设置是不完整的。这里我们将运行两个命令来执行客户端和服务器端的单元测试。因为这些是单元测试，所以不需要运行应用程序来进行测试。</p><h2 id="f225" class="mw kh it bd ki mx my dn km mz na dp kq lp nb nc ku lt nd ne ky lx nf ng lc nh bi translated">演示</h2><pre class="np nq nr ns gt nv no nw nx aw ny bi"><span id="bc12" class="mw kh it no b gy nz oa l ob oc">make test-client<br/>make test-api</span></pre><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/760aadea51d9adec22d25aba4a0730fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2v9XcDsduwAJ2E-BDPqmtw.png"/></div></div></figure><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pe"><img src="../Images/07c307cb5a42a6df221d08d01ed91f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_epmfoiHcN4oTSh-B5Y_g.png"/></div></div></figure><p id="737f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在您的CI构建系统中，您可以简单地构建docker映像的测试阶段来运行单元测试。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1fe5" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">一月份，我参加了在柏林举行的GoDays 2020。有一个精彩的演示，展示了如何在容器中运行集成和端到端测试。如果您希望这样做，请查看<a class="ae mq" href="https://speakerdeck.com/godays/integration-and-end-to-end-testing-with-testcontainers-go-nikolay-kuznetsov-and-erdem-toraman-zalando" rel="noopener ugc nofollow" target="_blank">幻灯片</a>。正在使用的库是<a class="ae mq" href="https://github.com/testcontainers/testcontainers-go" rel="noopener ugc nofollow" target="_blank"> testcontainers-go </a>和<a class="ae mq" href="https://github.com/testcontainers/moby-ryuk" rel="noopener ugc nofollow" target="_blank"> moby-ryuk </a>。</p><h1 id="cc8f" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="69b8" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我希望您已经了解了如何使用Docker构建最终的Go和React开发设置。无论您在客户端或服务器端使用什么语言，基本原则仍然适用。如果你想从一个真正的码头船长那里学习码头工人，我强烈推荐Bret Fisher在Udemy上的<a class="ae mq" href="https://www.udemy.com/course/docker-mastery" rel="noopener ugc nofollow" target="_blank">码头工人大师课程</a>。快乐编码。</p><p id="c8bc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><em class="og">系列中的</em> <a class="ae mq" href="https://medium.com/@ivorscott/transitioning-to-go-pt-2-31432d2a074f" rel="noopener"> <em class="og">下一篇文章</em> </a> <em class="og">正在过渡到Go部分2 </em></p><p id="9824" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae mq" href="https://twitter.com/ivorsco77" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">在Twitter上关注我</strong> </a> <strong class="lg iu"> </strong>获取实时更新。</p><p id="bfc4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><em class="og">原载于</em><a class="ae mq" href="https://blog.ivorscott.com/ultimate-go-react-development-setup-with-docker" rel="noopener ugc nofollow" target="_blank"><em class="og">https://blog.ivorscott.com</em></a><em class="og">。</em></p></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><div class="np nq nr ns gt pm"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">编写面试问题</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">技术开发</p></div></div><div class="pv l"><div class="pw l px py pz pv qa jz pm"/></div></div></a></div></div></div>    
</body>
</html>