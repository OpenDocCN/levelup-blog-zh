<html>
<head>
<title>BigData/DBA: Querying a Database Table with over a Billion Rows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigData/DBA:查询超过10亿行的数据库表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bigdata-dba-querying-a-database-table-with-over-a-billion-rows-2278f17d3e69?source=collection_archive---------4-----------------------#2022-08-26">https://levelup.gitconnected.com/bigdata-dba-querying-a-database-table-with-over-a-billion-rows-2278f17d3e69?source=collection_archive---------4-----------------------#2022-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="840b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">查询大小为TB和PBs的关系数据库，也称为超大型数据库(VLDB)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/e0f5575d5b360bb2fba0ed518482a17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*Ky79awKprGNVxeS1u13kKA.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">图片来源:rkimball.com</figcaption></figure><p id="b1da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嘿伙计们！在这篇简短的文章中，我记下了特定于VLDBs的各种事实上的数据库(DB)优化技术。最重要的是，在应用或跳回到一个特定的技术之前，我已经总结了围绕构建这些优化技术的心智模型。</p><blockquote class="ln lo lp"><p id="20a6" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">写这篇文章的灵感:在我过去从事VLDBs工作的几个项目中，我意识到为了解决DB的读/写延迟问题，我们经常在确保基本而强大的简单优化技术处于受控状态之前，过快地采用非常先进的技术，如分片或NoSQL迁移。这篇文章是我过去解决这类问题的经验的反映。</p></blockquote><p id="d8b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我从DB world的一句名言开始，它是这样的:</p><blockquote class="lu"><p id="7818" class="lv lw iq bd lx ly lz ma mb mc md lm dk translated">查询有十亿行的表的最好方法是避免查询有十亿行的表。</p></blockquote><h1 id="7d8c" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">目录</h1><ol class=""><li id="89ec" class="mw mx iq kt b ku my kx mz la na le nb li nc lm nd ne nf ng bi translated"><strong class="kt ir">事实上的数据库优化技术&amp;围绕实现它们的心智模型</strong></li><li id="4a1e" class="mw mx iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated"><strong class="kt ir">索引文摘！—详细介绍索引、索引扫描的类型以及与此相关的示例</strong></li><li id="08bb" class="mw mx iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">其他技术的要点:简单来说就是分区、复制和分片。</li></ol></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="403a" class="me mf iq bd mg mh nt mj mk ml nu mn mo jw nv jx mq jz nw ka ms kc nx kd mu mv bi translated">1.简单的数据库优化技术</h1><p id="b171" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la ny lc ld le nz lg lh li oa lk ll lm ij bi translated">对于关系数据库，有各种简单有效的策略可以用来优化读/写IOPS或延迟。下面是要按顺序检查的所有技术的总结。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/10f63f803116ace122bbfcd27997a223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*stnd_4z7fDWDOXrzStyOIg.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">数据库实践</figcaption></figure><p id="8c53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi og translated"><span class="l oh oi oj bm ok ol om on oo di">从上图可以理解，要优化VLDBs的读/写延迟，应该先考虑<strong class="kt ir"> <em class="lq">索引</em></strong><strong class="kt ir"><em class="lq">缓存</em> </strong> &amp; <strong class="kt ir"> <em class="lq">复制</em> </strong>技术，然后再投入精力开发高级技术，如<strong class="kt ir"><em class="lq"/></strong>或<strong class="kt ir"> <em class="lq">迁移到NoSQL </em> </strong>数据库，这些数据库已经</span></p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="2f61" class="me mf iq bd mg mh nt mj mk ml nu mn mo jw nv jx mq jz nw ka ms kc nx kd mu mv bi translated">2.索引文摘</h1><p id="4259" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la ny lc ld le nz lg lh li oa lk ll lm ij bi translated">由于索引是一种比上面提到的其他实践更受欢迎的实践，在这一节中，我将演示如何充分利用索引。因此，它可以从这种VLDB的表中查询记录，而无需对源表进行一次扫描。</p><p id="15f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从下面附加的快照开始，它提到了所有的索引级别，并在每个级别使用右箭头将其增强扩展到右侧。<strong class="kt ir">级别1 </strong>默认为顺序扫描(无步进)，而<strong class="kt ir">级别3 </strong>为步进扫描。</p><p id="e07b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从<strong class="kt ir">级x </strong>到<strong class="kt ir">级x-1 </strong>的向上箭头显示回退扫描。如果索引扫描失败，则退回到位图扫描，如果位图扫描失败，则退回到顺序扫描。</p><p id="f4ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lq">因此请注意，如果索引配置不正确，底层扫描将总是回退到基于数据库功能的顺序扫描或并行顺序扫描。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi op"><img src="../Images/fc544ae126917325b849816b571a27df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1iys9uXeQ65i0y7SOsgDQ.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">利用数据库索引优化查询延迟</figcaption></figure><p id="5f76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在解释上面的快照之前，考虑一个表的方案:<br/><strong class="kt ir">public . vehicle _ histories:(vehicle _ no，timestamp，lat，long，speed，distance，state)。</strong>让我像这样定义一个目标查询，以理解上面提到的3个级别:</p><pre class="kg kh ki kj gt oq or os ot aw ou bi"><span id="bb86" class="ov mf iq or b gy ow ox l oy oz">EXPLAIN ANALYZE<br/>SELECT  <br/>    UPPER(vehicle_no),  <br/>    CAST(pst_timestamp AS DATETIME),  <br/>    latitude :: NUMERIC,  <br/>    longitude :: NUMERIC<br/>FROM  vehicle_histories<br/>WHERE  CASE1 | CASE2 | CASE3<br/>ORDER BY  pst_timestamp DESC<br/>LIMIT  10;</span></pre></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h2 id="0e30" class="ov mf iq bd mg pa pb dn mk pc pd dp mo la pe pf mq le pg ph ms li pi pj mu pk bi translated">情况1/级别1:无索引顺序扫描</h2><p id="6ca6" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la ny lc ld le nz lg lh li oa lk ll lm ij bi translated"><strong class="kt ir">其中:vehicle_no = "XYZ" <br/> </strong>这将是一次顺序扫描，可以使用MPP数据库进一步优化为并行顺序扫描。</p><p id="d675" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi og translated"><span class="l oh oi oj bm ok ol om on oo di"> M </span>这通常是数据仓库DB的主要特征。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h2 id="29bb" class="ov mf iq bd mg pa pb dn mk pc pd dp mo la pe pf mq le pg ph ms li pi pj mu pk bi translated">情况2/级别2:位图扫描</h2><p id="dab7" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la ny lc ld le nz lg lh li oa lk ll lm ij bi translated"><strong class="kt ir">索引在:</strong>vehicle _ no _ and _ vehicle _ timestamp _ idx+PST _ timestamp _ idx<br/><strong class="kt ir">其中:</strong> vehicle_no = "XYZ" <strong class="kt ir">或</strong> pst_timestamp在(T1，T2)之间</p><blockquote class="ln lo lp"><p id="87f8" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><em class="iq">vehicle _ no _ vehicle _ timestamp _ idx =&gt;这是一个</em> <strong class="kt ir"> <em class="iq">多列</em> </strong> <em class="iq">索引的例子，因为2个或更多的列/属性构成了索引。</em></p></blockquote><p id="9c78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，我们以<strong class="kt ir">位图索引扫描</strong>结束。你可以把它看作是两个或多个索引的交集。这比并行/顺序扫描好得多，但仍不如<strong class="kt ir">索引扫描或仅索引扫描</strong>(我们将在后面的案例中看到这一点)</p><p id="aca7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还要注意，由于这个索引扫描是两个索引的交集，所以我们在pst_timestamp上有第二个索引。使用位图扫描执行此类<strong class="kt ir">或查询</strong>非常重要。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h2 id="4a29" class="ov mf iq bd mg pa pb dn mk pc pd dp mo la pe pf mq le pg ph ms li pi pj mu pk bi translated">案例3:索引扫描</h2><p id="31c4" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la ny lc ld le nz lg lh li oa lk ll lm ij bi translated"><strong class="kt ir">索引on:</strong>vehicle _ no _ PST _ timestamp _ idx<br/><strong class="kt ir">其中:v </strong> ehicle_no = "XYZ" <strong class="kt ir">和</strong> pst_timestamp之间(T1，T2)</p><p id="fe83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个令人高兴的情况。数据库会使用索引堆文件找到源表 的<strong class="kt ir"> <em class="lq">行ID &amp;页号然后跳转到源表堆文件获取数据。但是跳转到源堆文件并查找行仍然是开销，并最终导致降低查询&amp;索引的性能。</em></strong></p><blockquote class="ln lo lp"><p id="c9bd" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><em class="iq">如上所述，索引扫描仍然比位图索引扫描更有效。</em></p></blockquote><h2 id="95f8" class="ov mf iq bd mg pa pb dn mk pc pd dp mo la pe pf mq le pg ph ms li pi pj mu pk bi translated">情况3/子情况:仅索引扫描(最有效)</h2><p id="9db2" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la ny lc ld le nz lg lh li oa lk ll lm ij bi translated"><strong class="kt ir">索引于:</strong>vehicle _ no _ pst_timestamp _ idx<strong class="kt ir">与</strong>纬度&amp;经度<br/>T5】其中: vehicle_no = "XYZ "与PST _ timestamp之间(T1，T2)</p><blockquote class="ln lo lp"><p id="aef3" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><em class="iq">vehicle _ no _ vehicle _ PST _ timestamp _ idx</em></p></blockquote><p id="30f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要注意的是<strong class="kt ir">多栏索引和多行索引</strong>是有区别的。在多行索引中，我们存储额外的行作为信息，不像在多列索引中，我们只有一个索引，没有额外的属性/列。</p><p id="16a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在任何数据库中，总有大约20%的查询在80%的时间里运行。在这里，我们可以通过对少数查询进行索引扫描来充分利用索引的功能。</p><p id="d1af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望所有3个案例和它们的子案例现在看起来都很简单。感谢你阅读这篇文章，我想分享一些索引后可以进一步使用的技巧。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="80ee" class="me mf iq bd mg mh nt mj mk ml nu mn mo jw nv jx mq jz nw ka ms kc nx kd mu mv bi translated">3.其他技术的要点</h1><p id="d704" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la ny lc ld le nz lg lh li oa lk ll lm ij bi translated">除了索引之外，让我们依次讨论一下其他技术<strong class="kt ir">可以用来提高读/写延迟。根据以下快照:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/10f63f803116ace122bbfcd27997a223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*stnd_4z7fDWDOXrzStyOIg.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">数据库性能增强</figcaption></figure><ul class=""><li id="b184" class="mw mx iq kt b ku kv kx ky la pl le pm li pn lm po ne nf ng bi translated"><strong class="kt ir">缓存:</strong>缓存可用于减少每个缓存TTL的查询次数。这将间接地减少数据库CPU和内存的使用。这可以在应用程序级别完成，通常使用像REDIS这样的内存缓存。</li></ul><p id="a472" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，值得注意的是，缓存也可以在数据库级别完成和配置。PostgreSQL主要使用缓存来存储数据、索引数据，甚至查询成本/计划者。</p><blockquote class="ln lo lp"><p id="2f25" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">您可以通过更改<strong class="kt ir"> shared_buffer </strong>来配置PostgreSQL缓存，并且可以将其从128MB(默认)增加到系统RAM的30%&lt;。</p></blockquote><ul class=""><li id="9566" class="mw mx iq kt b ku kv kx ky la pl le pm li pn lm po ne nf ng bi translated"><strong class="kt ir">分区:</strong>顾名思义，我们可以按区域或时间戳进行分区。例如，在上述示例中，分区如下所示:</li></ul><p id="acf1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">父表:</strong>事件历史记录</p><p id="011b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">分区字段:pst_timestamp @月频率<br/> <strong class="kt ir">子表1:</strong>event _ histories _ Jan _ 2022 _ feb _ 2022<br/><strong class="kt ir">子表2:</strong>event _ histories _ feb _ 2022 _ mar _ 2022<br/><strong class="kt ir">子表3:</strong>event _ histories _ mar _ 2022 _ apr _ 2022</p><blockquote class="ln lo lp"><p id="e674" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><em class="iq">通常，作为清理服务，每月运行一次作业来删除超过3-6个月的分区，并进行清理等。分区技术对于读取非常有用，但同时对于批量写入也非常有益。</em></p></blockquote><ul class=""><li id="f5e1" class="mw mx iq kt b ku kv kx ky la pl le pm li pn lm po ne nf ng bi translated"><strong class="kt ir">复制</strong>:在这种方法中，我们有一个主从架构/arc，其中主用户写，从用户读。</li><li id="498d" class="mw mx iq kt b ku nh kx ni la nj le nk li nl lm po ne nf ng bi translated"><strong class="kt ir">分片</strong>:分片应该始终是优化DB &amp;查询性能的最后努力。在应用程序级别，复杂性和维护开销可能会很麻烦。但是有工具可以形式化不同数据库的分片过程。比如MySQL:<a class="ae pp" href="https://vitess.io/" rel="noopener ugc nofollow" target="_blank">https://vitess.io/</a></li></ul><p id="95db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于关系数据库的性能增强，我们在本文中已经讨论了很多。我希望你喜欢这篇文章。</p><p id="ce24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lq">感谢阅读！</em></p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="4c58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lq">连接</em> </strong>🤝<strong class="kt ir"><em class="lq">:</em>T26】</strong></p><ul class=""><li id="2d8f" class="mw mx iq kt b ku kv kx ky la pl le pm li pn lm po ne nf ng bi translated"><strong class="kt ir"> <em class="lq">邮箱</em></strong>:<em class="lq">bbhopalw @ Gmail</em></li><li id="5419" class="mw mx iq kt b ku nh kx ni la nj le nk li nl lm po ne nf ng bi translated"><strong class="kt ir"><em class="lq">Linkedin</em></strong>:<a class="ae pp" href="http://www.linkedin.com/in/bbhoaplw" rel="noopener ugc nofollow" target="_blank"><em class="lq">www.linkedin.com/in/bbhoaplw</em></a></li></ul></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="10d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lq">供进一步阅读</em></strong>✍️<strong class="kt ir"><em class="lq">:</em></strong></p><p id="edb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lq">大数据&amp;云工程博客:</em> </strong></p><ul class=""><li id="3043" class="mw mx iq kt b ku kv kx ky la pl le pm li pn lm po ne nf ng bi translated"><strong class="kt ir"> <em class="lq">走向数据科学出版:</em></strong><a class="ae pp" href="https://medium.com/@burhanuddinbhopalwala" rel="noopener"><em class="lq">https://medium.com/@burhanuddinbhopalwala</em></a></li></ul><p id="14ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lq">后端工程&amp;软件工程博客:</em> </strong></p><ul class=""><li id="89b6" class="mw mx iq kt b ku kv kx ky la pl le pm li pn lm po ne nf ng bi translated"><strong class="kt ir"> <em class="lq"> DEV社区:</em><br/></strong><a class="ae pp" href="https://dev.to/burhanuddinbhopalwala" rel="noopener ugc nofollow" target="_blank"><em class="lq">https://dev.to/burhanuddinbhopalwala</em></a></li></ul></div></div>    
</body>
</html>