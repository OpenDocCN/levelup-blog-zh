<html>
<head>
<title>Dependency Injection (DI) — Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入(DI) —角度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-di-angular-21172d932f4f?source=collection_archive---------8-----------------------#2020-11-03">https://levelup.gitconnected.com/dependency-injection-di-angular-21172d932f4f?source=collection_archive---------8-----------------------#2020-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b49" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它是什么，它是如何工作的？+具体例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1ff84b8f39b7cc286ba75a8d86124b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjzTgolT-h7s0F7qb-56Xw.png"/></div></div></figure><p id="96a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组件的工作是呈现数据。因此，确保它有数据，并以正确的方式呈现数据，有时确保它将正确的数据分派给其子节点。</p><p id="c901" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们将获取和管理数据的任务委托给组件，那么这将是一件难以管理的事情。除此之外，如果我们在渲染组件时遇到问题，测试将会耗费更多的时间，因为我们要在同一个组件中进行数据获取和管理以及渲染。未来的任何改变都将更难实现和测试。这就是为什么这种类型的设计是一种可怕的做法。</p><p id="9981" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Angular的构建方式是通过使用服务和依赖注入来避免这个问题，因此:</p><ul class=""><li id="5a2c" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">您使得应用程序与其依赖项之间没有强耦合和链接。</li><li id="6e79" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">分解依赖关系的实例化</li><li id="53a1" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">提高可维护性，因为我们可以快速轻松地用另一个实现替换一个依赖项。</li><li id="e17a" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">促进可测试性，因为您分别测试服务及其功能。因此，缺陷检测及其纠正是容易和快速的。</li></ul><p id="91fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">在这篇文章中，我将介绍:</strong></p><ul class=""><li id="0671" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw iu">什么是服务？</strong></li><li id="534b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><strong class="kw iu">什么是DI，它是如何工作的？</strong></li><li id="5579" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><strong class="kw iu">DI的一个具体例子</strong></li><li id="4c0f" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><strong class="kw iu">外卖</strong></li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="ec2d" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">什么是服务？</h1><p id="9acc" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">从技术上讲，服务是Angular中可用的<a class="ae ni" href="https://angular.io/guide/schematics" rel="noopener ugc nofollow" target="_blank"> <em class="nj">示意图</em> </a>的一种类型。它可以通过使用Angular CLI(命令行界面)生成。</p><p id="a5c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从功能上来说，服务是针对特定主题的一组功能。我们可以想象一个导入CSV文件的服务，或者一个获取数据的服务，一个认证服务，一个服务日志等等。</p><p id="ac5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Angular中的服务是用<code class="fe nk nl nm nn b">@Injectable</code>装饰器来装饰的。以下是Angular中空白服务的框架:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7135" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以复制并传递骨架，重命名它并添加你需要的功能。或者，使用Angular CLI生成服务，如下所示:</p><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="3a30" class="nu mm it nn b gy nv nw l nx ny">ng generate service [put-the-service-name-here]</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="6da1" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">什么是DI，它是如何工作的？</h1><p id="6801" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">依赖注入(DI)首先是一种设计模式。Angular有自己的DI框架来提高应用程序的效率和模块化。DI是每个Angular开发人员都应该了解和学习的Angular核心概念之一。</p><p id="c870" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您一直在跟踪，您可能会记得在服务框架中看到过:</p><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="62e4" class="nu mm it nn b gy nv nw l nx ny">@<a class="ae ni" href="https://angular.io/api/core/Injectable" rel="noopener ugc nofollow" target="_blank">Injectable</a>({<br/>  <strong class="nn iu">providedIn</strong>: 'root'<br/>})</span></pre><p id="74c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nk nl nm nn b">@Injectable</code>装饰器是一个标记器。它将一个类标记为可以作为依赖项提供和注入。这意味着当注入类时，TypeScript <strong class="kw iu">编译器将生成必要的元数据</strong>来创建类的依赖项，而无需开发人员提供任何额外的代码。</p><p id="83ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还有元数据字段<code class="fe nk nl nm nn b"><strong class="kw iu">providedIn</strong>: ‘root’`</code>，它指向当前应用程序的根模块(<code class="fe nk nl nm nn b">app.module.ts</code>)。它向模块的注入器注册服务。我们也可以将<code class="fe nk nl nm nn b"><strong class="kw iu">providedIn</strong></code>类型改为:</p><ul class=""><li id="19c3" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><code class="fe nk nl nm nn b">root</code>:应用级注入器(最常用)。</li><li id="6e5a" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><code class="fe nk nl nm nn b">platform</code>:页面上所有应用程序共享的特殊单例平台注入器(通常用于大型应用程序之间的通信)。</li><li id="7c72" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><code class="fe nk nl nm nn b">any</code>:在每个延迟加载的模块中提供一个唯一的实例，而所有急切加载的模块共享一个实例。</li></ul><p id="6394" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组件只需要在构造函数中实例化服务。之后，它可以在组件中的任何地方使用实例化的服务实例。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="280a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，上面的代码与执行以下操作相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3c68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">构造函数参数<code class="fe nk nl nm nn b">articleService</code>的类型为<code class="fe nk nl nm nn b">ArticleService</code>。角度注入器将检查该服务是否被识别。因为我们用<code class="fe nk nl nm nn b">@Injectable</code> decorator标记了ArticleService，所以该服务是可用的并且可以识别的。因此，角度注入器会完成实例化。</p><p id="3fef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们看一个具体的例子。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="fb15" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">DI的一个具体例子</h1><p id="e226" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">下面是我的ArticleComponent，它需要一个获取文章数据的服务:</p><ul class=""><li id="a7c6" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">首先，这里是文章服务:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><ul class=""><li id="ec1a" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">其次，需要显示文章的组件需要在该组件中注入ArticleService，以便我们可以使用组件中的服务功能:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5dcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我还注入了NgxLogger服务(来自ngx-logger)来记录错误。</p><ul class=""><li id="1610" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">第三，我们需要确保服务是在使用它的模块中提供的。如果组件有自己的模块，则为app模块或组件模块。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="94fe" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">外卖:</h1><ul class=""><li id="a4b9" class="lq lr it kw b kx nd la ne ld nz lh oa ll ob lp lv lw lx ly bi translated">服务的存在是为了解除数据管理或特定功能与组件的链接。</li><li id="f978" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">angular中的服务和依赖注入旨在封装服务中的公共逻辑，并在我们需要多个组件中的逻辑时注入(一个完美的例子是LoggerService，它几乎在任何地方都需要记录和调试)</li><li id="1bc5" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">这种设计模式允许你更好的可测试性和代码可维护性。</li><li id="0b5b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">服务需要<code class="fe nk nl nm nn b">@Injectable</code>装饰器，这样它就可以被注入到app模块或组件模块中。此后，该组件及其子组件也可以使用它。</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="5855" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">亲爱的读者朋友们，感谢你们的支持和宝贵时间。我希望这对你有用和有帮助。</p><p id="5b3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">关注我上</strong> <a class="ae ni" href="https://medium.com/@famzil/" rel="noopener"> <strong class="kw iu">中</strong> </a> <strong class="kw iu">、</strong><a class="ae ni" href="https://www.linkedin.com/in/fatima-amzil-9031ba95/" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">Linkedin</strong></a><strong class="kw iu">、</strong><a class="ae ni" href="https://twitter.com/FatimaAMZIL9" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">Twitter</strong></a><strong class="kw iu">了解更多文章。</strong></p><p id="e67c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不久后见(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧)</p><p id="9bcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> FAM </strong></p></div></div>    
</body>
</html>