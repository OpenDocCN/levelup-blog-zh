<html>
<head>
<title>Implement an External Memory Merge Sort Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现外部存储器合并排序算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implement-an-external-memory-merge-sort-algorithm-373fada27c93?source=collection_archive---------1-----------------------#2022-12-08">https://levelup.gitconnected.com/implement-an-external-memory-merge-sort-algorithm-373fada27c93?source=collection_archive---------1-----------------------#2022-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="d83c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="d713" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这篇文章将检验我在阅读《编程珍珠<strong class="kn ir"><em class="lj"/></strong>这本书时遇到的一个有趣问题。这个问题简单来说是这样的:<code class="fe lk ll lm ln b">How to sort a large disk file? The disk file has so much data that it cannot all fit into the main memory.</code>这个<code class="fe lk ll lm ln b">algorithm</code>问题我考虑了一会儿；但是注意到所有经典的排序算法，像<code class="fe lk ll lm ln b"><a class="ae lo" href="https://en.wikipedia.org/wiki/Quicksort" rel="noopener ugc nofollow" target="_blank">Quick sort</a></code>和<code class="fe lk ll lm ln b"><a class="ae lo" href="https://en.wikipedia.org/wiki/Merge_sort" rel="noopener ugc nofollow" target="_blank">merge sort</a></code>，都不能轻松解决。然后我做了一些关于它的研究，我将在这篇文章中分享我所学到的。相信看完这篇文章，你也能解决这个问题。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="ff88" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">外部算法的背景</h1><p id="633d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">传统上，计算机科学家通过计算执行指令的数量来分析算法的运行时间，通常表示为输入大小n的函数，就像众所周知的<code class="fe lk ll lm ln b"><a class="ae lo" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">Big O notation</a></code>。这种算法复杂性分析基于<code class="fe lk ll lm ln b">Random access machine(RAM)</code>模型，该模型定义了以下假设:</p><ul class=""><li id="bdd2" class="mb mc iq kn b ko md ks me kw mf la mg le mh li mi mj mk ml bi translated">有无限可用内存的机器；</li><li id="bf6f" class="mb mc iq kn b ko mm ks mn kw mo la mp le mq li mi mj mk ml bi translated">在单位时间内可以访问任何期望的存储位置；</li><li id="d117" class="mb mc iq kn b ko mm ks mn kw mo la mp le mq li mi mj mk ml bi translated">每条指令花费相同的时间。</li></ul><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/6b05046cead8d7d483fbcb6ea835a7f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/0*lGu8fVhQEhmOg2Kk.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">随机存取机器模型</figcaption></figure><p id="d3a4" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">当算法需要使用的内存量小于运行该代码的计算机的内存量时，这种模型可以很好地工作。</p><p id="7420" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">但在现实世界中，一些应用程序需要处理的数据太大，无法一次放入计算机的主内存。而用来解决这类问题的算法叫做<code class="fe lk ll lm ln b">external memory algorithms</code>或者<code class="fe lk ll lm ln b">disk-based algorithms</code>；因为输入数据存储在<code class="fe lk ll lm ln b"><a class="ae lo" href="https://en.wikipedia.org/wiki/External_storage" rel="noopener ugc nofollow" target="_blank">external memory</a></code> <a class="ae lo" href="https://en.wikipedia.org/wiki/External_storage" rel="noopener ugc nofollow" target="_blank">存储设备</a>中。</p><p id="a43d" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">代替<code class="fe lk ll lm ln b">RAM</code>模型，基于<code class="fe lk ll lm ln b">external memory model</code>对<code class="fe lk ll lm ln b">external memory algorithm</code>进行分析。该模型由一个CPU处理器和一个连接到无限外部存储器的有限大小的内部存储器组成。一个I/O操作包括将一块连续的元素从外部内存移动到内部内存(这称为<code class="fe lk ll lm ln b"><a class="ae lo" href="https://en.wikipedia.org/wiki/Page_cache" rel="noopener ugc nofollow" target="_blank">page cache</a></code>，由内核管理。).</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/3cf4da99488ec570d39f1e5cd1b7960a.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/0*npAWuXA5WqO8sZC5.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">外部记忆模型</figcaption></figure><p id="1411" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">与主存储器相比，外部存储器的访问速度要慢<a class="ae lo" href="https://en.wikipedia.org/wiki/Memory_hierarchy" rel="noopener ugc nofollow" target="_blank">几个数量级</a>，尽管已经采用了<code class="fe lk ll lm ln b"><a class="ae lo" href="https://en.wikipedia.org/wiki/Solid-state_drive" rel="noopener ugc nofollow" target="_blank">SSD</a></code>等现代存储技术。因此，对于外部算法，性能的瓶颈是<code class="fe lk ll lm ln b">disk IO</code>速度而不是CPU周期。</p><p id="0a86" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">在本节中，我们检查了外部存储器算法的计算模型。接下来，让我们回顾一种典型的外部存储算法:外部排序。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="d18b" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">外部合并排序</h1><p id="f925" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">类似于传统的内部排序算法，外部排序有几种不同的解决方案。在本文中，我将重点介绍<code class="fe lk ll lm ln b">external mergesort</code>。</p><p id="7218" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">外部合并排序是内部合并排序的直接推广。该算法首先将M个输入项重复加载到内存中(由于内存缓冲区大小有限，一次只能存储M个输入项)，对它们进行排序，然后将它们写回磁盘。该步骤将输入文件分成一些(或者许多，如果输入文件非常大的话)排序的运行，每个运行有M个排序的项目。然后，该算法重复合并多个排序运行，直到只剩下一个包含所有输入数据的排序运行。</p><p id="74cd" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">让我们用下面的例子模型来分析这个算法。首先假设内存缓冲区有限，大小为一个<code class="fe lk ll lm ln b">page</code>。并且输入文件大小为8 <code class="fe lk ll lm ln b">pages</code>。外部mergesort可以分为两个阶段:<code class="fe lk ll lm ln b">sort phase</code>和<code class="fe lk ll lm ln b">merge phase</code>。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/37f37e0bc4f3bacab43855750add627c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z6VfxFYO8pzuxzBq.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">双向外部合并排序</figcaption></figure><p id="6431" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated"><strong class="kn ir"> <em class="lj">排序阶段</em> </strong>:</p><ul class=""><li id="a723" class="mb mc iq kn b ko md ks me kw mf la mg le mh li mi mj mk ml bi translated">将整个输入文件分成8组，每组大小为一页(内存缓冲容量)。</li><li id="4644" class="mb mc iq kn b ko mm ks mn kw mo la mp le mq li mi mj mk ml bi translated">将每个页面加载到内存中，对内存缓冲区中的项目进行排序(使用内部排序算法)，并将排序后的项目保存在临时子文件中。每个子文件被称为一个<code class="fe lk ll lm ln b">run</code>。</li></ul><p id="c851" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">在排序阶段结束时，将创建8个临时排序的单页运行。这一步可以标记为<strong class="kn ir"> <em class="lj">通过0 </em> </strong>。</p><p id="94e1" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated"><strong class="kn ir"> <em class="lj">合并阶段</em> </strong>:</p><p id="1201" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">第0遍中的8个排序运行将被合并到一个排序文件中，再有3遍。</p><p id="dc86" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">传递1:为合并执行4次运行。</p><ul class=""><li id="0e14" class="mb mc iq kn b ko md ks me kw mf la mg le mh li mi mj mk ml bi translated">运行1:合并前两个小的1页运行到一个大的2页运行。该合并步骤如下进行:</li><li id="5c84" class="mb mc iq kn b ko mm ks mn kw mo la mp le mq li mi mj mk ml bi translated">读取前两个排序的子文件(每个文件一个项目)。</li><li id="0ba0" class="mb mc iq kn b ko mm ks mn kw mo la mp le mq li mi mj mk ml bi translated">找到较小的项，将其输出到新的子文件中，相应的输入子文件将被推进。重复这个循环，直到输入子文件完成。<strong class="kn ir">该例程的逻辑与内部mergesort算法相同。</strong></li><li id="ee4b" class="mb mc iq kn b ko mm ks mn kw mo la mp le mq li mi mj mk ml bi translated">运行2:将接下来的两个1页运行合并成一个2页运行。</li><li id="7738" class="mb mc iq kn b ko mm ks mn kw mo la mp le mq li mi mj mk ml bi translated">运行3和4:遵循相同的过程。</li><li id="70b8" class="mb mc iq kn b ko mm ks mn kw mo la mp le mq li mi mj mk ml bi translated">在<strong class="kn ir"> <em class="lj">通道1 </em> </strong>结束时，将创建4个临时排序的2页运行。</li></ul><p id="8fcb" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">传递2:为合并执行2次运行。</p><ul class=""><li id="7073" class="mb mc iq kn b ko md ks me kw mf la mg le mh li mi mj mk ml bi translated">在<strong class="kn ir"> <em class="lj">通道2 </em> </strong>结束时，将创建2个临时排序的4页运行。</li></ul><p id="cbf4" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">传递3:为合并执行1次运行。</p><ul class=""><li id="4d3b" class="mb mc iq kn b ko md ks me kw mf la mg le mh li mi mj mk ml bi translated">在<strong class="kn ir"> <em class="lj">通道3 </em> </strong>结束时，将创建包含所有排序项目的最终8页运行。</li></ul><p id="692e" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">注意:乍一看，上面的过程似乎很复杂，但是逻辑几乎与内部合并排序相同。唯一的区别是内部合并是基于内存缓冲区的，而外部合并是基于磁盘文件的，需要从磁盘读取项目到内存。</p><p id="48e4" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">由于我们不断将两个小的子文件合并成一个两倍大小的大文件，所以上面的算法可以称为<code class="fe lk ll lm ln b">two-way</code>外部合并排序。我们可以把这个想法推广到<code class="fe lk ll lm ln b">multi-way</code>外部合并排序，将M个游程合并成一个。</p><p id="9c9f" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">接下来，我们来分析一下它的复杂性。假设输入文件有<code class="fe lk ll lm ln b">N</code>项，每页由<code class="fe lk ll lm ln b">B</code>项组成。并且<code class="fe lk ll lm ln b">M</code>表示在合并阶段中使用的路的数量，因此通过的数量应该是:<strong class="kn ir"> logM(N/B) + 1 </strong>，其中加1表示排序阶段中的第一次通过。并且每一遍，每一项都从磁盘文件中读取和写入一次。所以磁盘I/O总数是:<strong class="kn ir"> 2N*(logM(N/B) + 1) </strong></p><p id="1df8" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">在本节中，我们研究了外部内存算法的抽象计算模型，并分析了外部mergesort算法的细节。下一节，让我们实现代码并评估性能。</p><p id="7f0d" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">首先，你可以在这个Github <a class="ae lo" href="https://github.com/baoqger/external-merge-sort" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到这个实现的所有源代码。</p><div class="nm nn gp gr no np"><a href="https://github.com/baoqger/external-merge-sort" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">GitHub-baoqger/外部-合并-排序:外部-排序</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od mx np"/></div></div></a></div><p id="83c1" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">在这个回购中，我实现了<code class="fe lk ll lm ln b">two-way</code>和<code class="fe lk ll lm ln b">multi-way</code>两种解决方案，它们在不同的分支中被跟踪，请注意这一点。但是为了简单起见，在本文中我将集中讨论通用的<code class="fe lk ll lm ln b">multi-way</code> mergesort解决方案。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="7149" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">数据准备</h1><p id="2d00" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在深入研究代码之前，让我们先定义一下这里需要解决的问题。我将生成一个包含几百万个七位数随机数的输入文件，从1，000，000到9，999，999。随机数可以复制，每个数字存储在输入文件的一个新行中。输入文件是用下面的Bash脚本准备的，该脚本调用GNU <a class="ae lo" href="https://en.wikipedia.org/wiki/Shuf" rel="noopener ugc nofollow" target="_blank"> shuf </a>:</p><pre class="ms mt mu mv gt oe ln of bn og oh bi"><span id="dfef" class="oi jo iq ln b be oj ok l ol om">#!/usr/bin/bash <br/><br/># Author: Chris Bao<br/># Generate millions of seven digits random integers<br/># based on shuf utility<br/><br/>shuf -i 1000000-9999999 -n 7777777 &gt; ./input.txt</span></pre><p id="5637" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">生成的输入文件大小大致为<code class="fe lk ll lm ln b">60 MB</code>。对于现代计算机，它可以很容易地加载到内存中。但是因为我们正在运行外部存储器算法，所以让我们假设我们正在一台只有<code class="fe lk ll lm ln b">100000 Byte</code>存储器的旧计算机上运行该算法。基于这个假设的限制，我们需要对输入文件中的数字进行排序，并将结果保存在一个新文件中。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="c66a" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">履行</h1><p id="e611" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们在这个算法中定义一些全局常数:</p><pre class="ms mt mu mv gt oe ln of bn og oh bi"><span id="633a" class="oi jo iq ln b be oj ok l ol om">#ifndef CONSTANT_H<br/>#define CONSTANT_H<br/><br/>#define MEMORY_LIMIT 100000<br/>#define RECORD_SIZE 4<br/>#define MULTI_WAY_NUMBER 2<br/><br/>#endif</span></pre><p id="6a16" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated"><code class="fe lk ll lm ln b">MEMORY_LIMIT</code>表示<code class="fe lk ll lm ln b">100000 bytes</code>内存限制；在C中，我们可以使用类型<code class="fe lk ll lm ln b">unsigned int</code>来存储1，000，000到9，999，999之间的整数。所以<code class="fe lk ll lm ln b">RECORD_SIZE</code>意味着每条记录(或整数)将占用4个字节的内存。</p><p id="aa0e" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">默认情况下，算法将使用<code class="fe lk ll lm ln b">two-way</code>合并，但是用户也可以传递一个参数来运行<code class="fe lk ll lm ln b">multi-way</code>合并。</p><p id="71c2" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated"><strong class="kn ir">分拣阶段</strong></p><p id="9c9e" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">排序阶段在<code class="fe lk ll lm ln b">separationSort</code>函数中实现，如下所示:</p><pre class="ms mt mu mv gt oe ln of bn og oh bi"><span id="02a2" class="oi jo iq ln b be oj ok l ol om">/*<br/> * Goes through a given file and separates that file into sorted 1MB files using (internal) mergeSort algorithm<br/> * */<br/>void separationSort(FILE *input) {<br/>    FILE *fp;<br/>    unsigned int *buffer = malloc(sizeof(unsigned int)*(MEMORY_LIMIT/RECORD_SIZE));<br/>    char *line = NULL;<br/>    size_t len = 0;<br/>    ssize_t nread;<br/>    int count = 0;<br/>    printf("Sort phase start.\n");<br/>    while((nread = getline(&amp;line, &amp;len, input)) != -1) {<br/>        if (count &lt; MEMORY_LIMIT/RECORD_SIZE) {<br/>            buffer[count++] = (unsigned int)strtoul(line, NULL, 10); <br/>        } else {<br/>            mergeSort(buffer, count); // sort records<br/>            <br/>            // output sorted to file<br/>            if (fileNum == 1) { // create the dir<br/>                int status;<br/>                // create tmp directory<br/>                if ((status = mkdir("./tmp", S_IRWXU | S_IRWXU | S_IROTH | S_IXOTH)) == -1) {<br/>                    fprintf(stderr, "Failed to create tmp directory.\n");<br/>                    exit(EXIT_FAILURE);<br/>                }<br/>                // create pass0 directory for sort phase<br/>                if ((status = mkdir("./tmp/pass0", S_IRWXU | S_IRWXU | S_IROTH | S_IXOTH)) == -1) {<br/>                    fprintf(stderr, "Failed to create pass0 directory.\n");<br/>                    exit(EXIT_FAILURE);<br/>                }<br/> <br/>            }<br/><br/>            char fileName[20];<br/>            sprintf(fileName, "./tmp/pass0/%d.txt", fileNum);<br/>            if ((fp = fopen(fileName, "w+")) == NULL) {<br/>                fprintf(stderr, "Failed to create file: %s.\n", fileName);<br/>                exit(EXIT_FAILURE);<br/>            }<br/><br/>            outputToFile(buffer, count, fp);<br/><br/>            // Reset memory buffer(zero-out the entire array)<br/>            memset(buffer, 0, sizeof(unsigned int)*(MEMORY_LIMIT/RECORD_SIZE));<br/>            count = 0;<br/>            fileNum++;<br/>            buffer[count++] = (unsigned int)strtoul(line, NULL, 10); // add the current record into new buffer's as first element<br/>            <br/>        }<br/>    }<br/><br/>    // sort the last and final file<br/>    mergeSort(buffer, count);<br/>    char fileName[20];<br/>    sprintf(fileName, "./tmp/pass0/%d.txt", fileNum);<br/>    if ((fp = fopen(fileName, "w+")) == NULL) {<br/>        fprintf(stderr, "Failed to create file: %s.\n", fileName);<br/>        exit(EXIT_FAILURE);<br/>    }<br/>    outputToFile(buffer, count, fp);<br/>    <br/>    free(buffer);<br/>    free(line);<br/>    printf("Sort phase done. %d tmp sorted files are produced.\n", fileNum);<br/>}</span></pre><p id="44b1" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">逻辑并不难。该函数将输入文件描述符作为参数，并循环读取每一行(通过<code class="fe lk ll lm ln b">getline</code>方法),直到到达文件末尾。在达到内存限制之前，这些数字将被读入内存缓冲区。当内存缓冲区已满(100000字节)时，使用功能<code class="fe lk ll lm ln b">mergeSort</code>对数字进行排序。</p><p id="2799" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">函数<code class="fe lk ll lm ln b">mergeSort</code>在文件<code class="fe lk ll lm ln b"><a class="ae lo" href="https://github.com/baoqger/external-merge-sort/blob/multi-way-with-pass/internal_sort.c" rel="noopener ugc nofollow" target="_blank">internal_sort.c</a></code>中定义，它实现了经典的内部<code class="fe lk ll lm ln b"><a class="ae lo" href="https://en.wikipedia.org/wiki/Merge_sort" rel="noopener ugc nofollow" target="_blank">merge sorting</a></code>算法。我不会在本文中涉及它，因为您可以在网上找到许多关于它的文档。如果你不了解，请花点时间了解一下。当然，你也可以用其他排序算法来代替它，比如<code class="fe lk ll lm ln b"><a class="ae lo" href="https://en.wikipedia.org/wiki/Quicksort" rel="noopener ugc nofollow" target="_blank">quick sort</a></code>。我把这个留给读者。</p><p id="4026" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">排序后，编号保存在<code class="fe lk ll lm ln b">./tmp/pass0</code>目录下的临时文件中。文件名就是运行编号。</p><pre class="ms mt mu mv gt oe ln of bn og oh bi"><span id="b786" class="oi jo iq ln b be oj ok l ol om">/*<br/> * Output sorted record to given file(of)<br/> * */<br/><br/>void outputToFile(unsigned int *buffer, int size, FILE *of) {<br/>    int i;<br/>    for (i = 0; i &lt; size; i++) {<br/>        fprintf(of, "%u\n", buffer[i]);<br/>    }<br/>    fclose(of);<br/>}</span></pre><p id="7b0c" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">我们可以验证排序阶段的结果，如下所示:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi on"><img src="../Images/94d8d29c672b41315fb723e4eb022630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6QQHCO1wnHGy8j2V.png"/></div></div></figure><p id="df2a" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">您可以看到每个文件包含多达<code class="fe lk ll lm ln b">25000</code>(等于<code class="fe lk ll lm ln b">MEMORY_LIMIT/RECORD_SIZE</code>)个数字，并且在pass0中创建了312个文件。</p><p id="c16b" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">请注意，我不会研究如何创建一个新目录以及如何打开一个新文件进行读写的细节。你可以自己学习这样的Linux文件I/O概念。</p><p id="1154" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated"><strong class="kn ir">合并阶段</strong></p><p id="aae0" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated"><code class="fe lk ll lm ln b">exMerge</code>功能控制从<code class="fe lk ll lm ln b">pass1</code>开始的合并阶段的走刀。</p><pre class="ms mt mu mv gt oe ln of bn og oh bi"><span id="9fe8" class="oi jo iq ln b be oj ok l ol om">void exMerge() {<br/>    /* some code omitted ... */<br/>    int pass = 1;<br/>    while (fileNum &gt; 1) {<br/>        exMergeSort(pass, fileNum);<br/>        int remainer = fileNum % ways;<br/>        fileNum = fileNum / ways;<br/>        if (remainer &gt; 0) {<br/>            fileNum++;<br/>        } <br/>        pass++;<br/>    }<br/>    /* some code omitted ... */<br/>}</span></pre><p id="0b66" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">变量<code class="fe lk ll lm ln b">fileNum</code>存储每次通过的<code class="fe lk ll lm ln b">run</code>号。变量<code class="fe lk ll lm ln b">ways</code>表示多路的数量。因此，下一遍的<code class="fe lk ll lm ln b">run</code>号应计算为<code class="fe lk ll lm ln b">fileNum / ways</code>。</p><p id="0c16" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">详细的合并逻辑在函数<code class="fe lk ll lm ln b">exMergeSort</code>中，它有两个参数。<code class="fe lk ll lm ln b">pass</code>表示当前的走刀次数(从1开始)，而<code class="fe lk ll lm ln b">nums</code>表示上一次走刀需要合并多少次运行(或子文件)。</p><pre class="ms mt mu mv gt oe ln of bn og oh bi"><span id="3576" class="oi jo iq ln b be oj ok l ol om">void exMergeSort(int pass, int nums) {<br/>    /* some code omitted ... */<br/>    int inputFileNum = 0; <br/>    int run = 1;<br/>    for (; inputFileNum &lt; nums;) { <br/>        <br/>        // create the dir for current pass<br/>        if (inputFileNum == 0) {<br/>            int status;<br/>            char dirName[20];<br/>            sprintf(dirName, "./tmp/pass%d", pass);<br/>            if ((status = mkdir(dirName, S_IRWXU | S_IRWXU | S_IROTH | S_IXOTH)) == -1) {<br/>                fprintf(stderr, "Failed to create tmp directory %s.\n", dirName);<br/>                exit(EXIT_FAILURE);<br/>            }<br/>        }<br/>        // open new file to merge in each run<br/>        FILE *fm; <br/>        char mergedFileName[20];<br/>        sprintf(mergedFileName, "./tmp/pass%d/%d.txt", pass, run);<br/>        if ((fm = fopen(mergedFileName, "w+")) == NULL) {<br/>            fprintf(stderr, "%s\n", strerror(errno));<br/>            fprintf(stderr, "merged file %s: can't create or open.\n", mergedFileName);<br/>        }<br/>        run++;<br/>        /* some code omitted ... */<br/>    }<br/><br/>}</span></pre><p id="4a18" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">上面的代码为每次传递创建一个临时目录，并为每次运行创建一个临时文件。</p><p id="9b2e" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">接下来，我们为每次运行创建一个输入文件数组。输入文件在最后一遍的临时目录中。每次运行在<code class="fe lk ll lm ln b">for</code>循环中合并多个文件。这里唯一的技巧逻辑是，最后一次运行中剩余的文件可能少于声明的路的数量，我们需要正确地处理这个问题(下面代码块的第5行)。</p><pre class="ms mt mu mv gt oe ln of bn og oh bi"><span id="67dc" class="oi jo iq ln b be oj ok l ol om">// Rewind the sorted files in previous pass, each run merge way_numbers numbers of files<br/>// Merge the sorted files with multi ways in N runs. <br/>// In the first N - 1 runs, each run merge ways numbers of files<br/>// In the last run, merge the remaining files. <br/>int way_numbers = run * ways &lt;= nums ? ways : nums - inputFileNum;<br/>FILE *fiarr[way_numbers];<br/>for (int i = 0; i &lt; way_numbers; i++) {<br/>   char inputFileName[20];<br/>   inputFileNum++; // start from 0 to nums<br/>   sprintf(inputFileName, "./tmp/pass%d/%d.txt", pass - 1, inputFileNum);<br/>   if ((fiarr[i] = fopen(inputFileName, "r")) == NULL) {<br/>        fprintf(stderr, "%s\n", strerror(errno));<br/>        fprintf(stderr, "input file %s: can't create or open.\n", inputFileName);<br/>   }<br/>   rewind(fiarr[i]);<br/>}</span></pre><p id="e584" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">接下来，我们需要从每个输入文件中读取一个数字，直到只有一个文件没有用完。找到最小的一个并保存在临时输出运行文件中。对于剩下的最后一个文件，记得将剩余的数字也放入输出文件中。</p><pre class="ms mt mu mv gt oe ln of bn og oh bi"><span id="00e6" class="oi jo iq ln b be oj ok l ol om">// get and compare records until files runs out of records<br/>char *records[way_numbers]; <br/>for (int i = 0; i &lt; way_numbers; i++) {<br/>    records[i] = getRecord(fiarr[i]);<br/>}<br/>// loop until only one file is not run-out<br/>while(validateRecords(records, way_numbers )) {<br/>    int index = getMinRecordIndex(records, way_numbers);<br/>    fprintf(fm, "%s", records[index]); // print record to new merged file<br/>    free(records[index]); // free the memory allocated by getline in getRecord function<br/>    records[index] = getRecord(fiarr[index]); // Get new record from the file<br/>}<br/>       <br/>// put the rest record in the last remaining file into new file <br/>int lastIndex = getLastRemainRecordIndex(records, way_numbers);<br/>while(records[lastIndex]) {<br/>    fprintf(fm, "%s", records[lastIndex]);<br/>    free(records[lastIndex]);<br/>    records[lastIndex] = getRecord(fiarr[lastIndex]);<br/>}</span></pre><p id="53bc" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">上面的代码块使用了<code class="fe lk ll lm ln b">getRecord</code>、<code class="fe lk ll lm ln b">validateRecords</code>、<code class="fe lk ll lm ln b">getMinRecordIndex</code>、<code class="fe lk ll lm ln b">getLastRemainRecordIndex</code>等几种方法，这些函数很容易理解。</p><pre class="ms mt mu mv gt oe ln of bn og oh bi"><span id="f10b" class="oi jo iq ln b be oj ok l ol om">/*<br/> * Returns a copy of the record<br/> *<br/> * */<br/>char* getRecord(FILE *ifp) {<br/>    char *line = NULL;<br/>    size_t len = 0;<br/>    ssize_t nread;<br/>    while ((nread = getline(&amp;line, &amp;len, ifp)) != -1) {<br/>        return line;       <br/>    }<br/>    return NULL;<br/>}<br/>/*<br/> * Validate whether at least two records are non-zero<br/> * */<br/>bool validateRecords(char **records, int size) {<br/>    int count = 0;<br/>    for (int i = 0; i &lt; size; i++) {<br/>        if (records[i] != NULL) {<br/>            count++;<br/>        }<br/>    }<br/>    return count &gt;= 2;<br/>}<br/><br/>/*<br/> * Get the min valid record's index<br/> * */<br/>int getMinRecordIndex(char **records, int size) {<br/>    int index = 0;<br/>    unsigned int min = (int)INFINITY;<br/>    for (int i = 0; i &lt; size; i++) {<br/>        if (records[i] == NULL) { // pass invalid run-out record files<br/>            continue;<br/>        } <br/>        if (strtoul(records[i], NULL, 10) &lt; min) {<br/>            min = strtoul(records[i], NULL, 10);<br/>            index = i;<br/>        }<br/>    }<br/>    return index;<br/>}<br/>/*<br/> * Get the last remainer of the records<br/> * */<br/>int getLastRemainRecordIndex(char **records, int size) {<br/>    for (int i = 0; i &lt; size; i++) {<br/>        if (records[i] != NULL) {<br/>            return i;<br/>        }<br/>    }<br/>}</span></pre><p id="98eb" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">详细可以参考这个<a class="ae lo" href="https://github.com/baoqger/external-merge-sort/blob/multi-way-with-pass/main.c" rel="noopener ugc nofollow" target="_blank"> github repo </a>的源代码。接下来，让我们通过调整合并方式的数量来评估该算法的性能。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="994e" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">性能赋值</h1><p id="16a1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将使用Linux <code class="fe lk ll lm ln b">time</code>实用程序来测量这个算法的运行时间。</p><p id="1217" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">双向合并排序的结果是:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oo"><img src="../Images/5e6f2260b16f6b2e0bea1153dd76c77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uQFtajLNLnnl2LbP.png"/></div></div></figure><p id="69f5" class="pw-post-body-paragraph kl km iq kn b ko md kq kr ks me ku kv kw nd ky kz la ne lc ld le nf lg lh li ij bi translated">而六路合并排序可以用较短的运行时间完成。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi op"><img src="../Images/9767941c7f845eb773d01716654281f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*otIP1qwDdsGU783a.png"/></div></div></figure><h1 id="b8a2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="aa8e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我们通过从头实现一个外部合并排序算法来研究它是如何工作的。</p></div></div>    
</body>
</html>