<html>
<head>
<title>How to Find the Nth Prime Number</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何求第n个质数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-find-the-nth-prime-number-c16dac27963?source=collection_archive---------1-----------------------#2020-05-24">https://levelup.gitconnected.com/how-to-find-the-nth-prime-number-c16dac27963?source=collection_archive---------1-----------------------#2020-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/9e0f848005c4dee2f780ef125de63a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*K4lmLJ_GpSUAy8Wo"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">厄拉多塞在亚历山大教学。Bernardo Strozzi /公共领域</figcaption></figure><p id="f7e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我第一次想到它时，我觉得它似乎更容易。但是，快速找到一个随机的质数并不简单。例如，第五个质数是11，第二十个是71。但是，第50个、第600个或第20000个质数呢？我想给你展示一个找到第N个质数的有效方法。我们将从一个被称为厄拉多塞<a class="ae kx" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="noopener ugc nofollow" target="_blank">筛的旧算法中得到帮助。</a></p><p id="339f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">质数是大于1的整数，能被1和它本身整除。所有非素数的整数都叫做合数。<a class="ae kx" href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic" rel="noopener ugc nofollow" target="_blank">算术基本定理</a>说，每个大于1的整数要么是素数，要么可以表示为素数的乘积。</p><p id="43b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确定一个数是否是质数的一个简单方法是通过<em class="kw">试除法:</em>将数<em class="kw"> n </em>除以所有小于<em class="kw"> n的整数，</em>如果找不到除1以外的整除因子，那么<em class="kw"> n </em>就是质数。您可以看到随着<em class="kw"> n </em>的值增加，这是如何变得耗时的。50275是质数吗？</p><p id="0f1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有更好的方法来产生质数。这些方法产生一系列给定极限的素数。对<em class="kw">试分工</em>的一个改进是以<a class="ae kx" href="https://en.wikipedia.org/wiki/Wheel_factorization" rel="noopener ugc nofollow" target="_blank"><em class="kw"/></a><em class="kw"/>为例进行车轮因式分解。还有一套叫做<a class="ae kx" href="https://en.wikipedia.org/wiki/Sieve_theory" rel="noopener ugc nofollow" target="_blank">筛</a>的技术，包括阿特金筛和孙达拉姆筛。但是，其中最著名的是厄拉多塞的筛子。可能是因为它已经存在了很长时间——一位叫做<a class="ae kx" href="https://en.wikipedia.org/wiki/Eratosthenes" rel="noopener ugc nofollow" target="_blank">昔兰尼的厄拉多塞</a>的希腊数学家在公元前200年左右创造了这个算法。</p><h1 id="b068" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是厄拉多塞的筛子，它是如何工作的？</h1><p id="8a05" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">厄拉多塞筛是一种有效的算法来产生素数直到一个给定的限制。为了了解它的工作原理，我们来看一个例子。我们想找出所有小于13的质数。</p><p id="e3fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最初，我们有一个包含从2到13的所有整数的列表——根据定义，1不是质数，所以我们丢弃它。然后从2开始，我们开始划掉(筛选)所有小于13的2的倍数。一个质数的任何倍数都不可能是质数——它会有两个以上的除数，使它失去质数的资格。我们从列表中删除了所有这些。然后我们检查列表，找到下一个可用的数字，也就是3——这是下一个质数。我们重复这个过程，消除所有3的倍数。这一直持续到列表中不再有可用的号码。最终，我们将消除所有的合数，只剩下质数。</p><p id="756d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来说明这个过程，我们从2到13的整数列表开始:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mb"><img src="../Images/9da4117a987ee97af750799d34d040bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owusG5GwF2tDlpmJwLwrkA.png"/></div></div></figure><p id="1461" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">步骤1) </strong>取第一个素数<em class="kw"> p </em> = 2，划掉列表中它的所有倍数，2×2 = 4，2×3，= 6，2×4 = 8，等等:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mb"><img src="../Images/4612373ec550339beea462f968e7c997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIIoNtuYz7hqv56TX5VGbg.png"/></div></div></figure><p id="8410" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">步骤2) </strong>找出下一个可用的数字，划掉它的所有倍数。下一个是<em class="kw"> p </em> = 3，所以我们划掉它的倍数3×2 = 6，3×3 = 9，3×4 = 12(注意6和12已经划掉了):</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mb"><img src="../Images/11e8baeb0a3ba6ef1c513d4c1122c41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dSW5OENJTui4vyQLHkh6OA.png"/></div></div></figure><p id="6306" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">步骤3) </strong>用下一个可用的数字继续这个过程，<em class="kw"> p </em> = 5。唯一小于13的5的倍数是5×2 = 10，这在前面的步骤中被划掉了。所以，我们继续。</p><p id="9339" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">列表中的下一个数字是7，但是7的第一个倍数(7×2 = 14)大于我们的限制13。任何大于7的数都会产生大于13的倍数，所以我们完成了。列表中剩余的数字都是13:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mb"><img src="../Images/2d8491a657cc1df6240e246b328703fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7Efq2-hEZg1dwByUXvCDA.png"/></div></div></figure><h1 id="3d13" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">优化流程</h1><p id="fcc8" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在上一个练习中，我们重复了一些工作。例如，我们不止一次划掉了几个因素。我们可以通过认识到对于每个质数<em class="kw"> p </em>，我们只需要检查大于或等于<em class="kw"> p </em>的<em class="kw"> p </em>的因子来优化算法。这是因为小于<em class="kw"> p </em>的<em class="kw"> p </em>的所有因子都被前面的更小的素数划掉了。这将让我们一找到素数<em class="kw"> p </em>就终止算法，其中<em class="kw"> p </em>大于我们列表的大小。</p><p id="ae61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了说明这一点，让我们按照与前面相同的例子。但是，这次我们将列表增加到23个。在步骤1之后，我们有:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mb"><img src="../Images/70b0cfb84f11700564e7774f9e865321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHi3xtSzMT2QqSt4j3VABg.png"/></div></div></figure><p id="7871" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意2的所有因子都被划掉了。使用我们的启发式方法，我们应该只检查大于或等于3 = 9的因子3。所以，我们划掉9，12，15，18和21:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mb"><img src="../Images/8058d90fee693d250a2feb1587364f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2c3TyI843egPGcnq_CDfQ.png"/></div></div></figure><p id="0fc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">列表中的下一个素数是5，但是由于5 = 25大于23，我们结束这个过程:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mb"><img src="../Images/90899f84ef46ed589f3a66ee324e4aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHmeb3N61EpPHi5tUUeIuA.png"/></div></div></figure><p id="e3b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">剩下的列表包含了23以内的所有素数。</p><p id="644f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们仍然不止一次划掉了一些因素。然而，我们在<em class="kw"> p </em> = 5时停止了这个过程。因此，即使我们将列表增加了10个——从13个增加到23个——我们还是做了和上一个例子一样多的工作。这是一个很小的改进，但是随着我们增加列表的大小，它变得很重要。</p><h1 id="f019" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用厄拉多塞筛求第n个质数</h1><p id="2fcd" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">回到我们的问题，我们现在利用厄拉多塞的筛子来寻找第N个<em class="kw">素数。正如我上面所描述的，算法找到了所有的素数，直到一个给定的极限。然而，在这种情况下，我们没有预定义的限制。这是因为我们不知道我们需要多大的列表来包含我们的第N个素数<em class="kw">。<a class="ae kx" href="https://en.wikipedia.org/wiki/Prime_number_theorem" rel="noopener ugc nofollow" target="_blank">素数定理</a>说有大约<em class="kw"> n / log(n) </em>个素数小于<em class="kw"> n </em>。但是，<a class="ae kx" href="https://primes.utm.edu/notes/gaps.html" rel="noopener ugc nofollow" target="_blank">一个素数和下一个素数之间的差距</a>变得任意大。</em></em></p><p id="e7e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这个限制，我们将遵循一个迭代过程。首先，我们为列表选择一个初始大小。我们知道它必须至少大于我们的目标质数<em class="kw"> n </em>。例如，我们选择大小<em class="kw"> s = 2n </em>。然后我们生成小于<em class="kw"> s </em>的所有素数(使用厄拉多塞的筛子)。最后，我们计算列表中有多少个素数。如果素数的数量小于<em class="kw"> n </em>，我们进行下一次迭代，将列表的大小增加n。当我们找到<em class="kw"> n </em>或更多素数<em class="kw">时，迭代停止。</em>第<em class="kw"> N </em>个质数将是移除所有组合后列表中第<em class="kw"> N </em>个位置的数字。</p><h1 id="69a8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用Python实现算法</h1><p id="9ca6" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">下面的python代码实现了这种策略来寻找第<em class="kw"> N </em>个素数。它包括厄拉多塞筛的优化版本。为了方便起见，我使用一个字节数组来表示我们的整数列表。每个元素的索引对应于列表中的整数值。字节数组中的所有元素都被初始化为1。</p><p id="89f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过在相应的索引处将元素从1切换到0来“划掉”因子。例如，如果我们想要删除因子4，我们切换索引4处的元素。划掉所有因素后，由于我们没有从列表中删除它们，我们需要计数所有的1，直到找到第<em class="kw"> N </em>个1。我们返回这个元素的索引，它是我们的第N个质数。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mk"><img src="../Images/accb884da9af45ebc7ac04d0750b920a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MaMIgSHhqO2y_8VkyA3rEw.png"/></div></div></figure><h1 id="a71c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">计算的复杂性</h1><p id="9436" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们上面的代码反复执行<code class="fe ml mm mn mo b">get_primes()</code>函数(厄拉多塞筛),直到我们找到<em class="kw"> n </em>(或更多)个质数。在每次迭代中，我们增加字节数组的大小。迭代的总次数由变量<code class="fe ml mm mn mo b">size_factor</code>决定，该变量随着<em class="kw"> n </em>的值而增长。最后，我们遍历<em class="kw">字节数组</em>计数1，直到我们找到第<em class="kw"> N </em>个1。让我们分别分析这三个函数的运行时。</p><p id="aaa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再看函数<code class="fe ml mm mn mo b">get_nth_prime()</code>，迭代次数由变量<code class="fe ml mm mn mo b">size_factor - 1</code>决定(姑且称这个值为<em class="kw"> s </em>)。那么工作量——使用渐近符号——是<em class="kw"> O(s) </em>。</p><p id="c06f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，<code class="fe ml mm mn mo b">count_primes()</code>函数遍历<em class="kw">字节数组</em>计数1，它以线性时间运行，由<em class="kw"> n*s决定</em>运行时间为<em class="kw"> O(n*s) </em>，其中<em class="kw">n = n，</em>我们的目标素数。</p><p id="3f7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ml mm mn mo b">get_primes()</code>函数实现厄拉多塞的筛选。这个算法的运行时间是<em class="kw"> O(N log log N)，</em>其中<em class="kw"> N </em>是链表的大小。为了得出这个结果，考虑一下在划掉每个素数的因子后，列表的大小会发生什么变化。一个好的近似值如下。我们从尺寸<em class="kw"> N </em>开始。划掉第一个素数2的所有因子后，大小就变成了<em class="kw"> N/2 </em>。划掉3的因子后，大小将为<em class="kw"> N/3 </em>。这一直持续到尺寸减小到<em class="kw"> N/N = 1 </em>。我们可以这样表达:<em class="kw"> N*(1 + 1/2 + 1/3 + 1/5 +...+ 1/N) </em>。注意括号内的表达式是一个<a class="ae kx" href="https://mathworld.wolfram.com/HarmonicSeriesofPrimes.html" rel="noopener ugc nofollow" target="_blank">调和质数级数</a> <em class="kw">，</em>表示为<em class="kw"> : </em></p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mb"><img src="../Images/58ea0c7cff9e84ee640d44e40c9ed8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gousrvNxtW0XjEvj3PEUCw.png"/></div></div></figure><p id="2505" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<em class="kw"> p </em>是质数<em class="kw"> N </em>是我们列表的大小。它有一个渐近下界<em class="kw"> log log N </em>。因此，运行时间——包括圆括号外的因子<em class="kw">N</em>——为<em class="kw"> O(N log log N) </em>。</p><p id="059f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">综合三个函数的运行时间，记住我们的<em class="kw"> bytearray </em>的大小是<em class="kw"> n*s </em>，我们得到总运行时间，<em class="kw">O(s)* O(n * s log log(n * s))+O(n * s)</em>。这变成了:</p><p id="cdc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw"> O(s *n log log(n*s)) </em></p><p id="4b51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在测试程序时，我注意到<em class="kw"> s </em>与<em class="kw"> n. </em>相比增长缓慢，<em class="kw"> s </em>的值从12(用<em class="kw"> n = 20，000) </em>增加到16(用<em class="kw"> n = 1，000，000)。</em></p><p id="f430" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，内存开销来自于<em class="kw">字节数组</em>的大小，所以空间复杂度为:</p><p id="c2d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw"> O(n*s) </em></p><h1 id="84ee" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">这到底有什么用？</h1><p id="bd55" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">现在你可能会想，这些怎么会有用呢？让我给你举几个例子。质数在散列法中很重要——这是计算机科学中的一个基本概念。从数据结构和算法到加密，哈希在许多领域都很有用。</p><p id="ca05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个例子是密码学——这是一项每天都在使用的安全数据通信的关键技术。网上银行和购物交易是安全数据通信的例子。</p><p id="bdd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像我一开始觉得找一个随机的质数是非常容易的，乍一看我们可能看不出来，但是仔细看，数学无处不在。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="8293" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于2020年5月24日https://stemhash.com</em><a class="ae kx" href="https://stemhash.com/how-to-find-the-nth-prime-number/" rel="noopener ugc nofollow" target="_blank"><em class="kw"/></a><em class="kw">。</em></p></div></div>    
</body>
</html>