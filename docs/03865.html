<html>
<head>
<title>JavaScript Patterns —Static Members and Chaining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript模式——静态成员和链接</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-patterns-static-members-and-chaining-f56a4f3d040b?source=collection_archive---------9-----------------------#2020-05-30">https://levelup.gitconnected.com/javascript-patterns-static-members-and-chaining-f56a4f3d040b?source=collection_archive---------9-----------------------#2020-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6e963c71076be4222270ece3ab9268cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gOySEYN7tbj94Sq8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@judsonlmoore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Judson Moore </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="878d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript让我们可以做很多事情。它的语法有时过于宽容。</p><p id="9766" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何创建和使用类和构造函数，包括静态成员和链接。</p><h1 id="0808" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">静态成员</h1><p id="4e98" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以给类和构造函数添加静态成员。</p><p id="b69f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有什么特别的方法可以做到这一点。我们只是把它们作为函数的属性加入。</p><p id="7458" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c6fe" class="mq lf it mm b gy mr ms l mt mu">class Foo {}<br/>Foo.bar = 1;</span></pre><p id="03da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将<code class="fe mv mw mx mm b">bar</code>属性作为<code class="fe mv mw mx mm b">Foo</code>的静态属性。</p><p id="392d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于方法，我们可以使用static关键字。我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b636" class="mq lf it mm b gy mr ms l mt mu">class Foo {<br/>  static hello() {<br/>    //...<br/>  }<br/>}</span></pre><p id="6908" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e303" class="mq lf it mm b gy mr ms l mt mu">class Foo {</span><span id="ba59" class="mq lf it mm b gy my ms l mt mu">}<br/>Foo.hello = function() {<br/>  //...<br/>}</span></pre><h1 id="e493" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">公共静态成员</h1><p id="df30" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">静态成员总是公共的，因为它们只是函数的属性。</p><p id="dc18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们调用上面定义的<code class="fe mv mw mx mm b">hello</code>方法，我们可以写出:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="76be" class="mq lf it mm b gy mr ms l mt mu">Foo.hello()</span></pre><p id="e246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不必实例化<code class="fe mv mw mx mm b">Foo</code>。</p><p id="fc1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果我们如下定义一个实例方法:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b737" class="mq lf it mm b gy mr ms l mt mu">class Foo {<br/>  bar() {<br/>    //...<br/>  }<br/>}<br/>Foo.hello = function() {<br/>  //...<br/>}</span></pre><p id="67dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并称之为:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8ce2" class="mq lf it mm b gy mr ms l mt mu">Foo.bar()</span></pre><p id="591d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到“未捕获类型错误:<code class="fe mv mw mx mm b">Foo.bar</code>不是函数”错误。</p><p id="5604" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为在我们实例化<code class="fe mv mw mx mm b">Foo</code>之前<code class="fe mv mw mx mm b">Foo.bar</code>没有被定义。</p><p id="c3d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当方法实际上是实例方法时，我们应该小心被静态调用的方法。</p><h1 id="a107" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">私有静态成员</h1><p id="843d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">私有静态成员是由同一类或构造函数创建的所有对象共享的成员。</p><p id="94a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也不能在构造函数之外访问。</p><p id="a550" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过创建IIFE来定义私有成员，IIFE将返回一个类或构造函数，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9c27" class="mq lf it mm b gy mr ms l mt mu">const Foo = (() =&gt; {<br/>  let counter = 0;</span><span id="73f5" class="mq lf it mm b gy my ms l mt mu">  return class {<br/>    constructor() {<br/>      console.log(counter += 1);<br/>    }<br/>  };<br/>})();</span></pre><p id="2721" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有私有成员<code class="fe mv mw mx mm b">counter</code>。</p><p id="a8f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在回归生活的课上提到了它。</p><p id="9849" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们调用<code class="fe mv mw mx mm b">Foo</code>类两次:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0666" class="mq lf it mm b gy mr ms l mt mu">new Foo();<br/>new Foo();</span></pre><p id="4af8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="abb7" class="mq lf it mm b gy mr ms l mt mu">1<br/>2</span></pre><p id="62ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记录在控制台输出中。</p><p id="d630" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在每个类调用中增加相同的<code class="fe mv mw mx mm b">counter</code>变量，所以我们看到每次调用类时<code class="fe mv mw mx mm b">counter</code>的值都会增加。</p><p id="2ed4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以在返回的类中添加新方法。</p><p id="9911" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以添加一个<code class="fe mv mw mx mm b">getLastId</code>方法，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ee9f" class="mq lf it mm b gy mr ms l mt mu">const Foo = (() =&gt; {<br/>  let counter = 0;</span><span id="88f9" class="mq lf it mm b gy my ms l mt mu">  return class {<br/>    constructor() {<br/>      console.log(counter += 1);<br/>    }</span><span id="a3e1" class="mq lf it mm b gy my ms l mt mu">    getLastId() {<br/>      return counter;<br/>    }<br/>  };<br/>})();</span></pre><p id="f84b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以获得<code class="fe mv mw mx mm b">counter</code>的值，并将其用作ID。</p><h1 id="69ab" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象常数</h1><p id="59e3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">const</code>关键字来创建常量。</p><p id="2d41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，它们只对变量有效。</p><p id="7bb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想创建一个常量作为一个对象的属性，我们必须创建一个私有成员，然后通过返回它们来访问其中定义的常量。</p><p id="9a3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fb69" class="mq lf it mm b gy mr ms l mt mu">const Foo = (() =&gt; {<br/>  const BAR = 1;<br/>  return {<br/>    get BAR() {<br/>      return BAR;<br/>    }<br/>  }<br/>})();</span></pre><p id="0191" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们将私有的<code class="fe mv mw mx mm b">BAR</code>常量设置为1。</p><p id="a7aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mv mw mx mm b">BAR</code> getter返回一个对象，它返回私有常量<code class="fe mv mw mx mm b">BAR</code>的值。</p><p id="fb49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，即使我们尝试将其设置如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bf7b" class="mq lf it mm b gy mr ms l mt mu">Foo.BAR = 2;</span></pre><p id="e356" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们仍然得到<code class="fe mv mw mx mm b">Foo.BAR</code>是1，因为我们记录了它的值。</p><p id="d5a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为该属性只是一个getter。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/198781ef782a68eb3f3cfbcdb19e4565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HxaqpGnr2PNM1Syw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">paweczerwi324ski在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="6f75" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">链接模式</h1><p id="2af6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，我们经常看到如下模式:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6274" class="mq lf it mm b gy mr ms l mt mu">obj<br/>  .method1("hello")<br/>  .method2("world")<br/>  .method3();</span></pre><p id="7731" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这被称为链接模式。</p><p id="4598" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要创建可链接的方法，我们只需在每个方法中返回<code class="fe mv mw mx mm b">this</code>。</p><p id="5cb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="25f0" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  value: 0,<br/>  increment() {<br/>    this.value += 1;<br/>    return this;<br/>  },<br/>  subtract(v) {<br/>    this.value -= v;<br/>    return this;<br/>  },<br/>  log() {<br/>    console.log(this.value);<br/>  }<br/>};</span></pre><p id="4aaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个方法都返回上面对象中的<code class="fe mv mw mx mm b">this</code>。</p><p id="438e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以将对象中的方法链接起来，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3f10" class="mq lf it mm b gy mr ms l mt mu">obj<br/>  .increment()<br/>  .subtract(2)<br/>  .log();</span></pre><p id="aa5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们从<code class="fe mv mw mx mm b">log</code>方法中得到<code class="fe mv mw mx mm b">-1</code>。</p><h1 id="f9d0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="679a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们在每个方法中返回<code class="fe mv mw mx mm b">this</code>，我们可以链接方法。</p><p id="237a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将静态成员定义为函数的属性，那么它们就是公共的。</p><p id="8040" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们希望它们是私有的，那么我们可以在IIFE中定义它们，并返回一个使用静态成员的类或构造函数。</p></div></div>    
</body>
</html>