<html>
<head>
<title>Managing React Application State with Mobx — Full stack tutorial (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Mobx管理React应用程序状态—全栈教程(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-react-application-state-with-mobx-full-stack-tutorial-part-1-372a7825847a?source=collection_archive---------0-----------------------#2018-05-14">https://levelup.gitconnected.com/managing-react-application-state-with-mobx-full-stack-tutorial-part-1-372a7825847a?source=collection_archive---------0-----------------------#2018-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8119f71bae771753e387607843ab4319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zOFYeKw76jPB6yVn.jpg"/></div></div></figure><p id="86d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SPA的fullstack教程，前端是React JS + MobX，后端是Django-rest-framework，受基于令牌的认证保护。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="65d9" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">介绍</h1><p id="3bca" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">React是前端开发人员在各种应用程序中使用的最流行的UI库之一。React的优势在本文以及网上的各种博客中都有介绍。在我以前的文章中，我试图不关注React本身，而是关注一些用于状态管理、数据流实现、路由、动作分派等的强大工具。我从非常简单并且不太出名的<a class="ae mg" href="https://medium.com/front-end-hacking/react-and-reflux-usage-in-real-time-applications-based-on-websockets-part-1-introduction-12fcc7cc3590" rel="noopener">回流</a>库开始，通过与Redux-Thunk和React-Router-Redux的结合，我开发出了著名且强大的<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/enhancing-your-react-graphql-app-with-redux-and-redux-thunk-90c556aff1c5"> Redux </a>。</p><p id="0613" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将重点关注众所周知的<a class="ae mg" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> MobX </a>库，它是为可伸缩的状态管理而设计的。在第一部分中，我们将开始在客户端使用React + Mobx编写单页面应用程序(SPA ),并为后端使用受Python开发人员欢迎的框架<a class="ae mg" href="http://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank"> Django-rest-framework </a>(使用Django版本<a class="ae mg" href="https://docs.djangoproject.com/en/1.11/" rel="noopener ugc nofollow" target="_blank"> 1.11 </a>)。该应用程序将负责<code class="fe mh mi mj mk b">Users</code>和<code class="fe mh mi mj mk b">Todos</code>列表，与之前的<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/enhancing-your-react-graphql-app-with-redux-and-redux-thunk-90c556aff1c5">文章</a>中相同，并将通过某种身份验证来保护。在本文中，我们将重点关注以下几个部分:</p><ul class=""><li id="cd9b" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">新用户的注册</li><li id="3f1e" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">使用令牌的身份验证</li><li id="e72c" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">显示用户列表</li><li id="6210" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">在列表中执行搜索</li></ul><p id="6808" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在接下来的部分中，我们将继续todos的实现。您可以在<a class="ae mg" href="https://github.com/KilroggD/Todos-python" rel="noopener ugc nofollow" target="_blank">库</a>中找到工作代码示例。</p><p id="d985" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要警告:本文中使用的注册和认证并不能保证100%安全和生产就绪，尽管它使用非常安全的工作流在数据库中存储会话。此外，本教程没有经过生产测试，因为它的目的是展示django + MobX + React JS的全栈教程，并举例说明主要的MobX特性。</p><h1 id="8c04" class="ld le iq bd lf lg mz li lj lk na lm ln lo nb lq lr ls nc lu lv lw nd ly lz ma bi translated">服务器端应用程序</h1><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2a300cbd13979f88b7f565028d924c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G7_HiKyQEonwGSTM.jpg"/></div></div></figure><p id="209a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要让服务器端在您的计算机上工作，只需运行</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="a713" class="nm le iq mk b gy nn no l np nq">pip install -r requirements.txt</span></pre><p id="ae1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要安装所有python依赖项，请运行以下命令</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="39db" class="nm le iq mk b gy nn no l np nq">python manage.py runserver</span></pre><p id="5dac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(除了像<code class="fe mh mi mj mk b">django</code>和<code class="fe mh mi mj mk b">django-rest</code>这样的必选项目之外，你可以随意跳过其中的一些)</p><p id="e9d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务器端python应用程序的源代码可以在<a class="ae mg" href="https://github.com/KilroggD/Todos-python/tree/master/todos" rel="noopener ugc nofollow" target="_blank">这里</a>找到。它没有什么特别之处——它只是一个带有sqlite示例数据库的<code class="fe mh mi mj mk b">django-rest</code>后端应用程序。</p><p id="c609" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于认证，我们将使用<a class="ae mg" href="http://django-rest-auth.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> django-rest-auth </a>。相对于使用JWT进行用户会话，它更安全，因为它将会话令牌存储在服务器端ID数据库中，并使您能够验证服务器从客户端接收的令牌。要启用这个库进行用户验证，我们需要将它包含在已安装的应用程序列表中，并定义URL。我们将在主<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/tutorial/urls.py" rel="noopener ugc nofollow" target="_blank"> urls.py </a>中为API调用和身份验证定义不同的URL路径</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="483b" class="nm le iq mk b gy nn no l np nq">url(r'^api/', include('todos.urls')),<br/>url(r'^rest-auth/', include('rest_auth.urls')),</span></pre><p id="c323" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用来自<code class="fe mh mi mj mk b">rest_auth</code>库的默认登录视图，并为用户注册编写简单的视图</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="ab95" class="nm le iq mk b gy nn no l np nq">class Registration(generics.GenericAPIView):<br/>    serializer_class = UserRegistrationSerializer<br/>    permission_classes = (AllowAny,)</span><span id="ab10" class="nm le iq mk b gy nr no l np nq">def post(self, request, *args, **kwargs):<br/>        serializer = self.get_serializer(data=request.data)<br/>        serializer.is_valid(raise_exception=True)<br/>        user = self.perform_create(serializer, request.data)</span><span id="fcd2" class="nm le iq mk b gy nr no l np nq">return Response({}, status=status.HTTP_201_CREATED)</span><span id="4e24" class="nm le iq mk b gy nr no l np nq">def perform_create(self, serializer, data):<br/>        user = serializer.create(data)<br/>        return user</span></pre><p id="fb3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我不会关注后端部分，因为它是一个非常基本的django应用程序，带有一个简单的sqlite数据库。我们将添加一些功能来扩展默认用户模型管理器(例如，使用搜索表单帖子参数过滤用户的搜索方法)</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="1f6b" class="nm le iq mk b gy nn no l np nq">def search(self, **kwargs):<br/>        qs = self.get_queryset()<br/>        if kwargs.get('first_name', ''):<br/>            qs =  qs.filter(<br/>                first_name__icontains=kwargs['first_name'])<br/>        if kwargs.get('last_name', ''):<br/>            qs = qs.filter(<br/>                last_name__icontains=kwargs['last_name'])<br/>        if kwargs.get('department', ''):<br/>            qs = qs.filter(department__name=kwargs['department'])<br/>        if kwargs.get('country', ''):<br/>            qs = qs.filter(country__name=kwargs['country'])</span></pre><p id="f399" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以自由探索存储库中的其他特性。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="5917" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">客户端应用程序</h1><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/936d577cec3bfde34e08414db2cbefa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U1dXF-9oxjw9mdvr.jpg"/></div></div></figure><p id="a52a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本教程的前端部分是基于<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/enhancing-your-react-graphql-app-with-redux-and-redux-thunk-90c556aff1c5">上一个</a>的React和Redux。源代码可以在存储库中的<a class="ae mg" href="https://github.com/KilroggD/Todos-python/tree/master/client" rel="noopener ugc nofollow" target="_blank">客户端文件夹</a>中找到。它使用标准的<code class="fe mh mi mj mk b">create-react-app</code>样板文件和一些附加的包:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="1bc5" class="nm le iq mk b gy nn no l np nq">"mobx": "^3.5.1",<br/>"mobx-react": "^4.3.5",</span></pre><p id="1820" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于React应用中的Mobx支持，我们添加了以下插件:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="7997" class="nm le iq mk b gy nn no l np nq">"babel-plugin-transform-class-properties": "^6.24.1",<br/>"babel-plugin-transform-decorators-legacy": "^1.3.4"</span></pre><p id="d0c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些为MobX中使用的decorator语法增加了类属性支持。</p><p id="7d11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你仍然面临编译前端的任何问题，我建议使用<a class="ae mg" href="https://www.npmjs.com/package/custom-react-scripts" rel="noopener ugc nofollow" target="_blank">自定义反应脚本</a>而不是反应脚本。你可以从项目的开始(create-react-app my-app-scripts-version custom-react-scripts)开始，或者如果你已经设置了create-react-app样板文件，你可以按照<a class="ae mg" href="https://github.com/kitze/custom-react-scripts/issues/30" rel="noopener ugc nofollow" target="_blank">这条线索</a>删除react-scripts并添加自定义脚本:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="06e5" class="nm le iq mk b gy nn no l np nq">npm remove react-scripts<br/>npm i -s custom-react-scripts</span></pre><p id="ddfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后创造<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/.env" rel="noopener ugc nofollow" target="_blank">。您的app文件夹中的env </a>文件，包含以下内容:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="37d1" class="nm le iq mk b gy nn no l np nq">REACT_APP_BABEL_STAGE_0=true<br/>REACT_APP_DECORATORS=true</span></pre><p id="6f67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者如果你只是下载教程，你会没事的，因为我更新了package.json来使用自定义脚本:)</p><p id="4433" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要运行前端部分，首先使用以下命令安装软件包:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="e86a" class="nm le iq mk b gy nn no l np nq">npm install</span></pre><p id="0606" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后使用以下命令启动应用程序:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="5626" class="nm le iq mk b gy nn no l np nq">npm start</span></pre><p id="27a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哪个在您的本地机器上运行开发服务器</p><p id="c23c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个应用程序拥有超级用户<strong class="ka ir">admin@tutorial.com</strong>，密码为<strong class="ka ir"> q1w2e3r4。</strong>随意创建另一个具有注册功能的用户，命令行，或者直接在sqlite DB文件中。</p><p id="f394" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用良好的旧REST API来服务JSON对象。我们需要前端的API路由，类似于<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/src/api.js" rel="noopener ugc nofollow" target="_blank"> API路由</a>。因为这些URL是用于API的，所以我们将路由放在一个单独的<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/src/routes.js" rel="noopener ugc nofollow" target="_blank">文件</a>中。</p><p id="c909" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">保持<a class="ae mg" href="https://github.com/KilroggD/Todos-python/tree/master/client/src/services" rel="noopener ugc nofollow" target="_blank">服务</a>类与API端点调用、本地存储API等交互是很方便的。请注意<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/src/services/ApiService.js" rel="noopener ugc nofollow" target="_blank"> ApiService </a>已经被更改为使用REST端点。我们还需要一个新的<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/src/services/history.js" rel="noopener ugc nofollow" target="_blank">历史</a>存储，以便能够从MobX存储中以功能方式执行重定向，因为没有像react-router-redux这样的包来实现开箱即用的功能(如果有，请告诉我:)</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="6a32" class="nm le iq mk b gy nn no l np nq">import createHistory from 'history/createBrowserHistory'export default createHistory()</span></pre><p id="3bc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于文件夹结构，我们将保持与Redux教程中相同的结构。我们将有服务文件夹来保存上述服务</p><p id="208a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将把组件分成<a class="ae mg" href="https://github.com/KilroggD/Todos-python/tree/master/client/src/containers" rel="noopener ugc nofollow" target="_blank">容器</a>——保持“智能”组件连接到数据存储并能够触发动作，<a class="ae mg" href="https://github.com/KilroggD/Todos-python/tree/master/client/src/forms" rel="noopener ugc nofollow" target="_blank">表单</a> —保持组件与用户输入数据相关，最后，<a class="ae mg" href="https://github.com/KilroggD/Todos-python/tree/master/client/src/components" rel="noopener ugc nofollow" target="_blank">组件</a> —保持无状态的表示组件，这些组件可以从redux教程中复制过来，或者在将来的任何示例中重用。</p><p id="df88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后让我们把重点放在本教程中使用的MobX特性上。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="4abe" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">MobX功能</h1><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a8745a7364b525e72acd372bc86a32ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0EIK6NY5kw_I9Yyy.jpg"/></div></div></figure><p id="edc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MobX的一个主要概念是商店。与Redux概念相比，store可以提供Redux中reducers和actions所提供的相同功能。商店的一个简单例子是<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/src/stores/UserStore.js" rel="noopener ugc nofollow" target="_blank"> UserStore </a>，它负责根据搜索参数加载用户列表。</p><p id="c99a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从顶部开始—用途之一是可观察的(或“@observable”)</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="7b91" class="nm le iq mk b gy nn no l np nq">@observable isLoading = true<br/>@observable isFailure = false<br/>@observable users = []</span></pre><p id="3eae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个装饰器定义了react组件应该观察的值(可以是JS原语、引用、普通对象、类实例、数组和映射)。当这个值改变时，组件将识别它并相应地更新(类似于redux中的mapStateToProps)。</p><p id="7c02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个有用的特性是计算属性，该属性的值基于另一个值，可通过getter方法访问。</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="949c" class="nm le iq mk b gy nn no l np nq">@computed get total() {<br/>     return this.users.length<br/> }</span></pre><p id="55ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python开发人员可能对这个特性很熟悉，因为在Python中广泛使用了“@property”修饰符。</p><p id="690d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为MobX不像Redux那样为动作指定任何显式位置，所以您也可以使用“@ action”decorator在商店中定义动作。你也可以在商店之外以更“类似redux”的方式定义动作——这在一篇关于从Redux迁移到MobX的非常有用的文章<a class="ae mg" href="https://www.robinwieruch.de/mobx-react/" rel="noopener ugc nofollow" target="_blank">中有完美的描述。您还可以使用Javascript ES7中引入的async/await语法来定义异步操作</a></p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="c2b9" class="nm le iq mk b gy nn no l np nq"><a class="ae mg" href="http://twitter.com/action" rel="noopener ugc nofollow" target="_blank">@action</a> async getUsers(params) {<br/>        try {<br/>            const data = await ApiService.search_users(params)          <br/>            runInAction(() =&gt; {<br/>                this.isLoading = false<br/>                this.users = data.users<br/>                if (Object.keys(params).length &amp;&amp; data) {<br/>                    //save successful request<br/>                    StorageService.setSearchData(params)<br/>                }<br/>            })<br/>        } catch (e) {<br/>            runInAction(() =&gt; {<br/>                this.isLoading = false<br/>                this.isFailure = true<br/>                this.users = []<br/>            })<br/>        }<br/>    }</span></pre><p id="fcd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个动作中有一点语法上的好处，它获取一段代码并执行它，这是一个匿名动作。如上面的代码示例所示，这对于异步操作非常方便。</p><p id="b1f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，您可以使用简单的同步操作来修改您的存储状态，并执行一些副作用(例如<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/src/stores/SearchStore.js" rel="noopener ugc nofollow" target="_blank"> localStorage update </a></p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="f760" class="nm le iq mk b gy nn no l np nq"><a class="ae mg" href="http://twitter.com/action" rel="noopener ugc nofollow" target="_blank">@action</a> loadStoredData() {<br/>        //load form data from local storage<br/>        const data = StorageService.getSearchData() || {}<br/>        //dispatch an action        <br/>        this.loadForm(data)<br/>    }</span><span id="a5dd" class="nm le iq mk b gy nr no l np nq"><a class="ae mg" href="http://twitter.com/action" rel="noopener ugc nofollow" target="_blank">@action</a> clearForm() {<br/>        StorageService.removeSearchData()<br/>        this.searchData = {}<br/>    }</span><span id="7a3a" class="nm le iq mk b gy nr no l np nq"><a class="ae mg" href="http://twitter.com/action" rel="noopener ugc nofollow" target="_blank">@action</a> clearForm() {<br/>        StorageService.removeSearchData()<br/>        this.searchData = {}<br/>    }</span></pre><p id="4f23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们需要使用声明的方式从一个动作执行重定向，我们可以使用本教程前面描述的历史服务:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="0674" class="nm le iq mk b gy nn no l np nq"><a class="ae mg" href="http://twitter.com/action" rel="noopener ugc nofollow" target="_blank">@action</a> async logout() {<br/>        await ApiService.logout(StorageService.getToken())<br/>        StorageService.removeToken()<br/>        runInAction(() =&gt; {<br/>            this.isAuthenticated = false<br/>            this.isFailure = false<br/>            this.currentUser = null<br/>            this.isLoading = false<br/>            history.push('/')<br/>        })<br/>    }</span></pre><p id="30c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了给商店注入令人惊叹的功能，我们有几种选择:</p><ul class=""><li id="c505" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">通过商店作为道具</li><li id="4ff2" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">通过<em class="ns"> this.store = new MyStore() </em>在构造函数中实例化store</li><li id="2777" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">使用<a class="ae mg" href="https://mobx.js.org/refguide/api.html" rel="noopener ugc nofollow" target="_blank">注入</a>功能包装器</li><li id="26c3" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">使用注入装饰语法</li></ul><p id="10df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们选择最后一个的<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/src/index.js" rel="noopener ugc nofollow" target="_blank">，因为在我看来，它看起来更‘复古’和干净。</a></p><p id="92bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们能够像下面这样组合我们的商店:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="7ffa" class="nm le iq mk b gy nn no l np nq">const stores = {<br/>    authStore,<br/>    userStore,<br/>    searchStore,<br/>    registerStore,<br/>};</span></pre><p id="6f47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们使用Redux-like Provider模式将组合商店传递给应用程序</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="77a9" class="nm le iq mk b gy nn no l np nq">ReactDOM.render(<br/>    &lt;Provider { ...stores }&gt;<br/>        &lt;App&gt;<br/>            &lt;Router history={history}&gt;<br/>                &lt;Switch&gt;<br/>                    &lt;Route exact path="/" component={Home} /&gt;<br/>                    &lt;Route path={routes.login} component={LoginContainer} /&gt;<br/>                    &lt;Route path={routes.sign_up} component={RegisterContainer} /&gt;<br/>                    &lt;Route path={routes.users} component={UserListContainer} /&gt;<br/>                &lt;/Switch&gt;<br/>            &lt;/Router&gt;<br/>        &lt;/App&gt;<br/>    &lt;/Provider&gt;,<br/>    document.getElementById('root')<br/>);</span></pre><p id="2d29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要忘记定义我们需要的所有导入:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="1042" class="nm le iq mk b gy nn no l np nq">import { Provider } from 'mobx-react'<br/>import { Router, Switch, Route } from 'react-router'<br/>import history from './services/history'<br/>import authStore from './stores/AuthStore'<br/>import userStore from './stores/UserStore'<br/>import searchStore from './stores/SearchStore'<br/>import registerStore from './stores/RegisterStore'</span></pre><p id="b4d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以使用“@inject”和“@observer”装饰器轻松地将我们需要的存储插入到每个组件中(例如，参见<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/src/containers/UserListContainer.js" rel="noopener ugc nofollow" target="_blank"> UserListContainer </a></p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="5f0a" class="nm le iq mk b gy nn no l np nq"><a class="ae mg" href="http://twitter.com/inject" rel="noopener ugc nofollow" target="_blank">@inject</a>('userStore', 'searchStore') <a class="ae mg" href="http://twitter.com/observer" rel="noopener ugc nofollow" target="_blank">@observer</a><br/>class UserListContainer extends React.Component {</span></pre><p id="01a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过容器中的props可以访问注入的存储，因此我们可以使用存储中的属性和动作作为我们的“共享状态”</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="038a" class="nm le iq mk b gy nn no l np nq">return &lt;div className="user"&gt;<br/>            &lt;UserForm data={searchStore.searchData}<br/>                submitHandler={this.getUsers}<br/>                changeHandler={searchStore.loadForm.bind(searchStore)}<br/>                clearHandler={searchStore.clearForm.bind(searchStore)} /&gt;<br/>            {userStore.users &amp;&amp; &lt;UserList users={userStore.users} /&gt;}<br/>        &lt;/div&gt;;</span></pre><p id="1d1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者在异步操作的情况下，我们甚至可以在生命周期方法中使用它们</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="480a" class="nm le iq mk b gy nn no l np nq">async componentDidMount() {<br/>        this.props.searchStore.loadStoredData()<br/>        await this.props.userStore.getUsers()<br/>    }</span></pre><p id="ec96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/src/containers/LoginContainer.js" rel="noopener ugc nofollow" target="_blank"> LoginContainer </a>或<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/client/src/containers/RegisterContainer.js" rel="noopener ugc nofollow" target="_blank"> RegisterContainer </a>的情况下，我们可以只注入我们需要检查认证用户的存储，并在必要时进行重定向:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="0d90" class="nm le iq mk b gy nn no l np nq">async componentWillReact() {<br/>        if(this.props.authStore.isAuthenticated) {<br/>            await this.props.authStore.fetchProfile()<br/>            history.push('/')<br/>        }<br/>    }</span></pre><p id="97fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个新的生命周期挂钩，当组件由于观察到的数据发生变化而需要重新呈现时，就会触发这个挂钩。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="2f26" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">运行生产版本</h1><p id="7df5" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">您可以使用webpack和python dev-servers全面测试这些代码，但是如果您想使用“类似生产”的构建来运行它，您可能需要这些有用的提示。</p><p id="aaaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，您需要通过转到客户端文件夹并运行以下命令来构建fronend:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="9608" class="nm le iq mk b gy nn no l np nq">npm run build</span></pre><p id="de0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您需要在您的<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/tutorial/urls.py" rel="noopener ugc nofollow" target="_blank"> url.py </a>文件中定义适当的url，以便从django提供它:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="e945" class="nm le iq mk b gy nn no l np nq">url(<br/>    r'^$',         <br/>    csrf_exempt(TemplateView.as_view(template_name='index.html'))<br/>),<br/>url(<br/>    r'^(?P&lt;path&gt;.*)/$',     <br/>    csrf_exempt(TemplateView.as_view(template_name='index.html'))<br/>),</span></pre><p id="f658" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，这两种模式强制所有路径服务于index.html模板。</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="6591" class="nm le iq mk b gy nn no l np nq">url(r'^api/', include('todos.urls')),<br/>url(r'^rest-auth/', include('rest_auth.urls')),</span></pre><p id="6d3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外两个定义了到我们的todos API和rest-auth API的链接</p><p id="2ded" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个需求将服务于fronend构建中的service-worker.js:</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="5670" class="nm le iq mk b gy nn no l np nq">url(<br/>        r'^service-worker.js', cache_control(max_age=2592000)(<br/>            TemplateView.as_view(<br/>                template_name="service-worker.js",<br/>                content_type='application/javascript',<br/>            )<br/>        ),<br/>        name='service-worker.js'<br/>    ),</span></pre><p id="f297" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要在您的<a class="ae mg" href="https://github.com/KilroggD/Todos-python/blob/master/tutorial/settings.py" rel="noopener ugc nofollow" target="_blank">设置</a>中定义静态文件中模板的路径</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="3515" class="nm le iq mk b gy nn no l np nq">TEMPLATES = [<br/>    { <br/># ......<br/>        'DIRS': ['client/build/'],<br/>        'APP_DIRS': True,</span><span id="d797" class="nm le iq mk b gy nr no l np nq"># ......<br/>    },<br/>]<br/># .....<br/># Static files (CSS, JavaScript, Images)<br/># <a class="ae mg" href="https://docs.djangoproject.com/en/1.11/howto/static-files/" rel="noopener ugc nofollow" target="_blank">https://docs.djangoproject.com/en/1.11/howto/static-files/</a><br/>CORS_ORIGIN_ALLOW_ALL = True<br/>STATIC_URL = '/static/'<br/>STATICFILES_DIRS = [<br/>    'client/build/static',<br/>]</span></pre><p id="2df8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些准备工作完成后，我们就可以在运行后看到我们的主页了</p><pre class="ne nf ng nh gt ni mk nj nk aw nl bi"><span id="5ca9" class="nm le iq mk b gy nn no l np nq">python manage.py runserver</span></pre><p id="653f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并导航到<code class="fe mh mi mj mk b">localhost:8000</code>(或不同的主机/端口，如果已定义)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="0ea7" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">我对MobX的看法</h1><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a1efe7d66c0937a66b898cd52abdd278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d3KXTSlujJn7j7ar.jpg"/></div></div></figure><p id="65ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先— MobX和React—MobX不能认为是React—Redux的替代品。这是一件有点不同的事情。MobX很好，是一个相对较小的库，用于执行可伸缩的状态管理。与Redux相比，它只提供了一个明确定义的模式——商店，但是您可以非常灵活地使用它。</p><p id="1426" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于动作、简化器和中间件没有严格的符号，但这并不意味着你不能自己定义它。</p><p id="94d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与Redux (redux-thunk、redux-saga、react-router-redux等)相比，MobX没有太多的附加组件和外部库，其社区也没有那么大。然而，它在不断成长和改进。</p><p id="78ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在使用MobX和Redux一段时间后，我可以说MobX更加“轻量级”,更容易学习，但在为您提供适当的状态管理工具方面非常强大。虽然它主要关注商店层，但它的工作做得很好。Redux在我看来还是比较强大的库。它为你提供了一个完整的关于存储和动作的架构模式，并且，如果你使用额外的东西，比如thunk和react-router，它还为你提供了中间件，并把它自己注入到路由工作流中。然而，在我看来，这有点难学，而且你并不总是需要它——对于相对较小的项目来说，它可能过于复杂了。如果你从一个小应用开始，并期望它成长——不要担心，Redux和MobX都是完全可扩展的。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="7fc0" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">未完待续…</h1><p id="dbd3" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在本教程的以下部分中，我们将介绍:</p><ul class=""><li id="ba1c" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">添加待办事项存储和查看待办事项列表的功能</li><li id="243c" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">添加向用户分配任务、更改任务状态等功能</li><li id="4c8d" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">使用React和Mobx添加单元测试示例</li></ul></div></div>    
</body>
</html>