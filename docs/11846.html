<html>
<head>
<title>Ingress Nginx on Azure Kubernetes Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure Kubernetes服务上的入口Nginx</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ingress-nginx-on-azure-kubernetes-service-14e6108373e9?source=collection_archive---------4-----------------------#2022-04-21">https://levelup.gitconnected.com/ingress-nginx-on-azure-kubernetes-service-14e6108373e9?source=collection_archive---------4-----------------------#2022-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="758f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在单个主机上公开多个服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3e7d18a00f4ee6b25dee0be63a0367c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v26YjatruSj-IBp7"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jordanharrison?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔丹·哈里森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将一个应用程序部署在由多个微服务组成的Kubernetes集群上，您可能希望公开其中的一些微服务，以便可以通过互联网进行访问。虽然这显然是为了您的web应用程序服务，但是您可能还想公开一些额外的API。</p><p id="e06a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes的世界里，任何与你的微服务的连接都是通过使用<em class="lv">服务</em>资源来完成的。使用Kubernetes <em class="lv">服务</em>资源的类型<em class="lv">负载平衡器</em>利用底层云提供商创建特定于云提供商的负载平衡器，用于通过外部IP公开微服务。这种方法的问题是，每个微服务将暴露在一个单独的IP地址下。</p><p id="b4e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让它们暴露在同一个主机下会方便得多，同时有不同的路径到达专用微服务，对吗？</p><p id="4d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文展示了如何使用Azure上的Kubernetes集群和流行的Nginx来实现这一点。这是我关于使用Azure应用网关和Traefik的文章的后续。许多内容将基于那篇文章。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4edb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">介绍</h1><p id="11c0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">微服务可以使用Kubernetes <em class="lv">服务</em>资源在Kubernetes内部和外部公开。到目前为止，一切顺利。但是如前所述，如果我们想在集群之外公开它们，使用类型为<em class="lv"> LoadBalancer </em>的服务资源，我们最终会为每个微服务提供不同的IP。这不是我们想要的，相反，我们想让它们暴露在一个和主机使用不同的路径。</p><p id="8be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是Kubernetes <em class="lv"> Ingress </em>资源派上用场的地方。把一个<em class="lv">入口</em>想象成Kubernetes服务之上的一层。它是访问我们微服务的流量的单一入口，微服务根据指定的规则将流量路由到不同的Kubernetes <em class="lv">服务</em>。</p><p id="7173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">库伯内特斯<em class="lv">入口</em>资源的概念是抽象的。为了使用Kubernetes <em class="lv">入口</em>，你必须安装一个特定的<em class="lv">入口控制器</em>。Kubernetes <em class="lv"> Ingress </em>抽象有很多不同的实现。Nginx和Traefik是其中两个在Kubernetes和开源社区中非常受欢迎的工具。</p><p id="a124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们还有云提供商，你可以使用负载平衡器和网关等资源作为Kubernetes <em class="lv">入口</em>。无论如何，在本文中，我们将重点关注<a class="ae ky" href="https://kubernetes.github.io/ingress-nginx/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">入口Nginx </em> </a>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="76df" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">先决条件</h1><p id="7bdc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">以下是完成整个过程所需的一些先决条件:</p><ul class=""><li id="9843" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">Azure CLI已安装</li><li id="a21d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">获取您拥有全局管理员角色的Azure订阅</li><li id="f576" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">kubectl已安装</li><li id="6eb3" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">jq已安装</li><li id="ca60" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">已安装Helm CLI</li></ul><h1 id="4605" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">准备Azure环境</h1><p id="9d64" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在创建AKS集群之前，我们从准备Azure环境开始。</p><h2 id="3c39" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">创建新的资源组</h2><p id="73b1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们要做的第一件事是在<strong class="lb iu"> eastus </strong>区域创建一个名为<strong class="lb iu"> k8srg </strong>的新资源组。因此，您首先必须登录您的Azure帐户。以下命令将打开一个带有单点登录站点的浏览器，您可以在其中输入凭据。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="eeb2" class="nt me it og b gy ok ol l om on">az login</span></pre><p id="bbaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功登录后，CLI将列出您帐户的所有可用订阅。选择您的订阅。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="5dd1" class="nt me it og b gy ok ol l om on">az account set --subscription &lt;subscription id&gt;</span></pre><p id="33dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以实际上我们的新资源组。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="b4fb" class="nt me it og b gy ok ol l om on">az group create --name k8srg --location eastus</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="40c1" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">创建新的虚拟网络</h2><p id="c85c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当使用<em class="lv"> Ingress Nginx </em>时，无论何时您想要公开一个微服务，Nginx内部都会创建一个指向特定微服务的新路由。为了让连接工作，Nginx和Kubernetes必须在同一个Azure Vnet中。否则，连接将无法建立，您最终将拥有不健康的连接。</p><p id="a3f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们创建一个包含子网的新虚拟网络。此外，我们为Nginx创建了一个公共IP。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="32a9" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">创建AKS实例</h1><p id="0bcd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们可以开始创建一个简单配置的Kubernetes集群了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="c88c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列出的命令将在<strong class="lb iu"> eastus </strong>区域创建一个名为<strong class="lb iu"> k8srg </strong>的资源组，并在其中创建一个Kubernetes集群。Kubernetes集群被命名为<strong class="lb iu"> myk8s </strong>，包含1个worker节点。最后一个命令将使您的<code class="fe oq or os og b">kubectl</code>连接到新创建的<strong class="lb iu"> myk8s </strong> Kubernetes集群。</p><h1 id="349f" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">部署入口Nginx</h1><p id="ff5d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">将<em class="lv"> Ingress </em> Nginx部署到您的Kubernetes集群基本上有两种方式。要么通过编写自己的部署清单文件来“手动”部署它，要么使用helm。我们将在本文中使用helm。</p><h2 id="9e8e" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">入口Nginx配置</h2><p id="e124" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">像所有其他舵图一样，<em class="lv">入口</em> Nginx的配置可以通过使用文件或CLI参数覆盖默认值来完成。我们将使用包含以下内容的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="65d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参见<a class="ae ky" href="https://github.com/kubernetes/ingress-nginx/blob/main/charts/ingress-nginx/values.yaml" rel="noopener ugc nofollow" target="_blank">本</a>了解配置文件可能性的完整概述。不过现在先说配置。</p><p id="04f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没什么特别的事。我们指定入口控制器应该分配到哪个外部IP，以及公共IP属于哪个资源组。使用以下命令获取我们之前创建的公共IP:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="5aa2" class="nt me it og b gy ok ol l om on">az network public-ip show -g k8srg -n nginx-public-ip | jq .ipAddress -r</span></pre><p id="d4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让<em class="lv">入口</em>控制器绑定公共IP，我们需要使用以下命令授予Kubernetes身份对包含公共IP的资源组的访问权:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="bb08" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">通过头盔安装入口Nginx</h2><p id="6e43" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们已经有了配置文件，通过Helm的实际安装非常方便。只需运行以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该通过运行<code class="fe oq or os og b">kubectl get pods -n ingress-nginx | grep ingress-nginx</code>来检查安装是否成功，这应该会产生一个正在运行的pod。</p><h1 id="0c4b" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">公开多个服务</h1><p id="4c37" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最后，是时候使用不同的路由在同一台主机上公开多个服务了。因此，我们利用了我在Dockerhub 上发布的一个小小的Node.js应用程序。这个应用程序是一个非常简单的服务器，它返回一个由环境变量指定的消息。</p><p id="8f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看部署清单是什么样子的，它公开了主机上某个路由下的服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="20db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件的前两部分相对来说并不引人注意。请注意最后两个部分，它们配置了如何公开服务。在第60行中，我们定义了应该公开服务的路线。一个有趣的方面是第54行的注释，当实际与我们的微服务通信时，它去掉了路径。这是必需的，因为示例应用程序只有一个端点“/”。如果没有注释，对<em class="lv"> hostname/service1 </em>的请求将被路由到不存在的<em class="lv"> exampleapp/service1 </em>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="e548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您可以复制文件内容，创建您的文件并应用它们。我为您简化了这一过程，并创建了一个GitHub repo，其中包含两个部署清单，每个清单公开了不同路径上的测试应用程序，而每个应用程序返回不同的响应。所以你只需要运行以下要点的命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="7740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，我们的入口Nginx中应该有两个注册的路由指向每个服务。我们将使用公共IP对它们进行测试，并附上各自的路径:</p><p id="3228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oq or os og b">curl &lt;pubIP&gt;/service1</code>应返回“来自服务1的问候”,相应地<code class="fe oq or os og b">curl &lt;pubIP&gt;/service2</code>应返回“来自服务2的问候”。</p><h1 id="dbc5" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">解决纷争</h1><p id="d478" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">由于在公开我们的微服务的过程中包含多个组件，如果某些东西不能按预期工作，您将不得不查看不同的地方。</p><ul class=""><li id="936a" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">首先，您应该检查所有pod是否都在运行。最重要的一个是<em class="lv">ingress-nginx-controller-*</em>pod，而*等于随机字符串。</li><li id="db3f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">之后，您可以检查代表您的微服务的pod是否正常运行。此外，检查指向您的微服务的服务是否已创建并正在运行。不要忘记仔细检查它们是否指向正确的端口。</li><li id="154c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">如果<em class="lv"> pods </em>和<em class="lv">服务</em>运行正常，检查<em class="lv">入口资源</em>是否也被创建，并且它们分别指向正确的<em class="lv">服务</em>。接下来，您应该使用<code class="fe oq or os og b">kubectl describe ing service1-ingress -n ingress-nginx</code>检查<em class="lv">入口资源</em>的事件。</li><li id="caab" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">此外，检查您的<em class="lv">重写目标注释</em>是否做了正确的事情。</li><li id="c1ed" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">如果一切都设置正确，Nginx控制器本身的日志可能会非常有用。因此只需运行<code class="fe oq or os og b">kubectl logs ingress-nginx-controller-*</code>。</li></ul><h1 id="7fe4" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">结论</h1><p id="aa5c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这是关于使用Kubernetes <em class="lv"> Ingress </em>在单个主机上公开不同服务的第三篇文章。我第一篇文章用的是Azure App Gateway，感觉很重量级。在第二篇文章中，我使用了Traefik，感觉非常流畅。</p><p id="e4d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还没有机会长期使用Ingress Nginx或将其用于生产用例，但一如既往，没有最好的解决方案或技术。一切都取决于你的背景和要求。</p><p id="0f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读我的文章，并且你已经成功地公开了你的服务。我很想听听你对Traefik入口的体验。非常感谢任何反馈。</p><h1 id="412a" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">进一步阅读</h1><ul class=""><li id="6aa3" class="na nb it lb b lc mv lf mw li ot lm ou lq ov lu nf ng nh ni bi translated"><a class="ae ky" href="https://www.nginx.com" rel="noopener ugc nofollow" target="_blank">https://www.nginx.com</a></li><li id="27a6" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://kubernetes.github.io/ingress-nginx/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.github.io/ingress-nginx/</a></li><li id="65d0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://github.com/kubernetes/ingress-nginx/blob/main/charts/ingress-nginx/values.yaml" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/ingress-nginx/blob/main/charts/ingress-nginx/values . YAML</a></li><li id="15b5" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://kubernetes.github.io/ingress-nginx/troubleshooting/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.github.io/ingress-nginx/troubleshooting/</a></li><li id="54b8" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/workloads/controllers/deployment/</a></li><li id="6fe0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/services-networking/ingress/</a></li></ul></div></div>    
</body>
</html>