<html>
<head>
<title>Scala journals — parametric polymorphism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala期刊—参数多态性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-parametric-polymorphism-sounds-scarier-than-it-is-818714b31fe8?source=collection_archive---------13-----------------------#2020-06-02">https://levelup.gitconnected.com/scala-journals-parametric-polymorphism-sounds-scarier-than-it-is-818714b31fe8?source=collection_archive---------13-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0945" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想以承认我发现非常正确的一件事开始这篇博客:函数式编程与泛型行话的混合会使理解甚至是直观的概念变得困难。今天，我将尽我最大的努力去钻透类型界限、参数多态、抽象类型、泛型类型、类型推理和所有其他听起来…嗯…至少是外国的东西的混乱世界。请原谅我在这篇文章中重复了几次。这都是为了更大的利益！</p><h1 id="6666" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">总体来说…我们到底在谈论什么？</h1><p id="3475" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">多态性！不多不少。让我们回顾一下它的含义:</p><blockquote class="lr ls lt"><p id="5752" class="jq jr lu js b jt ju jv jw jx jy jz ka lv kc kd ke lw kg kh ki lx kk kl km kn im bi translated"><em class="it"> Poly' —许多，' morphism' —形状。</em></p></blockquote><p id="cd62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有三种类型的多态性(什么？！):</p><ul class=""><li id="61ca" class="ly lz it js b jt ju jx jy kb ma kf mb kj mc kn md me mf mg bi translated">亚型多态性—良好的ould OOP(猫是动物的一个亚型)</li><li id="fe4c" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated"><strong class="js iu">参数多态性—仿制药。这就是我们今天要谈论的</strong></li><li id="9012" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated">特殊多态性——我们暂时不考虑这一点。这有点像泛型，但是更灵活</li></ul><p id="a5c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你猜对了——Scala支持所有这些！所以下一次你在面试的时候，你可以继续回答一个问题“告诉我关于多态性的事情”，用“哦，但是你想让我谈论哪种多态性？”。如果你问我，我会觉得很酷！</p><h1 id="62b6" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">好的。什么是什么？</h1><p id="78de" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">正如我提到的，行话让我们这些凡人不容易。但是没关系。我们很快就会长生不老。让我们试着理解这些大词，看看隐藏在它们背后的东西实际上是非常直观的东西。</p><p id="790a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们考虑下面这段代码。把类<code class="fe mm mn mo mp b">Zone</code>想象成一个区域，在这里只允许特定的<strong class="js iu">类型</strong>的东西。也许就像城市中的一个区域，那里只允许特定类型的建筑。有趣的事实:由于这个博客是我的旅行职业休息项目，我需要提到的是，我是在秘鲁的许多地方看到这个项目的，并从中获得了灵感！你可能会认为把20家药店放在一条街上(或者，我在这里称之为一个药店“区”)是个坏主意，会让其中一半的药店破产，但秘鲁人不会同意。让我们来模拟一下:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="f818" class="my kp it mp b gy mz na l nb nc">trait Building<br/>trait School extends Building<br/>trait Shop extends Building<br/>trait Pharmacy extends Shop<br/>trait Llama<br/><br/>class Zone[A](val anything: A)</span></pre><p id="633b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重要的事情先来。条款。给定我们的<code class="fe mm mn mo mp b">Zone</code>类的定义，考虑这个疯狂的命名:</p><ul class=""><li id="9b0d" class="ly lz it js b jt ju jx jy kb ma kf mb kj mc kn md me mf mg bi translated"><code class="fe mm mn mo mp b">Zone[A]</code>是一个<strong class="js iu">通用类</strong>。将类型作为其构造函数参数的类。泛型类需要实例化类型，因为(顾名思义)它只对泛型值进行操作，而不对具体类型进行操作。所以想想<code class="fe mm mn mo mp b">List</code>——我们能知道把<code class="fe mm mn mo mp b">List[A]</code>的所有元素加起来意味着什么吗？那<code class="fe mm mn mo mp b">List[Int]</code>呢？</li><li id="8203" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated"><code class="fe mm mn mo mp b">A</code>是一个<strong class="js iu">抽象类型</strong>。仔细想想还是有点道理的。它是“抽象的”，因为我们不能对它进行推理。仅仅因为我们不知道它实际上可能是什么。我们可以直觉地猜测，我们需要提供一些具体的东西。</li><li id="66af" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated">我们的泛型类<code class="fe mm mn mo mp b">Zone</code>展示了第二种类型的多态- <strong class="js iu">参数多态</strong>，这意味着我们需要传递一个<strong class="js iu">类型参数</strong>来实现多态。</li></ul><p id="f082" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总结一下，我们的<code class="fe mm mn mo mp b">Zone[A]</code>可以被称为“一个以抽象类型A作为参数的泛型类‘区域’”。听起来很聪明，但是…太长了。在现实生活中，当讨论它的时候，我可能会称它为<code class="fe mm mn mo mp b">generic class "Zone"</code>。将一个类称为“泛型”意味着它是一个将类型作为参数的类，正如我上面提到的。</p><h1 id="1929" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">使用泛型(又名参数多态性)</h1><p id="2d70" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如上所述，泛型类采用类型参数(提醒:这就是为什么它被称为参数多态)。这意味着，如果我们想从上面的代码中构建一个药房区域，我们将把药房作为一个类型传递给泛型类区域:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="ae75" class="my kp it mp b gy mz na l nb nc">val pharmacyZone = new Zone[Pharmacy](new Pharmacy)</span></pre><p id="7ca5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很好。如果我们只想拥有一个商店区呢？</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="ac62" class="my kp it mp b gy mz na l nb nc">val shopZone = new Zone[Shop](new Pharmacy) <br/>val shopZone2 = new Zone[Shop](new School) // will get an error here: School is not the same type as Shop</span></pre><h1 id="5b98" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">类型推断——用编译器玩猜谜游戏</h1><p id="3c8a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">关于与上述代码相关的注释，我们来谈谈<strong class="js iu">类型推理</strong>。Scala编译器很棒，它可以帮你做很多思考……它可以推断类型。</p><p id="abea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看“推断”在现实生活中是什么意思:</p><blockquote class="lr ls lt"><p id="d37c" class="jq jr lu js b jt ju jv jw jx jy jz ka lv kc kd ke lw kg kh ki lx kk kl km kn im bi translated">推断(动词):通过证据或推理得出结论</p></blockquote><p id="983b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，换句话说，上面的类型推断就是Scala编译器<em class="lu">“从证据</em>推断出类型”，也就是猜测你指的是哪种类型。</p><p id="e026" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许你已经知道这是怎么回事了？</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="b314" class="my kp it mp b gy mz na l nb nc">val shopZone = new Zone(new Pharmacy)</span></pre><p id="493e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记得<code class="fe mm mn mo mp b">Zone</code>类需要一个类型参数吗？注意，在上面的代码中，我们没有传递类型。但是我们仍然需要它！在这种情况下，Scala编译器会查看上面的代码，并计算出既然类签名是<code class="fe mm mn mo mp b">Zone[A](val anything: A)</code>，然后你传递一个类型为<code class="fe mm mn mo mp b">Pharmacy</code>的实例，那么你一定意味着类型A等于<code class="fe mm mn mo mp b">Pharmacy</code>。</p><p id="8642" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意<strong class="js iu">类型推断</strong>是一个通用术语，不仅与泛型有关，也与其他对象(函数、值)有关:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="43ed" class="my kp it mp b gy mz na l nb nc">val name = "John" // value type inferred to be String<br/>def add(one: Int, two: Int) = one + two // function return type inferred to be Int</span></pre><p id="4743" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总而言之，只要让Scala编译器判断出类型，类型推断就会发生。尽管这很酷，但我尽量避免使用它，并显式声明我的类型，尤其是当涉及嵌套代码时。代码可读性更好，也更容易推理，更不用说我不太可能看到臭名昭著的<code class="fe mm mn mo mp b">Product with Serializable</code>类型破坏我的代码(原因之一可能是您让编译器过度思考了您的意思)。</p><h1 id="86ab" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">类型上限和下限——都是关于它们的健康边界</h1><p id="1727" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><code class="fe mm mn mo mp b">Bounds</code>引用你为类/方法的类型参数设置的边界。如果果汁和咖啡是液体，而土豆是固体，那么建模一个泛型类<code class="fe mm mn mo mp b">Glass[???]</code>只接受类型为<code class="fe mm mn mo mp b">Liquids</code>(谁会点一杯土豆？)因此，您为Glass类的类型参数设置了一个<strong class="js iu"> bound </strong> (ary ),从而得到了类似于<code class="fe mm mn mo mp b">Glass[Liquid]</code>的结果。你可能听说过<code class="fe mm mn mo mp b">upper type bounds</code>和<code class="fe mm mn mo mp b">lower type bounds</code>——那我们就来看看吧。</p><h2 id="7b81" class="my kp it bd kq nd ne dn ku nf ng dp ky kb nh ni lc kf nj nk lg kj nl nm lk nn bi translated">上类型界限</h2><p id="c254" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">上限是传递给类构造函数的参数类型必须“小于或等于”你的类型边界(“小于”=子类，“等于”=本身)。所以相对于上面的例子,“upper”意味着我们的类型<code class="fe mm mn mo mp b">Liquid</code>是“最高”允许的类型。这是一个从顶部开始的边界，因此称为“上限”。现在知道了这一点，Scala语法“小于或等于”<code class="fe mm mn mo mp b">&lt;:</code>也就很有意义了:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="22a3" class="my kp it mp b gy mz na l nb nc">class Glass[T &lt;: Liquid] // our type T has to be "less or equal" to Liquid<br/>trait Liquid<br/>trait Solid<br/>class Juice extends Liquid<br/>class Coffee extends Liquid<br/>class Potato extends Solid<br/><br/>new Glass[Juice] // ok!<br/>new Glass[Coffee] // ok!<br/>new Glass[Liquid] // ok!<br/>new Glass[Any] // nop! "Any" is "higher" than Liquid <br/>new Glass[Potato] // hmm.. why? nop! compile error</span></pre><p id="667b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">懂Java的注意:<code class="fe mm mn mo mp b">T &lt;: Liquid</code>基本就是<code class="fe mm mn mo mp b">&lt;T extends Liquid&gt;</code></p><h2 id="224f" class="my kp it bd kq nd ne dn ku nf ng dp ky kb nh ni lc kf nj nk lg kj nl nm lk nn bi translated">下界</h2><p id="f7c8" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">下限是指传递给类构造函数的参数类型必须“大于或等于”你的类型边界(“大于”=超类，“等于”=自身)。在与以下代码的关系中,“较低”再次意味着<code class="fe mm mn mo mp b">Liquid</code>是“最低”允许类型。这是一个自下而上的边界，因此称为“下界”。同样，语法<code class="fe mm mn mo mp b">&gt;:</code>也很有意义:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="7761" class="my kp it mp b gy mz na l nb nc">class Glass[T &gt;: Coffee] // our type T has to be "greater or equal" to Coffee<br/>trait Liquid<br/>trait Solid<br/>class Juice extends Liquid<br/>class Coffee extends Liquid<br/>class Potato extends Solid<br/><br/>new Glass[Coffee] // ok!<br/>new Glass[Liquid] // ok!<br/>new Glass[Any] // ok!<br/>new Glass[Juice] // nop! Juice is not "greater" than Coffee<br/>new Glass[Potato] // again, nop!</span></pre><h1 id="a7fd" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">摘要</h1><p id="f576" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这次有点脑子进水了！让我们来回顾一些重要的词汇:</p><ul class=""><li id="decf" class="ly lz it js b jt ju jx jy kb ma kf mb kj mc kn md me mf mg bi translated"><strong class="js iu">泛型类</strong> —需要类型参数的类<code class="fe mm mn mo mp b">class Something[A]</code></li><li id="911c" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated"><strong class="js iu">类型参数</strong> —作为参数传递给类/方法的类型</li><li id="2932" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated"><strong class="js iu">参数多态性</strong>——基本上……泛型编程(“参数化”是因为类型是作为类/函数参数传递的)</li><li id="44a4" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated"><strong class="js iu">类型推断</strong>——当Scala编译器猜测你指的是什么类型时</li><li id="a278" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated"><strong class="js iu">类型限制</strong> —一种类型，它限制了什么类型可以作为参数</li><li id="454b" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated"><strong class="js iu">上类型界限</strong>——不允许任何“大于”(<code class="fe mm mn mo mp b">T &gt;: A</code>)该类型界限的东西</li><li id="3e1d" class="ly lz it js b jt mh jx mi kb mj kf mk kj ml kn md me mf mg bi translated"><strong class="js iu">较低的类型界限</strong>——不允许比该类型“更小”(<code class="fe mm mn mo mp b">T &lt;: A</code>)的任何内容</li></ul><p id="c979" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为结束语，我建议你花几分钟时间学习Scala中的类层次结构。使用泛型时，了解这一点至关重要。或者从现在开始我们可以称之为参数多态性。</p><figure class="mq mr ms mt gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi no"><img src="../Images/41615276a4956f864368ea4cb46388b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cbkzfX_Js7FsbEr1.png"/></div></div></figure><p id="09db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考资料:<br/><a class="ae nw" href="https://docs.scala-lang.org/tour/variances.html" rel="noopener ugc nofollow" target="_blank">Scala docs</a>—Scala官方文档<br/> <a class="ae nw" href="http://like-a-boss.net/2013/03/29/polymorphism-and-typeclasses-in-scala.html" rel="noopener ugc nofollow" target="_blank">巴托兹·维特科夫斯基的博客</a> —关于一些Scala事物的很棒的小博客<br/> <a class="ae nw" href="https://www.youtube.com/channel/UCGOoAhrv-mOe3dB2PeSVQGw" rel="noopener ugc nofollow" target="_blank"> Java9s YouTube频道</a> —一组关于Java 9的YouTube视频</p></div></div>    
</body>
</html>