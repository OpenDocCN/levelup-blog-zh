<html>
<head>
<title>JavaScript Best Practices — Object Shorthand and Arrow Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—对象速记和箭头函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-object-shorthand-and-arrow-functions-afbcb39d4ce3?source=collection_archive---------13-----------------------#2020-05-28">https://levelup.gitconnected.com/javascript-best-practices-object-shorthand-and-arrow-functions-afbcb39d4ce3?source=collection_archive---------13-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b83c566b76f3d56dc432fb0aa3dc7fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h64L06sm5JaHV6Ky"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@japhethmast?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">船桅</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">防溅板</a>上拍摄</figcaption></figure><p id="e837" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="a72c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究使用对象文字速记语法、回调的箭头函数，以及在大多数情况下使用<code class="fe le lf lg lh b">const</code>来防止意外的重新分配。</p><h1 id="ce90" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用对象文字速记语法</h1><p id="1afc" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们应该使用对象文字速记语法来用属性填充我们的对象。</p><p id="9ec1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两种快捷方式可用于填充对象中的对象属性。</p><p id="6b8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个是对象属性速记，另一个是方法速记。</p><p id="5df2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用object属性简写，我们可以编写类似下面的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="dd43" class="mt lj it lh b gy mu mv l mw mx">const a = 1,<br/>  b = 2,<br/>  c = 3;</span><span id="8a66" class="mt lj it lh b gy my mv l mw mx">const obj = {<br/>  a,<br/>  b,<br/>  c<br/>};</span></pre><p id="0e7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有常量<code class="fe le lf lg lh b">a</code>、<code class="fe le lf lg lh b">b</code>和<code class="fe le lf lg lh b">c</code>。</p><p id="8a5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用属性<code class="fe le lf lg lh b">a</code>、<code class="fe le lf lg lh b">b</code>和<code class="fe le lf lg lh b">c</code>填充<code class="fe le lf lg lh b">obj</code>对象，这些属性的值与同名变量的值相同。</p><p id="f492" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码等效于下面的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4798" class="mt lj it lh b gy mu mv l mw mx">const a = 1,<br/>  b = 2,<br/>  c = 3;</span><span id="b520" class="mt lj it lh b gy my mv l mw mx">const obj = {<br/>  a: a,<br/>  b: b,<br/>  c: c<br/>};</span></pre><p id="3825" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们用速记法删除了重复的代码。省去了我们打字，看起来更干净。</p><p id="0467" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于方法，我们可以用如下的简写来声明它们。例如，我们可以使用以下代码向我们的对象添加方法:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="862a" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  foo() {},<br/>  bar() {}<br/>};</span></pre><p id="427f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过使用简写将<code class="fe le lf lg lh b">obj</code>对象中的<code class="fe le lf lg lh b">foo</code>和<code class="fe le lf lg lh b">bar</code>方法声明为传统函数，这让我们可以在不使用<code class="fe le lf lg lh b">:</code>和<code class="fe le lf lg lh b">function</code>关键字的情况下将传统函数声明为对象中的方法。</p><p id="e636" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们知道它们是传统函数，因为我们可以在其中引用<code class="fe le lf lg lh b">this</code>。例如，我们可以编写以下代码来实现这一点:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4c27" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  baz: 'baz',<br/>  foo() {<br/>    console.log(this.baz);<br/>  },<br/>  bar() {}<br/>};</span></pre><p id="e807" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们记录了<code class="fe le lf lg lh b">this.baz</code>的值，其中<code class="fe le lf lg lh b">this</code>是上面代码中的<code class="fe le lf lg lh b">obj</code>。</p><p id="da74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么当我们这样称呼它的时候:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4392" class="mt lj it lh b gy mu mv l mw mx">obj.foo();</span></pre><p id="b82b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe le lf lg lh b">'baz'</code>登录到控制台。因此，我们知道<code class="fe le lf lg lh b">foo</code>方法内部的<code class="fe le lf lg lh b">this</code>是<code class="fe le lf lg lh b">obj</code>对象，所以我们知道<code class="fe le lf lg lh b">foo</code>方法是一个传统的JavaScript函数。</p><p id="c300" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比它的旧版本要短得多，旧版本如下:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="cad0" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  baz: 'baz',<br/>  foo: function() {<br/>    console.log(this.baz);<br/>  },<br/>  bar: function() {}<br/>};</span></pre><p id="a84c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们从上面的代码中看到的，我们必须键入更多的字符来声明上面代码中的方法，关键字<code class="fe le lf lg lh b">function</code>是8个额外的字符，我们在两个方法中都有它。</p><p id="281b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以缩短生成器函数的声明。以下是在JavaScript对象中声明生成器方法的简写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e59e" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  * foo() {<br/>    yield 1;<br/>  },<br/>};</span></pre><p id="3011" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有一个符号<code class="fe le lf lg lh b">*</code>,表示<code class="fe le lf lg lh b">foo</code>是一个生成器函数，而不是一个常规函数。</p><p id="38e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是以下代码的简写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="713d" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  foo: function*() {<br/>    yield 1;<br/>  },<br/>};</span></pre><p id="0769" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如我们所见，它要短得多。</p><p id="8410" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该尽可能使用快捷键来填充我们的对象属性，这样我们可以输入更少的内容，使我们的代码更整洁，同时保持代码清晰。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/aeebd046e0541fd54ddb281b895409b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uX_L7EX5WILTdI1-"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@brookecagle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克·卡吉尔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="969d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">为回调使用箭头函数</h1><p id="478c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用箭头函数进行回调是一个好主意。我们不必担心箭头函数中<code class="fe le lf lg lh b">this</code>的值，因为它并不介意。</p><p id="36ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也不那么冗长，并且它绑定到它们周围范围内的<code class="fe le lf lg lh b">this</code>，而不是绑定到它们自己的<code class="fe le lf lg lh b">this</code>值，这与常规函数不同。</p><p id="141f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不需要在回调中为<code class="fe le lf lg lh b">this</code>指定一个特定的值，这是最有可能的情况，那么我们可以在回调中使用箭头函数。</p><p id="bbf1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不用编写下面的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="288a" class="mt lj it lh b gy mu mv l mw mx">const arr = [1, 2, 3].map(function(x) {<br/>  return x * 2;<br/>})</span></pre><p id="8cfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用一个箭头函数作为回调函数编写如下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="64f1" class="mt lj it lh b gy mu mv l mw mx">const arr = [1, 2, 3].map(x =&gt; x * 2);</span></pre><p id="86ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，每段代码中的字符数有很大的不同。他们做同样的事情，但第一个例子比第二个长得多。</p><p id="d301" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们隐式返回<code class="fe le lf lg lh b">x * 2</code>，因为我们在第一行返回了结果。此外，我们不必使用<code class="fe le lf lg lh b">function</code>和<code class="fe le lf lg lh b">return</code>关键字来定义我们的函数并返回一些内容。</p><p id="e1cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于它没有引用<code class="fe le lf lg lh b">this</code>的具体值，所以使用箭头函数是正确的选择。</p><h1 id="d89c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="fe8b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">只要有可能，我们就应该使用对象快捷键来填充对象的属性。值属性和方法都有缩写。</p><p id="d8db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用arrow函数进行回调是一个很好的选择，因为它节省了大量的输入，并且不会绑定到自己的值<code class="fe le lf lg lh b">this</code>。</p></div></div>    
</body>
</html>