<html>
<head>
<title>API Caching with Redis, Flask, and Docker [Step-By-Step]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redis、Flask和Docker进行API缓存[循序渐进]</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implement-api-caching-with-redis-flask-and-docker-step-by-step-9139636cef24?source=collection_archive---------1-----------------------#2021-06-07">https://levelup.gitconnected.com/implement-api-caching-with-redis-flask-and-docker-step-by-step-9139636cef24?source=collection_archive---------1-----------------------#2021-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2cc0329e6a995c88e268937b98485983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kweAChrF5o0hO83KK2fQHQ.png"/></div></div></figure><p id="4643" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您希望您的API更快、更一致，并减少对服务器的请求吗？—这就是缓存发挥作用的地方。在本文中，我将向您展示如何在Flask上用Redis实现API缓存。我在这里以Flask为例，但是无论采用何种技术，缓存的概念都是相同的。</p><ul class=""><li id="262d" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">【2022年2月进行了以下更新——Python更新至3.9并更改了项目结构</li></ul><h1 id="397f" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">什么是缓存？</strong></h1><p id="33d6" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在我们进入关于使用Redis和Flask实现缓存的实际部分之前，让我们首先了解什么是缓存的定义，并学习它的概念，这样你就知道用例是什么了。</p><p id="e810" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">缓存是将频繁访问的数据的副本存储在请求-响应路径上的几个地方的能力。当消费者请求资源表示时，请求通过一个缓存或一系列缓存(本地缓存、代理缓存或反向代理)到达托管资源的服务。如果请求路径上的任何缓存有所请求的表示的新副本，它将使用该副本来满足请求。如果没有一个缓存能够满足请求，那么请求将被传送到服务(或者正式名称为源服务器)。这可以用两个术语来很好地定义，即缓存未命中和<strong class="ka ir"> </strong>缓存命中。</p><p id="55e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缓存命中</strong>—<strong class="ka ir">缓存命中</strong>是指在<strong class="ka ir">缓存</strong>内存中找到组件或应用程序请求处理的数据的状态。这是一种向处理器传送数据的更快方式，因为<strong class="ka ir">缓存</strong>已经包含了所请求的数据。</p><p id="0486" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">高速缓存未命中<em class="lf"> </em> </strong> <em class="lf"> — </em>高速缓存未命中是指在高速缓存中找不到组件或应用程序请求处理的数据的状态。它要求程序或应用程序从其他缓存级别或主内存中获取数据，从而导致执行延迟。</p><p id="377e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所述，有几种方法可以实现缓存。可以在客户端通过Web缓存，在服务器端通过数据缓存(关系数据库、Redis等)，以及通过安装在应用程序上的插件(例如:WordPress上的插件)进行应用程序缓存。在本教程中，我们将使用Redis来保存来自API的响应，然后使用这些响应，而不是向服务器发出获取数据的请求。</p><h2 id="4afe" class="mj lh iq bd li mk ml dn lm mm mn dp lq kj mo mp lu kn mq mr ly kr ms mt mc mu bi translated">Flask和Redis —实现</h2><p id="acf3" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">先决条件:</p><ul class=""><li id="325c" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">Docker &amp; Docker-撰写</li><li id="a25c" class="kw kx iq ka b kb mv kf mw kj mx kn my kr mz kv lb lc ld le bi translated">瓶</li><li id="bb0d" class="kw kx iq ka b kb mv kf mw kj mx kn my kr mz kv lb lc ld le bi translated">Python 3。*+</li></ul><p id="cfc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用docker来隔离我们的服务，然后用<code class="fe na nb nc nd b">docker-compose</code>来将这些服务编排在一起(将它们放在同一个网络上，它们之间的通信，环境变量，等等)。如果你不了解Docker，建议你参考官方文档<a class="ae ne" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/0dae431083dbec56981f2129cd7ae5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEpkD_3NMTxK-w96c_QBBA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd li">一般工作流程</strong></figcaption></figure><h2 id="d9c6" class="mj lh iq bd li mk ml dn lm mm mn dp lq kj mo mp lu kn mq mr ly kr ms mt mc mu bi translated"><strong class="ak">项目设置</strong>:</h2><p id="dd82" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">创建python virtualenv并安装flask、Redis、Flask缓存和请求:</p><pre class="ng nh ni nj gt no nd np nq aw nr bi"><span id="e4b9" class="mj lh iq nd b gy ns nt l nu nv">$ python -m venv venv<br/>$ source venv/Scripts/activate<br/>$ (venv) pip install Flask redis flask_caching requests</span></pre><p id="d7e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的应用程序将如下所示:</p><pre class="ng nh ni nj gt no nd np nq aw nr bi"><span id="1559" class="mj lh iq nd b gy ns nt l nu nv">/root<br/>├── <!-- -->app.py                 - Application entrypoint<br/>├── <!-- -->config.py              - Config file for Flask<br/>├── docker-compose.yml     - Docker compose for app and redis<br/>├── Dockerfile             - Dockerfile for Flask API<br/>├── .env                   - Environment variables</span></pre><p id="00c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们继续创建此设置所需的文件:</p><pre class="ng nh ni nj gt no nd np nq aw nr bi"><span id="090e" class="mj lh iq nd b gy ns nt l nu nv">$ touch Dockerfile docker-compose.yml .env<br/>$ pip freeze &gt; requirements.txt<br/>$ touch config.py app.py</span></pre><p id="3f9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们要实施什么？</strong></p><p id="02c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将创建一个简单的端点，从<strong class="ka ir">hipo labs universities API</strong><em class="lf"/>中获取大学数据，并基于我们作为查询参数发送的国家，获取指定国家的大学列表。</p><p id="b71f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们继续，在<code class="fe na nb nc nd b">app.py</code>中创建一个Flask实例，并使用它创建一个获取大学数据的端点。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a6a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以基本上，基于查询参数<code class="fe na nb nc nd b">country</code>，它向外部API发出请求，并在<code class="fe na nb nc nd b">JSON format</code>中取回数据。让我们继续尝试一下:</p><pre class="ng nh ni nj gt no nd np nq aw nr bi"><span id="4710" class="mj lh iq nd b gy ns nt l nu nv">$ export FLASK_APP=app.py      # To tell where your flask app lives<br/>$ export FLASK_ENV=development # Set debug mode on<br/>$ flask run</span></pre><p id="5baf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用<a class="ae ne" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>来发出请求，因为我也想知道处理我的请求所花费的时间。</p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/eb2530ec6ec61811bdbd1cfaa157b1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9o8_94EDMwGO-BWWKnshBA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd li">用邮递员测试端点；为德国获取所有大学</strong></figcaption></figure><p id="f3c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在我们看到我们有了结果，一切正常。使用红色，您可以看到从该端点获取数据所花费的时间。我们可以尝试多次提出相同的请求，性能不会改变。这是因为我们总是向服务器发出新的请求。我们的目标是尽量减少这种情况，正如开始时解释的那样，减少对服务器的请求。所以让我们开始吧。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="038d" class="mj lh iq bd li mk ml dn lm mm mn dp lq kj mo mp lu kn mq mr ly kr ms mt mc mu bi translated">添加Redis并对应用程序进行归档</h2><p id="05c9" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">我们看到它在本地工作得很好，但现在我们想实现缓存，为此，我们将需要<code class="fe na nb nc nd b">Redis</code>。这里有几种方法可供您选择:</p><ul class=""><li id="0d56" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">安装Redis(官方兼容Linux，不兼容Windows，见<a class="ae ne" href="https://redis.io/topics/introduction" rel="noopener ugc nofollow" target="_blank">此处</a>)</li><li id="fc4a" class="kw kx iq ka b kb mv kf mw kj mx kn my kr mz kv lb lc ld le bi translated">托管一个Redis实例并使用它(例如:Heroku上的Redis实例)</li><li id="afaf" class="kw kx iq ka b kb mv kf mw kj mx kn my kr mz kv lb lc ld le bi translated">用Docker启动Redis实例(我们正在这样做)</li></ul><p id="fa31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将对应用程序进行dockerize，并添加Redis作为服务，这样我们就可以轻松地从我们的应用程序中进行通信。让我们继续为Flask应用程序编写docker文件:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="feca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们这里没有运行图像的<a class="ae ne" href="https://docs.docker.com/engine/reference/builder/#cmd" rel="noopener ugc nofollow" target="_blank">命令</a>，因为我将使用docker-compose来运行容器。让我们配置<code class="fe na nb nc nd b">docker-compose</code>来运行我们的应用程序和Redis:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c9de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们简单地添加两个服务，即我们的应用程序和Redis。对于应用程序，我们公开端口<code class="fe na nb nc nd b">5000</code>的输入和输出，对于Redis，我们公开<code class="fe na nb nc nd b">6379</code>。现在让我们用<code class="fe na nb nc nd b">docker-compose.</code>启动服务</p><pre class="ng nh ni nj gt no nd np nq aw nr bi"><span id="0677" class="mj lh iq nd b gy ns nt l nu nv">$ docker-compose up -d --build </span></pre><p id="6421" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的服务应该已经启动并运行了，如果我们再次发出与没有Docker的情况下运行应用程序时相同的请求，我们将得到相同的输出。要检查服务是否正在运行，请输入以下命令:</p><pre class="ng nh ni nj gt no nd np nq aw nr bi"><span id="65c5" class="mj lh iq nd b gy ns nt l nu nv">$ docker ps</span></pre></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="fdfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们配置我们的应用程序，使其与Redis实例连接，并在端点中实现缓存。我们可以直接在代码中设置变量，但在这里，我试图向您展示一些使用Flask和Docker开发时的良好实践。在上述的<code class="fe na nb nc nd b">docker-compose</code>中，我们可以看到，对于环境变量，我引用了<code class="fe na nb nc nd b">.env</code>文件，然后我使用config.py将这些变量映射到Flask应用程序。为了让<code class="fe na nb nc nd b">flask-caching</code>库工作，我们需要设置一些环境变量，这些变量用于Redis连接和缓存类型。根据您想要实现的缓存类型，您可以从库的文档 中了解关于<a class="ae ne" href="https://flask-caching.readthedocs.io/en/latest/#configuring-flask-caching" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">配置的更多信息。</strong></a></p><pre class="ng nh ni nj gt no nd np nq aw nr bi"><span id="e455" class="mj lh iq nd b gy ns nt l nu nv"># .env file<br/>CACHE_TYPE=redis<br/>CACHE_REDIS_HOST=redis<br/>CACHE_REDIS_PORT=6379<br/>CACHE_REDIS_DB=0<br/>CACHE_REDIS_URL=redis://redis:6379/0<br/>CACHE_DEFAULT_TIMEOUT=500</span></pre><p id="323c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe na nb nc nd b">.env</code>中，我们设置了一些变量，如缓存类型、主机、数据库等。因为我们已经将这些变量从docker-compose挂载到我们的容器中，所以现在我们可以使用<code class="fe na nb nc nd b">os</code>模块来获取这些变量。让我们在<code class="fe na nb nc nd b">config.py</code>中获取这些变量，稍后我们将使用它们将值映射到我们的Flask应用程序。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="fd7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从配置方面来说，我们很好。现在让我们初始化Flask上的缓存，并将其与我们的应用程序集成。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="212b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们添加了一个新的装饰器<code class="fe na nb nc nd b">@cache.cached</code>,然后我们指定一个<code class="fe na nb nc nd b">timeout</code>,它是这个响应将被缓存在Redis内存中的时间。所以基本上在第一个请求之后，我们会将这个响应存储30秒，之后会有一个新的请求，再次更新内存。第二个参数<code class="fe na nb nc nd b">query_string=True</code>在这种情况下是有意义的，因为我们希望基于存储的查询字符串而不是静态路径来存储响应。</p><ul class=""><li id="fd51" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir"> query_string </strong> —默认为假。如果为True，则使用的缓存键将是对有序查询字符串参数进行哈希运算的结果。这避免了仅仅因为参数以不同的顺序传递而为同一个查询创建不同的缓存。</li></ul><p id="df21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经完成了，让我们再次构建容器，并在缓存就绪的情况下进行实际测试。</p><pre class="ng nh ni nj gt no nd np nq aw nr bi"><span id="8641" class="mj lh iq nd b gy ns nt l nu nv">docker-compose up -d --build</span></pre><p id="a97c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们再次到Postman，在大学端点上做同样的请求。</p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/32c13d920aefb8a4bf77c853e4dbb9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u4a8OUBQu2gBzvc6iL5nsw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">使用Redis实现缓存后的响应时间</figcaption></figure><p id="7753" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一次，我们将拥有与不使用缓存时大致相同的时间，但如果我们再次进行同样的请求，我们将获得显著的改进，这都要感谢Redis。所以我们要做的是，我们将响应保存到内存数据库中，然后当数据仍然存储在那里时，它们将从那里返回，而不是从服务器发出请求。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="1a85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">潜得更深？—让我们通过使用GUI工具来查询我们的Redis存储，来看看实际情况。为了直观起见，我使用了<a class="ae ne" href="https://tableplus.com/" rel="noopener ugc nofollow" target="_blank"> TablePlus </a>，但是您也可以使用Redis CLI来查询数据。为了连接到我们的Redis实例，我们将主机指定为<code class="fe na nb nc nd b">localhost</code>，然后对于端口，我们输入<code class="fe na nb nc nd b">6379</code>，就像我们在<code class="fe na nb nc nd b">docker-compose</code>中公开的那样。</p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/57e2c32a38c2848e96041c30b6006e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*KbeJEpo_id_pG6c76qyp1g.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">。与Redis和Tableplus的连接</figcaption></figure><p id="db92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们可以看到存储在Redis实例中的数据。当有一个响应被保存时，您可以看到一个<code class="fe na nb nc nd b">db0</code>，如果我们寻找更多，我们将看到我们的缓存响应，包括<strong class="ka ir">[key；价值；类型；ttl】。</strong></p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/a727189128c307d6fe804b007ac08acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55ynzdVZ2TDPrwnGIgAtdw.png"/></div></div></figure><p id="4177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以清楚地看到，缓存的响应是<code class="fe na nb nc nd b">/universities?*</code>，并且在<code class="fe na nb nc nd b">ttl</code>出现的时间内可用。这一部分有点超出了范围，但是知道后台发生了什么是很好的。</p><p id="c9ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们用Redis和Flask实现了API缓存。更多选项请参考<code class="fe na nb nc nd b">flask-caching</code>库的<a class="ae ne" href="https://flask-caching.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>，它是一个实现不同客户端缓存的包装器。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="c7e9" class="mj lh iq bd li mk ml dn lm mm mn dp lq kj mo mp lu kn mq mr ly kr ms mt mc mu bi translated">结论</h2><p id="2b0d" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">所以我们使用Redis实现了API缓存。这是一个简单的例子，但是它包含了关于这个主题的很多细节。当您编写应用程序时，缓存非常重要，因为它对性能有很大帮助，如果可能，您应该实现它，但要确保您的目标是正确的用例。</p><p id="29c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">您可以在GitHub资源库上找到文章的完整源代码，以及说明。</strong></p><div class="oj ok gp gr ol om"><a href="https://github.com/vjanz/flask-cache-redis" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">vjanz/flask-cache-redis</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">在GitHub上创建一个帐户，为vjanz/flask-cache-redis的开发做出贡献。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa jw om"/></div></div></a></div><p id="c2a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你觉得它有帮助，请不要忘记鼓掌并在你的社交网络上或与你的朋友分享。</p><p id="d7c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有任何问题，请随时联系我。</p><p id="4ab6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">如果你愿意支持我的工作，你可以点击下面的图片给我买杯咖啡😄:</strong></p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><a href="https://www.buymeacoffee.com/valonjanuzaj"><div class="gh gi pb"><img src="../Images/59b5c6e154bad5ee3b8395e0d7fe91b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kiygRTkeWNs36xpV.gif"/></div></a></figure><p id="4c1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae ne" href="https://www.linkedin.com/in/valon-januzaj-b02692187/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae ne" href="http://www.github.com/vjanz" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上与我联系</p><h2 id="7eb7" class="mj lh iq bd li mk ml dn lm mm mn dp lq kj mo mp lu kn mq mr ly kr ms mt mc mu bi translated">参考资料:</h2><p id="10cd" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated"><a class="ae ne" href="https://www.cloudflare.com/learning/cdn/what-is-caching/" rel="noopener ugc nofollow" target="_blank">https://www.cloudflare.com/learning/cdn/what-is-caching/</a>T13】https://redislabs.com<br/>https://docs.docker.com/<br/>https://flask-caching . readthedocs . io<br/>http://universities.hipolabs.com/</p><h2 id="d688" class="mj lh iq bd li mk ml dn lm mm mn dp lq kj mo mp lu kn mq mr ly kr ms mt mc mu bi translated"><strong class="ak">我在媒体上发表的其他文章</strong>:</h2><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/asynchronous-tasks-in-python-with-celery-rabbitmq-redis-480f6e506d76"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">用Celery + RabbitMQ + Redis实现Python中的异步任务</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">在本文中，我们将使用Celery、RabbitMQ和Redis来构建一个分布式任务队列。但是什么是…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa jw om"/></div></div></a></div><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/deploy-a-dockerized-fastapi-application-to-aws-cc757830ba1b"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">将dockerized FastAPI应用程序部署到AWS</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">您已经创建了您的FastAPI应用程序，现在您想通过部署它来公开它吗？—不要担心…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="pd l ox oy oz ov pa jw om"/></div></div></a></div></div></div>    
</body>
</html>