# 测试中模仿代码的技巧

> 原文：<https://levelup.gitconnected.com/some-tips-for-mocking-code-in-tests-f46bc9499767>

## 模仿很棒。直到他们不再是。

![](img/0a69e3772f389644d2a094a6e9448b4a.png)

当你第一次学习如何测试你的代码时，[嘲讽看起来很神奇](https://www.telerik.com/products/mocking/unit-testing.aspx)。但是它是如此强大的一个特性，以至于不管使用什么语言，它都有被滥用的趋势。作为一名初级开发人员，我不得不修正许多模糊且无用的测试，这里是我在这个过程中获得的一些智慧。

# 尽量减少模拟功能

“我没有测试`function X`，所以当我在`function Y`中调用`X`时，我可以只模拟返回值！”这是一个常见的场景，但可能不是一个好主意。假设`function X`在别处得到严格的单元测试可能是一个错误。我在`function Y`看到 bug 弹出的次数是因为在`function X` 没有被抓到是*虚幻*。

测试应该让你相信改变不会破坏现有的架构。它们就像一个免费的迷你问答环节。但是，如果你过度使用嘲笑，那么你就不会那么自信；您实际上忽略了大量代码。即使一切都测试得很好，也永远不会是完美的。而且太多的模仿会在你的代码中引入漏洞，而这些漏洞是 bug 乐于安家的。只有在必要的时候才模仿，并确保你模仿的函数在别处测试过。

# 对函数的模拟调用

假设我们正在测试一个内部有 API 调用的函数:

```
// makes an API request and returns result
const **getUsers** = () => {
   ...
}// returns array of user names or 'nobody here'
const**displayNames** =() => {
  const **users** = **getUsers**();
  if (**users.**length) {
    return **users**.map(**user** => **user**.name);   
  } 
  return ["*Nobody here*"];
}
```

给定这个伪代码，我们有两个主要选择:模仿`getUsers`返回值或其中的 API 请求。嘲笑`getUsers`很有诱惑力，大多数测试套件都很容易做到这一点。然而，这意味着对`getUsers` **的任何实际代码更改都不会影响这个测试。**

## 在请求级别嘲笑

如果您模拟网络响应本身，就没有必要担心被跳过的更改。`getUsers`将进行常规的 API 调用并接收响应，而不知道它得到了一个模仿。如果你使用类似于 [fetch API](https://developer.mozilla.org/en/docs/Web/API/Fetch_API) 的东西进行异步调用，有一些库可以让[轻松地模仿](https://www.npmjs.com/package/fetch-mock)。

主要的缺点是，通常需要更长的时间来建立测试套件，以有效地模拟服务器调用。如果你有时间，努力是值得的。然而，情况可能并不总是如此。所以，如果你有来模仿函数，那么至少:

# 使用“真实的”模拟数据

***模拟数据应该总是与真实世界数据*** 相匹配。无论模拟值是什么，都不要弄乱数据的形状:

```
// real data always sent by API: 
{
  id: 1,
  name: "Tom",
  age: 23,
  height: 75,
  bio: "I'm a nice person."
}// "Test" version
{
  id: 0,
  name: "Tom",
  age: "some age"
}
```

测试版本可能会导致问题。有一个奇怪的 id 0，一个在现实世界中是数字**的年龄**，一个在测试中是字符串**的年龄**，它完全没有属性。

## 错误的数据意味着假阴性

当测试仓促进行时，不完整的模拟值是常见的。当有人通过检查一些属性的存在来“证明”一个函数有效时，它们就会弹出来，就是这样。然而，如果有一个未来的测试来检查`bio`的长度，例如，它会失败，因为*生物错误地不存在。*这破坏了新的测试，因为我们依赖的真实世界数据**在测试中不存在。如果数据*总是以某种方式返回*，测试应该反映这一点。**

## 没有免费文档

如果代码[使用了错误的数据，那么它就不是自文档化的](https://itnext.io/tips-for-writing-self-documenting-code-e54a15e9de2),坦白地说，它对其他开发人员没有太大的帮助。如果您是代码新手，并且不确定函数应该返回什么，那么检查模拟数据是一个很好的起点。当你修改代码的时候，需要花费更多的精力来维护，但是自信的提升和知识共享带来的好处远远超过了弥补。相信我。

别误会，嘲讽很棒！没有它，测试会运行得更慢，更不可预测。像你腰带上的任何工具一样，当你负责任地使用它时，你会得到最好的结果。

大家编码快乐，

麦克风