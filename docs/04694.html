<html>
<head>
<title>Analyzing Spikes in Cloud Function Require Latency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析云功能中的峰值需要延迟</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/analyzing-weird-spikes-in-cloud-function-require-latency-50c5d1b0ce87?source=collection_archive---------23-----------------------#2020-07-09">https://levelup.gitconnected.com/analyzing-weird-spikes-in-cloud-function-require-latency-50c5d1b0ce87?source=collection_archive---------23-----------------------#2020-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4e3c048a4f0c32ec42b68478eeb3ad75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jxs4LedEKEnLMc49LbjNJg.png"/></div></div></figure><p id="4d9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用child_process在云函数中运行代码似乎会在require语句周围产生显著的延迟峰值。我调查了一下，得出了一些数据。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><blockquote class="ld le lf"><p id="df02" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated"><em class="iq">代码复制本可在</em> <a class="ae lk" href="https://github.com/ehacke/cloud-function-latency-spikes" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> GitHub </em> </a>上获得</p></blockquote><p id="ccb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lk" href="https://asserted.io" rel="noopener ugc nofollow" target="_blank">断言</a>的整体思想是，它允许你对你的应用程序连续运行<a class="ae lk" href="https://asserted.io/features/uptime-as-code" rel="noopener ugc nofollow" target="_blank">定制测试代码。当我开始构建它的时候，我认为最快最简单的方法就是使用GCP云函数。云功能已经存在很多年了，具有众所周知的性能和安全特性，所以它看起来是一个安全的赌注。</a></p><p id="b55e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其核心是，实现很简单。将代码复制到云函数中，然后使用<strong class="ka ir"> child_process </strong>在超时的情况下安全地执行它。</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="99ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">起初这似乎很有效。相对低的延迟，易于维护。</p><p id="56a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这段代码会持续运行，每分钟一次，永远如此。不到一天，我就在child_process.exec上得到一个超时。</p><h1 id="f5e2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">神秘开始了</h1><p id="504f" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">从逻辑上讲，我认为这是我的错，因为大多数事情都是这样。</p><p id="d261" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我正在执行的代码正在调用API端点，可能他们保持连接打开的时间太长了或者什么的。我首先忽略了它，但是后来我注意到，当我在本地机器上长时间运行代码时，没有发生超时。所以它并不完全是代码，也不是我从代码内部调用的API。</p><p id="736c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我开始调查。我做了通常的调试步骤，基本上是在每个地方添加<strong class="ka ir"> console.log </strong>语句，以查看阻塞在哪里，并将exec设置为继承stdio，这样我就可以很容易地查看日志。</p><p id="b19f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在<strong class="ka ir"> child_process.exec </strong>周围加了一些:</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="e74f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以及用户代码本身中的其他内容:</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="3ff3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在多次运行该函数后，我查看了GCP日志记录，在那里我可以看到日志行和它们发生的时间。</p><p id="08e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我惊讶地发现，延迟并没有发生在大部分用户代码中，而是发生在exec启动和require语句完成之间。</p><blockquote class="ld le lf"><p id="4926" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated"><em class="iq">完成require语句所需的时间差异很大。有些时候，require语句会在100毫秒内完成，而其他时候可能需要超过2秒钟，甚至在超时前还没有完成。</em></p></blockquote><p id="97fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这看起来很奇怪。这些并不是怪异深奥的依赖关系。它们是NPM最常用的图书馆。</p><p id="1be6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我自己的机器上对这些require语句进行分析显示影响可以忽略不计，所以可能是云函数本身的问题比较奇怪？</p><p id="1876" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我决定想出一个更正式的测试，看看我是否能找到它。</p><h1 id="81a5" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">实验</h1><h1 id="d413" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">环境</h1><p id="ffba" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">大约在同一时间，我试用了Cloud Run，知道我没有发现这个问题，只是在云函数中。所以我决定做个三方对比。我会在三种环境中运行相同的代码，并比较结果:</p><ul class=""><li id="7358" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">云功能— 2048 MB内存—单个2.4 GHz CPU</li><li id="4f41" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">云运行— 2048 MB内存—单个vCPU</li><li id="91d0" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">本地Docker — 2048 MB内存—单CPU</li></ul><h1 id="4492" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">密码</h1><p id="263d" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">就我正在运行的代码而言，我不想依赖特定的预先存在的库。虽然这是我最初注意到它的地方，但我不想引入这样的想法，即出于某种原因，这种特定的依赖性是一个问题。</p><p id="8090" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我写了一点随机生成节点模块的代码。每个都包含一个对象，该对象最多包含100个随机创建的属性。</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="2783" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我用它创建了一个文件夹，其中包含1000个随机生成的库，以及一个index.js文件，该文件需要所有这些库，并将它们导出到一个巨大的对象中。</p><blockquote class="ld le lf"><p id="8c74" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated">1000个依赖项听起来可能很多，但是如果你在一个任意的节点项目中运行<strong class="ka ir"><em class="iq">ls-al Node _ modules | WC-l</em></strong><em class="iq">，你会发现它实际上是非常合理的。甚至可能保守。</em></p></blockquote><p id="ad6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如帖子开头提到的，你可以在这里看到这个实验的完整代码库。</p><h1 id="6069" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">情节</h1><p id="9fcf" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">除了在1000个依赖项上调用require之外，我还想将它与一些不同的场景进行对比，以给出这个问题的一些背景。所以我想出了三个场景，我将在这三个环境中的每一个中运行:</p><ul class=""><li id="7bc8" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">正常要求—从默认目录加载1000个依赖项</li><li id="88a5" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">重新生成并要求—在<strong class="ka ir"> /tmp </strong>中重新生成并加载1000个依赖项</li><li id="6539" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">CPU —只吃CPU 1秒钟</li></ul><p id="3e95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的想法是，云函数从只读目录中加载您提供的代码。我对云功能的底层实现知之甚少，但我想控制这个只读目录可能会以某种方式影响事情的事实。所以我添加了第二个场景，在请求/tmp的过程中重新生成所有的依赖项，然后从那里加载它们。</p><p id="75fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个场景是一个简单的对照组，我只是原地旋转1000 ms，然后退出。</p><h1 id="5cf9" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结果呢</h1><p id="3d06" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">我在这三个环境中分别运行了1000次这些场景，并收集了结果。所有这些图表中显示的时间不是HTTP请求延迟，而是child_process.exec完成加载巨型依赖项所花费的时间。</p><h1 id="51b7" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">需要时间</h1><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/249675474eaa80b641b5f940cdb491b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*syVeCfQyHvdLB8LViff8SA.png"/></div></figure><p id="9e98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在图表中看到的，在云函数中加载假依赖项所需的时间有很大的差异。从2.5秒到超过10秒。</p><p id="b6bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">云运行实例显示了一些变化，但是非常合理。本地Docker实例基本上没有变化，这是您所期望的。</p><p id="83a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">统计数据:</p><ul class=""><li id="f55d" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">云函数—标准偏差:862毫秒—中位数:4015毫秒</li><li id="a89d" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">云运行—标准偏差:207毫秒—中位数:2265毫秒</li><li id="0ba5" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">本地Docker —标准偏差:30毫秒—中位数:1213毫秒</li></ul><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a55796635b3d4d3b8b7cbd26e27a98a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*e0eD0u4kB36YE80Pq4X22g.png"/></div></figure><p id="8e84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上图显示了剔除1%异常值后的延迟分布。本地docker非常紧凑，云运行有一些变化，云功能有很大变化。</p><h1 id="c9c2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">再生需要时间</h1><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b5efb8771a3fdb78abc9de0cb5a8c0fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*mCBYXbCVKenj4ZHUe2x9tA.png"/></div></figure><p id="4e7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种情况发生得更多，所以数字更大，但模式基本上是一样的。云函数表现最差，云运行有一定变异但合理，本地Docker吃紧。</p><p id="3410" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">统计数据:</p><ul class=""><li id="7c33" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">云函数—标准偏差:1664毫秒—中位数:7198毫秒</li><li id="7829" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">云运行—标准偏差:524毫秒—中位数:5895毫秒</li><li id="32ea" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">本地Docker —标准偏差:36毫秒—中位数:3245毫秒</li></ul><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f81e204ec301b53dfe72b159a06875a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*YzllkGsczRcolQ4fEYweNg.png"/></div></figure><p id="0fef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该分布类似于更简单的需求场景。本地Docker很紧，云运行得更宽(有一个离群值)，云函数分布得更广。</p><h1 id="7f6b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">CPU时间(控制)</h1><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/249980936974918f58f9eb63587a23ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*PONOiVHmcYlvwdc66AaR2A.png"/></div></figure><p id="680a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此图表上的纵轴已经过调整，与第一个场景相匹配，以便进行更好的直观比较。</p><p id="dda1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以看到，当它只是做直接的CPU工作时，所有环境都接近相同。云函数时间有一些峰值，但不显著。</p><p id="7778" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">统计数据:</p><ul class=""><li id="b76f" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">云函数—标准偏差:23毫秒—中位数:1172毫秒</li><li id="2cc2" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">云运行—标准偏差:20毫秒—中位数:1095毫秒</li><li id="0c79" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">本地Docker —标准偏差:2毫秒—中位数:1045毫秒</li></ul><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/65196b472f052a23e83420c467b8de6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*wRhgxtid1_r0G9vhG8cWYQ.png"/></div></figure><p id="df60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我似乎不能调整水平轴，但请注意，这里显示的整体变化很窄，即使云函数比其他两个更宽。</p><h1 id="c797" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><blockquote class="ld le lf"><p id="398f" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated">埃里克，这很有趣，但这意味着什么呢？</p><p id="9648" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated"><em class="iq">我:我不知道。</em></p></blockquote><p id="0987" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我对云功能是如何实现的了解还不足以推测为什么会出现这种情况。</p><p id="1e53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">乍一看，由于某种原因，从磁盘(或内存中的磁盘？)对于云函数似乎具有不可预测的性能特征。</p><p id="3585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我说不出这到底是为什么。但我可以说，这对我来说是一个足够大的问题，以至于我改用了云运行。</p><p id="8ffd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我真的很好奇，想知道是否有谷歌的人猜测为什么会这样，如果我听到什么，我一定会在这里发布。</p></div></div>    
</body>
</html>