<html>
<head>
<title>JavaScript Clean Code — Function Exceptions and Duplicate Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码—函数异常和重复代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-function-exceptions-and-duplicate-code-b44520643242?source=collection_archive---------9-----------------------#2020-02-28">https://levelup.gitconnected.com/javascript-clean-code-function-exceptions-and-duplicate-code-b44520643242?source=collection_archive---------9-----------------------#2020-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3614368b23806427f6f46e61fa8f3d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hOZffCpcpZ4_YkLE"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@ashishjha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Avinash Kumar </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="27a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数是JavaScript程序的重要组成部分。它们用于将代码分割成主要做一件事的可重用块。</p><p id="6b4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，为了拥有清晰的JavaScript代码，我们必须拥有易于理解的函数。</p><p id="7f0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看到函数的更多部分，包括输出参数、命令查询分离。、抛出异常和重复代码。</p><h1 id="6efa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">输出参数</h1><p id="fc3a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">输出参数是由函数直接返回的参数。</p><p id="6893" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很奇怪，因为参数通常被解释为输入，而不是直接用作输出。这个没有太多的用例。通常，参数是以某种方式计算出来的，方法是组合它们或检查它们，并通过这些检查和操作返回结果。</p><p id="a902" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，如果我们想改变一个共享状态，我们可以把共享状态作为类成员，然后我们可以有方法来操作类成员。</p><p id="ecd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们应该这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1d60" class="mq lf it mm b gy mr ms l mt mu">class FruitStand {<br/>  constructor(numFruits) {<br/>    this.numFruits = numFruits;<br/>  }</span><span id="1946" class="mq lf it mm b gy mv ms l mt mu">  addFruit() {<br/>    this.numFruits++;<br/>  }</span><span id="44c7" class="mq lf it mm b gy mv ms l mt mu">  removeFruit(numFruits) {<br/>    this.numFruits--;<br/>  }<br/>}</span></pre><p id="95f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是返回传入的参数。</p><h1 id="0f52" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">命令查询分离</h1><p id="ddaf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">一个函数要么改变一个对象的状态，要么返回一个对象的一些信息。然而，它不应该两者兼而有之。</p><p id="38af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该有如下的函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5eba" class="mq lf it mm b gy mr ms l mt mu">const setProperty = (obj, property, value) =&gt; {<br/>  obj[property] = value;<br/>  return value;<br/>}</span></pre><p id="aae2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数就地改变<code class="fe mw mx my mm b">obj</code>对象，并返回该值。</p><p id="2467" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它做了两件事，这并不好，而且名字并没有传达出，也返回了一些关于对象的信息。这就误导了这个函数的用户，当他或她没有阅读函数定义，而仅仅是按照名字去做的时候。</p><p id="bcc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，最好将属性设置和返回值分开，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7013" class="mq lf it mm b gy mr ms l mt mu">const setProperty = (obj, property, value) =&gt; {<br/>  obj[property] = value;<br/>}</span><span id="6985" class="mq lf it mm b gy mv ms l mt mu">const getProperty = (obj, property) =&gt; {<br/>  return obj[property];<br/>}</span></pre><p id="628f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像我们上面的那样，让每个函数做一件事情会好得多，这样人们就不会对他们正在做的事情感到困惑。</p><h1 id="95b1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">抛出异常比返回错误代码要好</h1><p id="e714" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">返回错误代码违反了我们上面提到的命令和查询分离规则。这是因为返回某物的函数在出错时返回它，在函数成功运行时返回其他东西。</p><p id="04ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着函数既做一些事情，形成命令部分，又返回一些事情，形成查询部分。</p><p id="bde4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它应该只做一件事。因为函数的主要目的是做一些事情而不是返回一些东西，所以它应该只做命令部分而不是返回一个错误代码。</p><p id="65b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着不要像下面这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f3e8" class="mq lf it mm b gy mr ms l mt mu">const setProperty = (obj, property, value) =&gt; {<br/>  obj[property] = value;<br/>  if (!value) {<br/>    return 'Value not found';<br/>  }<br/>}</span></pre><p id="2732" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该抛出一个异常，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d4d1" class="mq lf it mm b gy mr ms l mt mu">const setProperty = (obj, property, value) =&gt; {<br/>  if (!value) {<br/>    throw new Error('Value not found');<br/>  }<br/>  obj[property] = value;<br/>}</span></pre><p id="4ccb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果需要，我们可以捕捉并处理它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5b5d" class="mq lf it mm b gy mr ms l mt mu">try {<br/>  let obj = {};<br/>  setProperty(obj, 'foo', null)<br/>} catch (ex) {<br/>  console.log(ex);<br/>}</span></pre><p id="936a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mw mx my mm b">try...catch</code>消除大量的错误代码检查条件语句，而不是用if语句来检查函数返回的每个错误代码。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1452ba576baf82932ecf9331cbf8e22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1abq0Z3t4g3CG3Ro"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@averieclaire?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾弗里·伍德阿德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="ad84" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">提取Try…Catch块</h1><p id="60cc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mw mx my mm b">try</code>程序块不应包含正常的加工代码。这是因为这使得我们很难知道错误会被抛出到哪里。</p><p id="7f04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该把我们预计会有错误抛出的代码包装在一个<code class="fe mw mx my mm b">try</code>块中。然后我们可以在它下面写一个<code class="fe mw mx my mm b">catch</code>块来捕捉这个异常。</p><p id="d193" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有正常代码和需要捕获异常的代码，那么我们可以编写如下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="06e0" class="mq lf it mm b gy mr ms l mt mu">const functionThatThrowsError = () =&gt; { //... };<br/>const doSomething = () =&gt; { //... };<br/>const runFunctionThatThrowsError = () =&gt; {<br/>  try {<br/>    functionThatThrowsError();<br/>  } catch (ex) {<br/>    console.log(ex);<br/>  }<br/>}</span><span id="7cb8" class="mq lf it mm b gy mv ms l mt mu">const runEverything = () =&gt; {<br/>  doSomething();<br/>  runFunctionThatThrowsError();<br/>}</span></pre><p id="cde9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将异常抛出和处理代码隔离到它自己的函数中，这让读者清楚地知道特定的抛出了一个需要处理的异常。</p><h1 id="ccef" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要重复自己</h1><p id="9501" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">重复代码绝对是大忌，一个东西变了，重复代码就得多处变。也很容易遗漏重复的代码。</p><p id="f14e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码也变得更加臃肿，因为它们在不同的地方重复。</p><p id="ce9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有很多方法可以消除JavaScript中的重复代码，比如函数和模块。我们应该尽可能多地使用它们。</p><p id="d74f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有重复的对象声明，那么我们也应该使用类作为模板来创建这些对象。</p><p id="c7ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重复的文字应该被赋值给一个常量并重用。</p><h1 id="2c39" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="8c28" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">应该消除输出参数，因为我们不需要用它们来改变JavaScript中的共享状态。</p><p id="1149" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">做某事的函数应该与返回某事的函数分开。</p><p id="1b83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，引发异常的代码比返回错误代码的代码更受欢迎。当我们需要处理异常时，抛出异常的代码应该被分离到它自己的函数中，以表明我们想要处理异常的意图。</p><p id="984a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重复代码是不好的。更改代码需要更多的时间，因为我们必须在多个地方进行更改。我们应该采取措施，通过使用可以在不同地方访问的代码来消除它们。</p></div></div>    
</body>
</html>