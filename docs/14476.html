<html>
<head>
<title>Favoring Composition Over Inheritance: Kotlin’s “by” magic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重创作轻继承:科特林的“by”魔术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/favoring-composition-over-inheritance-kotlins-by-magic-7f7bc8cf166c?source=collection_archive---------1-----------------------#2022-12-01">https://levelup.gitconnected.com/favoring-composition-over-inheritance-kotlins-by-magic-7f7bc8cf166c?source=collection_archive---------1-----------------------#2022-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a5bd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于科特林代表的详尽指南</h2></div><p id="db04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">继承之上的复合是面向对象编程的一个重要设计原则。这使得代码更具可重用性和可维护性。这就是人们常说的OOP原则，比如在很有影响力的书<a class="ae lk" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ll">设计模式:可重用面向对象软件的元素</em> </strong> </a> <strong class="kh ir"> <em class="ll">。</em>T11】</strong></p><p id="5e3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看维基百科是怎么说的:</p><blockquote class="lm ln lo"><p id="2f91" class="kf kg ll kh b ki kj jr kk kl km ju kn lp kp kq kr lq kt ku kv lr kx ky kz la ij bi translated">组合优先于继承的原则是，类应该通过它们的组合(通过包含实现所需功能的其他类的实例)而不是从基类或父类继承来实现多态行为和代码重用。—维基百科</p></blockquote><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/599ad8d6fa1b0f35b555fa1b14339d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DzS1kEdyl-_l_9ai"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">由<a class="ae lk" href="https://unsplash.com/@varpap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vardan Papikyan </a>在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5b47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看到如何利用Kotlin委托来实现合成</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="d6ec" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">遗传有什么问题？</h2><p id="1280" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">继承是一个强大的特性，但是它被设计用来创建一个具有“是”关系的对象层次结构。当这种关系不明确时，继承可能会有问题，应该谨慎执行。以下是继承实现的常见问题:</p><ol class=""><li id="f5b7" class="nn no iq kh b ki kj kl km ko np ks nq kw nr la ns nt nu nv bi translated">继承在父类和它的子类之间创建了一个强关系，并产生了紧密耦合的代码。继承一个类将子类与父类的实现细节联系起来，因此当父类中的代码发生变化时，所有的子类可能都需要更新。</li><li id="31c0" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated">使用一个父类来保存所有的公共代码片段违反了单一责任原则，最终导致代码混乱</li><li id="5ab7" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated">当类是封闭的或最终的时，实现继承来扩展类的功能是不可能的</li></ol><p id="4d21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们需要的只是简单的代码提取或重用时，应该谨慎使用继承；相反，我们应该更喜欢一个更轻松的选择:课堂作文。</p><h2 id="f4a0" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">实现组合</h2><p id="6816" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">通过委托，可以使组合像继承一样对代码重用具有强大的功能。委托本质上意味着将请求转移或转发给相关的委托对象。委托下的两个对象处理一个请求:接收对象将任务委托给它的委托人，然后委托人处理请求。</p><p id="9985" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ll">委托模式</em>是一种流行的设计模式，其中父对象将请求传递给子对象<em class="ll">委托对象</em>。这提供了通过继承类似地实现的代码重用，同时还实施了“单一责任原则”,该原则允许父节点保持对请求如何执行的不可知。</p><p id="a40a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lk" href="https://en.wikipedia.org/wiki/Delegation_pattern" rel="noopener ugc nofollow" target="_blank">委托模式</a>已经被证明是实现继承的一个很好的替代方案，Kotlin本身就支持它，不需要任何样板代码。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="b9f0" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">什么是科特林代表团？</h2><p id="25dd" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">Kotlin添加了一个名为<code class="fe ob oc od oe b">“by”</code>的新关键字来支持“委托”设计模式。可用于<strong class="kh ir">财产委托</strong>或<strong class="kh ir">委托</strong>执行。</p><p id="e2ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ob oc od oe b">“by”</code>既可以用于委托接口实现，也可以用于属性委托接口实现。我们将在下面看看这两个。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="25e0" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">委托接口实现</h2><p id="542c" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">看看下面的代码:</p><pre class="lt lu lv lw gt of oe og bn oh oi bi"><span id="aea7" class="oj mq iq oe b be ok ol l om on">interface BaseCar {<br/>    fun color()<br/>    fun maxSpeed()<br/>}<br/><br/>class BaseCarImpl(val color: String) : BaseCar {<br/>    override fun color() { print(color) }<br/>    override fun maxSpeed() { print("250") }<br/>}<br/><br/>class Derived(b: BaseCar) : BaseCar by b<br/><br/>fun main() {<br/>    val b = BaseCarImpl("Green")<br/>    Derived(b).color()<br/>}</span></pre><p id="7617" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，类<code class="fe ob oc od oe b">Derived</code>实现了接口<code class="fe ob oc od oe b">BaseCar</code>，但是它不需要覆盖接口的任何方法。<code class="fe ob oc od oe b">Derived</code>类只是将传入的请求委托给实际的实现，在本例中是<code class="fe ob oc od oe b">BaseCarImpl</code>。如果我们看到上面代码的输出，我们会在控制台中看到“绿色”字样</p><p id="7ed0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过覆盖<code class="fe ob oc od oe b">Derived</code>类中所需的方法来进一步定制行为。检查下面的代码:</p><pre class="lt lu lv lw gt of oe og bn oh oi bi"><span id="348d" class="oj mq iq oe b be ok ol l om on">class Derived(b: BaseCar) : BaseCar by b{<br/>    override fun color() { print("Red") }<br/>}<br/><br/>fun main() {<br/>    val b = BaseCarImpl("Green")<br/>    Derived(b).color()<br/>}</span></pre><p id="42e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们将“红色”作为控制台中的输出。<code class="fe ob oc od oe b">Derived</code>类不会将请求委托给委托对象，因为我们已经覆盖了<code class="fe ob oc od oe b">Derived</code>类中方法<code class="fe ob oc od oe b">color()</code>的行为。</p><p id="0609" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个委托实现在Android的<code class="fe ob oc od oe b">BaseActivity</code>类中特别有用，该类通常是为了保存公共代码而创建的。仅仅使用<code class="fe ob oc od oe b">BaseActivity</code>来保存公共的代码片段违反了单一责任原则，而且我们最终会暴露父类的API，而所有的子类可能都不需要这些API。</p><p id="68cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看一个更现实的例子:</p><p id="f34c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们为我们的产品定义了两种类型的用户层:免费层<strong class="kh ir">和付费层<strong class="kh ir"/>。因此，为了在应用程序端处理这个问题，我们可以有一个名为<code class="fe ob oc od oe b">Tier</code>的接口，以及付费和免费层的相应实现:<code class="fe ob oc od oe b">FreeTierImpl</code>和<code class="fe ob oc od oe b">PaidTierImpl</code>。我们最终的代码看起来会像这样:</strong></p><pre class="lt lu lv lw gt of oe og bn oh oi bi"><span id="c834" class="oj mq iq oe b be ok ol l om on">interface Tier {<br/>    fun getLicenseType() : Int<br/>    fun numberOfFeatureAvailable() : Int<br/>}<br/><br/>class FreeTierImpl() : Tier {<br/>    override fun getLicenseType() : Int { return 1 }<br/>    override fun numberOfFeatureAvailable() : Int { return 2 }<br/>}<br/><br/>class PaidTierImpl() : Tier {<br/>    override fun getLicenseType() : Int { return 2 }<br/>    override fun numberOfFeatureAvailable() : Int { return 4 }<br/>}<br/><br/>class CompositeService(val tier: Tier, val messagingServ: MessagingService) : Tier by tier<br/>, MessagingService by messagingServ{<br/>    <br/>}<br/><br/>fun main() {<br/>    val service = CompositeService(PaidTierImpl(), UserMessagingSErvice())<br/>    service.numberOfFeatureAvailable()<br/>}</span></pre><p id="fd58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ob oc od oe b">CompositeService</code>仅聚合两个服务层和MessagingService，但它不知道为计算功能数量的许可证而实施的业务逻辑。<code class="fe ob oc od oe b">CompositeService</code>类的构造函数中的参数可以通过一些DI逻辑注入</p><p id="9526" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一节中，我们将研究<strong class="kh ir">属性委托</strong></p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="587c" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">财产委托</h2><p id="8954" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">对于一些常见类型的属性，即使我们可以在每次需要时手动实现它们，但更有帮助的是实现一次，将它们添加到库中，并在以后重用它们。我们可以创建自己的自定义属性委托，但为了本文的简洁，我们将研究Kotlin提供的一些现成的标准委托。Kotlin标准库为几种有用的委托提供了工厂方法。</p><h2 id="8c2b" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">1.懒惰的财产</h2><p id="5b1b" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated"><code class="fe ob oc od oe b">lazy()</code>是一个函数，接受一个lambda并返回一个<code class="fe ob oc od oe b">Lazy&lt;T&gt;</code>的实例，它可以作为实现一个lazy属性的委托。对<code class="fe ob oc od oe b">get()</code>的第一次调用执行传递给<code class="fe ob oc od oe b">lazy()</code>的lambda并记住结果。随后对<code class="fe ob oc od oe b">get()</code>的调用只是返回记忆的结果。这对于那些计算起来很昂贵并且我们可能永远都不需要的属性来说是很有用的。查看下面的示例:</p><pre class="lt lu lv lw gt of oe og bn oh oi bi"><span id="10e9" class="oj mq iq oe b be ok ol l om on">class UserDb(userId: String) {<br/>    val name: String by lazy {<br/>        queryForValue("SELECT name FROM users_table WHERE id = :id", mapOf("id" to userId)<br/>    }<br/>}</span></pre><h2 id="3995" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">2.Delegates.observables()</h2><p id="0a68" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated"><code class="fe ob oc od oe b">Delegates.observable()</code>接受两个参数:初始值和修改处理程序。</p><p id="fdbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当我们改变属性时(在赋值被执行后<em class="ll">，处理程序被调用。Lambda有三个参数:被赋值的属性、旧值和新值。</em></p><pre class="lt lu lv lw gt of oe og bn oh oi bi"><span id="b76f" class="oj mq iq oe b be ok ol l om on">class ObservedProperty {<br/>    var name: String by Delegates.observable("Initia value") {<br/>        prop, old, new -&gt; println("Old value: $old, New value: $new")<br/>    }<br/>}</span></pre><h2 id="8187" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">3.在地图中存储属性</h2><p id="a022" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">一个常见的用例是在地图上保存属性值。这通常发生在解析JSON或执行其他动态操作的应用程序中。这里，map实例本身可以充当委托属性的委托。请看下面的代码示例:</p><pre class="lt lu lv lw gt of oe og bn oh oi bi"><span id="81bf" class="oj mq iq oe b be ok ol l om on">class DelegateMapExample(map: MutableMap&lt;String, Any?&gt;) {<br/>    var name: String by map<br/>    var license: Int by map<br/>}<br/><br/>fun main() {<br/>    val data = DelegateMapExample(mapOf(<br/>        "name" to "USP",<br/>        "license" to 4<br/>    ))<br/>    println(data.name)<br/>}</span></pre><p id="4449" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码的输出将是“USP”。委派属性使用与属性名称相关联的字符串键从该映射中获取值。</p><h2 id="2336" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">最后的想法</h2><p id="0412" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">属性委托和委托实现是Kotlin提供的强大特性。我希望这篇文章已经激发了你去利用它们。</p><p id="dd4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就把我们带到了文章的结尾。我希望你觉得这东西有用。既然您已经阅读了这篇文章，请点击“鼓掌”按钮，继续阅读更多这样的文章</p><h2 id="5862" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">参考资料:</h2><p id="4ca7" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated"><a class="ae lk" href="https://kotlinlang.org/docs/delegation.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/delegation.html</a></p><p id="8ddb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">https://kotlinlang.org/docs/delegated-properties.html<a class="ae lk" href="https://kotlinlang.org/docs/delegated-properties.html" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>