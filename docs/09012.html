<html>
<head>
<title>Frontend driven design analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端驱动的设计分析</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/frontend-driven-design-analysis-3cb0697d8f01?source=collection_archive---------2-----------------------#2021-06-28">https://levelup.gitconnected.com/frontend-driven-design-analysis-3cb0697d8f01?source=collection_archive---------2-----------------------#2021-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4dcd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在创建设计或分析设计需求时，作为前端开发人员进行思考</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/9598489cc02f377759a5c5769f032c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*eWDc__iPfBjxyExg7LpiqA.png"/></div></figure><h1 id="eaf9" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">从设计到产品</h1><p id="2527" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从设计到最终产品的过程包括</p><ol class=""><li id="6487" class="mb mc iq lh b li md ll me lo mf ls mg lw mh ma mi mj mk ml bi translated">设计的创造</li><li id="3285" class="mb mc iq lh b li mm ll mn lo mo ls mp lw mq ma mi mj mk ml bi translated">设计分析</li><li id="40cd" class="mb mc iq lh b li mm ll mn lo mo ls mp lw mq ma mi mj mk ml bi translated">制定组件的要求</li><li id="4bf7" class="mb mc iq lh b li mm ll mn lo mo ls mp lw mq ma mi mj mk ml bi translated">组件的实现</li></ol><p id="88a0" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">正如我们所看到的，设计的创建和组件的实现之间有很大的差距。我们将组件定义为一个封装的功能块。这可以小到一个按钮，也可以大到一个表单。一个页面被分成逻辑单元，我们称之为组件。</p><p id="02e8" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">如何解释某个设计通常很简单，但不太清楚的是，在不同的内容或不同的屏幕尺寸下，该设计应该如何变得生动。因此，我们可以通过教授如何实现组件以及如何自动化某些设计规则来缩小差距。应该注意的是，我们试图实现一个CSS优先的方法。</p><p id="4568" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">我们希望通过这种方法实现的主要目标如下</p><ol class=""><li id="a8e6" class="mb mc iq lh b li md ll me lo mf ls mg lw mh ma mi mj mk ml bi translated">组件应<strong class="lh ir">一致</strong></li><li id="252c" class="mb mc iq lh b li mm ll mn lo mo ls mp lw mq ma mi mj mk ml bi translated">组件应该对任何内容和屏幕尺寸做出<strong class="lh ir">响应</strong></li><li id="8c10" class="mb mc iq lh b li mm ll mn lo mo ls mp lw mq ma mi mj mk ml bi translated"><strong class="lh ir">元素之间的间距</strong>应该均匀</li></ol><p id="09dd" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">考虑到这一点，下面的陈述应该是主要的指导方针。</p><blockquote class="mu"><p id="0950" class="mv mw iq bd mx my mz na nb nc nd ma dk translated">实现应该基于设计规则，而不是绝对值</p></blockquote><h1 id="0279" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ne jx kz jz nf ka lb kc ng kd ld le bi translated">组件应该一致</h1><p id="7759" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">组件(变体)的每个实例都应该遵循相同的规则。这意味着您应该以这样一种方式来分析需求，即它们适合组件的所有出现。</p><p id="37a4" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">任何无意的偏差都应该与设计师讨论和协调，以确保我们创建一个可维护的系统。</p><h1 id="bc79" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">组件应该对任何内容和屏幕尺寸做出响应</h1><p id="51b2" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如今，一个网站可以在过多的屏幕上浏览。我们需要确保无论网站在多大的屏幕上显示，都没有视觉上的瑕疵。</p><p id="62af" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">最重要的是，大多数应用程序都由某种CMS支持。因此，组件应该能够处理任何类型的内容。</p><p id="61bc" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">我们应该问的主要问题是</p><blockquote class="mu"><p id="5338" class="mv mw iq bd mx my mz na nb nc nd ma dk translated">如果…会发生什么</p></blockquote><ul class=""><li id="60ee" class="mb mc iq lh b li nh ll ni lo nj ls nk lw nl ma nm mj mk ml bi translated">屏幕更小</li><li id="dee6" class="mb mc iq lh b li mm ll mn lo mo ls mp lw mq ma nm mj mk ml bi translated">屏幕更大</li><li id="902b" class="mb mc iq lh b li mm ll mn lo mo ls mp lw mq ma nm mj mk ml bi translated">组件是嵌入的</li><li id="d891" class="mb mc iq lh b li mm ll mn lo mo ls mp lw mq ma nm mj mk ml bi translated">还有更多内容</li><li id="6587" class="mb mc iq lh b li mm ll mn lo mo ls mp lw mq ma nm mj mk ml bi translated">内容少了</li><li id="834a" class="mb mc iq lh b li mm ll mn lo mo ls mp lw mq ma nm mj mk ml bi translated">没有内容</li></ul><h1 id="fe6c" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated"><strong class="ak">元素之间的间距</strong>应一致</h1><p id="6cdd" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">理想情况下，组件是独立创建的，但是一旦我们开始组合页面，这就会产生问题。因此，我们需要考虑一个组件将如何与其兄弟组件交互。最好从所有组件之间的默认间距开始，然后使用以下一种或多种方法进行扩展。</p><h2 id="e3d1" class="nn ko iq bd kp no np dn kt nq nr dp kx lo ns nt kz ls nu nv lb lw nw nx ld ny bi translated">相对于字体大小的方法</h2><p id="6910" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们看文本时，标题通常意味着一个新的部分。为了形象化这个新部分，在标题上方增加了更多的空间。标题越大，间距越大。这个逻辑允许我们定义每个元素顶部相对于该元素字体大小的间距。HTML中的每个元素都有字体大小，不仅仅是文本元素，所以这可以应用于所有组件。我们可以用下面这段CSS对每个前面有元素的元素应用这个方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">任何有在先元素的元素都将获得相对于其字体大小的上边距</figcaption></figure><p id="7da4" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">试试看:<a class="ae of" href="https://codepen.io/RobinAlaerts/full/bGqzJLz" rel="noopener ugc nofollow" target="_blank">https://codepen.io/RobinAlaerts/full/bGqzJLz</a></p><h2 id="b346" class="nn ko iq bd kp no np dn kt nq nr dp kx lo ns nt kz ls nu nv lb lw nw nx ld ny bi translated">特定组件方法</h2><p id="dcbe" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当您知道某个组件需要比平常更多的间距时，您可以专门为此组件定义间距。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">目标元素将获得特定的上边距</figcaption></figure><h2 id="2147" class="nn ko iq bd kp no np dn kt nq nr dp kx lo ns nt kz ls nu nv lb lw nw nx ld ny bi translated">组件组合方法</h2><p id="9ce5" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这种方法更难预测，但在某些情况下是可行的。假设你想要两个组件之间有一个特定的空间，你可以确保这个空间总是被尊重。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">如果组件X位于组件Y之前，组件Y将获得特定的上边距</figcaption></figure><h1 id="51c0" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">例子</h1><h2 id="c977" class="nn ko iq bd kp no np dn kt nq nr dp kx lo ns nt kz ls nu nv lb lw nw nx ld ny bi translated">容器</h2><p id="7bb8" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们看看容器的第一个例子，它可以是横幅、卡片、文章……任何包含内容的容器都可以应用于此。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi og"><img src="../Images/8fc7c8baadc0a51ed7d480b43a952123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6n8P8mf1frA0dBIi2niGBg.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">通用横幅示例</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi ol"><img src="../Images/578d66dc926b9585cadca50d80658982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VExkQlx089Fr5mur63PrQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi og"><img src="../Images/b926e471a0ed098c163b97c71df28522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E86zZO3YVdtvN4LWuvAygA.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">带有可见规则的通用横幅</figcaption></figure><p id="4be1" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">如果我们定义了正确的设计规则(左)，那么它将应用下面的例子。然而，如果我们选择了错误的设计规则(正确的)，每个横幅都需要自己的规格。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi om"><img src="../Images/59bf4311975a96213401b3b7949612bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DolG0uR91qg4hYEy_F1B8w.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">不同内容的横幅示例</figcaption></figure><p id="f8e0" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">试试看:【https://codepen.io/RobinAlaerts/full/wvgNBpP T2】</p><h2 id="6355" class="nn ko iq bd kp no np dn kt nq nr dp kx lo ns nt kz ls nu nv lb lw nw nx ld ny bi translated">小跟班</h2><p id="db2d" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是按钮的第二个例子。我添加了一个带有图标的例子来展示灵活规则的重要性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi on"><img src="../Images/cf6212423cc48dad96e7fee4c4501ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBvLRbT6-D8RvojEK-Do_Q.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">按钮的示例</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi ol"><img src="../Images/d6d1e6ac33938fcc88e81b88254cac7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtIHTJVmh87dPWjvmwkpPA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/0f342dc46e7b45d814d5920979fcd1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*q_F0y2ejcejh6X8Oq-FAWQ.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">具有可见规则的按钮</figcaption></figure><p id="291f" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">不正确的设计规则(右)仅适用于第一个按钮(文本ok)，而正确的规则(左)适用于所有实例。这条规则甚至支持全角按钮和图标。</p><p id="fdaa" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">试试吧欧:【https://codepen.io/RobinAlaerts/full/qBreNbX】</p><h2 id="bcf0" class="nn ko iq bd kp no np dn kt nq nr dp kx lo ns nt kz ls nu nv lb lw nw nx ld ny bi translated">网格</h2><p id="1e9d" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在分析网格时，有一种方法可以避免为每个断点定义网格。我们将定义列的最小宽度以及列和行之间的间距，而不是说我们期望在每个断点上有多少列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi op"><img src="../Images/85317c6287b7520646c72bf929d783a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsQ-5ARyO9wswm5yEGAn9A.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi ol"><img src="../Images/c0f79e3ceae6a9e65d014df0fe7ecf4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNoYLXbnk80qRJfnroaCqA.png"/></div></div></figure><p id="7473" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">只要满足所需的最小宽度，网格将尝试在一行中容纳尽可能多的列。行为有两种类型，<code class="fe oq or os ot b">auto-fit</code>和<code class="fe oq or os ot b">auto-fill</code>。第一个会在可能的情况下不断添加列，即使这些列中没有要放置的项目。第二种方法将只添加与填充这些列的项目一样多的列。如果没有更多的项目，网格将拉伸现有的列，而不是添加新的列。</p><p id="c427" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">这种方法的优点是网格现在独立于断点。网格列将根据网格的大小而不是屏幕宽度来增长或收缩。例如，当你的网格被嵌入到一个弹出窗口中，并且它不再与屏幕大小相关时，这是很有用的。</p><p id="1756" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">使用下面的CSS代码可以很容易地实现这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="35ea" class="pw-post-body-paragraph lf lg iq lh b li md jr lk ll me ju ln lo mr lq lr ls ms lu lv lw mt ly lz ma ij bi translated">试试看:【https://codepen.io/RobinAlaerts/full/vYypNJj T2】</p><h1 id="1cc0" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">测量两次，切割一次</h1><p id="cede" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过实施简单、一致且可扩展的规则，我们避免了过多的迭代并防止了设计的不一致性。让您的设计师、分析师和开发人员步调一致，缩短上市时间。</p></div></div>    
</body>
</html>