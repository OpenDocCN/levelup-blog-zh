<html>
<head>
<title>JavaScript Best Practices — Numbers, Bad Features, and Conditionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践——数字、坏特性和条件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-numbers-bad-features-and-conditionals-bdd821021ba9?source=collection_archive---------37-----------------------#2020-06-29">https://levelup.gitconnected.com/javascript-best-practices-numbers-bad-features-and-conditionals-bdd821021ba9?source=collection_archive---------37-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d18374706d2eedace3a13a6bf4220bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TlIOJKufO_3DF2YQ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@tlholly?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Terrah Holly </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="51cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看在操作数字和条件时应该遵循的一些最佳实践。</p><p id="ede9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也看到了我们不应该使用的糟糕的JavaScript特性。</p><h1 id="c78a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用断路器防止开关箱中的故障</h1><p id="e92f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该在每个<code class="fe mh mi mj mk b">case</code>块或语句的末尾添加<code class="fe mh mi mj mk b">break</code>，以防止匹配案例下面的案例运行。</p><p id="86ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，与其写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0f51" class="mt lf it mk b gy mu mv l mw mx">switch (val) {<br/>  case 1:<br/>    foo()<br/>  case 2:<br/>    bar()<br/>}</span></pre><p id="9369" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b9b2" class="mt lf it mk b gy mu mv l mw mx">switch (val) {<br/>  case 1:<br/>    foo();<br/>    break;         <br/>  case 2:<br/>    bar();<br/>    break;<br/>}</span></pre><h1 id="a1f4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">无浮动小数</h1><p id="2f5f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们想写一个介于0和1之间的小数，我们应该从一个十进制数的0开始。</p><p id="9a6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它让每个人都明白这是一个十进制数，尽管JavaScript并不要求这样。</p><p id="0aad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d09e" class="mt lf it mk b gy mu mv l mw mx">const tax = .5;</span></pre><p id="2521" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5a57" class="mt lf it mk b gy mu mv l mw mx">const tax = 0.5;</span></pre><h1 id="9442" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有重新分配给函数声明</h1><p id="dafa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该给函数声明重新赋值。覆盖函数声明的值通常是一个错误或问题。如果我们希望能够改变这个值，我们应该使用一个函数表达式。</p><p id="ccb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="808f" class="mt lf it mk b gy mu mv l mw mx">function foo () { };<br/>foo = otherFunc;</span></pre><h1 id="f555" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要给全局变量赋值</h1><p id="f848" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">像<code class="fe mh mi mj mk b">window</code>和<code class="fe mh mi mj mk b">process</code>这样的全局变量是为了使用。我们不想给它重新赋值，因为它会覆盖对象，我们不会再得到任何我们需要的属性。</p><p id="d08b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该编写这样的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b697" class="mt lf it mk b gy mu mv l mw mx">window = {};</span></pre><h1 id="f2b3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有隐含的评估调用</h1><p id="7987" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">除了<code class="fe mh mi mj mk b">eval</code>，还有<code class="fe mh mi mj mk b">Function</code>构造函数、<code class="fe mh mi mj mk b">setTimeout</code>和<code class="fe mh mi mj mk b">setInterval</code>，它们也接受字符串并作为代码运行。</p><p id="e2f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="74ac" class="mt lf it mk b gy mu mv l mw mx">const fn = new Function('a', 'console.log(a)');</span></pre><p id="5284" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d31a" class="mt lf it mk b gy mu mv l mw mx">setTimeout('console.log("foo")')</span></pre><p id="57a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6891" class="mt lf it mk b gy mu mv l mw mx">setTimeout('console.log("foo")', 2000)</span></pre><p id="6072" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些都是有效的，并导致字符串中的代码被运行。这是一个安全风险，因为我们可以从字符串运行代码。字符串中的代码很难调试。此外，它们不能被优化，因为它们在一个字符串中。</p><p id="5450" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该只写代码。</p><p id="fc01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="81a6" class="mt lf it mk b gy mu mv l mw mx">setTimeout(() =&gt; console.log("foo"), 2000)</span></pre><h1 id="a686" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">嵌套块中没有函数声明</h1><p id="07db" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数声明应该只在顶层。</p><p id="99b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript允许它出现在块中，但它不应该出现在那里。</p><p id="6791" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该有这样的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cf79" class="mt lf it mk b gy mu mv l mw mx">if (authenticated) {<br/>  function doSomething () {}<br/>}</span></pre><h1 id="92b0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">RexExp构造函数中的正则表达式字符串内没有无效的正则表达式</h1><p id="4b6a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们使用<code class="fe mh mi mj mk b">RegExp</code>构造函数创建正则表达式时，确保我们在字符串中有有效的正则表达式。</p><p id="800e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="727e" class="mt lf it mk b gy mu mv l mw mx">const re =new RegExp('[a-z');</span></pre><p id="93db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c557" class="mt lf it mk b gy mu mv l mw mx">const re =new RegExp('[a-z]');</span></pre><h1 id="3b0e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有不规则的空白</h1><p id="bd1b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该在代码中使用普通的空白字符，以避免在不同的运行时环境中解析它的问题。</p><p id="9887" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不应该有这样的事情:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9ef0" class="mt lf it mk b gy mu mv l mw mx">function foo () /*&lt;NBSP&gt;*/{}</span></pre><h1 id="88ac" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用__迭代器_ _</h1><p id="889e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">属性<code class="fe mh mi mj mk b">__iterator__</code>不是JavaScript对象创建迭代器函数的标准属性。</p><p id="ffd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该使用<code class="fe mh mi mj mk b">Symbol.iterator</code>属性。</p><p id="f295" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不应该写这样的话:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e695" class="mt lf it mk b gy mu mv l mw mx">Foo.prototype.__iterator__ = function () {}</span></pre><p id="541c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f62c" class="mt lf it mk b gy mu mv l mw mx">const obj = {<br/>  *[Symbol.iterator](){<br/>    //...<br/>  }<br/>}</span></pre><p id="8a25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="668b" class="mt lf it mk b gy mu mv l mw mx">class Foo {<br/>  *[Symbol.iterator](){<br/>    //...<br/>  }<br/>}</span></pre><h1 id="f207" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有标签与范围内变量共享一个名称</h1><p id="3d37" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该让循环的标签与循环范围内的变量同名。</p><p id="07d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给译员和我们都造成了困惑。</p><p id="e379" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c672" class="mt lf it mk b gy mu mv l mw mx">let score = 100;<br/>const foo = () =&gt; {<br/>  score: while (true) { <br/>    score -= 10;<br/>    if (score &gt; 0) continue score;<br/>    break;<br/>  }<br/>}</span></pre><h1 id="5385" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有标签语句</h1><p id="6090" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">标签语句是用一个名字来标记循环，所以我们可以用它来做一些循环操作，比如<code class="fe mh mi mj mk b">continue</code>和<code class="fe mh mi mj mk b">break</code>。</p><p id="523b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是JavaScript中很少使用的特性。</p><p id="17ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们很可能不想使用它。</p><p id="8a20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不应该有这样的事情:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e4da" class="mt lf it mk b gy mu mv l mw mx">label:<br/>  while (true) {<br/>    break label     <br/>  }</span></pre><h1 id="a524" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有不必要的嵌套块</h1><p id="b677" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该有无用的嵌套块。</p><p id="36c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嵌套代码更难阅读，无用的嵌套更糟糕。</p><p id="7c09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以与其写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="07d9" class="mt lf it mk b gy mu mv l mw mx">function foo () {<br/>  {                  <br/>    bar()<br/>  }<br/>}</span></pre><p id="5365" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="829e" class="mt lf it mk b gy mu mv l mw mx">function foo  () {<br/>  bar();<br/>}</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/b26d3c561a13a60e6585f0e2d17abd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R2rACtAicdGcWo5y"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@alex_andrews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山大·安德鲁斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="bbce" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="5143" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该避免非标准的和很少使用的结构。</p><p id="61a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不应该有导致混乱的不必要的代码。</p></div></div>    
</body>
</html>