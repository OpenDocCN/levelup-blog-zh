<html>
<head>
<title>Rethinking Web APIs to be Dynamic and Run-Time Adaptable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新思考Web APIs的动态性和运行时适应性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/re-thinking-web-apis-to-be-dynamic-and-run-time-adaptable-a1e9fb43cc4?source=collection_archive---------3-----------------------#2020-04-02">https://levelup.gitconnected.com/re-thinking-web-apis-to-be-dynamic-and-run-time-adaptable-a1e9fb43cc4?source=collection_archive---------3-----------------------#2020-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c2eb008cb3a9020f49b5a63e56d95011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAHAoshtMsTbO85p71AKQQ.jpeg"/></div></div></figure><h1 id="06ee" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="9368" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">所有web应用程序最重要的方面之一是应用程序编程接口(API)，因为它是一种粘合剂，允许给定通信通道的两端确切地知道该做什么。因为API的健壮性、可伸缩性和可靠性非常重要，所以大量的<em class="lu">人工</em>工作都投入到了维护静态API上。事实上，<a class="ae lv" href="https://www.google.com/search?rlz=1C1CHBF_enUS857US857&amp;ei=d0KFXq29AcnQ-gSH8ZuQBg&amp;q=api+designer+jobs&amp;oq=api+designer+jobs&amp;gs_lcp=CgZwc3ktYWIQAzICCAA6BAgAEEc6BAgAEEM6BQgAEIMBOgkIABBDEEYQ-wE6BwgAEIMBEEM6CQgAEEMQRhD5AToFCAAQkQI6BggAEBYQHlC5oRBYr8QQYOPMEGgAcAJ4AIABuQGIAYoSkgEEMC4xN5gBAKABAaoBB2d3cy13aXo&amp;sclient=psy-ab&amp;ved=0ahUKEwjt1LKLzsjoAhVJqJ4KHYf4BmIQ4dUDCAs&amp;uact=5" rel="noopener ugc nofollow" target="_blank">许多</a>科技公司为设计和维护API留出了全职岗位<em class="lu">只是</em>。这些年来，我们显然忽略了一个问题:API从来就不应该是静态的。</p><p id="b8ba" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">可以说，一个给定的web应用程序的好坏取决于它能够访问和显示的数据。虽然我们很幸运地生活在一个充满数据来源的世界，但我们最终只会使用我们可以访问的数据源(因此，从数学上来说，可能只占世界数据的很小一部分)。通常，每个数据源都有自己独特的API需求，每当要使用新的数据源时，这就成了一个大麻烦。通常，它需要足够的时间来阅读冗长的API文档，迭代与API一样健壮的代码，并让开发人员远离待办事项中的其他任务。每次新加入一个数据提供者都会产生这种时间和开发成本。</p><p id="b474" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">即使一个应用程序只需要关注一个数据源，比如它自己的后端，现有的API模型仍然会使迭代变得不必要的耗时。我认为，一个只依赖于一个数据源的web应用程序可能会很快变成一个非常无聊的应用程序，因为通常情况下，它的用户需要不断的参与和不同种类的刺激。</p><p id="dfa5" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">让我们分析一下我认为最常用的API模型:(大大简化)</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/26e384bad7c94a841b19d37e7ccf2f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*skwFyfHj9OewJhvP.png"/></div></div></figure><p id="cbcb" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在这个模型中，我是这样看的:</p><ul class=""><li id="3417" class="mg mh iq ky b kz lw ld lx lh mi ll mj lp mk lt ml mm mn mo bi translated">服务器<em class="lu">拥有API，客户端开发者必须及时更新冗长的API文档</em></li><li id="e093" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated">客户端发出<em class="lu">请求</em>，服务器<em class="lu">响应</em></li><li id="2ae4" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated">客户端期待一个单独的<em class="lu">响应</em>，因此如果在服务器执行所请求的服务时发生了什么，它将不会被传递回客户端。此模型中没有通知，只有响应。</li><li id="014f" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated">通信是单向的；请求是单向的，响应是双向的。</li><li id="0756" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated">当服务器的API改变时，所有的客户端在更新它们的请求方法<em class="lu">之前<em class="lu">被阻止</em>与服务器通信，除非</em>服务器提供对<em class="lu">以前</em>版本的访问。这是一个可怕的模型，因为它不可靠，或者即使可靠，它也是昂贵的，因为服务器必须维护所有版本的代码，以便老客户可以使用它。较新版本的代码<em class="lu">包括错误修复</em>和其他<em class="lu">增强</em>，所以无论如何，客户坚持使用旧的错误代码可能会适得其反。</li></ul><p id="885e" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">退一步来真正思考一下我们在网络上的交流点是什么样子可能会更有益。下图对此进行了说明。在图中，我仍然使用术语“服务器”和“客户端”,因为这是大家仍然熟悉的，但我更喜欢用术语“IO节点”来表示每个点。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/2eaf4735a025668d2bb61faf06f5eece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_VInV7Omyo7ySZff.png"/></div></div></figure><p id="9da0" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这张图片缩小了之前的模型，以考虑给定网络上的许多IO节点。以下是如何看待这一模式:</p><ul class=""><li id="d54a" class="mg mh iq ky b kz lw ld lx lh mi ll mj lp mk lt ml mm mn mo bi translated">每条线代表双向IO</li><li id="584b" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated">每个客户端和服务器都可以看作IO <em class="lu">节点</em></li><li id="9aa4" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated">每个IO <em class="lu">节点</em>可以在任何给定时间发出或监听事件。因此，每个节点都可以拥有自己的<em class="lu">API，它希望在任何给定的时间点公开这些API。是的，<em class="lu">客户端</em>可以有一个API。</em></li><li id="3141" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated">由于这些事件在运行时<em class="lu">已知</em>，每一方都可以传递它可以发出和监听的事件；即，每个节点可以传送<em class="lu">其</em> API。这意味着如果一个外部IO节点出现，由“服务器3”表示，它可以将它的API 传送给任何或所有节点，并且那些节点将知道如何与那个新节点通信，所有这些都不需要事先知道它的API。</li><li id="6763" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated">然而，更重要的是，每个节点可以传达其<em class="lu">节点类型</em>，这样，如果两个节点相同，它们可以被认为是<em class="lu">对等方</em>，并且可以推断出对等方一定<em class="lu">已经知道</em>彼此的API。</li><li id="54a9" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated">这个模型<em class="lu">只有</em>像各方必须同意的API <em class="lu">格式</em>一样健壮，但是如果格式<em class="lu">简单</em>就可以工作！</li></ul><h1 id="e4c4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">一点题外话</h1><p id="bee7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我喜欢把客户机和服务器想象成相隔很远的物理距离。事实上，这已经是真的了，因为通信必须穿越长长的电缆、卫星的反弹等等。客户端可以从服务器获得的响应应该需要一些时间。然而，我喜欢采取更极端的观点。我喜欢把客户想象成去一个完全不同的星球旅行的人，比如火星或冥王星。那个客户端会离得更远，为了生存，她必须不断地与地球上的IO服务器通信。</p><p id="f81a" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在她天文旅行的几年里，这种交流的双方很可能会以某种方式发生变化，双方都必须适应彼此的交流。我们亲爱的宇航员将没有机会熟悉最新的API文档，她将不得不简单地处理服务器发送给她的任何东西。她<em class="lu">观察到的</em>所说的“最新API”从地球的角度来看已经是几个旧版本了(物理学)，所以也许如果服务器只能维护几个以前的版本，她就有机会幸存下来。</p><p id="8753" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这可能是一个极端的模型，但仍然可以应用于我们的网络不断变化的需求和API。当去遥远星球旅行的时候，我们会做好准备。</p><h1 id="cc7d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">KISS动态API格式</h1><p id="e04d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果我可以引用60年代一个古老而有价值的首字母缩略词的话，<a class="ae lv" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank">“KISS”</a>，“KISS原则指出，大多数系统如果保持简单而不是变得复杂，它们会工作得最好；因此，简单应该是设计的关键目标，应该避免不必要的复杂。”-维基百科</p><p id="1b94" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这是我设计的“KISS动态API格式”的设计目标。如果高级格式的描述不适合便利贴，那就违背了KISS原则。概括地说，KISS格式如下所示:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/ac0f1b35976fb8ac72059ca8fc3745a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vLWCcR_2LFuZtdPKHVm3A.png"/></div></div></figure><p id="16a4" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在最高级别，格式很简单:每个IO节点指定其标签和版本。如果进行通信的给定节点呈现与另一个节点相同的标签和版本，则它可以被认为是<em class="lu">对等方</em>，此时，该节点将不需要任何额外的信息。同行已经知道对方的能力。然而，不是对等节点的节点<em class="lu">会</em>需要更多的信息:支持的事件和方法。(注:这里讨论的重点是IO模型。可以实现一个独立的安全模型来帮助验证IO节点是否是他们所说的那样)</p><p id="1ab8" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">如果任何节点发生变化，它们必须更新它们的API，并将这个新的API与更新的版本进行通信。然后，如果检测到版本不匹配，接收此信息的IO节点可以选择更新其API缓存。</p><p id="c78c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">如果没有指定标签，客户端将只能依赖自己的别名来使用该API。因为客户端<em class="lu">已经知道</em>它正在与之通信的域、端口和名称空间，所以对于它来说，创建它想要的任何别名(例如<code class="fe mv mw mx my b">apis['localhost:8080/chatRoom']</code>)可能是一种直接的方式。如果没有指定版本，客户端将不得不总是假设版本不匹配，并在每个新连接开始时请求完整的API有效负载；即，客户端将不能依赖或利用API缓存。因此，尽管版本控制是可选的，但强烈建议您这样做。</p><p id="1699" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">每个节点可以有自己的一组事件和方法。“evts”意味着节点将<em class="lu">发出</em>那些事件，而“方法”意味着节点将<em class="lu">监听</em>那些事件(并分别运行自己的同名方法)。</p><h1 id="6dcb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">吻:“evts”格式</h1><p id="c607" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们深入到“evts”格式，看看它会是什么样子:(同样，必须适合便利贴)</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/d82de2706561697f512e04286a0a3898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zlc4WQKZp42YqXfC.png"/></div></div></figure><p id="3ea1" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这里,“evts”将采用以下形式:JSON <em class="lu">对象</em>,其中对象属性是事件名称，其对应的值也是可选的JSON对象，但是强烈推荐。这使得编写多个事件和按事件组织事情变得容易。</p><p id="d154" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">每个事件名称指向一个JSON对象，该对象包含以下可选但强烈推荐的属性:</p><ul class=""><li id="1c74" class="mg mh iq ky b kz lw ld lx lh mi ll mj lp mk lt ml mm mn mo bi translated"><strong class="ky ir">方法</strong>:字符串的<em class="lu">数组</em>，每个字符串代表发出该事件的方法名。如果不同的方法发出相同的事件，这使得接收者很容易通过方法名来组织事件数据。如果省略，接收方将不得不以一种更通用、更不组织的方式缓存发出的数据。</li><li id="384c" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated"><strong class="ky ir">数据</strong>:客户端可以接收并用来验证输入数据的模式。建议在模式中使用默认值，因为这些值也表示数据的类型(在Javascript中，<code class="fe mv mw mx my b">typeof (variable)</code>告诉我们原语的类型)。在我看来，这使得代码更简单，可读性更好。</li><li id="73c9" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated"><strong class="ky ir"> ack </strong>:一个布尔值，表示发出的事件是否期望被确认。(这可能需要，也可能不需要，将在后续文章中解释。然而，知道代码在等待ack时是否阻塞，以及ack何时不会被发送，可能是有用的。</li></ul><h1 id="9247" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">KISS:使用“evts”格式的示例</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/baca775e52eaa058acc44a5827168acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O49OodaL7rFaZCOO.png"/></div></div></figure><p id="51ad" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在本例中，该API标签为“mainServer ”,版本为1.02。它将发出事件“itemRxd”和“msgRxd”。客户端可以预期发出“itemRxd”的方法要么是“getItems”，“toBeAdded”，要么都不是。仍然由服务器指定发出该事件的方法，以便客户端可以正确地组织其数据。当服务器发出“itemRxd”时，客户端可以期望数据JSON包含“progress”，它被指定为类型Number(默认为0)，以及“item”，它被指定为类型Any(默认为空对象)。这样，<em class="lu">类型</em>和<em class="lu">默认值</em>都以简单紧凑的方式表示。随着时间的推移，服务器可能希望制作“item”类型的“Item”，而不是“Any”，以帮助客户端验证每个项目(例如:<code class="fe mv mw mx my b">Item = {name: '', description: '', unitCost: ''}</code>)。</p><p id="ffff" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这里有一个例子:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1c19" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">另一个事件是“msgRxd”。这个条目没有指定任何方法，只指定了数据的模式。客户可以期待收到“日期”和“消息”。由于没有指定方法，客户端可以预期事件来自服务器上的任何或所有方法。</p><h1 id="2a0f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">亲吻:“方法”格式</h1><p id="2608" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">“evts”容器描述了给定节点的<em class="lu">输出</em>,“方法”描述了该节点的<em class="lu">输入</em>，以及相应的响应。格式可能是这样的:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/9a7c211b52ed06a09b2eb02a7c52f91b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6lF-lzkK8xyfvG1G.png"/></div></div></figure><p id="648e" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">格式是一个JSON对象，其中的属性表示支持的方法名。每个方法名指向一个相应的JSON对象，它描述了:</p><ul class=""><li id="be50" class="mg mh iq ky b kz lw ld lx lh mi ll mj lp mk lt ml mm mn mo bi translated"><strong class="ky ir"> msg </strong>:接收节点期望的消息模式(一个“msg”JSON对象)</li><li id="7919" class="mg mh iq ky b kz mp ld mq lh mr ll ms lp mt lt ml mm mn mo bi translated"><strong class="ky ir"> resp </strong>:节点期望响应的响应模式，如果有的话。如果响应指定由方括号包围的架构，则指定该架构的数组。</li></ul><p id="059f" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">实时提供这些模式的一个潜在好处是可以自动创建UI；也就是说，某些类型可以帮助确定哪些UI元素最适合这些类型，尤其是如果这些类型是原语。例如，如果给定的消息模式指定了字符串和数字类型，则字符串类型可以转换为<code class="fe mv mw mx my b">&lt;input type="text" /&gt;</code>，而数字类型可以转换为<code class="fe mv mw mx my b">&lt;input type="number" /&gt;</code>。整个表单控件可能可以用这种方式动态创建。同样，文本响应可能会附加到<code class="fe mv mw mx my b">&lt;div class="resp"&gt;&lt;/div&gt;</code>元素上。样式仍然可以在很大程度上由CSS来处理。</p><h1 id="167c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">KISS:使用“方法”格式的示例</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/6773296b9615d56323863addbee11dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8ogk2FlVPi05R8eI.png"/></div></div></figure><p id="6ca5" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在这个例子中，API指定了两个方法，“getItems”和“getItem”。“getItems”没有指定“msg”模式，所以“msg”可以是任何内容(或者什么都不是),因为它将被忽略。该方法将只返回“Item”类型的数组。项目模式被定义为“id”、“name”和“desc”的JSON对象，都是空字符串(类型String)。然而，“getItem”方法指定了一个“msg”模式，一个带有属性“id”和格式字符串(默认为空字符串)的JSON对象。当客户端调用此方法时，服务器期望客户端提供正确类型(字符串)的id。它会以Item类型响应。</p><h1 id="0b07" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="618c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里给出了一个冗长的，但希望不会太混乱的讨论，关于API如何被动态化，以便它们可以适应通信信道双方所做的改变。对于许多人来说，这很可能是一个非常新的概念，所以我的下一篇文章将描述这一点的确切实现，它将与<a class="ae lv" href="https://www.npmjs.com/package/nuxt-socket-io" rel="noopener ugc nofollow" target="_blank"> nuxt-socket-io </a> v1.0.22一起发布。开始时会有痛苦，因为这是一个学习曲线，但我希望我们在爬过曲线后都会感到高兴(是的，我们正在一起爬过曲线)。</p></div></div>    
</body>
</html>