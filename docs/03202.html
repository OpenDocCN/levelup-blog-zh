<html>
<head>
<title>React Context Using TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用类型脚本反应上下文</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-context-using-typescript-c717f1dee2d1?source=collection_archive---------1-----------------------#2020-04-25">https://levelup.gitconnected.com/react-context-using-typescript-c717f1dee2d1?source=collection_archive---------1-----------------------#2020-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="0340" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">ReactJS很简单，当数据发生变化时，它可以有效地更新和呈现正确的组件。React使用基于组件的方法来管理自己的状态。</p><p id="12e1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通常在React应用中，数据是通过props自上而下传递的(从父到子)。但这可能会使事情复杂化。假设我们有10个组件，用户更新了他的首选语言。现在，我们需要将这些信息传递给所有10个组件，这既复杂又耗时。</p><p id="2629" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了克服这个问题，我们使用<strong class="jz iu">上下文。</strong> React文档称<em class="kv">上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动传递道具。</em></p><p id="79bf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">最重要的问题是什么时候使用上下文？</strong></p><p id="4a34" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Context旨在共享可以被视为React组件树的“全局”数据，例如当前经过身份验证的用户、主题或首选语言。</p><p id="de1b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是使用上下文使得组件的重用变得困难。所以在设计阶段，我们需要格外小心，确保组件的可重用性不受干扰。</p><p id="20b9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">演示项目</strong></p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/934ccd82b0d376835a6e4903eab34f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*809ZLwm-nY78eJ73-f719A.gif"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">演示项目，允许黑暗模式，并提供关于你最喜欢的IPL队的信息😀</figcaption></figure><p id="ccc0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当我在禁闭和板球失踪期间写这篇文章的时候😒我在IPL上建立了一个简单的应用程序，它给你关于你最喜欢的球队的基本信息，并允许你改变主题。</p><p id="05bf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">注意:</strong> <em class="kv">我没有解释这个应用程序中使用的状态、道具和用户界面，因为它们非常基本，没有复杂之处</em></p><p id="59af" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">代码可以从<a class="ae li" href="https://github.com/suhas86/react-context-typescript" rel="noopener ugc nofollow" target="_blank">这里下载</a></p><p id="c730" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">上下文可以分为三个部分</p><ol class=""><li id="459e" class="lj lk it jz b ka kb ke kf ki ll km lm kq ln ku lo lp lq lr bi translated">创建上下文</li><li id="6805" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated">提供创建的上下文(给组件)</li><li id="71be" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated">使用上下文(在任何子组件中)</li></ol><p id="d4e1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> 1。创建上下文</strong></p><p id="3201" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们可以使用<code class="fe lx ly lz ma b">createContext</code> API创建一个上下文。请记住，订阅上下文的组件将从最近的提供者那里读取当前的上下文值。我们可以从react导入它:</p><pre class="kx ky kz la gt mb ma mc md aw me bi"><span id="3562" class="mf mg it ma b gy mh mi l mj mk">import React, {createContext} from "react";</span></pre><p id="5695" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我们的例子中，我们需要两个上下文——一个是处理主题，另一个是跨应用程序更新团队。</p><pre class="kx ky kz la gt mb ma mc md aw me bi"><span id="dd65" class="mf mg it ma b gy mh mi l mj mk"><strong class="ma iu">TeamContext.tsx </strong><br/>export const TeamContext = createContext&lt;{team:string,changeTeam:any}&gt;({team:"rcb",changeTeam:null})</span><span id="d3f9" class="mf mg it ma b gy ml mi l mj mk"><strong class="ma iu">ThemeContext.tsx</strong><br/>export const ThemeContext = createContext&lt;themeState&gt;({  isDarkMode: false,  toggleTheme: null,});</span></pre><p id="a44e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> 2。提供背景</strong></p><p id="5d99" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">每个上下文都有一个提供者组件。这允许消费组件订阅上下文更改。</p><p id="5c95" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在将上下文提供者包含到我们的上下文中之后，我们的代码将如下所示</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a61c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">注意:这两个文件都有更新主题和团队细节的方法</em></p><p id="aa59" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> 3。消费语境</strong></p><p id="c610" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在基于类的组件中，从上下文中获取值非常简单。下面是在基于类的组件中获取上下文的示例代码。我稍后将讨论功能组件。</p><pre class="kx ky kz la gt mb ma mc md aw me bi"><span id="612a" class="mf mg it ma b gy mh mi l mj mk">const {isDarkMode} = this.context</span></pre><p id="c78c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是具有挑战性的部分是当我们想要在一个组件中使用两个上下文时。在我们的例子中，Navbar既需要改变颜色的上下文，也需要更新团队标志。根据文档，我们需要通过订阅来消费</p><pre class="kx ky kz la gt mb ma mc md aw me bi"><span id="478f" class="mf mg it ma b gy mh mi l mj mk">&lt;MyContext.Consumer&gt;<br/>  {value =&gt; /* render something based on the context value */}<br/>&lt;/MyContext.Consumer&gt;</span></pre><p id="1830" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了处理这个问题，我在TeamContext.tsx中包含了高阶组件</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b793" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">上述步骤增加了代码，也使实现变得复杂。所以最好的处理方法是使用基于功能的组件。这避免了高阶组件，我们可以通过使用<code class="fe lx ly lz ma b">useContext</code> hook简单地在组件中使用任意数量的上下文:</p><pre class="kx ky kz la gt mb ma mc md aw me bi"><span id="4544" class="mf mg it ma b gy mh mi l mj mk">const {isDarkMode, toggleTheme} = useContext(ThemeContext);    <br/>const {team} = useContext(TeamContext);</span></pre><p id="e0fe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可以在Github中找到完整的解决方案</p><p id="b4e3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于基于类的组件，请参考此处的<a class="ae li" href="https://github.com/suhas86/react-context-typescript/tree/class_based_context" rel="noopener ugc nofollow" target="_blank"/>。基于功能的组件的例子可以在<a class="ae li" href="https://github.com/suhas86/react-context-typescript/tree/function_based_context" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="c754" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是我的第一篇文章，所以如果你有任何反馈，请在评论区告诉我。希望这篇文章能让你对React上下文有一些基本的了解</p></div></div>    
</body>
</html>