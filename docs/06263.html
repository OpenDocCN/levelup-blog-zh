<html>
<head>
<title>Asserting timeouts in JUnit 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JUnit 5中断言超时</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asserting-timeouts-in-junit-5-4477054f82d3?source=collection_archive---------12-----------------------#2020-11-09">https://levelup.gitconnected.com/asserting-timeouts-in-junit-5-4477054f82d3?source=collection_archive---------12-----------------------#2020-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c43a021a4710c39c3bc718b113d75d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VwCX_nCGnskzrWYs"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@candrawnt_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">坎德拉·温纳塔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d2f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些天来，我们希望尽快得到正确的结果。作为程序员，要求自己写出最高效的Java程序来快速交付正确的结果是没有错的。</p><p id="3419" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JUnit 4提供了多种方法来测试一个进程在指定的时间段(比如说两秒钟)之前完成的情况。这段时间称为超时。如果任务花费的时间超过超时时间，则测试失败。</p><p id="4150" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JUnit 5还提供了两种超时测试方法，但它们与JUnit 4提供的方法不同。</p><p id="005e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子，我将使用斐波那契数列。也许你从丹·布朗的《达芬奇密码》中知道它们。它们很容易理解，有许多不同的方法来计算它们，包括一些效率极低的方法。这正是我们说明超时所需要的。</p><p id="b5bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">前十三个斐波那契数列是0，1，1，2，3，5，8，13，21，34，55，89，144。这些对应于指数0到12。前两个之后，每个数字都是前两个的和。</p><p id="fa60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其实负指数也有斐波那契数。一旦我们为0和正索引的斐波那契数编写了一个函数，就很容易修改这个函数来给出负索引的斐波那契数。我稍后将回到这一点。</p><p id="ecab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个数学家可能会把公式写成这样:<em class="le"> F </em> (0) = 0，<em class="le"> F </em> (1) = 1，对于<em class="le"> n </em> &gt; 2，<em class="le">F</em>(<em class="le">n【T22)=<em class="le">F</em>(<em class="le">n</em>—2)+<em class="le">F</em>(<em class="le">n</em>—1)。这就暗示了我们应该如何编写这个函数。</em></p><p id="665f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，斐波那契数列很快变得非常大。具体来说，<code class="fe lf lg lh li b">int</code> (32位)在到达第50个斐波那契数之前溢出，而<code class="fe lf lg lh li b">long</code> (64位)在到达第100个之前溢出。</p><p id="c386" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这表明我们应该在这里使用<code class="fe lf lg lh li b">java.math.BigInteger</code>。对于一个<code class="fe lf lg lh li b">BigInteger</code>实例可以表示多大的整数，在实践和理论上都有限制，但是我们不会接近其中任何一个。</p><p id="dec1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于Java没有操作符重载或隐式转换，使用<code class="fe lf lg lh li b">BigInteger</code>的基本算法有点笨拙，尽管它是可管理的。尽管我真希望他们把加法函数命名为<code class="fe lf lg lh li b">plus()</code>而不是<code class="fe lf lg lh li b">add()</code>。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="be6b" class="lr ls it li b gy lt lu l lv lw">    public static BigInteger fibonacci(int n) {<br/>        switch (n) {<br/>            case 0: return BigInteger.ZERO;<br/>            case 1: return BigInteger.ONE;<br/>            default:<br/>                return fibonacci(n - 2).add(fibonacci(n - 1));<br/>        }<br/>    }</span></pre><p id="2817" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这看起来像是数学公式的一个很好的翻译，并且它对于非常小的正数<em class="le"> n </em>工作得相当好。我用<em class="le"> n </em> = 12和<em class="le"> n </em> = 13运行了几次测试，它很快给出了144和233的正确结果。</p><p id="286b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，实现实际上效率极低:它需要465次函数调用来计算<em class="le"> F </em> (12) = 144，需要753次函数调用来计算<em class="le"> F </em> (13) = 233。</p><p id="ece4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了计算<em class="le">F</em>(100)= 354224848179261915075，这个实现将需要1146295688027634168201个函数调用(参见斯隆在线整数序列百科全书中的<a class="ae kf" href="https://oeis.org/A001595" rel="noopener ugc nofollow" target="_blank">条目A1595 </a>)。</p><p id="a082" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设Java虚拟机每毫秒可以执行1000次函数调用，完成这个计算需要3600万年。但是你可能会在一两分钟后厌倦等待，并且你会在引发<code class="fe lf lg lh li b">StackOverflowError</code>之前很久就停止测试。</p><p id="3f15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不知道确切的答案是什么，一些过程必须被允许运行到完成，即使它们花费的时间比我们希望的要长一点。但是一个花费太长时间来给出一个我们已经知道的答案的过程应该被停止和拒绝，取而代之的是一个更有效的过程。</p><p id="8842" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用的是NetBeans或IntelliJ IDEA这样的集成开发环境，您可以通过按一个按钮来停止长时间运行的测试。但是更有条理的方法是提前指定一个测试应该完成的特定时间段。</p><p id="4fd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是暂停的原因。在JUnit 4中，以毫秒为单位将超时间隔指定为<code class="fe lf lg lh li b">@Test</code>注释的属性。如果已经导入了注释，就不需要再从JUnit导入任何东西。</p><p id="7551" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得注意的是，以这种方式定义超时的测试是在一个独立于运行测试设置和拆卸的线程的线程中运行的。对于这里的例子来说，这可能重要，也可能无关紧要，但是请记住这一点。</p><p id="e25b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想让测试在同一个线程中运行，您需要来自<code class="fe lf lg lh li b">org.junit.rules</code>包的<code class="fe lf lg lh li b">Timeout</code>规则，所以如果您选择走这条路，这可能是测试类的额外导入。</p><p id="86e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们的函数应该能够在不到两秒的时间内计算第一百个斐波那契数。使用<code class="fe lf lg lh li b">@Test</code>注释的<code class="fe lf lg lh li b">timeout</code>属性，我们的测试看起来会像这样:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="0ae5" class="lr ls it li b gy lt lu l lv lw">    @Test(timeout = 2000)<br/>    public void testFibonacci100() {<br/>        BigInteger expected <br/>            = new BigInteger("354224848179261915075");<br/>        BigInteger actual = fibonacci(100);<br/>        assertEquals(expected, actual);<br/>    }</span></pre><p id="5497" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比当您厌倦等待时停止测试要好，因为如果您有<code class="fe lf lg lh li b">@After</code>或<code class="fe lf lg lh li b">@AfterClass</code>过程，即使测试超时，它们也可能仍然会运行。</p><p id="4cef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个特殊的例子，我有一个函数调用计数器。在超时之前，它累计调用了139851545次。我们需要一个更好的算法，要么需要更少的递归，要么缓存以前的结果。</p><p id="fae4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是在我们了解如何通过这个测试之前，我们将把这个测试重写为一个JUnit 5测试。JUnit 5改变了超时测试，使用Java 8 lambdas并避开注释属性，就像预期异常测试一样。</p><p id="eca5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我看来，JUnit 5超时测试是对JUnit 4超时测试的改进，尽管没有预期异常测试的改进大。更加清晰，但也有更多的概念开销。</p><p id="ae4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于同线程测试，使用<code class="fe lf lg lh li b">assertTimeout()</code>。但是请注意:这并不能保证失控的过程会被停止。因此，对于这个理论上可以运行亿万年的斐波那契数列的例子，我们肯定要使用<code class="fe lf lg lh li b">assertTimeoutPreemptively()</code>来代替。</p><p id="1e91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论哪种方式，我们都不需要导入JUnit规则，但是我们需要导入<code class="fe lf lg lh li b">java.time.Duration</code>来指定超时时间。在这个例子中，显而易见的选择是<code class="fe lf lg lh li b">Duration.ofSeconds(2)</code>，但是我们也可以用毫秒(两千)甚至纳秒(2000000000)来指定它。</p><p id="8ca8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们以秒为单位，不要担心我们可能会错误地转换成毫秒或纳秒。这在清晰度上是一个进步，因为JUnit 4 <code class="fe lf lg lh li b">timeout</code>属性中的数字感觉像是一个“神奇的数字”(声明一个像<code class="fe lf lg lh li b">TWO_SECONDS_TO_MILLISECONDS</code>这样的命名常量对于一个超时测试来说可能是多余的)。</p><p id="1b0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">超时断言的第二个参数是lambda，它包含有望在分配的时间内运行的内容。与预期的异常断言没有太大的不同。</p><p id="580d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是这里有一个概念性的开销:如果你不需要lambda的结果，lambda就是一个<code class="fe lf lg lh li b">Executable</code>；但是如果您确实需要lambda的类型为<code class="fe lf lg lh li b">T</code>的结果，那么lambda就是一个<code class="fe lf lg lh li b">ThrowingSupplier&lt;T&gt;</code>(这是在<code class="fe lf lg lh li b">org.junit.jupiter.api.function</code>包中定义的接口，但是您实际上不需要导入它来使用它)。</p><p id="8c4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我们的例子，我们需要一个<code class="fe lf lg lh li b">ThrowingSupplier&lt;BigInteger&gt;</code>。第一次做的时候，这可能看起来令人生畏，但实际上这很容易。</p><p id="40ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我坦率地承认，在这一点上我确实需要IntelliJ IDEA的帮助。在IntelliJ的帮助下，我得出了以下结论:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="233a" class="lr ls it li b gy lt lu l lv lw">    @Test<br/>    public void testFibonacci100() {<br/>        BigInteger expected <br/>               = new BigInteger("354224848179261915075");<br/>        BigInteger actual <br/>               = assertTimeoutPreemptively(Duration.ofSeconds(2),<br/>                                           () -&gt; fibonacci(100));<br/>        assertEquals(expected, actual);<br/>    }</span></pre><p id="d628" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个JUnit 5测试实际上比JUnit 4测试更冗长，但也更清晰。显然，<code class="fe lf lg lh li b">expected</code>的赋值不应该导致超时。</p><p id="fa3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是“超时”这个词出现在对<code class="fe lf lg lh li b">actual</code>的赋值上要清楚得多。步骤Arrange-Act-Assert(来自有用的AAA助记符)之间的区别非常明显。</p><p id="7b76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还不得不将<code class="fe lf lg lh li b">@After</code>注释改为<code class="fe lf lg lh li b">@AfterEach</code>。我运行了这个测试，有124351254个函数调用。比以前稍微好一点的性能，但是在超时之前仍然没有结果。</p><p id="bb67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想想看，我可以重写测试，这样<code class="fe lf lg lh li b">assertEquals()</code>就在过程lambda中，而不是在函数lambda之后:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="1391" class="lr ls it li b gy lt lu l lv lw">    @Test<br/>    public void testFibonacci100Alt() {<br/>        BigInteger expected<br/>                = new BigInteger("354224848179261915075");<br/>        assertTimeoutPreemptively(Duration.ofSeconds(2), <strong class="li iu">() -&gt; {<br/>            BigInteger actual = fibonacci(100);<br/>            assertEquals(expected, actual);<br/>        }</strong>);<br/>    }</span></pre><p id="cbe5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我觉得这模糊了排列-动作-断言步骤之间的界限。总的结果是一样的:我们低效的Fibonacci函数实现在超时前调用了132094676次函数。</p><p id="6702" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的系统可能会变得更好或更差，但无论哪种方式都不会在任何合理的时间内给出结果。</p><p id="f450" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以现在让我们试着通过测试。这可能就行了…以下是我想到的:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="7501" class="lr ls it li b gy lt lu l lv lw">    public static BigInteger fibonacci(int n) {<br/>        switch (n) {<br/>            case 0: return BigInteger.ZERO;<br/>            case 1: return BigInteger.ONE;<br/>            default:<br/>                BigInteger[] fibos = new BigInteger[n + 1];<br/>                fibos[0] = BigInteger.ZERO;<br/>                fibos[1] = BigInteger.ONE;<br/>                for (int i = 2; i &lt;= n; i++) {<br/>                    fibos[i] = fibos[i - 2].add(fibos[i - 1]);<br/>                }<br/>                return fibos[n];<br/>        }<br/>    }</span></pre><p id="ab36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它不是很优雅，也没有任何缓存，但也许它通过了一个超时测试。确实如此，它在不到40毫秒的时间内通过了两项测试。现在我们来谈谈重构。</p><p id="4893" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个实现让我感到困扰的是<code class="fe lf lg lh li b">BigInteger.ZERO</code>和<code class="fe lf lg lh li b">BigInteger.ONE</code>各出现了两次。我认为通过实现缓存，我们可以消除这种明显的冗余。</p><p id="6b05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保导入<code class="fe lf lg lh li b">java.util.ArrayList&lt;E&gt;</code>。我们将添加一个<code class="fe lf lg lh li b">BigInteger</code>实例的静态<code class="fe lf lg lh li b">ArrayList</code>和一个静态初始化器，该初始化器将<code class="fe lf lg lh li b">BigInteger.ZERO</code>和<code class="fe lf lg lh li b">BigInteger.ONE</code>放入<code class="fe lf lg lh li b">ArrayList</code>。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="38a5" class="lr ls it li b gy lt lu l lv lw">    private static final ArrayList&lt;BigInteger&gt; FIBO_CACHE <br/>            = new ArrayList&lt;&gt;();</span><span id="bf6e" class="lr ls it li b gy lx lu l lv lw">    static {<br/>        FIBO_CACHE.add(BigInteger.ZERO);<br/>        FIBO_CACHE.add(BigInteger.ONE);<br/>    }</span></pre><p id="b278" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们修改<code class="fe lf lg lh li b">fibonacci()</code>函数，从缓存中获取答案(如果可以找到的话),否则构建缓存:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="5e66" class="lr ls it li b gy lt lu l lv lw">    public static BigInteger fibonacci(int n) {<br/>        if (n &gt;= FIBO_CACHE.size()) {<br/>            for (int i = FIBO_CACHE.size(); i &lt;= n; i++) {<br/>                FIBO_CACHE.add(FIBO_CACHE.get(i - 2)<br/>                        .add(FIBO_CACHE.get(i - 1)));<br/>            }<br/>        }<br/>        return FIBO_CACHE.get(n);<br/>    }</span></pre><p id="051b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个重构的版本通过了所有的测试。并且它还具有降低<code class="fe lf lg lh li b">fibonacci()</code>函数的圈复杂度的好处。</p><p id="1d55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许我们不需要对负指数斐波那契数列进行超时测试。如果<em class="le"> n </em>为正奇数，则<em class="le">F</em>(-<em class="le">n</em>)=<em class="le">F</em>(<em class="le">n</em>)，但如果<em class="le"> n </em>为正偶数，则<em class="le">F</em>(-<em class="le">n</em>)=<em class="le">F</em>(<em class="le">n</em>)。所以<em class="le">F</em>(100)= 354224848179261915075。</p><p id="b079" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于乘以1是瞬时的，至少从人的角度来看是这样，因此如果我们测试的函数能够在合理的时间内给出<em class="le"> F </em> (100)，那么它也应该能够在合理的时间内得出<em class="le">F</em>(100)。</p><p id="221a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，两个带有等式断言的测试(一个带有负的奇数索引，一个带有负的偶数索引，比如100)应该足够了。我认为对于这个特殊的例子，我们不需要另外一个超时的测试。</p><p id="604d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您认为有必要再进行一次超时测试，那么现在您知道如何用JUnit 5的方式编写了。</p></div></div>    
</body>
</html>