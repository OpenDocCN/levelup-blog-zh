<html>
<head>
<title>Expensive Mistake That Often Plagues Layered Architectures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经常困扰分层架构的代价高昂的错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/expensive-mistake-that-often-plagues-layered-architectures-700d876afbb5?source=collection_archive---------1-----------------------#2022-10-10">https://levelup.gitconnected.com/expensive-mistake-that-often-plagues-layered-architectures-700d876afbb5?source=collection_archive---------1-----------------------#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="31cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从在没有清晰业务逻辑的情况下从事上帝对象主导的项目的痛苦经历中得到的教训。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66da1082133b37df73577971e794ba5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dObCpZtDETgNoQZz"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">威廉·冈克尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="150d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">业务逻辑通常保存在服务层</h1><p id="cc45" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">快速的谷歌搜索告诉我，几乎每个人对服务层的定义都有所不同。很可能每个阅读这篇文章的人都会对它有不同的定义。然而，我注意到人们对服务层的定义有一个共同点，那就是<em class="mn">服务层应该封装业务逻辑</em>。</p><p id="3879" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">服务层应该封装业务逻辑，这意味着什么？这句话可以有不同的解释，所以它没有告诉我们任何有价值的东西。</p><p id="a75d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我看到最多的是这样一种信念，即服务层只不过是一个网关，表示层通过它访问业务层。听起来像是一件可怕的事情，但在实践中却很常见。这是我在一些公司(和许多在线博客)中看到的，所以我怀疑在许多组织中也是如此。</p><p id="cc4b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这种信念通常会导致这样的认识，即如果服务层只是将请求传递给it，那么拥有单独的业务层就没有意义，这使得人们将服务层和业务层合并在一起，并声明服务层包含业务逻辑，这实际上只留下了服务层，并消除了作为系统独立部分的业务逻辑。</p><h1 id="4467" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么合并层是一个问题</h1><p id="0e2d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">由组合层产生的是一个功能失调的三层架构，它由表示层、服务层和持久层组成。最糟糕的是服务层，因为在其中你通常只能看到我称之为<em class="mn">的服务类</em>，例如<em class="mn"> BookService </em>、<em class="mn"> UserService </em>、<em class="mn"> OrderService </em>等等…</p><p id="a8b5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">那么问题出在哪里？注意到奇怪的事情了吗？人们认为服务层是包含业务逻辑的层。但是，如果您查看它，您只会看到<em class="mn">服务类别</em>。业务领域在哪里？无处可见。从本质上讲，你有同一个类作为两件事:业务逻辑和服务层的一部分。</p><h2 id="e4b4" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">服务层通常由上帝对象组成</h2><p id="b3f1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">再来定义一件事。一个常见的反模式叫做<em class="mn">神物</em>。<br/>什么是神物？它是一个知道并做所有事情的物体。很容易理解。我们都知道这是一个应该避免的糟糕的反模式。</p><p id="ff8c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">为什么我说的是上帝的物品？如果您仔细观察服务类，就会发现它们处理与领域对象相关的所有事情，比如图书、用户或订单。它们是字面上的上帝物品。所谓的业务逻辑通常存在于上帝的对象中。它不是作为一个独立的单元独立存在的。</p><p id="e7db" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这就产生了很多问题。上帝对象是很难维护的，因为所有的东西到处都是，而且有很多耦合。它们违反了优秀设计的大部分原则。例如，单一责任原则。如果你看一看一个典型的服务类实现，你会发现它有不止一个改变的理由。我不打算详述，因为这个故事本身就值得写一整篇文章。</p><p id="2ac4" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">您可能会想"<em class="mn">好吧，公平点，但是，我在我的项目中没有使用OOP，所以我没有编写服务类</em>"，如果是这样，请跟我呆一会儿，因为这个问题与您正在使用的编程范例或者特定的类没有任何关系。</p><blockquote class="nf ng nh"><p id="b730" class="lr ls mn lt b lu mo ju lw lx mp jx lz ni mq mc md nj mr mg mh nk ms mk ml mm im bi translated">如果您正在编写过程化代码，这并不重要，您仍然可以创建一个相当于god对象的模块，其中耦合是通过屋顶实现的。</p></blockquote><p id="0b6c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">服务层和业务层的合并是人们没有意识到服务层和业务层之间的区别的结果。这就是为什么你有服务上帝的对象，做一切事情，并依赖于外部世界。</p><h2 id="2697" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">服务和业务层的区别</h2><p id="b87b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">服务实际上应该是什么样的？服务是客户端可以调用来做某事的一组功能，无论是执行计算还是检索一些数据。这是一个抽象概念。抽象的存在是有原因的。他们隐藏了事情的真相。模块中作为抽象的东西知道抽象背后在做什么。意思是，它不是一个独立的单元。</p><p id="85a1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">业务层应该是什么？它应该是一个独立于你系统中发生的一切的单元，只知道<em class="mn">你的业务领域</em>，换句话说，<em class="mn">你的业务模式</em>，你做什么来提供一些有用的服务。</p><p id="4ca8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">把依赖服务层和独立业务层合并成一层会怎么样？</p><blockquote class="nf ng nh"><p id="c895" class="lr ls mn lt b lu mo ju lw lx mp jx lz ni mq mc md nj mr mg mh nk ms mk ml mm im bi translated">当您合并层时，您消除了它们之间的边界，并且，由于您将它们视为一个整体，您最终会使业务层依赖于外部世界。</p></blockquote><p id="52e6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">据我所见，人们开始编写我之前提到的<em class="mn">服务神类</em>。</p><h2 id="0c6e" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">错误的信仰</h2><p id="a797" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为什么会这样呢？是人们相信他们的架构选择自动保证了质量吗？看起来是这样。当你看到一个典型的微服务架构时，这种错误的信念尤其明显，在这个架构中，方法调用只是被HTTP调用所取代，仅此而已。这也是一个不同的故事，值得一篇自己的文章。</p><p id="1c59" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">不然人们为什么要写上帝的物品？god object反模式什么时候变成了一种大多数人接受的模式，把它的名字改成了service，并争辩说它是服务层的一部分，因为它是分层的架构，所以它自动是好的？</p><h2 id="182a" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">合并图层是没有意义的</h2><blockquote class="nf ng nh"><p id="bddc" class="lr ls mn lt b lu mo ju lw lx mp jx lz ni mq mc md nj mr mg mh nk ms mk ml mm im bi translated">当您开始将您的业务领域视为一个独立的单元时，服务层和业务层就会分离，这就使得最初合并它们的目的落空了。</p></blockquote><p id="fb89" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">你想想，服务层和业务层合并有什么意义？我看不出有什么好的理由。</p><p id="65a6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">即使您遇到一个层只是将请求传递给另一个层的情况，这也不是一个好的理由，因为分层体系结构的事情是，当您遇到这种情况时，您允许一个层绕过另一个层，但您不只是开始合并层。</p><h1 id="5165" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建筑不能保证任何事情</h1><blockquote class="nf ng nh"><p id="69a0" class="lr ls mn lt b lu mo ju lw lx mp jx lz ni mq mc md nj mr mg mh nk ms mk ml mm im bi translated">建筑不保证质量。仅仅因为你使用分层架构并不意味着你的系统就一定是好的。不管你的建筑如何，上帝物品仍然是不好的。</p></blockquote><p id="38de" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">使用分层架构的两个主要好处是易于开发和可测试性。那么，上帝对象反模式的后果是什么呢？这使得你的代码很难维护，实际上也不可能测试。因此，当你开始只使用上帝对象编写你的服务+业务层时，你违背了分层架构的好处，并使它们在所述层中无用。</p><h1 id="b8c3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">回顾和提示</h1><p id="4fa6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">以下是我在从事将服务层和业务层合并为一个由上帝对象组成的项目的痛苦经历中得出的主要结论:</p><p id="3d18" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> #1。不要将服务层视为包含业务逻辑的层</strong></p><p id="523d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我仍然相信，如果你做了这样的事情，你仍然可以没有任何麻烦，但这需要很多的照顾。然而，你可能会理解，如果你在一个团队中工作，可能会有(而且经常是)不这样的人，这就是为什么把不应该在一起的东西分开是很重要的。</p><blockquote class="nf ng nh"><p id="7030" class="lr ls mn lt b lu mo ju lw lx mp jx lz ni mq mc md nj mr mg mh nk ms mk ml mm im bi translated">如果您发现您的应用程序主要由<em class="it">服务类</em>组成，那么您可能应该重新考虑您在做什么。</p></blockquote><p id="286e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">上帝对象是坏的，称它们为服务并不能改变它们是什么。</p><p id="57d2" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> #2。不要认为服务层仅仅是通向业务层的网关</strong></p><p id="d8da" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">将业务层视为独立于外部世界的层。</p><p id="ce7e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">请将服务层视为封装应用程序中其他层的功能的一层，其目的只是作为一种抽象，当业务层需要执行不属于它的内容时，可以参考它。</p><p id="8942" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> #3。不要假设分层架构会保证质量</strong></p><p id="bca3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">不会的。架构选择应该是明智的决定。如果您选择分层架构，那么它所包含的层也应该是一个明智的决定。</p><p id="8824" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> #4。必要时允许一层绕过另一层</strong></p><p id="a2b9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这在分层架构中是允许的。但是，如果您发现自己经常需要绕过层，这表明有些层是不必要的，或者架构不是最合适的，您应该做出一些改变。</p><p id="38d6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> #5。明确区分服务层和业务层</strong></p><p id="e835" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">不同之处应该是你明智的决定，最适合你的项目。确保参与项目的每个人都意识到这种差异。</p><p id="50f3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> #6。避免没有明确目的的服务和经理课程</strong></p><p id="649e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">当你有像<em class="mn"> BookService </em>、<em class="mn"> UserService、BookManager或UserManager </em>这样的类时，它们并没有真正告诉你它们做了什么。</p><blockquote class="nf ng nh"><p id="7d39" class="lr ls mn lt b lu mo ju lw lx mp jx lz ni mq mc md nj mr mg mh nk ms mk ml mm im bi translated">无目的的类意味着可以将与你的领域对象相关的所有东西都放在一个类中，这导致了上帝对象，这使得人们思考得更少，这使得你的项目的维护非常昂贵。</p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="35a0" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">将服务层与业务层合并是一个很大的错误，最终会导致一堆糟糕的决策，使您的代码库无法工作，并可能产生严重的后果。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="15a0" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这里有一篇文章对这个话题进行了更深入的阐述:</p><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-differentiate-business-and-service-layers-in-layered-architecture-912123b2ccf1"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">如何区分分层架构中的业务层和服务层</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">探索业务逻辑和服务之间的关系和区别。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div></div></div>    
</body>
</html>