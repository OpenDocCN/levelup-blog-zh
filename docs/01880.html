<html>
<head>
<title>Dependency Injection Containers in Swift — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的依赖注入容器—第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-container-in-swift-b4d7e139338c?source=collection_archive---------6-----------------------#2020-02-04">https://levelup.gitconnected.com/dependency-injection-container-in-swift-b4d7e139338c?source=collection_archive---------6-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="833a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何松散地耦合您的整个项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/01bf3a35acc85c32ec4c26433c503ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZA5ym9Y5_X08tfjqaAUTQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">帕特里克·布林克斯马在<a class="ae ky" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论swift中的依赖注入容器(DIC)。在我之前的文章中，我探讨了如何在Swift 中解耦代码，并介绍了解耦阶梯的四个级别，如果你不确定我的意思，可以看看。我已经提到了依赖注入或DI，它是一种通过从外部注入类的依赖来将类与其依赖解耦的方法。</p><p id="da3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用DI有助于类的解耦，但不能完全解决问题。创建子类的父类呢？我们只是将耦合从子类转移到父类。父类现在是紧密耦合的，让我们看一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="954b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lx ly lz ma b">ParentClass</code>创建了<code class="fe lx ly lz ma b">serviceOne</code>和<code class="fe lx ly lz ma b">serviceTwo</code>。<code class="fe lx ly lz ma b">ServiceOne</code>对<code class="fe lx ly lz ma b">ServiceTwoProtocol</code>有依赖性，我们可以假设它们都是松散耦合或解耦的。然而<code class="fe lx ly lz ma b">ParentClass</code>与<code class="fe lx ly lz ma b">ServiceOne</code>和<code class="fe lx ly lz ma b">ServiceTwo</code>紧密耦合，因为它创建了不可替换的特定对象。那么我们如何才能解耦<code class="fe lx ly lz ma b">ParentClass</code>？</p><p id="5731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是注入<code class="fe lx ly lz ma b">ParentClass</code>依赖项，在本例中是<code class="fe lx ly lz ma b">serviceOne</code>。让我们看看那会是什么样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="335d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过注入<code class="fe lx ly lz ma b">serviceOne</code>，我们使得<code class="fe lx ly lz ma b">ParentClass</code>松散耦合！这很好，但让我们更深入地思考一下。我们没有完全解决这个问题，因为现在<code class="fe lx ly lz ma b">LooselyCoupledParentClass</code>‘母’将紧密耦合。创建对象的类将总是与创建的对象紧密耦合。我们只是把这个问题转给了其他班级。那么，我们如何尽可能多的解耦类呢？</p><p id="31c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个复杂的项目中，可能有许多类，每个类都有自己的依赖项。这些类可能会被排列成复杂的层次结构。对象的创建可能是分散的，导致许多类紧密耦合。</p><p id="0266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种情况，我们可以创建一个负责创建所有其他对象的对象。你可能已经猜到了，我指的是依赖注入容器对象，让我们看看它会是什么样子。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b86c" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">依赖注入容器</h1><p id="95aa" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们对DIC的要求是能够从协议中解析(创建)我们需要的任何对象。这意味着我们向DIC请求一个符合协议的对象，DIC创建它及其所有的依赖项。这听起来可能有点不可思议，事实是，确实如此。</p><p id="a216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够解析对象，我们需要首先赋予DIC创建对象的能力。我们通过登记小工厂关闭来做到这一点。这听起来可能有点抽象，所以让我们看看这可能是什么样子。下面的例子是一个非常简单的DIC，因为它的目标是理解它是什么，以及如何使用它。还有很多具有更多特性的库，例如<a class="ae ky" href="https://github.com/Swinject/Swinject" rel="noopener ugc nofollow" target="_blank"> swinject </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d766" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来有点混乱，所以让我们一行一行地检查一下。</p><ol class=""><li id="baab" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们声明一个FactoryClosure类型别名，它将我们的容器作为输入，并返回我们想要创建的对象。</li><li id="da5f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">向特定协议注册工厂外壳。服务是泛型的，所以类型是在运行时解析的。服务也可以是一个类类型，但是我们希望我们的对象是松散耦合的，因此我们将只使用协议。</li><li id="e544" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">解析(创建)符合协议的对象。服务是在运行时解析的一般服务。</li><li id="12ff" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">服务拥有所有的工厂，它的关键字是协议名，它的值是工厂闭包。</li></ol><p id="bb43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看将对象注册到容器会是什么样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="76e5" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们创造我们的容器。</li><li id="2a31" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们向<code class="fe lx ly lz ma b">ServiceTwoProtocol</code>注册了一家工厂。工厂不需要容器，因为<code class="fe lx ly lz ma b">ServiceTwo</code>没有依赖项，所以我们让它为空。我们返回一个<code class="fe lx ly lz ma b">ServiceTwo</code>对象。</li><li id="eebe" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们给<code class="fe lx ly lz ma b">ServiceOneProtocol</code>注册了一个工厂。工厂使用容器是因为<code class="fe lx ly lz ma b">ServiceOne</code>有依赖关系。我们返回一个<code class="fe lx ly lz ma b">ServiceOne</code>对象，其中容器被用来解析它的依赖关系。</li></ol><p id="b5a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经设置了容器，让我们看看如何使用它。在继续阅读之前，请查看上面的代码，并尝试计算出创建了多少个对象。请随意留下您的答案作为回应。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="ddfd" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">把所有的放在一起</h1><p id="fc6c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在我们的第一个例子中,<code class="fe lx ly lz ma b">ParentClass</code>创建了自己的依赖项，这使得它与它们紧密耦合。让我们看看如何使用容器来解析<code class="fe lx ly lz ma b">ParentClass</code>的依赖关系。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1b28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在将container作为唯一的参数，并使用它来解析它的所有依赖项！在这种情况下，只有一个依赖项，但是在更大的项目中，可以有更多的依赖项。预先删除和添加依赖关系会影响初始化器，从而导致整个项目中的连锁反应。现在，删除和添加依赖项不会影响初始化器，这使得它更容易处理。</p><p id="3530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用容器也有一些缺点。设置依赖关系是隐式的，而不是显式的，这意味着我们相信容器能够在运行时解析我们的依赖关系。另一个问题是，我们不知道一个对象依赖于它的初始化器。之前我们确切地知道类的依赖关系是什么，但是现在我们需要深入一点来弄清楚它。</p><p id="d6fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了尽量减少不利因素，让我们把事情说得更清楚些。我们可以添加容器初始化器作为一个方便的初始化，并保留我们原来的。让我们看看那会是什么样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="296a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将需要更多的维护，因此开发人员需要权衡使用这种方法的利弊。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0636" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">面向协议的方法</h1><p id="4dad" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们可以通过使用面向协议的方法来进一步改进我们的<code class="fe lx ly lz ma b">DIC</code>。对于每个服务协议，我们可以创建一个<code class="fe lx ly lz ma b">HasServiceProtocol</code>，它声明一个变量来解析所需的服务。让我们看看那会是什么样子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在声明我们的<code class="fe lx ly lz ma b">HadServiceProtocol</code>之后，我们将它们添加到<code class="fe lx ly lz ma b">DICProtocol</code>。<code class="fe lx ly lz ma b">DIC</code>需要实现一个额外的getter来解析服务，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="38e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以用面向协议的方式来解决依赖性了！让我们看看那会是什么样子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="094d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一行一行地过一遍</p><ol class=""><li id="0242" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们声明了一个<code class="fe lx ly lz ma b">Dependencies</code> typealias，它定义了类需要的依赖关系</li><li id="b68c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们的类是用符合<code class="fe lx ly lz ma b">HasProtocols</code>的<code class="fe lx ly lz ma b">DIC</code>对象初始化的</li><li id="9078" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们使用<code class="fe lx ly lz ma b">HasProtocols</code>来解析我们的依赖关系。请注意，每当我们解析一个依赖项时，都会创建一个新的实例。</li></ol><p id="7d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案要干净得多，我们只创建一个实例来保存我们所有的依赖项！添加和删除依赖项不会改变类的接口，减少了维护，尤其是在较大的项目中。</p><h1 id="6d9a" class="mi mj it bd mk ml nt mn mo mp nu mr ms jz nv ka mu kc nw kd mw kf nx kg my mz bi translated">包扎</h1><p id="220c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们已经看到了如何使用DICs松散耦合我们的类。如果在整个项目中正确使用，我们可以松散地耦合所有的类，除了注册容器的类。这是对DICs的介绍，我建议查看一下<a class="ae ky" href="https://github.com/Swinject/Swinject" rel="noopener ugc nofollow" target="_blank"> swinject </a>中的全功能DIC。我希望你喜欢这篇文章，并祝你好运实现你的DIC！</p><p id="4f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一篇文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/dependency-injection-containers-in-swift-part-2-5b24f1c4238a">Swift中的依赖注入容器——第2部分</a>中，我将探讨如何在解析对象时传递参数。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="4a17" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">我的应用</h1><div class="ny nz gp gr oa ob"><a href="https://apps.apple.com/us/app/koala-nap/id1478157024?ls=1" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">考拉午睡</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">你或你的伴侣打鼾吗？现在你可以从第一天开始积极减少打鼾，使用考拉午睡。除了展示如何…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">apps.apple.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://apps.apple.com/us/app/last-flower/id1112524681?ls=1" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">最后一朵花</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">你能拯救最后一朵花吗？iPad上也有-小行星正在撞击地球，所有的…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">apps.apple.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op ks ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://apps.apple.com/us/app/tile-color-match/id1294483076?ls=1" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">瓷砖颜色匹配</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">彩色瓷砖匹配是一个令人兴奋的新游戏。目的是通过移动底部的瓷砖来匹配上面的棋盘布局…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">apps.apple.com</p></div></div><div class="ok l"><div class="or l om on oo ok op ks ob"/></div></div></a></div><p id="792e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【www.koalanap.com T4】</p></div></div>    
</body>
</html>