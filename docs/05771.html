<html>
<head>
<title>Learning about Reactive Messaging Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解反应式消息传递模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-about-reactive-messaging-patterns-ec174f510b03?source=collection_archive---------16-----------------------#2020-09-29">https://levelup.gitconnected.com/learning-about-reactive-messaging-patterns-ec174f510b03?source=collection_archive---------16-----------------------#2020-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b82bbc89c1f98448273f6fc00edb9fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhCm1oI9Pz-IdwpP4MzkOg.png"/></div></div></figure><h1 id="96ae" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">概观</h1><p id="1efa" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">根据反应宣言，任何反应系统的一个关键要素是它是消息驱动的。但是消息驱动意味着什么呢？</p><p id="794f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">消息驱动系统是那些主要通过异步和非阻塞消息进行通信的系统。消息使我们能够建立既有弹性又有弹性的系统，从而在各种情况下做出响应。</p><h1 id="af26" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">消息驱动架构</h1><p id="7dc3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们有各种方法来实现同步和异步消息传递。但是当我们试图使用同步消息来完成需要异步消息的任务时，或者反之亦然，事情就变得糟糕了。因此，我们需要确保在工作中使用正确的工具。</p><h2 id="b333" class="lz jz iq bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">异步消息传递的使用</h2><p id="a6e6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当消息无需等待响应即可发送时，使用异步消息传递。它用于避免系统的两个部分互相等待，并且一直消耗资源的情况。使用异步和非阻塞消息、线程、内存等资源。可以立即释放，减少了争用，从而提高了可伸缩性。它提供了更高的可靠性，因为在接收者离线的情况下，消息可以排队等待传递。它还允许我们让系统的一部分脱机一段时间，而让系统的其余部分继续正常运行。</p><h2 id="540d" class="lz jz iq bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">异步消息传递的成本</h2><p id="fdfd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">异步消息使事务变得更加困难，因为事务可能长时间保持打开状态，这使得系统非常缓慢和脆弱。应该避免使用跨越微服务边界的事务，因为有些服务可能不可用，或者可能涉及多个数据库，并且长时间运行的事务会增加争用。</p><h2 id="b040" class="lz jz iq bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">同步消息的使用</h2><p id="9bfe" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">异步消息应该是反应式系统的主干。为了实现这一点，也可以使用同步消息，但是通常可以放宽对它们的要求。因此，与其发送消息并等待响应，我们可以只发送一条消息并让接收者确认他们收到了消息。</p><h2 id="4b80" class="lz jz iq bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">同步消息传递的成本</h2><p id="3523" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">从技术上讲，使用完全同步的消息来构建通常非常方便。但是也有相关的成本。这些成本表现为无法扩展和可靠性降低。</p><p id="6fb0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，我们的目标应该是理解同步和异步消息传递之间的区别，以及在两者之间做出选择的后果。</p><h1 id="f4eb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">保证消息的传递</h1><p id="d914" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当我们构建分布式系统时，我们不得不面对在分布式系统中传递消息是复杂的这一现实。我们需要小心确保有保证的消息传递，也就是说，消息应该按照预期的次数传递给正确的接收者。为了提供这些保证，我们需要新的工具和技术。</p><h2 id="daa9" class="lz jz iq bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">最多一次交货</h2><p id="acfb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="ml">至多一次</em> delivery承诺任何消息都不会被传递超过一次。如果出现故障，将不会重试消息传递，这意味着消息不会被复制，但可能会丢失。这种交付技术的优点是非常容易实现，并且不需要存储消息。</p><h2 id="b135" class="lz jz iq bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">至少一次交货</h2><p id="38cb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="ml">至少一次</em>传递保证所有消息最终都会被传递。当故障发生时，有两种可能性。一种可能性是消息可能没有被传递。另一种可能性是消息可能已经发送但没有被确认。失败总是导致重试，这意味着消息可能会被传递多次，但它们永远不会丢失。这种传送技术要求在发送方存储消息。</p><h2 id="b354" class="lz jz iq bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">恰好一次交货</h2><p id="aad0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="ml">恰好一次</em>传递不容易实现，因为在网络中断或信息丢失的情况下，我们不能保证我们的信息是否被收到。当失败发生时，我们必须重新发送消息以确保有保证的传递，但这可能会产生潜在的重复。因此，为了模拟<em class="ml">恰好一次</em>递送，使用了<em class="ml">至少一次</em>递送技术，并且在接收者端执行消息的重复数据删除。这种传送技术要求在发送方和接收方都进行存储。</p><h1 id="7a43" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">保证交付技术的实施</h1><p id="35d3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Akka默认最多使用<em class="ml">一次</em>交货。然而，<em class="ml"> Akka持久性</em>具有至少一次交付<em class="ml">的选项。鉴于<em class="ml"> Lagom </em>通过其消息代理API支持<em class="ml">至少一次</em>交付和<em class="ml">最多一次</em>交付。</em></p><p id="3684" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要实现有保证的交付技术，有两种不同的方法。一种方法是，每个微服务可以直接依赖于其他微服务，这意味着以<em class="ml">点对点</em>的方式发送消息。另一种方法是，每个微服务可以利用<em class="ml">发布/订阅</em>消息代理从其他服务获取消息。</p><h2 id="58e8" class="lz jz iq bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">点对点方法</h2><p id="04a1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在点对点设置中，每个服务都直接向其他服务发送消息，这意味着它们直接耦合到彼此的API。这种方法的优点是服务知道它们的依赖关系，这使得容易理解消息流。这个优点也是一个缺点，因为服务之间是高度耦合的。</p><h2 id="e3f8" class="lz jz iq bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">发布/订阅方法</h2><p id="a81a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在<em class="ml">发布/订阅</em>设置中，我们有一系列微服务和一个中央消息总线或消息代理。服务将消息发布到公共消息总线，然后其他服务订阅这些消息。这意味着发布服务不知道订阅服务，反之亦然。因此，这种方法的优点是依赖关系更加灵活，这使得这是一种非常解耦的方法。</p><p id="b91a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Akka actors通常用<em class="ml">点对点</em>消息传递来实现。Lagom还支持服务之间的<em class="ml">点对点</em>通信。在我们的微服务内部，我们有<em class="ml">发布/订阅</em>机制，为了使用它，我们可以使用Akka持久性。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="0d67" class="jy jz iq bd ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv bi translated">类似文章-</h1><p id="3316" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你也可以看看我关于<em class="ml">反应式架构</em>系列的其他文章——</p><ul class=""><li id="b160" class="my mz iq ky b kz lu ld lv lh na ll nb lp nc lt nd ne nf ng bi translated"><a class="ae nh" rel="noopener ugc nofollow" target="_blank" href="/leaning-towards-reactive-architecture-190a6e02d0e1">倾向于反应式架构</a></li><li id="26c7" class="my mz iq ky b kz ni ld nj lh nk ll nl lp nm lt nd ne nf ng bi translated"><a class="ae nh" rel="noopener ugc nofollow" target="_blank" href="/diving-into-reactive-microservices-f9ff6a3f9686">投入反应式微服务</a></li><li id="1ccd" class="my mz iq ky b kz ni ld nj lh nk ll nl lp nm lt nd ne nf ng bi translated"><a class="ae nh" rel="noopener ugc nofollow" target="_blank" href="/building-scalable-systems-c09374da82d7">构建可扩展的系统</a></li></ul></div></div>    
</body>
</html>