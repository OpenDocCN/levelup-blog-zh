<html>
<head>
<title>Arrow functions vs regular functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的箭头函数与常规函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/arrow-function-vs-regular-function-in-javascript-b6337fb87032?source=collection_archive---------0-----------------------#2020-01-17">https://levelup.gitconnected.com/arrow-function-vs-regular-function-in-javascript-b6337fb87032?source=collection_archive---------0-----------------------#2020-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/98925b19c735314afde3d7b550ed8d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehXbV2aumA_TPQlgG2shuw.jpeg"/></div></div></figure><p id="c924" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自ECMAScript 2015以来，箭头函数已被采用，这是一个简单但非常强大的功能。然而，箭头函数不同于普通函数。那有什么不同？</p><h1 id="a5e8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">语法:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="fd59" class="md kx iq lz b gy me mf l mg mh">// (param1, param2, paramN) =&gt; expression</span><span id="4991" class="md kx iq lz b gy mi mf l mg mh">// ES5 Regular function<br/>var add = function(x, y) { <br/>return x + y;<br/>};</span><span id="b64e" class="md kx iq lz b gy mi mf l mg mh">// ES6 Arrow function<br/>let add = (x, y) =&gt; { return x + y };</span></pre><p id="f18e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript箭头函数大致相当于python 中的<a class="ae mj" href="https://www.programiz.com/python-programming/anonymous-function" rel="noopener ugc nofollow" target="_blank"> lambda函数或者Ruby </a>中的<a class="ae mj" href="http://ruby-for-beginners.rubymonstas.org/blocks.html" rel="noopener ugc nofollow" target="_blank">块，但是它们有更复杂的细节。箭头函数允许开发人员用更少的代码行和大约一半的输入来完成相同的结果。</a></p><p id="26ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果只有一个表达式，就不需要花括号，它会从函数中隐式返回这个结果。上面的例子也可以写成这样:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2146" class="md kx iq lz b gy me mf l mg mh">let add = (x, y) =&gt; x + y;</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/75374e4ddd9d0ca61896c74fb97ade39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_IejCVtnJg24RDNQC9xftg.png"/></div></div></figure><h1 id="ab92" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><code class="fe ml mm mn lz b">"this" </code>装订</h1><p id="69a7" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">与常规函数不同，箭头函数没有自己的<code class="fe ml mm mn lz b">this</code>或<code class="fe ml mm mn lz b">arguments</code>绑定。相反，这些标识符像任何其他变量一样在词法范围内被解析。让我们看一个简单的例子:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9647" class="md kx iq lz b gy me mf l mg mh">name ="Arrow function"<br/>let me = { <br/> name: "Regular function", <br/> thisInArrow:() =&gt; { <br/>   console.log("Example of " + this.name); //no 'this' binding here <br/> }, <br/> thisInRegular(){ <br/>   console.log("Example of " + this.name); //'this' binding works here <br/> } <br/>};<br/>me.thisInArrow(); <br/>me.thisInRegular();</span></pre><p id="3180" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与常规函数不同，箭头函数没有自己的<code class="fe ml mm mn lz b">this</code>。在箭头函数的情况下，<code class="fe ml mm mn lz b">this</code>指的是箭头函数在中定义的<em class="mt">环境中的<code class="fe ml mm mn lz b">this</code>的值(即在箭头函数的“外部”)，并且在函数的整个生命周期中保持不变，并且总是绑定到最近的非箭头父函数中的<code class="fe ml mm mn lz b">this</code>的值。</em></p><p id="a8db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们再看一个简单的例子:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/890468c1170497a23e98034e23b0e6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AtKbfph8cPXrGf5TdFpUzg.png"/></div></div></figure><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d4228d0b522334e65822d610dbdf6074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fF5QgM8AdaBHtXNG7nx-w.png"/></div></div></figure><p id="0499" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在函数表达式中，<code class="fe ml mm mn lz b">this</code>指的是在<code class="fe ml mm mn lz b">createObject</code>中创建的对象。在箭头功能情况下，<code class="fe ml mm mn lz b">this</code>是指<code class="fe ml mm mn lz b">createObject</code>本身的<code class="fe ml mm mn lz b">this</code>。</p><h1 id="9d20" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">“参数”绑定:</h1><p id="3596" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">Arguments对象在箭头函数中不可用，但在常规函数中可用。</p><p id="20a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="mt">常规功能:</em> </strong></p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="e1c9" class="md kx iq lz b gy me mf l mg mh">let myFunc = { <br/> showArgs(){ <br/>   console.log(arguments); <br/> } <br/>}; <br/>myFunc.showArgs(1, 2, 3, 4);</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/bda87a65d76ce761df5af269dce6df9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkJdJ-slG5uY2_J2ntU4Qw.png"/></div></div></figure><p id="1937" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">箭头功能:</strong></p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ba9c" class="md kx iq lz b gy me mf l mg mh">let myFunc = { <br/> showArgs : ()=&gt; {<br/>      console.log(arguments); <br/>   }<br/>}; <br/>myFunc.showArgs(1, 2, 3, 4);</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/6f173187248d9d0cf99ab4992f343f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8x6pidH46zBjs6USpKjxPQ.png"/></div></div></figure><h1 id="e868" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">箭头功能不能用【新</strong>T12】调用</h1><p id="0916" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">ES6区分了<em class="mt">可调用</em>的函数和<em class="mt">可构造</em>的函数。</p><p id="e8e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果函数是可构造的，可以用<code class="fe ml mm mn lz b">new</code>调用，即<code class="fe ml mm mn lz b">new User()</code>。如果一个函数是可调用的，那么不需要<code class="fe ml mm mn lz b">new</code>就可以调用(即正常的函数调用)。</p><p id="7278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过函数声明/表达式创建的常规函数既可构造又可调用。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0c7a" class="md kx iq lz b gy me mf l mg mh">let x = <strong class="lz ir">function</strong>(){<br/>   console.log(arguments);<br/>};</span><span id="e3b1" class="md kx iq lz b gy mi mf l mg mh"><strong class="lz ir">new</strong> <!-- -->x =(1,2,3);</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/df9eec8bbfbbd02065969838c3ccf4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyhaA3FJei5V0D_MYlWNdQ.png"/></div></div></figure><p id="eb29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">箭头函数</strong>(和方法)仅可调用，即箭头函数永远不能用作构造函数。因此，永远不能用关键字<code class="fe ml mm mn lz b">new</code>调用它们。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="03da" class="md kx iq lz b gy me mf l mg mh">let x = ()=&gt; {<br/>   console.log(arguments);<!-- --> <br/>};</span><span id="76dc" class="md kx iq lz b gy mi mf l mg mh"><strong class="lz ir">new</strong> <!-- -->x(1,2,3);</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/a5653e5de2808d35adcd3817a693e682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f99qCorcJmIgo9Od0rC4AA.png"/></div></div></figure><h1 id="7928" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">何时不使用箭头功能:</h1><p id="db7c" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">我希望你明白，箭头函数并不能在所有情况下取代常规函数。</p><p id="dd19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一些情况下，您不应该查看箭头函数，</p><p id="72de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1。对象方法</strong></p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="291d" class="md kx iq lz b gy me mf l mg mh">var cat = {<br/>  lives: 9,<br/>  jumps: () =&gt; {<br/>    this.lives--;<br/>  }<br/>}</span></pre><p id="df99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你呼叫<code class="fe ml mm mn lz b">cat.jumps</code>时，生命数量不减少。这是因为<code class="fe ml mm mn lz b">this</code>没有绑定任何东西，将从其父作用域继承<code class="fe ml mm mn lz b">this</code>的值。</p><p id="2b73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。具有动态上下文的回调函数</strong></p><p id="2235" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看下面这个事件处理程序:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9c67" class="md kx iq lz b gy me mf l mg mh">var button = document.getElementById('press');<br/>button.addEventListener('click', () =&gt; {<br/>  this.classList.toggle('on');<br/>});</span></pre><p id="2b2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们点击按钮，我们会得到一个类型错误。这是因为<code class="fe ml mm mn lz b">this</code>没有绑定到按钮，而是绑定到了它的父作用域。</p><p id="e9ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。承诺和承诺链</strong></p><p id="dc31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">箭头函数使代码更干净、更直观的另一个地方是管理异步代码。</p><p id="f272" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank">承诺</a>让管理异步代码变得更加容易。然而，使用promises仍然需要定义在异步代码或调用完成后运行的函数。</p><p id="a8f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个箭头函数的理想位置，特别是如果你的结果函数是有状态的，引用你的对象中的一些东西。</p><p id="8805" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">缺点是确保你再次理解<code class="fe ml mm mn lz b">this</code>将如何工作。示例:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9b3d" class="md kx iq lz b gy me mf l mg mh"><strong class="lz ir">this</strong>.doSomethingAsync().then((result) <strong class="lz ir">=&gt;</strong> { <strong class="lz ir">this</strong>.storeResult(result); });</span></pre><p id="1d33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4。当它使你的代码可读性降低时</strong></p><p id="b0bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有必要考虑一下我们前面提到的各种语法。有了常规函数，人们就知道会发生什么。使用箭头功能，可能很难直接破译你正在看的东西。</p><h1 id="a255" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">最后的想法💭 🤔</h1><p id="7cbd" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">箭头函数是对JavaScript语言的一个很好的补充，在许多情况下可以实现更加符合人体工程学的代码。</p><p id="7cec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，像其他功能一样，它们也有优点和缺点。我们应该把它们作为我们工具箱中的另一个工具，而不是作为所有功能的一揽子替代品。</p><p id="2c9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谢谢😊看了我的文章，如果你喜欢就分享吧！查看我的其他文章</p><p id="d4b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">延伸阅读:</strong></p><div class="na nb gp gr nc nd"><a href="https://medium.com/better-programming/difference-between-regular-functions-and-arrow-functions-f65639aba256" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">常规函数和箭头函数的区别</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">探索ES6中新的胖箭头功能</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jw nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://www.geeksforgeeks.org/higher-order-arrow-functions-in-javascript/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">JavaScript - GeeksforGeeks中的高阶箭头函数</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">先决条件:箭头函数高阶函数是一个接受函数作为自变量的函数，否则…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="nm l"><div class="ns l no np nq nm nr jw nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://www.freecodecamp.org/news/when-and-why-you-should-use-es6-arrow-functions-and-when-you-shouldnt-3d851d7f0b26/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">什么时候(为什么)应该使用ES6箭头功能，什么时候不应该使用</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">由辛西娅李何时(以及为什么)你应该使用ES6箭头功能-当你不应该箭头功能(也称为…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">www.freecodecamp.org</p></div></div><div class="nm l"><div class="nt l no np nq nm nr jw nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://stackoverflow.com/questions/34361379/are-arrow-functions-and-functions-equivalent-exchangeable" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">“箭头函数”和“函数”是等价的/可交换的吗？</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">TL；玛:不！箭头函数和函数声明/表达式是不等价的，不能盲目替换…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">stackoverflow.com</p></div></div><div class="nm l"><div class="nu l no np nq nm nr jw nd"/></div></div></a></div></div></div>    
</body>
</html>