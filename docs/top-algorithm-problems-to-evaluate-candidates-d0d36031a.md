# 评估候选人的顶级算法问题

> 原文：<https://levelup.gitconnected.com/top-algorithm-problems-to-evaluate-candidates-d0d36031a>

![](img/abef6aa614c3ec376d3a0779bb09aed2.png)

照片由 [Cytonn 摄影](https://unsplash.com/@cytonn_photography?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

我们都会时不时地去参加工作面试，有时我们会看到任务，然后我们会问——这是我在这份工作中要做的吗？。
测试算法知识的愿望是可以理解的，但有时面试官会给出一个问题，为了解决这个问题，你需要知道一些非常具体的算法。

# #9000.最小生成树

> 给定一个加权无向图。最小生成树(MST)是将所有顶点无圈连接在一起的边的子集，并且具有最小可能的总边权重。
> 
> 在给定图的 MST 中找到所有的**关键**和**伪关键边**。如果一条 MST 边从图中删除会导致 MST 权重增加，则这条边称为临界边。另一方面，伪临界边缘可以出现在一些 MST 中，但不是所有 MST 中。

这个任务是通过 Prim 的算法或者 Kruskal 的算法来解决的，这些算法在日常工作任务中相当少见，但在需求中可以很容易地 googled 出来。如果面试的目的是淘汰尽可能多的候选人，这是一项伟大的任务。但是如果你一年没有收到 300 万份简历，那么我就不会那样浪费时间和候选人。

您可以在此找到解决方案:

[](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/discuss/855731/Simple-Java-Solution-or-Kruskal-Algo) [## 简单的 Java 解决方案| Kruskal Algo - LeetCode 讨论

### 提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…

leetcode.com](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/discuss/855731/Simple-Java-Solution-or-Kruskal-Algo) 

# #2.两个数的和

> 给定一个排序的整数数组。找出数字，使它们加起来等于给定的数字。

通过几个算法问题，你可以与候选人进行大量交流，让他找到更好的解决方案。

这是一个简单的任务，但仍然有评估候选人的空间。有许多解决方案，您可以从简单走向复杂:

1.  使用嵌套循环的暴力。O(n)时间，O(1)内存。
2.  二分搜索法。O(nlogn)时间，O(1)内存。
3.  散列表。O(n)时间，O(n)内存。
4.  两个指针:从开始和从结束。O(n)时间，O(1)内存。

双指针算法

# #1.限速器

> *给定一个接口和整数* `*N > 0*` *。编写一个实现，将对此方法的调用限制为每秒 N 次调用。*

```
public interface Service {
    void doSomething();
}
```

这项任务的美妙之处主要在于它很可能是项目的工作任务之一。例如，如果您向客户销售 API，其中每个价格计划都有自己的单位时间内允许调用的次数。

它还有一个应用设计模式的空间。如果候选人已经猜到使用装饰，这已经是一个好的迹象。如果他提到 AOP(针对 Spring 中的 Java 程序员)，那也是一个很好的加分项。

任务本身有两个阶段。

## 需要精确计数

这里的标准解决方案是使用 LinkedList (O(n)时间和内存)。想法是保存所有新呼叫尝试的列表:

1.  从头部删除传出的请求
2.  检查列表大小
3.  在尾部插入一个新值

还有一个循环缓冲解(O(1)时间，O(n)内存)，但是面试的时候比较难想出来，通常情况下，LinkedList 解就够了。

圆形限速器

## с计算误差是可以接受的

在现实生活中，我们通常愿意牺牲完美的准确性来显著提高复杂度(O(1)时间，O(1)内存)。因此，访问的第二阶段是实现允许 1%假阳性误差的服务(即，在最坏的情况下，用户可以每秒进行 10100 次呼叫)。

这里的解决方案是在 LinkedList 中存储的不是调用时间，而是存储桶、时间间隔开始的内容以及对它的调用次数。根据新的请求，我们将:

1.  从列表中删除旧的存储桶
2.  检查列表中当前的请求数
3.  向最后一个时段添加请求，或者创建一个新的时段

1%假阳性误差的速率限制器

在现实生活中，解决方案必须是线程安全的，并且很可能有每个用户的限制，但是这超出了工作面试问题的范围。

# 结论

在工作面试中解决现实生活中的问题总是比单纯的算法问题更有趣。算法仍然有用武之地，但是你也可以测试架构模式的知识。
如果你不是 Google，基于对一些稀有算法的无知，不太可能有这么多候选人筛选出来，所以筛选过程应该更高效。