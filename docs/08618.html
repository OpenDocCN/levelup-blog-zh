<html>
<head>
<title>10 Advanced Python Concepts To Level Up Your Python Skills</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升Python技能的10个高级Python概念</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/10-advance-python-concepts-to-level-up-your-python-skills-da3d6284ad53?source=collection_archive---------0-----------------------#2021-05-18">https://levelup.gitconnected.com/10-advance-python-concepts-to-level-up-your-python-skills-da3d6284ad53?source=collection_archive---------0-----------------------#2021-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ca71" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有助于增加Python知识的概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c65afe775a428f3342ec9d26411ebf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9JZkPRgyrVBHoJypyoMFg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者使用<a class="ae ky" href="http://canva.com" rel="noopener ugc nofollow" target="_blank">Canva.com</a>创建图像</figcaption></figure><p id="71de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博客中，我们将看到一些帮助我们掌握Python的高级概念。</p><h1 id="ae49" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.异常处理</h1><p id="9c27" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">异常是指在程序执行过程中出现并中断程序执行的情况。发生这种情况的原因有很多。假设你正在写一个除法的程序，在分母中，0出现了，所以它将是一个ZeroDivisionError。其他的例子可能是导入一个不存在的库或者访问一个不在列表索引中的元素。python中大约有30个内置异常。</p><p id="de6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe ms mt mu mv b">try</code>和<code class="fe ms mt mu mv b">except</code>块来处理python中的异常。为了一次处理多个异常，我们使用了多个<code class="fe ms mt mu mv b">except</code>块。</p><p id="cc38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">try</code>程序块包含需要执行的代码。<code class="fe ms mt mu mv b">except</code>块包含当<code class="fe ms mt mu mv b">try</code>执行失败时执行的代码。我们还有和<code class="fe ms mt mu mv b">else</code>和<code class="fe ms mt mu mv b">finally</code>块。<code class="fe ms mt mu mv b">else</code>程序块仅在<code class="fe ms mt mu mv b">try</code>程序块成功执行时执行。一个<code class="fe ms mt mu mv b">finally</code>块总是执行，它独立于其他块。</p><div class="kj kk kl km gt ab cb"><figure class="mw kn mx my mz na nb paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/ec6048e382edd44247c28088a7f7a671.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*XNr5A2It7Jcw0adRgn3KxA.png"/></div></figure><figure class="mw kn mx my mz na nb paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/efcc3b7a166809da500698e77b1d0a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*06faJIXNoj9qnfAfAENmYA.png"/></div></figure><figure class="mw kn nc my mz na nb paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/4c206d5a2db9d8fb47fdb3aaf5414402.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*TIx6ryznY9v-Y-8o_YGFbA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk nd di ne nf translated">处理异常——内置异常vs自定义消息vs代码(使用<a class="ae ky" href="http://carbon.now.sh" rel="noopener ugc nofollow" target="_blank"> carbon.now.sh </a>创建的代码块图像)</figcaption></figure></div><p id="41eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要处理多个异常，可以使用嵌套的<code class="fe ms mt mu mv b">except</code>块。</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="79f6" class="nk lw it mv b gy nl nm l nn no">import sys<br/>try:<br/>   f = open('myfile.txt') <br/>   s = f.readline()<br/>   i = int(s.strip())<br/><strong class="mv iu">except OSError as err</strong>:<br/>   print("OS error: {0}".format(err))<br/><strong class="mv iu">except ValueError</strong>:<br/>   print("Could not convert data to an integer.")<br/><strong class="mv iu">except</strong>:<br/>   print("<strong class="mv iu">Unexpected error:", sys.exc_info()[0]</strong>)<br/>   raise<br/>finally:<br/>   print("Operation Successfully Done!!")</span><span id="6c27" class="nk lw it mv b gy np nm l nn no"><em class="nq">(Example Taken From Official </em><a class="ae ky" href="https://docs.python.org/3/tutorial/errors.html" rel="noopener ugc nofollow" target="_blank"><em class="nq">Python Docs</em></a><em class="nq">)</em></span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="6573" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">2.收集</h1><p id="7ee2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">python中的集合被称为用于存储数据的容器。例如列表、元组、集合、字典。Python中开发了许多库来提供额外的数据结构。该集合是Python中的一个库，旨在改进内置容器的功能。收集模块中最常用的五种数据结构是:</p><h2 id="ac64" class="nk lw it bd lx od oe dn mb of og dp mf li oh oi mh lm oj ok mj lq ol om ml on bi translated">1.计数器</h2><p id="308a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它接受一个iterable并返回一个字典，其中键是一个元素，值是它在iterable中出现的次数。它返回的字典是排序的。</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="0604" class="nk lw it mv b gy nl nm l nn no">from collections import <em class="nq">Counter<br/></em>data = [1,1,1,1,2,3,4,3,3,5,6,7,7]<br/>count = Counter(data)<br/>print(count)<br/>---------------------------------------------------<br/>Counter({1: 4, 3: 3, 7: 2, 2: 1, 4: 1, 5: 1, 6: 1})</span></pre><p id="0e10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有三个额外的功能。<br/> 1。<strong class="lb iu"> elements() </strong>:返回计数器对象的项目。<br/> 2。<strong class="lb iu"> most_common() </strong>:返回一个元组列表，其中包含按排序顺序排列的最常见的元素。<br/> 3。<strong class="lb iu">减去:</strong>从计数器中减去映射对象。</p><h2 id="8b2e" class="nk lw it bd lx od oe dn mb of og dp mf li oh oi mh lm oj ok mj lq ol om ml on bi translated">2.命名元组</h2><p id="7368" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">nametuple</code>的引入是为了给元组的每个位置赋予更多的意义。它返回一个元组，其中包含元组中每个位置的名称。</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="c010" class="nk lw it mv b gy nl nm l nn no">from collections import namedtuple<br/>Direction = namedtuple('Direction','N,S,E,W')<br/>dt = Direction(4,74,0,0)<br/>print(dt)<br/>---------------------------------------------<br/>Direction(N=4, S=74, E=0, W=0)</span></pre><h2 id="1717" class="nk lw it bd lx od oe dn mb of og dp mf li oh oi mh lm oj ok mj lq ol om ml on bi translated">3.有序直接</h2><p id="b3d6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个<code class="fe ms mt mu mv b">OrderedDict</code>是一种记住它们被插入的顺序的字典。在Python的新版本中，内置的字典也能记住它。</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="463e" class="nk lw it mv b gy nl nm l nn no">from collections import OrderedDict<br/>dictt = OrderedDict()<br/>dictt['a'] = 5<br/>dictt['d'] = 2<br/>dictt['c'] = 1<br/>dictt['b'] = 3<br/>print(dictt)<br/>--------------------------------------------------------<br/>OrderedDict([('a', 5), ('d', 2), ('c', 1), ('b', 3)])</span></pre><h2 id="5136" class="nk lw it bd lx od oe dn mb of og dp mf li oh oi mh lm oj ok mj lq ol om ml on bi translated">4.默认字典</h2><p id="fed9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个<code class="fe ms mt mu mv b">defaultdict</code>将为字典中不存在的键返回一个默认值，而不是显示一个键错误。</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="09f5" class="nk lw it mv b gy nl nm l nn no">from collections import defaultdict<br/>dictt = defaultdict(int)<br/>dictt['a'] = 2<br/>print(dictt['a'])  ## return the value<br/>print(dictt['b'])  ## returns the default value<br/>-------------------------------<br/>2<br/>0</span></pre><h2 id="928d" class="nk lw it bd lx od oe dn mb of og dp mf li oh oi mh lm oj ok mj lq ol om ml on bi translated">5.双端队列</h2><p id="4b85" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它是一个双端队列，可以从两端添加和删除元素。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="ec72" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">3.itertools</h1><p id="35be" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python itertools模块提供了各种处理迭代器的函数。<br/> 1。<code class="fe ms mt mu mv b"><strong class="lb iu">product(iterable,iterable)</strong></code>:两个可迭代对象的笛卡尔积<br/> 2。<code class="fe ms mt mu mv b"><strong class="lb iu">permutation(iterable)</strong></code>:没有重复元素的所有可能排序<br/> 3。<code class="fe ms mt mu mv b"><strong class="lb iu">combinations(iterable,n)</strong></code>:指定长度的所有可能组合，没有重复。这里<strong class="lb iu"> n </strong>是组合元组的大小。<br/> 4。<code class="fe ms mt mu mv b"><strong class="lb iu">combinations_with_replacement(iterable,n)</strong></code>:指定长度重复的所有可能组合。<br/> 5。<code class="fe ms mt mu mv b"><strong class="lb iu">accumlate(iterable)</strong></code> : returns累加iterable的元素之和。<br/> 6。<code class="fe ms mt mu mv b"><strong class="lb iu">groupby(iterable,key=FUNC)</strong></code>:从iterable <em class="nq">返回一个带有连续键和组的迭代器。</em></p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="76e6" class="nk lw it mv b gy nl nm l nn no">from itertools import combinations<br/>a = [1,2,3]<br/>print(list(combinations(a,2)))<br/>-------------------------------------------<br/>[(1, 2),(1, 3),(2, 3)]</span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="665b" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">4.希腊字母的第11个</h1><p id="88d0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它也被称为匿名函数。它没有主体，也不需要<code class="fe ms mt mu mv b">def</code>关键字来定义。lambda函数可以有任意数量的参数，但只能有一个表达式。表达式计算并返回。它没有返回语句。</p><p id="bc91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">语法</strong> : <code class="fe ms mt mu mv b"><strong class="lb iu">lambda arguments:expression</strong></code></p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="a9ac" class="nk lw it mv b gy nl nm l nn no">even_or_odd = <em class="nq">lambda a: a%2==0</em><br/>numbers = [1,2,3,4,5]<br/>even = list(map(even_or_odd,numbers))<br/>print(even)<br/>---------------------------------<br/><em class="nq">[False, True, False, True, False]</em></span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="3644" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">5.装修工</h1><p id="4857" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">装饰器是python中的一个特性，它在不显式修改现有代码的情况下向现有代码添加一些新功能。有两种类型的装饰器——函数和类装饰器。decorators函数在函数名前有一个<code class="fe ms mt mu mv b">@</code>。</p><p id="143d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解decorators的概念，我们首先需要理解一件事python中的函数是类对象。与其他对象不同，它们可以在函数内部定义，作为参数在其他函数中传递，甚至作为函数返回。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">装饰示例</figcaption></figure><p id="d37e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来理解上面装饰者的例子——首先，我们有一个名为<code class="fe ms mt mu mv b">add</code>的函数，它的工作是获取两个变量并返回它们的和。现在，经过一段时间的工作，我们意识到有必要将乘法和占卜功能添加到同一个函数中。现在我们有两个选择第一个是在同一个<code class="fe ms mt mu mv b">add</code>函数中添加乘法和占卜代码，或者我们可以使用decorators来添加功能而不显式地改变函数。</p><p id="39b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用装饰器，我们首先在<code class="fe ms mt mu mv b">2</code>行定义了一个装饰器函数。该函数将一个<code class="fe ms mt mu mv b">func</code>作为输入。在第二行中，我们有另一个函数，我们知道我们可以在函数中定义函数。它是一个具有<code class="fe ms mt mu mv b">*args, **kwargs</code>函数参数的包装函数。有了这些，两者都被定义为参数，现在我们可以在函数中传递任意数量的参数。在包装函数的主体中，我们有乘法逻辑，然后实际的<code class="fe ms mt mu mv b">add</code>函数被调用，只有加法逻辑，最后，我们有除法逻辑。当我们用一些参数<code class="fe ms mt mu mv b">add(5,6)</code>调用<code class="fe ms mt mu mv b">add</code>函数时，输出将是:</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="5477" class="nk lw it mv b gy nl nm l nn no">30<br/>0.8333333333333334<br/>11</span></pre><p id="9209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它首先执行乘法逻辑并打印值，然后执行加法逻辑并保存值，然后执行除法逻辑并打印值，最后返回相加值并打印值。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="3972" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">6.发电机</h1><p id="e893" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">生成器是一种返回可以迭代的对象的函数。它至少包含一个<code class="fe ms mt mu mv b">yield</code>语句。<code class="fe ms mt mu mv b">yield</code>是python中的一个关键字，用于从函数返回值，而不破坏其当前状态或对局部变量的引用。带有<code class="fe ms mt mu mv b">yield</code>关键字的函数称为生成器。</p><p id="4e72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器只在请求时生成一次项目。它们的内存效率很高，占用的内存空间也较少。</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="e4ab" class="nk lw it mv b gy nl nm l nn no">-------------- <a class="ae ky" href="https://stackoverflow.com/questions/102535/what-can-you-use-python-generator-functions-for#:~:text=Generators%20are%20good%20for%20calculating,results%20at%20the%20same%20time." rel="noopener ugc nofollow" target="_blank">Fibonacci Series Using Generators</a> ------------<br/>def fibon(limit):<br/>  a,b = 0,1<br/>  while a &lt; limit:<br/>      yield a<br/>      a, b = b, a + b</span><span id="e500" class="nk lw it mv b gy np nm l nn no">for x in fibon(10):<br/>   print (x)</span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="7e04" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">7.线程和多重处理</h1><p id="225e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">线程和多重处理都用于同时运行多个脚本。进程是程序的实例，线程是进程中的实体。</p><p id="443d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线程是一种技术，其中多个线程同时运行以执行不同的任务，而多处理是一种技术，其中多个进程同时在不同的CPU上运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/6a9473cce480f3f2903e97525d753aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x79qDXHAfyMSktsuJ7DHeA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者使用<a class="ae ky" href="http://Canva.com" rel="noopener ugc nofollow" target="_blank">Canva.com</a>创建图像</figcaption></figure><p id="41ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<a class="ae ky" href="https://timber.io/blog/multiprocessing-vs-multithreading-in-python-what-you-need-to-know/" rel="noopener ugc nofollow" target="_blank">这里</a>阅读这篇博客获得详细的理解</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="9982" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">8.邓德方法</h1><p id="5f55" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Dunder方法或Magic方法是那些在方法前后有两个下划线<code class="fe ms mt mu mv b">__</code>的方法。这些方法是在某个动作上从类中直接调用的。当你试图用符号<code class="fe ms mt mu mv b">*</code>将两个数相乘时，内部的<code class="fe ms mt mu mv b">__mul__</code>方法就会被调用。</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="3fe7" class="nk lw it mv b gy nl nm l nn no">num =  5<br/>num*6<br/>&gt;&gt; 30</span><span id="54ef" class="nk lw it mv b gy np nm l nn no">num.__mul__(6)<br/>&gt;&gt;30</span></pre><p id="2c9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法主要用于重载预定义的运算符。例如+、-、*、/是必须在数字对象周围使用的数字运算符，但+也用作两个字符串之间的连接运算符。所以我们可以说,+运算符被重载来执行多个任务。</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="0f59" class="nk lw it mv b gy nl nm l nn no">5+6<br/>&gt;&gt;11</span><span id="1820" class="nk lw it mv b gy np nm l nn no">"python"+"programming"<br/>&gt;&gt; 'pythonprogramming'</span></pre><p id="0df6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="noopener ugc nofollow" target="_blank">官方Python文档</a></p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="08ab" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">9.记录</h1><p id="68a4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">日志记录是在代码执行时捕获代码流的过程。日志记录有助于轻松调试代码。它通常是在文件中完成的，以便我们以后可以检索它。在python中，我们有一个库<code class="fe ms mt mu mv b">logging</code>来帮助我们将日志写到一个文件中。日志记录有五个级别:</p><ol class=""><li id="a415" class="or os it lb b lc ld lf lg li ot lm ou lq ov lu ow ox oy oz bi translated">调试:用于诊断问题，并提供详细信息。</li><li id="f229" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated">信息:确认成功。</li><li id="b28c" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated">警告:当意外情况发生时。</li><li id="991b" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated">错误:由于比警告更严重的问题。</li><li id="2e96" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated">Critical:严重错误，在该错误之后程序不能自己运行。</li></ol><p id="3340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<a class="ae ky" href="https://docs.python.org/3/library/logging.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>中了解更多信息</p><div class="pf pg gp gr ph pi"><a href="https://medium.com/pythoneers/master-logging-in-python-73cd2ff4a7cb" rel="noopener follow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">Python中的主日志记录</h2><div class="pp l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">medium.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv ks pi"/></div></div></a></div></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="cfa2" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">10.上下文管理器</h1><p id="25fe" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">上下文管理器是python中一个很好的工具，有助于资源管理。它们允许您在需要时分配和释放资源。上下文管理器最常用和公认的例子是<code class="fe ms mt mu mv b">with</code>语句。<code class="fe ms mt mu mv b">with</code>主要用于打开和关闭文件。</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="7b2d" class="nk lw it mv b gy nl nm l nn no">file = open('data.txt','w')<br/>try:<br/>  file.write("Hello")<br/>except:<br/>   file.close()</span></pre><p id="007b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上下文管理器的帮助下，<code class="fe ms mt mu mv b">with</code>你可以用写模式打开一个文件，如果一行出错，你也可以关闭它。使用<code class="fe ms mt mu mv b">with</code>的主要优点是它确保我们的文件将在最后关闭。</p><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="d31b" class="nk lw it mv b gy nl nm l nn no">with open ('data.txt','w') as f:<br/>    f.write("Hello")</span></pre><p id="0d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将<a class="ae ky" href="https://book.pythontips.com/en/latest/context_managers.html" rel="noopener ugc nofollow" target="_blank">上下文管理器</a>实现为一个类，在生成器和装饰器的帮助下发挥作用。</p><h2 id="5056" class="nk lw it bd lx od oe dn mb of og dp mf li oh oi mh lm oj ok mj lq ol om ml on bi translated">参考</h2><p id="2473" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">[1] <a class="ae ky" href="https://docs.python.org/3/tutorial/index.html" rel="noopener ugc nofollow" target="_blank">官方Python文档</a></p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="779a" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">作者✍的一些精选文章</h1><pre class="kj kk kl km gt ng mv nh ni aw nj bi"><span id="3e47" class="nk lw it mv b gy nl nm l nn no"><a class="ae ky" href="https://medium.com/pythoneers/a-quick-look-at-object-oriented-programming-oop-in-python-975fc3cb9618" rel="noopener"><strong class="mv iu">A Quick Look At The Object Oriented Programming In Python</strong></a></span><span id="b183" class="nk lw it mv b gy np nm l nn no"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/10-advance-python-concepts-to-level-up-your-python-skills-da3d6284ad53"><strong class="mv iu">10 Advance Python Concepts To Level Up Your Python Skills</strong></a></span><span id="c8b7" class="nk lw it mv b gy np nm l nn no"><a class="ae ky" href="https://medium.com/pythoneers/10-facts-you-didnt-know-about-python-b18d87529c23" rel="noopener"><strong class="mv iu">10 Facts You didn't Know About Python</strong></a></span><span id="92d8" class="nk lw it mv b gy np nm l nn no"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/10-python-tricks-for-speed-up-your-code-8c189d8c99b6"><strong class="mv iu">10 Python Tricks For Speed Up Your Code</strong></a></span><span id="1783" class="nk lw it mv b gy np nm l nn no"><a class="ae ky" href="https://medium.com/pythoneers/10-must-known-built-in-functions-in-python-2f196b9c0359" rel="noopener"><strong class="mv iu">10 Must Known Build In Functions In Python</strong></a></span><span id="8cc6" class="nk lw it mv b gy np nm l nn no"><a class="ae ky" href="https://medium.com/pythoneers/15-python-packages-you-probably-dont-know-exits-aef0525a965f" rel="noopener"><strong class="mv iu">15 Python Packages You Probably didn't know Existed</strong></a></span><span id="e98f" class="nk lw it mv b gy np nm l nn no"><a class="ae ky" href="https://pub.towardsai.net/the-7-stages-of-preparing-data-for-machine-learning-dfe454da960b" rel="noopener ugc nofollow" target="_blank"><strong class="mv iu">The 7 Stages For Preparing Data For Machine Learning</strong></a></span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="8904" class="lv lw it bd lx ly ny ma mb mc nz me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">分级编码</h1><p id="06bf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">感谢您成为我们社区的一员！<a class="ae ky" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank">订阅我们的YouTube频道</a>或者加入<a class="ae ky" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="pf pg gp gr ph pi"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">编写面试问题+获得开发工作</h2><div class="pw l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">掌握编码面试的过程</h3></div><div class="pp l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">技术开发</p></div></div><div class="pq l"><div class="px l ps pt pu pq pv ks pi"/></div></div></a></div></div></div>    
</body>
</html>