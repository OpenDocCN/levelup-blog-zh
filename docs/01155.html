<html>
<head>
<title>A Guide to JSON and How It’s Handled in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JSON指南及其在JavaScript中的处理方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/manipulating-json-strings-in-javascript-5c9423841fa3?source=collection_archive---------2-----------------------#2019-11-19">https://levelup.gitconnected.com/manipulating-json-strings-in-javascript-5c9423841fa3?source=collection_archive---------2-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="92be" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">概述JSON以及可以用来操作和转换它的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d860a1378ca12da43825e7789d02e6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VY_SjcztP0e5BOLs"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tormius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adri Tormo </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JSON代表JavaScript对象符号。它是一种用于序列化数据的格式，这意味着它可以用于在不同的源之间传输和接收数据。在JavaScript中，有一个<code class="fe lv lw lx ly b">JSON</code>实用程序对象，它提供了将JavaScript对象转换成JSON字符串的方法，反之亦然。不能构造或调用<code class="fe lv lw lx ly b">JSON</code>实用程序对象——只有两个静态方法，分别是<code class="fe lv lw lx ly b">stringify</code>和<code class="fe lv lw lx ly b">parse</code>,用于在JavaScript对象和JSON字符串之间进行转换。</p><h1 id="6e76" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">JSON的属性</h1><p id="19af" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">JSON是一种用于序列化对象、数组、数字、布尔值和<code class="fe lv lw lx ly b">null</code>的语法。它基于JavaScript对象语法，但它们不是一回事。并非所有的JavaScript对象属性都可以转换为有效的JSON，JSON字符串必须正确格式化才能转换为JavaScript对象。</p><p id="3536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于对象和数组，JSON属性名必须用双引号括起来，并且禁止在对象后面加逗号。数字不能有前导零，小数点后必须至少有一位数字。不支持<code class="fe lv lw lx ly b">NaN</code>和<code class="fe lv lw lx ly b">Infinity</code>，JSON字符串不能有<code class="fe lv lw lx ly b">undefined</code>或注释。另外，JSON不能包含函数。</p><p id="ad1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何JSON文本都必须包含有效的JavaScript表达式。在某些浏览器引擎中，JSON中的字符串和属性键允许使用U+2028行分隔符和U+2029段落分隔符，但是在JavaScript代码中使用它们会导致语法错误。这两个字符可以用<code class="fe lv lw lx ly b">JSON.parse</code>解析成有效的JavaScript字符串，但是传递给<code class="fe lv lw lx ly b">eval</code>时会失败。</p><p id="a506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无关紧要的空白可以包含在JSONNumber或JSONString之外的任何地方。数字中不能有空格，字符串会被解释为字符串中的空格，否则会导致错误。制表符(U+0009)、回车符(U+000D)、换行符(U+000A)和空格(U+0020)是JSON中唯一有效的空白字符。</p><h1 id="7dc1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">JSON对象的基本用法</h1><p id="bc30" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在<code class="fe lv lw lx ly b">JSON</code>实用程序对象上有2个方法。有将JavaScript对象转换成JSON字符串的<code class="fe lv lw lx ly b">stringify</code>方法和将JSON字符串转换成JavaScript对象的<code class="fe lv lw lx ly b">parse</code>方法。</p><p id="7420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">parse</code>方法将一个字符串解析为JSON，并将一个函数作为第二个参数，以选择性地将JSON实体转换为您指定的JavaScript实体，并返回结果JavaScript对象。如果字符串包含JSON语法中不允许的实体，那么就会引发SyntaxError。此外，传递给<code class="fe lv lw lx ly b">JSON.parse</code>的JSON字符串中不允许有逗号结尾。例如，我们可以在下面的代码中使用它:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="f2e0" class="na ma it ly b gy nb nc l nd ne">JSON.parse('{}'); // {}     <br/>JSON.parse('false'); // false      <br/>JSON.parse('"abc"'); // 'abc'       <br/>JSON.parse('[1, 5, "abc"]');  // [1, 5, 'abc']<br/>JSON.parse('null'); // null</span></pre><p id="4176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行将返回一个空对象。第二个会返回<code class="fe lv lw lx ly b">false</code>。第三行将返回<code class="fe lv lw lx ly b">'abc'</code>。第四行将返回<code class="fe lv lw lx ly b">[1, 5, "abc"]</code>。第五行会返回<code class="fe lv lw lx ly b">null</code>。它返回我们期望的结果，因为我们传入的每一行都是有效的JSON。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/bc9a97d8e19aac7fc1ca88212b9f61f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o_sha5EKnOrWT-wL"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kris_ricepees?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">加里·本迪格</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="dd3f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">自定义Stringify和Parse的行为</h1><p id="7e86" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">或者，我们可以传入一个函数作为第二个参数，将值转换成我们想要的任何值。我们传入的函数将把键作为第一个参数，把值作为第二个参数，并在操作完成后返回值。例如，我们可以写:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="a002" class="na ma it ly b gy nb nc l nd ne">JSON.parse('{"a:": 1}', (key, value) =&gt;<br/>  typeof value === 'number'<br/>    ? value * 10<br/>    : value     <br/>);</span></pre><p id="f62c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到返回的<code class="fe lv lw lx ly b">{a: 10}</code>。如果值的类型是数字，则该函数返回原始值乘以10。</p><p id="b6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">JSON.stringify</code>方法可以将一个函数作为第二个参数，将JavaScript对象中的实体映射到JSON中的其他东西。默认情况下，<code class="fe lv lw lx ly b">undefined</code>的所有实例和不受支持的原生数据(如函数)都会被删除。例如，如果我们编写以下代码:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="bbb0" class="na ma it ly b gy nb nc l nd ne">const obj = {<br/>  fn1() {},<br/>  foo: 1,<br/>  bar: 2,<br/>  abc: 'abc'<br/>}<br/>const jsonString = JSON.stringify(obj);<br/>console.log(jsonString);</span></pre><p id="1c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们看到在运行<code class="fe lv lw lx ly b">JSON.stringify</code>之后，从JSON字符串中删除了<code class="fe lv lw lx ly b">fn1</code>，因为JSON语法不支持函数。对于<code class="fe lv lw lx ly b">undefined</code>，我们可以从下面的代码中看到<code class="fe lv lw lx ly b">undefined</code>属性将被移除。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="5802" class="na ma it ly b gy nb nc l nd ne">const obj = {<br/>  fn1() {},<br/>  foo: 1,<br/>  bar: 2,<br/>  abc: 'abc',<br/>  nullProp: null,<br/>  undefinedProp: undefined<br/>}<br/>const jsonString = JSON.stringify(obj);<br/>console.log(jsonString);</span></pre><p id="a29e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">undefinedProp</code>不在记录的JSON字符串中，因为它已被<code class="fe lv lw lx ly b">JSON.strinfiy</code>删除。</p><p id="4116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，<code class="fe lv lw lx ly b">NaN</code>和<code class="fe lv lw lx ly b">Infinity</code>在转换成JSON字符串后都变成了<code class="fe lv lw lx ly b">null</code>:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="6992" class="na ma it ly b gy nb nc l nd ne">const obj = {<br/>  fn1() {},<br/>  foo: 1,<br/>  bar: 2,<br/>  abc: 'abc',<br/>  nullProp: null,<br/>  undefinedProp: undefined,<br/>  notNum: NaN,<br/>  infinity: Infinity<br/>}<br/>const jsonString = JSON.stringify(obj);<br/>console.log(jsonString);</span></pre><p id="c5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="72fc" class="na ma it ly b gy nb nc l nd ne">'{“foo”:1,”bar”:2,”abc”:”abc”,”nullProp”:null,”notNum”:null,”infinity”:null}'</span></pre><p id="1bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">NaN</code>和<code class="fe lv lw lx ly b">Infinity</code>都变成了<code class="fe lv lw lx ly b">null</code>而不是原来的值。</p><p id="8588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于不受支持的值，我们可以使用第二个参数中的replacer函数将它们映射到受支持的值，我们可以选择传入第二个参数。replace函数将属性的键作为第一个参数，将值作为第二个参数。例如，保留<code class="fe lv lw lx ly b">NaN</code>、<code class="fe lv lw lx ly b">Infinity</code>或函数的一种方法是将它们映射到一个字符串，如下面的代码所示:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="6591" class="na ma it ly b gy nb nc l nd ne">const obj = {<br/>  fn1() {},<br/>  foo: 1,<br/>  bar: 2,<br/>  abc: 'abc',<br/>  nullProp: null,<br/>  undefinedProp: undefined,<br/>  notNum: NaN,<br/>  infinity: Infinity<br/>}</span><span id="b1d5" class="na ma it ly b gy ng nc l nd ne">const replacer = (key, value) =&gt; {<br/>  if (value instanceof Function) {<br/>    return value.toString();<br/>  } else if (value === NaN) {<br/>    return 'NaN';<br/>  } else if (value === Infinity) {<br/>    return 'Infinity';<br/>  } else if (typeof value === 'undefined') {<br/>    return 'undefined';<br/>  } else {<br/>    return value; // no change<br/>  }<br/>}</span><span id="a582" class="na ma it ly b gy ng nc l nd ne">const jsonString = JSON.stringify(obj, replacer, 2);<br/>console.log(jsonString);</span></pre><p id="4e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最后一行的<code class="fe lv lw lx ly b">jsonString</code>上运行<code class="fe lv lw lx ly b">console.log</code>之后，我们看到:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="e5a0" class="na ma it ly b gy nb nc l nd ne">{<br/>  "fn1": "fn1() {}",<br/>  "foo": 1,<br/>  "bar": 2,<br/>  "abc": "abc",<br/>  "nullProp": null,<br/>  "undefinedProp": "undefined",<br/>  "notNum": null,<br/>  "infinity": "Infinity"<br/>}</span></pre><p id="1f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">replace</code>函数所做的是使用键和值添加额外的解析，这些值来自用<code class="fe lv lw lx ly b">JSON.stringify</code>转换的对象。它检查<code class="fe lv lw lx ly b">value</code>是否是一个函数，然后我们将它转换成一个字符串并返回它。同样，对于<code class="fe lv lw lx ly b">NaN</code>、<code class="fe lv lw lx ly b">Infinity</code>和<code class="fe lv lw lx ly b">undefined</code>，我们做了同样的事情。否则，我们按原样返回值。</p><p id="4be6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">JSON.stringfy</code>函数的第三个参数接受一个数字来设置要插入到JSON输出中的空格数，以使输出更具可读性。第三个参数也可以接受任何要插入的字符串，而不是空格。请注意，如果我们将一个字符串作为第三个参数，而该参数包含除空格之外的内容，我们可能会创建一个“JSON”一个不是有效JSON的字符串。</p><p id="d2bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们写:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="a9ea" class="na ma it ly b gy nb nc l nd ne">const obj = {<br/>  fn1() {},<br/>  foo: 1,<br/>  bar: 2,<br/>  abc: 'abc',<br/>  nullProp: null,<br/>  undefinedProp: undefined,<br/>  notNum: NaN,<br/>  infinity: Infinity<br/>}</span><span id="a3f0" class="na ma it ly b gy ng nc l nd ne">const replacer = (key, value) =&gt; {<br/>  if (value instanceof Function) {<br/>    return value.toString();<br/>  } else if (value === NaN) {<br/>    return 'NaN';<br/>  } else if (value === Infinity) {<br/>    return 'Infinity';<br/>  } else if (typeof value === 'undefined') {<br/>    return 'undefined';<br/>  } else {<br/>    return value; // no change<br/>  }<br/>}</span><span id="0ff0" class="na ma it ly b gy ng nc l nd ne">const jsonString = JSON.stringify(obj, replacer, 'abc');<br/>console.log(jsonString);</span></pre><p id="af2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe lv lw lx ly b">console.log</code>将会是:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="eeff" class="na ma it ly b gy nb nc l nd ne">{<br/>abc"fn1": "fn1() {}",<br/>abc"foo": 1,<br/>abc"bar": 2,<br/>abc"abc": "abc",<br/>abc"nullProp": null,<br/>abc"undefinedProp": "undefined",<br/>abc"notNum": null,<br/>abc"infinity": "Infinity"<br/>}</span></pre><p id="b2d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这显然不是有效的JSON。<code class="fe lv lw lx ly b">JSON.stringify</code>会抛出一个“循环对象值”类型错误。同样，如果一个对象有<code class="fe lv lw lx ly b">BigInt</code>值，那么转换将失败，并显示“BigInt值不能在JSON中序列化”类型错误。</p><p id="944e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另请注意，如果符号被用作对象中的关键字，它们会被<code class="fe lv lw lx ly b">JSON.stringify</code>自动丢弃。所以如果我们有:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="11e3" class="na ma it ly b gy nb nc l nd ne">const obj = {<br/>  fn1() {},<br/>  foo: 1,<br/>  bar: 2,<br/>  abc: 'abc',<br/>  nullProp: null,<br/>  undefinedProp: undefined,<br/>  notNum: NaN,<br/>  infinity: Infinity,<br/>  [Symbol('foo')]: 'foo'<br/>}</span><span id="92e1" class="na ma it ly b gy ng nc l nd ne">const replacer = (key, value) =&gt; {</span><span id="fc27" class="na ma it ly b gy ng nc l nd ne">if (value instanceof Function) {<br/>    return value.toString();<br/>  } else if (value === NaN) {<br/>    return 'NaN';<br/>  } else if (value === Infinity) {<br/>    return 'Infinity';<br/>  } else if (typeof value === 'undefined') {<br/>    return 'undefined';<br/>  } else {<br/>    return value; // no change<br/>  }<br/>}</span><span id="09df" class="na ma it ly b gy ng nc l nd ne">const jsonString = JSON.stringify(obj, replacer, 2);<br/>console.log(jsonString);</span></pre><p id="325b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们回来了:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="dfde" class="na ma it ly b gy nb nc l nd ne">{<br/>  "fn1": "fn1() {}",<br/>  "foo": 1,<br/>  "bar": 2,<br/>  "abc": "abc",<br/>  "nullProp": null,<br/>  "undefinedProp": "undefined",<br/>  "notNum": null,<br/>  "infinity": "Infinity"<br/>}</span></pre><p id="9569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用与<code class="fe lv lw lx ly b">date.toISOString()</code>将返回的相同的字符串，日期对象被转换成字符串。例如，如果我们把:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="51ea" class="na ma it ly b gy nb nc l nd ne">const obj = {<br/>  fn1() {},<br/>  foo: 1,<br/>  bar: 2,<br/>  abc: 'abc',<br/>  nullProp: null,<br/>  undefinedProp: undefined,<br/>  notNum: NaN,<br/>  infinity: Infinity,<br/>  [Symbol('foo')]: 'foo',<br/>  date: new Date(2019, 1, 1)<br/>}<br/>const replacer = (key, value) =&gt; {<br/>  if (value instanceof Function) {<br/>    return value.toString();<br/>  } else if (value === NaN) {<br/>    return 'NaN';<br/>  } else if (value === Infinity) {<br/>    return 'Infinity';<br/>  } else if (typeof value === 'undefined') {<br/>    return 'undefined';<br/>  } else {<br/>    return value; // no change<br/>  }<br/>}<br/>const jsonString = JSON.stringify(obj, replacer, 2);<br/>console.log(jsonString);</span></pre><p id="dc83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="64e4" class="na ma it ly b gy nb nc l nd ne">{<br/>  "fn1": "fn1() {}",<br/>  "foo": 1,<br/>  "bar": 2,<br/>  "abc": "abc",<br/>  "nullProp": null,<br/>  "undefinedProp": "undefined",<br/>  "notNum": null,<br/>  "infinity": "Infinity",<br/>  "date": "2019-02-01T08:00:00.000Z"<br/>}</span></pre><p id="b028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe lv lw lx ly b">date</code>属性的值在转换成JSON后现在是一个字符串。</p><h1 id="872f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">深层复制对象</h1><p id="5283" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们也可以使用<code class="fe lv lw lx ly b">JSON.stringify</code>和<code class="fe lv lw lx ly b">JSON.parse</code>来制作JavaScript对象的深层副本。例如，要在没有库的情况下做一个对象的深层拷贝，你可以<code class="fe lv lw lx ly b">JSON.stringify</code>然后<code class="fe lv lw lx ly b">JSON.parse</code>:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="6945" class="na ma it ly b gy nb nc l nd ne">const a = { foo: {bar: 1, {baz: 2}}<br/>const b = JSON.parse(JSON.stringfy(a)) // get a clone of a which you can change with out modifying a itself</span></pre><p id="abfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是对对象的深层复制，这意味着对象的所有级别都被克隆，而不是引用原始对象。这是因为<code class="fe lv lw lx ly b">JSON.stringfy</code>将对象转换成了一个不可变的字符串，当<code class="fe lv lw lx ly b">JSON.parse</code>解析字符串返回一个不引用原始对象的新对象时，就会返回一个副本。</p></div></div>    
</body>
</html>