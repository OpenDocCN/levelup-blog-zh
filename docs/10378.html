<html>
<head>
<title>CI/CD for .net 6, using GitHub actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CI/CD用于。使用GitHub动作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ci-cd-for-net-6-using-github-actions-a81fde5c5da2?source=collection_archive---------15-----------------------#2021-11-29">https://levelup.gitconnected.com/ci-cd-for-net-6-using-github-actions-a81fde5c5da2?source=collection_archive---------15-----------------------#2021-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/28ac3e43d2fcca7563a740947f6765d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7-k7EKk7O_MsftaG.PNG"/></div></div></figure><p id="668b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着《奥尔良》的出版。SyncWork ，我有机会探索GitHub动作——这是一种自动化工作流的方式。下面是我第一次体验“行动”(呻吟)。</p><h1 id="8634" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">自动化工作流程</h1><p id="756b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">首先，什么是工作流，自动化意味着什么？亲爱的潜在读者，工作流只不过是完成一项任务的一系列步骤。</p><p id="9731" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自<a class="ae kz" href="https://en.wikipedia.org/wiki/Workflow" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="md me mf"><p id="bf23" class="kb kc mg kd b ke kf kg kh ki kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ky im bi translated"><em class="it">一个工作流由一个编排好的可重复的活动模式组成，通过将资源系统地组织成转换材料、提供服务或处理信息的过程来实现。它可以被描述为一系列操作、一个人或一组人的工作、一个员工组织的工作，或者一个或多个简单或复杂的机制。</em></p></blockquote><p id="34ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以将工作流视为完成“某件事”所采取的步骤。“某物”可以是任何数量的事物，与任何数量的主题相关。在这篇文章的上下文中，我们将主要讨论与构建和发布管道相关的工作流，通常也称为持续集成(CI)和持续交付(CD)。</p><p id="c379" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想涵盖奥尔良的CI和CD两个方面。SyncWork ，那么我们开始吧。</p><h1 id="bfa1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">你(可能)需要什么</h1><ul class=""><li id="7665" class="mk ml it kd b ke ly ki lz km mm kq mn ku mo ky mp mq mr ms bi translated">使用<a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/core/tools/" rel="noopener ugc nofollow" target="_blank"> CLI </a>的经验</li><li id="e0ec" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">为了构建、测试和部署您的代码，您需要采取的步骤的概念。如果这些步骤已经以CLI命令的形式出现在您的脑海中，那么您已经成功了！</li><li id="e3fa" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">在让你的工作流程合理布局方面需要一些耐心</li></ul><h1 id="b0f4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">连续累计</h1><p id="5e23" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在您能够通过工作流(连续交付)部署代码之前，您需要能够将它安全地集成到您的主/主干中。对于dotnet，通过一些CLI命令，代码的构建和测试非常简单。做CI还有一个额外的好处，那就是每次都会为构建带来一个全新的环境，这也是为什么我这么长时间以来一直支持<a class="ae kz" href="https://blog.kritner.com/2015/01/21/And-its-like-whats-the-deal-with-build-servers" rel="noopener ugc nofollow" target="_blank">构建服务器</a>的原因。</p><h1 id="c3ed" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">建设</h1><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="e34e" class="nh lb it nd b gy ni nj l nk nl">dotnet build</span></pre><p id="a222" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的命令是在dotnet端构建解决方案文件或项目文件所需的最少命令。从持续集成的角度来看，您可能希望在命令中添加一些标志，例如:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="f33c" class="nh lb it nd b gy ni nj l nk nl">dotnet build --configuration release</span></pre><p id="b4b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和诸如此类的事情，看看用<a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-build" rel="noopener ugc nofollow" target="_blank"> dotnet build </a>文档你能得到什么。</p><p id="ba6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从CLI看可能是这样的:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/8f2af6b9b35c61e12e40fe7ee783d65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7ZkYHLGjL03pHxQj.PNG"/></div></div></figure><h1 id="db08" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">试验</h1><p id="4aee" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">接下来是测试。我可能已经说了太多次了，但是<a class="ae kz" href="https://blog.kritner.com/2018/12/06/getting-started-with-xunit/" rel="noopener ugc nofollow" target="_blank">测试你的代码</a>！尤其是当你在建图书馆的时候！测试有助于确保您编写的代码确实如您所说的那样。此外，在某种程度上，测试被用作“文档”,如果测试被很好地命名，并且调用代码的方式类似于您的消费者将如何使用它，那么他们将在一个更好的地方开始使用您已经交付的东西。</p><p id="c6ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与<a class="ae kz" href="https://blog.kritner.com/2021/11/29/cicd-for-net6-with-github-actions/#build" rel="noopener ugc nofollow" target="_blank"> build </a>命令一样，test命令也非常简单:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="de63" class="nh lb it nd b gy ni nj l nk nl">dotnet test</span></pre><p id="1570" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，以上是绝对的最小命令，还有很多参数可以传递给<a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-test" rel="noopener ugc nofollow" target="_blank"> dotnet test </a>。</p><p id="b79f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从CLI看，测试运行可能如下所示:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/45d0664b0bb282835874d9274996f9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FJBfz_wqXbL9kqqf.PNG"/></div></div></figure><h1 id="adaa" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">CI操作</h1><p id="9665" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">有了上面的<code class="fe no np nq nd b">dotnet build</code>和<code class="fe no np nq nd b">dotnet test</code>命令，我们就有了<em class="mg">大部分</em>自动构建和测试代码所需的东西！</p><p id="839c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有很多好的信息，甚至一些特定的。对<a class="ae kz" href="https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net" rel="noopener ugc nofollow" target="_blank">文档</a>进行净测试。我基本上是以文档作为起点，并以这个结尾…</p><p id="ea6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">。github/workflows/ci.yml:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="bd83" class="nh lb it nd b gy ni nj l nk nl">name: Build and test<br/><br/>on:<br/>  pull_request:<br/>    branches: [ main ]<br/><br/>jobs:<br/>  build:<br/><br/>    runs-on: ubuntu-latest<br/><br/>    steps:<br/>    - uses: actions/checkout@v2<br/>      with:<br/>        fetch-depth: 0<br/><br/>    - name: Setup .NET<br/>      uses: actions/setup-dotnet@v1<br/>      with:<br/>        dotnet-version: 6.0.x<br/>    <br/>    - name: Restore dependencies<br/>      run: dotnet restore<br/>    <br/>    - name: Build<br/>      run: dotnet build -c Release --no-restore<br/>    <br/>    - name: Test<br/>      run: dotnet test -c Release --no-build --verbosity normal --filter "Category!=LongRunning"</span></pre><p id="4e15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的文件应该非常简单，首先我们用<code class="fe no np nq nd b">name</code>给我们的工作流命名，指定工作流的触发器，在本例中是“针对主分支的拉请求”。然后，该文件继续定义作业“build ”,它指定要运行的操作系统，然后执行步骤。这些步骤做了一些值得注意的事情:</p><ul class=""><li id="cf68" class="mk ml it kd b ke kf ki kj km nr kq ns ku nt ky mp mq mr ms bi translated">签出代码，将其放入上一步中使用的ubuntu实例中</li><li id="1142" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">设置。带有预建操作的. NET</li><li id="1058" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">恢复依赖关系</li><li id="a908" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">在项目根目录下生成解决方案文件</li><li id="b897" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">最后测试代码</li></ul><p id="b6fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的构建和测试命令中有一些新的标志，即指定发布的配置，并且不在已经发生的步骤上恢复/构建。最后一点要注意的是<code class="fe no np nq nd b">--filter "Category!=LongRunning"</code>——我在测试运行人员通过我布置的测试时遇到了麻烦。他们花了3分钟在本地运行，但是在构建代理上运行了超过25分钟。由于这个事实，我将一些“category”的分类添加到长时间运行的测试中，并在上面的ci.yml文件中将它们从测试运行中排除。</p><h1 id="d120" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">连续交货</h1><p id="77d7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">持续交付很像持续集成，并建立在它之上。我的想法是，裁谈会应该做CI应该做的一切，或者甚至更好，实际上依靠CI，而不是像我最后做的那样重新定义你的CICD的步骤。这有点乱，但是CD应该做CI应该做的所有事情，除了额外的步骤，即作为其工作流程的一部分，实际上<em class="mg">交付</em>(部署/推送)代码。</p><h1 id="b28c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">交付复杂性</h1><p id="72b1" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">与“CI”相比，交付部分可能有许多细微差别，从而大大增加了复杂性。实际交付代码是什么意思？这很大程度上取决于你实际交付的代码类型。在我的例子中，我正在交付一个NuGet包，它有自己的复杂性，但是还有什么呢？我想到的另一件显而易见的事情是网站/ web api，除了代码之外，它还可能会有数据库更改。对我来说，这可能比仅仅推出一个NuGet包要复杂得多。在web推送或数据库推送出现问题的情况下，如何不仅处理故障，而且检测故障并回滚？也许有一天我能够探索这个问题，但是现在，让我们回到NuGet包。</p><p id="703e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，交付一个NuGet包是否很复杂呢？是的。手动部署时，NuGet包版本控制可能是一项大工程，更不用说CD了；因为要求NuGet包是不可变的。这是否意味着对于每一个的<em class="mg">检入，在<em class="mg">的每一个</em>潜在分支将被推送到NuGet，你需要更新一些文本文件或代码来指示下一个构建版本？这是我最初的想法，但谢天谢地，在Nerdbank的帮助下，情况并非如此。GitVersioning </em></p><p id="800e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不认为我有我的CICD设置<em class="mg">确切地说</em>我将如何结束拥有它，但现在它的工作。我安装了NerdBank。GitVersioning工具和包，现在对于每一个构建，我在构建时获得NuGet包的唯一版本号。我可以在预发布或发布包之间切换，甚至可以发布包含提交散列的“夜间”构建，所有这些都以唯一可识别的NuGet包的名义进行。</p><p id="dc8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有相当多的设置，在某些方面我仍在努力，但这篇文章已经够长了，如果你好奇，看看这些公关:【https://github.com/OrleansContrib/Orleans.SyncWork/pull/8和<a class="ae kz" href="https://github.com/OrleansContrib/Orleans.SyncWork/pull/13" rel="noopener ugc nofollow" target="_blank">https://github.com/OrleansContrib/Orleans.SyncWork/pull/13</a>。它的“tldr”是，<code class="fe no np nq nd b">nbgv</code>工具使用git历史来修订构建期间使用的版本号，允许每次CI/CD触发时使用唯一的构建号。</p><h1 id="bc31" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">CD动作</h1><p id="7f90" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">到目前为止，已经有了相当多的信息，但是在我们的CI动作和关于GitVersioning的信息之间，我们已经有了我们需要的所有东西来组合“第一遍”cicd.yml。对于CD，当代码被<em class="mg">推送到</em>main，以及以“RELEASE/v*”开头的分支时，我们将希望进行交付。我在这里的想法是，由于我们将经常集成到main中(理论上)，我们不一定要为每个提交给main的<em class="mg">创建完整的“新发布包”。然而，我们可以为每次提交创建“预发布”的NuGet包，使这些更改对NuGet提要可用，但它们不会被标记为发布版本。否则我有Nerdbank。GitVersioning设置为从“release/v*”分支发布包的“RELEASE”版本。</em></p><p id="4b4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CD操作文件本身看起来<em class="mg">非常</em>类似于CI文件，只是增加了一些<code class="fe no np nq nd b">dotnet nuget...</code>命令，如下所示:</p><p id="91c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">。github/workflows/cicd.yml</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="f4ca" class="nh lb it nd b gy ni nj l nk nl">name: Build, test, and deploy<br/><br/>on:<br/>  push:<br/>    branches:<br/>      - 'main'<br/>      - 'RELEASE/v**'<br/><br/><br/>jobs:<br/>  build:<br/><br/>    runs-on: ubuntu-latest<br/><br/>    steps:<br/>    - uses: actions/checkout@v2<br/>      with:<br/>        fetch-depth: 0<br/><br/>    - name: Setup .NET<br/>      uses: actions/setup-dotnet@v1<br/>      with:<br/>        dotnet-version: 6.0.x<br/>    <br/>    - name: Restore dependencies<br/>      run: dotnet restore<br/>    <br/>    - name: Build<br/>      run: dotnet build -c Release --no-restore<br/>    <br/>    - name: Test<br/>      run: dotnet test -c Release --no-restore --no-build --verbosity normal --filter "Category!=LongRunning"<br/><br/>    - name: Pack<br/>      run: dotnet pack src/Orleans.SyncWork/Orleans.SyncWork.csproj -c Release --no-restore --no-build --include-symbols -p:SymbolPackageFormat=snupkg -o .<br/><br/>    - name: Push to NuGet<br/>      run: dotnet nuget push *.nupkg --skip-duplicate -s <a class="ae kz" href="https://api.nuget.org/v3/index.json" rel="noopener ugc nofollow" target="_blank">https://api.nuget.org/v3/index.json</a> -k ${{secrets.NUGET_API_KEY}}</span></pre><p id="73c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的内容中，您会注意到有超过50%的内容是与CI“相同的文件”。我可能会在某个时候研究一下<a class="ae kz" href="https://docs.github.com/en/actions/creating-actions/creating-a-composite-action" rel="noopener ugc nofollow" target="_blank">复合动作</a>，看看我是否可以将CI和CD“链接”起来，而不是在CD文件中重新定义CI；但是我还没有机会去探索。</p><p id="4793" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了对“on”事件的更改(pull_request -&gt; push)，底部还有两个新命令<code class="fe no np nq nd b">dotnet pack</code>和<code class="fe no np nq nd b">dotnet nuget push</code>。<code class="fe no np nq nd b">dotnet pack</code>命令用于将指定的项目打包成一个。nupkg”文件(在这种情况下，符号为snupkg)。最后，使用<code class="fe no np nq nd b">dotnet nuget push</code>命令将新打包的NuGet包推送到NuGet指定的feed。在这个命令中，你还可以看到命令的<code class="fe no np nq nd b">{{secrets.NUGET_API_KEY}}</code>部分，它被定义为<a class="ae kz" href="https://docs.github.com/en/actions/security-guides/encrypted-secrets" rel="noopener ugc nofollow" target="_blank">库秘密</a>，它可以用来将“秘密”信息传递给工作流之类的东西，在这个例子中，它是我的NuGet API密钥。这些秘密可以从储存库的【设置】- &gt;“秘密”中设置:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/10b06d1ff3378dc9479fa1d3308c5026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Pckmh1zE3voR6f3.PNG"/></div></div></figure><h1 id="2aa4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">仍然要做</h1><p id="e898" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">“发布一个发布分支”对我来说仍然有点像手工操作。我需要从我的<em class="mg">本地</em>环境中运行<code class="fe no np nq nd b">nbgv prepare-release</code>，然后推进随后创建的“RELEASE/v*”分支，并更新在main下创建的新的预发布版本。</p><p id="7205" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这可能没有意义。</p><p id="84c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我在main中使用“1.0-预发布”的预发布版本，当我<code class="fe no np nq nd b">nbgv prepare-release</code>时，main将(作为一个例子)更新到“1.1-预发布”，并创建一个名为“RELEASE/v1.0”的分支，其发布版本为“1.0”。这两个变更的推送将<em class="mg">目前</em>构建“1.1-prerelease”的新预发布包和“1.0”的发布包，两者在推送时将包含“相同的内容”。</p><p id="b694" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不确定我对以上的感觉。我喜欢包的自动构建和部署，但是我不喜欢必须在本地创建发布。我可以设想创建一个手动分派的工作流来为我做这个发布准备，但是与“以前的”预发布包和正在构建的新发布包相比，立即推出一个没有任何变化的预发布包仍然会有一点奇怪。我还不确定“正确的流程”是什么，我现在拥有的<em class="mg">确实有效</em>，只是看起来有点<em class="mg">混乱。</em></p><p id="8432" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也许我最终会像这样研究工作流:</p><ul class=""><li id="6861" class="mk ml it kd b ke kf ki kj km nr kq ns ku nt ky mp mq mr ms bi translated">CI —继续在PRs至main上运行</li><li id="1966" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">CICD —可以在主分支和“RELEASE/v*”分支上执行，但是不能像现在这样自动执行</li><li id="18fb" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">准备发布工作流——在这个工作流中，我想做我目前准备发布所采取的“本地”步骤，但是通过github动作来做。</li></ul><h1 id="d8ed" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">参考</h1><ul class=""><li id="52ef" class="mk ml it kd b ke ly ki lz km mm kq mn ku mo ky mp mq mr ms bi translated"><a class="ae kz" href="https://github.com/OrleansContrib/Orleans.SyncWork" rel="noopener ugc nofollow" target="_blank">奥尔良。GitHub上的sync work</a></li><li id="4a1e" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Workflow" rel="noopener ugc nofollow" target="_blank">维基百科</a></li><li id="13e2" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated"><a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/core/tools/" rel="noopener ugc nofollow" target="_blank"> CLI </a></li><li id="c75d" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated"><a class="ae kz" href="https://blog.kritner.com/2015/01/21/And-its-like-whats-the-deal-with-build-servers" rel="noopener ugc nofollow" target="_blank">这就像是构建服务器有什么好处？</a></li><li id="b295" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">【XUnit入门</li><li id="3211" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated"><a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-build" rel="noopener ugc nofollow" target="_blank">点网构建</a></li><li id="0293" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated"><a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-test" rel="noopener ugc nofollow" target="_blank">网络测试</a></li><li id="bef9" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated"><a class="ae kz" href="https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net" rel="noopener ugc nofollow" target="_blank">构建和测试用。NET使用GitHub动作</a></li><li id="030e" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">Nerdbank。GitVersioning </li><li id="ab47" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated"><a class="ae kz" href="https://docs.github.com/en/actions/creating-actions/creating-a-composite-action" rel="noopener ugc nofollow" target="_blank"> GitHub复合动作</a></li><li id="02a1" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated"><a class="ae kz" href="https://docs.github.com/en/actions/security-guides/encrypted-secrets" rel="noopener ugc nofollow" target="_blank"> GitHub加密的秘密</a></li></ul></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="7d96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mg">原载于2021年11月29日https://blog.kritner.com</em><em class="mg"><a class="ae kz" href="https://blog.kritner.com/2021/11/29/cicd-for-net6-with-github-actions/" rel="noopener ugc nofollow" target="_blank"><em class="mg">。</em></a></em></p></div></div>    
</body>
</html>