<html>
<head>
<title>Two Instructive Binary Search Problems: Explained with Thought Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两个指导性的二分搜索法问题:用思维过程解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/two-instructive-binary-search-problems-explained-with-thought-process-1584982525d1?source=collection_archive---------18-----------------------#2021-07-05">https://levelup.gitconnected.com/two-instructive-binary-search-problems-explained-with-thought-process-1584982525d1?source=collection_archive---------18-----------------------#2021-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c01f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">二分搜索法是一个强大的算法。请看两个关于如何使用它的有启发性的例子。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80f66236b25feb8f8df492ab6ef44407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MS9FgqfPaMC3Et8f"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@worthyofelegance?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历克斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看看两个二分搜索法问题，并了解其解决方案背后的思维过程。我认为，与其简单地陈述解决方案，不如看看你是如何得出解决方案的，这会让你更好地理解。</p><p id="13a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们应该回顾一下基本的二分搜索法算法。它的工作方式是这样的。我们有一个排序的升序列表，我们正在列表中搜索一个数字。我们查看列表的中间值，检查我们要找的数字是大还是小。如果再大一点，我们就可以剔除列表的前半部分。否则，我们可以删除列表的后半部分。然后，我们再次做同样的事情(取中间值，消除一半列表)，直到我们找到我们的号码。现在我们来看看第一个问题。</p><h1 id="284b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题1</h1><blockquote class="mn mo mp"><p id="ff7e" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">我们有一个按升序排序的整数列表。可能会有重复。我们想找到一个给定数字的开始和结束索引。例如，我们可能有列表[3，4，5，5，6]。假设给定的数字是5。那么起始索引是2，结束索引是4。</p></blockquote><p id="c7cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该如何处理这个问题？首先，我们可以尝试使用普通的二分搜索法。我们最终会在列表中找到我们想要的数字和索引。如果没有我们想要查找的重复数字，那么起始和结束索引将是相同的。那我们就完事了。不幸的是，可能会有我们想要的数字的副本，所以开始和结束索引可能不会相同。我们需要不同的解决方案。</p><p id="d4a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我们不能只插入常规的二分搜索法算法。不如我们先试着找到起始索引。然后我们想，与其他索引(我们想要的数字的副本的索引)相比，是什么使起始索引特别？<strong class="lb iu">它的特别之处在于它是第一个指数。因此，它之前的索引将对应于一个不同的、更小的数字。</strong>我们如何利用这一点？在二分搜索法的每个时间步，我们不仅检查列表中的数字是否等于、大于或小于我们想要查找的数字，还检查列表中的前一个数字是否更小。如果这两个标准都满足，我们知道我们已经找到了起始索引。下面是伪代码:</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="edab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义函数find_starting_index(列表L，编号n):</p><ul class=""><li id="6e75" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">求l的中值指数，称之为m。</li><li id="0cb1" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">如果list[m] &lt; n，从索引m+1开始取L的子列表。在子列表上运行find_starting_index。</li><li id="0a76" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">如果list[m] = n，则检查list[m-1]是否小于n，如果是，则我们完成并返回m，否则，取L的子列表，在索引m-1处结束。在子列表上运行find_starting_index。</li><li id="f559" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">如果list[m] &gt; n，取L的子列表，在索引m-1处结束。在子列表上运行find_starting_index。</li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="a7f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，我们想出了一个找到起始索引的方法。现在我们要做的就是找到结束索引。我们对自己说:等等，我们不能基本上做同样的事情吗？事实证明，是的。求结束索引的思路很类似。我们意识到，<strong class="lb iu">结束索引的特殊之处在于，下一个索引将对应于一个更大的数字，而不是同一个数字</strong>。这类似于起始索引的特殊属性，正如我们所说的，前一个索引将对应于一个较小的数，而不是相同的数。所以伪代码是类似的:</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="9915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义函数find_ending_index(列表L，编号n):</p><ul class=""><li id="3c29" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">求l的中值指数，称之为m。</li><li id="03b7" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">如果list[m] &lt; n, take the sublist of L starting from index m+1. Run find_starting_index on the sublist.</li><li id="1c6b" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">If list[m] = n, check if list[m+1] is larger than n. If so, we are done and return m. Otherwise, take the sublist of L starting at index m+1. Run find_starting_index on the sublist.</li><li id="60c6" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">If list[m] &gt; n，取L的子列表，结束于索引m-1。在子列表上运行find_starting_index。</li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="664f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完了。现在我们转到第二个问题。</p><h1 id="beec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题2</h1><blockquote class="mn mo mp"><p id="603a" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">我们有两个相同大小的升序列表。我们想找到组合列表的中间值。</p></blockquote><p id="3d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能尝试的第一个合乎逻辑的事情是，当我们得到两个列表的中间值时，看看会发生什么。这些中间值之一是最终答案吗？仔细想想，不幸的是，两个中间值都不是两个列表的中间值。要了解这一点，请考虑列表1为[1，2，3，4，5]，列表2为[6，7，8，9，10]的示例。列表1的中位数是3，列表2的中位数是8。综合榜单的中位数是5.5。</p><p id="bad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这没用。我们可以尝试的另一个非常直观的方法是首先合并列表，然后找到中间值。但是，这样做的问题是，一旦将两个列表合并，它们可能不再排序。要解决这个问题，我们必须对组合列表进行排序。一旦我们这样做了，这种方法就有效了，但是对列表进行排序需要O(nlog(n))时间。我们能做得更好吗？</p><p id="254d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">二分搜索法花费O(log(n))时间的原因是，在每次迭代中，我们可以消除一半的元素。或许我们可以遵循“排除一半元素”的直觉，想出点什么来。既然我们有两个列表，也许在第一次迭代中我们可以去掉其中一个？这显然也行不通。考虑我们之前的例子[1，2，3，4，5]和[6，7，8，9，10]。消除这两个列表中的任何一个都会给另一个列表留下不正确的中值。</p><p id="c37f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望消除一半的元素，但我们不能完全消除任何一个列表。唯一剩下的选择是消除每个列表的一半。这怎么可能呢？两个列表都有前半部分和后半部分。在有一个列表的常规二分搜索法中，一个列表的前半部分或后半部分被消除。受此启发，我们对这两个列表有了另一个想法:要么去掉前半部分，要么去掉后半部分。不幸的是，这可能会消除中间值。考虑[1，2，3，4]和[5，6，7，8]，真实中值为4.5。去掉这两个前半部分将得到[3，4]和[7，8]，得出中位数5.5。去掉两个后半部分将得到[1，2]和[5，6]，从而得到3.5的中值。这两个答案都是错的。</p><p id="9dfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们毫不畏惧，继续思考。一个列表的二分搜索法的每次迭代是如何工作的？我们在每次迭代中去掉一半的元素，我们通过取列表的中间值并与我们想要的数字进行比较来做到这一点。也许我们可以专注于两个列表的中间值，而不是专注于消除一半的元素。假设我们算法的每次迭代的第一步是取两个列表的中值并比较它们。我们能从中收集到什么信息吗？</p><p id="9c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，让我们假设列表1的中值大于列表2的中值。这意味着列表2的前半部分小于列表2的后半部分(很明显)，<strong class="lb iu">，也小于列表1的后半部分</strong>。换句话说，列表2的前半部分不到组合列表(列表1 +列表2)的一半。因此，列表2前半部分中唯一能影响组合中值的元素是最后一个。其余的都无关紧要。按照类似的逻辑，列表1的后半部分大于组合列表的一半。因此，列表2的后半部分中唯一能够影响组合中值的元素是第一个元素。其他的都无关紧要。由于不相关的部分大小相同，并且位于组合中间值的相对两侧，因此我们可以消除所有不相关的部分，移除几乎一半的组合元素。</p><p id="dac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一次迭代中，我们可以再次做同样的事情——比较两个新列表的中值，并根据哪个中值更大来消除每个列表的大约一半。最后，如果两个列表的中间值相等，这意味着这个中间值大于组合元素的一半，小于另一半。所以是最终答案！伪代码是:</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="67b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义函数find_combined_median(列出L1，列出L2):</p><ul class=""><li id="4714" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">找出两个列表的中间值，称之为m1和m2。把L1和L2分成两半，L1 a和L1 b，L2 a和L2 b</li><li id="7e1e" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">如果m1 &gt; m2，组合L1_a和L1_b的第一个元素。组合L2_a和L2_b的最后一个元素。对这两个新列表运行find_combined_median。</li><li id="dfa7" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">如果m1 = m2，则返回m1。</li><li id="0b26" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">如m1&lt; m2, combine the last element of L1_a and L1_b. Combine L2_a and the first element of L2_b. Run find_combined_median on these two new lists.</li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="eff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">That was tricky, but we managed to solve it.</p><p id="54b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">I hope seeing the thought process behind solving these two problems deepened your understanding of how to use binary search concepts. These problems are taken from LeetCode (problems <a class="ae ky" href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" rel="noopener ugc nofollow" target="_blank">34</a>/中、<a class="ae ky" href="https://leetcode.com/problems/median-of-two-sorted-arrays/" rel="noopener ugc nofollow" target="_blank">4</a>/硬，略有修改)。让我知道你的想法，感谢你的阅读！</p></div></div>    
</body>
</html>