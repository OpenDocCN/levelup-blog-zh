<html>
<head>
<title>How to approach image overlay problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决图像重叠问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-approach-image-overlay-problems-ad2d4a8e22bc?source=collection_archive---------5-----------------------#2020-06-05">https://levelup.gitconnected.com/how-to-approach-image-overlay-problems-ad2d4a8e22bc?source=collection_archive---------5-----------------------#2020-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1e3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个图像都有三个通道:R、G、B，即红色、绿色和蓝色，用于定义图像中任意点的像素值，其中红色、绿色或蓝色的值介于0-255之间。</p><p id="7d5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:<code class="fe ko kp kq kr b">[255, 0, 0]</code>的像素值将全部是红色，而<code class="fe ko kp kq kr b">[255, 255, 0]</code>将是红色和绿色的混合，这给出了黄色。</p><p id="fbf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果使用OpenCV读取图像，它会生成BGR格式的图像，也就是说，<code class="fe ko kp kq kr b">[255, 0, 0]</code>会是蓝色等等。</p><h1 id="2346" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">安装OpenCV </strong></h1><p id="4cfd" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">OpenCV是一个用于Python或C语言图像操作的开源库。</p><p id="8cd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于Python OpenCV可以使用<code class="fe ko kp kq kr b">pip install opencv-python</code>下载。</p><h1 id="f73b" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">在OpenCV中读取图像</strong></h1><p id="059d" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">使用<code class="fe ko kp kq kr b">cv2.imread()</code>命令可以在opencv中读取任何图像。不过OpenCV还不支持HEIC图片，你可能要用Pillow之类的另一个库来读取HEIC图片(或者转换成。JPEG优先)。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="b599" class="md kt it kr b gy me mf l mg mh">import cv2</span><span id="798e" class="md kt it kr b gy mi mf l mg mh">image = cv2.imread(‘image.jpg’)</span></pre><p id="e8df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">读取图像后，如果需要，可以使用<code class="fe ko kp kq kr b">cv2.cvtColor()</code>命令将其从BGR转换为RGB格式。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="0fb3" class="md kt it kr b gy me mf l mg mh">image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><span id="adeb" class="md kt it kr b gy mi mf l mg mh">image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span></pre><h1 id="3fdc" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">覆盖图</strong></h1><p id="b530" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">图像只不过是以类似矩阵的格式存储的一堆像素值。任何像素的值都可以独立于其他像素而改变。</p><p id="a13a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设有一个图像</p><figure class="lv lw lx ly gt mk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/f69870aa35758755e0eae8ff64f56a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*XgyADwwHbdnHXcd2pOnM8A.jpeg"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图片_1</figcaption></figure><p id="4bcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用opencv读取图像:</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="61d8" class="md kt it kr b gy me mf l mg mh">image_1 = cv2.imread(‘image_1.jpg’)</span><span id="5ef6" class="md kt it kr b gy mi mf l mg mh">print(image_1)</span></pre><p id="6403" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这给出了矩阵形式的一堆像素值。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="fa2a" class="md kt it kr b gy me mf l mg mh">array([[[107, 108, 106],</span><span id="246a" class="md kt it kr b gy mi mf l mg mh">[107, 108, 106],</span><span id="e770" class="md kt it kr b gy mi mf l mg mh">[107, 108, 106],</span><span id="7158" class="md kt it kr b gy mi mf l mg mh">…,</span><span id="8ea5" class="md kt it kr b gy mi mf l mg mh">[ 77, 78, 76],</span><span id="8baf" class="md kt it kr b gy mi mf l mg mh">[ 77, 78, 76],</span><span id="566e" class="md kt it kr b gy mi mf l mg mh">[ 76, 77, 75]],</span><span id="91f1" class="md kt it kr b gy mi mf l mg mh">…,</span><span id="d65c" class="md kt it kr b gy mi mf l mg mh">[[ 93, 88, 87],</span><span id="7812" class="md kt it kr b gy mi mf l mg mh">[ 93, 88, 87],</span><span id="3125" class="md kt it kr b gy mi mf l mg mh">[ 92, 87, 86],</span><span id="2012" class="md kt it kr b gy mi mf l mg mh">…,</span><span id="5ce6" class="md kt it kr b gy mi mf l mg mh">[ 52, 62, 62],</span><span id="0e47" class="md kt it kr b gy mi mf l mg mh">[ 52, 62, 62],</span><span id="0e00" class="md kt it kr b gy mi mf l mg mh">[ 52, 62, 62]]], dtype=uint8)</span></pre><p id="cc9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你只是改变图像的某个区域的像素值，比如说<code class="fe ko kp kq kr b">[0, 0, 0]</code>，图像的那个区域就会变成黑色，因为那是黑色的像素值。类似地，如果您将像素值更改为<code class="fe ko kp kq kr b">[255, 0, 0]</code>，该区域将变成蓝色(OpenCV读取BGR格式的图像)。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="9b7a" class="md kt it kr b gy me mf l mg mh">image_1[50: 100, 50:100] = [255, 0, 0]</span></pre><figure class="lv lw lx ly gt mk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/47f1042e4c8537cf3c82e5384efa6c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*gM5ij0Qm6OmTwGnR7ZVfKA.jpeg"/></div></figure><p id="1c35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似地，这些像素值可以被另一个图像替换，只需使用该图像的像素值。</p><p id="0e07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，您必须将叠加图像的形状调整为您想要替换其像素值的大小。</p><p id="522c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以通过使用<code class="fe ko kp kq kr b">cv2.resize()</code>功能来完成。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="8309" class="md kt it kr b gy me mf l mg mh">image_2 = cv2.imread(‘image_2.jpg’)</span><span id="ade4" class="md kt it kr b gy mi mf l mg mh">resized_image_2 = cv2.resize(image_2, dsize=(100, 100))</span></pre><p id="f5b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，<code class="fe ko kp kq kr b">dsize</code>接受图像要调整的尺寸</p><p id="98f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，第二个图像可以覆盖在第一个图像的顶部。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="836c" class="md kt it kr b gy me mf l mg mh">image_1[50:150, 50:150] = resized_image_2</span></pre><figure class="lv lw lx ly gt mk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/ce0b87c0716b59fc473e6581a637afa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*E0fWFABvt0L-26xVhViJxg.jpeg"/></div></figure><h1 id="eaec" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">叠加PNG图像</strong></h1><p id="7811" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">与JPEG图像不同，PNG(便携式网络图形)图像中也可以有第四个通道，它定义给定像素的ALPHA(不透明度)。</p><p id="e806" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除非另有说明，OpenCV读取png的方式与读取JPEGs的方式相同(即有3个通道)。</p><p id="2232" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要读取带有Alpha值的PNG图像，我们需要在读取图像时指定标志<code class="fe ko kp kq kr b">cv2.IMREAD_UNCHANGED </code>。</p><p id="7e72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，图像阅读器有4个频道:BGRA。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="d991" class="md kt it kr b gy me mf l mg mh">image_3 = cv2.imread(‘image_3.png’, cv2.IMREAD_UNCHANGED)</span><span id="252a" class="md kt it kr b gy mi mf l mg mh">print(image_3)</span><span id="fd59" class="md kt it kr b gy mi mf l mg mh">array([[[0 0 0 0]</span><span id="ad69" class="md kt it kr b gy mi mf l mg mh">[0 0 0 0]</span><span id="5a66" class="md kt it kr b gy mi mf l mg mh">[0 0 0 0]</span><span id="8909" class="md kt it kr b gy mi mf l mg mh">…</span><span id="63d2" class="md kt it kr b gy mi mf l mg mh">[0 0 0 0]</span><span id="9f7c" class="md kt it kr b gy mi mf l mg mh">[0 0 0 0]</span><span id="d022" class="md kt it kr b gy mi mf l mg mh">[0 0 0 0]]</span><span id="89b7" class="md kt it kr b gy mi mf l mg mh">…</span><span id="374f" class="md kt it kr b gy mi mf l mg mh">[[0 0 0 0]</span><span id="833a" class="md kt it kr b gy mi mf l mg mh">[0 0 0 0]</span><span id="33b2" class="md kt it kr b gy mi mf l mg mh">[0 0 0 0]</span><span id="2100" class="md kt it kr b gy mi mf l mg mh">…</span><span id="5103" class="md kt it kr b gy mi mf l mg mh">[0 0 0 0]</span><span id="27a7" class="md kt it kr b gy mi mf l mg mh">[0 0 0 0]</span><span id="5452" class="md kt it kr b gy mi mf l mg mh">[0 0 0 0]]], dtype=uint8)</span></pre><p id="5bff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(<strong class="js iu">* *注:* </strong>打印的值都是0，因为图像的开始和结束都是空白的)</p><figure class="lv lw lx ly gt mk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/9551e61999dc5d0607b8f561b5525f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*R-utGCtvBqGXnwq361JJAA.png"/></div></figure><p id="5032" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，这个图像有4个通道，但我们的JPEG图像只有3个通道，所以这些值不能简单地被替换。</p><p id="399a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要在我们的JPEG图像中添加一个虚拟通道。</p><p id="f4d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们将使用一个<code class="fe ko kp kq kr b">numpy</code>。可以使用<code class="fe ko kp kq kr b">pip install numpy</code>安装。</p><p id="6f84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">numpy提供了一个函数<code class="fe ko kp kq kr b">numpy.dstack()</code>来沿着深度方向堆叠值。</p><p id="e39c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要一个与图像大小相同的虚拟数组。</p><p id="e2a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了创建一个虚拟通道，我们可以使用<code class="fe ko kp kq kr b">numpy.ones()</code>函数来创建一个数组。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="e086" class="md kt it kr b gy me mf l mg mh">import numpy as np</span><span id="297d" class="md kt it kr b gy mi mf l mg mh">ones = np.ones((image_1.shape[0], image_1.shape[1]))*255</span><span id="1ecb" class="md kt it kr b gy mi mf l mg mh">image_1 = np.dstack([image_1, ones])</span></pre><p id="a32a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将1的数组乘以255，因为alpha通道的值也存在于0-255之间。</p><p id="9e67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可以用PNG图像替换图像的像素值。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="fdb6" class="md kt it kr b gy me mf l mg mh">image_1[150:250, 150:250] = image_3</span></pre><p id="0c15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，它不会给出想要的结果，因为我们也改变了阿尔法通道的值为零。</p><figure class="lv lw lx ly gt mk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/736de5315e6c15b50d38d5378859c070.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*yfA-ZodeIfS7db8yOZdAJw.png"/></div></figure><p id="2ff4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只需要替换那些具有非零值的像素值。</p><p id="6793" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要做到这一点，你总是可以通过检查每个像素值并替换非零值来强行完成，但这很耗时。</p><p id="08ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，有更好的办法。</p><p id="2e3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以获取要覆盖的图像的alpha值。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="3c5d" class="md kt it kr b gy me mf l mg mh">alpha_image_3 = image_3[:, :, 3] / 255.0</span></pre><p id="f009" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将像素值除以255.0，以便将值保持在0-1之间。</p><p id="d20b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">image_1</code>和<code class="fe ko kp kq kr b">image_3</code>的alpha之和需要等于255。</p><p id="8c5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，您可以创建另一个数组，其中包含所需的alpha值，以使总和等于255。</p><p id="710a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">alpha_image = 1 — alpha_image_3</code></p><p id="4959" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可以简单地将每个图像的每个通道的alpha值和图像像素值按元素进行乘积，并对它们求和。</p><pre class="lv lw lx ly gt lz kr ma mb aw mc bi"><span id="fc34" class="md kt it kr b gy me mf l mg mh">for c in range(0, 3):</span><span id="67c6" class="md kt it kr b gy mi mf l mg mh">    image_1[150:250, 150:250, c] = ((alpha_image*image_1[150:250,      150:250, c]) + (alpha_image_3*image_3[:, :, c]))</span></pre><figure class="lv lw lx ly gt mk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/f36c0590ba64a21c1e6180f7e4300a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*LXDIfYCSQRsax8zPlU-dbg.png"/></div></figure><p id="5e51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">瞧啊。图像现在已经覆盖在另一个之上。ez pz:)</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><div class="lv lw lx ly gt mz"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">编写面试问题</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">技术开发</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ml mz"/></div></div></a></div></div></div>    
</body>
</html>