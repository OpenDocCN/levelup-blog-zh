<html>
<head>
<title>Syncing GitHub Forks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步GitHub分叉</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/syncing-github-forks-42306190bf91?source=collection_archive---------14-----------------------#2020-11-17">https://levelup.gitconnected.com/syncing-github-forks-42306190bf91?source=collection_archive---------14-----------------------#2020-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b90224d18aae3dd675098e631a0125ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nF98AC_upZsGhIplS4mdKA.png"/></div></div></figure><figure class="jy jz ka kb gt jr"><div class="bz fp l di"><div class="kc kd l"/></div><figcaption class="ke kf gj gh gi kg kh bd b be z dk translated">PS:查看我的相关视频来演示这篇文章所描述的内容(同步GitHub forks)☝🏼</figcaption></figure></div><div class="ab cl ki kj hu kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ij ik il im in"><p id="03c3" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以你已经听说了这个<em class="ln"> GitHub </em>的东西对于协作来说是非常好的。</p><p id="a866" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您发现有人在GitHub上启动了一个很棒的项目，并遵循了一些关于派生这个、克隆那个等方面的教程。您做了一些额外的工作，并对您的版本进行了一些提交。一切看起来都很好。</p><p id="73e6" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后你会发现，当你摆弄你的项目版本时，原作者加入了一个非常酷的特性。你想把它包含在你的版本中，但是你不确定怎么做。你可以试着开始复制和粘贴代码。或者干脆放弃你自己的工作，重新开发新版本。</p><p id="bf6e" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但你知道你能做得更好！你真是个坏蛋，想学什么就学什么。你认为其他人在从事新项目时也遇到了同样的问题。所以肯定有更好的方法。</p><p id="7d11" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有<em class="ln">是</em>更好的办法！进入GitHub <strong class="kr ir"> forks </strong>！然而，有一个警告。几乎所有的解决方案都会带来额外的复杂性。我们特别需要讨论同步你的叉子。如果您不确定fork到底是什么，下一节将给您一个简要的概述。如果您对分叉概念足够熟悉，可以跳过下一节。</p><h1 id="93c8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">什么叉子？</h1><p id="6591" class="pw-post-body-paragraph kp kq iq kr b ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">在我们进入任何关于处理GitHub分叉的具体细节之前，回顾一下什么是分叉可能会有所帮助。当探索新的主题时，正式文档通常是一个好的起点。GitHub做了一个很棒的<a class="ae mr" href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-forks" rel="noopener ugc nofollow" target="_blank">介绍</a>，值得一看。但大概还是值得总结一点。</p><p id="ca5d" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">fork实际上不是git版本控制系统的一部分，像GitHub GitHub GitHub git lab git lab git lab git lab git。fork只是一个带有一些漂亮的额外特性的存储库，可以使在GitHub这样的平台上的协作更加容易。您“派生”了一个项目的存储库，或<em class="ln"> repo </em>，这将创建一个具有相同提交、分支和当然文件的存储库的副本。</p><p id="c02e" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您派生一个回购协议时，您将在该时间点从原始回购协议创建一个新的回购协议。然后，您可以从原始的历史开始修改您的新分叉。同样好的是，你可以保留一点记录，将你的叉子绑在原始回购上。</p><p id="85ea" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我喜欢把forks看作原始存储库的一种“超级分支”。当您创建一个分支时，您有一个共享的提交历史和一个共享的公共提交祖先。现在这两个分支都可以独立于另一个进行更改。同样，原始回购和分叉都有一个相同的共享时间点。然后，随着新提交的增加，可以独立地处理它们。</p><p id="cb1f" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以创建一个新的分支，进行一些新的提交，然后合并它们。这样，两个分支都包括彼此过去的提交历史。合并分支是一个强大的工具，如果我们能用forks做到这一点就好了…</p><figure class="jy jz ka kb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/fae267785171c133860279be66bbe047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l8or_MizkRjwtqY1ze8tbQ.png"/></div></div><figcaption class="ke kf gj gh gi kg kh bd b be z dk translated">“fork”实际上只是原始回购协议的副本，包含所有分支机构的历史记录！</figcaption></figure><p id="acd3" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，我们可以！这就是为什么叉子对于协作如此重要；您可以采用某人的工作，进行一些更改，然后将存储库合并在一起。(从技术上讲，它们位于每个回购的两个分支之间。)GitHub调用这些<a class="ae mr" href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request-from-a-fork" rel="noopener ugc nofollow" target="_blank"> <em class="ln">拉请求</em> </a>。我们不会在这里详细讨论(也许下次)。相反，我们将讨论在我们分叉并且原始项目领先于您的分叉之后我们做什么。</p><h1 id="7343" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">与平行宇宙一起工作</h1><figure class="jy jz ka kb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/dd882d439b7ebe607ee2a5fa476929a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fH8_uzg0Qf1YmJOhUD3c0A.png"/></div></div><figcaption class="ke kf gj gh gi kg kh bd b be z dk translated">回购的典型抽象表示。</figcaption></figure><p id="c260" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">分支经常被比作<em class="ln">“平行宇宙”</em>，因为当一个分支被创建时，它与一个分支共享一个共同的(提交)历史。此后，每个分支都可以继续自己的历史。如果您稍后想要将某个分支的一些变更合并到另一个分支中，我们可以在该分支上进行<a class="ae mr" href="https://git-scm.com/docs/git-merge" rel="noopener ugc nofollow" target="_blank">合并</a>。</p><blockquote class="mu mv mw"><p id="541d" class="kp kq ln kr b ks kt ku kv kw kx ky kz mx lb lc ld my lf lg lh mz lj lk ll lm ij bi translated"><em class="iq">声明一下，Atlassian有一个关于</em><a class="ae mr" href="https://www.atlassian.com/git/tutorials/using-branches/git-merge" rel="noopener ugc nofollow" target="_blank"><em class="iq">git merge</em></a><em class="iq">的很棒的教程。</em></p></blockquote><p id="dc3c" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">叉子和树枝很相似。因此，我们基本上可以使用相同的合并工作流，包括fork和原始回购。这确实有点棘手，因为它真的不是一个分支。但是你可能会发现按照下一节中的步骤做并没有那么糟糕。</p><p id="1722" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们回忆一下当时的情况:</p><blockquote class="mu mv mw"><p id="eb12" class="kp kq ln kr b ks kt ku kv kw kx ky kz mx lb lc ld my lf lg lh mz lj lk ll lm ij bi translated"><em class="iq">您已经进行了回购。也许你甚至在这个分叉的回购协议中加入了你的香料，并做出了一些承诺。然后你看原来的回购做了一些改动。您希望将新的历史记录合并到分叉回购中，而不必完全重新开始。</em></p></blockquote><figure class="jy jz ka kb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/bcbc4879ef3b321b6883a33d1cc59d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlX0YF93vjRmURFGNguf-Q.png"/></div></div><figcaption class="ke kf gj gh gi kg kh bd b be z dk translated">情况是:原始回购上的新提交和分叉回购上的新提交。</figcaption></figure><h1 id="f007" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">解决方案是同步:整合从原始回购到分叉回购的变化</h1><h2 id="e28b" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh mc le ni nj mg li nk nl mk nm bi translated">步骤1:向原始回购添加一个遥控器</h2><p id="9cc4" class="pw-post-body-paragraph kp kq iq kr b ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们首先需要配置一个指向原始回购协议的遥控器。这将使您的回购知道在哪里寻找原始回购的更新历史。</p><p id="8d9a" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们在电脑上打开一个终端，导航到我们的(分叉)回购。接下来，我们添加一个名为<code class="fe nn no np nq b">upstream</code>的新远程存储库，它将指向原始回购:</p><pre class="jy jz ka kb gt nr nq ns nt aw nu bi"><span id="32cb" class="nb lp iq nq b gy nv nw l nx ny">git remote add upstream <a class="ae mr" href="https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</a></span></pre><p id="d542" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的命令中，<code class="fe nn no np nq b">https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</code>应该是原始回购的链接(不是你分叉的那个)。这告诉你的回购原始回购的位置。</p><p id="a2d4" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了确保一切顺利，我们可以用<code class="fe nn no np nq b">git remote -v</code>检查我们的遥控器。您应该会看到一个指向分叉回购的链接(通常我们使用名称<code class="fe nn no np nq b">origin</code>)和一个指向名为<code class="fe nn no np nq b">upstream</code>的原始回购的链接。输出应该如下所示:</p><pre class="jy jz ka kb gt nr nq ns nt aw nu bi"><span id="52c1" class="nb lp iq nq b gy nv nw l nx ny">$ git remote -v <br/>&gt; origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) <br/>&gt; origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) <br/>&gt; upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch) <br/>&gt; upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)</span></pre><blockquote class="mu mv mw"><p id="431e" class="kp kq ln kr b ks kt ku kv kw kx ky kz mx lb lc ld my lf lg lh mz lj lk ll lm ij bi translated"><em class="iq">注意，我们把这个新的遥控器叫做</em> <code class="fe nn no np nq b"><em class="iq">upstream</em></code> <em class="iq">，但是你也可以很容易地把它命名为其他的东西，比如</em> <code class="fe nn no np nq b"><em class="iq">original_repo</em></code> <em class="iq">。但是我们这样做是因为上面的命名方案是常见的做法。</em></p></blockquote><p id="03dd" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以查看GitHub文档中关于<a class="ae mr" href="https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/configuring-a-remote-for-a-fork" rel="noopener ugc nofollow" target="_blank">“为fork配置遥控器”</a>的步骤总结</p><h2 id="152c" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh mc le ni nj mg li nk nl mk nm bi translated">第2步:从原始文件中获取变更</h2><p id="84a7" class="pw-post-body-paragraph kp kq iq kr b ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">好了，现在我们已经配置了遥控器，我们必须从原始回购中获取当前历史记录。</p><p id="6307" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以使用以下命令来实现这一点:</p><pre class="jy jz ka kb gt nr nq ns nt aw nu bi"><span id="9b82" class="nb lp iq nq b gy nv nw l nx ny">git fetch upstream</span></pre><blockquote class="mu mv mw"><p id="a381" class="kp kq ln kr b ks kt ku kv kw kx ky kz mx lb lc ld my lf lg lh mz lj lk ll lm ij bi translated"><em class="iq">注意如果你用了一个不同于</em> <code class="fe nn no np nq b"><em class="iq">upstream</em></code> <em class="iq">的名字，你必须使用那个名字。</em></p></blockquote><p id="d8b6" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将<em class="ln">获取所有分支的最新历史记录</em>(类似于单个分支的<code class="fe nn no np nq b">git pull</code>)。完成后，我们将能够将原始回购分支的变更合并到我们自己的回购中。</p><h2 id="37af" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh mc le ni nj mg li nk nl mk nm bi translated">步骤3:将变更合并到您的回购工作分支中</h2><p id="86cf" class="pw-post-body-paragraph kp kq iq kr b ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">这将我们引向期待已久的时刻；将变更合并到我们自己的回购中！🎉</p><p id="55e3" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">真正酷的事情是，如果你对合并感到舒服，这是相同的过程！</p><p id="05bd" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，确保您在分叉回购中的正确分支上，您希望更改包含在其中。你可能需要像<code class="fe nn no np nq b">git checkout main</code>一样做一个<em class="ln">检验</em>。</p><p id="3f42" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦您确定您在正确的分支上，我们可以合并来自原始repo ( <code class="fe nn no np nq b">upstream</code>)分支的变更。根据分支名称的不同，该命令类似于以下内容:</p><pre class="jy jz ka kb gt nr nq ns nt aw nu bi"><span id="94d6" class="nb lp iq nq b gy nv nw l nx ny">git merge upstream/main</span></pre><blockquote class="mu mv mw"><p id="4dc2" class="kp kq ln kr b ks kt ku kv kw kx ky kz mx lb lc ld my lf lg lh mz lj lk ll lm ij bi translated"><em class="iq">注意，这里我们从原始回购的</em> <code class="fe nn no np nq b"><em class="iq">main</em></code> <em class="iq">分支进行合并。如果分支的名称不同，您应该更改该分支的名称。</em></p></blockquote><p id="1660" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样！如果一切正常，输出应该如下所示:</p><pre class="jy jz ka kb gt nr nq ns nt aw nu bi"><span id="c36a" class="nb lp iq nq b gy nv nw l nx ny">$ git merge upstream/main <br/>&gt; Updating q3f2742..4f55dbc <br/>&gt; Fast-forward <br/>&gt; TEMP | 5 ----- <br/>&gt; README.md | 3 +++ <br/>&gt; 2 files changed, 3 insertions(+), 5 deletions(-) <br/>&gt; delete mode 100644 TEMP <br/>&gt; create mode 100644 README.md</span></pre><blockquote class="mu mv mw"><p id="67cb" class="kp kq ln kr b ks kt ku kv kw kx ky kz mx lb lc ld my lf lg lh mz lj lk ll lm ij bi translated"><em class="iq">注意，在这一步你可能会遇到</em>合并冲突<em class="iq">。您可以遵循与合并两个分支时相同的步骤。</em></p></blockquote><h1 id="b87b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">所有设置和同步！</h1><figure class="jy jz ka kb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/7ade7d41a259bade450ce1de2036741a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7gKz_QSPLt-hejj2ZYNaw.png"/></div></div><figcaption class="ke kf gj gh gi kg kh bd b be z dk translated">同步后，分叉回购将包括原始分支的历史！</figcaption></figure><p id="fd2a" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们完事了。回顾一下，我们为原始回购添加了一个遥控器，获取了历史记录，最后检查了我们分叉的回购分支，并将原始回购的分支合并到我们的分支中！我们可以像下面的命令集那样做:</p><pre class="jy jz ka kb gt nr nq ns nt aw nu bi"><span id="5ef9" class="nb lp iq nq b gy nv nw l nx ny">git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git git fetch upstream git checkout main git merge upstream/main</span></pre><blockquote class="mu mv mw"><p id="e1b0" class="kp kq ln kr b ks kt ku kv kw kx ky kz mx lb lc ld my lf lg lh mz lj lk ll lm ij bi translated"><em class="iq">如果你想深入了解更多细节，你可能想看看GitHub的这组</em> <a class="ae mr" href="https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/working-with-forks" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> fork教程</em> </a> <em class="iq">。</em></p></blockquote><p id="f390" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，请随意查看我关于同步GitHub forks的附带视频<a class="ae mr" href="https://youtu.be/q2fQMD1gLPI" rel="noopener ugc nofollow" target="_blank">！</a></p><figure class="jy jz ka kb gt jr"><div class="bz fp l di"><div class="kc kd l"/></div></figure></div><div class="ab cl ki kj hu kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ij ik il im in"><p id="f8cb" class="pw-post-body-paragraph kp kq iq kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">原载于</em>【https://blog.mrgeislinger.com/syncing-github-forks/】<em class="ln"/></p></div></div>    
</body>
</html>