# C#中五大存储库模式实现的比较

> 原文：<https://levelup.gitconnected.com/5-ways-to-implement-repository-pattern-in-c-e12565e4d4a2>

![](img/478427480f22d83d595bd22cca0a71b0.png)

丹尼尔·伊德里在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

一个成熟的软件工程师通常知道解决同一编程问题的几种方法，并通过权衡分析做出选择。

目标越大，程序员必须越仔细地进行权衡分析，以避免将技术债务引入项目。

在编写数据访问层时，除了众所周知的存储库模式之外，还有其他几种选择。甚至存储库本身也有几种类型的实现。了解所有这些对于开发人员做出最合适的决定非常重要。

# 直接使用 DbContext

实体框架是对象关系映射技术，它实现不同的数据访问模式，如工作单元、存储库等。在使用实体框架时，开发人员创建一个 DbContext 对象，其中包含在数据库上执行 CRUD 操作所需的一切。

开发人员可以在项目中需要与数据库交互的任何地方直接注入 DbContext 类——控制器、应用程序或域服务、基础设施代码等。

## 优点:

*   简单。ApplicationContext 只需要在使用之前向 DI 容器注册。

## 缺点:

*   代码重复和硬维护。随着项目的发展，定制查询会变得越来越重复。例如，可能有多个副本查询*用户。FirstOrDefault(u =>u . UserId = = UserId)*在项目的不同部分。如果新的需求迫使开发人员过滤附加属性(IsActive、Status 等)。)，代码中有几个地方需要找到并更新。
*   用另一个 ORM 如 Dapper 或 NHibernate 替换实体框架将是一个挑战，因为在重构后，应用程序中将没有未被触及的地方。所以回归问题的风险很高。

# 每个实体的存储库

一组存储库类，每个域实体一个(不完全是每个实体，而是每个**聚合根**)，通常是组织项目中数据访问层的选择。每个特定的存储库类都包含与其实体相关的查询，而所有存储库共有的一些逻辑可以放在 BaseRepository 类中。

## 优点:

*   应用程序逻辑与数据访问细节相分离。当需要切换数据源时，应该只重写存储库类。
*   自定义查询只能在存储库类中找到。应用程序逻辑的不同部分可以重用它们。每当出现新的需求时，比如通过附加属性进行过滤，就需要更新单个位置。

## 缺点:

*   如果有大量的逻辑与一个实体相关联，那么存储库的大小会显著增加。如果存储库变得很大，很可能会将许多依赖项注入到构造函数中。数量越多，对存储库代码进行单元测试就越困难。
*   读取和写入查询是同一个存储库类的一部分，因此读取不能与写入分开扩展。

# 只读和只写存储库

在上面的例子中，混合读写操作的一个缺点可以通过创建只读和只写存储库很容易地解决。只读存储库将包含所有不改变状态的定制请求。

```
public class UserReadOnlyRepository : IUserReadOnlyRepository 
{ 
    ... 
}public class OrderReadOnlyRepository : IOrderReadOnlyRepository
{ 
    ... 
}
```

这将允许读取操作独立于写入操作进行扩展。这也将使维护存储库变得更加容易。副作用是由写操作而不是读操作引起的。因此，当需要找到意外行为的根本原因时，开发人员可以开始研究一个小型的只写存储库。

# 带有 IQueyrable 的存储库

由于自定义查询，存储库类的代码会增加。避免这种情况的一种方法是从存储库中公开 IQueryable 接口。客户端能够编写自己的查询，因此没有必要为每个实体都建立一个存储库。对于一般的插入、删除、更新方法，IRepository 接口的单一实现就足够了。

## 优点:

*   不管项目中有多少个实体，一个存储库的实现就足够了。
*   存储库将相对较小，因为自定义查询将在控制器、服务等中编写。，而不是存储库本身。

## 缺点:

*   同样，我们遇到了与第一个例子相同的问题:定制查询不会合并到一个地方，因此存在很高的重复风险。此外，迁移到新的 ORM 需要对应用程序的各个部分进行重构。
*   从存储库中公开 IQueryable 接口是将问题泄露给应用层的一个例子。要编写查询，repository 类的客户端需要知道 ORM 或数据库的细节。

# 命令和查询

每个存储库方法代表一个业务场景:创建用户、获得高级用户、激活用户、创建订单等。将每个场景封装在一个单独的对象中，而不是将它们保存在一个大的存储库类中或者分布在整个项目中，这样如何？负责读取数据的对象将被称为**查询**，负责写入数据的对象将被称为**命令**。

## 优点:

*   命令和查询处理程序对象遵循单一责任原则，[所以它们是可重用的](https://esashamathews.medium.com/how-to-design-reusable-software-components-213e05119796)，易于单元测试，易于理解。
*   每个命令或查询处理程序对象可以不同的方式访问数据库。例如，95%的对象可以使用实体框架，而剩下的 5%使用 Dapper，因为它们封装的业务场景对性能有很高的要求。
*   将读和写操作分离到不同的对象中有利于可维护性(很清楚哪个对象改变了应用程序的状态，哪个没有)和可伸缩性(读可以很容易地并行化)。

## 缺点:

*   与所有以前的数据访问层实现相比，类的数量将显著增加。

# 结论

没有适合所有人的完美实现。只有彻底分析利弊，才能帮助开发人员找到解决设计和编码挑战的最合适的解决方案。

## 我的其他文章

[](https://esashamathews.medium.com/5-easy-ways-to-improve-your-software-design-quickly-e738f2bcf97e) [## 改进软件设计的 5 种简单方法

### 简单的解决方案在 80%的情况下都有帮助。

esashamathews.medium.com](https://esashamathews.medium.com/5-easy-ways-to-improve-your-software-design-quickly-e738f2bcf97e) [](/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2) [## 在 C#中实现单例设计反模式的 5 种方法

### 各有利弊

levelup.gitconnected.com](/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2) [](/5-ways-to-clone-an-object-in-c-d1374ec28efa) [## 在 C#中克隆对象的 5 种方法

### 各有利弊

levelup.gitconnected.com](/5-ways-to-clone-an-object-in-c-d1374ec28efa)