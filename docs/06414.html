<html>
<head>
<title>Practical Advice to Good API Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">良好API设计的实用建议</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-advice-to-good-api-design-fa857fa569a1?source=collection_archive---------8-----------------------#2020-11-23">https://levelup.gitconnected.com/practical-advice-to-good-api-design-fa857fa569a1?source=collection_archive---------8-----------------------#2020-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/702170fc5eba7c5a03d659b8ec5b9ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*em1PMRKT6LNteEgC1PJG8A.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片来源:我</figcaption></figure><p id="c8d2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在一次罕见的卓有成效的youtube会议上，我看到了Joshua Bloch(《有效的Java》的作者)关于如何构建好的API以及为什么它很重要的演讲。看完之后，我知道我必须做笔记，因为这个演讲太精彩了，我无法忘记。事实上非常好，所以我想和你分享。</p><p id="34cc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Joshua设法将许多主题压缩到一个小时内，触及了好的API的高级特征、构建API的过程以及构建API的一些实用技巧。所以让我们直接开始吧。</p><p id="707b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，让我们快速回顾一下什么是API。这在视频中没有涉及，所以如果你已经知道了，可以随意跳过这一部分。</p><p id="6543" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个API ( <em class="ld">【应用编程接口】</em>可以认为是一个如何与API背后的软件进行通信的契约。它定义了您可以获取的数据、数据的格式以及可以对这些数据执行的操作。这意味着API可以是完全成熟的REST API，也可以是可以调用来操作列表的一组方法。</p><p id="c276" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">根据Bloch的说法，要设计一个好的API，你可以瞄准某些特征。</p><h1 id="9ff0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">好的API的特征</h1><ul class=""><li id="a016" class="mc md it kh b ki me km mf kq mg ku mh ky mi lc mj mk ml mm bi translated">简单易学</li><li id="657d" class="mc md it kh b ki mn km mo kq mp ku mq ky mr lc mj mk ml mm bi translated">易于使用，即使没有文档</li><li id="3f9a" class="mc md it kh b ki mn km mo kq mp ku mq ky mr lc mj mk ml mm bi translated">难以误用</li><li id="aedc" class="mc md it kh b ki mn km mo kq mp ku mq ky mr lc mj mk ml mm bi translated">易于阅读和维护使用它的代码</li><li id="fd3e" class="mc md it kh b ki mn km mo kq mp ku mq ky mr lc mj mk ml mm bi translated">足够强大以满足需求</li><li id="431c" class="mc md it kh b ki mn km mo kq mp ku mq ky mr lc mj mk ml mm bi translated">容易进化</li><li id="4e87" class="mc md it kh b ki mn km mo kq mp ku mq ky mr lc mj mk ml mm bi translated">适合观众</li></ul><p id="6414" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">虽然这些特征很抽象，很难实现，但它们可以用作指导原则。如何实现这些特征是这篇文章剩下的内容。</p><h1 id="e1ad" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构建API的过程</h1><p id="e94e" class="pw-post-body-paragraph kf kg it kh b ki me kk kl km mf ko kp kq ms ks kt ku mt kw kx ky mu la lb lc im bi translated">构建API的第一步是从需求开始。然而，小心涉众提出的解决方案，尝试提取用例。弄清楚你试图解决的确切问题，而不是用户希望如何解决。</p><p id="ad3f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一旦你有了合适的需求，就从小事做起。写一份最多一页的说明书。</p><p id="3b26" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">任何比这更大的事情，你的自我就会被投资。沉没成本谬论开始起作用，你不会放心放弃它。</p><p id="9853" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">做出改变并不费力，一旦你开始得到反馈，重写就很容易了。只有当你开始更好地理解你试图解决的问题时，你才应该更加充实这个规范。</p><p id="c988" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">虽然听起来很不直观，但是您应该立即开始针对您的API进行编码。创建接口，不要为实现而烦恼，直到你把一切都计划好了。即使这样，也要继续对API进行编码，以确保它的行为符合您的预期。这可以让你澄清和防止意外。</p><p id="0062" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些代码片段可能是您将为API编写的一些最重要的代码。他们可以作为例子继续存在，你应该在这些方面花很多时间。一旦您的API投入使用，就需要复制示例代码。<strong class="kh iu">有好的例子意味着很好地使用了你的API，所以它们应该成为典范。</strong></p><p id="d5a2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然而，构建API时最重要的事情是</p><blockquote class="mv mw mx"><p id="a412" class="kf kg ld kh b ki kj kk kl km kn ko kp my kr ks kt mz kv kw kx na kz la lb lc im bi translated">当有疑问时，不要去想它。</p></blockquote><p id="63f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">尤其是如果你正在构建一个公共API，一旦用户开始使用它，就几乎不可能删除它的功能。</p><h1 id="b256" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实用技巧</h1><p id="e6c5" class="pw-post-body-paragraph kf kg it kh b ki me kk kl km mf ko kp kq ms ks kt ku mt kw kx ky mu la lb lc im bi translated">注意，这些例子中有许多是基于Java和OOP(面向对象编程)的。尽管如此，它的大部分仍然适用于Java和OOP之外。</p><p id="9b4e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">一个API应该做一件事并且做好</strong></p><p id="31ed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">该功能应该易于解释。如果很难命名，一般是不好的征兆。一个好的API读起来应该像散文。</p><p id="8c4f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当你想在一个地方做太多事情的时候，可以把事情分开，或者当你在做类似的事情的时候，把事情放在一起。</p><p id="96cc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">一个API应该尽可能的小，但是不能更小</strong></p><p id="bdc5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">满足要求，其他都不考虑。您可以随时添加，但不能删除。</p><p id="33a5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">考虑学习理解API的概念数量。您应该考虑必须学习API的概念权重，并尽量将其保持在最低水平。</p><p id="9993" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一种方法是尽可能重用接口。通过重用接口，用户只需学习一次接口。</p><p id="b0ae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">不要把实现细节放在API里</strong></p><p id="967e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您不应该向客户端公开实现细节。如果你想改变实现，这使得API更难改变。</p><p id="c936" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个例子是抛出异常。您可能会抛出一个SQL异常，但在以后的版本中还想实现另一种形式的数据存储。现在你必须抛出一个SQL异常，即使你正试图写一个文件，因为用户正在期待和处理SQL异常。</p><p id="a079" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">最小化所有东西的可访问性</strong></p><p id="93d8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">尽可能保持私密。它为您提供了更改名称和实现的灵活性，而不会影响客户的实现。</p><p id="9e0d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">名字很重要</strong></p><p id="1b6c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些名字应该是不言自明的，你应该把一个API当成一个小型语言。这意味着它的命名应该是一致的。同样的词应该表示同样的事情，同样的意思应该用来描述同样的事情。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="7c75" class="nk lf it ng b gy nl nm l nn no">// Does the same thing, but different names are used</span><span id="7f5c" class="nk lf it ng b gy np nm l nn no">fun remove()<br/>fun delete()</span></pre><p id="5c71" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">文件事宜</strong></p><p id="520c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">记录良好的API组件更有可能被重用。虔诚地记录，尤其是在处理状态或副作用时。文档越好，用户遇到的错误就越少。</p><p id="6936" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">永远不要为了性能而扭曲API</strong></p><p id="130e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好的API设计通常与好的性能一致。像使类型可变或使用实现类型而不是接口这样的事情会限制性能。</p><p id="f73c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过改变你的API来获得更好的性能，你冒着破坏API的风险。例如，通过创建一个不可变的类，使其可变以使用更少的内存。虽然潜在的性能问题将被修复，但令人头疼的问题将永远存在。</p><p id="a880" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">最小化可变性</strong></p><p id="52fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">除非有非常好的理由，否则类应该是不可变的。如果可变性是必要的，保持状态空间尽可能小。</p><p id="be84" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">仅在有意义的地方划分子类</strong></p><p id="616a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">只有当你能一本正经地说子类的每个实例都是超类的一个实例时，你才需要子类。如果答案不是响亮的“是”,那就用作文来代替。公开的类不应该仅仅为了重用实现代码而子类化。</p><p id="350b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">为传承而设计并记录，否则禁止</strong></p><p id="832c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这适用于OOP。避免<a class="ae nq" href="https://en.wikipedia.org/wiki/Fragile_base_class" rel="noopener ugc nofollow" target="_blank">脆弱的基类问题</a>，当对基类的更改可能破坏子类的实现时，就会出现这种问题。</p><p id="1b7b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果不可避免，彻底记录方法如何相互使用。尽管尽可能地限制对实例变量的访问，并使用getters和setters来控制基类的实现。</p><p id="3d25" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">不要让客户端做模块可以做的任何事情</strong></p><p id="d119" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让API做那些总是需要做的事情。为客户避免样板文件。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="975d" class="nk lf it ng b gy nl nm l nn no">// DON'T<br/>val circle = CircleFactory.newInstance().newCircle()<br/>circle.radius(1)<br/>circle.draw()</span><span id="7785" class="nk lf it ng b gy np nm l nn no">// DO<br/>val circle = CircleFactory.newCircle(radius = 0.5)<br/>circle.draw()</span></pre><p id="2f19" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">避免最小惊讶原则</strong></p><p id="9449" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">API用户不应对这种行为感到惊讶。要么避免副作用，要么使用描述性的名称来描述副作用是什么。</p><p id="60e5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">快速失败</strong></p><p id="ac6a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">错误发生后应尽快报告。编译时是最好的，所以利用泛型/静态类型。</p><p id="6419" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">提供对字符串形式的所有可用数据的编程访问</strong></p><p id="6d77" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你只使用字符串，格式和内容就会成为API的一部分，所以你永远不能改变它。所以通过一个对象提供对字符串内容的访问。这样你就不用对字符串的格式和内容做任何承诺了。</p><p id="b8c7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">小心超载</strong></p><p id="6cf4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">仅当方法的行为相同时才重载它们。以Java TreeSet构造函数为例，<code class="fe nr ns nt ng b">TreeSet(Collection)</code>忽略顺序，而<code class="fe nr ns nt ng b">TreeSet(SortedSet)</code>尊重顺序。</p><p id="d05c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">使用合适的参数和返回类型</strong></p><p id="9b9c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于输入，优先使用接口而不是类，但是使用最具体的输入参数类型。如果存在更好的类型，就不要使用string。例如，对于货币值，应该使用BigDecimal而不是floats。</p><p id="5ef4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">跨方法使用一致的参数排序</strong></p><p id="0143" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">尤其是当参数类型相同时，因为您可能会意外地交换参数。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="98d9" class="nk lf it ng b gy nl nm l nn no">fun copy(source: String, destination: String)<br/>fun partialCopy(destination: String, source: String, numberToCopy: Int)</span></pre><p id="3910" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">避免长参数列表</strong></p><p id="8a87" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">三个或更少的参数是理想的。相同类型参数的长列表可能是有害的，并且非常容易出错。如有必要，分解函数或使用助手类来保存参数。</p><p id="d414" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">避免需要异常处理的退货类型</strong></p><p id="14ef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">用户会忘记编写特例代码，这可能会导致错误。在非异常流量也足够的情况下，应避免这种情况。例如，返回零长度数组或集合，而不是空值。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="9797" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，您应该准备好犯错误，这就是为什么这么多要点是关于能够容易地改变事情，而不是从一开始就构建完美的API。</p><p id="bd50" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">也请看看这篇演讲，他比我在这里讲得更详细。</p><p id="1fb3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望你觉得这些有用，并在评论中分享你的想法或经历！</p><p id="cd9b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">感谢你阅读❤️</p></div></div>    
</body>
</html>