<html>
<head>
<title>Create a Modal with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个带有反应钩子的模型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-a-modal-with-react-hooks-357c8aae7c3f?source=collection_archive---------1-----------------------#2019-11-29">https://levelup.gitconnected.com/create-a-modal-with-react-hooks-357c8aae7c3f?source=collection_archive---------1-----------------------#2019-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0009" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上周的博客中，我讲述了如何用React钩子在一个类组件和一个函数组件中获取数据。今天，我们将讨论如何在这两种类型的组件中实现一个模型，并比较主要的区别。我们将从类组件的实现开始。</p><h1 id="c589" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">创建一个模态类组件</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/2284fa1b4cb78fae0001d097a409d1e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gV9mGK3mH9KPDhx0dyi5Tw.png"/></div></div></figure><p id="15ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们从React Bootstrap导入一些组件，并创建一个初始状态，其中<code class="fe lw lx ly lz b">nasaData</code>设置为空对象，<code class="fe lw lx ly lz b">showModal</code>设置为<code class="fe lw lx ly lz b">false</code>。下一步是获取NASA的数据，并使用<code class="fe lw lx ly lz b">this.setState</code>将这些数据分配给<code class="fe lw lx ly lz b">nasaData</code>。</p><p id="4ff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建了<code class="fe lw lx ly lz b">handleShow</code>和<code class="fe lw lx ly lz b">handleHide</code>函数来切换<code class="fe lw lx ly lz b">showModal</code>的布尔值。我们调用render返回组件，并用<a class="ae kl" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">片段简写</a>、<code class="fe lw lx ly lz b">&lt;&gt;</code>和<code class="fe lw lx ly lz b">&lt;/&gt;</code>包装返回。这是一种替代，而不是包装<code class="fe lw lx ly lz b">&lt;React.Fragment&gt;</code>中的组件。我们通过调用格式<code class="fe lw lx ly lz b">this.state.nasaData.title</code>向浏览器显示API数据。</p><p id="8544" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在应用程序的登录页面上，我们单击一个按钮来打开模式，并使用<code class="fe lw lx ly lz b">onClick={this.handleShow}</code>调用事件监听器和函数。当<code class="fe lw lx ly lz b">showModal</code>状态为<code class="fe lw lx ly lz b">true</code>时，<code class="fe lw lx ly lz b">show={this.state.showModal}</code>在浏览器中呈现模态。当<code class="fe lw lx ly lz b">showModal</code>值为<code class="fe lw lx ly lz b">false</code>时，显示原始登陆页面。</p><h1 id="9fd1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">创建带挂钩的模态功能元件</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ma"><img src="../Images/74a6c3dcb9a8a6d469bcc82798cdbe67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ye2eNaj16ukyryywTstrtw.png"/></div></div></figure><p id="dfd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在函数组件中，我们从React导入<code class="fe lw lx ly lz b">useState</code>和<code class="fe lw lx ly lz b">useEffect</code>钩子，从React Bootstrap导入几个组件。我们创建<code class="fe lw lx ly lz b">nasaData</code>变量，用<code class="fe lw lx ly lz b">setData</code>更新值，用<code class="fe lw lx ly lz b">useState({ })</code>将初始状态设置为空对象。我们还构造了<code class="fe lw lx ly lz b">showModal</code>变量、<code class="fe lw lx ly lz b">setModal</code>函数和<code class="fe lw lx ly lz b">useState(false)</code>作为初始状态。</p><p id="fe30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们在<code class="fe lw lx ly lz b">useEffect</code>钩子中获取NASA的数据，并使用<code class="fe lw lx ly lz b">setData</code>将其分配给<code class="fe lw lx ly lz b">nasaData</code>。我们通过链接格式<code class="fe lw lx ly lz b">nasaData.title</code>在浏览器中显示特定的数据片段。要查看模态，我们点击按钮调用<code class="fe lw lx ly lz b">onClick={() =&gt; setModal(true)}</code>。该事件调用<code class="fe lw lx ly lz b">setModal</code>函数，将<code class="fe lw lx ly lz b">showModal</code>值更新为<code class="fe lw lx ly lz b">true</code>，并显示带有<code class="fe lw lx ly lz b">show={showModal}</code>的模态。要返回登录页面，我们单击模式右上角的x或关闭按钮。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="8cac" class="km kn iq bd ko kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj bi translated">模态功能</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mn"><img src="../Images/8c389797e0e5032a7108d71b98642e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTg2ZdP_nAXJjpdbkUOoDA.png"/></div></div></figure><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mo"><img src="../Images/a0d3e545fc44070d19d75ea6855bebb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LoGtm9i4gaBHMdqz2TP6ag.png"/></div></div></figure><h1 id="63ed" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">最终想法—模态比较</h1><ul class=""><li id="6717" class="mp mq iq jp b jq mr ju ms jy mt kc mu kg mv kk mw mx my mz bi translated">三元运算符在类组件中很难阅读，需要分成多行。</li><li id="0fd4" class="mp mq iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">在带有钩子的函数组件中，我们可以用函数内联处理事件，而不会弄乱返回语句。</li><li id="cf83" class="mp mq iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">我们删除了功能组件中不必要的<code class="fe lw lx ly lz b">this.state…</code>链接，以便在浏览器上显示数据属性。</li></ul><p id="016e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个组件实现了相同的功能，但是带有钩子的功能组件有明显的好处。除了上面的三个要点之外，function组件缩短了七行，每行代码的字符更少，可读性更好。请访问<a class="ae kl" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a>以找到额外的例子并继续学习钩子！</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nf"><img src="../Images/d50e1ee903ab7701e849e1af6e3b0b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7IXJeto1c3k5VxjH"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae kl" href="https://unsplash.com/photos/yZygONrUBe8" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure></div></div>    
</body>
</html>