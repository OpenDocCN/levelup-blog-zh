<html>
<head>
<title>AWS CodeArtifact with Maven — Further adventures with ServerLess</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS code artifact with Maven——无服务器的进一步探索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/aws-codeartifact-with-maven-further-adventures-with-serverless-4ff07fd69e1b?source=collection_archive---------3-----------------------#2021-03-06">https://levelup.gitconnected.com/aws-codeartifact-with-maven-further-adventures-with-serverless-4ff07fd69e1b?source=collection_archive---------3-----------------------#2021-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9bcbc2ce3654a238edf8355fc1ded296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngUIPP6rjvn1Dh9rBe-MGg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">宁静——作者照片</figcaption></figure><p id="4ccf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你读过我以前的文章，你会注意到我是一个服务迷，这些服务不需要我在任何地方直接构建和管理服务器。称它们为“无服务器”，称它们为“X-as-a-service”，对我来说，关键是我可以专注于使用服务，而不是太担心它在哪里以及如何运行。</p><p id="9ad8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对我来说，CodeArtifact 正好属于这一类。我最近写了一篇关于为Go代码构建<a class="ae la" href="https://rahook.medium.com/serverless-code-pipelines-on-aws-30dfc91889c6" rel="noopener">无服务器CI/CD管道</a>的文章。对于Go，管道的最终输出是发布到S3桶中的可执行文件。对于Java代码，这种方法有点笨拙。</p><p id="ef34" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不管喜欢与否，多年来构建和打包Java代码的事实标准一直是<a class="ae la" href="http://maven.apache.org" rel="noopener ugc nofollow" target="_blank"> Maven </a>。像Gradle 这样的替代者逐渐削弱了它的统治地位，但是Maven仍然戴着皇冠。我不认为这个星球上的任何人可以说他们喜欢Maven，但尽管它有许多烦恼，但它可以可靠地重复完成工作。</p><p id="dff5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Java世界中，团队的自动实际开发基础设施看起来和十多年前一样:桌面上的Eclipse或Intellij，与Maven项目相对照。某种代码库，通常是Gitlab或Github。Jenkins或Hudson来完成实际的CI构建(尽管现在有更好的解决方案)，以及一个工件存储库来存储构建的jar并允许它们被共享。同样，多年来事实上的标准一直是来自JFrog的广受好评的Artifactory，CodeArtifact取代的正是堆栈中的这个组件。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/cf8ce7ba5c3e56dd2fb0db71b8b5ae12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*-udCORRH-z5kdFbCjLF0EA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">抽象代码管道</figcaption></figure><p id="9025" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现代人工制品仓库的角色相当简单:一个可管理的地方，在那里编译的代码人工制品可以被编目和共享。制品库中一个更重要的想法是代码制品的每个版本都是不同的，并且有一些方法可以追溯到生成代码的版本。大多数人工制品库也可以作为外部库的缓存代理或镜像副本。企业经常使用这个特性来管理开发人员使用什么外部存储库，以及他们可以导入什么外部依赖项。</p><p id="e1c8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Maven的情况下，每个项目都由一个或多个XML文件定义，通常命名为<em class="lb"> pom.xml </em>和<em class="lb"> settings.xml </em>，它们(以及许多其他东西)定义了Maven将把构建的工件发布到哪里，以及它将在哪里寻找解决依赖关系的方法。这些地方通常是相同的，但并不总是如此，这会导致一定程度的混淆！</p><p id="5b51" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">作为我探索如何组装<a class="ae la" href="https://rahook.medium.com/serverless-code-pipelines-on-aws-30dfc91889c6" rel="noopener">无服务器CI/CD管道</a>的一部分，我终于坐下来思考如何让CodeBuild、CodeArtifact和Maven合作构建和发布Java JARs。我将研究下面的一些细节，尽管请参考我以前关于整理代码构建/代码管道片段以提供持续集成和部署所需的所有零碎内容的笔记。在这篇文章中，我将重点关注CodeArtifact和Maven配置。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/093f1b00c3403c9df1cf325c78764bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*sE-pcHK_qdJ9S_LmlVvmjg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">无服务器CI/CD管道</figcaption></figure><p id="41ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还要注意，我将给出使用Terraform的例子——如果你读过我写的其他东西，你就会知道我喜欢Terraform，并且非常喜欢使用Terraform代码在AWS上定义基础设施的想法。</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="8a98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我绊倒的第一件事是，在撰写本文时(2021年初)，CodeArtifact仅在有限数量的AWS环境中可用。一般来说，我在伦敦(eu-west-2)地区构建东西，因为那是我住的地方，但是让我有点烦恼的是CodeArtifact只在爱尔兰(eu-west-1)可用。所以，唉，第一步是在我的Terraform代码中添加一个额外的命名提供者:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="c2b0" class="lu lv iq lq b gy lw lx l ly lz">provider "aws" {<br/>  region  = var.aws_region<br/>  profile = var.aws_profile<br/>}</span><span id="ab01" class="lu lv iq lq b gy ma lx l ly lz">provider "aws" {<br/>  alias   = "eu-west-1"<br/>  region  = "eu-west-1"<br/>  profile = var.aws_profile<br/>}</span></pre><p id="478f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一步，我假设我将在未来中期为更多的Java库构建更多的管道，所以我创建了一个项目列表(每个项目都有自己独特的管道和存储库)。这非常简单——一个映射，其中的关键字是我为项目使用的常用名称及其所有的零碎内容，以及一个描述:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="d772" class="lu lv iq lq b gy lw lx l ly lz">locals {<br/>  projects = {<br/>    iplib : "Small library for consuming AWS CIDR block data"<br/>  }<br/>}</span></pre><p id="8f25" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">CodeArtifact是围绕<em class="lb">域</em>组织的——域是任何适合您的逻辑分组，并且充当一组工件的逻辑容器。你可能想按产品或项目，或按团队，或按组织界限来组织。这真的没关系，除了它给你一个机会使用IAM角色和策略来限制谁可以访问给定的域。</p><p id="f64d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于角色和策略的一个小问题。在下面的例子中，我一直作为一个对帐户有很高访问权限的用户进行操作。您可能需要使用Terraform创建资产的权限。</p><p id="01e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对，所以，<em class="lb">域</em>。下一步是创建一个域:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="a587" class="lu lv iq lq b gy lw lx l ly lz">resource "aws_codeartifact_domain" "development" {<br/>  provider = aws.eu-west-1</span><span id="d322" class="lu lv iq lq b gy ma lx l ly lz">domain         = "development"<br/>  encryption_key = aws_kms_key.codeartifact.arn<br/>  tags           = merge({ "Name" = "development" }, var.tags)<br/>}</span></pre><p id="2448" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可能会注意到有一个加密密钥。这是强制性的，也是限制访问的另一个潜在工具。它还增加了对存储库中任何工件是真实的保证:对于一个外部不良行为者来说，要破坏密钥和代码工件域以便能够安装欺骗的工件(尽管来自上游存储库的缓存工件可能仍然已经在上游中毒)将花费相当多的精力</p><p id="af6c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">键很容易抛出，但是要确保它和域在同一个区域:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="4dff" class="lu lv iq lq b gy lw lx l ly lz">resource "aws_kms_key" "codeartifact" {<br/>  provider                = aws.eu-west-1<br/>  deletion_window_in_days = 30<br/>  enable_key_rotation     = true<br/>  tags                    = merge({ "Name" = "codeartifact" }, <br/>                                  var.tags)<br/>}</span></pre><p id="2d0e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，存储库本身。总的来说，您可能会围绕一个项目来组织这个项目，将所有密切相关的工件放在一个库中:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="15af" class="lu lv iq lq b gy lw lx l ly lz">resource "aws_codeartifact_repository" "maven" {<br/>  provider = aws.eu-west-1</span><span id="64d0" class="lu lv iq lq b gy ma lx l ly lz">  domain      = aws_codeartifact_domain.development.domain<br/>  repository  = "maven"<br/>  description = "Repository to install maven artifacts into"<br/>  external_connections {<br/>    external_connection_name = "public:maven-central"<br/>  }<br/>  tags = merge({ "Name" = "maven"}, var.tags)<br/>}</span></pre><p id="21f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我称它为“maven ”,因为在我的脑海中，我将只使用这个库来通过Maven读写工件，但是每个库都可以用于Maven、Gradle、pip、NPM……几乎所有你需要的标准，并且随着时间的推移而增长。</p><p id="88cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">代码构建的定义比我之前<a class="ae la" href="https://rahook.medium.com/serverless-code-pipelines-on-aws-30dfc91889c6" rel="noopener">描述的</a>要简单一点——关键的区别是我没有指定代码构建产生的产品。这是因为发布到CodeArtifact的工作是由Maven本身完成的:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="88be" class="lu lv iq lq b gy lw lx l ly lz">resource "aws_codebuild_project" "maven" {<br/>  for_each = local.projects</span><span id="af11" class="lu lv iq lq b gy ma lx l ly lz">  name         = each.key<br/>  description  = "project to build the ${each.key} project"<br/>  service_role = aws_iam_role.maven.arn</span><span id="323b" class="lu lv iq lq b gy ma lx l ly lz">  build_timeout  = 15<br/>  badge_enabled  = true<br/>  source_version = "refs/heads/main"</span><span id="f099" class="lu lv iq lq b gy ma lx l ly lz">  source {<br/>    git_clone_depth     = 1<br/>    insecure_ssl        = false<br/>    location            = aws_codecommit_repository.maven[each.key].clone_url_http<br/>    report_build_status = false<br/>    type                = "CODECOMMIT"</span><span id="0c17" class="lu lv iq lq b gy ma lx l ly lz">    git_submodules_config {<br/>      fetch_submodules = false<br/>    }<br/>  }</span><span id="bf75" class="lu lv iq lq b gy ma lx l ly lz">  artifacts {<br/>    type = "NO_ARTIFACTS"<br/>  }</span><span id="3eaa" class="lu lv iq lq b gy ma lx l ly lz">  environment {<br/>    compute_type                = "BUILD_GENERAL1_SMALL"<br/>    image                       = "aws/codebuild/amazonlinux2-x86_64-standard:3.0"<br/>    image_pull_credentials_type = "CODEBUILD"<br/>    privileged_mode             = false<br/>    type                        = "LINUX_CONTAINER"<br/>  }</span><span id="4d23" class="lu lv iq lq b gy ma lx l ly lz">  logs_config {<br/>    cloudwatch_logs {<br/>      status     = "ENABLED"<br/>      group_name = aws_cloudwatch_log_group.maven.name<br/>    }</span><span id="387f" class="lu lv iq lq b gy ma lx l ly lz">  s3_logs {<br/>      encryption_disabled = false<br/>      status              = "DISABLED"<br/>    }<br/>  }</span><span id="af2d" class="lu lv iq lq b gy ma lx l ly lz">  tags = merge({ "Name" = each.key }, var.tags)<br/>}</span></pre><p id="0c8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除非你非常熟悉Terraform，否则代码片段中会出现一些微妙的东西——使用<em class="lb"> for_each </em>意味着我定义的每个项目都将由相同的代码创建一个管道。添加一个新项目就像在顶部的<em class="lb">本地</em>列表中添加一个条目一样简单，然后重新运行Terraform。</p><p id="90a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一个细微的差别可能不是很明显CodeBuild项目(以及CodePipeline管道和CodeCommit git存储库)是<em class="lb">而不是<code class="fe mb mc md lq b">eu-west-1</code>中的</em>——不要求CodeArtifact存储库与构建和发布工件的零碎部分位于同一区域。</p><p id="c334" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">附加到<em class="lb"> service_role </em>的策略与我之前发布的策略相同，只是添加了CodeBuild使用CodeArtifact的权限。如果你想更精确地了解所使用的资源，这可能会有一点细微的差别，稍后我会自己进行调整。最小特权原则是一个非常强大的安全网。</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="47f2" class="lu lv iq lq b gy lw lx l ly lz">data "aws_iam_policy_document" "codebuild" {<br/>  .<br/>  .<br/>  .<br/>  statement {<br/>    actions = [<br/>      "codeartifact:GetAuthorizationToken",<br/>      "codeartifact:GetRepositoryEndpoint",<br/>      "codeartifact:ReadFromRepository",<br/>      "codeartifact:PublishPackageVersion",<br/>      "codeartifact:PutPackageMetadata"<br/>    ]<br/>    resources = ["*"]<br/>  }</span><span id="8545" class="lu lv iq lq b gy ma lx l ly lz">  statement {<br/>    actions   = ["sts:GetServiceBearerToken"]<br/>    resources = ["*"]<br/>    condition {<br/>      test     = "StringEquals"<br/>      variable = "sts:AWSServiceName"<br/>      values = [<br/>        "codeartifact.amazonaws.com"<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="a5dc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">唯一复杂的是使用STS来获得一个认证令牌。这是IAM原则和策略的世界与(在本例中)Maven的老派认证世界之间的“粘合剂”。</p><p id="a7a8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以让我们过渡到Java项目本身的内容。首先，因为这是一个CodeBuild项目，我们需要<code class="fe mb mc md lq b">buildspec.yml</code>来告诉CodeBuild如何处理代码:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="07fb" class="lu lv iq lq b gy lw lx l ly lz">version: 0.2<br/><br/>phases:<br/>  install:<br/>    runtime-versions:<br/>      java: corretto11<br/>  pre_build:<br/>    commands:<br/>      - export STAMP="1.0-`date +%Y%m%d.%H%M%S`"<br/>      - export CODEARTIFACT_AUTH_TOKEN=`aws --region eu-west-1 codeartifact get-authorization-token --domain development --domain-owner 304388931199 --query authorizationToken --output text`<br/>  build:<br/>    commands:<br/>      - mvn --no-transfer-progress versions:set -DnewVersion=$STAMP<br/>      - mvn --no-transfer-progress -s settings.xml clean package deploy<br/>artifacts:<br/>  files:<br/>    - target/iplib-$STAMP.jar<br/>  name: iplib-$STAMP.jar</span></pre><p id="0236" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从上到下工作:我指定AWS的<a class="ae la" href="https://aws.amazon.com/corretto/" rel="noopener ugc nofollow" target="_blank"> Coretto </a>是因为我知道他们已经为它优化了构建环境——简单地说，用Coretto构建会更快一点，而且稍微便宜一点。生产的产品完全兼容任何Java 11(或更高版本)JDK。我还使用当前的日期和时间创建了一个版本标记，你可以看到它被用在更低的人工制品的名字中。</p><p id="1b53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">唯一复杂的部分是要求CodeBuild获得一个在构建中使用的身份验证令牌。即使调用是<code class="fe mb mc md lq b">aws codeartifact get-authorisation-token</code>，在幕后STS也参与其中，这就是为什么我们也需要授予对该服务的访问权。</p><p id="e248" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">构建采用我们已经配置好的那些位，然后运行一个普通的Maven构建，首先设置我们将使用的版本标识符，然后进行构建和部署。</p><p id="a9e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从这里开始，都是Maven配置。首先，我们必须在项目的顶部有一个<code class="fe mb mc md lq b">settings.xml</code>来为Maven指定一个或多个服务器。这就是环境中的身份验证令牌发挥作用的地方。注意，服务器<em class="lb"> id </em>是基于CodeArtifact域和存储库的，但这只是为了方便起见，以便在整个项目中使用一致的名称。</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="638c" class="lu lv iq lq b gy lw lx l ly lz">&lt;settings&gt;<br/>    &lt;servers&gt;<br/>        &lt;server&gt;<br/>            &lt;id&gt;development--maven&lt;/id&gt;<br/>            &lt;username&gt;aws&lt;/username&gt;<br/>            &lt;password&gt;${env.CODEARTIFACT_AUTH_TOKEN}&lt;/password&gt;<br/>        &lt;/server&gt;<br/>    &lt;/servers&gt;<br/>&lt;/settings&gt;</span></pre><p id="1578" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe mb mc md lq b">pom.xml</code>本身中，包含对代码源代码的引用是一个好习惯:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="4149" class="lu lv iq lq b gy lw lx l ly lz">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;project <br/> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br/> xsi:schemaLocation="http://maven.apache.org/POM/4.0.0<br/> http://maven.apache.org/maven-v4_0_0.xsd"&gt;<br/>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/><br/>    &lt;name&gt;IPLib&lt;/name&gt;<br/>    &lt;groupId&gt;net.parttimepolymath&lt;/groupId&gt;<br/>    &lt;artifactId&gt;iplib&lt;/artifactId&gt;<br/>    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br/>    &lt;packaging&gt;jar&lt;/packaging&gt;<br/><br/>    &lt;description&gt;Simple library to extract IP ranges fom the IP range set published by AWS&lt;/description&gt;<br/>    &lt;url&gt;http://parttimepolymath.net&lt;/url&gt;<br/><br/>    &lt;scm&gt;<br/>      &lt;url&gt;scm:ssh://git-codecommit.eu-west-2.amazonaws.com/v1/repos/iplib&lt;/url&gt;<br/>      &lt;connection&gt;scm:ssh://git-codecommit.eu-west-2.amazonaws.com/v1/repos/iplib&lt;/connection&gt;<br/>      &lt;developerConnection&gt;scm:ssh://git-codecommit.eu-west-2.amazonaws.com/v1/repos/iplib&lt;/developerConnection&gt;<br/>      &lt;tag&gt;iplib-1.0-snapshot&lt;/tag&gt;<br/>    &lt;/scm&gt;<br/>.<br/>.<br/>.</span></pre><p id="cd39" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是发布的重要部分是指定<em class="lb"> distributionManagement </em>:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="74b6" class="lu lv iq lq b gy lw lx l ly lz">&lt;distributionManagement&gt;<br/>    &lt;repository&gt;<br/>        &lt;id&gt;development--maven&lt;/id&gt;<br/>        &lt;name&gt;development--maven&lt;/name&gt;<br/>        &lt;url&gt;https://development-304388931199.d.codeartifact.eu-west-1.amazonaws.com/maven/maven/&lt;/url&gt;<br/>    &lt;/repository&gt;<br/>&lt;/distributionManagement&gt;</span></pre><p id="1452" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将所有这些组装起来，并将我的Java代码推上来，结果非常令人满意地是，各种版本进入了存储库，没有人工干预，没有忙乱，最重要的是<em class="lb">没有服务器需要管理</em>。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/bf8959378b0e0c674efece72e42b6a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6P7YS_Djxbd5xsrV6PG4pQ.png"/></div></div></figure><p id="ffac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样的信息也可以从命令行中检索，但这绝对是使用控制台要简单得多的情况之一:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="f019" class="lu lv iq lq b gy lw lx l ly lz">% aws --profile XXX --region eu-west-1 codeartifact \<br/>    list-package-versions \<br/>    --namespace net.parttimepolymath --package iplib \<br/>    --domain development --repository maven \<br/>    --format maven</span><span id="c08e" class="lu lv iq lq b gy ma lx l ly lz">{<br/>  "versions": [<br/>    {<br/>      "version": "1.0-20210306.104320",<br/>      "revision": "IsZFITs4QUJ+NQ4f45Sipzxy6RAbM5GOs1DNPYUh0YY=",<br/>      "status": "Published"<br/>    },<br/>    {<br/>      "version": "1.0-20210306.104728",<br/>      "revision": "hCdgGhXuuqVIqUWlSe3r9YKxQZDnWG3LnBAFR4mCqLw=",<br/>      "status": "Published"<br/>    },<br/> .<br/> .<br/> .</span></pre></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="ed37" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，以上所有这些让我们到达了在我们的无服务器管道中将 Maven工件部署到CodeArtifact中的点。为了结束这个循环，我们需要能够在我们的构建中将工件下拉到桌面——例如在不同的项目中使用<em class="lb"> iplib </em>库。好消息是，这非常简单明了。</p><p id="a65a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们的客户项目需要与上面相同的<code class="fe mb mc md lq b">settings.xml</code>(或者，这可以进入您当地的<code class="fe mb mc md lq b">.m2/settings.xml</code>，正如在<a class="ae la" href="https://docs.aws.amazon.com/codeartifact/latest/ug/using-maven-packages-in-codebuild.html" rel="noopener ugc nofollow" target="_blank"> AWS文档</a>中所讨论的)。</p><p id="4b18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，<code class="fe mb mc md lq b">pom.xml</code>需要分发管理定义来部署:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="4306" class="lu lv iq lq b gy lw lx l ly lz">&lt;distributionManagement&gt;<br/>    &lt;repository&gt;<br/>        &lt;id&gt;development--maven&lt;/id&gt;<br/>        &lt;name&gt;development--maven&lt;/name&gt;<br/>        &lt;url&gt;https://development-304388931199.d.codeartifact.eu-west-1.amazonaws.com/maven/maven/&lt;/url&gt;<br/>    &lt;/repository&gt;<br/>&lt;/distributionManagement&gt;</span></pre><p id="7e1a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是我们需要一个额外的项目来从CodeArtifact中<em class="lb">提取</em>依赖项:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="9c5c" class="lu lv iq lq b gy lw lx l ly lz">&lt;repositories&gt;<br/>    &lt;repository&gt;<br/>        &lt;id&gt;development--maven&lt;/id&gt;<br/>        &lt;url&gt;https://development-304388931199.d.codeartifact.eu-west-1.amazonaws.com/maven/maven/&lt;/url&gt;<br/>    &lt;/repository&gt;<br/>&lt;/repositories&gt;</span></pre><p id="71fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于这个定义有一个警告——在没有指定其他库的情况下，这将导致<em class="lb">所有</em>工件解析都通过我们的CodeArtifact实例。这就是为什么在我们的CodeArtifact配置中，我们在开始时指定了一个外部连接:我们的实例充当Maven中央存储库前面的缓存代理。根据您的需求，这可能不是您想要的，在这种情况下，您可能想要使用<a class="ae la" href="http://maven.apache.org/guides/mini/guide-multiple-repositories.html" rel="noopener ugc nofollow" target="_blank">多库</a>。</p><p id="2e46" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无论哪种方式，进行本地构建都很容易:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="e8d5" class="lu lv iq lq b gy lw lx l ly lz">$ CODEARTIFACT_AUTH_TOKEN=`aws --region eu-west-1 codeartifact get-authorization-token --domain development --domain-owner 304388931199 --query authorizationToken --output text`<br/>$ mvn -s settings.xml clean package</span></pre><p id="e3a4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在maven构建的初始阶段，您应该会看到从我们的codeartifact库下载的依赖项:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="730e" class="lu lv iq lq b gy lw lx l ly lz">[<strong class="lq ir">INFO</strong>] Scanning for projects...<br/>[<strong class="lq ir">INFO</strong>]<br/>[<strong class="lq ir">INFO</strong>] <strong class="lq ir">--------------------&lt; </strong>net.parttimepolymath:awscidr<strong class="lq ir"> &gt;--------------------<br/></strong>[<strong class="lq ir">INFO</strong>] <strong class="lq ir">Building AWSCidr 1.0-SNAPSHOT<br/></strong>[<strong class="lq ir">INFO</strong>] <strong class="lq ir">--------------------------------[ jar ]---------------------------------<br/></strong>Downloading from development--maven: <a class="ae la" href="https://development-889199313043.d.codeartifact.eu-west-1.amazonaws.com/maven/maven/net/parttimepolymath/iplib/1.0-20210306.194311/iplib-1.0-20210306.194311.pom" rel="noopener ugc nofollow" target="_blank">https://development-889199313043.d.codeartifact.eu-west-1.amazonaws.com/maven/maven/net/parttimepolymath/iplib/1.0-20210306.194311/iplib-1.0-20210306.194311.pom</a><br/>.<br/>.<br/>.</span></pre></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="c3a6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后一点:<a class="ae la" href="https://aws.amazon.com/codeartifact/pricing/" rel="noopener ugc nofollow" target="_blank">定价</a>。CodeArtifact的成本低得离谱，在成本上升到“一杯咖啡的价格”之前，您需要有一个非常活跃的开发环境。更重要的是，这些成本比运行安装了Artifactory或类似软件的服务器的成本低几个数量级，更不用说管理该服务器的人力成本了。</p></div></div>    
</body>
</html>