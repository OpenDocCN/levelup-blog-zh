<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践—函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-functions-93ca66ad1a8f?source=collection_archive---------10-----------------------#2020-05-12">https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-functions-93ca66ad1a8f?source=collection_archive---------10-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e568487beb62db68159ff4b8575b8cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xl2cglz5WoHwusGt"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@pictagramar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Amar Yashlaha </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="89f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行和执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="4fc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何编写更加健壮和可维护的JavaScript函数。</p><h1 id="0a52" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">多个参数优于一个对象参数</h1><p id="a81b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果函数中没有太多的参数，我们应该有多个参数，而不是一个对象参数。</p><p id="6020" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有多个参数比只有一个对象参数要清楚得多。</p><p id="a8c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="217d" class="mq lf it mm b gy mr ms l mt mu">const fullName = (person) =&gt; `${this.firstName} ${this.lastName}`</span></pre><p id="d4d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比以下内容更难阅读:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="27a5" class="mq lf it mm b gy mr ms l mt mu">const fullName = (firstName, lastName) =&gt; `${firstName} ${lastName}`</span></pre><p id="3008" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们不知道函数签名中的<code class="fe mv mw mx mm b">person</code>参数包含什么，直到我们查看代码。</p><p id="a28d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二个例子中，我们知道<code class="fe mv mw mx mm b">firstName</code>和<code class="fe mv mw mx mm b">lastName</code>是参数。</p><p id="4c30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果函数比上面的更复杂，那么追踪我们的函数就更难了。</p><p id="05ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个好的经验法则是，对于具有5个或更少参数的函数，它们应该在函数签名中单独列出。</p><p id="8b1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们别无选择，只能将它们中的一些或全部组合成一个对象参数，以保持参数的数量为5个或更少。</p><p id="4106" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为一旦一个函数有超过5个参数，现在函数签名变得难以阅读。</p><p id="da39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，如果一个函数有很多参数，那么就很难记住传递参数的顺序，这样我们就可以正确地调用我们的函数。</p><p id="58a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们的函数有很多参数，跳过参数也是一个问题，因为我们必须检查在哪里传入<code class="fe mv mw mx mm b">undefined</code>以便我们可以跳过传入该参数的值。</p><p id="11f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们传入一个对象，那么我们可以将属性设置为<code class="fe mv mw mx mm b">undefined</code>，然后调用函数，而不是考虑如果我们的函数有很多参数，我们需要在哪里传入<code class="fe mv mw mx mm b">undefined</code>。</p><h1 id="e3b0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">析构和函数</h1><p id="8b6a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">析构是ES2015的一个很好的功能，它让我们可以将数组条目和对象条目分解成它们自己的变量。</p><p id="518c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在函数方面，我们可以使用它来析构对象或数组参数，以选择性地引用我们需要的对象属性或数组条目。</p><p id="fe4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="feba" class="mq lf it mm b gy mr ms l mt mu">const fullName = (person) =&gt; `${this.firstName} ${this.lastName}`</span></pre><p id="5b32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以用析构语法重写它，写为:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7e1d" class="mq lf it mm b gy mr ms l mt mu">const fullName = ({<br/>  firstName,<br/>  lastName<br/>}) =&gt; `${firstName} ${lastName}`</span></pre><p id="c4a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以这样称呼它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5532" class="mq lf it mm b gy mr ms l mt mu">fullName({<br/>  firstName: 'joe',<br/>  lastName: 'smith'<br/>})</span></pre><p id="22ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们传入了:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="59b0" class="mq lf it mm b gy mr ms l mt mu">{<br/>  firstName: 'joe',<br/>  lastName: 'smith'<br/>}</span></pre><p id="f6b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到<code class="fe mv mw mx mm b">fullName</code>，然后由于析构语法的原因，JavaScript解释器将自动获取具有给定属性名的值，并插入具有该变量值的字符串。</p><p id="48e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，析构对象中的<code class="fe mv mw mx mm b">firstName</code>与字符串中引用的相同，也与传递给<code class="fe mv mw mx mm b">fullName</code>函数的<code class="fe mv mw mx mm b">firstName</code>属性相同。</p><p id="be32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，控制台日志输出应该是<code class="fe mv mw mx mm b">'joe smith'</code>。</p><p id="4e3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也适用于嵌套对象。例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5041" class="mq lf it mm b gy mr ms l mt mu">const fullName = ({<br/>  name: {<br/>    firstName,<br/>    lastName<br/>  }<br/>}) =&gt; `${firstName} ${lastName}`</span></pre><p id="1a7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么如果我们如下调用<code class="fe mv mw mx mm b">fullName</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e998" class="mq lf it mm b gy mr ms l mt mu">fullName({<br/>  name: {<br/>    firstName: 'joe',<br/>    lastName: 'smith'<br/>  }<br/>})</span></pre><p id="4389" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们会得到和以前一样的结果。重要的是要注意，我们不必在析构语法中包含对象的每个属性。</p><p id="0923" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4e84" class="mq lf it mm b gy mr ms l mt mu">const name = ({<br/>  name: {<br/>    firstName,<br/>  }<br/>}) =&gt; `${firstName}`</span></pre><p id="9dbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">称之为:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4585" class="mq lf it mm b gy mr ms l mt mu">name({<br/>  name: {<br/>    firstName: 'joe',<br/>    lastName: 'smith'<br/>  }<br/>})</span></pre><p id="dbfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">析构也适用于数组。在函数方面，我们可以用它将数组参数析构为变量。例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9e9e" class="mq lf it mm b gy mr ms l mt mu">const fullName = ([firstName, lastName]) =&gt; `${firstName} ${lastName}`</span></pre><p id="ba4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在<code class="fe mv mw mx mm b">fullName</code>函数接受一个数组作为参数，而不是一个对象。</p><p id="2333" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以这样称呼它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cbb2" class="mq lf it mm b gy mr ms l mt mu">fullName(['joe', 'smith'])</span></pre><p id="f9c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们会像之前一样得到<code class="fe mv mw mx mm b">'joe smith'</code>作为返回值。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/405a2be99891267892987a5c4fca82bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TP8T21JL4cn3ZBzw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@avirichards?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿维·理查兹</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="b524" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="da2b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们的函数接受5个或更少的参数，那么它们应该是分开的，以便于阅读，并减少使用函数的人的认知负担。</p><p id="9597" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，当我们需要将对象或数组条目作为函数中的参数，并且希望有选择地引用这些参数中的条目时，析构语法非常有用。</p></div></div>    
</body>
</html>