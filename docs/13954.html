<html>
<head>
<title>If You Really Must Use SQL Distinct…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果您真的必须使用SQL Distinct…</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/if-you-really-must-use-distinct-c1233761baae?source=collection_archive---------10-----------------------#2022-10-19">https://levelup.gitconnected.com/if-you-really-must-use-distinct-c1233761baae?source=collection_archive---------10-----------------------#2022-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a433" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Distinct就像group by (*)，除非它不是！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/514611b0639aa0011067a7f360291d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRmd9KB5GM0PKBPOSk2mrA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">乔希·弗雷内特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有SQL命令中，Distinct是概念上最容易理解的命令之一:对于给定的一组行，只返回唯一的行。</p><p id="1127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单吧？再想想…</p><p id="edf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在许多存在真正重复的情况下很有用<em class="lv">(像流中的消息)</em>，但是它经常被误用，因为用户并不总是理解它的所有含义。</p><p id="2833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的文章<a class="ae ky" href="https://jmarquesdatabeyond.medium.com/sql-like-a-pro-please-stop-using-distinct-31bdb6481256" rel="noopener"> <em class="lv"> SQL Like a Pro:请停止使用Distinct </em> </a>中，我展示了Distinct是如何经常被误用的。在本文中，我将从一个不同的角度来讨论这个话题:当一个人必须使用Distinct时，他应该完全了解和理解它。这篇文章将试图为你提供一个全新的视角，关于什么是独特的关键字，它是如何工作的，是什么使它表现得更好或更差，以及如何优化它。</p><p id="8601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在培训工程师时，我总是喜欢更深入地挖掘不同的实现，让受训者对其工作原理有一个更全面的理解，并希望减少错误的使用。</p><blockquote class="lw"><p id="9b00" class="lx ly it bd lz ma mb mc md me mf lu dk translated">这篇文章将给你一个新的视角，让你了解Distinct是如何工作的，并且自然会引出一些优化技术。</p></blockquote><p id="067a" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">好奇想了解更多？请继续阅读…</p><h1 id="b8d8" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">Distinct =分组依据(全部)</h1><p id="2bd4" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我总是喜欢将不同的行为解释为<em class="lv">“按所有列分组”</em>，即:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/34a65c8c00da5aed9b73429a883a7ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9icwPYWN_XFXo20pNS4Gw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Select Distinct = Select … group by …</figcaption></figure><p id="b7a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真的就是这样！以至于数据库执行计划100%相同，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/974c85232261e6d7b164d54ea83444be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xW2_NMCDMp7tC0v4tb0oFg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">比较执行计划— Distinct与Group By (ALL)</figcaption></figure><p id="3a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但事实真的总是如此吗？你真的总是按照所有的列进行分组吗？</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="6ec8" class="ml mm it bd mn mo nr mq mr ms ns mu mv jz nt ka mx kc nu kd mz kf nv kg nb nc bi translated">当Distinct不同于Group By (col1，col2)时</h1><p id="b4f1" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">但是有一点你可能没有考虑到，那就是Distinct和group有时会有所不同。为什么？</p><blockquote class="lw"><p id="2adb" class="lx ly it bd lz ma mb mc md me mf lu dk translated">因为group by可以作为目标，而Distinct不能(或者通常不是)。</p></blockquote><p id="3f06" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">一个典型的例子是一个列被多次用于不同的计算/转换。让我们看一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/c0d19982cf14426110889cc6c6a2f809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEPE2lt4-wZ6SAof9tZc_A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(distinct a，b，a+b)如何不同于(group by a，b)</figcaption></figure><p id="5ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实是，数据库无法理解列是否相互依赖<em class="lv">(在某些情况下，它可以，并且可能依赖于查询优化器…但是您真的不想依赖它)</em>。</p><p id="b945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，数据库不想关心这个。如果您的查询要求一个<strong class="lb iu"> <em class="lv">不同的年龄，年龄*年龄，</em> </strong>数据库将准确地执行该操作。为什么？因为只有你明白，对于同一个<strong class="lb iu">年龄，不可能<strong class="lb iu">年龄*年龄</strong>会不一样；</strong>你知道你可以根据年龄进行聚合，然后在之后乘以<strong class="lb iu">。使用同一个年龄相乘的例子，两种说法的区别是:</strong></p><ul class=""><li id="3e36" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><strong class="lb iu"> <em class="lv">【坏】</em> </strong>对于10M行中的每一行，计算<strong class="lb iu"> <em class="lv"> calc=age*age </em> </strong>，然后在10M行中查找不同的<strong class="lb iu"> <em class="lv"> age|calc </em> </strong>记录</li><li id="fa5e" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><strong class="lb iu"> <em class="lv">【好】</em> </strong>找出数据集中所有不同的年龄(100行)，然后只执行计算(100次)</li></ul><p id="df44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种差异确实会影响查询的性能。我们来看看为什么。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="e6fd" class="ml mm it bd mn mo nr mq mr ms ns mu mv jz nt ka mx kc nu kd mz kf nv kg nb nc bi translated">因为Distinct是一个非常昂贵的操作</h1><p id="d1bd" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">对大量列运行Distinct可能会对性能产生严重影响，这对于分布式数据库来说更糟。为什么？</p><p id="cb39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为查找数据集中所有唯一的记录意味着将所有记录相互比较，这意味着在能够将记录卸载给用户之前，要遍历整个数据集。保存所有这些“记录”<em class="lv">(或记录的散列)</em>需要大量的内存，并且将它们相互比较需要大量的计算操作。</p><p id="6071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在大量的大列上运行Distinct时，由于内存限制<em class="lv">(内存访问负载，可能需要磁盘缓存)</em>和计算要求，您的查询性能将会下降。</p><blockquote class="lw"><p id="fd89" class="lx ly it bd lz ma mb mc md me mf lu dk translated">distinct的性能由Distinct项的数量和总体行大小决定:列越多越宽，查询的性能越差。</p></blockquote><p id="936d" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">让我们看一个例子，使用一个有一千万行的表。首先，当考虑列的平均长度和非重复计数时，让我们看看这个表中的数据模式是什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/f0335cf72ad8409a447d5c2c3440cd97.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*eQSWCu2Fr278GktKVGDFow.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">独特的计数和平均长度</figcaption></figure><p id="1d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了比较性能，让我们在简单的列集合(<em class="lv">列a、b、c </em>)上运行Distinct，并与较难的列集合(<em class="lv">列c、d、e </em>)进行比较:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/5a8126bfd8b3f5165a1501fe54e4a9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fslo9o10jq8cmzTa0lgLPA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">小/低基数与大/高基数的区别</figcaption></figure><p id="716a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从执行时间差(7s对9s)可以看出，改变平均列长度和不同值的数量确实会影响查询性能，并且影响的方式不同:</p><ul class=""><li id="137d" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><strong class="lb iu">平均柱长影响:</strong></li><li id="2425" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">&gt;&gt;&gt;所需的磁盘I/O操作<em class="lv">(从磁盘提取数据)</em></li><li id="f0be" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">&gt;&gt;&gt;需要计算<em class="lv">(列越长，构建用于比较的散列所需的操作就越多)</em></li><li id="75c1" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><strong class="lb iu">不同值影响的数量:</strong></li><li id="7432" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">&gt;&gt;&gt;所需的内存量<em class="lv">(在内存中保存所有不同的哈希以便比较)</em></li><li id="f10d" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">&gt;&gt;&gt;计算<em class="lv">(需要更多比较)</em></li></ul><p id="5047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv"> NB: </em> </strong> <em class="lv">以上分析对于柱状存储数据库是成立的。不过，对于基于行的数据库，分析会略有不同。</em></p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="ebaf" class="ml mm it bd mn mo nr mq mr ms ns mu mv jz nt ka mx kc nu kd mz kf nv kg nb nc bi translated">使用这些信息来提高查询性能</h1><p id="27e4" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">有了这些知识，你现在就可以用不同的眼光看待你独特的查询，并理解如何优化它们。</p><blockquote class="lw"><p id="a1cd" class="lx ly it bd lz ma mb mc md me mf lu dk translated">TL；DR；这里最大的提示如下:</p><p id="07fb" class="lx ly it bd lz ma mb mc md me mf lu dk translated">执行Distinct时，如果任何列被多次使用，请考虑按列显式分组，而不是执行完整的group by。</p></blockquote><p id="e890" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">让我们看看这是什么样子的。使用相同的1000万行数据集，我对所有列进行了大量的计算，因此我们可以真正体会到两者之间的差异。让我们从坏的例子开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/20a26e1a8422b937092dd7a35875129f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PnacVLlOHSfXG7rh1PalUw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">也许是手术太多了？或者会有那么明显吗？</figcaption></figure><p id="7cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个查询花了40秒。不可怕，但是请记住这是一个小表，列真的没有那么复杂。</p><p id="ba5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们用group by替换它呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/1b372ee137eb07751ff617639ac81b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOoWXUDYPwy5Af5EGCNkMg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">那就好多了！</figcaption></figure><p id="1154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新的改进的查询现在用时不到28秒，<strong class="lb iu">产生完全相同的输出</strong>。通过做这个小小的改变，我们已经告诉数据库，所有这些计算都可以在聚合之后进行，并且分组不需要这些计算。因此，查询在67%的时间内运行。<strong class="lb iu">这就是我所说的结果！</strong></p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="ad63" class="ml mm it bd mn mo nr mq mr ms ns mu mv jz nt ka mx kc nu kd mz kf nv kg nb nc bi translated">结论</h1><p id="1190" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在代码审查期间，Distinct关键字总是让我多看两眼。人们很容易误解其使用的复杂性，即使从性能的角度来看，通常也有很多收获。这就是为什么我觉得第二篇文章如此重要，因为Distinct是非常有用和必要的，但如果您希望产生高质量和高性能的SQL，也必须很好地应用它。</p><blockquote class="lw"><p id="bd82" class="lx ly it bd lz ma mb mc md me mf lu dk translated">即使您已经了解了它的所有内容，我希望这篇文章至少让您对Distinct的实际工作方式有了额外的了解，并让您对它有了更好的理解。</p></blockquote><p id="392b" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">也许下次你遇到这个独特的关键词时，你会以不同的方式看待它。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="73f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你看我的文章！<br/>而现在，为了几个<em class="lv">(不要脸)</em>支持我”的词。</p><p id="b285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否在考虑订阅Medium？ <br/>也许你会考虑<a class="ae ky" href="https://jmarquesdatabeyond.medium.com/membership" rel="noopener">通过使用我的推荐链接</a>来支持我的写作。注意:使用我的链接会给我一点佣金，不会给你额外的费用。</p></div></div>    
</body>
</html>