<html>
<head>
<title>Building a Location-Based App with Appwrite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Appwrite构建基于位置的应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-location-based-app-with-appwrite-48a2e2b6d4c2?source=collection_archive---------6-----------------------#2022-05-16">https://levelup.gitconnected.com/building-a-location-based-app-with-appwrite-48a2e2b6d4c2?source=collection_archive---------6-----------------------#2022-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d24630a63e51208c1b5cda807b6231dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9oI7Uq8h-agaea8f"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@dead____artist?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Z </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3905" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我使用<a class="ae kf" href="https://appwrite.io/discord" rel="noopener ugc nofollow" target="_blank"> Appwrite discord </a>服务器期间，我看到一些人询问如何使用Appwrite创建一个使用GPS坐标的应用程序，因为Appwrite还没有<a class="ae kf" href="https://github.com/appwrite/appwrite/issues/388" rel="noopener ugc nofollow" target="_blank">地理查询</a>。虽然我对如何实现这一点有一些想法，但我在<a class="ae kf" href="https://dev.to/devteam/announcing-the-appwrite-hackathon-on-dev-1oc0" rel="noopener ugc nofollow" target="_blank">app write Hackathon on Dev</a>with<a class="ae kf" href="https://dev.to/stnguyen90/places-appwrite-and-maps-14kh" rel="noopener ugc nofollow" target="_blank">Places</a>期间找到了解决这个问题的机会。请继续阅读，了解Places是如何设计和构建的详细信息。</p><h1 id="1b6b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">概观</h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/18a93ec3bb365a2f63cc4821215bfe6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMMpoDsm1ntFKL57Z0uGIg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用例图</figcaption></figure><p id="13f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Places有两种类型的用户:</p><ol class=""><li id="0f6e" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">未经证实的</li><li id="a5a2" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">鉴定</li></ol><p id="075d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">未经身份验证的用户应该能够:</p><ol class=""><li id="924b" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">查看地图上的地点</li><li id="22c2" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">查看对某个地点的评论</li><li id="d477" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">查看某个地方的照片</li></ol><p id="bcab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">经过身份验证的用户应该能够做未经身份验证的用户可以做的所有事情，以及:</p><ol class=""><li id="b354" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">添加一个位置</li><li id="8ee2" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">添加对某个地点的评论</li><li id="bd03" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">在一个地方添加照片</li></ol><h1 id="a658" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设计</h1><h2 id="273f" class="mv lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">收集</h2><p id="02eb" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">给定概述中定义的用例，需要以下集合:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/0c9a963d04497e684fdf8eae450dba81.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*KEkeIG9Je21HNXlS"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">类图</figcaption></figure><ul class=""><li id="78e5" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld nn mn mo mp bi translated">地点:使用纬度和经度在地图上存储地点</li><li id="557e" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld nn mn mo mp bi translated">users:公开存储用户名Users，因为Appwrite的用户数据是不能公开访问的</li><li id="7fc6" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld nn mn mo mp bi translated">评论:存储一个地点的评论<br/> - <code class="fe no np nq nr b">created</code> : ISO 8601格式时间戳<br/> - <code class="fe no np nq nr b">place_id</code> : <code class="fe no np nq nr b">$id</code>地点将该评论链接到一个地点<br/> - <code class="fe no np nq nr b">user_id</code> : <code class="fe no np nq nr b">$id</code>用户将该评论链接到一个用户<br/> - <code class="fe no np nq nr b">text</code>:评论文本</li><li id="8c32" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld nn mn mo mp bi translated">照片:从<a class="ae kf" href="https://appwrite.io/docs/client/storage" rel="noopener ugc nofollow" target="_blank">存储API </a> <br/> - <code class="fe no np nq nr b">place_id</code> : <code class="fe no np nq nr b">$id</code>中存储一个位置的照片元数据<br/> - <code class="fe no np nq nr b">created</code>:文件的ISO 8601格式时间戳<br/> - <code class="fe no np nq nr b">file_id</code> : <code class="fe no np nq nr b">$id</code>将该评论链接到用户的位置<br/> - <code class="fe no np nq nr b">user_id</code> : <code class="fe no np nq nr b">$id</code>将该评论链接到用户<br/> - <code class="fe no np nq nr b">text</code>:照片描述</li></ul><h2 id="1f64" class="mv lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">储存；储备</h2><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/a42e25ccc9fbc45770735b752daf12cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wNXdOSlfcDwkdJ6Y"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">存储图</figcaption></figure><p id="cf8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2个桶用于实际的照片文件:</p><ol class=""><li id="b14f" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">照片上传:只写桶，允许用户提交照片</li><li id="0a75" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">照片:对用户公开的照片的只读存储桶</li></ol><h2 id="8e5c" class="mv lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">功能</h2><p id="834a" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">为了确保数据的完整性，使得对于不存在的地方没有评论，并且用户不能冒充另一个用户，评论和照片集合不是公开可写的。相反，<a class="ae kf" href="https://appwrite.io/docs/functions" rel="noopener ugc nofollow" target="_blank"> Appwrite函数</a>在创建文档之前验证并自动填充属性。此外，基于事件的功能用于用户和照片。</p><p id="0cbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">创建评论和创建照片</strong></p><p id="3094" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些函数都接受以下输入:</p><ul class=""><li id="d096" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld nn mn mo mp bi translated"><code class="fe no np nq nr b">place_id</code></li><li id="4a2a" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld nn mn mo mp bi translated"><code class="fe no np nq nr b">text</code></li></ul><p id="715d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，他们:</p><ol class=""><li id="3df0" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">通过按ID提取位置来验证<code class="fe no np nq nr b">place_id</code>是否存在</li><li id="2f78" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">使用当前时间戳自动填充<code class="fe no np nq nr b">created</code></li><li id="0d70" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">使用执行该功能的用户的用户ID自动填充<code class="fe no np nq nr b">user_id</code></li><li id="b2c0" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">在相应的集合中创建文档</li></ol><p id="b757" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">创建用户</strong></p><p id="7db7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户创建一个帐户时，这个函数被触发。该函数唯一做的事情是使用用户ID和名称创建一个用户文档。</p><p id="1c2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">工艺照片</strong></p><p id="996f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为存储API只支持除了名称之外没有任何其他元数据的文件(通过JavaScript是<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/File#instance_properties" rel="noopener ugc nofollow" target="_blank">只读</a>)，所以一个Photos集合被用于元数据(将用户和地点链接到照片)。Appwrite函数用于保持照片文档和文件同步，以及对照片执行任何处理。上传照片的流程如下:</p><ol class=""><li id="4dee" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">创建照片文档</li><li id="52e5" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">创建文件，提供照片文档ID作为自定义ID</li></ol><p id="0084" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，处理照片功能触发并执行以下操作:</p><ol class=""><li id="dc45" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">如果存储桶不是照片上传存储桶，则退出</li><li id="9668" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">从文件读取权限获取用户ID</li><li id="90cd" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">验证用户ID与照片文档的<code class="fe no np nq nr b">user_id</code> <br/>匹配——这确保上传文件的用户与创建文档的用户相同。</li><li id="aeb5" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">从照片上传桶下载上传的文件</li><li id="4528" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">调整图像大小，使照片不会过大</li><li id="9d6e" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">从照片中移除位置元数据以保护用户隐私</li><li id="b7fb" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">在照片存储桶中创建新文件</li><li id="d275" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">用新创建的文件ID更新现有照片文档的<code class="fe no np nq nr b">file_id</code></li><li id="438a" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">从照片上传存储桶中删除文件，以防止存储桶变得过大</li></ol><h2 id="2110" class="mv lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">前端</h2><p id="f544" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">前端由以下库构建:</p><ol class=""><li id="f1f2" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><a class="ae kf" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>因为它是一个广受欢迎的前端库</li><li id="561b" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">因为静态类型检查通过及早捕捉错误并提供信息丰富的代码完成大大改善了开发人员的体验</li><li id="e19c" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">MUI因为它是一个广泛流行的用户界面库，使得构建一个好看的、响应迅速的用户界面变得简单快捷</li><li id="f5a5" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><a class="ae kf" href="https://react-leaflet.js.org" rel="noopener ugc nofollow" target="_blank"> React传单</a>因为我们使用React，而<a class="ae kf" href="https://leafletjs.com" rel="noopener ugc nofollow" target="_blank">传单</a>是一个开源的移动友好地图库，有很多<a class="ae kf" href="https://leafletjs.com/plugins.html" rel="noopener ugc nofollow" target="_blank">插件</a></li></ol><p id="ce7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">获取GPS数据</strong></p><p id="9b28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React传单库让处理GPS数据变得如此简单。当人们第一次来到discord服务器询问如何查询数据时，我认为有必要使用三角学来计算给定中心点和半径的北-南-东-西边界。</p><p id="7a0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">做数学是一种方法，但我很快发现这完全没有必要。原来React传单库公开了一个<code class="fe no np nq nr b">map.getBounds()</code>函数，该函数返回一个<code class="fe no np nq nr b"><a class="ae kf" href="https://leafletjs.com/reference.html#latlngbounds" rel="noopener ugc nofollow" target="_blank">LatLngBounds</a></code> <a class="ae kf" href="https://leafletjs.com/reference.html#latlngbounds" rel="noopener ugc nofollow" target="_blank">对象</a>，该对象包含地图当前视图的北-南-东-西边界。</p><pre class="md me mf mg gt nt nr nu nv aw nw bi"><span id="8f55" class="mv lf it nr b gy nx ny l nz oa">map.getBounds()<br/>{<br/>  "_southWest": {<br/>    "lat": 51.46684144864419,<br/>    "lng": -0.15964508056640628<br/>  },<br/>  "_northEast": {<br/>    "lat": 51.5429188223739,<br/>    "lng": -0.020256042480468753<br/>  }<br/>}</span></pre><p id="9b8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，剩下要做的唯一一件事就是构建一个查询来基于这些界限进行过滤:</p><pre class="md me mf mg gt nt nr nu nv aw nw bi"><span id="103e" class="mv lf it nr b gy nx ny l nz oa">const b = map.getBounds();<br/>const documentList = await sdk.database.listDocuments&lt;Place&gt;(<br/>  Collections.Places,<br/>  [<br/>    Query.greater(Attributes.Places.Latitude, b.getSouth()),<br/>    Query.lesser(Attributes.Places.Latitude, b.getNorth()),<br/>    Query.greater(Attributes.Places.Longitude, b.getWest()),<br/>    Query.lesser(Attributes.Places.Longitude, b.getEast()),<br/>  ]<br/>);</span></pre><h1 id="ab54" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">逮到你了</h1><h2 id="1de9" class="mv lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">向东和向西平移</h2><p id="6a1b" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">因为地球是圆的，如果你向西平移，你最终会回到你开始的地方。然而，这如何在应用程序中转换为经度？原来，小叶并没有重置经度，只是继续减少或增加。例如，如果您从(40.71，-74.01)开始，向西绕地球两圈，再次到达同一位置，您将到达(40.71，-794.01)。这导致在查看地点和添加地点时出现问题。</p><p id="26bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">查看地点时平移</strong></p><p id="322b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看地点时平移的问题是，如果在(40.71，-74.01)添加了一个地点，但用户平移到(40.71，-794.01)时，他们将看不到该地点。</p><p id="a93b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，如果用户平移超过某个点，地图将重置以保持在某个范围内。当使用0°和360°作为范围时，我注意到一个问题，即地图在穿越边界时出现毛刺。这可以通过使用-180°和180°作为边界来改善。由于这一边界在太平洋上空，没有任何陆地，所以故障不太明显，如果用户不横跨太平洋，甚至可能不会体验到。</p><p id="bdd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">添加地点时平移</strong></p><p id="7f2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">添加地点时平移的问题是，如果有人平移到(40.71，-794.01)并在那里添加地点，当有人查看同一位置时，但在(40.71，-74.01)，该地点不会出现。</p><p id="9ad8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，我在发送给Appwrite之前修改了经度。当经度小于-180°时，增加360°。当经度大于180°时，减去360°。</p><h1 id="e213" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="f3e4" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">如你所见，即使没有地理查询，使用Appwrite创建基于位置的应用程序也是完全可能的。地点有效地展示:</p><ol class=""><li id="9cf1" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">如何设计相关系列</li><li id="f930" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">如何通过Appwrite函数确保相关数据的完整性</li><li id="f80e" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">如何存储和获取位置数据</li></ol><p id="6ade" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然本文中没有提到，但是Places也使用了:</p><ol class=""><li id="b466" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">获取异步处理数据的实时API</li><li id="db10" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">响应式设计构建渐进式Web应用程序</li></ol><p id="907f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要观看地点演示，请浏览<a class="ae kf" href="https://places.pages.dev" rel="noopener ugc nofollow" target="_blank"> https://places.pages.dev </a>。完整的源代码，请查看<a class="ae kf" href="https://github.com/stnguyen90/places" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></div></div>    
</body>
</html>