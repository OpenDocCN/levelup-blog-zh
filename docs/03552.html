<html>
<head>
<title>Learning C++: Class Templates and the STL Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:类模板和STL第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-class-templates-and-the-stl-part-1-d3a9891f827e?source=collection_archive---------11-----------------------#2020-05-15">https://levelup.gitconnected.com/learning-c-class-templates-and-the-stl-part-1-d3a9891f827e?source=collection_archive---------11-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4fc25123208e663e094a4296521cf90f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TDN09_Ll2OIynrVt"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@mimithian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米米·蒂安</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0fb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前两篇文章中，我讨论了如何在C++中创建和使用函数模板。在这篇文章和下一篇文章中，我将讨论如何创建和使用类模板。模板允许我们创建通用程序，这些程序可以处理不同的数据类型，而不必重载和/或复制编程代码。泛型编程是C++标准模板库(STL)的核心，理解如何使用函数和类模板是有效使用STL的基础。</p><h1 id="68e5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义类模板—堆栈类</h1><p id="93ff" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">套用已故计算机科学家西蒙·派珀特的一句话，没有编程就很难谈论编程。对于我的类模板示例，我将首先定义一个<code class="fe mh mi mj mk b">Stack</code>类，然后定义一个模仿C++的<code class="fe mh mi mj mk b">pair </code>结构的<code class="fe mh mi mj mk b">Pair</code>类。</p><p id="575f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如许多人所知，堆栈是一种数据结构，其中数据被输入到堆栈的顶部(通过<code class="fe mh mi mj mk b">push</code>成员函数)，而数据只从堆栈的顶部移除(通过<code class="fe mh mi mj mk b">pop</code>成员函数)。唯一需要的另一个主成员函数是一个<code class="fe mh mi mj mk b">top</code>函数，它检查并返回栈顶的数据元素。</p><p id="0446" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">栈可以用于所有数据类型，这种能力有助于通用实现。我们可能需要一个整数堆栈，或者字符串堆栈，或者浮点值堆栈。为每种数据类型创建单独的实现是不切实际的，因此模板定义是必要的。</p><p id="d378" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将通过展示如何将一个类定义为类模板来开始类定义。这看起来很像你第一次定义一个函数模板。下面是我如何开始这个<code class="fe mh mi mj mk b">Stack</code>类的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4458" class="mt lf it mk b gy mu mv l mw mx">template &lt;typename T&gt;<br/>class Stack {<br/>  // declarations and definitions<br/>};</span></pre><p id="56b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从现在开始，每当我们需要引用一个数据类型，或者引用进入该类的数据或者从该类发送的数据时，我们将使用<code class="fe mh mi mj mk b">T</code>占位符来键入数据。下面是<code class="fe mh mi mj mk b">Stack</code>类的完整声明:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3bf6" class="mt lf it mk b gy mu mv l mw mx">template &lt;typename T&gt;<br/>class Stack {<br/>  private:<br/>    vector&lt;T&gt; data;<br/>  public:<br/>    void push(T element);<br/>    bool pop();<br/>    T top();<br/>};</span></pre><p id="873c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到，保存堆栈数据的向量是用<code class="fe mh mi mj mk b">T</code>键入的，<code class="fe mh mi mj mk b">push</code>成员函数的参数和<code class="fe mh mi mj mk b">top</code>成员函数的返回类型也是如此。您还应该注意到，为了节省空间，我没有为该类定义构造函数，也没有定义任何实用函数，这并不是因为我认为它们对于一个完整的堆栈类定义来说是不必要的。</p><p id="582d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看<code class="fe mh mi mj mk b">Stack</code>类的定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7764" class="mt lf it mk b gy mu mv l mw mx">template &lt;typename T&gt;<br/>void Stack&lt;T&gt;::push(T const&amp; element) {<br/>  data.push_back(element);<br/>}</span><span id="ead1" class="mt lf it mk b gy my mv l mw mx">template &lt;typename T&gt;<br/>bool Stack&lt;T&gt;::pop() {<br/>  if (!data.empty()) {<br/>    data.pop_back();<br/>    return true;<br/>  }<br/>  return false;<br/>}</span><span id="7301" class="mt lf it mk b gy my mv l mw mx">template &lt;typename T&gt;<br/>T const&amp; Stack&lt;T&gt;::top() {<br/>  return data.back();<br/>}</span></pre><p id="8db1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请特别注意模板参数占位符在定义部分中的使用位置。每次提到类名时，以及每当它需要作为参数类型或返回类型的占位符时，都必须将它放在括号中。</p><p id="960a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个将<code class="fe mh mi mj mk b">Stack</code>类用于整数的程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c6b3" class="mt lf it mk b gy mu mv l mw mx">int main()<br/>{<br/>  Stack&lt;int&gt; numbers;<br/>  numbers.push(1);<br/>  numbers.push(2);<br/>  cout &lt;&lt; "The top of the stack" " &lt;&lt; numbers.top() &lt;&lt; endl;<br/>  numbers.push(3);<br/>  cout &lt;&lt; "The top of the stack: " &lt;&lt; numbers.top() &lt;&lt; endl;<br/>  numbers.pop();<br/>  cout &lt;&lt; "The top of the stack: " &lt;&lt; numbers.top() &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="862c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您需要注意的一件事是，如果您不提供模板参数，程序将无法编译。与函数模板不同，在函数模板中，编译器可以从参数中推导出数据类型，而在类模板中，编译器无法推导出类的类型，因为没有要推导的参数。</p><h1 id="f0e6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第二个例子:Pair类</h1><p id="ee1d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Pair</code>是一个保存两个数据元素的类。这些数据元素可以是任何类型，也可以是不同的类型。我的定义将模仿STL中的<code class="fe mh mi mj mk b">pair</code>结构，并用于STL容器，如map。</p><p id="4c25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该类的两个成员变量是<code class="fe mh mi mj mk b">first</code>和<code class="fe mh mi mj mk b">second</code>。为了更接近地模仿STL版本，这些将在<code class="fe mh mi mj mk b">public</code>部分声明，这样它们可以直接从<code class="fe mh mi mj mk b">pair</code>对象访问。(由于成员变量的公共访问，我也可以将这个类实现为一个结构。)</p><p id="620f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为这是一个简单的类，所以声明也是对<code class="fe mh mi mj mk b">Pair </code>类的定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d4a7" class="mt lf it mk b gy mu mv l mw mx">template &lt;typename T1, typename T2&gt;<br/>class Pair {<br/>  public:<br/>    T1 first;<br/>    T2 second;<br/>};</span></pre><p id="8b88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">pair</code> struct有一个帮助生成pair对象的函数，<code class="fe mh mi mj mk b">make_pair</code>。这是我的版本的定义，叫做<code class="fe mh mi mj mk b">makePair</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8a74" class="mt lf it mk b gy mu mv l mw mx">template &lt;typename T1, typename T2&gt;|<br/>Pair&lt;T1, T2&gt; makePair(T1 first, T2 second) {<br/>  Pair&lt;T1, T2&gt; p;<br/>  p.first = first;<br/>  p.second = second;<br/>  return p;<br/>}</span></pre><p id="edc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这需要一个函数模板，以便我们可以根据需要更改第一个和第二个类型。</p><p id="4284" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用<code class="fe mh mi mj mk b">Pair</code>类和<code class="fe mh mi mj mk b">makePair</code>函数的示例程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8bf1" class="mt lf it mk b gy mu mv l mw mx">template &lt;typename T1, typename T2&gt;<br/>class Pair {<br/>  public:<br/>    T1 first;<br/>    T2 second;<br/>};</span><span id="20a7" class="mt lf it mk b gy my mv l mw mx">template &lt;typename T1, typename T2&gt;<br/>Pair&lt;T1, T2&gt; makePair(T1 first, T2 second) {<br/>  Pair&lt;T1, T2&gt; p;<br/>  p.first = first;<br/>  p.second = second;<br/>  return p;<br/>}</span><span id="392d" class="mt lf it mk b gy my mv l mw mx">int main()<br/>{<br/>  Pair&lt;string, int&gt; nameAge;<br/>  string name = "Mary";<br/>  int age = 23;<br/>  nameAge = makePair&lt;string, int&gt;(name, age);<br/>  cout &lt;&lt; "Name: " &lt;&lt; nameAge.first &lt;&lt; endl;<br/>  cout &lt;&lt; "Age: " &lt;&lt; nameAge.second &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="66a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d4e6" class="mt lf it mk b gy mu mv l mw mx">Name: Mary<br/>Age: 23</span></pre><p id="a33d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了说明类模板为什么有用，下面是另一个使用这个类和函数的程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3cda" class="mt lf it mk b gy mu mv l mw mx">int main()<br/>{<br/>  Pair&lt;double, string&gt; ratios;<br/>  double r = 3.14159;<br/>  string name = "pi";<br/>  ratios = makePair(r, name);<br/>  cout &lt;&lt; "Value: " &lt;&lt; ratios.first &lt;&lt; endl;<br/>  cout &lt;&lt; "Name: " &lt;&lt; ratios.second &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="6908" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="93d3" class="mt lf it mk b gy mu mv l mw mx">Value: 3.14159<br/>Name: pi</span></pre><h1 id="0b95" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类模板的价值</h1><p id="7ba3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">像函数模板一样，类模板使C++中的泛型编程成为可能。泛型程序比其他编程范式更灵活，因为正如标准模板库所示，我们可以以各种方式混合和匹配容器(数据结构)和算法(函数)，这在其他范式中是不可能的。</p><p id="a15d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有更多关于类模板的主题，我将在下一篇文章中讨论其中的几个主题。</p><p id="17ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。</p></div></div>    
</body>
</html>