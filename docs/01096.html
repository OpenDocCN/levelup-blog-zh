<html>
<head>
<title>Learn TypeScript Data Types — From Zero to Hero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解TypeScript数据类型——从零到英雄</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-typescript-data-types-from-zero-to-hero-e6791e7acf85?source=collection_archive---------10-----------------------#2019-11-08">https://levelup.gitconnected.com/learn-typescript-data-types-from-zero-to-hero-e6791e7acf85?source=collection_archive---------10-----------------------#2019-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1bf366bbe4cd9c4f4c993cb41c98d3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GBMtmHf-Ba7ij88h"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">与Raj 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@roadtripwithraj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">公路旅行照片</a></figcaption></figure><p id="c2c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">我</span>如今，在网络开发的世界里，打字稿风靡一时。我敢打赌，到现在你已经听说过了，甚至是顺便听说过。但是，如果你没有，或者你只是好奇，那么你来对地方了，我的朋友！</p><p id="9619" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我目前正在结合Angular学习TypeScript(关于这方面的一篇文章正在撰写中，敬请关注！)因为这是我们的web应用程序在工作时内置的。我决定编写一个简单易懂的指南，这样您就可以开始使用TypeScript数据类型了。</p><p id="9d62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了简单起见，我将这篇文章分成两篇，第一篇简要概述什么是TypeScript、数据类型和一些支持性的例子。第二篇文章将关注如何在您的机器上安装和运行TypeScript。</p><h1 id="2360" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">这是什么？</h1><p id="04c6" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在我们开始之前，这里有一个用我自己的话对TypeScript的超级浓缩的描述。它是JavaScript的<strong class="ki iu"> <em class="mq">超集</em></strong>——本质上意味着它是一种JavaScript形式，除了“普通”JavaScript所包含的所有优点之外，它还能给你带来某些好处。这是一种由微软编写和维护的开源语言。</p><p id="6376" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript将文件转换为JavaScript，并将在本地JavaScript运行的任何环境中运行。您可以对前端和后端应用程序都使用TypeScript。</p><p id="82ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它就像JavaScript一样编写，除了一些例外，我们很快就会看到。下面是一些打字稿的例子:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/7985323f0ac24436e0bbeba3888bc771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cIOUiHs9o41iiF6i.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">TyepScript在所有它的荣耀</figcaption></figure><p id="4cef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽量不要关注上面看到的所有冒号和额外的东西，我们将在下面深入探讨。相反，关注突出的东西——我们只是用值声明变量，这些是字符串、数组和对象，就像在JavaScript中一样。</p><p id="fd6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我学到的关于TypeScript的另一件大事是，您可以将JavaScript与代码混合使用，这样做没有任何问题。查看下面的截图(这是在Angular应用程序内):</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d4429e42b1492dadf390cb79b901a54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/0*NL_3TMqJ4DzMtdON.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在同一文件中一起使用的TypeScript和JavaScript</figcaption></figure><h1 id="6266" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">数据类型</h1><p id="149d" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">让我们从有趣的东西开始——数据类型！(有一些数据类型我们不会涉及——never、null、undefined。这仅仅是因为对他们来说没有什么。我想让你知道它们的存在，如果你想深入了解这些类型，这里有一个到官方<a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank"> TypeScript文档</a>的链接供你参考。)</p><p id="7097" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript将推断分配给变量的数据类型，而无需显式设置类型，但为了简单起见，我喜欢在声明变量时声明数据类型。</p><p id="6b6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过简单地在变量名之后等号之前放置一个冒号来分配数据类型:</p><p id="8b2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="mq">常量{变量名}:{变量类型} = {变量值</em> </strong> }</p><p id="26b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是大多数TypeScript数据类型声明的约定，但函数和对象除外。</p><p id="3084" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有些数据类型比这要复杂一些，但是您已经大致了解了。下面是对数据类型的一些简要说明以及如何声明它们的例子。</p><h2 id="30b7" class="mx lo it bd lp my mz dn lt na nb dp lx kr nc nd mb kv ne nf mf kz ng nh mj ni bi translated">布尔代数学体系的</h2><p id="32a9" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">TypeScript中的布尔值与JavaScript中的布尔值工作方式相同。数据类型为boolean的变量声明如下:</p><p id="46b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">const myBool: boolean = false</code>；</p><h2 id="4750" class="mx lo it bd lp my mz dn lt na nb dp lx kr nc nd mb kv ne nf mf kz ng nh mj ni bi translated">线</h2><p id="eba5" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">TypeScript中的字符串与JavaScript中的字符串工作方式相同。数据类型为string的变量声明如下:</p><p id="e438" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b"><em class="mq">let myString: string = 'bacon'</em></code></p><h2 id="b06f" class="mx lo it bd lp my mz dn lt na nb dp lx kr nc nd mb kv ne nf mf kz ng nh mj ni bi translated">数字</h2><p id="0b41" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">TypeScript中的数字与JavaScript中的数字工作方式相同。数据类型为number的变量声明如下:</p><p id="1414" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">const myNum: number = 1207;</code></p><h2 id="53ee" class="mx lo it bd lp my mz dn lt na nb dp lx kr nc nd mb kv ne nf mf kz ng nh mj ni bi translated">排列</h2><p id="c6b4" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">TypeScript中的数组和其他数据类型一样，就像JavaScript中的数组一样。数据类型数组的变量有两种不同的声明方式:</p><p id="3146" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">const myArr: number[] = [12, 90, 71];</code></p><p id="50fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果数组中的所有元素都是数字，那么上面的方法就是你声明数组的方法。</p><p id="6555" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">const myArr: Array&lt;number&gt; = [12, 90, 71];</code></p><p id="92ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种声明数组的方式使用设置为number的通用数组类型。从功能上讲，这些方法产生声明数组类型变量的最终结果的方式没有区别。</p><p id="1f8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果数组中的数据类型未知或为混合数据类型，可以使用<em class="mq"> &lt; any &gt; </em>类型声明数组(这是一种独立的类型，将在下面讨论):</p><p id="6b88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">const myArr: Array&lt;any&gt; = [12, 'thirteen', false];</code></p><p id="737f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方式将允许您在数组中混合数据类型。</p><h2 id="8cb1" class="mx lo it bd lp my mz dn lt na nb dp lx kr nc nd mb kv ne nf mf kz ng nh mj ni bi translated">元组</h2><p id="cb7f" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">元组是TypeScript特有的数据类型。可以把它们想象成元素数量固定的数组。当您确切知道应该有多少个变量时，最好使用这种数据类型。可以重新分配索引的值，但不能重新分配元组中的元素数量。</p><p id="b098" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据类型tuple的变量就像数组一样声明:</p><p id="28f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">let mine: [number, string];</code></p><p id="2ecd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想要改变元素的<em class="mq">值</em>，我们可以这样做，只要它们匹配我们在声明变量时提供的类型:</p><p id="3c4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">mine[0] = 14</code> ✔️</p><p id="e8b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">mine[0] = 'Steve'</code> ❌</p><p id="5d0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们将<code class="fe nj nk nl nm b">mine</code>定义为一个元组，所以值的顺序也很重要，并且不能改变，在最初定义的数字之外分配一个索引将会产生一个错误:</p><p id="21a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">mine[0] = ['Dave', 71]</code> ❌</p><p id="489c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">mine = [121, 'Dave', 'Steve'];</code> ❌</p><p id="1ad1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">mine = [121, 'bacon'];</code> ✔️</p><h2 id="e45a" class="mx lo it bd lp my mz dn lt na nb dp lx kr nc nd mb kv ne nf mf kz ng nh mj ni bi translated">功能</h2><p id="d4b9" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">函数可以像你希望的那样显式。我的意思是，我们可以对参数和返回值应用类型。下面是两个例子:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/872b7112af0e9e63ca8cfab5dea32dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/0*FuIj50zqHieMQemx.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们明确定义了我们期望这个函数返回的值的类型</figcaption></figure><p id="bc39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果返回的值不是数字或指向数字，这个函数将抛出一个<em class="mq">错误</em>。只有当 变量指向一个数字时，它才可以返回一个变量<strong class="ki iu"> <em class="mq">。</em></strong></p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/0196697311732dc5a12fa9536e763394.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/0*77xbjopaFymoqzss.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们也可以定义我们期望的参数类型</figcaption></figure><p id="fbc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面，我们对传递给函数的参数进行了类型检查。这是避免错误的一个很好的方法，因为如果参数的数量是关闭的，或者如果它们的数据类型与我们期望的不匹配，TypeScript会让我们知道错误。</p><p id="865d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我想要一个不返回值的函数，我可以将类型设置为<em class="mq"> void </em>(一种数据类型，意味着没有任何数据。虽然它可以在声明变量时使用，但通常不是这样，因为那样我们必须将变量设置为<em class="mq"> null </em>或<em class="mq"> undefined </em>，我只在函数没有返回值时使用过，如果函数返回任何东西，TypeScript将抛出一个错误:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi np"><img src="../Images/970dd2742c0835586578fde9cfbfcf7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/0*VoTLaQs4AJXgy6wp.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">类型设置为void的函数</figcaption></figure><p id="9ef6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将类型设置为<em class="mq"> void </em>，我明确了我的返回，并且确定了虽然这个函数仍然可以运行，但是它不应该<em class="mq">返回值</em>。如果它确实返回值，我会得到一个错误。</p><h2 id="cd58" class="mx lo it bd lp my mz dn lt na nb dp lx kr nc nd mb kv ne nf mf kz ng nh mj ni bi translated">列举型别</h2><p id="dfb5" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">枚举是数据类型的一个受欢迎的补充(依我拙见)。可以把它们看作是一种更加用户友好的给数值命名的方法。下面是一个枚举示例:</p><p id="3263" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">enum Foods {'bacon', 'tomato', 'lettuce'};</code></p><pre class="ms mt mu mv gt nq nm nr ns aw nt bi"><span id="3419" class="mx lo it nm b gy nu nv l nw nx">console.log(Foods[0]) // yields 'bacon'<br/>console.log(Foods.bacon) // yields 0 <br/>console.log(Foods['lettuce']) // yields 2</span></pre><p id="c75f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也可以用枚举来分配编号索引格式。包括C#在内的许多语言都有枚举，我很高兴看到JavaScript也有枚举。</p><p id="ee86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以想怎么起名字就怎么起。你甚至可以改变指数的数字表示。如果希望第一个索引从18开始，而不是从0开始，那么很简单:</p><p id="a777" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">enum Foods {'bacon'= 18, 'tomato', 'lettuce'};</code></p><p id="8f75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">console.log(Foods['bacon']); // 18</code></p><p id="878f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有值18，但不确定它在我们的<code class="fe nj nk nl nm b">Foods</code>枚举中映射到什么，我们也可以检查它:</p><p id="e7a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">console.log(Foods[18]); // 'bacon'</code></p><p id="4da7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一条值得注意的信息是，我们已经将第一个索引设置为从18开始，下一个索引将是19，依此类推，遵循您建立的编号约定。</p><p id="8f64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">对象</strong></p><p id="06aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript中对象的定义方式与JavaScript中对象的定义方式相似。我们可以根据自己的喜好或形势的要求，对我们的定义进行含蓄或明确的表述:</p><p id="d877" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">let data: = {name: 'Jonathan', age: 30, hobbies: ['running','swimming','coding']};</code> ✔️</p><p id="b8a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">let data: {name: string, age: number, hobbies: string[]} = {name: 'Jonathan', age: 30, hobbies: ['running','swimming','coding']};</code> ✔️</p><p id="ad17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当创建对象时，属性名是不可变的，但是它们出现的顺序并不重要，即使我们以特定的顺序定义它们。</p><p id="2a79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以有类似上面的简单对象，或者我们可以定义利用多种数据类型的复杂对象，如下所示(该对象仅用于演示):</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/7a062ae547367e65436ee02be38dbf94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kqF8d_HDLb5hSRH-.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在这里，我们在这个复杂对象中尽可能明确地设置数据类型</figcaption></figure><h2 id="0f0b" class="mx lo it bd lp my mz dn lt na nb dp lx kr nc nd mb kv ne nf mf kz ng nh mj ni bi translated">类型别名/接口</h2><p id="7937" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">以上面的复杂对象为例，你可能会想这太棒了，但是下一次我需要创建一个复杂对象时会发生什么呢？我需要再次手动输入所有这些吗？</p><p id="6a96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要担心，类型别名和接口类型会有所帮助！类型别名是一种数据类型，它允许我们在其中保存其他数据类型，然后引用一个变量，而不是一遍又一遍地重写代码。</p><p id="91f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便提一下，类型别名和接口的工作方式非常相似。两者都允许我们为我们的数据构建一个对象/蓝图。然而，还有<strong class="ki iu"> <em class="mq">的细微差别</em> </strong>我们就不在这里赘述了。相反，这里有一个<a class="ae kf" href="https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c" rel="noopener">帖子，以极其有效的方式解释了这些差异</a>，如果你想深入了解的话。</p><p id="d74d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该注意这两者之间的一些细节——当使用类型别名时，我们使用等号(=)来声明值，接口不需要等号。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/27a1dae7c88ba2074ef69b8a1ee7636f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r7e2RZ32mU589LEC.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">接口类型的工作方式与类型别名非常相似，但是不需要等号(=)</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/c764295005e53450c1c0e239dfbc27fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UusRXo2dzZtNNeDY.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">别名数据类型需要等号(=)</figcaption></figure><p id="e7e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经声明了我们的别名，是时候使用这个别名了。当我们想要从这个别名“构建”我们的新变量时，我们简单地将它设置为数据类型:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/26329c18df7d7933ca99e10673ca34a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/0*eAKgE9AjpPmOE9a4.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用接口/类型数据类型搭建对象非常有用:)</figcaption></figure><p id="a327" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的是，<em class="mq">接口</em>是特定于TypeScript的。它只在编译时被用来做类型检查和捕捉任何可能被我们忽略的错误。<strong class="ki iu">来自我们接口的数据将最终出现在我们的最终代码中，但是接口本身是编译出来的</strong>。</p><p id="bba9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">类</strong></p><p id="fef6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某种程度上，类是TypeScript真正的“面包和黄油”(至少在我看来是这样)。按照搭建新对象的想法，类允许我们以一种比每次需要时手工输入更简单的方式构建数据。</p><p id="b90d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类可以被认为是我们的数据应该如何定义的蓝图，以及它应该能够通过方法做什么动作(如果有的话)。</p><p id="0445" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是TypeScript中的一个类的例子(这是通过在ES6中引入类实现的):</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/47515d3c61910639498b129bdb1de37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/0*OjS2nOeqUe8WC30I.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">TypeScript类，已准备好进行实例化:)</figcaption></figure><p id="70f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，你可能会问自己一个<em class="mq">类</em>、一个<em class="mq">类型别名</em>和一个<em class="mq">接口</em>之间有什么区别？很棒的问题！两者的主要区别在于类可以被实例化(我们可以创建它们的新实例),而接口不能。</p><p id="5c83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，还有其他不同之处，但不在本文的讨论范围之内。如果你想更深入地挖掘，这里有一篇我读过的<a class="ae kf" href="https://ultimatecourses.com/blog/classes-vs-interfaces-in-typescript#Using_TypeScript_class_vs_using_Typescript_interface" rel="noopener ugc nofollow" target="_blank">很棒的文章</a>，可以帮助我理解这些差异。当使用TypeScript时，你会发现它们的用例，就像我一样。</p><p id="c3ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">工会</strong></p><p id="ddde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这无疑是我最喜欢的类型脚本数据类型！联合类型允许我们声明一个变量，然后将其设置为“非此即彼”的值。我的意思是，假设我们期望数据被传递到一个函数中，但是我们不确定它是一个字符串还是一个数字——这是union类型的完美(和预期)目的。</p><p id="478f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在定义类型时使用单管道字符(在Windows上是Shift+Enter正上方的键)。下面是使用union数据类型定义变量时的样子:</p><p id="9d24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl nm b">const numOfDoors: string | string[ ];</code></p><p id="d812" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这告诉TypeScript<em class="mq">numOfDoors</em>是一个可以保存字符串或字符串数组的变量。</p><p id="cbc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我前面提到使用联合类型的函数的一个示例:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/94d555e31d3d4af734235156b64dc547.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/0*nVlAwaM_GuuyYdpQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">TypeScript有一个称为union的唯一数据类型，它允许对非此即彼的情况进行类型检查</figcaption></figure><p id="4d33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">任何</strong></p><p id="eb1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Any是我们在不确定将要获得的数据类型时设置的类型。也许我们从第三方获得了一些东西或一些动态数据，但我们不能100%确定我们是否获得了一个字符串、一个数字或一组信息。这是任何类型的完美用例。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/1065a1645265b3b92dab19e8f5a86d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/0*9psRY94ffrqscm9g.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">数据类型any是一种退出类型检查的方法</figcaption></figure><p id="47e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我会警告不要使用type <em class="mq"> any </em>，除非你绝对必须这样做，因为当使用时，我们会选择放弃TypeScript的核心特性之一——类型检查。</p><p id="744e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这种数据类型有它的用例，就像所有提到的数据类型一样。</p><h1 id="5984" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">这是一个总结！</h1><p id="deea" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我告诉过你这不会花太长时间的，:D</p><p id="b07b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望您喜欢这篇关于TypeScript的文章，并对它如何证明对您的代码库有用感到兴奋。在下一篇文章中，我们将深入探讨TypeScript的实用方面。我们将检查它的安装、编译，并在您的项目中使用它(不仅仅是Angular项目)！</p><p id="6484" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章最初发表在我的博客上。</p><p id="9ce5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你在那里的时候，不要忘记注册我的<strong class="ki iu">时事通讯</strong>——你可以在点击上面的链接后在页面的右上角注册。我保证我永远不会给你的收件箱发垃圾邮件，你的信息也不会与任何人/网站共享。我喜欢偶尔发送我发现的有趣资源、关于web开发的文章以及我的最新帖子列表。</p><p id="2364" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你还没有，你也可以在社交媒体上和我联系！我所有的链接都在那个页面的右上方。我喜欢与他人交流，认识新朋友，所以不要害怕打招呼:)</p><p id="4459" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有个牛逼的日友，开心编码！</p></div></div>    
</body>
</html>