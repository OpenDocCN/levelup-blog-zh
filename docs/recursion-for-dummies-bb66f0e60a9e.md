# 假人递归

> 原文：<https://levelup.gitconnected.com/recursion-for-dummies-bb66f0e60a9e>

## 递归是计算中的一个基本构造。你不应该因为看到它而惊慌失措。

![](img/ce65c90e0bfb74ec142256fe30360649.png)

有些问题很难。为这些人建立一个心智模型是很有挑战性的。然而，我们有一个强有力的工具。递归！这是一个稳健的想法。

假设你正在解决一个问题。你心里有想法。这是一种迭代但模糊的东西——不那么清晰。尽管如此，你觉得这可能是解决办法。但是，你不能实施。这个解很有可能是递归的。

这篇文章是为那些到处学习循环和函数的初学者准备的。如果你已经了解了递归的概念，但你不觉得它太直观，那就更好了。

我将在这里使用 python，因为几乎每个人都这么做。我要你做的是运行你看到的每一段代码。我更喜欢你全部打出来，而不是复制粘贴。

读完这篇文章后，你会有所收获

1.  对什么是递归的理解
2.  通过解决四个递归问题来练习
3.  优雅与性能
4.  为什么需要写递归函数

## 递归到底是什么意思？

非正式地说，递归函数有一个`base case`和一个`recursive call`，这意味着调用函数本身。就是这样。不多不少。

## 问题 1

编写一个函数`power`，它接受一个数字`num`和一个正整数`pow`——它返回将`num`提升到`pow`的幂的值。

为了说明，

1.  `power(2, 3)`会返回`8`
2.  `power(5, 5)`会返回`3125`

为了发现`base case`，让我们首先理解将`num`提升到`pow`的幂在形式上意味着什么。

是的，

`num * num * num * num (pow times)`。例如，`5 ^ 3 = 5 * 5 * 5 = 125`

但是有一个问题。任何数字的幂`0`都等于`1`。完美！这可能是一个非常可靠的消息。在代码中，我们会说当用值为`0`的`pow`调用函数时，我们将返回`1`。

它只说当 p 为 0 时返回 1

现在，我们必须用相同的函数来定义函数。

`5 ^ 3 = 5 * 5 ^ 2`或`pow(5, 3) = 5 * pow(5, 2)`。

`n ^ p = n * n ^ (p-1)`总的来说。

由于我们已经根据函数本身定义了函数，现在我们可以对它进行编码了。

现在，你自己写吧。运行它。在进入下一个问题之前，试着理解它。或者，你可以试试这个漂亮的[可视化工具](http://pythontutor.com/visualize.html)。

## 问题 2

定义一个接受正整数`num`并返回其阶乘的函数。

如果你在[之前从未听说过阶乘，看看这篇关于阶乘](https://www.mathsisfun.com/numbers/factorial.html)的很棒的初级读本。

正整数的阶乘`N`定义如下，

`N! = N * (N-1) * (N-2) * … * 2 * 1`

因此，为了进行递归调用，我们需要根据函数本身来定义函数。在阶乘的情况下，就像`N! = N * (N-1)!`一样简单。同样，如果你没有得到这个，请检查上面链接的阶乘指南。

你能想到基本情况吗？它直接来自定义，因为`zero`的阶乘被定义为`one`。(`0! = 1`)

如果您尝试使用第一个问题的信息和示例自己编写代码，将会令人印象深刻。

步骤 1:编写基本案例

步骤 2:进行递归调用

[Pythontutor 可视化](http://pythontutor.com/visualize.html#code=%23%20factorial%285%29%20%3D%20120%0A%0Adef%20factorial%28num%29%3A%0A%20%20%0A%20%20%23%20the%20base%20case%0A%20%20if%20num%20%3D%3D%200%3A%0A%20%20%20%20return%201%0A%20%20%0A%20%20%23%20the%20recursive%20call%0A%20%20return%20num%20*%20factorial%28num%20-%201%29%0A%20%0Afactorial%285%29&cumulative=false&curInstr=26&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)

如果你已经走了这么远，恭喜你！现在，你对编写递归函数更有信心了。让我们试着多写一些递归函数来固化你的理解。

## 更加结构化的思维框架

正如我之前说过的，递归实际上是一种数学构造。因此，它有一些正式的定义和证明。为了让你可爱的小脑袋免于困惑，每当你解决递归问题时，你可以遵循以下步骤。

**第一步:基础案例**

基本情况是递归函数最关键的部分。它必须坚如磐石。如果其中有任何漏洞——也就是说如果你的递归调用没有命中基本用例——你就冒着代码抛出一个被广泛称为 **StackOverflow** 异常的风险。在幕后，您的程序进行无限的递归调用，因此为每个调用创建一个堆栈。堆栈内存有限。因此，基本情况是递归函数的关键。

**第二步:递归调用**

递归调用很难正确。在你的头脑中运行递归调用将是痛苦的。

然而，您可以简单地这样做，

1.  假设该函数适用于所有其他输入。这意味着你必须假设你的递归调用是有效的。
2.  现在，让函数为当前输入工作

这实际上是递归证明的工作方式。称之为**归纳法证明。**不过递归解题不一定要学。

## 问题 3

定义一个接受正整数`num`的函数，并返回一个包含该范围`[N,1]`中元素的列表。

举个例子，

1.  `makeList(5)`将返回`[5, 4, 3, 2, 1]`
2.  `makeList(1)`将返回`[1]`

你能看到这里的基本情况吗？这是第二个例子。每当使用参数`1`调用我们的函数时，它将简单地返回一个包含该参数的列表，即`[1]`。

基本情况是可靠的。无论该函数抛出什么有效输入，如果递归调用被准确构造，它将不可避免地求助于基本情况，从而避免 **StackOverflow** 异常。

对于递归调用，我们将采用稍微不同的方法。首先，我们将把递归调用的结果存储在一个变量中。

按照我上面提到的递归心理框架，在这一点上，我们完成了`base-case`和`recursive-call`。我们假设递归调用完成了它的工作，因为我们已经假设该函数对所有其他输入都有效。

现在，我们必须只让它为当前输入工作。

我们完了。

## 问题 4

这将是我们今天看到的最后一个问题。和上一个差不多。所以，你，如果还没有的话，可以试着把你的手弄脏。

定义一个函数，该函数将整数列表`lst`和长度`l`作为参数，并将返回列表中所有元素的总和。

为了说明，

1.  `sumList([1, 2, 3, 4, 5], 5)`将返回`15`
2.  `sumList([9], 1)`将返回`9`

基本情况很简单，因为我已经在示例中向您展示了这一点。每当列表的长度为 1 时，函数将简单地返回列表的第一个元素，实际上是唯一的元素。

让我们考虑一下递归调用。这样想，长度为`N`的整数列表中所有元素的总和等于列表中的第一个元素加上列表中其余元素的总和。这是构造递归调用的关键。根据相同的函数定义函数。

## 优雅与性能

一旦你熟悉了递归函数的编写，你就会真正体会到与迭代实现相比，递归实现是多么优雅。如果你遵循所说的心理框架，递归代码将非常容易阅读。

然而，递归函数的性能不如迭代函数。因为它涉及到为每个递归调用创建一个堆栈框架。虽然，有一种编写尾递归函数的惯用方法。尾递归在命令式范式中并不常见，但在函数式语言中有一流的支持。尾递归函数只用一个堆栈就能完成任务，因此与迭代函数的性能相当。

## 需要写递归函数吗？

你可能想到的一个明显的问题是，你是否需要写递归函数。因为到目前为止，我展示的所有代码都可以通过一个简单的 for 循环轻松实现。实际上，所有这些例子都是用`sequential`数学函数或`linear data structures`运算的。的确，在这些特定的用例中，迭代实现是不错的。

但是，让我提醒你，这些是递归函数的基本实例，让你了解这个概念。只有在操作`tree-like`数据结构时，你才会意识到递归的真正威力。树状数据结构基本上被设计成递归的。

当我偶然发现经典的河内塔问题时，我第一次欣赏了递归。我强烈建议你看看下面的视频。这是一个看似简单，实则极其困难的问题的迷人表现。在了解解决方案之后，确保考虑迭代实现。我都不敢想象会有多难看。

## 摘要

这是整首曲子的总结，

1.  递归是强大的
2.  任何迭代构造都可以递归实现
3.  递归函数需要坚实的基础。否则，您可能会遇到 StackOverflow 异常。
4.  对于递归调用，你必须根据同一个函数来定义函数。
5.  编写递归调用时，假设该函数适用于所有其他输入。然后让它为当前输入工作。
6.  可以说，递归比迭代更优雅。
7.  与迭代相比，递归的性能较差，因为它涉及到为每个操作创建一个新的堆栈。
8.  通过编写一个名为`tail-recursion`的惯用结构，可以避免性能问题。它在函数范式中得到了广泛的支持。
9.  对于`sequential math functions`和`linear data structures`来说，迭代实现通常是可读和简单的。
10.  对于`tree-like`数据结构，递归更适合，因为这些数据结构基本上是递归的。
11.  为了欣赏递归，第一次，你可以检查河内 问题的 [**塔。**](https://www.youtube.com/watch?v=rf6uf3jNjbo&t=1s)

我很高兴你已经做到了。希望现在你对`recursive-constructs`更加熟悉了，你可能已经回避很久了。享受递归之旅。

我真的希望你能就你的想法说几句话。✏️

你可以给我买杯咖啡来支持我的工作。☕

 [## 尼兰詹🌱🌱正在写编程相关的文章

### 嘿👋我写编程相关的文章。我还是个学生。你可以请我喝杯咖啡，让我开心一天。

www.buymeacoffee.com](https://www.buymeacoffee.com/nilTheDev)