<html>
<head>
<title>Build a simple REST API using Go, MySQL, Gorm, and mux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go、MySQL、Gorm和mux构建一个简单的REST API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-rest-api-using-go-mysql-gorm-and-mux-a02e9a2865ee?source=collection_archive---------0-----------------------#2019-07-13">https://levelup.gitconnected.com/build-a-rest-api-using-go-mysql-gorm-and-mux-a02e9a2865ee?source=collection_archive---------0-----------------------#2019-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e4911a6424d82298e9e20dcba7746610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYCXrSu36OldVLXzHy-1FA.png"/></div></div></figure><p id="f876" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go是谷歌设计的。Golang受C语言的影响，但更简单，可移植性更强。本文将带您使用Go构建一个简单的REST API。</p><p id="89bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">关于应用</strong> <br/>该应用是一个简单的REST API服务器，将为足球场预订记录上的CRUD操作提供端点。</p><p id="79a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完成这项工作，我们必须先安装一些依赖项。</p><p id="4a0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.Gorilla <code class="fe kw kx ky kz b">mux</code>:用于创建路由和HTTP处理程序。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="8eb1" class="li lj iq kz b gy lk ll l lm ln">go get github.com/gorilla/mux</span></pre><p id="d27e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<code class="fe kw kx ky kz b">gorm</code>:MySQL的ORM工具。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="45f5" class="li lj iq kz b gy lk ll l lm ln">go get github.com/jinzhu/gorm</span></pre><p id="7234" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.<code class="fe kw kx ky kz b">mysql</code>:MySQL驱动。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="aabb" class="li lj iq kz b gy lk ll l lm ln">go get github.com/go-sql-driver/mysql</span></pre><p id="3290" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始之前，首先我们必须手动创建一个数据库。我正在使用MySQL shell创建一个数据库。登录MySQL shell，使用以下语句创建数据库</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="f82b" class="li lj iq kz b gy lk ll l lm ln">CREATE DATABASE Football;</span></pre><p id="fe15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在您的项目目录中创建一个文件<code class="fe kw kx ky kz b">main.go</code>并开始烹饪。我们希望将应用程序连接到数据库:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="c1d8" class="li lj iq kz b gy lk ll l lm ln"><strong class="kz ir">db, err = gorm.Open(“mysql”, “user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8&amp;parseTime=True”)</strong></span></pre><blockquote class="lo lp lq"><p id="254f" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:为了处理<code class="fe kw kx ky kz b">time.Time</code>，需要包含<code class="fe kw kx ky kz b">parseTime</code>作为参数。(<a class="ae lv" href="https://github.com/go-sql-driver/mysql#parameters" rel="noopener ugc nofollow" target="_blank">更多支持参数</a>)</p></blockquote><p id="899e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们来看看我们的<code class="fe kw kx ky kz b">main.go</code>文件:</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="2c3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们测试这个文件</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4910" class="li lj iq kz b gy lk ll l lm ln">abhi@abhi-Inspiron-N4050:~/$ <strong class="kz ir">go build</strong><br/>abhi@abhi-Inspiron-N4050:~/$ <strong class="kz ir">go run main.go </strong><br/><strong class="kz ir">2019/07/13 00:49:33 Connection Established</strong></span></pre><p id="c6d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，创建一个简单的<code class="fe kw kx ky kz b">Booking</code>结构，它包含<code class="fe kw kx ky kz b">id</code>、<code class="fe kw kx ky kz b">user</code>、<code class="fe kw kx ky kz b">total_members</code></p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="d4ed" class="li lj iq kz b gy lk ll l lm ln">type Booking struct{<br/> Id      int    `json:”id”`<br/> User    string `json:”user”`<br/> Members int  `json:”members”`<br/>}</span></pre><p id="a38a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建结构之后，是时候迁移我们的模式了</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="7a1b" class="li lj iq kz b gy lk ll l lm ln">db.AutoMigrate(&amp;Booking{})</span></pre><p id="a710" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">警告</strong> : <em class="lr">自动迁移</em>只会创建表、缺失列和缺失索引，不会更改现有列的类型或删除未使用的列以保护您的数据。</p><h1 id="cad5" class="ly lj iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">创建Web服务器</h1><p id="8c23" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">现在我们创建一个web服务器来处理HTTP请求。为此，我创建了一个名为<code class="fe kw kx ky kz b">handleRequests()</code>的新函数。在此功能下，创建一个<code class="fe kw kx ky kz b">mux</code>路由器的新实例:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="546f" class="li lj iq kz b gy lk ll l lm ln">myRouter := mux.NewRouter().StrictSlash(true)</span></pre><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="fa5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在通过键入<code class="fe kw kx ky kz b">go run main.go</code>运行代码</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="5876" class="li lj iq kz b gy lk ll l lm ln">abhi@abhi-Inspiron-N4050:~/$ <strong class="kz ir">go run main.go </strong><br/><strong class="kz ir">2019/07/13 00:59:54 Connection Established<br/>2019/07/13 00:59:54 Starting development server at </strong><a class="ae lv" href="http://127.0.0.1:10000/" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir">http://127.0.0.1:10000/</strong></a></span><span id="6cdb" class="li lj iq kz b gy na ll l lm ln"><strong class="kz ir">2019/07/13 00:59:54 Quit the server with CONTROL-C.</strong></span></pre><p id="a8df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在浏览器中打开<code class="fe kw kx ky kz b"><a class="ae lv" href="http://localhost:10000/" rel="noopener ugc nofollow" target="_blank">http://localhost:10000/</a></code>，您应该会看到一个<code class="fe kw kx ky kz b">Welcome to Homepage!</code></p><h1 id="8a54" class="ly lj iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">CRUD操作</h1><p id="92a7" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">在这一部分，我们将进行<strong class="ka ir">创建</strong>、<strong class="ka ir">读取</strong>、<strong class="ka ir">更新</strong>和<strong class="ka ir">删除</strong>的操作</p><ul class=""><li id="3bdd" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated"><strong class="ka ir">创建</strong>新的预订</li></ul><p id="a307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将路线添加到在<code class="fe kw kx ky kz b">handleRequests</code>功能中定义的路线列表中。然而，我们将在路由的末尾添加<code class="fe kw kx ky kz b">.Methods("POST")</code>,以指定我们只希望在传入请求是<code class="fe kw kx ky kz b">HTTP POST</code>请求时调用这个函数。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="a843" class="li lj iq kz b gy lk ll l lm ln">myRouter.HandleFunc(“/new-booking”, createNewBooking).Methods(“POST”)</span></pre><p id="0d20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个新函数<code class="fe kw kx ky kz b">createNewBooking()</code>，它将获取POST请求数据，并在数据库中创建一个新的预订条目。但是首先我们必须将请求体中的JSON数据解组到一个新的<code class="fe kw kx ky kz b">Booking</code>结构中，该结构随后可以附加到表中，为了创建一个新的记录，我们使用下面的函数:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="415f" class="li lj iq kz b gy lk ll l lm ln">func createNewBooking(w http.ResponseWriter, r *http.Request) {<br/>    // get the body of our POST request<br/>    // return the string response containing the request body<br/>    reqBody, _ := ioutil.ReadAll(r.Body)</span><span id="686c" class="li lj iq kz b gy na ll l lm ln">    var booking Booking<br/>    json.Unmarshal(reqBody, &amp;booking)<br/>    db.Create(&amp;booking) </span><span id="ed0c" class="li lj iq kz b gy na ll l lm ln">    fmt.Println("Endpoint Hit: Creating New Booking")<br/>    json.NewEncoder(w).Encode(booking)<br/>}</span></pre><ul class=""><li id="8b3e" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated"><strong class="ka ir">阅读</strong>所有预订</li></ul><p id="938e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次将路线添加到在<code class="fe kw kx ky kz b">handleRequests</code>功能中定义的路线列表中</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="d32a" class="li lj iq kz b gy lk ll l lm ln">myRouter.HandleFunc(“/all-bookings”, returnAllBookings)</span></pre><p id="7332" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个新函数<code class="fe kw kx ky kz b">returnAllBookings()</code>来获取我们使用的所有记录<code class="fe kw kx ky kz b">db.Find(&amp;bookings)</code></p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="1f3c" class="li lj iq kz b gy lk ll l lm ln">func returnAllBookings(w http.ResponseWriter, r *http.Request){<br/> bookings := []Booking{}<br/> db.Find(&amp;bookings)<br/> fmt.Println(“Endpoint Hit: returnAllBookings”)<br/> json.NewEncoder(w).Encode(bookings)<br/>}</span></pre><ul class=""><li id="0a79" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated"><strong class="ka ir">通过Id读取预订详情</strong></li></ul><p id="5211" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完成这项工作，我们对所有预订运行一个循环，如果<code class="fe kw kx ky kz b">booking.id</code>等于我们在UTL中传递的键，它返回编码为JSON的预订细节。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="48b7" class="li lj iq kz b gy lk ll l lm ln">//handleRequests()<br/>myRouter.HandleFunc("/booking/{id}", returnSingleBooking)</span><span id="ce34" class="li lj iq kz b gy na ll l lm ln"><br/>func returnSingleBooking(w http.ResponseWriter, r *http.Request){<br/> vars := mux.Vars(r)<br/> key := vars[“id”]<br/> bookings := []Booking{}<br/> db.Find(&amp;bookings)</span><span id="ec39" class="li lj iq kz b gy na ll l lm ln"> for _, booking := range bookings {<br/>     // string to int<br/>     s , err:= strconv.Atoi(key)<br/>     if err == nil{<br/>        if booking.Id == s {<br/>           fmt.Println(booking)<br/>           fmt.Println(“Endpoint Hit: Booking No:”,key)<br/>           json.NewEncoder(w).Encode(booking)<br/>        }<br/>     }<br/>  }<br/>}</span></pre><p id="14f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在轮到您构建更新和删除操作了。如果你需要任何帮助，请在评论区提问。您也可以从以下链接获得帮助:</p><ul class=""><li id="d6db" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated"><a class="ae lv" href="http://jinzhu.me/gorm/crud.html" rel="noopener ugc nofollow" target="_blank">http://jinzhu.me/gorm/crud.html</a></li><li id="482d" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><a class="ae lv" href="https://gorm.io/docs/" rel="noopener ugc nofollow" target="_blank">https://gorm.io/docs/</a></li></ul><p id="8d16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们完成了在Golang的第一个项目。希望你喜欢:)</p></div></div>    
</body>
</html>