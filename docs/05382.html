<html>
<head>
<title>How to Find The Merge Point of Two Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何找到两个链表的合并点</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-find-the-merge-point-of-two-linked-lists-ba55a129caa2?source=collection_archive---------10-----------------------#2020-08-24">https://levelup.gitconnected.com/how-to-find-the-merge-point-of-two-linked-lists-ba55a129caa2?source=collection_archive---------10-----------------------#2020-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c062007cd036f7e79501a282ccfdb5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyq6q2WiQdfV409Xdhz93g.jpeg"/></div></div></figure><h2 id="9545" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">理解问题</h2><p id="2171" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我们得到了两个单链表，我们必须找到它们合并的点。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="bb22" class="jy jz iq lu b gy ly lz l ma mb">[SLL 1] <strong class="lu ir">1</strong>---&gt;<strong class="lu ir">3</strong>---&gt;<strong class="lu ir">5</strong><br/>                     \<br/>                      <strong class="lu ir">9</strong>---&gt;<strong class="lu ir">12</strong>---&gt;<strong class="lu ir">17</strong>---&gt;<strong class="lu ir">None</strong><br/>                     /<br/>     [SLL 2] <strong class="lu ir">7</strong>---&gt;<strong class="lu ir">8</strong></span></pre><p id="dbdb" class="pw-post-body-paragraph ku kv iq kw b kx mc kz la lb md ld le kh me lg lh kl mf lj lk kp mg lm ln lo ij bi translated">上图说明合并发生在节点9。</p><p id="4cc7" class="pw-post-body-paragraph ku kv iq kw b kx mc kz la lb md ld le kh me lg lh kl mf lj lk kp mg lm ln lo ij bi translated">我们可以放心，给定的参数head1和head2(两个列表的头)永远不会相等，也永远不会为零。这两个列表肯定会在某个时候合并。</p><p id="5e76" class="pw-post-body-paragraph ku kv iq kw b kx mc kz la lb md ld le kh me lg lh kl mf lj lk kp mg lm ln lo ij bi translated">我们需要一个计划来找到并返回两个列表合并的节点的整数数据值。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="a21b" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">计划</h2><p id="e7c5" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">为了遍历列表找到它们合并的点，我们需要设置两个不同的指针。一个用于第一个单链表，另一个用于第二个。请记住，我们将两者的头作为参数给出，因此我们将设置指向它们的指针，以便从每一个的开头开始。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/2df027fdff786b7c8cb6f2772ae316c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r5eWbBHexx_UTESS8Yp_GQ.png"/></div></div></figure><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="7108" class="jy jz iq lu b gy ly lz l ma mb">pointer1 = head1<br/>pointer2 = head2</span></pre><p id="8343" class="pw-post-body-paragraph ku kv iq kw b kx mc kz la lb md ld le kh me lg lh kl mf lj lk kp mg lm ln lo ij bi translated">要开始遍历列表，我们需要创建一个while循环，以便在列表不是None时遍历列表。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="cd8a" class="jy jz iq lu b gy ly lz l ma mb">while not None:</span></pre><p id="a118" class="pw-post-body-paragraph ku kv iq kw b kx mc kz la lb md ld le kh me lg lh kl mf lj lk kp mg lm ln lo ij bi translated">如果在任何一点上，指针1和指针2相等，我们必须跳出while循环，因为我们已经找到了两个列表合并的节点。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="0b0d" class="jy jz iq lu b gy ly lz l ma mb">if pointer1 == pointer2:<br/>    break</span></pre><p id="a76f" class="pw-post-body-paragraph ku kv iq kw b kx mc kz la lb md ld le kh me lg lh kl mf lj lk kp mg lm ln lo ij bi translated">但是，如果不相等，我们将通过利用. next向前移动。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/9d55f9116387641c945b1dbbaf73150f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kL4z33PK5MjogouGx1Alw.png"/></div></div></figure><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="1f9a" class="jy jz iq lu b gy ly lz l ma mb">pointer1 = pointer1.next<br/>pointer2 = pointer2.next</span></pre><p id="445a" class="pw-post-body-paragraph ku kv iq kw b kx mc kz la lb md ld le kh me lg lh kl mf lj lk kp mg lm ln lo ij bi translated">正如我们从示例图中看到的，我们的第一个单链表，SLL 1，比SLL 2短。所以让我们假设在SLL 2找到合并节点之前，SLL 1没有命中。在这种情况下，我们将简单地重新开始，为SLL 2设置相同的if语句，以防我们的程序中有一个测试用例，其中第二个SLL较短。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="3ad2" class="jy jz iq lu b gy ly lz l ma mb">if pointer1 == None:<br/>    pointer1 == head1<br/>if pointer2 == None:<br/>    pointer2 == head1</span></pre><p id="c5c0" class="pw-post-body-paragraph ku kv iq kw b kx mc kz la lb md ld le kh me lg lh kl mf lj lk kp mg lm ln lo ij bi translated">这种重新开始的逻辑将在while循环中重复，直到两个指针同时找到合并节点，或者换句话说，直到指针1和指针2相等。当发生这种情况时，我们必须记住做要求我们做的事情，并返回该节点的整数数据值。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="eac4" class="jy jz iq lu b gy ly lz l ma mb">return pointer1.data</span></pre><p id="2dbc" class="pw-post-body-paragraph ku kv iq kw b kx mc kz la lb md ld le kh me lg lh kl mf lj lk kp mg lm ln lo ij bi translated">因为这也将是指针2的数据，所以我们可以返回它来代替指针1。它具有相同的值。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="e833" class="jy jz iq lu b gy ly lz l ma mb">return pointer2.data </span></pre></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="d879" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">执行</h2><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="b2c7" class="jy jz iq lu b gy ly lz l ma mb"># For our reference:<br/>#<br/># SinglyLinkedListNode:<br/>#     int data<br/>#     SinglyLinkedListNode next<br/>#<br/>#</span><span id="87b0" class="jy jz iq lu b gy mq lz l ma mb">def findMergeNode(head1, head2):</span><span id="b207" class="jy jz iq lu b gy mq lz l ma mb">    # Set the pointers<br/>    pointer1 = head1<br/>    pointer2 = head2</span><span id="5d83" class="jy jz iq lu b gy mq lz l ma mb">    while not None:</span><span id="0601" class="jy jz iq lu b gy mq lz l ma mb">        # if we found the merging node, then break out of the loop<br/>        if pointer1 == pointer2:<br/>            break</span><span id="ed51" class="jy jz iq lu b gy mq lz l ma mb">        #traverse through lists<br/>        pointer1 = pointer1.next<br/>        pointer2= pointer2.next</span><span id="b665" class="jy jz iq lu b gy mq lz l ma mb">        # Begin again if one was shorter than the other<br/>        if pointer1 == None:<br/>            pointer1 = head1<br/>        if pointer2 == None:<br/>            pointer2 = head2</span><span id="72d2" class="jy jz iq lu b gy mq lz l ma mb">    return pointer1.data</span></pre></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="4735" class="mr jz iq bd ka ms mt mu kd mv mw mx kg my mz na kk nb nc nd ko ne nf ng ks nh bi translated">分级编码</h1><p id="1dff" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">感谢您成为我们社区的一员！<a class="ae ni" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae ni" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> Skilled.dev编码面试课程</strong> </a>。</p><div class="nj nk gp gr nl nm"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">编写面试问题</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">掌握编码面试的过程</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">技术开发</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jw nm"/></div></div></a></div></div></div>    
</body>
</html>