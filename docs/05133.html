<html>
<head>
<title>Speed up your Django Admin with the NoCountPaginator — Optimizing Django: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NoCountPaginator加速Django管理——优化Django:第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/speed-up-your-django-admin-by-removing-sql-counts-optimizing-django-part-2-f5e09da667c?source=collection_archive---------4-----------------------#2020-08-06">https://levelup.gitconnected.com/speed-up-your-django-admin-by-removing-sql-counts-optimizing-django-part-2-f5e09da667c?source=collection_archive---------4-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7d0d768e613a0f7367d2d2c8d32459af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ii89QKBeSfY5B8hofOU0rA.png"/></div></div></figure><p id="c2a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Django管理门户在某些地方可能又笨又慢，但是在这篇短文中，我将试着帮助您以较小的代价使它更有效。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="c0ce" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">那么，它有什么问题呢？</h2><p id="c66b" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">好吧，Django admin是一个很好的工具，只需很少的额外开发工作就可以得到一个可靠的Django后台用户界面。为Django模型添加一个管理界面实际上只需要几行代码，对于试图平衡使特性工作与使非技术人员(比如他们的客户)可以访问特性的开发人员来说，这是一个很大的帮助。</p><p id="989c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，让Django admin易于访问需要付出一些代价，其中之一就是速度。拿页面计数器来说。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/4f531a5543754e198c15868985663fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*1oOWVttMwI93JyAAe1lfUA.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">数据库中的1个用户(红框)</figcaption></figure><p id="c9bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有一个用户时，SQL查询如下所示:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c1fe7256d80902829b99e7e17d1bf4bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*60Wu2rY2sY2C2zEbngNmkQ.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">实际上，很好。</figcaption></figure><p id="b85f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意请求中的选择计数值。对于1个用户来说，这不成问题。事实上，即使是10k用户也没问题:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/b1c933d4182a5243eb98342de19fbaf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*ZTHYpdm9_euIk7qFV5CEow.png"/></div></figure><p id="d235" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，对50万用户进行同样的尝试会导致SQL时间开始增加。</p><div class="mc md me mf gt ab cb"><figure class="mm jr mn mo mp mq mr paragraph-image"><img src="../Images/16ed412f9d294502b5234e162533b27f.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*4binEWOqThWTLL2c7CIEjg.png"/></figure><figure class="mm jr ms mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/9b04a6648b1ef81800a57866fe5119dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*RhTHFMyV61lZLWnQZbP_MA.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk mt di mu mv translated">我想与更多的用户进行演示，但我不想为了截图而破坏我的本地数据库</figcaption></figure></div><p id="57c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何与Django进行小规模以外的交易的人可能都熟悉这个问题，尤其是在通过模型进行交易时。例如，社交媒体后端可能使用直通表来记录订阅或评论(大公司倾向于使用Redis或其他一些缓存实现来更快地提供这些服务，但对于更永久的记录，像Postgresql这样的数据库是黄金标准)。你可以想象这些表爆炸的速度有多快，会让它们的管理员无法使用。</p><p id="63b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以选择不使用admin，但这将是一种浪费。因此，让我们看看是否可以通过删除计数查询来修复它。</p><h2 id="df1c" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">那么是什么导致了计数查询呢？</h2><p id="5af0" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">一句话:SQL count查询用于提供您在admin中看到的对象计数。是的，就是页面选择UI元素旁边的那个数字。Django ModelAdmin使用一个Paginator类来管理页面选择UI和对象计数，并至少调用一次SQL:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8b58ca8353ad90e0823ae0c46fb6b8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*o9VzHw5kRnwcTY_PbDii8w.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">我们的罪犯在这里。</figcaption></figure><p id="0623" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最重要的是，当管理员收集信息来呈现屏幕时，它会执行另一个queryset计数。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/b16faec534b7d831db8f69a3f0ac06c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*IH9y1OLs86-3RDyNq5bCdg.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">请注意self.root_queryset.count()。</figcaption></figure><p id="37b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为可以肯定地说，当你加载你的管理时，如果你有这么多的条目，你可能会使用某种过滤器或搜索栏来找到你想要的条目。您可能并不关心这个表中到底有多少条目，也不打算使用page tab来处理前几页之外的内容。</p><p id="4938" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">幸运的是，有一种简单的方法可以摆脱SQL查询，节省宝贵的查询时间。</strong></p><h1 id="564a" class="my le iq bd lf mz na nb li nc nd ne ll nf ng nh lo ni nj nk lr nl nm nn lu no bi translated">你只需要更新两个地方。</h1><p id="c97c" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">就像这样简单:</p><pre class="mc md me mf gt np nq nr ns aw nt bi"><span id="3a33" class="ld le iq nq b gy nu nv l nw nx">from django.core.paginator import Paginator<br/>class NoCountPaginator(Paginator):<br/>    @property<br/>    def count(self):<br/>        return 999999999 # Some arbitrarily large number,<br/>                         # so we can still get our page tab.</span></pre><p id="49aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像这样设置您的管理员:</p><pre class="mc md me mf gt np nq nr ns aw nt bi"><span id="1feb" class="ld le iq nq b gy nu nv l nw nx">from django.contrib import admin<br/>from . import models</span><span id="5609" class="ld le iq nq b gy ny nv l nw nx">class UserAdmin(admin.ModelAdmin):<br/>    model = models.User<br/>    paginator = NoCountPaginator<br/>    show_full_result_count = False</span><span id="b041" class="ld le iq nq b gy ny nv l nw nx">admin.site.register(models.User, UserAdmin)</span></pre><p id="1fb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在有50万用户，相同的页面负载如下所示:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d27039f47a7ce44cf8ccc55a28d4b67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*O-QjbS-n9zKslP8rg4ajjg.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">这还差不多！</figcaption></figure><h1 id="3e7b" class="my le iq bd lf mz na nb li nc nd ne ll nf ng nh lo ni nj nk lr nl nm nn lu no bi translated">结论</h1><p id="7103" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">Django管理员因效率低下而受到指责，原因有几个。然而，Django Admin作为一个开箱即用的解决方案很好地服务于它的目的，并且可以被扩展来关闭你不需要的东西。在本指南中，我们演示了如何阻止Django admin调用SQL count查询，代价是呈现正确的对象计数。</p><p id="352c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，您可以做更多的事情来改进Django管理。在本系列的下一篇指南中，我将向您展示一个场景，其中Django admin变得非常慢，甚至在对象数低于500k的情况下，以及您如何处理它。</p></div></div>    
</body>
</html>