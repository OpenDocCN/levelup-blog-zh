<html>
<head>
<title>Big Data: Lambda Architecture in a nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大数据:Lambda架构概述</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/big-data-lambda-architecture-in-a-nutshell-fd5e04b12acc?source=collection_archive---------2-----------------------#2020-10-08">https://levelup.gitconnected.com/big-data-lambda-architecture-in-a-nutshell-fd5e04b12acc?source=collection_archive---------2-----------------------#2020-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="423c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/thought-programmer" rel="noopener">思维程序员</a></h2><div class=""/><div class=""><h2 id="cec5" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">我们如何打败CAP定理？</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/16a425e2405db8e5b3c3b7c2fe8f7914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyXE41bENSEUP29slqpQyQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">CAP定理</figcaption></figure><p id="1f2d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">计算机科学中有一个定理叫做CAP定理，它指出分布式数据存储不可能同时提供以下三种保证中的两种以上。</p><ul class=""><li id="7d2e" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">一致性</em> </strong>:每次读取都会收到最近一次写入或一个错误。</li><li id="6b14" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">可用性</em> </strong>:每个请求都会收到一个(无错误的)响应，但不能保证它包含最近的写操作。</li><li id="0865" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">分区容差</em> </strong>:尽管网络在节点间丢弃(或延迟)了任意数量的消息，系统仍继续运行。</li></ul><h1 id="e8a6" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">历史简介</h1><p id="25d4" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">2011年，Nathan Marz在其博客中提出了一种解决CAP定理局限性的重要方法，称为Lambda架构。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/15aca95089849740601f844685556735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RX4WviL_wF7vVChcQUgyzg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">λ架构</figcaption></figure><h1 id="e830" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">它是如何工作的？</h1><p id="8e24" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">让我们仔细看看Lambda架构。Lambda架构中有三层:批处理层、速度层和服务层。</p><blockquote class="nm"><p id="5861" class="nn no iq bd np nq nr ns nt nu nv lz dk translated">它结合了相同数据的实时和批量处理。</p></blockquote><p id="d3ac" class="pw-post-body-paragraph le lf iq lg b lh nw ka lj lk nx kd lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated"><strong class="lg ja"> <em class="mj">首先是</em> </strong>，输入的实时数据流存储在批处理层的主数据集中，同时保存在速度层的内存缓存中。批处理层中的数据被<strong class="lg ja"> <em class="mj">然后</em> </strong>索引并通过批处理视图可用。而速度层中的实时数据通过实时视图显示。<strong class="lg ja"> <em class="mj">最后</em> </strong>，批处理和实时视图都可以单独或一起查询，以回答任何历史或实时问题。</p><h2 id="7a13" class="ob mq iq bd mr oc od dn mv oe of dp mz ln og oh nb lr oi oj nd lv ok ol nf iw bi translated">批量层</h2><p id="2bb9" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">这一层负责管理主数据集。主数据集中的数据必须包含如下三个属性。</p><ul class=""><li id="aebd" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated">数据是原始的</li><li id="383f" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated">数据是不可变的</li><li id="c136" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated">数据永远是真实的</li></ul><p id="12a6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">主数据集是真实的来源。即使丢失了所有的服务图层数据集和速度图层数据集，也可以从主数据集重新构建应用程序。</p><p id="5cd5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">批处理层还将主数据集预先计算到批处理视图中，以便可以低延迟地解析查询。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d650332eee850534f37b913c0e0c0af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fEm3ceh7KurPVJ027S2TA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">批处理视图的预计算</figcaption></figure><p id="0c24" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因为我们的主数据集在持续增长，所以当新数据可用时，我们必须有一个策略来管理我们的批处理视图。</p><ul class=""><li id="3342" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">重新计算算法</em> </strong>:丢弃旧的批处理视图，重新计算整个主数据集的函数。</li><li id="e2c4" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">增量算法</em> </strong>:新数据到来时直接更新视图。</li></ul><h2 id="ee55" class="ob mq iq bd mr oc od dn mv oe of dp mz ln og oh nb lr oi oj nd lv ok ol nf iw bi translated">速度层</h2><p id="37fd" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">速度层为快速特殊查询的批处理视图编制索引。它存储实时视图并处理输入的数据流，以便更新这些视图。底层存储层必须满足以下条件。</p><ul class=""><li id="a60d" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">随机读取</em> </strong>:支持快速随机读取，快速回答查询。</li><li id="e311" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">随机写入</em> </strong>:为了支持增量算法，还必须能够以低延迟修改实时视图。</li><li id="ea3e" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">可伸缩性</em> </strong>:实时视图应该随着它们存储的数据量和应用程序所需的读/写速率而伸缩。</li><li id="fa1a" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">故障容忍</em> </strong>:如果机器崩溃，实时视图应该继续正常工作。</li></ul><h2 id="9500" class="ob mq iq bd mr oc od dn mv oe of dp mz ln og oh nb lr oi oj nd lv ok ol nf iw bi translated">服务层</h2><p id="3001" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">该层提供对主数据集上执行的计算结果的低延迟访问。为了加快读取速度，可以通过对数据进行额外的索引来促进这一过程。与速度层类似，该层必须满足以下要求，如随机读取、批量写入、可伸缩性和容错。</p><h1 id="cb0d" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">Lambda架构满足几乎所有的属性</h1><p id="7aab" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">Lambda架构基于几个假设:容错、支持特定查询、可伸缩性、可扩展性。</p><ul class=""><li id="c26d" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">容错</em></strong>:Lambda架构为大数据系统提供了人工容错能力，因为当出现错误时，我们可以修复算法或从头开始重新计算视图。</li><li id="686b" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">临时查询:</em> </strong>批量层允许对任何数据进行临时查询。</li><li id="b09a" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">可伸缩性:</em> </strong>所有的批处理层、速度层、服务层都很容易伸缩。由于它们都是完全分布式的系统，我们可以在添加新机器时轻松扩展它们。</li><li id="c5dd" class="ma mb iq lg b lh mk lk ml ln mm lr mn lv mo lz mf mg mh mi bi translated"><strong class="lg ja"> <em class="mj">扩展性</em> </strong> <em class="mj"> : </em>添加一个新视图就像添加主数据集的一个新函数一样简单。</li></ul><h1 id="9cd4" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">有些问题要问？</h1><h2 id="d0dc" class="ob mq iq bd mr oc od dn mv oe of dp mz ln og oh nb lr oi oj nd lv ok ol nf iw bi translated">代码是如何在层之间同步的？</h2><p id="a00e" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">解决这个问题的方法之一是通过使用公共库或引入流之间共享的某种抽象，为各层提供一个公共的代码库。这种框架的例子有Summingbird或Lambdoop。</p><h2 id="3088" class="ob mq iq bd mr oc od dn mv oe of dp mz ln og oh nb lr oi oj nd lv ok ol nf iw bi translated">我们能去掉速度层吗？</h2><p id="d1f4" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">是的，速度层在许多应用中是不必要的。如果我们缩短批处理周期，就可以减少数据可用性的延迟。另一方面，用于访问存储在Hadoop上的数据的新的更快的工具，如Impala、Drill或新版本的Tez等。，使得在合理的时间内对数据采取一些行动成为可能。</p><h2 id="ed37" class="ob mq iq bd mr oc od dn mv oe of dp mz ln og oh nb lr oi oj nd lv ok ol nf iw bi translated">能不能放弃批处理层，把一切都处理在速度层？</h2><p id="4c48" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">是的，这种架构的一个例子叫做Kappa Kreps，它提出以流式方式处理传入的数据，每当需要更大的历史记录时，可以从Kafka缓冲区重新流式传输，或者如果我们必须返回更远，可以从历史数据群重新流式传输。</p><h1 id="5023" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">如何实现Lambda架构？</h1><p id="5cb4" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">我们可以通过使用Hadoop数据湖在现实世界中实现这种架构，其中HDFS可以用于存储主数据集，Spark(或Storm)可以形成速度层，HBase(或Cassandra)可以是服务层，Hive可以创建可查询的视图。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5c526cbdd123219b6ab151e0f5f6ef55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4oItXvPnvE04LCB9Z2-BZw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Lambda架构的示例实现</figcaption></figure><h1 id="6c37" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">使用Lambda架构</h1><h2 id="cd63" class="ob mq iq bd mr oc od dn mv oe of dp mz ln og oh nb lr oi oj nd lv ok ol nf iw bi translated">美国Yahoo公司(提供互联网的信息检索服务)</h2><p id="05a8" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">对于在其广告数据仓库上运行分析，雅虎采取了类似的方法，也使用了Apache Storm、Apache Hadoop和Druid。</p><h2 id="deb4" class="ob mq iq bd mr oc od dn mv oe of dp mz ln og oh nb lr oi oj nd lv ok ol nf iw bi translated">网飞</h2><p id="980e" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">网飞·苏罗项目是网飞数据管道的主干，该管道有单独的数据处理路径，但并不严格遵循lambda架构，因为路径可能旨在服务于不同的目的，不一定提供相同类型的视图。</p><p id="dad1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">领英</strong></p><p id="85f4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">用Apache方解石连接离线和近线计算。</p><h1 id="82eb" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">结论</h1><p id="2a15" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">请记住:<code class="fe om on oo op b">batch view = function (all data)</code>、<code class="fe om on oo op b">realtime view = function (real-time view, new data)</code>和<code class="fe om on oo op b">query = function (batch view, real-time view)</code>。</p><p id="b813" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">很简单，对吧？</p><h1 id="ef91" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">参考</h1><p id="535b" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">[1]<a class="ae oq" href="http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html" rel="noopener ugc nofollow" target="_blank">http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html</a></p><p id="dd51" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[2]<a class="ae oq" href="http://www.slideshare.net/Hadoop_Summit/interactive-analytics-in-human-time?next_slideshow=1" rel="noopener ugc nofollow" target="_blank">http://www . slide share . net/Hadoop _ Summit/interactive-analytics-in-human-time？next_slideshow=1 </a></p><p id="dafb" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[3]<a class="ae oq" href="https://netflixtechblog.com/announcing-suro-backbone-of-netflixs-data-pipeline-5c660ca917b6" rel="noopener ugc nofollow" target="_blank">https://Netflix tech blog . com/announcing-suro-backbone-of-netflixs-data-pipeline-5c 660 ca 917 b 6</a></p></div></div>    
</body>
</html>