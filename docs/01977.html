<html>
<head>
<title>Staging Commits with “Git Add Patch”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用“Git添加补丁”进行提交</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/staging-commits-with-git-add-patch-1eb18849aedb?source=collection_archive---------4-----------------------#2020-02-10">https://levelup.gitconnected.com/staging-commits-with-git-add-patch-1eb18849aedb?source=collection_archive---------4-----------------------#2020-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e7ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一名开发人员，很少有比开始一个新项目更令人兴奋的事情了。绘制一个领域模型来绘制后端逻辑，创建一个前端线框来决定它在web浏览器或移动设备上的布局，然后最终编写代码来实现您的愿景，这一过程可能会令人兴奋。过去，当我开始从事新项目时，很容易进入状态，忘记我学习编码时学到的最早的课程之一:</p><blockquote class="kl"><p id="9b3e" class="km kn iq bd ko kp kq kr ks kt ku kk dk translated">“早承诺，常承诺；记住，你每写两行代码就应该提交一次”——一个明智的指导者</p></blockquote><p id="aef1" class="pw-post-body-paragraph jn jo iq jp b jq kv js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kz ki kj kk ij bi translated">当我最终第一次真正提交时(我不好意思说在那之后还有很多提交)，它看起来通常是这样的:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="2cda" class="lj lk iq lf b gy ll lm l ln lo">$ git add .</span><span id="7b0c" class="lj lk iq lf b gy lp lm l ln lo">$ git commit -m “I added a bunch of code.”</span><span id="c488" class="lj lk iq lf b gy lp lm l ln lo">$ git push origin master</span></pre><p id="0a19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您不熟悉Git，请允许我快速地向您介绍一下。在第一行中，我们将刚刚编辑的所有代码添加到git暂存区。在第二行中，我们将提交/保存分段代码到我们的本地git存储库。最后，在最后一行，我们将这些更改上传到在线存储库。这种提交方式在您刚刚开始并且还不熟悉git过程时可能是好的，但是当您开始处理更复杂的项目时，它可能会导致进一步的复杂化。</p><p id="9240" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直到与一位更有经验的开发人员交谈，我才了解到一种更高级的创建git提交的方法，<code class="fe lq lr ls lf b">git add -p</code>。在这篇文章中，我将描述为什么应该进行小规模提交，这个命令是如何工作的，以及它将如何允许您开始进行更有针对性、更有影响力和更细粒度的提交，以及养成更频繁地提交的习惯。</p><h2 id="a5af" class="lj lk iq bd lt lu lv dn lw lx ly dp lz jy ma mb mc kc md me mf kg mg mh mi mj bi translated"><strong class="ak">为什么小规模提交很重要？</strong></h2><p id="c43f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">一个行业惯例是，开发人员应该编写小而易读的提交，但是为什么呢？这有几个原因。首先，做一个小的承诺会让你更容易跟踪你所做的改变。如果您无意中破坏了应用程序，较小的提交还允许您快速进行修复。此外，做一个小的提交可以让其他可能查看你的源代码的开发人员理解你在添加一个更新或者一个特性的时候在做什么</p><h2 id="7525" class="lj lk iq bd lt lu lv dn lw lx ly dp lz jy ma mb mc kc md me mf kg mg mh mi mj bi translated"><strong class="ak">什么是<em class="mp">“git add-patch”</em></strong></h2><p id="8bd0" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><code class="fe lq lr ls lf b">git add -p</code> <strong class="jp ir"> </strong>是<code class="fe lq lr ls lf b">git add --patch</code>的缩写，它是一个git选项，允许您进行更具体的提交。它的工作原理是，它将遍历您代码中所有的新变化，并一次显示其中的大块内容，让您决定想要登台或不登台的内容。</p><p id="43ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在进行一些更改后使用此命令，只需运行以下命令:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d836" class="lj lk iq lf b gy ll lm l ln lo">git add -p</span><span id="7ac6" class="lj lk iq lf b gy lp lm l ln lo">// or </span><span id="6138" class="lj lk iq lf b gy lp lm l ln lo">git add --patch</span></pre><p id="7ef2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你这样做，你会看到一个类似这样的消息:</p><figure class="la lb lc ld gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mq"><img src="../Images/6f59ba28c05db5611182c1986d25dab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IiWnA58A1Ha6LW2MUTfGkQ.png"/></div></div></figure><p id="d5cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们查看粗体文本，我们可以看到自上次提交以来，我们所在的文件发生了什么变化。如果我们看绿色文本，我们会看到添加到文件中的内容。如果我们对已经存在的代码进行任何更改，它看起来会像这样:</p><figure class="la lb lc ld gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi my"><img src="../Images/627226c34c79b682952b68f3ae84f07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qEe_G2ACc6tsEck3U7rUbg.png"/></div></div></figure><p id="6372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们的旧代码用红色标记，新编辑的代码用绿色标记。我们在这里看到的最后一行是问我们想用这段代码做什么，并为我们提供了各种选项。这就引出了一个问题——每个选项意味着什么？</p><p id="d067" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要获得每个选项的简单描述，只需点击“？”然后回来。此文本将在您的终端中弹出:</p><figure class="la lb lc ld gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mz"><img src="../Images/8b2b3ee9ab0ea98b2e38238330b2ded1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avgPCY6YLTZBb6zoQ4bnSA.png"/></div></div></figure><p id="92e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于更深入的描述，请继续阅读以下内容:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="2c95" class="lj lk iq lf b gy ll lm l ln lo"><strong class="lf ir">y - stage this hunk - </strong>this command adds the current hunk to staging meaning it is ready.<br/><strong class="lf ir">n - do not stage this hunk - </strong>this command won’t add the current hunk to staging.<br/><strong class="lf ir">q - quit; do not stage this hunk or any of the remaining ones - </strong>this command quits out of the staging process.  Any hunks before this one that has been added to staging will still be staged but the current hunk and all hunks after will be ignored.<br/><strong class="lf ir">a - stage this hunk and all later hunks in the file </strong>- this command works similar to the `git add .` call. It will stage all changes made from this hunk on.<br/><strong class="lf ir">d - do not stage this hunk or any of the later hunks in the file -</strong> this command will not stage this hunk or any hunks in the same file.<br/><strong class="lf ir">e - manually edit the current hunk- </strong>this command opens vim and allow you to edit the hunk of code in your terminal.<br/><strong class="lf ir">? - print help -  </strong>this opens up the menu above.</span><span id="fbd2" class="lj lk iq lf b gy lp lm l ln lo"><em class="na">//One option not printed here is:<br/></em><strong class="lf ir">s - split this hunk </strong>- this option is only available if the current hunk of code has an unchanged line of code between edits.  This will split the hunk into two separate hunks allowing you to stage them individually.</span></pre><p id="2ea6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现最有用的命令是' y '，' n '，' s '和'？'。但是，我在不同的时间都用过。对于每一个代码块，您可以选择是否暂存，它将循环到下一个代码块，直到循环完您所做的所有编辑，或者选择退出该过程。</p><p id="978c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成转移过程后，您可以创建更直接的提交:</p><figure class="la lb lc ld gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nb"><img src="../Images/e701f67fca293f9122eb553a4f4315c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9_ETwVnEz1uDQZmsNftsw.png"/></div></div></figure><h2 id="e1c7" class="lj lk iq bd lt lu lv dn lw lx ly dp lz jy ma mb mc kc md me mf kg mg mh mi mj bi translated"><strong class="ak">为什么要用它</strong></h2><p id="3645" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我推荐几个理由，说明为什么您应该现在就开始使用这种分段技术进行提交！首先:如果您在编程时碰巧进入了这个区域，并且忘记了提交，这是一个很好的实践，它将允许您解析您的代码，隔离任何编辑，并决定在任何给定的提交中哪些应该提交，哪些不应该提交。第二:这个过程也允许你在提交之前再做一次编辑。第三:从更个人的角度来说，我发现自从使用这个提交选项后，我开始养成了小规模提交的习惯。</p><h2 id="bd09" class="lj lk iq bd lt lu lv dn lw lx ly dp lz jy ma mb mc kc md me mf kg mg mh mi mj bi translated"><strong class="ak">结论</strong></h2><p id="25c8" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">是一项伟大的git技术，它将允许您进行更小更具体的提交，并且是对任何人的git工作流程的一个伟大补充。感谢阅读！</p></div></div>    
</body>
</html>