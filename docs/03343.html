<html>
<head>
<title>Seven Tips For Using Fluentd For Logs Collection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Fluentd收集日志的七个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-tips-for-using-fluentd-for-logs-collection-c9613f7a387c?source=collection_archive---------8-----------------------#2020-05-04">https://levelup.gitconnected.com/7-tips-for-using-fluentd-for-logs-collection-c9613f7a387c?source=collection_archive---------8-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b1e0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">集中记录</h2><div class=""/><div class=""><h2 id="eae8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过应用一些最佳实践来改进您的FluentD配置和脚本</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ff9dcf53084f8a5c229ad8de3c8fd2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mZpDSJKUINoJ3O-j"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">萨姆·丹·张在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="li lj lk"><p id="091d" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Fluentd是一个跨平台的开源数据收集软件项目，最初是在Treasure Data开发的。它主要是用Ruby编程语言编写的。<a class="ae lh" href="https://en.wikipedia.org/wiki/Fluentd" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="b2cb" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">Fluentd是一个工具，可用于从多个数据源收集日志，如应用程序日志、网络协议。和第三方服务。此外，Fluentd允许您跨所有支持的服务和应用程序构建统一的日志记录层。例如，您可以从包括反向代理(Nginx或Apache)在内的所有应用程序中收集日志，并解析应用程序的日志以从日志消息中提取属性，以便能够在以后使用诸如<a class="ae lh" href="https://www.elastic.co/kibana" rel="noopener ugc nofollow" target="_blank"> Kibana </a>之类的工具可视化日志，甚至将日志存储在MongoDB数据库中。</p><p id="a488" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">在Fluentd中收集和解析日志可以通过编写FluentD特定的<a class="ae lh" href="https://docs.fluentd.org/configuration/config-file" rel="noopener ugc nofollow" target="_blank">配置文件</a>来完成，这些文件定义了日志的数据源、集成插件和解析配置。</p><p id="6735" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">在这篇文章中，我将试图强调和描述一些编写Fluentd配置文件的最佳实践和建议。此外，我将描述一些可以与Fluentd集成的有用插件。</p><p id="397e" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">组织配置文件</strong></p><p id="7393" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">虽然FluentD配置可以存储在一个包含所有Fluentd配置的巨大配置文件中，但我建议将Fluentd配置分成以下部分或文件:</p><ul class=""><li id="0d15" class="ml mm it lo b lp lq ls lt mi mn mj mo mk mp mh mq mr ms mt bi translated">源配置文件:这些文件将包括所有支持的数据源的配置。例如，下面的配置设置了一个<strong class="lo jd"> <em class="ln"> tail </em> </strong>源来从Docker容器收集日志。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mu"><img src="../Images/2b0896581ce960dfa8fca05d66a84f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwC7iF1lV1lazHW58vldDw.png"/></div></div></figure><ul class=""><li id="92ef" class="ml mm it lo b lp lq ls lt mi mn mj mo mk mp mh mq mr ms mt bi translated">分类配置文件:这些文件负责将日志源分类到不同的类别，并确保日志可以被解析。对于这些类别中的每一个，将对日志进行不同的解析。下面的代码片段显示了一个Fluentd配置的示例，它可以用来对docker容器日志进行分类。配置中的第一个过滤器将docker属性加载到日志事件中，例如docker容器名称。第二个过滤器将根据从第一个过滤器中提取的容器名称重新标记日志事件。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/882bc840e4661ce6e65bb1b8ce5e514c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BfVx0TyHM20TrC4GgNC7sQ.png"/></div></div></figure><ul class=""><li id="65ee" class="ml mm it lo b lp lq ls lt mi mn mj mo mk mp mh mq mr ms mt bi translated">解析日志配置文件:这些文件负责解析日志消息，并从日志消息中提取属性和参数。在下面的例子中，我们从每个Nginx日志消息中提取请求代理、请求时间和响应代码。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mw"><img src="../Images/ebbb0187da66df7301c22150e17ab9ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JR0RF8edVl2Fq1241MStJA.png"/></div></div></figure><ul class=""><li id="8e67" class="ml mm it lo b lp lq ls lt mi mn mj mo mk mp mh mq mr ms mt bi translated">输出配置文件:这些文件将包含将日志发送到最终目的地的配置，比如本地文件或远程日志服务器。Fluentd支持几个<a class="ae lh" href="https://docs.fluentd.org/output" rel="noopener ugc nofollow" target="_blank">输出插件</a>比如forward、copy和stdout。下图显示了我们如何将日志转发到外部日志服务器</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mx"><img src="../Images/22bab54e95ae6dec52111ed0c9675473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X96xhW3x0g-aCTpaYkx6Mw.png"/></div></div></figure><p id="4138" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">使用tail over forward等输入插件</strong></p><p id="bee9" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">Fluentd支持多个<a class="ae lh" href="https://docs.fluentd.org/input" rel="noopener ugc nofollow" target="_blank">输入插件</a>，并从不同的<a class="ae lh" href="https://www.fluentd.org/datasources" rel="noopener ugc nofollow" target="_blank">数据源</a>收集日志，如应用程序日志、网络协议日志和第三方服务日志。例如，要收集docker容器中运行的rails应用程序的日志，您有以下选择</p><ul class=""><li id="e307" class="ml mm it lo b lp lq ls lt mi mn mj mo mk mp mh mq mr ms mt bi translated">将日志直接从应用程序转发到Fluentd。</li><li id="b440" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh mq mr ms mt bi translated">配置docker将容器日志转发到Fluentd。</li><li id="d05f" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh mq mr ms mt bi translated">配置Fluentd从日志文件中收集应用程序日志。</li></ul><p id="2835" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">虽然使用前两个选项收集日志似乎更容易，但我强烈建议使用第三个选项来收集应用程序日志，原因如下。</p><ol class=""><li id="e605" class="ml mm it lo b lp lq ls lt mi mn mj mo mk mp mh nd mr ms mt bi translated">对于前两个选项，需要修改应用程序的源代码并升级应用程序日志系统，或者更新Docker的配置。</li><li id="b19e" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh nd mr ms mt bi translated">将docker配置为转发日志有一些缺点，比如无法从Docker命令行获得日志，因为我们需要更改日志记录驱动程序(如果应用程序停止将日志记录到STDOUT，这也适用于直接发送日志)</li><li id="e17d" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh nd mr ms mt bi translated">对于前两个选项，如果缓冲配置不正确(尤其是对于第一个选项)，如果远程服务器停机或出于某种原因不接受日志，就会出现松散日志的变化。</li><li id="40aa" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh nd mr ms mt bi translated">通过跟踪日志文件来收集日志提供了更大的灵活性，并将易受影响的配置与应用程序本身隔离开来。举例来说，唯一的要求或依赖性是能够访问应用程序的日志文件。解析和发送日志的所有其他步骤都可以由Fluentd来处理。此外，使用第三种方法，应用程序根本不需要担心日志的流动或传送。</li></ol><p id="c3ff" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">使用标签</strong></p><p id="1ade" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">微服务架构应用的Fluentd配置可能非常复杂，具体取决于服务数量和支持的日志格式。有助于降低配置复杂性的一种方法是使用Fluentd "label <strong class="lo jd"> <em class="ln"> " </em> </strong>指令来隔离和分组配置的不同部分。</p><p id="7a1d" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">忽略不需要的日志</strong></p><p id="56a3" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">在开始解析日志之前，最重要的步骤之一是处理“噪音”日志或日志消息，这些日志或日志消息可以被忽略，不需要发送。例如，通常，负载平衡器和监控系统会定期使用几个应用程序端点，如健康检查端点或指标端点。忽略与这些端点相关的所有日志消息以减少发送的日志量是很有意义的，尤其是在日志服务器对发送的日志大小有限制的情况下。下面的例子显示了如何忽略与web请求<code class="fe ne nf ng nh b">health</code>和<code class="fe ne nf ng nh b">metrics</code>相关的所有日志消息</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/65102198c16849eedc2afa3613558912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAnwGhh1IjP6GBxyDkwQfQ.png"/></div></div></figure><p id="85d2" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">处理多行日志</strong></p><p id="4798" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">有许多应用程序会生成多行日志，其中一个请求的日志会被分成多行。默认情况下，Fluentd会将每一行作为独立的日志消息来处理，并且不会将日志行关联起来。此外，Kibana会将这些日志行视为单独的日志事件，很难在Kibana界面中圈出这些日志行，甚至很难读取它们。RubyonRails是一个生成多行日志的web框架。下图显示了Kibana中Rails日志的样子。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nj"><img src="../Images/28fe85cfed8f06c0ed29a0b737143b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXvKuIIVDy6ksnkMKmFbAw.png"/></div></div></figure><p id="2398" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">因此，如果您的应用程序正在生成多行日志，您需要考虑将这些日志行关联在一起，并通过Fluentd处理多行日志。在这篇文章中，我详细讨论了如何处理Rails应用程序的多行日志。</p><div class="nk nl gp gr nm nn"><a href="https://medium.com/faun/parse-ruby-on-rails-logs-with-fluentd-9fca4df6ebfe" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">用FluentD解析Ruby on Rails日志</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">让我们通过使用FluentD解析rails多行日志来减少日志量。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob lb nn"/></div></div></a></div><p id="02be" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">弹性搜索的稳定接口</strong></p><p id="f618" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">将日志发送到Elasticsearch或任何其他数据库是一项简单的任务，但是，有几个制动问题可能会破坏日志记录系统并导致日志丢失。</p><ul class=""><li id="e4ae" class="ml mm it lo b lp lq ls lt mi mn mj mo mk mp mh mq mr ms mt bi translated">索引太多:如果您的应用程序正在生成包含大量属性的JSON日志(因为您的应用程序正在记录对象的JSON表示),就会出现这个问题。这也会基于对象的JSON表示生成一些奇怪的索引名。</li><li id="87f7" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh mq mr ms mt bi translated">索引冲突:如果您有两个(甚至一个)应用程序记录具有相同索引但不同数据类型的消息，可能会发生此问题。例如，如果您的应用程序生成带有“字符串”数据类型的<strong class="lo jd">错误索引</strong>的日志消息，而您的另一个应用程序生成带有“对象”数据类型的<strong class="lo jd">错误索引</strong>的日志。</li><li id="963a" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh mq mr ms mt bi translated">有效负载太大:当应用程序生成的日志消息超过Elasticsearch的限制时，就会出现这个问题。</li></ul><p id="1d33" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">为了克服这些问题，我建议使用Fluentd构建一个统一的日志记录接口，并且只使用该层定义的ke来发布日志消息。我们不应该允许应用程序直接更改或添加索引。使用record_reformer插件可以很容易地构建这一层。如下面的代码片段所示，Nginx日志将由Fluentd解析，只有定义或提取的密钥将被发送到远程日志记录系统。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mw"><img src="../Images/ebbb0187da66df7301c22150e17ab9ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JR0RF8edVl2Fq1241MStJA.png"/></div></div></figure><p id="965f" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">清理有效载荷空键</strong></p><p id="9dc7" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">最后，作为一项清理措施，我建议过滤所有日志事件，删除所有值为空的键。此操作有助于保持Kibana上的日志消息干净，并且只包含具有有效值的键。可以使用<a class="ae lh" href="https://github.com/wshihadeh/fluent-plugin-filter_empty_keys" rel="noopener ugc nofollow" target="_blank"> empty_keys </a>插件轻松完成这项任务。默认情况下，它将删除所有具有空字符串值的键。但是，它允许为自定义键定义空值。在下面的例子中，我们将<strong class="lo jd"> 0 </strong>定义为列出的键的空值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/4b49ae1f58afd4722fcc5ec2d97d6947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tk7vQ5KCfVn6poBuwLSKvg.png"/></div></div></figure><p id="4e67" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">推荐和有用的插件</strong></p><p id="a9af" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">Fluentd支持<a class="ae lh" href="https://www.fluentd.org/plugins" rel="noopener ugc nofollow" target="_blank">多种插件和过滤器</a>来处理和解析日志。下面是一些最常用的插件的简要描述。</p><ul class=""><li id="42ab" class="ml mm it lo b lp lq ls lt mi mn mj mo mk mp mh mq mr ms mt bi translated"><a class="ae lh" href="https://github.com/wshihadeh/fluent-plugin-filter-docker_metadata" rel="noopener ugc nofollow" target="_blank"> docker_metadata </a>:这个插件帮助我们收集与日志消息相关的docker元数据，比如容器名。</li><li id="2942" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh mq mr ms mt bi translated"><a class="ae lh" href="https://github.com/sonots/fluent-plugin-record-reformer" rel="noopener ugc nofollow" target="_blank"> record-reformer </a>:这个插件对于重新创建日志消息事件非常有帮助。</li><li id="a5f0" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh mq mr ms mt bi translated"><a class="ae lh" href="https://github.com/nttcom/fluent-plugin-rabbitmq" rel="noopener ugc nofollow" target="_blank"> Rabbitmq </a>:这是一个生成Rabbitmq事件的输出插件。</li><li id="f848" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh mq mr ms mt bi translated"><a class="ae lh" href="https://github.com/uken/fluent-plugin-elasticsearch" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>:这个插件帮助将日志发送到Elasticsearch实例。</li><li id="2fb1" class="ml mm it lo b lp my ls mz mi na mj nb mk nc mh mq mr ms mt bi translated"><a class="ae lh" href="https://github.com/fluent/fluent-plugin-mongo" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>:这个插件可以用来在MongoDB实例中存储日志消息。</li></ul><p id="c136" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">结论</strong></p><p id="b905" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">从应用程序、网络协议和第三方服务收集日志相对容易完成。在这篇文章中，我强调了一些可以提高Fluentd配置可读性和质量的地方。</p></div></div>    
</body>
</html>