<html>
<head>
<title>Explain Cut Vertex and Cut Edges like I'm Five</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释割顶点和割边就像我五岁一样</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/explain-cut-vertex-and-cut-edges-like-im-five-bc295f919eeb?source=collection_archive---------23-----------------------#2021-01-26">https://levelup.gitconnected.com/explain-cut-vertex-and-cut-edges-like-im-five-bc295f919eeb?source=collection_archive---------23-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/591201f1dbdbaf909cc92094856856a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1EAuemr379rp5Amf"/></div></div></figure><p id="0c78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我解释割顶点和割边的定义之前，让我们来看看这个问题陈述。</p><p id="0141" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给定一个网络(图)，找出网络中的临界点(或边)，这样，如果我们删除该点或边，它会将网络一分为二。</p><p id="eb0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">网络中的一个临界点是，当你移除顶点时，该顶点将断开网络。</p><p id="dd16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以把一个网络想象成一个图，其中每个节点可以是一个实体，边代表两个实体是否相连。</p><p id="68ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将图一分为二的点称为割点。</p><p id="ec68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与割边相同，它是一条临界边(或桥)，是必要边，当去掉时会使一个图一分为二。</p><p id="d102" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，让我们假设顶点，因为边将是相似的顶点，我们将简要讨论如何找到桥。</p><p id="885d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么我们如何解决这个问题呢？</p><p id="0b1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们想找到所有的顶点，我们将把图一分为二。我们将尝试逐个删除图中的每个顶点。如果图形在移除顶点后断开，我们可以将该顶点添加到我们的割顶点桶列表中。</p><p id="e375" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">蛮力法管用。然而，如果我们有一个很大的图形，它将永远需要做操作。</p><p id="40fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于每个顶点，我们执行以下操作:</p><ul class=""><li id="36f1" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">移除顶点</li><li id="f128" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">检查图是否保持连接(我们可以使用DFS或BFS，或联合查找)</li><li id="b93f" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">将顶点添加回图表</li></ul><p id="81cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想象一下，检查一个图是否是每个顶点的连通分支。根据您如何实现检查连通分量算法，您将运行<code class="fe ln lo lp lq b">V*(V+E)</code>。遍历每个顶点花费V，检查每个顶点上的连通分量花费<code class="fe ln lo lp lq b">V+E</code>。</p><p id="a8d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们仔细观察上面的解决方案时，我们意识到检查图是否保持连接可以通过检查是否有一个环沿着邻居向下连接到该顶点的祖先来完成。</p><p id="470d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在图论中，顶点内的循环形式意味着后边缘。可以把它看作子节点中指向父节点的另一条边。</p><p id="81cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们以此为例:</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lr"><img src="../Images/fb6761bd05f886eea5eb9caa51db825d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lVE2FkrIGcDhtIwS.png"/></div></div></figure><p id="c1cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[示例(切割顶点)]</p><p id="3421" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个顶点上还有什么条件可以确定这个顶点是临界顶点？</p><p id="60b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果一个关键顶点的邻居没有指向其父节点的后边缘，我们可以尝试将具有后边缘的节点组合成更重要的节点。像这样:</p><p id="d047" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你意识到了什么？</p><p id="8667" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过观察，我们之前看到的精心制作的图表变成了一棵树。</p><p id="12ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以得出一个结论——如果一个图没有循环，那么它也是一个T2树。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lr"><img src="../Images/f32eb3b812b1598ce93d9b858cc7f6d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U7R2g8pZaLdCXUxr.png"/></div></div></figure><p id="8ae3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">顶点C是关键顶点，因为它是树的根，并且它有两个以上的孩子。为什么是两个？因为如果我们在那个根中有一个孩子，去掉那个顶点，这个图仍然是连通的。如果我们在根中有两个孩子，并删除顶点，它将把图一分为二。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/20ade51915019559e964d77c22a44a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BQEU-iFxGNv4z0W3.png"/></div></figure><p id="6040" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">图中的另一点是，一片叶子不可能是关节点，因为如果我们去掉叶子，图仍然是连接的。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/f4b360d8d5b19df75e03d9c0fa6fab39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AghIjdkGmjQbwm-K.png"/></div></div></figure><p id="5b6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面所有的观察中，我们可以看出，一个顶点在这两个条件下是临界顶点:</p><ol class=""><li id="7250" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky lz lf lg lh bi translated">顶点是DFS树的根，它至少有两个子节点</li><li id="0195" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky lz lf lg lh bi translated">如果顶点不是DFS树的根，则没有从其子节点连接到其祖先或自身的后边缘。</li></ol><p id="c590" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，我们知道这两个主要属性是如何找到关节点的。我们如何确定父母至少有两个孩子？我们如何知道顶点的子顶点是否没有后边缘？</p><p id="dd44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很高兴你这么问。</p><h1 id="e8e6" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">我们如何确定父母至少有两个孩子？</h1><p id="b582" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">我们可以跟踪在DFS树中遍历的所有父节点。假设我们从顶点c开始。我们可以有一个父数组，其中索引代表顶点，索引象征父数组的指针。我们将顶点C设为-1。我们探索它的邻居(孩子),并将父数组中的所有邻居元素标记为c。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/0679ee4556e4cdc6b4d6d3ff90d7c96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M_Ebm916YNR4pRUV.png"/></div></div></figure><h1 id="c963" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">我们如何发现没有后边缘来自顶点的子顶点？</h1><p id="2a47" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">当我们使用DFS遍历图时，我们可以使用时间戳数组来跟踪每个节点遍历图的顺序。如果我们开始遍历顶点C，顶点C的时间戳数组元素将是1。然后，我们遍历C的邻居，假设是顶点D，顶点D中的时间戳数组是1。我们遍历顶点D的邻居，该邻居将被赋予时间戳2，以此类推。</p><p id="86df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么我们需要时间戳来确定周期？</p><p id="d2da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">确定循环的典型方式是保存DFS操作期间所有被遍历节点的列表。如果一个节点有一个邻居指向已经存在的列表，这意味着该图有一个循环。</p><p id="5b20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">保存所有节点的时间戳表有助于我们跟踪遍历中第一个访问的节点。</p><p id="3727" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在时间戳表中，我们可以看到操作发现顶点D晚于顶点c。有了这一知识，我们可以看到一个更具体的属性，如果顶点D可以比顶点c更早到达节点时间戳表。</p><p id="54f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了检查顶点D是否可以到达比顶点C更早的节点时间戳表，我们需要找到另一个数组来跟踪从顶点D可以访问的最低时间戳。让我们称之为“低墨水”。</p><p id="5f48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果顶点D的低链接为0，我们从顶点D可以到达的最早发现时间为0。</p><p id="cdd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">低链接对我们寻找循环有什么帮助？有了时间戳表，我们可以检查每个节点的发现时间。</p><p id="800e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过low链接，我们可以检查当前节点到达的最早发现时间。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/83862e670a3dba931834a8fe0394af16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OLuFj711NvdmDkLf.png"/></div></div></figure><p id="9459" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上图中，顶点A的发现时间为1。顶点B的发现时间是2。然而，在图中的某个地方，循环中有一个后边缘指向顶点a。我们可以通过低链接检查顶点B的邻居之一的低链接，并看到小于顶点B。如果它小于顶点B，这意味着顶点B的邻居之一与B的祖先有联系。</p><p id="053b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要找到临界点，我们不希望有一个后沿。因此，如果其邻居的任何低链路大于当前时间戳距离，我们可以保证没有后沿。</p><p id="9376" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以遍历所有的顶点，做一个DFS。我们将有一系列的访问，父母，墨水少，和探索时间。对于每个顶点:</p><ul class=""><li id="e847" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">使用当前时间戳设置发现时间(在每个DFS的开头，initial为0)。将低链接设置为发现时间。</li><li id="02c7" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">设置发现顶点的父对象。</li><li id="ac71" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">对于每次递归，我们通过比较邻居的最小发现时间和当前发现时间来不断改变低链路。</li><li id="57c4" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">一旦我们设置完所有的低链接、发现时间和父图，我们就可以提到这两个属性了。首先，我们检查当前节点是否是父节点，是否有两个以上的子节点。第二，我们检查是否有任何邻居节点具有大于当前发现时间的低链路。(发现时间[当前节点]&gt;低链接[邻居])</li><li id="8ef9" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">如果两个陈述中的任何一个是正确的，那么这个节点就是关节点。</li></ul><p id="f415" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">执行上述算法可以将时间复杂度从<code class="fe ln lo lp lq b">V*(V+E)</code>降低到<code class="fe ln lo lp lq b">V+E</code>。</p><p id="494c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查找桥或切割边类似于查找切割顶点，只是它不需要检查第一个语句——顶点是一个父级，至少有两个子级。图中任何不能引起循环的边都是桥。</p><h1 id="7c3c" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">用例</h1><p id="a47a" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">切割顶点和切割边对于检测网络中的弱点是有用的，因为如果它具有切割顶点的属性，则网络是断开的。</p><p id="8ce8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们识别网络、循环、需求、管道中的流体和电路中的单点故障。</p><p id="0f40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望你觉得这个解释有用！你可以试着把算法实现为一个练习，进一步把知识植入你的大脑。本文旨在理解算法的直观性以及切割顶点和切割边的定义。请随意在下面评论，这样其他人也可以从你的问题或评论中学习。</p><h1 id="0dba" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">资源</h1><p id="8a7e" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">有一些关于连接点和桥的很好的资源，以及它们的用例。如果您想了解更多信息，请查看下面的参考资料！</p><ul class=""><li id="5873" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae nf" href="https://web.iitd.ac.in/~bspanda/biconnectedMTL776.pdf" rel="noopener ugc nofollow" target="_blank">双连通图讲座</a></li><li id="9185" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><a class="ae nf" href="https://en.wikipedia.org/wiki/Flow_network" rel="noopener ugc nofollow" target="_blank">心流网—维基百科</a></li><li id="08a1" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><a class="ae nf" href="https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/" rel="noopener ugc nofollow" target="_blank">图中的关节点(或切割顶点)——GeeksforGeeks</a></li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="8aab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lw">最初发表于</em><a class="ae nf" href="https://edward-huang.com/algorithm/graph-theory/2021/01/24/explain-cut-vertex-and-cut-edges-like-im-five/" rel="noopener ugc nofollow" target="_blank">T5【https://edward-huang.com】</a><em class="lw">。</em></p></div></div>    
</body>
</html>