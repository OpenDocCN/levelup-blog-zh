<html>
<head>
<title>Set Up a Connection Over WebSocket: Video Call with WebRTC Step 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过WebSocket建立连接:使用WebRTC进行视频通话步骤2</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/set-up-a-connection-over-websocket-videochat-with-javascript-step-2-f78c307c4fd3?source=collection_archive---------1-----------------------#2020-03-19">https://levelup.gitconnected.com/set-up-a-connection-over-websocket-videochat-with-javascript-step-2-f78c307c4fd3?source=collection_archive---------1-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ab58311d16b69570700fd96f4c2bf5c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZLgk_yBVnG-aur4LvBrDA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@cytonn_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Cytonn摄影</a>在<a class="ae kf" href="https://unsplash.com/s/photos/handshake?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="fa62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们想使用WebRTC协议创建一个视频聊天。我们在<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/data-stream-from-your-webcam-and-microphone-videochat-with-javascript-step-1-29895b70808b">的上一篇文章</a>中看到了如何从浏览器访问网络摄像头和麦克风流。我们现在想在两个用户之间建立一个P2P连接。</p><p id="7145" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本地浏览器和远程用户(对等点)之间的WebRTC连接将由JavaScript接口<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection" rel="noopener ugc nofollow" target="_blank"> RTCPeerConnection </a>表示。但是你必须首先协调这个连接，在对等体之间交换消息以找到对方，控制通信，然后终止它。这是信号传递过程。信令过程不是WebRTC规范的一部分，您可以自由地使用您想要的任何消息传递协议来建立和控制连接。从技术上讲，您可以在每次发布时传递这些消息，但是一个常见的解决方案是使用WebSocket协议。</p><p id="0a4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将允许两个用户通过WebSocket进行通信。我们将用一个节点服务器构建一个例子，在这个例子中，对等体可以创建一个连接，互相打招呼，然后关闭连接。</p><h1 id="8422" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">WebSocket</h1><p id="56bd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">WebSocket是一种通信协议，类似于HTTP。像HTTP一样，WebSocket支持客户端(浏览器)和服务器之间的通信。</p><p id="64dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当通过HTTP通信时，服务器只能对客户机的请求做出反应。它不记得以前的请求，HTTP是无状态的。另一方面，WebSocket允许您在客户机和服务器之间打开一个通道。一旦这个通道打开，直到它关闭，通信可以双向进行:服务器可以在它喜欢的时候发送数据，客户端也可以。</p><p id="c6fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">WebSocket实际上被设计为基于HTTP工作，所以我们可以使用普通的web服务器来构建它。我们将在客户机和节点服务器之间实现一个WebSocket通信。</p><h1 id="cc4e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置节点项目</h1><p id="3ba2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们将为此使用一个节点服务器和一个实现WebSocket的库:<a class="ae kf" href="https://github.com/Worlize/WebSocket-Node" rel="noopener ugc nofollow" target="_blank"> WebSocket-Node </a>。</p><p id="b43e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你的机器上还没有，你应该安装<a class="ae kf" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>。创建一个文件夹，在其中放置你的WebSocket项目(我把我的命名为<em class="mh"> web-socket </em>)。然后在该文件夹中初始化您的项目:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7129" class="mr lf it mn b gy ms mt l mu mv">npm init</span></pre><p id="f70a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个index.js文件，并使用npm安装<a class="ae kf" href="https://github.com/Worlize/WebSocket-Node" rel="noopener ugc nofollow" target="_blank"> WebSocket-Node </a>库:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="57e7" class="mr lf it mn b gy ms mt l mu mv">npm install websocket --save</span></pre><p id="0444" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按照库的文档，我们首先需要定义一个HTTP服务器。我们的将监听端口1337。然后我们可以在其上创建WebSocket服务器。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5c16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们想做一些非常简单的事情来理解WebSocket是如何工作的。每个人都可以通过我们的服务器连接和发送消息。当用户发送消息时，其他所有连接的用户都会收到。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3685" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要跟踪连接的用户，我们在<em class="mh">客户端</em>数组中这样做。当一个用户请求一个连接时，我们首先接受它，然后通知其他所有连接的用户。我们生成一个随机id，然后将带有该id的新连接添加到数组中。</p><p id="66f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户发送消息时，发出事件<em class="mh">消息</em>。除了发送消息的用户之外，每个连接的用户都被发送一些包含消息文本和发送消息的用户的索引的数据。</p><p id="0e38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，当一个用户断开连接时，他将从<em class="mh">客户端</em>阵列中被删除，其他用户将得到通知。</p><p id="6b34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们通过构建一个简单的用户界面来检查这是否可行。</p><h1 id="149a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">客户</h1><p id="2df6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不打算在客户端构建任何复杂的东西，我们只想确保通信正常工作。我们将显示三个按钮:</p><ul class=""><li id="1d99" class="my mz it ki b kj kk kn ko kr na kv nb kz nc ld nd ne nf ng bi translated">一键连接</li><li id="9c23" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated">一键发送“你好！”消息</li><li id="b25f" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated">一键断开</li></ul><p id="5d71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户未连接时，只有第一个按钮被启用，否则只有最后两个按钮被启用。</p><p id="65f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在按钮下面，我们显示一些区域(在代码中称为<em class="mh">控制台</em>),在这里将打印消息。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/7323ab66e949e57feb2cf973bfa3e92d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Svkc7XQguDfE7BSVxHLk3w.png"/></div></div></figure><p id="0492" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以为客户机代码创建一个新文件夹(我将我的命名为<em class="mh"> client </em>)。同样，我们保持事情简单，所以你只需要<em class="mh">index.html</em>、<em class="mh"> index.js </em>和<em class="mh"> styles.css </em>文件。HTML和CSS非常简单:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="811a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在下面找到完整的<em class="mh"> index.js </em>文件，但是为了让它更容易理解，我们首先将重点放在摘录上。</p><p id="cc22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要定义点击按钮时会发生什么。当点击第一个时，我们想要初始化连接。当第二个被点击时，我们想发送一个“你好！”通过连接传递消息。单击最后一个按钮应该会关闭连接。<em class="mh">连接</em>是一个全局变量，在<em class="mh">setupWebSocketConnection</em>函数中初始化。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f66d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最有趣的部分当然是如何建立连接。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4be6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们简单地创建了一个<em class="mh"> WebSocket </em>类的实例，将url作为参数传递。然后我们定义事件处理程序。当连接打开时，我们向控制台添加一条消息，并正确设置按钮的禁用属性。当收到消息时，我们在控制台中显示它。</p><p id="20df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦连接打开，通过它发送消息就像下面这样简单:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="991f" class="mr lf it mn b gy ms mt l mu mv">connection.send('Hello!');</span></pre><p id="10bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以在事件监听器函数中看到。关闭连接也很简单，正如您在<em class="mh"> closeConnection </em>函数中看到的:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5685" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如承诺的那样，这里有完整的<em class="mh"> index.js </em>文件:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="f776" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试</h1><p id="dacb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在让我们启动服务器，在两个客户机之间尝试我们的消息传递系统。要运行服务器，请转到<em class="mh"> web-socket </em>文件夹并运行:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5af5" class="mr lf it mn b gy ms mt l mu mv">node index.js</span></pre><p id="f6af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该在终端中看到“服务器监听端口1337”。</p><p id="bedf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要测试两个客户端是否可以通过服务器通信，请在两个选项卡或两个浏览器窗口中打开您的<em class="mh">index.html</em>。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/c6b52713569aa16518e3d8f3683c5b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKcUTWPRSNCmh83Bd2m-dA.png"/></div></div></figure><p id="bf8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在按你想要的顺序点击按钮。您可以看到客户端之间正在交换消息:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/7b211e191238959034a1b2b7a100de80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfVfW8b4UKJHIQjmexInXg.png"/></div></div></figure><p id="439e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">WebSocket上的通信工作正常。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="9f7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们确实设置了一个WebSocket服务器来允许两个客户端交换消息。回到更大的画面，我们现在可以使用这个通道来交换创建和控制WebRTC连接所必需的消息。这就是我们在下一篇文章中<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/establishing-the-webrtc-connection-videochat-with-javascript-step-3-48d4ae0e9ea4">要做的事情。</a></p></div></div>    
</body>
</html>