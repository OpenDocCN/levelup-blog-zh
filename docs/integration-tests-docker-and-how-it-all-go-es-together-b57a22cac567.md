# 集成测试、Docker 以及它们是如何一起进行的

> 原文：<https://levelup.gitconnected.com/integration-tests-docker-and-how-it-all-go-es-together-b57a22cac567>

![](img/cf0b7b3ae6993bcd9dc734c70251344d.png)

P 你已经学习了组合、接口、简单性、领域驱动设计(什么都不懂)和单元测试。你觉得自己已经长大了，准备好接受并发性，奔向希望之乡。你已经构建了一个可爱的 CRUD 应用程序，它将彻底改变我们做 x 的方式。你当然已经联系了一家房地产中介，查看你一直想要的顶层公寓，并在多家风投基金和投资者那里发了推文。你基本上已经准备好上线了，但是在你发布你的代码之前，你拿出你最喜欢的终端并输入`go run main.go`。上面写着，光辉岁月！

你安排了多次演示和投资者会议。你在你的 Linkedin 个人资料中添加了“CEO 和创始人”(当然还有 tinder)，并告诉你妈妈你随时都会搬出地下室。你出现在你的第一次会议上，做了几个有力的姿势，并开始演示真正至关重要的端点，这是应用程序的主干。用你的右手拇指按下回车键(左手拇指在精神上准备好打开香槟)，你继续。然后，它完全崩溃了。什么他妈的。你不仅会在超级重要的会议上被嘲笑，还得告诉房地产经纪人你可能负担不起顶层公寓，你还得住在你妈妈的地下室里(并继续试图说服你的约会对象这绝对是一个临时的解决方案)。

希望你没有经历过上述情况，只是因为你在谷歌上输入了一些单词。我将向您展示我如何使用 docker 和一些漂亮的 Makefile 命令在 Go 中设置和运行集成测试。

*这个帖子在我自己的网站上也有* [*这里*](https://mortenvistisen.com/posts/how-to-do-integration-test-with-go) *。*

# 本条的目的

关于这个主题已经有很多文章了(查看本文末尾的参考资料列表)。这并不是试图在现有的基础上进行改进。它试图展示如何在本地和外部(CI env)设置和配置可扩展和可移植的集成测试。我确信有很多方法可以改进我将要在这里展示给你的东西，但是，主要的目标是为你提供构建一个伟大的测试套件的工具。一旦你理解了这些概念和配置，根据你的需要定制它们就容易多了。此外，你对谷歌搜索什么有了一个更好的想法(未知的未知是一个棘手的问题)，所以你可以解决你自己的问题，这些问题可能会在以后出现。

## 要求

好吧，首先。您将需要一些工具，因此请安装并设置以下内容:

*   去
*   码头工人
*   附带存储库的本地副本(在此处找到

# 剥猫皮的方法不止一种

就像软件中的所有东西一样，做同样的事情有很多方法，甚至关于如何做这件事情有更多的观点。对于集成测试，我们可能会讨论如何设置/配置测试套件，使用什么库(如果有的话),甚至什么时候可以归类为集成测试、单元测试、E2E 测试等等。这会让概念变得比需要的更复杂，尤其是当你刚刚开始的时候。我认为处理这种情况的最好方法之一是就某种指导原则/首要原则达成一致，这将成为我们工作的基础。我发现最好的原则之一是:

> *测试行为，不实施细节*

为了扩展这一点，我们想让我们的测试覆盖用户可能如何实际使用我们软件的案例/场景。我在这里非常广泛地使用用户和软件这两个术语，因为它是非常上下文相关的。用户可能是调用我们创建的代码库中的某个方法的同事，也可能是使用我们的 API 的人。我们的测试不应该真的担心我们实际上是如何实现代码的，只需要考虑给定 X 输入，我们会看到 Y 响应。从某种意义上来说，我们是在测试我们作为开发人员通过向世界公开我们的代码/功能/方法而达成的“契约”是否真的得到了遵守。

如果我们想要一个更具体的集成测试定义，我们可以重温一下谷歌的大书，看看他们是如何定义的:

> *…中等范围的测试(通常称为集成测试)旨在验证少量组件之间的交互；例如，在服务器和数据库之间*
> 
> 来源:谷歌软件工程，第一章。11

如果我们从 [clean architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) 中借用一些术语，我们可以认为当我们在测试中包含来自基础设施层的代码时，我们就处于集成测试领域。

# 我们在做什么

当我开始用 Go 编写集成测试时；我最纠结的是如何为现实世界的使用配置和设置它。同样，这也会因开发人员/用例/现实而异，因为这种方法可能不适合大型跨国公司。我的集成测试标准是，它们应该跨不同的操作系统运行，易于运行，并且与 CI/CD 工作流配合良好(基本上，在 dockerized 环境中配合良好)。

我是 YAGNI 的坚定信徒(你不会需要它)，所以我将向你展示两种设置集成测试的方法:

*   传统的只使用标准库中的测试包的方法
*   使用图书馆方法(stretchr/evidence)

这应该有望说明如何开始相对简单(我们可以跳过 Docker 部分，但老实说，这将使建立我们的 CI/CD 流变得有点棘手)，然后根据需要添加。

# 我们正在测试什么

我将重用我那篇关于如何构建 Go 应用的文章中的一些代码(可以在[这里](https://blog.mortenvistisen.com/posts/a-practical-approach-to-structuring-golang-applications)找到)。如果你还没有看过，它基本上建立了一个小应用程序，让你在锁定期间跟踪你的体重增加。这篇文章应该更新了(我建议查看这个 [repo](https://github.com/bnkamalesh/goapp) ，它是一个关于如何使用 DDD 和 clean architecture 构建 Go 应用程序的很好的例子)，所以我们将专注于添加基于代码的集成测试(测试行为与实现细节的一个很好的例子)。我们希望确保对我们服务的调用按预期方式运行。

你可以在这里找到回购[。](https://github.com/MBvisti/integration-test-in-go)

# 基础设施设置

许多现代 web 开发都使用 Docker，本教程也不例外。这不是 Docker 的教程，所以我不会详细介绍设置，但会提供一些入门的基础。通过扩展 docker-compose 文件，在 docker 文件中使用标签等等，有很多方法可以改进这种设置。但我经常发现这让我头疼多于收获。在某种程度上，我们违反了 DRY，但是它确实给了我们拥有完全独立的开发和测试环境的能力。读完这篇文章后，你可以自己尝试缩短 docker 的设置。

## Docker 测试环境设置

有了这些，我们现在可以轻松地运行我们的集成测试，这可以通过:

```
make run-integration-tests
```

# 方法 1:普通设置

*边注:如果你想看到与其余部分分开的代码，查看分支* `*vanilla-approach/running-integration-tests-using-std-library*`

Go 社区有一种倾向，更倾向于标准库，而不是引入外部库。有一个很好的理由，你可以只用标准库做很多事情。在这方面，我绝不是纯粹主义者，我们也使用外部库进行路由、迁移等。这里，但是我认为它通过从标准库开始，然后使用其他库，给出了正在发生的事情的一个很好的理解。

在早期阶段，我们启动并运行了基础设施，因此我们有了一个活动的数据库、一个正在运行的应用程序，或者在这种情况下，有可能触发针对我们的应用程序的测试运行。

为了最大化我们对代码的信心，我们希望我们的集成测试尽可能模拟我们的生产环境。这意味着我们需要一些安装和拆卸功能来运行迁移，用种子数据填充数据库，并在测试后拆除所有东西，这样我们每次都有一个干净的环境。最后一部分很重要，因为我们想要一个可靠的测试环境，所以我们不希望之前运行的测试影响当前运行的测试。

这里值得注意的是，这也意味着我们的集成测试必须顺序运行，而不是并行运行，因为我们最有可能让我们的单元测试这样做，这意味着运行测试套件需要更长的时间。在开始时，我不会太担心这个问题，只是简单地关注一些具有良好覆盖率的集成测试。一旦你开始进行难以忍受的长时间集成测试，那么是时候开始研究其他设置/改进当前的设置了。例如，我们可以为每个测试创建一个新的数据库并使用它，但是这会增加一个更复杂的设置。或者，我们可以使用 SQLite 数据库进行集成测试，但同样，一旦你到达那里，就要跨过那座桥。

尝试修改这些代码，尝试不同的策略来加速测试运行，这将是一个很好的练习。

# 迁移

我是 golang-migrate 库的忠实粉丝，所以我们将使用它来编写我们的迁移。简而言之，它生成向上/向下迁移对，并将每次迁移视为一个新版本，因此如果需要，您可以回滚到上一个工作版本。

这里我不打算讨论迁移策略，所以我们编写测试时会假设我们有一个包含所有最新迁移的数据库。为了在我们的测试中实现这一点，我们将在每次测试运行之前运行 up 版本。为此，我们需要以下函数:

测试结束后，我们希望环境干净，所以我们也需要这个函数:

基本上，我们获得一个到数据库的新连接，创建一个新的 migrate 实例，其中我们传递一个到 migrations 文件夹、我们使用的数据库和驱动程序的路径。然后，我们运行迁移并再次关闭连接，这非常简单。

接下来，我们需要数据库中的一些数据来运行我们的测试。我非常喜欢将它保存在一个 SQL 文件中，然后让一个助手函数对数据库运行 SQL 脚本。为此，我们只需要一个类似于上面两个的函数:

有了这个设置，我们就可以编写我们的第一个测试了。

# 我们的第一个测试

从技术上讲，我们可以通过提供 database/SQL 包中方法的模拟版本来测试与数据库交互的代码。但是这并没有给我们太多的信息，因为模拟一个场景是很棘手的，比如，你在你的。扫描方法或有一些语法问题。因此，我倾向于为我所有的数据库功能编写集成测试。让我们为 CreateUser 函数添加一个测试。我们需要以下内容:

我们首先创建一个新的 config 和 storage 实例(就像在 main.go 中运行整个应用程序一样)，然后运行 up migrations 功能。如果不出什么差错，我们应该有类似于生产中的*东西*。

然后，我们使用刚刚设置的存储实例来创建一个新用户，打开一个新连接来查询我们刚刚创建的用户，并验证所述用户是使用我们期望的值创建的。之后，使用测试包提供的清理功能来调用向下迁移。这基本上清除了数据库。

您可能注意到的另一件事是，我们有一个 psql_test.go 文件。打开它，你会发现下面的功能:

TestMain 是一个特殊的函数，在它所在的包中的所有其他测试之前被调用。在这里，我们变得(我认为是合理的)偏执，并调用一个函数来删除数据库中的所有内容，这样我们就可以确信我们是从一张白纸开始。如果你想仔细看看，可以在`repository/psql.go`中找到这个函数。

这就是对我们的数据库功能运行集成测试的基本内容。我们可以在这里使用表驱动测试，也许应该这样做，但这只是为了说明的目的。如果你不知道表格驱动测试，请看[这里](https://dave.cheney.net/2019/05/07/prefer-table-driven-tests)的解释。接下来，让我们做一个“适当的”集成测试，并确保我们的端点按预期工作！

# 测试我们的端点

现在我们进入了实质内容。我们已经达到(或至少更接近)谷歌旧书中的定义。我们正在测试我们代码的多个部分是否能够协同工作，主要是在基础设施层，以我们期望的方式协同工作。在这里，我们希望确保无论何时我们的 API 接收到一个请求，该请求正在履行我们作为开发人员发布的合同，它做我们想要做的。也就是说，我们想要测试快乐路径。理想情况下，我们还想测试 sad 路径(不确定是否是这个词，但这是我的文章，所以现在是),但集成测试更“昂贵”,所以这是一个微妙的平衡。您可以选择模拟数据库响应，并以一种更加单元测试的方式测试 sad 路径，或者您可以添加集成测试，直到运行测试套件所需的时间变得无法忍受。我可能会犯错误，将一个集成测试添加到多个测试中，并在“成本”变得太大时处理它。

好了，说够了。让我们开始吧。这里有一个旁注；我正在使用 gofiber，它的灵感来自于 express，Node web 框架。我设置 POST 请求的方式取决于 gofiber 的工作方式。我之所以这么说，是因为从 Go 发送 post 请求的基础是使用封送处理。当我们谈到它的时候，我会指出来，但是请注意，如果你喜欢大猩猩或杜松子酒，你可能需要谷歌一下。

# 路由器设置的快速概述

我们不会在这上面花太多时间，因为你可以在回购中找到代码。基本上，我们有这个:

我们设置了一个 HTTP 结构，它有一些依赖关系来启动我们的服务器并运行路由器。在这个结构上，我们定义了一些特定于服务器的方法。这很简单。

# 测试我们的端点以创建新用户

我们的终点非常简单。没有中间件和认证，每个人都可以向我们的服务器发送垃圾请求，并创建大量用户。这并不理想，但也不是我们现在真正关心的。我们只想确保我们的 API 做它应该做的事情。

大部分内容看起来与我们在存储库测试中的内容相似。我们设置数据库、服务，最后是服务器。我们创建一个请求，对其进行编码，将其发送到我们的端点并检查响应。这里要注意的一件重要事情是，我们并不真正知道在这个怪兽的引擎盖下发生了什么。我们只知道我们发送了一个带有一些数据的请求，它返回 OK 并在数据库中创建一个带有预期数据的用户。这也被称为黑盒测试。我们不关心这是如何做到的，我们关心的是预期的行为会发生。

关于上面的代码，有一点是，在我们如何设置测试以及每次运行后如何拆除测试中，有相当多的重复性。如果我们不必复制粘贴所有这些，并在每次测试运行后洗一个长时间的热水澡，那就好了，因为我们违反了 DRY。当然，我们可以自己来做，或者我们可以使用**方法 2——使用带有 evidence**的测试套件。

# 方法 2——使用 evidence 运行我们的集成测试

为此，我们将使用我已经使用了相当一段时间的证明包。这对我们的主要作用是节省一些配置行，并确保我们的测试套件的一致性。当只有这么大时，很容易在头脑中记住整个代码库，但是随着它的增长，在一个地方完成设置和配置会使事情变得容易得多。让我们看看如何为我们的处理程序集成测试进行设置:

我们基本上采取了整个设置步骤，并对每个测试套件进行了自动化。如果我们查看 SetupSuite 方法的文档，我们会发现它基本上是一个在测试运行之前运行的方法。所以我们用标准库做的整个设置是这样的:

对我们来说是自动化的，很好！现在，我们也有一些其他的需求，也就是说，我们有一个“新鲜的”环境用于每次测试运行。这意味着我们需要运行向上/向下迁移来确保我们的数据库是干净的。这是在*每个*测试之前的设置和拆卸部分完成的，但是有了 evidence，我们可以只定义`beforeTest`和`afterTest`，在这里我们可以像以前一样运行相同的方法，而不必为每个测试复制粘贴它们。

如果你查看回购协议，你会注意到一件事，那就是我们在仓库中拥有与这里几乎完全相同的代码。只有结构中的 TestRouter 除外。我真的不介意这里的重复，因为我对端点测试的需求在未来可能会改变，尽可能少地保持我的依赖性是可取的。所以如果你愿意，你可以做一个大型的集成测试套件。我只是喜欢把事情分开，各做各的。

# 最后

以上步骤会让你避免我们在文章开头经历的灾难吗？可能吧，看情况(每个资深开发者最喜欢的回答)。但是，它肯定会增加您对代码的信心。有多少集成测试总是一个平衡，因为它们确实需要更长的时间来运行，但是有办法解决这个问题，所以测试快乐的路径直到事情变得令人无法忍受的慢是一个好的经验法则。当你到达那座桥的时候，穿过它。

正如在介绍中提到的，这并不是试图添加一些新的东西，并彻底改变我们在 Go 社区中进行集成测试的方式。而是给你另一个视角和一些样板代码来开始你的集成测试之旅。如果您想继续并向比我聪明得多的人学习(您肯定应该这样)，请查看参考资料部分。

## 关注我的社交活动

我的[推特](https://twitter.com/mbvisti)，自己的[博客](https://blog.mortenvistisen.com)和 [GitHub](https://github.com/MBvisti/) 。

# 资源

[学习 go with tests](https://quii.gitbook.io/learn-go-with-tests/)——基本上读完整本书。Chris 做了一件了不起的工作，向您展示了如何开始 Go 和测试驱动开发。绝对值得一读。

HTML 表单、数据库、集成测试——虽然它不在 Go 中，但在 Rust 中，Luca 很好地解释了集成测试。总是试图寻找哪些概念超越了编程语言，哪些没有。有一个细致入微的观点总是有益的。