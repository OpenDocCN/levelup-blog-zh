<html>
<head>
<title>I released vaporware.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我释放了蒸汽。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/i-released-vaporware-c1850e6a9c5d?source=collection_archive---------3-----------------------#2022-11-21">https://levelup.gitconnected.com/i-released-vaporware-c1850e6a9c5d?source=collection_archive---------3-----------------------#2022-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/abf96845764e8baa3f7368f165c49796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJfklwC2OfY5cSZHLlwRMw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Boitumelo Phetla在<a class="ae kf" href="https://unsplash.com/photos/viS6-ja0dCw" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="0450" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Vaporware是已经做了广告但还不能使用的软件或硬件。显然，发布vaporware并不是一件值得骄傲的事情。然而我却意外地做到了。你可以从我的错误中吸取教训，以便不犯同样的错误。所以这是它是如何发生的，我是如何解决的。</p><p id="e305" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2022年3月1日，我开始创建<a class="ae kf" href="https://github.com/switchupcb/disgo" rel="noopener ugc nofollow" target="_blank"> Disgo </a>，一个设计灵活、高性能、安全和线程安全的Discord API包装器。Disgo的目标是提供Discord API中的每一个特性，以及可选的速率限制、结构化日志、分片管理和缓存……然而，当时有一个问题:<em class="le">我还没有提交一行代码。相反，我创建了一个自述文件，概述了我对Disgo的愿景。我想到了什么？</em></p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="f7d8" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">设计文件</h1><h2 id="ae20" class="mk ln it bd lo ml mm dn ls mn mo dp lw kr mp mq ma kv mr ms me kz mt mu mi mv bi translated">要求</h2><p id="7476" class="pw-post-body-paragraph kg kh it ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">为了使用大多数API包装器，您必须了解三件事情。</p><ol class=""><li id="21ae" class="nb nc it ki b kj kk kn ko kr nd kv ne kz nf ld ng nh ni nj bi translated">编程语言</li><li id="31a4" class="nb nc it ki b kj nk kn nl kr nm kv nn kz no ld ng nh ni nj bi translated">消费者的API(库)</li><li id="ec21" class="nb nc it ki b kj nk kn nl kr nm kv nn kz no ld ng nh ni nj bi translated">生产者的API(不和谐)</li></ol><p id="c010" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为大多数程序员开始使用函数来创建库:比如发送消息的函数是<code class="fe np nq nr ns b">ChannelMessage(…)</code>，而响应交互的函数是<code class="fe np nq nr ns b">InteractionRespond(…)</code>。每个函数都有自己的参数，这需要您阅读库的文档来了解如何完成每个任务。</p><p id="b582" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是对时间的巨大浪费和不必要的复杂。</p><p id="7592" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Disgo使用单个函数发送HTTP请求<em class="le">(没有类型断言或泛型)</em>。</p><pre class="nt nu nv nw gt nx ns ny bn nz oa bi"><span id="eb1e" class="ob ln it ns b be oc od l oe of">Send(*Client)</span></pre><p id="0dd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">就这样。</strong>容易记忆，更容易使用。这个函数总是维护一个参数:发送请求的客户端。但是，您仍然需要一种方法来指定实际发送的是什么数据。如果不使用函数来做这件事，有什么替代方法？结构。</p><pre class="nt nu nv nw gt nx ns ny bn nz oa bi"><span id="b4b6" class="ob ln it ns b be oc od l oe of">// Create a Create Global Application Command request.<br/>request := disgo.CreateGlobalApplicationCommand{<br/>  Name: "main",<br/>  Description: "A basic command.",<br/>  ...<br/>}<br/><br/>// Send the request.<br/>command, err := request.Send(bot)</span></pre><p id="a6b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个结构维护一个人发送有效请求所需的所有数据。这包括URL查询字符串参数、JSON字段和文件。这样，开发人员只需了解两件事就可以使用Disgo。</p><ol class=""><li id="e836" class="nb nc it ki b kj kk kn ko kr nd kv ne kz nf ld ng nh ni nj bi translated">如何在Go中创建结构？</li><li id="eabf" class="nb nc it ki b kj nk kn nl kr nm kv nn kz no ld ng nh ni nj bi translated">如何使用Discord API？</li></ol><p id="9233" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不再浪费时间学习API消费者的实现细节。<strong class="ki iu">我是怎么做到的？在Disgo <code class="fe np nq nr ns b">v0.10.0</code>发布之前，我没有。这就是问题所在:整个图书馆只是一个正在进行的设计。这导致了很久以后的一次事故。</strong></p><h2 id="a991" class="mk ln it bd lo ml mm dn ls mn mo dp lw kr mp mq ma kv mr ms me kz mt mu mi mv bi translated">事件</h2><p id="f079" class="pw-post-body-paragraph kg kh it ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">其他Go库使用类型断言或泛型将来自Discord的JSON事件数据翻译成开发人员在运行时可以引用的实际Go对象。Disgo没有。结果就快多了。当然，这只是在Disgo <code class="fe np nq nr ns b">v0.10.0</code>发布之前理论上的真实情况。这个特性的实现将在本文后面讨论。</p><p id="4f26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"> Disgo还维护自动意图计算；这是其他图书馆没有的功能。</em></p><h2 id="27e1" class="mk ln it bd lo ml mm dn ls mn mo dp lw kr mp mq ma kv mr ms me kz mt mu mi mv bi translated">贮藏</h2><p id="7bd0" class="pw-post-body-paragraph kg kh it ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">决定使用可选缓存背后的文档直到后来才发布:<a class="ae kf" href="https://github.com/switchupcb/disgo/issues/39" rel="noopener ugc nofollow" target="_blank"> #39 </a>。不管怎样，这个决定是在设计Disgo时做出的。总之，使用内置于HTTP库中的缓存会增加开销，往好了说是复杂，往坏了说是不正确。</p><h2 id="f96f" class="mk ln it bd lo ml mm dn ls mn mo dp lw kr mp mq ma kv mr ms me kz mt mu mi mv bi translated">更新</h2><p id="8871" class="pw-post-body-paragraph kg kh it ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">Discord API已经发布了6年<strong class="ki iu"/>,然而同样的API仍然以一种有些不稳定的方式持续着许多变化。具体来说，Discord实际上并没有为其API提供文档。相反，社区用于确定API的当前状态并记录下来。此外，在历史上，人们只考虑公司的特性，当一个特性执行不力时，就会引起<a class="ae kf" href="https://gist.github.com/Rapptz/4a2f62751b9600a31a0d3c78100287f1" rel="noopener ugc nofollow" target="_blank">争议</a>。</p><p id="c723" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Discord已经被提示需要一个<strong class="ki iu">机器可读的API </strong>无数次都没有用。使得频繁地对Discord API进行改变，但是没有将这些改变应用于API消费者的有效策略。出于这些原因，Disgo需要能够保持较高的开发速度<em class="le">(在其最初创建期间和之后)。</em></p><p id="340f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">静态代码分析用于维护没有已知安全问题的格式化代码。覆盖大部分Discord API的广泛集成测试也在计划之中。此外，Go有一个数据竞争检测器，它允许我们检测并消除任何潜在的数据竞争或死锁问题。以便Disgo提供可靠的数据竞争保护，而不牺牲并发运行代码的能力。</p><p id="2546" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">最重要的是实现功能完善的目标。有几个图书馆做过，但是都没有用Go。</em></p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="166c" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">实施设计</h1><p id="ea99" class="pw-post-body-paragraph kg kh it ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">Go语言使用JSON标签将字段解组和封送到它的结构中。然而，这意味着区分“空”和“null”是很重要的。当时的主要Go API包装器——DiscordGo——在开发时添加了这些标签，导致Discord API的一些特性在没有fork的情况下无法实现。为了解决这个问题，我们为名为<a class="ae kf" href="https://github.com/switchupcb/dasgo" rel="noopener ugc nofollow" target="_blank"> Dasgo </a>的Discord API创建了一个Go API类型库。这个库是按照规范构建的，并且是<strong class="ki iu">而不是</strong>特定于Disgo的实现；这意味着其他Go API包装器可以将它用于它们的类型。</p><p id="a663" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当Dasgo被很多人使用的时候，Go Discord API包装器的维护者的工作量急剧减少。这是因为对Discord API数据结构的新更改只需要对Dasgo提供的底层Go类型进行更改。Go本身提供了散列版本控制，允许库指定要导入的特定版本或分支。使得人们可以维护多个版本化端点以及不和谐机器人可能使用的每个API版本。</p><h2 id="1c2a" class="mk ln it bd lo ml mm dn ls mn mo dp lw kr mp mq ma kv mr ms me kz mt mu mi mv bi translated">要求</h2><p id="cc4c" class="pw-post-body-paragraph kg kh it ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">设计文档指定了Disgo API如何处理HTTP请求，但是我实际上是如何实现它的呢？提醒一下，我并没有打算使用类型断言或泛型:在Go中，两者都有轻微的性能影响。因此，我不能在<code class="fe np nq nr ns b">Send(*Client)</code>函数中使用结构作为参数。相反，将使用接收器功能。</p><pre class="nt nu nv nw gt nx ns ny bn nz oa bi"><span id="4688" class="ob ln it ns b be oc od l oe of">func (r *CreateGlobalApplicationCommand) Send(bot *Client) (*ApplicationCommand, error) {<br/>  ...<br/>}</span></pre><p id="c0ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，有一个问题。必须为每个请求创建一个这样的接收函数<em class="le">。然而，Discord API维护着<strong class="ki iu"> 176个端点</strong>(不包括构成路线的变化)。我们要做什么？</em>输入<a class="ae kf" href="https://github.com/switchupcb/copygen" rel="noopener ugc nofollow" target="_blank"> Copygen </a>，这是一个基于类型的代码生成器，我创建它是为了创建类型到类型的复制功能。使用Copygen，我能够使用我们在Dasgo中定义的类型为每个请求生成一个<code class="fe np nq nr ns b">Send(*Client)</code>函数。</p><p id="bb82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">最精彩的部分？更新就像运行一个命令一样简单。</em></p><p id="e7be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在创建Disgo时，我还发现当前的速率限制文档具有误导性。在另一篇文章中会有更多的介绍。</p><h2 id="496a" class="mk ln it bd lo ml mm dn ls mn mo dp lw kr mp mq ma kv mr ms me kz mt mu mi mv bi translated">事件</h2><p id="e164" class="pw-post-body-paragraph kg kh it ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">Discord网关是一个TCP WebSocket连接，它在有效负载中发送JSON或二进制数据包。这在JavaScript中很容易使用，因为这种语言是非类型化和解释的。相比之下，Go是静态类型和编译的。因此，其他Go API包装器通过类型断言传入负载来实现事件处理。避免类型断言的唯一方法是将有效载荷直接解组到一个对象<em class="le"> (struct) </em>中。然而，这不是一个简单的任务，因为解组必须同时进行<em class="le">(来自WebSocket连接)</em>，以免阻塞其他事件的处理。</p><p id="23d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更不用说，我们需要为开发者提供一种处理事件的方式。</p><p id="a9e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Disgo中，使用<code class="fe np nq nr ns b">Handle</code>和<code class="fe np nq nr ns b">Remove</code>函数添加或删除事件处理程序。然而，这又是一个代表数百个事件的单一函数。没有使用类型断言，我们是如何做到的？由于在没有事先说明的情况下，您无法确定正在处理的事件，因此需要做出妥协。具体来说，<code class="fe np nq nr ns b">Handle</code>函数不能接受一个单独的事件作为参数，因为这需要使用反射来确定要解组到哪个事件对象。</p><pre class="nt nu nv nw gt nx ns ny bn nz oa bi"><span id="30c5" class="ob ln it ns b be oc od l oe of">// Add an event handler to the bot.<br/>bot.Handle(disgo.FlagGatewayEventNameInteractionCreate, func(i *disgo.InteractionCreate) {<br/>  log.Printf("main called by %s", i.User.Username)<br/>})</span></pre><p id="fe45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，用户传递一个字符串<em class="le">(由Dasgo指定)</em>，它告诉我们哪个事件将被解组。缺点是，如果将不匹配的字符串和事件传递给函数，可能会涉及用户(开发人员)错误。因此，鼓励开发人员处理这些函数的错误，因为错误虽然不太可能发生，但还是会发生。从这一点来看，创建一个goroutine(为开发人员)来解组事件有效负载，并为每个处理程序创建一个goroutine是很简单的。</p><p id="4288" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Copygen <em class="le">用于为事件处理生成所有必要的代码。</em></p><p id="9a26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">网关意图很难处理；尤其是在当前的API包装器中。每次你想处理一个新事件，你必须确保它不需要一个意图。当它出现时，您必须在API包装器指定的任何时间点将该意图添加到您的bot中。那是大量的工作。相反，为了追求无反射事件处理，Disgo能够自动计算开发人员需要的意图。这使得开发人员可以更多地关注机器人的功能，而不是技术细节。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="b224" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">迪斯戈的释放</h1><p id="3876" class="pw-post-body-paragraph kg kh it ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">在完成Disgo的过程中出现了一些复杂情况，导致它以未完成的状态发布。具体来说，Disgo <code class="fe np nq nr ns b">v0.10.0</code>支持使用Discord API提供的每个请求和事件。但是，诸如分片、缓存管理和全面集成测试等功能并没有实现。相比之下，Disgo的愿景致力于主分支。这样任何人都可以阅读它，并在不知不觉中认为它的承诺已经实现。没有考虑它的解释，我做了一个<code class="fe np nq nr ns b">v0.10.0</code>测试版。</p><p id="f643" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">经过所有这些努力，我们得到了什么？</strong></p><h2 id="ae8c" class="mk ln it bd lo ml mm dn ls mn mo dp lw kr mp mq ma kv mr ms me kz mt mu mi mv bi translated">电子邮件</h2><blockquote class="og oh oi"><p id="d7c4" class="kg kh le ki b kj kk kl km kn ko kp kq oj ks kt ku ok kw kx ky ol la lb lc ld im bi translated">“亲爱的SwitchUpCB:</p><p id="7186" class="kg kh le ki b kj kk kl km kn ko kp kq oj ks kt ku ok kw kx ky ol la lb lc ld im bi translated">你的图书馆装饰是一件艺术品…如果它是他妈的作品的话！！！该死的。我浪费了至少三分钟来进口这些垃圾！两个以上的设置示例…才意识到这实际上并没有完成？？？你他妈的CK是怎么了！该死的白痴。也许在事情完成之前不要发表。啊？啊？！那现在怎么办？我要怎么做才能使用这个该死的工具…什么，你是同性恋吗？你知道吗？让我吸你的蛋。让我舔你的小弟弟。让大黄蜂7吸你的蛋吧！让大黄蜂7吸你的D*CK N****。让。大黄蜂7。烂透了。你的。CK！</p><p id="0554" class="kg kh le ki b kj kk kl km kn ko kp kq oj ks kt ku ok kw kx ky ol la lb lc ld im bi translated">谢谢，</p><p id="69e6" class="kg kh le ki b kj kk kl km kn ko kp kq oj ks kt ku ok kw kx ky ol la lb lc ld im bi translated">大黄蜂7”</p></blockquote><p id="eaf1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">是啊…灵感来自</em><a class="ae kf" href="https://youtu.be/l2cDkl_JRTo" rel="noopener ugc nofollow" target="_blank"><em class="le">Filnobep</em></a><em class="le">…而且完全是假的。</em></p><p id="1fdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，没有什么坏事发生。有一个用户最终发现了一个阻止人们使用应用程序命令的主要错误。我提出补偿用户的时间，但他们并不生气。事实上，已经有一份声明指出了<code class="fe np nq nr ns b">v0.10.0</code>的局限性。也许，其他库应该在陷入向后兼容性承诺之前创建设计文档。其结果将是一个像迪斯戈一样伟大的图书馆。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="2d90" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用Disgo</h1><p id="cb04" class="pw-post-body-paragraph kg kh it ki b kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz na lb lc ld im bi translated">在Go中创建一个不和谐Bot:<a class="ae kf" href="https://github.com/switchupcb/disgo/releases/tag/v0.10.1" rel="noopener ugc nofollow" target="_blank">Disgo</a>T3】发布于<strong class="ki iu">2022年11月17日</strong>。</p></div></div>    
</body>
</html>