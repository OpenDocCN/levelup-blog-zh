<html>
<head>
<title>Adapter Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适配器设计模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/adapter-design-pattern-2ca673e72839?source=collection_archive---------5-----------------------#2022-03-01">https://levelup.gitconnected.com/adapter-design-pattern-2ca673e72839?source=collection_archive---------5-----------------------#2022-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d69f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">“改编”这个词意思是适合新的用途。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9d8f173d3a252a6c2ac07e80f4fc3644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IEOF-EGx5jmnoYOg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@maartenwijnants?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的</a>马腾Wijnants拍摄</figcaption></figure><p id="a2fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举一个家里的例子，我们都见过墙上安装的电源插座。关于这些插座有一个奇怪的事实，每个国家都有自己风格的电源插座。这就是为什么智能手机制造商针对不同的国家制造不同风格的充电适配器。</p><p id="2a2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个很好的例子是苹果的超空间引擎。它将如此多的设备连接到一个USB端口。在这里，超光速引擎充当了一个适配器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/3a091752f3eba1d10570244696c1599e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LK4iU_ZJ1JazD8Jx_xL_yA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:超光速引擎雷电3中心</figcaption></figure><p id="c017" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">适配器也称为包装器。因为它包装了可以被不同对象使用的对象。</p><p id="91a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">先看UML。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/d0a0949b8bf40c5dc8dcb0c1b3323c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*YpnrUFV4UpFrUnmjzRDW7w.jpeg"/></div></figure><ol class=""><li id="f37e" class="lu lv iq ky b kz la lc ld lf lw lj lx ln ly lr lz ma mb mc bi translated"><code class="fe md me mf mg b"><strong class="ky ir">client</strong></code> <strong class="ky ir"> </strong>基本上就是想用模式的阶层。调用类。</li><li id="a102" class="lu lv iq ky b kz mh lc mi lf mj lj mk ln ml lr lz ma mb mc bi translated"><code class="fe md me mf mg b"><strong class="ky ir">client</strong></code> <strong class="ky ir"> </strong>想要有<code class="fe md me mf mg b"><strong class="ky ir">Specific_request()</strong></code>只能由<code class="fe md me mf mg b"><strong class="ky ir">class Adaptee</strong></code>来服务，我们可以直接有-有关系就完事了。但问题在于，当有另一个特定的请求由另一个<code class="fe md me mf mg b"><strong class="ky ir">class Adaptee2</strong></code>提供服务时，在这种情况下，我们必须建立另一个HAS-A关系，这可能会随着每个新的需求而重复出现。所以你看到了问题，每次新的请求来了，我们都必须把它映射到客户端类，现在你会争论这种方法有什么问题，如果你对每个请求都这样做，你的代码就不能按照"<a class="ae kv" href="https://medium.com/gitconnected/solid-design-principles-simplified-with-uml-8432a3406248" rel="noopener"> <strong class="ky ir">开闭原则</strong> </a>"我们对修改关闭<strong class="ky ir"><em class="mm"/></strong>"来扩展。</li></ol><p id="619a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi mn translated">那么，我们如何在陷入太多混乱之前度过这一关呢？！</p><p id="60fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了处理这种混乱，我们可以抽象出一个新请求的概念，并让抽象处理客户端发出的请求的委托。在上面的UML中，它是由<code class="fe md me mf mg b"><strong class="ky ir">interface ITarget</strong></code>处理的。</p><p id="a51e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始编码吧。</p><p id="6796" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> E </span> <strong class="ky ir">例如，</strong>假设我们的应用程序从一个XML文件中读取数据，它满足了今天的需求，但是如果明天我们希望我们的应用程序支持JSON，那该怎么办呢？这时我们就可以使用适配器设计模式了。</p><p id="8269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来设计一下这个问题的架构。在下图中，我们有两个类<code class="fe md me mf mg b"><strong class="ky ir">XMLAdaptee</strong></code>和<code class="fe md me mf mg b"><strong class="ky ir">JSONAdaptee</strong></code>，这些类将继承具有抽象方法<code class="fe md me mf mg b"><strong class="ky ir">GetData()</strong></code>的<code class="fe md me mf mg b"><strong class="ky ir">interface IEmployeeDetails</strong></code>，因此我们的类可以使用自己的实现来实现自己的逻辑。</p><p id="8866" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果需要XML格式的结果，<code class="fe md me mf mg b"><strong class="ky ir">class program</strong></code>可以将<code class="fe md me mf mg b"><strong class="ky ir">XMLAdaptee’s</strong></code>实例注入到<code class="fe md me mf mg b"><strong class="ky ir">Adapter object</strong></code>中，或者如果需要JSON格式的结果，它可以传递<code class="fe md me mf mg b"><strong class="ky ir">JSONAdaptee’s</strong></code>实例。</p><p id="a182" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果明天YAML有另一个需求，那么我们可以简单地创建类<code class="fe md me mf mg b"><strong class="ky ir">YAMLAdaptee</strong></code>并在<code class="fe md me mf mg b"><strong class="ky ir">GetData() method</strong></code>中编写它自己的逻辑。</p><p id="63f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的UML看起来的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/02d03bb9228ea8cd835138f88c38753d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuex8QNRSGRFmqZRKNGwoA.jpeg"/></div></div></figure><p id="423d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个将被我们的客户端调用的<code class="fe md me mf mg b"><strong class="ky ir">interface ITarget</strong></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="caa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，<code class="fe md me mf mg b"><strong class="ky ir">class Adapter</strong></code>，</p><p id="ddd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将实现<code class="fe md me mf mg b"><strong class="ky ir">ITarget</strong></code>:这个类也有<code class="fe md me mf mg b"><strong class="ky ir">interface IEmployeeDetails</strong></code>:这个接口将由我们两个XML &amp; JSON适配器实现，以保持两个类中相似的架构，所以我们的客户端代码不会改变。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ad47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个<code class="fe md me mf mg b"><strong class="ky ir">interface IEmployeeDetails</strong></code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dd1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安<code class="fe md me mf mg b"><strong class="ky ir">class employee</strong></code>和<code class="fe md me mf mg b"><strong class="ky ir">entity:</strong></code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5fdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">加载xml数据的一个<code class="fe md me mf mg b"><strong class="ky ir">class XMLAdaptee</strong></code>。目前，我们可以从代码本身生成数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ee35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，<code class="fe md me mf mg b"><strong class="ky ir">class JSONAdaptee</strong></code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b2b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，我们的来电者<code class="fe md me mf mg b"><strong class="ky ir">class program</strong></code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ca5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">XML数据的输出:<code class="fe md me mf mg b"><strong class="ky ir">program.cs</strong></code>中的第15行</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/82752cfaf43a7d0417d2be3515d3385a.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*NOTWasJrzYpTiLu-pD7FKA.png"/></div></figure><p id="da7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于JSON数据的输出，只需取消代码中上述行的注释即可。<code class="fe md me mf mg b"><strong class="ky ir">program.cs</strong></code>中的第18行</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/75fe1495d2f757a51e784eba183b76a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0h6eV1mfv4nhGegd7E3VA.png"/></div></div></figure><p id="9e22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完美！我真诚地希望您喜欢这篇文章，并希望您受到启发，将所学知识应用到自己的应用程序中。谢谢你。</p><p id="ef6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！！</p><p id="f6d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Linkedin上找到我</p><div class="nb nc gp gr nd ne"><a href="https://www.linkedin.com/in/rikampalkar/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">Rikam Palkar -软件工程师-小天鹅-威德福| LinkedIn</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">通过编写可伸缩的代码让世界变得更美好。我从来没有在大学里发现我对编码的热情，也没有在…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">www.linkedin.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns kp ne"/></div></div></a></div></div></div>    
</body>
</html>