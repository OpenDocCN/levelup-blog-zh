<html>
<head>
<title>JavaScript Antipatterns — Immediate Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript反模式—即时函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-antipatterns-immediate-functions-3603dd64c5e5?source=collection_archive---------23-----------------------#2020-06-01">https://levelup.gitconnected.com/javascript-antipatterns-immediate-functions-3603dd64c5e5?source=collection_archive---------23-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/808ca01b6d0d4483b27845d9f34ee9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mqF2RDBF_xX30Rl3"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@jipy32?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">让-菲利普·德尔伯格</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="9b84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript让我们可以做很多事情。它的语法有时过于宽容。</p><p id="9766" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些在定义和使用函数时应该避免的反模式。</p><h1 id="c6ca" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">返回函数</h1><p id="d609" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中返回函数是可能的，因为函数只是普通的对象。</p><p id="cea0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以定义一个返回另一个函数的函数，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9d4f" class="mq lf it mm b gy mr ms l mt mu">const foo = () =&gt; {<br/>  return () =&gt; {<br/>    console.log('bar');<br/>  }<br/>}</span></pre><p id="42b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在上面的函数中返回一个记录<code class="fe mv mw mx mm b">'bar'</code>的函数。</p><p id="2bec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用<code class="fe mv mw mx mm b">foo</code>返回函数就可以调用它。那么我们可以称之为:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bddb" class="mq lf it mm b gy mr ms l mt mu">const bar = foo();<br/>bar();</span></pre><h1 id="8e15" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">自定义函数</h1><p id="4be3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们把一个函数赋给一个已经有函数的变量，那么旧的函数会覆盖现有的函数。</p><p id="0c54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a5d9" class="mq lf it mm b gy mr ms l mt mu">let foo = () =&gt; {<br/>  console.log("foo");<br/>  foo = () =&gt; {<br/>    console.log("bar");<br/>  };<br/>};</span></pre><p id="8fbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们调用它两次，我们会得到两个不同的结果:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ff06" class="mq lf it mm b gy mr ms l mt mu">foo()<br/>foo()</span></pre><p id="3c3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们会得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="818f" class="mq lf it mm b gy mr ms l mt mu">foo<br/>bar</span></pre><p id="ce74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在控制台日志输出中。</p><p id="85b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，即使我们能够做到，它在大多数情况下可能也不是很有用。</p><h1 id="f003" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">即时功能</h1><p id="a6e5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们还可以定义立即调用的函数表达式(IIFEs ),即立即创建并调用的函数。</p><p id="ab78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样写生活:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b058" class="mq lf it mm b gy mr ms l mt mu">(() =&gt; {<br/>  console.log('foo');<br/>})();</span></pre><p id="7ded" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个用括号括起来的匿名函数。</p><p id="2f1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过在末尾加上括号来调用它。</p><p id="af27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就不必创建一个命名函数并在其他地方调用它。</p><p id="ca5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创造生命的模式如下:</p><ul class=""><li id="146a" class="my mz it ki b kj kk kn ko kr na kv nb kz nc ld nd ne nf ng bi translated">使用函数表达式或箭头函数定义函数</li><li id="181a" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated">在末尾添加一组括号，使函数立即运行。</li><li id="167a" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated">用括号将整个函数括起来</li></ul><p id="6d50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很有用，因为我们可以有外部无法访问的变量。</p><p id="92df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也可以作为一个模块，因为它可以返回函数内部的内容。</p><p id="ee34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以将返回值赋给一个变量。</p><p id="6443" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，现在我们有了模块，我们可以使用它们而不是使用IIFEs来隐藏私有变量。</p><p id="1d7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">IIFEs的一个很好的用途是，我们可以在它被定义后立即用它来调用异步函数。</p><p id="73b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a5cd" class="mq lf it mm b gy mr ms l mt mu">(async () =&gt; {<br/>  const val1 = await promise1;<br/>  //...<br/>  const val2 = await promise2;<br/>  //...<br/>})();</span></pre><p id="b566" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以使用异步函数，而无需定义命名函数。</p><h1 id="7c1b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">立即函数的参数</h1><p id="0c71" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">即时函数也可以像其他函数一样接受参数。</p><p id="65ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以添加参数并按如下方式使用它们:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7d17" class="mq lf it mm b gy mr ms l mt mu">((firstName, lastName) =&gt; {<br/>  console.log(`${firstName} ${lastName}`);<br/>})('joe', 'smith');</span></pre><p id="fa14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参数在生命结束时被传入，并立即使用这些参数运行函数。</p><p id="4f4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们从控制台日志输出中得到<code class="fe mv mw mx mm b">‘joe smith’</code>。</p><p id="aa28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用IIFEs以安全的方式访问全局对象。</p><p id="34ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它让我们通过在顶层使用<code class="fe mv mw mx mm b">this</code>来访问全局变量。</p><p id="c7ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="10e2" class="mq lf it mm b gy mr ms l mt mu">const global = ((global) =&gt; {<br/>  return global<br/>})(this);</span></pre><p id="5cb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从外部传入<code class="fe mv mw mx mm b">this</code>，所以我们可以使用一个箭头函数来返回<code class="fe mv mw mx mm b">global</code>参数。</p><p id="68ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在浏览器中，<code class="fe mv mw mx mm b">this</code>应该是<code class="fe mv mw mx mm b">window</code>对象。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/17d14493767d409bc2116219c34bb48d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aQ3Mio-_PJFtoI2D"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">奥马尔·弗洛雷斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7429" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">立即函数的返回值</h1><p id="92b8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以像之前看到的那样从生活中返回值。</p><p id="1c1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="73c6" class="mq lf it mm b gy mr ms l mt mu">const result = (() =&gt; {<br/>  return 1 + 2;<br/>})();</span></pre><p id="b65a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将看到3被赋给了<code class="fe mv mw mx mm b">result</code>,因为我们调用了函数并立即返回值。</p><p id="275c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它对于存储私有数据同时返回其他数据也很有用。</p><p id="6864" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9ab8" class="mq lf it mm b gy mr ms l mt mu">const result = (() =&gt; {<br/>  let x = 1;<br/>  return x + 2;<br/>})();</span></pre><p id="0282" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到同样的结果。<code class="fe mv mw mx mm b">x</code>在功能外部不可用。</p><p id="fab9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">IIFEs也可以用来定义对象属性。</p><p id="be98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="396a" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  message: (() =&gt; {<br/>    const who = "me",<br/>      what = "call";<br/>    return `${what} ${who}`;<br/>  }()),</span><span id="618a" class="mq lf it mm b gy nn ms l mt mu">  getMsg() {<br/>    return this.message;<br/>  }<br/>};</span></pre><p id="f1c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mv mw mx mm b">message</code>是<code class="fe mv mw mx mm b">'call me'</code>由于模板的值，字符串是由IIFE返回的。</p><p id="2db1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">getMsg</code>是一样的，因为<code class="fe mv mw mx mm b">this</code>是<code class="fe mv mw mx mm b">obj</code>而<code class="fe mv mw mx mm b">message</code>是<code class="fe mv mw mx mm b">'call me'</code>。</p><h1 id="1daf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="4a06" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用IIFEs来存储私人数据。同样，我们可以用它们来返回我们想要的东西。</p><p id="ce97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们对于运行异步函数也很方便，无需定义命名函数。</p><p id="8ed9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们像其他函数一样接受参数。</p><p id="13e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数也可以返回其他函数。</p></div></div>    
</body>
</html>