<html>
<head>
<title>Flask: A Flexible Micro-Framework for Backend Dev in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">flask:Python中后端开发的灵活微框架</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flask-a-flexible-micro-framework-for-backend-dev-in-python-9cfaf1114095?source=collection_archive---------4-----------------------#2020-06-07">https://levelup.gitconnected.com/flask-a-flexible-micro-framework-for-backend-dev-in-python-9cfaf1114095?source=collection_archive---------4-----------------------#2020-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="968a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">打造紧凑型大功率服务器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d05765b48465de3b45d553909ad62617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BnJl3worSrIfaJfhSPgu2Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/@guilhermestecanella" rel="noopener ugc nofollow" target="_blank">古伊列梅·斯特卡内拉</a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="cd1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你还没有读过我以前的文章，让我以一个简短的个人声明作为这篇文章的序言:我是一个数据迷，当然也是一个图形爱好者——我的朋友和同事会衷心地证明这一点。</p><p id="1f3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我的兴趣，我经常发现自己在项目中使用数据表。Excel表格、CSV文件、SQL表格……你明白了。例如，在过去的两到三年里，我在一张我高度保密的个人财务表上对每一笔交易进行了跟踪和分类。</p><p id="e3ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你认为我完全疯了之前，这比听起来容易。大部分工作只是从我的卡提供商那里下载交易数据，并将其放入一个正在进行的表中。非常简单。然而，几周前，我的朋友给了我一个好主意，让我建立一个应用程序来进一步自动化我的追踪。当时我正在寻找我的下一个项目，所以这听起来像是一个很好的机会来建立一些我个人可以利用的东西。</p><p id="bd8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我想到数据表操作时，我会想到Python。特别是Pandas和Numpy库，它们是当今最强大的数据分析和表格操作工具包。这个项目会给我一个极好的机会去探索两者的能力。</p><p id="0ed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是这样的:我想用React构建我的GUI(主要是出于熟悉)，当时我唯一有经验的后端框架是Ruby on Rails框架。强迫Rails后端与Python脚本接口，虽然可能是一个有趣的项目，但会非常复杂，而且对我试图做的事情来说完全没有必要。因此，我决定使用一个用Python编写的后端框架来充分利用一个更适合我所想的工作的工具包。</p><h1 id="0ad5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我的解决方案:Flask Python框架</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/6c1244b74057d61649cd7b1dfc996a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*K5teGZsxHzreleIAWNRJSg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">烧瓶标志和座右铭</figcaption></figure><p id="e746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Flask是用Python语言进行web开发的微型框架。微框架的具体含义是，在项目开发的开始阶段，它几乎没有可用的特性和样板代码。这并不是说Flask框架没有可用的特性库和插件库，但是默认情况下，Flask会倾向于<em class="ml">而不是</em>包含一个特性，除非你作为开发人员另有说明。</p><p id="e87c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与Rails或Django(后者是另一个非常流行的Python web框架)等框架有很大的不同，在这些框架中，为您创建项目提供了大量的特性和便利。例如，这两个框架都提供了一个数据库抽象层，允许开发人员通过对象模型轻松地读写数据库(例如，Rails通过活动模型，Django通过其对象关系映射器)。</p><p id="39b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">微框架的缺点显然是在启动时缺乏这些特性。更广泛的框架中的许多(如果不是全部)特性都存在于Flask库中，但是它们必须被显式包含。然而，最大的好处是，如果你不打算使用这些特性，那么制作一个Flask应用程序会容易得多，而且不需要删除大量不必要的文件和依赖项。微框架应用程序的代码膨胀要少得多，并且总是可以根据需要使用额外的工具进行扩展。</p><p id="3d8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于我的目的，我的后端只需要是一个API，用于读写数据文件，并返回格式化的JSON对象。事实上，我甚至不需要数据库。在我的例子中，Flask micro框架更容易实现，并为我提供了根据需要包含更多Python模块的灵活性。</p><h2 id="1184" class="mm lt iq bd lu mn mo dn ly mp mq dp mc lf mr ms me lj mt mu mg ln mv mw mi mx bi translated">设置它:</h2><p id="d112" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">设置flask服务器非常简单。首先，您需要将flask模块安装到您选择的python环境管理器中。</p><p id="c72a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您激活的环境中，创建一个新文件(命名为app.py是Flask期望的缺省值),并在其中键入以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e108" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！在六行代码中，我们已经为一个正在运行的Flask服务器编写了足够的代码。就这么简单。此时在命令行中键入“flask run”将启动一个服务器，在根域中有一条路由返回字符串“Hello，World！”。Flask解释路由请求，并运行为该特定路由编写的函数。该函数的返回值是作为对URL请求的响应返回的内容，但是我们将在后面更详细地探讨请求响应。</p><p id="8218" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个六行服务器主要展示了Flask作为一个微框架的强大功能；我们可以用极少量的代码生产一个运行中的服务器，并根据需要添加。然而，这个服务器远远没有用，它需要更多的功能来运行我们所需要的功能，所以让我们概述一下Flask的一些内置功能，看看我们可以构建什么。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="6ae2" class="ls lt iq bd lu lv nm lx ly lz nn mb mc jw no jx me jz np ka mg kc nq kd mi mj bi translated">按指定路线发送</h1><p id="ba6f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Flask提供了一个完整的接口来控制路由，包括标准路由、动态URL和URL参数。</p><h2 id="b65f" class="mm lt iq bd lu mn mo dn ly mp mq dp mc lf mr ms me lj mt mu mg ln mv mw mi mx bi translated">标准路由:</h2><p id="4ba7" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">可以使用route decorator手动包含路由，将URL指向控制器函数以获得唯一的响应值。例如，手动写出多条路线可能如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6b7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，请注意，可以使用可选的方法参数明确告知路由它们接受什么类型的请求。这样，可以完全控制和定制路由响应，以满足应用程序的需要。</p><h2 id="1bdb" class="mm lt iq bd lu mn mo dn ly mp mq dp mc lf mr ms me lj mt mu mg ln mv mw mi mx bi translated">参数:</h2><p id="e68c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">还可以包括动态URL参数。当接收到一个请求时，Flask能够解析一个URL并提取可以用来控制请求响应的参数。例如，可以向/users/*username_here*发出请求，该请求可以根据提供的URL slug定位用户的数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1bcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码将把URL中提供的任何用户名传递给get_data函数，为不同的用户返回适当的值。</p><h2 id="18d7" class="mm lt iq bd lu mn mo dn ly mp mq dp mc lf mr ms me lj mt mu mg ln mv mw mi mx bi translated">参数:</h2><p id="aa09" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">与参数类似，Flask可以读取为附加规范传递的URL参数。它从请求对象获取参数值，这是Flask框架的一个可选特性。请确保您还从“flask”模块和“Flask”构造函数一起导入了“request”。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9fd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，上面的代码可以向数据库查询给定用户在URL参数中传递的日期范围内的帖子。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="c070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些特性，Flask为框架内置的URL响应提供了充分的灵活性，并且所有这些特性仍然完全可以从单个文件中管理。</p><h1 id="57bb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">跨产地资源共享(CORS)</h1><p id="f300" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">默认情况下，Flask遵循CORS约定，这意味着在没有额外设置的情况下，正在运行的Flask服务器将只响应来自运行该服务器的同一个域的请求。这对于用来提供HTML视图的Flask服务器来说很好，但是对于构建API(就像我需要做的)来说，这是有问题的，因为我们的API的目的是与运行在其他域上的应用程序接口。</p><p id="b458" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Flask提供了一整套定制CORS设置的工具，并且(和Flask的方式一样)默认不包括它！我们可以简单地将“flask_cors”模块安装到我们的python环境中，并通过将“从flask_cors导入cors”添加到导入中，将其导入到我们的app.py中。</p><p id="83b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种方法可以自定义我们的CORS设置，我将列出一些从最少到最多的限制:</p><h2 id="6da6" class="mm lt iq bd lu mn mo dn ly mp mq dp mc lf mr ms me lj mt mu mg ln mv mw mi mx bi translated">接受所有域请求:</h2><p id="fd36" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">接受来自任何和所有域的请求可能是最容易实现的。您只需将存储了初始化Flask实例的app变量传递到导入的CORS构造函数中。见下文。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="e5b9" class="mm lt iq bd lu mn mo dn ly mp mq dp mc lf mr ms me lj mt mu mg ln mv mw mi mx bi translated">对给定模式的多条路线应用CORS限制:</h2><p id="98f1" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这可能会有点复杂，但比方说，你希望所有的域都能够访问你的后端，但只能通过某个/api/ route，你已经建立了公开可用。CORS构造函数包含一系列可选参数，包括“origins”，一个所有可接受的起源域的列表；和“方法”，外部域可以请求的已接受方法的列表；和一些标题选项。</p><p id="2fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这些可选参数中最灵活的是“resources”参数，您可以将一个regex URLs字典作为键传递给它，CORS选项作为它们各自的值。这意味着，如果一个URL从外部域传入，它将检查“resources”键中regex匹配的键。如果找到匹配项，则该键的选项用于限制和/或允许来自匹配域的请求。换句话说，您可以在单个“requests”可选参数中紧凑地组织和定制来自任何可能的URL的访问，您希望从这些URL接收请求。我已经尽力在下面的代码片段中列出了一些例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="262c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多详情，请查阅<a class="ae kv" href="https://flask-cors.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">烧瓶文件</a>。</p><h2 id="ce14" class="mm lt iq bd lu mn mo dn ly mp mq dp mc lf mr ms me lj mt mu mg ln mv mw mi mx bi translated">特定路线的CORS限制:</h2><p id="fbb3" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">最后一个是最具体的，并且在许多情况下比resources键更容易实现。您可以使用“@cross_origin”装饰器将自定义CORS规范应用到一条路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7df2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，上面的代码只允许从接受的用户域获取用户，只允许从接受的图片域获取图片。这是我主要使用的方法，因为我发现它更容易实现。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="9b58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面列出的特性结合在一起，为您的API或服务提供了来自主机域之外的源的可访问性的完全定制。既然我们已经讨论了路由和可访问性，那么让我们来讨论如何格式化返回给请求源的值。</p><h1 id="caa7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">返回值</h1><p id="2e78" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Flask可以返回各种数据类型作为返回值，对于开发人员来说，它实际上是相当不错的，因为它可以直观地将某些Python数据类型转换成您所期望的响应。下面，我列出了一些最标准的返回类型以及它们是如何实现的。</p><h2 id="dc34" class="mm lt iq bd lu mn mo dn ly mp mq dp mc lf mr ms me lj mt mu mg ln mv mw mi mx bi translated">HTML/模板:</h2><p id="2adc" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如果路由函数的返回值是一个字符串，Flask将自动构造一个格式正确的返回对象，并将传递的字符串作为响应的主体。从技术上来说，这意味着如果你返回静态HTML，你可以把你的HTML存储在一个“视图”文件夹中的一系列文本文件中，并在需要时提供给用户。虽然这对于HTML注入来说是100%安全的，但它绝对不是动态的，在当今大多数情况下也绝对不是最佳实践。对于动态HTML模板，我们实际上可以依赖Flask默认包含的少数几个库中的一个:Jinja2模板引擎。</p><p id="d68b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您以前使用过rails，这个引擎的功能与Rails提供的动态视图文件非常相似。变量可以传递给模板文件，代码可以在模板中执行，允许根据请求动态生成HTML。例如，给定以下路线:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="101f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和下面的greeting.html文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="752e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将返回以下两种HTML布局之一:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="69ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Jinja2库还清除了变量输入，以防止有害的HTML注入发生。因此，模板既减少了您编写的代码量，提供了更多的灵活性，又为您的站点提供了安全性。更多详情，请随时查阅<a class="ae kv" href="https://jinja.palletsprojects.com/en/2.11.x/" rel="noopener ugc nofollow" target="_blank"> Jinja2文档</a>。</p><h2 id="1d77" class="mm lt iq bd lu mn mo dn ly mp mq dp mc lf mr ms me lj mt mu mg ln mv mw mi mx bi translated">JSON对象:</h2><p id="7c6a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">对于API生成(这是我的财务应用程序所需要的)，JSON对象通常是最常见的返回数据格式。Python确实包含用于JSON化字典的库，但事实证明Flask也知道这一点。Flask在这方面对我们很好，因为如果您从route函数返回dict，它会将字典识别并格式化为JSON对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a67a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述代码将尝试通过数据处理程序类添加一个新条目。如果成功，它返回一个状态为“成功”的dict和请求体。如果不成功，它将返回“失败”状态。在这两种情况下，Flask都会自动将dicts转换成JSON。</p><p id="aaae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我的经验，返回列表对象会在发送端和接收端产生类似的成功行为。因此，如果您需要转发的只是一个条目列表，那么可以像处理字典一样返回列表，但是可能会有意想不到的副作用。</p><h2 id="0b86" class="mm lt iq bd lu mn mo dn ly mp mq dp mc lf mr ms me lj mt mu mg ln mv mw mi mx bi translated">文件:</h2><p id="adb1" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">最后，Flask能够将文件发送到前端进行下载或跨服务器数据传输。这也可以通过从“flask”模块导入“send_file”方法来完成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="34a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，这些文件类型构成了你对任何URL请求的大部分响应，并且一如既往，可以参考<a class="ae kv" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask Docs </a>以获得进一步的参考。最后，我想通过概述将定制模块导入到您的服务器环境中是多么简单，来提一下Flask作为服务器框架的定制的便利性。</p><h1 id="c1ed" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">定制代码和Python的强大功能</h1><p id="f5e3" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">虽然这可能不是Flask的一个特别的特性，但我认为值得一提的是，将自己的代码、组织和文件结构包含到任何Flask项目中是多么容易。请记住，到目前为止，本文介绍的所有内容都可以在一个文件中完成，并且可以紧凑地启动。但都还是python代码。</p><p id="8e09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像我们可以导入‘flask’和‘flask _ CORS’模块一样，我们可以导入我们想要的任何其他python模块。熊猫，Numpy，Xlrd，我们自己的定制模块——世界是我们的！回到我们的起源，对Flask的探索是作为一种为金融跟踪应用程序开发Python后端的手段开始的。在这篇文章的最后，我想概述一下Flask与我的应用程序执行所需任务所需的所有其他Python库的接口是多么简单。</p><p id="a41c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们在Flask中查看的所有内容都可以(而且通常应该)在一个app.py或routes.py文件中完成。所以我们现在的文件树看起来像这样:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="0225" class="mm lt iq ns b gy nw nx l ny nz">app.py</span></pre><p id="7490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更像是一个树桩而不是一棵树，但是这个文件本身就能够处理我们的服务器运行所需的所有路由控制。至于应用程序的功能，我将可执行代码分成三个独立的文件:</p><ol class=""><li id="87c8" class="oa ob iq ky b kz la lc ld lf oc lj od ln oe lr of og oh oi bi translated"><strong class="ky ir"> loaders.py — </strong>导入的“Pandas”——负责将数据文件加载到Pandas数据帧中，并将数据帧保存到数据文件中</li><li id="b128" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated"><strong class="ky ir"> data_handlers.py — </strong>导入“熊猫”和“Numpy”——从loaders.py接收数据帧，并处理所有遍历、计算和表操作</li><li id="1391" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated"><strong class="ky ir"> json_parsers.py </strong> —导入的“json”——从data_handlers接收处理过的数据，并将响应格式化为适当的JSON格式。将JSON返回到app.py</li></ol><p id="4e41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些可执行模块允许我分离我的应用程序的职责，所有这些都被组织到一个名为“控制器”的文件夹中。(我在Rails时代养成的习惯……)</p><p id="9e30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还将我所有的数据文件保存在一个“资源”文件夹中，并为不同的文件格式设置了子文件夹。这是加载器模块用来读写数据的内容。</p><p id="d206" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我有一些应用程序范围内的常量，我把它们保存在一个顶级的“常量”模块中。这让我可以在一个地方组织我所有的集合和属性，这些集合和属性可以被我的其他模块导入。最后，我的文件树看起来像这样:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="56dd" class="mm lt iq ns b gy nw nx l ny nz">app.py<br/>constants.py<br/>/controllers<br/>    json_parsers.py<br/>    data_handlers.py<br/>    loaders.py<br/>/resources<br/>    data.p<br/>    /xl_files<br/>    /csv_files<br/>    /pickle_files<br/>    /exports</span></pre><p id="dc6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这突出了使用像Flask这样的微框架的主要好处和动机之一。项目结束时，存储库中的文件和文件夹只是项目使用的文件和文件夹。这是Rails中所没有的，Rails为您预先生成了许多文件结构。</p><p id="e990" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢Flask，如此紧凑和受控的后端能够处理支持像我这样的财政狂热分子的全功能前端财务跟踪应用程序所需的所有数据处理！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b1099e4467c60b3d029b6bd0d89ee17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*OcMS0dTX_muPkEoTJOIQMg.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我的<a class="ae kv" href="http://griffinpoole.com/project_overview/Budget.web" rel="noopener ugc nofollow" target="_blank"> Budget.py </a>应用程序的快照，用后端Flask编写</figcaption></figure><p id="6e23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢我关于Flask作为Python的紧凑后端开发工具的文章。下面，我收集了Flask文档、Jinja2资源、我的后端的github repo的链接，以及我的Budget.py项目的一个高亮页面，供那些想了解更多信息的人参考。</p><p id="e3d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我成功说服你们中的任何人在下一个数据密集型项目中使用Flask作为后端，那么我绝对认为这是一个胜利。感谢阅读！</p><div class="op oq gp gr or os"><a href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">欢迎使用Flask — Flask文档(1.1.x)</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">欢迎阅读Flask的文档。开始安装，然后了解快速入门概述。有…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">flask.palletsprojects.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kp os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://jinja.palletsprojects.com/en/2.11.x/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">金贾-金贾文档(2.11.x)</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">Jinja是一种现代的、设计者友好的Python模板语言，模仿Django的模板。它很快…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">jinja.palletsprojects.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg kp os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://github.com/griftheorange/budget_web_py_backend" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">gritheorange/budget _ web _ py _ back end</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">使用pandas/flask后端和临时React前端的预算应用程序的初始化框架。Python类和…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">github.com</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg kp os"/></div></div></a></div><div class="op oq gp gr or os"><a href="http://griffinpoole.com/project_overview/Budget.web" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">Budget.web项目概述</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">一个用于个人财务跟踪的React/Flask应用程序</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">griffinpoole.com</p></div></div><div class="pb l"><div class="pj l pd pe pf pb pg kp os"/></div></div></a></div></div></div>    
</body>
</html>