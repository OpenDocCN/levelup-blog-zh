<html>
<head>
<title>Advanced Python: Dataclasses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级Python:数据类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/advanced-python-dataclasses-6a1e53bc4d8d?source=collection_archive---------0-----------------------#2022-03-08">https://levelup.gitconnected.com/advanced-python-dataclasses-6a1e53bc4d8d?source=collection_archive---------0-----------------------#2022-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1c49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看Python 3.7中引入的Python数据类。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c39087c39630340e645006c36730f128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYcp2CWlau25j8KdOo_cCg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@cdr6934?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae lb" href="https://unsplash.com/s/photos/python-programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="92c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据类是python模块中的新成员，它将使Python开发人员的生活变得更加轻松。尽管这不是一个高级主题，但我们将在本系列中讨论它。这个模块提供了一个装饰器和函数，用于自动将生成的<a class="ae lb" href="https://docs.python.org/3.7/glossary.html#term-special-method" rel="noopener ugc nofollow" target="_blank">特殊方法</a>如<code class="fe lc ld le lf b"><strong class="jp ir">__init__()</strong></code>和<code class="fe lc ld le lf b"><strong class="jp ir">__repr__()</strong></code>添加到用户定义的类中。最初在<a class="ae lb" href="https://www.python.org/dev/peps/pep-0557" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> PEP 557 </strong> </a>中有描述。</p><h1 id="c9e6" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">到目前为止，这个系列</h1><ul class=""><li id="ff4b" class="me mf iq jp b jq mg ju mh jy mi kc mj kg mk kk ml mm mn mo bi translated"><a class="ae lb" href="https://python.plainenglish.io/advanced-python-classes-objects-and-mro-423bb01521fb" rel="noopener ugc nofollow" target="_blank"> Python类、对象和MRO </a></li><li id="c3df" class="me mf iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">数据类(当前员额)</li></ul><h1 id="7e99" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">为什么和如何？</h1><p id="9b86" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">现在，对于任何新功能的添加，现有系统中肯定有一些东西需要更多的功能，或者只是不符合标准(在替换的情况下)。所以我们需要知道为什么<a class="ae lb" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank">python.org</a>引入了<a class="ae lb" href="https://docs.python.org/3.7/library/dataclasses.html#module-dataclasses" rel="noopener ugc nofollow" target="_blank">数据类</a>。</p><h2 id="d8dc" class="mx lh iq bd li my mz dn lm na nb dp lq jy nc nd lu kc ne nf ly kg ng nh mc ni bi translated">不使用数据类:</h2><p id="a8bc" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">假设我们正在编写一个新的类似twitter的应用程序，这个应用程序有一个名为“Tweets”的类，用于跟踪tweet的详细信息。让我们看看这个快速且接近生产就绪的类将会是什么。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="dcb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，等等！您的产品经理现在希望您添加在tweet帖子中添加评论的功能，您需要引入一个新的类变量！！！！</p><p id="deec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你需要重写几乎整个类。又浪费了2个小时。</p><h2 id="2412" class="mx lh iq bd li my mz dn lm na nb dp lq jy nc nd lu kc ne nf ly kg ng nh mc ni bi translated">使用数据类:</h2><p id="9b23" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">好的，现在让我们试试<code class="fe lc ld le lf b"><strong class="jp ir">@dataclass</strong></code>。</p><pre class="km kn ko kp gt nl lf nm nn aw no bi"><span id="f903" class="mx lh iq lf b gy np nq l nr ns"><strong class="lf ir">from dataclasses import dataclass, field<br/>from datetime import datetime<br/>from uuid import UUID, uuid4</strong></span><span id="1dd7" class="mx lh iq lf b gy nt nq l nr ns"><strong class="lf ir">@dataclass(frozen=True, order=True)<br/>class Tweets:<br/>    <em class="nu">""" Class to store tweets of users """<br/><br/>    </em>tweet_body: str = None<br/>    tweet_time: datetime = datetime.utcnow()<br/>    tweet_id: UUID = uuid4()<br/>    tweet_lang: str = 'en-IN'<br/>    tweet_place: str = 'IN'<br/>    tweet_retweet_count: int = 0<br/>    tweet_hashtags: list[str] = field(default_factory=list)<br/>    tweet_user_id: str = None<br/>    tweet_user_name: str = None</strong></span></pre><p id="a597" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。我们完了。Python自己处理了所有的样板代码。对于任何新增加的类变量，我们可以像上面那样声明，然后忘掉它。让我们看看这个类中所有可用的方法。</p><pre class="km kn ko kp gt nl lf nm nn aw no bi"><span id="9dd3" class="mx lh iq lf b gy np nq l nr ns">&gt;&gt;&gt; inspect.getmembers(Tweets, predicate=inspect.isfunction) <br/>[('<strong class="lf ir">__delattr__</strong>', &lt;function Tweets.__delattr__ at 0x0000015EE175A440&gt;), <br/>('<strong class="lf ir">__eq__</strong>', &lt;function Tweets.__eq__ at 0x0000015EE1759EA0&gt;), ('<strong class="lf ir">__ge__</strong>', &lt;function Tweets.__ge__ at 0x0000015EE175A320&gt;), ('<strong class="lf ir">__gt__</strong>', &lt;function Tweets.__gt__ at 0x0000015EE175A200&gt;), ('<strong class="lf ir">__hash__</strong>', &lt;function Tweets.__hash__ at 0x0000015EE175A4D0&gt;), ('<strong class="lf ir">__init__</strong>', &lt;function Tweets.__init__ at 0x0000015EE1759C60&gt;), ('<strong class="lf ir">__le__</strong>', &lt;function Tweets.__le__ at 0x0000015EE175A0E0&gt;), ('<strong class="lf ir">__lt__</strong>', &lt;function Tweets.__lt__ at 0x0000015EE1759FC0&gt;), ('<strong class="lf ir">__repr__</strong>', &lt;function Tweets.__repr__ at 0x0000015EE1759BD0&gt;), ('<strong class="lf ir">__setattr__</strong>', &lt;function Tweets.__setattr__ at0x0000015EE175A3B0&gt;)]</span></pre><p id="3c7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">似乎python已经创建了<code class="fe lc ld le lf b"><strong class="jp ir">__setattr__()</strong></code>和<code class="fe lc ld le lf b"><strong class="jp ir">__delattr__()</strong></code>，这使得它是不可变的。Python这样做是因为我们添加了<code class="fe lc ld le lf b"><strong class="jp ir">frozen=True</strong></code>，它添加了<code class="fe lc ld le lf b"><strong class="jp ir">__le__()</strong></code>、<code class="fe lc ld le lf b"><strong class="jp ir">__lt__()</strong></code>、<code class="fe lc ld le lf b"><strong class="jp ir">__gt__()</strong></code>、<code class="fe lc ld le lf b"><strong class="jp ir">__ge__()</strong></code>、<strong class="jp ir">、</strong>，就像我们添加了<code class="fe lc ld le lf b"><strong class="jp ir">order=True</strong></code>、<strong class="jp ir">、</strong>(注意，我们甚至没有在我们的旧风格类声明中实现这四个，因为代码已经相当长了)。</p><p id="52e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于默认值，记得在没有默认值的值之后声明有默认值的值。对于可变对象(这里是列表对象)的默认值，您需要使用一个<code class="fe lc ld le lf b"><strong class="jp ir">default_factory</strong></code>。这可以通过使用从<code class="fe lc ld le lf b"><strong class="jp ir">dataclass</strong></code>导入的<code class="fe lc ld le lf b"><strong class="jp ir">field()</strong></code>来声明。这非常重要，因为我们不希望该类的所有实例都使用同一个列表。</p><p id="a4d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不想在你的班级里有一个<code class="fe lc ld le lf b"><strong class="jp ir">__eq__()</strong></code>、<code class="fe lc ld le lf b"><strong class="jp ir">__init__()</strong></code>或<code class="fe lc ld le lf b"><strong class="jp ir">__hash__()</strong></code>就这样做，</p><pre class="km kn ko kp gt nl lf nm nn aw no bi"><span id="3386" class="mx lh iq lf b gy np nq l nr ns"><strong class="lf ir">@dataclass(init=False, repr=False, eq=Flase, unsafe_hash=False)<br/>class Tweets():</strong></span></pre><p id="003b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以控制从<code class="fe lc ld le lf b"><strong class="jp ir">__repr__()</strong></code> <strong class="jp ir"> </strong>和<code class="fe lc ld le lf b"><strong class="jp ir">__eq__()</strong></code> <strong class="jp ir"> </strong>方法中返回什么。</p><pre class="km kn ko kp gt nl lf nm nn aw no bi"><span id="6552" class="mx lh iq lf b gy np nq l nr ns"><strong class="lf ir">tweet_retweet_count: int = field(repr=False, compare=False,                    <br/>                                 default=0)</strong></span></pre><p id="90af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们制作的<code class="fe lc ld le lf b"><strong class="jp ir">repr=False</strong></code>这个字段不包含在生成的<code class="fe lc ld le lf b"><strong class="jp ir">__repr__()</strong></code>方法返回的字符串中，对于<code class="fe lc ld le lf b"><strong class="jp ir">compare=False</strong></code> <strong class="jp ir"> </strong>它将排除生成的等式和比较方法中的<code class="fe lc ld le lf b"><strong class="jp ir">tweet_retweet_count</strong></code><strong class="jp ir"/>(<code class="fe lc ld le lf b"><strong class="jp ir">__eq__()</strong></code>、<strong class="jp ir"> </strong> <code class="fe lc ld le lf b"><strong class="jp ir">__gt__()</strong></code> <strong class="jp ir"> </strong>、<code class="fe lc ld le lf b"><strong class="jp ir"> __lt__()</strong></code>等)。).</p><p id="19f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于post init处理，我们有<code class="fe lc ld le lf b"><strong class="jp ir">__post_init__()</strong></code> <strong class="jp ir">。</strong></p><pre class="km kn ko kp gt nl lf nm nn aw no bi"><span id="2799" class="mx lh iq lf b gy np nq l nr ns"><strong class="lf ir">@dataclass</strong><br/><strong class="lf ir">class</strong> <strong class="lf ir">ResponseOnTweet</strong>:<br/>    <strong class="lf ir"><br/>    tweet_total_response_count: int = field(init=False)<br/>    tweet_retweet_count: int = 0<br/>    tweet_comment_count: int = 0 <br/>    tweet_like_count: int = 0</strong></span><span id="f350" class="mx lh iq lf b gy nt nq l nr ns"><strong class="lf ir">    def</strong> <strong class="lf ir">__post_init__(self):<br/>        self.tweet_total_response_count = self.tweet_retweet_count  <br/>                 + self.tweet_comment_count + self.tweet_like_count</strong></span></pre><h1 id="b19b" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="3113" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">是不是很好玩？嗯，我当然喜欢使用数据类。我认为你也永远不会回到老方法，除非你想要一些真正具体和定制的东西。就这样，我将结束这篇文章，在下一篇文章中，我们将研究Python中的装饰者，一如既往，如果你有任何建议或想法，请随时通过<a class="ae lb" href="https://twitter.com/duttasandipan_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae lb" href="https://www.linkedin.com/in/duttasandipan/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。回头见。</p></div></div>    
</body>
</html>