<html>
<head>
<title>How Does Hoisting Work in Javascript ES6?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript ES6中的提升是如何工作的？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-does-hoisting-work-in-javascript-es6-b0e06727e071?source=collection_archive---------4-----------------------#2020-02-24">https://levelup.gitconnected.com/how-does-hoisting-work-in-javascript-es6-b0e06727e071?source=collection_archive---------4-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/609344d9fe0a9437cfea4a30e5da796a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNZZ6HSO0bdjFPN_wL9n-Q.jpeg"/></div></div></figure><p id="132d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://unsplash.com/@guillaume_t?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Guillaume TECHER </a>在<a class="ae kz" href="https://unsplash.com/s/photos/crane?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p><p id="e4df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我困惑了一段时间的是<code class="fe la lb lc ld b">const</code>、<code class="fe la lb lc ld b">let</code>和<code class="fe la lb lc ld b">var</code>在提升时的行为方式是否相同。如果你不熟悉什么是提升，我也将在本文中讨论它！</p><h1 id="1c91" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">范围界定</strong></h1><p id="de92" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">在进入细节之前，我们先来谈谈Javascript中变量的作用域。范围定义了变量的可见性。在Javascript中，变量可以用以下方式声明:</p><ol class=""><li id="ed8d" class="mh mi it kd b ke kf ki kj km mj kq mk ku ml ky mm mn mo mp bi translated">全局范围—变量在函数或{ }之外声明</li></ol><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">可以在函数和{}内部看到全局范围变量</figcaption></figure><p id="4b24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.局部范围—变量在函数或{ }内部声明</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">局部范围变量只能在其函数或{}中看到</figcaption></figure><p id="ab9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">值得注意的是，在局部作用域中，可以有块作用域或函数作用域。</p><h1 id="2ebd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">吊装</strong></h1><p id="9778" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">Javascript中的提升是指Javascript将变量声明(<strong class="kd iu"> <em class="na">而非</em> </strong>定义)移动到其全局或局部范围的顶部。这意味着<code class="fe la lb lc ld b">var</code>、<code class="fe la lb lc ld b">const</code>和<code class="fe la lb lc ld b">let</code>变量声明被解释为位于其作用域的顶部。</p><p id="3d87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看下面的例子:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">使用var的示例代码</figcaption></figure><p id="522c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过提升，我们可以预期会发生的是，<code class="fe la lb lc ld b">a</code> <em class="na"> </em>会被提升到其局部范围的顶部，初始值为<code class="fe la lb lc ld b">undefined</code>。下面是提升后Javascript将如何解释上面的例子:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">使用提升的var示例代码解释</figcaption></figure><p id="c5f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，提升允许<code class="fe la lb lc ld b">var</code>声明发生在它的调用之后，因为它被Javascript解释和初始化为在其作用域顶部的一个<code class="fe la lb lc ld b">undefined</code>变量。</p><h1 id="c45a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">颞侧死区</strong></h1><p id="2ff6" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我前面提到过，Javascript将把<code class="fe la lb lc ld b">var</code>、<code class="fe la lb lc ld b">const</code>和<code class="fe la lb lc ld b">let</code>变量声明提升到其作用域的顶部。虽然这是真的，<code class="fe la lb lc ld b">const</code><em class="na"/><em class="na"/><code class="fe la lb lc ld b">let</code><em class="na"/>并不会表现得和<em class="na"> </em> <code class="fe la lb lc ld b">var</code> <em class="na">一样。如果没有提供定义，</em> <code class="fe la lb lc ld b">var</code>将提升一个声明并将变量初始化为<code class="fe la lb lc ld b">undefined</code> <em class="na"> </em>。但是，如果没有提供定义，<code class="fe la lb lc ld b">const</code>和<code class="fe la lb lc ld b">let</code>将提升变量声明，而<strong class="kd iu">不会</strong>初始化变量</p><p id="d666" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了更好地理解这一点，让我们看一下下面的代码:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">时间死区示例</figcaption></figure><p id="fcfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">变量<code class="fe la lb lc ld b"> a</code>将被提升到其作用域的顶部。然而，因为<code class="fe la lb lc ld b">a</code>是使用<code class="fe la lb lc ld b">let</code>声明的，<code class="fe la lb lc ld b">a</code>将保持未初始化状态。因此，当您试图执行<code class="fe la lb lc ld b">a</code>时，Javascript将抛出一个引用错误，指出<code class="fe la lb lc ld b">a</code>未初始化。<strong class="kd iu">时间死区</strong>是在<em class="na"> a </em>初始化之前执行的代码行。如您所见，这在下面的解释代码中得到了演示:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c866" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，尽管<code class="fe la lb lc ld b">let</code>和<code class="fe la lb lc ld b">const</code>仍然提升与<code class="fe la lb lc ld b">var</code>声明相同的内容，但它们的行为却不同。</p><h1 id="0583" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">结论</strong></h1><p id="55b8" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们检查了<code class="fe la lb lc ld b">var</code>、<code class="fe la lb lc ld b">let</code>和<code class="fe la lb lc ld b">const</code>变量的提升。虽然它们都是一样的，但它们的行为却不一样。希望这有助于澄清一些关于提升不同变量声明的混淆。</p><h1 id="fcb7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">引用</h1><p id="1fd6" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我使用了以下资源来帮助我理解这些主题:</p><p id="e625" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[1].泰勒·麦金尼斯。<em class="na">高级Javascript课程。</em> (2020)。<a class="ae kz" href="https://tylermcginnis.com/courses/" rel="noopener ugc nofollow" target="_blank"><em class="na">https://tylermcginnis.com/courses/</em></a></p><p id="5ca4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[2].MDN Web文档。(2020).<em class="na"/><a class="ae kz" href="https://developer.mozilla.org/" rel="noopener ugc nofollow" target="_blank"><em class="na">https://developer.mozilla.org/</em></a></p><p id="b7ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[3].堆栈溢出。<em class="na">用let或const声明的变量在ES6中不吊吗？(2020).</em><a class="ae kz" href="https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6" rel="noopener ugc nofollow" target="_blank"><em class="na">https://stack overflow . com/questions/31219420/are-variables-declared-with-let-or-const-not-hung-in-es6</em></a><em class="na">。</em></p><p id="196f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[4].泽尔·刘。<em class="na"> JavaScript范围和闭包</em>。(2020).<a class="ae kz" href="https://css-tricks.com/javascript-scope-closures/" rel="noopener ugc nofollow" target="_blank"><em class="na">https://css-tricks.com/javascript-scope-closures/</em></a></p><p id="0536" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[5].面试蛋糕。JS-范围。(2020).<a class="ae kz" href="https://www.interviewcake.com/question/javascript/js-scope" rel="noopener ugc nofollow" target="_blank"><em class="na">https://www.interviewcake.com/question/javascript/js-scope</em></a></p></div></div>    
</body>
</html>