<html>
<head>
<title>Test-Driven Development + Continuous Integration using NodeJS and GitHub Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试驱动开发+使用NodeJS和GitHub钩子的持续集成</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/test-driven-development-continuous-integration-using-nodejs-and-github-hooks-f9f0e2924f7?source=collection_archive---------16-----------------------#2020-07-05">https://levelup.gitconnected.com/test-driven-development-continuous-integration-using-nodejs-and-github-hooks-f9f0e2924f7?source=collection_archive---------16-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d01c243e471d93f430337375e31d6a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kStI68X-Mxz7CRCv1mzRQw.jpeg"/></div></div></figure><h2 id="32f3" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">为什么是测试驱动开发或单元测试？</h2><ol class=""><li id="3356" class="kx ky it kz b la lb lc ld kk le ko lf ks lg lh li lj lk ll bi translated">测试驱动开发帮助您减少bug，因为我们预先定义了测试用例</li><li id="3960" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated">它有助于代码的可维护性。假设一个新的开发人员在没有产品知识的情况下修改了代码。我们的测试用例将会失败，这将有助于新开发人员知道他哪里出错了</li><li id="d065" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated">除此之外，这些测试用例可以作为文档，帮助新开发人员更好地理解代码</li><li id="1a36" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated">测试驱动开发被敏捷软件开发人员采用，因为它通过使用连续集成和连续部署(CI/CD)来帮助您快速发布</li></ol></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="d209" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">在本文中，让我们使用TTD构建一个简单的Node注册服务。我将使用之前在我的一篇文章中使用的相同的初始设置来使用Kubernetes 设置<a class="ae mp" href="https://medium.com/@murthy.suhas/build-a-node-service-using-kubernetes-b360bde91ced" rel="noopener">节点。如果你感兴趣，请查看这里的文章。GitHub link for initial setup with express和typescript可以在</a><a class="ae mp" href="https://github.com/suhas86/node-typescript-kube-sample/tree/initial-setup" rel="noopener ugc nofollow" target="_blank">这里</a>找到。<em class="mq">(如果您不熟悉Docker和Kubernetes设置，请忽略它们，因为我们不会在这里使用它们)。</em></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="a6a6" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">假设我们有一个新的用户案例，我们的产品/客户想要一个简单的注册页面。</p><p id="3b22" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">通常作为开发人员，我们从产品所有者那里获得需求，然后开始编写代码，但是这里我们需要将这个用户故事转换成测试用例。对于这个故事，假设这些将是我的测试用例，所有平台都应该遵循相同的。通过这样做，我们还确保了它在所有平台上的一致性</p><ol class=""><li id="261e" class="kx ky it kz b la ma lc md kk mr ko ms ks mt lh li lj lk ll bi translated">名字应该是强制性的</li><li id="65d3" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated">电子邮件必须有效</li><li id="71d0" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated">密码长度不得少于6个字符</li><li id="f609" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated">电子邮件Id和密码字段应该是必填的</li><li id="a91c" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated">密码和确认密码必须相同</li><li id="d2aa" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated">重复的电子邮件不应该被允许</li><li id="09b1" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated">应该允许创建一个正确的名字，姓氏，电子邮件，密码和确认密码的用户</li><li id="796b" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated">应该允许创建一个没有姓氏的用户。</li></ol></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="cdf6" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">现在我们已经准备好了需求，让我们构建我们的应用程序。</p><h2 id="3f85" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">安装所需的所有依赖项，并设置测试环境</strong></h2><p id="094c" class="pw-post-body-paragraph ly lz it kz b la lb mb mc lc ld me mf kk mu mh mi ko mv mk ml ks mw mn mo lh im bi translated">在这个应用程序中，我们将使用<a class="ae mp" href="https://www.npmjs.com/package/supertest" rel="noopener ugc nofollow" target="_blank"> supertest </a>来测试HTTP</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="820f" class="kb kc it nc b gy ng nh l ni nj">npm install supertest @types/supertest --save-dev</span></pre><p id="0b4b" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated"><a class="ae mp" href="https://www.npmjs.com/package/jest" rel="noopener ugc nofollow" target="_blank"> Jest </a>用于JavaScript测试</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="f981" class="kb kc it nc b gy ng nh l ni nj">npm install jest @types/jest --save-dev</span></pre><p id="716d" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated"><a class="ae mp" href="https://github.com/nodkz/mongodb-memory-server" rel="noopener ugc nofollow" target="_blank"> mongodb-memory-server </a>用于模仿mongodb进行测试</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="70c2" class="kb kc it nc b gy ng nh l ni nj">npm i mongodb-memory-server --save-dev</span></pre><p id="8926" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">最后，<a class="ae mp" href="https://www.npmjs.com/package/ts-jest" rel="noopener ugc nofollow" target="_blank"> ts-jest </a>允许jest测试项目建立在TypeScript之上</p><p id="5ce8" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">安装完这些依赖项后，我们需要在package.json中修改测试脚本，如下所示</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="b123" class="kb kc it nc b gy ng nh l ni nj">"scripts": {</span><span id="b17f" class="kb kc it nc b gy nk nh l ni nj">"start": "ts-node-dev src/index.ts",</span><span id="8771" class="kb kc it nc b gy nk nh l ni nj">"test": "jest --watchAll --no-cache"</span><span id="f8c0" class="kb kc it nc b gy nk nh l ni nj">},</span><span id="18ae" class="kb kc it nc b gy nk nh l ni nj">"jest": {</span><span id="e136" class="kb kc it nc b gy nk nh l ni nj">"preset": "ts-jest",</span><span id="539f" class="kb kc it nc b gy nk nh l ni nj">"testEnvironment": "node",</span><span id="d555" class="kb kc it nc b gy nk nh l ni nj">"setupFilesAfterEnv": [</span><span id="3cbe" class="kb kc it nc b gy nk nh l ni nj">"./src/test/setup.ts"</span><span id="e1b3" class="kb kc it nc b gy nk nh l ni nj">]</span><span id="3920" class="kb kc it nc b gy nk nh l ni nj">},</span></pre><p id="a2d3" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">上面我们基本上是告诉jest使用ts-jest，因为我们使用TypeScript构建这个应用程序，并提供一个运行代码的路径，以便在套件中的每个测试文件执行之前配置或设置测试框架。</p><p id="b2bf" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">让我们通过在src目录下创建一个名为test的文件夹来创建安装文件，并创建一个文件setup.ts</p><p id="2e90" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">在设置中，我们将设置3个辅助函数</p><ol class=""><li id="b8d2" class="kx ky it kz b la ma lc md kk mr ko ms ks mt lh li lj lk ll bi translated"><strong class="kz iu">首先</strong> = &gt;连接Mongo内存服务器</li><li id="bb64" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated"><strong class="kz iu">每次</strong> = &gt;前获取并删除所有收藏</li><li id="000c" class="kx ky it kz b la lm lc ln kk lo ko lp ks lq lh li lj lk ll bi translated"><strong class="kz iu">毕竟</strong> = &gt;完成所有测试后，停止Mongo服务器并关闭连接</li></ol><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="07eb" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">这就结束了为一个简单的注册路径编写测试用例所需的设置</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="8478" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">就像我前面提到的，我们需要我们的代码通过8个测试用例来满足我们的产品所有者/客户需求</p><p id="45ff" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">在routes下创建一个__test__文件夹。当我们运行测试脚本时，这个命名约定将通知jest选择这个文件夹中的所有文件。</p><p id="bff9" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">在这个文件夹中，创建一个名为signup.test.ts的文件，并定义所需的8个测试用例。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="01c1" class="kb kc it nc b gy ng nh l ni nj">it("Should not allow to create user without first name", () =&gt; {});</span><span id="d378" class="kb kc it nc b gy nk nh l ni nj">it("Should not allow to create user with invalid email", () =&gt; {});</span><span id="0a1c" class="kb kc it nc b gy nk nh l ni nj">it("Should not allow to create user with invalid password. Has to be minimum of 6", () =&gt; {});</span><span id="ce39" class="kb kc it nc b gy nk nh l ni nj">it("Should not allow to create user without email id and password", () =&gt; {});</span><span id="ec2c" class="kb kc it nc b gy nk nh l ni nj">it("Should not allow to create user without same password and confirm password", () =&gt; {});</span><span id="3340" class="kb kc it nc b gy nk nh l ni nj">it("Should not allow to create user with same email", () =&gt; {});</span><span id="b948" class="kb kc it nc b gy nk nh l ni nj">it("Should allow to create user with proper first name, last name  email, password and confirm password", () =&gt; {});</span><span id="53e4" class="kb kc it nc b gy nk nh l ni nj">it("Should allow to create user without last name", () =&gt; {});</span></pre><p id="ea46" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">让我们通过导入超级测试和app.ts来填充这些测试用例。</p><p id="e482" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">因此，对于第一个测试案例，如果主体没有有效的名字，我们不应该允许用户注册，而是抛出错误400。所以我们的测试用例应该是这样的。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="9b3a" class="kb kc it nc b gy ng nh l ni nj">it("Should not allow to create user without first name", async () =&gt; {</span><span id="a524" class="kb kc it nc b gy nk nh l ni nj">return request(app)</span><span id="ec74" class="kb kc it nc b gy nk nh l ni nj">.post("/api/users/signup")</span><span id="83a0" class="kb kc it nc b gy nk nh l ni nj">.send({</span><span id="4a8a" class="kb kc it nc b gy nk nh l ni nj">lastName: "Abc",</span><span id="c7df" class="kb kc it nc b gy nk nh l ni nj">email: "abc@example.com",</span><span id="39c4" class="kb kc it nc b gy nk nh l ni nj">password: "12345678",</span><span id="ed05" class="kb kc it nc b gy nk nh l ni nj">confirmPassword: "12345678",</span><span id="2c14" class="kb kc it nc b gy nk nh l ni nj">})</span><span id="5bb4" class="kb kc it nc b gy nk nh l ni nj">.expect(400);</span><span id="499c" class="kb kc it nc b gy nk nh l ni nj">});</span></pre><p id="d8e7" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">类似地，让我们填充所有的测试用例，这非常简单。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d822" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">现在，当我们运行测试脚本时，所有测试用例都会失败，我们会在控制台上看到类似这样的内容。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/aa23c1f404d85dce701ad0fa4fdfb493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKCDucF0XbtDtoe8hJgkSA.png"/></div></div></figure><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/5a3e37d9110d7d276334d732499baaf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqFGpWE6ZXLaL5xmlUEXAw.png"/></div></div></figure><p id="3990" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">现在让我们修改代码来通过每一个测试用例</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="002b" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated"><strong class="kz iu">通过测试用例</strong></p><p id="09f0" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">让我们修改代码来通过这些测试用例</p><p id="e4f3" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">第一个测试用例说名字不能无效。为了检查这个条件，我们将使用<a class="ae mp" href="https://www.npmjs.com/package/express-validator" rel="noopener ugc nofollow" target="_blank"> express-validator </a></p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="63d9" class="kb kc it nc b gy ng nh l ni nj">npm install express-validator</span></pre><p id="d048" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">现在让我们将express-validator主体作为中间件包含到我们的路由中，检查名字是否存在，并检查错误。如果错误不为空，抛出400状态错误代码</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="6471" class="kb kc it nc b gy ng nh l ni nj">import express, { Request, Response } from "express";</span><span id="c29e" class="kb kc it nc b gy nk nh l ni nj">import { User } from "../models/user";</span><span id="9662" class="kb kc it nc b gy nk nh l ni nj">import express, { Request, Response } from "express";</span><span id="0985" class="kb kc it nc b gy nk nh l ni nj">import { User } from "../models/user";</span><span id="66dd" class="kb kc it nc b gy nk nh l ni nj">import { body, validationResult } from "express-validator";</span><span id="b67a" class="kb kc it nc b gy nk nh l ni nj">const router = express.Router();</span><span id="a076" class="kb kc it nc b gy nk nh l ni nj">router.post(</span><span id="c55b" class="kb kc it nc b gy nk nh l ni nj">"/api/users/signup",</span><span id="fb76" class="kb kc it nc b gy nk nh l ni nj">[</span><span id="f580" class="kb kc it nc b gy nk nh l ni nj">body("firstName")</span><span id="715c" class="kb kc it nc b gy nk nh l ni nj">.trim()</span><span id="06c0" class="kb kc it nc b gy nk nh l ni nj">.not()</span><span id="d3c0" class="kb kc it nc b gy nk nh l ni nj">.isEmpty()</span><span id="ea4d" class="kb kc it nc b gy nk nh l ni nj">.withMessage("First Name is required")</span><span id="39f1" class="kb kc it nc b gy nk nh l ni nj">],</span><span id="f72b" class="kb kc it nc b gy nk nh l ni nj">async (req: Request, res: Response) =&gt; {</span><span id="80d1" class="kb kc it nc b gy nk nh l ni nj">const errors = validationResult(req);</span><span id="0348" class="kb kc it nc b gy nk nh l ni nj">if (!errors.isEmpty()) {</span><span id="c1e4" class="kb kc it nc b gy nk nh l ni nj">return res.status(400).send(errors.array());</span><span id="3344" class="kb kc it nc b gy nk nh l ni nj">}</span><span id="8fe8" class="kb kc it nc b gy nk nh l ni nj">res.send({})</span><span id="c8ef" class="kb kc it nc b gy nk nh l ni nj">}</span><span id="f29e" class="kb kc it nc b gy nk nh l ni nj">);</span><span id="eecf" class="kb kc it nc b gy nk nh l ni nj">export { router as SignupRoute };</span></pre><p id="89e6" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">现在，如果我们运行测试脚本，我们的第一个测试用例将会通过</p><p id="91af" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">如果你观察到四个测试用例非常相似，都与验证有关。为了保持文章简短，我将所有的验证总结成一段代码。通过这样做，我们的代码将会像这样结束</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9119" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">接下来的三个测试用例与MongoDB有关。为了通过这些测试用例，让我们在模型文件夹下创建一个用户模型</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="4e64" class="kb kc it nc b gy ng nh l ni nj">import mongoose from "mongoose";</span><span id="72d9" class="kb kc it nc b gy nk nh l ni nj">const userSchema = new mongoose.Schema({</span><span id="b192" class="kb kc it nc b gy nk nh l ni nj">firstName: { type: String, required: true },</span><span id="5e30" class="kb kc it nc b gy nk nh l ni nj">lastName: { type: String, required: false },</span><span id="94a3" class="kb kc it nc b gy nk nh l ni nj">email: { type: String, required: true },</span><span id="bad3" class="kb kc it nc b gy nk nh l ni nj">password: { type: String, required: true },</span><span id="b5f1" class="kb kc it nc b gy nk nh l ni nj">});</span><span id="8992" class="kb kc it nc b gy nk nh l ni nj">const User = mongoose.model("User", userSchema);</span><span id="a5e3" class="kb kc it nc b gy nk nh l ni nj">export { User };</span></pre><p id="cf21" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">所以下一个测试用例是确保没有输入重复的电子邮件id。为了通过这一关，让我们对我们的路线进行验证</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="8ee8" class="kb kc it nc b gy ng nh l ni nj">const { firstName, lastName, email, password } = req.body;</span><span id="b7be" class="kb kc it nc b gy nk nh l ni nj">const existingUser = await User.findOne({ email });</span><span id="cf55" class="kb kc it nc b gy nk nh l ni nj">if (existingUser) {</span><span id="a5fc" class="kb kc it nc b gy nk nh l ni nj">return res.status(400).send({ error: "Email already exists" });</span><span id="64c8" class="kb kc it nc b gy nk nh l ni nj">}</span></pre><p id="d84f" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">如果我们运行我们的测试用例，我们的6个测试用例将会通过。接下来的两个测试用例是愉快的测试用例，我们允许创建用户。通过添加这个，我们所有的测试用例都会通过，我们的代码会像这样结束</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="999a" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">可以在<a class="ae mp" href="https://github.com/suhas86/node-typescript-kube-sample/tree/add-test-signup-route" rel="noopener ugc nofollow" target="_blank">这里</a>找到完整的代码部分。测试驱动开发到此结束</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="23a4" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated"><a class="ae mp" href="https://docs.github.com/en/actions" rel="noopener ugc nofollow" target="_blank"> <strong class="kz iu"> GitHub动作</strong> </a> <strong class="kz iu">钩子和CI测试脚本</strong></p><p id="3a19" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">CI测试脚本的重要性是什么？</p><p id="3f9e" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">通常，我们在主分支中维护我们的生产代码，并为开发创建一个单独的分支。因此，当我们想要将对主分支的更改合并到生产发布中时，我们需要一个验证层，它应该在我们的项目中运行测试脚本，并告诉我们是否所有的测试用例都通过了，并且我们不会最终将错误添加到我们的应用程序中。为此，我们可以在Github action hook中使用CI测试脚本</p><p id="a7d5" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated"><strong class="kz iu">先决条件:</strong>要创建GitHub action，将您的代码推送到GitHub并创建另一个分支，比如dev。</p><p id="cbbe" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">让我们去GitHub创造行动</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/c4132a00473ad7afb143eaf338b708e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3r4NIaloq1nt8i1TRyHjQ.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">单击设置此员工团队</figcaption></figure><p id="fa71" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">将文件重命名为tests.yaml，并删除编辑器中的所有内容</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/abababc5060dbadafd16455727ed8d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IEbGP7O3Gg_454ZRKgJbUw.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">清除编辑新文件中的所有内容</figcaption></figure><p id="23d1" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">在编辑器中添加以下代码</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2e2a" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">在这个Yaml文件中，我们定义了在pull请求期间何时运行测试脚本ie，同时传递构建指令，并单击start commit提交文件</p><p id="bb9d" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">在发出pull请求之前，我们需要对package.json和add做一个小的修改，因为现有的测试脚本不会出现在作业中，我们正在为GitHub显式添加一个新的脚本</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="72f5" class="kb kc it nc b gy ng nh l ni nj">"test:ci": "jest"</span></pre><p id="c22e" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">现在让我们创建一个从dev(在我的例子中是它的add-test-signup-route)到master branch的pull请求，并测试这是否有效。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/881b6c35d4b718ce0ab70437d9ab19a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QSTs2hw4ORzbazuulrLlew.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">单击“拉式请求”,然后单击“新拉式请求”</figcaption></figure><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/d12766e0132c6db9507dd737a28271a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8u8Qq7JrGfR5Fs0eLcB4g.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">从您希望合并到主数据库的分支中选择，然后点击“创建拉式请求”</figcaption></figure><p id="b4d1" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">当我们点击拉请求时，我们可以看到我们的脚本在Github中运行</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/ec2cbc6b60d3034ab1795cfc2f56072f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eMI_YlhPIzbvNfJSA6OQ4w.png"/></div></div></figure><p id="90b7" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">如果您单击“显示所有检查”,然后单击“详细信息”,我们可以找到详细信息</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/5204c75e3d5d170266bde5c321b66f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vamoUOwVkZyViGfkCvi6qg.png"/></div></div></figure><p id="f724" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">现在，我们可以放心地点击一个合并请求，将代码合并到我们的主分支。</p><p id="e0d9" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">这就结束了使用GitHub钩子的CI。</p><p id="b96e" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">希望您喜欢这篇关于使用GitHub进行测试驱动开发和CI的文章。</p><p id="479a" class="pw-post-body-paragraph ly lz it kz b la ma mb mc lc md me mf kk mg mh mi ko mj mk ml ks mm mn mo lh im bi translated">编码快乐！！！干杯！！！</p></div></div>    
</body>
</html>