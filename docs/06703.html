<html>
<head>
<title>Maximum Sum in a Sliding Window of Length w</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">长度为w的滑动窗口中的最大和</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/maximum-sum-in-a-sliding-window-of-length-w-69f4e8b86af4?source=collection_archive---------9-----------------------#2020-12-21">https://levelup.gitconnected.com/maximum-sum-in-a-sliding-window-of-length-w-69f4e8b86af4?source=collection_archive---------9-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0be5c3727a6377ee5188c98071bf114b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZuJe0Z5Pad5hD8DK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Pierre chtel-Innocenti在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3c11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先说一个滑动窗口问题，以及如何解决。</p><p id="ec65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您有一组数据(如字符串或数组)并且正在寻找数据的连续子集时，滑动窗口方法非常有用。我们创建一个窗口(可以是子数组或子串),并根据条件移动窗口。</p><p id="4f05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑下面这个问题:<em class="lb">写一个函数，接受一个整数数组和一个名为</em> <strong class="kf ir"> <em class="lb"> w </em> </strong> <em class="lb">的数字。该函数应该计算数组中连续的</em> <strong class="kf ir"> <em class="lb"> w </em> </strong> <em class="lb">个元素的最大和。</em></p><h2 id="6a8e" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">暴力破解— O(nw) </strong></h2><p id="e5d1" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">强力方法是使用嵌套循环。我们已经可以断定这不会是高效的，但仍然值得讨论。</p><p id="ad8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案如下:</p><p id="fc7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们检查数组确实比<code class="fe ma mb mc md b">w</code>长。否则我们返回<code class="fe ma mb mc md b">null</code>,因为数组中没有足够的整数相加。</p><p id="0cf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将一个名为<code class="fe ma mb mc md b">maxSum</code>的变量设置为<code class="fe ma mb mc md b">-Infinity</code>，我们将使用它来比较我们的总和，以便在最后返回最大值。我们将<code class="fe ma mb mc md b">maxSum</code>初始化为一个小数字，这样我们迭代时计算的任何总和都将大于它。我们使用<code class="fe ma mb mc md b">-Infinity</code>代替<code class="fe ma mb mc md b">0</code>，以防数组被负数填充。</p><p id="54fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从数组的第一个元素开始循环，直到可以开始求和的最后一个元素。我们不想去数组中的最后一个元素，而是最后一个元素，这个元素后面还有<code class="fe ma mb mc md b">w-1</code>个元素可以被求和。</p><p id="f538" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每一次迭代，我们运行一个从<code class="fe ma mb mc md b">0</code>到<code class="fe ma mb mc md b">w</code>的循环(排他的)来计算我们的和。</p><p id="5879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查我们的总和是否大于当前的<code class="fe ma mb mc md b">maxSum</code>，如果是，将其存储在<code class="fe ma mb mc md b">max</code>变量中。</p><p id="f831" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，在退出外部循环后，我们返回最大和。</p><p id="42c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面提供了示例代码:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="1df3" class="lc ld iq md b gy mm mn l mo mp">function maxSubarraySum(<em class="lb">arr</em>, <em class="lb">w</em>){</span><span id="e0e9" class="lc ld iq md b gy mq mn l mo mp">  if (num &gt; arr.length){<br/>    return null;<br/>  }</span><span id="f5bb" class="lc ld iq md b gy mq mn l mo mp">  let <!-- -->maxSum<!-- --> = -Infinity<br/>  for (let i = 0; i &lt; arr.length - w + 1; i++){<br/>    let temp = 0;<br/>    for (let j = 0; j &lt; w; j++){<br/>      temp += arr[i+j];<br/>    }</span><span id="5031" class="lc ld iq md b gy mq mn l mo mp">    if (temp &gt; <!-- -->maxSum<!-- -->){<br/>      <!-- -->maxSum<!-- --> = temp;<br/>    }<br/>  }<br/>  return <!-- -->maxSum<!-- -->;<br/>}</span></pre><p id="0a1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们前面提到的，这种解决方案效率很低，因为它使用了嵌套循环。这个解的时间复杂度是O(nw)。</p><h2 id="63b2" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">滑动窗口解— O(n) </strong></h2><p id="9afa" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们可以使用滑动窗口提出一个更有效的解决方案。</p><p id="6648" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案如下:</p><p id="1630" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像上次一样，我们首先检查数组是否比<code class="fe ma mb mc md b">w</code>长。</p><p id="71c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建两个变量，<code class="fe ma mb mc md b">maxSum</code>和<code class="fe ma mb mc md b">tempSum</code>。</p><p id="20cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们遍历数组中的第一个<code class="fe ma mb mc md b">w</code>元素，将它们相加，并将它们存储在<code class="fe ma mb mc md b">maxSum</code>和<code class="fe ma mb mc md b">tempSum</code>中。</p><p id="d207" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来我们从<code class="fe ma mb mc md b">w</code>开始循环<code class="fe ma mb mc md b">i</code>直到数组结束，<em class="lb">向右滑动我们的窗口</em>。这意味着，不是使用内部循环来计算从当前位置开始的<code class="fe ma mb mc md b">w</code>元素的和，而是使用我们已经计算的和，并更新它以说明我们向右移动了一个元素。这是通过从前一个总和中减去最左边的元素(<code class="fe ma mb mc md b">arr[i — w]</code>)并加上下一个元素(<code class="fe ma mb mc md b">arr[i]</code>)来完成的。然后，我们将新总和(<code class="fe ma mb mc md b">tempSum</code>)与当前总和<code class="fe ma mb mc md b">maxSum</code>进行比较，并在必要时重新分配<code class="fe ma mb mc md b">maxSum</code>。</p><p id="d5ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，在退出循环后，我们返回<code class="fe ma mb mc md b">maxSum</code>。</p><p id="9aee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面提供了示例代码:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="89e7" class="lc ld iq md b gy mm mn l mo mp">function maxSubarraySum(<em class="lb">arr</em>, <em class="lb">w</em>){</span><span id="8748" class="lc ld iq md b gy mq mn l mo mp">  if (w &gt; arr.length){<br/>    return null;<br/>  }</span><span id="c069" class="lc ld iq md b gy mq mn l mo mp">  let maxSum = 0;<br/>  let tempSum = 0;</span><span id="3741" class="lc ld iq md b gy mq mn l mo mp">  for (let i = 0; i &lt; w; i++){<br/>    maxSum += arr[i]<br/>  }</span><span id="c06b" class="lc ld iq md b gy mq mn l mo mp">  tempSum = maxSum;</span><span id="e714" class="lc ld iq md b gy mq mn l mo mp">  for (let i = w; i &lt; arr.length; i++){<br/>    tempSum = tempSum - arr[i - w] + arr[i];<br/>    if (tempSum &gt; maxSum){<br/>      maxSum = tempSum;<br/>    }<br/>  }<br/>  return maxSum;<br/>}</span></pre><p id="388f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，这是一个更有效的解决方案，因为我们完全消除了内部循环。这个解的时间复杂度是O(n)。</p><p id="421d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参考资料:</p><div class="mr ms gp gr mt mu"><a href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">JavaScript (JS)算法和数据结构大师班</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">嗨！我是柯尔特。我是一名热爱教学的开发人员。过去几年我一直在教人们…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">www.udemy.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni jw mu"/></div></div></a></div><div class="mr ms gp gr mt mu"><a href="https://medium.com/outco/how-to-solve-sliding-window-problems-28d67601a66" rel="noopener follow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">如何解决滑动窗口问题</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">滑动窗口问题是在软件工程面试中经常被问到的一种问题</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">medium.com</p></div></div><div class="nd l"><div class="nj l nf ng nh nd ni jw mu"/></div></div></a></div></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="afa2" class="nr ld iq bd le ns nt nu lh nv nw nx lk ny nz oa ln ob oc od lq oe of og lt oh bi translated">分级编码</h1><p id="f4c8" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">感谢您成为我们社区的一员！<a class="ae kc" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae kc" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Skilled.dev编码面试课程</strong> </a>。</p><div class="mr ms gp gr mt mu"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">编写面试问题+获得开发工作</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">掌握编码面试的过程</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">技术开发</p></div></div><div class="nd l"><div class="oi l nf ng nh nd ni jw mu"/></div></div></a></div></div></div>    
</body>
</html>