<html>
<head>
<title>Useful Preprocessor Macro Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的预处理宏技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/useful-preprocessor-macro-trick-1f91f526a80f?source=collection_archive---------5-----------------------#2020-07-14">https://levelup.gitconnected.com/useful-preprocessor-macro-trick-1f91f526a80f?source=collection_archive---------5-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3f4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有效的预处理器元编程技巧</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8127bb8bb605994424c8b4dc15c74682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1ArNNbqcjVJaZpHFYGW-w.png"/></div></div></figure><p id="4128" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">C/C++预处理器是用于在编译过程之前处理源代码的工具。预处理器处理源代码中以散列(<code class="fe la lb lc ld b">#</code>)符号开始的某些指令。有几个预处理指令。最著名的可能是用于包含特定文件的<code class="fe la lb lc ld b">#include</code>指令。</p><pre class="kp kq kr ks gt le ld lf lg aw lh bi"><span id="d0b1" class="li lj it ld b gy lk ll l lm ln">#include &lt;iostream&gt; // Includes standard library <em class="lo">iostream</em> header</span></pre><p id="dad2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，还有<code class="fe la lb lc ld b">#if</code>、<code class="fe la lb lc ld b">#ifdef</code>、<code class="fe la lb lc ld b">#ifndef</code>、<code class="fe la lb lc ld b">#elif</code>、<code class="fe la lb lc ld b">#endif</code>指令，它们可以作为预处理程序指令的其他示例用于条件编译。在这篇文章中，我决定谈谈<code class="fe la lb lc ld b">#define</code>指令及其用法，因为在所有的指令中，<code class="fe la lb lc ld b">#define</code>指令的某些用法特别有争议，在某些情况下，使用它被认为是一种不好的做法，但在实践中，它仍然被广泛使用，我喜欢提出一些它的用法变得有利的情况。有关其他类型的预处理程序指令的详细信息，请参考文档。</p><h1 id="0f7c" class="lp lj it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">预处理宏</h1><p id="eb5c" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated"><code class="fe la lb lc ld b">#define</code>指令用于定义<em class="lo">宏</em>。宏是已经命名的代码片段。无论何时使用宏，它都会被宏的内容替换。简单的例子如下所示。</p><pre class="kp kq kr ks gt le ld lf lg aw lh bi"><span id="6b6b" class="li lj it ld b gy lk ll l lm ln">#define PI 3.14</span><span id="d758" class="li lj it ld b gy mr ll l lm ln">double radius = 2.0;<br/>double area = PI * radius * radius;</span></pre><p id="dbab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">PI</code>是一个被归类为类对象宏的宏。它将被预处理器在代码中使用的标记<em class="lo"> 3.14 </em>所取代。</p><p id="7aa5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种类型的宏称为类似函数的宏，如下所示</p><pre class="kp kq kr ks gt le ld lf lg aw lh bi"><span id="9987" class="li lj it ld b gy lk ll l lm ln">#define max(a, b) ( ((a) &gt; (b)) ? (a) : (b) )<br/><br/>int a = 5;<br/>int b = 4;<br/><br/>int c = max(++a, b); // c becomes 7 not 6!</span></pre><p id="a85d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，这个例子经常被用来解释为什么类似函数的宏会带来混乱的效果并使代码容易出错。在上面的例子中，在最后一次给<em class="lo"> c. </em>赋值后，你会期望<em class="lo"> a </em>和<em class="lo"> c </em>的值是6，然而，这些值是7而不是6。这是因为宏展开后的代码如下所示，因此</p><pre class="kp kq kr ks gt le ld lf lg aw lh bi"><span id="78ac" class="li lj it ld b gy lk ll l lm ln">int c = ( ((++a) &gt; (b)) ? (++a) : (b) );</span></pre><p id="44c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lo"> a </em>的值增加两次，变成7而不是6。当宏的用户希望它像正常的函数调用一样工作时，这可能会有问题。</p><p id="c696" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，还有其他原因可能使宏不受欢迎:对于人和调试器来说，用宏调试代码的难度增加，宏没有作用域的概念，它不是类型安全的，等等。</p><p id="06d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，尽管使用宏有一些缺点，但只要小心使用，在某些情况下宏会是一个有用的工具。</p><h1 id="fb83" class="lp lj it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">为RAII对象创建唯一的名称</h1><p id="f595" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">有效使用宏的一个例子是创建从不被直接引用的唯一命名的变量，特别是当这些变量与RAII⁴技术一起使用时。现在，我用一个来自Andrei Alexandrescu和Petru Marginean的scopeguard⁵·习语的例子来解释这个用例。ScopeGuard习语的思想是让Guard对象的析构函数在作用域的末尾调用用户指定的清理动作。注意:为了简化，我使用了ScopeGuard习语的一个非常粗糙的实现，以便我们可以专注于宏的使用。实现如下所示，</p><pre class="kp kq kr ks gt le ld lf lg aw lh bi"><span id="2d4d" class="li lj it ld b gy lk ll l lm ln">#define CONCATENATE_IMPL(s1, s2) s1##s2<br/>#define CONCATENATE(s1, s2) CONCATENATE_IMPL(s1, s2)</span><span id="1a7f" class="li lj it ld b gy mr ll l lm ln">#ifdef __COUNTER__<br/>#define ANONYMOUS_VARIABLE(str) \<br/>CONCATENATE(str, __COUNTER__)<br/>#else<br/>#define ANONYMOUS_VARIABLE(str) \<br/>CONCATENATE(str, __LINE__)<br/>#endif</span><span id="0f79" class="li lj it ld b gy mr ll l lm ln">namespace scope_guard {</span><span id="cd0b" class="li lj it ld b gy mr ll l lm ln">template &lt;class Func&gt;<br/>class ScopeGuard {<br/> public:<br/>  ScopeGuard( Func const&amp; cleanup ) <br/>           : cleanup_( cleanup ) {}<br/>      <br/>  ~ScopeGuard() { cleanup_(); }</span><span id="6ae3" class="li lj it ld b gy mr ll l lm ln"> private:<br/>  Func cleanup_;<br/>};</span><span id="65dc" class="li lj it ld b gy mr ll l lm ln">enum class ScopeGuardOnExit {};</span><span id="8310" class="li lj it ld b gy mr ll l lm ln">template &lt;typename Fun&gt;<br/>ScopeGuard&lt;Fun&gt; operator+(ScopeGuardOnExit, Fun&amp;&amp; fn) {<br/>return ScopeGuard&lt;Fun&gt;(std::forward&lt;Fun&gt;(fn));<br/>}</span><span id="2f12" class="li lj it ld b gy mr ll l lm ln">}  // end of namespace scope_guard</span><span id="e2fe" class="li lj it ld b gy mr ll l lm ln">#define SCOPE_EXIT \<br/>auto ANONYMOUS_VARIABLE(scope_exit_var) \<br/>= ::scope_guard::ScopeGuardOnExit() + [&amp;]()</span><span id="d0c4" class="li lj it ld b gy mr ll l lm ln">int main() {<br/>  <br/>  std::ofstream myfile;<br/>  SCOPE_EXIT{ myfile.close(); std::cout &lt;&lt; "Finished cleanup"; };<br/>  <br/>  myfile.open ("example.txt");<br/>  myfile &lt;&lt; "Writing this to a file.\n";<br/>}</span></pre><p id="bb6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们先来看看<em class="lo"> main() </em>函数中<code class="fe la lb lc ld b">SCOPE_EXIT</code>宏的用法。在我们创建了<code class="fe la lb lc ld b">myfile</code>对象之后，我们可以声明性地指定退出作用域(在本例中，退出main函数)时需要执行的清理步骤。在这种情况下，它将关闭打开的文件，并输出消息以指示清理已经完成。使用这个宏，描述退出作用域时要执行的必要步骤(例如，释放资源、记录日志等)变得非常清晰和直观。</p><p id="485b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们看看<code class="fe la lb lc ld b">SCOPE_EXIT</code>宏是如何实现的以及它是如何工作的。</p><p id="e5e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">SCOPE_EXIT</code>宏扩展成如下代码，</p><pre class="kp kq kr ks gt le ld lf lg aw lh bi"><span id="8680" class="li lj it ld b gy lk ll l lm ln">auto ANONYMOUS_VARIABLE(scope_exit_var) = ::scope_guard::ScopeGuardOnExit() + [&amp;]()</span></pre><p id="76e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于<code class="fe la lb lc ld b">SANONYMOUS_VARIABLE(scope_exit_var)</code>也是一个宏，它也将被扩展。让我们来看看代码开头定义的相应宏。</p><pre class="kp kq kr ks gt le ld lf lg aw lh bi"><span id="0736" class="li lj it ld b gy lk ll l lm ln">#define CONCATENATE_IMPL(s1, s2) s1##s2<br/>#define CONCATENATE(s1, s2) CONCATENATE_IMPL(s1, s2)</span><span id="6492" class="li lj it ld b gy mr ll l lm ln">#ifdef __COUNTER__<br/>#define ANONYMOUS_VARIABLE(str) \<br/>CONCATENATE(str, __COUNTER__)<br/>#else<br/>#define ANONYMOUS_VARIABLE(str) \<br/>CONCATENATE(str, __LINE__)<br/>#endif</span></pre><p id="1c02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">_COUNTER_</code>和<code class="fe la lb lc ld b">_LINE_</code>是特殊的预定义宏。在本例中，它们用于在代码中展开的每个地方提供唯一的编号。从Gcc发布notes⁶:</p><blockquote class="ms mt mu"><p id="71ca" class="jq jr lo js b jt ju jv jw jx jy jz ka mv kc kd ke mw kg kh ki mx kk kl km kn im bi translated">添加了一个新的预定义宏<code class="fe la lb lc ld b">__COUNTER__</code>。它扩展为从0开始的连续整数值。结合<code class="fe la lb lc ld b">##</code>操作符，这提供了一种生成唯一标识符的便捷方法。</p></blockquote><p id="2a28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是并不是所有的编译器都支持<code class="fe la lb lc ld b">_COUNTER_</code>，所以它使用标准的预定义<code class="fe la lb lc ld b">_LINE_</code>宏作为备份。该宏以十进制整数常量的形式扩展到当前输入行号。</p><p id="1a6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">CONCATENATE</code>宏被定义为连接给定的两个输入。要使它与预定义的宏一起工作，需要两级宏扩展。这就是为什么我们也有<code class="fe la lb lc ld b">CONCATENATE_IMPL</code>宏。<code class="fe la lb lc ld b">CONCATENATE_IMPL</code>宏使用<code class="fe la lb lc ld b"><em class="lo">##</em></code>宏操作符，该操作符获取两个单独的令牌并将它们粘贴在一起形成一个令牌。得到的令牌可以是变量名、类名或任何其他标识符。</p><p id="56e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样一来，<code class="fe la lb lc ld b">ANONYMOUS_VARIABLE(scope_exit_var)</code>的扩展就可以像<code class="fe la lb lc ld b">scope_exit_var1</code>(末尾的数字取决于它在源代码<code class="fe la lb lc ld b">_LINE_</code>中被调用的地方，被调用了多少次<code class="fe la lb lc ld b"><em class="lo">_COUNTER_</em></code>)。</p><p id="5691" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，例子中对<code class="fe la lb lc ld b">SCOPE_EXIT</code>宏的调用扩展如下，现在，我们只剩下普通的C++代码。</p><pre class="kp kq kr ks gt le ld lf lg aw lh bi"><span id="981c" class="li lj it ld b gy lk ll l lm ln">auto scope_exit_var1 = ::scope_guard::ScopeGuardOnExit() + [&amp;]() { myfile.close(); std::cout &lt;&lt; "Finished cleanup"; };</span></pre><p id="18af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们再来看看最初的l示例代码。它定义了一个模板操作符函数，该函数将枚举类<code class="fe la lb lc ld b">ScopeGuardOnExit</code>和模板参数<code class="fe la lb lc ld b">Fun&amp;&amp; fn</code>作为参数。</p><pre class="kp kq kr ks gt le ld lf lg aw lh bi"><span id="f2fa" class="li lj it ld b gy lk ll l lm ln">template &lt;typename Fun&gt;<br/>ScopeGuard&lt;Fun&gt; operator+(ScopeGuardOnExit, Fun&amp;&amp; fn) {<br/>  return ScopeGuard&lt;Fun&gt;(std::forward&lt;Fun&gt;(fn));<br/>}</span></pre><p id="63a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是在扩展代码右侧调用的操作符。</p><p id="3b2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将模板参数<code class="fe la lb lc ld b">fun</code>转发给<code class="fe la lb lc ld b">ScopeGuard</code>类的构造函数，并返回构造的对象。在这种情况下，模板参数<code class="fe la lb lc ld b">fun</code>是λfunction⁷</p><pre class="kp kq kr ks gt le ld lf lg aw lh bi"><span id="302e" class="li lj it ld b gy lk ll l lm ln">[&amp;]() { myfile.close(); std::cout &lt;&lt; "Finished cleanup"; };</span></pre><p id="aa4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">ScopeGuard</code>是一个接受模板参数<code class="fe la lb lc ld b">Func</code>的类。它有一个<code class="fe la lb lc ld b">Func</code>类型的<code class="fe la lb lc ld b">cleanup_</code>成员，该成员是用构造函数中给定的参数初始化的。在<code class="fe la lb lc ld b">ScopeGuard</code>的析构函数中调用<code class="fe la lb lc ld b">cleanup_</code>，在本例中，它是给定的lambda函数。因此，当<code class="fe la lb lc ld b">scope_exit_var1</code>变量超出范围并且对象的析构函数被析构时，包含用户指定的清理步骤的lambda函数被执行！</p><p id="0198" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我上面提到的，我将ScopeGuard的实现限制到最小，以便更简单地解释宏用法的思想。例如，在实践中，我们需要使它不可复制，并且它可以像ScopeGuardOnFailure一样被扩展，以指定在异常等情况下要执行的步骤，正如你可以从Andrei Alexandrescu的演讲“声明式控制Flow"⁸”中看到的那样。</p><h1 id="e873" class="lp lj it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">摘要</h1><p id="4162" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">在这篇文章中，我解释了预处理器指令和宏的基础。然后我谈到了在代码中使用宏的缺点，以及为什么在社区中使用宏会有争议。即使宏有潜在的问题，它仍然在实践中被广泛使用，如果我们小心使用它，它会很有用。作为一个例子，我用ScopeGuard习语用例的例子介绍了使用宏创建唯一变量名的技术。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="1726" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">[1]:<a class="ae nf" href="https://en.wikipedia.org/wiki/C_preprocessor" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/C_preprocessor</a></p><p id="6342" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">[2]:<a class="ae nf" href="https://en.wikipedia.org/wiki/Conditional_compilation#:~:text=In%20computer%20programming%2C%20conditional%20compilation,that%20are%20provided%20during%20compilation." rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Conditional _ compilation #:~:text = In % 20 computer % 20 programming % 2C % 20 Conditional % 20 compilation，that % 20 are % 20 provided % 20 during % 20 compilation。</a></p><p id="610a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">【3】:【https://en.cppreference.com/w/cpp/preprocessor T2】</p><p id="6089" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">【4】:【https://en.cppreference.com/w/cpp/language/raii T4】</p><p id="e1a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">[5]:<a class="ae nf" href="https://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758" rel="noopener ugc nofollow" target="_blank">https://www . drdobbs . com/CPP/generic-change-the-way-you-write-excepti/184403758</a></p><p id="f324" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">【6】:<a class="ae nf" href="https://gcc.gnu.org/gcc-4.3/changes.html" rel="noopener ugc nofollow" target="_blank">https://gcc.gnu.org/gcc-4.3/changes.html</a></p><p id="f42e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">[7]:<a class="ae nf" href="https://en.cppreference.com/w/cpp/language/lambda" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/lambda</a></p><p id="4f03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">[8]:<a class="ae nf" href="https://youtu.be/WjTrfoiB0MQ" rel="noopener ugc nofollow" target="_blank">https://youtu.be/WjTrfoiB0MQ</a></p></div></div>    
</body>
</html>