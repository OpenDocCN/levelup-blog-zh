<html>
<head>
<title>Proxy Pattern in a Clean Architecture context: A decoupled Cache implementation proposal with NodeJS and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净架构环境中的代理模式:使用NodeJS和TypeScript的解耦缓存实现方案</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/proxy-pattern-in-a-clean-architecture-context-a-decoupled-cache-implementation-proposal-with-ff0bb5f96161?source=collection_archive---------4-----------------------#2022-10-22">https://levelup.gitconnected.com/proxy-pattern-in-a-clean-architecture-context-a-decoupled-cache-implementation-proposal-with-ff0bb5f96161?source=collection_archive---------4-----------------------#2022-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7675" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“代理”设计模式是一种结构模式，它允许一个对象被另一个作为原始对象中间媒介的对象所替换。缓存就是一个例子，它临时存储数据以避免访问昂贵的资源。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/cc732ed737e1ea71eb414af1d3aeff12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDrHTUBGj4yNWerl9yiWZA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://refactoring.guru/design-patterns/proxy" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/design-patterns/proxy</a></figcaption></figure><p id="e805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我提出了一个优雅的解耦方法来解决干净架构环境中的这个问题。<br/>这篇文章建立在我的<a class="ae lb" href="https://hofstede-matheus.medium.com/achieve-dependency-inversion-with-nodejs-typescript-and-tsyringe-8b956bc3254c" rel="noopener">上一篇文章</a>的基础上，它仍然尊重依赖倒置的原则。</p><p id="c9bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">亮点包括:</p><ul class=""><li id="745c" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir"> <em class="ll">代理</em> </strong>实现了与任何<strong class="jp ir"> <em class="ll">存储库</em> </strong>相同的接口，因此<strong class="jp ir"> <em class="ll">用例</em> </strong>不知道(也不应该需要)他们正在使用代理。</li><li id="19a2" class="lc ld iq jp b jq lm ju ln jy lo kc lp kg lq kk lh li lj lk bi translated">代理实现中的一些样板文件。</li><li id="7af4" class="lc ld iq jp b jq lm ju ln jy lo kc lp kg lq kk lh li lj lk bi translated">通过<strong class="jp ir"> <em class="ll">代理</em> </strong>和<strong class="jp ir"> <em class="ll">可缓存</em> </strong>接口进行扩展</li></ul><p id="bdc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们必须实现两个接口:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="071b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ll">可缓存</em> </strong>定义要缓存的对象将被包装的形状。<br/> <strong class="jp ir"> <em class="ll"> value </em> </strong>代表数据本身，<br/><strong class="jp ir"><em class="ll">expire sat</em></strong>代表对象何时到期。</p><p id="b49e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ll">代理</em> </strong>定义代理必须遵循的契约。<br/> <strong class="jp ir"> <em class="ll"> TTL </em> </strong>是通用的缓解扩展性的一个代理。<br/>由于我们的<strong class="jp ir"> <em class="ll">代理</em> </strong>将是一个<strong class="jp ir"><em class="ll">InMemmoryCacheProxy</em></strong>，其实现可以是:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="9aae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个实现中，我们定义通用的<strong class="jp ir"> TTL </strong>是一个数字，而<strong class="jp ir"><em class="ll">expire condition</em></strong>是日期类型。在这个特定的代理实现中，我们希望它随着时间的推移而过期。</p><p id="60a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，在这个特定的实现中，缓存存储在内存中，并通过<strong class="jp ir"> <em class="ll"> DI </em> </strong>进行管理。尽管如此，它也可以，例如，存储在<strong class="jp ir"><em class="ll">【RedisCacheProxy】</em></strong>中，只要<strong class="jp ir"> <em class="ll">代理</em> </strong>接口被遵守。</p><p id="ad1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，请注意，<strong class="jp ir"> <em class="ll"> proxy() </em> </strong>函数接收一个函数作为参数。在实现中，我们使用那个函数名来注入<strong class="jp ir"> <em class="ll">可缓存的</em> </strong>对象，并在缓存到期<em class="ll">时调用它。</em></p><p id="bb7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但同样重要的是，我创建了一个函数，使得区分<strong class="jp ir"> <em class="ll">代理</em> </strong>令牌和<strong class="jp ir"> <em class="ll">代理</em> </strong>令牌变得更加容易。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="a76d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，无论是谁呼叫，都不知道他们正在呼叫一个<strong class="jp ir"> <em class="ll">代理</em> </strong>，因为该合同对于任何存储库都是一样的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="de45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随后是代理实现:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="10c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一的区别是，它在构造函数中接收原始存储库以指向实际的源代码。</p><p id="0df9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于整个实现位于<strong class="jp ir"> <em class="ll"> CacheProxy </em> </strong>中，我们可以重用代码并简化<strong class="jp ir"> <em class="ll">代理</em> </strong>实现。</p><p id="7b17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的容器中，我们必须注册<strong class="jp ir"> <em class="ll">代理</em> </strong>、<strong class="jp ir"> <em class="ll">被代理</em> </strong>(实际存储库)，以及要被<strong class="jp ir"> <em class="ll">缓存的</em> </strong>函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="ca53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们的<strong class="jp ir"><em class="ll">GetCatsUseCase</em></strong>甚至没有得到修改，因为它仍然在使用一个<strong class="jp ir"><em class="ll">cats repository</em></strong>。</p><p id="f5ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个运行示例，我使用<strong class="jp ir"> <em class="ll"> jest </em> </strong>创建了一个测试套件。首先，我们需要配置测试容器:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="fb56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是测试结果:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="4ea4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一个测试中，我们检查实际的存储库是否被调用，因为它被初始化为<strong class="jp ir"><em class="ll"/></strong>和<strong class="jp ir"> <em class="ll"> expiresAt </em> </strong>为<strong class="jp ir"> <em class="ll"> new Date() </em> </strong>。</p><p id="3661" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二个例子中，我们模拟了原始存储库中的变化。但是，由于对象在缓存中尚未过期，它仍应返回以下内容:</p><pre class="km kn ko kp gt lt lu lv lw aw lx bi"><span id="61c6" class="ly lz iq lu b gy ma mb l mc md">[<br/>  { name: 'cat1', breedName: 'Persa' },<br/>  { name: 'cat2', breedName: 'Sphynx' }<br/>]</span></pre><p id="088a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最后一个示例中，我们模拟了一个足够长的延迟，导致缓存过期，以便从原始存储库中获取数据:</p><pre class="km kn ko kp gt lt lu lv lw aw lx bi"><span id="e67f" class="ly lz iq lu b gy ma mb l mc md">[<br/>  { name: 'cat3', breedName: 'Persa' }, <br/>  { name: 'cat4', breedName: 'Sphynx' }<br/>]</span></pre><p id="2ad8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要实时观看，请运行:</p><pre class="km kn ko kp gt lt lu lv lw aw lx bi"><span id="44b8" class="ly lz iq lu b gy ma mb l mc md">yarn test</span></pre><p id="e0ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个简单的例子展示了如何在后端使用NodeJS实现具有干净架构的缓存。尽管如此，如果它支持OOP，主要思想仍然适用于前端或移动设备，即使使用不同的编程语言。</p><p id="3b0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的代码位于本<a class="ae lb" href="https://github.com/hofstede-matheus/proxy-pattern-cache" rel="noopener ugc nofollow" target="_blank">报告</a>中。</p></div></div>    
</body>
</html>