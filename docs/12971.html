<html>
<head>
<title>Implementing Infinite Scrolling Using Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用角度实现无限滚动</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-infinite-scrolling-using-angular-82c66f27e817?source=collection_archive---------1-----------------------#2022-07-27">https://levelup.gitconnected.com/implementing-infinite-scrolling-using-angular-82c66f27e817?source=collection_archive---------1-----------------------#2022-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f67ce60639f4aec12be98133d220994c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahzxF3XN2M5EHIL5q4yXqA.png"/></div></div></figure><p id="3a7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将带您了解如何使用Angular实现无限滚动。您希望一次呈现一定数量的元素，当您滚动到页面底部时，您将呈现下一组元素。这个过程可以清洗和重复，直到你已经滚动到最底部，并已达到你的数据集的最后一个条目。</p><p id="6b24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从可用性的角度来看，当用户无限期地浏览大量数据时(想想在社交媒体移动应用程序上滚动新闻提要或用户生成的一些大型内容列表)，这可能是有益的。一旦用户滚动到页面的末尾，新数据的呈现是自动的，而不是单击按钮以分页的方式前进到下一页。</p><p id="f7e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个演示中，我们将使用Angular 14和一个公开可用的REST API来显示猫的列表和关于它们的信息(<a class="ae kz" href="https://docs.thecatapi.com/api-reference/breeds/breeds-list" rel="noopener ugc nofollow" target="_blank"> TheCatAPI </a>)。这个例子的源代码可以在<a class="ae kz" href="https://github.com/mwiginton/angular-infinite-scroll-example" rel="noopener ugc nofollow" target="_blank">这里</a>找到，你可以在这里<a class="ae kz" href="https://angular-infinite-scroll-fd946.web.app/" rel="noopener ugc nofollow" target="_blank">找到这个例子的现场版本。</a></p><p id="9a85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">新项目设置</strong></p><p id="60dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们通过首先创建我们的项目来实现我们的无限滚动示例。您可以通过运行命令<code class="fe la lb lc ld b">ng new angular-infinite-scroll-example</code>创建一个新项目。你可以给你的项目起任何你喜欢的名字。在我们的例子中，我们的项目名为<code class="fe la lb lc ld b">angular-infinite-scroll-example</code>。</p><p id="a8e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦您的项目被创建，通过执行命令<code class="fe la lb lc ld b">cd angular-infinite-scroll-example</code>导航到您的项目目录。在此目录中，您需要添加角度材料从属关系。需要这种依赖来创建卡片，在这些卡片中，我们的每个数据条目都将呈现在UI中。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="f87e" class="lm ln it ld b gy lo lp l lq lr">ng add @angular/material</span></pre><p id="89d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来你需要安装<code class="fe la lb lc ld b">ngx-infinite-scroll</code>包。这种依赖性将用于实现我们的无限滚动功能。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="010e" class="lm ln it ld b gy lo lp l lq lr">npm i ngx-infinite-scroll</span></pre><p id="253e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们将我们的<code class="fe la lb lc ld b">InfiniteScrollModule</code>导入到我们的<code class="fe la lb lc ld b">app.module.ts</code>文件中。我们还将导入<code class="fe la lb lc ld b">HTTPClientModule</code>来进行REST API调用，以及<code class="fe la lb lc ld b">MatCardModule</code>来显示从API调用返回的每个条目的信息。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="482b" class="lm ln it ld b gy lo lp l lq lr">import { HttpClientModule } from '@angular/common/http';<br/>import { MatCardModule } from '@angular/material/card';<br/>import { InfiniteScrollModule } from 'ngx-infinite-scroll';<br/>...<br/>imports: [... HttpClientModule, MatCardModule, InfiniteScrollModule]</span></pre><p id="4fa4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">创建我们的模型和服务</strong></p><p id="c906" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们为我们想要呈现的条目创建一个类似于我们的<code class="fe la lb lc ld b">Cat</code>对象的模型。通常，为应用程序中使用的每个实体定义模型是一种很好的做法，因为它为数据模型设定了一个标准，并有助于保持事物的有序性。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="9950" class="lm ln it ld b gy lo lp l lq lr">ng g i cat --type=model</span></pre><p id="09f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们具有所有期望属性的最终结果如下所示:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e747" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要执行的下一步是创建我们的服务类。我们的服务类是我们消费API的地方，API最终获取我们将在无限滚动示例中使用的数据。我们在这种情况下使用的API是前面提到的CatAPI，我们将使用它来检索猫的列表，以便在我们的示例中显示。我们可以通过执行下面的命令来生成一个新服务:<code class="fe la lb lc ld b">ng g s cat</code>。</p><p id="7826" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的<code class="fe la lb lc ld b">CatService</code>类中，我们可以创建我们的函数<code class="fe la lb lc ld b">getCats(page:number)</code>，它将使用我们的API来检索猫的列表。你会注意到我们在这里用了一个<code class="fe la lb lc ld b">page</code>作为参数。除了跟踪我们所在页面的<code class="fe la lb lc ld b">page</code>查询参数之外，您还需要记下<code class="fe la lb lc ld b">limit</code>查询参数。这是我们每个API调用检索的记录数(在本例中，我们每个API调用检索5条记录)。这就是API调用如何跟踪我们所在的页面。为了实际使用API，我们将把<code class="fe la lb lc ld b">HttPClient</code>模块注入到服务类的构造函数中。我们演示中的服务将如下所示。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="afd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">添加无限滚动逻辑</strong></p><p id="68c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经建立了我们的项目，创建了我们的<code class="fe la lb lc ld b">Cat</code>接口和<code class="fe la lb lc ld b">CatService</code>，我们可以继续在我们的<code class="fe la lb lc ld b">app.component.ts</code>和<code class="fe la lb lc ld b">app.component.html</code>文件中实现无限滚动功能。</p><p id="8c5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">先来看看我们的<code class="fe la lb lc ld b">app.component.ts file</code>。我们要做的第一件事是初始化关键变量，如下所示:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7d22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将变量<code class="fe la lb lc ld b">page</code>初始化为<code class="fe la lb lc ld b">1</code>，因为我们希望从API请求的第一页开始。我们将我们的<code class="fe la lb lc ld b">cats</code>数组初始化为一个空的<code class="fe la lb lc ld b">Cat</code>数组。我们将使用这个集合来存储我们对API调用的响应。</p><p id="77b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来你会看到我们正在把我们的<code class="fe la lb lc ld b">CatService</code>注入到我们的构造函数中。这样我们就可以从组件中的<code class="fe la lb lc ld b">CatService</code>文件中访问<code class="fe la lb lc ld b">getCats(page)</code>函数，并且可以进行API调用。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="74f2" class="lm ln it ld b gy lo lp l lq lr">constructor(private catService: CatService) {}</span></pre><p id="3b76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来我们来看看我们的<code class="fe la lb lc ld b">ngOnInit()</code>函数。这个函数是角度生命周期的一部分，每次加载页面时都会被调用。在这个函数中，我们调用<code class="fe la lb lc ld b">getCats(page)</code>方法并传入当前页码(在页面第一次加载的情况下，页面将是1)。一旦该调用完成，我们就将我们的<code class="fe la lb lc ld b">cats</code>数组设置为来自API调用的<code class="fe la lb lc ld b">cats</code>响应。您将会看到，我们正在将<code class="fe la lb lc ld b">cats</code>响应设置为<code class="fe la lb lc ld b">Cat</code>数组，以保持我们的数据整洁，并与我们定义的模型保持一致。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="5509" class="lm ln it ld b gy lo lp l lq lr">ngOnInit(): void {<br/>   this.catServic<br/>      .getCats(this.page)<br/>      .subscribe((cats: Cat[]) =&gt; {<br/>         this.cats = cats;<br/>      });<br/>}</span></pre><p id="79ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后你会注意到<code class="fe la lb lc ld b">onScroll()</code>功能。该函数将基于我们的<code class="fe la lb lc ld b">app.component.html</code>文件中的<code class="fe la lb lc ld b">(scrolled)</code>事件触发，我们稍后将在这里查看该文件。在我们的<code class="fe la lb lc ld b">onScroll()</code>函数中，我们从<code class="fe la lb lc ld b">CatService</code>内部调用我们的<code class="fe la lb lc ld b">getCats(page)</code>方法。您会注意到，每次我们进行这个调用时，我们都会将<code class="fe la lb lc ld b">page</code>递增1，以表示我们将在API中查询下一页数据。然后，我们将来自API调用的<code class="fe la lb lc ld b">cats</code>响应追加到现有的<code class="fe la lb lc ld b">cats</code>数组中。我们使用spread <code class="fe la lb lc ld b">…</code>操作符这样做，这样我们就可以将整个响应一次添加到数组中。我们的完整组件如下所示:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">app.component.ts文件</figcaption></figure><p id="9509" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们研究一下我们的<code class="fe la lb lc ld b">app.component.html</code>文件。这是我们实际呈现数据并以我们想要的方式显示在UI上的地方。您可以删除该文件中任何自动生成的样板代码。</p><p id="3e11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先用一些与无限滚动相关的属性定义一个<code class="fe la lb lc ld b">div</code>。其中包括<code class="fe la lb lc ld b">infinite-scroll</code>属性，表明我们希望在这个div中执行无限滚动。</p><p id="b94b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一项是<code class="fe la lb lc ld b">[infiniteScrollDistance]</code>。这表示为了激发下一个滚动事件，用户需要到达div的末尾多远。这是一个基于浏览器窗口大小的乘数。默认值是<code class="fe la lb lc ld b">0</code>,这意味着一旦到达页面末尾，下一个滚动事件将被触发。在我们的例子中，我们使用了<code class="fe la lb lc ld b">2</code>，这意味着下一个滚动事件将在我们接近当前视图末尾80%时触发。</p><p id="dc25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一项是<code class="fe la lb lc ld b">[infiniteScrollThrottle]</code>，它作为在<code class="fe la lb lc ld b">(scrolled)</code>事件中何时执行函数的延迟，以毫秒为单位(在我们的例子中是1000)。这种延迟的好处是，否则该函数将被触发太多次，最终可能导致一些性能问题。</p><p id="b600" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将看到的最后一项是<code class="fe la lb lc ld b">(scrolled)</code>事件。这包含当用户滚动到页面末尾时将执行的函数。在我们的例子中，我们将使用递增的<code class="fe la lb lc ld b">page</code>值进行API调用，以获取下一个数据块。</p><p id="a826" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建一个<code class="fe la lb lc ld b">mat-card</code>来存储从我们的API调用返回的每个实体。在此<code class="fe la lb lc ld b">mat-card</code>中，我们将显示每只猫的响应中的关键信息，包括<code class="fe la lb lc ld b">name</code>、<code class="fe la lb lc ld b">temperament</code>、<code class="fe la lb lc ld b">image</code>和<code class="fe la lb lc ld b">description</code>。</p><p id="6614" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完整的<code class="fe la lb lc ld b">app.component.html</code>将如下所示:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0eb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这件作品最后的修饰是在我们的<code class="fe la lb lc ld b">mat-card</code>元素之间增加一点空间。我们通过在mat-card上增加一个空白边来做到这一点。我们还在图像周围添加了一些填充。我们的app.component.css文件将如下所示:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">无限滚动的样式</figcaption></figure><p id="c8cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦完成了这段代码的实现，您就可以运行命令<code class="fe la lb lc ld b">ng serve</code>来启动您的应用程序，然后在浏览器中查看它。最终产品的行为方式与录音类似:</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/23efa99ae1bb06036233f2904b31538e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Jct3MfgWWIs5Dl-ORVYHig.gif"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">无限滚动的现场演示</figcaption></figure><p id="49ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用Angular实现无限滚动到此结束。我希望这个演示有所帮助。如果有任何问题、顾虑或反馈，请随时告诉我。感谢您的阅读！</p><p id="f169" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本例中使用的<code class="fe la lb lc ld b">ngx-infinite-scroll</code>库的官方文档可以在<a class="ae kz" href="https://www.npmjs.com/package/ngx-infinite-scroll" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="d2b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mg">如果你喜欢阅读这篇文章，请考虑使用</em> <a class="ae kz" href="https://medium.com/@michelle.wiginton00/membership" rel="noopener"> <em class="mg">我的推荐链接</em> </a> <em class="mg">注册Medium。这种订阅保证了可以无限制地访问我的文章以及其他许多学科的数千名天才作家的文章。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8bf5" class="mh ln it bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">分级编码</h1><p id="5a77" class="pw-post-body-paragraph kb kc it kd b ke ne kg kh ki nf kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="20cf" class="nj nk it kd b ke kf ki kj km nl kq nm ku nn ky no np nq nr bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="aa77" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">📰查看<a class="ae kz" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="3e72" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">🔔关注我们:<a class="ae kz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kz" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kz" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="6c57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🚀👉<a class="ae kz" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>