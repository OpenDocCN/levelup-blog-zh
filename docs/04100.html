<html>
<head>
<title>A Micro Frontend Solution for React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种用于反应的微前端解决方案</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-micro-frontend-solution-for-react-1914b19663b?source=collection_archive---------2-----------------------#2020-06-09">https://levelup.gitconnected.com/a-micro-frontend-solution-for-react-1914b19663b?source=collection_archive---------2-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="474d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过一个简单的网上商店应用程序，了解使用React的微前端的可能实现</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/03b95c5069cca58fbd1c610269bc9ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z6fvCk9Vk8t7oKkpQ82mKw.png"/></div></div></figure><p id="71ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="la"> ***更新*** <br/> </em>我写过另一篇关于使用模块联邦的相同例子的文章。看看不同的方法。👇🏼</p><div class="lb lc gp gr ld le"><a rel="noopener  ugc nofollow" target="_blank" href="/a-module-federation-example-for-react-1fa29d6ac07b"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">React的模块联合示例</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">查看通过模块联合实现的React微前端解决方案</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls ky le"/></div></div></a></div><h1 id="2d7f" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">这个故事是关于什么的？</h1><p id="f052" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">我想展示一个我用React创建的展示微前端的示例应用程序。有大量的介绍性文章讨论了利弊，所以在我的例子中，我将只关注实现。对于那些不熟悉这个概念的人，我在<a class="ae mw" href="#77e8" rel="noopener ugc nofollow">底部</a>放了一些关于这个主题的更多信息的链接。去看看，然后回来。😉</p><h1 id="bd3d" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">用几句话概括一下微前端</h1><p id="7d6b" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">这是一个架构概念，构建可以独立开发、测试和部署的更小的应用程序，而不是一个整体。然后，可以使用几种不同的技术将这些应用程序结合起来。在本文中，我想介绍一种用微前端构建单页面React应用程序的可能方法。</p><h1 id="e127" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">这个例子</h1><p id="1185" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">我在GitHub上创建了一个<a class="ae mw" href="https://github.com/burzaszsolt/react-micro-frontends" rel="noopener ugc nofollow" target="_blank">库</a>，这样你就可以查看代码的细节。用几句话总结一下:该应用程序是一个非常简单的法国斗牛犬配件网店，其中列出了一些展示可爱的法国人的产品，还有一个购物车页面列出了等待“购买”的产品。我还实现了一些添加、修改或删除这些项目的功能。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/0e8dba1c7be6d46ae974efda612c1056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PAyX19OSZDFJ13SLSuOCsQ.jpeg"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/94e9aae8b7d762c76769e9d2d5e3d7ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJxockfLiJg37PCvwd0xrw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">主页</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/1adcdfa5ecbcea311da36e4e10afb71b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eELUiEGkICpZWiezvnV6RQ.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">购物车页面</figcaption></figure></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="551c" class="lt lu it bd lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm no mo mp mq bi translated">结构</h1><p id="638a" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">该示例由四部分组成:</p><ul class=""><li id="d994" class="np nq it js b jt ju jx jy kb nr kf ns kj nt kn nu nv nw nx bi translated">主机应用程序</li><li id="d0c7" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">产品微前端</li><li id="310d" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">推车微前端</li><li id="a912" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">后端</li></ul><p id="6c81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主机应用程序是一个React应用程序，充当网上商店的框架。产品微前端呈现在主页上，将显示项目。购物车按钮出现在主机应用程序的顶部栏上，重定向到购物车页面。大车微前端渲染在这条路线上。它负责显示购物车中的产品列表。它们都连接到“后端”,这基本上是一个用<a class="ae mw" href="https://github.com/typicode/json-server" rel="noopener ugc nofollow" target="_blank"> json-server </a>包创建的假REST API。现在我们已经对这个例子有了一个简要的了解，让我们来看看一些代码。🤓</p><h1 id="a305" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">解决办法</h1><h2 id="c8aa" class="od lu it bd lv oe of dn lz og oh dp md kb oi oj mh kf ok ol ml kj om on mp oo bi translated">微前端</h2><p id="37c8" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">在我的例子中，每个微前端可以作为一个独立的应用程序运行，也可以构建为一个微前端。为了实现这一点，我使用了<a class="ae mw" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>来创建单独的配置，为每个行为创建不同的入口点。当独立运行它时，我使用<a class="ae mw" href="https://github.com/burzaszsolt/react-micro-frontends/blob/master/mf-products/src/index.js" rel="noopener ugc nofollow" target="_blank"> index.js </a>作为一个入口点，它将以一种简单的老式React方式呈现应用程序，应用程序将由<a class="ae mw" href="https://www.npmjs.com/package/webpack-dev-server" rel="noopener ugc nofollow" target="_blank"> webpack-dev-server </a>托管。然而，当构建为微前端时，使用了一个不同的文件，称为microfrontend.js。这就是神奇之处，所以让我们来看看它。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="23f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> render() </strong></p><p id="7117" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该方法将<code class="fe or os ot ou b">App</code>呈现到用<code class="fe or os ot ou b">containerId</code>参数标识的容器中的DOM中，并将所有的<code class="fe or os ot ou b">data</code>作为道具传递给<code class="fe or os ot ou b">App</code>。</p><p id="9ec1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> unMount() </strong></p><p id="4a7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顾名思义，这个函数负责从DOM中移除挂载的<code class="fe or os ot ou b">App</code>。</p><p id="598f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">订阅()</strong></p><p id="fdd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe or os ot ou b">subscribe</code>方法在窗口上注册事件监听器来处理自定义事件，因为这些将是主机和微前端之间通信的常用方式。</p><p id="2d5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">退订()</strong></p><p id="3320" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个函数从窗口中移除注册的事件监听器。</p><p id="5124" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">客户事件</strong></p><p id="fbbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它是一个保存自定义事件的对象，可以从微前端进行调度。</p><p id="6bbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为webpack构建的结果，将创建一个包文件，其中包含一个在其他应用中使用时可以通过<code class="fe or os ot ou b">window</code>访问的库。在我的例子中，这些被称为<code class="fe or os ot ou b">mfCart</code>和<code class="fe or os ot ou b">mfProducts</code>。查看这个<a class="ae mw" href="https://github.com/burzaszsolt/react-micro-frontends/blob/master/mf-products/build/webpack.build.config.js" rel="noopener ugc nofollow" target="_blank">构建配置</a>以了解更多细节。</p><h2 id="3bac" class="od lu it bd lv oe of dn lz og oh dp md kb oi oj mh kf ok ol ml kj om on mp oo bi translated">主持</h2><p id="838f" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">现在让我们看看如何在宿主应用程序中使用这些库。我们有一个来自微前端构建的javascript文件。问题是如何将这个包添加到宿主应用程序中，以访问微前端及其方法。在本例中，我为此创建了一个定制的React挂钩，名为<code class="fe or os ot ou b">useMicrofrontend</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/219d2165faf0a5d954fe72aba540ea44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*-py8Vq9kGV2N5FWqDAEgZw.jpeg"/></div></figure><p id="bd1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么这里发生了什么？</p><ul class=""><li id="53f2" class="np nq it js b jt ju jx jy kb nr kf ns kj nt kn nu nv nw nx bi translated">钩子接收两个参数，<code class="fe or os ot ou b">id</code>和<code class="fe or os ot ou b">url</code>。</li><li id="b791" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">检查脚本是否已经添加到DOM中，并再次跳过加载。</li><li id="2c68" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">用提供的参数创建一个<code class="fe or os ot ou b">&lt;script&gt;</code>标签，并将其附加到DOM的<code class="fe or os ot ou b">&lt;body&gt;</code>中。</li><li id="f6d3" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">它将返回一个指示资源是否已加载的对象，并返回微前端本身，一旦它通过窗口对象可用。</li></ul><p id="c9ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重要的是要注意，通过这种方式，包是动态加载到页面上的。这意味着主页中的购物车微前端将不会被加载，以避免客户端不必要的下载。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ow"><img src="../Images/9bca8167671dfd30f18c637862b65103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWP5DEPmWGAwNniOOh5QJA.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">主页</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/19acf0c6d0c5c90b57e9d90736c43522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99C2me2h5P9B9Nih5t2KXg.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">导航到购物车页面后</figcaption></figure><p id="5542" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们来看看这个定制钩子的运行情况。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="b335" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">乍一看，有人可能会说它只呈现了一个带有id的<code class="fe or os ot ou b">&lt;div&gt;</code>，但是这里还有更多的内容。10号线上的<code class="fe or os ot ou b">useMicrofrontend</code>吊钩开始为<code class="fe or os ot ou b">mfProducts</code>装载捆。</p><ul class=""><li id="573e" class="np nq it js b jt ju jx jy kb nr kf ns kj nt kn nu nv nw nx bi translated">加载时，组件不会呈现任何内容。</li><li id="9479" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">如果加载了包，但微前端仍然不可用，组件将显示一条错误消息。</li><li id="dc05" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">最好的情况是加载了脚本并且微前端可用。在这种情况下，<code class="fe or os ot ou b">mfProducts</code>的<code class="fe or os ot ou b">render</code>方法可以用两个参数来访问和调用:由<code class="fe or os ot ou b">Products</code>组件呈现的div的id和我将在后面介绍的一些数据。因此，产品微前端将被安装到该div中。🎉🙌</li></ul><h2 id="b1bd" class="od lu it bd lv oe of dn lz og oh dp md kb oi oj mh kf ok ol ml kj om on mp oo bi translated">沟通</h2><p id="490f" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">主机应用程序的顶栏中有两个图标:一个显示购物车中有多少产品，用于导航到购物车页面，另一个用于在亮色和暗色主题之间切换。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/64294485d81495549b3d64a9b6dd701b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ervMKQ1ibuCyG7cXc_f0w.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">栏顶横木</figcaption></figure><p id="e58f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是，如果产品微前端处理向购物车添加产品，如何更新购物车徽章？这就是使用<a class="ae mw" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent" rel="noopener ugc nofollow" target="_blank">客户事件</a>发挥作用的地方。通过单击产品卡上的购物车图标，请求被发送到json-server。如果请求成功，就会从产品微前端调度一个自定义事件，指示产品已添加到购物车中。下面是<code class="fe or os ot ou b">CartBadge</code>组件，它监听自定义事件并相应地更新它的状态。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="406c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个组件中，可以再次使用自定义钩子来获取产品的微前端。这次不需要呈现它，而是通过从<code class="fe or os ot ou b">mfProducts</code>调用<code class="fe or os ot ou b">subscribe</code>方法将一个事件监听器附加到窗口。作为对<code class="fe or os ot ou b">useEffect</code>钩子的清理，事件监听器被<code class="fe or os ot ou b">unSubscribe</code>函数移除。自定义事件的类型也来自<code class="fe or os ot ou b">mfProducts</code>，所以我可以确保听到正确的事件。</p><p id="2ead" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们来看一个从主机应用程序到微前端的通信示例。我使用<a class="ae mw" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank"> Material-UI </a>来构建和设计组件。这个库提供了一种简单的方法来使用带有<a class="ae mw" href="https://material-ui.com/styles/api/#themeprovider" rel="noopener ugc nofollow" target="_blank"> ThemeProvider </a>组件的明暗主题。我需要做的就是将一个包含每个主题样式的对象传递给这个组件，并将我的应用程序包装在其中。听起来很简单，对吧？然而，大多数东西是由微前端渲染的，这超出了<code class="fe or os ot ou b">ThemeProvider</code>的范围。那么如何为他们应用相同的主题呢？当在宿主应用程序中呈现微前端时，所选主题被传递给<code class="fe or os ot ou b">render</code>方法。每个微前端都有自己的ThemeProvider，它用来自主机应用程序的主题进行初始化。这仍然很简单，但是如果我在主机应用程序中通过点击顶栏中的按钮来切换主题，会发生什么呢？嗯，在某些情况下，特别是当微前端有自己的状态时，重新渲染整个微前端将是一个糟糕的解决方案。因此，我们没有这样做，而是使用主机应用程序中选择的主题来调度一个<code class="fe or os ot ou b">HOST_THEME_CHANGED</code>自定义事件。微前端可以监听这个自定义事件，并向其<code class="fe or os ot ou b">ThemeProvider</code>提供接收到的数据。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="1adf" class="lt lu it bd lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm no mo mp mq bi translated">总结</h1><p id="a70e" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">与JayStack团队一起，我们已经为一个国际产品工作了一年多，这个例子是基于这个项目的经验。我们发现使用这种配置使用微前端非常简单，如果您有兴趣在React中使用它们，我希望这个例子能有所帮助。我已经试着涵盖了大部分内容，但是如果你有任何问题，请查看<a class="ae mw" href="https://github.com/burzaszsolt/react-micro-frontends" rel="noopener ugc nofollow" target="_blank">库</a>或者留下评论。</p><h1 id="77e8" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">更多…</h1><p id="97e5" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">如果你想了解更多，这里有一些关于微前端的有用链接。</p><div class="lb lc gp gr ld le"><a href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">微前端</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">Cam Jackson Cam Jackson是ThoughtWorks的一名全栈web开发人员和顾问，他对如何…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">martinfowler.com</p></div></div><div class="ln l"><div class="oy l lp lq lr ln ls ky le"/></div></div></a></div><div class="lb lc gp gr ld le"><a href="https://micro-frontends.org/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">微前端</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">与多个团队一起构建现代web应用程序的技术、策略和方法，这些团队可以发布功能…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">micro-frontends.org</p></div></div><div class="ln l"><div class="oz l lp lq lr ln ls ky le"/></div></div></a></div><div class="lb lc gp gr ld le"><a href="https://medium.com/stepstone-tech/microfrontends-extending-service-oriented-architecture-to-frontend-development-part-1-120b71c87b68" rel="noopener follow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">微前端—第1部分:将面向服务的架构扩展到前端开发</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">StepStone服务的主要产品——复杂作业板——迁移到微前端架构的案例研究</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">medium.com</p></div></div><div class="ln l"><div class="pa l lp lq lr ln ls ky le"/></div></div></a></div><div class="lb lc gp gr ld le"><a href="https://hackernoon.com/understanding-micro-frontends-b1c11585a297" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">了解微前端</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">作为一名前端开发人员，这些年来你一直在开发monoliths，尽管你已经知道这是一个糟糕的…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">hackernoon.com</p></div></div><div class="ln l"><div class="pb l lp lq lr ln ls ky le"/></div></div></a></div></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt le"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">编写面试问题</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">技术开发</p></div></div><div class="ln l"><div class="pc l lp lq lr ln ls ky le"/></div></div></a></div></div></div>    
</body>
</html>