<html>
<head>
<title>Writing a regex to detect a range of numbers? Why not just parse the string to integers instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写一个正则表达式来检测一系列数字？为什么不直接把字符串解析成整数呢</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-a-regex-to-detect-a-range-of-numbers-why-not-just-parse-the-string-to-integers-instead-8a24089eab0b?source=collection_archive---------0-----------------------#2020-04-14">https://levelup.gitconnected.com/writing-a-regex-to-detect-a-range-of-numbers-why-not-just-parse-the-string-to-integers-instead-8a24089eab0b?source=collection_archive---------0-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b25e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将字符串解析为整数和正则表达式匹配数值，哪一个是“更好”的选择？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/195a0d4c5b876a4927d02f82c9186454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eAz6-UCmjgbSqVflzuxnCw.png"/></div></div></figure><h2 id="bd77" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">我思考了这个问题，因为我正在探索一个基于bucket的方法，用Nginx做ab测试。</h2><p id="44b0" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">这个想法的前提是这样的。假设群组A包含10%的受众，而其余90%的受众被自动分配到群组b。如果我们要将群组A增加到20%，我们如何在生产中做到这一点，而不必重新分配群组A中的用户，同时确保持久性。</p><p id="4c1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">部分想法是使用带有数值的“桶”。每个群组将被分配一个数值范围(例如群组A的用户被分配0到19之间的值，而群组B的用户被分配20到99之间的值)。在Nginx中，作为ab测试的一部分，我们将测试这个赋值和正确群组的代理。但是，由于我们无法在Nginx中执行数值比较(这里的<a class="ae ly" href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#if" rel="noopener ugc nofollow" target="_blank">见</a>，不允许使用<code class="fe lz ma mb mc b">&lt;</code>和<code class="fe lz ma mb mc b">&gt;</code>等运算符)，使用正则表达式(regex)似乎是一个合适的解决方案。我还想构建一个范围正则表达式生成器来简化正则表达式的工作流程。</p><p id="4a39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在讨论评估正则表达式与将字符串解析为整数以进行条件检查的性能比较之前，让我们看看如何将一个数值范围分解为它的正则表达式。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="3ea4" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">正则表达式难题</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mk"><img src="../Images/712662903896c31fb5521c9f45e003cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qahD7BWK-9fvS3cFOQUasA.png"/></div></div></figure><p id="2df4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决这个问题最简单的方法是将数值范围转换为regex值，其中每个数字都出现在该范围内。0-99的简单范围将被转换为以下正则表达式。</p><pre class="kp kq kr ks gt ml mc mm mn aw mo bi"><span id="54df" class="la lb it mc b gy mp mq l mr ms">/^(0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55|56|57|58|59|60|61|62|63|64|65|66|67|68|69|70|71|72|73|74|75|76|77|78|79|80|81|82|83|84|85|86|87|88|89|90|91|92|93|94|95|96|97|98|99)$/</span></pre><p id="c05a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，上面没有利用regex的基本特性，比如检测一系列字符和分组。</p><p id="5eac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个例子是10、11、12这样的范围...19.由于每个数字的第一个字符在这个范围内是相同的，我们可以对第一个字符的正则表达式进行分组。另一个观察结果是，对于第二个字符，找到了0-9之间的所有数值，我们可以用regex中更简单的术语来验证这一点。产生的正则表达式如下:</p><pre class="kp kq kr ks gt ml mc mm mn aw mo bi"><span id="3e7a" class="la lb it mc b gy mp mq l mr ms">/^1[0-9]$/</span></pre><p id="e05c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将逻辑扩展到前面的查询0-99，我们得到一个更简单的regex值:</p><pre class="kp kq kr ks gt ml mc mm mn aw mo bi"><span id="f5a7" class="la lb it mc b gy mp mq l mr ms">/^[0-9]{1,2}$/</span></pre><p id="1644" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">长短正则表达式的性能如何匹配？在JavaScript中测试性能时，我得到了以下结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/ff879015e424a70a4515e636b82ee362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7qMCSY8bCDrbMChv-auUA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">性能指标评测，由jsperf.com提供— <a class="ae ly" href="https://jsperf.com/regex-length-perf" rel="noopener ugc nofollow" target="_blank">点击此处自行测试</a></figcaption></figure><p id="bc3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上所示，我运行了3次long和short正则表达式的性能基准，以确保得到一致的结果。结论是，虽然较短的正则表达式性能更好，但差别很小。然而，随着正则表达式在更长的范围内变得更长，我们可以预期这种差异也会变大。此外，较短的正则表达式更容易阅读，没有必要用较长的正则表达式淹没您的代码，尤其是如果涉及的数量和范围很大的话。</p><p id="b494" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">侧注: regex101有一个非常酷的规则分解和对所有regex事物的解释。请参阅下面对上述正则表达式值的解释:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/48e9c120025f5a54641f969cdbd6efe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUXlfewsn9JzbloRRSLmQA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">regex101 — <a class="ae ly" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">链接</a></figcaption></figure><h2 id="5d77" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">但是解决方法有那么简单吗？</h2><p id="81dc" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">通过上面的优化，我们发现我们遇到了另一个问题，那就是它仅仅是最终解决方案的一个子集。以2-99的范围为例。我们发现，我们不能简单地使用与0-99相同的解决方案，因为它也会将0和1测试为阳性。</p><p id="e81b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果我们从范围中删除2-9，并测试10-99，我们可以稍微修改之前的解决方案，以获得此子范围的可接受解决方案:</p><pre class="kp kq kr ks gt ml mc mm mn aw mo bi"><span id="eadb" class="la lb it mc b gy mp mq l mr ms">/^[1-9][0-9]$/</span></pre><p id="ba0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，检测2-9使人想起相同的问题，并且很容易解决:</p><pre class="kp kq kr ks gt ml mc mm mn aw mo bi"><span id="92d9" class="la lb it mc b gy mp mq l mr ms">/^[2-9]$/</span></pre><p id="c168" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将两种解决方案放在一起，我们就能得到该系列的解决方案:</p><pre class="kp kq kr ks gt ml mc mm mn aw mo bi"><span id="629e" class="la lb it mc b gy mp mq l mr ms">/^([2-9]|[1-9][0-9])$/</span></pre><h1 id="27e5" class="mz lb it bd lc na nb nc lf nd ne nf li ng nh ni ll nj nk nl lo nm nn no lr np bi translated">完整的解决方案</h1><p id="08b1" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">基于以上所述，我开始制定规则，作为生成正则表达式的完整解决方案，来检测一个范围内的数字。</p><ol class=""><li id="da45" class="nq nr it js b jt ju jx jy kb ns kf nt kj nu kn nv nw nx ny bi translated">获取可以表示为正则表达式的最大子范围，它通常位于整个范围的中间。该子范围通常从一个数字开始，该数字在该范围内具有最大数量的“0 ”,从右侧开始计数。该范围末端的数字通常具有与该子范围中的第一个数字相同的字符数量，并且具有与作为第一个数字的“0”数量相同的“9”数量。</li><li id="da82" class="nq nr it js b jt nz jx oa kb ob kf oc kj od kn nv nw nx ny bi translated">使用全范围左侧剩余的子范围，生成一个正则表达式。</li><li id="16ed" class="nq nr it js b jt nz jx oa kb ob kf oc kj od kn nv nw nx ny bi translated">使用全范围右侧剩余的子范围，生成一个正则表达式。</li></ol><p id="3ad0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看一个例子，将上述规则应用于2 - 98的范围:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/3a5bf826fd6526d25af3d1c2a8d0747d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-v5GnGtJpWEMJeU4bhmBVw.png"/></div></div></figure><p id="de1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">呜！好像成功了！</p><p id="490e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更复杂的怎么样，比如2 - 963？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/3f70e42c516ced18e692fe4fb9d74e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOrhGqAXpC1S4VE0xHHq0w.png"/></div></div></figure><p id="b656" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">啊哦。将整个范围分成3个子范围似乎并不能解决问题。但是如果你足够细心，你会看到在左边，我们已经解决了范围2 - 99的问题。我们能在两边迭代地应用解决方案，直到我们得到最终的解决方案吗？事实证明我们可以！</p><p id="3123" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">调整规则以匹配上述内容，我们得到了这些修改后的规则:</p><ol class=""><li id="bec6" class="nq nr it js b jt ju jx jy kb ns kf nt kj nu kn nv nw nx ny bi translated">….(和以前一样)</li><li id="e1a5" class="nq nr it js b jt nz jx oa kb ob kf oc kj od kn nv nw nx ny bi translated">使用全范围左侧剩余的子范围，生成一个正则表达式。<strong class="js iu">如果我们不能立即将这个子范围解析为一个正则表达式，那么将从1开始的所有步骤应用到这个子范围。</strong></li><li id="bafd" class="nq nr it js b jt nz jx oa kb ob kf oc kj od kn nv nw nx ny bi translated">使用全范围右侧剩余的子范围，生成一个正则表达式。<strong class="js iu">如果我们不能立即将这个子范围解析为一个正则表达式，则将从1开始的所有步骤应用到这个子范围。</strong></li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/02262cfbe616a952a03a6daef9b917be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYSA635MKRLgw_EEFvwLag.png"/></div></div></figure><p id="45f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">👍👍👍👍👍👍</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="744f" class="mz lb it bd lc na og nc lf nd oh nf li ng oi ni ll nj oj nl lo nm ok no lr np bi translated">构建正则表达式生成器</h1><p id="9a66" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">有了固定的规则，构建正则表达式生成器就是实现规则的关键。我决定用TypeScript构建一个简单的前端应用程序，这是我在工作中还没有探索过的东西。无论如何，这是发电机最辉煌的时刻:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="1d3c" class="mz lb it bd lc na og nc lf nd oh nf li ng oi ni ll nj oj nl lo nm ok no lr np bi translated">关键时刻到了</h1><p id="7906" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">有了正则表达式生成器，我决定带着这个比较基准“进城”。这里的测试是检查值(1234567)是否在0 - 12345678的范围内。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/e57a9add34bb0e39a901121968a3a23a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkGj9235XXYcjswbJROR4A.png"/></div></div></figure><p id="b4b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不，正则表达式解决方案的表现一直更差，大约差了98%。嗯，如果我简化匹配的值呢？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/c4fe761189266845b096c37b82e3a16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZP3fS00ECi_3IFBWYEW2OA.png"/></div></div></figure><p id="0b68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">遗憾的是，不管正则表达式有多复杂，与用JavaScript将字符串解析成数字相比，正则表达式解决方案的性能还是不够好。</p><p id="e7cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您对在自己的机器上运行上述测试感到好奇，请查看以下链接:</p><ul class=""><li id="141b" class="nq nr it js b jt ju jx jy kb ns kf nt kj nu kn op nw nx ny bi translated">复杂正则表达式vs parse int—【https://jsperf.com/regex-vs-parseint-comp T2】</li><li id="6da1" class="nq nr it js b jt nz jx oa kb ob kf oc kj od kn op nw nx ny bi translated">简单正则表达式vs parse int—【https://jsperf.com/simple-regex-vs-parseint-compe T4】</li></ul><p id="29bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论如何，这就是我对这个非常有趣的问题的全部看法。如果你有任何想法，请在评论中告诉我！</p><p id="5daa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再见。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="2e91" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="c953" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">经过JavaScript测试，解析字符串并进行比较比使用regex要快得多。</p></div></div>    
</body>
</html>