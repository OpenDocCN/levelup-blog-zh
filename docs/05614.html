<html>
<head>
<title>We need Deno in the browser! 🦕</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们需要在浏览器中显示Deno！🦕</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/we-need-deno-in-the-browser-ea069e4f590a?source=collection_archive---------15-----------------------#2020-09-14">https://levelup.gitconnected.com/we-need-deno-in-the-browser-ea069e4f590a?source=collection_archive---------15-----------------------#2020-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="82e5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个派生的节点替代方案如何为我们的用户界面带来革命性的微前端架构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/44ea3218d85793338c204e568de5ccd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pVn4hWtA3KRzDxov"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@daiga_ellaby?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Daiga Ellaby </a>拍摄的照片</figcaption></figure><p id="f3be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">微前端(MFEs)是一种UI架构理念。它最近越来越受关注，但也带来了许多悬而未决的问题。</p><p id="9932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">mfe与微服务后端架构一起出现，因此有许多一致的想法。以下是关键概念:</p><ol class=""><li id="fc1e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">每个MFE应该是一个完全独立的代码库。</li><li id="728c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">mfe不应该在相同的资源(包括DOM、状态、URL)上操作。稍后会详细介绍。)</li><li id="fc8c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">每个MFE需要单独部署，并从唯一的URL提供服务。</li></ol><p id="8fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自包含代码库意味着独立的Webpack构建(如果Webpack是您的选择)。MFEs最大的优势之一是能够增量地更新项目的各个部分。我曾经领导过一个项目，我们从Backbone到React重构了大约50万行代码。这是唯一可能的，因为大约有50，000行可以单独重构——我应该提到，50，000行对于MFE来说太大了，我们使用了一种混合方法。</p><p id="a8de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不在相同的资源上操作与我们不喜欢全局变量的原因是一样的。如果许多东西可以在同一个资源上操作，那么对代码的推理和调试就变得几乎不可能了。在您可以改变您正在工作的MFE之前，您必须了解其他MFE是如何工作的，这完全否定了首先进行MFE的价值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">两个mfe试图操作同一资源的真实镜头。</figcaption></figure><p id="76a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在UI中，我们被困在一些我们无法逃避的共享资源中，例如DOM。为了解决这个问题，你必须定义mfe的边界。例如，当呈现输入MFE时，您告诉它DOM中允许操作的特定元素。那是它将呈现自己的地方。</p><p id="c2ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三点是其他两点的结果。如果代码是自包含的，并且它执行的操作也是自包含的，那么在知道它对页面上的其他mfe没有影响的情况下，独立部署它是安全的。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="ab7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果您的每个mfe都是完全隔离的，并且可以放心地独立部署，那么您就一切顺利。问题是，您可能会为每个MFE发送大量的包。您可能使用输入组件发送React v16.8.1，但是使用TextBox组件发送React v16.8.2，使用DatePicker发送React v 16 . 8 . 3...</p><p id="a8e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会争辩说，如果你从React切换到像<a class="ae kv" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank">svelet</a>这样在编译时编译的东西，那么你就没有这个问题。虽然这是苗条的一个巧妙卖点，但它并没有解决问题。你的框架并不是你唯一依赖的库。</p><p id="8115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我意识到以下几点时，我对MFEs有了新的认识:</p><blockquote class="mp"><p id="d52b" class="mq mr iq bd ms mt mu mv mw mx my lr dk translated">微前端架构将您的依赖性从构建时转移到运行时。</p></blockquote><p id="deff" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">当您将一个输入组件作为一个MFE加载时，这有点像将它作为一个依赖项添加到package.json中，只不过您是实时获取依赖项，而不是在绑定代码时。</p><p id="ad82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将我们引向前端开发如何工作的圣杯:</p><blockquote class="mp"><p id="ab41" class="mq mr iq bd ms mt mu mv mw mx my lr dk translated">如果我们停止将所有的代码捆绑在一起，并使所有的依赖项都活起来，web开发将更加灵活，最终用户的速度成本将很小，甚至没有。</p></blockquote><p id="5b54" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如果您想知道这可能是什么样子，想象您删除了package . JSON——因为依赖项是活动的——并且您的组件看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne mh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">请忽略shonky html。我开始思考标记的有效性，然后意识到这真的与示例无关…</figcaption></figure><p id="4dfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终用户没有速度成本的原因是以下几个方面的结合:</p><ol class=""><li id="3cdf" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">使用^16.8.0语法浏览器可以解决许多依赖一个单一版本的库。</li><li id="2d74" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在访问一些网站后，最常见的依赖项将被缓存。</li><li id="2d61" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">浏览器制造商可能会开始将最常见的依赖项与其更新捆绑在一起。</li></ol><p id="3bf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仔细想想，捆绑是性能优化的噩梦:</p><blockquote class="nf ng nh"><p id="23d8" class="kw kx ni ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated">如果你有5个包，那么你必须缓存5个包。如果你让人们捆绑这些包的每一个可能的组合，你就有5个！(=120)个可能要缓存的包。</p></blockquote><h2 id="99f4" class="nm nn iq bd no np nq dn nr ns nt dp nu lf nv nw nx lj ny nz oa ln ob oc od oe bi translated">为什么这听起来很熟悉？</h2><p id="3d8a" class="pw-post-body-paragraph kw kx iq ky b kz of jr lb lc og ju le lf oh lh li lj oi ll lm ln oj lp lq lr ij bi translated">如果是的话，你可能会想到<a class="ae kv" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>。Deno是从<a class="ae kv" href="https://en.wikipedia.org/wiki/Ryan_Dahl" rel="noopener ugc nofollow" target="_blank">Ryan Dahl</a>—<a class="ae kv" href="https://en.wikipedia.org/wiki/Node.js" rel="noopener ugc nofollow" target="_blank">Node . js</a>的原创者衍生出来的Node-alternative。Deno的标题是它支持开箱即用的TypeScript，但它还有其他技巧来解决Ryan描述的“<a class="ae kv" href="https://github.com/denolib/awesome-deno/blob/master/resources/design-mistakes-in-node/design-mistakes-in-node.pdf" rel="noopener ugc nofollow" target="_blank">我对Node.js </a>感到遗憾的10件事”。</p><p id="2570" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中一个特性是，它去掉了package.json文件，转而以内联方式处理导入，有点像我上面展示的例子。</p><p id="cb8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个JavaScript存在于浏览器中。然后Node允许我们在服务器上运行JS。Deno已经开始尝试修复服务器上的一些问题。现在我想看到Deno中的这些修复开始回到浏览器中。</p><h2 id="3a3e" class="nm nn iq bd no np nq dn nr ns nt dp nu lf nv nw nx lj ny nz oa ln ob oc od oe bi translated">那么，我们如何将它放入浏览器呢？</h2><p id="10d6" class="pw-post-body-paragraph kw kx iq ky b kz of jr lb lc og ju le lf oh lh li lj oi ll lm ln oj lp lq lr ij bi translated">不幸的是，这个问题没有简单的答案。要在JavaScript中加入任何新功能，你必须向TC39技术委员会提交一份提案。从想法到出现在浏览器中的整个过程可能需要几年时间，如果一切顺利的话。据我所知，还没有人提出这个特性。</p><p id="0a9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你今天想使用它，最快的方法可能是定制一个巴别塔插件。你必须做以下事情:</p><ol class=""><li id="0ecf" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">(可以随便玩玩，但对大规模安全运营至关重要)</strong>设置一个CDN来托管您引用的每个npm包。你要找的是npm前面的CDN代理。第一次请求一个包时，它会将它代理给npm，之后它会缓存在您的CDN中。缓存可以是永恒的，因为所有的包都是结合它们的版本号来引用的，即。如果你缓存了React 16 . 0 . 0版本，你不需要一天后再回来检查React 16 . 0 . 0版本是否还是一样的。<a class="ae kv" href="https://jspm.org/" rel="noopener ugc nofollow" target="_blank"> JSPM已经这样做了</a>如果你可以使用外部资源。</li><li id="65c3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">创建一个依赖关系管理库，像npm一样处理依赖关系树的构建。它必须是动态的。当加载新的MFE时——带有新的依赖关系——依赖关系树必须更新以处理它<em class="ni">,而不破坏预先存在的依赖关系</em>。</li><li id="c178" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">创建一个Babel插件，将所有导入转换成对依赖管理库的引用。</li></ol><p id="36a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">据我所知，不存在这样的东西，我也不确定如果没有至少一些浏览器的合作，它的可行性或性能如何。由于不是所有的浏览器都支持JS模块(感谢IE11 ),你可能会发现很难让你的依赖管理器公开每个包的导出。您可以通过修改包在窗口上设置一个全局变量来解决这个问题，但是这样做太复杂了，而且可能很慢。</p><p id="fcba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你正在做一些类似的事情，请让我知道，我很想知道进展如何。否则，如果时间允许，我可能会尝试将其中一些作为开源项目。</p><p id="293c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">祝一切顺利，<br/>尼克</p></div></div>    
</body>
</html>