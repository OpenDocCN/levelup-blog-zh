<html>
<head>
<title>Why Write Rails View Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么要编写Rails视图测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-write-rails-view-tests-5a39b408702b?source=collection_archive---------18-----------------------#2021-03-30">https://levelup.gitconnected.com/why-write-rails-view-tests-5a39b408702b?source=collection_archive---------18-----------------------#2021-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7ba8f22f95a24b73a27866f9f78b938b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7c9igxcSO8PGFnfGkKxCg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">照片由</em> <a class="ae kg" href="https://unsplash.com/@nmsilva?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="kf">努诺席尔瓦</em></a><em class="kf"/><a class="ae kg" href="https://unsplash.com/s/photos/window-cleaning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="kf"/></a></figcaption></figure><p id="7be6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">有许多方法可以测试Ruby on Rails应用程序，但是有一种方法不经常讨论。这就是测试Rails视图的方式。是的——有控制器、模型和其他类型的测试，但我们很少看到视图层测试。让我们给他们更多的关注，看看他们是怎么回事。</p><p id="bb01" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你可能会问——那么，你为什么不写集成测试并用它们测试视图层呢？我可以，但是运行集成测试可能会很慢，编写一个简单的视图“单元”测试可能会更简单。另外，RSpec为编写视图规范提供了强大的支持。更有趣的是，我创建了一个示例项目来测试这些。让我们看看我发现了什么。</p><h1 id="2fbf" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">新项目，这是谁</h1><p id="26d6" class="pw-post-body-paragraph kh ki it kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le im bi translated">我创建了新的Rails 6.1项目，安装了RSpec，并使用以下代码生成了图书模型:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1c53" class="mr lg it mn b gy ms mt l mu mv">bin/rails generate scaffold Book title:string description:text download_url:string status:string</span></pre><p id="cfa1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">看看我得到了什么:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d890" class="mr lg it mn b gy ms mt l mu mv">...<br/><br/>    create      spec/views/books/edit.html.erb_spec.rb<br/>    create      spec/views/books/index.html.erb_spec.rb<br/>    create      spec/views/books/new.html.erb_spec.rb<br/>    create      spec/views/books/show.html.erb_spec.rb<br/><br/>...</span></pre><p id="cb37" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果我们看一下其中一个规格，我们可以找到以下代码:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="9b9c" class="mr lg it mn b gy ms mt l mu mv"># spec/views/books/index.html.erb_spec.rb<br/><br/>require 'rails_helper'<br/><br/>RSpec.describe "books/index", type: :view do<br/>  before(:each) do<br/>    assign(:books, [<br/>      Book.create!(<br/>        title: "Title",<br/>        description: "MyText",<br/>        download_url: "Download Url",<br/>        status: "Status"<br/>      ),<br/>      Book.create!(<br/>        title: "Title",<br/>        description: "MyText",<br/>        download_url: "Download Url",<br/>        status: "Status"<br/>      )<br/>    ])<br/>  end<br/><br/>  it "renders a list of books" do<br/>    render<br/>    assert_select "tr&gt;td", text: "Title".to_s, count: 2<br/>    assert_select "tr&gt;td", text: "MyText".to_s, count: 2<br/>    assert_select "tr&gt;td", text: "Download Url".to_s, count: 2<br/>    assert_select "tr&gt;td", text: "Status".to_s, count: 2<br/>  end<br/>end</span></pre><p id="b0e1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">有一个<code class="fe mw mx my mn b">type: view</code>表示特殊类型的规格。我们稍后会深入讨论这个问题。您可以区分出<code class="fe mw mx my mn b">assign</code>和<code class="fe mw mx my mn b">render</code>方法，这表明它们是内部定义的，而不是我们应该提供的。但是，在我做这个测试的时候，还有一件事一直困扰着我。</p><p id="fb23" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这里有趣的是，这个<code class="fe mw mx my mn b">assert_select</code>匹配器看起来有点“过时”或者好像不是来自RSpec世界。没有阶级<code class="fe mw mx my mn b">expect(...).to</code>的形成。这里发生的事情是，生成这些规格的模板有点脏。从2010年开始推回购时就没有变过。你可以在GitHub 上找到带来<code class="fe mw mx my mn b">assert_select</code> <a class="ae kg" href="https://github.com/rspec/rspec-rails/commit/800a56402ced481ae5b531e9a1d1a69bc8f66e90" rel="noopener ugc nofollow" target="_blank">的提交。</a></p><p id="1aa7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">别担心，我没有看到很多项目使用视图规范，更不用说生成模型和依赖那些生成的视图规范了。我想这就是为什么没有人花时间重构或改进现有的模板。但是，由于这篇博客文章是关于关注Rails视图测试的，所以让我们试着这样做。</p><h1 id="8ed6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">春季大扫除</h1><p id="dcf5" class="pw-post-body-paragraph kh ki it kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le im bi translated">如果我们看一下RSpec 中查看规范的<a class="ae kg" href="https://relishapp.com/rspec/rspec-rails/docs/view-specs/view-spec" rel="noopener ugc nofollow" target="_blank">文档，我们可以看到几乎所有的文档都使用了以下内容:</a></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3151" class="mr lg it mn b gy ms mt l mu mv">expect(rendered).to match /something/</span></pre><p id="0af7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们可以使用RSpec中的<code class="fe mw mx my mn b">match</code>和<code class="fe mw mx my mn b">include</code>。我们得到的是一个类似这样的测试:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="917d" class="mr lg it mn b gy ms mt l mu mv"># spec/views/books/index.html.erb_spec.rb<br/><br/>require 'rails_helper'<br/><br/>RSpec.describe "books/index", type: :view do<br/>  before(:each) do<br/>    assign(:books, [<br/>      Book.create!(<br/>        title: "Rails Testing",<br/>        description: "How to test Ruby on Rails applications.",<br/>        download_url: nil,<br/>        status: "draft"<br/>      ),<br/>      Book.create!(<br/>        title: "Rails Patterns",<br/>        description: "A book about patterns and anti-patterns in Ruby on Rails.",<br/>        download_url: "rails-patterns.com/download",<br/>        status: "published"<br/>      )<br/>    ])<br/>  end<br/><br/>  it "renders a list of books" do<br/>    render<br/><br/>    expect(rendered).to match(/Rails Testing/)<br/>    expect(rendered).to include("Rails Patterns")<br/><br/>    expect(rendered).to match(/How to test Ruby on Rails applications./)<br/>    expect(rendered).to include("A book about patterns and anti-patterns in Ruby on Rails.")<br/><br/>    expect(rendered).to include("rails-patterns.com/download")<br/><br/>    expect(rendered).to include("published")<br/>  end<br/>end</span></pre><p id="4631" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">之前的测试感觉更像是一个RSpec规范。但是，我们可以注意到，我们失去了检查实际内容是否在某个HTML标记中的能力。<code class="fe mw mx my mn b">assert_select</code>让我们在匹配预期结果时更加灵活。在<a class="ae kg" href="https://api.rubyonrails.org/v4.1/classes/ActionDispatch/Assertions/SelectorAssertions.html#method-i-assert_select" rel="noopener ugc nofollow" target="_blank">的文档</a>中你可以传递给<code class="fe mw mx my mn b">assert_select</code>更多的选项。我建议你选择你觉得能给你更多控制的选项。</p><h1 id="eceb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">利用水豚</h1><p id="8e47" class="pw-post-body-paragraph kh ki it kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le im bi translated">如果你安装了水豚，你可以像这样使用它的选择器:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4e6e" class="mr lg it mn b gy ms mt l mu mv">require "rails_helper"<br/><br/>RSpec.describe "books/index", type: :view do<br/>  before(:each) do<br/>    assign(:books, [<br/>      Book.create!(<br/>        title: "Rails Testing",<br/>        description: "How to test Ruby on Rails applications.",<br/>        download_url: nil,<br/>        status: "draft"<br/>      ),<br/>      Book.create!(<br/>        title: "Rails Patterns",<br/>        description: "A book about patterns and anti-patterns in Ruby on Rails.",<br/>        download_url: "rails-patterns.com/download",<br/>        status: "published"<br/>      )<br/>    ])<br/>  end<br/><br/>  it "renders a list of books" do<br/>    render<br/><br/>    expect(rendered).to have_selector("tr&gt;td", text: "Rails Testing")<br/>    expect(rendered).to have_selector("tr&gt;td", text: "Rails Patterns")<br/><br/>    expect(rendered).to have_selector("tr&gt;td", text: "How to test Ruby on Rails applications")<br/>    expect(rendered).to have_selector("tr&gt;td", text: "A book about patterns and anti-patterns in Ruby on Rails.")<br/><br/>    expect(rendered).to have_selector("tr&gt;td", text: "rails-patterns.com/download")<br/><br/>    expect(rendered).to have_selector("tr&gt;td", text: "published")<br/>  end<br/>end</span></pre><p id="6e56" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在，您得到了两个RSpec <code class="fe mw mx my mn b">expect(...).to</code>，并且得到了断言文本在表行内部的粒度。你可以在这里的repo中找到所有的代码和例子<a class="ae kg" href="https://github.com/nikolalsvk/rails-view-testing" rel="noopener ugc nofollow" target="_blank">。但是你为什么要使用这些呢？下面来讨论一下。</a></p><h1 id="672c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么要查看规格</h1><p id="7dab" class="pw-post-body-paragraph kh ki it kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le im bi translated">我们略读了您为什么要编写视图规范的几个原因。这个想法是为了测试你的观点或部分观点中的一些条件逻辑。编写一个覆盖视图中所有分支的集成测试运行起来会很慢，编写起来会很痛苦。视图规格在以下两者之间取得了巨大的平衡:</p><ul class=""><li id="b049" class="mz na it kj b kk kl ko kp ks nb kw nc la nd le ne nf ng nh bi translated">💸开发成本，</li><li id="6ba8" class="mz na it kj b kk ni ko nj ks nk kw nl la nm le ne nf ng nh bi translated">🏍执行速度，以及</li><li id="08e2" class="mz na it kj b kk ni ko nj ks nk kw nl la nm le ne nf ng nh bi translated">🔀条件呈现覆盖率。</li></ul><p id="90c0" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当然，如果您有装饰器和视图模型、表单对象以及所有其他可以将逻辑移出视图的东西，那么您可能根本不需要视图规范。但是，有时候，在现实世界中，并不是每个代码库都是完美设计的，你不得不不时地偷工减料。</p><p id="f355" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">不管是某个利益相关者盯着你。或者是复杂的遗留部分，不容易提取到您选择的设计中。无论原因是什么，您都可以选择让视图规范快速运行，并对逻辑进行测试。</p><p id="e6b1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当那一天到来的时候(或者已经到来了)，你可以回到这篇博文，按照你的喜好使用它。</p><p id="702e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果你喜欢这篇文章，你可以在Twitter上分享。考虑订阅<a class="ae kg" href="https://pragmaticpineapple.com/newsletter" rel="noopener ugc nofollow" target="_blank">时事通讯</a>来获取像这样的新文章。</p><p id="4258" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">下次再见，干杯。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="f0f8" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="nu">原载于2021年3月30日</em><a class="ae kg" href="https://pragmaticpineapple.com/why-write-rails-view-tests/" rel="noopener ugc nofollow" target="_blank"><em class="nu">【https://pragmaticpineapple.com】</em></a><em class="nu">。</em></p></div></div>    
</body>
</html>