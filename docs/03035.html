<html>
<head>
<title>Async Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步生锈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/async-rust-ece546f34231?source=collection_archive---------9-----------------------#2020-04-16">https://levelup.gitconnected.com/async-rust-ece546f34231?source=collection_archive---------9-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/2aa09d1c8e01f5a7d9be9812b7d93ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*c-2MCmrREKLfYCtQSpgb-w.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk translated">异步编程</figcaption></figure><div class=""/><p id="62c4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我认为可以肯定地说，Rust最令人期待的语言功能之一终于登陆了。我假设对Rust的语法和生态系统有一些基本的了解。但是在深入编码部分之前，让我们用异步的定义来涵盖异步编程的一些基本概念。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/e6b6f557f0b04b314bc36fed6f2f2ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*YgamoOv9N-iBIBJ4slC07g.png"/></div></figure><h1 id="4b27" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">异步定义:</h1><p id="5bfe" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">在Rust中，异步意味着不等待另一个任务完成，因为它可以在一个线程上并发运行代码或同时运行多个任务。多线程就像这样，但是有一个不同的概念。大多数情况下，当你有计算密集型任务(所谓的CPU密集型任务)时，就使用多线程。IO绑定是花费大量时间等待的任务，例如等待服务器的响应。</p><p id="5fa1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">异步编程让我们可以在单线程上同时运行多个IO绑定的计算，而不会浪费任何时间，因为当它们等待响应时，它们只是空闲的，因此在异步的帮助下，我们可以让计算机继续工作。</p><h1 id="a941" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么异步生锈:</h1><p id="1c51" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">Rust值得注意的一点是无所畏惧的并发性。这就是你应该被授权在不放弃安全的情况下同时做一些事情的概念。此外，Rust是一种低级语言，它是关于无所畏惧的并发性，而无需选择特定的实现策略。这意味着如果我们想要在不同策略的用户之间共享代码，我们必须对策略进行抽象以允许以后的选择。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/7c57f7cee1e4db9ea480f9799ad10dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*GFg-2q6iqCAobA0w9aI3qQ.png"/></div></figure><h1 id="6086" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">期货:</h1><p id="42fb" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">计算上的期货抽象。它们描述“什么”，独立于“在哪里”和“什么时候”。为此，他们的目标是将代码分解成小的、可组合的动作，这些动作可以由我们系统的一部分来执行。</p><h2 id="9c93" class="mi lf je bd lg mj mk dn lk ml mm dp lo km mn mo ls kq mp mq lw ku mr ms ma mt bi translated">让我们举一个例子来说明这一点:</h2><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="c30c" class="mi lf je mv b gy mz na l nb nc">use async_std::task;</span><span id="6f92" class="mi lf je mv b gy nd na l nb nc">// ^ we need this for task spawning</span><span id="78f1" class="mi lf je mv b gy nd na l nb nc">async fn negate_async(n: i32) -&gt; i32 {</span><span id="869c" class="mi lf je mv b gy nd na l nb nc">  println!(“Negating {}”, n);</span><span id="06e2" class="mi lf je mv b gy nd na l nb nc">  task::sleep(std::time::Duration::from_secs(5)).await;</span><span id="5b2f" class="mi lf je mv b gy nd na l nb nc">  println!(“Finished sleeping for {}!”, n);</span><span id="b1ac" class="mi lf je mv b gy nd na l nb nc">  n * -1</span><span id="afc4" class="mi lf je mv b gy nd na l nb nc">}</span><span id="7f8d" class="mi lf je mv b gy nd na l nb nc">async fn f() -&gt; i32 {</span><span id="b66e" class="mi lf je mv b gy nd na l nb nc">  let neg = negate_async(1);</span><span id="07a8" class="mi lf je mv b gy nd na l nb nc">  // … nothing happens yet</span><span id="9a99" class="mi lf je mv b gy nd na l nb nc">  let neg_task = task::spawn(negate_async(2));</span><span id="7619" class="mi lf je mv b gy nd na l nb nc">  // ^ this task /is/ started</span><span id="ec14" class="mi lf je mv b gy nd na l nb nc">  task::sleep(std::time::Duration::from_secs(1)).await;</span><span id="6656" class="mi lf je mv b gy nd na l nb nc">  // we sleep for effect.</span><span id="4fe6" class="mi lf je mv b gy nd na l nb nc">  neg.await + neg_task.await</span><span id="3b51" class="mi lf je mv b gy nd na l nb nc">  // ^ this starts the first task `neg`</span><span id="1212" class="mi lf je mv b gy nd na l nb nc">  // and waits for both tasks to finish</span><span id="df59" class="mi lf je mv b gy nd na l nb nc">}</span></pre><p id="3460" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的小代码片段中，事情是这样的。</p><p id="5457" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一行导入async_std::task。</p><p id="24f9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">异步函数negate_async接受一个带符号整数的输入，休眠5秒钟，然后返回该整数的取反版本。</p><p id="7dc3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">异步函数f更有趣:</p><p id="015a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">o第一行(let neg …)创建了negate_async函数的未来，并将其赋给neg变量。重要的是，它还没有开始执行。</p><p id="1fd2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">o下一行代码(let neg_task …)使用task::spawn函数开始执行negate_async返回的Future。与neg一样，negate_async返回的未来值被赋给neg_task变量。</p><p id="78c0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一个:我们睡一会儿。这是为了当任务开始运行时，从输出中可以明显看出。</p><p id="aaa7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们等待两个未来，将它们相加，然后返回。通过等待否定，我们开始执行未来，并运行到完成。由于neg_task已经开始，我们只需等待它完成。</p><p id="b945" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，这有什么结果呢？</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="64e5" class="mi lf je mv b gy mz na l nb nc">Negating 2</span><span id="3e84" class="mi lf je mv b gy nd na l nb nc"># &lt;- there’s a 1 second pause here</span><span id="2191" class="mi lf je mv b gy nd na l nb nc">Negating 1</span><span id="6bf4" class="mi lf je mv b gy nd na l nb nc">Finished sleeping for 2!</span><span id="735d" class="mi lf je mv b gy nd na l nb nc">Finished sleeping for 1!</span></pre><p id="54b5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们所看到的，第二个future，neg_task，一被调用就开始执行——多亏了task::spawn——而neg直到被等待才开始执行。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/9362b348014a179644bd3f1cdf97840e.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*fAHNsUYY969SDNdGk2LePA.jpeg"/></div></div></figure><h1 id="b541" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何在Rust中使用async-await:</h1><p id="9d43" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">您可能对JavaScript或C#中的async-await比较熟悉。Rust版本的功能类似，但没有什么关键区别。</p><p id="39af" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要使用async-await，您可以通过async fn而不是fn开始编写。</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="a4d0" class="mi lf je mv b gy mz na l nb nc">async fn first_function() -&gt; u32 { .. }</span></pre><p id="509d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与常规函数不同，调用异步fn不会立即产生任何效果。相反，它返回一个未来。这是一个等待执行的挂起计算。要实际执行未来，使用<code class="fe nj nk nl mv b">.await</code>操作符:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="4125" class="mi lf je mv b gy mz na l nb nc">async fn another_function() {</span><span id="5f91" class="mi lf je mv b gy nd na l nb nc">  // Create the future:</span><span id="e028" class="mi lf je mv b gy nd na l nb nc">  let future = first_function();</span><span id="5c6e" class="mi lf je mv b gy nd na l nb nc">  // Await the future, which will execute it (and suspend</span><span id="f282" class="mi lf je mv b gy nd na l nb nc">  // this function if we encounter a need to wait for I/O):</span><span id="bfef" class="mi lf je mv b gy nd na l nb nc">  let result: u32 = future.await;</span><span id="4bec" class="mi lf je mv b gy nd na l nb nc">  …</span><span id="ebf9" class="mi lf je mv b gy nd na l nb nc">}</span></pre><p id="c6cb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个例子展示了Rust和其他语言的第一个区别:我们写future.await而不是await future。该语法与Rust的<code class="fe nj nk nl mv b">?</code>操作符更好地集成在一起，用于传播错误(毕竟，这在I/O中很常见)。你可以简单地写<code class="fe nj nk nl mv b">future.await?</code>来等待未来的结果并传播错误。它还具有使方法链接变得不费力的优点。</p><h1 id="0255" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论:</h1><p id="c76c" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们相信，在稳定的Rust上拥有async-await将是Rust中许多令人兴奋的新开发的关键促成因素。如果你过去在Rust中尝试过异步I/O并遇到了问题——特别是如果你过去尝试过基于组合的期货——你会发现<a class="ae nm" href="http://aturon.github.io/tech/2018/04/24/async-borrowing/" rel="noopener ugc nofollow" target="_blank"> async-await与Rust的借用系统</a>集成得更好。</p><p id="eb7e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望它有助于理解Rust 中的<strong class="kd jf">异步编程，如果有任何反馈请告诉我。</strong></p><blockquote class="nn"><p id="c884" class="no np je bd nq nr ns nt nu nv nw ky dk translated"><strong class="ak"> <em class="nx">谢谢。</em> </strong></p></blockquote><p id="bee6" class="pw-post-body-paragraph kb kc je kd b ke ny kg kh ki nz kk kl km oa ko kp kq ob ks kt ku oc kw kx ky im bi translated"><strong class="kd jf">资源:</strong></p><p id="0a11" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae nm" href="https://thomashartmann.dev/blog/async-rust/" rel="noopener ugc nofollow" target="_blank">https://thomashartmann.dev/blog/async-rust/</a></p><p id="0a8a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae nm" href="https://book.async.rs/concepts/futures.html" rel="noopener ugc nofollow" target="_blank">https://book.async.rs/concepts/futures.html</a></p></div></div>    
</body>
</html>