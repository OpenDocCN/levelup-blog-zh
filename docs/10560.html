<html>
<head>
<title>A complete AWS Architecture for Module-federated micro-frontends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于模块联合微前端的完整AWS架构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-complete-aws-architecture-for-module-federated-micro-frontends-a0306ba466e3?source=collection_archive---------0-----------------------#2021-12-20">https://levelup.gitconnected.com/a-complete-aws-architecture-for-module-federated-micro-frontends-a0306ba466e3?source=collection_archive---------0-----------------------#2021-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="a7aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我的下一系列文章将介绍一个完整的无服务器架构，旨在基于<a class="ae ks" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank"> Webpack Module Federation </a>插件和<a class="ae ks" href="https://github.com/lerna/lerna" rel="noopener ugc nofollow" target="_blank"> Lerna </a>在AWS上部署和托管客户端mono-repo微前端。</p><p id="5cd0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所有AWS资源都将通过CDK提供，这意味着在几分钟内，您将获得部署到您的AWS帐户的生产就绪、可靠且可扩展的基础架构，允许您的团队独立扩展，并通过其独立的微前端交付快速业务迭代。</p><h1 id="5e7f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">建筑</h1><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/843aaa8afe203f54d8be0e0b2d72aaf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_OrAE8h81-7u_2x5DWJIw.png"/></div></div></figure><p id="4850" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该架构由3个主要部分组成:</p><ol class=""><li id="5999" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated">Mono-repo代码更改触发特定的部署管道。</li><li id="d6a5" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated">部署管道为目标AWS资源构建和部署捆绑包工件。</li><li id="4767" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated">为客户端微前端定制的全球可扩展托管基础设施。</li></ol><h1 id="2397" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">关于单一回购设置的一点</h1><p id="f467" class="pw-post-body-paragraph ju jv iq jw b jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ij bi translated">微前端是mono-repo设置的一部分，也就是一个包含独立web应用程序的子文件夹的单一存储库，通过Webpack模块联盟插件和Lerna粘合在一起。回购结构如下图所示:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/460a34f441e323f157eab26f1f63d23c.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*WJ7j1CvzaZ9Dn5CNY4doPQ.png"/></div></figure><p id="cb23" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你不耐烦，你可以在下面的要点中看到微前端是如何通过模块联合系统来表示的，这将在不久的将来详细讨论。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="74cc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简而言之，上面的代码允许我们将微前端建模为系统，这些系统可以作为Web组件惰性地加载到您的应用程序中。诀窍是在应用程序页面中动态注入每个微前端脚本，以便主机/外壳应用程序可以远程加载它们。如前所述，更多内容将在下一篇文章中介绍。现在，我们将看看前面提到的3个子体系结构。</p><h1 id="b861" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">单一回购触发器</h1><p id="bf62" class="pw-post-body-paragraph ju jv iq jw b jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ij bi translated">第一步的目标是捕获单个微前端repos更改，并触发它们供无服务器组件稍后使用。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/dae5a47c05d6118ebe96e33f25b592af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*8bLIHFGWteY4F7u_OJsafA.png"/></div></figure><p id="b4c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">开发人员通过Github将更改推送到他们所属的微前端，尽管对于其他众所周知的版本控制源平台(如BitBucket)也可以完成相同的操作。通过一个<a class="ae ks" href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks" rel="noopener ugc nofollow" target="_blank"> Github webhook </a>，通过ApiGateway暴露为Restful api的Lambda函数处理变更。Lambda的主要目标是将微前端代码变更与它们的目标管道相关联。这种方法的手动演练可以在这里<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/a-server-less-ci-cd-approach-for-mono-rep-micro-frontends-e91261bbdf69">欣赏</a>，而它的CDK实现将是下一篇文章的一部分。</p><h1 id="3ba9" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">部署管道</h1><p id="68a9" class="pw-post-body-paragraph ju jv iq jw b jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ij bi translated">第二步的目标是确保单个微前端回购变更触发单个代码管道。这鼓励团队独立性，就好像只有一个微前端被修改(例如:mfe-app1)，我们只想触发它的相关管道，而不是所有其他的。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi na"><img src="../Images/057d3410a121e8a2c35d98d62e21010f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*vQTICQ0SDtJg4VKNL4PAeg.png"/></div></figure><p id="f9bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦关联了代码变更，AWS代码管道就会启动。这包括四个主要步骤:</p><ul class=""><li id="492b" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr nb mj mk ml bi translated"><em class="nc">代码管道</em>本身，它管理GitHub连接并获取相关的GitHub源代码</li><li id="19a3" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr nb mj mk ml bi translated"><em class="nc">代码构建</em>，它将接收源代码构建到构建工件中。由于微前端是基于JavaScript的，它们将利用yarn将它们构建成一组包，供下一步使用。</li><li id="9de6" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr nb mj mk ml bi translated"><em class="nc">代码展开</em>。这一步采用前面步骤中构建的捆绑文件，并将它们部署到一个简单的存储服务(S3)中。每个微前端都将存储在一个独立的“文件夹”(或密钥)中，这样它们就可以单独部署。</li><li id="e771" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr nb mj mk ml bi translated"><em class="nc">代码构建缓存失效</em>。最后一步是另一个代码构建步骤，它确保每次我们在S3上发布和部署新的工件时，CloudFront缓存都会失效。</li></ul><h1 id="3b24" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">托管基础设施</h1><p id="0a93" class="pw-post-body-paragraph ju jv iq jw b jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ij bi translated">最后但同样重要的是，需要调配基础AWS资源。这最后一步的目标是确保通过可扩展、简单、智能且可靠的架构实现这一点。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/83ff4a66f3c7c41ec08bea4d29d30f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*zK1QOLn0giIQ_85rkUEUAw.png"/></div></figure><p id="1d71" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有了上述子架构，终端用户将通过受WAF 保护的CloudFront发行版<a class="ae ks" href="https://aws.amazon.com/waf/" rel="noopener ugc nofollow" target="_blank">访问web应用，因为微前端是面向客户的优化应用。CloudFront通过一个</a><a class="ae ks" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html" rel="noopener ugc nofollow" target="_blank"> OAI </a>身份连接到私有的S3桶，确保数据只能通过CDN公开访问，而不能直接从桶中访问。CloudFront使用一个<a class="ae ks" href="https://aws.amazon.com/lambda/edge/" rel="noopener ugc nofollow" target="_blank"> Lambda@Edge </a>函数对来自单个存储桶的不同来源进行适当的调度。</p><h1 id="996c" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">CDK统治他们所有人</h1><p id="1176" class="pw-post-body-paragraph ju jv iq jw b jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ij bi translated">所有上述内容都将通过包含一个堆栈的CDK应用程序来提供。</p><p id="6ace" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">微前端堆栈包括三个构造，提供用于托管应用的基础AWS资源和所有部署相关资源，包括代码管道、S3桶、Lambda@Edge函数、CloudFront分发和各种IAM策略、角色和OAI，以支持连接到GitHub的正确隐私和安全性。</p><p id="64f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">只有在将您的基础设施部署到非us-east-1的区域时，另一个堆栈才是隐式堆栈，因为它是在通过CDK实验性CloudFront API提供Lambda@Edge功能时创建的，因为它必须在特定的AWS区域上部署Lambda@Edge(所有Edge功能默认使用us-east-1)。</p><h1 id="5880" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h1><p id="9190" class="pw-post-body-paragraph ju jv iq jw b jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ij bi translated">这篇文章故意给人一种悬而未决的感觉，因为涉及的内容太多了。它给出了一个事实上的无服务器AWS架构的高层次概述，该架构用于托管和部署基于模块联合Webpack插件的mono-repo微前端。接下来的文章将深入探讨这是如何实现的，所以请继续关注；)</p></div></div>    
</body>
</html>