<html>
<head>
<title>Static Classes and Methods—Are They Terrible?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">静态类和方法——它们很糟糕吗？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/static-classes-and-methods-are-they-terrible-c9c611a921b3?source=collection_archive---------2-----------------------#2021-06-13">https://levelup.gitconnected.com/static-classes-and-methods-are-they-terrible-c9c611a921b3?source=collection_archive---------2-----------------------#2021-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="da84" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从设计角度探索C#静态类和方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/425f9bc2fda6b9252c4e4953720ff5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LebeCBoEVKy_Sgk6"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">阿诺德·弗朗西斯卡在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="631b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态类和方法是有争议的编程工具之一。</p><ul class=""><li id="e4e8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">静态类和方法是糟糕的设计和编码实践吗？</li><li id="4b49" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用静态类会使单元测试变得复杂吗？</li><li id="2518" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">什么时候静态方法是唯一可行的选择？</li><li id="d965" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个类什么时候应该是静态的，什么时候应该是非静态的？</li></ul><p id="678b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将解决这个问题和其他问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6136" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">静态类和状态突变</h1><p id="9f93" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用静态类，耦合应用程序的多个部分变得非常容易。</p><p id="b95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当应用程序的不同部分使用的静态类没有状态并且总是返回确定的结果时，这没有什么错。</p><p id="32a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个静态类<code class="fe nn no np nq b">Math</code>的例子:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="86a6" class="nv mr it nq b gy nw nx l ny nz">public static class Math<br/>{<br/>   public static double Sum(double x, double y)<br/>   {<br/>       return x + y;<br/>   } <br/>}</span></pre><p id="cc40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类是无状态的，它的输出总是可预测的。<code class="fe nn no np nq b">Math</code>类可以直接用于应用程序的许多部分，没有副作用的风险。</p><p id="db84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当一个静态类有状态时，事情变得复杂得多。</p><blockquote class="oa"><p id="902a" class="ob oc it bd od oe of og oh oi oj lu dk translated">有状态静态类与全局变量相同。</p></blockquote><figure class="ol om on oo op kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f5d7e6e2b95747f89f6c372833bb2546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0X9IevxHICgfoeaE6lkFg.png"/></div></div></figure><p id="8523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用程序的一部分中更改静态类的状态会影响依赖于该状态的应用程序的其他部分的行为。这被称为副作用，会显著降低应用程序的可维护性。因此，静态类应该<strong class="lb iu">设计成无状态</strong>以避免副作用。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="cff1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">静态类和紧密耦合</h1><p id="30c5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">静态类依赖总是编译时依赖。换句话说，静态依赖与使用它的类紧密耦合。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="8c9b" class="nv mr it nq b gy nw nx l ny nz">public class Calculator<br/>{<br/>   public int CalculateValue()<br/>   {<br/>       <strong class="nq iu">//Math dependency is tightly coupled to Calculator object</strong><br/>       var max = <strong class="nq iu">Math</strong>.Max(1, 2); <br/>        <br/>       ...<br/>   }<br/>}</span></pre><p id="ecc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用紧耦合，不可能实现多态行为，因为没有办法在运行时用静态类B替换静态类A。</p><p id="128c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">紧密耦合不一定是开发人员应该不惜一切代价避免的坏事。每个现有的类。NET应用程序与许多静态类和方法紧密耦合，这里仅举几个常见的例子:</p><ul class=""><li id="1c50" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nn no np nq b">string.IsNullOrEmpty(value);</code></li><li id="ec8f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">TimeSpan.FromSeconds(value);</code></li><li id="6b5e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">Math.Sqrt(value);</code></li></ul><p id="d9dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，开发人员通常不会试图以这样的方式将这些类型从它们的类中分离出来:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="e057" class="nv mr it nq b gy nw nx l ny nz">public class Service<br/>{<br/>   private readonly IString _string;<br/>   private readonly ITimeSpan _timeSpan;<br/>   private readonly IMath _math;</span><span id="a20c" class="nv mr it nq b gy oq nx l ny nz">   public Test(IString string, ITimeSpan timeSpan, IMath math)<br/>   {<br/>      _string = string;<br/>      _timeSpan = timeSpan;<br/>      _math = math;<br/>   }</span><span id="af70" class="nv mr it nq b gy oq nx l ny nz">   //...<br/>}</span></pre><p id="506e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于单元测试或其他目的，开发人员不关心从<code class="fe nn no np nq b">string</code>、<code class="fe nn no np nq b">TimeSpan</code>、<code class="fe nn no np nq b">Math</code>等依赖关系中抽象出他们的代码的主要原因之一是因为它们是稳定的。</p><p id="1c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<strong class="lb iu">稳定依赖</strong>的主要特征:</p><ul class=""><li id="83ea" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">稳定依赖是无状态的。</li><li id="03d8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">稳定的依赖总是产生确定性的结果(包含<a class="ae ky" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯函数</a>)。</li><li id="c0f6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">开发者不需要为另一个改变稳定依赖的实现。</li><li id="4b44" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">稳定依赖关系的新版本与旧版本向后兼容。</li></ul><p id="d3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与稳定依赖相比，还有<strong class="lb iu">易变依赖</strong>，以下是它们的主要特征:</p><ul class=""><li id="5958" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">易变依赖项的行为可能依赖于外部世界，如文件系统、数据库、外部服务。</li><li id="8173" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">易变依赖可能返回不确定的结果(<code class="fe nn no np nq b">DateTime.Now</code>是易变依赖的一个简单例子，这就是为什么开发人员通过包装类从代码中抽象出它)。</li><li id="1c73" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将来可以用新的实现替换易变的依赖关系。</li><li id="702c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">易变的依赖关系会改变状态。</li></ul><blockquote class="oa"><p id="be35" class="ob oc it bd od oe or os ot ou ov lu dk translated">开发人员在考虑创建一个静态类时应该回答的主要问题是，它将包含稳定行为还是不稳定行为。</p></blockquote><p id="6323" class="pw-post-body-paragraph kz la it lb b lc ow ju le lf ox jx lh li oy lk ll lm oz lo lp lq pa ls lt lu im bi translated">易变依赖应该设计成非静态类，并使用接口注入构造函数。</p><p id="f204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稳定依赖项可以被设计成静态类，因为不需要用其他实现来替换它们，也不需要从稳定依赖项中单独测试应用程序逻辑。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3b79" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">静态依赖是隐式依赖</h1><p id="2dd2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">通常，除了非常简单的类之外，所有的类都需要依赖。这些依赖项可以是非静态的或静态的类。</p><p id="e5e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非静态依赖的实例通常被注入到类构造函数中。这样的依赖被称为<strong class="lb iu">显式</strong>。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="9c53" class="nv mr it nq b gy nw nx l ny nz">public class DocumentBuilder <br/>{<br/>    private IFileParser _fileParser;</span><span id="fae2" class="nv mr it nq b gy oq nx l ny nz">    public DocumentBuilder(IFileParser fileParser) <strong class="nq iu">//Explicit dep.</strong><br/>    {<br/>        _fileParser = fileParser;<br/>    }<br/>}</span></pre><p id="481a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在分析和维护类时，显式依赖对于开发人员来说非常方便。为了理解一个类使用了什么依赖关系，开发人员只需要看看这个类的构造函数。</p><p id="5899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，静态类没有实例，所以没有办法将静态类注入构造函数。静态依赖总是隐式的。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="1156" class="nv mr it nq b gy nw nx l ny nz">public class DocumentBuilder <br/>{<br/>    public DocumentBuilder() <br/>    {<br/>    }</span><span id="f795" class="nv mr it nq b gy oq nx l ny nz">    public Document Build()<br/>    {<br/>        var file = FileParser.Parse(); <strong class="nq iu">//Implicit dep.</strong></span><span id="d5e9" class="nv mr it nq b gy oq nx l ny nz">        //...<br/>    }<br/>}</span></pre><p id="1d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解一个类使用什么样的静态依赖，开发人员需要查看该类的整个实现。</p><p id="64b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能认为显式的非静态依赖总是比静态隐式依赖好，但事实上它取决于。</p><p id="c01a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于开发人员来说，隐式使用静态依赖比将非静态依赖注入构造函数更容易。不需要在依赖注入容器中设置静态依赖，也不需要在单元测试期间模仿静态依赖(这是稳定的)。</p><h2 id="28bd" class="nv mr it bd ms pb pc dn mw pd pe dp na li pf pg nc lm ph pi ne lq pj pk ng pl bi translated"><strong class="ak">使静态依赖显式化</strong></h2><p id="a44e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">对于总是试图避免隐式依赖的开发人员来说，有几种方法可以实现这个目标。</p><p id="8706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种也是最明显的方法是将静态类转换为非静态类，并将它的一个实例注入构造函数中。如果开发人员能够完全控制定义静态类的源代码，这种解决方案将会奏效。</p><p id="8cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种解决方案适用于开发人员需要利用单独库中的静态类，而源代码不能被修改的情况。解决方案是在静态类上创建一个非静态包装器/代理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="b7a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了将静态依赖转换为非静态依赖，开发人员还从第三方库代码中抽象出应用程序代码，这允许在不大量重构应用程序的情况下更改第三方库。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5d45" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">对象实例化的构造函数与静态工厂方法</h1><p id="888f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">构造函数是有特殊用途的函数，即创建对象。</p><p id="f689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实例化一个类，开发人员通常调用它的公共构造函数。</p><p id="fbad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构造函数和常规函数的区别之一是，开发人员不能随心所欲地命名构造函数。构造函数的名称必须与定义它的类的名称相匹配。当有多个重载构造函数从不同的参数集实例化一个类时，这种细微差别会使代码变得复杂。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="2670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，任何想要创建对象的人都需要阅读构造函数体，可能还有类实现的其余部分，以选择调用哪个构造函数重载。</p><p id="e9dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个例子，重载的构造函数根本不能使用，客户端需要另一个选项。</p><p id="8892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设开发人员正在设计一个时间跨度结构，他们想让客户能够在几秒钟、几分钟或几小时内实例化一个对象。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="a199" class="nv mr it nq b gy nw nx l ny nz">public struct TimeSpan<br/>{<br/>    public TimeSpan(double seconds)<br/>    {</span><span id="f117" class="nv mr it nq b gy oq nx l ny nz">    }</span><span id="2e8c" class="nv mr it nq b gy oq nx l ny nz">    public TimeSpan(double minutes)<br/>    {</span><span id="a075" class="nv mr it nq b gy oq nx l ny nz">    }<br/>}</span></pre><p id="f513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于相同的构造函数签名，这样的代码甚至无法编译。</p><p id="f4cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述两个问题都可以通过将公共构造函数私有并公开公共静态方法来很好地解决，客户端可以使用这些方法来获取该类的实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="2737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">ProposalStatus</code>类的实例现在只能通过调用静态方法<code class="fe nn no np nq b">Accepted</code>或<code class="fe nn no np nq b">Rejected</code>来实例化。方法名清楚地声明了客户端代码实例的用途。在这里，静态工厂方法是比公共重载构造函数更好的选择。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="74d9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">静态类和面向对象</h1><p id="8703" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">与非静态类相比，静态类有几个限制:</p><ul class=""><li id="f3bd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">静态类不能从另一个类继承。</li><li id="4290" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">静态类不能是另一个静态或非静态类的基类。</li><li id="1fc0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">静态类不支持虚方法。</li><li id="4619" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">静态类不能实现接口。</li></ul><p id="5fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些限制使得静态类在需要多态行为的地方不可用。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e3bf" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="299f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用静态类和方法没有问题。它只是一个工具，像其他任何工具一样，可以被滥用。</p><p id="4076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您知道如何在代码库中正确应用静态类和方法，您将从中受益。如果您对声明一个静态类还没有信心，您总是可以选择只使用非静态类。</p><p id="490c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在静态类更好的地方使用非静态类，几乎总是会使代码更麻烦。然而，过多地使用静态类会影响应用程序的可维护性。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="f514" class="nv mr it bd ms pb pc dn mw pd pe dp na li pf pg nc lm ph pi ne lq pj pk ng pl bi translated">我的其他文章:</h2><div class="po pp gp gr pq pr"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd iu gy z fp pw fr fs px fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf ks pr"/></div></div></a></div><div class="po pp gp gr pq pr"><a href="https://medium.datadriveninvestor.com/estimation-hell-or-what-can-developers-do-better-with-their-estimates-614f9e71f43d" rel="noopener  ugc nofollow" target="_blank"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd iu gy z fp pw fr fs px fu fw is bi translated">评估地狱，或者开发人员如何利用他们的评估做得更好？</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">估计过程很难，但没那么难。</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">medium.datadriveninvestor.com</p></div></div><div class="qa l"><div class="qg l qc qd qe qa qf ks pr"/></div></div></a></div><div class="po pp gp gr pq pr"><a rel="noopener  ugc nofollow" target="_blank" href="/7-outstanding-practical-tips-with-examples-for-oop-software-developers-44f0d11b23df"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd iu gy z fp pw fr fs px fu fw is bi translated">7面向对象编程和设计实用技巧(附例子)</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">改进软件应用程序设计的实践。</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="qa l"><div class="qh l qc qd qe qa qf ks pr"/></div></div></a></div></div></div>    
</body>
</html>