<html>
<head>
<title>Curse of Recursion in .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归的诅咒。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/curse-of-recursion-in-net-c-b017271ddbe6?source=collection_archive---------4-----------------------#2022-02-02">https://levelup.gitconnected.com/curse-of-recursion-in-net-c-b017271ddbe6?source=collection_archive---------4-----------------------#2022-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5443" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">最佳实践</h2><div class=""/><div class=""><h2 id="68c2" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">为什么以及如何在？NET C#</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3b2aca5701db84d39b093ebfc3eda82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0O7VNtg__LIHgU8QjcR-Rg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@tine999?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂内·伊万尼奇</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><p id="c460" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我在执行代码评审时经常遇到的一个著名错误是过多地使用了<strong class="lk jd">递归</strong>。</p><p id="aaa2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我现在能听到有人在问:</p><blockquote class="me mf mg"><p id="c32f" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">递归有什么问题？！！</p></blockquote><p id="d828" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我的回答是:</p><blockquote class="me mf mg"><p id="9f37" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">如果你知道何时以及如何使用递归，它并不总是坏的。有时候，你可能会错过一些更好的选择。</p></blockquote><p id="e21b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用递归的主要问题是它在内存消耗方面代价太高。这就是为什么你需要谨慎使用它。</p><p id="7fff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你不相信我，对吗？让我给你看一个例子。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><div class="mm mn gp gr mo mp"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jd gy z fp mu fr fs mv fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">medium.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd lb mp"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ne"><img src="../Images/7257c5384d6e893eaa77313accdf250f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLCL0kojxDyr_B3oCxMIEA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">节点系列示例。由<a class="ae lh" href="https://unsplash.com/@onderortel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安德·罗特</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="add8" class="nf ng it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">节点系列示例</h1><p id="9d81" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">假设我们有一系列节点，其中每个<code class="fe oc od oe of b">Node</code>都引用它旁边的节点。我们的主要目标是遍历这一系列节点。</p><p id="1bbc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，首先我们如下定义我们的<code class="fe oc od oe of b">Node</code>类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="8fe2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在是时候实现一个方法来遍历树了，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="4883" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个方法中，我们以这样的方式使用递归，每个<code class="fe oc od oe of b">Node</code>负责从它开始遍历系列的其余部分。</p><p id="35b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很棒吧？好吧，可以，但是让我给你看样东西。</p><p id="f506" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们试着做同样的工作，但是现在用循环代替递归。所以，按照这种思路，我们最终应该得到这样的结果:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="c633" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，在这个方法中，我们使用循环来遍历节点。</p><p id="b1c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们开始调用这些方法，看看它们是否会产生相同的结果。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="3ed9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们只是创建一系列5000个节点，然后调用这两个方法；<code class="fe oc od oe of b">TraverseTreeUsingRecursion</code>和<code class="fe oc od oe of b">TraverseTreeUsingLoops</code>。</p><p id="5245" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行该应用程序，我们应该得到类似这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/1f64861240edddc31fbad7cb6685cf7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pUAA48R4HvVEVN9Qm6zjg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nh">结果</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="50fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，两种方法都返回相同的结果，一个包含5000个节点名的列表。</p><p id="0ca6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，我们能说两种方法在性能和内存消耗上完全一样吗？让我给你看一些有趣的东西。</p><p id="4504" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我对这两种方法进行了内存分析，结果如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/8cc1e54c3d97eaf0dd26b6b5f500a328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvsjRI9gLFz28VMyf5RIbQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nh">递归期间的内存分析</strong>。图片来自<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a></figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/89fce43efd571263528a1203b43b0247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ETGSLHmE9jD4nvKQ-nLFtQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nh">循环期间的内存分析</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="9c79" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您能注意到这两种情况下内存分配的巨大差异吗？是的，这是真的；<strong class="lk jd">递归</strong>太贵了。</p><p id="137a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，老实说，在这个例子中，即使使用了<strong class="lk jd">递归</strong>，我们也可以应用一些修改来增强性能和内存分配，以匹配循环实现。</p><p id="425f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我听到你问:</p><blockquote class="me mf mg"><p id="ed02" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">怎么会？？？</p></blockquote><p id="fb76" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我给你看一些有趣的东西。让我们来看看<strong class="lk jd">递归</strong>是如何工作的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/9f2e8ced9610e52dbf4db94a72c9aac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*QyBcjJzvrlj_zgPrMNLvRA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nh">递归函数</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="472c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个简单的递归函数。如你所见，我们在递归调用之前有一些代码，递归调用，最后是递归调用之后的代码。</p><p id="a157" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当调用这个函数时，这就是内存分配的情况。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/1ca7a15150faf08dacef7da912ad172a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9eU3JtRTDFHwaOdJXwWZA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nh">递归函数内存分配</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="2a9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，在遍历递归调用时，内存分配会增加，而内存释放直到最后一个/最深的递归调用被解决后才会开始。</p><p id="6277" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，这里值得注意的是{递归调用之前的代码}在内存分配中的贡献最大。因此，这段代码需要的内存分配越大，整个递归调用的开销就越大。</p><p id="55f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由此我们可以得出结论，如果我们能够最小化{递归调用之前的代码}所需的内存分配，这将显著减少整个递归方法的总内存分配。</p><p id="7f13" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，回到我们的例子。尝试最小化{递归调用前的代码}的内存分配，我们可以执行以下操作:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="ae25" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看，我们不是在每次递归调用时创建一个<code class="fe oc od oe of b">new List&lt;string&gt;</code>,而是传递一个对列表的引用。因此，所有级别都使用相同的列表，因此每次递归调用都不需要分配内存。</p><p id="7aee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，调用<code class="fe oc od oe of b">TraverseTreeUsingRecursion</code>应该如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="3636" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">内存分析如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/ea116623b1be4e50d59fc2a1868658d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLNhsuVPLhbRGXVXeXguFg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nh">增强递归期间的内存分析</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="bafb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看，这完全不同。</p><p id="10eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里值得一提的是，在<strong class="lk jd">递归</strong>方法上实现相同的增强方法并不总是容易的。有时候通话太复杂。在这种情况下，我们有其他的处理方法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/55c27af086b7cbf2c61db7ccd37c81be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4qsjczpIZgE5slBPRHiEA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">调查结果。照片由<a class="ae lh" href="https://unsplash.com/@javaistan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Afif Kusuma </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="b309" class="nf ng it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">调查的结果</h1><p id="59be" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">正如我告诉你的，在执行代码评审时，我曾经遇到过一些过多的不必要的<strong class="lk jd">递归</strong>用法。这种情况已经发生了一段时间。</p><p id="d92f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我决定研究这种方式，试图了解开发人员在这一点上的想法。因此，每次遇到这种情况，我都决定停下来问问开发商。</p><p id="7fb9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">大部分的回答都是关于他没有多想。使用递归对他来说是合理的选择，他甚至没有停下来想一想。</p><p id="2802" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，很明显，有时<strong class="lk jd">递归</strong>似乎更自然，更类似于我们大脑的工作方式。简单来说，当你发现自己在脑海中重复一些逻辑时，你的大脑瞬间尖叫<strong class="lk jd"> <em class="mh">递归</em> </strong>。</p><p id="487f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，如果你问我，我会建议你抵制使用递归的冲动，并总是试图找到一种替代方法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/dcc14252581f85d473e7a46b45dfdda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hb1mtRLM5acFJSOtrOsrOQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">总是有可能吗？照片由<a class="ae lh" href="https://unsplash.com/@emilymorter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾米丽·莫特</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="13bf" class="nf ng it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">总是有可能吗？</h1><p id="689e" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">现在，你可能会想到的问题是:</p><blockquote class="me mf mg"><p id="0a5b" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">我们总是可以用循环来代替递归吗？</p></blockquote><p id="889c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不完全是。有时候递归可能是唯一的方法，但是请相信我，在很多情况下，你可能会错过另一种选择，因为你更关注于小图。</p><p id="fde5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我通常会做的是，当我发现自己试图使用<strong class="lk jd">递归</strong>时，我会尝试访问一些概念，看看它们是否可以替代。</p><p id="0e2d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像这样的概念:</p><ul class=""><li id="90e3" class="oq or it lk b ll lm lo lp lr os lv ot lz ou md ov ow ox oy bi translated">使用循环？</li><li id="ec2d" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated">使用堆栈和队列？</li><li id="81fa" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated">使用缓存映射(如在动态编程中)？</li><li id="b624" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated">以自下而上的方式使用循环(如在动态编程中)？</li></ul><p id="15f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果这些中的任何一个或一些帮助我达到相同的结果，我通常会做一些性能和内存分析，将它们与递归进行比较，并最终使用它们之间的最佳者。</p><p id="c9a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下一节中，我将向您展示我最喜欢的替代<strong class="lk jd">递归</strong>的方法之一，即<strong class="lk jd">以自底向上的方式使用循环</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pe"><img src="../Images/8c3b63f5c3f23cb3c062b9a3d04f1747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFkhmjSRQ-vwE3wWcflY8g.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">以自下而上的方式使用循环。由<a class="ae lh" href="https://unsplash.com/@snapsbyfox?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">罗马福克斯</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><h1 id="f9d7" class="nf ng it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">以自下而上的方式使用循环</h1><p id="b168" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">这个概念源于<strong class="lk jd">动态编程</strong>概念。解释<strong class="lk jd">动态编程</strong>超出了本文的范围。所以，如果你需要了解更多，你可以搜索互联网，你会找到大量的资源。</p><p id="6b30" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我给你介绍一下<strong class="lk jd">斐波那契</strong>数列。</p><p id="b4a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据<a class="ae lh" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="me mf mg"><p id="a72e" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">在数学中，<strong class="lk jd">斐波纳契数列</strong>，通常表示为<em class="it"> Fn </em>，形成了一个<a class="ae lh" href="https://en.wikipedia.org/wiki/Integer_sequence" rel="noopener ugc nofollow" target="_blank">数列</a>，<strong class="lk jd">斐波纳契数列</strong>，其中每个数字都是前两个数字的和。该序列通常从0和1开始，尽管一些作者省略了初始项，并从1和1或从1和2开始序列。从0和1开始，序列中接下来的几个值是:<a class="ae lh" href="https://en.wikipedia.org/wiki/Fibonacci_number#cite_note-oeis-1" rel="noopener ugc nofollow" target="_blank">【1】</a></p><p id="faad" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …</p><p id="4815" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">斐波纳契数列最早在公元前200年由<a class="ae lh" href="https://en.wikipedia.org/wiki/Pingala" rel="noopener ugc nofollow" target="_blank">平加拉</a>在列举由两种长度的音节形成的梵语诗歌的可能模式的工作中，在<a class="ae lh" href="https://en.wikipedia.org/wiki/Indian_mathematics" rel="noopener ugc nofollow" target="_blank">印度数学</a>、<a class="ae lh" href="https://en.wikipedia.org/wiki/Fibonacci_number#cite_note-GlobalScience-2" rel="noopener ugc nofollow" target="_blank">【2】</a><a class="ae lh" href="https://en.wikipedia.org/wiki/Fibonacci_number#cite_note-HistoriaMathematica-3" rel="noopener ugc nofollow" target="_blank">【3】</a><a class="ae lh" href="https://en.wikipedia.org/wiki/Fibonacci_number#cite_note-Donald_Knuth_2006_50-4" rel="noopener ugc nofollow" target="_blank">【4】</a>中被描述。它们以意大利比萨数学家莱昂纳多的名字命名，后来被称为<a class="ae lh" href="https://en.wikipedia.org/wiki/Fibonacci" rel="noopener ugc nofollow" target="_blank">斐波那契</a>，他在1202年的著作<a class="ae lh" href="https://en.wikipedia.org/wiki/Liber_Abaci" rel="noopener ugc nofollow" target="_blank"> <em class="it"> Liber Abaci </em> </a>中将数列引入西欧数学。<a class="ae lh" href="https://en.wikipedia.org/wiki/Fibonacci_number#cite_note-FOOTNOTEPisano2002404%E2%80%9305-5" rel="noopener ugc nofollow" target="_blank">【5】</a></p></blockquote><p id="b0c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">换句话说:</p><ul class=""><li id="aac1" class="oq or it lk b ll lm lo lp lr os lv ot lz ou md ov ow ox oy bi translated">Fn = Fn-1 + Fn-2</li><li id="0361" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated">F0 = 0</li><li id="7823" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated">F1 = 1</li></ul><p id="4d91" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你所看到的，斐波纳契数列根据定义是基于T21递归的。因此，我们的头脑很容易把它表述为:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="c390" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">会有用吗，肯定会。然而，正如我们之前证明的那样，在内存方面，它的成本太高了。</p><p id="e1dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，如果我们试图调用<code class="fe oc od oe of b">FibonacciUsingRecursion</code>传入<strong class="lk jd"> 80 </strong>作为输入，编译器根本不会返回。为什么？</p><p id="5105" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您尝试按照定义来可视化该系列，您将得到以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/9a9b8056526078c543ecbd14bce3c7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*4VQRY48AmRKePL_wxcy25A.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nh">5的斐波纳契数列</strong>。<strong class="bd nh">我</strong>法师由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a></figcaption></figure><p id="7ab1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你看到了吗？你注意到了吗，我们有重复的递归树，它们会被求值不止一次。fib(3)子树将被评估两次。fib(2)子树将被评估3次，依此类推…</p><p id="15a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在你能想象fib(80)树的重复子树的数量吗？这将是巨大的。</p><p id="142a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，你可能会问:</p><blockquote class="me mf mg"><p id="869c" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">现在怎么办？我们能做些什么呢？</p></blockquote><p id="c04f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">处理这个问题的方法之一是用不同的方式来思考级数的定义。</p><p id="0812" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们来分析一下这个:</p><ol class=""><li id="8ddb" class="oq or it lk b ll lm lo lp lr os lv ot lz ou md pg ow ox oy bi translated">纤维(5) =纤维(4) +纤维(3)</li><li id="ce7b" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md pg ow ox oy bi translated">纤维(4) =纤维(3) +纤维(2)</li><li id="d79f" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md pg ow ox oy bi translated">纤维(3) =纤维(2) +纤维(1)</li><li id="1fce" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md pg ow ox oy bi translated">fib(2) = fib(1) + fib(0) = 1 + 0 = 1</li></ol><p id="d015" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你注意到了吗，为了得到fib(5 ),我们需要fib(2)到fib(4 )?那我们为什么不这样做呢？</p><p id="a4d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们首先从fib(2)开始，继续向上，直到到达fib(5)。实际上，我们可以这样做:</p><ol class=""><li id="a375" class="oq or it lk b ll lm lo lp lr os lv ot lz ou md pg ow ox oy bi translated">fib(2) = 1 + 0 = 1</li><li id="d726" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md pg ow ox oy bi translated">纤维(3) =纤维(2) +纤维(1)</li><li id="4c5a" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md pg ow ox oy bi translated">纤维(4) =纤维(3) +纤维(2)</li><li id="2ef6" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md pg ow ox oy bi translated">纤维(5) =纤维(4) +纤维(3)</li></ol><p id="828f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着我们只需要从两个值开始；fib(0) = 0和fib(1) = 1，然后我们通过将前两者相加并移动这两个值来保持上升。</p><p id="299c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，按照这个，你可以这样做:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="52a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如果您运行这个，您将得到与递归解决方案相同的结果，但是具有更好的性能和内存分配。</p><p id="5450" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，如果我们试图调用<code class="fe oc od oe of b">FibonacciUsingLoops</code>并传入<strong class="lk jd"> 80 </strong>作为输入，编译器会立即返回结果。</p><p id="c69d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们从中可以学到的是，取代<strong class="lk jd">递归</strong>可以使不可能成为可能。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/8e5093b12afe11355c3c1444c5bc163c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mgjGyLPsnUGbk2JOy-eTJA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">最后的想法。照片由<a class="ae lh" href="https://unsplash.com/@jasongoodman_youxventures?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰森·古德曼</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><h1 id="08ab" class="nf ng it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">最后的想法</h1><p id="4a3f" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">如你所见，<strong class="lk jd">递归</strong>太昂贵了，有时它不可能在不遇到障碍的情况下执行一些逻辑。</p><p id="48b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在使用<strong class="lk jd">递归</strong>之前，你应该总是考虑其他的选择。</p><p id="5c3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我希望你喜欢读这篇文章，就像我喜欢写它一样。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="8195" class="nf ng it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="3514" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">如果您还不是<strong class="lk jd">媒介</strong>会员，您可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="lk jd">我的推荐链接</strong> </a>，这样我就可以从<strong class="lk jd">媒介</strong>那里获得您的一部分费用，您无需支付任何额外费用。订阅<a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"> <strong class="lk jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="e6a7" class="nf ng it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">其他资源</h1><p id="2846" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">这些是你可能会发现有用的其他资源。</p><div class="mm mn gp gr mo mp"><a rel="noopener  ugc nofollow" target="_blank" href="/passing-parameters-to-a-net-c-method-388badb7c095"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jd gy z fp mu fr fs mv fu fw jc bi translated">将参数传递给. NET C#方法</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">向. NET C#方法传递参数的不同方式。</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="my l"><div class="pi l na nb nc my nd lb mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a rel="noopener  ugc nofollow" target="_blank" href="/protecting-public-methods-from-illogical-calls-in-net-c-91fcbb8bee33"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jd gy z fp mu fr fs mv fu fw jc bi translated">保护公共方法免受不合逻辑的调用。NET C#</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">包含代码示例和解释的完整指南。</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="my l"><div class="pj l na nb nc my nd lb mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a rel="noopener  ugc nofollow" target="_blank" href="/flagged-enumerations-how-to-represent-features-combinations-into-one-field-f32e46a0885"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jd gy z fp mu fr fs mv fu fw jc bi translated">标记枚举:如何在一个字段中表示特征组合</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">将[读、写、修改……]等功能及其组合表示到单个字段中。</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="my l"><div class="pk l na nb nc my nd lb mp"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure></div></div>    
</body>
</html>