# 使用字符串生成器提高 Java 程序的性能

> 原文：<https://levelup.gitconnected.com/improve-the-performance-of-your-java-programs-with-string-builders-4c3316ccad55>

本文激发并解释了 StringBuilder 类在 Java 中的使用。

![](img/fa94189b082963a6f7328df6da66be4d.png)

[斯蒂夫·约翰森](https://unsplash.com/@steve_j?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 不变性的结果

Java 中的字符串是不可变的。这意味着当您给类型为`String`的变量重新赋值时，它实际上会创建一个新的`String`实例。特别是，当您使用`+=`连接两个字符串时，会创建一个新的`String`对象。这样做的结果是，像下面这样的程序将在每次迭代中创建一个新对象，并在下一次迭代后将其转储。

这会占用堆上的空间，并给垃圾收集器带来更多的工作。

要解决这个问题，建议使用`StringBuilder`类代替`String`。一个`StringBuilder`只不过是一个可变的字符序列。本文的其余部分将展示如何创建字符串生成器，并介绍其中包含的一些方法。

# 构造、追加和插入

两个最常见的`StringBuilder`构造函数是`StringBuilder()`，它创建一个空的字符串生成器，和`StringBuilder(String)`，它从一个现有的常规的、不可变的字符串创建一个字符串生成器。

方法`append`接受任何类型的参数，并将其附加到字符串生成器。这可能需要:

*   一个原始类型(`int`，`double` …)，
*   一个对象(它附加了参数的字符串表示，由方法`toString`给出)，
*   实现`CharSequence`接口的类的实例(例如，另一个字符串生成器)。

类似的方法是`insert`。它将一个索引和 *something* 作为参数插入指定的索引(其中 *something* 与`append`的参数类型相同)。`insert`抛出一个`StringIndexOutOfBoundsException`是指标不在合适的范围内。

例如:

# 基准

我在电脑上运行了以下程序:

它执行相同的操作两次，一次使用字符串生成器，一次使用不可变字符串。使用字符串生成器需要 0.04 秒，使用不可变字符串需要 6 分 58.12 秒，这表明与字符串生成器相比，连接常规字符串是多么低效。

# 高级方法

本节介绍一些对操作字符串生成器有用的附加方法。

`charAt`获取一个索引并返回该索引处的字符。如果索引无效，它抛出一个`StringIndexOutOfBoundsException`。

`deleteCharAt`获取一个索引并删除该索引处的字符。这是破坏性的，但也会返回更新后的字符串生成器:

`substring`带`int`类型的两个参数:`begin`和`end`。它返回一个`String`，对应于从索引`begin`开始到索引`end — 1`结束的字符串生成器的子字符串。

同样，`delete`是一个破坏性的方法，删除从第一个参数(含)给定的索引开始，到第二个参数(不含)给定的索引结束的序列。

# 下降趋势

字符串生成器仍然有一些您需要注意的缺点:

*   可变对象使得代码更难维护，并且可能会发生意外的/不想要的变化；
*   它们不是线程安全的，这意味着当多个线程操作单个`StringBuilder`实例时，可能会发生意外的行为；
*   它们占用了更多的空间，因为它们允许额外的内存，以防我们想给它们添加更多的字符。

最后一点值得深入探讨一下。字符串生成器的“大小”由两个属性表征:`length`和`capacity`。`length`是它包含的字符数，而`capacity`是分配的内存块可以包含的字符总数。当实例化一个新的字符串生成器时，默认情况下它的容量被设置为 16 个字符。当长度达到容量时，包含字符串生成器的内存块会随着容量的更新而重新分配。

如果需要节省空间，可以使用`trimToSize`的方法。它调整字符串占用的内存块的大小，使其容量等于实际的字符数。

为了演示容量和长度是如何演变的，wen 可以运行如下程序。

它给出以下输出:

# 结论

*   字符串生成器是 Java 中常规字符串的可变替代品。
*   它们提供了更好的性能，尤其是在执行重复连接时。
*   它们不是线程安全的，并且比不可变字符串占用更多的内存。