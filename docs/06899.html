<html>
<head>
<title>Playing with Puppeteer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">和木偶师玩耍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/playing-with-puppeteer-1438af6bf95e?source=collection_archive---------19-----------------------#2021-01-11">https://levelup.gitconnected.com/playing-with-puppeteer-1438af6bf95e?source=collection_archive---------19-----------------------#2021-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8fd6b6484ed376c638d690b14daa2b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_fyXEb95VqYIscia8LraSg.jpeg"/></div></div></figure><p id="6e3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本周，我决定去看一看<a class="ae kw" href="https://github.com/puppeteer/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>。我知道这是一种制作小型自动化浏览器脚本的方法，并且很高兴尝试一下。我编写了一个简单的脚本，在MDN JavaScript docs网站上搜索数组方法，返回方法的定义和数组方法网页的链接。这是一个概念验证，只是为了让我了解木偶师。</p><p id="98b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你对它不熟悉，<a class="ae kw" href="https://github.com/puppeteer/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>是一个节点库，它提供了一个高级API来通过<a class="ae kw" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> DevTools协议</a>控制Chrome或Chrome。默认情况下，它无头运行，但可以配置为完全运行(非无头)。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="4209" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个项目，我决定也使用包<a class="ae kw" href="https://www.npmjs.com/package/chalk" rel="noopener ugc nofollow" target="_blank">粉笔</a>和<a class="ae kw" href="https://www.npmjs.com/package/inquirer" rel="noopener ugc nofollow" target="_blank">询问者</a>。Chalk将允许我轻松地格式化我们的终端输出，Inquirer将允许我轻松地创建我们的命令行用户界面。</p><p id="621c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建了一个名为“searchMDN”的新文件夹，在终端中导航到它并安装了三个依赖项。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f891" class="ln lo iq lj b gy lp lq l lr ls">$ npm i puppeteer chalk inquirer</span></pre><p id="7a55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个名为app.js的新JavaScript文件，首先，我将创建将在终端中显示的用户提示。我还进入了package.json文件，并将启动命令设置为‘node app . js’…</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="d603" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">创建用户提示</h1><p id="0666" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">首先要求我们的文件中的问询者包。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f103" class="ln lo iq lj b gy lp lq l lr ls">const inquirer = require('inquirer')</span></pre><p id="713d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在它可用了，我可以用它来让用户提示。我只希望提示是“输入要搜索的数组方法”。Inquirer有许多如何提示用户的选项，但我不需要太多——只需要它最基本的提示，即“prompt()”方法。这个方法要求我指定提示的类型。我希望用户写下他们希望查找的方法的名称。对于这种用户输入，我将使用inquirer提供的“输入”类型。接下来，我必须命名从用户那里得到的响应。我将把它命名为userInput。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d7d6" class="ln lo iq lj b gy lp lq l lr ls">inquirer.prompt({<br/>  type: 'input',<br/>  name: 'userInput',<br/>  message: 'Enter array method to search for'<br/>})</span></pre><p id="dda8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我需要获取userInput并将其发送给一个使用Puppeteer搜索MDN网站并返回结果的函数。因为prompt()方法返回一个承诺，所以我将使用。then()方法并获取userInput的结果，然后将其传递给“getResults()”函数，我将在Puppeteer的帮助下创建该函数。我还将把它包装在一个名为start()的函数中。因为这个函数必须是第一个被调用的函数，并且启动getResults()函数，所以在文件末尾调用start()来初始化这个数组方法搜索脚本是有意义的。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9179" class="ln lo iq lj b gy lp lq l lr ls">const start = () =&gt; {<br/>  inquirer.prompt({<br/>    type: 'input',<br/>    name: 'userInput',<br/>    message: 'Enter array method to search for'<br/>  })<br/>  .then(resp =&gt; getResults(resp.userInput))<br/>}</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="dcd7" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用木偶师实现自动化</h1><p id="483d" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">就像上面一样，我需要app.js文件中的木偶师包。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="b6e2" class="ln lo iq lj b gy lp lq l lr ls">const puppeteer = require('puppeteer')</span></pre><p id="fd8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的功能，我需要从木偶戏将是异步的，这是有意义的。我必须创建一个chromium浏览器的实例，打开一个新页面，加载网站，找到搜索栏的id，输入搜索词，等待新页面加载，然后找到第一个结果，将结果url存储在一个变量中，转到结果的网页，找到定义，将定义存储在一个变量中，最后输出到控制台。我需要代码等待这些任务完成后再继续。因此，我将把这一切包装在一个异步函数中。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="faf6" class="ln lo iq lj b gy lp lq l lr ls">async function getResults(term) {<br/>  const browser = await puppeteer.launch()<br/>  const page = await browser.newPage() <br/>}</span></pre><p id="98a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，我已经创建了async getResults()函数，它接受一个参数，该参数由我将用来查询MDN站点的搜索词的start()函数发送。我用puppeteer.launch()创建了一个无头chromium浏览器的实例。一旦完成，代码将创建一个新页面。然后我们需要给木偶师我希望开始搜索的url地址。</p><p id="c173" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我弄清楚这个脚本时，我启用了创建完整(非无头)浏览器的选项。这样，随着我每一步的进展，我可以在浏览器中迅速找出下一步需要做什么。我通过调用puppeteer.launch()中的选项{ headless: false }来实现这一点。</p><p id="1e46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用了开发者主页，并将语言环境设置为en-US，以确保我只能得到英文结果。使用chrome开发工具，我发现网站上的搜索栏的html id是“main-q”。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3f67" class="ln lo iq lj b gy lp lq l lr ls">const mdnUrl = 'https://developer.mozilla.org/en-US/search?locale=en-US'</span><span id="db50" class="ln lo iq lj b gy mv lq l lr ls">async function getResults(term) {<br/>  const browser = await puppeteer.launch({ headless: false })<br/>  const page = await browser.newPage()<br/>  await page.goto(mdnUrl)<br/>  await page.type('#main-q', `Array.prototype.${term}`)<br/>  await page.keyboard.down('Enter')<br/>}</span></pre><p id="ed44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mw mx my lj b">page.type</code>选择我想要输入文本的元素，并在第二个参数中选择我想要输入的文本。我只搜索数组方法，所以我将在字符串“Array.prototype”的末尾输入术语。一旦按下回车键，搜索查询就被发送。</p><p id="1ccd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要等待新页面加载并找到第一个结果。页面上的所有结果都有“结果”类，每个标题都有“结果-标题”类。如果我只是在“result-title”上调用querySelector，它将获取第一个结果，然后剩下要做的就是从结果标题中获取链接。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="b892" class="ln lo iq lj b gy lp lq l lr ls">const mdnUrl = 'https://developer.mozilla.org/en-US/search?locale=en-US'</span><span id="33d6" class="ln lo iq lj b gy mv lq l lr ls">async function getResults(term) {<br/>  const browser = await puppeteer.launch({ headless: false })<br/>  const page = await browser.newPage()<br/>  await page.goto(mdnUrl)<br/>  await page.type('#main-q', `Array.prototype.${term}`)<br/>  await page.keyboard.down('Enter')<br/>  await page.waitForSelector('.result')</span><span id="6375" class="ln lo iq lj b gy mv lq l lr ls">  const resultUrl = await page.evaluate(() =&gt; {<br/>    const topResult = document.querySelector('.result-title')<br/>    return topResult.href<br/>  })<br/>}</span></pre><p id="883a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，快到了！我有了方法定义的url，现在我所需要的就是获取定义并输出到终端。</p><p id="22df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照类似的模式，我用我们保存在resultUrl常量中的url打开一个页面。定义在最顶层的<p>标记中，所以我用querySelector选择它，然后将innerText保存到resultDef的常量中。之后，我们完成了浏览器，需要关闭它，这样它就不会继续在后台运行。</p></p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d623" class="ln lo iq lj b gy lp lq l lr ls">const mdnUrl = 'https://developer.mozilla.org/en-US/search?locale=en-US'</span><span id="36fc" class="ln lo iq lj b gy mv lq l lr ls">async function getResults(term) {<br/>  const browser = await puppeteer.launch({ headless: false })<br/>  const page = await browser.newPage()<br/>  await page.goto(mdnUrl)<br/>  await page.type('#main-q', `Array.prototype.${term}`)<br/>  await page.keyboard.down('Enter')<br/>  await page.waitForSelector('.result')</span><span id="60bd" class="ln lo iq lj b gy mv lq l lr ls">  const resultUrl = await page.evaluate(() =&gt; {<br/>    const topResult = document.querySelector('.result-title')<br/>    return topResult.href<br/>  })</span><span id="5218" class="ln lo iq lj b gy mv lq l lr ls">  await page.goto(resultUrl)<br/>  <br/>  const resultDef = await page.evaluate(() =&gt; {<br/>    const termDef = document.querySelector('p')<br/>    return termDef.innerText<br/>  })</span><span id="42fb" class="ln lo iq lj b gy mv lq l lr ls">  browser.close()<br/>}</span></pre><p id="243f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我就有了我们需要的所有数据，我唯一需要做的就是将结果输出到控制台。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="41e7" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">输出到控制台</h1><p id="0495" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">接下来，我需要将Chalk包添加到app.js文件中。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2ee6" class="ln lo iq lj b gy lp lq l lr ls">const chalk = require('chalk')</span></pre><p id="72f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Chalk有很多格式化文本的选项，最棒的是它们都是简单的英语，没有十六进制或RGB值。嗯，<strong class="ka ir">你</strong>可以用粉笔使用RGB值，但我会保持简单。我只是想添加一点颜色，这样定义和url感觉是分开的，输出更容易阅读。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4250" class="ln lo iq lj b gy lp lq l lr ls">console.log(chalk.magentaBright(resultDef))<br/>console.log(chalk.underline.dim(resultUrl))</span></pre><p id="54cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将resultDef文本设为亮洋红色，并为url加下划线，将其颜色从显示它的控制台的默认颜色变暗。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="8d44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我从puppeteer.launch()中删除了{ headless: false }选项，这样，这个简单的概念验证脚本就完成了。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/b5814adf36f2771393f9d26c0dfa0578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*I4HapsSGpo9nhDkLu9S4DA.gif"/></div></div></figure><p id="c89c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于这些软件包的更多信息，请查看下面它们各自的链接。</p><p id="bc8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/puppeteer/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a></p><p id="ecb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.npmjs.com/package/chalk" rel="noopener ugc nofollow" target="_blank">粉笔</a></p><p id="f6b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.npmjs.com/package/inquirer" rel="noopener ugc nofollow" target="_blank">问询者</a></p></div></div>    
</body>
</html>