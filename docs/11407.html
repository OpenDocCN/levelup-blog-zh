<html>
<head>
<title>ELI5: What the F*** is a Bloom Filter?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ELI5:什么是布鲁姆过滤器？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/eli5-what-the-f-is-a-bloom-filter-4a58a160833d?source=collection_archive---------17-----------------------#2022-03-14">https://levelup.gitconnected.com/eli5-what-the-f-is-a-bloom-filter-4a58a160833d?source=collection_archive---------17-----------------------#2022-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f0e86296c4710f0ef443ab024cb54e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sMnzrXqmsN84Mh7nYvpPg@2x.jpeg"/></div></div></figure><h1 id="4d80" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">目录</h1><ul class=""><li id="065e" class="kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">介绍</li><li id="c074" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">ELI5</li><li id="a2c0" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">解释:布隆过滤器</li><li id="46f8" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">代码:Bloom filter vs Redis</li><li id="14ad" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">概述</li><li id="3e12" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">恶作剧</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="86a2" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated"><a class="ae mr" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank">布隆过滤器</a>是一种概率数据结构，用于测试一个元素是否是一个集合的成员。换句话说，一个Bloom filter可以让你知道，如果一组事物中存在某个事物，那么它是正确的几率非常高。</p><blockquote class="ms mt mu"><p id="7980" class="ma mb mv ky b kz mc md me lb mf mg mh mw mi mj mk mx ml mm mn my mo mp mq lj ij bi translated"><strong class="ky ir">我</strong>:布鲁姆滤镜，这袋糖果里是不是有一颗红色的糖果？<br/> <strong class="ky ir">布鲁姆滤镜</strong>:也许吧。</p></blockquote><p id="27a8" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">为什么要关心这个数据结构呢？<strong class="ky ir">布隆过滤器可以消除高达85%的磁盘读取</strong><a class="ae mr" href="https://www.semanticscholar.org/paper/Space%2Ftime-trade-offs-in-hash-coding-with-allowable-Bloom/f39a2c11983b21fd5054d5393614959bfbc4e50f" rel="noopener ugc nofollow" target="_blank">【1】</a>。在测试一个元素是否存在时，客户端在检查数据库之前首先查询Bloom filters<em class="mv"/>，从而潜在地阻止了磁盘读取(因为数据库持久存储在磁盘上)。</p><p id="876d" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">好吧，但是谁会用布鲁姆滤镜呢？<a class="ae mr" href="https://web.archive.org/web/20180909043421/https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=9ee014fc899a28a198492b074e32b60ed8915ea9" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>，<a class="ae mr" href="https://web.archive.org/web/20101027012345/http://blog.alexyakunin.com/2010/03/nice-bloom-filter-application.html" rel="noopener ugc nofollow" target="_blank"> Google Chrome </a>，<a class="ae mr" href="https://danluu.com/bitfunnel-sigir.pdf" rel="noopener ugc nofollow" target="_blank"> Bing </a>，<a class="ae mr" href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/68a74a85e1662fe02ff3967497f31fda7f32225c.pdf" rel="noopener ugc nofollow" target="_blank"> Google Cloud Bigtable </a>，不胜枚举。</p><p id="f16d" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">但是在我们深入研究正式定义之前，我想通过一个简单的、非技术性的类比来解释Bloom filters，从而实现我在标题中做出的承诺。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ab9e7228ed5974f141204fc732e59bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*FdNtmQXsotEktRlAfWFpag.jpeg"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">图一。我(布莱恩)</figcaption></figure><p id="940e" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">当谈到我们冰箱里的东西时，我的女朋友Stacey是我的布鲁姆过滤器。当我问她冰箱里有没有东西的时候，她会用以下任何一种说法来回答:</p><ul class=""><li id="e578" class="kw kx iq ky b kz mc lb mf ld ni lf nj lh nk lj lk ll lm ln bi translated">是的，在冰箱里。</li><li id="fff0" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">是的，我想它在冰箱里。</li><li id="1169" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">不，百分之百不在冰箱里</li></ul><p id="1d07" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">当斯泰西说它在冰箱里的时候，她通常是对的，而且她的反应从来不会错。众所周知，从任何地方(如沙发、床、楼上)走到冰箱前都是<em class="mv">贵</em>。所以，我永远感激她，因为她大大减少了我去冰箱的次数。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="024a" class="jy jz iq bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">布鲁姆过滤器是如何工作的？</h1><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/27c893d87b103e9fc68ba5e1a549fc02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5ileX5qwUiXC-3qeXif5g.jpeg"/></div></div></figure><p id="5934" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">所以你正在考虑在你的技术栈中实现一个Bloom filter。它是如何工作的？让我们来定义布隆过滤器的组件以及它们是如何协同工作的。</p><h1 id="a610" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">算法描述</h1><p id="8b76" class="pw-post-body-paragraph ma mb iq ky b kz la md me lb lc mg mh ld nr mj mk lf ns mm mn lh nt mp mq lj ij bi translated">一个<em class="mv">空布隆过滤器</em>是一个<em class="mv"> m </em>位的<a class="ae mr" href="https://en.wikipedia.org/wiki/Bit_array" rel="noopener ugc nofollow" target="_blank">位数组</a>，全部置0。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/c9cdd312008a489b2e7a938fe811c87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HiSdGEIcIdR1JiObvaV6RA.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">m=10的空布隆过滤器</figcaption></figure><p id="b323" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">还必须定义<em class="mv"> k </em>个不同的<a class="ae mr" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">散列函数</a>，其中每个<a class="ae mr" href="https://en.wikipedia.org/wiki/Map_(mathematics)" rel="noopener ugc nofollow" target="_blank">将</a>映射或散列一些集合元素到<em class="mv"> m </em>数组索引之一。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/3414c380e046c2a45dff20ebdff6df8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbsWuyJwJW8pzby4zoo5eg.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">单一散列函数，k=1</figcaption></figure><p id="d899" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">为了<em class="mv">添加</em>一个元素，将该元素提供给每个<em class="mv"> k </em>哈希函数以获得<em class="mv"> k </em>数组索引。将这些索引处的位设为1。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/8f2fd83074e1726e8b634d6994c5978d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMkgBwIb3hqtKoS5pQfjHQ.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">具有三个散列函数的布隆过滤器，k=3</figcaption></figure><p id="4526" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">为了<em class="mv">向</em>查询一个元素(即测试它是否在集合中)，将该元素提供给每个<em class="mv"> k </em>散列函数，以获得<em class="mv"> k </em>数组索引。<strong class="ky ir">如果<em class="mv">这些索引位的任一位</em>为0，则该元素100%不在集合</strong>中；如果是的话，那么当它被插入时，所有的位都将被设置为1。因此，布隆过滤器在确定元素是否是集合的成员时非常有效。</p><p id="53b7" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">另一方面<strong class="ky ir">，如果<em class="mv">在这些索引处的所有</em>位都是1，那么要么该元素在集合中，要么这些位在插入其他元素</strong>期间被设置为1，导致<a class="ae mr" href="https://en.wikipedia.org/wiki/False_positive" rel="noopener ugc nofollow" target="_blank">假阳性</a>。</p><p id="7597" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">尽管布隆过滤器允许假阳性，但是作为回报，布隆过滤器提供了非常紧凑的存储:<strong class="ky ir">对于1%的假阳性概率</strong>，每个元素需要少于10比特，而与集合[ <a class="ae mr" href="http://theory.stanford.edu/~rinap/papers/esa2006b.pdf" rel="noopener ugc nofollow" target="_blank"> 2 </a>中元素的大小或数量无关。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="69fc" class="jy jz iq bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">带代码的Bloom Filter vs Redis</h1><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/685c404f16cae076868c4fbdc7f2b77a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*uFCD7abCfUIpQI96_v8GPw.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">由<a class="ae mr" href="https://www.vecteezy.com/free-photos" rel="noopener ugc nofollow" target="_blank"> Vecteezy </a>提供的免费库存照片</figcaption></figure><p id="2ae1" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">如果您仍然不相信，让我们用Python将Bloom filter与Redis数据库进行比较，来完成一个实际的实现。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="4da2" class="jy jz iq bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">布鲁姆过滤器测试用例</h1><p id="c792" class="pw-post-body-paragraph ma mb iq ky b kz la md me lb lc mg mh ld nr mj mk lf ns mm mn lh nt mp mq lj ij bi translated">我使用Python内置库<strong class="ky ir"> uuid </strong>和一个list comprehension生成了1M new+unique id。</p><pre class="na nb nc nd gt ny nz oa ob aw oc bi"><span id="4232" class="od jz iq nz b gy oe of l og oh">unique_ids = [uuid.uuid4() for i in range(0, 1_000_000)]</span></pre><p id="1b1b" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">然后，我使用<a class="ae mr" href="https://pypi.org/project/pybloomfiltermmap3" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">pybloomfiltermmap 3</strong></a><strong class="ky ir"/>库创建了一个新的Bloom filter实例。通过使用这个库，我们不必担心实现<em class="mv"> k </em>散列函数。</p><pre class="na nb nc nd gt ny nz oa ob aw oc bi"><span id="f2b8" class="od jz iq nz b gy oe of l og oh">bloom_filter = BloomFilter(capacity=1_000_000, error_rate=0.01, filename='filter.bloom')</span></pre><p id="5caa" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">接下来，我遍历1M个唯一ID，检查该ID是否存在于Bloom filter中，不久之后，将该ID添加到Bloom filter中。如果一个ID存在(它不应该存在)，我会记下这个假阳性。</p><pre class="na nb nc nd gt ny nz oa ob aw oc bi"><span id="1056" class="od jz iq nz b gy oe of l og oh">def get_bloom_filter_stats():<br/>    start = time.time()<br/>    false_positives = 0<br/><br/>    for i, element in enumerate(unique_ids):<br/>        if element in bloom_filter:<br/>            print(f'false positive for id={element} at index={i}')<br/>            false_positives += 1<br/><br/>        # hashes element, and stores in bit array<br/>        bloom_filter.add(element)<br/><br/>    elapsed_time = time.time() - start<br/>    return {'execution_time': elapsed_time, 'false_positives': false_positives}</span></pre><p id="aa02" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">以下是Bloom filter测试的一些统计数据。请注意，实际错误率不到1%,执行时间&lt; 500ms.</p><pre class="na nb nc nd gt ny nz oa ob aw oc bi"><span id="412f" class="od jz iq nz b gy oe of l og oh">## Bloom Statistics ##<br/>emulated_requests: 1,000,000<br/>false_positives: 1,838<br/>expected_error_rate: 1.00%<br/>actual_error_rate: 0.1838%<br/>bloom filter file_size: 1.14MB<br/>Bloom execution_time: 482ms</span></pre><h1 id="e924" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Redis Test Case</h1><p id="cc50" class="pw-post-body-paragraph ma mb iq ky b kz la md me lb lc mg mh ld nr mj mk lf ns mm mn lh nt mp mq lj ij bi translated">Now, let’s see how Redis performs with the same 1M key lookups. I started by creating a Redis instance of my local Redis server.</p><pre class="na nb nc nd gt ny nz oa ob aw oc bi"><span id="bf9b" class="od jz iq nz b gy oe of l og oh">redis_client = StrictRedis().from_url('redis://localhost:6379')</span></pre><p id="6dbc" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">Then, I iterated through the same 1M unique IDs, taking note of the elapsed time.</p><pre class="na nb nc nd gt ny nz oa ob aw oc bi"><span id="615b" class="od jz iq nz b gy oe of l og oh">def get_redis_execution_time():<br/>    start = time.time()<br/>    for element in unique_ids:<br/>        redis_client.get(str(element))<br/>    elapsed_time = time.time() - start<br/>    return elapsed_time</span></pre><p id="2f9e" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">Redis took 31 seconds (!) to iterate through the entire list of IDs, compared to a Bloom filters execution time of 482 milliseconds. I did not test a SQL database since Redis is generally faster (in-memory vs disk). <strong class="ky ir">极快，这意味着对于键存在检查，Bloom filter至少比SQL数据库</strong>快<em class="mv">63倍。</em></p><p id="483e" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">当然，也有一些权衡:误报和布隆过滤器文件大小(大约1MB/1M记录)。然而，错误率低于1%且占用空间如此之小，这绝对<em class="mv">值得。</em></p><p id="b9a2" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">如果你有兴趣看完整的代码片段，可以在这里找到:<a class="ae mr" href="https://github.com/bryangalindo/bloomfilter-example/blob/main/main.py" rel="noopener ugc nofollow" target="_blank">https://github . com/bryangalindo/bloom filter-example/blob/main/main . py</a>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="463c" class="jy jz iq bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">概述</h1><p id="1865" class="pw-post-body-paragraph ma mb iq ky b kz la md me lb lc mg mh ld nr mj mk lf ns mm mn lh nt mp mq lj ij bi translated">感谢阅读！以下是这篇文章的一些要点。</p><ul class=""><li id="923d" class="kw kx iq ky b kz mc lb mf ld ni lf nj lh nk lj lk ll lm ln bi translated">一个<em class="mv">空的</em>布隆过滤器是一个<em class="mv"> m个</em>位的<a class="ae mr" href="https://en.wikipedia.org/wiki/Bit_array" rel="noopener ugc nofollow" target="_blank">位数组</a>，全部设置为0。</li><li id="5b5f" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">为了确认一个元素是否不存在，一个元素的散列集至少需要<em class="mv">一个映射到0位索引的值。</em></li><li id="26d8" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">如果一个元素的散列集合包含所有的值都映射到1位索引，那么要么该元素在集合中，要么在插入其他元素时这些位被设置为1。</li><li id="c04f" class="kw kx iq ky b kz lo lb lp ld lq lf lr lh ls lj lk ll lm ln bi translated">布隆过滤器允许假阳性，但是假阳性的概率可以小于1%。</li></ul><h1 id="404c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">一个很短的测验</h1><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/ece312c719681fb1972a0cfb0bf0ef8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7dOQRVki773kCeaNGiltw.jpeg"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">由<a class="ae mr" href="https://www.vecteezy.com/free-photos" rel="noopener ugc nofollow" target="_blank"> Vecteezy </a>提供的免费库存照片</figcaption></figure><h1 id="4315" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">问题1 </strong></h1><p id="60aa" class="pw-post-body-paragraph ma mb iq ky b kz la md me lb lc mg mh ld nr mj mk lf ns mm mn lh nt mp mq lj ij bi translated">布隆过滤器中的哪些元素(foo、bar、baz)是<strong class="ky ir">不是</strong>？</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/2faa4f00243c30c0a48d8be0461eb524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xHZ_HLfyX0nL7IAgnXtChQ.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">答案:Foo，Bar，Baz</figcaption></figure><h1 id="c8dc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">问题2 </strong></h1><p id="67da" class="pw-post-body-paragraph ma mb iq ky b kz la md me lb lc mg mh ld nr mj mk lf ns mm mn lh nt mp mq lj ij bi translated">一个新元素，<em class="mv"> qux </em>，出现了一个散列集{1，5，9}。</p><p id="43dc" class="pw-post-body-paragraph ma mb iq ky b kz mc md me lb mf mg mh ld mi mj mk lf ml mm mn lh mo mp mq lj ij bi translated">如果我们要检查元素<em class="mv"> qux </em>是否存在于集合中，哪个布隆过滤器(A，B，C)会返回一个<strong class="ky ir">误报</strong>？</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/ebd1c5bc637739395a51ba0b3da7dba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owRYO0HW6NrvlvLChRt0xw.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">答:答</figcaption></figure></div></div>    
</body>
</html>