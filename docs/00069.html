<html>
<head>
<title>Building a Twitter Emoji Map with Elixir’s GenStage, Phoenix Channels, and Angular 😀🙃😘</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Elixir的GenStage、Phoenix Channels和Angular构建Twitter表情地图😀🙃😘</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-twitter-emoji-map-with-elixirs-genstage-phoenix-channels-and-angular-134319061b8a?source=collection_archive---------3-----------------------#2018-01-10">https://levelup.gitconnected.com/building-a-twitter-emoji-map-with-elixirs-genstage-phoenix-channels-and-angular-134319061b8a?source=collection_archive---------3-----------------------#2018-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/da2727b1e88c76864b5256f85f7d646f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2VLYn_mLF8gGR5y3VVNpQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">从开普敦的海点长廊看去。</figcaption></figure><h1 id="4f99" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">背景</h1><p id="701f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">2017年2月，我在开普敦度假，在某个时候感到无聊(老实说，我的信用卡在长街的一个简陋的酒吧被刷了——别去那里——这限制了我的预算，打乱了我的旅行计划，并将我绑在了这座城市上)。因此，我认为用Elixir的GenStage构建一个小的周末项目会很好，因为它是最近推出的，我没有用它来构建一些东西。</p><p id="bb00" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我选择Twitter作为数据源，因为他们的Stream API提供了持续的数据流，这可能会使系统过载——这正是GenStage承诺要处理好的事情之一。我选择Angular是因为我喜欢使用它，而且我没有找到很多关于如何将Phoenix频道与Angular前端连接在一起的文章。</p><p id="e2c8" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">基本的想法是过滤一个tweets流，并在前端尽可能快地显示结果，只需要很少的资源，而且不会使系统崩溃。我通常喜欢看得见的有趣的东西，但是在引擎盖下有复杂的技术。所以在组合中加入表情符号和地图是非常有意义的。</p><p id="df20" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">如果你不喜欢阅读整篇文章:我在GitHub上发布了整个项目。你可以自由使用和修改它。如果你发现任何你更了解的东西，请提交一份个人简历！</p><div class="md me gp gr mf mg"><a href="https://github.com/ospaarmann/ex-emoji-map/blob/master/backend/lib/emoji_map/twitter_stream.ex" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">ospaarmann/ex-emoji-map</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">ex-emoji-map -用Elixir的GenStage和Angular构建的emoji地图。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">github.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu jw mg"/></div></div></a></div><h1 id="d6e0" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">这个应用程序是做什么的？</h1><p id="5f7b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">基本上，它显示所有附有地理位置的推文，并(几乎)实时地在地图上包含一个表情符号。它显示了第一个表情符号，当点击它时，你可以阅读整个推文。它还显示了自你访问该页面以来Twitter上全球表情符号使用情况的快照统计。</p><p id="8c2f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">它不积累任何东西，也不在数据库中存储任何东西。它总是只显示你现在正在发生的事情。而且真的很快。在http://emojimap.ospaarmann.com/的<a class="ae mv" href="http://emojimap.ospaarmann.com/" rel="noopener ugc nofollow" target="_blank">试试自己。打开地图，放大任意位置，拿起手机发送推文，在该位置进行地理标记并包含表情符号。</a></p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="dbf0" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">在过去</h1><p id="8684" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">让我们记住，如果没有Streams、OTP和WebSockets，我们将如何构建这样的东西。我们将有一个后端不断轮询Twitter的REST API，寻找新的推文(可能达到速率限制)。符合我们标准的推文必须进入数据库——可能是Redis——因为投票将由一些后台工作完成，这些工作不会直接回复客户的请求。客户端会不断轮询后端(可能会超载和崩溃)以获取新的推文。但是很难决定我们应该发回什么数据，因为每个客户在不同的时间开始投票，可能已经收到了不同的推文。我们将需要更多的服务器能力，我们将有更多的移动部件，这将非常难以设计，我们将不得不在发送一条推文和看到它在地图上弹出之间等待至少几秒钟。</p><h1 id="1b58" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">为什么是GenStage？</h1><p id="f84f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我强烈推荐从阅读马里奥·弗拉克的<a class="ae mv" href="http://elixir-lang.org/blog/2016/07/14/announcing-genstage/" rel="noopener ugc nofollow" target="_blank">宣布GenStage </a>和<a class="ae mv" href="https://almightycouch.org/blog/reactive-tweets-elixir-genstage/" rel="noopener ugc nofollow" target="_blank">这篇伟大的文章开始。基本上，GenStage是OTP中的一种行为，或者更准确地说，是Elixir GenServer的一种变体，它在设计时考虑到了反压力，这样消息的消费者就不会被消息的数量淹没。或者换句话说:这是一个需求驱动的系统，在这个系统中，消息的消费者只接收她所能处理的尽可能多的消息，并且只有在她请求时才接收。</a></p><blockquote class="nc nd ne"><p id="4ffe" class="la lb nf lc b ld ly lf lg lh lz lj lk ng ma ln lo nh mb lr ls ni mc lv lw lx ij bi translated">为了启动事件流，我们将消费者订阅给生产者。一旦他们之间的沟通渠道建立起来，消费者就会向生产者要求事件。我们通常说消费者正在向上游发送需求。一旦需求到来，生产者将发出物品，决不会发出比消费者要求的更多的物品。这提供了背压机制。<br/> <a class="ae mv" href="https://hexdocs.pm/gen_stage/GenStage.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> GenStage文档</em> </a></p></blockquote><p id="22e9" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">当我们想要处理一个数据流，而又不知道有多少消息会到达我们这里时，这就非常方便了。比如说，一串带着滑稽面孔的推文。</p><p id="ba42" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">在GenStage中，我们有发布事件的生产者(或广播者)，消费事件的消费者，以及两者兼而有之的生产者-消费者，他们通常位于生产者和消费者之间。但是我不想在这里涉及太多的细节，我建议阅读提到的文章和文档。我还会在本文末尾列出参考文献。</p><h1 id="9ea0" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">移动部件—概述</h1><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/a8773ce2460b63fd9aeb99631fa7907f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHe0ThhFI2bPjOjTlpJpUQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我不是平面设计师，我几乎是色盲，所以闭嘴。</figcaption></figure><p id="879f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">在Elixir端，我们有处理到Twitter流API的连接的TwitterStream(通过<a class="ae mv" href="https://github.com/parroty/extwitter" rel="noopener ugc nofollow" target="_blank"> ExTwitter客户端库</a>)。它接收推文，只保留包含表情符号和地理坐标的推文。我从一个非常粗糙的正则表达式开始，但后来发现了<a class="ae mv" href="https://github.com/mroth/exmoji" rel="noopener ugc nofollow" target="_blank"> Exmoji </a>，它自称是处理Elixir中表情符号的瑞士刀，是Elixir社区疯狂增长的一个伟大标志。</p><p id="d10b" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">然后我们有TweetBufferFiller，它是一个GenServer，封装了TwitterStream，启动它并通知TweetBroadcaster关于新的tweets。这非常容易，因为TwitterStream模块从ExTwitter接收一个<a class="ae mv" href="https://hexdocs.pm/elixir/Stream.html" rel="noopener ugc nofollow" target="_blank"> Elixir Stream </a>，应用过滤器和一些规范化，并再次返回一个流。所以我可以使用<code class="fe nk nl nm nn b">Stream.map/2</code>为流中的每个tweet调用<code class="fe nk nl nm nn b">TweetBroadcaster.sync_notify/1</code>。</p><p id="5c75" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><code class="fe nk nl nm nn b">TweetBroadcaster</code>和<code class="fe nk nl nm nn b">TweetConsumer</code>是我们GenStage的生产者和消费者。他们确保系统不会超载。每当有新的推文到达，<code class="fe nk nl nm nn b">TweetBroadcaster</code>就会收到通知。它会缓冲推文，直到<code class="fe nk nl nm nn b">TweetConsumer</code>请求更多推文。每当<code class="fe nk nl nm nn b">TweetConsumer</code>完成将它们向下推到前端时，就会发生这种情况。如果在某个时候没有足够的tweets可用，那么<code class="fe nk nl nm nn b">TweetBroadcaster</code>也会存储需求。<code class="fe nk nl nm nn b">TweetConsumer</code>通过WebSocket或者在我们的例子中WebSocket的Phoenix实现将它们推送给客户端:<a class="ae mv" href="https://hexdocs.pm/phoenix/channels.html" rel="noopener ugc nofollow" target="_blank"> Phoenix Channels </a>。</p><p id="9a90" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">前端写的是Angular 2。那现在已经过时了，但是对这个目的来说，那真的不重要。它在启动时与凤凰频道连接，然后在样式化的<a class="ae mv" href="http://mapbox.com" rel="noopener ugc nofollow" target="_blank">地图框</a>地图上放置一个带有表情符号的标记作为符号，推文作为弹出内容。它总是只显示最新的700条推文，以避免浏览器过载(这样已经有点滞后了)。还有一个小小的统计，统计并显示每个表情符号的使用情况(排序顺序每5秒改变一次，以节省CPU)。</p><p id="75b5" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">就是这样。没那么复杂吧。</p><h1 id="26e8" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">活动部件——详细</h1><p id="af15" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在文章的这一部分，我将更详细地讨论代码中最重要的部分。如果你更喜欢自己阅读代码，请前往我的<a class="ae mv" href="https://github.com/ospaarmann/ex-emoji-map" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>并跳过这一部分。但是它可能会有帮助和有趣。另外:如果我做了什么傻事，请在评论或GitHub上告诉我！</p><h2 id="f32b" class="no kd iq bd ke np nq dn ki nr ns dp km ll nt nu kq lp nv nw ku lt nx ny ky nz bi translated">EmojiMap。Twitter stream—lib/e moji _ map/Twitter _ stream . ex</h2><p id="113f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这里的主要功能是<code class="fe nk nl nm nn b">get_emoji_stream/0</code> <em class="nf">。</em>它启动Twitter流并进行标准化和过滤。这里的第一个小技巧是，我只想要有地理位置的推文。我不能将此作为一个选项传递给Twitter，我不想在我这边进行过滤。所以我使用<code class="fe nk nl nm nn b"><a class="ae mv" href="https://hexdocs.pm/extwitter/ExTwitter.html#stream_filter/1" rel="noopener ugc nofollow" target="_blank">ExTwitter.stream_filter/1</a></code>并传递一个覆盖整个星球的边界框作为选项。这样我只能得到地理标记的推文。但是一些有位置，一些有实际纬度/经度地理位置。剩下的代码会处理好这个问题。</p><p id="70db" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">然后，我将这个流(这是一个灵丹妙药流)传递到一个函数管道中，以进一步过滤和规范推文。为此，我可以方便地使用<code class="fe nk nl nm nn b"><a class="ae mv" href="https://hexdocs.pm/elixir/Stream.html#filter/2" rel="noopener ugc nofollow" target="_blank">Stream.filter/2</a></code>和<code class="fe nk nl nm nn b"><a class="ae mv" href="https://hexdocs.pm/elixir/Stream.html#map/2" rel="noopener ugc nofollow" target="_blank">Stream.map/2</a></code>。主函数<code class="fe nk nl nm nn b">get_emoji_stream/0</code> <em class="nf"> </em>最终返回一串经过过滤和规范化的推文。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="oa nb l"/></div></figure><h2 id="382f" class="no kd iq bd ke np nq dn ki nr ns dp km ll nt nu kq lp nv nw ku lt nx ny ky nz bi translated">EmojiMap。TweetBufferFiller—lib/e moji _ map/tweet _ buffer _ filler . ex</h2><p id="607d" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">该模块将所有内容联系在一起。它启动<code class="fe nk nl nm nn b">EmojiMap.TweetBroadcaster</code> <em class="nf"> </em>和<code class="fe nk nl nm nn b">EmojiMap.TweetConsumer</code>生产者和消费者。这一对通过发电阶段和背压负责系统的稳定性(还记得吗？).</p><p id="01a0" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">它还调用<code class="fe nk nl nm nn b">EmojiMap.TwitterStream.get_emoji_stream/0</code> <em class="nf">，</em>接收经过过滤和规范化的tweet的Elixir流，对其调用<code class="fe nk nl nm nn b">Stream.map/2</code>，并通知<code class="fe nk nl nm nn b">TweetBroadcaster</code>每条传入的tweet。</p><p id="6c0c" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">它也是应用程序启动时在supervisor树中启动的模块。因此，一旦应用程序启动，一切都启动并运行。请参见<code class="fe nk nl nm nn b">lib/emoji_map.ex</code>。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="oa nb l"/></div></figure><h2 id="527e" class="no kd iq bd ke np nq dn ki nr ns dp km ll nt nu kq lp nv nw ku lt nx ny ky nz bi translated">EmojiMap。tweet broadcaster-lib/e moji _ map/tweet _ broadcaster . ex</h2><p id="126d" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这非常符合标准实践。这里没什么特别的。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="oa nb l"/></div></figure><h2 id="0c35" class="no kd iq bd ke np nq dn ki nr ns dp km ll nt nu kq lp nv nw ku lt nx ny ky nz bi translated">EmojiMap。tweet consumer-lib/e moji _ map/tweet _ consumer . ex</h2><p id="a3ba" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">消费者最终从广播公司接收经过过滤、标准化的推文，并通过WebSocket或Phoenix Channel将其发送到前端。这里唯一重要的是:不要把<code class="fe nk nl nm nn b">EmojiMap.Endpoint.broadcast</code>和GenStage系统的一部分混淆。它只是<code class="fe nk nl nm nn b"><a class="ae mv" href="https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#c:broadcast/3" rel="noopener ugc nofollow" target="_blank">Phoenix.Endpoint.broadcast/3</a></code>并向一个频道的所有订户发送消息。</p><h1 id="8f38" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">就这样&amp;谢谢</h1><p id="edb5" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">如果你有任何问题，反馈，评论:请评论或给我发消息。我希望这篇文章有助于理解GenStage。也许这是一个有趣的想法，你们中的一些人想用我扔出去的相当不完美的代码做点什么。</p><p id="8607" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">如果你想了解更多关于我们在</strong><a class="ae mv" href="https://www.codeshift.co" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir">codeshift</strong></a><strong class="lc ir">的工作，请查看我们的</strong> <a class="ae mv" href="https://www.codeshift.co" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">网站</strong> </a> <strong class="lc ir">。</strong></p><p id="6239" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">❤️谢谢。</p></div></div>    
</body>
</html>