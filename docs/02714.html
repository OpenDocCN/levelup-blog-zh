<html>
<head>
<title>Building a RESTful API with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js构建RESTful API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-restful-api-with-node-js-831bff629e3b?source=collection_archive---------2-----------------------#2020-03-31">https://levelup.gitconnected.com/building-a-restful-api-with-node-js-831bff629e3b?source=collection_archive---------2-----------------------#2020-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0bf1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Node.js、Express、MongoDB和React.js的全栈应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ad5357debb34218c1c3febc2d342271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JiEqpbLNSk6SxGFE"/></div></div></figure><p id="c19a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最近的任务是为运行Node.js后端的web应用程序构建REST API端点。使用Flask框架在Python中工作了一段时间后，我需要刷新Node.js并研究其支持的web框架的最新情况。</p><p id="9445" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇博客中，我构建了一个简单的Node.js应用程序，它从MongoDB数据库中读取数据，并向其中写入数据。我首先用Node HTTP包创建一个基本的web服务器，然后用Mongoose连接到MongoDB，最后用Express.js web框架增强应用程序。要跟进，你可以在我的GitHub上找到<a class="ae lq" href="https://github.com/ckraczkowsky91/rest-api-node-express" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="8dd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你对探索Flask框架感兴趣，我已经写了单独的博客解释<a class="ae lq" href="https://medium.com/@ckraczkowsky/getting-started-with-the-flask-web-framework-a7c2862dfba8" rel="noopener">如何开始使用Python的Flask框架</a>，<a class="ae lq" href="https://medium.com/@ckraczkowsky/building-modern-user-interfaces-with-flask-23016d453792" rel="noopener">如何使用Flask构建用户界面</a>，以及<a class="ae lq" href="https://medium.com/@ckraczkowsky/building-a-secure-admin-interface-with-flask-admin-and-flask-security-13ae81faa05" rel="noopener">如何使用Flask-Admin构建使用Flask-Security保护的管理界面</a>。</p><h2 id="ae02" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">构建一个简单的Node.js应用程序</strong></h2><p id="c6c9" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我们需要做的第一件事是在本地开发环境中安装Node.js。Node.js是一个开源、跨平台的运行时环境，它使我们的开发人员能够用JavaScript创建服务器端应用程序。然后，我们为项目创建文件夹，通过运行以下命令，我们将在其中构建Node.js应用程序。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="6a5d" class="lr ls it mq b gy mu mv l mw mx">$ mkdir rest-api-node-express</span></pre><p id="ab6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将添加到项目中的第一个文件是<code class="fe my mz na mq b">index.js</code>文件，我们将在该文件中编写在应用程序启动时运行的JavaScript。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="87cc" class="lr ls it mq b gy mu mv l mw mx">$ touch index.js</span></pre><p id="f3cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe my mz na mq b">index.js</code>文件中，我们添加代码来创建我们的基本web服务器，该服务器使用节点http包监听URL<a class="ae lq" href="http://127.0.0.1:4000/" rel="noopener ugc nofollow" target="_blank">HTTP://127 . 0 . 0 . 1:4000/</a>上的任何类型的HTTP请求。我们设置响应头，以便当接收到请求时，Node.js应用程序将以HTTP状态200进行响应，并且响应体的内容将以HTML返回。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="6119" class="lr ls it mq b gy mu mv l mw mx">const http = require(“http”);<br/>const hostname = “127.0.0.1”;<br/>const port = 4000;<br/>const basicWebServer = http.createServer((req, res) =&gt; {<br/>   res.writeHead(200, {‘Content-Type’: ‘text/html’});<br/>   res.end(‘&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;h2&gt;Item List&lt;/h2&gt;&lt;ul&gt;&lt;li style=”color: red”&gt;Item 1&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Add Item&lt;/h2&gt;&lt;form&gt;&lt;label for=”item”&gt;Item: &lt;/label&gt;&lt;input type=”text”&gt;&lt;/br&gt;&lt;input type=”submit” value=”Submit”&gt;&lt;/form&gt;’);<br/>});<br/>basicWebServer.listen(port, hostname, () =&gt; {<br/>   console.log(`Server running at <a class="ae lq" href="http://${hostname}:${port}/`);" rel="noopener ugc nofollow" target="_blank">http://${hostname}:${port}/`);</a><br/>});</span></pre><p id="02ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">响应头是可以在HTTP响应中使用的HTTP头，它与消息的内容无关。响应标头有许多属性；在我们的应用程序中，我们使用了<code class="fe my mz na mq b">Content-Type</code>属性。当这个属性被设置为<code class="fe my mz na mq b">text/plain</code>时，我们的Node.js应用程序将用纯文本的响应体来响应HTTP请求。我们可以用Postman来模拟这种情况，它提供了一个HTTP客户端来发出HTTP请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/940b070e5759617463a771c76b204d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HH7jFm4B6UdKb-ox"/></div></div></figure><p id="d601" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe my mz na mq b">Content-Type</code>属性被设置为<code class="fe my mz na mq b">text/html</code>时，我们的Node.js应用程序将用HTML格式的响应体来响应HTTP请求。我也用Postman模拟了下面的场景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/dcd5d184371ad45981e2e59be3e94bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XgIhd3XyusH_1dG3"/></div></div></figure><p id="d082" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们的应用程序首选的HTTP客户端是一个web浏览器，所以我们将Content-Type属性设置为text/html，这是当今浏览器的语言，并允许它们按照我们的意图呈现响应。</p><p id="d071" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要指示我们的基本web服务器处于活动状态，并在我们定义的主机和端口上等待请求。节点HTTP包为此提供了listen方法。这个方法将启动我们的web服务器，并告诉它监听连接。如果没有这样做的机制，就永远无法连接到我们的web服务器，因此也就永远无法发送响应。</p><p id="f200" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这些，我们就可以第一次启动Node.js应用程序了。我们可以使用node命令并提供index.js文件的路径来做到这一点。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="aa76" class="lr ls it mq b gy mu mv l mw mx">$ node ./index.js</span></pre><p id="6b3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个直观的指示，当我们的应用程序启动时，我们应该看到类似下面的消息，这是我们告诉Node.js记录的结果。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="1f60" class="lr ls it mq b gy mu mv l mw mx">Server running at <a class="ae lq" href="http://127.0.0.1:4000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:4000/</a></span></pre><h2 id="be81" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">安装并运行MongoDB </strong></h2><p id="f591" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">好了，到目前为止，我们已经让Node.js应用程序创建了一个web服务器，它监听http://127.0.0.1:4000/ 上的HTTP请求，并用一些HTML进行响应。现在，我们想通过向堆栈中添加一个数据库来包含一些持久性。我们将使用MongoDB，这是一个NoSQL，基于文档的数据库。所以首先，我们需要在本地开发环境中安装MongoDB。安装完成后，我们可以通过运行<code class="fe my mz na mq b">mongod</code>命令在本地启动MongoDB。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="a2d3" class="lr ls it mq b gy mu mv l mw mx">$ mongod</span></pre><p id="0f38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经有了一个MongoDB数据库，我们希望将它连接到我们的应用程序。我们可以使用MongoDB节点直接将Node.js连接到MongoDB。JS驱动。然而，使用这个驱动程序需要我们编写代码来与MongoDB交互并连接到MongoDB，执行数据库操作，实现错误处理，并执行回调操作。虽然这提供了性能增强和灵活性，但也增加了项目代码库的开销。相反，我们将使用Mongoose包，它使得为MongoDB建模我们的应用程序数据变得容易，并为转换、验证、查询构建和业务逻辑提供了许多很好的钩子。</p><h2 id="b918" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">用猫鼬连接到我们的数据库</h2><p id="75ae" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">像任何其他包一样，我们需要做的第一件事是在我们的本地环境中安装Mongoose包。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="4067" class="lr ls it mq b gy mu mv l mw mx">$ npm install mongoose</span></pre><p id="e720" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装好Mongoose后，我们将把它的<code class="fe my mz na mq b">mongoose</code>模块加载到我们的<code class="fe my mz na mq b">index.js</code>文件中。这个模块是一个构造器，将成为我们用Mongoose做的大多数事情的入口点。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="3cf2" class="lr ls it mq b gy mu mv l mw mx">const mongoose = require(‘mongoose’);<br/>...<br/>mongoose.connect(‘mongodb://127.0.0.1:27017/itemDB’);<br/>...</span></pre><blockquote class="nc nd ne"><p id="ab09" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>请注意使用require而不是import来加载模块。这是因为Node.js自带了对CommonJS的内置支持，不支持开箱即用的EcmaScript模块。这将导致我们的import语句失败，除非我们在项目中添加一个像Babel这样的JavaScript编译器。</p></blockquote><p id="1af7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在可以开始用猫鼬了。我们要做的第一件事是在本地运行的MongoDB实例上打开一个数据库连接。Mongoose通过提供<code class="fe my mz na mq b">connect</code>方法简化了这一过程，该方法将我们的MongoDB实例的URI作为第一个参数，将一个可选的配置对象作为第二个参数。默认情况下，MongoDB从端口27017开始。此外，我们将把自动为我们创建的数据库命名为<code class="fe my mz na mq b">itemDB</code>。使用这些信息，我们可以生成所需的URI。</p><p id="ecec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们试图这样运行，Node将抛出一些<code class="fe my mz na mq b">DeprecationWarning</code>消息，我们可以通过<code class="fe my mz na mq b">connect</code>方法可选的第二个参数向我们的Mongoose连接添加一些配置来修复这些消息。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="c7f3" class="lr ls it mq b gy mu mv l mw mx">mongoose.connect(‘mongodb://127.0.0.1:27017/itemDB’, {<br/>   “useNewUrlParser”: true,<br/>   “useUnifiedTopology”: true<br/>});</span></pre><h2 id="5c22" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">用猫鼬定义文档</strong></h2><p id="8620" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">Mongoose中的一切都是从一个模式开始的。每个模式映射到一个MongoDB集合，用于定义该集合中的文档。就在我们的代码中定义该模式的位置而言，我们将遵循流行的模型-视图-控制器(MVC)软件设计模式，在该模式中，我们通过将相关的程序逻辑划分为互连的模块来实现关注点的分离。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="60cf" class="lr ls it mq b gy mu mv l mw mx">$ touch itemModel.js</span></pre><p id="8fef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个文件代表了我们的模型模块。在其中，我们为数据库定义了一个项目的属性模式。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="c844" class="lr ls it mq b gy mu mv l mw mx">const mongoose = require(‘mongoose’);<br/>const Schema = mongoose.Schema;<br/>const itemSchema = new Schema({<br/>   name: {<br/>      type: String,<br/>      required: true<br/>   },<br/>   dateAdded: {<br/>      type: Date,<br/>      default: Date.now<br/>   }<br/>});</span><span id="e25d" class="lr ls it mq b gy nj mv l mw mx">module.exports = itemSchema;</span></pre><p id="e11a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">定义属性是在键-值对中完成的，其中键是属性的名称，值是我们希望键被转换的<code class="fe my mz na mq b">SchemaType</code>。例如，我们定义了一个属性<code class="fe my mz na mq b">name</code>，它将被转换为<code class="fe my mz na mq b">String</code>的<code class="fe my mz na mq b">SchemaType</code>，另一个属性<code class="fe my mz na mq b">dateAdded</code>，它将被转换为<code class="fe my mz na mq b">Date</code>的<code class="fe my mz na mq b">SchemaType</code>，默认值为当前日期和时间。</p><h2 id="097f" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">添加处理HTTP方法的逻辑</strong></h2><p id="3e0b" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">然后，我们将创建MVC应用程序的控制器模块，其中我们创建控制器来从我们的<code class="fe my mz na mq b">itemSchema</code>创建一个模型，并定义如何与该模型交互，即使用该模型创建一个新实例，找到一个或多个这些实例，更新一个或多个这些实例，等等。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="4c97" class="lr ls it mq b gy mu mv l mw mx">$ touch itemControllers.js</span></pre><p id="775d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使用我们的模式定义，我们需要将我们的<code class="fe my mz na mq b">itemSchema</code>转换成我们可以使用的数据模型。模型是Mongoose提供的一个构造函数，带有许多查询MongoDB的内置方法。我们在控制器的函数中使用这些方法来处理传入的HTTP请求，例如GET、POST、PUT、DELETE等。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="f765" class="lr ls it mq b gy mu mv l mw mx">const mongoose = require(‘mongoose’);<br/>const itemSchema = require(‘./itemModel’);<br/>const Item = mongoose.model(‘Item’, itemSchema);<br/>const addItem = (req, res) =&gt; {<br/>   let newItem = new Item(req.body);<br/>   newItem.save((err, Item) =&gt; {<br/>      if (err) {<br/>         res.send(err);<br/>      } else {<br/>         res.json(Item);<br/>      };<br/>   });<br/>};<br/>const getItems = (req, res) =&gt; {<br/>   Item.find({}, (err, Item) =&gt; {<br/>      if (err) {<br/>         res.send(err);<br/>      } else {<br/>         res.json(Item);<br/>      };<br/>   });<br/>};</span><span id="d5fb" class="lr ls it mq b gy nj mv l mw mx">module.exports.addItem = addItem;<br/>module.exports.getItems = getItems;</span></pre><p id="6e71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的第一个控制器函数<code class="fe my mz na mq b">addItem</code>将创建一个名为<code class="fe my mz na mq b">Item</code>的新模型实例，将其保存到我们的MongoDB数据库中，如果成功，将返回该实例的JSON表示。模型类的一个实例是文档，它们是MongoDB中的条目，所以返回的内容类似于我们数据库中输入的内容。我们的第二个控制器<code class="fe my mz na mq b">getItems</code>将定位<code class="fe my mz na mq b">Item</code>的所有实例，并以JSON格式返回它们。这些控制器将成为POST背后的机制，并获得我们的REST API的端点。</p><h2 id="3b5a" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">创建API端点</strong></h2><p id="bfbd" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">既然我们有了查询数据库的机制，我们需要创建一个路径，REST客户机可以调用这个路径来执行这个机制。这是使用路线完成的。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="9c61" class="lr ls it mq b gy mu mv l mw mx">$ touch itemRoutes.js</span></pre><p id="213e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先加载我们在<code class="fe my mz na mq b">itemControllers.js</code>文件中定义的控制器。然后，我们将路由的端点定义为'/items '，这将成为REST API中使用的请求URL的一部分。最后，我们将控制器传递给应用程序，并将它们与适当的HTTP方法相关联。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="8c9a" class="lr ls it mq b gy mu mv l mw mx">const controllers = require(‘./itemControllers’);<br/>const addItem = controllers.addItem;<br/>const getItems = controllers.getItems;<br/>const path = require(‘path’);<br/>const routes = (app) =&gt; {<br/>   app.route(‘/items’)<br/>   .post(addItem)<br/>   .get(getItems);<br/>};</span><span id="4e4c" class="lr ls it mq b gy nj mv l mw mx">module.exports = routes;</span></pre><p id="28ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以通过POST端点添加数据，并查看通过GET端点发布的数据。</p><p id="530d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">使用Express.js web框架增强我们的应用</strong></p><p id="a41c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会注意到我们的<code class="fe my mz na mq b">routes</code>函数采用了一个参数，我们用它来定义一个路由，并定义调用该路由时要执行的函数。这就是Express.js web框架的用武之地，因为我们将创建一个Express的实例来访问它的<code class="fe my mz na mq b">route</code>、<code class="fe my mz na mq b">get</code>和<code class="fe my mz na mq b">post</code>方法，使我们的Node.js服务器更容易处理REST路由。</p><p id="a748" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Express是一个最小且灵活的Node.js web应用程序框架，它提供了一个基本web应用程序功能的薄层。相比之下，Node适用于直接在计算机或服务器操作系统上运行的服务器端应用程序，而web应用程序则需要通过web浏览器等客户端在web上运行。因此，Node省略了特定于浏览器的JavaScript APIs，并增加了对更传统的OS APIs的支持，如我们在上面的<strong class="kw iu">构建简单的Node.js应用程序</strong>部分中使用的Node HTTP包。</p><p id="55ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是说Node.js没有内置对常见web开发任务的支持。为了给不同的HTTP方法添加特定的处理，单独处理路由请求，或者像网页一样提供静态文件，我们要么需要自己编写代码，要么使用web框架—输入Express！在Python世界中生活了一段时间后，我回到了Node，并做了如下类比:Express框架对于JavaScript就像Django和Flask框架对于Python一样。</p><p id="282a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在回到代码。要开始使用Express.js web框架，我们需要做的第一件事是在我们的本地环境中安装Express包，就像我们在Mongoose中所做的那样。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="950e" class="lr ls it mq b gy mu mv l mw mx">$ npm install express</span></pre><p id="f56b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们将重构<code class="fe my mz na mq b">index.js</code>文件以使用Express。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="ab1d" class="lr ls it mq b gy mu mv l mw mx">const express = require(‘express’);<br/>...<br/>const app = express();<br/>app.use(express.json());<br/>...<br/>routes(app);<br/>app.listen(port, hostname, () =&gt; {<br/>   console.log(`Server running at <a class="ae lq" href="http://${hostname}:${port}/`);" rel="noopener ugc nofollow" target="_blank">http://${hostname}:${port}/`);</a><br/>});<br/>...</span></pre><p id="cfef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将Express加载到我们的项目中，然后使用它的顶级<code class="fe my mz na mq b">express</code>函数创建一个Express应用程序。由<code class="fe my mz na mq b">express</code>函数返回的对象是一个JavaScript函数，作为处理请求的回调传递给Node.js服务器，按照惯例，我们已经将这个对象赋给了一个名为<code class="fe my mz na mq b">app</code>的新变量。调用<code class="fe my mz na mq b">app.listen</code>函数实际上启动了UNIX套接字，告诉它监听指定主机和端口上的连接。这与我们在上面的<strong class="kw iu">构建一个简单的Node.js应用程序</strong>部分中所做的相同，当时我们将<code class="fe my mz na mq b">basicWebServer.listen</code>编码到文件中。接下来，我们调用一些中间件来允许我们的应用程序解析JSON请求，这将在本节稍后讨论。最后，我们将新创建的Express应用程序传递给我们在<code class="fe my mz na mq b">itemRoutes.js</code>文件中定义的<code class="fe my mz na mq b">routes</code>函数。</p><h2 id="4103" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">了解我们应用程序的优势表达</strong></h2><p id="2f17" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">让我们带着对Express.js web框架是什么以及我们为什么使用它的新理解，通过重新访问<code class="fe my mz na mq b">itemRoutes.js file</code>、<code class="fe my mz na mq b">itemControllers.js</code>文件和<code class="fe my mz na mq b">index.js</code>文件，在我们自己的代码中更深入地看看Express的实际应用。</p><p id="ec27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先来看一下<code class="fe my mz na mq b">itemRoutes.js</code>文件中的<code class="fe my mz na mq b">routes</code>函数。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="559a" class="lr ls it mq b gy mu mv l mw mx">...<br/>const routes = (app) =&gt; {<br/>   app.route(‘/items’)<br/>      .post(addItem)<br/>      .get(getItems);<br/>};<br/>...</span></pre><p id="bba7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们在上面看到的，Express使得用内置方法为不同HTTP方法的请求编写处理程序变得很容易。此外，如果我们希望将数据库中的特定文档作为目标，例如处理PUT请求，Express可以轻松地将标识符添加到我们的路由中，并使它们可供处理。</p><p id="fffe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们看看<code class="fe my mz na mq b">itemControllers.js</code>文件中的<code class="fe my mz na mq b">addItem</code>控制器函数。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="ef49" class="lr ls it mq b gy mu mv l mw mx">const addItem = (req, res) =&gt; {<br/>   let newItem = new Item(req.body);<br/>   newItem.save((err, Item) =&gt; {<br/>      if (err) {<br/>         res.send(err);<br/>      } else {<br/>         res.json(Item);<br/>      };<br/>   });<br/>};</span></pre><p id="467b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了我们的利益，Express提供了代表HTTP请求的<code class="fe my mz na mq b">req</code>对象，包括请求的属性，比如查询字符串、查询参数、尊重主体和HTTP头。在我们的<code class="fe my mz na mq b">addItem</code>函数中，我们主要对<code class="fe my mz na mq b">req.body</code>属性感兴趣，该属性包含在请求体中提交的数据的键值对，并且应该与我们在<code class="fe my mz na mq b">itemModel.js</code>文件中定义的模式相匹配。</p><p id="2502" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Express还提供了一个<code class="fe my mz na mq b">res</code>对象，这是一个Express应用程序在收到HTTP请求时发送的HTTP响应。这个对象有很多方法，包括<code class="fe my mz na mq b">send</code>方法，我们用它来发送一个错误消息作为响应。它还有一个<code class="fe my mz na mq b">json</code>方法，如果成功创建了新项目，我们就用这个方法把它以JSON格式发送回去。无论哪种情况，Express都会自动为响应添加<code class="fe my mz na mq b">Content-Type</code>和<code class="fe my mz na mq b">Content-Length</code>头。我们可以使用Postman工具来观察这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/43ac405be565063c70921a74c81e976f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_c2pPqTHlfkc_Xzi"/></div></div></figure><p id="c68f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们看看添加了下面一行的<code class="fe my mz na mq b">index.js</code>文件。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="d05e" class="lr ls it mq b gy mu mv l mw mx">...<br/>app.use(express.json());<br/>...</span></pre><p id="a5ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na mq b">express.json</code>函数举例说明了Express的另一个好处，它是处理HTTP请求的中间件，比如用于解析POST请求主体的函数。这个函数允许我们解析JSON格式的<code class="fe my mz na mq b">req</code>对象，并且只查看那些<code class="fe my mz na mq b">Content-Type</code>头与默认的类型选项<code class="fe my mz na mq b">application/json</code>匹配的请求。如果接收到另一种类型的请求，例如<code class="fe my mz na mq b">application/xml</code>，Express包含错误处理以返回错误。</p><p id="c1fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na mq b">express.json</code>函数还为我们填充了一个包含解析数据的新的<code class="fe my mz na mq b">body</code>对象，并在<code class="fe my mz na mq b">req</code>对象中返回它。这是我们通过<code class="fe my mz na mq b">req.body</code>属性在<code class="fe my mz na mq b">newItem</code>变量中访问的内容，我们将该属性传递给Mongoose以保存到我们的数据库中。</p><p id="fb8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不用说，如果没有Express.js web框架，我们将需要自己编写更多的代码。</p><h2 id="890e" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">使用我们的REST API </strong></h2><p id="e105" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我们准备再次使用Express应用程序启动Node.js，并使用我们的REST API。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="bf66" class="lr ls it mq b gy mu mv l mw mx">$ node ./index.js</span></pre><p id="fe13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们回到我们在上面的<strong class="kw iu">构建一个简单的Node.js应用程序</strong>小节中使用的Postman工具，并向位于<a class="ae lq" href="http://127.0.0.1:4000/items" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:4000/items</a>路径的“/items”端点提交一个POST请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/becefded3c9cfc9de06a49cf1cac2832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lyH83IkkdmD3qr3J"/></div></div></figure><p id="2968" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们验证该数据是否成功保存到我们的数据库中。MongoDB提供了一个命令行接口，称为mongo shell。我们可以通过输入<code class="fe my mz na mq b">mongo</code>命令来启动这个shell。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="1723" class="lr ls it mq b gy mu mv l mw mx">$ mongo</span></pre><p id="2627" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在mongo shell中，我们可以查看我们的数据库。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="60a3" class="lr ls it mq b gy mu mv l mw mx">&gt; show databases<br/>itemDB 0.000GB<br/>&gt; use itemDB<br/>switched to db itemDB<br/>&gt; show collections<br/>items<br/>&gt; db.items.find()<br/>{ “_id” : ObjectId(“*********************************”), “name” : “bag”, “dateAdded” : ISODate(“2020–03–29T19:52:42.648Z”), “__v” : 0 }</span></pre><p id="f1b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们看到，在我们的第一个POST请求中，我们的数据库是根据我们在上面的<strong class="kw iu">使用mongose</strong>连接到我们的数据库一节中定义的连接字符串末尾给出的名称自动创建的。我们看到,<code class="fe my mz na mq b">items</code>集合也是自动创建的。这是因为Mongoose通过它的<code class="fe my mz na mq b">utils.toCollectionName </code>方法自动生成一个集合名，该方法创建了我们的模型名的复数小写版本，我们在上面的<strong class="kw iu">添加处理HTTP方法的逻辑</strong>部分的<code class="fe my mz na mq b">itemControllers.js</code>文件中将其定义为<code class="fe my mz na mq b">mongoose.model(‘Item’, itemSchema) </code>。最后，我们看到一个文档被添加到集合中，其中包含我们在POST请求中提供的数据。</p><p id="2685" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然我们可以在MongoDB中看到我们的条目，但是我们应该仔细检查一下我们的“/items”端点是否也可以像预期的那样处理GET请求。我们可以使用邮递员工具来完成这项工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/d8a32c443f8e67c8e0959770c6f922c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1C3Ba44ixc-Jxs1q"/></div></div></figure><p id="8e08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了，一切似乎都在工作！我们现在有了一个构建在Node.js上的工作REST API，它使用Express.js web框架，使用Mongoose从MongoDB数据库中读取和写入数据。虽然这满足了我们的要求，但还有一点可选的工作要做。随着我们为支持Express所做的重构，我们不再有前端了！</p><h2 id="bb13" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">添加前端</strong></h2><p id="03d9" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在上面的<strong class="kw iu">用Express.js web框架增强我们的应用</strong>一节中，我们重构了<code class="fe my mz na mq b">index.js</code>文件来创建一个Express应用，而不是使用Node HTTP包创建一个基本的web服务器。这让我们可以访问<code class="fe my mz na mq b">app</code>对象以及<code class="fe my mz na mq b">req</code>和<code class="fe my mz na mq b">res</code>对象。正如我在<strong class="kw iu">用Express.js web框架增强我们的应用</strong>一节中提到的，Node.js没有内置机制来服务静态文件，但Express有。在本节中，我们将使用该特性向节点应用程序添加一个HTML前端。</p><p id="a0ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能已经注意到，当我们用Express instantiation替换了<code class="fe my mz na mq b">http.createServer</code>时，对<a class="ae lq" href="http://127.0.0.1:4000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:4000/ </a>的调用不再返回我们编码的古老HTML。我们现在将使用Express提供给上面提到的<code class="fe my mz na mq b">res</code>对象的<code class="fe my mz na mq b">sendFile</code>方法将它添加回来。</p><p id="fa17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na mq b">sendFile</code>方法需要一个静态文件的路径，所以我们首先需要创建一个文件。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="4400" class="lr ls it mq b gy mu mv l mw mx">$ touch index.html</span></pre><p id="b8b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用想要显示的内容填充新的<code class="fe my mz na mq b">index.html</code>文件。然后我们需要为这个文件创建路径。我们希望从我们的项目的根目录提供<code class="fe my mz na mq b">index.html</code>文件，所以我们向我们的<code class="fe my mz na mq b">itemRoutes.js</code>文件添加了一个新的路径，并相应地设置了路径。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="b5bb" class="lr ls it mq b gy mu mv l mw mx">...<br/>const routes = (app) =&gt; {<br/><strong class="mq iu">   app.route(‘/’)<br/>      .get((req, res) =&gt; {<br/>         res.sendFile(path.join(__dirname + ‘/index.html’));<br/>      });</strong><br/>   app.route(‘/items’)<br/>      .post(addItem)<br/>      .get(getItems);<br/>};<br/>...</span></pre><p id="9333" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na mq b">sendFile</code>方法按照我们给定的路径传输文件，根据文件名的扩展名设置<code class="fe my mz na mq b">Content-Type</code>响应HTTP头字段。我们可以通过使用我们所做的更改重新启动我们的应用程序，导航到<a class="ae lq" href="http://127.0.0.1:4000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:4000/ </a>，并检查浏览器的开发人员工具来观察这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/79e2b559e371a997bca1450944077853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-5TTEvDmkBF-GcNY"/></div></div></figure><p id="6d8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了一个使用Express web框架构建在Node.js中的REST API，并通过一个非常基本的前端连接到MongoDB数据库！在未来，我们可以将我们的基本前端重构为React.js应用程序，以允许最终用户查看和编辑我们数据库中的数据，并将后端和前端部署到AWS或Heroku等云基础架构。</p><p id="23ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要查看Nodes.js、Express和MongoDB的运行情况，请从我的GitHub中克隆我们在这篇博客中构建的应用程序的源代码<a class="ae lq" href="https://github.com/ckraczkowsky91/rest-api-node-express" rel="noopener ugc nofollow" target="_blank">，并在您的本地机器上运行它。</a></p><h2 id="e51c" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">关于作者</h2><p id="6410" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">Colin Kraczkowsky在探索了产品管理的技巧之后，最近回到了web开发领域。Colin的职业经历包括在企业和初创企业环境中工作，编写web和移动应用程序代码，推出新产品，构建模型和原型，分析指标，以及不断创新。</p><p id="dba7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闲暇时，科林会去大苏尔看看最新的阿利特露营装备，计划下一次去柯克伍德·丹尼尔山，或者在网飞的恐怖区冲浪。科林目前居住在加利福尼亚州的旧金山。</p><p id="72d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与科林-https://www.linkedin.com/in/colinkraczkowsk联系</p></div></div>    
</body>
</html>