<html>
<head>
<title>Understanding Node.js File System Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Node.js文件系统模块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-node-js-file-system-module-b16da1e01949?source=collection_archive---------2-----------------------#2019-06-24">https://levelup.gitconnected.com/understanding-node-js-file-system-module-b16da1e01949?source=collection_archive---------2-----------------------#2019-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1f6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">文件系统是一种机制，用于控制数据在硬盘上的存储方式，以及在操作系统上的访问和管理方式。Node.js中的文件系统模块允许您以编程方式与操作系统上的文件系统进行交互。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/5793ddcb85159c8a0ad29cc5d065e351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*6Lj4amyOX_v7EcYZdNIBUQ.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">图片来自Pixabay</figcaption></figure><p id="f085" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用文件系统(<code class="fe la lb lc ld b">fs</code>)模块，我们可以执行读、写、删除和许多其他操作。让我们看看一些最重要的操作。</p><h1 id="ca69" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">先决条件</h1><p id="ea62" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">在我们开始研究文件系统操作之前，我们需要导入<code class="fe la lb lc ld b">fs</code>模块。</p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="2784" class="ml lf it ld b gy mm mn l mo mp">const fs = require("fs");</span></pre><h1 id="c3f0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">同步和异步读取文件</h1><p id="49a7" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">fs模块提供了简单的读取文件的方法:<code class="fe la lb lc ld b">fs.readFile()</code>和<code class="fe la lb lc ld b">fs.readFileSync()</code>T12。<code class="fe la lb lc ld b">fs.readFile()</code>用于异步读取文件，<code class="fe la lb lc ld b">fs.readFileSync()</code>用于同步读取文件。</p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="4d09" class="ml lf it ld b gy mm mn l mo mp">fs.readFile('file.txt', function(err, data) {<br/>    if (err) return callback(err);<br/><br/>    // If succeeded, print the contents.<br/>    console.log(data);<br/>});</span></pre><p id="d74a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，文件路径必须作为第一个参数和一个回调函数提供，该函数将使用文件数据进行调用。</p><p id="07b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe la lb lc ld b">fs.readFileSync()</code>，我们将文件路径作为参数传递。</p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="40d0" class="ml lf it ld b gy mm mn l mo mp">const data = fs.readFileSync('test.txt', "utf8");<br/>console.log(data);</span></pre><p id="fbbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">utf8</code> <em class="mq"> </em>是默认编码，但是我们可以指定任何我们需要的定制编码作为两个方法中的第二个参数。</p><p id="d6ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两种方法都在返回数据之前读取内存中的整个文件内容。当我们读取大文件时，这可能会造成问题。为了处理这些情况，建议将<em class="mq">流</em>与<code class="fe la lb lc ld b">fs</code>模块一起使用。</p><h1 id="c0b0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">通过流读取文件</h1><p id="8804" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们经常要处理大文件。读取操作可能会花费相当多的时间，并占用更多的内存。在这种情况下，我们可以使用流。我们可以使用读取文件，并在一大块数据准备好发送时通过HTTP连接提供它。</p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="e3a7" class="ml lf it ld b gy mm mn l mo mp">const http = require('http')<br/>const fs = require('fs')</span><span id="e4bc" class="ml lf it ld b gy mr mn l mo mp">const server = http.createServer((req, res) =&gt; {<br/>  const stream = fs.createReadStream('test.txt')<br/>  stream.pipe(res)<br/>})<br/>server.listen(3000, () =&gt; {<br/>    console.log(`Server running at port 3000`)<br/>})</span></pre><p id="1589" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们正在建立HTTP连接，读取文件并将其传输到HTTP客户端。<code class="fe la lb lc ld b">pipe()</code> <em class="mq"> </em>用于将文件流传送到HTTP响应。</p><h1 id="d931" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">同步和异步写文件</h1><p id="880d" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">编写文件最简单的方法是调用<code class="fe la lb lc ld b">fs.writeFile()</code> <em class="mq"> </em>，这是一个异步操作。</p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="6683" class="ml lf it ld b gy mm mn l mo mp">fs.writeFile('file.txt', "Hello world", function(err) {<br/>    if (err) return callback(err);</span><span id="31d3" class="ml lf it ld b gy mr mn l mo mp">    // If succeeded, print the message.<br/>    console.log("file created successfully!")<br/>});</span></pre><p id="ff09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在同步写操作中，我们写如下:</p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="9afe" class="ml lf it ld b gy mm mn l mo mp">try {<br/>  const file = fs.writeFileSync('test.txt', "Hello world");<br/>} catch (err) {<br/>  console.error(err)<br/>}</span></pre><p id="d714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，这些API调用将覆盖已经存在的内容。我们可以通过在options参数中指定一个标志来覆盖此行为，如下所示:</p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="39e2" class="ml lf it ld b gy mm mn l mo mp">{ flag: 'a+' }</span></pre><p id="caf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当写入大量数据时，我们可能会遇到内存效率的问题。像可读的流一样，我们也有可写的流API <code class="fe la lb lc ld b">fs.createWriteStream()</code> <em class="mq"> </em>来成块地写数据。</p><h1 id="db06" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查文件的状态</h1><p id="a7aa" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们可以使用<code class="fe la lb lc ld b">fs.stat()</code>和<code class="fe la lb lc ld b">fs.statSync()</code> <em class="mq">来检查文件的细节。</em></p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="4dc1" class="ml lf it ld b gy mm mn l mo mp">fs.stat('test.txt', (err, stats) =&gt; {<br/>    if (err) {<br/>      console.error(err)<br/>      return<br/>    }<br/>    console.log(stats.isFile());<br/>    console.log(stats.isSymbolicLink());<br/>    console.log(stats.isDirectory());<br/>    console.log(stats.size);<br/>  });</span><span id="5748" class="ml lf it ld b gy mr mn l mo mp">const status = fs.statSync('test.txt');</span><span id="324c" class="ml lf it ld b gy mr mn l mo mp">  console.log(status.isFile());<br/>  console.log(status.isSymbolicLink());<br/>  console.log(status.isDirectory());<br/>  console.log(status.size);</span></pre><p id="6d24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，<em class="mq"> stats或status </em>变量上的<code class="fe la lb lc ld b">isFile()</code> <em class="mq"> </em>方法告诉它是否是一个文件。同样，<code class="fe la lb lc ld b">isDirectory()</code> <em class="mq"> </em>告知是否是目录。<code class="fe la lb lc ld b">isSymbolicLink()</code> <em class="mq"> </em>告知文件是否是符号链接。最后，<code class="fe la lb lc ld b">size</code><em class="mq">属性告诉文件的大小。</em></p><h1 id="71df" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">删除文件或符号链接</h1><p id="004a" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们可以异步删除一个文件或一个符号链接。该方法只接受文件路径和回调函数。</p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="11f4" class="ml lf it ld b gy mm mn l mo mp">fs.unlink('test.txt', (err) =&gt; {<br/>  if (err) throw err;<br/>  console.log('test.txt was removed');<br/>});</span></pre><p id="5334" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此方法不适用于目录。我们可以用<code class="fe la lb lc ld b">fs.rmdir()</code> <em class="mq"> </em>来代替。</p><p id="faed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于同步操作，我们有<code class="fe la lb lc ld b">fs.unlinkSync()</code>。</p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="9e61" class="ml lf it ld b gy mm mn l mo mp">fs.unlinkSync('text.txt');</span></pre><h1 id="7c92" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">重命名文件</h1><p id="4e84" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">可以使用<code class="fe la lb lc ld b">fs.rename()</code> <em class="mq">重命名文件。这里，它以旧文件名、新文件名和一个回调函数作为参数。</em></p><pre class="kp kq kr ks gt mh ld mi mj aw mk bi"><span id="d912" class="ml lf it ld b gy mm mn l mo mp">fs.rename('file.txt', 'hello.txt', (err) =&gt; {<br/>  if (err) throw err;<br/>  console.log('Rename complete!');<br/>});</span></pre><p id="dde4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，我们有<code class="fe la lb lc ld b">fs.renameSync()</code> <em class="mq"> </em>进行同步操作。</p><h1 id="8f31" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包扎</h1><p id="52d3" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">在本文中，我们只是介绍了一些最常用的API方法。在<code class="fe la lb lc ld b">fs</code>模块中有更多的方法。查看<a class="ae ms" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank">此处</a>的完整文档。</p><p id="d31e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里是本文中使用的例子的<a class="ae ms" href="https://github.com/swathisprasad/nodejs-fs-module-examples" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><p id="3a4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mq">本文原载于</em><a class="ae ms" href="https://techshard.com/2019/06/24/understanding-node-js-file-system-module/" rel="noopener ugc nofollow" target="_blank"><em class="mq">techshard.com</em></a><em class="mq">。</em></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt na"><a href="https://gitconnected.com/learn/node-js" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">学习Node.js -最佳Node.js教程(2019) | gitconnected</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">排名前44的Node.js教程-免费学习Node.js。课程由开发人员提交和投票，使您能够…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">gitconnected.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ku na"/></div></div></a></div></div></div>    
</body>
</html>