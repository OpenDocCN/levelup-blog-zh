<html>
<head>
<title>EventSourcing with NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NodeJS的事件源</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/eventsourcing-with-nodejs-5d0f8e255676?source=collection_archive---------13-----------------------#2020-07-27">https://levelup.gitconnected.com/eventsourcing-with-nodejs-5d0f8e255676?source=collection_archive---------13-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/327e2705c870b22f8ebb14027c1ca06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpMwBCVZbHDCzWtl2SfnEA.png"/></div></div></figure><p id="8674" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近我一直在使用NodeJS中的事件源构建一个小应用程序。</p><p id="e536" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常我是用Ruby做的，用NodeJS做很有趣，想和你分享一下。</p><p id="6810" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我举了WhatsApp的例子:我们将构建WhatsApp的一个子部分，特别是群组功能。<br/>我们不会建立聊天功能…:)</p><p id="558b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从互动开始:</p><ul class=""><li id="9606" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">创建组</li><li id="04eb" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">添加参与者</li><li id="4a56" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">移除参与者</li><li id="7e89" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">改变话题</li></ul><p id="36dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个动作都有一个到域事件的一对一映射。</p><p id="89b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单来说:</p><ul class=""><li id="8572" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">GroupWasCreated {groupSubject，userIds，currentUserId}</li><li id="3a57" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">参与者已添加{groupId，userId，admin}</li><li id="3a61" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">参与者已删除{groupId，userId，admin}</li><li id="6e86" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">SubjectWasChanged { group subject }</li></ul><p id="4414" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很自然，对吧？</p><blockquote class="ln"><p id="1883" class="lo lp it bd lq lr ls lt lu lv lw ky dk translated"><em class="lx">这就是事件采购的美妙之处:设计交互及其结果是一件很容易的事情。</em></p></blockquote><p id="cfe5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">不需要考虑数据库模型或关系:我们完全按照人类的方式来描述系统。</p><p id="5e85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语义注释:我们正在实现一个基于聚合的微服务。我们可以将WhatsApp::Group视为AggregateRoot，并确定两个子实体:WhatsApp::Group和WhatsApp::GroupParticipant。<br/>后者引用带有 <code class="fe me mf mg mh b"><em class="md">userId</em></code> <em class="md">外键的远程聚合。</em></p><p id="0a85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们为这些特性定义一个API服务(一个AggregateRoot api)。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b7ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将被我们的HTTP API层(即。MVC模式中的控制器)，在本例中是ExpressJS。但是我们也可以将这个AggregateRoot api挂接到像Kafka这样的消息总线上，接收命令消息。</p><p id="5c38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="md">技术提示:我们将假设所有方法都是</em> <code class="fe me mf mg mh b"><em class="md">async</em></code> <em class="md">并返回承诺。<br/> NB:我不是节点。JS专家，我是相当的Ruby专家。所以如果你有什么代码推荐，欢迎评论。</em></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="aa8d" class="mv mw it bd mx my mz dn na nb nc dp nd km ne nf ng kq nh ni nj ku nk nl nm nn bi translated">“创建组”命令</h2><p id="7141" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">我们可以选择如何实现它:</p><ul class=""><li id="87bb" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">要么使用单个事件<strong class="kd iu"><em class="md">group is created</em></strong>(它包括原始参与者和主题)来描述参与者列表、主题和组管理。</li><li id="822a" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">或者在发射<strong class="kd iu"> <em class="md">组创建</em> </strong>时，发射事件<strong class="kd iu"> <em class="md">参与者被添加</em></strong><strong class="kd iu"><em class="md">主题被更改</em> </strong>。</li></ul><p id="5ad4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一种解决方案减少了事件的数量，并且具有隐含的行为；而后者使创建时发生的事情一目了然，并允许命令端(<em class="md"> createGroup </em>调用<em class="md"> addParticipant </em>)和查询端(我们不必将<strong class="kd iu"><em class="md">group was created</em></strong>作为特殊事件处理，并从中提取参与者，因为我们知道<strong class="kd iu"><em class="md">participant was add</em></strong>事件将与它一起发出)。</p><p id="fd25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了可重用性(DRY)和清晰性(没有隐式行为)，我将选择第二种解决方案并发出每个事件。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8db9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用一个库来帮助我存储和获取npm上的事件:<code class="fe me mf mg mh b">eventstore</code>。</p><p id="fb69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe me mf mg mh b">npm install --save eventstore</code></p><p id="c416" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe me mf mg mh b">npm install --save uid</code></p><p id="84af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一个内存适配器(基本上是一个假的数据库)，但是lib也提供了一个MongoDB和Redis适配器。我个人在以前的项目中使用过Redis，但MongoDB应该是imo的默认选择。</p><p id="da64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将在我的服务的构造函数中初始化lib，并在加载事件周围添加一个小的Promise包装器，以获得一个良好一致的Promise api。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d9b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但到目前为止，我还没有运行代码。</p><p id="83fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，因为我很懒…而且很专业…(懒的部分实际上更准确，但那是另一个争论)我要写一个自动化测试:)</p><p id="4b97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是的编码人员，如果你不写自动化测试…你只是半个专业人员！(根据鲍勃大叔；而且练了4年BDD/TDD，不得不认同)。</p><p id="9527" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe me mf mg mh b">npm install --save-dev assert</code></p><p id="86c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe me mf mg mh b">npm install --save-dev mocha</code></p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e336" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们目前没有办法获得我们实体的“结束状态”，我们只能验证事件正在被发出。<br/>让我运行一下，看看这是否有效……好的，在几次修复后，它确实运行了。</p><p id="12a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一步的代码在分支“step-1”的<a class="ae nt" href="https://github.com/diegodurs/evented_whatsapp/tree/step-1" rel="noopener ugc nofollow" target="_blank"> github上。<br/>可以拉一下试跑<code class="fe me mf mg mh b">npm install</code>和<code class="fe me mf mg mh b">npm test</code>。</a></p><p id="b693" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，聚合行为由以下内容定义(至少对于创建而言):</p><ul class=""><li id="6144" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">当<em class="md">命令</em>时</li><li id="730a" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">然后是<strong class="kd iu"> <em class="md">事件</em> </strong></li></ul><p id="c49f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这反映在测试中。<br/>当我们要实现“更新”命令(如“addParticipant”)时，我们将有:</p><ul class=""><li id="1922" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">给定<strong class="kd iu">事件<em class="md">事件</em>事件</strong></li><li id="e5b4" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">当<em class="md">命令</em>时</li><li id="6dfd" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">然后是<strong class="kd iu"> <em class="md">事件</em> </strong></li></ul><p id="46b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止，我们一直在构建应用程序的“命令端”,目前只有一个命令，但没有读取应用程序状态的功能(除了对用户不太友好的事件流)。<br/>这就是EventSourcing与CQRS相结合的原因:命令/查询分离。</p><p id="58d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个阶段的应用程序代码可以在<a class="ae nt" href="https://github.com/diegodurs/evented_whatsapp/tree/step-1" rel="noopener ugc nofollow" target="_blank"> github分支step-1 </a>上找到。</p><h2 id="f96b" class="mv mw it bd mx my mz dn na nb nc dp nd km ne nf ng kq nh ni nj ku nk nl nm nn bi translated">到目前为止怎么样？</h2><p id="6d17" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">让我们意识到，有了这个，我们就有了一个持久化模型，它可以接受非结构化数据，并为参与者持久化一个多对多关系。</p><p id="8478" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这本身就很强大:如果您想添加一个新的命令或持久化另一个“属于”或“有多个”关联，您不必进行任何数据库迁移或深入思考；只要在无处不在的领域语言和事件源中定义了清晰的AggregateRoot，就很容易以清晰一致的方式添加行为。我们将在下一步看到这一点。</p><p id="1839" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们想要添加特定于该组的通知设置，这只是一个新命令和一个新事件。就命令模型而言非常简单:不需要更改数据库，唯一需要的更改仅限于领域需求:一个命令、一个事件；就是这样。</p><h2 id="2e27" class="mv mw it bd mx my mz dn na nb nc dp nd km ne nf ng kq nh ni nj ku nk nl nm nn bi translated">让我们来比较一下CRUD:</h2><p id="318c" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">我们需要一个Group模型和一个GroupParticipant模型，用一个<code class="fe me mf mg mh b">has_many/belongs_to</code>关系联系起来。两者都有像底层ORM中的“创建”、“更新”和“销毁”这样的方法。<br/><em class="md">create group</em>逻辑您可以在控制器中使用<code class="fe me mf mg mh b">GroupParticipant.create</code>添加参与者(在我看来这是个坏主意)。更好的方法是在模型中，将Group.create方法覆盖到使用<code class="fe me mf mg mh b">GroupParticipant.create</code>的定制域逻辑。<br/>但更好的是:您可以围绕每个AggregateRoot(正如我们在这里所做的那样)构建一个服务模块(在模型之外),它将定义围绕该聚合可用的所有命令和查询。这将最终得到一个与我们现有的代码结构非常相似的代码结构。但在MVC框架中并不常见:Rails和其他人不鼓励这种类型的代码结构。</p><blockquote class="nu nv nw"><p id="6ad3" class="kb kc md kd b ke kf kg kh ki kj kk kl nx kn ko kp ny kr ks kt nz kv kw kx ky im bi translated">在ORM默认值之外进行开发，可以使用集合、存储库和值对象的清晰架构概念，使您的代码更加整洁。</p></blockquote><p id="1821" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，即使使用干净的代码架构，使用经典的MVC，您也需要两个DB表，并且任何新特性都可能需要数据库迁移。</p><h2 id="d17c" class="mv mw it bd mx my mz dn na nb nc dp nd km ne nf ng kq nh ni nj ku nk nl nm nn bi translated">状态？</h2><p id="de73" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">现在，让我们来看看如何获得某种状态。<br/>目前我们可以查询事件，通常是通过<code class="fe me mf mg mh b">aggregate_id</code>，但是也可以通过<code class="fe me mf mg mh b">aggregate_type</code>或者<code class="fe me mf mg mh b">event_name</code>加载。<br/>但这并不高效(例如，查询所有超过2个参与者的组将需要处理所有<code class="fe me mf mg mh b">ParticipantWasAdded</code>事件)，也不人性化(我们没有简单的方法来获得组的最终状态，只有它的事件)。</p><p id="0d35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个问题的常见解决方案是实现一个投影，该投影处理所有事件并更新为查询而创建的特殊数据库。</p><h1 id="de67" class="oa mw it bd mx ob oc od na oe of og nd oh oi oj ng ok ol om nj on oo op nm oq bi translated">在投影中构建状态</h1><p id="d494" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">我们可以把它看作一个独立的微服务，从消息总线流式传输事件，用增量变化更新数据库，把投影状态和新事件结合起来。它不会访问事件的历史，而是实时流。</p><p id="2238" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个投影是:</p><ul class=""><li id="8a31" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">给定状态(投影状态)</li><li id="3a0e" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">当<strong class="kd iu"> <em class="md">事件</em> </strong>(新聚合事件)</li><li id="d19c" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">然后状态(新投影状态)</li></ul><h1 id="90d6" class="oa mw it bd mx ob oc od na oe of og nd oh oi oj ng ok ol om nj on oo op nm oq bi translated">减少值对象中的状态</h1><p id="de34" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">在事件源文献中，通常我们说读取模型是从事件流中构建的投影。但是还有另一个选择:加载一个聚合的历史，并将其还原到它的结束状态。</p><p id="fac2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">动机:几年前，在我之前的工作中，在我们使用事件源大约1.5年后，我正在与预测和重放的复杂性作斗争:对一个实体的最终状态100%有信心并不容易。</p><p id="1855" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此，我想到了围绕Aggregate的历史构建减速器的想法。当时我称它们为<code class="fe me mf mg mh b">StateModel</code>:因为它们代表了一种构建聚合最终状态的方式；一个聚合类型可能有多个StateModel(不同解释)。<br/>现在我相信<code class="fe me mf mg mh b">Reducer</code>是正确的术语，因为它在ReactJS中是众所周知的……而且想法非常相似。</p><p id="e150" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">减速器是:</p><ul class=""><li id="6557" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">给定<strong class="kd iu"> <em class="md">事件</em> </strong>(一个集合的历史)</li><li id="413f" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">然后陈述</li></ul><p id="c8e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并且可以看作是ValueObject(功能性的)。</p><p id="e457" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这具有不依赖于预测数据库的巨大优势(这通常意味着最终的一致性)。<br/>有了这个想法，我们可以返回一个实体的结束状态(由REST端点如<code class="fe me mf mg mh b">/group/:id</code>返回),而不需要额外的投影。当然，这不允许我们轻松地查询组。</p><p id="f483" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，让我们编写一个极简的读取模型来轻松获取我们的聚合状态。</p><p id="6d23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们开始吧，但是…让我们从测试开始吧，:D</p><p id="5348" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们应该为我们的测试加载事件…但是因为我很懒，并且因为我更喜欢我的测试使用服务api，所以我不会从前面的测试中提取事件来创建我的“给定”案例，而是，我将使用服务api，并且简单地使用CreateGroup命令来填充数据库中的事件:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0fd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，通过测试，我定义了api行为和预期的有效负载。<br/>我还添加了将从事件中推断出来的<code class="fe me mf mg mh b">createdAt</code>和<code class="fe me mf mg mh b">updatedAt</code>属性。</p><p id="76c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们实现缩减器:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="dfbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和模块函数来完成我们的聚合api:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="dae9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这给了我们一个绿色测试和以下最终状态有效载荷:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c543" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在有了一个生成事件的命令，这些事件可以被简化为一种人类友好的最终状态。<br/>我们注意到，我们在创建组时发出了多个事件，从而简化了缩减器。</p><p id="a440" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由此，很容易创建查询数据库:只需将这个最终状态保存到AggregateRoot的保存后钩子中的NoSQL数据库中！</p><p id="3d5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是…对于简单的应用程序，您可能不需要它…</p><p id="bd3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此状态下的代码在<a class="ae nt" href="https://github.com/diegodurs/evented_whatsapp/tree/step-2" rel="noopener ugc nofollow" target="_blank"> github分支step-2 </a>上</p><h2 id="2754" class="mv mw it bd mx my mz dn na nb nc dp nd km ne nf ng kq nh ni nj ku nk nl nm nn bi translated">让我们添加缺少的动作:<em class="lx">add participant&amp;remove participant</em></h2><p id="6d6b" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">如果我们不验证用户是否已经存在(我们应该验证，以避免多余的事件)，AddParticipant 很简单。<br/>对于<em class="md"> RemoveParticipant </em>我们必须检查用户Id是否在参与者列表中。如果没有，我们应该抛出一个错误，因为命令是无效的。</p><p id="cfcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此，我将使用aggregateState并向状态对象添加一个助手函数<code class="fe me mf mg mh b">hasParticipant(userId)</code>。</p><p id="5694" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先编写测试:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c5cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和域代码:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="740d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我添加了不在不存在的集合上执行命令的验证(未经测试🤦).</p><p id="8591" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我用<br/> <em class="md"> const {groupId，userId，admin} = payload提取命令payload的具体属性；</em>避免我的事件中的未知属性。稍后将详细介绍数据验证。</p><p id="8dd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和域状态对象:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d554" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好的，我的测试通过了，但是还缺少一点，如果我在删除一个参与者之后加载状态，这个参与者仍然在列表中，这是因为我没有减少<code class="fe me mf mg mh b">ParticipantWasRemoved</code>事件。</p><p id="3dc8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们调整测试，并在当前测试中包含状态断言。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="36a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将事件添加到我们的缩减器中，以返回一个有效的状态:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2f64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">瞧！今天的代码到此结束..</p><h2 id="b078" class="mv mw it bd mx my mz dn na nb nc dp nd km ne nf ng kq nh ni nj ku nk nl nm nn bi translated">更新groupSubject怎么办？</h2><p id="3acb" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">轻松点。没有吗？</p><p id="16b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本上，所需要的是实现我们服务的changeSubject方法，以便它在aggregateId(即groupId)已存在，不再存在。<br/>不需要减少聚集的状态来验证命令，也不需要将事件添加到减少器中:它已经存在了。</p><p id="092c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你准备接受一点挑战，请在评论中评论你的代码片段<em class="md"> changeSubject(payload) </em>！；-)</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="75a8" class="mv mw it bd mx my mz dn na nb nc dp nd km ne nf ng kq nh ni nj ku nk nl nm nn bi translated">你怎么想呢?</h2><p id="59fb" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">如何看待这个使用:<br/> command + events + reducer编写新特性的过程？</p><p id="dd34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">测试呢？</p><p id="e3b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我看来，非常简单(一致)且强大:一旦设置完成，就很容易添加通常需要数据库设计和迁移的定制特性，而在这里，我们只是实现业务所谈论的内容。</p><h2 id="eddd" class="mv mw it bd mx my mz dn na nb nc dp nd km ne nf ng kq nh ni nj ku nk nl nm nn bi translated">摧毁呢？</h2><p id="a637" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">如果我们想摧毁这个团体呢？嗯，我们应该在reducer中添加一个新的命令，一个新的事件<code class="fe me mf mg mh b">GroupWasDestroyed</code>,并在那里决定我们是否保持状态，只是在添加一个字段<em class="md"> deleted_at，或者取消状态。<br/>另一个选择是销毁聚合流…但这意味着永远失去这些信息。除非在GDPR的暗示下，否则我不会考虑那样做。</em></p><blockquote class="nu nv nw"><p id="e847" class="kb kc md kd b ke kf kg kh ki kj kk kl nx kn ko kp ny kr ks kt nz kv kw kx ky im bi translated">最后，由业务来决定领域细节，<br/>这就是EventSourcing的美妙之处:您专注于您真正关心的东西，使用<br/>给定状态(事件)、何时动作、然后状态(事件+新事件)来实现它们</p></blockquote><h1 id="7437" class="oa mw it bd mx ob oc od na oe of og nd oh oi oj ng ok ol om nj on oo op nm oq bi translated">生产就绪了吗？</h1><p id="c20c" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">除了我们没有太多的能力来查询组(当前唯一的方法是加载所有的集合)，还有一个重要的部分(在我看来)是这个应用程序所缺少的…</p><p id="7345" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你能猜到吗？嗯……数据库……是商业应用的金矿。我们没有足够的地方来强制我们的事件保持理智。</p><p id="70ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，我们防范:</p><ul class=""><li id="a0e6" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">避免对不存在的聚合执行命令。</li><li id="b0c7" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">避免在已经存在的聚合id上创建组。</li><li id="df96" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">当用户不存在时，避免发出ParticipantWasRemoved。</li><li id="6bac" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">我们将命令有效负载过滤为已知的属性。</li></ul><p id="5932" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关于:</p><ul class=""><li id="21d7" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">这是一封电子邮件吗？UUID吗？一个UID？从现在开始，这可以是任何事情。现在所有的字段都是这样:我们不约束它们的类型。在一个严肃的应用程序中，我肯定会仔细验证每个字段的类型。</li><li id="6171" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">事件定义？我们有隐式的事件定义，但不是显式的。目前只有事件名称和有效负载是众所周知的，但是没有一个中心位置来读取这些定义。一个错误(例如在事件名称中)很容易犯并且不容易被发现。</li></ul><p id="75b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以基本上，我们严重缺少的是事件模式定义。</p><p id="a3d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果api很小，并且您是唯一使用它的开发人员，这不是一个大问题，因为在理想情况下，您不会犯错误。但是在现实世界中，你会犯错误，你可能会错误地将无效数据推送到你的有效载荷中。所以你应该保护你的数据库免受你自己的伤害…因为你是人…你会犯错误。<br/>你会的！:)</p><p id="b209" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种状态的代码在<a class="ae nt" href="https://github.com/diegodurs/evented_whatsapp/tree/step-3" rel="noopener ugc nofollow" target="_blank"> github分支step-3 </a>上</p><h1 id="add1" class="oa mw it bd mx ob oc od na oe of og nd oh oi oj ng ok ol om nj on oo op nm oq bi translated">结论</h1><p id="722a" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">瞧，通过这个例子，你可以看到我在定义基于聚合的微服务时的编码风格:</p><p id="edbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本上我们有以下几个部分:</p><ul class=""><li id="77c4" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">服务api</li><li id="f0c0" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">服务api测试</li><li id="c906" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">聚合(命令端)</li><li id="b0e6" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">减压器(单个骨料的读取端)</li></ul><p id="305a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由此，只需将缩减器的计算状态保存到NoSQL数据库中，就可以很容易地创建查询数据库。</p><p id="ffd9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="md">注意:如果最终的一致性不成问题，您可以将事件(+ end-state，取决于您对增量变化计算或哑推-更新的偏好)推送到总线，并让另一个进程实现该投影。</em></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="72f4" class="mv mw it bd mx my mz dn na nb nc dp nd km ne nf ng kq nh ni nj ku nk nl nm nn bi translated">结论</h2><p id="e5ce" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">EventSourcing背后的思想对于构建严肃的应用程序有很大的前景。CRUD可能会留给简单的应用程序……在这种情况下，您可能不需要后端开发人员，而需要前端开发人员，只需使用RESTfull数据库(如<a class="ae nt" href="https://gist.github.com/diegodurs/RestDB.io" rel="noopener ugc nofollow" target="_blank"> RestDB.io </a>)作为后端。</p><p id="c158" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="md">注:我已经用</em><a class="ae nt" href="https://markdowntomedium.com/create" rel="noopener ugc nofollow"><em class="md">https://markdowntomedium.com/create</em></a><em class="md">创建了这篇从Markdown到Medium的博文。</em></p></div></div>    
</body>
</html>