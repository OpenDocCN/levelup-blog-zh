# 函数式编程有什么意义？

> 原文：<https://levelup.gitconnected.com/whats-the-point-of-functional-programming-83920cf24a89>

![](img/0f66d499d8e2f7aee608e7e04e2ae7ee.png)

爵士树，漂亮但不相干的照片。图片来源:[https://unsplash.com/photos/GfAqbDrCoio](https://unsplash.com/photos/GfAqbDrCoio)

最近我读了尼尔·福特的书《T2 功能思维》。我觉得很有意思，决定在这个帖子里整理一下自己的想法。这篇文章绝不是书评，也不是 TLDR。大部分内容都是基于我自己的经历和理解。

# 关于我

我受过命令式编程和面向对象风格的“训练”。但是作为一个熟悉 Ruby 和 JavaScript 的程序员，我对函数式编程的“元素”有点熟悉。我知道“作为一等公民的功能”，库里，compose，声明式编程，以及它们在 React 和 Redux 等真实世界战场上的工作方式。我有一些使用 Elixir 的经验，知道如何用递归函数替换循环。但是，我仍然觉得缺少了一些东西:一个连接所有点的范式的全貌。我开始读这本书。

在开始阅读之前，我心中有几个问题:

1.  有什么意义？所有这些扭曲思维的优点是什么？
2.  “元素”与函数式编程有什么关系？

读完这本书后，我想我能以某种方式回答这些问题。

# 超级简短的函数式编程概述

让我们首先对函数式编程做一个非常简短和非正式的概述。函数式编程是一种范式，其中函数是一等公民，这意味着，用简单的话来说，它们可以出现在你能想到的任何地方。循环被诸如“map”、“reduce”和“filter”之类的抽象所取代。人们可以通过 currying、composing 或者利用闭包来创建函数。大多数时候，变量是不可变的，这意味着它们一旦创建就不能被修改。异常或堆栈跳转是不常见的，其含义不同于它们的命令式并行。

# 有什么意义？

> **这都是关于抽象的。**

函数式编程抽象事物的方式不同于命令式编程。它从命令式操作中抽象出一些“操作”，比如循环、映射和归约。随着通常单调乏味的操作被抽象出来，开发人员可以专注于更高层次的逻辑，并使代码更具表现力。

为了说明这一点，我将使用下面的 JavaScript 代码片段。虽然对许多人来说，它不是一种“合格的”函数式语言，但在这里足以证明这个想法。假设我们有一个数字列表，我们想找到偶数并加倍。(不要问我为什么这个世界会有人想那么做。)

对于命令式方法:

```
const myNumberArray = findSomeNumberArray()
const evenNums = []
const doubled = []
for (let i = 0; i < myNumberArray.length; i += 1) {
  if (isEven(num)) {
    evenNums.push(myNumberArray[i])
  }
}
for (let i = 0; i < evenNums.length; i += 1) {
  doubled.push(double(evenNums[i]))
}
```

对于功能方法:

```
const myNumberArray = findSomeNumberArray()function isEven (num) {
  return num % 2 === 0
}
function double (num) {
  return num * 2
}myNumberArray.filter(isEven)
             .map(double)
```

正如我们所见，后一种方法**更具表现力**。一看就能知道代码想做什么(虽然背后的目的还很神秘，因为没有人。)此外，通过转移我们抽象的地方，**我们不仅改变了代码重用的粒度，还改变了我们思考问题的抽象层。**现在,“我是”和“双重”可以在其他地方分享，我们可以专注于我们想做的“什么”,而不是“如何”去做。

***抽象带来的另一个好处是它为运行时打开了“接缝”。*** 当垃圾收集器第一次被发明出来的时候，开发者的生活就在那一点上改变了。不再需要管理内存，开发人员可以更多地关注业务逻辑，而不是系统级的通信。与此同时，通过抽象上述“操作”,函数式语言为运行时打开了“接缝”,以接管一些潜在的繁琐工作，如[并发处理](https://www.scala-lang.org/api/2.12.2/scala/collection/parallel/immutable/ParMap.html)和状态管理(移动部分)。)

> OO 通过封装移动部分使代码变得可以理解。FP 通过最大限度地减少活动部分来使代码易于理解。—迈克尔·费哲(引自该书)

最小化活动部分的函数式语言的一些例子是

*   将并发控制与数据结构相结合
*   通过不变性和纯函数最小化状态

同样，摆脱了“活动部件”(线程、状态管理)，开发人员可以更加关注业务逻辑和表达能力。

当然，没有什么是没有代价的。为了让语言运行库很好地处理这些任务，开发人员必须编写代码，甚至以特定的方式考虑问题。就像由于 GC 的存在，你在 C++中组织代码的方式不同于在 Java 中一样，通常，我们需要在函数式语言中构造不同于命令式语言的逻辑。

在我看来，这些责任转移与其说是对还是错，不如说是交易。我们开发人员的工作是为正确的任务找到正确的工具。

# “元素”与函数式编程有什么关系？

我经常听说函数式编程的“元素”，比如不可变的、处理异常的不同方式、递归。我分别理解他们每一个人。但我的问题是:**它们和函数式编程有什么关系？**

**不可变**

不可变数据一旦启动就不能被修改。这意味着，如果你持有相同的引用，你可以确定“值”是相同的。**为了使大多数功能机制生效，需要*传递的函数是纯的*** :一个没有副作用的函数，其返回值完全由其输入参数决定。这就是为什么这么多函数式语言都有不可变的数据:只有当数据不可变时，函数才是纯粹的。

**错误处理**

处理错误最常见的方式是异常:您抛出一个异常，执行流程跳转到捕获它的代码行。

```
function sthMightGoWrong (a, b) {
  if (everythingGoesWell()) {
    return 'the-result'
  } else {
    throw new Error('ops!')
  }
}try {
  const result = sthMightGoWrong('hello', 'world')
} catch (e) {
  // execution jumps to here
}
```

另一种处理错误的方法是返回值。一些命令式语言(如 Go)和大多数函数式语言(如 Elixir)都使用这种机制。

```
function sthMightGoWrong (a, b) {
  if (everythingGoesWell()) {
    return { ok: true, result: 'the-result' }
  } else {
    return { ok: false, return: null }
  }
}
const { ok, result } = sthMightGoWrong('hello', 'world')
if (!ok) {
  // error handling without stack jumping here
}
```

后者与函数式编程有关，因为**堆栈跳转是一个副作用。**一个函数如果可能抛出就不再是纯的:给定同一套输入参数，结果不止一个:返回一些值或者跳转到别的地方。这就是为什么传统的抛出/捕捉错误处理在函数式语言中并不常见。

**递归**

递归是一种我们通过调用函数本身来分而治之解决问题的技术(这是一个非常草率的定义。这里看官方的。)这是一种可以解决棘手问题的方法，否则这些问题通常不是微不足道的。在函数式编程中，它经常被用来代替命令式语言中的循环控制流，如“for”和“while”。但是这里又来了，为什么呢？

通过循环多次说“嗨”,例如:

```
// say hi by loops
function sayHi () { console.log('hi') }
function sayHiForTimes (times) {
  for (var i = 0; i < times; i += 1) {
    sayHi()
  }
}
```

递归地做这件事:

```
function sayHi () { console.log('hi') }
function sayHiForTimes (times) {
  if (times === 0) {
    return
  }
  sayHi()
  sayHiForTimes(times - 1)
}
```

答案和上面类似:**对于抽象工作带来的好处，一定不能有共享状态。**例如，如果我们共享任何状态，运行时为我们处理并发就变得很困难，如果不是不可能的话。

这些循环使用共享状态来控制自然流。这就是我们使用递归的原因，递归将“状态”转移到后续的函数调用中。

# 事后思考

对我来说，最让我惊叹的是抽象方式的不同所带来的寓意和可能性。有时候，只有在最底层的东西被抽象掉之后，我们才能开始看到上层更大的画面。它类似于复利，因为当前回合获得的利益可以加快下一回合。

此外，范式转换让我们以不同的方式解构一个问题，这总是一件令人愉快的事情。💖

谢谢你的阅读。如果你有什么想讨论的，请在下面留下你的评论。