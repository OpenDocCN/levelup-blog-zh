<html>
<head>
<title>Functional Dynamic Programming With Haskell: Top Down and Bottom Up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Haskell函数式动态编程:自顶向下和自底向上</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-dynamic-programming-with-haskell-top-down-and-bottom-up-7ccade222337?source=collection_archive---------11-----------------------#2020-10-07">https://levelup.gitconnected.com/functional-dynamic-programming-with-haskell-top-down-and-bottom-up-7ccade222337?source=collection_archive---------11-----------------------#2020-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在runSTArray中使用STArray的纯函数记忆</p><p id="c64e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文第一部分<a class="ae kl" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-92e68efe808" rel="noopener">此处</a>。</p><p id="962a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于有状态计算，Haskell提供了<a class="ae kl" href="https://wiki.haskell.org/Monad/ST" rel="noopener ugc nofollow" target="_blank">圣单子</a>。</p><p id="ac2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据https://wiki.haskell.org/Monad/ST的<a class="ae kl" href="https://wiki.haskell.org/Monad/ST" rel="noopener ugc nofollow" target="_blank"/></p><div class="km kn gp gr ko kp"><a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Monad-ST.html#t%3AST" rel="noopener  ugc nofollow" target="_blank"><div class="kq ab fo"><div class="kr ab ks cl cj kt"><h2 class="bd ir gy z fp ku fr fs kv fu fw ip bi translated">控制。单子街</h2><div class="kw l"><h3 class="bd b gy z fp ku fr fs kv fu fw dk translated">这个库提供了对严格状态线程的支持，正如约翰·朗什伯里和西蒙在PLDI 94年的论文中所描述的…</h3></div><div class="kx l"><p class="bd b dl z fp ku fr fs kv fu fw dk translated">hackage.haskell.org</p></div></div></div></a></div><p id="49f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在ST的许多实例中，有一些是for数组，如MArray STArray等。在这里，我们将使用STArray和函数runSTArray将我们的变异封装在一元上下文中。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="bedc" class="lh li iq ld b gy lj lk l ll lm">:info ST <br/>...<br/>instance MArray (STArray s) e (ST s)</span></pre><p id="77e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从Haskell wiki上总结一下，<strong class="jp ir">圣单子</strong>:</p><ul class=""><li id="be62" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">对有状态计算的“线程”进行建模，这些线程可以操作可变引用，但被限制为只能返回纯值。</li><li id="90ac" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">STArray是严格数组的可变变体</li><li id="2b68" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">它解冻数组，使其变异，然后重新冻结，使其不能再变异。因此，它设法变异，并仍然保持引用透明。</li></ul><figure class="ky kz la lb gt mc gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/94744065ab4b55a4050c62245a540b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*NeRpl78Y_RJddeQC78gWUw.png"/></div></figure><p id="5df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的图片可能不太准确，但很容易总结。</p><p id="0d52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将STArray与runSTArray一起使用时，所有的变异都被包装在一个上下文中。此外，它还有一个额外的机制，即运行一个非常孤立的线程来应对突变。<strong class="jp ir">变异线程的环境与外界没有交换</strong>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="79ba" class="lh li iq ld b gy lj lk l ll lm">runSTArray :: (forall s. ST s (STArray s i e)) -&gt; Array i e</span></pre><p id="a22b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在这里重温圣莫纳多<a class="ae kl" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-bottom-up-space-optimized-ef7b5f73a849" rel="noopener">。</a></p><p id="9621" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">一元块runSTArray中带有递归的自顶向下版本</strong></p><ul class=""><li id="4f76" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">使用-1初始化STArray来调用runSTArray，并为arr(1)和arr(2)设置基本用例。</li><li id="ed46" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">调用cdRecursive，它接受MArray的一个实例，如果arr(n) = -1，则在内部计算并变异STArray</li></ul><figure class="ky kz la lb gt mc"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="22ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">对一元突变上下文使用STArray的自下而上版本</strong></p><p id="f1a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们使用<strong class="jp ir"> <em class="mh"> forM_ </em> </strong>(这是<strong class="jp ir"> <em class="mh"> mapM_ </em> </strong>，<strong class="jp ir">的翻转版本，不要与命令式for循环</strong>混淆)更像是一种语法糖，看起来像命令式“for”。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2fab" class="lh li iq ld b gy lj lk l ll lm">:t forM_<br/>forM_ :: (Foldable t, Monad m) =&gt; t a -&gt; (a -&gt; m b) -&gt; m ()<br/>:t mapM_<br/>mapM_ :: (Foldable t, Monad m) =&gt; (a -&gt; m b) -&gt; t a -&gt; m ()</span></pre><p id="3b83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，与<strong class="jp ir"> <em class="mh"> mapM </em> </strong>不同的是，使用<strong class="jp ir"> <em class="mh"> mapM_ </em> </strong>是因为我们只对它的副作用感兴趣。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0f95" class="lh li iq ld b gy lj lk l ll lm">:t mapM<br/>mapM :: (Traversable t, Monad m) =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)</span></pre><p id="224a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意两者的区别。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5b4a" class="lh li iq ld b gy lj lk l ll lm">m() <br/>m (t b)</span></pre><p id="f828" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们对积累成果不感兴趣。所以<strong class="jp ir"> <em class="mh"> mapM_ </em> </strong>(或者“翻转”版<strong class="jp ir"> <em class="mh"> forM_ </em> </strong>)跳过收集结果。这也是为什么我们没有使用<strong class="jp ir"><em class="mh">【mapM】</em></strong>(或其“翻转”版<strong class="jp ir"> <em class="mh">表单</em> </strong>)。</p><figure class="ky kz la lb gt mc"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="6ae3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们要费这么大的劲来实现它呢？</p><p id="baf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">维护引用透明性，这是通过表示纯函数实现安全不变性的基础。</p><p id="9422" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">又来了，为什么？</strong></p><p id="6ecc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FP背后的全部意义是，贴近数学表达式和函数。</p><p id="a665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果以这种方式编写，就像数学中的代数一样，人们总是可以从整体上对代码和应用程序进行推理。隔离突变和影响在其中扮演着重要角色。</p><p id="75cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FP的一大好处是，我们可以根据“证据”来调整我们的思维。当我们进行代码审查或进行技术讨论或头脑风暴时，这些小“证据”是很大的帮助。</p><p id="329e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们的基础是坚实的，并且有可靠的数学原理支持，我们就可以避免做出模棱两可的断言。</p><p id="3db8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再看一下上述Simple和TD/BU版本之间的时间/空间比较</p><figure class="ky kz la lb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/3ada64ef71a5422afe971f12bf745678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oop3W6mDIeKZW9dAKH5UQA.png"/></div></div></figure><figure class="ky kz la lb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mn"><img src="../Images/126326194c2eebbb7d66a9808a2afc1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViK3dWjme6rWucIPCzpZew.png"/></div></div></figure><p id="b157" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来:<a class="ae kl" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-bottom-up-space-optimized-ef7b5f73a849" rel="noopener">Haskell函数式动态编程:自下而上空间优化</a></p></div></div>    
</body>
</html>