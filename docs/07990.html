<html>
<head>
<title>Bypass firewalls and routers with reverse tunnels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用反向隧道绕过防火墙和路由器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bypass-firewalls-and-routers-with-reverse-tunnels-ff584c62e7a?source=collection_archive---------2-----------------------#2021-03-27">https://levelup.gitconnected.com/bypass-firewalls-and-routers-with-reverse-tunnels-ff584c62e7a?source=collection_archive---------2-----------------------#2021-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b62d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您经常使用远程的、无屏幕的机器，您可能也会经常使用SSH。SSH非常适合访问机器，但是如果它位于路由器或防火墙之后，并且您不能更改规则，该怎么办呢？这就是这篇文章的内容:反向隧道！</p><h1 id="049f" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">典型的SSH连接</h1><p id="cb28" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">最简单的场景是主机A和b之间的直接连接。假设A想要SSH到b。您只需在主机A的终端中键入<code class="fe lo lp lq lr b">ssh username@B</code>。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/bfaca24ebb52e1694914a4ad8f53c7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*K6x3V6zp2zJtO_8mi236aw.png"/></div></figure><p id="8d3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单。这只是一个普通的SSH连接。让我们进入隧道。</p><h1 id="d887" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">前方隧道</h1><p id="1621" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当您想要在特定端口转发连接时，可以使用隧道。假设A想要访问主机B上运行的Jupyter笔记本服务器，端口为8888，我们希望能够在主机A上访问它，就像它在本地运行一样，端口也是相同的。我们可以使用隧道，将主机A的端口8888中的所有连接转发到主机b的端口8888。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ma"><img src="../Images/fbcad893dc21f0e8aee88ed51e31e7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*qkQQVzTsZdVXdx0pyejEqA.png"/></div></div></figure><p id="f5eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你在主机A的浏览器上访问localhost:8888，你肯定会看到Jupyter笔记本页面(在主机B上提供)。</p><p id="a56b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果主机B位于路由器或防火墙之后呢？没问题，您只需要创建一个端口转发规则，确保到routerB的连接被转发到主机b的SSH端口。假设routerB的端口22(默认SSH端口)被转发到主机b的端口22。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/0e674388735cb1cfe6d5cfb2985a599b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*8_Iq7RLf1wX27J7oVV-EOA.png"/></div></figure><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/3acfeb9814316a0567c444b5ad24b6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*nCTPnVt4pLaMxtJSUP4bVA.png"/></div></figure><p id="bc3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果B坐在路由器后面，你只需要确定routerB的22号口到B的22号口有端口转发规则就可以了<strong class="jp ir">但是如果你配置不了路由器或者防火墙怎么办？</strong></p><h1 id="3624" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">反向隧道</h1><p id="3bd0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这就是反向隧道进入画面的地方。您不能通过SSH连接访问主机B，因为B是隔离的。没办法进去。但是，如果您可以直接访问它，如果您可以直接配置它(例如，手动)，那么您仍然可以通过使用<strong class="jp ir">反向隧道</strong>使连接工作。我们仍然有相同的场景，也就是说，我们希望A能够在本地访问运行在主机B上的Jupyter笔记本(实际上，这可以是任何服务)。</p><p id="df9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之前，我们使用<code class="fe lo lp lq lr b">-L</code>选项，将A端口8888上的本地连接转发到B端口8888。我们仍然希望这样做，但现在SSH连接将从主机B开始。如果我们再次使用<code class="fe lo lp lq lr b">-L</code>，我们将B端口8888上的连接转发到A端口8888，这与我们想要的正好相反。我们需要通过使用<code class="fe lo lp lq lr b">-R</code>选项来扭转这种情况。它和<code class="fe lo lp lq lr b">-L</code>完全一样，但是方向不同。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/709458063c770c337385120c93e21bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*vgFmGYYY-UUkZo3_4FYwQw.png"/></div></figure><p id="f74b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，SSH连接是从B到A发起的，但隧道内的转发连接是从A到B。请注意紫色箭头(初始SSH连接)现在是如何向左的，但蓝色箭头(转发隧道)仍然是向右的。</p><p id="074f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个，你就完事了。您可以再次在主机A的localhost的端口8888中访问Jupyter笔记本，它将从主机B(端口8888)接收页面。</p><h1 id="91fe" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">SSH进入带有反向隧道的防火墙主机</h1><p id="45c8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">让我们暂时忘记Jupyter笔记本吧。更常见的情况是通过SSH连接防火墙主机。使用反向隧道，很简单。让我们把它拆开:</p><ul class=""><li id="4590" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">b向A发起SSH连接:<code class="fe lo lp lq lr b">ssh anotherUser@A</code></li><li id="b2a0" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">这是基本命令。然后，我们在此基础上添加反向隧道，将A的端口X(我们给它一个数字，比如12345)上的连接转发到B的端口22。现在，如果A在A的本地主机的端口12345上建立连接，它就可以访问主机B的本地主机的端口22(下图对此进行了说明)。</li><li id="e2bb" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">然后，您只需在主机a的终端中键入<code class="fe lo lp lq lr b">ssh -p 12345 username@localhost</code>，进行交互式SSH会话。这将在本地主机的端口12345中启动一个SSH连接，该连接将通过反向隧道转发到主机B的端口22，从而创建所需的连接。</li></ul><p id="5084" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个inceptionesque场景中，我们有一个SSH连接(蓝色箭头，由A启动)在另一个SSH连接(大粉色箭头，由B启动)内部。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/848468e58447f3ca01a790753752af1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*4ljhX3p8CYeqb_i1cuQpZA.png"/></div></figure><p id="bdae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在已经介绍了正常和反向隧道的典型使用方式。你可以利用这些知识来进行交流，即使你不得不处理讨厌的防火墙和不可访问的路由器。</p><p id="9eb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个复杂但常见的设置是在A和互联网之间放置一个路由器(查看下图)。假设我们有一个routerA，它将端口6789转发到主机A的端口22 (SSH的默认端口)。目标仍然是相同的:让主机A访问受防火墙保护的主机b。这实际上并不复杂，但我们必须“分而治之”地解决问题，或者将问题分层:</p><ul class=""><li id="68da" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">主机B必须创建一个到主机a的SSH连接。这是通过<code class="fe lo lp lq lr b">ssh anotherUser@A</code>完成的。</li><li id="7f76" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">但是现在，A在routerA后面，routerA的端口6789转发到A的端口22，所以我们必须在原始SSH连接中指定该端口:<code class="fe lo lp lq lr b">ssh anotherUser@routerA -p 6789</code>。由于routerA的端口6789正在转发到A的端口22，我们得到了我们的连接。</li><li id="fcf1" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">b必须创建一个反向隧道。这部分我们已经讲过了:<code class="fe lo lp lq lr b">ssh -R 12345:localhost:22 anotherUser@routerA -p 6789</code>。</li><li id="76b2" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">最后，主机A像以前一样连接到主机B，<code class="fe lo lp lq lr b">ssh -p 12345 username@localhost</code></li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/6aa34818c3691a1d1060df4485f5fe0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*IalzlGq95zr6A54phdsMKg.png"/></div></figure><p id="7964" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们也不能配置routerA怎么办？这意味着没有端口转发，A和B都不能接收连接！唯一的出路就是血祭。鸡🐔通常会做。山羊🐐如果你想变得花哨。或者，也许，与第三个主机，与在A和B开始的隧道…那是家庭作业材料！</p><p id="4951" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">来源</strong></p><p id="d4b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mx" href="https://unix.stackexchange.com/questions/46235/how-does-reverse-ssh-tunneling-work" rel="noopener ugc nofollow" target="_blank">https://UNIX . stack exchange . com/questions/46235/how-does-reverse-ssh-tunneling-work</a></p></div></div>    
</body>
</html>