<html>
<head>
<title>Automating my blog post publishing process with Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Typescript自动化我的博客文章发布过程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/automating-my-blog-post-publishing-process-with-typescript-46dc1665d3a1?source=collection_archive---------11-----------------------#2020-05-13">https://levelup.gitconnected.com/automating-my-blog-post-publishing-process-with-typescript-46dc1665d3a1?source=collection_archive---------11-----------------------#2020-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b897" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本帖原载于</em> <a class="ae kp" href="https://leandrotk.github.io/tk/2020/04/publisher-a-tooling-to-automate-the-process-to-publish-my-blog-posts/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> <em class="ko"> TK的博客</em> </strong> </a> <em class="ko">。</em></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/4a165a29e93e864852c02b89a072d28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6oJ__u35KGU3AjJ2"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@patrickian4?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">帕特里克·福尔</a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="67f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我正在培养一种写作习惯，试图发表越来越多的文章。尽管我使用像<a class="ae kp" href="https://medium.com/@leandrotk_" rel="noopener"> Medium </a>、<a class="ae kp" href="https://dev.to/teekay" rel="noopener ugc nofollow" target="_blank"> dev.to </a>和<a class="ae kp" href="https://hashnode.com/@teekay" rel="noopener ugc nofollow" target="_blank"> Hashnode </a>这样的发布博客，我还是喜欢在<a class="ae kp" href="http://leandrotk.github.io/tk" rel="noopener ugc nofollow" target="_blank">我自己的博客</a>上发布我的内容。</p><p id="05c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我想建立一个简单的网站，这个博客基本上是HTML，CSS和很少的JavaScript网站。但问题是，出版过程可以更好。</p><p id="dc1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是怎么运作的？</p><p id="2719" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在观念上管理博客路线图。看起来是这样的:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lg"><img src="../Images/c62523aceffa1714c079cef69da951e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zktkXYTOLwL77bUhoKolJQ.png"/></div></div></figure><p id="34f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个简单的看板类型的板。我喜欢这个板，因为我可以把我所有的想法变成实体的(还是数字的？)表示。我也用它来建立一个草稿，润色，让它越来越好地发表在博客上。</p><p id="127f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我用概念来写我的博客。在我完成它之后，我复制这个想法并粘贴到一个在线工具中，将markdown转换成HTML。然后我可以使用这个HTML来创建实际的帖子。</p><p id="7e33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但这只是正文，页面的内容。我总是需要创建一个包含标题内容、正文和页脚的HTML。</p><p id="b5ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个过程繁琐又无聊。但好消息是，它可以自动化。这篇文章就是关于自动化的。我想向你们展示我创造的这个新工具的幕后，以及我在这个过程中所学到的东西。</p><h1 id="4300" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">特征</h1><p id="67f0" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我的主要想法是准备发布一整篇HTML文章。正如我之前提到的，<code class="fe mk ml mm mn b">&lt;head&gt;</code>和<code class="fe mk ml mm mn b">&lt;footer&gt;</code>部分变化不大。所以我可以用它作为“模板”。</p><p id="4e21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个模板，我就有了可以为我撰写和发表的每篇文章修改的数据。这个数据可以是模板中的一个变量，用这个表示<code class="fe mk ml mm mn b">{{ variableName }}</code>。一个例子:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d7d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我可以使用模板，用真实数据替换变量，每篇文章的具体信息。</p><p id="27a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二部分是正文，实帖。在模板中，用<code class="fe mk ml mm mn b">{{ article }}</code>表示。这个变量将被markdown生成的HTML替换。</p><p id="50cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们从概念中复制和粘贴笔记时，我们得到了一种降价风格。该项目将把这个markdown转换成HTML，并将其用作模板中的<code class="fe mk ml mm mn b">article</code>变量。</p><p id="ea7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了创建理想的模板，我查看了需要创建的所有变量:</p><ul class=""><li id="7ee6" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">title</code></li><li id="374c" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">description</code></li><li id="cc9b" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">date</code></li><li id="2f08" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">tags</code></li><li id="ce1d" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">imageAlt</code></li><li id="dfb7" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">imageCover</code></li><li id="3c12" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">photographerUrl</code></li><li id="4f6e" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">photographerName</code></li><li id="d48c" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">article</code></li><li id="dc60" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">keywords</code></li></ul><p id="bd99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这些变量，我创建了<a class="ae kp" href="https://github.com/leandrotk/publisher/blob/master/examples/template.html" rel="noopener ugc nofollow" target="_blank">模板</a>。</p><p id="3093" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了传递这些信息来构建HTML，我创建了一个<code class="fe mk ml mm mn b">json</code>文件作为文章配置:<code class="fe mk ml mm mn b">article.config.json</code>。我有这样的东西:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4c7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一步:项目应该知道如何打开和阅读模板和文章配置。有了这些数据，我可以用它来填充模板。</p><p id="62aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">模板优先:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="22a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们基本上需要实现<code class="fe mk ml mm mn b">getTemplateContent</code>函数。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="05c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">带有<code class="fe mk ml mm mn b">__dirname</code>的<code class="fe mk ml mm mn b">resolve</code>将从正在运行的源文件中获取目录的绝对路径。然后转到<code class="fe mk ml mm mn b">examples/template.html</code>文件。<code class="fe mk ml mm mn b">readFile</code>将异步读取并返回模板路径中的内容。</p><p id="2911" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了模板内容。我们需要为文章配置做同样的事情。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="76bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有两件不同的事情:</p><ul class=""><li id="25b5" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">由于<code class="fe mk ml mm mn b">article.config.json</code>具有json格式，我们需要在读取文件后将这个json字符串转换成JavaScript对象</li><li id="c253" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">文章配置内容的返回将是一个我在函数返回类型中定义的<code class="fe mk ml mm mn b">ArticleConfig</code>。让我们建造它。</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3c90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们得到这个内容时，我们也使用这个新类型。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e7ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以使用<code class="fe mk ml mm mn b">replace</code>方法来填充模板内容中的配置数据。为了说明这个想法，它看起来像这样:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cc46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是有些变量在模板中出现不止一次。营救用的正则表达式。有了这个:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1fc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…我得到所有匹配<code class="fe mk ml mm mn b">{{ title }}</code>的字符串。所以我可以构建一个函数来接收要查找的参数，并在标题位置使用它。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ff94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以替换所有匹配。标题变量的一个示例:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cdc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们不想只替换标题变量，而是替换文章配置中的所有变量。全部替换！</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="afe6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我全部换掉！我们这样使用它:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c2e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们遗漏了两个部分:</p><ul class=""><li id="291d" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">tags</code></li><li id="4058" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><code class="fe mk ml mm mn b">article</code></li></ul><p id="d104" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在config json文件中，<code class="fe mk ml mm mn b">tags</code>是一个列表。所以，对于这个列表:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e963" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终的HTML将是:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e1f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我用<code class="fe mk ml mm mn b">{{ tag }}</code>变量创建了另一个模板:<code class="fe mk ml mm mn b">tag_template.html</code>。我们只需要映射<code class="fe mk ml mm mn b">tags</code>列表并创建每个HTML标签模板。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d6f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里我们:</p><ul class=""><li id="8429" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">获取标记模板路径</li><li id="5287" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">获取标记模板内容</li><li id="4057" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">通过<code class="fe mk ml mm mn b">tags</code>映射，并基于标签模板构建最终的标签HTML</li></ul><p id="2caf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mk ml mm mn b">buildTag</code>是一个返回另一个函数的函数。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3a4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它接收<code class="fe mk ml mm mn b">tagContent</code>——它是标签模板内容——并返回一个函数，该函数接收一个标签并构建最终的标签HTML。现在我们调用它来获取文章标签。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="29d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于这篇文章。看起来是这样的:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3b7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它接收到<code class="fe mk ml mm mn b">articleFile</code>，我们试图获取路径，读取文件，并获取markdown内容。然后将这个内容传递给<code class="fe mk ml mm mn b">fromMarkdownToHTML</code>函数，将markdown转换成HTML。</p><p id="bc98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这部分我使用了一个名为<code class="fe mk ml mm mn b">showdown</code>的外部库。它处理将markdown转换成HTML的每一个小细节。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d464" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我有了标签和文章HTML:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ed9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我又错过了一件事！以前，我认为我总是需要将图像封面路径添加到文章配置文件中。大概是这样的:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="53b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们可以假设图像名称是<code class="fe mk ml mm mn b">cover</code>。挑战在于延伸。可以是<code class="fe mk ml mm mn b">.png</code>、<code class="fe mk ml mm mn b">.jpg</code>、<code class="fe mk ml mm mn b">.jpeg</code>或<code class="fe mk ml mm mn b">.gif</code>。</p><p id="9617" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我构建了一个函数来获得正确的图像扩展。想法是在文件夹中搜索图像。如果它存在于文件夹中，则返回扩展名。</p><p id="2bb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我从“现有的”部分开始。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="254d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我使用<code class="fe mk ml mm mn b">existsSync</code>函数来查找文件。如果它存在于文件夹中，则返回true。否则为假。</p><p id="e1b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将这段代码添加到一个函数中:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ccba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我为什么这样做？</p><p id="20a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这个函数，我需要通过<code class="fe mk ml mm mn b">folder</code>、<code class="fe mk ml mm mn b">filename</code>和<code class="fe mk ml mm mn b">extension</code>。<code class="fe mk ml mm mn b">folder</code>和<code class="fe mk ml mm mn b">filename</code>总是一样的。不同的是<code class="fe mk ml mm mn b">extension</code>。</p><p id="8f28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我可以用curry创建一个函数。这样，我可以为同一个<code class="fe mk ml mm mn b">folder</code>和<code class="fe mk ml mm mn b">filename</code>构建不同的函数。像这样:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ba39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">整个函数如下所示:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5767" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我不喜欢用这个硬编码的字符串来表示图像扩展。<code class="fe mk ml mm mn b">enum</code>真酷！</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d498" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在使用我们新枚举的函数<code class="fe mk ml mm mn b">ImageExtension</code>:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c0bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我已经有了填充模板的所有数据。太好了！</p><p id="361b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">HTML完成后，我想用这些数据创建真正的HTML文件。我基本上需要得到正确的路径，HTML，并使用<code class="fe mk ml mm mn b">writeFile</code>函数来创建这个文件。</p><p id="95d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了找到路径，我需要了解我的博客的模式。它用年、月、标题组织文件夹，文件命名为<code class="fe mk ml mm mn b">index.html</code>。</p><p id="a1b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个例子是:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">起初，我考虑将这些数据添加到文章配置文件中。所以每次我需要从文章配置中更新这个属性来获得正确的路径。</p><p id="0b85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是另一个有趣的想法是通过文章配置文件中已经有的一些数据来推断路径。我们有<code class="fe mk ml mm mn b">date</code>(如<code class="fe mk ml mm mn b">"2020-04-21"</code>)和<code class="fe mk ml mm mn b">title</code>(如<code class="fe mk ml mm mn b">"Publisher: tooling to automate blog post publishing"</code>)。</p><p id="c832" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从日期，我可以得到年和月。根据标题，我可以生成文章文件夹。<code class="fe mk ml mm mn b">index.html</code>始终不变。</p><p id="9993" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">字符串应该是这样的:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="dd2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于约会来说，真的很简单。我可以通过<code class="fe mk ml mm mn b">-</code>分裂和解构:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2cb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe mk ml mm mn b">slugifiedTitle</code>，我构建了一个函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7cab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它删除字符串开头和结尾的空格。然后向下转换字符串。然后删除所有特殊字符(只保留单词和空白字符)。最后，用一个<code class="fe mk ml mm mn b">-</code>替换所有空白。</p><p id="608d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">整个函数看起来像这样:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="135f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个函数试图获取文章文件夹。它不会生成新文件。这就是为什么我没有把<code class="fe mk ml mm mn b">/index.html</code>加到最后一个字符串的末尾。</p><p id="8391" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么会这样？因为，在写新文件之前，我们总是需要创建文件夹。我用这个文件夹路径的<code class="fe mk ml mm mn b">mkdir</code>来创建它。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="eaef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我可以使用该文件夹在其中创建新的文章文件。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="835a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们遗漏了一件事:当我在文章配置文件夹中添加图像封面时，我需要复制它并粘贴到正确的位置。</p><p id="cfed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe mk ml mm mn b">2020/04/publisher-a-tooling-to-blog-post-publishing/index.html</code>示例，图像封面将位于资产文件夹中:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c466" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我需要两样东西:</p><ul class=""><li id="fc9b" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">用<code class="fe mk ml mm mn b">mkdir</code>创建一个新的<code class="fe mk ml mm mn b">assets</code>文件夹</li><li id="6c2d" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">用<code class="fe mk ml mm mn b">copyFile</code>复制图像文件并粘贴到新文件夹中</li></ul><p id="cd84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要创建新文件夹，我只需要文件夹路径。要复制和粘贴图像文件，我需要当前图像路径和文章图像路径。</p><p id="59a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于文件夹，因为我有了<code class="fe mk ml mm mn b">newArticleFolderPath</code>，我只需要将这个路径连接到assets文件夹。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="920f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于当前的图像路径，我有正确扩展名的<code class="fe mk ml mm mn b">imageCoverFileName</code>。我只需要得到图像覆盖路径:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7cb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了获得未来的图像路径，我需要连接图像封面路径和图像文件名:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7708" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这些数据，我就可以创建新文件夹了:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="87a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">复制并粘贴图像封面文件:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3812" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我实现这个<code class="fe mk ml mm mn b">paths</code>部分的时候，我发现我可以把它们组合成一个函数<code class="fe mk ml mm mn b">buildPaths</code>。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3af9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还创建了<code class="fe mk ml mm mn b">ArticlePaths</code>类型:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e745" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我可以使用该函数获得我需要的所有路径数据:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6eca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是算法的最后一部分！我想快速验证创建的帖子。那么，如果我可以在浏览器选项卡中打开创建的帖子会怎么样呢？那太棒了！</p><p id="8dca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我做到了:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b129" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我使用<code class="fe mk ml mm mn b">open</code>库来模拟终端打开命令。</p><p id="0646" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就这样了！</p><h1 id="00fb" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">学习</h1><p id="237c" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">这个项目非常有趣！通过这个过程我学到了一些很酷的东西。我想把它们列在这里:</p><ul class=""><li id="27c0" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">当我在学习Typescript时，我想快速验证我写的代码。所以我配置<code class="fe mk ml mm mn b">nodemon</code>在每次文件保存时编译并运行代码。将开发过程变得如此动态是很酷的。</li><li id="8daf" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">我尝试使用新节点<code class="fe mk ml mm mn b">fs</code>的<code class="fe mk ml mm mn b">promises</code> : <code class="fe mk ml mm mn b">readFile</code>、<code class="fe mk ml mm mn b">mkdir</code>、<code class="fe mk ml mm mn b">writeFile</code>和<code class="fe mk ml mm mn b">copyFile</code>。它在<code class="fe mk ml mm mn b">Stability: 2</code>上。</li><li id="42b2" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">我做了大量的<a class="ae kp" href="https://leandrotk.github.io/tk/2020/03/closure-currying-and-cool-abstractions/index.html" rel="noopener ugc nofollow" target="_blank">奉承</a>来使一些功能可以重用。</li><li id="4110" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">枚举和<a class="ae kp" href="https://leandrotk.github.io/tk/2020/04/typescript-learnings-002-type-system/index.html" rel="noopener ugc nofollow" target="_blank">类型</a>是在Typescript中保持状态一致的好方法，也是所有项目数据的好表示和文档。<a class="ae kp" href="https://leandrotk.github.io/tk/2020/04/thinking-in-data-contracts/index.html" rel="noopener ugc nofollow" target="_blank">数据契约</a>真是个好东西。</li><li id="44cb" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">工具思维。这是我真正喜欢编程的原因之一。构建工具来自动化重复的任务，让生活更轻松。</li></ul><p id="2c84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这是一本好书！继续学习，继续编码！</p><p id="453d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的<a class="ae kp" href="https://twitter.com/leandrotk_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae kp" href="https://github.com/leandrotk/" rel="noopener ugc nofollow" target="_blank"> Github </a>。</p><h1 id="96a6" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">资源</h1><ul class=""><li id="512e" class="mq mr it js b jt mf jx mg kb ne kf nf kj ng kn mv mw mx my bi translated"><a class="ae kp" href="https://leandrotk.github.io/tk/2020/04/thinking-in-data-contracts/index.html" rel="noopener ugc nofollow" target="_blank">数据契约中的思考</a></li><li id="d7b7" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><a class="ae kp" href="https://leandrotk.github.io/tk/2020/04/typescript-learnings/index.html" rel="noopener ugc nofollow" target="_blank">打字稿学习</a></li><li id="a7b5" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><a class="ae kp" href="https://leandrotk.github.io/tk/2020/03/closure-currying-and-cool-abstractions/index.html" rel="noopener ugc nofollow" target="_blank">闭包、Currying和酷抽象</a></li></ul></div></div>    
</body>
</html>