<html>
<head>
<title>How to write manageable code without over-engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在不过度工程化的情况下编写可管理的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-manageable-code-without-over-engineering-24bf8d18591b?source=collection_archive---------13-----------------------#2020-05-29">https://levelup.gitconnected.com/how-to-write-manageable-code-without-over-engineering-24bf8d18591b?source=collection_archive---------13-----------------------#2020-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b8e475144eb371d5d01d0417d70a508e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R5_38wSj7DOXZgDV.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片来源:<a class="ae kf" href="https://aviation.stackexchange.com/" rel="noopener ugc nofollow" target="_blank">aviation.stackexchange.com</a></figcaption></figure><p id="647a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上可管理的代码是指无需太多更改即可轻松扩展的代码。如果我们的代码库易于管理，我们将拥有以下众所周知的优势。</p><ul class=""><li id="d758" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">新来者将能够在短时间内理解和添加新功能。</li><li id="c92a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">当开发团队很大时，减少git冲突。</li><li id="2454" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">无需修改太多文件或位置，即可轻松添加新功能。</li></ul><p id="a6ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑这个非常简单的例子</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="70cf" class="mb mc it lx b gy md me l mf mg">let action1Clicked = () =&gt; {<br/>  // some common logic same as action2Clicked<br/>  // specific logic<br/>}</span><span id="5bea" class="mb mc it lx b gy mh me l mf mg">let action2Clicked = () =&gt; {<br/>  // some common logic same as action1Clicked<br/>  // specific logic<br/>}</span></pre><p id="41db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以清楚地看到，这两种方法都有重复的逻辑。事实上，如果我们需要改变共同的逻辑，我们将不得不修改两个地方。因此，让我们按如下方式重构它。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a6b0" class="mb mc it lx b gy md me l mf mg">let commonLogic() =&gt; {<br/>  // common logic goes here<br/>}</span><span id="a1aa" class="mb mc it lx b gy mh me l mf mg">let action1Clicked = () =&gt; {<br/>  commonLogic();<br/>  // some specific logic<br/>}</span><span id="84ba" class="mb mc it lx b gy mh me l mf mg">let action2Clicked = () =&gt; {<br/>  commonLogic();<br/>  // some specific logic<br/>}</span></pre><p id="accc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您认为最好的方法是创建一个新的模块，那么本文就是为您准备的。</p><h2 id="f953" class="mb mc it bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">过度工程化</h2><blockquote class="mz na nb"><p id="09c2" class="kg kh nc ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated">凡事都有个限度，否则会有不好的副作用。</p></blockquote><p id="841a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据您的喜好，您可以对一组良好链接的类或良好链接的模块使用良好的逻辑分解。因此，您可以明智地将每个类或模块的责任分配给多个方法。如果我们做得太多，除了引入不必要的复杂性之外，没有任何收益，那会怎么样呢？</p><p id="38ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在纸上画一条直线，我们可以说左边的角代表最糟糕的代码，它根本不可管理，看起来也很乱，右边的角代表最过度设计的垃圾代码，看起来也很乱。因此，我们需要根据我们正在解决的问题，在这两个边缘之间平衡我们代码库的质量。</p><p id="76a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想给你3个原则来写易于管理但不过度工程化的代码。</p><h2 id="03c1" class="mb mc it bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">1.摆脱虚构特征的困境</h2><p id="4803" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">当一个特定的特性被实现时，可能会有将来需要的特性。因此，您可以通过添加更多的类/模块或方法来增加代码的灵活性。</p><p id="36a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:</p><p id="420a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设一个外部API返回摄氏温度，但您需要显示华氏温度，可以引入一个简单的实用函数在呈现之前进行转换。另一方面，假设将来会有更多的温度单位，我们也可以为整个温度单位转换引入新的模块/类。然而，无论是外部API还是您的应用程序在将来都不会改变它的单位。不知何故，如果用户要求开尔文作为一个显示单元，它将只是另一个实用功能。</p><p id="c435" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在实现特定功能之前，最好先确定哪些功能是真实的，哪些功能是虚构的。</p><h2 id="db52" class="mb mc it bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">2.控制分解的程度</h2><p id="feba" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">将逻辑分解成模块/类或方法是非常好的，但是理解分解的层次也是必须的。分解和组织良好的代码库通常具有高度可重用的组件。但是有时候，原子级的分解增加了项目的复杂性，却没有投资回报。重要的是，分解的级别显然取决于我们正在解决的问题。例如，当当前计划的分离级别有明显的增长，或者当未分离的元素显示出可重用的用例时，更深一点的逻辑分离是很好的。</p><p id="2114" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:</p><p id="3906" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您正在编写一个CLI程序，有一个命令将使用磁盘上的一些现有文件创建一个zip文件。有人可能会创建一个模块/类来处理这个任务，或者为压缩文件、压缩文件、将文件写入磁盘等等创建一组模块/类。如果没有人会重用那些东西；除了增加项目的复杂性之外，这样做没有任何好处。</p><p id="2280" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一点也适用于现代软件架构；现在，人们倾向于为一个最多只有数百个用户的应用程序创建数百个微服务。</p><h2 id="2c93" class="mb mc it bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">3.不要想太多</h2><p id="28c7" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">DRY(不要重复自己)是通过重用现有的东西或者编写更多可扩展的代码来减少额外工作的好习惯。然而，并非所有的东西都可以转换成干净的可重用元素。</p><p id="ce3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="22b7" class="mb mc it lx b gy md me l mf mg">let someAlgorithm = (myParam_1.. MyParam_n) =&gt; {<br/>   // some logic<br/>}</span></pre><p id="3d39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您需要添加另一个看起来相同的算法，但根据参数，这里和那里有许多差异。诚然，写<code class="fe nl nm nn lx b">anotherAlgorithm</code>方法比用大量条件语句严格复用<code class="fe nl nm nn lx b">someAlgorithm</code>要好。</p><h2 id="a650" class="mb mc it bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">结论</h2><p id="5823" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">一个良好设计和管理的代码库是好的。然而，确保你不要过度设计，因为它有更多的副作用。将工程学原理应用于一个问题应该会简化它，而不是让一切都变得过于复杂。</p><p id="63b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码快乐！🥳</p></div></div>    
</body>
</html>