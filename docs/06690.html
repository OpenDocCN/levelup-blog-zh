<html>
<head>
<title>GitHub Actions to build your Java/Scala application, test and deploy it to Kubernetes cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitHub Actions构建您的Java/Scala应用程序，测试并将其部署到Kubernetes集群</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/github-actions-to-build-your-java-scala-application-test-and-deploy-it-to-kubernetes-cluster-484779dfc200?source=collection_archive---------4-----------------------#2020-12-20">https://levelup.gitconnected.com/github-actions-to-build-your-java-scala-application-test-and-deploy-it-to-kubernetes-cluster-484779dfc200?source=collection_archive---------4-----------------------#2020-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/02fbb404c8156f3f26de6a38acf33aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehtVjiaBimIf7GARFo97Rw.jpeg"/></div></div></figure><p id="67e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的几年里，我一直在使用一些CI/CD服务器，比如TeamCity和Jenkins。我发现这些产品非常强大，因为它们能够运行分布式构建(即使是现在，3个月后，Kubernetes中的Jenkins也让我感到惊讶:)，与不同构建系统的高度集成以及对各种编程语言的支持，更不用说它们灵活的身份验证/授权系统了。</p><p id="4eef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，当我处理我最喜欢的项目时，我想要Jenkins的一些功能子集。我准备好接受任何托管或云Jenkins解决方案了吗—没有！所以，当我收到GitHub的下一个使用它的“动作”的邀请后，我决定研究一下它是什么。“GitLab CI/CD”的克隆！不，当然，我不想指责任何人窃取了这个概念——这只是我在阅读一些文档时想到的一个想法。</p><p id="9f92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub Actions能在一个大项目(有许多服务、复杂的部署逻辑、不同的语言、私有存储库)中取代Jenkins(或任何其他专用CI/CD解决方案)吗——不能！能有用吗(至少对我来说)——肯定有用！</p><p id="5883" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我阅读了大量关于GitHub Action on Medium的文章，但还没有找到描述我需求的内容。然而，现在我知道了如何构建和部署React应用程序:)。</p><p id="597b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望从未来管道中获得什么:</p><ul class=""><li id="3a07" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">缓存构建/编译依赖项(我不希望在每次构建时等待额外的时间，因为依赖项会一次又一次地下载，就像在以前的构建中没有做的那样)</li><li id="9027" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在每次推送时运行现有测试</li></ul><p id="3b5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进一步的步骤应该只针对<code class="fe lk ll lm ln b">master</code>分支:</p><ul class=""><li id="a93d" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">构建新的docker映像(带有标签<code class="fe lk ll lm ln b">latest</code>和上次提交的SHA)</li><li id="d6cf" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">对我的Kubernetes集群进行滚动更新</li></ul><p id="7d03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从创建管道定义开始。GitHub Action重用GitLab和Jenkins的方法——使用存储库本身进行管道定义存储(当然，如果你不在Jenkins 中使用类似<a class="ae lo" href="https://www.jenkins.io/doc/book/pipeline/shared-libraries/" rel="noopener ugc nofollow" target="_blank">共享库的东西)。所以我们会创建一个YAML文件<code class="fe lk ll lm ln b">.github/workflows/ci-cd.yml</code>，这个文件的名字起不到显著的作用它只应该是有意义的。</a></p><p id="ad4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将一步一步地介绍YML的所有部分，并加上一些评论(评论将在每个部分的下面)。</p><p id="9b54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从全球事物开始:</p><pre class="lp lq lr ls gt lt ln lu lv aw lw bi"><span id="29b8" class="lx ly iq ln b gy lz ma l mb mc">name: ci-cd<br/><br/>on:<br/>  push:<br/><br/>jobs:<br/>  build-test-deploy:<br/>    runs-on: ubuntu-18.04<br/>    steps:</span></pre><p id="1708" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那里，我们声明了管道的名称，以及管道开始的条件(在任何分支的每次推送中)。我们还定义了我们将要运行的单个作业(<code class="fe lk ll lm ln b">build-test-deploy</code>):由于我们的步骤依赖于前一步骤的结果，我看不出它有什么分离的理由。当然，我们指定了一个docker映像，一切都将在其中执行。</p><pre class="lp lq lr ls gt lt ln lu lv aw lw bi"><span id="24b1" class="lx ly iq ln b gy lz ma l mb mc">- uses: actions/checkout@v2<br/>- name: set-up-jdk<br/>  uses: actions/setup-java@v1<br/>  with:<br/>    java-version: '11' # The JDK version to make available on the path.<br/>    java-package: jdk # (jre, jdk, or jdk+fx) - defaults to jdk<br/>    architecture: x64 # (x64 or x86) - defaults to x64</span></pre><p id="a486" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那里，我们定义了两个步骤:当前分支的检出和特定的JDK安装。</p><pre class="lp lq lr ls gt lt ln lu lv aw lw bi"><span id="c198" class="lx ly iq ln b gy lz ma l mb mc">- name: cache-local-repository<br/>  uses: actions/cache@v2<br/>  with:<br/>    path: |<br/>      ~/.m2/repository<br/>      ~/.gradle/caches<br/>      ~/.gradle/wrapper<br/>    key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*') }}<br/>    restore-keys: |<br/>      ${{ runner.os }}-gradle-</span></pre><p id="d091" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那里，我们定义了我们的构建助推器——依赖关系缓存。在每一次成功的编译中，它都被压缩并以我们的密钥名存储在某个地方(可用于不同的参数，如操作系统、编译工具、JDS版本等)。)通过自动创建的步骤。</p><pre class="lp lq lr ls gt lt ln lu lv aw lw bi"><span id="7b48" class="lx ly iq ln b gy lz ma l mb mc">- name: grant-execute-permission-for-gradlew<br/>  run: chmod +x gradlew<br/>- name: build-with-gradle<br/>  run: ./gradlew build<br/>- name: run-tests<br/>  run: ./gradlew scalatest</span></pre><p id="2ea8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那里，我们为gradle 定义了3个简单的步骤:使其包装器可执行，构建并测试我们的代码。</p><pre class="lp lq lr ls gt lt ln lu lv aw lw bi"><span id="9285" class="lx ly iq ln b gy lz ma l mb mc">- name: login-to-docker-hub<br/>  if: ${{ github.ref == 'refs/heads/master' }}<br/>  uses: docker/login-action@v1<br/>  with:<br/>    username: ${{ secrets.DOCKER_USERNAME }}<br/>    password: ${{ secrets.DOCKER_PASSWORD }}<br/>- name: set-up-docker-buildx<br/>  if: ${{ github.ref == 'refs/heads/master' }}<br/>  uses: docker/setup-buildx-action@v1</span></pre><p id="2412" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那里我们定义了2个步骤(根据<a class="ae lo" href="https://github.com/docker/build-push-action" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/build-push-action</a>动作的新发布):在DockerHub创建并设置Docker的<a class="ae lo" href="https://github.com/docker/buildx" rel="noopener ugc nofollow" target="_blank"> Buildx </a>之后，登录Docker hub推送新的图像。</p><p id="4684" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是第一步，我们使用关键字<code class="fe lk ll lm ln b">if</code>检查我们的分支，并且仅当我们在条件中得到肯定结果时才执行该步骤(对我们来说，这意味着我们不会在除<code class="fe lk ll lm ln b">master</code>之外的任何分支上运行该步骤)。</p><p id="7547" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，这是我们第一次使用<a class="ae lo" href="https://docs.github.com/en/free-pro-team@latest/actions/reference/encrypted-secrets" rel="noopener ugc nofollow" target="_blank"> GitHub Secrets </a>的地方，这对于敏感数据是必不可少的，比如密码或证书。我们可以将这些作为秘密保存在GitHub中，然后在工作流中使用它们作为<code class="fe lk ll lm ln b">${{ secrets.XXXX }}</code>形式的环境变量。</p><pre class="lp lq lr ls gt lt ln lu lv aw lw bi"><span id="aa25" class="lx ly iq ln b gy lz ma l mb mc">- name: get-short-sha # https://github.community/t/substring-function/18401<br/>  if: ${{ github.ref == 'refs/heads/master' }}<br/>  run: |<br/>    id=$(echo ${{github.sha}} | cut -b-7)<br/>    echo "::set-output name=sha::sha-$id"<br/>  id: get-short-sha-id</span></pre><p id="c58e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们使用GitHub的输出概念为docker图像生成一个带有标签值的字符串(目前没有更简单的方法)。你也可以看到我使用了<code class="fe lk ll lm ln b">id</code>关键字，这将有助于在其他步骤中引用这些输出。</p><pre class="lp lq lr ls gt lt ln lu lv aw lw bi"><span id="40cd" class="lx ly iq ln b gy lz ma l mb mc">- name: build-and-push-docker-image<br/>  if: ${{ github.ref == 'refs/heads/master' }}<br/>  uses: docker/build-push-action@v2<br/>  with:<br/>    push: true<br/>    file: docker/Dockerfile<br/>    context: build/libs<br/>    tags: |<br/>      fedormalyshkin/conway-life-stream-server:latest<br/>      fedormalyshkin/conway-life-stream-server:${{steps.get-short-sha-id.outputs.sha}}</span></pre><p id="7d76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那里，我们定义了图像构建及其在DockerHub上发布的步骤</p><pre class="lp lq lr ls gt lt ln lu lv aw lw bi"><span id="b7b2" class="lx ly iq ln b gy lz ma l mb mc">- name: set-k8s-context<br/>  if: ${{ github.ref == 'refs/heads/master' }}<br/>  uses: azure/k8s-set-context@v1<br/>  with:<br/>    method: kubeconfig<br/>    kubeconfig: ${{ secrets.KUBE_CONFIG }}</span></pre><p id="9b1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那里，我们初始化了Kubernetes客户端(<code class="fe lk ll lm ln b">kubectl</code>)的配置，我们将在最后一步中使用它。正如你看到的，我们再次使用GitHub Secret record，在其中我们保存了<code class="fe lk ll lm ln b">.kube/config</code>文件的全部内容(默认情况下启用了所需的上下文)。</p><pre class="lp lq lr ls gt lt ln lu lv aw lw bi"><span id="8950" class="lx ly iq ln b gy lz ma l mb mc">- name: roll-update-k8s<br/>  if: ${{ github.ref == 'refs/heads/master' }}<br/>  run: kubectl set image deployment/stream-server-deployment conway-life-stream-server=fedormalyshkin/conway-life-stream-server:${{steps.get-short-sha-id.outputs.sha}}</span></pre><p id="65b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是在Kubernetes集群中运行滚动更新，方法是将docker的映像名称更改为我们在上一步中创建的新映像名称。</p><p id="77f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整版本可在此处获得:<a class="ae lo" href="https://github.com/fedor-malyshkin/conway-life-stream-server/blob/master/.github/workflows/ci-cd.yml" rel="noopener ugc nofollow" target="_blank">https://github . com/fedor-malyshkin/Conway-life-stream-server/blob/master/。github/workflows/ci-cd.yml </a></p><p id="13a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总而言之，GitHub扩展了它的动作列表，它们在使用中变得越来越有趣，而对我来说，它已经很适合一些应用程序了。</p><p id="8bd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">祝您在开发自动化方面一切顺利:)</p></div></div>    
</body>
</html>