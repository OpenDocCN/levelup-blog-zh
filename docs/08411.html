<html>
<head>
<title>Haskell Journey: Functions and Pattern Matching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Haskell之旅:函数和模式匹配</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/haskell-journey-functions-and-pattern-matching-135ca1f2c692?source=collection_archive---------2-----------------------#2021-04-29">https://levelup.gitconnected.com/haskell-journey-functions-and-pattern-matching-135ca1f2c692?source=collection_archive---------2-----------------------#2021-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d7fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎来到<em class="kl">哈斯克尔</em>系列集锦第二贴！今天，我将用这种不可思议的语言探索<em class="kl">功能</em>和<em class="kl">模式匹配</em>🤓</p><p id="bad5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在学习中使用的一些有用的链接:<br/> <strong class="jp ir"> (1) </strong>学习基于这些书的概念:<a class="ae km" href="https://www.casadocodigo.com.br/products/livro-haskell" rel="noopener ugc nofollow" target="_blank"> Haskell函数式编程导论</a> g和<a class="ae km" href="http://learnyouahaskell.com/chapters" rel="noopener ugc nofollow" target="_blank">为了更好的效果，学习Haskell！</a>📚<br/> <strong class="jp ir"> (2) </strong>对该<a class="ae km" href="https://www.notion.so/Haskell-29aac2ea56274d67bde03a529e8e4f09" rel="noopener ugc nofollow" target="_blank">意见</a>文件做笔记📝<br/> <strong class="jp ir"> (3) </strong>在我的<a class="ae km" href="https://github.com/jennifertakagi/haskell-projects-study" rel="noopener ugc nofollow" target="_blank"> GitHub库</a> 🗃上编写一些练习</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/6b0fd74b86df04304cedc3384effb67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qzNyH5PCOzL1lMTx"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae km" href="https://unsplash.com/@aridley88?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Andrew Ridley </a>在<a class="ae km" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="b5c9" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">功能</h1><blockquote class="mb mc md"><p id="4f3b" class="jn jo kl jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">函数被定义为可重用的块代码，可以在同一个程序中多次使用。</p></blockquote><p id="dfc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="kl"> Haskell </em>中，文件扩展名为<strong class="jp ir">T30。hs 是我们写<em class="kl">函数的地方。</em> </strong>语法非常简单明了:<strong class="jp ir"><em class="kl">funcName parameter 1 parameter 2…= execution</em></strong></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/16017e834321e99996640b4556b3349c.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*6wykymGSfkOvjPaiVb-PBw.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Haskell中函数的代码示例。</figcaption></figure><p id="fa8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我把影响我的区别列为一个<em class="kl"> JavaScript </em>和<em class="kl"> Python </em>用户:<br/> *没有<em class="kl">关键字</em>来定义一个<em class="kl">函数</em>，只要提名就可以了，继续。<br/> *在<em class="kl">参数</em>之间没有逗号，也没有涉及块的花括号，语言相当干净。😅<br/> *要定义执行代码，只需使用等号，并写出<em class="kl">函数</em>所做的事情——有点类似于<em class="kl">箭头函数语法i </em> n <em class="kl"> JS </em>。</p><h2 id="9411" class="mi le iq bd lf mj mk dn lj ml mm dp ln jy mn mo lr kc mp mq lv kg mr ms lz mt bi translated">辛德雷-米尔纳型系统</h2><blockquote class="mb mc md"><p id="72d0" class="jn jo kl jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">辛德雷-米尔纳是罗杰·辛德雷和后来的罗宾·米尔纳独立发现的<strong class="jp ir">型系统</strong>。它是几乎所有静态类型函数语言的类型系统的基础。</p></blockquote><p id="53e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="kl"> Haskell </em>中，<em class="kl">函数</em>可以有<em class="kl">类型</em>，并且它们可以被显式声明。实际上，编写<em class="kl">函数的类型</em>是一个很好的实践，为此我们可以使用<em class="kl"> Hindley-Milner类型系统</em>来定义这些类型。</p><p id="9fbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就此而言，我们可以说<em class="kl"> Hindley-Milner类型系统</em>的工作方式类似于<em class="kl">功能</em>文档。我们能够知道<em class="kl">函数</em>接收哪个<em class="kl">参数类型</em>以及它将返回哪个<em class="kl">类型</em>(该语言也能够解释这些信息，但是我还没有做到这一步)。</p><p id="e723" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，我在<strong class="jp ir"> <em class="kl">上使用了<em class="kl">辛德雷-米尔纳</em>的</em> </strong> <em class="kl">函数。</em>函数<strong class="jp ir">接收一个带有<em class="kl">字符类型</em>的<em class="kl">参数</em>，并返回一个<em class="kl">布尔值。</em>语法<em class="kl"> </em>简单<em class="kl">:</em></strong>(<strong class="jp ir"><em class="kl">function name::type-&gt;type</em></strong>)。<br/><em class="kl">*</em><strong class="jp ir"><em class="kl">”:::</em></strong><em class="kl">可以读作“已类型”<br/>* *-&gt;“拆分每个参数，最后一个类型表示返回的那个。<br/> ***显式类型总是用大写的第一个字母表示。</em> <br/> <em class="kl"> ****这里有一个链接，这样你可以阅读更多关于</em> <a class="ae km" href="http://dev.stephendiehl.com/fun/006_hindley_milner.html" rel="noopener ugc nofollow" target="_blank"> <em class="kl">辛德雷-米尔纳型系统</em> </a></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/ce8b1fe2810dfa8784a421537a333b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*GAGN90lA321SrxkCtpsCPw.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Haskell中函数的代码示例。</figcaption></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="de94" class="ld le iq bd lf lg nc li lj lk nd lm ln lo ne lq lr ls nf lu lv lw ng ly lz ma bi translated">模式匹配</h1><blockquote class="mb mc md"><p id="8480" class="jn jo kl jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">模式匹配包括指定一些数据应该符合的模式，然后检查是否符合，并根据这些模式解构数据。(利波瓦卡，米兰)</p></blockquote><p id="34b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个特性很神奇，而且不是Haskell独有的。例如，我已经在<em class="kl">药剂</em>上使用过。<strong class="jp ir"> <em class="kl">模式匹配</em>使我们能够为不同的模式定义单独的<em class="kl">函数体</em>，保持代码简单易读。</strong> 🧐</p><p id="7dcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的代码中，我们可以很容易地创建一个<em class="kl">函数</em>来检查名称是否有效——验证<em class="kl">字符串</em>是否为空——<strong class="jp ir">没有控制IF/ELSE </strong>！🤯</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f20ddeb1694651335caef40e07504c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*XPaiXSPnCb8Jaoqgn-7ong.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">使用模式匹配的代码示例。</figcaption></figure><p id="2e41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述，我写的<em class="kl">函数</em> <strong class="jp ir"> <em class="kl"> isValidName </em> </strong>行为分2种场景:<br/> (1)接收一个空的<em class="kl">字符串</em>作为<em class="kl">参数</em>，然后返回一个关于无效名称的消息；<br/> (2)接收任何<em class="kl">字符串</em>值——注意我将接收的<em class="kl">参数</em>作为<em class="kl">字符串键入。如果我试图发送一个<em class="kl">数字</em>而不是一个<em class="kl">字符串</em>，它会抛出一个错误，然后返回一个包含有效名称的消息。<br/> <em class="kl"> *如果不在乎在模式匹配上使用显式值，可以随便给它取个名字。在示例中，我使用了“名称”，但也可能是“x”。</em></em></p><p id="0d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用<em class="kl">模式匹配</em>能想象出整个可能性吗？它帮助我们在同一个<em class="kl">功能上处理不同的<em class="kl">参数</em>。L </em>让我们试一个稍微复杂一点的例子:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/25b75e29dda07fb97db22b22f86cc607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*NR18K6GBnhrjg6PU0YRRwA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">使用模式匹配的代码示例。</figcaption></figure><p id="8668" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们的<em class="kl">函数</em>将一些温度转换为摄氏度单位。想想解决方案:你需要知道<em class="kl">函数</em>接收的是哪个温度单位，然后据此应用转换。所以这可能是一个经典的IF/ELSE用法，但是我们有<em class="kl">模式匹配</em>来扭转局面！😲</p><p id="9ac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数<strong class="jp ir"><em class="kl">convertCelsius</em></strong>必须处理3种场景:<br/> (1)接收一个华氏单位作为<em class="kl">双精度类型</em>，然后应用转换；<br/> (2)接收一个开尔文单位作为<em class="kl">双型</em>，然后进行转换；<br/> (3)接收其他一些单位而忽略它。<br/> <em class="kl"> *如果只是想忽略模式匹配上的参数，应该使用符号“_”。</em></p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="869c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">好长的帖子！感谢您的阅读，我希望现在，您能和我一样，更加喜欢Haskell和函数式编程</em> 🥰 <em class="kl"> <br/>也许您在想“循环和条件语句呢，詹妮弗？”好吧，我保证在下一篇文章中回答这些问题。再见，注意安全！</em>🤟👩🏻‍💻</p></div></div>    
</body>
</html>