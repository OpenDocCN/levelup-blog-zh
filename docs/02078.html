<html>
<head>
<title>RxJava — Understanding Operators with the Marble Diagram</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">rx Java——用大理石图理解运算符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rxjava-understanding-operators-with-the-marble-diagram-fc96addb0beb?source=collection_archive---------9-----------------------#2020-02-17">https://levelup.gitconnected.com/rxjava-understanding-operators-with-the-marble-diagram-fc96addb0beb?source=collection_archive---------9-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb64" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过可视化RxJava操作符来学习</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1c3eef1e85b00692536a5b0dbd54c152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9HjN7iA7k6QQm_l7MaP9w.png"/></div></div></figure><p id="12ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Rx代表无功扩展。RxJava是一个非常棒的反应式库，我们可以轻松地将它集成到我们的应用程序中，以方便多线程。</p><p id="5eff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以将RxJava理解为由一个组件发出的数据，<strong class="kw iu"> Observable </strong>和由Rx库提供的底层结构将变化传播到另一个组件，<strong class="kw iu"> Observer </strong>。这是一个用可观察流进行<strong class="kw iu">异步</strong>编程的API。</p><p id="a3ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://medium.com/@pavan.careers5208/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener">Rx Java——Android中的多线程</a>有助于理解Rx的基础知识，关于<a class="ae lq" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener">observable</a>e、<a class="ae lq" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener"> Observe </a> r、<a class="ae lq" href="https://medium.com/better-programming/rxjava-multi-threading-in-android-302a7419edbf" rel="noopener"> Scheduler </a>等的一切。因此，希望您已经了解了RxJava的基础知识，让我们开始吧。</p><h2 id="ae32" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">操作员</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/98e2b99ffb106372299a3119a11e821e.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*dUZuHjbQCLneWx74-AfvUQ.png"/></div></figure><p id="7b6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Rx操作符允许我们在一个观察者观察到一个可观察对象之前对其发出的数据进行处理。我们可以在一个可观察对象上应用一系列操作符，其中一个操作符的每个输出都是下一个操作符的输入。使用这些算子我们可以<strong class="kw iu">修改</strong>、<strong class="kw iu">合并</strong>或<strong class="kw iu">过滤</strong>一个可观测发射的数据流。RxJava有大量不同的操作符。我们稍后会检查它们，让我们转到<strong class="kw iu">大理石图。</strong></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="06b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">什么是<strong class="kw iu">大理石图</strong>？<br/>弹珠图是Rx <strong class="kw iu">操作员</strong>如何工作的<strong class="kw iu">视觉</strong>表示。Rx在每个用例中使用这个弹珠图，使它们<strong class="kw iu">容易</strong>理解。理解这些图是<strong class="kw iu">跳跃学习Rx不同部件前的必要</strong>。一旦我们理解了这些图，我们就可以很容易地通过查看图来理解组件的主题。</p><p id="0ff6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通用图像将由主要部分组成，如<strong class="kw iu">时间轴、操作符、输入流项目、输出流项目和结果。</strong>让我们单独了解它们中的每一个，然后将它们全部组合起来，以便于理解。</p><h2 id="a719" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">时间线</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/000a5eadd76b7f454f686e674e5173e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*CKQMRreIX-apPAoZfo4bPA.png"/></div></figure><p id="b2b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">时间线只不过是一条水平线，表示流程是从<strong class="kw iu">左</strong>到<strong class="kw iu">右</strong>。当看任何大理石图时，我们需要从左到右研究时间线。时间轴代表了一个可观测物体在<strong class="kw iu">时间</strong>内将会做什么。</p><h2 id="2933" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">物品</strong></h2><p id="8fa1" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们可以用不同的形状来代表时间线上一个可观察物体发出的项目。在大多数情况下，我们看到圆形、三角形、星形和五边形。这些形状通常被称为大理石。将有一个项目的输入或输出流。让我们看看他们长什么样</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/19c235362a114d272d3ec9297d739769.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*QckaPcqUp2cdh5_paaaQHw.png"/></div></figure><p id="7a4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些物品按照圆形、三角形、星形和五边形的顺序发射。</p><h2 id="3ad5" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">结果</h2><p id="00c8" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">正如我们已经看到的时间线和项目最后一种情况是结果有三种可能的结果<strong class="kw iu">成功，失败，没有结果。</strong>这些表示为休耕</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/4a549b2046d26c4df08edafcd09d3011.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*_ZKhl9AZJ__U2sNZDotO4w.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">流成功完成</figcaption></figure><p id="8f46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">右端的垂直线表示<strong class="kw iu">成功。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/67c734c16f85c15419006c1eb13462b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*n8vYFGAhSPvJPvdnNs4bZQ.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">失败时中止流</figcaption></figure><p id="8871" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">右端的十字符号表示因<strong class="kw iu">错误</strong>而终止的流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/19c235362a114d272d3ec9297d739769.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*QckaPcqUp2cdh5_paaaQHw.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">流从未终止</figcaption></figure><p id="925f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有成功或失败，则该流不被终止</p><p id="a359" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经知道了各个项目，让我们通过分组并应用如下操作符来检查它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f5685e1d05cf98a65880e82c51c29dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*ETNhqr97VAfRr_G6W-fKMg.png"/></div></figure><p id="b484" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上面我们可以观察到</p><ol class=""><li id="5202" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp ni nj nk nl bi translated">有<strong class="kw iu">两条时间线</strong>一条与一个可观测的时间线相关联。</li><li id="092e" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated">在第一条时间线上，有不同的<strong class="kw iu">项</strong>由observable发出</li><li id="4885" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated">中间部分是<strong class="kw iu">操作符</strong>，它执行一些操作，并将结果提供给第二个时间线</li><li id="f5ab" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated">随着<strong class="kw iu">成功</strong>终止，第二个<strong class="kw iu">时间线</strong>来自操作员的观察项目</li></ol><p id="53ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查一下RxJava中的操作符是如何工作的，并检查一下我们如何在marble图的帮助下更好地理解它们。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b4fc" class="nr ls it bd lt ns nt nu lw nv nw nx lz jz ny ka mc kc nz kd mf kf oa kg mi ob bi translated">过滤器()</h1><p id="c6f0" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><strong class="kw iu"> filter </strong>运算符仅从可观察对象中发出那些通过了<strong class="kw iu">谓词</strong>测试的项目</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/e356d74371e4abe40794222d7e6b8ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jS2KXRNQAXu2BiSs1WD1Vw.png"/></div></div></figure><p id="8521" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看着这些图表，我们可以理解在时间线一上的一个可观察物体发出不同的<strong class="kw iu">形状</strong>像圆形、三角形、五边形和菱形。在第二阶段，从第一时间线发出的所有这些不同的形状都通过<strong class="kw iu">过滤器</strong>操作器，该操作器正在寻找<strong class="kw iu">圆形</strong>形状。最后，我们可以在第二条时间线上看到，只有<strong class="kw iu">个圆</strong>被接收。</p><p id="30a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过编码来检查</p><p id="0114" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有一个可观察对象正在发出1到100之间的一些整数，现在让我们对发出的值应用带有谓词条件的<strong class="kw iu"> filter() </strong>操作符，以获取其值大于10的值。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8cad" class="lr ls it oe b gy oi oj l ok ol">Observable.just(2, 30, 22, 5, 60, 1)<br/>    .<strong class="oe iu">filter</strong>(x -&gt; x &gt; 10)<br/>    .subscribe(x -&gt; println("item: " + x)));</span></pre><p id="3479" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出为<br/>项:<strong class="kw iu">30</strong>T3)项:<strong class="kw iu">22</strong>T6】项:<strong class="kw iu"> 60 </strong></p><p id="0e49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述问题的大理石图如下</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/143cba68ad909607335df795c0f4ea23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9OGzVHoouwDSKmjJI5gMw.png"/></div></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5613" class="nr ls it bd lt ns nt nu lw nv nw nx lz jz ny ka mc kc nz kd mf kf oa kg mi ob bi translated">地图()</h1><p id="eed8" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><strong class="kw iu">映射</strong>操作符<strong class="kw iu"> </strong>通过对每个项目应用一个函数来变换一个可观察对象发出的项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/81374612c9db1bc907a275c7ba2d1e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPwK7IGUPIOVwcDIKVwK2A.png"/></div></div></figure><p id="1d31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的大理石图中，在第二阶段，源可观测物发出穿过地图操作符的<strong class="kw iu">圆</strong>形状。这个map操作符通过应用一些功能将它们转换成<strong class="kw iu">菱形</strong>形状。因此，菱形将是第二可观察时间线的输入。</p><p id="6dce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过编码来检查</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="dfd5" class="lr ls it oe b gy oi oj l ok ol">Observable.just(1, 2, 3)<br/> .<strong class="oe iu">map</strong>(x -&gt; 1.25 * x)<br/> .subscribe(x -&gt; println(“item: “ + x)));</span></pre><p id="31da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出为<br/>项:<strong class="kw iu">1.25</strong>T20】项:<strong class="kw iu">2.50</strong>T23】项:<strong class="kw iu"> 3.75 </strong></p><p id="70ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述问题的大理石图如下</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/baa909540920dc6f0a2235770909d48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iw_nop_055Q-DOt4nkA7hw.png"/></div></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="d0e1" class="nr ls it bd lt ns nt nu lw nv nw nx lz jz ny ka mc kc nz kd mf kf oa kg mi ob bi translated">平面地图()</h1><p id="90ce" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><strong class="kw iu"> flatMap </strong>算子<strong class="kw iu"> </strong>将一个可观测发射的项目转化为可观测，然后将这些发射平坦化为一个单独的可观测</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/a0e58d30fde56b36898dcfe76263541b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HnjrvlaOGvVRmSs1uSUiqA.png"/></div></div></figure><p id="b4b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">平面图将一个可观察对象分成许多单独的可观察对象。因此，FlatMap不是逐个发送每个可观察值，而是在<strong class="kw iu">中并行</strong>执行所有操作，然后<strong class="kw iu">按照完成的顺序合并</strong>结果。</p><p id="11b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">来自平面图<strong class="kw iu">的新的可观察值</strong>不能保证相同的顺序。这些值是混合的。</p><blockquote class="oq"><p id="eb48" class="or os it bd ot ou ov ow ox oy oz lp dk translated">平面图发出可观察到的东西，而不是项目</p></blockquote><h2 id="a7c2" class="lr ls it bd lt lu pa dn lw lx pb dp lz ld pc mb mc lh pd me mf ll pe mh mi mj bi translated">地图()与平面地图()</h2><p id="9192" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">Map返回类型为<strong class="kw iu"> T </strong>的<strong class="kw iu">项</strong>，而FlatMap返回类型为<strong class="kw iu">可观察&lt;T&gt;T43】的<strong class="kw iu">可观察</strong>。给定类型T的输入和类型R的输出，</strong></p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="2f91" class="lr ls it oe b gy oi oj l ok ol"><strong class="oe iu">map()</strong>:<br/>input: Observable&lt;T&gt;<br/>transformation: <strong class="oe iu">(T -&gt; R)</strong><br/>output: Observable&lt;R&gt;</span><span id="8834" class="lr ls it oe b gy pf oj l ok ol"><strong class="oe iu">flatMap()</strong>:<br/>input: Observable&lt;T&gt;<br/>transformation: <strong class="oe iu">(T -&gt; Observable&lt;R&gt;)</strong><br/>output: Observable&lt;R&gt;</span></pre><blockquote class="pg ph pi"><p id="44b3" class="ku kv pj kw b kx ky ju kz la lb jx lc pk le lf lg pl li lj lk pm lm ln lo lp im bi translated"><strong class="kw iu"> <em class="it">当我们需要在</em> <strong class="kw iu"> <em class="it">并行</em> </strong> <em class="it">中执行多个网络请求时，flatMap </em> </strong> <em class="it">会很有用。它</em> <strong class="kw iu"> <em class="it">并不能</em> </strong> <em class="it"> </em> <strong class="kw iu"> <em class="it">保证</em> </strong> <em class="it">项在结果流中的顺序。</em></p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="081a" class="nr ls it bd lt ns nt nu lw nv nw nx lz jz ny ka mc kc nz kd mf kf oa kg mi ob bi translated">concatMap()</h1><p id="d78f" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><strong class="kw iu"> concatMap </strong>操作符类似于flatMap，除了它<strong class="kw iu">保证</strong>观察值的顺序。它一次只转换一个<strong class="kw iu">单个</strong>项目，从而实现最终的流顺序。它依次执行<strong class="kw iu">转换一个又一个项目，打破了平面图的<strong class="kw iu">平行</strong>规则，因此需要更多的时间来完成任务。flatMap隐式地使用了一个<strong class="kw iu"> merge </strong>操作符，而concatMap使用了<strong class="kw iu"> concat </strong>操作符。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/896c577ec49a772649b26dd09af35b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_EyDQ28vAbBdD0SOOW2mA.png"/></div></div></figure><blockquote class="pg ph pi"><p id="120e" class="ku kv pj kw b kx ky ju kz la lb jx lc pk le lf lg pl li lj lk pm lm ln lo lp im bi translated"><em class="it">当你想保持</em><strong class="kw iu"><em class="it"/></strong>的执行顺序时，ConcatMap更合适</p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="6b12" class="nr ls it bd lt ns nt nu lw nv nw nx lz jz ny ka mc kc nz kd mf kf oa kg mi ob bi translated">开关映射()</h1><p id="a897" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">SwitchMap不同于flatMap和concatMap，它总是返回最新的可观察对象，并从中发出项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/20067d8e664d1256c3b2937f0ab73e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RNcEOOUScJtxaBKFCtZLw.png"/></div></div></figure><p id="2455" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每次获得需要映射的新项目时，switchMap 将<strong class="kw iu">取消订阅</strong>以前的可观察对象，完全从一个项目切换到另一个项目。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="7e3e" class="nr ls it bd lt ns nt nu lw nv nw nx lz jz ny ka mc kc nz kd mf kf oa kg mi ob bi translated">concat()</h1><p id="d78b" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><strong class="kw iu"> concat </strong>操作符从两个或更多个可观察对象<strong class="kw iu">中发出项目，不需要</strong> <strong class="kw iu">交错</strong>或<strong class="kw iu">混合</strong>它们</p><p id="e76b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">concat运算符<strong class="kw iu">将<strong class="kw iu">多个</strong>可观察对象的输出</strong>连接起来，这样它们就像一个<strong class="kw iu">单个</strong>可观察对象一样，第一个可观察对象发出的所有项目都在第二个可观察对象发出的任何项目之前发出(如果有两个以上的项目，则以此类推)。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1d3c" class="lr ls it oe b gy oi oj l ok ol">val observerVable1 = Observable.<em class="pj">just</em>(1, 1, 1);<br/>val observerVable2 = Observable.<em class="pj">just</em>(2, 2);<br/><br/>Observable.<strong class="oe iu">concat</strong>(observerVable1, observerVable2)<br/>    .subscribe(x -&gt; println("item: " + x)));</span></pre><p id="ffbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出为<br/>项:<strong class="kw iu">1</strong>T27】项:<strong class="kw iu">1</strong>T30】项:<strong class="kw iu">1</strong>T33】项:<strong class="kw iu">2</strong>T36】项:<strong class="kw iu"> 2 </strong></p><p id="1361" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面代码片段的大理石图是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/4fc0d11cbd0af6f39199f4cad3726800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvleLNcHmH2F8xFwvJgVkQ.png"/></div></div></figure><p id="02e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">concat <strong class="kw iu">等待</strong>订阅您传递给它的每个额外的可观察对象，直到前一个可观察对象完成。请注意，正因为如此，如果您试图连接一个“热”可观察对象，即在订阅之前立即开始发送项目的可观察对象，Concat将看不到，因此<strong class="kw iu">也不会发送</strong>任何可观察对象在所有之前的可观察对象完成之前发出的项目，并且Concat订阅“热”可观察对象。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="0124" class="nr ls it bd lt ns nt nu lw nv nw nx lz jz ny ka mc kc nz kd mf kf oa kg mi ob bi translated">合并()</h1><p id="efe5" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><strong class="kw iu">合并</strong>算子通过合并它们的发射将多个可观测值合并成一个。Merge可以<strong class="kw iu">交错</strong>或<strong class="kw iu">混合</strong>被合并的可观测量发出的项目，而<strong class="kw iu"> concat </strong>不会<strong class="kw iu">交错</strong>这些项目。<strong class="kw iu">合并</strong><strong class="kw iu"/>不保证发射顺序。上面的合并和连接只对<strong class="kw iu">可见物</strong>有效。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="eced" class="lr ls it oe b gy oi oj l ok ol">val observerVable1 = Observable.<em class="pj">just</em>(20,40,60,80,100);<br/>val observerVable2 = Observable.<em class="pj">just</em>(1, 1);<br/><br/>Observable.<strong class="oe iu">merge</strong>(observerVable1, observerVable2)<br/>    .subscribe(x -&gt; println("item: " + x)));</span></pre><p id="698f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出为<br/>项:<strong class="kw iu"> 20 </strong>项:<strong class="kw iu">40</strong>T65】项:<strong class="kw iu">60</strong>T68】项:<strong class="kw iu">1</strong>T71】项:<strong class="kw iu">80</strong>T74】项:<strong class="kw iu">100</strong>T77】项:<strong class="kw iu"> 1 【T79</strong></p><p id="02d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面代码片段的大理石图是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/e06def94a2d9428af9ac87f6cb2ebc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6s-4TFdHcky2fQNQBz6pDg.png"/></div></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="854e" class="nr ls it bd lt ns nt nu lw nv nw nx lz jz ny ka mc kc nz kd mf kf oa kg mi ob bi translated">去抖()</h1><p id="decc" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">如果特定的<strong class="kw iu">时间跨度</strong>已经过去而没有发出另一个项目，则去抖算子仅从可观察对象发出一个项目。这个操作符在编辑<strong class="kw iu">搜索视图</strong>中的文本或者保持<strong class="kw iu">连续</strong>点击按钮的延迟等情况下非常有用。</p><p id="766e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，在一个应用程序中有一个酒店搜索视图。当用户输入一些文本时，我们需要点击API并获取细节以显示给用户。当我们为每个字符获取文本改变事件时，考虑到打字速度，最好在为每个字符点击API之前保持一些<strong class="kw iu">延迟</strong>。通过这种方式，我们可以降低服务器的负载，同时提高应用程序的性能。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="bf47" class="lr ls it oe b gy oi oj l ok ol">edtHotelSearch.<em class="pj">afterTextChangeEvents</em>()<strong class="oe iu"><br/>        </strong>.<strong class="oe iu">debounce</strong>(200, TimeUnit.MILLISECONDS)<br/>        .observeOn(schedulers.ui())<br/>        .subscribe(<strong class="oe iu">{ </strong>charsequence <strong class="oe iu">-&gt;<br/>            </strong>doSomething(charsequence)<br/>        <strong class="oe iu">}</strong>, <strong class="oe iu">{<br/>            </strong>Timber.v(<strong class="oe iu">it</strong>)<br/>        <strong class="oe iu">}</strong>).<em class="pj">let </em><strong class="oe iu">{<br/>            </strong>compositeDisposable.add(<strong class="oe iu">it</strong>)<br/>        <strong class="oe iu">}</strong></span></pre><p id="1392" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">去抖动算子过滤掉由源可观测物发射的项目，该源可观测物紧接着是另一个发射的项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/ee91b82fb381ffb4e88723e458541490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3lsC8hBv3AbSqiZwfx8-w.png"/></div></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="7251" class="nr ls it bd lt ns nt nu lw nv nw nx lz jz ny ka mc kc nz kd mf kf oa kg mi ob bi translated">奖金</h1><p id="f93a" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">渴望了解更多关于Rx的信息，请继续阅读RxJava 上的系列<a class="ae lq" href="https://medium.com/@pavan.careers5208/complete-guide-on-rxjava-d997235e4eec" rel="noopener">完整指南。</a></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="98c5" class="nr ls it bd lt ns nt nu lw nv nw nx lz jz ny ka mc kc nz kd mf kf oa kg mi ob bi translated">参考</h1><p id="bbc1" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><a class="ae lq" href="http://reactivex.io/documentation/operators.html" rel="noopener ugc nofollow" target="_blank">反应性算子</a></p><p id="ab02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://rxmarbles.com/" rel="noopener ugc nofollow" target="_blank"> RxMarbles </a></p><p id="df67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://medium.com/@jshvarts/read-marble-diagrams-like-a-pro-3d72934d3ef5#ca31" rel="noopener">反应流的大理石图</a></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="78de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请让我知道你的建议和意见。</p><p id="bd9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在<a class="ae lq" href="https://medium.com/@pavan.careers5208" rel="noopener"> <strong class="kw iu">中</strong> </a>和<a class="ae lq" href="https://www.linkedin.com/in/satya-pavan-kumar-kantamani-61770a9b/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> LinkedIn </strong> </a>上找到我…</p><p id="0489" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读…</p></div></div>    
</body>
</html>