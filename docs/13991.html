<html>
<head>
<title>Design Patterns: Flyweight Pattern in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:TypeScript中的Flyweight模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-flyweight-pattern-in-typescript-539066d57b42?source=collection_archive---------3-----------------------#2022-10-23">https://levelup.gitconnected.com/design-patterns-flyweight-pattern-in-typescript-539066d57b42?source=collection_archive---------3-----------------------#2022-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4900" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对象的创建大大减少，系统内存减少，效率提高。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ab266c7f7f1d2d8cce7fef075a39620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jCGhQe_JJ3IIr3ib"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">亚历山大·格雷在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="93d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎来到TypeScript 系列的<strong class="lb iu">设计模式，这里介绍了一些使用TypeScript进行web开发时有用的设计模式。</strong></p><div class="lv lw gp gr lx ly"><a href="https://medium.com/frontend-canteen/9-design-patterns-every-engineer-should-know-f2423d36d468" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">每个工程师都应该知道的9种设计模式</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">掌握这9种设计模式，写出更好的代码</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="55b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计模式对于web开发人员来说非常重要，通过掌握它们我们可以写出更好的代码。在本文中，我将使用<strong class="lb iu">类型脚本</strong>来介绍<strong class="lb iu"> Flyweight模式。</strong></p><p id="4302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Flyweight模式就是运行共享技术来有效支持大量细粒度对象，避免大量内容相同的小类的开销(比如内存消耗)，允许大家共享一个类。</p><p id="1d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UPhone公司是一家手机制造商，它可以批量生产UPhone手机，手机的大部分数据，比如型号和屏幕都是一样的，小部分数据是不一样的。例如内存大小和序列号。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/c2e8772928adb4f81e7e20d703c7f6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15NJTV2cyuyWppN0GsbPjw.png"/></div></div></figure><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="f32a" class="mt mu it mp b gy mv mw l mx my">class UPhone {<br/>  constructor(model: string, screen: number, <br/>    memory: number, sn: number) {}<br/>}</span><span id="c1b3" class="mt mu it mp b gy mz mw l mx my">let uphones = [];<br/>for (let i = 0; i &lt; 10000; i++) {<br/>  let memory = i % 2 == 0 ? 64 : 128;<br/>  uphones.push(new UPhone("8U", 5.0, memory, i));<br/>}</span></pre><p id="45b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，创建了10，000个UPhone对象，每个UPhone独立地申请一个内存。<strong class="lb iu">但如果我们仔细观察，可以看到大部分UPhone对象都是相似的，只是内存和序列号不同</strong>。如果是性能要求高的程序，就要考虑优化。对于有大量相似物体的场景，我们可以使用flyweight模式进行优化。</p><p id="77d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">flyweight模式中有两个重要的概念:内部状态和外部状态。</p><ul class=""><li id="9654" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><strong class="lb iu">内部状态</strong>:flyweight对象内部不随外界环境变化而变化的共享部分。</li><li id="43ef" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">外部状态</strong>:不能共享的状态是随着环境变化而变化的外部状态。</li></ul><p id="bf44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于flyweight模式区分了内部状态和外部状态，<strong class="lb iu">我们可以通过设置不同的外部状态，让同一个对象具有一些不同的特性，而内部状态则设置为同一个部分</strong>。</p><p id="4154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将介绍如何使用flyweight模式来解决前面的问题。为了更好地理解下面的代码，我们先来看看相应的UML图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl no"><img src="../Images/edf13b8aa7f447dd15820c9c255913dd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*vZRfyT_tPNWR9E1snnWVjQ.png"/></div></figure><p id="3f8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上例中的大部分UPhone手机型号、屏幕、内存都是一样的，所以这部分数据是可以共享的，这是flyweight模型中固有的数据，所以我们定义UPhone对应的flyweight类如下:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="7b59" class="mt mu it mp b gy mv mw l mx my">class UPhoneFlyweight {<br/>  constructor(public model: string, public screen: number,<br/>    public memory: number) {}<br/>}</span></pre><blockquote class="np nq nr"><p id="74dc" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated"><strong class="lb iu">内部状态(模型、屏幕、内存)</strong>:flyweight对象内部不随外界环境变化而变化的共享部分。</p></blockquote><p id="3cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nw nx ny mp b">UPhoneFlyweight</code>类中，有三个成员属性<code class="fe nw nx ny mp b">model</code>、<code class="fe nw nx ny mp b">screen</code>和<code class="fe nw nx ny mp b">memory</code>。除了flyweight类，我们还需要一个flyweight工厂来维护这些数据:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="83b6" class="mt mu it mp b gy mv mw l mx my">class FlyweightFactory {<br/>  private phonesMap: Map&lt;string, UPhoneFlyweight&gt; = new Map();</span><span id="a6dc" class="mt mu it mp b gy mz mw l mx my">  public get(model: string, screen: number, memory: number):  <br/>   UPhoneFlyweight {<br/>    const key = model + screen + memory;<br/>    if (!this.phonesMap.has(key)) {<br/>      this.phonesMap.set(key, new UPhoneFlyweight(model, <br/>        screen, memory));<br/>    }<br/>    return this.phonesMap.get(key)!;<br/>  }<br/>}</span></pre><p id="3c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nw nx ny mp b">FlyweightFactory</code>类中，我们定义了一个<code class="fe nw nx ny mp b">phonesMap</code>对象来保存flyweight对象，并提供了一个<code class="fe nw nx ny mp b">get</code>方法来根据模型、屏幕和内存参数获取flyweight对象。如果<code class="fe nw nx ny mp b">phonesMap</code>对象包含对应的<code class="fe nw nx ny mp b">UPhoneFlyweight</code>对象，则直接返回。否则创建一个新的<code class="fe nw nx ny mp b">UPhoneFlyweight</code>对象并返回。</p><p id="0e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于每个UPhone的序列号都是唯一的，因此该属性需要用作外部状态。基于<code class="fe nw nx ny mp b">UPhoneFlyweight</code>类，让我们更新之前定义的<code class="fe nw nx ny mp b">UPhone</code>类:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="8e5c" class="mt mu it mp b gy mv mw l mx my">class UPhone {<br/>  constructor(<br/>    public flyweight: UPhoneFlyweight, <br/>    public sn: number) {}<br/>}</span></pre><blockquote class="np nq nr"><p id="da81" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated"><strong class="lb iu">外部状态(sn) </strong>:不能共享的状态是随着环境变化而变化的外部状态。</p></blockquote><p id="de91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，为了更容易地创建UPhone对象，我们继续定义一个<code class="fe nw nx ny mp b">UPhoneFactory</code>类:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="20d9" class="mt mu it mp b gy mv mw l mx my">class UPhoneFactory {<br/>  private static flyweightFactory: FlyweightFactory = <br/>    new FlyweightFactory();</span><span id="ec07" class="mt mu it mp b gy mz mw l mx my">   public getUPhone(model: string, screen: number, <br/>     memory: number, sn: number) {<br/>       const flyweight: UPhoneFlyweight = <br/>         UPhoneFactory.flyweightFactory.get(<br/>           model, screen, memory<br/>         );<br/>       return new UPhone(flyweight, sn);<br/>  }<br/>}</span></pre><p id="2e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nw nx ny mp b">UPhoneFactory</code>类，我们可以通过以下方式创建10，000个UPhone对象:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="37ba" class="mt mu it mp b gy mv mw l mx my">const uphoneFactory = new UPhoneFactory();</span><span id="3a16" class="mt mu it mp b gy mz mw l mx my">let uphones = [];<br/>for (let i = 0; i &lt; 10000; i++) {<br/>  let memory = i % 2 == 0 ? 64 : 128;<br/>  uphones.push(uphoneFactory.getUPhone("8U", 5.0, memory, i));<br/>}</span><span id="1cee" class="mt mu it mp b gy mz mw l mx my">console.log(<br/>  "UPhoneFlyweight count:",<br/>  UPhoneFactory.flyweightFactory.phonesMap.size<br/>);</span></pre><p id="6db8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您成功运行上述代码时，终端将输出以下结果:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="deb4" class="mt mu it mp b gy mv mw l mx my">UPhoneFlyweight count: 2</span></pre><p id="9aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的结果来看，虽然我们创建了10000个UPhone对象，但是我们只创建了两个<code class="fe nw nx ny mp b">UPhoneFlyweight</code>对象。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="7d3d" class="mt mu it mp b gy mv mw l mx my">class UPhoneFlyweight {<br/>  constructor(model: string, screen: number, memory: number) {}<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/657b1ff6bc99f06330287c1243e1fcff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dknkZuhAEcCaD2Fxs8NdCg.jpeg"/></div></div></figure><p id="4196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们总结一下flyweight模式的使用场景:</p><ul class=""><li id="bf4e" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">一个程序使用大量相似的对象，造成很大的内存开销；</li><li id="2605" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">一个对象的大部分状态可以变成外部的，通过剥离一个对象的外部状态，可以用相对较少的共享对象来替换大量的对象。</li></ul><p id="c676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="3d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题，请随时给我留言。稍后我会继续介绍其他模式，如果你有兴趣，可以在<a class="ae ky" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或<a class="ae ky" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="bbec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想学习TypeScript，那么不要错过<strong class="lb iu">掌握TypeScript </strong>系列。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/frontend-canteen/with-these-articles-you-will-not-be-confused-when-learning-typescript-d96a5c99e229" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">有了30+篇文章，学习TypeScript就不会迷茫了</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">通过生动的动画，让你轻松了解TypeScript的难点和核心知识！不断地…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="oj l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>