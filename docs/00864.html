<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kubernetes-deployments-101-967689d68d30?source=collection_archive---------4-----------------------#2019-08-28">https://levelup.gitconnected.com/kubernetes-deployments-101-967689d68d30?source=collection_archive---------4-----------------------#2019-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><p id="d6f3" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated"><em class="jq">本文最初发表于https://www.magalix.com/blog/kubernetes-deployments-101</em><a class="ae jr" href="https://www.magalix.com/blog/kubernetes-deployments-101" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="d23d" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Kubernetes部署101</h1><p id="2115" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">在另一篇文章中，我们讨论了<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-101-concepts-and-why-it-matters" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>复制集。然而，<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-replicaset-101" rel="noopener ugc nofollow" target="_blank">ReplicaSet</a>有一个主要的缺点:一旦你选择了由replica set管理的<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-pods-101-the-cluster-sailors" rel="noopener ugc nofollow" target="_blank">pod</a>，你就不能改变它们的pod模板。因此，例如，如果您使用一个复制集来部署四个运行NodeJS的pod，并且您想要将NodeJS映像更改为一个较新的版本，您需要删除复制集并重新创建它。重启pod会导致停机，直到映像可用且pod再次运行。</p><p id="3f21" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">部署资源使用复制集来管理pod。但是，它以可控的方式处理更新。让我们更深入地研究部署控制器和<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-patterns-declarative-deployments" rel="noopener ugc nofollow" target="_blank">模式</a>。</p><p id="0928" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">让我们快速演示一下Kubernetes部署可以做什么。以下部署定义部署了四个以Apache作为其托管应用程序的pod:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ee61" class="le jt it la b gy lf lg l lh li">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: apache-deployment<br/>  labels:<br/>    role: webserver<br/>spec:<br/>  replicas: 4<br/>  selector:<br/>    matchLabels:<br/>      role: webserver<br/>  template:<br/>    metadata:<br/>      labels:<br/>        role: webserver<br/>    spec:<br/>      containers:<br/>      - name: frontend<br/>        image: httpd<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="dfc3" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">将上述内容保存在一个文件中。在本例中，我将文件命名为apache_deployment.yaml。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="a397" class="le jt it la b gy lf lg l lh li">kubectl apply -f apache_deployment.yaml --record</span></pre><p id="87ae" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">请注意在命令末尾使用了— record标志。虽然不是必需的，但这是一个您应该遵循的好习惯。— record标志将发布部署的命令保存在列表中。在本文的后面，您将看到保存这些信息的价值。几秒钟后，您就可以通过运行kubectl get pods来检查pods的状态。您应该会看到三个pod正在运行。</p><p id="4429" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">让我们看一下我们用来启动这些pod的定义文件:</p><ul class=""><li id="b7d8" class="lj lk it iu b iv iw iz ja jd ll jh lm jl ln jp lo lp lq lr bi translated">该文件以接受部署API对象的apiVersion开始。目前是apps/v1。</li><li id="aaab" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">然后我们有资源的类型:部署。</li><li id="a512" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">在元数据中，我们定义了这个部署的名称及其标签。</li><li id="69c2" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">spec字段定义了我们需要这个部署来维护多少个pod。它还包含控制器用来获取目标吊舱的选择标准。matchLabels字段以标记为role=webserver的窗格为目标。</li><li id="c9b8" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">规格字段也有用于创建(或重新创建)pod的pod模板。</li><li id="c3aa" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">spec.template.metadata定义了新pod将具有的标签。</li><li id="5c76" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">spec.template.spec部分具有实际的容器定义(由容器字段拥有)。在我们的例子中，我们定义了容器名和它监听的端口(HTTP 80)。</li></ul><p id="9acc" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">到目前为止，我们的部署所做的一切与典型的<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-replicaset-101" rel="noopener ugc nofollow" target="_blank">复制集没有什么不同。</a>部署的真正威力在于它能够更新<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-pods-101-the-cluster-sailors" rel="noopener ugc nofollow" target="_blank">窗格</a>模板，而不会导致应用程序中断。</p><p id="6955" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">假设您已经完成了Apache服务器2.4版的测试，并且准备在生产中使用它。当前的pod使用的是较旧的Apache版本。以下命令将部署窗格模板更改为使用新映像:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="8024" class="le jt it la b gy lf lg l lh li">kubectl set image deployment apache-deployment apache=httpd:2.4</span></pre><p id="086d" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">上面的命令将名为apache的容器的图像标记更改为使用httpd标记的图像2.4，而不是2。实现这一点的另一种方法是使用如下命令直接编辑部署配置YAML:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="b5a1" class="le jt it la b gy lf lg l lh li">kubectl edit deployment apache-deployment</span></pre><p id="4ac6" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">然后，向下滚动到pod模板部分，并更改httpd图像标记。一旦保存了配置，部署就开始逐个更新pod。您可以通过发出以下命令来查看此操作的实际进度:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4626" class="le jt it la b gy lf lg l lh li">kubectl rollout status deployment apache-deployment</span></pre><p id="8ab1" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">输出显示了更新进度，直到所有的窗格都使用了新的容器映像。</p><p id="1a88" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">Kubernetes部署在决定如何滚动更新时使用的算法是保持至少25%的pod运行。因此，它不会杀死旧的豆荚，除非有足够数量的新豆荚出现。同样，直到足够多的pod不再运行，它才创建新的pod。通过这种算法，应用程序在更新期间总是可用的。</p><p id="92bb" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">您可以使用以下命令来确定部署正在使用的更新策略:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="fac4" class="le jt it la b gy lf lg l lh li">kubectl describe deployments | grep Strategy</span></pre><p id="cb6c" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">输出如下所示:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="e2f5" class="le jt it la b gy lf lg l lh li">StrategyType: RollingUpdateRollingUpdateStrategy: 25% max unavailable, 25% max surge</span></pre><p id="ec4f" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">我们在这里使用grep过滤掉命令的输出，以揭示它是如何更新pod的。如果我们删除过滤器，我们会发现一些关于部署步骤的有价值的信息。让我们看看:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="b463" class="le jt it la b gy lf lg l lh li">Events:<br/>  Type    Reason             Age    From                   Message<br/>  ----    ------             ----   ----                   -------<br/>  Normal  ScalingReplicaSet  28m    deployment-controller  Scaled up replica set apache-deployment-6bdd4b58db to 4<br/>  Normal  ScalingReplicaSet  4m38s  deployment-controller  Scaled up replica set apache-deployment-67fd555f74 to 1<br/>  Normal  ScalingReplicaSet  4m38s  deployment-controller  Scaled down replica set apache-deployment-6bdd4b58db to 3<br/>  Normal  ScalingReplicaSet  4m38s  deployment-controller  Scaled up replica set apache-deployment-67fd555f74 to 2<br/>  Normal  ScalingReplicaSet  4m34s  deployment-controller  Scaled down replica set apache-deployment-6bdd4b58db to 2<br/>  Normal  ScalingReplicaSet  4m34s  deployment-controller  Scaled up replica set apache-deployment-67fd555f74 to 3<br/>  Normal  ScalingReplicaSet  4m33s  deployment-controller  Scaled down replica set apache-deployment-6bdd4b58db to 1<br/>  Normal  ScalingReplicaSet  4m33s  deployment-controller  Scaled up replica set apache-deployment-67fd555f74 to 4<br/>  Normal  ScalingReplicaSet  4m32s  deployment-controller  Scaled down replica set apache-deployment-6bdd4b58db to 0</span></pre><p id="5117" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">您应该在命令输出的末尾找到它。它展示了部署如何首先创建具有四个单元的复制集。然后，它使用了一个只有一个豆荚的新复制集。在那之后，它会立刻杀死旧复制体的一个豆荚。如你所见，它不断从旧的复制集中杀死豆荚，并扩大新的，直到它取代所有豆荚。</p><p id="97c1" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">让我们通过运行kubectl get rs来仔细检查我们是否创建了两个复制集。输出应该类似于以下内容:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="abe0" class="le jt it la b gy lf lg l lh li">NAME DESIRED CURRENT READY AGE apache-deployment-67fd555f74 4 4 4 19m apache-deployment-6bdd4b58db 0 0 0 43m</span></pre><p id="712a" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">旧的复制集没有豆荚，而新的有所有的四个豆荚。</p><h1 id="e82a" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Kubernetes部署策略概述</h1><h1 id="018d" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">滚动更新</h1><p id="ebb5" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">如果要使用滚动更新策略，不需要在定义文件中指定任何参数。然而，你可能想要微调如何处理旧荚到新荚的过渡。例如，Kubernetes自动决定它需要保持至少75%的pod可用。也就是说，只有25%的pod(例如，四分之一的pod可能会在更新过程中停机)。如果您想覆盖这种行为，可以添加. spec.strategy.type，如下所示:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="7a5f" class="le jt it la b gy lf lg l lh li">spec: strategy: type: RollingUpdate rollingUpdate: maxSurge: 1 maxUnavailable: 50%</span></pre><p id="0bff" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">通过将maxUnavailable参数设置为50%,我希望Kubernetes在更新期间关闭一半的正在运行的pod。这个数字可以是百分比，也可以是整数。</p><h1 id="0296" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">重新创建更新</h1><p id="b430" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">重建策略将立即关闭所有旧的吊舱，然后启动新的吊舱。这显然会造成停机。然而，有时这是必要的。例如，如果您发现应用程序中存在严重的安全缺陷，并且需要立即切换到新的修补映像。您不需要您的任何客户使用旧的易受攻击的版本，因为这可能会对您的商业信誉产生负面影响。这里需要重新创建部署策略，即使这会使应用程序停机一会儿。也许你可以显示一个友好的“维护中”的消息，直到更新完成。</p><figure class="kv kw kx ky gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lx"><img src="../Images/df3011ba51dc24f6095bbb8c0a288014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jBwAMxGAlgkt737i.jpg"/></div></div></figure><figure class="kv kw kx ky gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mf"><img src="../Images/6acf98c514607348a8a5e29f39fe1efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MqQsnO1iYeHLf68v.jpg"/></div></div></figure><p id="09c9" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">工程师可能需要使用其他类型的部署策略。在撰写本文时，Kubernetes部署只支持rollingupdate和recreate策略。但是，在其他控制器(如服务)的帮助下，您可以实现更复杂的场景，如:</p><ul class=""><li id="b230" class="lj lk it iu b iv iw iz ja jd ll jh lm jl ln jp lo lp lq lr bi translated"><a class="ae jr" href="https://martinfowler.com/bliki/BlueGreenDeployment.html" rel="noopener ugc nofollow" target="_blank">蓝/绿部署</a>:您有两个不同版本的应用程序，最新版本(绿色)和正在运行的版本(蓝色)。一旦绿色部署就绪，您就可以配置服务来选择新的Pod(通过Pod选择器)。如果一切顺利，您还可以将蓝色版本更新为最新版本，并将其用作暂存环境。</li><li id="3f89" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">金丝雀放生:以过去煤矿工人遵循的安全技术命名。他们带来了一个笼子，里面装着一些金丝雀，并把它放在未被发现的矿井的入口处。如果鸟死了，这表明有毒的一氧化碳排放的存在。除此之外，矿工们都准备好了。在软件发布中，金丝雀类型需要将一部分用户引导到应用程序的新版本，并测试他们的反馈。大多数用户仍在使用旧的稳定版本。如果没有发现问题，越来越多的用户会被引导到新版本，直到它完全发布。在Kubernetes中，这可以通过创建另一个副本数量较少的部署(Canary实例)来实现。根据测试结果，可以扩大部署规模或完全终止部署。</li></ul><p id="579c" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">一旦部署控制器检测到pod模板中的变化(即更新)，它就创建一个新的副本集，并开始将pod转出到该新的副本集，直到它移动所有的副本集。但是，有时您可能希望在现有更新仍在进行时发布新的更新。我们来举个例子。</p><p id="31b4" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">假设您正在将十个应用程序pods更新到版本1.1 (image myapp:1.1)。而且，当更新正在进行时，QA团队通知您他们刚刚完成了1.12版本的测试，可以部署了。因此，您决定中断正在运行的更新，继续使用最新版本(image myapp:1.2)。在后台，部署使用新的ReplicaSet，并且在检测到新的部署请求时，已经移动了三个pod来使用myapp:1.1映像。它立即创建另一个副本集，杀死三个移动的pod，并开始使用myapp:1.2扩展最新的副本集。换句话说，它不会等待全部十个pods完成升级到myapp:1.1，然后开始将它们迁移到myapp:1.2。相反，它会中止现有的操作，并立即启动新的操作。这种操作被称为翻转更新，它是一种强大的技术，可以确保您的pod在最短的时间内始终处于所需的状态，并且没有停机时间。</p><p id="f96b" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">Kubernetes部署允许您回滚更新。有许多情况下，当您想要撤消更改时。假设客户开始抱怨在QA阶段没有检测到的bug，因此，您需要将应用程序恢复到以前的版本，直到bug被修复。例如，假设我们决定为您的web层使用Nginx而不是Apache。您发出了以下命令来进行更改:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ae6b" class="le jt it la b gy lf lg l lh li">kubectl set image deployment apache-deployment frontend=nginx:1.7.9 --record</span></pre><p id="cf3b" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">不一会儿，所有的豆荚都使用Nginx作为他们的网络服务器。然后，您意识到应用程序存在性能问题，客户开始抱怨。您需要配置pod以再次使用Apache。在这个回滚过程中应该没有停机时间。</p><p id="d7fb" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">Kubernetes部署控制器跟踪已经完成的每一次部署(直到一个可配置的限制)。Kubernetes只考虑pod模板中的更改，并将它们保留在历史记录中。例如，如果更改是增加或减少正在运行的pod的数量，则不能算作记录。</p><p id="fbf9" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">回到我们的例子。要将部署回滚到以前的部署，您需要首先列出最近的更改。以下命令输出部署历史记录:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="7819" class="le jt it la b gy lf lg l lh li">kubectl rollout history deployment apache-deployment</span></pre><p id="6043" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">您应该会看到以下输出:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="47f1" class="le jt it la b gy lf lg l lh li">REVISION CHANGE-CAUSE 1 kubectl apply --filename=apache_deployment.yaml --record=true 2 kubectl set image deployment apache-deployment frontend=nginx:1.7.9 --record=true</span></pre><p id="78c9" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">变更原因包含发出的导致变更的命令。如果不使用— record标志，该字段将等于None。</p><p id="149c" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">要回滚最新部署并返回到以前的状态，请运行以下命令:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="c107" class="le jt it la b gy lf lg l lh li">kubectl rollout undo deployment apache-deployment</span></pre><p id="acd0" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">Kubernetes部署启动了一个类似于将pod升级到Nginx时使用的过程。过一会儿，所有的豆荚再次运行阿帕奇。</p><p id="4ce9" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">有时，您可能希望回滚到特定的部署。假设你在换Nginx之前，做了从httpd image 2.4到2.4.39的升级。您希望恢复使用httpd:2.4。那是两次部署。通过使用-to-revision标志，可以指定希望部署回滚到的确切版本号。例如:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="409c" class="le jt it la b gy lf lg l lh li">kubectl rollout undo deployment apache-deployment --to-revision=1</span></pre><p id="2ef0" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">因为部署在内部使用复制集来管理pod，所以它们也支持向上或向下扩展。让我们扩展我们的apache部署，运行六个而不是四个pod:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="758d" class="le jt it la b gy lf lg l lh li">kubectl scale deployment apache-deployment --replicas=6</span></pre><p id="7ad3" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">如果您现在使用kubectl get pods检查pod，您将看到部署正在创建另外两个pod。</p><p id="011c" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">您还可以使用<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-autoscaling-101" rel="noopener ugc nofollow" target="_blank">Horizontal Pod auto scaling(HPA)</a>根据节点上的CPU负载自动增加或减少部署中的单元数量。以下命令</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ad45" class="le jt it la b gy lf lg l lh li">kubectl autoscale deployment apache-deployment --min=6 --max=10 --cpu-percent=70</span></pre><p id="64c4" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">根据节点上的CPU负载量从部署中添加或删除单元。它确保pod的平均CPU负载为70%。随着负载的增加，部署会产生更多的吊舱，多达10个。当负载较少时，部署会杀死额外的吊舱，只要它们的数量不少于6个。你可以在这里阅读更多关于部署使用的自动缩放算法<a class="ae jr" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#algorithm-details" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6df4" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated"><strong class="iu mg">TL；博士</strong></p><ul class=""><li id="855e" class="lj lk it iu b iv iw iz ja jd ll jh lm jl ln jp lo lp lq lr bi translated">Kubernetes部署是您可以使用的最有效的控制器之一。它不仅维护指定数量的pod，而且还确保您想要对这些pod进行的任何更新都不会导致停机。</li><li id="d564" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">在幕后，部署使用复制集来管理pod。</li><li id="aed4" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">Kubernetes部署支持滚动更新，在这种更新中，您可以中断正在进行的部署更新，并指示部署控制器立即启动新的更新，而不会导致任何应用程序中断。</li><li id="e571" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">Kubernetes维护着最近部署的列表。您可以使用此列表来回滚更新。您也可以通过指定版本号来选择要移动到的特定部署。</li><li id="a276" class="lj lk it iu b iv ls iz lt jd lu jh lv jl lw jp lo lp lq lr bi translated">您可以使用部署来增加或减少它所管理的单元数量。您还可以通过创建或删除受最大和最小数量限制的pod来配置它以响应CPU负载。</li></ul></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="65c9" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated"><em class="jq">原载于2019年8月28日</em><a class="ae jr" href="https://www.magalix.com/blog/kubernetes-deployments-101" rel="noopener ugc nofollow" target="_blank"><em class="jq">【https://www.magalix.com】</em></a><em class="jq">。</em></p></div></div>    
</body>
</html>