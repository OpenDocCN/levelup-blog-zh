<html>
<head>
<title>Learning Haskell: Getting Started</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Haskell:入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-haskell-getting-started-9f34155456e?source=collection_archive---------9-----------------------#2020-05-14">https://levelup.gitconnected.com/learning-haskell-getting-started-9f34155456e?source=collection_archive---------9-----------------------#2020-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a1b3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">加入我学习Haskell的下一部分，我们将学习算术、函数、惰性求值等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8ace0c483e75dbb1956b97d4f81ec92e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dz48kXjXxS1HHdFm"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Paul Esch-Laurent在Unsplash的照片</figcaption></figure><p id="231a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的上一篇文章中，我们介绍了如何在您的机器上安装Haskell。如果你没有读过那篇文章，你可以在这里阅读。</p><p id="e1e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“学习Haskell”是我围绕我学习Haskell的旅程写的一系列文章，希望我也能教你一些关于Haskell的东西。</p><h1 id="cfbf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">算术</h1><p id="909e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我上一篇关于如何设置Haskell的文章的最后，我们开始通过执行一些算术来试验REPL。对于来自其他编程语言的人来说，这是非常简单明了的，所以我会尽量简短。如果你用<code class="fe mp mq mr ms b">ghci</code>或<code class="fe mp mq mr ms b">stack ghci</code>命令加载你的REPL，你可以开始加、减、乘、除整数和浮点数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/edec4d0c04c9d6f0b7e60032d93771bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*m5pg0jNbemyTehMS-DPeKw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">ghci REPL中的算术</figcaption></figure><p id="6773" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以使用括号来确保优先级。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e43c5bfdd8a1a0f393abeda8c1d3057b.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*LXTHuRPrc2c3Wm_wJTDxkA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">带括号的算术</figcaption></figure><p id="c587" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们尝试将一个整数和一个字符串相加会发生什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/cf8798879e8e76011bf326314c7eb1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*zRqFFcS-fegwf4caioxS0g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Haskell中的1+“nes pite”</figcaption></figure><p id="441f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到一个错误！这是因为“nespite”不是整数或浮点数，所以Haskell不知道如何将1和“nespite”相加，你只能将整数和浮点数相加。</p><h1 id="552a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">串并置</h1><p id="cd68" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你有两个字符串，你想创建一个连接的字符串，那么你可以使用一个<code class="fe mp mq mr ms b">++</code>来连接这些字符串。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/4b5e8d7ed64d05319896a9fe58581541.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*NmK0bhZ8QCyfg-ttILOhVw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">haskell中的字符串串联</figcaption></figure><h1 id="64b5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">布尔代数</h1><p id="d272" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这在Haskell上是非常简单的。<code class="fe mp mq mr ms b">&amp;&amp;</code>是逻辑<em class="mx">和</em>运算符，<code class="fe mp mq mr ms b">||</code>是逻辑<em class="mx">或</em>和<code class="fe mp mq mr ms b">not</code>反转布尔运算。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/c4659f63b96b971c9f721c2d57a570ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*vArngwF9SUzyJk1u7KU9vg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">haskell中的布尔代数</figcaption></figure><h1 id="eb46" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">平等</h1><p id="7000" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">同样，其他一些东西也很容易理解和实现</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/b14796ae5b9f086432add157bd4f968e.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*KMdpWAZR6uvjiPgT3-0ttQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">哈斯克尔的平等</figcaption></figure><p id="4e9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果我们试图比较像整数和字符串这样的东西，我们会得到一个错误消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/cf999ec64304790fd3737d3e9a762e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*PGayNDsFX19TPr57rYgOLw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">将1与“nespite”进行比较会导致错误</figcaption></figure><p id="ecbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为在Haskell中你只能比较两个相同类型的东西。</p><h1 id="9db8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">功能</h1><p id="4b01" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您习惯于命令式语言，那么当您第一次看到Haskell中的函数时，可能会觉得有点奇怪。这是因为在Haskell中调用函数不使用括号，传递给函数的参数也不用逗号分隔。</p><p id="66d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以<code class="fe mp mq mr ms b">max</code>函数为例。这个函数有两个参数，告诉你哪个最大。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/516969d9b298b2e2793c995b303d1cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*nIyIQJUMMapfbzzzVRBc8w.png"/></div></figure><h2 id="ae90" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">定义你自己的</h2><p id="b513" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可以这样定义你自己的函数；</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1597" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是一个函数名，然后是一个空格，然后是用空格分隔的参数，后面是一个等号，然后是你的实现。Haskell使用隐式返回，所以上面的函数将返回<code class="fe mp mq mr ms b">X * 2</code></p><p id="4d9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在REPL中使用该功能，请将该功能保存到文件中。在这种情况下，我把它保存到一个名为<code class="fe mp mq mr ms b">double.hs</code>的文件中，然后我可以用<code class="fe mp mq mr ms b">:l</code>把它加载到REPL中</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/8c67727a89b689ea032479b43a4ed394.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*BVcMXdfeOY9PehzSknxKXw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">将模块加载到REPL</figcaption></figure><h1 id="88a5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">纯函数</h1><p id="2e7a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我看来，这是Haskell的优点之一。事实上，它是一种纯粹的函数式编程语言，这意味着几乎所有的表达式都没有副作用，也不会改变全局状态。</p><p id="3331" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着，如果我们有一个函数，给定相同的参数，它将总是产生相同的输出。</p><h1 id="5231" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">不变的</h1><p id="f637" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Haskell中的表达式是不可变的，这意味着它们在被求值后不能改变。所以任何时候你写一些代码，你认为可能会操作一个变量，它实际上创建了这个变量的一个新版本。</p><p id="cfb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当人们第一次听说Haskell是不可变的时，他们认为不断创建新版本的东西不会很有效率，但它实际上非常有效率，因为Haskell并没有制作某个东西的全新副本——它引用了它正在复制的东西。这意味着如果你改变了第一个东西，它也会更新并改变第二个东西，但是因为它是不可变的，所以你不能改变第一个东西。</p><h1 id="7500" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">条件式</h1><p id="3afe" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在Haskell中，条件是另一个相对容易掌握的东西。在Haskell中，条件是通过一个<code class="fe mp mq mr ms b">if</code>语句提供的，这是每个使用命令式语言的人都应该熟悉的。与其他一些编程语言相比，Haskell的一个不同之处是你必须提供一个else。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/6b995c7d382bf85db8513769c6438a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*3cTiuCVCWrHWe5OVSEFM9A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">haskell中if语句的示例</figcaption></figure><h1 id="b792" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">懒惰评估</h1><p id="5d3d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">哈斯克尔很懒。Haskell不会在表达式被赋给变量时对其求值，而是将求值推迟到需要结果的最后一刻。这可能会导致一些有趣的场景，因为它给了Haskell处理无限数据的能力。当我们浏览列表的时候，我们会更深入地研究这个懒惰的评估。</p><h1 id="4daf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="a9f5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你已经完成了入门。请随意休息一下，因为一次要吸收很多信息。花些时间玩玩REPL，在头脑中巩固这些概念。</p><p id="efa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，你学到了:</p><ul class=""><li id="c335" class="nr ns iq ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated">Haskell中的算术</li><li id="f10e" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">使用括号表示优先顺序</li><li id="9079" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">如何在Haskell中连接字符串</li><li id="a9d7" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">如何在Haskell中执行布尔代数</li><li id="4f43" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">如何使用等式运算符</li><li id="e68a" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">如何定义函数</li><li id="d074" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">如何将模块加载到REPL</li><li id="71b3" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">Haskell是一种纯函数式编程语言</li><li id="be0e" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">Haskell是不可变的</li><li id="98d1" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">如何用Haskell编写if语句</li><li id="9720" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">哈斯克尔很懒</li></ul><p id="ac36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我以后关于Haskell的文章中，我们将开始深入研究递归、列表、元组、模式匹配、保护、Case表达式、本地绑定等等。</p><p id="ef06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这篇文章有助于你学习Haskell，请写下评论或鼓掌让我知道。</p></div></div>    
</body>
</html>