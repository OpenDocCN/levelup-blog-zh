<html>
<head>
<title>Developing a Website Scraper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发一个网站刮刀</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/developing-a-website-scraper-b7a78bb5544a?source=collection_archive---------1-----------------------#2022-01-14">https://levelup.gitconnected.com/developing-a-website-scraper-b7a78bb5544a?source=collection_archive---------1-----------------------#2022-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5a56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我学到的东西，用Python写的</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/38499989e593a4dc944e8e87242913db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPa9L1OaJWxZgl3g6ftqlQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=4963715" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="eb2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从网站检索信息是分析数据的企业的常见需求。因此，他们可能会要求你开发一个网站抓取器来自动化这个过程。网站抓取器是一种获取网站页面并试图识别对商业有用的信息的程序。</p><p id="c74a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看我们的武器库中有哪些工具可以开发这样的刮刀。本文主要关注Python工具，但它同样适用于其他流行的编程语言。</p><h1 id="0617" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">网站地图</h1><p id="c649" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了从网站中挖掘信息，你需要得到它的页面列表。站点地图是一个非常有效的工具，可以抓取一个网站所有页面的URL。网站地图以名称<code class="fe mj mk ml mm b">sitemap.xml</code>存储在网站的根路径中，它们包含这里指定的格式<a class="ae le" href="https://www.sitemaps.org/protocol.html" rel="noopener ugc nofollow" target="_blank">的信息</a>。</p><p id="065d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，看看https://www.playstation.com/网站的地图文件。这是得到它的链接:<a class="ae le" href="https://www.playstation.com/sitemap.xml" rel="noopener ugc nofollow" target="_blank">https://www.playstation.com/sitemap.xml</a>。</p><p id="588c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是它的摘录:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2de2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个<code class="fe mj mk ml mm b">loc</code>标签都有文本，它是网站上一个页面的URL。</p><h2 id="0425" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">获取远程内容</h2><p id="b067" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">但是我们如何获取网站地图呢？我们如何在本地获取<code class="fe mj mk ml mm b">sitemap.xml</code>页面的内容？</p><p id="46fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b"><strong class="js iu">requests</strong></code> <strong class="js iu">库</strong></p><p id="5a18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae le" href="https://docs.python-requests.org/en/latest/" rel="noopener ugc nofollow" target="_blank">请求Python库</a>的帮助下，获取网站地图的XML源很容易。</p><p id="7632" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">requests</code>图书馆有一个非常丰富的界面。使用这个库获取站点地图的XML内容的一个简单方法是:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2c4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上将获取Playstation网站sitemap的XML源。</p><p id="ec9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">page.text</code>将以Python的形式返回XML源代码<code class="fe mj mk ml mm b">str</code>。</p><p id="351c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<code class="fe mj mk ml mm b">requests.get()</code>方法从网站获取站点地图文件和实际页面。但是，对于实际的页面，我们将在稍后讨论。现在，我还想提一下，当我使用<code class="fe mj mk ml mm b">requests.get()</code>方法时，我还会注意以下技术细节:</p><p id="4f12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">用户代理</strong></p><p id="1b61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过简单地给出您想要获得源代码的页面的URL来使用<code class="fe mj mk ml mm b">requests.get()</code>，并不总是足够的。我建议你也把<code class="fe mj mk ml mm b">User-Agent</code>标题发送过来。<code class="fe mj mk ml mm b">User-Agent</code>应该设置为一个字符串，向对方暗示你的脚本是一个浏览器。这里有一个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="dd74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能还想将<code class="fe mj mk ml mm b">User-Agent</code>设置为一个值，以表明您的脚本是一个移动设备浏览器。当您希望看到站点为移动设备用户返回的内容时，这可能会很有用。一些网站根据客户端设备类型返回不同的内容<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent" rel="noopener ugc nofollow" target="_blank">，尽管这可能不是一个好主意</a>。</p><p id="7de5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了便于参考，<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent" rel="noopener ugc nofollow" target="_blank">本页</a>列出了最常见的用户代理字符串。</p><p id="7ba2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">超时</strong></p><p id="632d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当使用<code class="fe mj mk ml mm b">requests</code>库获取网站页面的源代码时，你应该考虑的另一个非常重要的因素是超时。你不会想让你的电话在一个没有响应或返回页面非常慢的网站上永远等待。</p><p id="2bee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了防止您的<code class="fe mj mk ml mm b">requests.get()</code>调用在特定页面上永远等待，您可以如下设置<code class="fe mj mk ml mm b">timeout</code>参数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a667" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，我们设置了2个超时值，其中<code class="fe mj mk ml mm b">REQUEST_CONNECT</code>设置为5秒，而<code class="fe mj mk ml mm b">REQUEST_READ</code>设置为10秒。您可以尝试不同的值，并根据自己的喜好调整请求超时。</p><p id="3e3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">处理错误</strong></p><p id="374a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">连接到页面以检索其内容的尝试可能会因为各种原因而失败。因此，我建议您将您的<code class="fe mj mk ml mm b">requests.get()</code>调用包装在一个<code class="fe mj mk ml mm b">try..except</code>块中，如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3736" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看上面的第10行。如果响应状态代码大于或等于<code class="fe mj mk ml mm b">400</code>，则<code class="fe mj mk ml mm b">response.raise_for_status()</code>将引发<code class="fe mj mk ml mm b">requests.exceptions.HttpError</code>异常。因此，该行是可选的。您可能不希望使用异常对这些情况进行分支。</p><p id="d224" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在任何情况下，<code class="fe mj mk ml mm b">requests.exceptions.RequestException</code>都是<code class="fe mj mk ml mm b">requests.get()</code>可能引发的所有异常的父类。捕捉它并相应地分支您的代码是一个很好的实践。</p><h2 id="be45" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">解析Sitemap.xml</h2><p id="1b2c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">因此，使用<code class="fe mj mk ml mm b">requests.get(..../sitemap.xml)</code>我们可以获得远程网站的站点地图文件。</p><p id="f86d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">找到所有<code class="fe mj mk ml mm b">loc</code>标签并获取其内容的最简单方法是什么？人们肯定可以使用一些字符串匹配和正则表达式工具来解析<code class="fe mj mk ml mm b">sitemap.xml</code>内容的整个字符串。但是，我们将使用<a class="ae le" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank"> BeautifulSoup </a>来代替。</p><p id="a887" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个非常棒的Python库，除了其他功能之外，它还允许浏览HTML或XML文档的DOM树。因此，获取所有的<code class="fe mj mk ml mm b">loc</code>标签并迭代它们的内容以获取指向的页面就像下面这段代码一样简单:</p><p id="cb81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:为了能够使用BeautifulSoup作为XML解析器，您可能还需要安装<code class="fe mj mk ml mm b"><a class="ae le" href="https://pypi.org/project/lxml/" rel="noopener ugc nofollow" target="_blank">lxml</a></code> <a class="ae le" href="https://pypi.org/project/lxml/" rel="noopener ugc nofollow" target="_blank"> python库</a>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><ul class=""><li id="2709" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">第2行:它获取XML文档中所有的<code class="fe mj mk ml mm b">urlset</code>标签。注意，一个适当构造的<code class="fe mj mk ml mm b">sitemap.xml</code>只有1个<code class="fe mj mk ml mm b">urlset</code>。但是，上面的代码足够通用，可以与许多代码一起工作。</li><li id="a76b" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">第4行:它获取所有的<code class="fe mj mk ml mm b">loc</code>标签。</li><li id="157e" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">第5–6行:对于每个<code class="fe mj mk ml mm b">loc</code>，它将其内容<code class="fe mj mk ml mm b">loc.text</code>发送给一个解析特定网站的函数。<code class="fe mj mk ml mm b">parse_website_page()</code>函数是解析网站页面的自定义函数。</li></ul><h2 id="98ea" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">指向其他站点地图的站点地图</h2><p id="474d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">但是网站地图内容可能不是网站页面的URL。一个<code class="fe mj mk ml mm b">sitemap.xml</code>文件可能不包含带有<code class="fe mj mk ml mm b">url &gt; loc</code>标签的<code class="fe mj mk ml mm b">urlset</code>。它可能包含带有<code class="fe mj mk ml mm b">sitemap &gt; loc</code>标签的<code class="fe mj mk ml mm b">sitemapindex</code>。这些类型的<code class="fe mj mk ml mm b">sitemap.xml</code>文件指向其他站点地图文件。这是网站声明大量页面的一种方式。注意一个<code class="fe mj mk ml mm b">sitemap.xml</code>文件不能包含超过50K的URL。因此，较长的URL列表需要分成多个站点地图，而站点地图索引是将它们组合在一起的一种方式。</p><p id="a5ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以<a class="ae le" href="https://www.samsung.com/" rel="noopener ugc nofollow" target="_blank">https://www.samsung.com/</a>站点的<code class="fe mj mk ml mm b">sitemap.xml</code>文件为例。这个<code class="fe mj mk ml mm b">sitemap.xml</code>就是这个<a class="ae le" href="https://www.samsung.com/sitemap.xml" rel="noopener ugc nofollow" target="_blank">https://www.samsung.com/sitemap.xml</a>。如果您查看它的内容，您会看到类似这样的内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="dbca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，<code class="fe mj mk ml mm b">loc</code>条目是其他的<code class="fe mj mk ml mm b">sitemap.xml</code>文件。</p><p id="b596" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，您需要确保您也可以解析这种类型的<code class="fe mj mk ml mm b">sitemap.xml</code>文件，它们包含指向其他<code class="fe mj mk ml mm b">sitemap.xml</code>文件的指针/loc。</p><p id="0cc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是Python中的一段伪代码，可以启发你实现这样的逻辑:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="eaab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第10行，我们调用<code class="fe mj mk ml mm b">process_sitemapindex()</code>来处理一个站点地图索引。第17行的这个函数递归地回调站点地图索引中的每一个<code class="fe mj mk ml mm b">loc</code>条目。在某种程度上，递归将会停止，因为将会下载一个带有urlset的站点地图(而不是一个站点地图索引)。</p><h2 id="e5a7" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">压缩网站地图</h2><p id="a336" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">到目前为止，网站地图还不错。但这并没有结束。网站地图可以被压缩。</p><p id="9eb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请看这里的文件:<a class="ae le" href="https://www.huaweistore.gr/sitemap.xml" rel="noopener ugc nofollow" target="_blank">https://www.huaweistore.gr/sitemap.xml</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ea3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<code class="fe mj mk ml mm b">sitemap.xml</code>文件的内容很小，里面只有一个条目。这是一个指向单个站点地图文件的<code class="fe mj mk ml mm b">sitemapindex</code>。这个:</p><pre class="kp kq kr ks gt np mm nq nr aw ns bi"><span id="3e35" class="mp lg it mm b gy nt nu l nv nw">https://www.huaweistore.gr/Uploads/xmlFiles/huaweigr-staginglh-com_GoogleSitemap_el_00001.xml.gz</span></pre><p id="fbe2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意这里指向的文件的文件扩展名。不是<code class="fe mj mk ml mm b">.xml</code>。正是<code class="fe mj mk ml mm b">.xml.gz</code>。这意味着，如果您尝试使用<code class="fe mj mk ml mm b">requests.get()</code>方法获取该文件，您将得到一个二进制的压缩数据流。</p><p id="163e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，您不能只是开始解析响应<code class="fe mj mk ml mm b">content</code>。您必须在本地下载二进制内容并创建一个文件，然后解压缩它，然后将其解析为一个普通的<code class="fe mj mk ml mm b">sitemap.xml</code>文件。</p><p id="eba9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">本地下载文件</strong></p><p id="eb7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了将请求响应的内容下载到本地文件中，您可以使用如下代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a68b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行时参数<code class="fe mj mk ml mm b">stream</code>被设置为<code class="fe mj mk ml mm b">True</code>(第9行)。这允许你使用<code class="fe mj mk ml mm b">response.iter_content()</code>来下载大文件。每个块的大小设置为128字节，但这可以根据您自己的喜好进行调整。每次下载一个块，我们保存到本地文件(第15行)。</p><p id="c663" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">解压本地文件</strong></p><p id="cfa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，您必须解压缩本地文件。下面的函数演示了解决这个问题的一种方法:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6e76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它使用Python标准库<code class="fe mj mk ml mm b">gzip</code>来解压缩文件(第9行)并将其保存到本地的另一个文件中。然后删除原始文件(第12行)。</p><p id="7e57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在有了实际的<code class="fe mj mk ml mm b">sitemap.xml</code>内容，您可以将它发送给进行站点地图解析的函数，就好像您从远程URL获取了这个文件一样。</p><h1 id="e0f6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Robots.txt</h1><p id="f164" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这篇博文继续详细介绍如何解析网站页面内容之前，我想提一下文件<code class="fe mj mk ml mm b">robots.txt</code>，它通常可以在网站的根路径中找到。</p><p id="ead5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看这里的文件:<a class="ae le" href="https://www.huaweistore.gr/robots.txt" rel="noopener ugc nofollow" target="_blank">https://www.huaweistore.gr/robots.txt</a>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5688" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个抓取网站的程序绝对应该尊重<code class="fe mj mk ml mm b">robots.txt</code>文件的内容。该文件包含诸如哪个是站点地图文件(这样您就不必猜测)之类的信息，而且非常重要的是，它告诉您的脚本网站的哪些路径不应该被访问/解析/抓取。</p><h1 id="89da" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在没有网站地图的情况下查找网站页面</h1><p id="d8c8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">但是，如果您无法访问一个<code class="fe mj mk ml mm b">sitemap.xml</code>文件来获得一个网站的页面列表呢？</p><p id="f28a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，在这种情况下，您必须获得站点的主页，即通过访问根路径返回的主页，然后识别所有锚点并递归地访问它们。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d43efbbdf50559088f4a05c8927d5073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*XKBC4_Nbu_z9z-7YuhyWHQ.png"/></div></figure><p id="d1fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您实现这个递归过程时，您必须注意以下几点:</p><ul class=""><li id="1efb" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">跟踪访问过的页面，这样你就不会再次访问它们。如果你不保持跟踪，你将会一次又一次地访问同一个页面，这将导致一个无限循环。</li><li id="53f5" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">注意锚href链接，它会把你带离你想要解析的网站。例如，如果您使用站点<code class="fe mj mk ml mm b"><a class="ae le" href="https://www.makita.gr" rel="noopener ugc nofollow" target="_blank">https://www.makita.gr</a></code>，并且在它的任何页面上有一个锚链接，其值为<code class="fe mj mk ml mm b"><a class="ae le" href="https://www.foo.gr," rel="noopener ugc nofollow" target="_blank">https://www.foo.gr</a></code> <a class="ae le" href="https://www.foo.gr," rel="noopener ugc nofollow" target="_blank">，</a>这个锚应该被忽略。</li><li id="101b" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">规范化非绝对路径。例如，如果一个anchor href值是<code class="fe mj mk ml mm b">/products/xyz.html</code>，首先使它成为<code class="fe mj mk ml mm b"><a class="ae le" href="https://www.makita.gr/products/xyz.html" rel="noopener ugc nofollow" target="_blank">https://www.makita.gr/products/xyz.html</a></code>，然后开始使用它。换句话说，对于非绝对路径，您最好将站点的根URL放在前面。但是，这又有点复杂。如果非绝对路径不是从<code class="fe mj mk ml mm b">/</code>开始的，那么，为了规范化它，你必须在你找到锚点的当前页面前面加上完整的路径。例如，如果您正在页面<code class="fe mj mk ml mm b"><a class="ae le" href="https://www.makita.gr/products/" rel="noopener ugc nofollow" target="_blank">https://www.makita.gr/products</a></code>中寻找锚href，并且您找到了一个具有href <code class="fe mj mk ml mm b">XYZ.html</code>的锚，那么规范化的值应该是<code class="fe mj mk ml mm b"><a class="ae le" href="https://www.makita.gr/products/XYZ.html" rel="noopener ugc nofollow" target="_blank">https://www.makita.gr/products/XYZ.html</a></code>而不是<code class="fe mj mk ml mm b">https://www.makita.gr/XYZ.html</code>。</li><li id="a47d" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">你需要确保你不会去找媒体文件。锚点href可能是一个到图像、视频或PDF文档的链接。您需要通过查看href指向的资源的文件扩展名来判断href值。例如，应该忽略href值等于<code class="fe mj mk ml mm b"><a class="ae le" href="https://www.makita.gr/logo.png," rel="noopener ugc nofollow" target="_blank">https://www.makita.gr/logo.png</a></code>的锚点。</li><li id="733c" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">注意<code class="fe mj mk ml mm b">nofollow</code>超链接。一个<code class="fe mj mk ml mm b">nofollow</code>锚标签有一个值为<code class="fe mj mk ml mm b">"nofollow"</code>的<code class="fe mj mk ml mm b">rel</code> HTML属性。例如:<code class="fe mj mk ml mm b">&lt;a href="/data" rel="nofollow"&gt;Data dir&lt;/a&gt;</code>。特定网页的设计者不希望机器人跟随这个链接，这是他们表达意图的一种方式。请注意，一个页面可能在页面的头部有一个robots meta标记，它将该页面的所有锚点声明为<code class="fe mj mk ml mm b">nofollow</code>。你可能也要考虑到这一点。顺便说一句，<code class="fe mj mk ml mm b">"nofollow"</code>超链接的发明有一个非常特殊的原因。你可以在这篇非常好的文章中了解更多信息<a class="ae le" href="https://ahrefs.com/blog/nofollow-links/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="210b" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">识别超链接并访问它可能会返回一个错误，如当链接<em class="mi">断开</em>时，即不对应于现有页面时，返回404。确保你也忽略了这个链接。</li></ul><h1 id="65da" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">检查站1</h1><p id="ec51" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们已经解释了如何获取网站页面列表:</p><ul class=""><li id="b709" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">使用<code class="fe mj mk ml mm b">sitemap.xml</code>文件和/或</li><li id="5a2f" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">从主/根页面开始爬行每个页面并遍历所有超链接。</li></ul><p id="fbe9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，给定一个页面URL，我们如何有效地获取它并解析它以识别我们感兴趣的数据？</p><p id="2855" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来让我们看看。</p><h1 id="37f0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">获取和解析网站页面</h1><p id="3f54" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">基本上，有两种方法可以获取和解析网站页面的内容。</p><ol class=""><li id="ed93" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ny nh ni nj bi translated">静态地</li><li id="d8dc" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ny nh ni nj bi translated">动态地</li></ol><h2 id="f4d4" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">静态获取网站页面</h2><p id="8c47" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">使用这种技术，您得到的只是页面的HTML源代码。这不一定是坏事。如果HTML源代码包含了你需要的所有信息，那么它就能为你的目标服务。</p><p id="a972" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae le" href="https://www.makita.gr/products/%CE%BA%CE%B7%CF%80%CE%BF%CF%85.html" rel="noopener ugc nofollow" target="_blank">的HTML源代码上寻找例子，这个页面在这里</a>。它包含了足够的信息让你建立一个产品的清单。</p><h2 id="b4f3" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated"><code class="fe mj mk ml mm b">requests</code>再图书馆</h2><p id="8c22" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">您可以再次使用<code class="fe mj mk ml mm b">requests.get()</code>方法，就像当您想要获取网站的<code class="fe mj mk ml mm b">sitemap.xml</code>文件时一样。</p><p id="8a03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml mm b">requests.get()</code>可用于获取网站页面的内容。</p><p id="e11a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kp kq kr ks gt np mm nq nr aw ns bi"><span id="8046" class="mp lg it mm b gy nt nu l nv nw">response = requests.get('https://www.makita.gr')<br/>response.content</span></pre><p id="9fec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，当然，我们建议您使用相同的增强版本，包括用户代理头、超时和异常处理。</p><h2 id="9ca3" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">又是美丽的声音</h2><p id="077f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">一旦您有了页面的HTML内容(<code class="fe mj mk ml mm b">response.content</code>)，您就可以依靠<a class="ae le" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank"> BeautifulSoup </a>来解析它，并在它的HTML标签和属性中识别感兴趣的信息。</p><p id="4b5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，以下标识了页面<a class="ae le" href="https://www.makita.gr/products/%CF%80%CE%BD%CE%B5%CF%85%CE%BC%CE%B1%CF%84%CE%B9%CE%BA%CE%AC-%CF%80%CE%B9%CF%83%CF%84%CE%BF%CE%BB%CE%AD%CF%84%CE%B1-%CE%B3%CE%B9%CE%B1-sds-plus.html" rel="noopener ugc nofollow" target="_blank">https://www.makita.gr/products/πνευματικά-πιστολέτα-για-sds-plus.html</a>中的所有产品代码</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><ul class=""><li id="bc69" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">第5行:我们用页面内容和<code class="fe mj mk ml mm b">'html.parser'</code>参数初始化<code class="fe mj mk ml mm b">BeautifulSoup()</code>。</li><li id="b36f" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">第6行:我们使用CSS选择器来选择我们感兴趣的标签。</li><li id="9a1c" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">第7行:<code class="fe mj mk ml mm b">anchor.text</code>返回<code class="fe mj mk ml mm b">&lt;a&gt;</code>锚的文本内容，在这个特定的例子中，包含产品代码。</li></ul><p id="ede6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！现在让我们来看另一种获取和解析网页内容的技术。</p><h2 id="a01f" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">动态获取网站页面</h2><p id="18ab" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果网页使用JavaScript在浏览器上动态构建内容，用<code class="fe mj mk ml mm b">requests.get()</code>获取网页内容是不够的。</p><p id="784d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://www.samsung.com/us/mobile/phones/all-phones/" rel="noopener ugc nofollow" target="_blank">这是一个动态构建内容的网站页面</a>的例子。如果您使用您的浏览器或使用<code class="fe mj mk ml mm b">requests.get()</code>检查页面的HTML源代码，您将不会找到当您使用浏览器打开此页面时可以直观看到的产品。这个页面使用JavaScript在浏览器端构建DOM。它不是在服务器端构建的。</p><p id="5542" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">硒</strong></p><p id="6f3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了获取一个网站页面并执行它包含的JavaScript代码，以便您可以拥有所有动态构建的内容，您需要使用一个类似于<a class="ae le" href="https://www.selenium.dev/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>的工具。Selenium的工作原理类似于浏览器。它获取一个网站页面并加载它，就像它是一个浏览器。然后它给你一个API来访问动态构建的页面的DOM。该API与<code class="fe mj mk ml mm b">BeautifulSoup()</code> API有相似之处，但它也有更多的功能，允许您在JavaScript级别工作。</p><p id="dc59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，Selenium需要在您的系统中安装一个浏览器来执行它的工作。</p><p id="34a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用<code class="fe mj mk ml mm b">chromedriver</code>二进制文件(<a class="ae le" href="https://chromedriver.chromium.org/downloads" rel="noopener ugc nofollow" target="_blank">从这里下载</a>)并让Selenium调用这个二进制文件来获取页面和模拟web浏览器。</p><p id="9386" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，给定一个web页面URL，我使用Selenium获取并解析它:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c232" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上适用于页面<a class="ae le" href="https://www.samsung.com/us/mobile/phones/all-phones/" rel="noopener ugc nofollow" target="_blank">https://www.samsung.com/us/mobile/phones/all-phones/</a>。</p><p id="469c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您在加载后检查该页面的元素(您可以使用Chrome开发人员工具来完成)，您会看到它将其产品包装到如下部分:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/7e8472ec14a4e7cc695f9c6fdcb633e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkskHlpBTcFsGXjy0Hzj1g.jpeg"/></div></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="f956" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以将模型代码视为属性<code class="fe mj mk ml mm b">data-modelcode</code>的值的HTML属性。</p><p id="774b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，上面的Python代码示例使用选择器<code class="fe mj mk ml mm b">'section[data-modelcode]'</code>来选择所有的部分。然后对于每个选中的部分，它调用<code class="fe mj mk ml mm b">.get_attribute('data-modelcode')</code>来获取相应HTML属性的值。</p><p id="1d56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请同时注意以下几点:</p><ul class=""><li id="289f" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">第14–21行:这是我用来在加载了Selenium的页面上查找元素的函数。寻找元素的方法是<code class="fe mj mk ml mm b">#find_elements()</code>，这里记录了<a class="ae le" href="https://selenium-python.readthedocs.io/api.html" rel="noopener ugc nofollow" target="_blank">。重点是我将它包装成一个<code class="fe mj mk ml mm b">try...except</code>块，并请求<code class="fe mj mk ml mm b">WebDriverWait().until()</code>方法的帮助。这个方法允许我定义一个超时来等待一个元素出现在页面上。这对于JavaScript加载的内容非常重要。因为当我们调用<code class="fe mj mk ml mm b">#find_elements()</code>的时候，我们正在寻找的东西可能还没有被加载。</a></li><li id="dc4c" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">第24–28行:看我如何初始化驱动程序来使用Chrome的一个无头版本。注意，我已经下载了<code class="fe mj mk ml mm b">chromedriver</code>二进制文件，在初始化webdriver时，我在第28行给出了它的位置/路径。</li></ul><p id="b7ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">点击用户界面元素</strong></p><p id="5556" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我在这里谈论的是动态构建的页面，所以我想特别提到这样一个事实:有时候，用<code class="fe mj mk ml mm b">driver.get()</code>加载页面可能是不够的。由于用户与页面上的元素交互，有些页面会加载更多的内容。例如，他们可能在用户点击标签页标题时就加载标签页的内容。</p><p id="3c68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个可能令人困惑的相关问题如下。内容可能被加载，但是<code class="fe mj mk ml mm b">find_elements()</code>可能不会返回它。这是一个你可能会挠头想知道为什么的时刻。答案可能是您必须使用包含不可见内容的CSS选择器，例如，选项卡后面的内容，或者您可能需要单击某个元素以使内容可见。</p><p id="13dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想成为Selenium方面的专家，您需要大量使用它并研究它的文档。它非常富有和强大。你甚至可以让它执行JavaScript代码，响应浏览器提示等等</p><p id="e878" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">硒IDE </strong></p><p id="c4e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我结束这篇文章关于Selenium的部分之前，我想提一下，当你在寻找写你的抓取，或者自动化测试，脚本的方法时，一个非常有用的工具正在等着你。它叫做<a class="ae le" href="https://www.selenium.dev/selenium-ide/" rel="noopener ugc nofollow" target="_blank">硒IDE </a>。你可以抓取一个网站页面，快速抓取正确的CSS选择器。此外，您可以与页面进行交互，IDE可以生成一个Python脚本，您可以在以后进一步调整该脚本并将其与您的项目集成。</p><h1 id="f321" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不明显但非常有用的信息</h1><p id="e951" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们已经看到了一些可以用来获取和解析网站页面的基本工具。到目前为止，我们已经讨论了如何从网站页面的元素中获取内容。通常人们停留在真实用户访问网站页面时可以看到的视觉元素上。但是，网站页面不仅仅是用户可以看到的。</p><h2 id="7787" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">打开图形标签</h2><p id="94f0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">页面可能有一些遵循<a class="ae le" href="https://ogp.me/" rel="noopener ugc nofollow" target="_blank">开放图协议</a>的特殊标签，它们被称为开放图标签或OG标签。</p><p id="89c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发明这些是为了支持向社交媒体共享网站页面URL。它们被社交媒体平台解析并显示给用户。</p><p id="1fe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果你在这个页面上<a class="ae le" href="https://www.samsung.com/us/smartphones/galaxy-z-fold3-5g/" rel="noopener ugc nofollow" target="_blank">https://www.samsung.com/us/smartphones/galaxy-z-fold3-5g/</a>，你会看到它有以下og标签:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="09f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您仍然可以使用BeautifulSoup API或Selenium API来获取<code class="fe mj mk ml mm b">content</code>属性的值。例如，上面的<code class="fe mj mk ml mm b">og:title</code>给出了该页面所针对的产品的名称。</p><p id="b340" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还要注意，这些标签静态地出现在页面上。这意味着您不需要使用Selenium的重载过程，但是一个简单的<code class="fe mj mk ml mm b">requests.get()</code>后跟<code class="fe mj mk ml mm b">BeautifulSoup(page.content, 'html.parser')</code>就可以完成这项工作。</p><h2 id="ffa6" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">结构数据</h2><p id="5b23" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如今，人们可以在许多网站上找到的另一个有用信息块是包含<a class="ae le" href="https://developers.google.com/search/docs/advanced/structured-data/intro-structured-data" rel="noopener ugc nofollow" target="_blank">结构化数据</a>的块。</p><p id="f27a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结构化数据是一种标准化格式，用于提供有关页面的信息并对页面内容进行分类。</p><p id="4004" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，继续访问页面<a class="ae le" href="https://www.playstation.com/el-gr/ps4/ps4-games/" rel="noopener ugc nofollow" target="_blank">https://www.playstation.com/el-gr/ps4/ps4-games/</a>。然后打开这个页面的源代码，寻找<code class="fe mj mk ml mm b">application/ld+json</code>。这将带你到这个网页的源代码块:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a257" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结构化数据被定义在一个<code class="fe mj mk ml mm b">&lt;script&gt;</code>中，其中<code class="fe mj mk ml mm b">type</code>的值为<code class="fe mj mk ml mm b">application/ld+json</code>。这个标签的内容是一个JSON对象，符合<code class="fe mj mk ml mm b"><a class="ae le" href="https://schema.org." rel="noopener ugc nofollow" target="_blank">https://schema.org</a></code> <a class="ae le" href="https://schema.org." rel="noopener ugc nofollow" target="_blank">定义的结构。</a></p><p id="9b35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面的例子中可以看出，对于出现在特定页面上的不同对象，您可以获得非常有用的信息。在这里你可以看到这个页面是关于不同PlayStation游戏的一系列视频。</p><p id="9a71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，您可以访问结构数据，而不需要使用Selenium，就像打开图形数据一样。</p><h1 id="7c50" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">检查站2</h1><p id="b564" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们已经看到了一些分析网站页面数据的技术:</p><ul class=""><li id="6d63" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">使用BeautifulSoup静态遍历页面HTML文档的DOM树。</li><li id="3095" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">在无头浏览器(Selenium)加载页面时动态地遍历页面元素。</li><li id="cb1b" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">静态分析开放图形数据。</li><li id="3bc2" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">静态分析结构化数据。</li></ul><h1 id="2964" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">页面对象模式</h1><p id="417e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在我结束这篇长文之前，我想提到一个叫做页面对象模式的模式。</p><p id="73a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您编写解析网站页面内容的脚本时，您需要引用页面的元素，并使用驱动程序API与它们进行交互。如果您使用如下命令传播解析代码:</p><pre class="kp kq kr ks gt np mm nq nr aw ns bi"><span id="8c7b" class="mp lg it mm b gy nt nu l nv nw">username = driver.find_elements(by=By.CSS_SELECTOR, value='#username')[0]<br/>username.fill('foo-bar')</span></pre><p id="57f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么你的脚本将变得脆弱，难以维护和扩展。</p><p id="54fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的建议是，为您想要解析的页面开发一个对象模型，然后开始使用对象模型API而不是驱动程序API。</p><p id="fd4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">模式是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/4c288f0fa0b2d9e8501472bf7f5e1945.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*FbDP3oLTHD3FYMLgD2yoqQ.png"/></div></figure><ul class=""><li id="f054" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">有一个超类<code class="fe mj mk ml mm b">Page</code>，它保存对<code class="fe mj mk ml mm b">driver</code>的引用，并有一个选择元素的方法。</li><li id="1d8f" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">有一个超类<code class="fe mj mk ml mm b">PageSection</code>对页面的一部分建模，称为sections。这使用一个已经选择的元素(<code class="fe mj mk ml mm b">web_element</code>)来选择另一个。</li><li id="a35a" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">您访问的特定页面使用<code class="fe mj mk ml mm b">Page</code>类的子类建模，这些页面的特定部分使用<code class="fe mj mk ml mm b">PageSection</code>类的子类建模。</li></ul><p id="5303" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个Python代码的例子:</p><h2 id="5b8b" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">页面类</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><ul class=""><li id="e854" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">初始化器使用<code class="fe mj mk ml mm b">driver</code>来加载页面。</li><li id="9316" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><code class="fe mj mk ml mm b">select()</code>方法使用<code class="fe mj mk ml mm b">driver</code>来查找元素。</li></ul><h2 id="8a71" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">PageSection类</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><ul class=""><li id="a98d" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">初始化器保存对已经选择的部分的引用。</li><li id="f502" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><code class="fe mj mk ml mm b">select()</code>方法使用web元素引用来查找元素。</li></ul><h2 id="26be" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">特定的页面模型</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0671" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个特定的类，是<code class="fe mj mk ml mm b">Page</code>的子类，模拟了一个产品列表页面，其中显示了产品的数组/列表。它还有一个方法(<code class="fe mj mk ml mm b">product_items</code>)来获取对应于页面上每个产品的web元素列表。它使用来自<code class="fe mj mk ml mm b">Page</code>类的<code class="fe mj mk ml mm b">self.select()</code>并传递静态定义的选择器<code class="fe mj mk ml mm b">ProductListPage.product_item_element</code>。</p><p id="835d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意<code class="fe mj mk ml mm b">product_items()</code>方法如何返回类型为<code class="fe mj mk ml mm b">ProductItem()</code>的对象，这些对象是页面部分。参见下一条:</p><h2 id="14d2" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">特定的PageSection模型</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><ul class=""><li id="8723" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">我们定义如何选择该部分的不同部分。例如，应使用<code class="fe mj mk ml mm b">'.code'</code>选择器选择产品的代码。</li><li id="e1d9" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">然后我们定义返回相应web元素的方法。<code class="fe mj mk ml mm b">code()</code>使用<code class="fe mj mk ml mm b">code_element</code>选择器返回web元素。</li><li id="e77c" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">然后我们定义返回实际值的方法，这些值是对我们的数据分析工作有用的内容。例如，<code class="fe mj mk ml mm b">code_value()</code>返回实际的产品代码。</li></ul><h2 id="bec2" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">这些类的使用</h2><p id="9faf" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们已经定义了我们的页面和页面部分模型。让我们现在使用它:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4eb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看我们如何使用我们建立的页面对象模型。它在第14行和第18行之间演示。它是一个面向对象的API，不透露我们使用Selenium driver API的实现细节。</p><p id="ecf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这更容易维护和扩展。你甚至可以切换驱动程序并使用不同的API，这比你将驱动程序特定的API调用分散在你的代码库中要容易得多。</p><h2 id="ddfd" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">页面对象模式的参考</h2><p id="16e8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果您想阅读/了解更多信息，请尝试以下两个参考资料:</p><ul class=""><li id="fbe8" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated"><a class="ae le" href="https://martinfowler.com/bliki/PageObject.html" rel="noopener ugc nofollow" target="_blank">页面对象—马丁·福勒</a></li><li id="12ea" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><a class="ae le" href="https://webdriver.io/docs/pageobjects/" rel="noopener ugc nofollow" target="_blank"> Webdriver页面对象</a></li><li id="cc34" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><a class="ae le" href="https://www.selenium.dev/documentation/test_practices/encouraged/page_object_models/" rel="noopener ugc nofollow" target="_blank">硒页对象</a></li></ul><h1 id="0fc6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结束语</h1><p id="cb63" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我试图为那些有兴趣建立一个网站刮刀的人建立一个实用的提示列表。</p><p id="2f99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一如既往，我从你那里学到的比你从我这里学到的更多，我很乐意听听你的评论和反馈。先谢谢你了。</p></div></div>    
</body>
</html>