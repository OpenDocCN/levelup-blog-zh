<html>
<head>
<title>The cleanest way to write observable chains</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">写可观察链的最干净的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-cleanest-way-to-write-observable-chains-91400c4f75f5?source=collection_archive---------3-----------------------#2022-03-07">https://levelup.gitconnected.com/the-cleanest-way-to-write-observable-chains-91400c4f75f5?source=collection_archive---------3-----------------------#2022-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cc3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我经常面临这样的情况，我需要保存一个可观测值的输出，但也要将它用作其他可观测值的输入。我遇到了如何清晰地组织信息的挑战。我经常面临以下情况:</p><ul class=""><li id="7f51" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">我有一个可观察对象，它发出一个值，我需要保存并显示在UI上</li><li id="c3e8" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">第二个可观察对象需要第一个对象的值来执行其功能。</li></ul><p id="23ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，这是一个很常见的场景。有几种方法可以写出你的观察值来实现这个目标。</p><h2 id="bf7b" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">解决方案1:嵌套订阅</h2><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="fe01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然这种做事方式并不理想。一方面，如果<code class="fe lz ma mb mc b">thingThatReturnsObservable</code>没有完成，我不得不担心创建太多的订阅。此外，它是可怕的嵌套，这使得它很难阅读。</p><h2 id="e30e" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">解决方案2:允许副作用</h2><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="2b10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为这是一个可以接受的解决方案。这消除了一些嵌套，同时仍然在正确的时间设置一切。我唯一不喜欢的是我们在<code class="fe lz ma mb mc b"><a class="ae md" href="https://rxjs.dev/api/operators/switchMap" rel="noopener ugc nofollow" target="_blank">switchMap</a></code>内部设置了一个组件级变量。这可能会使在代码库中进行可视化捕捉变得困难。我可以使用一个<code class="fe lz ma mb mc b"><a class="ae md" href="https://rxjs.dev/api/operators/tap" rel="noopener ugc nofollow" target="_blank">tap</a></code>操作符来更好地描述副作用。但是理想情况下，我希望这样的属性设置发生在订阅调用中。</p><h2 id="62f8" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">解决方案3:结合可观察的结果</h2><p id="f0b0" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">另一个解决方案是强制将第一个observables值传递给子对象。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="b3bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为这是朝着错误方向迈出的一步。为生成复合可观察对象而添加的代码增加了复杂性。我认为这降低了可读性，而不是增加了可读性。</p><h2 id="c973" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">解决方案4:打破可见链</h2><p id="64b2" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我们可以使用另一种策略来提高可读性。也就是把可观察的事物分解成不同的函数。要做好这一点，可以使用<code class="fe lz ma mb mc b"><a class="ae md" href="https://rxjs.dev/api/operators/shareReplay" rel="noopener ugc nofollow" target="_blank">shareReplay</a></code>函数在订阅者之间多播可观察对象。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="dc6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为这个策略有很多优点。组件级变量都是在订阅中以一种非常清晰易读的方式设置的。<code class="fe lz ma mb mc b"><a class="ae md" href="https://rxjs.dev/api/operators/shareReplay" rel="noopener ugc nofollow" target="_blank">shareReplay</a> </code>使得父可观察对象只被调用一次，但仍然在任何需要的地方提供信息。人们甚至可以更进一步，直接使用新创建的<code class="fe lz ma mb mc b">parseId$</code>，而不是使用<code class="fe lz ma mb mc b">componnetLevelVariable</code>。在Angular的上下文中，这意味着根据需要使用<a class="ae md" href="https://angular.io/api/common/AsyncPipe" rel="noopener ugc nofollow" target="_blank">异步管道</a>或其他可观察的函数链。</p><p id="4f82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不喜欢这种模式，因为它更冗长，会导致应用程序中更多的回调。随着代码库变得越来越大，存在一些风险，这些现在自治的代码可能会以这样的方式移动，从而丢失原始上下文。此外，还有更多订阅需要管理和取消订阅。</p><h1 id="edf3" class="mj la iq bd lb mk ml mm le mn mo mp lh mq mr ms lk mt mu mv ln mw mx my lq mz bi translated">那么答案是什么呢？</h1><p id="de31" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">抱歉，今天没有明确的答案。在我看来，写可观察链的正确方式介于“解决方案2”和“解决方案4”之间。对我个人来说，我想更多地尝试“解决方案4 ”,以更好地理解它在复杂的代码库中面临的挑战。目前，至少这概述了不同的策略。</p></div></div>    
</body>
</html>