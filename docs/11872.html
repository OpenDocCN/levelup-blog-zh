<html>
<head>
<title>An In-depth Look At Database Indexing For Performance And What Are The Trade-Offs For Using Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解数据库索引的性能，以及使用它们的利弊</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-in-depth-look-at-database-indexing-for-performanceand-what-are-the-trade-offs-for-using-them-e2debd4b5c1d?source=collection_archive---------18-----------------------#2022-04-24">https://levelup.gitconnected.com/an-in-depth-look-at-database-indexing-for-performanceand-what-are-the-trade-offs-for-using-them-e2debd4b5c1d?source=collection_archive---------18-----------------------#2022-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5268" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过PostgreSQL示例了解如何充分利用索引</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e1b7398f001f5f85a052ae395350ef40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3O7WyRucE5qY9PMoT0oUyA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@xps" rel="noopener ugc nofollow" target="_blank"> XPS </a>在<a class="ae ky" href="https://unsplash.com/photos/dpbXgTh0Lac" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="0311" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在我们开始讨论索引之前，我将尝试了解PostgreSQL的内部，它在哪里存储数据，以及当我们编写查询时如何检索数据。关于使用索引的优点和缺点，这将更有意义。因此，不要在介绍上浪费更多的时间，喝杯咖啡，让我们开始吧。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="94fb" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">Postgres如何存储数据</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/f1f38c709e75720f320c3a49b58e1f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*1Ljjo8l4LxgNe8Z3K2ARdA.png"/></div></figure><p id="413a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">首先，我们要记住上面的定义，这很重要。例如，如果我们有一个表，这意味着我们也将有一个包含该表所有数据的堆文件。并且根据表本身的大小，数据将被分别划分成多个块。</p><p id="db04" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因此，让我们以一种更加结构化的方式来看一下堆文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/66b38878f1f9b2f8fa74858e1fc09265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehz5sfMWT5wUlZ6sdcxAow.png"/></div></div></figure><p id="c906" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因此，在这种情况下，我们有3个块，每个块的大小通常在8kb左右，有许多行(项)。在较低层次上，这些都以二进制形式存储在您的物理驱动器上，但是我建议您在业余时间深入研究这些内容，因为我不想让您感到厌烦，也不想让这篇文章永远流传下去。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="507e" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">从数据库中检索数据</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/4b25d8b3958323bcef1d5fa736d9240d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7wlXlvtq0I1UIyGvXyJng.png"/></div></div></figure><p id="5e7a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">所以现在的问题是，Postgres不像我们，看不到Matt的确切位置，所以发生的事情是，来自块的所有不同行被合并到我们的内存(RAM)中的一个大列表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f2e704b224a2b346a96d36a709f3dc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*E18wmnunh-4_6p4IcN0lqw.png"/></div></figure><p id="ee35" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">加载完所有行后，Postgres将开始遍历数据，尝试查找用户名为“Matt”的客户，如果该名称更靠前，速度可能会稍快一些，但这对我们来说并不重要，因为将所有数据放入内存的过程本身的性能开销就很大。但是最重要的是，如果我们有成千上万的行，我们想要检索最后一行中的一行，你可以想象性能会有多差。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="f48e" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">什么是指数</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/db4112347d88e28b140b172ae18beac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PzGhoIYQ_sZgJOoFszRk2Q.png"/></div></div></figure><p id="246d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">想象一下，我们实际上知道我们正在寻找的客户的确切位置，而不是将所有这些文件加载到内存中。这就是指数的含义。它存储一个记录的确切位置，并允许我们只加载该记录所在的1个块，并很快找到它(是的，它确实加载了整个块，但由于块的大小有限，无论如何它总是非常快)。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="af38" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">索引是如何工作的</h2><p id="0b15" class="pw-post-body-paragraph lg lh it li b lj na ju ll lm nb jx lo lp nc lr ls lt nd lv lw lx ne lz ma mb im bi translated">当创建一个索引时，我们需要选择哪个字段是我们真正想要的索引。根据需要实现的目标，可以在多个属性上建立索引，但是为了简单起见，我将只使用一个索引。</p><p id="988c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在我们的示例中，对用户名进行了查询，因此我们希望对该属性进行索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/b190c4a6cf90328bc2e1abdc21fb9cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDhw-5LzKHaejqRszdjYuw.png"/></div></div></figure><p id="e81d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">第一步是从具有准确位置的记录中提取该属性。为了简单起见，我只提取了4条记录。提取所有记录后，我们需要以某种有意义的方式对它们进行排序——按字母顺序或数字值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/75d6b6cf2dfb82b5b0de45730c8e5127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*r-xEbQJBB15XGAU8p9QsEg.png"/></div></div></figure><p id="5551" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在，最后一步是将所有数据组织成某种树形数据结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/46769f32601b55b0d784780e4fa62cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSobm66RJpJk44JP-JooTw.png"/></div></div></figure><p id="74b1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">根节点是第一步，它将帮助我们消除大量不包含我们正在寻找的数据的叶节点。这个例子相当简单，但是你可以想象，如果我们有成百上千的行，这个索引会给我们很大帮助。</p><p id="9645" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因此，如果我们在根节点中寻找John，我们知道我们必须向右走，那么当我们检索“John”的位置时，我们可以转到特定的块并获得与该客户相关联的其余数据，从而在这个过程中节省大量时间。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="624e" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">使用索引的缺点</h2><p id="1425" class="pw-post-body-paragraph lg lh it li b lj na ju ll lm nb jx lo lp nc lr ls lt nd lv lw lx ne lz ma mb im bi translated">尽管索引具有所有的性能优势，但是我们不应该在表中的每个属性上使用它们，因为这样会有一些缺点。</p><ol class=""><li id="69ab" class="ni nj it li b lj lk lm ln lp nk lt nl lx nm mb nn no np nq bi translated">存储成本—因为创建索引也创建了保存记录位置的数据树结构，这也意味着我们需要存储该索引。一个文件被创建并存储在硬盘上，所以每当我们创建一个索引，我们使用更多的存储。</li><li id="8111" class="ni nj it li b lj nr lm ns lp nt lt nu lx nv mb nn no np nq bi translated">索引降低了插入、更新和删除的速度——每次我们对数据库进行更改时，Postgres也需要更新索引，这意味着它本身会有一些性能成本。因此，如果表要非常频繁地更新，您可能应该考虑索引是否是正确的解决方案。</li><li id="ee61" class="ni nj it li b lj nr lm ns lp nt lt nu lx nv mb nn no np nq bi translated">可能不使用索引—一些查询在没有索引的情况下可以运行得更快，因此您最终会使用更多的存储空间，而性能却丝毫没有提高。</li></ol></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="d678" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">结论</h2><p id="45de" class="pw-post-body-paragraph lg lh it li b lj na ju ll lm nb jx lo lp nc lr ls lt nd lv lw lx ne lz ma mb im bi translated">索引非常强大，可以极大地提高性能，但我们在使用它们之前需要三思，因为如果使用不当，它们会有一些缺点。但是知道它们如何在较低层次上工作是很好的，所以当我们编写/设计代码时，我们也知道数据将如何被处理。</p><div class="nw nx gp gr ny nz"><a href="https://medium.com/@ivan.zstoev/membership" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">通过我的推荐链接加入Medium-Ivan Stoev</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">medium.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>