<html>
<head>
<title>The official version of Python 3.11 is here and 10–60% faster than 3.10. This could be the best version!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.11的正式版本已经发布，比3.10快10-60%。这可能是最好的版本！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-official-version-of-python-3-11-f81080cd259f?source=collection_archive---------4-----------------------#2022-10-27">https://levelup.gitconnected.com/the-official-version-of-python-3-11-f81080cd259f?source=collection_archive---------4-----------------------#2022-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2c75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">终于，Python 3.11正式版发布了！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e62e22600882d6f55df85db781cfe3d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WZacy1sXHYDUe2e6"/></div></div></figure><p id="12b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2020年1月1日，Python正式结束对Python 2的维护，这意味着Python 2彻底退役，进入Python 3时代。自进入版本3以来，Python正式发布了很多修改分支，现在是最新版本Python 3.11。<br/>其实在研究界有一个不为人知的秘密，那就是Python速度不快但很好用，所以用户数量超级庞大，Python在很多最流行语言的榜单上都排在第一。许多开发人员都期待着提高这种语言的性能，有些人想知道Python 4是否会在某个不经意的时刻到来。有这种想法的可以放在一边。Python之父Van Rossum说的，Python 4.0不一定会来。<br/> Van Rossum曾说:“我和Python核心开发团队的成员对Python 4.0一无所知，也不感兴趣。估计至少要编号到3.33。Python的加速是增量的，3.11版本会有新的速度提升。预计会比3.10快很多。”<br/>正如Van Rossum所说，根据官方信息，最新发布的Python 3.11比Python 3.10快10–60%，并且更加用户友好。这个版本已经开发了17个月，现在已经公开发布。</p><p id="a6d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python 3.11中的具体改进主要体现在:更详细的错误回溯、更快的代码执行、更好的异步任务语法、改进的类型变量、对TOML配置解析的支持，以及其他一些非常酷的特性(包括快速启动、零成本异常处理、异常组等。).</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi la"><img src="../Images/0af9b040252deee45681917d72b42b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M-h3WSME0f4L9wa-"/></div></div></figure><p id="1c28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python指导委员会成员和核心开发人员、Python 3.10/3.11发布经理Pablo Galindo Salgado表示，为了使3.11成为Python的最佳版本，做了大量工作。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi la"><img src="../Images/826dccfdd07b72ac1338305f1a40ac20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z21OwTLyNePx9f4r"/></div></div></figure><p id="c331" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">Python 3.11新增功能</strong> <br/> <strong class="js iu">错误回溯</strong> <br/> Python是一种非常初学者友好的编程语言，具有易于理解的语法和强大的数据结构。但是对于刚接触Python的人来说，有一个问题，就是Python遇到错误时，如何解释显示的traceback。<br/> Python 3.11在回溯中增加了装饰性注释，帮助用户更快地解读错误信息。要获得此功能，请将以下代码添加到inverse.py文件中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi la"><img src="../Images/215b72ab96970c16b25ad7a79eeda647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_370nngy38Y8i2xr"/></div></div></figure><p id="1369" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，可以使用inverse()计算一个数的倒数。由于0没有倒数计时，因此当运行以下代码时会引发错误。注意回溯中嵌入的^和~符号，它们指向导致错误的代码。与以前的追溯一样，您应该从底层开始，一步步向上。这个操作对于查找bug非常有用，但是如果代码太复杂，带注释的回溯更好。</p><p id="572e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">更快的代码执行</strong> <br/> Python是出了名的慢，例如Python中的常规循环比c中的类似循环慢几个数量级。<br/> Python官方正在致力于改善这一缺陷。2020年秋天，Mark Shannon展示了Python的几项性能改进。这个提议被称为香农计划，他们希望通过几次版本更新使Python速度提高5倍。不久之后，微软正式加入了该计划，该公司正在支持包括马克·香农和吉多·范·罗苏姆在内的开发人员进行“更快的CPython”项目。<br/>“更快的CPython”项目中的一个重要提案是PEP 659，Python 3.11在此基础上有很多改进。<br/> PEP 659描述了一个“专门化的自适应解释器”。主要思想是通过优化频繁执行的操作使代码运行得更快，这类似于JIT(实时)编译。只是不影响编译而已，相反Python的字节码是动态调整或者变化的。<br/>研究人员在字节码生成中增加了一个叫做“加快”的新步骤，可以在运行时优化指令，并用适应性指令取代它们。<br/>一旦函数被调用一定次数，加速指令开始。在CPython 3.11中，加速在八次调用后开始。您可以通过调用dis()并设置adaptive参数来观察解释器如何适应字节码。<br/>在基准测试中，CPython 3.11比CPython 3.10平均快25%。更快的CPython项目是一个正在进行的项目，已经计划在2023年10月发布Python 3.12时进行一些优化。你可以在GitHub上关注这个项目。<br/>项目地址:<a class="ae lb" href="https://github.com/faster-cpython/ideas" rel="noopener ugc nofollow" target="_blank">https://github.com/faster-cpython/ideas</a></p><p id="eea7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">异步任务的更好语法</strong><br/>Python对异步编程的支持已经发展了很长时间。生成器是在Python 2时代添加的，asyncio库最初是在Python 3.4中添加的，async和await关键字是在Python 3.5中添加的。在Python 3.11中，您可以使用任务组，它为运行和监控异步任务提供了更简洁的语法。</p><p id="7c30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">改进类型变量</strong> <br/> Python是一种动态类型语言，但它支持带有可选类型提示的静态类型。Python的静态类型系统的基础是在2015年PEP 484中定义的。从Python 3.5开始，每个Python版本都引入了几个与类型相关的新提议。<br/> Python 3.11发布5个类型相关pep，再创新高:</p><ul class=""><li id="d704" class="lc ld it js b jt ju jx jy kb le kf lf kj lg kn lh li lj lk bi translated">PEP 646:可变泛型</li><li id="64b1" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated">PEP 655:将单个类型的项目标记为需要或可能缺少</li><li id="0a5b" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated">人教版673:自我类型</li><li id="fbfa" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated">PEP 675:任意文字字符串类型</li><li id="1dd5" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated">PEP 681:数据类转换</li></ul><p id="02c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">支持TOML配置解析</strong> <br/> TOML是Tom的显而易见的极简语言的缩写。这是一种配置文件格式，在过去十年中变得很流行。Python社区在为包和项目指定元数据时，已经将TOML作为首选格式。<br/>虽然TOML已经用了很多年，但是Python并没有内置的TOML支持。当tomllib被添加到标准库中时，Python 3.11中的情况发生了变化。这个新模块建立在toml第三方库之上，允许解析TOML文件。<br/>以下是一个名为units.toml的TOML文件示例:</p><p id="895c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">其他功能</strong> <br/>除了上面的重大更新和改进，Python 3.11还有更多值得探索的特性，比如更快的程序启动、更多对异常的修改以及对字符串格式的小改进。</p><p id="2f0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">更快的程序启动速度</strong> <br/>更快的CPython项目的结果之一就是更快的启动时间。运行Python脚本时，解释器初始化需要一些操作。这导致即使是最简单的程序也需要几毫秒才能运行。<br/>在许多情况下，与运行代码所花费的时间相比，启动程序所花费的时间可以忽略不计。但是在短期运行的脚本中，比如典型的命令行应用程序，启动时间会显著影响程序性能。例如，考虑下面的脚本，灵感来自经典的cowsay程序。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi la"><img src="../Images/985cb40f66658b76bc97614467df984d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CNzmFgJEOAScBHXt"/></div></div></figure><p id="cbb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在snakesay.py中，你从命令行读取一条消息，然后将这条消息打印在一个带有可爱的蛇的语音气泡中。你可以让蛇说任何话。下面是一个命令行应用程序的基本示例，它运行速度很快，但仍然需要几毫秒的时间。这种开销的很大一部分发生在Python导入模块的时候。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi la"><img src="../Images/a2753f5eb0fe803b825f2c8b9e24f14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ieaah0N8BzzpwLrB"/></div></div></figure><p id="15de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用-X importtime选项来显示导入模块所花费的时间。表中的数字以微秒为单位，最后一列是模块名称的格式。<br/>该示例分别在Python 3.11和3.10上运行，结果如下图所示。Python 3.11有更快的导入，帮助Python程序更快启动。</p><p id="3981" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">零成本异常</strong><br/>Python 3.11中异常的内部表示不同。异常对象更加轻量级，异常处理也发生了变化。因此，只要except子句没有被触发，try …except块中的开销就会减少。所谓的零成本异常是受C++和Java等其他语言的启发。当您的源代码被编译成字节码时，编译器会创建跳转表，零成本异常从该表中实现。如果出现异常，则查询这些跳转表。如果没有异常，try块中的代码就没有运行时开销。</p><p id="d55a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">异常组</strong> <br/>前面，你学习了任务组以及它们如何同时处理多个错误。这都要归功于一个叫做例外组的新特性。我们可以这样看待异常组，它们是包装了几个其他常规异常的常规异常。虽然异常组在许多方面表现得像常规异常，但它们也支持特殊的语法来帮助您有效地处理每个包装的异常。如下所示，您可以通过给出描述并列出包装的异常来创建一个异常组。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi la"><img src="../Images/3400fd71c4516e645c06d7d4cebbee58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HsPkFIBFGQXYXWnx"/></div></div></figure><p id="5fc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">异常注释</strong> <br/>一般异常具有添加任意注释的扩展能力。你可以用。add_note()向任何异常添加注释，并通过检查。__notes__属性。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi la"><img src="../Images/c405d8ae758b60ae6a6ca7882eeea5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UucJu0A3QBY5f9aB"/></div></div></figure><p id="b337" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">负零格式化</strong> <br/>用浮点数做计算时，可能会遇到一个奇怪的概念——负零。您可以观察到负零和常规零在REPL中的呈现方式不同，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi la"><img src="../Images/650bc95204a2621a9707bb6774da6543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-E8vSVOq2snmqioD"/></div></div></figure><p id="a4ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关Python 3.11中更新内容的更多详细信息，请参见原始文档。<br/> <em class="lq">参考:</em><a class="ae lb" href="https://realpython.com/python311-new-features/" rel="noopener ugc nofollow" target="_blank"><em class="lq">https://realpython.com/python311-new-features/</em></a></p><p id="b87b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">喜欢这篇文章吗？成为一个媒介成员，通过无限制的阅读继续学习。如果你使用<a class="ae lb" href="https://machinelearningabc.medium.com/membership" rel="noopener">这个链接</a>成为会员，你将会支持我而不需要额外的费用。提前感谢，再见！</p></div></div>    
</body>
</html>