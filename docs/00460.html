<html>
<head>
<title>Using Nested Templates in Go for Efficient Web Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中使用嵌套模板实现高效的Web开发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-go-templates-for-effective-web-development-f7df10b0e4a0?source=collection_archive---------0-----------------------#2019-03-14">https://levelup.gitconnected.com/using-go-templates-for-effective-web-development-f7df10b0e4a0?source=collection_archive---------0-----------------------#2019-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/60e050c566a8bed953e787a07869a3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*DWLURVrB2e5d43bdX4kxbQ.jpeg"/></div></figure><p id="8868" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管我很喜欢Go语言及其标准库文档，但我总是很难准确掌握如何使用标准模板包。Go模板库小巧、简洁、高性能——Go本身的所有优点。对于简单的模板插值，如邮件合并或呈现单个HTML页面，它的效用是显而易见的。</p><p id="b048" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，当我试图在模板中包含其他模板时，我发现自己很快陷入了困境。考虑到使用嵌套模板是一个相当标准的web设计模式，我觉得我好像遗漏了一些基本的东西。粗略地搜索一下文档，可以发现在模板标签中使用了一个<code class="fe ks kt ku kv b">template</code>函数，它带有一个“模板名”和一个可选的数据指针。然而，这就是困惑的开始。考虑以下代码:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="2998" class="le lf iq kv b gy lg lh l li lj">package main</span><span id="033a" class="le lf iq kv b gy lk lh l li lj">import (<br/> "text/template"<br/> "os"<br/>)</span><span id="4c43" class="le lf iq kv b gy lk lh l li lj">func main() {<br/> tmpl := "Hello, {{ .Name }}"<br/> t, _ := template.New("greeting").Parse(tmpl)<br/> t.Execute(os.Stdout, struct{ Name string }{"Prince Adam"})<br/>}</span></pre><p id="0bd5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个例子看起来很简单。我们声明我们的文本字符串，它将作为模板本身，然后我们调用一系列函数，这些函数:</p><ol class=""><li id="878f" class="ll lm iq jw b jx jy kb kc kf ln kj lo kn lp kr lq lr ls lt bi translated">分配一个新模板并返回一个<code class="fe ks kt ku kv b">*template.Template</code>指针</li><li id="a271" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated">解析包含在<code class="fe ks kt ku kv b">tmpl</code>中的字符串，从而为执行做准备。</li></ol><p id="ba46" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们调用<code class="fe ks kt ku kv b">Execute</code>，它带有一个<code class="fe ks kt ku kv b">io.Writer</code>(在我们的例子中是STDOUT)和一个空接口。对于这个例子，为了简洁起见，我只加入了一个匿名结构。</p><p id="84fd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个模板的简单实现，类似于Go text/template文档中的实现。然而，文档在这方面是混乱的。当文档提到一个“模板”时，它是指我在上面的例子中实例化的<code class="fe ks kt ku kv b">*template.Template</code>的实例，还是指“一个名称与我们的<code class="fe ks kt ku kv b">*template.Template</code>相关联的东西”？</p><p id="1933" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，假设我们想要编写一个程序来执行所谓的“邮件合并”，或者使用一个文本模板并将变量插入到所述文本中来生成一封群发电子邮件。我们的业务需求是，将有许多不同的消息模板，但消息头和消息尾将很少改变。困难是双重的:编写新的模板需要向每个模板文件添加不经常改变的数据，并且更新包含在标题中的信息需要对每个模板文件进行所述更新。这两个问题都会导致糟糕的、容易出错的模板。这是嵌套模板的完美用例！</p><p id="6b87" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设这是我们的标题模板:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="38fd" class="le lf iq kv b gy lg lh l li lj">WidgetCo, Ltd.<br/>463 Shoe Factory Rd.<br/>Hamford, VT 20202</span></pre><p id="b78f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的页脚模板:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="7c02" class="le lf iq kv b gy lg lh l li lj">Thank you for your business,<br/>WidgetCo Order Fulfillment Department</span><span id="b1ce" class="le lf iq kv b gy lk lh l li lj">Ph: 818-555-0123 Email: orders@widgetco.com</span></pre><p id="152a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们与客户的第一次沟通将是“感谢您的订单”信息。我们希望像这样“嵌套”页眉和页脚模板:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="c96b" class="le lf iq kv b gy lg lh l li lj">{{ template "header" }}</span><span id="c511" class="le lf iq kv b gy lk lh l li lj">Dear {{ .Name }},</span><span id="9ff2" class="le lf iq kv b gy lk lh l li lj">Thank you for your order! Your order number is {{ .OrderNumber }} and will be shipped on {{ .ShipDate }}.</span><span id="55f9" class="le lf iq kv b gy lk lh l li lj">{{ template "footer" }}</span></pre><p id="36b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对我来说，这就是线索变冷的地方，因为文档中没有一个清晰的例子来说明如何编写代码来实现这一点。经过大量的反复试验，我得出了以下解决方案:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="e30d" class="le lf iq kv b gy lg lh l li lj">package main</span><span id="84f3" class="le lf iq kv b gy lk lh l li lj">import (<br/>    "os"<br/>    "text/template"<br/>)</span><span id="3eac" class="le lf iq kv b gy lk lh l li lj">type orderData struct {<br/>    Name        string<br/>    OrderNumber int<br/>    ShipDate    string<br/>}</span><span id="82e5" class="le lf iq kv b gy lk lh l li lj">var header = `<br/>    WidgetCo, Ltd.<br/>    463 Shoe Factory Rd.<br/>    Hamford, VT 20202<br/>`</span><span id="21e0" class="le lf iq kv b gy lk lh l li lj">var footer = `<br/>    Thank you for your business,<br/>    WidgetCo Order Fulfillment Department<br/>    Ph: 818-555-0123 Email: <a class="ae lz" href="mailto:orders@widgetco.com" rel="noopener ugc nofollow" target="_blank">orders@widgetco.com</a><br/>`</span><span id="197a" class="le lf iq kv b gy lk lh l li lj">var thanks = `<br/>    {{ template "header" }}<br/>    Dear {{ .Name }},<br/>    Thank you for your order! Your order number is {{ .OrderNumber }} and will be shipped on {{ .ShipDate }}.<br/>    {{ template "footer" }}<br/>`</span><span id="33af" class="le lf iq kv b gy lk lh l li lj">func main() {<br/>    t, _ := template.New("header").Parse(header)<br/>    t.New("footer").Parse(footer)<br/>    t.New("thanks").Parse(thanks)<br/>    ordersToThank := []orderData{<br/>        {"Sleve McDichael", 17104, "2018-10-10"},<br/>        {"Bobson Dugnutt", 17106, "2018-10-12"},<br/>    }</span><span id="311a" class="le lf iq kv b gy lk lh l li lj">    for _, data := range ordersToThank {<br/>        t.ExecuteTemplate(os.Stdout, "thanks", data)<br/>    }<br/>}</span></pre><p id="55f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事实证明，文档中的“模板”一词既指<code class="fe ks kt ku kv b">*template.Template</code>的原始实例，也指与所述原始实例相关联的其他命名模板<em class="ma">。正确的说法可能是“一个<code class="fe ks kt ku kv b">*template.Template</code>可以代表一个单独的命名模板，或者一个命名模板的集合”，解决方案是初始化你的第一个模板，然后在上面调用<code class="fe ks kt ku kv b">New()</code>。请注意，文档中明确说明了这一点:</em></p><blockquote class="mb mc md"><p id="a6f6" class="ju jv ma jw b jx jy jz ka kb kc kd ke me kg kh ki mf kk kl km mg ko kp kq kr ij bi translated">每个模板由创建时指定的字符串命名。此外，每个模板都与零个或多个其他模板相关联，它可以通过名称来调用这些模板；这种关联是可传递的，并形成模板的名称空间。</p><p id="6074" class="ju jv ma jw b jx jy jz ka kb kc kd ke me kg kh ki mf kk kl km mg ko kp kq kr ij bi translated">模板可以使用模板调用来实例化另一个相关联的模板；请参见上面对“模板”操作的解释。该名称必须是与包含调用的模板相关联的模板的名称。</p></blockquote><p id="479f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，这是一个非常简洁的解释，需要一些上下文、细节和示例代码，以便对不熟悉该库的人有意义。</p><h2 id="5a97" class="le lf iq bd mh mi mj dn mk ml mm dp mn kf mo mp mq kj mr ms mt kn mu mv mw mx bi translated">那么我们如何用这个来渲染HTML呢？</h2><p id="b199" class="pw-post-body-paragraph ju jv iq jw b jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr ij bi translated">事实上，我们已经解决了我们的业务问题，但是如上面的代码所示，所有的模板数据都是硬编码的。我们当然不希望营销人员为了制作新消息而手工编辑我们的源代码！幸运的是，模板库提供了一个非常方便的方法，通过一个方法调用就可以从单个文件中加载许多模板！</p><p id="83fd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们转换一下思路，假设WidgetCo公司的网站急需更新，因为它自1997年以来看起来就没变过。由于我们的老板非常喜欢邮件合并程序，我们提议使用同样的技术来更新网站，她很高兴地同意了。</p><p id="307a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将从索引页面和“关于我们”页面开始，但首先我们必须定义一些模板。</p><p id="818a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们创建一个文件夹，其结构最终将如下所示:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="ce67" class="le lf iq kv b gy lg lh l li lj">widgetco_site<br/>├─ main.go<br/>└─ templates<br/>   ├─ about.html<br/>   ├─ footer.html<br/>   ├─ header.html<br/>   └─ index.html</span></pre><p id="2adb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们定义我们的文件。</p><p id="33f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">header.html:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="837d" class="le lf iq kv b gy lg lh l li lj">&lt;!DOCTYPE html&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;{{ .Title }}&lt;/title&gt;<br/>  &lt;style&gt;<br/>    body {<br/>      font-family: monospace;<br/>      background-color: #BBC;<br/>      color: #334;<br/>    }<br/>    #content {<br/>      margin: 30px auto 30px auto;<br/>    }<br/>    #footer {<br/>      font-size: 0.8em;<br/>    }<br/>  &lt;/style&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;h1&gt;Welcome to {{ .CompanyName }}!&lt;/h1&gt;<br/>    &lt;nav&gt;<br/>      &lt;a href="/"&gt;Home&lt;/a&gt;<br/>      &lt;a href="/about"&gt;About&lt;/a&gt;<br/>    &lt;/nav&gt;<br/>  &lt;div id="content"&gt;</span></pre><p id="61f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">页脚. html:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="c2da" class="le lf iq kv b gy lg lh l li lj">  &lt;/div&gt;<br/>  &lt;div id="footer"&gt;<br/>    &amp;copy;2018, {{ .CompanyName }}, All Rights Reserved<br/>  &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="c8fe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我们定义几页。</p><p id="ef54" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">index.html:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="4431" class="le lf iq kv b gy lg lh l li lj">{{ template "header.html" . }}<br/>&lt;div&gt;<br/>  Here at WidgetCo, we only offer the highest quality widgets!<br/>&lt;/div&gt;<br/>{{ template "footer.html" . }}</span></pre><p id="beaf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于. html:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="6375" class="le lf iq kv b gy lg lh l li lj">{{ template "header.html" . }}<br/>&lt;div&gt;<br/>  WidgetCo was founded in 1987 by Larry W. Cashdollar, a business man with a passion for seersucker suits and the highest quality widgets available anywhere.<br/>&lt;/div&gt;<br/>{{ template "footer.html" . }}</span></pre><p id="490e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们创建一个完整的web服务器程序。</p><p id="d92e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">主页面:</p><pre class="kw kx ky kz gt la kv lb lc aw ld bi"><span id="4c3d" class="le lf iq kv b gy lg lh l li lj">package main</span><span id="8214" class="le lf iq kv b gy lk lh l li lj">import (<br/>  "html/template"<br/>  "log"<br/>  "net/http"<br/>  "os"<br/>  "regexp"<br/>)</span><span id="addb" class="le lf iq kv b gy lk lh l li lj">type pageData struct {<br/>  Title       string<br/>  CompanyName string<br/>}</span><span id="c0e7" class="le lf iq kv b gy lk lh l li lj">var t *template.Template<br/>var routeMatch *regexp.Regexp<br/>var pd pageData</span><span id="2e39" class="le lf iq kv b gy lk lh l li lj">func servePage(w http.ResponseWriter, r *http.Request) {<br/>  matches := routeMatch.FindStringSubmatch(r.URL.Path)<br/>  if len(matches) &gt;= 1 {<br/>    page := matches[1] + ".html"<br/>    if t.Lookup(page) != nil {<br/>      w.WriteHeader(200)<br/>      t.ExecuteTemplate(w, page, pd)<br/>      return<br/>    }<br/>  } else if r.URL.Path == "/" {<br/>    w.WriteHeader(200)<br/>    t.ExecuteTemplate(w, "index.html", pd)<br/>    return<br/>  }<br/>  w.WriteHeader(404)<br/>  w.Write([]byte("NOT FOUND"))<br/>}</span><span id="3196" class="le lf iq kv b gy lk lh l li lj">func main() {<br/>  var err error<br/>  t, err = template.ParseGlob("./templates/*")<br/>  if err != nil {<br/>    log.Println("Cannot parse templates:", err)<br/>    os.Exit(-1)<br/>  }<br/>  routeMatch, _ = regexp.Compile(`^\/(\w+)`)<br/>  pd = pageData{<br/>    "WidgetCo Home",<br/>    "WidgetCo International",<br/>  }<br/>  http.HandleFunc("/", servePage)<br/>  log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="4303" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在main函数中，我们使用<code class="fe ks kt ku kv b">template.ParseGlob()</code>将整个文件夹的模板文件加载到<code class="fe ks kt ku kv b">t</code>中，得到一个以包含它们的文件命名的模板集合。然后，我们将编译一个简单的正则表达式来匹配传入的HTTP请求URL。我把这两件事都做成全局变量，因为它们只需要在程序启动时做一次，它们需要从我们的HTTP处理函数中容易地访问，并且它们在进程的生命周期中不会改变。</p><p id="e6f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们定义一些要导出到模板的数据。最后，我们将<code class="fe ks kt ku kv b">servePage</code>函数绑定到根路由，然后开始监听HTTP请求。</p><p id="070d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe ks kt ku kv b">servePage</code>函数中，我们使用编译后的正则表达式来匹配传入的请求URL。请记住，这是一个非常简单的机制——如果路径的第一部分与我们已经加载的文件相匹配，我们就呈现模板。如果不是，看看我们是否在请求<code class="fe ks kt ku kv b">/</code>，如果是，渲染<code class="fe ks kt ku kv b">index.html</code>。如果也不是那样，那么返回一个404。</p><p id="2a5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">改进我们计划的想法(将作为练习留给读者完成):</p><ol class=""><li id="3392" class="ll lm iq jw b jx jy kb kc kf ln kj lo kn lp kr lq lr ls lt bi translated"><strong class="jw ir">添加更复杂的路由机制。</strong>创建一个包含预编译正则表达式的<code class="fe ks kt ku kv b">route</code>结构类型，然后拥有一个从最具体到最不具体匹配的这些路由的排序数组。</li><li id="7dc0" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated"><strong class="jw ir">添加服务静态文件的路由。</strong>实现这一点的一种方法是将<code class="fe ks kt ku kv b">http.FileServer</code>绑定到<code class="fe ks kt ku kv b">/static</code>路径。</li><li id="b979" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated"><strong class="jw ir">将包括路由数据在内的相关变量放入配置文件。</strong>诸如web服务器运行的端口、模板文件夹、公司名称等变量不应硬编码到程序中。</li><li id="aab0" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated"><strong class="jw ir">添加更吸引人的404页面。</strong></li><li id="63af" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated"><strong class="jw ir">防止用户访问非消费路线。例如，用户可以输入URL <code class="fe ks kt ku kv b">/header</code>，然后只显示标题模板，这显然不是一个完整的HTML文档。这可以通过添加更复杂的路由机制很容易地实现。</strong></li><li id="b577" class="ll lm iq jw b jx lu kb lv kf lw kj lx kn ly kr lq lr ls lt bi translated"><strong class="jw ir">消除在每个页面中添加页眉和页脚模板标签的必要性。</strong>这种模式导致代码混乱，过一会儿就开始感觉像是<a class="ae lz" href="https://en.wikipedia.org/wiki/Cargo_cult_programming" rel="noopener ugc nofollow" target="_blank"> cargo cult编程</a>。顺便提一下，在本文的第二部分，我们将讨论一种可能的方法来做到这一点！</li></ol></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><div class="kw kx ky kz gt nk"><a href="https://gitconnected.com/learn/golang" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">学习围棋-最佳围棋教程(2019) | gitconnected</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">23大围棋教程-免费学习围棋。课程由开发者提交和投票，使您能够找到…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">gitconnected.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny js nk"/></div></div></a></div></div></div>    
</body>
</html>