<html>
<head>
<title>Type-Level Finite-State Machines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型级有限状态机</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/type-level-finite-state-machines-6714f849255?source=collection_archive---------3-----------------------#2019-03-24">https://levelup.gitconnected.com/type-level-finite-state-machines-6714f849255?source=collection_archive---------3-----------------------#2019-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4784" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将通过使用TypeScript中有限状态机的实现，让您对设计解决方案时的类型优先方法有一个直观的了解。</p><h1 id="c9ae" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是有限状态机</h1><p id="6c0d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated"><a class="ae lo" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">有限状态机</a>(也称:有限状态自动机或简称状态机)是一种计算的数学模型，它由一系列可能的状态、一个初始状态和一组状态之间的条件(或无条件)转移来定义。有限状态机广泛应用于工程，语言学，生物学，数学。它们非常适合描述具有有限状态集的系统:网络请求、问卷、自然语言解析器，甚至复杂的业务流程(如果你想更深入地了解这个主题，请参见<a class="ae lo" href="https://en.wikipedia.org/wiki/Business_process_modeling" rel="noopener ugc nofollow" target="_blank"> BPM </a>)。</p><h1 id="70be" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">示例:带有断路器的网络请求</h1><p id="fa5c" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">对于我们的例子，让我们看看使用<a class="ae lo" href="http://medium.com/@yuriybogomolov/circuit-breaker-in-a-functional-world-9c555c8e9527" rel="noopener">断路器模式</a>的简单网络请求，并使用FSM对其建模。</p><p id="57b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的状态列表将是请求状态和断路器状态的混合:</p><ul class=""><li id="9931" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">请求从未被执行(<em class="ly">初始</em>状态)；</li><li id="11f9" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">请求当前正在执行(<em class="ly">待定</em>状态)；</li><li id="333a" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">请求成功(<em class="ly">成功</em>状态)；</li><li id="0344" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">请求失败(<em class="ly">失败</em>状态)；</li><li id="3e74" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">断路器打开(<em class="ly">打开</em>状态)；</li><li id="03cc" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">断路器半开(<em class="ly">半开</em>状态)；</li><li id="05c3" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">断路器闭合(<em class="ly">闭合</em>状态)。</li></ul><p id="aad2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的初始状态(显然)是“请求从未被执行”。</p><p id="dd30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的过渡条件是:</p><ul class=""><li id="a68b" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">从<em class="ly">初始</em>到<em class="ly">待定</em>:无条件；</li><li id="133b" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">从<em class="ly">待定</em>到<em class="ly">关闭</em> : <em class="ly"> cb_closed </em>状态；</li><li id="13c8" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">从<em class="ly">关闭</em>到<em class="ly">打开</em> : <em class="ly"> req_fail </em>状态(“正常请求失败”)；</li><li id="16a7" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">从<em class="ly">关闭</em>到<em class="ly">成功</em> : <em class="ly"> req_ok </em>状态(“正常请求已成功”)。</li><li id="bdfb" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">从<em class="ly">打开</em>到<em class="ly">失效</em>:无条件；</li><li id="64ea" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">从<em class="ly">打开</em>到<em class="ly">半开</em> : <em class="ly"> cb_timeout </em>状态(“断路器已达到其冷却超时”)；</li><li id="1403" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">从<em class="ly">半开</em>到<em class="ly">开</em> : <em class="ly">金丝雀_失败</em>状态(“金丝雀请求失败”)；</li><li id="dc38" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">从<em class="ly">半开</em>到<em class="ly">关闭</em> : <em class="ly">金丝雀_ok </em>状态(“金丝雀请求已成功”)；</li></ul><p id="431d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们的有限状态机可以用下图表示:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/d3588ed69ffe729e0b974d8c032f5348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thtaZEbpOjHXZeOBcv5vOg.jpeg"/></div></div></figure><p id="0124" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，一个相当复杂的过程可以被描述(和描绘！)用一个简单的有向图。很容易推理，很容易理解，也很方便分析可能的错误。所以让我们继续下一部分——在类型级别上编码这个FSM。</p><h1 id="4e46" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">类型级设计</h1><blockquote class="mq mr ms"><p id="44a8" class="jn jo ly jp b jq jr js jt ju jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj kk ij bi translated">为了给你一个关于类型优先方法的介绍，我会试着在处理任务时表达我的想法。如果您熟悉类型级方法，可以跳过这一节，直接进入实现部分。</p></blockquote><p id="39be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们大声思考——我们如何使用类型来描述FSM的每个部分？首先，状态列表的概念可以用一个简单的sum类型来表示:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7102" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看这个转换:它有三个清晰可见的部分:<em class="ly">上一个</em>状态、<em class="ly">下一个</em>状态，以及一个<em class="ly">动作</em>，当转换发生时执行该动作。</p><p id="6f60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们要创建一个普通的旧JavaScript对象(POJO ),我们会将这个想法表达为一个带有三个参数的<code class="fe my mz na nb b">function</code>,返回一个带有三个字段的<code class="fe my mz na nb b">object</code>类型。在类型级别上，它可以用同样的方式表达，使用泛型类型。我们唯一需要的运行时部分是action，它是一个简单的函数:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以定义我们的转换了。我将使用<code class="fe my mz na nb b">string[]</code>作为有效载荷，所以我可以记录转换:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0683" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，<code class="fe my mz na nb b">Noop</code>转换有点棘手，因为它应该可以在<em class="ly">任何</em>两个状态之间插入，从而产生与输入状态相同的输出状态。因此，我把它变成了一个具有固定的<code class="fe my mz na nb b">S</code>类型参数的泛型类。</p><p id="09a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了方便起见，我将定义一组“函数构造器”——将实例化出转换类的简单函数。你马上就会明白为什么它们很方便:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="174c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们终于准备好表达我们第一次从源状态到目标状态的FSM转换了！</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="fb8e" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">现实生活中的例子</h1><blockquote class="mq mr ms"><p id="1c55" class="jn jo ly jp b jq jr js jt ju jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj kk ij bi translated">—好吧，那很好，但它和现实生活有什么共同点呢？—好奇的读者可能会问，所以我想向您展示一个使用所述方法的网络请求者(又名“fetcher”)的真实例子。抓紧，因为它将引入一些新概念，如<a class="ae lo" href="https://github.com/gcanti/fp-ts/blob/master/docs/modules/IORef.ts.md" rel="noopener ugc nofollow" target="_blank"> IORef </a>和<a class="ae lo" href="https://medium.com/@gcanti/functional-typescript-either-vs-validation-66c52f28ce1f" rel="noopener">monad，以及它将使用我的</a><a class="ae lo" href="https://github.com/YBogomolov/circuit-breaker-monad" rel="noopener ugc nofollow" target="_blank">断路器monad </a>包！</p></blockquote><p id="e9ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从有限状态机状态的定义开始。这里我不会仅仅使用字符串文字的总和；相反，我将创建具有运行时标签的简单包装器。在<code class="fe my mz na nb b">circuit-breaker-monad</code>包中使用了这种方法，我将坚持这种方法，以使我的代码风格保持一致。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cc35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们为运行时数据定义一些接口。我将使用一个很棒的<a class="ae lo" href="https://www.mockapi.io/" rel="noopener ugc nofollow" target="_blank"> MockAPI </a>来模拟一些数据。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bdd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我将修改<code class="fe my mz na nb b">Transition</code>类以更好地满足我们的需求。它应该包含一个将在转换期间调用的异步方法:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="11a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们定义我们的转换来表示上图。请注意，每次转换的有效载荷可能不同！</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="900e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一部分是定义我们的实际请求承诺，由断路器包要求。这里我将使用<a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank"> AbortController </a>实验API在超时后取消我的请求:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们代码的主要部分— <code class="fe my mz na nb b">step</code>函数，它在给定FSM当前状态的情况下生成一个<code class="fe my mz na nb b">Transition</code>:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="923e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们定义一个递归方法<code class="fe my mz na nb b">executeFSM</code>，这将使它的用法简单一点:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6d8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们试一试！</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8a3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在<a class="ae lo" href="https://gist.github.com/YBogomolov/1a0ebbd1303f4eab21ff87ec90fa331a" rel="noopener ugc nofollow" target="_blank">我的公共要旨</a>中找到完整的例子。请注意，由于过时的类型，您需要修补<code class="fe my mz na nb b">node-fetch</code>的<code class="fe my mz na nb b">RequestInit</code>接口，以包含一个<code class="fe my mz na nb b">signal</code>，如下所示:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="f12f" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="37da" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我希望这篇小文章能帮助你掌握有限状态机的类型级方法。我很乐意讨论你的想法，所以请回复我，电报回复<a class="ae lo" href="https://t.me/ybogomolov" rel="noopener ugc nofollow" target="_blank"> @ybogomolov </a>，推特回复<a class="ae lo" href="https://twitter.com/YuriyBogomolov" rel="noopener ugc nofollow" target="_blank"> @YuriyBogomolov </a>或通过<a class="ae lo" href="mailto:yuriy.bogomolov@gmail.com?subject=Circuit%20Breaker%20as%20a%20Monad%20feedback" rel="noopener ugc nofollow" target="_blank">yuriy.bogomolov@gmail.com</a>。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><figure class="mf mg mh mi gt mj gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nj"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="nk nl gp gr nm nn"><a href="https://gitconnected.com/learn/typescript" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">学习TypeScript -最佳TypeScript教程(2019) | gitconnected</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">18大TypeScript教程-免费学习TypeScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">gitconnected.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob mo nn"/></div></div></a></div></div></div>    
</body>
</html>