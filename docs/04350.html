<html>
<head>
<title>React Best Practices — Avoiding Anti-Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应最佳实践—避免反模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-best-practices-avoiding-bad-practices-fefe6062787d?source=collection_archive---------10-----------------------#2020-06-22">https://levelup.gitconnected.com/react-best-practices-avoiding-bad-practices-fefe6062787d?source=collection_archive---------10-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/230721f65d4925d957813943c2a735b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Py_grPQXzBOR28_"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Tj·霍洛韦丘克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0c12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，React应用程序也必须写得很好。否则，我们以后会遇到各种各样的问题。</p><p id="d58a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将查看React反模式以避免</p><h1 id="2f37" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用ReactDOM.render的返回值</h1><p id="c477" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">尽管<code class="fe mh mi mj mk b">ReactDOM.render</code>返回了对呈现的React组件实例的引用，但是我们应该避免使用它，因为它是一个遗留特性。</p><p id="53ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">未来的版本可能会异步呈现，所以我们不应该依赖它的返回值。</p><p id="a915" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="46f0" class="mt lf it mk b gy mu mv l mw mx">const inst = ReactDOM.render(&lt;App /&gt;, document.body);<br/>doSomething(inst);</span></pre><p id="ae72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1e51" class="mt lf it mk b gy mu mv l mw mx">ReactDOM.render(&lt;App ref={doSomething} /&gt;, document.body);</span></pre><h1 id="d00b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">尽量减少setState的使用</h1><p id="d6a0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">setState</code>不宜过多使用。这样，我们得到了没有太多副作用或内部状态的纯组件。内部状态可能很难跟踪和测试。</p><h1 id="0910" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用字符串引用</h1><p id="4a33" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该使用字符串引用。这是因为它已经被对象引用所取代。</p><p id="1741" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以与其写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d559" class="mt lf it mk b gy mu mv l mw mx">const Hello = createReactClass({<br/>  render: function() {<br/>    return &lt;div ref="hello"&gt;Hello, world.&lt;/div&gt;;<br/>  }<br/>});</span></pre><p id="b29f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d9db" class="mt lf it mk b gy mu mv l mw mx">function Foo {<br/>  const ref = useRef();</span><span id="bd1f" class="mt lf it mk b gy my mv l mw mx">  useEffect({} =&gt; {<br/>    ref.current.scrollIntoView()<br/>  }, []);</span><span id="38b5" class="mt lf it mk b gy my mv l mw mx">  return &lt;div ref={ref} /&gt;<br/>}</span></pre><p id="cf4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">引用的<code class="fe mh mi mj mk b">current</code>属性有DOM对象。</p><h1 id="481d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要在无状态函数组件中使用它</h1><p id="46e0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">无状态功能组件的一个很大的好处就是我们不用和<code class="fe mh mi mj mk b">this</code>打交道。</p><p id="a5be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不应该用它。</p><p id="6cf5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们应该只访问道具并渲染它们/</p><p id="cd90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，与其写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="edc7" class="mt lf it mk b gy mu mv l mw mx">function Foo(props) {<br/>  return (<br/>    &lt;div&gt;{this.props.bar}&lt;/div&gt;<br/>  );<br/>}</span></pre><p id="f3cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b044" class="mt lf it mk b gy mu mv l mw mx">function Foo(props) {<br/>  return (<br/>    &lt;div&gt;{props.bar}&lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="25bf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们应该避免的常见错别字</h1><p id="a6bd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该避免常见的错别字。</p><p id="c8c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们应该注意这些属性名:</p><ul class=""><li id="8325" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated">属性类型</li><li id="f828" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">上下文类型</li><li id="8d36" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">儿童上下文类型</li><li id="9668" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">默认道具</li></ul><p id="58a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该确保这些方法名称拼写正确:</p><ul class=""><li id="1001" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">getDerivedStateFromProps</code></li><li id="50dd" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">componentWillMount</code></li><li id="c628" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">componentDidMount</code></li><li id="76d9" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">componentWillReceiveProps</code></li><li id="29cf" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">shouldComponentUpdate</code></li><li id="ba7e" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">componentWillUpdate</code></li><li id="9c4a" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">getSnapshotBeforeUpdate</code></li><li id="363f" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">componentDidUpdate</code></li><li id="7d30" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">componentDidCatch</code></li><li id="5cb7" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">componentWillUnmount</code></li><li id="34c5" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">render</code></li></ul><p id="a2f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有些单词很多，很容易出现大小写和拼写错误。</p><h1 id="aba1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要写无效字符</h1><p id="9841" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们的标记中不应该有无效字符。</p><p id="a34f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7117" class="mt lf it mk b gy mu mv l mw mx">&lt;Foo<br/>  name="bar"<br/>  type="string"<br/>  foo="bar"&gt;  <br/>  x="y"&gt;<br/>  Body Text<br/>&lt;/Foo&gt;</span></pre><p id="456c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在<code class="fe mh mi mj mk b">foo=”bar”</code>后面多了一个<code class="fe mh mi mj mk b">&gt;</code>。</p><h1 id="18ec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用未知的DOM属性</h1><p id="57c4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该给DOM元素添加未知的DOM属性。</p><p id="3e70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f374" class="mt lf it mk b gy mu mv l mw mx">&lt;div className="hello"&gt;Hello World&lt;/div&gt;</span></pre><p id="f447" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6858" class="mt lf it mk b gy mu mv l mw mx">&lt;div class="hello"&gt;Hello World&lt;/div&gt;</span></pre><p id="6672" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应用CSS类的正确方法是使用<code class="fe mh mi mj mk b">className</code>属性，而不是<code class="fe mh mi mj mk b">class</code>属性。</p><p id="dd57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有<code class="fe mh mi mj mk b">class</code>道具，因为它是一个保留字。</p><h1 id="0591" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有不安全的生命周期方法</h1><p id="af10" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果它们被标记为不安全，那么我们就不应该使用它。</p><p id="7409" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们包括:</p><ul class=""><li id="3244" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">componentWillMount</code>(还有<code class="fe mh mi mj mk b">UNSAFE_componentWillMount</code>的别名)</li><li id="e2ff" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">componentWillReceiveProps</code>(和<code class="fe mh mi mj mk b">UNSAFE_componentWillReceiveProps</code>别名)</li><li id="a12d" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">componentWillUpdate</code>(和<code class="fe mh mi mj mk b">UNSAFE_componentWillUpdate</code>别名)</li></ul><p id="e3ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些不能用于异步渲染，所以不推荐使用，将被移除。</p><p id="5dbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调用<code class="fe mh mi mj mk b">componentWillMount</code>中的<code class="fe mh mi mj mk b">setState</code>将触发另一次渲染并降低性能。</p><p id="fc48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这和<code class="fe mh mi mj mk b">componentWillMount</code>是一样的。</p><p id="919b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，<code class="fe mh mi mj mk b">componentWillReceiveProps</code>是一个同步方法，不适合异步渲染，所以它将被移除。</p><h1 id="3c1a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要定义未使用属性类型</h1><p id="ebf9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果一个道具类型没有被使用，那么我们应该删除它。</p><p id="b38f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b84e" class="mt lf it mk b gy mu mv l mw mx">class Hello extends React.Component {<br/>  render() {<br/>    return &lt;div&gt;Hello Bob&lt;/div&gt;;<br/>  }<br/>});<br/><br/>Hello.propTypes = {<br/>  name: PropTypes.string<br/>},</span></pre><p id="86dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ad28" class="mt lf it mk b gy mu mv l mw mx">class Hello extends React.Component {<br/>  render() {<br/>    return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;<br/>  }<br/>});<br/><br/>Hello.propTypes = {<br/>  name: PropTypes.string<br/>},</span></pre><h1 id="7b9d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">移除或使用未使用状态</h1><p id="ee64" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们有一个未使用的状态，我们应该使用它们或删除它们。</p><p id="715c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c75a" class="mt lf it mk b gy mu mv l mw mx">class Component extends React.Component {<br/>  state = { foo: 0 };<br/>  render() {<br/>    return &lt;BarComponent /&gt;;<br/>  }<br/>}</span></pre><p id="6b02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d2bb" class="mt lf it mk b gy mu mv l mw mx">class Component extends React.Component {<br/>  state = { foo: 0 };<br/>  render() {<br/>    return &lt;BarComponent foo={this.state.foo} /&gt;;<br/>  }<br/>}</span></pre><h1 id="3762" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要在componentWillUpdate中使用setState</h1><p id="881c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用<code class="fe mh mi mj mk b">componentWillUpdate</code>中的<code class="fe mh mi mj mk b">setState</code>进行第二次渲染。</p><p id="9235" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，我们不应该用这个。</p><p id="151f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们把我们的<code class="fe mh mi mj mk b">setState</code>代码放在别的地方。</p><p id="4989" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="57f4" class="mt lf it mk b gy mu mv l mw mx">class Hello extends React.Compoennt {<br/>  componentWillUpdate() {<br/>     this.setState({<br/>        name: this.props.name.toUpperCase()<br/>      });<br/>  }</span><span id="ec0e" class="mt lf it mk b gy my mv l mw mx">  render() {<br/>    return &lt;div&gt;Hello {this.state.name}&lt;/div&gt;;<br/>  }<br/>};</span></pre><p id="d01e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8da5" class="mt lf it mk b gy mu mv l mw mx">class Hello extends React.Compoennt {<br/>  componentWillUpdate() {<br/>    this.updateStates();<br/>  }</span><span id="30f8" class="mt lf it mk b gy my mv l mw mx">  render() {<br/>    return &lt;div&gt;Hello {this.state.name}&lt;/div&gt;;<br/>  }<br/>};</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/366bccbd8cabd063d8b7546e665c0dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pGWw50k0skV230Ir"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@olia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Olia Gozha </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="94ac" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="a5d5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该停止使用旧的同步生命周期方法，因为它们不适用于异步渲染。</p><p id="cde3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们将在以后的版本中被删除。</p><p id="463c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mh mi mj mk b">setState</code>将降低我们组件的复杂性，使它们更容易操作和测试。</p></div></div>    
</body>
</html>