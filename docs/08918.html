<html>
<head>
<title>4 Ways to Implement Builder Design Pattern in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中实现生成器设计模式的4种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-ways-to-implement-builder-design-pattern-in-c-dd193e07096c?source=collection_archive---------2-----------------------#2021-06-18">https://levelup.gitconnected.com/4-ways-to-implement-builder-design-pattern-in-c-dd193e07096c?source=collection_archive---------2-----------------------#2021-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5e3e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建器，流畅构建器，严格构建器，嵌套构建器。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/15d896f898b95db054af66b5c43b669a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C_6xDAGvvQpCMWIM"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Artem Labunsky 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="96b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程是如此复杂，以至于总是有几种方法来完成同一件事情。</p><p id="264e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建器设计模式也不例外。我将向您介绍用C#实现Builder模式的4种方法，同时有意避免经典的实现(根据我的观察，这实际上并没有被使用)。</p><p id="08b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管下面的一些实现看起来在生产中使用起来很复杂，但是它们是训练你的OO和编码技能的很好的练习。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d475" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.只是建筑商</h1><p id="16b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">生成器是一个类，它提供了一组用户友好的API，客户端可以使用这些API来创建对象。</p><p id="d5bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建器应该尽可能地向客户隐藏不必要的对象创建细节，以便他们容易正确地构建对象<strong class="lb iu">，并且难以不正确地构建对象</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="63b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">HtmlDocumentBuilder</code>公开了简单的API来向HTML文档添加标签和文本。</p><p id="2263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端仍然可以在调用<code class="fe nb nc nd ne b">OpenTag</code>方法之前调用<code class="fe nb nc nd ne b">CloseTag</code>方法，这是一个错误。然而，客户端不再需要处理字符串连接，这比交换方法调用更容易出错。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4e99" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.流畅的建设者</h1><p id="ee96" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Fluent builder是builder设计模式的变体，其中除了<code class="fe nb nc nd ne b">Build</code>之外的每个方法都返回<code class="fe nb nc nd ne b">this</code>指针。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e01f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是Fluent Builder的使用方法:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="86fe" class="nj md it ne b gy nk nl l nm nn">//Usage<br/>HtmlDocument document = new HtmlDocumentBuilder()<br/>    .OpenTag("p")<br/>    .AddText("Text")<br/>    .CloseTag("p")<br/>    .Build();</span><span id="bc03" class="nj md it ne b gy no nl l nm nn">Console.WriteLine(document.Markup); //&lt;p&gt;Text&lt;/p&gt;</span></pre><p id="6d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Fluent Builder允许开发人员将方法链接在一起，这看起来更优雅，并稍微减少了代码重复。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="64c9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.严格的建设者</h1><p id="f8f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">前一个例子的缺点之一是这些方法可以以任何顺序调用。</p><p id="f002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如说<code class="fe nb nc nd ne b">Build</code>方法可以在还没有什么可以构建的时候先调用。当然不会出现编译错误。通知开发人员他们正在做错事的唯一方法是执行运行时检查并抛出异常。</p><p id="d495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有一种方法可以实现生成器，即编译器检查方法被调用的顺序。</p><p id="4899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们把下面的实现叫做<strong class="lb iu">严格构建器</strong>。这使得无法首先调用<code class="fe nb nc nd ne b">Build</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="65e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法是将<code class="fe nb nc nd ne b">Build</code>方法放到一个单独的类中。试图在<code class="fe nb nc nd ne b">HtmlDocumentBuilder</code>类型上调用<code class="fe nb nc nd ne b">Build</code>方法会导致复杂错误，因为<code class="fe nb nc nd ne b">Build</code>方法根本不存在。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/2886acbf85cff8661f8fda4d1c27ab6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5J_cKqETl76Opy_RBymPiw.png"/></div></div></figure><p id="ab2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在调用了<code class="fe nb nc nd ne b">HtmlDocumentBuilder</code>类型上的任何其他方法之后，调用<code class="fe nb nc nd ne b">Build</code>方法和往常一样简单:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="1091" class="nj md it ne b gy nk nl l nm nn">HtmlDocument document = new HtmlDocumentBuilder()<br/>    .AddText("Text")<br/>    .Build();</span></pre><p id="8d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">AddText</code>和其他方法返回包含<code class="fe nb nc nd ne b">Build</code>方法的<code class="fe nb nc nd ne b">HtmlDocumentBuilderFinal</code>对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ec52" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.嵌套生成器</h1><p id="a593" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在对象创建期间，构建者通常需要访问他正在构建的对象的属性。这意味着属性必须有公共设置器，但是这可能会破坏封装。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="da67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个实现中，<code class="fe nb nc nd ne b">MailMessage</code>对象必须公开<code class="fe nb nc nd ne b">List&lt;T&gt;</code>并有公共设置器供<code class="fe nb nc nd ne b">MailMessageBuilder</code>填充。</p><p id="5697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现<code class="fe nb nc nd ne b">MailMessage</code>对象的完全封装并继续使用构建器功能的方法是创建一个嵌套的构建器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2eca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">MailMessage</code>对象中的所有设置器现在都是私有的。</p><p id="78f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">Builder</code>是嵌套类，所以根据C#语言规则，它可以访问<code class="fe nb nc nd ne b">MailMessage</code>对象的私有属性。</p><p id="91ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<code class="fe nb nc nd ne b">MailMessage</code>类的构造函数被有意设为私有。因此，客户端实例化<code class="fe nb nc nd ne b">MailMessage</code>的唯一方法是使用构建器API:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="9a52" class="nj md it ne b gy nk nl l nm nn">var mailMessage =<br/>    new MailMessage.Builder()<br/>    .From("<a class="ae ky" href="mailto:from@from.com" rel="noopener ugc nofollow" target="_blank">from@from.com</a>")<br/>    .To("<a class="ae ky" href="mailto:to@to.com" rel="noopener ugc nofollow" target="_blank">to@to.com</a>")<br/>    .To("<a class="ae ky" href="mailto:to@to2.com" rel="noopener ugc nofollow" target="_blank">to@to2.com</a>")<br/>    .Build();</span></pre><p id="57a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在它创建的对象中嵌套一个构建器也是好的，因为相关的类共存在一起，所以<strong class="lb iu">内聚性更高</strong>。</p><h1 id="c9b0" class="mc md it bd me mf nq mh mi mj nr ml mm jz ns ka mo kc nt kd mq kf nu kg ms mt bi translated">结论</h1><p id="6e75" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">学习如何以不同的方式实现相同的东西是扩展您的编程视野并成为更好的开发人员的好方法。而builder是你可以开始积累经验的东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="d8db" class="nj md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">我的其他文章</h2><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">如何专业地对Bug修复进行代码审查</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">审查bug修复时要问的几个重要问题。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">5种免费提高C#代码性能的方法</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">慢速代码是可选的。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://medium.datadriveninvestor.com/estimation-hell-or-what-can-developers-do-better-with-their-estimates-614f9e71f43d" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">评估地狱，或者开发人员如何利用他们的评估做得更好？</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">估计过程很难，但没那么难。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">medium.datadriveninvestor.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ks oj"/></div></div></a></div></div></div>    
</body>
</html>