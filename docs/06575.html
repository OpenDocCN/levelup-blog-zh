<html>
<head>
<title>PHP Array Functions and C Syntax Loop Methods Few People Even Know.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP数组函数和C语法循环方法甚至很少有人知道。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/php-array-functions-and-c-syntax-loop-methods-few-people-even-know-33c198782a55?source=collection_archive---------3-----------------------#2020-12-08">https://levelup.gitconnected.com/php-array-functions-and-c-syntax-loop-methods-few-people-even-know-33c198782a55?source=collection_archive---------3-----------------------#2020-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="94b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注意，很抱歉，这篇文章会跳过一些语言。</em></p><p id="5b99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大家都知道<code class="fe kp kq kr ks b">count</code>、<code class="fe kp kq kr ks b">for</code>、<code class="fe kp kq kr ks b">foreach</code>。它们是编程数组循环的主食。如果你从事PHP工作，你可能知道它们做什么以及如何使用它们…</p><p id="1bae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是<code class="fe kp kq kr ks b">current</code>、<code class="fe kp kq kr ks b">end</code>、<code class="fe kp kq kr ks b">key</code>、<code class="fe kp kq kr ks b">last</code>、<code class="fe kp kq kr ks b">next</code>、<code class="fe kp kq kr ks b">prev</code>、<code class="fe kp kq kr ks b">reset</code>呢？</p><p id="ff0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更不用说如何在大多数C语法语言中使用<code class="fe kp kq kr ks b">if</code> / <code class="fe kp kq kr ks b">do</code> / <code class="fe kp kq kr ks b">while</code>来巧妙的循环了？</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/db5f2b10559591f5092a224095de1568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00k9Hd8yNb73KtzqF2-kIw.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">向你致以疯狂的敬意，卢普。石头脸黑仔。</figcaption></figure><p id="3675" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在过去的一年左右的时间里，我震惊地发现有多少dev从来没有听说过它们，更不用说理解它们的用途了。促成这篇文章的原因是，我刚刚在做一个匿名的“函数栈”，其他进程可以添加到这个函数栈中，我使用这个函数栈是因为“你不能在foreach中添加到数组中”这个问题；一个同事看到后说“那是什么鬼东西？！?"事实上，当他看到do/while时，他使用了更强烈的语言。</p><p id="067b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们是遍历数组(在某些情况下是对象)的另一种方式，基于一个简单的事实:</p><h1 id="c3e3" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">PHP数组的…不是。</h1><p id="a636" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">这听起来可能很奇怪，但是从汇编语言、C或像我这样的Pascal/ADA开发人员的角度来看，这是真的。PHP就像JavaScript一样伪造数组的外观。</p><p id="7f70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果PHP数组不是真正的数组，那它们是什么呢？答案:<strong class="js iu">尖锐的名单！</strong></p><p id="1d85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">容器对象<em class="ko">(我们不能正常访问)</em>有一个指向第一个和最后一个元素的指针，每个元素都有一个指向它的上一个和下一个兄弟元素的指针。在所有这些指针的情况下，null(或布尔false)意味着没有指针。</p><p id="eefc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不同于“真正的数组”方法，即每个值在内存中一个接一个地正交固定大小，它们可以遍布整个内存，因为每个元素都需要有一个动态大小。为什么需要这样做？因为PHP数组元素可以是任何东西；字符串、整数、浮点——甚至在同一个“数组”中。“真正的”数组依赖于统一大小的数据，这是PHP和JavaScript等动态类型语言所不具备的。</p><p id="ff61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果这听起来很熟悉，那么这与遍历DOM或使用二叉树非常相似。只是在这种情况下，它是一个一维指针驱动的列表。</p><p id="9f8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这使得许多东西——比如foreach——更加高效，但也使得一些东西——比如count() —非常慢。知道如何在JavaScript中做到这一点:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="a04e" class="mq lk it ks b gy mr ms l mt mu">for (var i = 0, iLen = str.length; i &lt; iLen; i++) {</span></pre><p id="1714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行速度比:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="50a0" class="mq lk it ks b gy mr ms l mt mu">for (var i = 0; i &lt; str.length; i++) {</span></pre><p id="e75a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相同的根本原因。为了得到一个数组的长度，JavaScript实际上必须遍历整个指针列表，计算元素数，因为它不是一个真正的数组。如果您在数组上执行“for”循环而不是“foreach ”,同样适用！</p><h1 id="097a" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">那么这些PHP数组函数是干什么的呢？</h1><p id="eed1" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">每个PHP数组都有一个内部指针用来遍历它的元素。Foreach在内部利用了这一点。默认情况下，指针从第一个元素开始。</p><h2 id="69c4" class="mq lk it bd ll mv mw dn lp mx my dp lt kb mz na lx kf nb nc mb kj nd ne mf nf bi translated">函数电流($array):混合；</h2><p id="60b9" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">返回内部指针指向的元素，如果数组为空，则返回布尔值false。</p><h2 id="6ae2" class="mq lk it bd ll mv mw dn lp mx my dp lt kb mz na lx kf nb nc mb kj nd ne mf nf bi translated">函数end($array):混合；</h2><p id="1198" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">将内部指针设置到列表的末尾，然后返回最后一个值。</p><h2 id="fe40" class="mq lk it bd ll mv mw dn lp mx my dp lt kb mz na lx kf nb nc mb kj nd ne mf nf bi translated">功能键($array):混合；</h2><p id="8382" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">返回当前指针指向的数组元素的“key”/index。</p><h2 id="1aff" class="mq lk it bd ll mv mw dn lp mx my dp lt kb mz na lx kf nb nc mb kj nd ne mf nf bi translated">函数next($ array):mixed；</h2><p id="39bc" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">将指针递增一个元素，并返回该元素(如果有)。如果没有下一个元素(列表的结尾),则返回布尔值false。</p><h2 id="f63e" class="mq lk it bd ll mv mw dn lp mx my dp lt kb mz na lx kf nb nc mb kj nd ne mf nf bi translated">function prev($ array):mixed；</h2><p id="1c85" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">将指针递减一个元素，返回该元素(如果有)。如果没有前一个元素(列表的开始)，则返回布尔值false。</p><h2 id="f008" class="mq lk it bd ll mv mw dn lp mx my dp lt kb mz na lx kf nb nc mb kj nd ne mf nf bi translated">函数重置($array):混合；</h2><p id="946c" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">将指针重置为数组的开头，如果有返回值，则返回该值，否则返回布尔值false。</p><h1 id="c993" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我们如何使用它们？</h1><p id="56f0" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">假设我们有这个简单的数组:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="023f" class="mq lk it ks b gy mr ms l mt mu">$test = [ 'a', 'b', 'c', 'd' ];</span></pre><p id="a218" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们想遍历它们来显示键和值。用<code class="fe kp kq kr ks b">foreach</code>表示:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="bcf5" class="mq lk it ks b gy mr ms l mt mu">foreach ($test as $key =&gt; $value) {<br/>  echo $key, ' : ', $value, '&lt;br&gt;';<br/>}</span></pre><p id="ead4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这些方法看起来会像这样:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="99e4" class="mq lk it ks b gy mr ms l mt mu">if ($value = reset($test)) do {<br/>  echo key($test), ' : ', $value, '&lt;br&gt;';<br/>} while ($value = next($test));</span></pre><p id="8ce8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，现在代码更多了，所以…</p><h1 id="a193" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我们为什么要使用它们？！？</h1><p id="4eeb" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">他们可以做<code class="fe kp kq kr ks b">foreach</code>做不到的事情。就像倒着浏览列表一样！这些年来，我在论坛上看到很多帖子，有人在做一些浪费的array_reverse和其他各种愚蠢的把戏，这些本来可以简单地做到:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="245f" class="mq lk it ks b gy mr ms l mt mu">if ($value = end($test)) do {<br/>  echo key($test), ' : ', $value, '&lt;br&gt;';<br/>} while ($value = prev($test));</span></pre><p id="cb0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">引导我写这篇文章的用例也是一个很好的例子。现在假设我们有相同的$test数组，但是当我们遇到字母“c”作为值时，我们希望追加“e”作为新值。</p><p id="a589" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不起作用:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="1187" class="mq lk it ks b gy mr ms l mt mu">foreach ($test as $key =&gt; $value) {<br/>  echo $key, ' : ', $value, '&lt;br&gt;';<br/>  if ($value === "c") $test[] = 'e';<br/>}</span></pre><p id="05b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="da8f" class="mq lk it ks b gy mr ms l mt mu">0 : a<br/>1 : b<br/>2 : c<br/>3 : d</span></pre><p id="2cc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它不输出“e”或它的键。但是，它会将其附加到$test。这源于这样一个事实，即foreach为其循环抓取“last”的键进行比较。<em class="ko">(其实有点蠢)</em>。</p><p id="30df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而这:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="d793" class="mq lk it ks b gy mr ms l mt mu">if ($value = reset($test)) do {<br/>  echo key($test), ' : ', $value, '&lt;br&gt;';<br/>  if ($value === "c") $test[] = 'e';<br/>} while ($value = next($test));</span></pre><p id="0573" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="3606" class="mq lk it ks b gy mr ms l mt mu">0 : a<br/>1 : b<br/>2 : c<br/>3 : d<br/>4 : e</span></pre><p id="2021" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们得到新的键/值对，因为<code class="fe kp kq kr ks b">next</code>实际上寻找列表的真正结尾，因为实际的“最后一个”的下一个将是假的。</p><p id="4276" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，你可以使用一个for循环，但是如果这是一个关联数组，那么这个选项可能就不存在了。</p><h1 id="eeda" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">性能是一个问题吗？</h1><p id="f845" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">你可能会认为这是可能的，但是因为我们实际上使用了底层的基于指针的列表，我们实际上和<code class="fe kp kq kr ks b">foreach</code>一样快，在某些情况下更快。数据的类型会对此产生影响。从PHP 5开始，我就没有对它进行过基准测试，但当时它还没有不同到足以产生任何影响。<em class="ko">将来当我有更多时间的时候，我会坐在板凳上把结果加到这里。</em></p><p id="1413" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不担心，因为你只会在<code class="fe kp kq kr ks b">foreach</code>让你失望的情况下使用这些技术。如果你坚持“正确的工作用正确的工具”，那就不再是哪种方法更快的问题，而是哪种方法能正确地完成工作。</p><p id="d94e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">另一个我认为大多数现代开发者都搞砸的地方。他们学习一种做事的方法，然后试着把它用在所有事情上！就像谚语中的拿着锤子的木匠，突然间所有的东西看起来都像钉子。你可以用锤子敲螺丝，并不意味着这是个好主意……</em></p><h1 id="db70" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">Do/While？实际上</h1><p id="648b" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我知道。有漫画拿它开玩笑。有些“专家”说永远不要使用它，因为它“不安全”。许多语言的Linters会抛出一个警告，甚至是“错误”。</p><p id="a79f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们比毕夫·坦南的48年福特超级豪华车还肥。</p><p id="597c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有很多情况下，初始测试条件与迭代“下一个”不匹配。</p><p id="d3fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，您可能见过这样的代码:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="7abd" class="mq lk it ks b gy mr ms l mt mu">if ($stmt-&gt;rowCount() &gt; 0) {<br/>  while ($row = $stmt-&gt;fetch()) {<br/>    // do something with $row here<br/>  }<br/>} else echo 'No records found.&lt;br&gt;';</span></pre><p id="05eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">许多SQL引擎在选择时不返回行计数。PHP文档中甚至提到了这一点:</p><blockquote class="ng nh ni"><p id="26d4" class="jq jr ko js b jt ju jv jw jx jy jz ka nj kc kd ke nk kg kh ki nl kk kl km kn im bi translated">对于大多数数据库，PDOStatement::rowCount()不会返回受SELECT语句影响的行数。<br/><a class="ae nm" href="https://www.php.net/manual/en/pdostatement.rowcount.php#example-1052" rel="noopener ugc nofollow" target="_blank">https://www . PHP . net/manual/en/pdostatement . rowcount . PHP # example-1052</a></p></blockquote><p id="4dd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以有一种方法可以解决这个问题？</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="5272" class="mq lk it ks b gy mr ms l mt mu">if ($row = $stmt-&gt;fetch()) {<br/>  do {<br/>    // do something with $row here<br/>  } while($row = $stmt-&gt;fetch());<br/>} else echo 'No records found.&lt;br&gt;';</span></pre><p id="9b94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为“do/while”不仅是不可避免的，而且人们也没有经常使用它。</p><p id="857e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我最近多次说过的，似乎现在整个编程运动完全基于这样一个想法，即"<em class="ko">我太蠢了，不能使用它，所以其他人也不应该被允许！</em>”。用那种噪音和心态去燃烧。 <em class="ko">再看90%以上的彻头彻尾的无知者胡说八道最令“棉短绒”抱怨。</em></p><h1 id="f9f3" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">其他语言呢？</h1><p id="430f" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">对于do/while也成立。用JavaScript进行一次简单的DOM遍历。假设你有一个变量“ul ”,它指向一个你想转换成markdown的列表。当然，您可以从“ul”中“getElementsByTagName”或者执行“querySelectorAll”，但是这些方法可能会很慢并且浪费内存。你可以简单地在大教堂里散步。</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="0bd2" class="mq lk it ks b gy mr ms l mt mu">var markdown = '';<br/>if (li = ul.firstElementChild) do {<br/>  markdown += "* " + li.textContent + "\r\n";<br/>} while (li = li.nextElementSibling);</span></pre><p id="c568" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将比任何nodeList或复制的数组方法和for循环执行快许多倍，因为我们“省去了中间人”,不需要任何花哨的“聚集”调用来创建列表。直接去DOM，沿着它的指针走。</p><p id="228e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，我像这样直接进入了DOM，这就是为什么当大多数人谈论他们如何“使用DOM”时，在我的书中他们并没有。GetElementById和QuerySelectorAll不是“DOM操纵”。InnerHTML肯定不是。你需要DOM操作，即removeChild、appendChild、insertBefore、createElement、createTextNode、firstChild、lastChild、nextSibling、previousSibling等。</p><p id="4f66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在JS中，很多时候人们会使用数组、nodeList或其他iterables来处理他们本可以直接操作的东西，这种方式更简洁、执行速度更快，而且只占用很少的内存。</p><p id="22fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，你们中的大多数抱怨Chrome标签页像一群变态狂一样消耗内存，这是他们为了避开大多数愚蠢的JavaScript开发人员糟糕的编码习惯而进行的优化！</p><p id="b4d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">如果你说不出好话，就用意第绪语说。</em></p><p id="c590" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是，在传统的Pascal中没有“while”这样的东西，这是该语言的新成员(如果30多年可以被称为最近的话)。最初，当我学习它时，唯一的条件重复结构是“repeat until()”，它与“do {} while()”直接平行。当我第一次学习机器语言编程时，Pascal是我的第一门高级语言，我认为无条件的首次运行和条件循环是正常的。对于我和我的编程背景来说，就是“while () {}”这就是不自然的结构！</p><blockquote class="nn"><p id="24f2" class="no np it bd nq nr ns nt nu nv nw kn dk translated"><em class="nx"> Kernigan可以去吸它。c不是我最喜欢的编程语言。</em></p></blockquote><h1 id="192c" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu ny lw lx ly nz ma mb mc oa me mf mg bi translated">等等！你也在使用赋值求值！</h1><p id="c6b9" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">这就是PHP程序员嘲笑JavaScript人有多愚蠢的地方……就像C/C++程序员嘲笑JavaScript对非常简单的“with”语句的“Use Strict”处理方式一样。</p><p id="13be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那些“只”和PHP打交道的人可能想知道我在说什么，但是很多自称是JavaScript“专家”的无知之人“如果你做了类似下面的事情，就会完全失去理智:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="a35c" class="mq lk it ks b gy mr ms l mt mu">if (li = ul.firstElementChild) {</span></pre><p id="e23e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">他们中的一半会认为你的意思是==，然后会大喊大叫，大发脾气，说只使用===，而实际上单=并不正确；这对它的运作至关重要。自然，PHP开发人员应该不会发现这有什么问题，因为我们:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="f070" class="mq lk it ks b gy mr ms l mt mu">while ($row = $stmt-&gt;fetch()) {</span></pre><p id="cac7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有该死的时间。在任何使用条件的地方，赋值的这种类型的求值都是可能的。</p><p id="fc4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">测试作业的结果没有错。=，==，和===都有不同的含义，都有存在的理由，同样，仅仅因为有些人太愚蠢而不能正确使用它们，也没有理由因为你自己的无知和愚蠢而到处嚷嚷着让我们停止以“特定的方式”使用它们。</p><p id="bf55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总的来说，有很多学究式的废话被外面那些..嗯……坦白说？我不相信他们能从尿湿了的底部有个洞的纸袋里爬出来。</p><p id="289c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你编写汇编程序。“for”循环是违反直觉的。如果你用这种心态，一个好的“循环30次”应该是:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="c686" class="mq lk it ks b gy mr ms l mt mu">$count = 30;<br/>do {<br/>  // something <br/>} while (--$count);</span></pre><p id="5bd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为<code class="fe kp kq kr ks b">++</code>和<code class="fe kp kq kr ks b">--</code>是赋值，所以您也可以对它们的值进行操作。记住，zero是松散的false……这就相当于PHP在汇编中如何实现循环。</p><p id="c551" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，最有效的x86循环是:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="436a" class="mq lk it ks b gy mr ms l mt mu">MOV ECX, 30<br/>:loop<br/>; do something<br/>LOOP :loop</span></pre><p id="6e9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中ECX是“计数器”寄存器，:loop是标签，并且LOOP命令将ECX递减1，如果递减量没有设置零标志，则跳转到标签。</p><p id="caa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为Ruby在这一点上做对了，考虑到这种语言仍然如此缓慢和低效，这很奇怪。它的许多结构都对应于汇编，这使得它很容易快速运行。</p><p id="74db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JavaScript甚至可以用它来实现一个非常快的NodeList循环。由于类似数组的iterable NodeList的元素是节点对象—通常是Element或TextNode —我们可以使用这些知识来做类似这样的事情:</p><pre class="ku kv kw kx gt mm ks mn mo aw mp bi"><span id="09e1" class="mq lk it ks b gy mr ms l mt mu">for (<br/>  var<br/>    anchors = document.getElementsByTagName('a'),<br/>    i = 0,<br/>    a;<br/>  a = anchors[i];<br/>  i++<br/>) {</span></pre><p id="27d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这看起来可能很奇怪，但实际上这是遍历NodeList或类似的iterable的最快方法，因为你知道没有一个值会丢失false！绕着dumbass Array.forEach运行绝对一圈，其开销会导致回调垃圾。它甚至比for/of还快。<em class="ko">这真的不应该，它说了很多关于脚本引擎中的实现有多糟糕。</em></p><h1 id="fef8" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ob"><img src="../Images/f6058fa9c1a324d9fabb08c4371b60bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-sepBj2z-OlvEtTpJLYOig.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">随机问题:先拉拉链再系紧，还是先系紧再拉拉链？</figcaption></figure><p id="af56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">穿裤子的方法不止一种。同样，有各种不同的循环方法和方式来处理循环和数组；甚至假装JS和PHP中的数组。</p><p id="27f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">学习它们。</p><p id="9d48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很容易就确定了一种做事方式，然后试图全盘应用；把那个方木栓塞进圆孔里。这种心态只会阻碍你作为开发人员的发展。同样，你们中有太多的人盲目地鹦鹉学舌，从那些一开始就没有充分理解事物并给出建议的人那里得到不好的建议。从“不要单身=在某种情况下”的无知到“永远不要做/当”的古怪工作。</p><p id="4122" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把这些很少使用的方法想象成你工具箱里的更多工具，以确保你尽你所能做好工作。</p><p id="99f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些技术的出现不是出于某种恶意，当然也不是出于无知。不要让那些可能以卖汉堡为生的人假装是这个领域的权威，试图告诉你相反的事情。</p></div></div>    
</body>
</html>