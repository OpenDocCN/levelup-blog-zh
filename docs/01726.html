<html>
<head>
<title>JavaScript Type Checking with Flow — More Data Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用流的JavaScript类型检查—更多数据类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-type-checking-with-flow-more-data-types-ebdec9bd7597?source=collection_archive---------7-----------------------#2020-01-25">https://levelup.gitconnected.com/javascript-type-checking-with-flow-more-data-types-ebdec9bd7597?source=collection_archive---------7-----------------------#2020-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/803e5616b09ff78a8259c856a3c2feec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kI0z-iXiyXKemrrT"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@rodlong?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杆长</a>对<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">防溅板</a>拍照</figcaption></figure><p id="22b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Flow是由脸书开发的一个类型检查器，用于强制JavaScript中的数据类型。它有许多内置的数据类型，我们可以用它们来注释变量和函数参数的类型。</p><p id="7ad1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些流特有的数据类型，包括可能类型、文字类型、<code class="fe le lf lg lh b">mixed</code>和<code class="fe le lf lg lh b">any</code>类型</p><h1 id="2bbb" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">也许是类型</h1><p id="39cc" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">也许类型是用来注释可选的变量或参数的。它由类型名前面的问号表示。</p><p id="6be6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，<code class="fe le lf lg lh b">?string</code>和<code class="fe le lf lg lh b">?number</code>可能分别是字符串和数字的类型。</p><p id="374b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe le lf lg lh b">?string</code>类型，我们可以用一个字符串、<code class="fe le lf lg lh b">null</code>、<code class="fe le lf lg lh b">undefined</code>或者什么都不用设置。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e548" class="mt lj it lh b gy mu mv l mw mx">let a: ?string = null;<br/>let b: ?string = undefined;<br/>let c: ?string;<br/>let d: ?string = 'abc';</span></pre><p id="702c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参数的规则是相同的:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="52a8" class="mt lj it lh b gy mu mv l mw mx">maybeString(null);<br/>maybeString(undefined);<br/>maybeString();<br/>maybeString('abc');</span></pre><p id="6444" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有什么，比如:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="eb79" class="mt lj it lh b gy mu mv l mw mx">maybeString(0);</span></pre><p id="caac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">会给我们带来错误。</p><h1 id="c471" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">可选对象属性</h1><p id="c66c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以通过在属性名后添加一个<code class="fe le lf lg lh b">?</code>来将对象属性标记为可选的。</p><p id="ddc3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="bf2d" class="mt lj it lh b gy mu mv l mw mx">let x: { foo?: string } = {};<br/>let y: { foo?: string } = { foo: 'abc' };</span></pre><p id="8e0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这条规则也适用于参数，因此下面的代码将会起作用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c13a" class="mt lj it lh b gy mu mv l mw mx">function optionalFoo(val:  { foo?: string }){</span><span id="8b23" class="mt lj it lh b gy my mv l mw mx">}</span><span id="2733" class="mt lj it lh b gy my mv l mw mx">optionalFoo({});<br/>optionalFoo({ foo: 'abc'});</span></pre><p id="111a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">undefined</code>也管用。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="81b1" class="mt lj it lh b gy mu mv l mw mx">let y: { foo?: string } = { foo: undefined };</span></pre><p id="7f6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0481" class="mt lj it lh b gy mu mv l mw mx">function optionalFoo(val:  { foo?: string }){</span><span id="402b" class="mt lj it lh b gy my mv l mw mx">}<br/>optionalFoo({ foo: undefined });</span></pre><p id="1000" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">foo</code>属性的任何其他值都将导致错误。</p><h1 id="f35c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">默认功能参数值</h1><p id="4c5f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">像从ES2015或更高版本开始的JavaScript一样，我们可以为函数参数分配默认值。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2de2" class="mt lj it lh b gy mu mv l mw mx">function foo(value: string = "foo") {</span><span id="675e" class="mt lj it lh b gy my mv l mw mx">}</span></pre><p id="8cd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">value</code>参数的默认值是<code class="fe le lf lg lh b">'foo'</code>。</p><p id="d958" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以向<code class="fe le lf lg lh b">foo</code>函数传递一个字符串、<code class="fe le lf lg lh b">undefined</code>或者什么都不传递。例如，以下内容将起作用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="06a0" class="mt lj it lh b gy mu mv l mw mx">foo<!-- -->("bar");     <br/>foo<!-- -->(undefined);<em class="mz"><br/></em>foo<!-- -->();</span></pre><p id="7471" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">传入<code class="fe le lf lg lh b">undefined</code>或不传入将导致<code class="fe le lf lg lh b">'foo'</code>成为<code class="fe le lf lg lh b">value</code>参数的值。</p><p id="9592" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">传入的其他所有内容都将导致错误。例如，以下内容不起作用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="38ef" class="mt lj it lh b gy mu mv l mw mx">foo<!-- -->(null);</span></pre><h1 id="0f33" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">文字类型</h1><p id="314f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">Flow有文字类型，允许我们创建只能被赋予少数可能值的变量或函数参数。</p><p id="b9ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f3fb" class="mt lj it lh b gy mu mv l mw mx">let x: 1|2 = 1;</span></pre><p id="90ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe le lf lg lh b">x</code>具有类型<code class="fe le lf lg lh b">1|2</code>，这意味着<code class="fe le lf lg lh b">x</code>只能被赋值1或2。每个可能的值由<code class="fe le lf lg lh b">|</code>符号分隔。<code class="fe le lf lg lh b">|</code>符号是联合类型运算符。它指示该类型是操作数中指示的类型之一。</p><p id="8c66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="61c3" class="mt lj it lh b gy mu mv l mw mx">let y: 1|2 = 3;</span></pre><p id="9b2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到一个错误，因为<code class="fe le lf lg lh b">x</code>被赋予了一个不在<code class="fe le lf lg lh b">y</code>可能值列表中的值。</p><p id="2d19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数参数也是如此。例如，以下内容将起作用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="cca2" class="mt lj it lh b gy mu mv l mw mx">function fruitFn(fruit: 'orange' | 'apple'){</span><span id="fcf5" class="mt lj it lh b gy my mv l mw mx">}</span><span id="b242" class="mt lj it lh b gy my mv l mw mx">fruitFn('apple');</span></pre><p id="aa4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而下面的代码将无法编译:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6017" class="mt lj it lh b gy mu mv l mw mx">function fruitFn(fruit: 'orange' | 'apple'){</span><span id="4f95" class="mt lj it lh b gy my mv l mw mx">}</span><span id="465a" class="mt lj it lh b gy my mv l mw mx">fruitFn('banana');</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/1d5a582b8e94a446382a00ea3f4689ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IIlfx_1xA61yE0hk"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯汀·门多萨在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="740b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">混合型</h1><p id="b2d6" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">mixed</code>类型允许我们给变量或函数参数赋值。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="953f" class="mt lj it lh b gy mu mv l mw mx">function foo(value: mixed) {<br/>  <br/>}</span><span id="4039" class="mt lj it lh b gy my mv l mw mx">foo('apple');<br/>foo(1);<br/>foo(true);</span></pre><p id="8e92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe le lf lg lh b">mixed</code>类型，我们必须在操作参数或变量之前弄清楚实际的类型。在对它们进行操作之前，我们可以使用<code class="fe le lf lg lh b">typeof</code>或<code class="fe le lf lg lh b">instanceof</code>操作符来检查类型。</p><p id="a419" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以检查一个值是字符串还是数字，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="afd5" class="mt lj it lh b gy mu mv l mw mx">function foo(value: mixed) {<br/>  if (typeof value === 'number'){<br/>    return value;<br/>  }<br/>  else if (typeof value === 'string'){<br/>    return +value;<br/>  }<br/>}</span></pre><p id="8547" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用<code class="fe le lf lg lh b">instanceof</code>操作符来检查创建对象的构造函数，并相应地运行代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="39be" class="mt lj it lh b gy mu mv l mw mx">function foo(value: mixed) {<br/>  if (value instanceof Date){<br/>    return value.toUTCString();<br/>  }<br/>  else if (value instanceof Object){<br/>    return value.toString();<br/>  }<br/>}</span></pre><p id="e8f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果Flow不知道我们传入的是什么类型的对象，那么它不会接受代码。例如，我们不能写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d6c9" class="mt lj it lh b gy mu mv l mw mx">function foo(value: mixed) {<br/>  return value.toString();<br/>}</span></pre><p id="9e51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将得到错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9789" class="mt lj it lh b gy mu mv l mw mx">[Flow] Cannot call `value.toString` because property `toString` is missing in mixed [1].</span></pre><h1 id="8a11" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">任何类型</h1><p id="51b1" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">any</code>类型让我们选择不使用流进行类型检查。如果它是一个变量，我们可以把它赋给任何东西，如果它是一个函数参数，我们可以传入任何东西。</p><p id="b8b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它不检查我们调用的方法是否实际存在，或者我们使用的操作符是否实际处理我们传入的数据。</p><p id="2bd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">any</code>类型与<code class="fe le lf lg lh b">mixed</code>类型不同。<code class="fe le lf lg lh b">mixed</code>类型为选中类型。我们必须用代码检查类型，因为我们可以用类型<code class="fe le lf lg lh b">mixed</code>对变量或参数做任何事情。</p><p id="7635" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类型为<code class="fe le lf lg lh b">any</code>的变量或参数没有任何类型检查，所以Flow允许我们对类型为<code class="fe le lf lg lh b">any</code>的变量做任何我们想做的事情。这意味着，如果我们没有检查正在操作的数据类型，我们可能会像其他JavaScript代码一样出现运行时错误。</p><p id="c171" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当类型为<code class="fe le lf lg lh b">any</code>的变量或参数被赋给没有类型注释的其他变量时。它将被设置为<code class="fe le lf lg lh b">any</code>类型。</p><p id="0a14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该通过用类型注释变量或参数来停止这种情况。</p><p id="3085" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们应该写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="40d6" class="mt lj it lh b gy mu mv l mw mx">function fn(obj: any) {<br/>  let bar: number = obj.bar;<br/>}</span></pre><p id="b2a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后将在<code class="fe le lf lg lh b">bar</code>上进行类型检查。这意味着</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5b6e" class="mt lj it lh b gy mu mv l mw mx">function fn(obj: any) {<br/>  let bar: number = obj.bar + 1;  <br/>}</span></pre><p id="e0fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">会有用，但是</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f3c8" class="mt lj it lh b gy mu mv l mw mx">function fn(obj: any) {<br/>  let bar: number = obj.bar + 'abc';  <br/>}</span></pre><p id="743b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">会失败。</p><p id="1c10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Flow有许多数据类型，使得来自JavaScript的类型注释非常方便。我们可以使用<code class="fe le lf lg lh b">mixed</code>类型传入任何东西或将变量赋给任何东西，但是我们可以在传入值或变量赋值后在代码中检查类型。</p><p id="f93f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">any</code>类型绕过了流的类型检查，允许我们给函数赋值或传递值。</p><p id="38e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文字类型让我们将变量或参数设置为列出的可能值，用一个<code class="fe le lf lg lh b">|</code>符号分隔。</p><p id="a12a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许类型使得属性或变量可以被随意传入或停留<code class="fe le lf lg lh b">undefined</code>。</p></div></div>    
</body>
</html>