# 管理和共享充满信心地对本地状态做出反应

> 原文：<https://levelup.gitconnected.com/manage-and-share-react-local-state-with-confidence-42523fee555c>

![](img/a526effc1bbf5d2221246f760b063cf3.png)

最近，我一直在强调避免使用 Redux 或其他状态管理解决方案来处理不需要它的场景或状态片段。不过，我不打算在这里详细阐述。如果你想了解更多为什么我会有这种感觉，看看我以前的[帖子](/react-is-a-state-manager-too-ya-know-ff3a7b357eeb)。我想分享一下我在没有外部状态管理的应用程序中处理 CRUD(**C**create， **R** ead， **U** pdate， **D** elete)的方法(借助 TypeScript)。逻辑本身并不独特，但希望这能让您更多地考虑如何管理组件中的本地状态。

## 让我们开始吧。

让我们建立一个场景，其中我们有一个应用程序，它有与各种帖子相关联的 CRUD，为了简单起见，这些帖子的状态是在一个中央`App`组件中设置的。该组件将从一个 API 获取帖子，将它们设置为本地状态，然后将各种状态更新程序传递给其子组件。我们将在一会儿得到那些更新，首先让我们得到我们的职位。

```
*export* interface Post {
   id: string;
   content: string;
   date: Date;
}const App: React.FC = (): JSX.Element => {
   const [posts, setPosts] = useState<Post[]>([]);
   const [loading, setLoading] = useState<boolean>(true);
   const [error, setError] = useState<boolean>(false);useEffect(() => {
   (async () => {
      *try* {
         const res = *await* fetch(postsUrl);
         const posts: Post[] = *await* res.json();
         *await* setPosts(posts);
      } *catch*(error) {
          setError(error)
      }
    setLoading(false)
   })();
 }, [])
}
```

很酷，很直接的在坐骑上取东西。我们处理 CRUD 的一种方法是简单地将`setPosts`传递给子组件:

```
*//App.tsx
return* (
   <PostList *posts*={posts} />
   <SinglePost *setPosts*={setPosts} />
   <CreatePost *setPosts*={setPosts} />
)
```

例如，在`CreatePost`中，当一个帖子被创建时，我们可以将它添加到我们的`posts`状态:

```
*import* React, { useState, Dispatch, SetStateAction } *from* 'react';
*import* { Post } *from* './App';interface Props {
   setPosts: Dispatch<SetStateAction<Post[]>>
}*//Use TS Omit utility to omit id property that will be generated by the server (in theory)* type CreatePostRequest = <Omit<Post, 'id'>>const initialFormState: CreatePostRequest = { 
   content: '',
   date: new Date()
}const CreatePost: React.FC<Props> = ({ setPosts }): JSX.Element => {
   const [newPost, setNewPost] = useState<CreatePostRequest>(
      initialFormState
   )
   const [loading, setLoading] = useState<boolean>(true);
   const [error, setError] = useState<boolean>(false); const createPost = async (): Promise<void> => {
      setLoading(true);
      *try* {
         const res = *await* fetch(createPostUrl, {
            method: 'POST',
            body: JSON.stringify(newPost)
         })
         const createdPost: Post = *await* res.json();
         *//update parent state* setPosts(prevPosts => [...prevPosts, createdPost]);
         setNewPost(initialFormState)
     } *catch*(error) {
        setError(error)
     }
     setLoading(false)
}... return (
     <form onSubmit={createPost}>
        ...
     </form> )
}
```

因此，当提交表单时，会触发一个创建帖子的请求，然后返回创建的帖子。然后，我们可以将帖子添加到我们的父节点`App`所在的州。提醒一下，任何 set state 函数的初始参数都是前一个状态，所以我们可以把我们的新帖子附加到前一个帖子上。

尽管传递在`App` *中定义的状态更新器可以工作*，但这是一个糟糕的范例。消费组件必须知道如何使用初始的先前状态参数，这给消费组件带来了负担。不仅如此，`App`本质上允许任何使用其状态更新器的组件对状态做任何它想做的事情。

从概念上讲，我喜欢把任何包含给定状态的组件看作是该状态的某种服务器。我的意思是，它是该州唯一的真实来源，实际上是应用程序其他部分的 API。我努力让尽可能少的智能组件管理大量的哑组件——智能在这里指的是完整的应用程序状态

# 满怀信心

让我们定义一些 CRUD 操作符，我们可以更有把握地传递它们。

```
//*App.tsx*
const addPostToLocalState = (newPost: Post) => {
   setPosts(prevPosts => [...prevPosts, newPost])
}const updatePostInLocalState = (updatedPost: Post) => {
   setPosts(prevPosts =>
     prevPosts.map(post => (post.id === updatedPost.id ? 
       updatedPost : post)
    )
 )
}const deletePostFromLocalState = (postId: string) => {
   setPosts(prevPosts => prevPosts.filter(({ id }) => id !== postId))
}
```

所以现在当这些函数被传递给`App`的子组件时，您应该会注意到一些关键的区别。首先，消费者不需要了解状态，他们只需将所需的参数传递给操作，就可以了。此外，在命名本地状态更新程序(坦白地说，是所有的东西)时，我喜欢使用冗长的描述性语言，以免混淆我自己或我团队中的其他开发人员。当在包含 Redux 的代码库中工作时，这一点尤其重要。

我在上面链接的文章中试图强调的一点是，并不是应用程序状态的每一部分都需要在 Redux store 中。我在 99%的 React 应用中使用 Redux，但是它很少有超过 2-5 个属性。我强烈建议你在使用 React state 时，以及更一般的编程中，应用一种极简主义的方法。我可以自信地说，你未来的自己和其他人会感谢你的。

差不多就是这样！

感谢您的倾听👋🏻

你可以在这里联系我