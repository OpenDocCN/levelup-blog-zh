<html>
<head>
<title>Unit testing with ngUpgrade</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ngUpgrade进行单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-testing-with-ngupgrade-b84c36535c6c?source=collection_archive---------17-----------------------#2020-06-04">https://levelup.gitconnected.com/unit-testing-with-ngupgrade-b84c36535c6c?source=collection_archive---------17-----------------------#2020-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e291af2e601167574eff33738438a657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTJj_q7zBUN5DsnE_Wf0JA.jpeg"/></div></div></figure><p id="9407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的两年中，我的团队所做的大部分工作都围绕着ngUpgrade包，我很高兴地说，大部分工作都是无缝和简单的。一旦一切都启动了，降级AngularJS要消费的服务和组件的艺术对我们来说已经很好了。一个在早期给我们带来很多麻烦并且有时仍然令人头疼的领域是消耗两个框架的应用程序的单元测试部分。让我们一步步走过去。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="978e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Services </strong> <br/>为了简洁起见，让我们假设我们有一个现有的AngularJS应用程序，并且我们已经用升级包引导了它。我们已经编写了第一个Angular服务，对它进行了降级，现在正在我们现有的AngularJS服务中使用它。一切都完美无缺，我们感觉棒极了。现在，我们想要为AngularJS服务运行(或者编写，如果它们还不存在的话)我们的单元测试，该服务正在使用降级的Angular服务。还有…</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ld"><img src="../Images/921eccc452418bdcc3650603daeac583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iAmzrUEmiFZjbmnq4PMGTg.png"/></div></div></figure><p id="27a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者其他可能的罪魁祸首</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/101f1bca996dc98281f38a3cd16fd77d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DA-6HTwUYdodRgSYK4bzBg.png"/></div></div></figure><p id="9116" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中UserService是注入AngularJS服务的Angular服务的名称。我在这里创建了一个示例库:<a class="ae lj" href="https://github.com/saconnolly/ngupgrade-unit-testing" rel="noopener ugc nofollow" target="_blank">https://github.com/saconnolly/ngupgrade-unit-testing</a>，我们可以用它来讨论这两个错误消息(感谢<a class="lk ll ep" href="https://medium.com/u/360cd444e1fc?source=post_page-----b84c36535c6c--------------------------------" rel="noopener" target="_blank">托马斯·图拉真</a>，我克隆了他的报告<a class="ae lj" href="https://stackblitz.com/edit/angular-ng-upgrade-downgrade" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angular-ng-upgrade-downgrade</a>作为起点)</p><p id="a1a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您克隆我的回购，检查标签<code class="fe lm ln lo lp b">starting_point</code>，并运行<code class="fe lm ln lo lp b">ng test</code>，您将看到3个测试通过。如果你打开<code class="fe lm ln lo lp b">index.ts</code>，看看<code class="fe lm ln lo lp b">downgraded-angular-module</code>和<code class="fe lm ln lo lp b">downgraded-angular-module-tests</code>两个模块的区别，你会注意到用于测试的模块不需要引导模块。如果你添加了这个，你会得到<code class="fe lm ln lo lp b">Angular injector before bootstrapping</code>错误。然后如果你打开<code class="fe lm ln lo lp b">app.service.ajs.spec.ts</code>你会看到这条线</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/3a44b49e95d3f76dacbf2e60db254b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjwmjdKi79qzVODTvssi0Q.png"/></div></div></figure><p id="2164" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是奇迹发生的地方(感谢<a class="lk ll ep" href="https://medium.com/u/ece7b098dce2?source=post_page-----b84c36535c6c--------------------------------" rel="noopener" target="_blank">皮特·培根·达尔文</a>在<a class="ae lj" href="https://angular.io/api/upgrade/static/testing/createAngularJSTestingModule" rel="noopener ugc nofollow" target="_blank">https://angular . io/API/upgrade/static/testing/createngularjstestingmodule</a>上所做的所有努力)。它允许我们放弃引导混合应用程序进行测试，并允许注入器根据需要运行。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="b7ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">组件</strong></p><p id="2b47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这才是真正有趣的地方。对于跟随代码的任何人，检查标签<code class="fe lm ln lo lp b">starting_components</code>，您将看到一些变化:</p><ul class=""><li id="b321" class="lr ls iq ka b kb kc kf kg kj lt kn lu kr lv kv lw lx ly lz bi translated">添加了角度组件:用户</li><li id="c5cf" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">将AngularJS的组件降级</li><li id="d0cb" class="lr ls iq ka b kb ma kf mb kj mc kn md kr me kv lw lx ly lz bi translated">使用了app.component.ajs.ts中的angularJs <user>组件</user></li></ul><p id="748e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件本身非常简单，当您导航到/angularjs路径时，您可以看到它正在工作。你还可以看到，我添加了一个非常简单的测试来编译angularjs应用程序组件，我还添加了我们之前针对降级服务所做的修复。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/a87e267bccb982f657c21eba7fe47fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGMLd9uhjGr9dVj2CsX7XA.png"/></div></div></figure><p id="0831" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不关心测试降级组件的行为，解决方案是非常简单的(我知道，在这一点上，它变成了组件测试而不是单元测试。但我经常在棱角分明的世界里看到线条模糊)。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/182c5b5b0f682095ae598cd08c5b376e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Kpz6moUHQlUWWgwVC7HQA.png"/></div></div></figure><p id="cb3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将允许我们为降级的组件创建“存根”,这样它们就不会编译实际的组件，而只是作为一个空的HTML元素出现在DOM中。通过检查标签<code class="fe lm ln lo lp b">stub_out_components</code>，您可以在代码中看到这一点。对于在整个应用程序中使用的组件来说，这是一个完美的解决方案，因为您不需要在测试中测试组件的功能。随着升级的进行，您可以根据需要向<code class="fe lm ln lo lp b">directiveStubs</code>数组中添加任意多的指令。</p><p id="b939" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是现在让我们想象一下，在我们的<code class="fe lm ln lo lp b">app.component.ajs.spec.ts</code>中，我们想要测试以确保用户组件呈现了一个span标签。因为存根将覆盖现有AngularJS指令的行为，所以删除该指令是无效的。我们的测试可能很简单，比如:</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/6162928da732ca626029c3bd2e5f803f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwDyO_myYKIURAUc4cY30A.png"/></div></div></figure><p id="be15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，为了让它通过，我们需要编译指令，而不是使用存根。如果您看一下标签<code class="fe lm ln lo lp b">bootstrapped_hybrid_app</code>,我们可以逐步完成让这些测试工作的过程。首先要注意的是，我们不再剔除角度分量，也不再使用createAngularJSTestingModule。我们从调用<code class="fe lm ln lo lp b">clearPlatforms</code>开始，这允许我们破坏现有的测试平台并从头开始。然后我们调用我们在<code class="fe lm ln lo lp b">test-helpers.ts</code>中定义的<code class="fe lm ln lo lp b">testSetup</code>。这允许我们收集我们需要的模块，用我们想要测试的组件引导应用程序，并返回我们将需要的注入器。然后我们使用这个注入器来获得我们在<code class="fe lm ln lo lp b">getUpradeObjects</code>中需要的对象，比如AngularJS <code class="fe lm ln lo lp b">$compile</code>函数。一旦完成，我们就可以使用<code class="fe lm ln lo lp b">compileDirective</code>来编译AngularJS指令，它带有一个嵌套的Angular组件，也将被编译。现在，我们可以这样测试角度组件的内部工作方式:</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/029c8b570c85dab8ffd5b5f954c8a932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-5f_73mCJa67x1wOkPAAQ.png"/></div></div></figure><p id="b6b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我发现的引导混合应用程序允许跨框架单元测试组件的最简单的方法，我希望这有所帮助！</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><div class="le lf lg lh gt mj"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">编写面试问题</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">跳到内容一个完整的平台，在那里我会教你找到下一份工作所需的一切和技巧…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">技术开发</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx jw mj"/></div></div></a></div></div></div>    
</body>
</html>