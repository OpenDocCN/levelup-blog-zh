<html>
<head>
<title>The Truth About Hoisting in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS中关于吊装的真相</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-truth-about-hoisting-in-js-8ac79a08a5f9?source=collection_archive---------3-----------------------#2020-08-29">https://levelup.gitconnected.com/the-truth-about-hoisting-in-js-8ac79a08a5f9?source=collection_archive---------3-----------------------#2020-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="085e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">进入时间死区</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a7d7ad5e4f745c631a859d4957afcbbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0ptzO1Ca8wiCjSBO3mrTg.jpeg"/></div></div></figure><p id="798c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本周早些时候，我正准备做一个技术演讲，讲一些技术面试需要知道的基础JavaScript概念。像往常一样，当准备分享内容时，我会着魔地检查细节，以确保我所有的事实都是正确的。我不想误导任何人。毕竟，这些文章和谈话是为了帮助人们，而不是阻碍他们！</p><h1 id="3071" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">var、let和const</h1><p id="f542" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当我在回顾幻灯片中<code class="fe mo mp mq mr b">var</code>、<code class="fe mo mp mq mr b">let</code>和<code class="fe mo mp mq mr b">const</code>的区别时，我发现自己对<code class="fe mo mp mq mr b">var</code>是唯一一个被吊起的说法提出了质疑。这个“事实”是一位采访者不久前告诉我的，我想他一定是对的，因为他的头衔和公司声誉卓著。</p><p id="8a72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我知道是的，<code class="fe mo mp mq mr b">var</code>肯定被提升了，并用一个<code class="fe mo mp mq mr b">undefined</code>值初始化。我还了解到，如果在函数中有一个未声明的变量，它会在编译阶段自动被提升到作用域的顶部，并被初始化为一个带有假想的<code class="fe mo mp mq mr b">var</code>的全局变量，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/2523d9759e7ef51e3d7466959fe6e243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*A_9HnIDObIy6Qdtno0xGLg.png"/></div></figure><p id="d1e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，当调用<code class="fe mo mp mq mr b">exterminator()</code>时，<code class="fe mo mp mq mr b">cockroachA</code>的now全局变量(用<code class="fe mo mp mq mr b">undefined</code>初始化)用它的新值“我还活着！”。<code class="fe mo mp mq mr b">cockroachA</code>躲过了灭虫者。他活着！！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/782094bc48e7a16a54b5e89a17d14a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*cM6hrRdYbDH5AA45kl4QKA.gif"/></div></figure><h1 id="cc01" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">但是let和const呢？</h1><p id="a484" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当我测试代码示例时，我意识到当我在声明变量的上方引用变量时，带有<code class="fe mo mp mq mr b">let</code>和<code class="fe mo mp mq mr b">const</code>的变量并没有抛出“未定义”的引用错误。相反，引用错误称“初始化前无法访问‘a’”。嗯。🤔</p><pre class="kj kk kl km gt mu mr mv mw aw mx bi"><span id="2c4a" class="my ls it mr b gy mz na l nb nc">console.log(a) <br/>// ReferenceError: Cannot access 'a' before initialization<br/>console.log(b) <br/>// ReferenceError: Cannot access 'b' before initialization</span><span id="569f" class="my ls it mr b gy nd na l nb nc">let a = 'Remy'<br/>const b = 'Linguine'</span><span id="a219" class="my ls it mr b gy nd na l nb nc">console.log(a) // 'Remy'<br/>console.log(b) // 'Linguine'</span></pre><p id="f957" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以看起来这些变量<em class="ne">被</em>吊到了某个地方！否则，我们会收到一条错误消息，指出它们不存在，即“未定义”。我们知道<code class="fe mo mp mq mr b">let</code>和<code class="fe mo mp mq mr b">const</code>只在执行期间被求值，所以它们不像变量<code class="fe mo mp mq mr b">var</code>那样用<code class="fe mo mp mq mr b">undefined</code>值初始化。</p><p id="9f39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">所以如果let和const变量被提升，但没有给定任何值，它们去哪里了？在未初始化的<code class="fe mo mp mq mr b">let</code>和<code class="fe mo mp mq mr b">const</code>变量等待求值的地方，存在着什么样的炼狱？这些可怜的变量被困在什么奇怪的、肮脏的JavaScript底层，无助地向它们无情的主人(编译器和运行时)呼喊，让它们沐浴在初始化的阳光下？？</strong></p><p id="2246" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个炼狱叫做…</p><p id="a145" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">.</p><p id="ab76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">.</p><p id="b536" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">.</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/f52a4eec094c9867d868511775d03913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INd3KDtzvuZdRrc_J4N9tA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8c54348db89a3aef952a1b19525fceda.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*1kfennSKzOCfdkShx8j13A.gif"/></div></figure><p id="da0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但说真的，这是真的！</p><p id="5b8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">据书<a class="ae lq" href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch5.md#uninitialized-variables-aka-tdz" rel="noopener ugc nofollow" target="_blank">你不知道JS </a>:</p><blockquote class="nh ni nj"><p id="b9c4" class="ku kv ne kw b kx ky ju kz la lb jx lc nk le lf lg nl li lj lk nm lm ln lo lp im bi translated">TDZ[时间死区]是一个时间窗口，变量存在但仍未初始化，因此不能以任何方式访问……从技术上讲,<code class="fe mo mp mq mr b">var</code>也有一个TDZ，但它的长度为零，因此我们的程序无法观察到它！只有<code class="fe mo mp mq mr b">let</code>和<code class="fe mo mp mq mr b">const</code>有可观测的TDZ。</p></blockquote><p id="0a73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦执行了代码并评估了变量声明，<code class="fe mo mp mq mr b">let</code>和<code class="fe mo mp mq mr b">const</code>变量将初始化并离开临时死区，使它们可用于作用域的其余部分。</p><p id="4295" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“为什么时间死区会存在？?"你可能会问。既然<code class="fe mo mp mq mr b">var</code>、<code class="fe mo mp mq mr b">let</code>和<code class="fe mo mp mq mr b">const</code>都被提升了，为什么我们不能像处理var那样，用一个<code class="fe mo mp mq mr b">undefined</code>值自动初始化它们呢？</p><p id="904a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原因:<strong class="kw iu">都是</strong> <code class="fe mo mp mq mr b"><strong class="kw iu">const</strong></code> <strong class="kw iu">的错。</strong></p><p id="b498" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为<code class="fe mo mp mq mr b">const</code>不能用新值重新声明，如果它在编译期间被初始化为<code class="fe mo mp mq mr b">undefined</code>，然后在执行期间用新值初始化，这将违背<code class="fe mo mp mq mr b">const</code>所代表的一切！你可能会想，“好吧，我想这是有道理的，但是为什么我们也为<code class="fe mo mp mq mr b">let</code>做这个呢？”</p><blockquote class="nh ni nj"><p id="6bd9" class="ku kv ne kw b kx ky ju kz la lb jx lc nk le lf lg nl li lj lk nm lm ln lo lp im bi translated">嗯，TC39做出了决定:既然我们需要为<code class="fe mo mp mq mr b">const</code>设计一个TDZ，我们也可以为<code class="fe mo mp mq mr b">let</code>设计一个TDZ。事实上，如果我们让<code class="fe mo mp mq mr b">let</code>有一个TDZ，那么我们就阻止了所有那些丑陋的吊人变量。所以有一个一致性的观点，也许还有一点社会工程来改变开发者的行为。(<a class="ae lq" href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apA.md" rel="noopener ugc nofollow" target="_blank">你不知道JS </a>)</p></blockquote><p id="7768" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为<code class="fe mo mp mq mr b">var</code>和<code class="fe mo mp mq mr b">let</code>具有相似的属性，所以它们对齐，并且只有<code class="fe mo mp mq mr b">const</code>有一个时间死区，这不是更有意义吗？是的，这是符合逻辑的，但是我们知道，JavaScript并不总是如此。</p><blockquote class="nh ni nj"><p id="893a" class="ku kv ne kw b kx ky ju kz la lb jx lc nk le lf lg nl li lj lk nm lm ln lo lp im bi translated"><code class="fe mo mp mq mr b">let</code>有一个TDZ，因为<code class="fe mo mp mq mr b">const</code>需要一个TDZ，因为<code class="fe mo mp mq mr b">let</code>和<code class="fe mo mp mq mr b">const</code>在它们提升到(块)范围顶部时模仿<code class="fe mo mp mq mr b">var</code>。给你。太循环了？再读几遍。(<a class="ae lq" href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apA.md" rel="noopener ugc nofollow" target="_blank">你不知道JS </a>)</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/91f6a441cae41d743a6dd966dddc3d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*EfHNEjH-jn473qCepbk9Bg.gif"/></div></figure><h1 id="b3d1" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">那么，我们如何帮助这些无辜的变量避免这种无谓的绝望呢？</h1><p id="ce02" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">避开TDZ和避免潜在引用错误的最好方法是在作用域的顶部声明变量。除了避免错误之外，它还通过将所有可用的变量组合在一个地方，使您的代码更具可读性。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="adaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我的朋友们，这就是你们不断增长的清单上又多了一个奇怪的JS！</p><p id="db4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你遇到过最奇怪的JS怪癖是什么？请在下面的评论中告诉我！</p></div></div>    
</body>
</html>