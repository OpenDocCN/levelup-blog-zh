<html>
<head>
<title>Classes in C# using Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Unity的C#类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/classes-in-c-using-unity-4325f2080353?source=collection_archive---------1-----------------------#2022-04-11">https://levelup.gitconnected.com/classes-in-c-using-unity-4325f2080353?source=collection_archive---------1-----------------------#2022-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/d93b2654f0aaf59b7ca682ce35135d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*B_DH7dvCNcJwmCmmiq112A.png"/></div></figure><div class=""/><p id="347b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">什么是类、自定义类和类继承？在这篇文章中，我将深入探讨这些问题以及更多。上课了！</p><p id="a2f3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一个<em class="kv">类</em>基本上就是一个<em class="kv">脚本</em>，如果你熟悉Unity中的<em class="kv">单声道行为</em>，那么你已经熟悉了类<em class="kv">继承</em>。Mono行为是Unity提供的，这样用户可以将脚本拖放到游戏对象上，这对于面向对象的编程来说很重要。将脚本附加到游戏对象上，以实现运动、UI、射击等功能。因为附加的脚本从Unity继承了mono行为。</p></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="0ab1" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">自定义类</strong></p><p id="3699" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">自定义</em>类是开发人员定义的类，可用于创建模块化，并存储从自定义类继承的其他类的相关信息。对于第一个例子，让我们从一个名为<em class="kv">武器统计</em>的自定义类开始，它将被用作基类来定义创建最基本的武器需要哪些共享变量。在通过一个新的C#脚本来做这件事之前，让我们把它作为一个<em class="kv">自定义</em>类添加到<em class="kv">玩家</em>类中，在那里玩家可以直接访问武器属性。</p><p id="adbb" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<em class="kv">玩家</em>职业的顶端，为<em class="kv">武器属性</em>声明了一个新的公共<em class="kv">定制</em>职业。你可以在图像的底部看到玩家脚本开始的地方。这个<em class="kv">自定义</em>职业将是任何与各种武器相关的信息的基础。所有武器都会有一个<em class="kv">名称</em>、一个<em class="kv">射速</em>和一个<em class="kv">弹药</em>计数，所以这些都存储在<em class="kv">变量</em>中。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/7f01c330a03b7f69991f4d6f67dfb628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*9BlcAF0alz4W36TruQsdHw.png"/></div></figure><p id="8d2c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在玩家类中，新武器的变量可以通过将它们声明为<em class="kv">武器统计</em>来创建，这使用了玩家类之上的<em class="kv">自定义</em>武器统计类。这里我为新的<em class="kv">武器</em>引入两个变量。一个是等离子步枪，另一个是火箭发射器。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi li"><img src="../Images/4710832065b5f451dcacf81cf356e37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*9V2VXbfoSRURJMf2ZNQEnA.png"/></div></figure><p id="302f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在在<em class="kv">开始</em>无效的情况下，可以通过声明火箭发射器为<em class="kv">新</em>武器属性来<em class="kv">创建</em>。在那之后，火箭发射器可以被引用，然后<em class="kv">点符号</em>可以用来给<em class="kv">自定义</em>类中的变量赋值，比如名称、射速和弹药数。现在火箭发射器已经被<em class="kv">实例化</em>，并且它的所有信息已经被<em class="kv">初始化</em>。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/d2e3b2f936336e10f6015fd99abab815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*LdlTARM7Xzdus1EdZrHkSg.png"/></div></figure><p id="319e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这种方法的问题是，你必须为你想制造的每一件武器都这样做。如果你的游戏中有50件武器，这会变得非常冗长乏味。为了真正利用自定义类的能力，建议使用构造函数初始化对象。</p></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="3538" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">构造函数</strong></p><p id="45ec" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">构造函数是<em class="kv">初始化来自<em class="kv">自定义</em>类的</em>对象的一种神奇方式。构造函数使用<em class="kv">公共</em>声明以及声明它的<em class="kv">自定义</em>类的<em class="kv">相同的</em>类名。然后，可以在构造函数中用您想要的任何值初始化变量。这里的主要问题是，这将<em class="kv">硬编码</em>这个信息到自定义武器统计<em class="kv">类</em>中，这是最好避免的。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/6654acfc6da2a1ad86d3b72e778bcc75.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*MLmZH0J2hDsPaXHBh_zfTQ.png"/></div></figure><p id="f6c8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">更好的解决方案是将<em class="kv">参数</em>添加到构造器<em class="kv">方法</em>中，要求用户在创建武器时输入值。现在，用户将有机会在创建新武器时传递他们想要的值，而不是对信息进行硬编码。为了清楚起见，<em class="kv"> this.name </em>引用了<em class="kv">自定义</em>类中的名称<em class="kv">变量</em>，然后将通过构造函数方法<em class="kv">参数</em>传入的<em class="kv">名称</em>的值赋给它。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ll"><img src="../Images/4666fb43426286d2bb754bc6bda71ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyZLDjR3IpaH0uGrmaMsLA.png"/></div></div></figure><p id="08d5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在player类中的火箭发射器声明被打乱了，因为它正在寻找那些要传入这里的参数。我们来处理一下。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/cc6668f59c4fa403ce847d0663846c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*M4Olr7ylFrJfXod1L0rk8A.png"/></div></figure><p id="a51d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在在void <em class="kv"> start </em>的<em class="kv"> player </em>类中，用户可以在创建新武器时在方法<em class="kv">参数</em>中传递他们想要的值。如果您想要在检查器中自定义这些值，该怎么办？好了，我们来看看<em class="kv">序列化定制类</em>。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lr"><img src="../Images/18a71b1d0a5785889024a378097b1821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mAFgF5J6whQQxIKF6bSJYw.png"/></div></div></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="1a8c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">序列化定制类</strong></p><p id="fe76" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们来看看如何创建一个商品数据库。我们首先需要的是一个不继承mono行为的<em class="kv">自定义</em>类，称为<em class="kv">项目</em>。然后我们可以声明所有项目将共享的基本<em class="kv">变量</em>。在这种情况下，有用于<em class="kv"> ID、名称、描述</em>和<em class="kv">图标</em>的变量。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/d93b2654f0aaf59b7ca682ce35135d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*B_DH7dvCNcJwmCmmiq112A.png"/></div></figure><p id="fdb2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下一步是创建一个名为<em class="kv">物品数据库</em>的<em class="kv">空游戏对象</em>，以及对应的同名C#脚本。将继承mono行为的项目数据库脚本拖到项目数据库对象上进行分配。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/1340c6087d8244bfc8e35ac15be03fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*C-nwHWUDFYsHYTC6Xh4uXg.png"/></div></figure><p id="6979" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">可以通过引用物品<em class="kv">类</em>来声明物品变量，然后可以在void start中创建和初始化物品，就像之前的武器类一样。同样，如果您要创建大量的项目，这可能会变得很乏味。让我们通过在自定义的<em class="kv">项目</em>类中添加一个构造函数来简化这个过程。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lt"><img src="../Images/4fac2a31c4fae19a6dc0094517ff6ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KCE-1KdxrF9Gbq7yT2KVAQ.png"/></div></div></figure><p id="0b8f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一个自定义类可以有<em class="kv">多个</em>构造函数。第一个<em class="kv">空</em>构造函数方法将允许用户创建一个<em class="kv">空</em>项，然后<em class="kv">在<em class="kv">项数据库</em>脚本的<em class="kv">空开始</em>中初始化</em>项。第二个构造函数使用需要满足的方法参数<em class="kv">来创建一个条目。</em></p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lu"><img src="../Images/ab18d61c4e60cc5cfd3b5004f16b17a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4OKg-THjxKxuz7fu46vZNg.png"/></div></div></figure><p id="8936" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">回到<em class="kv">物品数据库</em>类，<em class="kv">匕首</em>使用需要<em class="kv">参数</em>的构造函数初始化，而剑使用<em class="kv">空</em>构造函数然后定义之后的值。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lv"><img src="../Images/2c0a5b83deec02288f818fbf73cd5412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0SeLJ5FhhOBG-at4RBWEA.png"/></div></div></figure><p id="7e89" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一个更干净的创建条目的方法是通过一个带有参数的<em class="kv">返回方法</em>。return方法中的<em class="kv"> var </em>数据类型会检测到你试图创建一个新的<em class="kv">项</em>。或者，您也可以键入<strong class="jz jb">项目</strong>项目<em class="kv">项目</em>。通过声明其变量，将其值赋给<em class="kv">创建项目</em>返回方法的值，然后传入所需的<em class="kv">参数</em>来创建屏蔽项目。既然我们已经看到了创建项目的三种不同方式，让我们<em class="kv">序列化</em>这些数据，以便在<em class="kv">检查器</em>中查看。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lw"><img src="../Images/14679b4df8b20be9e294f15a8ea7fd49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Acuc_sslCrwEDunUM035gA.png"/></div></div></figure><p id="fe36" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">即使匕首和剑物品是<em class="kv">公共</em>，它们也不会出现在<em class="kv">检查器</em>中，除非通过基本<em class="kv">物品类</em>使它们可见。这可以通过把<em class="kv">【系统。</em>【可序列化】在<em class="kv">项</em>类的顶部。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/980ff7ed51d527881e9e2c9ed0a5f634.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*DIOaLro_S0yjpiS1uj7idQ.png"/></div></figure><p id="2fb2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在<em class="kv">物品数据库</em>中的<em class="kv">公共</em>物品将在<em class="kv">检查器</em>中可见。盾牌仍然是私有的，所以需要一个额外的序列化字段属性。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/0b76dbfde72fe0df3f4b524cc2f64ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*Q_ruWMYzJRO_MeUuv-0NxA.png"/></div></figure><p id="4ab8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在创建的项目在<em class="kv">检查器</em>中可见。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/29d79d576a1cbe369f77dd07cf3a08ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*Qc55-vbpnCSAL2X7Si_55w.png"/></div></figure><p id="a1dc" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当<em class="kv">播放</em>按钮被按下时，信息通过<em class="kv">构造器</em>和<em class="kv">初始化</em>被<em class="kv">分配给</em>。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/80f068264fd041b3d6852e017f99a691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*ZtOS7gZ7nbqPeQTTbXnvsg.png"/></div></figure><p id="04b3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">由于基础项目类现在被序列化到检查员，你可以绕过所有项目中的硬编码，而是通过<em class="kv">检查员</em>将完全控制权交给<em class="kv">设计者</em>。您所需要的只是数据库中的一个<em class="kv">数组</em>或<em class="kv">列表</em>，使用自定义的<em class="kv"> Item </em>类。<em class="kv"> foreach </em>循环将告诉我当前在<em class="kv">数组中的<em class="kv">的每个</em>项的<em class="kv">名称</em>，</em>但不需要这样做。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ma"><img src="../Images/cac1e3581bef65dd0484a477f1e8fe26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brbvweb49n5gUyRt_Q6Xaw.png"/></div></div></figure><p id="2f96" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<em class="kv">检查器</em>中，数组中的项目数量可以被赋值<em class="kv"> (3) </em>。然后，该数组将填充那么多的<em class="kv">元素</em>，供设计者填充空白信息。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/7bb8ab0beed5d3d532a51a5acd28efb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*UZP7Po-3WtgzPAnina0gqQ.png"/></div></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="ea86" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">挑战:</strong> <em class="kv">客户数据库</em></p><p id="e79a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我的任务是将<em class="kv">客户</em>添加到<em class="kv">数据库</em>中。让我们利用到目前为止所学的知识，创建一个<em class="kv">自定义</em>类来表示一个客户最基本的属性。</p><p id="e4b5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建两个脚本，<em class="kv">客户</em>和<em class="kv">客户数据库</em>。<em class="kv">客户</em>将是<em class="kv">自定义</em>类，而<em class="kv">客户数据库</em>将被附加到一个<em class="kv">空</em>游戏对象，同时继承<em class="kv"> Mono行为</em>。</p><p id="6ad3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">从顶部开始，这个<em class="kv">自定义</em>类被<em class="kv">序列化</em>以显示在<em class="kv">检查器</em>中。这个<em class="kv">公共</em>类不继承Mono行为，有一个<em class="kv">客户属性</em>头。这些属性包括一个<em class="kv">客户ID </em>、<em class="kv">名字</em>和<em class="kv">姓氏</em>、<em class="kv">年龄</em>、<em class="kv">性别</em>和<em class="kv">职业</em>。底部是一个<em class="kv">构造器</em>方法，它采用<em class="kv">参数</em>来创建一个<em class="kv">客户</em>。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mc"><img src="../Images/517129dc125816709e3cf8c9d16e8046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvBqAQywdl7rj9Ne0R6Yqw.png"/></div></div></figure><p id="5fab" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">客户数据库</em>类展示了客户的<em class="kv">数组</em>，以及另外三个硬编码到系统中的客户。有一个<em class="kv">创建客户</em>返回方法，它采用<em class="kv">参数</em>。这些客户在void start中通过使用<em class="kv"> return </em>方法进行初始化。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi md"><img src="../Images/d98154ef1275d06336e6be30d525eff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtanLLjJXFbbmXPs6kPqSA.png"/></div></div></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="8535" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">阶级继承</strong></p><p id="cf87" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们之前设置了一个项目类，它具有所有项目共有的基本特征<em class="kv"> (ID、名称、描述和图标)</em>。现在，需要更多信息的其他项目可以在它们各自的类中创建，同时从<em class="kv"> Item </em>类继承基本特征。创建了一个名为<em class="kv">武器</em>的新类来处理武器物品的创建。另一个叫做<em class="kv">药剂</em>的新职业是为管理各种药剂而创建的。</p><p id="91ad" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里要注意的主要一点是，这两个脚本都不是从<em class="kv">单声道行为</em>继承的，而是从<em class="kv">项目</em>继承的。这样武器和药剂两个职业都将拥有与物品<em class="kv"> (ID，名字，描述，图标)</em>相同的基础信息。武器类有更多的变量来表示与武器相关的东西，并不是所有的物品都需要这些变量<em class="kv">(攻击力和重量)</em>。<em class="kv">示例方法</em>显示在调试消息中，可以从<em class="kv"> Item </em>类中访问<em class="kv"> itemName </em>变量。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi me"><img src="../Images/76f23e87fa26f1e9a92ee359646d287a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*AbvXwTCzvHkt3Wy7dJ30lg.png"/></div></figure><p id="a35f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">药水类只有一个字符串变量，告诉我们药水会有什么效果。这是一个包含与<em class="kv">健康</em>恢复相关的<em class="kv"> int </em>值的好地方。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/4603eaf05a83d66d849c9e2cf61d3879.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*MIDf1E5tZ_uYVmkIlB396Q.png"/></div></figure><p id="ab62" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<em class="kv">项目数据库</em>类中，为新类声明了两个公共变量。有一把军刀<em class="kv">武器</em>和一剂<em class="kv">生命值</em>。你也可以有一个<em class="kv">数组</em>或<em class="kv">列表</em>中的<em class="kv">武器</em>和<em class="kv">药剂</em>，就像用<em class="kv">物品</em>的例子一样。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/0b374ee6a4a90a4feb17f76f32bbb266.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*1c6tKWmkmY2qx_-kuPn1vA.png"/></div></figure><p id="5bc4" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为<em class="kv">武器</em>和<em class="kv">药水</em>职业都在用<em class="kv">系统。在<em class="kv">检查器</em>中可以看到并调整新的军刀和生命药剂的值。</em></p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/8a9eb903472ce7f7ec5ce54c0f443e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*uJmcWSGT98OjGGFiZ3uyAw.png"/></div></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="7f38" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">银行系统:</strong> <em class="kv">继承示例</em></p><p id="d248" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里有一个定制的<em class="kv"> Bank </em>类，它可以被<em class="kv"> Bank Manager </em>脚本继承。所有银行都有一个分支机构的基本属性<em class="kv">名称</em>、<em class="kv">地址</em>以及金库里有多少<em class="kv">现金</em>。可以调用三种方法来检查账户的<em class="kv">余额</em>、<em class="kv">取款</em>或<em class="kv">存款</em>。<em class="kv">调试</em>消息将说出调用该方法的分支的<em class="kv">名称</em>。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/4b0aca4b3afaaca8fff6e6303092b699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*qA1CO-cBDDjDJzHMP2UKJQ.png"/></div></figure><p id="c787" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">银行经理</em>类继承自<em class="kv"> Mono行为</em>，因此它可以附加到场景中的银行对象。一个<em class="kv">银行</em>变量将为每个银行项目提供来自<em class="kv">银行</em>类的所有<em class="kv">细节</em>和<em class="kv">方法</em>，并且位于一个<em class="kv">分支细节</em>变量名称下。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/621fcea0a3cb349acaf4eaa6da9698f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*z5JXdSpqUBgfkHWefX9v6w.png"/></div></figure><p id="8b51" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">联邦信用合作社</em>类继承了<em class="kv">银行</em>的基本属性，但也为<em class="kv">借贷</em>添加了一个值，以及当您的贷款被批准时ping的<em class="kv">方法</em>。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/47de63d9c7bdce7ff6c2c9a73d8c717b.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*tQQsk2ilI5evQinzDYvA5g.png"/></div></figure><p id="23d8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建一个<em class="kv">联邦信用合作社经理</em>类来放置在银行游戏对象上，并使用从<em class="kv">银行</em>继承的<em class="kv"> FCU </em>类来处理所有细节。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/81d6f55b0d64fb1893c47b1d3b4cf9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*tTohwsYmeP96m8Y8tvgmVA.png"/></div></figure><p id="43aa" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在层次结构中创建立方体原语来表示一些不同的已知银行机构。美洲银行、富国银行和夏威夷银行都获得附加的<em class="kv">银行经理</em>脚本，而夏威夷联邦信用合作社获得<em class="kv"> FCU经理脚本</em>。这些游戏物体上有<em class="kv">碰撞器</em>，所以当玩家进入银行时，所有的银行信息都可以被碰撞的玩家<em class="kv">访问。</em></p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/44f68a47f666d06a96534f1bcc7c9486.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*7UWQNW-wMtB97YryivNKow.png"/></div></figure><p id="1db3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">每个银行都可以在检查器中分配其唯一的信息。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/f2cbfbcc58b6dea618c61d61dd91e1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*0XvKxbuu1e61QkBEDmKeVA.png"/></div></figure><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/1b0cd376c4773296c16690130565e538.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*sFYw9E3SPIJL49CuXdKHLQ.png"/></div></figure><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/15f6737ce5150acc12509ca6a73ee33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*hXjnBL6xfYzJcXYoTEtDAw.png"/></div></figure><p id="1a0d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">FCU有额外的价值供<em class="kv">可用的钱借给</em>。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/41a8bf7b529d219c792b07fc26e0d71d.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*_QWcbdblebih0dAk3zXhTw.png"/></div></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="8b2b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">受保护的访问修饰符</strong></p><p id="0ba8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">虽然<em class="kv">私有</em>声明使得一个变量或方法只能从它自己的类中访问，而<em class="kv">公共</em>声明允许访问任何脚本，但是<em class="kv">保护的</em>访问修饰符做什么呢？Protected将保持私有，除了从它继承的类。在Bank类中保护这些变量和方法，意味着只有从<em class="kv"> Bank </em>继承而来的<em class="kv">Bank manager</em>可以访问这些数据。即使<em class="kv">系统。Serializable </em>属性出现在<em class="kv"> Bank </em>类的顶部，您仍然需要<em class="kv">序列化</em>各个字段，以便在<em class="kv">检查器</em>中填充它们。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/1ed45ed55609e8a5aa50eb03af1072c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*4to2fTAtzmG2MfAXg7MEaQ.png"/></div></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="e6e3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">虚拟方法和覆盖</strong></p><p id="2f4d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有时候你可能需要用另一个脚本覆盖一个脚本中的数据。让我们来看看如何用宠物系统做到这一点。这个<em class="kv">宠物</em>类将是所有宠物的基类，<em class="kv">从<em class="kv">单声道行为</em>继承</em>，这样它就可以被放置在场景中的宠物<em class="kv">对象</em>上。有一个<em class="kv">受保护的</em>名称，这样只有继承类的<em class="kv">才能访问它，还有一个受保护的<em class="kv">虚拟</em>方法。<em class="kv">虚拟</em>方法可用于存储数据，当从另一个脚本访问时，这些数据可被<em class="kv">覆盖</em>。在void <em class="kv"> start </em>中调用一个Speak方法，该方法调用<em class="kv">虚拟</em>方法，并向<em class="kv">“Speak”</em>的控制台发送一个<em class="kv"> Debug </em>消息。</em></p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/fa8e49c0a301e02b8284f015fcebbcc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*B98P94WJNNiCPgGLG5v61g.png"/></div></figure><p id="6359" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为一只<em class="kv">狗</em>和一只<em class="kv">鸭</em>创建了两个立方体对象。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/f8602d6fd255090892f6f0af9d999578.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*k6Udv3Ju2pZKRQ68phZ2CQ.png"/></div></figure><p id="bb4b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">每种动物都有自己的剧本。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/a9e6297062f34966031f9b2c2b21735c.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*yqLotETJ2kdmrG2pB9WjNA.png"/></div></figure><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/22b8130d932c9d684d699b0dcb1116bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*wJolArZa5hA2sJTqcfuZSg.png"/></div></figure><p id="29a2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">鸭</em>和<em class="kv">狗</em>类<em class="kv">从<em class="kv">宠物</em>继承</em>，并有一个<em class="kv">覆盖</em>的方法。因为<em class="kv">虚拟</em>方法受<em class="kv">保护</em>，所以<em class="kv">覆盖</em>方法也需要<em class="kv">匹配</em>才能工作。因为Pet是基类，如果调用<em class="kv"> base。Speak() </em>，消息到控制台会打印<em class="kv">【Speak】</em>。如果每只动物用自己的语言用<em class="kv">覆盖</em>方法发送信息，打印的信息将被每只动物覆盖，以反映它们的母语。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/afa527ce86e500ae0613ed8eac936e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*0gwz2PsZnasoKE9ewkC_Ew.png"/></div></figure><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mv"><img src="../Images/f34f02b25b29c7baa0d0d260bef9fdc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*ODuRWJ8pbKx4_pXUKfxU0w.png"/></div></div></figure><p id="fb7b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当程序运行时，每个Pet发送一个调试消息，该消息覆盖Pet类中的原始消息！</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1110fbc6d3d1406f9f97db74b6aad165.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*bewnnCZlHr5hlHNSJxOfwQ.png"/></div></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="f738" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">结构和内存管理:</strong> <em class="kv">值类型vs引用类型</em></p><p id="0045" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了开始这个练习，用一个匹配的<em class="kv"> Struct Example </em>类创建一个空的游戏对象。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mx"><img src="../Images/f7b1447d9e53af5abfaf25f4eb86cc61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKKdK2OlvrWRDf57qIKTIw.png"/></div></div></figure><p id="c80b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一个<em class="kv">结构</em>很像一个类，只是有一些限制和非常轻微的<em class="kv">性能</em>提升。与类不同，<em class="kv">结构</em>不能使用类<em class="kv">继承</em>。你使用的<em class="kv">字段</em>的个数应该小于4，数据应该是不可变的<em class="kv">(无法更改)</em>。一个<em class="kv">结构</em>是一个<em class="kv">值类型</em>，它位于<em class="kv">堆栈</em>上，而一个<em class="kv">类</em>是一个<em class="kv">引用类型</em>，它位于<em class="kv">堆</em>上。一个<strong class="jz jb">值类型</strong> <em class="kv"> (bool，float，byte，char，double，int，long，struct) </em>直接存储自己的数据。一个<strong class="jz jb">引用类型</strong> <em class="kv"> (string，array，class，delegate) </em>指向硬盘上一个<em class="kv">内存地址</em>，数据实际存储在那里，而不是直接存储数据。让我们做一个练习，看看它们的功能有何不同。</p><p id="da06" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<em class="kv"> Struct Example </em>类之上，有一个Struct <em class="kv"> (Item2) </em>和一个类<em class="kv"> (Item3) </em>看似功能相同。两者都有一个<em class="kv">构造函数</em>方法，该方法使用<em class="kv">参数</em>来创建项目。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi my"><img src="../Images/ace9d190248f98e8e87ea5018caa3600.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*VH5R-_S5Ae_5eZf9uXLnhw.png"/></div></figure><p id="f7e6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<em class="kv"> Struct示例</em>类的顶部，使用<em class="kv"> Item2 </em> struct创建了一个小盾牌，而战斧则使用<em class="kv"> Item3 </em>类创建。这里一个值得注意的区别是，小盾不需要一个<em class="kv"> new </em>声明来被<em class="kv">创建</em>，因为它已经有了自己的信息作为<em class="kv"> value </em>类型。另一方面，战斧确实需要一个新的声明，因为它使用了一个类。在void <em class="kv"> start </em>中可以访问小盾，分配基础属性。为了测试这一点，调用了两个方法来更改项目的名称。一个方法用于<em class="kv">结构</em>，一个方法用于<em class="kv">类</em>。在调用<em class="kv">变值</em>方法前后，有调试消息将<em class="kv">项</em>的<em class="kv">名称</em>发送到控制台。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mz"><img src="../Images/73d94588e1ca1ee4cb51827d02e69967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igd4UNV6r5xErHFdA6e3Ug.png"/></div></div></figure><p id="763b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">战斧是<em class="kv">级</em>基础<em class="kv">参考</em>型。这里可以看到物品的名称是战斧，但是方法之后名称就变成了<em class="kv">蛮族战斧</em>。数据已成功<em class="kv">更改</em>。然而，基于<em class="kv">值类型</em>的<em class="kv">结构</em>在调用<em class="kv">改变值</em>方法之前和之后打印出小盾作为名称。数据被<em class="kv">而不是</em>成功更改。为了发送带有更改值名称的调试消息，我必须从更改值方法本身内部进行。所以它没有改变盾牌的实际价值，而是复制了一份。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi na"><img src="../Images/200c3a0f73ff089ea0be13d303e97553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*flnoD7Jl228r-oLZleUxig.png"/></div></figure><p id="6663" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我希望您喜欢这篇深入研究类和类继承的长篇文章。感谢阅读和快乐编码！</p></div></div>    
</body>
</html>