<html>
<head>
<title>Auto Detecting Mobile Devices &amp; Screen Orientation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动检测移动设备和屏幕方向</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/auto-detecting-mobile-devices-screen-orientation-ddcf9554b45b?source=collection_archive---------1-----------------------#2020-07-19">https://levelup.gitconnected.com/auto-detecting-mobile-devices-screen-orientation-ddcf9554b45b?source=collection_archive---------1-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d989" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用普通的JavaScript</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9c07b6cb6db645a9761108e24fda2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86hECXGoDm9irqihADETVw.png"/></div></div></figure><p id="2e0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为我在上一篇博客<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/top-10-tips-i-learned-from-deployment-1a8db769715b"> <strong class="kw iu">中所写内容的延伸，我想更详细地介绍一下如何用普通JavaScript自动检测移动设备和屏幕方向。</strong></a></p><p id="e091" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我过去一周一直在做的事情，我认为这将是一个有用的话题来写博客。设计响应式布局有很多种方法，尤其是JavaScript为我们提供了多少种选择，但是我们今天要解决的问题非常简单易懂。</p><p id="a957" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> ***注意*** </strong>我想指出Hugo Larrousse提到的一点，这个解决方案在Safari上不工作(感谢Hugo！).</p><p id="bda5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，让我们开始编码吧。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="90d7" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">基础知识</h2><p id="5339" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">首先，让我们尝试检测用户是从移动设备还是台式机/笔记本电脑(为了简洁起见，我们只说是一台计算机)连接到我们的项目。</p><p id="3928" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以从确保静态检测页面加载开始。然后，一旦我们有了工作，我们就可以想出如何在设备切换或屏幕方向改变时自动更新我们的功能。最后，我们可以用函数返回的内容来操作一些DOM元素，以确保一切按预期运行。</p><p id="2f83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了确保我们的出发点是一致的，下面是我正在使用的文件夹结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/a458cc275c1fee3f10ca25672948dd8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*KG9Jvse2j9_BDQjZXikOiA.png"/></div></figure><p id="a9cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前来看，<code class="fe mx my mz na b">detectDevice.js</code>和<code class="fe mx my mz na b">testLog.js</code>是空白的。</p><p id="d0cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mx my mz na b">index.html</code>是一个基本的HTML框架，有一个<code class="fe mx my mz na b">root</code> <code class="fe mx my mz na b">div</code>，一个<code class="fe mx my mz na b">h1</code>元素和一个<code class="fe mx my mz na b">h2</code>元素。它还加载我们的<code class="fe mx my mz na b">detectDevice.js</code>脚本。稍后我们将简要使用<code class="fe mx my mz na b">testLog.js</code>，但这不是必需的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9ba1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">非常基础的东西。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="9d82" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">检测移动设备</h2><p id="4c0e" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">浏览器的<code class="fe mx my mz na b">navigator</code> <code class="fe mx my mz na b">object</code>为我们提供了我们所需要的完美属性。<code class="fe mx my mz na b">navigator.maxTouchPoints</code>设置连接的设备是否有触摸屏。</p><p id="46c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe mx my mz na b">navigator.maxTouchPoints === 0</code>，我们可以安全地假设连接的设备是台式机或笔记本电脑(除非它也有触摸屏，但我们今天不会担心这一点)。如果<code class="fe mx my mz na b">navigator.maxTouchPoints === 1</code>，我们也可以假设连接的设备是智能手机或平板电脑。</p><p id="55a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于0是一个错误的陈述，我们还可以双击<code class="fe mx my mz na b">navigator.maxTouchPoints</code>到<code class="fe mx my mz na b">return</code> <code class="fe mx my mz na b">true</code>或<code class="fe mx my mz na b">false</code>来代替1或0: <code class="fe mx my mz na b">!!navigator.maxTouchPoints</code>。</p><p id="4bcd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了测试这一点，我们可以在<code class="fe mx my mz na b">detectDevice.js</code>中编写一个<code class="fe mx my mz na b">function</code>，名为……嗯……<code class="fe mx my mz na b">detectDevice</code>和<code class="fe mx my mz na b">console.log(!!navigator.maxTouchPoints)</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="25f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Chrome中，如果设备是移动设备，这将<code class="fe mx my mz na b">console.log()</code> <code class="fe mx my mz na b">true</code>或<code class="fe mx my mz na b">false</code>设备是计算机:</p><p id="ab13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">桌面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/642d4260815db1572534b8068b42ecc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U283PnJp-u2qorlMPak_tQ.png"/></div></div></figure><p id="ac90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">手机:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/c99c3eb2f1662cfe1726a59828deae9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wa0JwDYCAgqLOBKHvnheOg.png"/></div></div></figure><p id="eb7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了。</p><p id="ebef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">唯一的问题是，如果我们在设备之间切换，它不会自动更新。我们稍后会解决这个问题。不过现在，让我们让我们的设备方向检测工作。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="f53f" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">检测屏幕方向</h2><p id="66a3" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">检测屏幕的方向与我们检测设备的方式非常相似。我们浏览器的<code class="fe mx my mz na b">window</code> <code class="fe mx my mz na b">object</code>中还有一个非常有用的属性叫做<code class="fe mx my mz na b">window.screen.orientation.angle</code>，非常适合我们的需要。</p><p id="a085" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mx my mz na b">window.screen.orientation.angle</code>设置浏览器视窗旋转的角度，如果移动设备横放(横向),则为0度；如果移动设备正面朝上(纵向),则为90度。再说一次，因为0是一个错误的声明，我们可以单击或双击<code class="fe mx my mz na b">window.screen.orientation.angle</code>并将其视为一个布尔表达式。</p><p id="1f12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这个，我们就可以在<code class="fe mx my mz na b">detectDevice.js</code>上再加一个<code class="fe mx my mz na b">function</code>叫做<code class="fe mx my mz na b">detectOrientation</code>。结合<code class="fe mx my mz na b">navigator.maxTouchPoints</code>，我们可以向<code class="fe mx my mz na b">return</code>写一个嵌套的三元语句:根据设备是否有触摸屏，写“桌面”或“移动”，根据移动设备是侧放还是正面朝上(横向或纵向)，写“横向”或“纵向”:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="728b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Chrome中，如果<code class="fe mx my mz na b">navigator.maxTouchPoints</code>是<code class="fe mx my mz na b">false</code>，这将是<code class="fe mx my mz na b">console.log()</code>‘桌面’。如果是<code class="fe mx my mz na b">false</code>，则检查<code class="fe mx my mz na b">window.screen.orientation.angle</code>是否是<code class="fe mx my mz na b">false</code>和<code class="fe mx my mz na b">return</code>‘人像’。如果不是，它会<code class="fe mx my mz na b">return</code>‘风景’:</p><p id="a54c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">桌面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/1004bc1e013684d343bd98e5a5945a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ki0BkYmNP6AsdNqwlAyKKA.png"/></div></div></figure><p id="e75f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">风景:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/a928b02a8a19395667f706f859c4d79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBzcqzy9W1AFuDwysedYlw.png"/></div></div></figure><p id="f01c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">肖像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/616c1f098a889701492ca6bb8c04db95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUa0jYihVPwuNJH9D2hSKw.png"/></div></div></figure><p id="632f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。这意味着我们的两个功能是正确检测移动设备和屏幕方向。</p><p id="2cdd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是它们是静态的，并且只在页面加载时执行一次。</p><p id="a735" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理想情况下，我们会让这些<code class="fe mx my mz na b">function</code>动态更新它们正在进行的<code class="fe mx my mz na b">return</code>和<code class="fe mx my mz na b">log</code>操作。例如，如果用户旋转他们的手机，或者如果他们想将他们正在浏览的内容从手机发送到笔记本电脑或台式机。我们希望我们的检测功能能够注意到这一点，并在情况发生变化时发出提示。</p><p id="759c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，我们也能搞清楚。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="e927" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">动态地做两者</h2><p id="e9a9" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">首先，让我们将我们的两个探测<code class="fe mx my mz na b">function</code>合并成一个<code class="fe mx my mz na b">function</code>，并将我们的新<code class="fe mx my mz na b">function</code> <code class="fe mx my mz na b">return</code>变成一个<code class="fe mx my mz na b">object</code>。这样，我们可以将两种检测方法打包在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="8ea3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还想从我们的脚本中删除<code class="fe mx my mz na b">function</code>调用。称之为个人偏好，但它也会帮助我们为以后想做的事情做好准备。我仍然希望<code class="fe mx my mz na b">detectDevice()</code>在我们第一次加载页面时运行，我们可以通过添加一个<code class="fe mx my mz na b">“DOMContentLoaded”</code> <code class="fe mx my mz na b">event listener</code>并让它调用<code class="fe mx my mz na b">detectDevice</code> <code class="fe mx my mz na b">function</code>来保留该功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="49cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们现在检查浏览器控制台，无论何时页面被重新加载，我们都应该得到一个漂亮的<code class="fe mx my mz na b">object</code>返回:</p><p id="5d4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">桌面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/505b36507bdbf8c0d73d6b41e8d35aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuZJrRXUNjCHDktmXMg7AQ.png"/></div></div></figure><p id="76b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">风景:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/c098f95c1415a8516187cd09f7ca089a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEm33_WVHzXqafIjd4KbFA.png"/></div></div></figure><p id="912d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">肖像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/3e2f9f33a32bbb8889b3d1f76729da66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSYRMLCX5lKfV36ThXfh1A.png"/></div></div></figure><p id="ec80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以将注意力转向动态更新<code class="fe mx my mz na b">detectDevice</code> <code class="fe mx my mz na b">object</code>。</p><p id="e7bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过在浏览器的<code class="fe mx my mz na b">window</code> <code class="fe mx my mz na b">object</code>中添加一个<code class="fe mx my mz na b">eventListener</code>来实现。问题是我们需要我们的<code class="fe mx my mz na b">detectDevice</code> <code class="fe mx my mz na b">function</code>来执行页面加载和浏览器窗口调整。</p><p id="885c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着我们将需要另一个<code class="fe mx my mz na b">function</code>，也就是所谓的<code class="fe mx my mz na b">“DOMContentLoaded”</code> <code class="fe mx my mz na b">eventListener</code>。这个<code class="fe mx my mz na b">function</code>调用<code class="fe mx my mz na b">detectDevice</code> <code class="fe mx my mz na b">function</code>，给<code class="fe mx my mz na b">window</code> <code class="fe mx my mz na b">object</code>增加一个新的“resize”<code class="fe mx my mz na b">eventListener</code>，每当浏览器窗口调整大小时调用<code class="fe mx my mz na b">detectDevice()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="01c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这正是我们所需要的。</p><p id="ba55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们返回浏览器，尝试在设备和方向之间切换，我们应该会得到正确的<code class="fe mx my mz na b">object</code>的<code class="fe mx my mz na b">console.log()</code>和<code class="fe mx my mz na b">return</code>值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/9cadaea01961b8cdebdf63501621e795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zhA9OyBqNR1MWPFSsdHaig.gif"/></div></div></figure><p id="8444" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在…是的。我知道我们通过一次调用<code class="fe mx my mz na b">detectDevice()</code>得到了两个<code class="fe mx my mz na b">return</code>值。我必须做一些研究，找出原因。</p><p id="073c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原来，在Chrome的开发工具中切换设备或方向时，窗口实际上被调整了两次大小。</p><p id="dbda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用在<code class="fe mx my mz na b">index.html</code>、<code class="fe mx my mz na b">testLog.js</code>中注释掉的第二个脚本来测试这一点:</p><p id="fd6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以将同样的【调整大小】<code class="fe mx my mz na b">eventListener</code>添加到<code class="fe mx my mz na b">window</code> <code class="fe mx my mz na b">object</code>。这一次，我们可以<code class="fe mx my mz na b">console.log()</code>这两个属性<code class="fe mx my mz na b">window.innerWidth</code>和<code class="fe mx my mz na b">window.innerHeight</code>来看看实际发生了什么。</p><p id="e798" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mx my mz na b">testLog.js</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5ed1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mx my mz na b">index.html</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="dbd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是返回的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/e9f494637c29f854a4bdc79c2beb83fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TXFFiHNXGPJE1uY5UqfGfg.gif"/></div></div></figure><p id="c9e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，这似乎不是我们解决方案的问题，只是每当我们在方向之间切换时，窗口被调整大小两次，这导致了两次调用。</p><p id="a68a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有意思。</p><p id="39c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论哪种方式，这都不会对我们所写的内容造成问题。我们有动态检测移动设备和屏幕方向的<code class="fe mx my mz na b">detectDevice.js</code>，我们使用的只是几个<code class="fe mx my mz na b">eventListners</code>和几个简单的<code class="fe mx my mz na b">functions</code>。</p><p id="b001" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太棒了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="f3e5" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">更新DOM</h2><p id="1fe1" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我想为这个博客做的最后一件事是一些简单的DOM操作，并用<code class="fe mx my mz na b">detectDevice.js</code>检测和<code class="fe mx my mz na b">return</code> ing的内容更新两个header元素的<code class="fe mx my mz na b">innerHTML</code>。</p><p id="f472" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我将从<code class="fe mx my mz na b">detectDevice</code> <code class="fe mx my mz na b">function</code>中移除<code class="fe mx my mz na b">return</code>值和<code class="fe mx my mz na b">console.log()</code>值，并在其上链接1个额外的<code class="fe mx my mz na b">function</code>。</p><p id="e845" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个新的<code class="fe mx my mz na b">function</code>将把<code class="fe mx my mz na b">detectDeviceObj</code>作为一个参数，然后查询选择两个标题元素，并用来自<code class="fe mx my mz na b">detectDeviceObj</code>的适当属性替换它们的<code class="fe mx my mz na b">innerHTML</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9938" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，每当我们切换设备或屏幕方向时，我们都会看到<code class="fe mx my mz na b">h1</code>和<code class="fe mx my mz na b">h2 </code>标签更新:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/60f9529fe2a947b20dcf5c46a2958fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XGEpq9eWiQTri79XbFBWdg.gif"/></div></div></figure><p id="1331" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太棒了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="c581" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">任务完成</h2><p id="bdcf" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">虽然我们可以提出许多其他检测移动设备和屏幕方向的解决方案(有许多)，但我发现我们今天提出的解决方案是其中一个更清晰、更易于理解的解决方案。</p><p id="d5b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我在博客开始时提到的，这个解决方案还不能在Safari上使用。Safari不支持<code class="fe mx my mz na b">navigator.maxTouchPoints</code>或<code class="fe mx my mz na b">window.screen.orientation.angle</code>。对此，我有一些潜在的解决方案，但我仍在努力寻找不涉及浏览器嗅探的最干净的解决方案。我会更新我的博客。</p><p id="5c8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我的下一篇博客将讨论React的移动设备和屏幕方向检测。我们将使用和今天一样的<code class="fe mx my mz na b">navigator</code>和<code class="fe mx my mz na b">window</code>属性，但是它的实现会有一点不同。再说一遍，这并不复杂，但我发现它非常有用。尤其是如果你不想弄乱CSS媒体查询的话。</p><p id="6480" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管怎样，我希望你得到了一些有用的信息，希望你所有的函数都返回true，所有的请求都用200来响应。</p><p id="0d86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">保持安全…保持健康…继续为正义而战。</p></div></div>    
</body>
</html>