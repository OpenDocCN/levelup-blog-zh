<html>
<head>
<title>Stacks and Queues in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的堆栈和队列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/stacks-and-queues-in-python-b2e8b4dbd876?source=collection_archive---------2-----------------------#2020-02-28">https://levelup.gitconnected.com/stacks-and-queues-in-python-b2e8b4dbd876?source=collection_archive---------2-----------------------#2020-02-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/c457f89137b8e878bbd2bb63f6e32484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOmHUzESFpWHR2b9tDGIkQ.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="2135" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">学习两种流行的线性数据结构。</h2></div><h2 id="9fb9" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">为什么要看这个？</h2><p id="381a" class="pw-post-body-paragraph lq lr jf ls b lt lu kg lv lw lx kj ly ld lz ma mb lh mc md me ll mf mg mh mi in bi translated">堆栈和队列(<em class="mj">读作kyo͞o或kiu </em>)是简单而强大的数据结构，可以帮助您处理各种情况，其中需要一些有序的操作或逻辑，并且您的数据恰好适合堆栈或队列。它们作为编码面试问题也相当受欢迎，所以最有可能在考试中出现。</p><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="cb27" class="ku kv jf mp b gz mt mu l mv mw">ℹ️ Linear data structures maintain a sequence and ordered relationship to the previous/next element, non linear data structures on the other hand can branch like a <a class="ae mx" href="https://medium.com/swlh/making-data-trees-in-python-3a3ceb050cfd" rel="noopener">tree</a> or have multiple relationships, let's keep it simple and use some graphic examples to explain both...</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="6684" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">基础知识:解释煎饼的堆叠:</h2><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="98b1" class="ku kv jf mp b gz mt mu l mv mw"><strong class="mp jg"># Using lists:</strong><br/>pancakeStack = []</span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nf"><img src="../Images/17ede223a256685b2bd3e2a42d662e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMbmwIbB_MQl9p1z6MvA_Q.png"/></div></div></figure><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="23ca" class="ku kv jf mp b gz mt mu l mv mw"># The operation of adding things to a stack is called <strong class="mp jg">PUSH, </strong>but it's implemented with<strong class="mp jg"> append </strong>in lists<strong class="mp jg">:</strong></span><span id="a6e5" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack.<strong class="mp jg">append</strong>('Pancake #1') </span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nh"><img src="../Images/d45464723dca2a1421984830d37a1165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*enDp7p2HIoGdqYLNjuUrgQ.png"/></div></div></figure><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="36b4" class="ku kv jf mp b gz mt mu l mv mw">pancakeStack.append(<strong class="mp jg">'Pancake #2'</strong>)</span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nh"><img src="../Images/52c9d8386a02249a6b150b45693affd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BnA0x0H9zDSP0sDN8RoX_A.png"/></div></div></figure><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="8ac3" class="ku kv jf mp b gz mt mu l mv mw">pancakeStack.append(<strong class="mp jg">'Pancake #3'</strong>)</span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj ni"><img src="../Images/3ee1254b2afc7ed0689fc04b82a934db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSYJJ0C7iojN9tVqHk7HuA.png"/></div></div></figure><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="e8c7" class="ku kv jf mp b gz mt mu l mv mw"><strong class="mp jg">print(pancakeStack)</strong></span><span id="dfa3" class="ku kv jf mp b gz ng mu l mv mw">&gt;&gt; <strong class="mp jg">['Pancake #1', 'Pancake #2', 'Pancake #3']</strong></span></pre><p id="fec6" class="pw-post-body-paragraph lq lr jf ls b lt nj kg lv lw nk kj ly ld nl ma mb lh nm md me ll nn mg mh mi in bi translated">作为数据结构的堆栈的关键行为是添加和移除元素的方式，所以现在我们已经添加了一些元素，移除元素是以<strong class="ls jg">后进先出</strong> <code class="fe no np nq mp b"><strong class="ls jg">LIFO</strong></code>的方式完成的:</p><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="5e39" class="ku kv jf mp b gz mt mu l mv mw"># The operation of removing things from a stack is called <strong class="mp jg">POP </strong>and matches the list method:</span><span id="f58d" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack.<strong class="mp jg">pop()<br/></strong>print(pancakeStack)</span><span id="b70a" class="ku kv jf mp b gz ng mu l mv mw">&gt;&gt; <strong class="mp jg">['Pancake #1', 'Pancake #2']</strong></span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nr"><img src="../Images/290acadb241f3d8c7c0f9c364688a84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nk1bGVtP3anwCGsMXQo-Qw.png"/></div></div></figure><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="707f" class="ku kv jf mp b gz mt mu l mv mw"># If you repeat the pop operation, you remove the next element on the stack...</span><span id="2bae" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack.<strong class="mp jg">pop()<br/></strong>print(pancakeStack)</span><span id="ceb3" class="ku kv jf mp b gz ng mu l mv mw">&gt;&gt; <strong class="mp jg">['Pancake #1']</strong></span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj ns"><img src="../Images/5d7af9ccbcbd55a9297c5536e15b80ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-WQu5v60D8wHgeq_lc9PQ.png"/></div></div></figure><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="8189" class="ku kv jf mp b gz mt mu l mv mw"># One last pop operation and you are left with an empty <!-- -->p̶l̶a̶t̶e̶ stack:</span><span id="3af9" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack.<strong class="mp jg">pop()<br/></strong>print(pancakeStack)</span><span id="51e6" class="ku kv jf mp b gz ng mu l mv mw">&gt;&gt; <strong class="mp jg">[]</strong></span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nt"><img src="../Images/cd919be74ca87a22c75b094bb78971f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbdf8lO2e0g9_8FoeN-WYA.png"/></div></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="8268" class="ku kv jf mp b gz mt mu l mv mw">👋👋 Hi there 👋👋 all my content is free for Medium subscribers, if you are already a subscriber I wanted to say thank you ! 🎉 If not and you are considering subscribing, you can use my membership referral link, you will be supporting this and other high quality content, Thank you !</span><span id="cb7e" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">⭐️⭐ </strong><a class="ae mx" href="https://k3no.medium.com/membership" rel="noopener"><strong class="mp jg">Subscribe to Medium !</strong></a><strong class="mp jg"> ⭐️⭐️</strong></span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="2279" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">基础知识:解释售票亭排队的原因:</h2><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="9b89" class="ku kv jf mp b gz mt mu l mv mw"># Let's start once more with an empty list which will be our queue. </span><span id="82de" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">ticket_queue = []</strong></span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nu"><img src="../Images/669688ce27cc067c1fb912727b0242de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9vVpwRxgLFstuAkIaRL-BA.png"/></div></div></figure><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="a50a" class="ku kv jf mp b gz mt mu l mv mw"># Adding elements is the same as with stacks, only here it's called enqueue or enqueuing (<em class="mj">but still uses the append list method</em>):</span><span id="8122" class="ku kv jf mp b gz ng mu l mv mw">ticket_queue.<strong class="mp jg">append</strong>('Customer # 1')</span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nv"><img src="../Images/78a18e8d01d8f70b852fe266834cc486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGvirDU8DJr5BVDsi6EfTw.png"/></div></div></figure><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="0cee" class="ku kv jf mp b gz mt mu l mv mw"># Let's add 2 more customers:</span><span id="2256" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">ticket_queue.append('Customer # 2')<br/>ticket_queue.append('Customer # 3')</strong></span><span id="ac83" class="ku kv jf mp b gz ng mu l mv mw">print(ticket_queue)</span><span id="cc34" class="ku kv jf mp b gz ng mu l mv mw">&gt;&gt; ['Customer # 1', 'Customer # 2', 'Customer # 3']</span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nw"><img src="../Images/92bd63a211d09c1e949d7f7cf69a4bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XntpCrN_qyeCh7Ey9Wdxuw.png"/></div></div></figure><p id="328a" class="pw-post-body-paragraph lq lr jf ls b lt nj kg lv lw nk kj ly ld nl ma mb lh nm md me ll nn mg mh mi in bi translated">与堆栈不同，当移除元素时，队列以<strong class="ls jg">先入先出</strong>T1】的方式从开始移除它们，这也被称为<code class="fe no np nq mp b">dequeue</code>或<code class="fe no np nq mp b">dequeuing</code>:</p><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="6980" class="ku kv jf mp b gz mt mu l mv mw"># The only difference here is the index given to <strong class="mp jg">pop(), </strong>which refers to the first element in the list:</span><span id="bdb6" class="ku kv jf mp b gz ng mu l mv mw">print(“Served:" + <strong class="mp jg">ticket_queue.pop(0)</strong>)</span><span id="6775" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">Served:Customer # 1</strong></span><span id="285e" class="ku kv jf mp b gz ng mu l mv mw">print(ticket_queue)</span><span id="56e4" class="ku kv jf mp b gz ng mu l mv mw">&gt;&gt; <strong class="mp jg">['Customer # 2', 'Customer # 3']</strong></span></pre><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nx"><img src="../Images/3ed76510ec49d75542b72345fec53ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RIZUeIh6VzjuYlajzFscxg.png"/></div></div></figure><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="c991" class="ku kv jf mp b gz mt mu l mv mw">You can continue removing or dequeuing elements in the same way:</span><span id="27aa" class="ku kv jf mp b gz ng mu l mv mw">print("Served: " + <strong class="mp jg">ticket_queue.pop(0)</strong>)<br/>&gt;&gt; Served: Customer # 2<br/><br/>print("Served: " + <strong class="mp jg">ticket_queue.pop(0)</strong>)</span><span id="b99c" class="ku kv jf mp b gz ng mu l mv mw">&gt;&gt; Served: Customer # 3</span><span id="630a" class="ku kv jf mp b gz ng mu l mv mw">print(ticket_queue)</span><span id="84ee" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">&gt;&gt; []</strong></span></pre><p id="70a2" class="pw-post-body-paragraph lq lr jf ls b lt nj kg lv lw nk kj ly ld nl ma mb lh nm md me ll nn mg mh mi in bi translated">以下是两者的简短摘要比较:</p><figure class="mk ml mm mn gu iw gi gj paragraph-image"><div class="gi gj ny"><img src="../Images/dd20f54e72d8eb74b38da2b493c80dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*eycnGZxBOckWS80RRo-s9Q.png"/></div></figure><h2 id="8858" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">使用</h2><p id="6d65" class="pw-post-body-paragraph lq lr jf ls b lt lu kg lv lw lx kj ly ld lz ma mb lh mc md me ll mf mg mh mi in bi translated">如果你要在程序的某个地方实现一个<code class="fe no np nq mp b"><strong class="ls jg">undo</strong></code> <strong class="ls jg"> </strong>函数，那么<code class="fe no np nq mp b"><strong class="ls jg">stack</strong></code>将是一个完美的选择。当操作发生在用户界面上时，你可以推送它们，当撤销命令被调用时，你可以弹出它们。</p><p id="9cb0" class="pw-post-body-paragraph lq lr jf ls b lt nj kg lv lw nk kj ly ld nl ma mb lh nm md me ll nn mg mh mi in bi translated">比方说，当数据到达或输入到脚本中时，您需要对一些数据进行一系列操作。A <code class="fe no np nq mp b"><strong class="ls jg">queue</strong></code> <strong class="ls jg"> </strong>是存储(<em class="mj">入队</em>)数据的好地方，稍后将数据发送到下游进行处理。</p><p id="0407" class="pw-post-body-paragraph lq lr jf ls b lt nj kg lv lw nk kj ly ld nl ma mb lh nm md me ll nn mg mh mi in bi translated">所以顺序FIFO(先进先出)，LIFO(后进先出)操作是主要用途。点击此处阅读关于堆栈和队列的其他观点:</p><div class="it iu gq gs iv nz"><a href="https://stackoverflow.com/questions/2074970/stack-and-queue-why" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fp"><div class="ob ab oc cl cj od"><h2 class="bd jg gz z fq oe fs ft of fv fx je bi translated">堆栈和队列，为什么？</h2><div class="og l"><h3 class="bd b gz z fq oe fs ft of fv fx dk translated">有人问我为什么以及何时应该使用堆栈或队列数据结构，而不是数组/列表？你能举个例子吗…</h3></div><div class="oh l"><p class="bd b dl z fq oe fs ft of fv fx dk translated">stackoverflow.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on jb nz"/></div></div></a></div></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="3869" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">复杂性和替代实施:</h2><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="2f12" class="ku kv jf mp b gz mt mu l mv mw">The original reason (<em class="mj">for me at least</em>) to write this article came when reviewing someone else's code and finding an import for collections deque, the good news is that if you've been following the examples, you already know most of what collections deque does , so what follows is a brief overview...</span></pre><p id="507a" class="pw-post-body-paragraph lq lr jf ls b lt nj kg lv lw nk kj ly ld nl ma mb lh nm md me ll nn mg mh mi in bi translated">而列表<code class="fe no np nq mp b">[]</code>似乎非常适合您的一般堆栈和队列需求。如果你需要更多的性能和一些额外的功能还有其他的选择，一个流行的是<code class="fe no np nq mp b"><a class="ae mx" href="https://docs.python.org/2/library/collections.html#deque-objects" rel="noopener ugc nofollow" target="_blank"><strong class="ls jg">collections deque</strong></a></code> <strong class="ls jg"> : </strong></p><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="c859" class="ku kv jf mp b gz mt mu l mv mw"><strong class="mp jg"># STACK: </strong>The syntax is identical (except the deque object), but as mentioned you get better performance... </span><span id="5134" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">from collections import deque</strong></span><span id="7d78" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack = <strong class="mp jg">deque()</strong></span><span id="d0a5" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">Adding elements:</strong></span><span id="6272" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack.<strong class="mp jg">append</strong>('Pancake #1')<br/>pancakeStack.<strong class="mp jg">append</strong>('Pancake #2')<br/>pancakeStack.<strong class="mp jg">append</strong>('Pancake #3')</span><span id="2337" class="ku kv jf mp b gz ng mu l mv mw">print(pancakeStack)<br/># &gt;&gt; deque(['Pancake #1', 'Pancake #2', 'Pancake #3'])</span><span id="d4de" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">Removing elements:</strong></span><span id="3220" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack<strong class="mp jg">.pop()</strong></span><span id="fefe" class="ku kv jf mp b gz ng mu l mv mw">print(pancakeStack)<br/># &gt;&gt; deque(['Pancake #1', 'Pancake #2'])</span><span id="8b5f" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">Get removed element:</strong></span><span id="6d0f" class="ku kv jf mp b gz ng mu l mv mw">print(pancakeStack.<strong class="mp jg">pop()</strong>)<br/># &gt;&gt; Pancake #2<br/></span><span id="5563" class="ku kv jf mp b gz ng mu l mv mw">           ---------------------||---------------------<br/></span><span id="491f" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg"># QUEUE: </strong>The syntax is also similar,the only difference is when removing elements you use <strong class="mp jg">popleft.</strong></span><span id="f40c" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">from collections import deque</strong></span><span id="3fa7" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">ticket_queue = deque()</strong></span><span id="fc8c" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">Adding elements:</strong></span><span id="aee5" class="ku kv jf mp b gz ng mu l mv mw">ticket_queue.<strong class="mp jg">append</strong>('Customer # 1')<br/>ticket_queue.append('Customer # 2')<br/>ticket_queue.append('Customer # 3')</span><span id="9bdd" class="ku kv jf mp b gz ng mu l mv mw">print(ticket_queue)<br/># &gt;&gt;&gt; deque(['Customer # 1', 'Customer # 2', 'Customer # 3'])</span><span id="c822" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">Removing elements:</strong></span><span id="baf9" class="ku kv jf mp b gz ng mu l mv mw">print(ticket_queue.<strong class="mp jg">popleft()</strong>)<br/># &gt;&gt;&gt; Customer # 1</span><span id="d09d" class="ku kv jf mp b gz ng mu l mv mw">print(ticket_queue)<br/># &gt;&gt;&gt; deque(['Customer # 2', 'Customer # 3'])</span></pre><p id="e2ef" class="pw-post-body-paragraph lq lr jf ls b lt nj kg lv lw nk kj ly ld nl ma mb lh nm md me ll nn mg mh mi in bi translated">您可能会发现还有一些其他有用的功能。这些适用于列表和队列:</p><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="6d80" class="ku kv jf mp b gz mt mu l mv mw"><strong class="mp jg"># Length of queue or stack </strong><br/>print(<strong class="mp jg">len(pancakeStack)</strong>)<br/># &gt;&gt; <strong class="mp jg">3</strong></span><span id="c51f" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg"># count items that match x:</strong><br/>print(<strong class="mp jg">pancakeStack.count('Pancake #1')</strong>)<br/># &gt;&gt; <strong class="mp jg">1</strong></span><span id="af2b" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg"># Add a bunch of pancakes in one go:</strong></span><span id="75f9" class="ku kv jf mp b gz ng mu l mv mw">pancakes = ['Pancake #4','Pancake #5','Pancake #6']</span><span id="9332" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack.<strong class="mp jg">extend</strong>(pancakes)</span><span id="301f" class="ku kv jf mp b gz ng mu l mv mw">['Pancake #1', 'Pancake #2', 'Pancake #3', 'Pancake #4', 'Pancake #5', 'Pancake #6']</span><span id="0cbb" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg"># Reverse the queue or stack:</strong></span><span id="15de" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack.<strong class="mp jg">reverse()</strong></span><span id="9184" class="ku kv jf mp b gz ng mu l mv mw"># &gt;&gt; ['Pancake #6', 'Pancake #5', 'Pancake #4', 'Pancake #3’...</span><span id="c24b" class="ku kv jf mp b gz ng mu l mv mw">             ------------- <strong class="mp jg">Deque only:</strong> -------------</span><span id="4195" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg"># Rotate the stack... Move N elements from the end to the start :</strong><br/>pancakeStack.<strong class="mp jg">rotate(1)</strong></span><span id="213b" class="ku kv jf mp b gz ng mu l mv mw">&gt;&gt; [<strong class="mp jg">'Pancake #6'</strong>, 'Pancake #1', 'Pancake #2', 'Pancake #3', 'Pancake #4', 'Pancake #5']</span><span id="fcac" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack.<strong class="mp jg">rotate(2)</strong> # on the original order...</span><span id="e7c8" class="ku kv jf mp b gz ng mu l mv mw">&gt;&gt; [<strong class="mp jg">'Pancake #5', 'Pancake #6'</strong>, 'Pancake #1', 'Pancake #2', 'Pancake #3', 'Pancake #4']</span><span id="4ef7" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">#You can also do the inverse, moving elements from the front of the stack or queue to the back:</strong></span><span id="c87e" class="ku kv jf mp b gz ng mu l mv mw">pancakeStack.<strong class="mp jg">rotate(-1) </strong></span><span id="68f1" class="ku kv jf mp b gz ng mu l mv mw">['Pancake #2', 'Pancake #3', 'Pancake #4', 'Pancake #5', 'Pancake #6', <strong class="mp jg">'Pancake #1'</strong>]</span><span id="bd60" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg"># For the full feature set of deque, check the docs:</strong></span></pre><div class="it iu gq gs iv nz"><a href="https://docs.python.org/2/library/collections.html#deque-objects" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fp"><div class="ob ab oc cl cj od"><h2 class="bd jg gz z fq oe fs ft of fv fx je bi translated">8.3.集合-高性能容器数据类型- Python 2.7.17文档</h2><div class="og l"><h3 class="bd b gz z fq oe fs ft of fv fx dk translated">源代码:Lib/collections.py和Lib/_abcoll.py这个模块实现了专门的容器数据类型，提供了…</h3></div><div class="oh l"><p class="bd b dl z fq oe fs ft of fv fx dk translated">docs.python.org</p></div></div></div></a></div><pre class="mk ml mm mn gu mo mp mq mr aw ms bi"><span id="8a64" class="ku kv jf mp b gz mt mu l mv mw"><strong class="mp jg">More complex: </strong>While beyond this overview, there is yet another way of implementing stacks and queues in python, only this time it is aimed at threaded programming :</span><span id="3b2f" class="ku kv jf mp b gz ng mu l mv mw"><strong class="mp jg">Python queue class:</strong> <a class="ae mx" href="https://docs.python.org/3/library/queue.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/queue.html</a></span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="c8cf" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论:</h2><p id="2642" class="pw-post-body-paragraph lq lr jf ls b lt lu kg lv lw lx kj ly ld lz ma mb lh mc md me ll mf mg mh mi in bi translated">就像编码中的许多事情一样，堆栈和队列一开始可能看起来令人生畏，但是通过正确的类比，它们会变得更容易理解。这里的类比特别管用，因为这些数据结构在日常生活中随处可见，而且非常匹配。如果你今天早上买了咖啡，你很可能是排队的一部分，就像物品和情况无处不在一样。</p><p id="41dc" class="pw-post-body-paragraph lq lr jf ls b lt nj kg lv lw nk kj ly ld nl ma mb lh nm md me ll nn mg mh mi in bi translated">通过使用列表，在python中实现堆栈和队列也非常简单，如果您在野外遇到deque，我希望介绍deque也会对您有所帮助。</p><p id="b7ec" class="pw-post-body-paragraph lq lr jf ls b lt nj kg lv lw nk kj ly ld nl ma mb lh nm md me ll nn mg mh mi in bi translated">感谢阅读！</p></div></div>    
</body>
</html>