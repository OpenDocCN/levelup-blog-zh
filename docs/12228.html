<html>
<head>
<title>Uploading Mirror Server Builds in Unity Easily</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上传镜像服务器很容易在Unity中建立</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/uploading-mirror-server-builds-in-unity-easily-bd29b6fc4957?source=collection_archive---------11-----------------------#2022-05-24">https://levelup.gitconnected.com/uploading-mirror-server-builds-in-unity-easily-bd29b6fc4957?source=collection_archive---------11-----------------------#2022-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="191a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自动化技巧，以帮助测试你的多人游戏服务器建立快</p><p id="f761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/michaelkellam-cs/ArchiveUploadServerExample" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/73b0bd1e5616297e4bd03e1b221d7ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SY7NzdBL9fGYtkrxs7LFjg.png"/></div></div></figure><h1 id="20dc" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">发展的斗争</h1><p id="f759" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当开发多人游戏时，调试网络问题和其他游戏功能已经够难的了。将服务器文件打包并上传到服务器上是另一件痛苦的事情，我已经花了几个小时寻找高效完成这项工作的方法。虽然它并不完美，但我认为我已经有了一个很好的工作流程来简化它，这样你就可以把更多的时间放在开发你的游戏上。</p><h2 id="11cf" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">注意:这个过程不是任何种类的管道，所以我建议您只在想要在正确部署之前快速测试新特性时使用这个方法。</h2><h1 id="171d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">要求</h1><ul class=""><li id="8988" class="mn mo iq jp b jq lw ju lx jy mp kc mq kg mr kk ms mt mu mv bi translated">Windows 10(我们将使用批处理脚本。如果你能写一个<em class="mw"> bash </em>脚本或者其他类型的能够归档和移动文件的脚本，你也许能让它在另一个操作系统上工作)</li><li id="2264" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated"><a class="ae kl" href="https://unity.com/download" rel="noopener ugc nofollow" target="_blank">统一</a></li><li id="2d92" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated"><a class="ae kl" href="https://mirror-networking.com/" rel="noopener ugc nofollow" target="_blank">镜子</a></li><li id="f3c7" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated"><a class="ae kl" href="https://www.win-rar.com/start.html?&amp;L=0" rel="noopener ugc nofollow" target="_blank"> WinRAR </a></li><li id="1251" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated"><a class="ae kl" href="https://www.nuget.org/packages/SSH.NET/" rel="noopener ugc nofollow" target="_blank">仁慈。SshNet C# DLL </a>(使用net35版本。导入dll可能很棘手，所以<a class="ae kl" href="https://www.youtube.com/watch?v=GRn49ehm_pI" rel="noopener ugc nofollow" target="_blank">这里有一个关于如何做的教程</a></li><li id="be46" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated">AWS Lightsail(或其他Linux托管服务)的实例</li></ul><h1 id="854b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">概观</h1><p id="f852" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们将按此顺序:</p><ul class=""><li id="bff0" class="mn mo iq jp b jq jr ju jv jy nc kc nd kg ne kk ms mt mu mv bi translated"><strong class="jp ir">构建</strong>服务器，</li><li id="741d" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated"><strong class="jp ir">归档</strong>使用WinRAR构建的服务器，以及</li><li id="16c3" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated"><strong class="jp ir">使用SFTP将存档的服务器上传到远程托管服务</strong></li></ul><p id="a540" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Unity编辑器中，所有这些都与<strong class="jp ir">中的一个</strong>按钮有关。</p><h1 id="b188" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">出发</h1><p id="0634" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">作为起点，我们将使用<a class="ae kl" href="https://github.com/ShrineGames/UnityMirrorTutorials" rel="noopener ugc nofollow" target="_blank"> ShrineGames的教程repo </a>作为构建脚本(<a class="ae kl" href="https://www.youtube.com/c/ShrineApp" rel="noopener ugc nofollow" target="_blank">看看Shrine，他们有很棒的镜像视频！</a>)。我们将在此基础上构建，特别是Linux服务器脚本。</p><p id="4699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请确保查看该脚本中已经存在的代码，并查看是否需要对其值进行任何更改，以应用于您当前的游戏。例如，<code class="fe nf ng nh ni b">buildPlayerOptions.scenes</code>只有一个场景，它可能与你的任何场景都不对应。之后，我们可以开始归档过程。</p><h1 id="00b0" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">归档</h1><p id="bc19" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">为了上传服务器文件，必须将<strong class="jp ir">存档</strong>。我们将使用<strong class="jp ir"> WinRAR </strong>，因为您可以通过命令行运行它，这对于通过批处理脚本运行它很有用。<br/>您需要将winrar.exe的路径添加到path变量中。稍后，当我们运行归档程序脚本时，将会用到它。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/6fd38777d2e6e3fc2461f659e4f9da9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*uTdkBucQxR-dI8yYGHmqMQ.png"/></div></figure><p id="b401" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我建议将这段代码封装在一个<strong class="jp ir"> try/catch </strong>中，这样你就可以在Unity中记录任何错误。</p><p id="62a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，这将是<strong class="jp ir">归档</strong>文件的方法。我们称之为<code class="fe nf ng nh ni b">ArchiveFile()</code>。我们将使用一个新的<code class="fe nf ng nh ni b">Process</code>作为我们的批处理脚本，这是一个运行WinRAR的简单的一行命令</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="fb57" class="mb kz iq ni b gy no np l nq nr">Process archiveScript = new Process();</span></pre><p id="09ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要找到<strong class="jp ir">到【winrar.exe】的</strong>绝对路径。这是因为当创建一个新进程时，这个进程<em class="mw">不</em>知道任何路径值。所以我们需要在运行之前告诉脚本winrar.exe在哪里，因为我们不能在脚本中只使用路径值。只需几行代码就可以找到这一点，我们将路径字符串分成一个由分号分隔的字符串数组。然后，对于每个字符串，检查目录<em class="mw">与exe名称(winrar.exe)的组合</em>是否表示有效的文件路径。</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="adcc" class="mb kz iq ni b gy no np l nq nr">string exe = "winrar.exe";</span><span id="6187" class="mb kz iq ni b gy ns np l nq nr">string result = Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.Machine)<br/>    .Split(';')<br/>    .Where(s =&gt; File.Exists(Path.Combine(s, exe)))<br/>    .FirstOrDefault();</span><span id="77ea" class="mb kz iq ni b gy ns np l nq nr">result = "\"" + result + "\"\\";</span></pre><p id="7f9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们要设置<strong class="jp ir">文件名</strong>和<strong class="jp ir">参数</strong>。一旦设置了这些<code class="fe nf ng nh ni b">Process</code>值，脚本就可以运行了。</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="38c2" class="mb kz iq ni b gy no np l nq nr">string path = Directory.GetCurrentDirectory() + "/archiver.bat";<br/>archiveScript.StartInfo.FileName = path;<br/>archiveScript.StartInfo.Arguments = result;</span><span id="0e76" class="mb kz iq ni b gy ns np l nq nr">archiveScript.Start();<br/>archiveScript.WaitForExit();</span></pre><p id="338a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据经验，我了解到试图在C#中直接归档<em class="mw">是一件非常困难的事情，所以我让批处理脚本来做。在继续之前，您的<code class="fe nf ng nh ni b">ArchiveFile()</code>方法应该是这样的:</em></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">ArchiveFile()方法</figcaption></figure><p id="7e97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目的根目录下，制作一个名为<code class="fe nf ng nh ni b">archiver.bat</code>的<strong class="jp ir">批处理</strong>脚本，只有一行:</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="e0d1" class="mb kz iq ni b gy no np l nq nr">start cmd /k "cd Builds/Linux &amp;&amp; %1winrar a -r Server.zip &amp;&amp; move Server.zip ../../BuildsForRemote &amp;&amp; exit"</span></pre><p id="593b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个批处理脚本做了几件事，每件事都用<code class="fe nf ng nh ni b">&amp;&amp;</code>隔开:</p><ol class=""><li id="6e4a" class="mn mo iq jp b jq jr ju jv jy nc kc nd kg ne kk nz mt mu mv bi translated">将目录设置为<code class="fe nf ng nh ni b">Builds/Linux</code></li><li id="5678" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk nz mt mu mv bi translated">运行winrar.exe，<strong class="jp ir">归档</strong>服务器文件夹并将其命名为<code class="fe nf ng nh ni b">Server.zip</code>。<code class="fe nf ng nh ni b">%1</code>指的是第一个参数，我们将其设置为winrar.exe的目录。</li><li id="7c89" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk nz mt mu mv bi translated">将Server.zip移动到文件夹<code class="fe nf ng nh ni b">BuildsForRemote</code>。这是为了不让根目录变得混乱。</li><li id="5b2d" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk nz mt mu mv bi translated">退出脚本</li></ol><p id="4e93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<strong class="jp ir">归档</strong>的全部内容。下一部分是<strong class="jp ir">使用SFTP上传</strong>文件。</p><h1 id="2c34" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">上传</h1><p id="9d5f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这个解释将假设你使用一个<strong class="jp ir">私钥</strong>来连接SFTP。我已经在AWS Lightsail上用Debian和Ubuntu测试过了。</p><p id="0bf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们要验证文件是否已经完成<strong class="jp ir">归档</strong>并被移动到文件夹<strong class="jp ir"> BuildsForRemote。</strong>参数<code class="fe nf ng nh ni b">fileChecks</code>记录脚本检查存档文件是否存在的次数。这是必需的，因为在归档仍在进行时调用了<code class="fe nf ng nh ni b">UploadFile()</code>,这意味着在归档完成之前文件将不存在。</p><p id="5900" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们试图<strong class="jp ir">上传</strong>文件之前，我们会检查服务器文件是否存在于指定的目录中。为了确保Unity永远不会在尝试上传文件时陷入循环，您需要设置一个文件检查次数的限制。这将使用一个名为<code class="fe nf ng nh ni b">maxFileChecks</code>的全局变量来完成。</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="b40c" class="mb kz iq ni b gy no np l nq nr">private short maxFileChecks = 50;</span></pre><p id="4ae4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在该方法中，添加了一个<code class="fe nf ng nh ni b">fileChecks</code>的<code class="fe nf ng nh ni b">int</code>参数，所以看起来是这样的:</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="71ee" class="mb kz iq ni b gy no np l nq nr">private static void UploadFile(int fileChecks = 0)</span></pre><p id="d444" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果文件<em class="mw">不存在</em>，我们将递增<code class="fe nf ng nh ni b">fileChecks</code>，并在一秒钟后重试(<code class="fe nf ng nh ni b">Thread.Sleep(1000)</code>)。如果<code class="fe nf ng nh ni b">fileChecks</code>的值达到文件检查的最大次数，而文件还不存在，它将取消<strong class="jp ir">上传</strong>。根据您的计算机需要多长时间将<strong class="jp ir">存档</strong>，您可能想要更改<code class="fe nf ng nh ni b">maxFileChecks</code>的值。对于每个文件检查，它将分配<strong class="jp ir">一秒钟</strong>让脚本完成归档。</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="ebc3" class="mb kz iq ni b gy no np l nq nr">if (!File.Exists(Directory.GetCurrentDirectory() + "/BuildsForRemote/Server.zip")) {<br/>    if (fileChecks &gt;= maxFileChecks) {<br/>        UnityEngine.Debug.Log(string.Format("Could not upload file after {0} attempts. Please try again by clicking \"Retry Upload\"", maxUploadAttempts));<br/>        return;<br/>    }<br/>    Thread.Sleep(1000);<br/>    UploadFile(uploadAttempts, fileChecks + 1);<br/>    return;<br/>}</span></pre><p id="d5c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦发现文件存在于给定的目录中，我们就可以继续设置服务器文件的<strong class="jp ir">上传</strong>，从服务器的凭证开始。</p><p id="5a78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种方式可以拥有<strong class="jp ir"> IP </strong>、<strong class="jp ir">用户名</strong>、<strong class="jp ir">端口</strong>和<strong class="jp ir">私钥</strong>:</p><ul class=""><li id="d9ab" class="mn mo iq jp b jq jr ju jv jy nc kc nd kg ne kk ms mt mu mv bi translated">环境变量(推荐，更安全)</li><li id="4ab2" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated">硬编码</li></ul><p id="bcac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果按照<strong class="jp ir">环境变量</strong>的路线，一个好的命名约定是<code class="fe nf ng nh ni b">GAME-ABBREVIATION_SERVER_DEV_VALUE</code> <br/>，即:<code class="fe nf ng nh ni b">PONG_SERVER_DEV_IP</code>，<code class="fe nf ng nh ni b">PONG_SERVER_DEV_PRIVATE_KEY</code></p><ul class=""><li id="83ae" class="mn mo iq jp b jq jr ju jv jy nc kc nd kg ne kk ms mt mu mv bi translated"><code class="fe nf ng nh ni b">IP</code>:服务器的IP地址</li><li id="1000" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated"><code class="fe nf ng nh ni b">PORT</code>:连接SFTP的港口，几乎都是22</li><li id="8929" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated"><code class="fe nf ng nh ni b">USER</code>:服务器用于连接的用户名</li><li id="8f55" class="mn mo iq jp b jq mx ju my jy mz kc na kg nb kk ms mt mu mv bi translated"><code class="fe nf ng nh ni b">PRIVATE_KEY</code>:用于远程连接服务器的私钥的路径</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a815adf88c4b5e5ae66a2756f21aaaa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*k3q2vONPJmPpyloU0ZGx5g.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">设置用户变量将使你的代码更加安全，因为没有硬编码！</figcaption></figure><p id="ac58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们所有的<strong class="jp ir">上传</strong>功能都将发生在一个叫做<code class="fe nf ng nh ni b">UploadFile()</code>的方法中。</p><p id="c301" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是动态地拉这些环境变量<em class="mw"/>(如果走<strong class="jp ir">硬编码</strong>路线，简单地用值替换<code class="fe nf ng nh ni b">Environment.GetEnvironmentVariable(...)</code></p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="4e38" class="mb kz iq ni b gy no np l nq nr">String ip = Environment.GetEnvironmentVariable("FB_SERVER_DEV_IP", EnvironmentVariableTarget.User);</span><span id="5254" class="mb kz iq ni b gy ns np l nq nr">int port = Int32.Parse(Environment.GetEnvironmentVariable("FB_SERVER_DEV_PORT", EnvironmentVariableTarget.User));</span><span id="0ab6" class="mb kz iq ni b gy ns np l nq nr">String user = Environment.GetEnvironmentVariable("FB_SERVER_DEV_USER", EnvironmentVariableTarget.User);</span><span id="4e11" class="mb kz iq ni b gy ns np l nq nr">String privateKeyStr = Environment.GetEnvironmentVariable("FB_SERVER_DEV_PRIVATE_KEY", EnvironmentVariableTarget.User);</span></pre><p id="8f71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，使用提取的路径获取<strong class="jp ir">私钥</strong>。</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="05d5" class="mb kz iq ni b gy no np l nq nr">PrivateKeyFile privateKey = new PrivateKeyFile(privateKeyStr);</span></pre><p id="a5a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们希望获得我们在<code class="fe nf ng nh ni b">ArchiveFile()</code>中创建的<code class="fe nf ng nh ni b">Server.zip</code>文件的绝对路径，这样我们就可以指向要上传的正确文件。</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="1838" class="mb kz iq ni b gy no np l nq nr">string path = Directory.GetCurrentDirectory() + @"\BuildsForRemote\Server.zip";</span></pre><p id="db75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们使用<strong class="jp ir">仁慈。SshNet </strong> SFTP库上传Server.zip</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="d345" class="mb kz iq ni b gy no np l nq nr">using (var client = new SftpClient(ip, 22, user, privateKey)) {<br/>    client.Connect();<br/></span><span id="b648" class="mb kz iq ni b gy ns np l nq nr">    if (client.IsConnected) {<br/>        byte[] byteData = File.ReadAllBytes(path);<br/>        using (var ms = new MemoryStream(byteData)) {<br/>            ms.Write(byteData, 0, byteData.Length);<br/>            ms.Position = 0;<br/>            client.UploadFile(ms, "/home/ubuntu/fbrev/Server.zip", true);<br/>        }<br/>    } else {    <br/>        UnityEngine.Debug.LogError("Could not connect to server with the given environment credentials.");<br/>    }<br/>}</span></pre><p id="e5e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，作为常规管理，当文件上传完成时，如果您不再需要Server.zip文件，就可以删除它。</p><p id="6aee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nf ng nh ni b">File.Delete(path);</code></p><h1 id="3aa4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">异常处理/优化</h1><p id="30b9" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">就功能而言，这足以让它工作。然而，软件是<em class="mw">永远不会</em>完美的，所以你会想要有一个安全网，以<em class="mw">尝试/捕捉</em>的形式，以确保任何<strong class="jp ir">错误</strong>得到相应的处理。首先，您将希望获得问题的正确记录。此外，如果您想要重试失败的<strong class="jp ir">上传</strong>，您将想要记录已经进行了多少次尝试，这样您可以完全停止上传尝试并记录每次失败尝试背后的原因。</p><p id="7606" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，您将想要添加另一个<em class="mw">全局变量</em>:</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="9517" class="mb kz iq ni b gy no np l nq nr">private static short maxUploadAttempts = 5;</span></pre><p id="f80b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在方法参数中，您将希望再添加一个<code class="fe nf ng nh ni b">int</code>变量，设置为0，称为<code class="fe nf ng nh ni b">uploadAttempts</code></p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="c9ff" class="mb kz iq ni b gy no np l nq nr">private static void UploadFile(int uploadAttempts = 0, int fileChecks = 0)</span></pre><p id="0778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参数<code class="fe nf ng nh ni b">uploadAttempts</code>记录SFTP <strong class="jp ir">上传</strong>的尝试次数。发生错误后，您希望增加该值并重新运行该方法。</p><p id="283d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上传失败有多种原因。如果是一个<code class="fe nf ng nh ni b">ArgumentException</code>，那就是<em class="mw">文件名</em>或者其他参数有问题。在这种情况下，重试<strong class="jp ir">上传</strong>是没有意义的，因为这是我们传递的参数的根本问题，所以我们可以让<strong class="jp ir">上传</strong>失败，并将其记录到Unity中。否则，我们将重试<strong class="jp ir">上传</strong>，递增<code class="fe nf ng nh ni b">uploadAttempts</code>。最终，如果达到最大<strong class="jp ir">上传</strong>尝试限制，它将取消上传并记录错误。</p><p id="d876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mw"> try/catch </em>中，<code class="fe nf ng nh ni b">ArgumentException</code>的特定异常将首先出现，然后是随后的一般异常<code class="fe nf ng nh ni b">Exception</code>，其中它将增加<code class="fe nf ng nh ni b">uploadAttempts</code>并再次尝试，除非达到最大尝试次数</p><pre class="kn ko kp kq gt nk ni nl nm aw nn bi"><span id="d5d9" class="mb kz iq ni b gy no np l nq nr">try {<br/>    // Previous Upload Logic...<br/>} catch (ArgumentException argEx) {<br/>    UnityEngine.Debug.LogError(argEx.StackTrace);<br/>    return;<br/>} catch (Exception ex) {<br/>    if (uploadAttempts &gt;= maxUploadAttempts) {<br/>        UnityEngine.Debug.LogError(ex.ToString());<br/>        return;<br/>    }<br/>    UnityEngine.Debug.LogWarning(string.Format("Upload attempt failed on attempt #{0}. Attempting to upload again. ({0} of {1} max attempts)", uploadAttempts, maxUploadAttempts));<br/>    UploadFile(uploadAttempts + 1, fileChecks);<br/>}</span></pre><p id="6223" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这之后，<code class="fe nf ng nh ni b">UploadFile()</code>应该是这样的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="36ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦这两个方法都完成了，剩下的就是创建一个方法来完成普通的<strong class="jp ir">构建</strong>，然后调用<code class="fe nf ng nh ni b">ArchiveFile()</code>，接着调用<code class="fe nf ng nh ni b">UploadFile()</code>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">构建、归档和上传的方法</figcaption></figure><p id="a41d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，一旦你的脚本重新编译，你应该在你的Unity编辑器顶部看到一个<code class="fe nf ng nh ni b">Build</code>标签。展开它，然后您应该看到“构建/构建服务器+上传(Linux)”</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b2c0232e96121950f30f3ef3b47e4005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*29JL3OYX2vT3F_zT1fBGtg.png"/></div></figure><p id="d4cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已！使用一些脚本，上传和测试游戏的新版本应该会容易得多。您仍然必须在Linux中解压缩并正确运行服务器应用程序，但这是另一个主题，我可能改天再写。祝你在构建你的游戏时好运！</p></div></div>    
</body>
</html>