<html>
<head>
<title>WebSockets: Lesser Known Pattern in Data Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebSockets:数据工程中鲜为人知的模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/websockets-lesser-known-pattern-in-data-engineering-200329e90331?source=collection_archive---------1-----------------------#2020-09-06">https://levelup.gitconnected.com/websockets-lesser-known-pattern-in-data-engineering-200329e90331?source=collection_archive---------1-----------------------#2020-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="12b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">了解如何使用API方法，使用WebSockets在客户端和服务器之间异步进行全双工数据传输，web sockets是HTTP的升级版，提供了一个有效的Python代码。</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/2f1e813fddc665ab76376fd2c88da67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUU0wLMnbx5wV8ehbiaj_A.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图片提供:【http://www.freepik.com】&gt;Freepik&lt;/a&gt;</figcaption></figure><h1 id="fc25" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">让我们补上API</h1><p id="6121" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi mj translated"><span class="l mk ml mm bm mn mo mp mq mr di"> T </span>典型的数据集成管道通常是单向的，例如移动应用程序等客户端调用运行在某处服务器上的RESTful API。API完成所有工作，并将结果发送回客户端。如果客户机再次需要相同的数据，它必须再次调用API。如果它需要持续的数据，例如更新它自己的仪表板，它必须反复调用API来获取最新的数据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ms"><img src="../Images/e2108b687497c5db349e049a748ddf11.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/0*_xy4g8qQ6ELdQaW9"/></div></div></figure><p id="7c46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种模式的成功有多种原因。请求和响应通过http(或https，如果需要的话)调用，这是相当标准的。有效载荷可以是可变的，以适应所有类型的数据，并且响应可以是可预测的。如果一切顺利，它将获得200的响应代码。请求响应对也是异步的，即一个API可以在任何时候接收1000个调用，并行处理它们，并且并行发送响应。</p><h1 id="183e" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">HTTP的问题是</h1><p id="bcd1" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">有两个问题。首先，这种情况下的服务器或API是被动的。它等待来自客户端的调用，然后才发送数据。在任何时候，通信都是单向的。请求来自客户端；API处理它，响应它，这就是通信的结束。请注意，这是一次纯单向的数据移动；这不是双向的，也不是闲聊。换句话说，它不是全双工的，也不是实时的。</p><p id="b474" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个问题是，API本身不会将任何其他内容发送回客户端。这是第一个问题的必然结果。由于通信是由客户机驱动的，而不是由服务器驱动的，所以服务器没有利用向客户机发送数据的时间来发送自己的数据。因此，客户端不断轮询API以获取最新的数据。不仅浪费带宽；这增加了流程的延迟，因为数据仅与上次轮询时一样好。</p><p id="76c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，考虑一个客户端应用程序，它测量用户在网页上的点击，并将计数发送到API，该API计算所有客户端的运行总数，并将其存储在数据库中。但是客户端还需要知道所有客户端的总数，以便显示在其网页上。在普通的API设计中，它是这样工作的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2bab4b9f6b85a70269b8b5ba5caea9a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*v_AYMlRSg03LRmrA"/></div></figure><h2 id="eace" class="mu lh it bd li mv mw dn lm mx my dp lq kb mz na lu kf nb nc ly kj nd ne mc nf bi translated">事件顺序:</h2><ol class=""><li id="0b5a" class="ng nh it js b jt me jx mf kb ni kf nj kj nk kn nl nm nn no bi translated">客户端使用参数点击次数= 6调用API</li><li id="82f8" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">API得到它，更新它的数据库，并以“得到它”作为响应。在API术语中，我们称之为响应代码200。所有客户端的累计点击量为10次。随着来自客户端的新计数6，累计总数现在是10+ 6 = 16。通讯关闭。</li><li id="8c83" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">但是客户端仍然需要知道显示在其页面上的总数。所以它向API发送另一个请求。这次是一个GET请求。</li><li id="1fd7" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">API以16作为响应。通讯关闭。</li></ol><p id="a021" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有两个通信线程，都是由客户端发起的。既然通信已经打开，让服务器在第一个线程上把运行总数推送到客户机不是很好吗？例如，除了200代码之外，它还可以发送累计总数，从而消除第二次通信。更好的是，这将是客户端的实时数据更新，而不是单独的请求，如下图所示。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/d41270490ac1fe3ed7d505e2f1aaf483.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*d4u_HSn4zKuvBAqU"/></div></figure><p id="5311" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑一个真实的例子，其中多个客户端正在报告它们的计数，当它们报告计数时，将从API获得运行总数。例如，另一个客户端报告它的点击，5，在它的情况下:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/6161c623b45c3fcdbbb350584dc5b06b.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*8cShkzm_Fs-CcWmK"/></div></figure><h1 id="c8c8" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">直接耦合系统的问题</h1><p id="7b69" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">难道我们不能通过使两个系统(客户机和服务器)直接耦合来使过程双向化吗？当然，我们可以；但是我们遇到了两个问题:</p><p id="3a17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，它将不是一个RESTful API。这将只是两个程序同步通信，这降低了可伸缩性。想象一下在前面的例子中，当两个客户端进行同步调用时，其中一个必须等待。成千上万的客户同时打电话会使情况变得更糟。</p><p id="7307" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二，它不会通过http进行通信，http是与为它配置的防火墙进行数据通信的公认标准，代理服务器理解它，并且客户端(如web浏览器和SDK)可供它使用。</p><p id="7a43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仔细想想，我们真的不需要持续的、专用的或同步的连接。我们只是想让数据交换是双向的，这样服务器就有机会向客户端推送一些东西，而无需客户端明确请求。我们喜欢API方法；但是我们需要做些什么来使这个过程更轻松。</p><p id="4ada" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们稍微清楚地检查一下问题陈述:</p><blockquote class="nu nv nw"><p id="b22c" class="jq jr ko js b jt ju jv jw jx jy jz ka nx kc kd ke ny kg kh ki nz kk kl km kn im bi translated">我们希望让服务器通过http(或https)将一些数据推送到客户端，而无需客户端显式请求。</p></blockquote><h1 id="8343" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">那么，我们怎么解决呢？</h1><p id="7722" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">有多种选择。一种选择是进行http长轮询。我们只是保持客户端和API之间的连接长时间开放，允许客户端实时获得更新。在某些情况下，这可能是可取的；但不是全部。而且它也不可伸缩。对于全双工数据传输，出现了一套统称为<strong class="js iu"> Comet </strong>的方法(<a class="ae lf" href="https://en.wikipedia.org/wiki/Comet_(programming)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Comet _(programming)</a>)。它没有被采用；但它确实引发了对标准化过程的需求的思考，以便通过http协议实现全双工数据传输。这些标准化产生了两种模式:websockets和服务器发送事件(SSE)。WebSockets是一种协议，允许全双工数据传输。在这个博客中，你将了解websockets，将SSEs留给未来的博客。</p><p id="eeb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要把它和一个看似相似但不同的概念混淆，这个概念叫做双向API调用，通常叫做<strong class="js iu"> webhooks </strong>。我们将在另一篇博客中探讨这个问题。</p><h1 id="67b9" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">让我们探索一下websockets</h1><p id="69a7" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我将把WebSockets的完整历史和发展留给它在维基百科上的文章(<a class="ae lf" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/WebSocket</a>)。简而言之，WebSockets协议允许数据通过TCP协议从服务器返回到客户端。它们与http协议不同，但与之兼容，因此通信分别通过http和https的端口80和443进行。这在已经考虑到这些端口的防火墙和代理配置中非常有用。</p><p id="e3f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">等等！这是令人困惑的。WebSockets是一个<em class="ko">不同的</em>协议，不是http但是<em class="ko">跟它兼容</em>吗？你可能会问，这实际上意味着什么。</p><h1 id="03c8" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">免费升级</h1><p id="546e" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">这就是http中引入的一个特性有所帮助的地方。HTTP允许您将请求的连接升级到其他连接。HTTP 1.1允许的升级屈指可数，分别是h2c、HTTPS/1.3、IRC/6.9、RTA/x11、websocket。升级允许请求以普通http协议的形式出现，但随后升级到协议列表中的其他协议。在这种情况下，websocket是经过批准的升级。在握手期间，协议被升级。</p><p id="4a9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">典型的http请求具有以下URI(统一资源标识符)结构</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="180f" class="mu lh it ob b gy of og l oh oi">http://host[:port]path[?query]</span></pre><p id="458b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">WebSocket请求看起来与此完全一样，只是使用了不同的协议标识符(“ws”)</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="9c36" class="mu lh it ob b gy of og l oh oi">ws://host[:port]path[?query]</span></pre><p id="dd82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像http的https一样，安全ws也有wss版本。需要WebSocket连接的客户端发送以下内容:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="666b" class="mu lh it ob b gy of og l oh oi">GET ws://www.proligence.com:5678/ HTTP/1.1</span><span id="266d" class="mu lh it ob b gy oj og l oh oi">Host: localhost:5678</span><span id="33ee" class="mu lh it ob b gy oj og l oh oi">Connection: Upgrade</span><span id="44c6" class="mu lh it ob b gy oj og l oh oi">Pragma: no-cache</span><span id="6178" class="mu lh it ob b gy oj og l oh oi">Cache-Control: no-cache</span><span id="c473" class="mu lh it ob b gy oj og l oh oi">Upgrade: websocket</span><span id="2e04" class="mu lh it ob b gy oj og l oh oi">Sec-WebSocket-Version: 13</span><span id="24b6" class="mu lh it ob b gy oj og l oh oi">Sec-WebSocket-Key: q4xkcO32u266gldTuKaSOw==```</span></pre><p id="a72b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意这些线条</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="fe63" class="mu lh it ob b gy of og l oh oi">Connection: Upgrade</span><span id="b5e0" class="mu lh it ob b gy oj og l oh oi">Upgrade: websocket</span></pre><p id="fa66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是客户端要求将此连接请求升级到WebSocket连接的地方。假设服务器支持WS并愿意这样做，它会做出如下响应:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="68fc" class="mu lh it ob b gy of og l oh oi">HTTP/1.1 101 Switching Protocols</span><span id="da2f" class="mu lh it ob b gy oj og l oh oi">Upgrade: websocket</span><span id="11a6" class="mu lh it ob b gy oj og l oh oi">Connection: Upgrade</span><span id="9ca1" class="mu lh it ob b gy oj og l oh oi">Sec-WebSocket-Accept: fA9dggdnMPU79lJgAE3W4TRnyDM=</span></pre><p id="ba86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">行<code class="fe ok ol om ob b">HTTP/1.1 101 Switching Protocols</code>在告诉客户端协议已经从http切换到WS时非常关键。现在客户机有了一个从http连接升级的WebSocket连接。没有比免费升级更好的了。</p><p id="1372" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便说一下，如果你想了解WebSocket协议的数据包格式规范，欢迎你访问https://tools.ietf.org/html/rfc6455#section-5.1的IETF官方页面<a class="ae lf" href="https://tools.ietf.org/html/rfc6455#section-5.1" rel="noopener ugc nofollow" target="_blank"/>。但是请放心，要利用WebSockets的强大功能，您不需要学习这些。</p><h1 id="4bd6" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Sec参数</h1><p id="9b03" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">你可能会问，上面回答中的<code class="fe ok ol om ob b">Sec-WebSocket-Key</code>和<code class="fe ok ol om ob b">Sec-WebSocket-Accept</code>值是什么？</p><p id="d726" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，WebSocket在客户端和服务器之间建立了双向双工通信。两者<em class="ko">再利用</em>http；但是协议不是http。这带来了安全风险。如果其中一个将WebSocket数据误解为正常的http请求怎么办？他们都必须明确地知道，在整个过程中，他们都支持WebSocket，并且通信是基于web socket的；不是http。因此，他们必须建立某种验证，以确保WS请求不会被误解为http。这就是为什么他们需要用一个密钥来验证请求，而http并不需要这个密钥。客户端在其请求中发送一个随机生成的密钥(称为“nonce”):</p><p id="965a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ok ol om ob b">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</code></p><p id="95a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务器接受这个值，连接一个静态值258 eafa 5-E914–47DA-95CA-C5 ab 0 DC 85 b 11(在RFC 6455中定义)，接受结果值的base-64编码，这是它在自己的响应中发回的内容:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="b597" class="mu lh it ob b gy of og l oh oi">Sec-WebSocket-Accept: fA9dggdnMPU79lJgAE3W4TRnyDM=</span></pre><p id="e6cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客户端检查报头并计算相同的值，只有当值匹配时才接受WebSockets帧。这样，客户机和服务器就可以确信WS请求不会被误解为http。</p><h1 id="12e8" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">行动中的准则</h1><p id="8e8c" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi mj translated">充足的理论。如果你像我一样，你一定渴望行动。使用WebSockets有多容易？你需要知道所有的帧布局，基数64的值是如何计算的，等等。？</p><p id="6910" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，没有。大多数现代语言都支持SDK来启动WebSockets。让我们考虑我们上面描述的例子，即，在全双工通信中，客户端需要将其计数发送到API，并在相同的数据传输中从服务器获得运行计数。我们将用Python实现它。</p><p id="2a0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将创建两个程序:</p><ol class=""><li id="5833" class="ng nh it js b jt ju jx jy kb on kf oo kj op kn nl nm nn no bi translated"><strong class="js iu">服务器</strong>，它是一个API，监听来自客户端的WebSocket请求。当连接建立后，它从客户端接收计数数据，从所有客户端更新其运行总数，并将当前运行总数发送到客户端，所有这些都在同一个线程中。</li><li id="54df" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated"><strong class="js iu">客户端</strong>，这只是一个简单的微服务，它发送计数数据(为了简单起见，我们让用户在运行时输入数据)并从服务器接收总计数，显示它并切断连接。</li></ol><p id="4d3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是代码:</p><p id="cede" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Server.py </strong></p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="713d" class="mu lh it ob b gy of og l oh oi">import asyncio as aio</span><span id="a3d9" class="mu lh it ob b gy oj og l oh oi">import websockets as wss</span><span id="b372" class="mu lh it ob b gy oj og l oh oi">sum = 0</span><span id="cb81" class="mu lh it ob b gy oj og l oh oi">print(f”Waiting for clients to connect. Running total = {sum}”)</span><span id="3747" class="mu lh it ob b gy oj og l oh oi">async def add(wss, ev):</span><span id="1186" class="mu lh it ob b gy oj og l oh oi"> global sum</span><span id="ffa6" class="mu lh it ob b gy oj og l oh oi"> event = await wss.recv()</span><span id="afc9" class="mu lh it ob b gy oj og l oh oi"> print(f”Debug: Received {event}”)</span><span id="7a87" class="mu lh it ob b gy oj og l oh oi"> sum = sum + int(event) </span><span id="4f9b" class="mu lh it ob b gy oj og l oh oi"> await wss.send(str(sum))</span><span id="307e" class="mu lh it ob b gy oj og l oh oi"> print(f”Running total = {sum}”)</span><span id="cbaf" class="mu lh it ob b gy oj og l oh oi">ws_server = wss.serve(add, “localhost”, 8181)</span><span id="d7da" class="mu lh it ob b gy oj og l oh oi">aio.get_event_loop().run_until_complete(ws_server)</span><span id="dd2b" class="mu lh it ob b gy oj og l oh oi">aio.get_event_loop().run_forever()</span></pre><p id="8549" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来剖析一下代码。</p><p id="ef18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这是一个API调用，我们需要这个调用是异步的(你马上就会了解到)，因此我们需要导入模块asyncio。我们还需要导入模块websockets，它封装了使用WebSockets所需的所有基础。如果您没有它们，当然需要使用以下命令来安装它们:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="09c2" class="mu lh it ob b gy of og l oh oi">pip install websockets<br/>pip install asyncio</span></pre><p id="7411" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们定义一个名为“sum”的变量，并在服务器启动时将其设置为0。我们计算累计总数的主要函数名为“add”。在这个函数中，我们将添加从客户端获得的计数；但是我们需要这个值对整个程序可见，所以我们需要将这个变量定义为一个全局变量。这在python中至关重要。否则变量将是函数的局部变量，从函数外部对它的任何引用都将是无效的。</p><p id="0c24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，您可能会看到不太常见的声明</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="c32c" class="mu lh it ob b gy of og l oh oi">async def add(wss, ev)<br/>await wss.send(str(sum))</span></pre><p id="5831" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是在python中定义异步流程所必需的。在这个小博客中，不可能公正地评价这些关键词的作用；所以我会留到下次。</p><p id="7f82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其余的是不言自明的。我们在端口8181上定义了一个名为ws_server的web服务器，它支持websockets协议，当收到请求时，它调用add()函数来更新sum变量，然后通过相同的连接将变量的值发送给客户端。</p><p id="9ddb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们编写一个简单的客户端程序，它通过API调用将其计数发送给服务器，并接受服务器通过同一连接发送的任何内容。我们将使计数成为用户的输入。</p><p id="df21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Client.py </strong></p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="c8be" class="mu lh it ob b gy of og l oh oi">import asyncio as aio</span><span id="f824" class="mu lh it ob b gy oj og l oh oi">import websockets as ws</span><span id="5a3f" class="mu lh it ob b gy oj og l oh oi">async def send_event():</span><span id="0a3b" class="mu lh it ob b gy oj og l oh oi">  uri = “ws://localhost:8181”</span><span id="424a" class="mu lh it ob b gy oj og l oh oi">  async with ws.connect(uri) as wss:</span><span id="32ec" class="mu lh it ob b gy oj og l oh oi">    event = input(“What is the number you want to send? “)</span><span id="41d2" class="mu lh it ob b gy oj og l oh oi">    await wss.send(event)</span><span id="a688" class="mu lh it ob b gy oj og l oh oi">    recv_event = await wss.recv()</span><span id="d492" class="mu lh it ob b gy oj og l oh oi">    print(f”Running total so far (received): {recv_event}”)</span><span id="1836" class="mu lh it ob b gy oj og l oh oi">aio.get_event_loop().run_until_complete(send_event())</span></pre><p id="0a5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这两个工具，在一个窗口中，从命令行运行<code class="fe ok ol om ob b">python server.py</code>。该程序将显示以下内容，并等待客户端连接。</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="61af" class="mu lh it ob b gy of og l oh oi">Server&gt; python server.py</span><span id="b635" class="mu lh it ob b gy oj og l oh oi">Waiting for clients to connect. Running total = 0</span></pre><p id="e2e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在不同的窗口中，从命令行运行<code class="fe ok ol om ob b">python client.py</code>。</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="912b" class="mu lh it ob b gy of og l oh oi">Client&gt; python client.py</span><span id="9a0e" class="mu lh it ob b gy oj og l oh oi">What is the number you want to send? 1</span><span id="4bf9" class="mu lh it ob b gy oj og l oh oi">Running total so far (received): 1</span></pre><p id="721f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在服务器窗口中，您可以看到以下消息:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="2dbc" class="mu lh it ob b gy of og l oh oi">Debug: Received 1</span><span id="6e0e" class="mu lh it ob b gy oj og l oh oi">Running total = 1</span></pre><p id="f427" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客户端程序已经退出。在另一个窗口中，运行相同的client.py，这次传递“3”:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="a74b" class="mu lh it ob b gy of og l oh oi">Client&gt; python client.py</span><span id="da0b" class="mu lh it ob b gy oj og l oh oi">What is the number you want to send? 3</span><span id="fc38" class="mu lh it ob b gy oj og l oh oi">Running total so far (received): 4</span></pre><p id="0163" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在服务器窗口上，您可以看到以下内容:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="ba17" class="mu lh it ob b gy of og l oh oi">Debug: Received 3</span><span id="57af" class="mu lh it ob b gy oj og l oh oi">Running total = 4</span></pre><p id="606d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务器保持运行总数，这并不有趣。但是关键的事情是<strong class="js iu">服务器将它推送给客户端</strong>。客户端没有从服务器中提取它。所有这些都是通过API调用实现的；不是两个系统之间的同步数据传输。</p><p id="d73c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这仅仅是说明WebSockets概念的一个例子。这并不像看起来那样具有限制性。服务器可以发送它想要的任何数据；而不仅仅是本例中显示的累计计数。在实际使用中，它可能会发送一个JSON对象，客户端将解析该对象并从中获取有意义的数据。例如，在工厂的机器中运行的客户端可以发送由其传感器记录的功耗数据，而服务器可以跟踪所有客户端的最大功耗。如果任何地方达到最大功耗，服务器将发出警告，甚至命令关闭一些机器以降低整体功耗，从而降低电网风险。该警告通过同一通信从服务器实时发送到客户端，而无需客户端明确请求。</p><h1 id="fef0" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">概括起来</h1><ol class=""><li id="a66e" class="ng nh it js b jt me jx mf kb ni kf nj kj nk kn nl nm nn no bi translated">WebSocket是一种新的协议</li><li id="ec32" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">它与HTTP兼容</li><li id="fe2c" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">请求以WS协议的形式出现；但是通过普通的HTTP端口</li><li id="ce4b" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">该请求包括升级连接的请求</li><li id="f9b0" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">如果连接从HTTP升级到WS，连接将变成全双工</li><li id="5cc2" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">这允许以正常的API请求-响应方式进行完全双向的数据传输</li><li id="4d9d" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">服务器可以将数据推送到客户端，而无需客户端通过同一连接明确请求数据</li></ol></div></div>    
</body>
</html>