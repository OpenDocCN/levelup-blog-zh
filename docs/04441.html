<html>
<head>
<title>Deploying a Simple Golang Web App to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将一个简单的Golang Web应用程序部署到Kubernetes</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploying-simple-golang-webapp-to-kubernetes-25dc1736dcc4?source=collection_archive---------3-----------------------#2020-06-27">https://levelup.gitconnected.com/deploying-simple-golang-webapp-to-kubernetes-25dc1736dcc4?source=collection_archive---------3-----------------------#2020-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02a9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第二部分:使用YAML配置进行部署</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d2ace6256dd6b2c2ef6075d179f60d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMoGmZdUby6e4SKCGSxohA.png"/></div></div></figure><p id="3aaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://medium.com/@almas.hilman/simple-kubernetes-deployment-using-kops-273fc7990006" rel="noopener">之前</a>我们使用kops部署了一个Kubernetes集群。这次我将向您展示如何在kubernetes中部署一个非常简单的web应用程序。你可以在这里查看我用Go <a class="ae lq" href="https://github.com/lmnzr/simpleapp/tree/master/simpleapp" rel="noopener ugc nofollow" target="_blank">写的简单应用程序，或者你也可以使用你自己的应用程序图片。</a></p><p id="7173" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，我们在这里所做的只是为我们的集群制作一个yaml配置文件。还有另一种方法将应用程序部署到Kubernetes集群。例如，您可以使用kubectl命令。但是我个人推荐你使用YAML或者JSON格式的配置文件。我喜欢YAML，因为我觉得它更容易阅读。您可以使用<a class="ae lq" href="https://onlineyamltools.com/convert-yaml-to-json" rel="noopener ugc nofollow" target="_blank">这种</a>工具将其中一种转换成另一种。</p><p id="a2fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用配置文件，您可以更好地维护您的基础设施。由于它是一个文件，您可以很容易地改进和修复您的配置。结合版本控制，您还可以轻松地检查配置中的更改。这也比在kubectl中添加许多命令行更方便。因此，您可以通过使用配置文件来构建更复杂的基础设施。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="277f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">手在上面</h1><p id="d036" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们开始吧。</p><h2 id="c49e" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">命名空间</h2><p id="bf83" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">平时想有几个开发的环境。通常，我需要一个开发环境来托管开发代码，准备好发布代码并准备好进行内部测试，最后是生产环境来托管为公众/用户发布的代码。为了节省成本，我通常在同一个集群中创建开发和试运行环境，在另一个环境中创建生产环境。我发现在一个集群中分离开发和登台的最方便的方法是使用名称空间。名称空间用于分隔Kubernetes集群中的资源。</p><p id="993c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我用来在Kubernetes中定义名称空间的配置文件。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="6783" class="mv lz it ni b gy nm nn l no np">#namespaces.yaml</span><span id="715d" class="mv lz it ni b gy nq nn l no np">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: development<br/>  labels:<br/>    stage: development</span><span id="9a15" class="mv lz it ni b gy nq nn l no np">---</span><span id="88ee" class="mv lz it ni b gy nq nn l no np">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: staging<br/>  labels:<br/>    stage: staging</span></pre><h2 id="2645" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">部署(Pod和副本集)</h2><p id="5069" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在kubernetes中，最小的可展开单元被称为pod。我们的豆荚会消耗我们节点的资源。因此，每个节点只能托管它所能提供的资源。每个pod可以托管一个或多个应用程序容器，它们共享公共卷和网络。Docker是应用程序容器的流行选择，我在这个例子中使用了它。</p><p id="8cae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不能在同一个名称空间中部署完全相同的pod。但是我们可以使用副本集来创建pod的副本。使用副本集，我们可以在集群中维护一个稳定的pod集。这有助于水平扩展我们的应用程序。我发现使用部署配置来管理pod和副本集很方便。下面是我的后端和前端应用程序的部署配置示例。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7a91" class="mv lz it ni b gy nm nn l no np">#backend-deployment.yaml</span><span id="1c01" class="mv lz it ni b gy nq nn l no np">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: backend-dpl<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: backend<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: backend<br/>    spec:<br/>      containers:<br/>        - name: backend-container<br/>          image: lmnzr/simplebackend:latest<br/>          resources:<br/>            limits:<br/>              memory: "128Mi"<br/>              cpu: "500m"<br/>          ports:<br/>            - containerPort: 8080</span><span id="848b" class="mv lz it ni b gy nq nn l no np">---</span><span id="f589" class="mv lz it ni b gy nq nn l no np">#frontend-deployment.yaml</span><span id="b08f" class="mv lz it ni b gy nq nn l no np">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: frontend-dpl<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: frontend<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: frontend<br/>    spec:<br/>      containers:<br/>        - name: frontend-container<br/>          image: lmnzr/simplefrontend:latest<br/>          env:<br/>            - name: BACKEND_URL<br/>              value: "http://backend-svc:8080"<br/>          resources:<br/>            limits:<br/>              memory: "128Mi"<br/>              cpu: "500m"<br/>          ports:<br/>            - containerPort: 80</span></pre><p id="1c4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的配置中，我设置了<code class="fe nr ns nt ni b">spec-replicas : 1</code>这是我声明副本集的最大pod数量的方式。定义了<code class="fe nr ns nt ni b">spec-template-spec-containers</code>部分来通知集群我们的pod的规范。在这里，我为每个pod使用一个容器，该容器使用simplefrontend或simplebackend映像。每个集装箱也有指定的港口和资源限制。</p><p id="2be5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用kubectl应用配置，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0e62" class="mv lz it ni b gy nm nn l no np">kubectl create -f backend-deployment.yaml --namespace development<br/>kubectl create -f frontend-deployment.yaml --namespace development</span></pre><p id="23f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">检查是否一切正常，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="fe1b" class="mv lz it ni b gy nm nn l no np">kubectl get deployment --namespace development<br/>kubectl get pods --namespace development<br/>kubectl get rs --namespace development</span></pre><p id="b40b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该看到pod运行的副本数量与定义的一样多。</p><h2 id="3f07" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">服务</h2><p id="6436" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们已经在pods中启动并运行了我们的应用程序。现在你可能会问我们如何从互联网访问pod内部的应用程序，或者如何连接两个或更多的pod。这就是服务的来源。Kubernetes服务有四种类型:集群IP、节点端口、负载平衡器和外部。默认服务类型是ClusterIP，使用这种类型，您可以通过集群内部IP访问应用程序。NodePort通过使用节点的Ip和发布应用程序的端口来提供对应用程序的访问。LoadBalancer允许您使用云提供商的负载平衡器访问应用程序。External允许您将服务映射到外部名称。</p><p id="f137" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个关于我如何设置后端和前端服务的例子。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b914" class="mv lz it ni b gy nm nn l no np">#backend-service.yaml</span><span id="8b47" class="mv lz it ni b gy nq nn l no np">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: backend-svc<br/>spec:<br/>  ports:<br/>    - port: 8080<br/>      protocol: TCP</span><span id="d6f0" class="mv lz it ni b gy nq nn l no np">selector:<br/>    app: backend</span><span id="baa8" class="mv lz it ni b gy nq nn l no np">---<br/>#frontend-service.yaml</span><span id="73c6" class="mv lz it ni b gy nq nn l no np">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: frontend-svc<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>    - port: 80<br/>      protocol: TCP<br/>  selector:<br/>    app: frontend</span></pre><p id="7c2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于后端服务，我使用默认类型ClusterIP。如果您查看frontend-deployment.yaml，您会发现我定义了一个名为BACKEND_URL的环境变量，它的值是指后端服务的名称。这要感谢kubernetes内部DNS服务。群集可以在服务器名称和它的群集ip之间进行映射。这样，我们的前端可以通过内部网络访问后端，后端不发布到互联网上。对于前端，因为我想从互联网上访问它，所以我使用NodePort类型。</p><p id="3d1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用kubectl应用配置，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b68c" class="mv lz it ni b gy nm nn l no np">kubectl create -f backend-service.yaml --namespace development<br/>kubectl create -f frontend-service.yaml --namespace development</span></pre><p id="8701" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">检查是否一切正常，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b635" class="mv lz it ni b gy nm nn l no np">kubectl get svc --namespace development</span></pre><p id="2d10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">检查节点端口和端口ip并尝试访问它，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4aef" class="mv lz it ni b gy nm nn l no np">kubectl describe service/frontend-svc --namespace development</span><span id="731e" class="mv lz it ni b gy nq nn l no np">curl $NODE_PORT:$NODE_IP</span></pre><p id="f2c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该看到应用程序已经启动并运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/9491bffb08b5995b8a543f071eff0188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GOMRAOTOqMCtPB9IJ0UKg.png"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="69f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一部分中，我向您展示了在kubernetes集群中运行一个简单应用程序的基本步骤。<a class="ae lq" href="https://medium.com/@almas.hilman/make-your-own-helm-chart-590622a50c14" rel="noopener">下一个</a>，我将向你展示如何使用舵图来部署相同的应用程序。有了helm，将应用程序部署到Kubernetes集群变得更加容易，并且您可以为多个应用程序部署创建一个可重用的模板。</p><p id="3606" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读👋。</p></div></div>    
</body>
</html>