# 高级代码组织模式:每个文件一个函数的情况

> 原文：<https://levelup.gitconnected.com/advanced-code-organization-patterns-the-case-for-one-function-per-file-da68c15826e8>

## **回到这个模式的基础。**

![](img/1d1a1e5199f1042f579effe27de8001b.png)

照片由[穆罕默德·拉赫马尼](https://unsplash.com/@afgprogrammer?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/software?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

*免责声明:这篇文章是在考虑前端项目的情况下写的，比如网站、React 本地移动应用和电子应用。尽管后端编程有一些可移植的技能，正如我下面提到的。还有，标题有点开玩笑。😄这个没那么高级，但是经常被忽略。*

在这篇文章中，我将谈论一种在前端项目中组织功能代码的模式，这是非常基本的，但经常被完全忽视…它被称为… *一个文件一个功能！*

“你一定是在开玩笑，对吗？文件组织？这样一个基本的概念，我不能相信这个家伙会发这样的帖子……”好吧，我会反驳说，它被认为是*如此简单，以至于经常被忽视和遗忘，从长远来看，可能会导致巨大的“上帝”文件，其中充满了数十个函数。所以考虑看看这个帖子吧！并且尊重基本！*

# 两种代码组织模式

考虑两种组织代码功能的方法:

1.  将几个相关的函数组合成一个文件。例如:`**utils/**`文件夹下一个名为`**math.js**`的文件，里面有`**add**`、`**subtract**`、`**multiply**`和`**divide**`的函数:

```
**utils****└── math.js****^ contains functions add, subtract, multiply, and divide**
```

1.  将每个函数放在自己的文件中。例如:`**utils/math/**`文件夹下的`**add.js**`、`**subtract.js**`、`**multiply.js**`、`**divide.js**`文件:

```
**utils****└── math** **├── add.js** **├── divide.js** **├── multiply.js** **└── subtract.js**
```

在相当长的一段时间里，我习惯于选择 1。更好。将相关函数组织到同一个文件中！想不到！好像很有道理吧？更少的文件，更低的复杂性？

随着时间的推移，处理越来越大的项目，处理小的、可管理的代码构建块就越令人耳目一新。无论如何，我们可以通过使用各种文件夹来命名分组，从而抽象出“相似”或“相关”功能的概念。

让我们来看看我在十多年的软件工程师职业生涯中了解到的单函数文件更好的三个原因。

# 使用单一功能文件的三个原因

# 1.试验

当你想对你的函数进行单元测试时，在阅读测试代码时，很清楚你要导入的是哪一个函数——不多也不少。对于集成测试来说，这也很清楚——我们希望看到集成测试所需的每个功能的导入。

# 2.代码合并

如果您有一个包含特性和热修复分支的复杂 git 树，将许多函数放在一个大的“utils”文件或类似文件中只会在您希望保留每个函数的功能性(没有双关语)时导致麻烦。当你的每一个函数都被隔离到一个单独的文件中时，浏览每个文件的 git 历史并查看给定函数(并且只*那个函数)做了什么更改就容易多了。*

# 3.组织

仅仅根据`**import**`语句就能立即理解函数的位置，这就更容易找到代码库的组织。选择 1。，函数`**add**`在它自己命名的文件中，`**subtract**`也是如此，等等。采用备选方案 2。，从思考“好吧...`**utils/**`，`**math.js**`...啊哈！`**add**`在`**math.js**`以内！”

如果你正在编写任何复杂的现代应用程序，相信我:你将会有*许多*实用函数，都是围绕各种动作、任务和活动收集的——如果你正确划分代码，很容易超过 50 甚至 100 个函数。

# 缺点

这种模式没有太多缺点——我能想到的只有一个缺点，那就是如果你将你的每一个函数划分到一个单独的文件中，你的`**import**`语句(或者`**require**`语句)将会更多。*然而*，如果您选择选项 1，大多数 linters 和 formatters 无论如何都会生成`**import**`多行。以上，即格式如下:

```
***import* {****add,****subtract,****multiple,****divide****} *from* "./utils/math"**
```

而不是组织模式(选项 2。)那我建议:

```
***import* { add } *from* "./utils/math/add"*****import* { subtract } *from* "./utils/math/subtract"*****import* { multiply } *from* "./utils/math/multiply"*****import* { divide } *from* "./utils/math/divide"**
```

事实上，对你们这些线猎犬来说，这是一条更短的线😉

# 其他考虑

请注意，这种模式是针对您自己的内部代码的。如果你要发布一个库或者包，从同一个文件中导出所有的文件是有意义的，比如 and `**index.js**`或者`**index.ts**`。即使这样，这也只是为了导出接口，库本身的源代码可以(而且在我看来，应该)使用这种模式。

同样，这篇文章的整体看起来非常明显。但是我已经看到代码组织的缺乏在许多不同的项目中一次又一次地出现，所以我认为我应该重申这种模式的重要性。

这种模式也可以移植到面向对象的编程中。如果您发现您在一个类中编写了太多的私有(甚至公共)方法，这表明您应该将一些逻辑分解到另一个类中，最终得到更小、更易读、更易于理解的代码。

# 谢谢！

你喜欢如何在面向客户端的应用程序中组织你的功能？你会选择选项 1 吗？或者 2。，为什么？

干杯，

克里斯🍺