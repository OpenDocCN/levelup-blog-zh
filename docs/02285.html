<html>
<head>
<title>Singly Linked Lists: Data Structures in JavaScript (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单链表:JavaScript中的数据结构(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/data-structures-linked-lists-in-javascript-es6-part-i-db9c83854d94?source=collection_archive---------6-----------------------#2020-03-03">https://levelup.gitconnected.com/data-structures-linked-lists-in-javascript-es6-part-i-db9c83854d94?source=collection_archive---------6-----------------------#2020-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7d86208e7d74c2d499c57e1c61f1eae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pP5AFPGzSzcIqc4Msb1zCQ@2x.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这张照片是我在亚美尼亚埃里温的黑安格斯汉堡酒吧拍的📸</figcaption></figure><p id="2bf7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">数据结构有不同的例子:数组、二叉树、基于散列的结构、图、链表、字符、指针、整数等等。有些是原始数据结构，有些是非原始数据结构。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="84a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在链表文章的这一部分，我想谈谈<strong class="ke ir">单个</strong> <strong class="ke ir">链表</strong>以及如何在JavaScript中创建它们。</p><p id="d831" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">链表是由节点组成的非原始数据结构。节点由数据和一个指向另一个节点的地址(或者双向链表中的地址)组成。</p><p id="b983" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">列表的起点是对第一个节点的引用，它被称为<strong class="ke ir">头</strong>。所有的链表都必须有一个头，因为这实际上是链表及其所有元素的唯一入口点，没有它，你将不知道从哪里开始！列表的结尾不是一个节点，而是一个指向空值的节点。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/03980b4f73eee771279909600b4797de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NeVU-g7nnseNUcAxkOTZiA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自<a class="ae lm" href="https://jojozhuang.github.io/popular/data-structure/data-structure-linked-list/" rel="noopener ugc nofollow" target="_blank"> jojozhuang.github.io </a></figcaption></figure><p id="8cd6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">链表类似于数组。让我们来看看链表和<a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">数组</strong> </a>的一些区别:</p><ol class=""><li id="9c39" class="ln lo iq ke b kf kg kj kk kn lp kr lq kv lr kz ls lt lu lv bi translated">数组的大小是固定的，但是链表是动态的、灵活的，可以扩展和收缩它们的大小。</li><li id="5fb9" class="ln lo iq ke b kf lw kj lx kn ly kr lz kv ma kz ls lt lu lv bi translated">在数组中，要找到特定的元素，你可以用index找到它，但是在链表中，你必须从头开始，直到找到第四个元素。</li><li id="123e" class="ln lo iq ke b kf lw kj lx kn ly kr lz kv ma kz ls lt lu lv bi translated">访问数组中的元素很快，而链表需要线性时间，所以比较慢。</li><li id="39bb" class="ln lo iq ke b kf lw kj lx kn ly kr lz kv ma kz ls lt lu lv bi translated">像数组中的插入和删除这样的操作会消耗很多时间。另一方面，链表上这些操作的性能很快。</li><li id="a3d3" class="ln lo iq ke b kf lw kj lx kn ly kr lz kv ma kz ls lt lu lv bi translated">此外，阵列中的内存利用率很低。相反，链表中的内存利用是高效的。</li></ol><p id="9f8c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是数组和链表的主要区别。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="c3fb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以让我们通过一步一步在JavaScript环境下制作链表来看看。但是在阅读本文的下一部分之前，我建议阅读这个<a class="ae lm" href="https://javascript.info/class" rel="noopener ugc nofollow" target="_blank">链接</a>中的JavaScript类以及其他<a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/ultimate-guide-to-tips-tricks-and-javascript-features-you-should-know-27e0a4a6ffdf"> ES6特性</a>。</p><h1 id="6b1b" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">步骤1:创建节点构造函数</h1><p id="0a22" class="pw-post-body-paragraph kc kd iq ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">首先让我们制作我们的主要构造块——带有<code class="fe ne nf ng nh b">class</code>的节点。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/d5ac730bc5d43205dfe080e46b69220c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MJ_x7EX4B9CIKNx1u21gg.png"/></div></div></figure><p id="9ec0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个节点构造器，它接受第<strong class="ke ir">个数据</strong>和第<strong class="ke ir">个</strong>个参数。<strong class="ke ir">数据</strong>参数表示Node的值，您希望将它存储在您的节点中。<strong class="ke ir"> next </strong>参数指向链表中在我们的节点之后出现的下一个元素，默认情况下我们将其初始化为null(如果在next参数下没有传递任何值)。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="71e5" class="mb mc iq bd md me nj mg mh mi nk mk ml mm nl mo mp mq nm ms mt mu nn mw mx my bi translated">步骤2:创建一个链表构造函数</h1><p id="3286" class="pw-post-body-paragraph kc kd iq ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">下一步是创建主容器构造函数——链表构造函数，它将是我们所有节点的容器。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/bbda68053d5d710efefe2c9b3403d770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLf1nX0HhoTwR9Cuq4Wr6g.png"/></div></div></figure><p id="40ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">头</strong>属性指向列表中的第一个节点。</p><p id="a7bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于我们的链表的起点是头<strong class="ke ir">头</strong>，它最初将不会指向任何地方(<code class="fe ne nf ng nh b">null</code>)，因为当我们第一次创建一个链表时，将不会有指向的节点。</p><p id="3d21" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的<strong class="ke ir">链表</strong>类中的下一个构造函数项是链表的<strong class="ke ir">长度</strong>，它是可选的。我们将长度指定为0，因为我们知道，最初我们的列表没有节点。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="a55f" class="mb mc iq bd md me nj mg mh mi nk mk ml mm nl mo mp mq nm ms mt mu nn mw mx my bi translated">步骤3:为我们的链表创建插入方法</h1><p id="b9db" class="pw-post-body-paragraph kc kd iq ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">链表的主要功能之一是插入。可以在列表的开头、中间(通过索引)和末尾插入。</p><p id="5fb4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以我们需要为它们建立3个方法。</p><h2 id="3c6d" class="np mc iq bd md nq nr dn mh ns nt dp ml kn nu nv mp kr nw nx mt kv ny nz mx oa bi translated"><strong class="ak">在开头插入</strong></h2><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/d18e82350487602453f7afed10e21a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9yFY2NyWJnzF65mhNoohSA.png"/></div></div></figure><p id="f224" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第2行，我们初始化即将到来的节点的<strong class="ke ir"> next </strong>指针，当我们在列表的开头插入新节点时，<strong class="ke ir"> next </strong>节点将是我们当前的第一个节点，它由<strong class="ke ir">头</strong>指向。</p><p id="9b0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">数据参数作为参数传递给第1行的<strong class="ke ir"> insertNodeAtBeginning </strong>方法。</p><p id="7f3d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们有<strong class="ke ir"> next </strong>和<strong class="ke ir"> data </strong>参数，所以在第4行我们创建了新的节点，并把它指定为列表的头。如果您已经初始化了列表的length属性，不要忘记增加它的值(第5行)。</p><p id="0e36" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">之后，在第7行，我们返回新的节点作为列表的头。</p><h2 id="504b" class="np mc iq bd md nq nr dn mh ns nt dp ml kn nu nv mp kr nw nx mt kv ny nz mx oa bi translated"><strong class="ak">在末端插入</strong></h2><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/f86d96016abcb25f0ffeb742641bc84b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GkoJyy5VqetKXljM5-F9g.png"/></div></div></figure><p id="8c75" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好吧，这个有点长。在这种插入类型中，我们需要到达列表的末尾，并在那里插入节点。所以我们需要从我们列表的开始(头部)开始上路。</p><p id="d947" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">当前节点</strong>是我们当前正在查看的节点。第一个节点是<strong class="ke ir">头</strong>指向的节点。因此，我们获取head指针，并将其分配给第2行的<strong class="ke ir"> currentNode </strong>。</p><p id="3293" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了起点之后，我们检查我们的列表是否有任何节点(第4行)。</p><p id="9d5a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果答案是肯定的，我们就遍历节点来找到列表的尾部(第5-7行)。当我们找到它的时候，就是插入的时候了(第9行)。</p><p id="36e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是如果我们得到一个否定的答案，我们只需将链表的头指针指向第11行的新节点。</p><p id="6b5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">插入后，除了增加列表的长度和返回头指针之外，什么都不做。</p><h2 id="7b7f" class="np mc iq bd md nq nr dn mh ns nt dp ml kn nu nv mp kr nw nx mt kv ny nz mx oa bi translated"><strong class="ak">在中间插入</strong></h2><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/d8173af328ca50ef945f03886efa2af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2q5GMcNpevP_LykhGNHMw.png"/></div></div></figure><p id="724d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个方法中，我们不仅需要指定数据参数，还需要指定新节点的<strong class="ke ir">索引</strong>。</p><p id="04d5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第2-6行，我们检查给定的索引是否在列表的中间。如果没有，我们返回一个错误信息。</p><p id="d23f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，如果索引是正确的，我们需要找到我们的节点的位置，并将其插入那里。求解路径类似于在结束路径插入，除了此时我们的方向是给定的索引而不是列表的端点，并且我们还需要一些辅助变量。</p><p id="6260" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们在第8行指定起点，也在第9行计数。<strong class="ke ir">计数</strong>帮助我们找到循环的停止点。</p><p id="e17a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们想在索引5处插入新节点。我们循环遍历索引0、1、2、3，当我们在索引4时，我们停止循环(<strong class="ke ir"> count = 4 </strong>)。</p><p id="9cf6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第16行和第17行，我们获取索引4 ( <strong class="ke ir"> prevNode </strong>)和索引5 ( <strong class="ke ir"> nextNode </strong>)处的节点。在第18行，我们创建了一个指向索引5的节点。在第20行，我们将索引4节点的指针改为指向我们的新节点。</p><p id="51db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在所有这些之后，我们最终得到了索引4( <strong class="ke ir"> prevNode </strong>)、索引5( <strong class="ke ir"> newNode </strong>)和索引6( <strong class="ke ir"> nextNode </strong>)处的节点。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="743b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是最后一种插入方法。让我们看看我们一起写的全部代码。</p><p id="8aac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">别担心，你可以在文章下面找到完整的代码源代码。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="91ea" class="mb mc iq bd md me nj mg mh mi nk mk ml mm nl mo mp mq nm ms mt mu nn mw mx my bi translated">4.为链接列表创建删除方法</h1><p id="e052" class="pw-post-body-paragraph kc kd iq ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">链表的下一个主要功能是删除。像插入一样，可以从列表的开头、中间(通过索引)和结尾删除。</p><h2 id="e7f6" class="np mc iq bd md nq nr dn mh ns nt dp ml kn nu nv mp kr nw nx mt kv ny nz mx oa bi translated"><strong class="ak">中间删除+开始删除</strong></h2><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/e413439f526d4a0113273c37cd7ded13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6SAEcRyxwBv3zwDppOcZNg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们可以将两三种删除或插入方法结合成一种，但是不推荐<strong class="bd md"/></figcaption></figure><p id="6875" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种方法中，我们结合了两种删除类型(从中间删除和从开始删除)。在第2行中，我们初始化了deletedNode变量，需要它来显示哪个节点被删除了。<strong class="ke ir">(注意:最好初始赋值为空)</strong></p><p id="6474" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在初始化之后，像从中间方法插入一样，我们检查索引值是否为0。此时，当它为0时，我们不会给出错误。相反，我们取第一个节点，并通过将<strong class="ke ir"> head </strong>指针改为指向第一个节点之后的下一个节点来删除它。然后我们从语句中退出，减少列表的长度，并返回被删除的节点。</p><p id="6e7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一个语句是检查我们的索引是否不是列表的最后一个索引。如果不是，那么我们开始遍历列表节点，直到到达指定的索引- 1。</p><p id="6d8b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就拿前面的例子来说吧。我们想删除索引5处的节点。因此，我们循环遍历索引0、1、2、3，当我们在索引4时，我们停止循环(<strong class="ke ir"> count = 4 </strong>)。</p><p id="c429" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第18行和第20行，我们取索引4 (prevNode)和索引6 ( <strong class="ke ir"> nextNode </strong>)处的节点。在第19行，我们取索引5处的目标节点。然后在第22行，我们通过切换<strong class="ke ir"> prevNode </strong>的指针到<strong class="ke ir"> nextNode来删除一个节点。</strong></p><p id="2969" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在<strong class="ke ir"> prevNode </strong>将<strong class="ke ir"> </strong>指向<strong class="ke ir"> nextNode </strong>，它位于索引6，最终成为索引5节点。</p><p id="9552" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以这是两种结合在一起的方法。但是我建议将它们彼此分开，如下面的代码图所示👇。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/91c4cee3078c623b6033ec8133ef8295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6wHuVFUTPUFutBqhPbDkw.png"/></div></div></figure><h2 id="72a1" class="np mc iq bd md nq nr dn mh ns nt dp ml kn nu nv mp kr nw nx mt kv ny nz mx oa bi translated"><strong class="ak">从末尾删除</strong></h2><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/199a09cb8bd1b2495c93349feddfc02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_YSc10opoBom3LK9PgwgyQ.png"/></div></div></figure><p id="b3fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个方法中，我们循环遍历节点，直到到达末尾，就像在list方法的末尾插入一样，只是现在我们还需要最后一个节点的前一个节点(第5–8行)。到达最后一个节点后，我们简单地获取前一个节点，并将其指针改为null(删除它们之间的连接线)(第12行)。减少列表的长度并返回删除的节点。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="ef43" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是删除过程。</p><h1 id="25f5" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">5.为链表创建一个getter方法</h1><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/30b7f00d7500bafe2cec9bef9da6a222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILnfBq1-i11sBaB3XgLoiQ.png"/></div></div></figure><p id="daac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要向链表中添加更多的信息源，你可以添加那些方法或者更好的方法——试着也创建你自己的方法。</p><p id="1c6f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样！感谢您阅读本文！希望这篇文章能帮助你理解什么是链表以及如何实现它。下一章见，我会讲到双向链表😉。</p><blockquote class="oh oi oj"><p id="d82c" class="kc kd ok ke b kf kg kh ki kj kk kl km ol ko kp kq om ks kt ku on kw kx ky kz ij bi translated"><a class="ae lm" href="https://github.com/danomov/DataStructures" rel="noopener ugc nofollow" target="_blank">github链接完整代码</a></p></blockquote><p id="f289" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">喜欢这篇文章吗？你可以在下面找到更多有趣的。</p><blockquote class="oh oi oj"><p id="7438" class="kc kd ok ke b kf kg kh ki kj kk kl km ol ko kp kq om ks kt ku on kw kx ky kz ij bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/ultimate-guide-to-tips-tricks-and-javascript-features-you-should-know-27e0a4a6ffdf">JS功能终极指南</a></p><p id="c3b3" class="kc kd ok ke b kf kg kh ki kj kk kl km ol ko kp kq om ks kt ku on kw kx ky kz ij bi translated">如何成为一名更好的开发人员</p><p id="0e95" class="kc kd ok ke b kf kg kh ki kj kk kl km ol ko kp kq om ks kt ku on kw kx ky kz ij bi translated"><a class="ae lm" href="https://medium.com/@danielmovsesyan/what-is-ai-yay-or-nay-781a5713b9cc" rel="noopener">什么是AI？是还是不是？</a></p></blockquote></div></div>    
</body>
</html>