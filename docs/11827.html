<html>
<head>
<title>Benefits of Embedded TDD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嵌入式TDD的优势</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/benefits-of-embedded-tdd-74c345c75a46?source=collection_archive---------17-----------------------#2022-04-19">https://levelup.gitconnected.com/benefits-of-embedded-tdd-74c345c75a46?source=collection_archive---------17-----------------------#2022-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/840752b9870aa499126edd01584b0b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8yz6QvWYqYLo9vG6X5LvA.png"/></div></div></figure><div class=""/><div class=""><h2 id="b736" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">作为微控制器程序员睡得更香。</h2></div><p id="d413" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi lm translated">在过去的几年里，我看到人们对软件测试和验证越来越感兴趣:运行良好的代码不仅仅是获得报酬和不被解雇的问题。对我来说，随着软件复杂性的增加，这也意味着感觉不那么焦虑，平静地跟上步伐。</p><p id="7758" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lv">然而，另一方面，大量的微控制器开发人员要么相信先进的测试技术，如测试驱动开发，并不十分适合裸机代码，要么相信收益并不超过努力。嗯，我认为他们可能错过了一个提高代码质量的好机会，也错过了压力较小的工作时间。</em></p><h2 id="e7a4" class="lw lx jb bd ly lz ma dn mb mc md dp me kz mf mg mh ld mi mj mk lh ml mm mn mo bi translated">今天我将讲述在您的日常嵌入式项目中采用测试驱动开发(TDD)的四个基本原因！T9】</h2><p id="f642" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated"><strong class="ks jc"> <em class="lv">免责声明:</em> </strong> <em class="lv">以下讨论是我在生产、学术和业余爱好背景下的学习和经历的结果。尽管随着时间的推移，我肯定已经被我读过的书以某种方式(积极地)“污染”了，但我在这里谈论的是基于我的实验，以及我通常如何在微控制器环境中接近TDD。我希望它对你也有用🙂</em></p><p id="04c1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">好了，我们继续吧！</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="e93c" class="nc lx jb bd ly nd ne nf mb ng nh ni me kh nj ki mh kk nk kl mk kn nl ko mn nm bi translated">1.硬件独立性</h1><p id="25c9" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> L </span> et说我们想为嵌入式系统实现一个WiFi通信库，并希望从TDD中受益。我们如何测试一个类的网络通信？</p><p id="e40f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了清楚起见，还假设通过串行端口向调制解调器发送命令来收发数据(是的，我说的是Hayes/AT命令😉).因此，在更抽象的层次上，我们的网络软件类主要是关于向/从串行端口发送/接收字符。</p><p id="59ed" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">嗯，我们当然可以编写硬件相关的单元测试，以便通过<em class="lv">实际的</em>串行端口向<em class="lv">实际的</em>调制解调器发送命令，但是我能想到至少一个不这么做的好理由。例如，<em class="lv">物理</em>串口由于某种原因停止工作怎么办？毕竟，我们是在测试网络类，而负责串行通信的模块应该可以正常工作。</p><h2 id="0d20" class="lw lx jb bd ly lz ma dn mb mc md dp me kz mf mg mh ld mi mj mk lh ml mm mn mo bi translated">单元测试是关于软件的。是的，我们当然可以试驾一个硬件驱动程序，但绝对不是像硬件一样的东西。TDD允许开发人员提前考虑代码的依赖性，并以这样一种方式设计它们，即软件模块可以以一种隔离的方式进行验证。</h2><p id="811f" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">我们现在有机会回顾我们的例子。我们可以让它依赖于一个<em class="lv">接口，而不是将真实世界的串行对象传递给我们的WiFi类。</em>让我们看看下面的类图来了解一下。</p><figure class="no np nq nr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/23aeefd2472903fe46c614e3fbee8842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFqacPHsHmcoU7-4S6tPxQ.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">可测试MyWiFi类的UML图</figcaption></figure><p id="58bb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这里，我们的WiFi类只依赖于UART <em class="lv">“契约”。</em> MockSerial是一个纯软件类，仅用于<em class="lv">模拟</em>真实串行驱动程序的行为，而real serial将在你的应用程序代码中使用(即与单元测试无关的一切)。</p><p id="17e9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">理解提到的UART方法根本不包含<em class="lv">代码是很重要的:</em>它们将由子类<em class="lv">实现。对于那些熟悉C++的人来说，这里是UML图的翻译。</em></p><figure class="no np nq nr gt is gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/818a4d49e3157b0d799a8b4737fa378d.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*y5h3LRPRJ7jei_1TvKTfuw.png"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="11ef" class="nc lx jb bd ly nd ne nf mb ng nh ni me kh nj ki mh kk nk kl mk kn nl ko mn nm bi translated">2.更快的反馈循环</h1><p id="0d17" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> T </span> DD基本上包括<em class="lv">非常快速的</em>三个连续步骤的迭代，每个步骤都用一种颜色来表示:红色、绿色、蓝色。在红色阶段，针对<em class="lv">尚不存在的</em>产品代码编写了一个新的单元测试，它代表了我们希望在系统中出现的一个特性。为了走向绿色，我们必须实现所需的功能/模块，以便测试套件编译和运行时没有任何错误。最后，在蓝色阶段，重构产品代码以删除重复和不必要的耦合。</p><p id="ae01" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">将此过程应用于“本地”应用程序(即在足够强大的机器上运行的任何东西)导致<em class="lv">快速</em>红色/绿色/蓝色循环。然而，在嵌入式系统上这样做从逻辑上讲会减少迭代次数，因为嵌入式目标的编译和上传过程通常比桌面环境慢。</p><h2 id="2205" class="lw lx jb bd ly lz ma dn mb mc md dp me kz mf mg mh ld mi mj mk lh ml mm mn mo bi translated">因此，应该通过引入一个中间步骤，即在开发机器上运行测试，来调整TDD周期以尽可能快地工作。</h2><p id="dfcb" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">由于TDD迫使我们尽可能独立于目标硬件编写代码，测试套件实际上可以由您的笔记本电脑/PC执行，从而更快地朝着修复错误和实现功能的方向前进。</p><h2 id="74b6" class="lw lx jb bd ly lz ma dn mb mc md dp me kz mf mg mh ld mi mj mk lh ml mm mn mo bi translated">请注意，我们也将在我们的目标硬件上运行测试，只是频率要低一些。</h2><p id="4abb" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">此外，这种混合方法提供了发现不同编译器和架构之间实现差异的好处。更清楚地说，有时我们会写一段在我们的PC上运行良好但在目标上失败的代码，反之亦然。举个例子，我曾经面对一个编译器，它没有在<em class="lv"> snprintf() </em> C函数内部实现十进制格式。对于那些好奇的人，这里有一个有趣的截图代表这种情况。</p><figure class="no np nq nr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/57fc5c84fab24bf6860bd7cb2926365d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vYq7oTzLFCGU10sz"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">运行相同的测试套件:在我的电脑上(左)，在Arduino Zero上(右)</figcaption></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="b8ef" class="nc lx jb bd ly nd ne nf mb ng nh ni me kh nj ki mh kk nk kl mk kn nl ko mn nm bi translated">3.连贯性和边界表达</h1><p id="88fd" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di">在</span>传统编程中，我们首先编写我们软件的内部，然后通过它的接口来使用它。然而，有时我们后来意识到使用它的方式是不一致的，不正确的，或者有点麻烦。</p><p id="8508" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">另一方面，TDD专注于在拥有产品代码之前编写测试，因此迫使我们充当自己代码的用户。虽然这可以被看作是一种不自然的开发程序的方式，但它实际上对编写更干净的架构有很大帮助。</p><p id="93f2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">此外，单元测试通常是针对单个类进行的。因此，它让您有机会更好地考虑模块的职责:它应该封装多少功能，以及多少方法、参数、返回值等等。</p><p id="7cd1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于嵌入式开发来说更是如此，因为我们通常必须实现与硬件相关的东西，并且要考虑硬件和软件的责任。</p><h2 id="c619" class="lw lx jb bd ly lz ma dn mb mc md dp me kz mf mg mh ld mi mj mk lh ml mm mn mo bi translated">TDD无疑有助于定义提供给你的东西和你必须实现的东西之间的界限。</h2></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="727d" class="nc lx jb bd ly nd ne nf mb ng nh ni me kh nj ki mh kk nk kl mk kn nl ko mn nm bi translated">4.补充调试器</h1><p id="70c3" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> U </span>唱TDD，我们小步前进，测试帮助我们不迷路。调试器在确保代码质量方面起着非常重要的作用，尤其是对于嵌入式系统。但是一旦我们关闭了一个调试会话，我们就很不幸地失去了关于我们的代码能做什么的任何可能的知识。</p><p id="d290" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">考虑在现有代码中添加新功能:我们不太可能找到证明我们没有破坏任何东西的方法。另一方面，拥有一个测试套件可以确保没有引入任何回归(或者，如果没有，就“建议”做些什么来解决这个问题)。</p><p id="4720" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">根据我的经验，我已经成功地在一个类似Arduino Zero的板上开发了几个月，甚至没有使用调试器:更不用说这有点痛苦，但如果没有TDD，这是不可能的。</p><p id="edb6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在任何情况下，通常没有人强迫我们在使用TDD或购买调试器之间做出选择:它们应该明确地放在我们的嵌入式开发工具集中！</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="0fa8" class="nc lx jb bd ly nd ne nf mb ng nh ni me kh nj ki mh kk nk kl mk kn nl ko mn nm bi translated">包扎</h1><p id="7b96" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">总而言之，嵌入式TDD允许我们:</p><ol class=""><li id="30f4" class="ny nz jb ks b kt ku kw kx kz oa ld ob lh oc ll od oe of og bi translated">尽可能独立于底层硬件编写代码</li><li id="6a5d" class="ny nz jb ks b kt oh kw oi kz oj ld ok lh ol ll od oe of og bi translated">利用PC运行测试的速度更快，还可以将其用作兼容性检查</li><li id="7e22" class="ny nz jb ks b kt oh kw oi kz oj ld ok lh ol ll od oe of og bi translated">通过允许我们在编写产品代码之前充当用户，开发更干净的架构</li><li id="0a55" class="ny nz jb ks b kt oh kw oi kz oj ld ok lh ol ll od oe of og bi translated">减少和补充硬件调试器的使用</li></ol><p id="4f03" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">好了，今天就到这里吧！<br/>感谢你读到这里。有任何问题，请联系我🍻。<br/>下次见！</p></div></div>    
</body>
</html>