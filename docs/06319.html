<html>
<head>
<title>Function, Methods &amp; Interfaces In Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的函数、方法和接口</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/function-methods-interfaces-in-go-d094243501b?source=collection_archive---------5-----------------------#2020-11-15">https://levelup.gitconnected.com/function-methods-interfaces-in-go-d094243501b?source=collection_archive---------5-----------------------#2020-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4c79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用示例和代码立即投入运行！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/01ca598369b48e646f7faeb2b7a700d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xaWb7EF1zax2Emm0.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自Pixabay</figcaption></figure><p id="2a62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi le translated">Go 通过对函数、方法和接口的隐式和显式定义，保持其独特的灵活性。主包中的<code class="fe ln lo lp lq b">main(){}</code>函数是我们的代码必须开始的地方。</p><p id="dd63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然Go通常会强制使用每个包和变量，但实际上您可以包含未被调用的空函数，并且您的代码仍会编译。调用函数也很简单。</p><pre class="kp kq kr ks gt lr lq ls lt aw lu bi"><span id="923d" class="lv lw it lq b gy lx ly l lz ma">package main</span><span id="4053" class="lv lw it lq b gy mb ly l lz ma">import "fmt"</span><span id="fbec" class="lv lw it lq b gy mb ly l lz ma">func main() {<br/>    fmt.Println("Hello World!")<br/>    helloFromFunc()<br/>}</span><span id="d1a8" class="lv lw it lq b gy mb ly l lz ma">func emptyFunc() {</span><span id="f103" class="lv lw it lq b gy mb ly l lz ma">}</span><span id="a825" class="lv lw it lq b gy mb ly l lz ma">func helloFromFunc() {<br/>    fmt.Println("Hello from a function!")<br/>}</span><span id="a703" class="lv lw it lq b gy mb ly l lz ma">/* Program Output:<br/>Hello World!<br/>Hello from a function!<br/>*/</span></pre><p id="0cec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">自变量和参数</strong>在Go中很容易传递。实参在函数调用中，参数在函数定义中。编码行话！</p><pre class="kp kq kr ks gt lr lq ls lt aw lu bi"><span id="bf8d" class="lv lw it lq b gy lx ly l lz ma">func main() {<br/>    // define arguments<br/>    firstNameArg := "Izzy"<br/>    lastNameArg := "Miles"</span><span id="9e07" class="lv lw it lq b gy mb ly l lz ma">    printFullName(firstNameArg, lastNameArg)<br/>}</span><span id="7061" class="lv lw it lq b gy mb ly l lz ma">func printFullName(firstNameParam string, lastNameParam string) {<br/>    fmt.Println(firstNameParam, lastNameParam)<br/>}</span></pre><p id="a80e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">函数的返回类型</strong>可以定义为返回单个值或不同类型的元组。返回类型在参数定义之后定义。我希望你知道哈利波特，否则这个函数对你来说就像拉丁语一样。</p><pre class="kp kq kr ks gt lr lq ls lt aw lu bi"><span id="2b98" class="lv lw it lq b gy lx ly l lz ma">package main</span><span id="c1f0" class="lv lw it lq b gy mb ly l lz ma">import "fmt"</span><span id="3bad" class="lv lw it lq b gy mb ly l lz ma">func main() {<br/>    ronWeasley := "Ron Weasley"</span><span id="680a" class="lv lw it lq b gy mb ly l lz ma">    canCastSpell := wingardiumLeviosa(ronWeasley)</span><span id="cdd0" class="lv lw it lq b gy mb ly l lz ma">    if canCastSpell {<br/>        fmt.Println("Levitating object...")<br/>    } else {<br/>        fmt.Println("Can't levitate, it was probably Ron...")<br/>    }<br/>}</span><span id="8086" class="lv lw it lq b gy mb ly l lz ma">func wingardiumLeviosa(wizard string) (bool) { // bool return type<br/>    if wizard == "Ron Weasley" {<br/>        fmt.Println("It's levi-OSA, not levio-SA!")<br/>        return false<br/>    } else {<br/>        return true<br/>    }<br/>}</span></pre><p id="e72b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于可能出错的操作，通常会返回一个<strong class="js iu">错误</strong>值。例如，假设我们试图打开一个文件。如果我们可以毫无问题地打开文件，我们将返回一个<code class="fe ln lo lp lq b">nil</code>来代替一个错误，这意味着一切正常。如果出现问题，我们希望发出信号并处理错误。</p><p id="26f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>下面的代码需要你导入<code class="fe ln lo lp lq b">"os"</code>包。</p><pre class="kp kq kr ks gt lr lq ls lt aw lu bi"><span id="cf3b" class="lv lw it lq b gy lx ly l lz ma">func openFile (filename string) (error) {<br/>    f, err := os.Open("filename.txt")<br/>    if err != nil {<br/>        log.Fatal(err)<br/>        return err<br/>    }<br/>    // do something with the open *File f<br/>    return nil<br/>}</span></pre><p id="43d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这有点重复，因为<code class="fe ln lo lp lq b">os.Open()</code>函数实际上也返回一个文件和一个错误。这也不是很好，因为如果它失败了，我们就让程序崩溃。主要的一点是，我们希望可能出错的函数准确地指出它们出错的原因，而错误有助于实现这一点。</p><p id="7c12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">方法</strong>在基本意义上不同于Go中的函数，方法与对象有关。Go与其他语言略有不同，因为你实际上只是将一个对象传递给一个函数，使它成为一个方法，而Python则是将一个函数定义为类的一部分，使它成为一个方法。提醒一下，Go里没有类，只有结构和接口！</p><pre class="kp kq kr ks gt lr lq ls lt aw lu bi"><span id="dddf" class="lv lw it lq b gy lx ly l lz ma">package main</span><span id="95e6" class="lv lw it lq b gy mb ly l lz ma">import "fmt"</span><span id="dd6d" class="lv lw it lq b gy mb ly l lz ma">func main() {<br/>    hp := NewWizard("Harry Potter", 12)</span><span id="3055" class="lv lw it lq b gy mb ly l lz ma">    hp.learnSpell("Wingardium Leviosa")</span><span id="ff88" class="lv lw it lq b gy mb ly l lz ma">    fmt.Println(hp.Name, "knows how to cast", hp.KnownSpells)<br/>}</span><span id="3186" class="lv lw it lq b gy mb ly l lz ma">type Wizard struct {<br/>    Name string<br/>    Age int<br/>    KnownSpells []string<br/>}</span><span id="70d0" class="lv lw it lq b gy mb ly l lz ma">// This function returns a new instance of a Wizard<br/>func NewWizard(name string, age int) *Wizard {<br/>    return &amp;Wizard{ // notice no explicit constructor<br/>        Name: name,<br/>        Age: age,<br/>    }<br/>}</span><span id="c795" class="lv lw it lq b gy mb ly l lz ma">// we pass a wizard to learnSpell create a method<br/>func (w *Wizard) learnSpell (spell string) {<br/>    w.KnownSpells = append(w.KnownSpells, spell)<br/>}</span></pre><p id="b3e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">返回对新struct实例的引用是一种常见的做法，这就是为什么<code class="fe ln lo lp lq b">NewWizard()</code>的返回类型是指针<code class="fe ln lo lp lq b">*Wizard</code>。</p><p id="a941" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与其他语言相比，Go中的接口有些不同，但在应用中仍然非常强大。本质上，接口给了我们一个实现特性的契约。让我们以形状为例，我们只需要实现面积和周长方法。</p><pre class="kp kq kr ks gt lr lq ls lt aw lu bi"><span id="8f6f" class="lv lw it lq b gy lx ly l lz ma">type shape interface {<br/>    area() float64<br/>    perim() float64<br/>}</span></pre><p id="8285" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很简单。在大多数其他通用语言中，你会实例化一些包含关键字的类来<em class="mc">实现</em>这个接口。相反，只要你为一个对象定义了在类型上等价的方法，Go就会假设你实现了一个接口。</p><pre class="kp kq kr ks gt lr lq ls lt aw lu bi"><span id="9bcf" class="lv lw it lq b gy lx ly l lz ma">type pentagon struct {<br/>    side float64<br/>}</span><span id="40c5" class="lv lw it lq b gy mb ly l lz ma">func (p pentagon) area() float64 {<br/>    radicand := 5*(5+(2*math.Sqrt(5)))<br/>    return (0.25)*math.Sqrt(radicand)*math.Pow(p.side,2)<br/>}<br/>func (p pentagon) perim() float64 {<br/>    return 5*p.side<br/>}</span></pre><p id="f3b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，既然我们实现了<code class="fe ln lo lp lq b">area()</code>和<code class="fe ln lo lp lq b">perim()</code>方法，我们也就实现了<code class="fe ln lo lp lq b">shape</code>接口本身！此外，您还学习了如何计算五边形的面积。现在是大脑思考的时候了。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi md"><img src="../Images/6c83b41687a580889f8345d383d4280e.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/0*-dnX9idbj9IeQSNA.gif"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="3b8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你喜欢这篇关于Go中的函数、方法和接口的教程。如果有你喜欢的东西或者你想知道更多的话题，请在下面留下评论！感谢阅读。</p></div></div>    
</body>
</html>