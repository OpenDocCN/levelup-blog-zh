<html>
<head>
<title>Convert CSV to JSON in a JavaScript App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript应用程序中将CSV转换为JSON</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/convert-csv-to-json-in-a-javascript-app-4673575a86aa?source=collection_archive---------2-----------------------#2020-05-16">https://levelup.gitconnected.com/convert-csv-to-json-in-a-javascript-app-4673575a86aa?source=collection_archive---------2-----------------------#2020-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/421e65e30ff1328102732d7a1cafb87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BYexmAteq_fkdkSN"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Krzysztof Niewolny 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5740" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将CSV转换为JSON是一项正在进行的任务，因为我们需要在应用程序中使用CSV。</p><p id="7cbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何使用<code class="fe le lf lg lh b">csvtojson</code>模块将CSV转换成JSON。</p><h1 id="5c85" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">装置</h1><p id="d5d8" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">csvtojson</code>可作为NPM模块使用。我们可以运行以下命令来安装它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a7ea" class="mt lj it lh b gy mu mv l mw mx">npm i csvtojson</span></pre><p id="f8eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个包适用于浏览器和Node.js。</p><h1 id="b409" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">基本用法</h1><p id="36da" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以从一个文件中获取一个CSV文件并将其转换成JSON，或者我们可以从一个字符串中获取CSV文件并做同样的事情。</p><p id="8a0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以从一个文件中获取一个CSV文件，并将其转换为JSON文件，如下所示:</p><p id="c74c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">person.csv</code></p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="72eb" class="mt lj it lh b gy mu mv l mw mx">first_name,last_name<br/>john,smith<br/>jane,smith</span></pre><p id="a14d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">index.js</code></p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6ef6" class="mt lj it lh b gy mu mv l mw mx">const csvFilePath = 'person.csv'<br/>const csv = require('csvtojson');<br/>(async () =&gt; {<br/>  const jsonObj = await csv().fromFile(csvFilePath)<br/>  console.log(jsonObj);<br/>})();</span></pre><p id="3baa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们调用了<code class="fe le lf lg lh b">csv</code>函数，该函数使用接受文件路径的<code class="fe le lf lg lh b">fromFile</code>方法返回一个对象。</p><p id="98f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">fromFile</code>方法返回一个承诺，将从CSV解析的JSON作为解析值。</p><p id="b7bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们像上面那样记录<code class="fe le lf lg lh b">jsonObj</code>时，我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="91fb" class="mt lj it lh b gy mu mv l mw mx">[ { first_name: 'john', last_name: 'smith' },<br/>  { first_name: 'jane', last_name: 'smith' } ]</span></pre><p id="139a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以将CSV从字符串解析成JSON。为此，我们可以编写以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b2f8" class="mt lj it lh b gy mu mv l mw mx">const csv = require('csvtojson');<br/>const csvStr = `first_name,last_name<br/>john,smith<br/>jane,smith`;</span><span id="2aa3" class="mt lj it lh b gy my mv l mw mx">(async () =&gt; {<br/>  const jsonObj = await csv().fromString(csvStr)<br/>  console.log(jsonObj);<br/>})();</span></pre><p id="e15f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe le lf lg lh b">csvStr</code>，它包含存储在字符串中的相同CSV内容。</p><p id="6330" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe le lf lg lh b">fromString</code>而不是<code class="fe le lf lg lh b">fromFile</code>来获取CSV内容，并用解析后的数据解析返回承诺。</p><p id="48e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们得到与第一个例子相同的结果。</p><h1 id="bdc4" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">异步处理CSV URL中的每一行</h1><p id="88ef" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以用<code class="fe le lf lg lh b">subscribe</code>方法逐行解析CSV字符串。例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6e30" class="mt lj it lh b gy mu mv l mw mx">const csv = require('csvtojson');<br/>const csvFilePath = 'person.csv'</span><span id="7bc6" class="mt lj it lh b gy my mv l mw mx">csv()<br/>.fromFile(csvFilePath)<br/>.subscribe(<br/>  (json) =&gt; console.log(json), <br/>  () =&gt; console.log('error'), <br/>  () =&gt; console.log('success')<br/>);</span></pre><p id="ad42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们调用了<code class="fe le lf lg lh b">fromFile</code>方法，但是我们在它之后调用了<code class="fe le lf lg lh b">subscribe</code>方法，而不是从承诺中获取解析后的值。</p><p id="377b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将一次一行地获取解析后的值，而不是全部放在一个数组中。</p><h1 id="7958" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">转换为CSV行</h1><p id="cd88" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们还可以使用<code class="fe le lf lg lh b">subscribe</code>方法和<code class="fe le lf lg lh b">'line'</code>输出选项一次一行地获取原始CSV行。</p><p id="2c35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以调用以下代码来实现这一点:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d7d4" class="mt lj it lh b gy mu mv l mw mx">const csv = require('csvtojson');<br/>const csvFilePath = 'person.csv'</span><span id="e589" class="mt lj it lh b gy my mv l mw mx">csv({ output: "line" })<br/>.fromFile(csvFilePath)<br/>.subscribe((csvLine) =&gt; console.log(csvLine))</span></pre><p id="6300" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d7a5" class="mt lj it lh b gy mu mv l mw mx">john,smith<br/>jane,smith</span></pre><p id="4c38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从控制台日志输出。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/91bc1d5d828c59c8ebd1b4ef8cbba373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V_gcHqB3cIFxm37z"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@russn_fckr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> russn_fckr </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="08ab" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">选择</h1><p id="f39b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们传递给<code class="fe le lf lg lh b">csv</code>函数的对象可以采用以下选项:</p><ul class=""><li id="baa6" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">output</code> —要转换成的格式。它可以是默认的<code class="fe le lf lg lh b">'json'</code>，CSV行的<code class="fe le lf lg lh b">'csv'</code>，或者将CSV转换为CSV行字符串的<code class="fe le lf lg lh b">'line'</code>。</li><li id="b4fd" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">delimiter</code> —用于分隔列的分隔符。<code class="fe le lf lg lh b">'auto'</code>应该是未知的值</li><li id="bb34" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">quote</code> —如果一个列有分隔符，它可以使用引号将列内容括起来，这样像<code class="fe le lf lg lh b">'hello,world'</code>这样的文本就不会被认为是在两列中。</li><li id="d087" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">trim</code> — <code class="fe le lf lg lh b">true</code>如果我们想要空间被修剪，否则<code class="fe le lf lg lh b">false</code></li><li id="b806" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">checkType</code> —打开和关闭是否检查字段类型</li><li id="89cf" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">ignoreEmpty</code> —忽略CSV列中的空值</li><li id="27ce" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">noheader</code> — <code class="fe le lf lg lh b">true</code>如果我们解析的CSV中没有标题</li><li id="83e0" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">headers</code> —指定CSV数据头的数组。如果是<code class="fe le lf lg lh b">false</code>，那么这个值将覆盖CSV标题行</li><li id="543a" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">flatKeys</code> —不要将标题字段中的<code class="fe le lf lg lh b">.</code>和方括号解释为嵌套对象。默认为<code class="fe le lf lg lh b">false</code></li><li id="221f" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">maxRowLength</code>—CSV行可以包含的最大字符数</li><li id="c36c" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">checkColumn</code> —检查一行的列号是否与标题相同</li><li id="437a" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">eol</code> —要检查的行尾字符</li><li id="1fda" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">escape</code> —引用列中使用的转义字符。默认为双引号</li><li id="39ab" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">includeColumns</code> —包含列模式的正则表达式</li><li id="5226" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">ignoreColumns</code> —包含要忽略的列的模式的正则表达式</li><li id="977f" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">colParser</code> —覆盖如何解析列的JSON对象。例如<code class="fe le lf lg lh b">{ foo : ’number’}</code>将把<code class="fe le lf lg lh b">foo</code>字段解析为一个数字。</li><li id="7417" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">alwaysSplitAtEOL</code> —布尔值，表示是否按行尾字符分割每一行</li><li id="4977" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">nullObject</code> —布尔值，表示我们是否保留<code class="fe le lf lg lh b">null</code>。</li><li id="4a15" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">downstreamFormat</code> —设置下游需要什么JSON数组格式的选项。可以用<code class="fe le lf lg lh b">'line'</code>解析成CSVlines，<code class="fe le lf lg lh b">'array'</code>向下游写一个完整的JSON数组</li><li id="df33" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe le lf lg lh b">needEmitAll</code> —如果调用了<code class="fe le lf lg lh b">.then</code>或使用了<code class="fe le lf lg lh b">await</code>，解析器将构建JSON结果。</li></ul><h1 id="286d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="757d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">有了<code class="fe le lf lg lh b">csvtojson</code>节点包，将CSV解析成JSON就很容易了。它返回一个承诺或逐行发出解析后的CSV，这样我们就可以按照自己喜欢的方式处理它们。</p><p id="f8a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解析是异步完成的，所以性能不会成为问题。</p></div></div>    
</body>
</html>