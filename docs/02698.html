<html>
<head>
<title>Create Mobx Observable Objects and Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Mobx可观察对象和数组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-mobx-observable-objects-and-arrays-3743bed6366d?source=collection_archive---------5-----------------------#2020-03-30">https://levelup.gitconnected.com/create-mobx-observable-objects-and-arrays-3743bed6366d?source=collection_archive---------5-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6c90c141d8d9ec0c69ba9e2d559c8c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kicbyFlor5pMg-Js"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@junfungchin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">钱杰夫</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2208" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Mobx是JavaScript应用程序的状态管理解决方案。它让我们观察来自商店的值，然后设置这些值，这些值将立即反映在商店中。</p><p id="228e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何用Mobx创建可观察对象。</p><h1 id="a85f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可观察的物体</h1><p id="2ef2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Mobx为我们提供了<code class="fe mh mi mj mk b">observable.object</code>方法，可以这样调用:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5d94" class="mt lf it mk b gy mu mv l mw mx">observable.object(props, decorators?, options?)</span></pre><p id="4189" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一个普通的JavaScript对象被传递给<code class="fe mh mi mj mk b">observable</code>，那么里面的所有属性都将被克隆并变得可见。</p><p id="2018" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">普通对象不是由构造函数创建的，而是以<code class="fe mh mi mj mk b">Object</code>为原型或者没有原型的对象。</p><p id="82c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，<code class="fe mh mi mj mk b">observable</code>是递归应用的，所以如果遇到的值是一个对象或数组，该值也将通过<code class="fe mh mi mj mk b">observable</code>传递。</p><p id="e462" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下使用<code class="fe mh mi mj mk b">observable.object</code>方法:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c58c" class="mt lf it mk b gy mu mv l mw mx">import { observable, autorun, observe, action } from "mobx";</span><span id="253b" class="mt lf it mk b gy my mv l mw mx">const person = observable(<br/>  {<br/>    firstName: "Jane",<br/>    lastName: "Smith",<br/>    get fullName() {<br/>      return `${this.firstName}, ${this.lastName}`;<br/>    },<br/>    setAge(age) {<br/>      this.age = age;<br/>    }<br/>  },<br/>  {<br/>    setAge: action<br/>  }<br/>);</span><span id="4d4b" class="mt lf it mk b gy my mv l mw mx">observe(person, ({ newValue, oldValue }) =&gt; console.log(newValue, oldValue));<br/>person.setAge(20);</span></pre><p id="9d63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mh mi mj mk b">observable</code>函数创建了可观察的<code class="fe mh mi mj mk b">person</code>对象，它将一个普通对象作为第一个参数。然后我们用第二个对象将对象中的<code class="fe mh mi mj mk b">setAge</code>方法设置为<code class="fe mh mi mj mk b">action</code>。</p><p id="bdd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以用<code class="fe mh mi mj mk b">observe</code>方法观察值的变化，该方法将可观察的<code class="fe mh mi mj mk b">person</code>对象作为第一个参数，将一个变化监听器作为第二个参数。</p><p id="b22e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们跑的时候:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6624" class="mt lf it mk b gy mu mv l mw mx">person.setAge(20);</span></pre><p id="e4e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们传递给<code class="fe mh mi mj mk b">observe</code>的监听器将会运行。</p><p id="53c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在MobX 4或更低版本中，当我们将对象传递给<code class="fe mh mi mj mk b">observable</code>时，只有在使对象可观察时存在的属性才会被观察到。除非使用了<code class="fe mh mi mj mk b">set</code>或<code class="fe mh mi mj mk b">extendObservable</code>操作系统，否则以后添加到对象的属性是不可见的。</p><p id="eeaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有普通的物体才会被观察到。对于非简单对象，初始化可观察属性被认为是构造函数的责任。</p><p id="8faf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">@observale</code>注释或者<code class="fe mh mi mj mk b">extendObservable</code>函数。</p><p id="e34a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性getters将自动转换为派生属性。</p><p id="03b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">oberservable</code>在实例化时自动递归应用于整个对象，当新值被分配给可观察属性时也是如此。它不会递归地将<code class="fe mh mi mj mk b">observable</code>应用于非简单对象。</p><p id="a4b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将<code class="fe mh mi mj mk b">{ deep: false }</code>传递给<code class="fe mh mi mj mk b">observable</code>的第三个参数来禁用属性值的自动转换。</p><p id="1c35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以使用<code class="fe mh mi mj mk b">autorun</code>函数来观察如下变化的值:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7fa0" class="mt lf it mk b gy mu mv l mw mx">import { observable, autorun, action } from "mobx";</span><span id="ae19" class="mt lf it mk b gy my mv l mw mx">const person = observable(<br/>  {<br/>    firstName: "Jane",<br/>    lastName: "Smith",<br/>    get fullName() {<br/>      return `${this.firstName}, ${this.lastName}`;<br/>    },<br/>    setAge(age) {<br/>      this.age = age;<br/>    }<br/>  },<br/>  {<br/>    setAge: action<br/>  },<br/>  {<br/>    name: "person"<br/>  }<br/>);</span><span id="24f2" class="mt lf it mk b gy my mv l mw mx">autorun(() =&gt; console.log(person.age));<br/>autorun(() =&gt; console.log(person.firstName));</span><span id="3133" class="mt lf it mk b gy my mv l mw mx">person.setAge(20);<br/>person.firstName = "Joe";</span></pre><p id="43aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，当我们通过<code class="fe mh mi mj mk b">setAge</code>更新<code class="fe mh mi mj mk b">person.age</code>时，或者当我们像使用<code class="fe mh mi mj mk b">firstName</code>一样直接更新属性时，我们将看到传递给<code class="fe mh mi mj mk b">autorun</code>的回调函数运行。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/cbfc42a0eb383497bfd62f1efd36a667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-5b-i8zJKGa3nKiG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@robwingate?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗布·温盖特</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c2d0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可观察阵列</h1><p id="15ff" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">observable.array</code>方法创建一个可观察的数组。它将一个数组作为第一个参数。</p><p id="8ff2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8451" class="mt lf it mk b gy mu mv l mw mx">import { observable, autorun } from "mobx";</span><span id="c01a" class="mt lf it mk b gy my mv l mw mx">const fruits = observable(["apple", "orange"]);</span><span id="e115" class="mt lf it mk b gy my mv l mw mx">autorun(() =&gt; console.log(fruits.join(", ")));</span><span id="8893" class="mt lf it mk b gy my mv l mw mx">fruits.push("grape");<br/>fruits[0] = "pear";</span></pre><p id="cdfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们将数组传递给了<code class="fe mh mi mj mk b">observable</code>。然后我们运行<code class="fe mh mi mj mk b">autorun</code>,每次<code class="fe mh mi mj mk b">fruits</code>改变时都会运行一次回调。</p><p id="7693" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们在<code class="fe mh mi mj mk b">fruits</code>上运行数组操作时，我们在传递给<code class="fe mh mi mj mk b">autorun</code>的回调中获得最新的值。</p><p id="506b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下方法也可用于可观测阵列:</p><ul class=""><li id="d197" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><code class="fe mh mi mj mk b">intercept(interceptor)</code> —截取数组变化操作</li><li id="f215" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mh mi mj mk b">observe(listener, fireImmediately? = false)</code> —监听数组变化</li><li id="439f" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mh mi mj mk b">clear()</code> —从数组中删除所有条目</li><li id="ad4e" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mh mi mj mk b">replace(newItems)</code> —用新条目替换所有条目。</li><li id="4c31" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mh mi mj mk b">find(predicate: (item, index, array) =&gt; boolean, thisArg?)</code> —与通常的<code class="fe mh mi mj mk b">Array.prototype.find</code>方法相同</li><li id="18c0" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mh mi mj mk b">findIndex(predicate: (item, index, array) =&gt; boolean, thisArg?)</code> —与通常的<code class="fe mh mi mj mk b">Array.prototype.findIndex</code>方法相同</li><li id="a1fb" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mh mi mj mk b">remove(value)</code> —从数组中按值删除单个项目。如果找到并移除了该项目，则返回<code class="fe mh mi mj mk b">true</code></li></ul><p id="38e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将<code class="fe mh mi mj mk b">{ deep: false }</code>作为<code class="fe mh mi mj mk b">observable.array</code>的第二个参数传入，以防止将项目设置为递归可见。</p><p id="8eba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以传入<code class="fe mh mi mj mk b">{ name: "my array" }</code>作为第二个参数，为调试目的添加一个名称。</p><h1 id="41dd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="3def" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">observable.object</code>和<code class="fe mh mi mj mk b">observable.array</code>方法创建可观察的对象来创建可观察的数组。</p><p id="3f3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">autorun</code>观察值的变化，当可观察的物体变化时，它会给我们最新的值。</p><p id="d491" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以设置各种选项来控制可观察值的转换方式。</p></div></div>    
</body>
</html>