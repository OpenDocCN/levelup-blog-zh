<html>
<head>
<title>JavaScript Clean Code — Objects and Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码—对象和类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-objects-and-classes-49eb5a30e242?source=collection_archive---------2-----------------------#2020-03-10">https://levelup.gitconnected.com/javascript-clean-code-objects-and-classes-49eb5a30e242?source=collection_archive---------2-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/41ac948195b9550f62cd92e63317866d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Okfrecyeyo7flPIf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@creativeexchange?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上创意交流</a>拍摄的照片</figcaption></figure><p id="201f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当编写干净的代码时，我们必须小心我们定义的对象和类或构造函数。我们不想公开我们不想让外界看到的数据，我们希望我们的数据结构以一种易于重用的方式定义。</p><p id="aaa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何以一种易于使用的方式组织我们的数据。</p><h1 id="f8d5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在构造函数上使用类</h1><p id="140e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该使用类而不是构造函数。它更清晰，继承也更容易。</p><p id="c865" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们本质上是一样的。类语法是构造函数语法的语法糖。</p><p id="98d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下定义一个<code class="fe mh mi mj mk b">Person</code>类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ebf1" class="mt lf it mk b gy mu mv l mw mx">class Person{<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;    <br/>  }   <br/>}</span></pre><p id="ccd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，我们的构造函数将<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">age</code>作为参数，并将其设置为实例变量的值。</p><p id="7a58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们需要扩展这个类的时候，它会大放异彩。我们可以创建一个拥有<code class="fe mh mi mj mk b">Person</code>类的实例变量的<code class="fe mh mi mj mk b">Employee</code>类，并如下扩展它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1039" class="mt lf it mk b gy mu mv l mw mx">class Employee extends Person {<br/>  constructor(name, age, employeeCode) {<br/>    super(name, age);<br/>    this.employeeCode = employeeCode;<br/>  }<br/>}</span></pre><p id="d850" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所要做的就是用<code class="fe mh mi mj mk b">super</code>调用超类的构造函数，然后我们可以在<code class="fe mh mi mj mk b">constructor</code>中设置<code class="fe mh mi mj mk b">Employee</code>类的实例变量。</p><h1 id="43f0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Getters和Setters</h1><p id="337b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Getters和setters有利于隐藏被访问的实际数据。我们可以有计算属性，这意味着我们可以抽象这些计算属性的实现，这样当我们改变实现时，就不必担心改变使用它们的代码。</p><p id="4a99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，设置器让我们在设置数据之前进行验证，而不是直接设置它们。</p><p id="0912" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，错误处理和日志也可以很容易地添加到其中。</p><p id="2ec7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以用getters延迟加载对象属性。</p><p id="c7e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用getters:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="21f1" class="mt lf it mk b gy mu mv l mw mx">class Rectangle {<br/>  constructor(length, width) {<br/>    this._length = length;<br/>    this._width = width;<br/>  }</span><span id="7c13" class="mt lf it mk b gy my mv l mw mx">  get area() {<br/>    return this._length * this._width;<br/>  }<br/>}</span></pre><p id="c940" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们可以用它来创建一个计算属性，以获得矩形的面积。</p><p id="9880" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ba23" class="mt lf it mk b gy mu mv l mw mx">let rectangle = new Rectangle(1, 2);<br/>console.log(rectangle.area);</span></pre><p id="b47f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将验证添加到setters中，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2b1d" class="mt lf it mk b gy mu mv l mw mx">class Rectangle {<br/>  constructor(length, width) {<br/>    this._length = length;<br/>    this._width = width;<br/>  }</span><span id="9539" class="mt lf it mk b gy my mv l mw mx">  get area() {<br/>    return this._length * this._width;<br/>  }</span><span id="d7fc" class="mt lf it mk b gy my mv l mw mx">  get length() {<br/>    return this._length;<br/>  }</span><span id="2674" class="mt lf it mk b gy my mv l mw mx">  set length(length) {<br/>    if (length &lt;= 0) {<br/>      throw new Error('Length must be bigger than 0');<br/>    }<br/>    this._length = length;<br/>  }</span><span id="41d1" class="mt lf it mk b gy my mv l mw mx">  get width() {<br/>    return this._width;<br/>  }</span><span id="dd8b" class="mt lf it mk b gy my mv l mw mx">  set width(width) {<br/>    if (width &lt;= 0) {<br/>      throw new Error('Width must be bigger than 0');<br/>    }<br/>    this._width = width;<br/>  }<br/>}</span></pre><p id="f68a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，定义getters也是一个好主意，这样我们就可以访问属性的值。</p><h1 id="bffe" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">保持成员私密</h1><p id="46a6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript类中没有私有变量，所以我们应该在块范围内定义私有变量，这样它们就不会用<code class="fe mh mi mj mk b">let</code>和<code class="fe mh mi mj mk b">const</code>暴露给公众。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/ab68d0a58237d039f405b1df2a862bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pTN6fnoHlQjxMU2-"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">蒂娜·道森在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="9c80" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">链接方法</h1><p id="2b33" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">链接方法使得调用一系列函数变得不那么冗长。我们可以通过返回<code class="fe mh mi mj mk b">this</code>来定义一个可以被链接的函数。</p><p id="2fa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="918f" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>  setName(name) {<br/>    this.name = name;<br/>    return this;<br/>  }</span><span id="6446" class="mt lf it mk b gy my mv l mw mx">  setAge(age) {<br/>    this.age = age;<br/>    return this;<br/>  }<br/>}</span></pre><p id="0e55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="900c" class="mt lf it mk b gy mu mv l mw mx">const person = new Person().setName('Joe').setAge(10);</span></pre><p id="3ccb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们记录<code class="fe mh mi mj mk b">person</code>时，我们得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="397a" class="mt lf it mk b gy mu mv l mw mx">{name: "Joe", age: 10}</span></pre><p id="32d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是在jQuery和Lodash等许多库中使用的常见模式。</p><h1 id="7da6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更喜欢组合而不是继承</h1><p id="1ed7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该只为“是-a”关系留下类继承。关系是某个更大实体的子集。例如，雇员是一个人。</p><p id="e14c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不然就用作文代替。例如，如果我们想保留一个<code class="fe mh mi mj mk b">Person</code>的地址，我们可以创建一个名为<code class="fe mh mi mj mk b">Address</code>的类，并在<code class="fe mh mi mj mk b">Person</code>类的方法中实例化它，然后在那里使用它。</p><p id="4e7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">A <code class="fe mh mi mj mk b">Person</code>与<code class="fe mh mi mj mk b">Address</code>有‘has-a’关系，所以在这种情况下我们不应该使用继承。</p><p id="a5dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写类似下面的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d3d4" class="mt lf it mk b gy mu mv l mw mx">class Address {<br/>  constructor(streetName) {<br/>    this.streetName = streetName;<br/>  }<br/>}</span><span id="6c51" class="mt lf it mk b gy my mv l mw mx">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }</span><span id="2587" class="mt lf it mk b gy my mv l mw mx">  setAddress() {<br/>    const address = new Address('123 A St.');<br/>  }<br/>}</span></pre><h1 id="3e6a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="4f7a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">类的语法比构造函数的语法更容易理解，尤其是当我们需要继承的时候。因此，是时候尽快远离构造函数语法了。</p><p id="b33d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该只在“是-a”关系中使用类继承。不然就用作文代替。</p><p id="4ff8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以使用getters和setters来保持私有成员的实现。在为成员设置值之前，我们可以将getters用于计算属性，将setters用于运行代码。例如，我们可以在用setter设置值之前运行一些验证代码。</p><p id="c611" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">链接方法也是一种普遍接受的方法，通过减少调用的冗长来清理代码。</p></div></div>    
</body>
</html>