<html>
<head>
<title>A Complete Beginners Guide To Javascript — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript初学者完全指南—第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-complete-beginners-guide-to-javascript-part-1-d04919d0cb19?source=collection_archive---------2-----------------------#2019-06-29">https://levelup.gitconnected.com/a-complete-beginners-guide-to-javascript-part-1-d04919d0cb19?source=collection_archive---------2-----------------------#2019-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f2c1132f120d6dd330bd27a340b04e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Xqei5CDKIPJ7VewFuAPjA.png"/></div></div></figure><p id="97d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是两个故事中的第一个，在这里你将学到开始使用Javascript编程所需要知道的一切。</p><blockquote class="kw kx ky"><p id="61e0" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">要了解用于DOM和web的Javascript，请查看<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/a-complete-beginners-guide-to-javascript-part-2-501ec89af76c?source=friends_link&amp;sk=33ec19c8db7d53646246e9104b873281">第2部分</a></p></blockquote><p id="1b64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么这个故事包括什么呢？我将它分成了以下几个部分，涵盖了Javascript的基础知识:</p><ul class=""><li id="af07" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">介绍</li><li id="95cd" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">变量</li><li id="abf0" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">分配</li><li id="fafa" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">数据类型</li><li id="107e" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">功能</li><li id="b3ef" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">用线串</li><li id="29a6" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">数字</li><li id="03e7" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">数组</li><li id="1255" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">目标</li><li id="aa73" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">日期</li><li id="31e9" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">算术和数学</li><li id="771c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">条件和比较</li><li id="88ef" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">环</li><li id="7119" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">错误</li><li id="4d29" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">班级</li><li id="2654" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">异步编程</li></ul><p id="a4df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我建议使用类似于<a class="ae ld" href="http://playcode.io" rel="noopener ugc nofollow" target="_blank"> PlayCode.io </a>的工具来跟踪这个故事，这样你就可以真正了解我们经历的每一件事。</p><h1 id="6233" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">介绍</h1><p id="1ffb" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们先来说说Javascript是什么，为什么它如此重要。Javascript创建于1995年，是一种为万维网设计的编程语言，现在被绝大多数网站使用。它使我们能够创建交互式web应用程序，如果操作得当，可以给最终用户带来更加高效、用户友好和愉快的体验。</p><p id="d69b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">多年来，Javascript已经成为一种非常强大的语言，并且有了许多可用的框架，您可以做几乎任何您能想到的事情。现在，你甚至可以使用NodeJS将Javascript用于后端，使用ReactNative等框架构建iOS和Android应用，使用Electron等框架构建跨平台桌面应用。</p><p id="323f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经讨论了Javascript是什么以及它为什么有用，让我们来看看一些基本的语法。</p><p id="f042" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将从注释开始，这些注释非常有用，不仅有助于组织你的代码，也有助于你和其他开发者理解正在发生的事情。</p><p id="d28e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用两个正斜杠来编写单行注释:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9b8d" class="ne lt iq na b gy nf ng l nh ni">// This is a single line comment</span></pre><p id="1fd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以写多行注释:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="55f9" class="ne lt iq na b gy nf ng l nh ni">/*<br/>This is a<br/>multi-line<br/>comment<br/>*/</span></pre><p id="8326" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们有变量，这些用来保存数据。变量可以使用三个关键字声明，var、let和const:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6d54" class="ne lt iq na b gy nf ng l nh ni">var variableName;<br/>let variableName;<br/>const variableName;</span></pre><p id="d0a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nj nk nl na b">var</code>、<code class="fe nj nk nl na b">let</code>和<code class="fe nj nk nl na b">const</code>都是关键字，这意味着它们用来定义要执行什么动作。通过<code class="fe nj nk nl na b">var</code>、<code class="fe nj nk nl na b">let</code>和<code class="fe nj nk nl na b">const</code>，我们告诉浏览器创建变量。</p><p id="3be4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">变量名不能以数字开头，通常你会看到它们以小写字母或下划线开头。在Javascript中，我们对几乎所有东西都使用所谓的Camel Case，包括变量名。这是第一个单词以小写字母开始，然后后面的每个单词都以大写字母开始。</p><p id="a813" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着代替:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e1ec" class="ne lt iq na b gy nf ng l nh ni">variable_name<br/>variable-name<br/>VariableName</span></pre><p id="6030" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e333" class="ne lt iq na b gy nf ng l nh ni">variableName</span></pre><p id="1bc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Javascript也是区分大小写的，所以<code class="fe nj nk nl na b">variableName</code>和<code class="fe nj nk nl na b">VariableName</code>不一样。</p><p id="e499" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们有文字，它们只是简单的固定值。例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1096" class="ne lt iq na b gy nf ng l nh ni">20<br/>"Hello World"</span></pre><p id="339a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们快速看一下操作符，这些符号允许你做赋值，算术和比较。例如，如果我们想给一个变量赋值20，那么我们可以使用等号运算符。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fc9d" class="ne lt iq na b gy nf ng l nh ni">let variable = 20;</span></pre><p id="4a3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者我们想用20乘以5，为此，我们会使用乘法运算符，它是一个星号。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9515" class="ne lt iq na b gy nf ng l nh ni">20 * 5</span></pre><p id="f6ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用我们的乘法，我们刚刚写的叫做表达式。表达式是文字、变量、函数和运算符的混合体，当它们组合在一起时用于计算单个值。用20乘以5，我们用乘法运算符将文字20和5结合起来计算值100。</p><p id="5454" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是Javascript的基本语法，现在让我们更详细地看看变量。</p><h1 id="8d0b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">变量</h1><p id="9ad5" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">正如我前面提到的，在Javascript中我们有三种声明变量的方法，<code class="fe nj nk nl na b">var</code>，<code class="fe nj nk nl na b">let</code>和<code class="fe nj nk nl na b">const</code>。那么它们之间的区别是什么呢？</p><p id="8b68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nj nk nl na b">var</code>和<code class="fe nj nk nl na b">let</code>都是可变的，这基本上意味着我们可以改变它们的值。<code class="fe nj nk nl na b">const</code>另一方面，是不可变的，认为它是只读的，所以值不能被改变。例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="de0d" class="ne lt iq na b gy nf ng l nh ni">// This will work<br/>var animal = "dog";<br/>animal = "cat";</span><span id="26c2" class="ne lt iq na b gy nm ng l nh ni">// This will work<br/>let animal = "dog";<br/>animal = "cat";</span><span id="4a62" class="ne lt iq na b gy nm ng l nh ni">// This will not work<br/>const animal = "dog";<br/>animal = "cat";</span></pre><p id="09c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么如果<code class="fe nj nk nl na b">var</code>和<code class="fe nj nk nl na b">let</code>都是易变的，那么两者有什么区别呢？嗯，他们基本上有不同的范围。这意味着访问它们的能力根据您在脚本中的位置而不同，<code class="fe nj nk nl na b">var</code>是函数范围的，<code class="fe nj nk nl na b">let</code>和<code class="fe nj nk nl na b">const</code>都是块范围的。这意味着<code class="fe nj nk nl na b">var</code>可以在整个函数中被访问，而<code class="fe nj nk nl na b">let</code>和<code class="fe nj nk nl na b">const</code>只能在声明它们的块中使用。块是大括号内的任何东西。</p><p id="6052" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看一个例子:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="b4bd" class="ne lt iq na b gy nf ng l nh ni">// Var<br/>for (let i=0; i&lt;1; i++) {<br/>    <br/>  var animal = "dog";    <br/>  let country = "England";  <br/>  const planet = "Earth";</span><span id="d6eb" class="ne lt iq na b gy nm ng l nh ni">}</span><span id="4f1a" class="ne lt iq na b gy nm ng l nh ni">// This will log "dog"<br/>console.log(animal);</span><span id="18fd" class="ne lt iq na b gy nm ng l nh ni">// These will both throw errors<br/>console.log(country);<br/>console.log(planet);</span></pre><p id="c7e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当试图记录<code class="fe nj nk nl na b">country</code>和<code class="fe nj nk nl na b">planet</code>变量时，您会看到一个错误，这是因为我们试图从声明它们的块之外访问它们。</p><p id="a265" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你现在可能想知道为什么会这样，看着代码你可能会认为<code class="fe nj nk nl na b">var</code>也只能在块内使用，因为那是它被声明的地方。它的工作原理是一种叫做提升的东西。Javascript所做的是，在创建阶段，它在函数的开始用值<code class="fe nj nk nl na b">undefined</code>初始化<code class="fe nj nk nl na b">var</code>。当那行代码运行时，您想要的值就会被赋值。因为我们仍然在同一个函数中，所以我们可以从块的外部访问<code class="fe nj nk nl na b">animal</code>，因为它实际上已经在块之前被定义了。一开始这可能有点混乱，但是你写的Javascript越多，你就会越明白。</p><p id="cfb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Javascript中，我们不需要在声明变量时赋值，例如，我们可以这样声明<code class="fe nj nk nl na b">animal</code>:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3714" class="ne lt iq na b gy nf ng l nh ni">let animal;</span></pre><p id="7ba0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在即使我们没有给它赋值，它仍然有一个值，这个值就是<code class="fe nj nk nl na b">undefined</code>。我们甚至可以一次声明多个变量:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9f55" class="ne lt iq na b gy nf ng l nh ni">let animal, country, planet;</span></pre><p id="c128" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们对变量有了更多的了解，让我们继续学习赋值。</p><h1 id="81fd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">分配</h1><p id="1b78" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">赋值基本上就是它所说的，它是给一个变量赋值的过程。我们已经看过了给变量赋值:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="dd6f" class="ne lt iq na b gy nf ng l nh ni">let animal = "dog";</span></pre><p id="0a44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以将变量赋给其他变量:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5b37" class="ne lt iq na b gy nf ng l nh ni">let animalOne = "dog";<br/>let animalTwo = animalOne;</span></pre><p id="7174" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里<code class="fe nj nk nl na b">animalOne</code>和<code class="fe nj nk nl na b">animalTwo</code>都等于<code class="fe nj nk nl na b">"dog"</code>。</p><p id="e02e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Javascript中，我们有一些快速更新变量值的方法。例如，假设我们有一个值为<code class="fe nj nk nl na b">"Hello"</code>的变量，我们想给这个变量加上<code class="fe nj nk nl na b">"World"</code>。要做到这一点，您只需:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="8e29" class="ne lt iq na b gy nf ng l nh ni">let myVar = "Hello";<br/>myVar += " World";</span></pre><p id="b6ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里所做的被称为串联，这是两个或更多的值连接在一起成为一个值。在我们的例子中<code class="fe nj nk nl na b">"Hello"</code>和<code class="fe nj nk nl na b">" World"</code>变成了<code class="fe nj nk nl na b">"Hello World"</code>。</p><p id="39ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们尝试连接两个数字会发生什么？嗯，它们是加在一起的而不是连在一起的。例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="361d" class="ne lt iq na b gy nf ng l nh ni">let myVar = 1;<br/>myVar += 1;</span></pre><p id="6e32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的<code class="fe nj nk nl na b">myVar</code>现在等于<code class="fe nj nk nl na b">2</code>，而不是<code class="fe nj nk nl na b">11</code>。在处理数字时，我们也可以像刚才做加法一样，快速地进行加减运算。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="90f3" class="ne lt iq na b gy nf ng l nh ni">let myVar = 1;</span><span id="28bc" class="ne lt iq na b gy nm ng l nh ni">// Increment<br/>myVar++; // myVar now equals 2</span><span id="e7d2" class="ne lt iq na b gy nm ng l nh ni">// Multiple<br/>myVar *= 5; // myVar now equals 10</span><span id="cbcb" class="ne lt iq na b gy nm ng l nh ni">// Divide<br/>myVar /= 2; // myVar now equals 5</span><span id="0133" class="ne lt iq na b gy nm ng l nh ni">// Subtract<br/>myVar -= 2; // myVar now equals 3</span><span id="201c" class="ne lt iq na b gy nm ng l nh ni">// Decrement<br/>myVar--; // myVar now equals 2</span></pre><p id="fd2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是你需要知道的关于赋值的全部内容，现在让我们来看看数据类型。</p><h1 id="f248" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">数据类型</h1><p id="2730" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们现在已经很好地理解了变量和给这些变量赋值，所以让我们更深入地了解变量可以包含的数据类型。</p><p id="ded1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经知道了字符串和数字。关于字符串，有一点需要注意，它们可以用单引号或双引号括起来，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f14d" class="ne lt iq na b gy nf ng l nh ni">'my string'<br/>"my string"</span></pre><p id="0896" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个最简单的数据类型是布尔型，基本上不是真就是假。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="64e6" class="ne lt iq na b gy nf ng l nh ni">let loading = false;</span></pre><p id="c6cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于布尔变量，我们可以将相反的值赋给变量，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c8e3" class="ne lt iq na b gy nf ng l nh ni">let loading = false;<br/>loading = !loading; // Loading now equals true</span></pre><p id="7de7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以根据条件分配布尔值，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a721" class="ne lt iq na b gy nf ng l nh ni">let first = 4;<br/>let second = 7;<br/>let isEqual = (first === second);</span></pre><p id="52a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里<code class="fe nj nk nl na b">isEqual</code>等于<code class="fe nj nk nl na b">false</code>，因为我们的<code class="fe nj nk nl na b">first</code>变量不等于我们的<code class="fe nj nk nl na b">second</code>变量。</p><p id="b1f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们来看看数组。数组允许我们在一个变量中存储多个值，并且是用方括号定义的。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bbad" class="ne lt iq na b gy nf ng l nh ni">let colours = ["red", "green", "blue"];</span></pre><p id="2083" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不必在声明数组时填充它，我们可以声明一个空数组，稍后再填充它。例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1d89" class="ne lt iq na b gy nf ng l nh ni">let colours = [];</span><span id="ef32" class="ne lt iq na b gy nm ng l nh ni">colours.push("red");<br/>colours.push("green");<br/>colours.push("blue");</span></pre><p id="0480" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们仍然以数组结束，就像我们创建的第一个数组一样。为了访问变量保存的值，我们使用数组的索引。数组是从零开始的，这意味着索引从0开始。例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="46c4" class="ne lt iq na b gy nf ng l nh ni">console.log(colours[0]); // This logs red<br/>console.log(colours[1]); // This logs green<br/>console.log(colours[2]); // This logs blue</span></pre><p id="bb4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的索引不一定是数字，也可以是字符串，这叫做关联数组。例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="8210" class="ne lt iq na b gy nf ng l nh ni">let user = [];<br/>user["firstName"] = "Bob";<br/>user["lastName"] = "Smith";</span><span id="f0de" class="ne lt iq na b gy nm ng l nh ni">console.log(user["firstName"]); // This logs Bob<br/>console.log(user["lastName"]); // This logs Smith</span></pre><p id="f3b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我们创建的所有数组都是一维的，这意味着只有一个值列表。数组也可以是多维的，换句话说，是列表中的列表。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5543" class="ne lt iq na b gy nf ng l nh ni">let sequences = [];</span><span id="3333" class="ne lt iq na b gy nm ng l nh ni">let sequence1 = [1,2,3,4,5,6];<br/>let sequence2 = [1,1,2,3,5,8];</span><span id="a2d1" class="ne lt iq na b gy nm ng l nh ni">sequences.push(sequence1);<br/>sequences.push(sequence2);</span></pre><p id="b410" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在已经创建了一个二维数组，其中有一个包含不同序列的列表。我们访问值的方式和以前一样，唯一的不同是现在我们有两个索引，而不是一个。例如，假设我们想得到第一个序列中的第二个数字。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="57c5" class="ne lt iq na b gy nf ng l nh ni">console.log(sequences[0][1]); // This logs 2</span></pre><p id="9dbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于多维阵列，需要注意的一点是，添加的维度越多，阵列所需的总存储空间就会急剧增加。正因为如此，你应该明智地使用它们。</p><p id="89cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们暂时回到关联数组。尽管可以创建这种类型的数组，但您很少会在Javascript中看到它们。这是因为有一种更好的方法，那就是使用对象。</p><p id="021d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对象是Javascript的支柱，几乎Javascript中的所有东西都是对象的核心。对象是一组键值对，让我们创建一个用户对象。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5a87" class="ne lt iq na b gy nf ng l nh ni">let user = {<br/>  firstName: "Bob",<br/>  lastName: "Smith"<br/>};</span></pre><p id="da9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们有两个键，<code class="fe nj nk nl na b">firstName</code>和<code class="fe nj nk nl na b">lastName</code>，以及两个值，<code class="fe nj nk nl na b">"Bob"</code>和<code class="fe nj nk nl na b">"Smith"</code>。这些值可以是任何数据类型，甚至可以是其他对象，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3f62" class="ne lt iq na b gy nf ng l nh ni">let user = {<br/>  name: {<br/>    first: "Bob",<br/>    last: "Smith",<br/>  },<br/>  age: 30,<br/>  isActive: true,<br/>  favouriteColours: [<br/>    "red",<br/>    "green",<br/>    "blue"<br/>  ]<br/>};</span></pre><p id="68da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们访问对象就像访问数组一样，除了我们使用键而不是索引。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f703" class="ne lt iq na b gy nf ng l nh ni">console.log(user.age); // This logs 30<br/>console.log(user.name.first); // This logs Bob<br/>console.log(user.favouriteColours[0]) // This logs red</span></pre><p id="baf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这么简单，你很可能会发现自己在编写Javascript时会大量使用对象。对象的一个便利特性是能够将函数作为值。例如，我们可以编写一个函数来返回用户的名字和姓氏。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fcfc" class="ne lt iq na b gy nf ng l nh ni">let user = {<br/>   firstName: "Bob",<br/>   lastName: "Smith",<br/>   fullName: function() {<br/>      return `${this.firstName} ${this.lastName}`;<br/>   }<br/>};</span></pre><p id="e9ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们记录<code class="fe nj nk nl na b">user.fullName()</code>，我们将得到<code class="fe nj nk nl na b">"Bob Smith"</code>。在这里你会看到我们使用了一些我们还没有涉及到的东西，这些函数我们将在后面的故事中介绍。另外两件事是<code class="fe nj nk nl na b">this</code>关键字和奇怪的<code class="fe nj nk nl na b">${}</code>语法。首先，<code class="fe nj nk nl na b">this</code>是一个用于从自身访问值的关键字，所以这里它是从我们的<code class="fe nj nk nl na b">user</code>对象访问值。奇怪的语法叫做模板文字，这基本上允许我们在字符串中使用变量。模板文字是我最喜欢的Javascript特性之一，我们曾经不得不使用<code class="fe nj nk nl na b">+</code>操作符来实现模板文字的功能。例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="8307" class="ne lt iq na b gy nf ng l nh ni">let first = "Hello";<br/>let second = "World";<br/>let third = "!";</span><span id="0157" class="ne lt iq na b gy nm ng l nh ni">// Old Way<br/>let oldString = first + " " + second + third;</span><span id="e60e" class="ne lt iq na b gy nm ng l nh ni">// New Way<br/>let newString = `${first} ${second}${third}`;</span></pre><p id="fae4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nj nk nl na b">oldString</code>和<code class="fe nj nk nl na b">newString</code>都拥有完全相同的值，但<code class="fe nj nk nl na b">newString</code>是以一种更简单、更易读的方式创建的。模板文字的主要好处之一是能够创建多行字符串。</p><p id="ad66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要看的最后一个数据类型是<code class="fe nj nk nl na b">typeof()</code>函数，它允许你找出值是什么数据类型，并且非常有用。例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="32ac" class="ne lt iq na b gy nf ng l nh ni">console.log(typeof("Hello")); // This logs string<br/>console.log(typeof(1)); // This logs number<br/>console.log(typeof(true)); // This logs boolean<br/>console.log(typeof(function() {})); // This logs function</span></pre><p id="945f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经很好地掌握了数据类型，让我们来看看函数。</p><h1 id="6473" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">功能</h1><p id="3f98" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">函数是专门为执行单一任务而编写的代码块。它们可以很好地分割你的代码，使其更容易阅读，它们还允许代码的可重用性，而不需要在每次你需要执行特定任务时进行复制和粘贴。我们来看看怎么写一个。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fc0b" class="ne lt iq na b gy nf ng l nh ni">function sayHello() {<br/>  console.log("Hello World");<br/>}</span></pre><p id="6253" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Javascript中，我们使用<code class="fe nj nk nl na b">function</code>关键字来声明一个函数，后跟函数名，函数名后面有括号。要调用一个函数，只需键入函数名，后跟括号。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="b59f" class="ne lt iq na b gy nf ng l nh ni">sayHello(); // This will log "Hello World"</span></pre><p id="9e9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们愿意，我们可以把函数赋给一个变量。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3c2b" class="ne lt iq na b gy nf ng l nh ni">let sayHello = function() {<br/>  console.log("Hello World");<br/>}</span></pre><p id="cd3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们将函数赋给一个变量，那么我们不需要<code class="fe nj nk nl na b">function</code>关键字，相反我们可以使用箭头函数。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9d1b" class="ne lt iq na b gy nf ng l nh ni">let sayHello = () =&gt; {<br/>  console.log("Hello World");<br/>}</span></pre><p id="5791" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些函数都以相同的方式执行，并以相同的方式调用。有时，我们可能希望函数在不调用它的情况下执行，为此，我们使用一个可立即调用的函数表达式，简称IIFE。这些是这样写的:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5fb5" class="ne lt iq na b gy nf ng l nh ni">(function () {<br/>  console.log("Hello World");<br/>})();</span></pre><p id="453d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像把一个函数赋给一个变量一样，如果我们愿意，我们也可以去掉这里的关键字<code class="fe nj nk nl na b">function</code>。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a759" class="ne lt iq na b gy nf ng l nh ni">(() =&gt; {<br/>  console.log("Hello World");<br/>})();</span></pre><p id="8b2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两者的工作方式相同，只是没有关键字<code class="fe nj nk nl na b">function</code>。</p><p id="63ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你想对一个函数做的一件主要的事情是传递数据给它，我们使用参数来做这件事。函数接受的参数直接在函数名后面的括号中定义。例如，让我们创建一个将两个字符串组合在一起的函数。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3050" class="ne lt iq na b gy nf ng l nh ni">function combineStrings(first, second) {<br/>  let result = `${first} ${second}`;<br/>}</span><span id="a42d" class="ne lt iq na b gy nm ng l nh ni">combineStrings("Hello", "World");</span></pre><p id="4e5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数使用我们传入的两个字符串来创建一个新的字符串。但是有一个问题，目前我们不能得到新的字符串。为了获得新的字符串，我们需要从函数中返回它，这是使用<code class="fe nj nk nl na b">return</code>关键字完成的。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e758" class="ne lt iq na b gy nf ng l nh ni">function combineStrings(first, second) {<br/>  return `${first} ${second}`;<br/>}</span><span id="5917" class="ne lt iq na b gy nm ng l nh ni">let newString = combineStrings("Hello", "World");</span></pre><p id="5369" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们要记录<code class="fe nj nk nl na b">newString</code>，那么我们将得到<code class="fe nj nk nl na b">"Hello World"</code>。这是一个最基本的函数，函数可以像你希望的那样复杂。让我们看看参数的其他选项，例如，如果我们不知道有多少个字符串将被传递到函数中。这不是问题，我们可以使用<code class="fe nj nk nl na b">...</code>语法将所有传递的参数转换成一个数组，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ac14" class="ne lt iq na b gy nf ng l nh ni">function combineStrings(...strings) {<br/>   // This logs ["Hello","World","!"]<br/>   console.log(strings);<br/>}</span><span id="c43c" class="ne lt iq na b gy nm ng l nh ni">combineStrings("Hello", "World", "!");</span></pre><p id="39a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许我们甚至不确定参数是否会被传递，为此我们可以使用默认值。这些是这样写的:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6aa9" class="ne lt iq na b gy nf ng l nh ni">function doSomething(param1 = "Default", param2 = 34, param3 = false) {}</span><span id="ef17" class="ne lt iq na b gy nm ng l nh ni">// doSomething will use "Hello", 34, false<br/>doSomething("Hello");</span><span id="51a9" class="ne lt iq na b gy nm ng l nh ni">// doSomething will use "Hello", 100, false<br/>doSomething("Hello", 100);</span><span id="2055" class="ne lt iq na b gy nm ng l nh ni">// doSomething will use "Hello", 100, true<br/>doSomething("Hello", 100, true);</span></pre><p id="c7a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于函数，我们要看的最后一件事是它们可以调用自己，让我们来看看这是如何工作的:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="02fc" class="ne lt iq na b gy nf ng l nh ni">function increment(count = 0) {</span><span id="a9de" class="ne lt iq na b gy nm ng l nh ni">  // Log count<br/>  console.log(count);</span><span id="1610" class="ne lt iq na b gy nm ng l nh ni">  // Increment<br/>  count++;</span><span id="041c" class="ne lt iq na b gy nm ng l nh ni">  // If count equals 1then increment again<br/>  if (count === 1) {<br/>    increment(count);<br/>  }</span><span id="aac4" class="ne lt iq na b gy nm ng l nh ni">}</span><span id="b503" class="ne lt iq na b gy nm ng l nh ni">increment();</span></pre><p id="a723" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您运行这个函数，您将得到两个日志，<code class="fe nj nk nl na b">0</code>和<code class="fe nj nk nl na b">1</code>。你需要非常小心函数调用它们自己，如果你不小心，那么你可能会陷入一个无限循环，函数一遍又一遍地调用自己。</p><p id="41a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在你对函数有了很好的理解。接下来，我们将看一看我们可以用字符串做的一些很酷的事情。</p><h1 id="a75f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">用线串</h1><p id="1c2f" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Javascript有许多方便的方法来处理字符串。我现在不会一一介绍，但我会介绍我认为你会用得最多的几个。</p><p id="6935" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从<code class="fe nj nk nl na b">length</code>属性开始，它执行tin上的内容。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e5d9" class="ne lt iq na b gy nf ng l nh ni">let ourString = "Hello World!";</span><span id="a3ff" class="ne lt iq na b gy nm ng l nh ni">// This logs 12<br/>console.log(ourString.length);</span></pre><p id="65f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在假设我们想知道我们的字符串是否包含感叹号，为此我们使用<code class="fe nj nk nl na b">includes</code>方法。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="62fd" class="ne lt iq na b gy nf ng l nh ni">let withMark = "Hello World!";<br/>let withoutMark = "Hello World";</span><span id="6dd0" class="ne lt iq na b gy nm ng l nh ni">// This logs true<br/>console.log(withMark.includes("!"));</span><span id="2fef" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log(withoutMark.includes("!"));</span></pre><p id="fbd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们现在知道，如果我们的字符串包含感叹号，也许我们不希望它。为了去掉感叹号，我们可以使用<code class="fe nj nk nl na b">replace</code>方法，这需要两个参数。第一个参数是我们要搜索的内容，第二个参数是我们要替换的内容。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="dd5b" class="ne lt iq na b gy nf ng l nh ni">let ourString = "Hello World!!";</span><span id="2472" class="ne lt iq na b gy nm ng l nh ni">// This logs "Hello World!"<br/>console.log(ourString.replace("!", ""));</span></pre><p id="7785" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们搜索感叹号，并用一个空字符串替换它。现在您会注意到,<code class="fe nj nk nl na b">replace</code>方法只删除了一个感叹号，这是因为<code class="fe nj nk nl na b">replace</code>只搜索子子串的第一个实例。如果我们想要替换感叹号的所有实例，那么我们需要同时使用两种方法，即<code class="fe nj nk nl na b">split</code>和<code class="fe nj nk nl na b">join</code>方法。<code class="fe nj nk nl na b">split</code>方法使用给定的参数将一个字符串分割成一个数组，这个参数从字符串中移除。例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="31f8" class="ne lt iq na b gy nf ng l nh ni">let ourString = "Hello World!!";</span><span id="78e9" class="ne lt iq na b gy nm ng l nh ni">// This logs ["Hello World", "", ""]<br/>console.log(ourString.split("!"));</span></pre><p id="0ea1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，我们去掉了感叹号。现在唯一的问题是，这是一个数组，而不是一个字符串，要把它变回一个字符串，我们使用<code class="fe nj nk nl na b">join</code>方法。需要注意的是，<code class="fe nj nk nl na b">join</code>是一个<code class="fe nj nk nl na b">array</code>方法，而不是一个<code class="fe nj nk nl na b">string</code>方法，在一个字符串上使用它会给你一个错误。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="27d4" class="ne lt iq na b gy nf ng l nh ni">let ourString = "Hello World!!";</span><span id="4af4" class="ne lt iq na b gy nm ng l nh ni">// This logs "Hello World"<br/>console.log(ourString.split("!").join(""));</span></pre><p id="5964" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们再看一个例子，假设我们有一个字符串，其中多次出现单词single，我们想用world double替换所有single的实例。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6c1d" class="ne lt iq na b gy nf ng l nh ni">let ourString = "single single single";</span><span id="d67a" class="ne lt iq na b gy nm ng l nh ni">// Split - this logs ["", " ", " ", ""]<br/>console.log(ourString.split("single"));</span><span id="5ab8" class="ne lt iq na b gy nm ng l nh ni">// Join - this logs "double double double"<br/>console.log(ourString.split("single").join("double"));</span></pre><p id="28f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们来看看如何替换子字符串，假设我们想让所有的内容都大写。为此，我们使用了<code class="fe nj nk nl na b">toUpperCase</code>方法，还有一个以相反方式工作的<code class="fe nj nk nl na b">toLowerCase</code>方法。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cb56" class="ne lt iq na b gy nf ng l nh ni">let ourString = "hello world";<br/>let upperCase = ourString.toUpperCase();<br/>let lowerCase = upperCase.toLowerCase();</span><span id="bec0" class="ne lt iq na b gy nm ng l nh ni">// This logs "HELLO WORLD"<br/>console.log(upperCase);</span><span id="f700" class="ne lt iq na b gy nm ng l nh ni">// This logs "hello world"<br/>console.log(lowerCase);</span></pre><p id="ed94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有最后一个方法我想给你看，那就是<code class="fe nj nk nl na b">trim</code>方法。假设我们有一个用户输入，我们想处理它的值，这个值可能有不必要的空白。<code class="fe nj nk nl na b">trim</code>方法允许我们删除所有的空白。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ddb0" class="ne lt iq na b gy nf ng l nh ni">let badString = "     hello world     ";</span><span id="43e9" class="ne lt iq na b gy nm ng l nh ni">// This logs "     hello world     "<br/>console.log(badString);</span><span id="e3d0" class="ne lt iq na b gy nm ng l nh ni">// This logs "hello world"<br/>console.log(badString.trim());</span></pre><p id="6c1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，这些是我认为最有用和最常用的处理字符串的便捷方法。现在让我们来看看数字。</p><h1 id="b0de" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">数字</h1><p id="0553" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">让我们先来看看用Javascript写数字的一些不同方法。首先，我们有明显的两个，整数和浮点数。整数没有小数点，浮点有小数点。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d90e" class="ne lt iq na b gy nf ng l nh ni">// Integer<br/>8</span><span id="b70d" class="ne lt iq na b gy nm ng l nh ni">// Float<br/>8.4</span></pre><p id="d390" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们有指数符号。假设你想用7620万这个数字，而不需要输入大量的零，你可以直接输入它，它是指数。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e49a" class="ne lt iq na b gy nf ng l nh ni">// This<br/>762e5</span><span id="df59" class="ne lt iq na b gy nm ng l nh ni">// Instead of<br/>76200000</span></pre><p id="af3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以使用负指数，例如，<code class="fe nj nk nl na b">0.00762</code>就是<code class="fe nj nk nl na b">762e-5</code>。</p><p id="0e4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以把数字写成十六进制，例如，<code class="fe nj nk nl na b">161</code>就是<code class="fe nj nk nl na b">0xA1</code>。我不打算详细讨论十六进制和指数，这些是另一个更基于数学的故事的主题。</p><p id="5de1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道了一些写数字的方法，假设我们想要检查一个值是否是一个数字，为此，我们使用<code class="fe nj nk nl na b">isNaN</code>函数。<code class="fe nj nk nl na b">NaN</code>代表不是一个数字。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c700" class="ne lt iq na b gy nf ng l nh ni">// This logs false<br/>console.log(isNaN(1));</span><span id="c69b" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log(isNaN(1.6));</span><span id="7a80" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log(isNaN(762e5));</span><span id="9b2c" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log(isNaN(0xA1));</span><span id="8456" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log(isNaN(true));</span><span id="5b88" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log(isNaN("1"));</span><span id="bc6c" class="ne lt iq na b gy nm ng l nh ni">// This logs true<br/>console.log(isNaN("1A"));</span></pre><p id="b461" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数结果你都可以预料到，但是为什么<code class="fe nj nk nl na b">true</code>和<code class="fe nj nk nl na b">"1"</code>也会记录错误。<code class="fe nj nk nl na b">true</code>记录false，因为boolean基本上是一个<code class="fe nj nk nl na b">1</code>或一个<code class="fe nj nk nl na b">0</code>，所以true实际上是<code class="fe nj nk nl na b">1</code>。<code class="fe nj nk nl na b">isNaN</code>函数首先将参数转换成一个数字，然后计算出它是否是一个实际的数字。这个功能解释了为什么<code class="fe nj nk nl na b">"1"</code>返回false，因为如果你把<code class="fe nj nk nl na b">"1"</code>转换成一个数字，那么它等于<code class="fe nj nk nl na b">1</code>。</p><p id="10db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们看看改变数字格式的方法:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f8b4" class="ne lt iq na b gy nf ng l nh ni">let ourNumber = 1376.89;</span><span id="d684" class="ne lt iq na b gy nm ng l nh ni">// This logs "1376.89"<br/>console.log(ourNumber.toString());</span><span id="e8cf" class="ne lt iq na b gy nm ng l nh ni">// This logs "1.37689e+3"<br/>console.log(ourNumber.toExponential());</span><span id="cd6a" class="ne lt iq na b gy nm ng l nh ni">// This logs "1.4e+3"<br/>console.log(ourNumber.toExponential(1));</span><span id="a1cb" class="ne lt iq na b gy nm ng l nh ni">// This logs "1377"<br/>console.log(ourNumber.toFixed());</span><span id="44b1" class="ne lt iq na b gy nm ng l nh ni">// This logs "1376.890000"<br/>console.log(ourNumber.toFixed(6));</span><span id="2b74" class="ne lt iq na b gy nm ng l nh ni">// This logs "1376.89"<br/>console.log(ourNumber.toPrecision());</span><span id="62eb" class="ne lt iq na b gy nm ng l nh ni">// This logs "1376.9"<br/>console.log(ourNumber.toPrecision(5));</span></pre><p id="59dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以反过来，用<code class="fe nj nk nl na b">Number()</code>把这些格式化的字符串变回一个数字。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3071" class="ne lt iq na b gy nf ng l nh ni">let ourNumber = 1376.89;</span><span id="5a24" class="ne lt iq na b gy nm ng l nh ni">// This logs 1376.89<br/>console.log(Number(ourNumber.toString()));</span><span id="b839" class="ne lt iq na b gy nm ng l nh ni">// This logs 1376.89<br/>console.log(Number(ourNumber.toExponential()));</span><span id="45bf" class="ne lt iq na b gy nm ng l nh ni">// This logs 1400<br/>console.log(Number(ourNumber.toExponential(1)));</span><span id="cf78" class="ne lt iq na b gy nm ng l nh ni">// This logs 1377<br/>console.log(Number(ourNumber.toFixed()));</span><span id="4fdd" class="ne lt iq na b gy nm ng l nh ni">// This logs 1376.89<br/>console.log(Number(ourNumber.toFixed(6)));</span><span id="8860" class="ne lt iq na b gy nm ng l nh ni">// This logs 1376.89<br/>console.log(Number(ourNumber.toPrecision()));</span><span id="d3c5" class="ne lt iq na b gy nm ng l nh ni">// This logs 1376.9<br/>console.log(Number(ourNumber.toPrecision(5)));</span></pre><p id="d2e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，这就是作为Javascript初学者需要了解的关于数字的全部内容。现在让我们继续学习更多关于数组的知识。</p><h1 id="e928" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">数组</h1><p id="844e" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们已经看了如何声明和访问数组，现在让我们来看看你对数组做的最常见的事情之一，迭代它。在Javascript中，有三种简单的方法可以遍历整个数组。我们将从<code class="fe nj nk nl na b">for</code>循环开始。</p><p id="6516" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以用两种不同的方式编写我们的<code class="fe nj nk nl na b">for</code>循环，我们将首先看一下编写它们的老方法。我们首先声明一个计数变量，然后定义循环将运行多少次，在本例中是数组的长度，最后，我们在每次迭代中增加计数。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bfeb" class="ne lt iq na b gy nf ng l nh ni">let colours = ["red","green","blue","purple","yellow"];</span><span id="1089" class="ne lt iq na b gy nm ng l nh ni">for (let i=0; i&lt;colours.length; i++) {<br/>  console.log(colours[i]);<br/>}</span></pre><p id="3278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们刚刚编写的代码将遍历数组中的每一项，并将其记录到控制台。旧的语法有点麻烦，可能会导致令人讨厌的错误，例如，如果您不小心告诉它循环错误的次数。现在，我们能够以更简单的方式编写相同的循环，如下所示:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2e70" class="ne lt iq na b gy nf ng l nh ni">let colours = ["red","green","blue","purple","yellow"];</span><span id="92cb" class="ne lt iq na b gy nm ng l nh ni">for (colour of colours) {<br/>  console.log(colour);<br/>}</span></pre><p id="34a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这做完全相同的事情，但它看起来干净得多。虽然<code class="fe nj nk nl na b">for</code>循环确实有它的用处，例如，如果你想在循环中运行异步代码，我们有另外两种很好的方法来迭代数组。<code class="fe nj nk nl na b">forEach</code>和<code class="fe nj nk nl na b">map</code>是两个数组方法，两者写法相同。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3160" class="ne lt iq na b gy nf ng l nh ni">let colours = ["red","green","blue","purple","yellow"];</span><span id="5afc" class="ne lt iq na b gy nm ng l nh ni">colours.forEach((colour) =&gt; {<br/>  console.log(colour);<br/>});</span><span id="e703" class="ne lt iq na b gy nm ng l nh ni">colours.map((colour) =&gt; {<br/>  console.log(colour);<br/>});</span></pre><p id="4079" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两种方法都将函数作为参数，并且该函数将数组项作为参数。我们还可以向我们的函数添加两个其他参数，一个<code class="fe nj nk nl na b">index</code>参数和一个<code class="fe nj nk nl na b">array</code>参数，但我现在不会深入讨论这些。</p><p id="3a90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，你可能想知道拥有<code class="fe nj nk nl na b">forEach</code>和<code class="fe nj nk nl na b">map</code>方法的意义何在，因为它们看起来几乎完全一样，似乎做着完全相同的事情。没错，他们非常相似，<code class="fe nj nk nl na b">forEach</code>能做的事情，<code class="fe nj nk nl na b">forEach</code>能做的事情，<code class="fe nj nk nl na b">map</code>能做的事情，<code class="fe nj nk nl na b">map</code>都能做。区别在于<code class="fe nj nk nl na b">forEach</code>不返回任何东西，而<code class="fe nj nk nl na b">map</code>返回一个值。</p><p id="3b9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正因为如此，<code class="fe nj nk nl na b">forEach</code>用于当你不想修改数组时，例如，你只想显示其中的值，或者把每一项保存到存储器中。<code class="fe nj nk nl na b">map</code>用于当你想修改数组时，例如替换数组中的值。让我们通过给颜色本身添加颜色这个词来看看它的作用。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fc2d" class="ne lt iq na b gy nf ng l nh ni">let colours = ["red","green","blue","purple","yellow"];</span><span id="8b88" class="ne lt iq na b gy nm ng l nh ni">let mapColours = colours.map((colour) =&gt; {<br/>  return `${colour} colour`;<br/>});</span><span id="248d" class="ne lt iq na b gy nm ng l nh ni">let forEachColours = colours.forEach((colour) =&gt; {<br/>  return `${colour} colour`;<br/>});</span><span id="2940" class="ne lt iq na b gy nm ng l nh ni">// This logs ["red colour", "green colour", "blue colour", "purple colour", "yellow colour"]<br/>console.log(mapColours);</span><span id="74d2" class="ne lt iq na b gy nm ng l nh ni">// This logs undefined<br/>console.log(forEachColours);</span></pre><p id="1e2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我说过<code class="fe nj nk nl na b">map</code>可以做<code class="fe nj nk nl na b">forEach</code>能做的所有事情，但是你应该只在修改数组的时候使用它。你可能会想，为什么我只能用它来修改数组。原因是<code class="fe nj nk nl na b">map</code>将创建一个新的数组，即使你没有返回任何东西，作为程序员，这是我们不希望的，因为我们的代码应该尽可能快和高效。</p><p id="af4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看如何向数组中添加项，第一种方法是直接向索引中添加值。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f6a8" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4];<br/>numbers[4] = 5;</span><span id="4abf" class="ne lt iq na b gy nm ng l nh ni">// This logs [1,2,3,4,5]<br/>console.log(numbers);</span></pre><p id="43fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这样做是可能的，但我不推荐这样做。如果索引错误，那么您可能会覆盖一个值或在数组中创建间隙，这两种情况很可能都不是我们想要的。让我们来看看这些场景:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3c3f" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4];</span><span id="d2d2" class="ne lt iq na b gy nm ng l nh ni">// Overwrite<br/>numbers[2] = 5;</span><span id="6c76" class="ne lt iq na b gy nm ng l nh ni">// This logs [1,2,5,4]<br/>console.log(numbers);</span><span id="7787" class="ne lt iq na b gy nm ng l nh ni">// Gap<br/>numbers[9] = 5;</span><span id="bf27" class="ne lt iq na b gy nm ng l nh ni">// This logs [1,2,3,4,undefined,undefined,undefined,undefined,undefined,5]<br/>console.log(numbers);</span></pre><p id="8417" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">向数组中添加条目的更好的方法是使用<code class="fe nj nk nl na b">push</code>方法，就像我们在前面的故事中使用的一样。使用<code class="fe nj nk nl na b">push</code>，您想要添加的值将始终被添加到数组的末尾。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="49ad" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4];<br/>numbers.push(5);</span><span id="9abe" class="ne lt iq na b gy nm ng l nh ni">// This logs [1,2,3,4,5]<br/>console.log(numbers);</span></pre><p id="6d72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以在数组的开头添加值，为此我们使用了<code class="fe nj nk nl na b">unshift</code>方法。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e9f6" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4];<br/>numbers.unshift(5);</span><span id="594f" class="ne lt iq na b gy nm ng l nh ni">// This logs [5,1,2,3,4];<br/>console.log(numbers);</span></pre><p id="47d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们想在数组中间的某个地方添加一个值，或者多个值，该怎么办呢？我们可以通过使用<code class="fe nj nk nl na b">splice</code>方法做到这一点，这需要几个参数。第一个参数是应该插入新项目的索引。第二是应该删除多少项。最后，其余的参数是您想要添加的值。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1a9d" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4];</span><span id="cd7b" class="ne lt iq na b gy nm ng l nh ni">numbers.splice(2, 0, 5);</span><span id="b4da" class="ne lt iq na b gy nm ng l nh ni">// This logs [1,2,5,3,4];<br/>console.log(numbers);</span><span id="bea2" class="ne lt iq na b gy nm ng l nh ni">numbers.splice(2, 1, 8, 9);</span><span id="ffae" class="ne lt iq na b gy nm ng l nh ni">// This logs [1,2,8,9,3,4];<br/>console.log(numbers);</span></pre><p id="1c00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，我们可以在数组中任意位置添加值。如果我们想删除值呢。我们有三种方法可以做到这一点，<code class="fe nj nk nl na b">pop</code>、<code class="fe nj nk nl na b">shift</code>和<code class="fe nj nk nl na b">splice</code>。让我们从<code class="fe nj nk nl na b">pop</code>开始，这个方法移除数组的最后一个索引。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0cd1" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4];<br/>numbers.pop();</span><span id="e74e" class="ne lt iq na b gy nm ng l nh ni">// This logs [1,2,3]<br/>console.log(numbers);</span></pre><p id="2176" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nj nk nl na b">shift</code>方法移除数组的第一个索引。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d27e" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4];<br/>numbers.shift();</span><span id="312a" class="ne lt iq na b gy nm ng l nh ni">// This logs [2,3,4]<br/>console.log(numbers);</span></pre><p id="4842" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，<code class="fe nj nk nl na b">splice</code>的工作方式和以前一样，只是这次我们没有添加任何值。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="02a4" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4,5];</span><span id="df0c" class="ne lt iq na b gy nm ng l nh ni">numbers.splice(2, 1);</span><span id="cd57" class="ne lt iq na b gy nm ng l nh ni">// This logs [1,2,4,5]<br/>console.log(numbers);</span><span id="a730" class="ne lt iq na b gy nm ng l nh ni">numbers.splice(1,2);</span><span id="b512" class="ne lt iq na b gy nm ng l nh ni">// This logs [1,5]<br/>console.log(numbers);</span></pre><p id="88a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以声明、添加、移除和迭代数组了。在我们结束数组之前，让我们快速浏览一些非常有用的数组方法。</p><p id="713f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们有<code class="fe nj nk nl na b">toString</code>方法，它只是返回一个逗号分隔的数组字符串。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5b93" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4];</span><span id="20df" class="ne lt iq na b gy nm ng l nh ni">// This logs "1,2,3,4"<br/>console.log(numbers.toString());</span></pre><p id="eb05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们有<code class="fe nj nk nl na b">reverse</code>方法，它做了你所期望的，它反转了数组。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="53e4" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4];</span><span id="f285" class="ne lt iq na b gy nm ng l nh ni">// This logs [4,3,2,1]<br/>console.log(numbers.reverse());</span></pre><p id="451d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那之后，我们有了<code class="fe nj nk nl na b">includes</code>方法，这就像它处理字符串一样，它允许我们查看一个数组是否有值。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0251" class="ne lt iq na b gy nf ng l nh ni">let numbers = [1,2,3,4];</span><span id="53dd" class="ne lt iq na b gy nm ng l nh ni">// This logs true<br/>console.log(numbers.includes(2));</span><span id="4ed4" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log(numbers.includes(5));</span></pre><p id="326c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了一个非常方便的方法将数组连接在一起，这就是<code class="fe nj nk nl na b">concat</code>方法。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e2df" class="ne lt iq na b gy nf ng l nh ni">let numbers1 = [1,2,3,4,5];<br/>let numbers2 = [6,7,8,9,10];<br/>let numbers = numbers1.concat(numbers2);</span><span id="5b40" class="ne lt iq na b gy nm ng l nh ni">// This logs [1,2,3,4,5,6,7,8,9,10]<br/>console.log(numbers);</span></pre><p id="0370" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个数字数组，我们想计算出所有数字的和，例如把它们全部相减。为了进行求和，我们可以使用<code class="fe nj nk nl na b">reduce</code>和<code class="fe nj nk nl na b">reduceRight</code>方法。这些方法的区别在于<code class="fe nj nk nl na b">reduce</code>从第一个索引开始，<code class="fe nj nk nl na b">reduceRight</code>从最后一个索引开始。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="35f2" class="ne lt iq na b gy nf ng l nh ni">let numbers = [23,32,54,79];</span><span id="86ba" class="ne lt iq na b gy nm ng l nh ni">let reduce = numbers.reduce((total, number) =&gt; {<br/>  return total - number;<br/>});</span><span id="a57a" class="ne lt iq na b gy nm ng l nh ni">let reduceRight = numbers.reduceRight((total, number) =&gt; {<br/>  return total - number;<br/>});</span><span id="8faf" class="ne lt iq na b gy nm ng l nh ni">// This logs -142<br/>console.log(reduce);</span><span id="0f0b" class="ne lt iq na b gy nm ng l nh ni">// This logs -30<br/>console.log(reduceRight);</span></pre><p id="f905" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我选择减去所有的数字，因为这样可以让你清楚地看到<code class="fe nj nk nl na b">reduce</code>产生的结果与<code class="fe nj nk nl na b">reduceRight</code>不同，因为它是从第一个索引开始的，而不是从最后一个索引开始的。可以看到，这两种方法都将一个函数作为参数，并且这个函数有两个参数，总和以及数组的当前值。</p><p id="ac6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，假设我们想对一个数组进行升序排序，为此我们使用了<code class="fe nj nk nl na b">sort</code>方法。与前面的方法类似，<code class="fe nj nk nl na b">sort</code>也将一个函数作为参数，这个函数包含了排序的逻辑。我们传递的函数有两个参数，<code class="fe nj nk nl na b">a</code>和<code class="fe nj nk nl na b">b</code>，它们是当前值和下一个值。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="64b4" class="ne lt iq na b gy nf ng l nh ni">let numbers = [12, 97, 32, 56, 63];</span><span id="29b9" class="ne lt iq na b gy nm ng l nh ni">let sortedNumbers = numbers.sort((a, b) =&gt; {<br/>  return a - b;<br/>});</span><span id="b1bb" class="ne lt iq na b gy nm ng l nh ni">// This logs [12, 32, 56, 63, 97]<br/>console.log(sortedNumbers);</span></pre><p id="523c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，我们现在有了一个排序的数组，但是它是如何工作的呢？为什么我们要从<code class="fe nj nk nl na b">b</code>中减去<code class="fe nj nk nl na b">a</code>？</p><p id="d3bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从<code class="fe nj nk nl na b">b</code>中减去<code class="fe nj nk nl na b">a</code>，因为如果我们返回一个负数，那么<code class="fe nj nk nl na b">a</code>将排在<code class="fe nj nk nl na b">b</code>之前。如果我们想对数字进行降序排序，那么我们应该做<code class="fe nj nk nl na b">b — a</code>，因为我们希望<code class="fe nj nk nl na b">b</code>排在<code class="fe nj nk nl na b">a</code>之前。这可能需要一点时间来理解，我知道这花了我一点时间，所以让我们更详细地了解一下。</p><p id="2423" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个包含两个值的数组:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7115" class="ne lt iq na b gy nf ng l nh ni">[value1, value2]</span></pre><p id="31ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同比较<code class="fe nj nk nl na b">a — b</code>:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ce2f" class="ne lt iq na b gy nf ng l nh ni">a(value1) - b(value2)</span></pre><p id="b9b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这种比较，我们有三种可能的结果，正数、负数和零。正数表示<code class="fe nj nk nl na b">b</code>将排在<code class="fe nj nk nl na b">a</code>之前:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3d7e" class="ne lt iq na b gy nf ng l nh ni">value2, value1</span></pre><p id="6344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">负数表示<code class="fe nj nk nl na b">a</code>将排在<code class="fe nj nk nl na b">b</code>之前:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="632a" class="ne lt iq na b gy nf ng l nh ni">value1, value2</span></pre><p id="89e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">零表示不需要改变:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="88e0" class="ne lt iq na b gy nf ng l nh ni">value1, value2</span></pre><p id="4673" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，如果我们有<code class="fe nj nk nl na b">3</code>和<code class="fe nj nk nl na b">4</code>，那么它将排序为<code class="fe nj nk nl na b">[3, 4]</code>:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5c3f" class="ne lt iq na b gy nf ng l nh ni">[3, 4] -&gt; (3 - 4 = -1) -&gt; [3, 4]</span></pre><p id="6ade" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们有<code class="fe nj nk nl na b">4</code>和<code class="fe nj nk nl na b">3</code>，那么它将排序为<code class="fe nj nk nl na b">[3, 4]</code>:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c531" class="ne lt iq na b gy nf ng l nh ni">[4, 3] -&gt; (4 - 3 = 1) -&gt; [3, 4]</span></pre><p id="fc31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，如果我们有<code class="fe nj nk nl na b">4</code>和<code class="fe nj nk nl na b">4</code>，那么它将排序为<code class="fe nj nk nl na b">[4, 4]</code>:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f8ef" class="ne lt iq na b gy nf ng l nh ni">[4, 4] -&gt; (4 - 4 = 1) -&gt; [4, 4]</span></pre><p id="aa1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一次，这次用<code class="fe nj nk nl na b">[3,1,1,5]</code>:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="8400" class="ne lt iq na b gy nf ng l nh ni">// First pass<br/>[3, 1, 1, 5] -&gt; (3 - 1 = 2) -&gt; [1, 3, 1, 5] // 3 &amp; 1 swap<br/>[1, 3, 1, 5] -&gt; (3 - 1 = 2) -&gt; [1, 1, 3, 5] // 3 &amp; 1 swap</span><span id="c4ac" class="ne lt iq na b gy nm ng l nh ni">/*<br/>At this point the array is sorted, but the algorithm requires one full pass with no swaps to know that it is sorted.<br/>*/</span><span id="2485" class="ne lt iq na b gy nm ng l nh ni">[1, 1, 3, 5] -&gt; (3 - 5 = -2) -&gt; [1, 1, 3, 5] // No swap</span><span id="94fb" class="ne lt iq na b gy nm ng l nh ni">// Second pass<br/>[1, 1, 3, 5] -&gt; (1 - 1 = 0) -&gt; [1, 1, 3, 5] // No swap<br/>[1, 1, 3, 5] -&gt; (1 - 3 = -2) -&gt; [1, 1, 3, 5] // No swap<br/>[1, 1, 3, 5] -&gt; (3 - 5 = -2) -&gt; [1, 1, 3, 5] // No swap</span></pre><p id="a43c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该算法现在已经完成了一次没有交换的完整传递，因此它知道阵列已经完全排序。我已经对此进行了相当详细的介绍，因为在对数组进行排序时，了解它是如何工作的是很重要的，否则你就不能使用<code class="fe nj nk nl na b">sort</code>方法来发挥它的全部能力。我们刚刚使用的排序类型被称为冒泡排序，如果你想更多地了解不同类型的排序并直观地看到它们是如何工作的，那么我强烈推荐你尝试一下<a class="ae ld" href="https://cs.stanford.edu/people/jcjohns/sorting.js/" rel="noopener ugc nofollow" target="_blank">排序。</a></p><p id="5811" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，最后我们要看看<code class="fe nj nk nl na b">filter</code>方法。这个方法允许我们根据条件从数组中过滤出值。例如，假设我们需要所有大于50的数字。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="329d" class="ne lt iq na b gy nf ng l nh ni">let numbers = [12, 32, 43, 56, 72, 98];</span><span id="e599" class="ne lt iq na b gy nm ng l nh ni">let filteredNumbers = numbers.filter((number) =&gt; {<br/>  return number &gt; 50;<br/>});</span><span id="5ae6" class="ne lt iq na b gy nm ng l nh ni">// This logs [56, 72, 98]<br/>console.log(filteredNumbers);</span></pre><p id="9be3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">过滤数组就是这么简单。好的，现在让我们更详细地看看这些物体。</p><h1 id="54cc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">目标</h1><p id="003e" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们已经介绍了您需要了解的关于对象的大部分内容。我们已经了解了如何声明一个对象，如何给它们赋值，以及如何使用函数作为对象值。对象的值也可以使用我们刚刚看到的同样方便的方法，例如，如果你的对象有一个字符串值，你可以使用<code class="fe nj nk nl na b">toUpperCase()</code>来格式化它。关于对象，我还想给你们展示三个东西，它们是getters，setters，和constructors。</p><p id="43f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从getters开始，这些是你的对象内部的函数，允许你获取一个值。通常情况下，如果您想对所获得的值进行一些格式化，您会使用这些方法。例如，假设我们有一个包含购物篮总数的对象。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2081" class="ne lt iq na b gy nf ng l nh ni">let basket = {<br/>  total: 0<br/>};</span><span id="df1a" class="ne lt iq na b gy nm ng l nh ni">// Displays £0.00<br/>console.log(`£${basket.total.toFixed(2)}`);</span></pre><p id="fea5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果不使用getter，我们将不得不编写类似这样的代码，以用户习惯的方式显示总数。我敢肯定，你可以想象，这将是一个痛苦，必须写在你想显示总数的地方，所以我们将使用一个getter。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="abc0" class="ne lt iq na b gy nf ng l nh ni">let basket = {<br/>  total: 0,<br/>  get totalPrice() {<br/>    return `£${basket.total.toFixed(2)}`;<br/>  }<br/>};</span><span id="ae68" class="ne lt iq na b gy nm ng l nh ni">// Displays £0.00<br/>console.log(basket.totalPrice);</span></pre><p id="2075" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们所要做的就是每当我们想要得到格式化的总数时就写<code class="fe nj nk nl na b">basket.totalPrice</code>。另一方面，Setters允许我们很容易地在一个对象中设置一个值，假设我们有一个对象，当它被设置时，我们希望该值被格式化，例如，一个用户名，我们希望它是小写的。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="8238" class="ne lt iq na b gy nf ng l nh ni">let user = {<br/>  username: "",<br/>  set setUsername(value) {<br/>    this.username = value.toLowerCase();<br/>  }<br/>}</span><span id="5bb5" class="ne lt iq na b gy nm ng l nh ni">user.setUsername = "MYUSERNAME";</span><span id="eef3" class="ne lt iq na b gy nm ng l nh ni">// Logs "myusername"<br/>console.log(user.username);</span></pre><p id="830b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两个例子都是setters和getters的基本用法，通常你会用它们做比我们做的更多的事情，但是它们以简单的方式向你展示了它们做什么以及如何使用它们。</p><p id="4de1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看构造函数，它们非常方便。在开发时，很可能会出现需要多个对象使用同一个结构的情况。当然，你可以像我们一直做的那样为每个对象手动编写结构，或者你可以使用构造函数。构造函数基本上是创建对象的函数，例如，假设我们想要一个用户对象供多个用户使用。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f9d4" class="ne lt iq na b gy nf ng l nh ni">// Constructor<br/>function User(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>  this.fullName = function () {<br/>    return `${this.firstName} ${this.lastName}`<br/>  };<br/>};</span><span id="4fd5" class="ne lt iq na b gy nm ng l nh ni">// First user<br/>let firstUser = new User("Bob", "Smith");</span><span id="3e0a" class="ne lt iq na b gy nm ng l nh ni">// Second user<br/>let secondUser = new User("Jill", "Summers");</span><span id="53ca" class="ne lt iq na b gy nm ng l nh ni">// Logs "Bob Smith"<br/>console.log(firstUser.fullName());</span><span id="1f1a" class="ne lt iq na b gy nm ng l nh ni">// Logs "Jill Summers"<br/>console.log(secondUser.fullName());</span></pre><p id="83a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里你可以看到我们有两个用户变量，它们都使用相同的对象结构。就像常规函数一样，如果我们不想在创建对象时传入值，我们的构造函数可以有默认值，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e2a8" class="ne lt iq na b gy nf ng l nh ni">function User(name, online = true) {<br/>  this.name = name;<br/>  this.online = online;<br/>};</span><span id="ad46" class="ne lt iq na b gy nm ng l nh ni">let myUser = new User("Bob Smith");</span><span id="14b3" class="ne lt iq na b gy nm ng l nh ni">// This logs {name: "Bob Smith", online: true}<br/>console.log(myUser);</span></pre><p id="3b05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦创建了对象，就可以像使用任何其他对象一样使用它。这就是作为Javascript初学者需要了解的关于对象的一切。现在让我们来看看如何处理日期。</p><h1 id="5d8f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">日期</h1><p id="4f4e" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Javascript有一个处理日期的内置对象，即<code class="fe nj nk nl na b">Date</code>对象。让我们从获取当前日期和时间开始。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7416" class="ne lt iq na b gy nf ng l nh ni">// This logs Sat Jun 29 2019 15:40:17 GMT+0100 (BST)<br/>console.log(new Date());</span></pre><p id="6211" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，如果您运行此命令，您将获得不同的日志，但格式相同:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a603" class="ne lt iq na b gy nf ng l nh ni">DayName Month Day Year Hour:Minute:Second Timezone (TimezoneName)</span></pre><p id="0dfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数时候我们可能不需要所有这些信息，我们可以使用<code class="fe nj nk nl na b">Date</code> objects内置方法来获取我们想要的任何信息。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6cb2" class="ne lt iq na b gy nf ng l nh ni">// This logs 2019<br/>console.log(new Date().getFullYear());</span><span id="6527" class="ne lt iq na b gy nm ng l nh ni">// This logs 5<br/>console.log(new Date().getMonth());</span><span id="3189" class="ne lt iq na b gy nm ng l nh ni">// This logs 29<br/>console.log(new Date().getDate());</span><span id="466c" class="ne lt iq na b gy nm ng l nh ni">// This logs 6<br/>console.log(new Date().getDay());</span><span id="b53f" class="ne lt iq na b gy nm ng l nh ni">// This logs 15<br/>console.log(new Date().getHours());</span><span id="8594" class="ne lt iq na b gy nm ng l nh ni">// This logs 45<br/>console.log(new Date().getMinutes());</span><span id="9407" class="ne lt iq na b gy nm ng l nh ni">// This logs 56<br/>console.log(new Date().getSeconds());</span><span id="0f22" class="ne lt iq na b gy nm ng l nh ni">// This logs 129<br/>console.log(new Date().getMilliseconds());</span></pre><p id="d532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，这些方法将使用浏览器的时区返回日期，我们可能不希望这样。相反，我们可以使用UTC日期和时间，这就像在方法名的<code class="fe nj nk nl na b">get</code>后面加上<code class="fe nj nk nl na b">UTC</code>一样简单。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="060a" class="ne lt iq na b gy nf ng l nh ni">new Date().getUTCFullYear();<br/>new Date().getUTCMonth();<br/>new Date().getUTCDate();<br/>new Date().getUTCDay();<br/>new Date().getUTCHours();<br/>new Date().getUTCMinutes();<br/>new Date().getUTCSeconds();<br/>new Date().getUTCMilliseconds();</span></pre><p id="28a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个常见的任务是，你可能需要在某个时间点获取自纪元以来的毫秒数，这是1970年1月1日午夜UTC。自从纪元以来，我们有两种不同的方法来获得时间。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9378" class="ne lt iq na b gy nf ng l nh ni">// This logs 1561820006430<br/>console.log(new Date().getTime());</span><span id="410f" class="ne lt iq na b gy nm ng l nh ni">// This logs 1561820006430<br/>console.log(Date.now());</span></pre><p id="a742" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以看到它们都返回相同的值，我个人使用的是<code class="fe nj nk nl na b">Date.now()</code>，但是你选择哪种方法取决于你自己。这是目前你需要知道的全部内容。在Javascript中处理日期会变得非常复杂和混乱，我认识的大多数开发人员都使用第三方包来格式化和使用日期。</p><h1 id="bea0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">算术和数学</h1><p id="67c5" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们已经学习了基本的加法、减法、乘法和除法，还学习了变量的递增和递减。现在让我们来看看模数运算符，它用于计算总和的余数，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="44a3" class="ne lt iq na b gy nf ng l nh ni">// This logs 3.7<br/>console.log(8 % 4.3);</span></pre><p id="3342" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果您想知道一个数字是否是偶数，这可能很方便。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6d14" class="ne lt iq na b gy nf ng l nh ni">// This logs true because 4 is even<br/>console.log((4 % 2 === 0));</span><span id="dc9a" class="ne lt iq na b gy nm ng l nh ni">// This logs false because 3 is odd<br/>console.log((3 % 2 === 0));</span></pre><p id="60c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们有指数运算符，用于将一个数乘以另一个数的幂。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6205" class="ne lt iq na b gy nf ng l nh ni">// This logs 4 - 2 squared equals 4<br/>console.log(2 ** 2);</span><span id="1801" class="ne lt iq na b gy nm ng l nh ni">// This logs 64 - 4 cubed equals 64<br/>console.log(4 ** 3);</span></pre><p id="31c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像在学校一样，Javascript先做乘除再做加减，比如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6ee8" class="ne lt iq na b gy nf ng l nh ni">// This logs 12<br/>console.log(4 + 4 * 2);</span><span id="fb7e" class="ne lt iq na b gy nm ng l nh ni">// This logs 16<br/>console.log((4 + 4) * 2);</span></pre><p id="4180" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Javascript中，我们有一个很棒的对象叫做<code class="fe nj nk nl na b">Math</code>对象，这允许我们做更高级的数学运算。我将快速介绍一些你最有可能使用的方法。我不打算一一介绍或详述，因为那是另一个更数学化的故事。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bb8e" class="ne lt iq na b gy nf ng l nh ni">// Calculate the square root of a given value<br/>// This logs 4<br/>console.log(Math.sqrt(16));</span><span id="4168" class="ne lt iq na b gy nm ng l nh ni">// Calculate a given value to the power of another<br/>// e.g. 6 to the power of 8, or 6 * 6 * 6 * 6 * 6 * 6 * 6 * 6<br/>// This logs 1679616<br/>console.log(Math.pow(6, 8));</span><span id="ce27" class="ne lt iq na b gy nm ng l nh ni">// Round a given value to the nearest integer<br/>// This logs 8<br/>console.log(Math.round(7.6));</span><span id="6bac" class="ne lt iq na b gy nm ng l nh ni">// This logs 7<br/>console.log(Math.round(7.3));</span><span id="5e39" class="ne lt iq na b gy nm ng l nh ni">// Round a given value up to the nearest integer<br/>// This logs 8<br/>console.log(Math.ceil(7.3));</span><span id="445a" class="ne lt iq na b gy nm ng l nh ni">// Round a given value down to the nearest integer<br/>// This logs 7<br/>console.log(Math.floor(7.6));</span><span id="97f6" class="ne lt iq na b gy nm ng l nh ni">// Generate a random float between 0 and 1<br/>console.log(Math.random());</span><span id="37e4" class="ne lt iq na b gy nm ng l nh ni">// Get the highest value in a given sequence<br/>// This logs 7<br/>console.log(Math.max(5,2,6,7,5,3));</span><span id="d8de" class="ne lt iq na b gy nm ng l nh ni">// Get the lowest value in a given sequence<br/>// This logs 2<br/>console.log(Math.min(5,2,6,7,5,3));</span></pre><p id="d80e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nj nk nl na b">Math</code>对象也有几个常量供我们使用，就像之前一样，我会快速列出它们，但不会涉及太多细节。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="62f3" class="ne lt iq na b gy nf ng l nh ni">// This logs PI<br/>console.log(Math.PI);</span><span id="4c6e" class="ne lt iq na b gy nm ng l nh ni">// This logs E (Eulers number)<br/>console.log(Math.E);</span><span id="d9f9" class="ne lt iq na b gy nm ng l nh ni">// This logs the natural logarithm of 2<br/>console.log(Math.LN2);</span><span id="7bdc" class="ne lt iq na b gy nm ng l nh ni">// This logs the natural logarithm of 10<br/>console.log(Math.LN10)</span><span id="f2da" class="ne lt iq na b gy nm ng l nh ni">// This logs the base 2 logarithm of E<br/>console.log(Math.LOG2E);</span><span id="e99d" class="ne lt iq na b gy nm ng l nh ni">// This logs the base 10 logarithm of E<br/>console.log(Math.LOG10E);</span><span id="3301" class="ne lt iq na b gy nm ng l nh ni">// This logs the square root of 2<br/>console.log(Math.SQRT2);</span><span id="2cc4" class="ne lt iq na b gy nm ng l nh ni">// This logs the square root of 0.5<br/>console.log(Math.SQRT1_2);</span></pre><p id="2e7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，你现在知道如何用Javascript做数学了。接下来，我们将看看条件和比较。</p><h1 id="b243" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">条件和比较</h1><p id="295e" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在Javascript中，我们有两种方法进行比较，即<code class="fe nj nk nl na b">if</code>和<code class="fe nj nk nl na b">switch</code>语句。让我们从<code class="fe nj nk nl na b">if</code>的声明开始，这是这样写的:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="64f9" class="ne lt iq na b gy nf ng l nh ni">if (condition) {<br/>  code to be executed if the condition is true<br/>} else {<br/>  code to be executed if the condition is false<br/>}</span></pre><p id="440f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一条<code class="fe nj nk nl na b">if</code>语句可以有多个<code class="fe nj nk nl na b">if</code>条件，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="df1c" class="ne lt iq na b gy nf ng l nh ni">if (condition) {</span><span id="1ef0" class="ne lt iq na b gy nm ng l nh ni">} else if (condition) {</span><span id="cf88" class="ne lt iq na b gy nm ng l nh ni">} else if (condition) {</span><span id="1695" class="ne lt iq na b gy nm ng l nh ni">} else {</span><span id="4677" class="ne lt iq na b gy nm ng l nh ni">}</span></pre><p id="2b84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道了如何写一个<code class="fe nj nk nl na b">if</code>语句，让我们看看我们是如何写条件的。在Javascript中我们有9个比较操作符，让我们一个接一个地看看。</p><p id="2976" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们有等于运算符:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1ac0" class="ne lt iq na b gy nf ng l nh ni">// This logs true because 3 does equal 3<br/>console.log((3 == 3));</span><span id="033a" class="ne lt iq na b gy nm ng l nh ni">// This logs false because 3 does not equal 4<br/>console.log((3 == 4));</span><span id="6b30" class="ne lt iq na b gy nm ng l nh ni">// This logs true because 3 does equal '3'<br/>console.log((3 == '3'));</span><span id="4d17" class="ne lt iq na b gy nm ng l nh ni">// this logs true because "1" does equal true<br/>console.log(("1" == true));</span></pre><p id="2568" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前两个条件有道理，但为什么后两个也通？这是因为equals运算符不关心数据类型，对它来说，字符串<code class="fe nj nk nl na b">"1"</code>与数字<code class="fe nj nk nl na b">1</code>相同，数字<code class="fe nj nk nl na b">1</code>也与<code class="fe nj nk nl na b">true</code>相同。如果我们希望数据类型很重要，那么我们可以使用<code class="fe nj nk nl na b">===</code>而不是<code class="fe nj nk nl na b">==</code>，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="efe1" class="ne lt iq na b gy nf ng l nh ni">// This logs true<br/>console.log(("1" == true));</span><span id="e6d0" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log(("1" === true));</span><span id="9111" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log((1 === true));</span><span id="fa3b" class="ne lt iq na b gy nm ng l nh ni">// This logs true<br/>console.log((true === true));</span></pre><p id="3b09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们有不等于运算符:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d3d8" class="ne lt iq na b gy nf ng l nh ni">// This logs true<br/>console.log((1 != 2));</span><span id="7650" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log(("1" != 1));</span><span id="da05" class="ne lt iq na b gy nm ng l nh ni">// This logs true<br/>console.log(("1" !== 1));</span></pre><p id="42df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，您可以看到我们还可以向不等于运算符添加一个额外的<code class="fe nj nk nl na b">=</code>,这样我们的数据类型就很重要。</p><p id="cf10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们有小于、大于、小于或等于和大于或等于运算符。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1b45" class="ne lt iq na b gy nf ng l nh ni">// This logs true<br/>console.log((10 &gt; 5));</span><span id="f003" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log((10 &lt; 5));</span><span id="3441" class="ne lt iq na b gy nm ng l nh ni">// This logs true<br/>console.log((5 &gt;= 5));</span><span id="89ea" class="ne lt iq na b gy nm ng l nh ni">// This logs false<br/>console.log((6 &lt;= 5));</span></pre><p id="cd6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们有not运算符，我们用它来检查布尔值是真还是假，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d812" class="ne lt iq na b gy nf ng l nh ni">let exists = false;</span><span id="c87a" class="ne lt iq na b gy nm ng l nh ni">// This logs true because exists does equal false<br/>console.log((!exists));</span><span id="1288" class="ne lt iq na b gy nm ng l nh ni">exists = true;</span><span id="8a72" class="ne lt iq na b gy nm ng l nh ni">// This logs false because exists doe not equal false<br/>console.log((!exists));</span></pre><p id="8e8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是所有9个比较操作符，现在让我们在一个<code class="fe nj nk nl na b">if</code>语句中使用它们。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c582" class="ne lt iq na b gy nf ng l nh ni">let exists = false;</span><span id="2f12" class="ne lt iq na b gy nm ng l nh ni">if (!exists) {<br/>  // Condition passed<br/>} else {<br/>  // Condition failed<br/>}</span></pre><p id="5097" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以在我们的条件中添加多个比较，如果两个比较都为真或者其中一个为真，我们的条件就可以通过。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ba72" class="ne lt iq na b gy nf ng l nh ni">let exists = false;<br/>let number = 5;</span><span id="9c54" class="ne lt iq na b gy nm ng l nh ni">if (exists &amp;&amp; number === 5) {<br/>  // This will not be executed<br/>} else {<br/>  // This will be executed because neither of our comparisons passed<br/>}</span><span id="325b" class="ne lt iq na b gy nm ng l nh ni">if (exists || number === 5) {<br/> // This will be executed because our number does equal 5<br/>} else {<br/>  // This will not be executed<br/>}</span></pre><p id="486f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你甚至可以在条件中包含条件，例如，如果一个数字在0到10之间或者在20到30之间，我们想做一些事情。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3354" class="ne lt iq na b gy nf ng l nh ni">let number = 9;</span><span id="5051" class="ne lt iq na b gy nm ng l nh ni">if ((number &gt; 0 &amp;&amp; number &lt; 10) || (number &gt; 20 &amp;&amp; number &lt; 30)) {<br/>  // This will execute because 9 is between 0 and 10<br/>}</span><span id="b770" class="ne lt iq na b gy nm ng l nh ni">number = 23</span><span id="fdd9" class="ne lt iq na b gy nm ng l nh ni">if ((number &gt; 0 &amp;&amp; number &lt; 10) || (number &gt; 20 &amp;&amp; number &lt; 30)) {<br/>  // This will execute because 23 is between 20 and 30<br/>}</span><span id="3838" class="ne lt iq na b gy nm ng l nh ni">number = 15</span><span id="a999" class="ne lt iq na b gy nm ng l nh ni">if ((number &gt; 0 &amp;&amp; number &lt; 10) || (number &gt; 20 &amp;&amp; number &lt; 30)) {<br/>  // This will not execute because 15 isn't between 0 and 10 or 20 and 20<br/>}</span></pre><p id="f8ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以看到这很混乱，这是一个你可能想要使用<code class="fe nj nk nl na b">else if</code>的例子，例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bac0" class="ne lt iq na b gy nf ng l nh ni">let number = 23;</span><span id="6138" class="ne lt iq na b gy nm ng l nh ni">if (number &gt; 0 &amp;&amp; number &lt; 10) {<br/>  // This will not execute<br/>} else if (number &gt; 20 &amp;&amp; number &lt; 30) {<br/>  // This will execute<br/>} else {<br/>  // This will not execute<br/>}</span></pre><p id="3da6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在使用<code class="fe nj nk nl na b">else if</code>代码更容易阅读和理解。</p><p id="bf86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在你应该对<code class="fe nj nk nl na b">if</code>语句有了很好的理解，让我们来看看<code class="fe nj nk nl na b">switch</code>语句。<code class="fe nj nk nl na b">switch</code>语句将一个值与一系列不同的案例进行比较，如果没有一个案例匹配，则执行默认案例。例如，假设我们要将一个数字转换成星期几。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e706" class="ne lt iq na b gy nf ng l nh ni">let day = 5;</span><span id="a66d" class="ne lt iq na b gy nm ng l nh ni">switch(day) {</span><span id="ecf0" class="ne lt iq na b gy nm ng l nh ni">  case 1:<br/>    console.log("Monday");<br/>    break;</span><span id="6122" class="ne lt iq na b gy nm ng l nh ni">  case 2:<br/>    console.log("Tuesday");<br/>    break;</span><span id="1fb8" class="ne lt iq na b gy nm ng l nh ni">  case 3:<br/>    console.log("Wednesday");<br/>    break;</span><span id="eaad" class="ne lt iq na b gy nm ng l nh ni">  case 4:<br/>    console.log("Thursday");<br/>    break;</span><span id="0547" class="ne lt iq na b gy nm ng l nh ni">  case 5:<br/>    console.log("Friday");<br/>    break;</span><span id="e3eb" class="ne lt iq na b gy nm ng l nh ni">  case 6:<br/>    console.log("Saturday");<br/>    break;</span><span id="85ce" class="ne lt iq na b gy nm ng l nh ni">  case 7:<br/>    console.log("Sunday");<br/>    break;</span><span id="5dd0" class="ne lt iq na b gy nm ng l nh ni">  default:<br/>    console.log("Invalid Day");</span><span id="3c03" class="ne lt iq na b gy nm ng l nh ni">};</span></pre><p id="1afe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，<code class="fe nj nk nl na b">"Friday"</code>将被记录，如果我们将日期变量改为<code class="fe nj nk nl na b">12</code>，那么<code class="fe nj nk nl na b">"Invalid Day"</code>将被记录。您会注意到，在每个日志之后，我们都编写了<code class="fe nj nk nl na b">break</code>关键字，这样一旦案例与<code class="fe nj nk nl na b">switch</code>语句匹配，就会退出。</p><p id="911c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，使用<code class="fe nj nk nl na b">switch</code>语句，我们可以让多个案例运行相同的代码。假设我们想知道我们的一天是工作日还是周末。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="75cb" class="ne lt iq na b gy nf ng l nh ni">let day = 5;</span><span id="ce77" class="ne lt iq na b gy nm ng l nh ni">switch(day) {</span><span id="63ff" class="ne lt iq na b gy nm ng l nh ni">  case 1:<br/>  case 2:<br/>  case 3:<br/>  case 4:<br/>  case 5:<br/>    console.log("Weekday");<br/>    break;<br/>  case 6:<br/>  case 7:<br/>    console.log("Weekend");<br/>    break;</span><span id="caa4" class="ne lt iq na b gy nm ng l nh ni">  default:<br/>    console.log("Invalid Day");</span><span id="4745" class="ne lt iq na b gy nm ng l nh ni">};</span></pre><p id="f6eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们将看到如果<code class="fe nj nk nl na b">day</code>等于1、2、3、4或5，则记录<code class="fe nj nk nl na b">"Weekday"</code>，如果<code class="fe nj nk nl na b">day</code>等于6或7，则记录<code class="fe nj nk nl na b">"Weekend"</code>。关于条件和比较，这就是你所需要知道的，我们现在来看看循环。</p><h1 id="5be7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">环</h1><p id="b6ff" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们已经非常详细地介绍了循环，我们已经查看了<code class="fe nj nk nl na b">for</code>、<code class="fe nj nk nl na b">forEach</code>和<code class="fe nj nk nl na b">map</code>。我们还有两个循环要看，这是<code class="fe nj nk nl na b">while</code>和<code class="fe nj nk nl na b">do while</code>循环。</p><p id="9904" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，<code class="fe nj nk nl na b">while</code>循环运行，直到满足一个条件。例如，假设我们想要运行循环，直到一个数等于10。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="abfc" class="ne lt iq na b gy nf ng l nh ni">let fingers = 1;</span><span id="0567" class="ne lt iq na b gy nm ng l nh ni">while (fingers &lt; 11) {<br/>  console.log(fingers);<br/>  fingers++;<br/>}</span></pre><p id="e846" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们的循环运行了10次，每次都给<code class="fe nj nk nl na b">finger</code>加1。你必须小心使用<code class="fe nj nk nl na b">while</code>和<code class="fe nj nk nl na b">do while</code>循环，因为如果你的条件从未被满足，那么你将会以一个无限循环结束，这将会使你的脚本崩溃。</p><p id="d4f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nj nk nl na b">do while</code>循环的工作方式与while循环类似，只是它们执行一次块，而不管条件是否满足。例如:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6706" class="ne lt iq na b gy nf ng l nh ni">let fingers = 1;</span><span id="5b42" class="ne lt iq na b gy nm ng l nh ni">while (fingers &lt; 1) {<br/>  console.log(`Fingers: ${fingers}`);<br/>  fingers++;<br/>}</span><span id="339d" class="ne lt iq na b gy nm ng l nh ni">let toes = 1;</span><span id="014a" class="ne lt iq na b gy nm ng l nh ni">do {<br/>  console.log(`Toes: ${toes}`);<br/>  toes++;<br/>} while (toes &lt; 1);</span></pre><p id="9514" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您运行这段代码，您会看到我们没有从fingers循环中获得日志，而从toes循环中获得了一个日志。这是因为即使1不小于1，<code class="fe nj nk nl na b">do while</code>循环已经执行了一次该块。</p><h1 id="af96" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">错误</h1><p id="4ef4" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在Javascript中，错误可能非常令人困惑，很难理解到底哪里出错了。例如，如果您运行以下命令:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7ba4" class="ne lt iq na b gy nf ng l nh ni">let date = Date().parse();</span></pre><p id="0181" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将得到一个错误，内容如下:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="b301" class="ne lt iq na b gy nf ng l nh ni">error: TypeError: Date().parse is not a function. (In 'Date().parse()', 'Date().parse' is undefined)</span></pre><p id="1588" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这实际上是比较容易破译的错误之一，它基本上只是说在<code class="fe nj nk nl na b">Date()</code>中没有名为<code class="fe nj nk nl na b">parse</code>的函数。这里的主要问题是这会使你的脚本崩溃，这一行可能只是你脚本的一小部分，所以让整个脚本崩溃是不理想的。我们可以做的是将这一行放在一个<code class="fe nj nk nl na b">try catch</code>块中，这样脚本就不会崩溃，它可以继续做它应该做的一切。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3dcc" class="ne lt iq na b gy nf ng l nh ni">try {<br/>  let date = Date().parse();<br/>} catch(err) {<br/>  console.log('Error message');<br/>}</span></pre><p id="ba3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果您运行这个脚本，它不会崩溃，并且会显示一条错误消息。这可能仍然是你想要的，如果你的代码依赖于这一行，那么你可能希望脚本退出。要强制脚本退出，我们可以使用<code class="fe nj nk nl na b">throw</code>关键字。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9db4" class="ne lt iq na b gy nf ng l nh ni">try {<br/>  let date = Date().parse();<br/>} catch(err) {<br/>  console.log('Error message');<br/>  throw err;<br/>}</span></pre><p id="41a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的错误消息将被记录，然后脚本将退出并记录详细的错误。这个方法允许你在退出脚本之前向用户显示一个用户友好的错误信息，这比仅仅显示原始的Javascript错误更加用户友好。</p><p id="da40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调试Javascript时，你会遇到6种错误类型，让我们来看一看，这样你就能理解它们的意思了。</p><p id="b307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">语法错误</strong></p><p id="cb0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是罐头上写的，你的语法有错误。</p><p id="1ee3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">参考错误</strong></p><p id="1a41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着发生了非法引用，例如，从变量的作用域之外访问变量。</p><p id="0ac0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">类型错误</strong></p><p id="6319" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着您正在做一些您不应该用特定数据类型做的事情。例如，如果你试图在一个对象上调用<code class="fe nj nk nl na b">forEach</code>，这会给你一个类型错误，因为<code class="fe nj nk nl na b">forEach</code>对对象来说不是一个有效的方法。</p><p id="4e08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">范围错误</strong></p><p id="8a03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着数字超出了有效范围。例如，如果您试图使用<code class="fe nj nk nl na b">toPrecision</code>方法给出一个30位小数的浮点数，这会给你一个RangeError，因为<code class="fe nj nk nl na b">toPrecision</code>只允许数字最多有21位小数。</p><p id="2cd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> URIError </strong></p><p id="9ac7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着在一个URI处理函数中发生了错误，这是由畸形的URI引起的。</p><p id="e800" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> EvalError </strong></p><p id="7ddb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，这意味着在<code class="fe nj nk nl na b">eval</code>功能中出现了错误。EvalError不是您真正需要担心的问题，因为较新版本的Javascript会抛出SyntaxErrors而不是EvalErrors。</p><p id="966b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经知道了更多关于错误和如何处理它们的知识，让我们继续学习类。</p><h1 id="f2b4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">班级</h1><p id="fa45" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">类类似于对象，但更高级。我将编写一个类，然后我们将一点一点地学习它。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="b567" class="ne lt iq na b gy nf ng l nh ni">class ScoreBoard {</span><span id="2f24" class="ne lt iq na b gy nm ng l nh ni">  constructor(...players) {</span><span id="462d" class="ne lt iq na b gy nm ng l nh ni">    this.players = [];<br/>    players.forEach((player) =&gt; {</span><span id="5401" class="ne lt iq na b gy nm ng l nh ni">      this.players.push({<br/>        name: player,<br/>        score: 0<br/>      });</span><span id="540f" class="ne lt iq na b gy nm ng l nh ni">    });</span><span id="1fea" class="ne lt iq na b gy nm ng l nh ni">  }</span><span id="ef56" class="ne lt iq na b gy nm ng l nh ni">  displayScores() {</span><span id="9481" class="ne lt iq na b gy nm ng l nh ni">    this.players.forEach((player) =&gt; {<br/>      console.log(`${player.name}: ${player.score}`);<br/>    });</span><span id="996d" class="ne lt iq na b gy nm ng l nh ni">  }</span><span id="bd63" class="ne lt iq na b gy nm ng l nh ni">  updateScore(playerName) {</span><span id="98c8" class="ne lt iq na b gy nm ng l nh ni">    this.players.map((player) =&gt; {</span><span id="1c5b" class="ne lt iq na b gy nm ng l nh ni">      if (player.name === playerName) {<br/>        player.score++;<br/>      }</span><span id="e48c" class="ne lt iq na b gy nm ng l nh ni">      return player;</span><span id="4438" class="ne lt iq na b gy nm ng l nh ni">    });</span><span id="b05f" class="ne lt iq na b gy nm ng l nh ni">  }</span><span id="3eb8" class="ne lt iq na b gy nm ng l nh ni">}</span><span id="f3fa" class="ne lt iq na b gy nm ng l nh ni">let scoreboard = new ScoreBoard("John", "Lucy", "Steve");</span><span id="0cf8" class="ne lt iq na b gy nm ng l nh ni">scoreboard.updateScore("Lucy");<br/>scoreboard.updateScore("John");<br/>scoreboard.updateScore("Steve");<br/>scoreboard.updateScore("Steve");<br/>scoreboard.updateScore("Steve");<br/>scoreboard.updateScore("Lucy");<br/>scoreboard.updateScore("John");<br/>scoreboard.updateScore("Lucy");</span><span id="4523" class="ne lt iq na b gy nm ng l nh ni">scoreboard.displayScores();</span></pre><p id="0681" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们写了一个处理简单游戏得分的类。首先，我们有<code class="fe nj nk nl na b">constructor</code>，这是一个每当类的新实例被创建时都会被调用的函数。在我们的<code class="fe nj nk nl na b">constructor</code>中，我们将所有的玩家添加到一个数组中，并给他们一个零的初始分数。接下来，我们有一个显示分数的函数，它所做的就是遍历玩家并记录分数。最后，我们有一个更新特定玩家分数的函数，为此我们使用<code class="fe nj nk nl na b">map</code>来遍历所有玩家。如果玩家的名字与我们传入的名字相同，那么分数就会更新。</p><p id="e403" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个类下面，我们创建了这个类的一个新实例，并将其存储在一个名为<code class="fe nj nk nl na b">scoreboard</code>的变量中，然后我们给玩家添加一些分数，最后显示这些分数。希望这个例子显示了类对于模块化你的代码是多么的有用。我认为对你来说，学习更多关于类和它们如何工作的最好方法是利用我在上面写的东西，试着给它增加更多的功能。</p><h1 id="c035" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">异步编程</h1><p id="9b9b" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">假设我们想执行一个函数，但是我们不知道这个函数要执行多长时间，我们如何得到这个函数的返回值呢？我们过去使用所谓的回调，这些函数被传递给另一个函数，然后在完成时被调用。回调有点像噩梦，事情很快变得非常混乱。现在我们有了处理异步任务的更好方法，让我们从承诺开始。</p><p id="7b07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个返回承诺的函数。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9c16" class="ne lt iq na b gy nf ng l nh ni">function exists(value) {<br/>  <br/>  return new Promise((resolve, reject) =&gt; {<br/>    <br/>    setTimeout(() =&gt; {<br/>      <br/>      if (value) {<br/>        resolve('Value is true');<br/>      } else {<br/>        reject('Value is false')<br/>      }<br/>      <br/>    }, 2000);<br/>    <br/>  });<br/>  <br/>}</span><span id="765d" class="ne lt iq na b gy nm ng l nh ni">exists(true).then((response) =&gt; {<br/>  console.log(response);<br/>}).catch((err) =&gt; {<br/>  console.log(err);<br/>});</span></pre><p id="0b07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们的函数<code class="fe nj nk nl na b">exists</code>返回一个承诺，这个承诺根据我们传递给它的值决定是接受还是拒绝。如果我们传入true，那么承诺解决，换句话说，一切顺利，如果我们传入false，那么承诺拒绝，换句话说，这意味着错误。当我们调用我们的函数时，我们有两个其他的函数链接到它，<code class="fe nj nk nl na b">then</code>和<code class="fe nj nk nl na b">catch</code>。如果承诺成功，将调用<code class="fe nj nk nl na b">then</code>函数，如果承诺被拒绝，将调用<code class="fe nj nk nl na b">catch</code>函数。如果您运行这段代码，您会看到我们的日志直到两秒钟后才出现，这是因为我们使用了<code class="fe nj nk nl na b">setTimeout</code>来模拟发生的事情。如果您在函数中有一个网络请求，那么在请求完成之前，日志不会出现。</p><p id="7d65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以连锁承诺，例如，让我们再次呼唤存在。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3723" class="ne lt iq na b gy nf ng l nh ni">function exists(value) {<br/>  <br/>  return new Promise((resolve, reject) =&gt; {<br/>    <br/>    setTimeout(() =&gt; {<br/>      <br/>      if (value) {<br/>        resolve('Value is true');<br/>      } else {<br/>        reject('Value is false')<br/>      }<br/>      <br/>    }, 2000);<br/>    <br/>  });<br/>  <br/>}<br/>exists(true).then((response) =&gt; {<br/>  console.log(response);<br/>  return exists(true);<br/>}).then((response) =&gt; {<br/>  console.log(response);<br/>}).catch((err) =&gt; {<br/>  console.log(err);<br/>});</span></pre><p id="fbfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们运行这段代码，我们将在两秒钟后看到日志<code class="fe nj nk nl na b">"Value is true"</code>，然后两秒钟后我们将看到另一个日志说同样的话。</p><p id="cf09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">起初，承诺可能会令人迷惑，我知道我花了一段时间才理解它们，但是你用得越多，你就越能理解它们。你也可能看到链接多个承诺会变得非常混乱，我们实际上有一个更简单的方法来处理这个问题，那就是异步等待。</p><p id="eac7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用async-await，我们能够定义异步函数，这些函数可以等待来自其他异步函数的响应。例如，让我们用async-await写同样的东西。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7e09" class="ne lt iq na b gy nf ng l nh ni">function exists(value) {<br/>  <br/>  return new Promise((resolve, reject) =&gt; {<br/>    <br/>    setTimeout(() =&gt; {<br/>      <br/>      if (value) {<br/>        resolve('Value is true');<br/>      } else {<br/>        reject('Value is false')<br/>      }<br/>      <br/>    }, 2000);<br/>    <br/>  });<br/>  <br/>}</span><span id="95b8" class="ne lt iq na b gy nm ng l nh ni">async function getExists() {<br/>  <br/>  let firstResponse = await exists(true);<br/>  console.log(firstResponse);<br/>  <br/>  let secondResponse = await exists(true);<br/>  console.log(secondResponse);<br/>  <br/>}</span><span id="4328" class="ne lt iq na b gy nm ng l nh ni">getExists();</span></pre><p id="7214" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们仍然得到我们的两个日志，但是这段代码更加清晰易读。这里我们唯一没有的是捕捉任何错误的能力，让我们把它加进去。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9724" class="ne lt iq na b gy nf ng l nh ni">function exists(value) {<br/>  <br/>  return new Promise((resolve, reject) =&gt; {<br/>    <br/>    setTimeout(() =&gt; {<br/>      <br/>      if (value) {<br/>        resolve('Value is true');<br/>      } else {<br/>        reject('Value is false')<br/>      }<br/>      <br/>    }, 2000);<br/>    <br/>  });<br/>  <br/>}</span><span id="63c3" class="ne lt iq na b gy nm ng l nh ni">async function getExists() {<br/>  <br/>  let firstResponse = await exists(true);<br/>  console.log(firstResponse);<br/>  <br/>  let secondResponse = await exists(true);<br/>  console.log(secondResponse);<br/>  <br/>  let errorResponse = await exists(false);<br/>  <br/>}</span><span id="57f4" class="ne lt iq na b gy nm ng l nh ni">getExists().catch((err) =&gt; {<br/>  console.log(err);<br/>});</span></pre><p id="6da8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在已经用false添加了对<code class="fe nj nk nl na b">exists()</code>的调用，以便承诺被拒绝，我们还在调用<code class="fe nj nk nl na b">getExists</code>函数时添加了<code class="fe nj nk nl na b">catch()</code>。在这里添加<code class="fe nj nk nl na b">catch</code>将捕获<code class="fe nj nk nl na b">getExists</code>函数中的每个错误，这很好，因为我们所有的错误都集中在一个地方。</p><p id="fecc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想我会把异步编程留到这里，现在你应该对承诺和异步等待有了一个基本的了解。现在最好的办法是练习使用它们，这很可能会比阅读更多细节更快地帮助你掌握它们。</p><h1 id="a94a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="7113" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">如果我没有做错，那么您现在应该对Javascript基础有了很好的理解。像任何新技能一样，熟能生巧，你写的Javascript越多，你就会变得越好，越博学。如果你有任何问题，请提出来，我会尽我所能回答。</p><p id="bbe5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae ld" href="https://medium.com/@willptswan/a-complete-beginners-guide-to-javascript-part-2-501ec89af76c" rel="noopener">的下一个故事</a>中，我们将看看如何使用DOM以及如何使用Ajax异步发出网络请求。</p><p id="cb58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二部分:<a class="ae ld" href="https://medium.com/@willptswan/a-complete-beginners-guide-to-javascript-part-2-501ec89af76c" rel="noopener">https://medium . com/@ willptswan/a-complete-初学者-javascript指南-part-2-501ec89af76c </a></p></div></div>    
</body>
</html>