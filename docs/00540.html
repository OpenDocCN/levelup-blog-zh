<html>
<head>
<title>Anti-patterns to avoid when building a component library in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React Native中构建组件库时要避免的反模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/anti-patterns-to-avoid-when-building-a-component-library-in-react-native-61f11d8c9797?source=collection_archive---------2-----------------------#2019-04-16">https://levelup.gitconnected.com/anti-patterns-to-avoid-when-building-a-component-library-in-react-native-61f11d8c9797?source=collection_archive---------2-----------------------#2019-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b9927871f89f27c1c7accd9e57ac812a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m8VMLKs-jIIAOKzj"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@marcello54?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马塞罗·根纳里</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><div class=""/><p id="e167" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近，我帮助一个客户将他们的电子商务前端从原生包装应用程序迁移到React Native。</p><p id="b23d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于团队的很大一部分人以前没有任何使用React的经验，我们在开始时遇到许多不一致的地方是很自然的。我的工作是帮助解决这些问题，并为更易维护的代码库打下基础。</p><p id="6cb4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">挑战之一是理解和组织UI层的构件。我很快意识到，当在React中与一个5人以上的团队一起工作时，最终得到一个庞大的、支离破碎的UI组件集合是很常见的。</p><p id="c35e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么我们合作的最初努力之一是为UI库建立一些可理解、可维护、可扩展、可重用和可测试的准则。(我忘记什么了吗？)</p><p id="109a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的技术绝不是革命性的。大多数从事大型项目的团队很可能熟悉可重用组件、解耦和通用主题的概念。如果是这样的话，你可以直接进入这篇文章最后的“ <a class="ae jg" href="#a8ee" rel="noopener ugc nofollow"> <strong class="ki jk">补充构建模块</strong> </a> <strong class="ki jk">”部分，或者干脆跳过它。</strong></p><p id="bc3a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们看一下我在探索未知领域并开始编写我们的第一个组件时发现的反模式。</p><h1 id="7c9b" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">反模式#1:降低组件的可重用性</h1><p id="9e48" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">任意给组件加前缀来赋予它们更多的含义，强调它们在什么样的上下文中被使用，或者简单地增加它们的特异性，这种情况太普遍了。</p><p id="ba90" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">典型的例子是当人们使用像<code class="fe mh mi mj mk b">LoginButton</code>、<code class="fe mh mi mj mk b">RegisterLink</code>或者更糟的是<code class="fe mh mi mj mk b">FilterHeaderRightMenuCloseButtonIcon</code>这样的组件名时。</p><p id="1355" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我想指出两种问题。</p><p id="b8c0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">首先是</strong>，在<code class="fe mh mi mj mk b">FilterHeaderRightMenuCloseButtonIcon</code>中任何你想在别处重用的样式定义现在都被锁在那里了:</p><ul class=""><li id="e37e" class="ml mm jj ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">试图从这个组件中导入它们会引入耦合，这是没有人会原谅你的</li><li id="a6ff" class="ml mm jj ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">重复它们会导致代码重复，这是他们在小学教你的不好的做法</li></ul><p id="c7e8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">其次</strong>，<strong class="ki jk"> </strong> <code class="fe mh mi mj mk b">FilterHeaderRightMenuCloseButtonIcon</code>比<em class="mz"/>告诉我更多关于它被使用的上下文。因为它的目的是显示一个<code class="fe mh mi mj mk b">Icon</code>，所以<code class="fe mh mi mj mk b">FilterHeaderRightMenuCloseButton</code>前缀可能是多余的。</p><p id="04c4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，像这样添加前缀和隔离组件在短期内会使您的工作更容易。您使用特定的名称编写组件，因此它不会与任何其他组件冲突，并且样式完全符合您的设计者指定的样式。完美的像素和零缺陷…谁不想要呢？🤷‍♂️</p><p id="2e25" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你的应用程序变得越来越大，结构、语义和命名变得越来越相关时，问题就出现了。</p><p id="3c56" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从我的经验来看，当其他人不得不阅读你的代码时，提示组件<em class="mz">做什么</em>(例如:ScrollContainer)而不是它出现在一个有许多节点的树中的什么地方(例如:InnerWrapper)可以产生很大的不同，并且将使你在将来免于经历许多令人头疼的重构。</p><p id="ab2d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">向揭示目的的可配置UI组件问好</strong></p><p id="bf7e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么我通常认为编写这样的组件更有价值</p><ul class=""><li id="9d08" class="ml mm jj ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">使用不太冗长的名字，例如用<code class="fe mh mi mj mk b">Icon</code>代替<code class="fe mh mi mj mk b">CloseButtonIcon</code></li><li id="cced" class="ml mm jj ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">根据其用途命名，例如<code class="fe mh mi mj mk b">ScrollContainer</code>与<code class="fe mh mi mj mk b">InnerWrapper</code></li><li id="404d" class="ml mm jj ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">可通过道具配置，如<code class="fe mh mi mj mk b">&lt;Icon type="close" /&gt;</code></li></ul><p id="b1a4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，在编写一个接受各种属性的组件:<code class="fe mh mi mj mk b">&lt;Button right big leftAlign underline smallText /&gt;</code>和简洁的组件做<em class="mz">刚好够用</em>之间有一条细线。🎯</p><h1 id="b822" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">反模式#2:交叉引用，解耦的敌人</h1><p id="3cf0" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我观察到的另一件事是当人们在不相关的文件和文件夹之间创建交叉引用时。</p><p id="4210" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当在一个连贯的实体中引用文件时，比如一个特定的屏幕或一个更复杂的组件，这是可以接受的，因为它们仍然是一个自包含的单元，其部分在其他任何地方都不适用。</p><p id="13e1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你从一个完全不相关的文件中引用代码的某个部分(比如一个样式定义或者一个子组件)时，就会变得很混乱。这种代码味道的一个很好的指示器👃当某人从一个文件夹中导入一个文件时，该文件夹只能在组件层次结构中向上跳几级时才能被访问。</p><pre class="na nb nc nd gt ne mk nf ng aw nh bi"><span id="2a2a" class="ni lf jj mk b gy nj nk l nl nm"><em class="mz">// icon.jsx</em><br/>import { <strong class="mk jk">letMeJustGrabThis</strong> } from "../../../../../../components/button"</span></pre><p id="498d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想即使你不是一流的程序员，你也会意识到这种耦合方式可能会变得有点难以维护😱：</p><ul class=""><li id="2b6e" class="ml mm jj ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">如果这些依赖中的任何一个消失了，你的也会跟着消失。</li><li id="57a2" class="ml mm jj ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">没有一个组件作为独立的实体是可测试的，因为你必须要么模仿导入的模块，要么盲目地依赖它的正确行为</li><li id="a882" class="ml mm jj ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">理解组件的认知负荷越来越大，随着时间的推移，重构变得更加困难</li></ul><p id="e1bd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">解耦(和单元测试)来拯救！</strong></p><p id="30c3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我们如何实现这一点呢？要确信您的组件是一个自包含的实体，它最好不要依赖于对任何其他组件的交叉引用。</p><p id="6064" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现单元测试对于揭示这些相互依赖关系非常有效。由于它要求您在完全隔离的情况下测试和配置您的组件，这迫使您重新思考和考虑它所带来的依赖性。让我们看一个简单的笑话。</p><pre class="na nb nc nd gt ne mk nf ng aw nh bi"><span id="e53f" class="ni lf jj mk b gy nj nk l nl nm">// component.test.jsx<br/>import { <strong class="mk jk">ComponentOne</strong> } from "../ComponentOne"</span><span id="4b47" class="ni lf jj mk b gy nn nk l nl nm">it("should behave in a certain way", () =&gt; {<br/>  const result = <strong class="mk jk">ComponentOne</strong>.doSomething();<br/>  expect(result).toBe("expectedResult");<br/>}</span></pre><p id="8817" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果这需要你模拟出<code class="fe mh mi mj mk b">ComponentOne</code>所依赖的其他几个组件，或者你必须把它变成一个可实例化的对象，并通过依赖注入传递几十个模块来使它工作，那么你的组件很可能与你正在编写的其他软件紧密耦合。</p><p id="558b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这本身并不是一件坏事，但是在你的应用程序变成一个不可管理的庞然大物之前，这是一件值得关注的事情。🦍</p><h1 id="09f2" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">反模式#3:不一致</h1><p id="9023" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">通常情况下，人们最终会写出这样的东西，要么是出于无知，要么是纯粹的懒惰。</p><pre class="na nb nc nd gt ne mk nf ng aw nh bi"><span id="0eb8" class="ni lf jj mk b gy nj nk l nl nm"><em class="mz">// </em>👨‍💻 <em class="mz">writes screenOne/componentOne.jsx</em><br/>const <strong class="mk jk">ComponentOne</strong> = props =&gt; &lt;a style={{ padding: <strong class="mk jk">12</strong>, ... }} /&gt;</span><span id="cb5c" class="ni lf jj mk b gy nn nk l nl nm">// 👩🏻‍💻 <em class="mz">writes screenTwo/componentTwo.jsx<br/></em>const <strong class="mk jk">ComponentTwo </strong>= props =&gt; &lt;a style={{ padding: <strong class="mk jk">12</strong>, ... }} /&gt;</span></pre><p id="076f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于web来说，这个问题在前置处理器时代相当普遍，那时变量在CSS中并不存在。感谢像SASS和LESS这样的工具，我们从一遍又一遍地重复相同的样式定义的痛苦中解脱出来，并且能够从全局主题中获取公共参数。</p><p id="862a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，使用React，我们似乎需要重新学习其中的一些技术，因为我们现在考虑的是<em class="mz">组件</em>。因此，我们的风格定义经常分散在许多独立的单元中。与我们编写样式表和使用类来共享诸如间距、字体大小、颜色等可重用属性相比，这使得重复我们自己变得容易多了...</p><p id="0df6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特别是当团队中有很多人一起工作时，很容易忽略其他人已经编写的样式定义，并最终重复那些应该在组件间共享的值。</p><p id="3f1f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，这是一个错过的机会，不仅可以为自己节省一些工作，还可以为你的设计带来一些一致性<strong class="ki jk">。谁不喜欢一套适用于整个应用程序的通用间距、字体和颜色定义？<em class="mz">🎨</em></strong></p><p id="e8f9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在React中，这些通常会放入一个共享的<code class="fe mh mi mj mk b">theme</code>文件夹中，该文件夹位于应用程序的根目录下，每个组件都可以从该文件夹中导入。</p><pre class="na nb nc nd gt ne mk nf ng aw nh bi"><span id="f18e" class="ni lf jj mk b gy nj nk l nl nm"><em class="mz">/theme/index.js</em><br/>export const <strong class="mk jk">spacing</strong> = 12</span></pre><p id="291e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，您的组件可以按如下方式使用它们:</p><pre class="na nb nc nd gt ne mk nf ng aw nh bi"><span id="36fe" class="ni lf jj mk b gy nj nk l nl nm"><em class="mz">/screenOne/componentOne &amp;&amp; /screenTwo/componentTwo<br/></em>import { <strong class="mk jk">spacing </strong>} from '~/theme'</span><span id="e3df" class="ni lf jj mk b gy nn nk l nl nm">const Container = props =&gt; <br/>  &lt;a style={{ padding: <strong class="mk jk">spacing</strong>, ... }} /&gt;<br/>}</span></pre><blockquote class="no np nq"><p id="29f7" class="kg kh mz ki b kj kk kl km kn ko kp kq nr ks kt ku ns kw kx ky nt la lb lc ld im bi translated">如果你使用像<strong class="ki jk">风格组件</strong>这样的库，你可以考虑使用<a class="ae jg" href="https://www.styled-components.com/docs/advanced" rel="noopener ugc nofollow" target="_blank">主题提供者</a>，这使得那些普世价值在你的整个应用程序中可用。在这种情况下，您将所有的样式传递给更高一级的组件。</p></blockquote><p id="bff5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着你的主题变大，你可以考虑把它分成多个文件(例如，间距、版式、颜色等。):</p><pre class="na nb nc nd gt ne mk nf ng aw nh bi"><span id="f395" class="ni lf jj mk b gy nj nk l nl nm">/theme/spacing.js<br/>/theme/color.js<br/>/theme/typography.js</span></pre><p id="a8d8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…然后将它们全部从<code class="fe mh mi mj mk b">theme</code>文件夹的索引文件的根目录中导出:</p><pre class="na nb nc nd gt ne mk nf ng aw nh bi"><span id="26e6" class="ni lf jj mk b gy nj nk l nl nm"><strong class="mk jk"><em class="mz">// /theme/index.js</em></strong><br/>export * from "./color"<br/>export * from "./spacing"<br/>export * from "./typography"</span></pre><p id="2989" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，当使用<a class="ae jg" href="https://github.com/tleunen/babel-plugin-module-resolver" rel="noopener ugc nofollow" target="_blank">模块解析器</a>而不是一直写出那些长路径名时，导入它们要容易得多。</p><pre class="na nb nc nd gt ne mk nf ng aw nh bi"><span id="55d8" class="ni lf jj mk b gy nj nk l nl nm"><em class="mz">// this short form...</em><br/>import { <strong class="mk jk">spacing</strong> } from "~/theme"</span><span id="36a8" class="ni lf jj mk b gy nn nk l nl nm"><em class="mz">// looks much nicer than:</em><br/>import { <strong class="mk jk">spacing</strong> } from "../../../../../theme"</span></pre><h1 id="a8ee" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">互补的构建模块</h1><p id="179a" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果所有这些您都很熟悉，那么根据我的经验，还有一些额外的构件可以帮助您的团队变得更加一致，提高代码质量，并构建一个更加可重用的组件库:</p><ul class=""><li id="c816" class="ml mm jj ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><strong class="ki jk">风格指南</strong>:当你的应用程序设计有一个清晰且维护良好的风格指南作为后盾，详细描述每个组件时，开发人员将更容易识别可跨屏幕重用的组件，以及如何使它们可配置。<a class="ae jg" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank"> Storybook </a>可以帮助您进一步简化这个过程，并为React中维护良好且经过测试的组件库铺平道路。</li><li id="c2e0" class="ml mm jj ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><strong class="ki jk">评审过程</strong>:当人们互相评审代码时，发现违反上述原则的问题要容易得多。一个适当的拉请求过程(理想情况下每个特性至少有两个评审者)通常有助于消除大量的不一致和错误</li><li id="7446" class="ml mm jj ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><strong class="ki jk">持续集成</strong>:在大多数大型项目中，开发人员建立一个部署管道来帮助自动化重复的任务。如果你幸运地拥有一个持续的集成过程，你应该自动化诸如单元、集成和回归测试之类的事情，并可能包括一个像<a class="ae jg" href="https://codeclimate.com/" rel="noopener ugc nofollow" target="_blank"> Code Climate </a>这样的工具，它可以帮助自动识别你的代码库中的一些不一致或重复。</li></ul><p id="defe" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！希望你喜欢这篇文章。请随意分享你在构建可重用组件库方面的经验，或者如果这篇文章中有任何不清楚的地方，请提出问题。非常感谢你的阅读！</p></div></div>    
</body>
</html>