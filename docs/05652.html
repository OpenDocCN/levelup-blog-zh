<html>
<head>
<title>Back to Basics With Pointers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用指针回到基础</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/back-to-basics-with-pointers-58859c9c326b?source=collection_archive---------16-----------------------#2020-09-17">https://levelup.gitconnected.com/back-to-basics-with-pointers-58859c9c326b?source=collection_archive---------16-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="694d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">基础，编程</h2><div class=""/><div class=""><h2 id="b42a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">关于指针你需要知道的一切</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/37714b5ebddbd2584afc32b457c3ce46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qhttdpkc2CAEAGiT"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@aaker?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿克尔</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2a6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">指针是低级编程中需要理解的最重要的概念之一。我记得我试图不去想它。所以，我为初学者写了这篇文章。</p><blockquote class="me"><p id="67f6" class="mf mg it bd mh mi mj mk ml mm mn md dk translated">万事开头难——歌德。</p></blockquote><p id="6722" class="pw-post-body-paragraph li lj it lk b ll mo kd ln lo mp kg lq lr mq lt lu lv mr lx ly lz ms mb mc md im bi translated">所以让我们接受挑战，进入下一个阶段。</p><p id="9cc6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">文章概述— </strong></p><ul class=""><li id="a00a" class="mt mu it lk b ll lm lo lp lr mv lv mw lz mx md my mz na nb bi translated"><strong class="lk jd">挖入变量</strong></li><li id="b9ff" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated"><strong class="lk jd">现在让我们瞄准指针</strong></li><li id="335c" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated"><strong class="lk jd">为什么我们需要指针</strong></li><li id="a993" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated">让我们打破困惑</li><li id="34f7" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated"><strong class="lk jd">最终提示和要点</strong></li></ul></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="bf8b" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">挖掘变量</h1><p id="b559" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">每当我们创建一个变量时，我们必须给它分配一个<em class="ol">名称</em>、一个<em class="ol">数据类型</em>和一个<em class="ol">内存地址</em>。</p><p id="4054" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">名称</strong>用于调用或使用变量。一个<strong class="lk jd">数据</strong> <strong class="lk jd">类型</strong>定义了一个变量可以取什么样的值，ex — <code class="fe om on oo op b">int</code>用来存储整数，<code class="fe om on oo op b">char</code>用来存储字符。<strong class="lk jd">内存地址</strong>通常是变量的十六进制物理地址，它是变量在内存中的存储位置。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="a032" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">现在让我们瞄准指针</h1><p id="b142" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">指针是一个变量，用来存储另一个变量的内存地址。</p><p id="b96f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">指针存储变量的第一个字节的地址，因为我们知道变量的大小，其余的字节很容易计算。</p><h2 id="8e89" class="oq np it bd nq or os dn nu ot ou dp ny lr ov ow oa lv ox oy oc lz oz pa oe iz bi translated">在C #中声明指针</h2><p id="f50d" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">Astrix <code class="fe om on oo op b"><strong class="lk jd">*</strong></code>符号用于声明指针。宣言看起来像这样-</p><p id="f1c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe om on oo op b">int *p;</code>我们像这样声明变量— <code class="fe om on oo op b">int v;</code></p><p id="3f0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在可以说<code class="fe om on oo op b">p</code>是一个'<em class="ol">指向int '，</em>是因为类型<code class="fe om on oo op b">int</code> <em class="ol">。</em>它将存储整数变量的地址。</p><p id="7eab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有的指针都有相同的大小，因为它们只存储一个内存地址，这个地址对于机器来说是不变的。然而，不同的数据类型需要不同的指针声明。</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="c3f5" class="oq np it op b gy pf pg l ph pi">char * character;<br/>double * number;<br/>float * balance;</span></pre><p id="b4de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这只是宣言。现在他们不储存任何价值。为此，我们必须为它们提供另一个要存储的变量的地址。在C语言中,“与”符号<code class="fe om on oo op b">&amp;</code>又名“<em class="ol">地址——运算符“</em>”用于获取变量的地址。</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="2430" class="oq np it op b gy pf pg l ph pi">int a = 1000; // a stores the value 1000<br/>int *p = &amp;a; // p stores the memory address of a. NOT 1000</span><span id="da9a" class="oq np it op b gy pj pg l ph pi"><br/>// Another Way</span><span id="8ba1" class="oq np it op b gy pj pg l ph pi">int a = 1000;<br/>int *p;<br/>p = &amp;a; // Notice * is not used again. We only use it while declaring.</span></pre><h2 id="a355" class="oq np it bd nq or os dn nu ot ou dp ny lr ov ow oa lv ox oy oc lz oz pa oe iz bi translated">取消引用指针</h2><p id="8317" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">一旦指针被声明，下一步就是使用它。我们需要引用它所指向的值，称为指针的<strong class="lk jd"> <em class="ol">目标</em> </strong>。这被称为<strong class="lk jd"> <em class="ol">解引用指针。</em> </strong>为此，我们使用了Astrix符号<code class="fe om on oo op b">*</code>。</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="d98f" class="oq np it op b gy pf pg l ph pi">int * ptr;  // declaring a pointer to int<br/>int a = 6; // a stores the value 6<br/>ptr = &amp;a; // p stores the memory address of a. NOT 6<br/>printf("%d", *ptr); //prints 6. Astrix is used to dereference the pointer</span></pre><h2 id="e6f5" class="oq np it bd nq or os dn nu ot ou dp ny lr ov ow oa lv ox oy oc lz oz pa oe iz bi translated">空指针</h2><p id="9415" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">空指针是一种值为0的特殊指针。0是唯一可以赋给指针的整数值，任意值都会出错。空指针是一个占位符，可以在以后用来初始化指针。下面是如何设置空指针—</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="6ae3" class="oq np it op b gy pf pg l ph pi">int *p = 0; //Works fine<br/>int *z = 100; //Error<br/>int a = 420;</span><span id="83ee" class="oq np it op b gy pj pg l ph pi">p = &amp;a; //Works fine. Now P stores the address of a</span></pre></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="aa65" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">为什么我们需要指针</h1><p id="e31f" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">指针对于动态内存分配至关重要。指针提供了对变量的间接访问，这使得将变量传递给函数更加有效。</p><p id="6297" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们把一个变量传递给一个函数时，它会作为一个函数参数被再次复制。从；外；离；除；超过；以前的</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="a2ab" class="oq np it op b gy pf pg l ph pi">int a = 10;</span><span id="8268" class="oq np it op b gy pj pg l ph pi">int func(int b){<br/>//Some operation<br/>}</span><span id="aa3a" class="oq np it op b gy pj pg l ph pi">func(a);</span></pre><p id="d12e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，<code class="fe om on oo op b"><strong class="lk jd">a</strong></code>的值被复制到<code class="fe om on oo op b"><strong class="lk jd">b</strong></code> <strong class="lk jd"> <em class="ol">。</em> </strong>如果我们假设这个程序运行的是32位机器，<strong class="lk jd"> <em class="ol"> </em> </strong> <code class="fe om on oo op b"><strong class="lk jd">a</strong></code>将被分配4个字节，<code class="fe om on oo op b"><strong class="lk jd">b</strong></code> <strong class="lk jd"> <em class="ol"> </em> </strong>也将被分配4个字节。</p><p id="0bd6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，不存在任何问题，因为变量没有占用太多空间。但是如果我们对一个存储很多值的数组做同样的事情，我们可能会遇到障碍。</p><p id="df1f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">指点来了。指针使我们能够间接传递变量，因为变量的地址只有1个字节，所以效率更高。这是怎么做的-</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="be9b" class="oq np it op b gy pf pg l ph pi">int sum(int *a, int *b){<br/>    int ans = *a + *b;<br/>    return ans;<br/>}</span><span id="5219" class="oq np it op b gy pj pg l ph pi">void main(){<br/>int a = 100;<br/>int b = 200;<br/>printf("%d", sum(&amp;a,&amp;b));  //prints 300<br/>}</span></pre></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="bb4d" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">让我们打破困惑</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/6d4d1b5b3f4d444a9fd467bf755ce84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VZNuuCK8CeIi9-Bn"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@emilymorter?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾米丽·莫特</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="5730" class="oq np it bd nq or os dn nu ot ou dp ny lr ov ow oa lv ox oy oc lz oz pa oe iz bi translated">申报混乱</h2><ol class=""><li id="cf42" class="mt mu it lk b ll og lo oh lr pl lv pm lz pn md po mz na nb bi translated"><strong class="lk jd">三种方法</strong></li></ol><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="065c" class="oq np it op b gy pf pg l ph pi">int *p;<br/>int * p;<br/>int* p;</span></pre><p id="293b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">哪个是正确的？</p><p id="a211" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">他们都是正确的。不同的教科书/程序员使用不同的符号。</p><p id="c897" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.<strong class="lk jd">在同一条线上</strong></p><p id="9d2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当你试图在同一行中声明<strong class="lk jd"> <em class="ol">多个指针</em> </strong> <em class="ol">时，另一个混淆就出现了。这是声明变量的常见做法，下面是单行变量声明的样子-</em></p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="7efe" class="oq np it op b gy pf pg l ph pi">int a, b, c, d; // Works fine. All of them are variables of type int</span></pre><p id="25b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以我们可能认为这是正确的-</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="beec" class="oq np it op b gy pf pg l ph pi">int * x, y, z, g; // X is the pointer to int, but y, z, and g are variables of type int.</span></pre><p id="4e7c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但正确的做法是这样的-</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="4c9b" class="oq np it op b gy pf pg l ph pi">int *x, *y, *z, *g; // All of them are pointer to int</span></pre><p id="9752" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3.<strong class="lk jd">指向数组的指针</strong></p><p id="a2aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可能认为指向一个数组和指向任何其他变量是一样的。但事实并非如此。让我们看一看。</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="0795" class="oq np it op b gy pf pg l ph pi">// Pointer to int<br/>int a = 1000;     // variable of type int<br/>int *p;          // declaring a pointer to int<br/>p = &amp;a;         // initialing pointer, assigning value to it</span><span id="1b80" class="oq np it op b gy pj pg l ph pi">// Pointer to array </span><span id="a7b1" class="oq np it op b gy pj pg l ph pi">int* pta;<br/>int a[] = {1,2,3,4}; //Creating an array<br/>pta = a; //Notice we do not need '&amp;'</span></pre><p id="0306" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是因为<code class="fe om on oo op b"><strong class="lk jd">a</strong></code> <strong class="lk jd"> <em class="ol"> </em> </strong>本身就是指向数组第一个元素的指针。类似地，在处理string时不使用<code class="fe om on oo op b">&amp;</code>，因为string只是一个字符数组。</p><h2 id="977b" class="oq np it bd nq or os dn nu ot ou dp ny lr ov ow oa lv ox oy oc lz oz pa oe iz bi translated">解引用指针时的混乱和错误</h2><ol class=""><li id="1725" class="mt mu it lk b ll og lo oh lr pl lv pm lz pn md po mz na nb bi translated"><strong class="lk jd">与Astrix的混淆</strong></li></ol><p id="0f51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们声明一个指针时，我们使用<code class="fe om on oo op b"><strong class="lk jd">*</strong></code>,但是之后无论何时使用它，我们使用它<strong class="lk jd">只是为了解引用。</strong></p><blockquote class="me"><p id="c795" class="mf mg it bd mh mi mj mk ml mm mn md dk translated">如果您没有看到'<em class="pp"> int </em>'与<code class="fe om on oo op b">*</code>一起使用，那么指针是取消引用的。一直都是。</p></blockquote><p id="9333" class="pw-post-body-paragraph li lj it lk b ll mo kd ln lo mp kg lq lr mq lt lu lv mr lx ly lz ms mb mc md im bi translated">让我们看一个例子。假设a位于存储器中的位置8999。</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="28f6" class="oq np it op b gy pf pg l ph pi">int a = 100; //creating an integer variable<br/>int *p = &amp;a; // creating a pointer to int</span><span id="33a5" class="oq np it op b gy pj pg l ph pi">printf('%p',p); //prints 8999<br/>printf('%d',*p); // prints 100</span></pre><p id="6720" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.<strong class="lk jd">分段故障</strong></p><p id="8e81" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">指针的作用是引用<strong class="lk jd">内存空间</strong>中的某个地址，内存空间被分为<strong class="lk jd">段</strong>用于不同的操作。每个部分都有自己的目的，有些是<em class="ol">禁止的，</em>我们的程序不能访问。</p><p id="e229" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果一个指针指向一个极限内存位置，那么它将没有一个有效的目标。它会用一个<em class="ol">分段错误</em>错误使程序崩溃。</p><blockquote class="pq pr ps"><p id="5625" class="li lj ol lk b ll lm kd ln lo lp kg lq pt ls lt lu pu lw lx ly pv ma mb mc md im bi translated">当一个程序试图访问一个不允许它访问的内存位置，或者试图以一种不允许的方式访问一个内存位置时，就会出现<strong class="lk jd">分段故障</strong></p></blockquote><p id="a24c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是如何发生的</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="4318" class="oq np it op b gy pf pg l ph pi">int *p; //declaring a pointer<br/>printf('%d',*p); //dereferenging a pointer with no value. Segmentation fault.</span></pre><p id="f834" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3.<strong class="lk jd">传递一个指向函数的指针</strong></p><p id="2370" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在函数中使用指针来引用变量是非常诱人的，为什么不呢，它带来了很多好处。但是如果没有正确实现，它可能是您的程序的噩梦。看看这个例子——</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="3bff" class="oq np it op b gy pf pg l ph pi">void sum(int *a, int *b){<br/> *a = *a + *b;<br/>}</span><span id="713f" class="oq np it op b gy pj pg l ph pi">void main(){<br/>int a = 100;<br/>int b = 200;<br/>sum(&amp;a,&amp;b);</span><span id="42f3" class="oq np it op b gy pj pg l ph pi">printf(“%d”, a); //Prints 300<br/>}</span></pre><p id="ab07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们传递一个指向函数的指针时，我们传递的是一个变量的内存位置。如上述示例所示，内存地址可用于永久更改变量的值。</p><p id="0436" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">4.<strong class="lk jd">取消引用空指针</strong></p><p id="ee06" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">解引用空指针会导致<strong class="lk jd"> <em class="ol">分段错误</em> </strong>错误。为了防止错误，测试有效的目标通常是好的。</p><pre class="ks kt ku kv gt pb op pc pd aw pe bi"><span id="be0a" class="oq np it op b gy pf pg l ph pi">int* p = 0;</span><span id="60e6" class="oq np it op b gy pj pg l ph pi">if (p != 0 ) {<br/>printf("%p",*p) //Dereferencing only if the condition is met<br/>}</span></pre></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="c7a5" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">最后的提示和要点</h1><p id="e498" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">指针令人困惑，但它们是你武器库中最重要的武器之一，所以要明智地使用它们。</p><p id="292d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你感到困惑或者不明白发生了什么，试着画一些图表，指向变量的指针。记下指针的值和目标的值。</p><p id="d462" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你仍然不明白，不要担心，你总是有上面的部分来清除你的困惑。下面是一个小抄，复制它，忘记担心指针。</p><h2 id="88de" class="oq np it bd nq or os dn nu ot ou dp ny lr ov ow oa lv ox oy oc lz oz pa oe iz bi translated">外卖食品</h2><ul class=""><li id="aa7d" class="mt mu it lk b ll og lo oh lr pl lv pm lz pn md my mz na nb bi translated">指针提供了间接访问变量的方法</li><li id="975b" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated">指针允许你管理你的记忆</li><li id="2caf" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated">使用<code class="fe om on oo op b"><strong class="lk jd">int *</strong></code> <strong class="lk jd"> </strong>声明一个指针，使用<code class="fe om on oo op b"><strong class="lk jd">*</strong></code>取消对它的引用。</li><li id="765e" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated">要在同一行声明多个指针，在每个指针前使用<code class="fe om on oo op b">*</code></li><li id="73b1" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated">使用<code class="fe om on oo op b"><strong class="lk jd">&amp;</strong></code>获取变量的地址</li><li id="c4db" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated">数组、字符串和其他多值类型不需要<code class="fe om on oo op b"><strong class="lk jd">&amp;</strong></code>来获取地址</li><li id="037f" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated">取消引用没有值的指针或空指针会导致分段错误</li><li id="636f" class="mt mu it lk b ll nc lo nd lr ne lv nf lz ng md my mz na nb bi translated">内存地址可以用来永久改变变量的值，所以要小心</li></ul></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="f1a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望它有帮助。对于问题、疑问或请求，请使用个人资料中的链接通过任何社交媒体平台联系我。</p></div></div>    
</body>
</html>