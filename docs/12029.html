<html>
<head>
<title>Optimizing Clickhouse: Materialized View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化点击之家:物化视图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimizing-clickhouse-materialized-view-e4ecbdffa08e?source=collection_archive---------0-----------------------#2022-05-09">https://levelup.gitconnected.com/optimizing-clickhouse-materialized-view-e4ecbdffa08e?source=collection_archive---------0-----------------------#2022-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9bab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">根据用户的访问模式设计数据库读取路径</h2></div><h1 id="8983" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">什么是物化视图</h1><p id="b653" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">物化视图是一种数据库技术，它在用户请求查询之前以优化的形式计算或处理数据。数据通常来自另一个基表，这个<strong class="lc iu">有助于加速昂贵的查询，比如聚合大量数据</strong>。例如，您有一个在线商店的数据库。您有一个存储所有订单的数据库表，如下所示(我们将在本文中使用这个例子)。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/5cd2dc4a622ac9e21cfb5f422bc47515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6zK0VNJ2zDDDsbY4qXWsVQ.png"/></div></div></figure><p id="b61b" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">当经理想要从管理仪表板查看2021年的交易总量时，执行的SQL查询通常如下所示:</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="f87f" class="ms kj it mo b gy mt mu l mv mw">SELECT SUM(amount) FROM orders WHERE created_at BETWEEN '2021-01-01 00:00:00' AND '2021-12-31 23:59:59';</span></pre><p id="566d" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">该查询所做的是遍历订单表中的每一行，其中<code class="fe mx my mz mo b">created_at</code>日期在2021年之内，获取这些行的金额，并将它们相加。如果在2021年创建了100万个订单，那么经理每次查看管理仪表板时，数据库都会读取100万行。最糟糕的是，如果查询在主数据库节点上运行，它还会严重影响您的最终用户体验！</p><p id="f8e7" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">使用物化视图，您可以设计针对用户访问模式优化的数据。在我们的例子中，我们可以构建如下所示的物化视图:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi na"><img src="../Images/ad240578bb736a1ce32ea89d3336e03b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*RlrGFUcZl627q-TNTHv0JA.png"/></div></figure><p id="5364" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">当管理仪表板查询2021年的订单总量时，SQL查询应该如下所示:</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="1533" class="ms kj it mo b gy mt mu l mv mw">SELECT amount FROM yearly_order_mv WHERE year = 2021</span></pre><p id="57a1" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">该数据库仅执行了一次数据查找操作来获得2021年的订单总数。与之前的方法相比，这是一个<strong class="lc iu"> 1行读取与一百万行读取</strong>。物化视图就是这么强大。</p><h2 id="77a2" class="ms kj it bd kk nb nc dn ko nd ne dp ks lj nf ng ku ln nh ni kw lr nj nk ky nl bi translated">PostgreSQL中的物化视图</h2><p id="db62" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">相比之下，在PostgreSQL中，物化视图是在您第一次创建视图时计算/处理的，您需要刷新物化视图来手动更新物化视图。换句话说，PostgreSQL物化视图中的数据并不总是最新的，直到您手动刷新视图。这里有一个简短的演示。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nm"><img src="../Images/199e21af1be5db852810ef583791a541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*M7Pqc4DEEYuKigD6NuyR-w.gif"/></div></div></figure><p id="83e8" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">关于PostgreSQL中物化视图的另一个重要细节是，每当您<strong class="lc iu">创建或刷新物化视图时，PostgreSQL将读取整个基表以产生新的结果</strong>。如果您经常错误地这样做，您将不断地给数据库本身带来高负载。持续刷新物化视图<em class="nn">的成本可能远远大于从该物化视图中读取数据所获得的收益。</em></p><p id="a464" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">同样的行为可以在<a class="ae no" href="https://www.cockroachlabs.com/docs/v21.2/views#materialized-views" rel="noopener ugc nofollow" target="_blank">cocroach db</a>和其他一些数据库中找到。</p><h2 id="456d" class="ms kj it bd kk nb nc dn ko nd ne dp ks lj nf ng ku ln nh ni kw lr nj nk ky nl bi translated">在Clickhouse中有何不同</h2><p id="879d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">与PostgreSQL实体化视图相比，Clickhouse实体化视图的显著区别在于，只要在“基”表上有插入，Clickhouse <strong class="lc iu">就会自动更新实体化视图。在我们的例子中，它是<code class="fe mx my mz mo b">order</code>表。您不需要手动刷新视图，每次查询都会获得新的数据。</strong></p><h1 id="a2d1" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">实践教程</h1><h2 id="ad26" class="ms kj it bd kk nb nc dn ko nd ne dp ks lj nf ng ku ln nh ni kw lr nj nk ky nl bi translated">#1启动Clickhouse容器</h2><p id="ed78" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="nn">如果您已经有一个正在运行的Clickhouse数据库服务器</em>，您可以跳过这一步</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="a387" class="ms kj it mo b gy mt mu l mv mw"># Start a Clickhouse server<br/>$ docker run --rm --name some-clickhouse-server --ulimit nofile=262144:262144 yandex/clickhouse-server</span><span id="f6fb" class="ms kj it mo b gy np mu l mv mw"># Connect to Clickhouse client. Open this in another terminal<br/>$ docker run -it --rm --link some-clickhouse-server:clickhouse-server yandex/clickhouse-client --host clickhouse-server</span></pre><h2 id="a3b4" class="ms kj it bd kk nb nc dn ko nd ne dp ks lj nf ng ku ln nh ni kw lr nj nk ky nl bi translated">#2.创建和植入表格</h2><p id="0b9c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们将创建一个<code class="fe mx my mz mo b">orders</code>表，并用1亿行预先填充订单数据。生成的数据不是随机的；然而，这足以证明物化视图可以做什么。</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="6cdb" class="ms kj it mo b gy mt mu l mv mw">CREATE TABLE orders<br/>ENGINE = MergeTree()<br/>PRIMARY KEY (orderId)<br/>PARTITION BY toYYYYMM(created_at)<br/>SETTINGS index_granularity = 8192<br/>AS SELECT<br/> number as orderId,<br/> number as userId,<br/> number as amount,<br/> toDateTime('2021-01-01') + number/100000 as created_at <br/>FROM numbers(100000000);</span></pre><p id="6796" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">在我的笔记本电脑上，对2021年的3650万行记录求和需要<strong class="lc iu"> 246毫秒</strong>。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nq"><img src="../Images/e9969a83121809283a5cc736ac6e9f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCx-FXobNnj9nkMe_9EWdQ.png"/></div></div></figure><h2 id="16d6" class="ms kj it bd kk nb nc dn ko nd ne dp ks lj nf ng ku ln nh ni kw lr nj nk ky nl bi translated">#3创建物化视图</h2><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="abbf" class="ms kj it mo b gy mt mu l mv mw">-- Create yearly_order_mv materialized view<br/>CREATE MATERIALIZED VIEW yearly_order_mv <br/>ENGINE = SummingMergeTree<br/>PARTITION BY year ORDER BY year<br/>POPULATE<br/>AS<br/>SELECT <br/>  toYear(created_at) AS year,<br/>  SUM(amount) as amount<br/>FROM orders2<br/>GROUP BY year;</span></pre><p id="10a8" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">在物化视图中选择2021年总销售额的单个行需要5毫秒，<strong class="lc iu">比在步骤#2中聚合基表快49倍。</strong></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/dd7288a4ab1db43e116dadae5e291ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*8Ac9bMJmLRWc0fAwywG98w.png"/></div></figure><p id="453d" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">当然，加速因子根据不同的情况而变化，但是我们可以在这个例子中看到不同之处。</p><h2 id="eff6" class="ms kj it bd kk nb nc dn ko nd ne dp ks lj nf ng ku ln nh ni kw lr nj nk ky nl bi translated"><strong class="ak"> #4向基表插入数据将不断更新物化视图</strong></h2><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ns"><img src="../Images/8f985fe1c2063413805f390584357b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Fcs6ER2Ru5bditUdyAa2qA.gif"/></div></div></figure><p id="edec" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">注意，在插入新数据后，在<code class="fe mx my mz mo b">yearly_order_mv</code>物化视图中会出现一个新的<code class="fe mx my mz mo b">2024</code>行。我不需要像PostgreSQL中要求的那样刷新物化视图。</p><h1 id="72df" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">缺点</h1><p id="57f4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Clickhouse有一个主要缺点:<strong class="lc iu">它允许将重复的数据插入到表</strong>中。这可能会在调试时造成很多混乱。当涉及到物化视图时，这就更糟了，因为它可能会在您没有注意到的情况下导致重复输入。在Clickhouse中使用实例化视图时，应该避免多次插入相同的数据。</p><p id="3c43" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">物化视图也<strong class="lc iu">占用一些存储空间来存储预先计算的数据</strong>。但是，根据您如何设计您的物化视图，这应该不是一个问题，因为与它的基表相比，它应该占用相对较小的空间。</p><p id="c966" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">由于Clickhouse的物化视图中的数据总是最新的，这意味着Clickhouse正在主动更新物化视图中的数据。<strong class="lc iu">物化视图越多，维护所有物化视图所需的处理能力就越大</strong>。然而，这通常也不是一个大问题，因为这样做只需要相对较少的处理能力。</p><p id="d2ec" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">物化视图中反映的数据是<strong class="lc iu">最终一致</strong>。Clickhouse将在插入成功后响应客户端，但不会在实例化视图更新时响应。这是因为Clickhouse只在部件合并时更新物化视图(你可以多研究一下Clickhouse存储引擎是如何工作的，太迷人了！)，这发生在不可预测的时期。尽管如此，从我的经验来看，我从未见过它引人注目。如果您构建报告或商业智能仪表板，您可能能够容忍这种数据一致性。但是，如果你要求强一致性，那么物化视图并不适合你。</p><h1 id="89ec" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">脚枪</h1><p id="d498" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">当构建具有高基数数据的物化视图时，最好限制要处理的行数</strong>。例如，如果您正在为电子商务网站上的每小时或每分钟的销售额创建一个物化视图，那么最好通过在WHERE子句中指定来限制行，只显示最近三个月的销售额。否则，Clickhouse将扫描包含数百万行的整个表，消耗大量内存并最终崩溃(我曾在生产服务器上遇到过)。除此之外，<strong class="lc iu">在那些物化视图上实施数据TTL以节省磁盘空间</strong>也是一个好主意。</p><pre class="lx ly lz ma gt mn mo mp mq aw mr bi"><span id="99e2" class="ms kj it mo b gy mt mu l mv mw">-- BAD: Create order_hourly materialized view<br/>-- without WHERE and enforce data TTL<br/>CREATE MATERIALIZED VIEW hourly_order_mv <br/>ENGINE = SummingMergeTree<br/>PARTITION BY toYYYYMM(created_at) ORDER BY created_at<br/>POPULATE<br/>AS<br/>SELECT <br/>  toStartOfHour(toDateTime(created_at)) AS created_at,<br/>  SUM(amount) as amount<br/>FROM orders<br/>GROUP BY created_at</span><span id="475d" class="ms kj it mo b gy np mu l mv mw">-- GOOD: Create order_hourly materialized view <br/>-- with WHERE clause and enforce data TTL<br/>CREATE MATERIALIZED VIEW hourly_order_mv <br/>ENGINE = SummingMergeTree<br/>PARTITION BY toYYYYMM(created_at) ORDER BY created_at<br/>TTL created_at + INTERVAL 3MONTH<br/>POPULATE<br/>AS<br/>SELECT <br/>  toStartOfHour(toDateTime(created_at)) AS created_at,<br/>  SUM(amount) as amount<br/>FROM orders<br/>WHERE created_at &lt; subtractMonths(NOW(), 1)<br/>GROUP BY created_at</span></pre><p id="a751" class="pw-post-body-paragraph la lb it lc b ld mi ju lf lg mj jx li lj mk ll lm ln ml lp lq lr mm lt lu lv im bi translated">您可能需要一个每小时的实例化视图，因为您希望根据用户的本地时区向他们显示数据。假设您在UTC时区插入时间为<code class="fe mx my mz mo b">created_at</code>的数据；如果您在马来西亚(马来西亚时区比UTC早8小时)的用户打开它，您可以通过将数据按各自的时区偏移量分组来显示马来西亚时区的数据。</p><h1 id="0ae6" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">可供选择的事物</h1><p id="eef3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个数据库和数据流行业最近变得越来越热。出现了许多新的挑战者，如<a class="ae no" href="https://materialize.com/" rel="noopener ugc nofollow" target="_blank">物化</a>、<a class="ae no" href="http://timeplus.com" rel="noopener ugc nofollow" target="_blank">时间加</a>、<a class="ae no" href="https://tinybird.co/" rel="noopener ugc nofollow" target="_blank">小鸟儿</a>、<a class="ae no" href="https://rockset.com/" rel="noopener ugc nofollow" target="_blank">摇滚集</a>、<a class="ae no" href="https://readyset.io/" rel="noopener ugc nofollow" target="_blank">就绪集</a>等。我个人没有时间去探究其中的许多内容，但是Clickhouse对我很有帮助。</p><h1 id="072c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="424e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">计算机科学中的一切都是一种交换。如果你正确使用物化视图，你会得到它的好处。然而，<strong class="lc iu">如果您错误地使用物化视图，您将很容易得到不准确的数据、次优的性能、较高的磁盘使用率、较高的内存使用率</strong>等等。所以，在设计你的系统时要小心。</p></div></div>    
</body>
</html>