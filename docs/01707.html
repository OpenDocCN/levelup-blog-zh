<html>
<head>
<title>NodeJS Snippet: Child Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS片段:子流程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nodejs-snippet-child-process-46ebf735ea15?source=collection_archive---------7-----------------------#2020-01-23">https://levelup.gitconnected.com/nodejs-snippet-child-process-46ebf735ea15?source=collection_archive---------7-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed71" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将任务卸载到衍生的进程以解除对主线程的阻塞</h2></div><p id="0e96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js的设计是单线程的，因此需要它保持主节点进程的畅通才能继续执行。此外，Node仅限于一个线程和1.76GB(对于64位操作系统)的内存使用。因此，需要外部进程并行卸载CPU密集型处理。Node中的<code class="fe le lf lg lh b">child_process</code>模块允许我们生成可用于并行运行任何任务的进程。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="9955" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">内置Node.js模块:child_process</h2><p id="e622" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">节点模块<code class="fe le lf lg lh b"><strong class="kk iu">child_process</strong></code>允许我们创建新的<strong class="kk iu"> </strong>进程，并在不阻塞单个主线程的情况下，卸载要在后台并行处理的任务。这些子进程可用于任何可执行命令:</p><ul class=""><li id="01ae" class="mn mo it kk b kl km ko kp kr mp kv mq kz mr ld ms mt mu mv bi translated">系统命令:<code class="fe le lf lg lh b">ls -al</code>、<code class="fe le lf lg lh b">pwd</code>、<code class="fe le lf lg lh b">node --version</code></li><li id="c100" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated">运行节点或JavaScript代码:<code class="fe le lf lg lh b">child.js</code>或<code class="fe le lf lg lh b">node calculate.js</code></li><li id="f030" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated">任何其他语言的可执行文件:<code class="fe le lf lg lh b">program.exe</code>，<code class="fe le lf lg lh b">./script.sh</code></li></ul><p id="eb7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，系统命令可能无法在所有操作系统中运行，这应该由开发人员来处理。</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="78e3" class="lp lq it lh b gy nj nk l nl nm">const { platform } = require('os');<br/>const command = <strong class="lh iu">platform() === 'win32'</strong> ? 'cls' : 'clear';</span></pre></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="eaf4" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">创建新流程</h2><p id="02b4" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated"><code class="fe le lf lg lh b"><strong class="kk iu">spawn()</strong></code>在后台异步启动一个新进程，不阻塞主线程。</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="5c98" class="lp lq it lh b gy nj nk l nl nm">function <strong class="lh iu">spawn</strong>(command, args?, options?): <strong class="lh iu">ChildProcess</strong>;</span></pre><p id="dd6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的<code class="fe le lf lg lh b">command</code>可能需要可选的<code class="fe le lf lg lh b">arguments</code>命令和一些spawn <code class="fe le lf lg lh b">options</code>。这将返回衍生进程的一个<code class="fe le lf lg lh b">ChildProcess</code>实例。</p><p id="acd4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们生成一个子进程和一个执行系统命令:</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="5637" class="lp lq it lh b gy nj nk l nl nm">const cp = require("<strong class="lh iu">child_process</strong>");<br/>const child = cp.<strong class="lh iu">spawn</strong>('pwd');</span><span id="e7cf" class="lp lq it lh b gy nn nk l nl nm">const { spawn } = require("<strong class="lh iu">child_process</strong>");<br/>const ls = <strong class="lh iu">spawn</strong>('ls', ['-al', '/usr']);</span></pre><p id="6b0e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将在一个单独的衍生进程中执行<code class="fe le lf lg lh b">ls -al /usr</code>。进程和回调之间的交互可以利用新产生的子进程的输出。还要注意，在Windows操作系统上，运行命令需要一个特殊的标志:<code class="fe le lf lg lh b">spawn('dir', [], { <strong class="kk iu">shell:true</strong> })</code>。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="d1b8" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated"><strong class="ak">创建子进程的多种方法</strong></h2><p id="92b7" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">注:以下命令建立在<code class="fe le lf lg lh b">spawn</code>流程之上，以满足特殊需求。</p><ul class=""><li id="f92b" class="mn mo it kk b kl km ko kp kr mp kv mq kz mr ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">spawn()</code> →设计用于运行<strong class="kk iu">系统</strong> <strong class="kk iu">命令</strong>，此命令被发送到新进程上运行，但在主节点进程中不执行任何操作。</li><li id="93dc" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">fork()</code> →构建在<code class="fe le lf lg lh b">spawn()</code>之上的<strong class="kk iu">将旋转一个新的V8实例</strong>，用于运行任何基于节点的代码，无论是相同的程序还是另一个程序。这对于并行执行CPU密集型任务或扩展应用程序非常有用。与<code class="fe le lf lg lh b">spawn</code>的另一个区别是它将内置一个IPC频道。</li><li id="92ae" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">exec()</code> →当<strong class="kk iu">只有最终结果</strong>是关注点，并且不需要孩子的stdio流时，这很有用。<code class="fe le lf lg lh b">spawn()</code>返回一个数据流，而<code class="fe le lf lg lh b">exec()</code>将返回缓冲区数据，并对其进行编码以便读取。默认情况下，最大缓冲区大小被设置为200k，但可以扩展，否则会给出错误<code class="fe le lf lg lh b">maxBuffer exceeded</code>。</li><li id="23cf" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">execFile()</code> →与<code class="fe le lf lg lh b">exec()</code>不同，该命令执行时没有创建新的外壳。由于没有创建shell，一些系统命令可能无法在所有操作系统上运行，<code class="fe le lf lg lh b">execFile('ls', ...)</code>可以在Linux上运行，但类似的命令<code class="fe le lf lg lh b">execFile('dir', ...)</code>在Windows上无法运行。</li></ul><p id="f87d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以使用回调或侦听器来使用子进程:</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="ce92" class="lp lq it lh b gy nj nk l nl nm"><strong class="lh iu">// Consume using callbacks</strong></span><span id="54e2" class="lp lq it lh b gy nn nk l nl nm">const child = execFile('node', ['--version'],<br/>   <strong class="lh iu">(error, stdout, stderr)</strong> =&gt; {<br/>      if (error) throw error;<br/>      console.log(stdout);<br/>   });</span><span id="1f9c" class="lp lq it lh b gy nn nk l nl nm"><strong class="lh iu">// Consuming using listeners</strong></span><span id="bf1d" class="lp lq it lh b gy nn nk l nl nm">const child = execFile('node', ['--version']);<br/><strong class="lh iu">child.stdout.on</strong>('data',(data) =&gt; { console.log(data); });<br/><strong class="lh iu">child.stderr.on</strong>('data',(data) =&gt; { console.log(data); });</span></pre><figure class="nb nc nd ne gt no"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="9685" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated"><strong class="ak">异步或同步创建子流程</strong></h2><p id="3c00" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">子流程创建可以异步或同步进行。上面提到的通常方法是异步方法，其中函数进程被并行创建和执行，而不阻塞主节点进程。在同步进程创建中，这些方法是sync，Node.js事件循环被阻塞，暂停任何代码的执行，直到衍生的进程存在。</p><p id="e182" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些同步方法包括:<code class="fe le lf lg lh b">spawnSync</code>、<code class="fe le lf lg lh b">execSync</code>、<code class="fe le lf lg lh b">execFileSync</code>，是其异步方法的变体。这些方法在加载场景或应用程序启动时非常有用。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="dcdf" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">进程间通信</h2><p id="4daa" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">主节点进程和派生的子进程由于独立的空间而不共享内存，因此进程之间的通信对于共享数据和协调每个进程至关重要。由<code class="fe le lf lg lh b">child_process</code>模块中的<strong class="kk iu">进程间通信</strong>或<strong class="kk iu"> IPC </strong>完成。</p><p id="5ce3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，<code class="fe le lf lg lh b">spawn()</code>或<code class="fe le lf lg lh b">fork()</code>将返回<code class="fe le lf lg lh b">ChildProcess</code>的实例，该对象实现节点<code class="fe le lf lg lh b">EventEmitter</code> API。因此<strong class="kk iu">消息可以从子进程发送到主进程</strong>。</p><p id="aec5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如<code class="fe le lf lg lh b">'<strong class="kk iu">exit</strong>'</code>是子进程终止时发出的事件:</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="ca76" class="lp lq it lh b gy nj nk l nl nm">const { spawn } = require('child_process');<br/>const child = spawn('ls', ['-al', '/usr']);</span><span id="073f" class="lp lq it lh b gy nn nk l nl nm"><strong class="lh iu">child.on</strong>('<strong class="lh iu">exit</strong>', (code) =&gt; {<br/>   console.log(`child process exited with code ${code}`);<br/>});</span></pre><p id="48da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个重要事件是<code class="fe le lf lg lh b">'<strong class="kk iu">message</strong>'</code>事件，用于子进程和父进程之间的通信:</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="f7ad" class="lp lq it lh b gy nj nk l nl nm">// SEND MESSAGES FROM PARENT TO CHILD<br/>In parent → <strong class="lh iu">child.send('Hi')</strong><br/>In child  → <strong class="lh iu">process.on</strong>(<strong class="lh iu">'message'</strong>, message =&gt;</span><span id="e816" class="lp lq it lh b gy nn nk l nl nm">// SEND MESSAGES FROM CHILD TO PARENT<br/>In child  → <strong class="lh iu">process.send</strong>('Hi');<br/>In parent → <strong class="lh iu">child.on</strong>(<strong class="lh iu">'message'</strong>, message =&gt;</span></pre><p id="6d52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">子进程发出的所有值得注意的事件:<code class="fe le lf lg lh b"><strong class="kk iu">child.on</strong>('eventType', callback)</code></p><ul class=""><li id="1ab5" class="mn mo it kk b kl km ko kp kr mp kv mq kz mr ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">'<strong class="kk iu">exit</strong>'</code> →子进程退出。当子进程正常退出时，此<code class="fe le lf lg lh b">signal</code>变量为空。</li><li id="e0da" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">'<strong class="kk iu">disconnect</strong>'</code> →父进程手动调用<code class="fe le lf lg lh b">child.disconnect</code>函数</li><li id="f7c1" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">'<strong class="kk iu">error</strong>'</code> →如果无法产生或终止进程</li><li id="64ba" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">'<strong class="kk iu">close</strong>'</code> →子进程的<code class="fe le lf lg lh b">stdio</code>流关闭。这个<code class="fe le lf lg lh b">close</code>事件不同于<code class="fe le lf lg lh b">exit</code>事件，因为多个子进程可能共享同一个<code class="fe le lf lg lh b">stdio</code>流，所以一个子进程退出并不意味着流被关闭。</li><li id="d30f" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">'<strong class="kk iu">message</strong>'</code> →子进程使用<code class="fe le lf lg lh b">process.send()</code>函数向父进程发送消息。</li></ul><figure class="nb nc nd ne gt no"><div class="bz fp l di"><div class="nr nq l"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">父进程和子进程之间的IPC通信</figcaption></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="7653" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">标准标准io流</h2><p id="798c" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">此外，<code class="fe le lf lg lh b">ChildProcess</code>还包含用于I/O的标准<code class="fe le lf lg lh b">stdio</code>流，称为<code class="fe le lf lg lh b">stdin</code>(可写)、<code class="fe le lf lg lh b">stdout</code>(可读)、<code class="fe le lf lg lh b">stderr</code>(可读)，这些流在parent Node.js进程和衍生的子进程之间建立通信管道。这些流还在nodejs中实现了<code class="fe le lf lg lh b">EventEmitter</code> API。</p><p id="7f49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">readable</code>流上，父进程可以监听<code class="fe le lf lg lh b">data</code>事件:</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="9791" class="lp lq it lh b gy nj nk l nl nm">const { <strong class="lh iu">spawn</strong> } = require('child_process');<br/>const child = spawn('<strong class="lh iu">pwd</strong>');</span><span id="8b78" class="lp lq it lh b gy nn nk l nl nm"><strong class="lh iu">child.stdout.on</strong>('<strong class="lh iu">data</strong>', (data) =&gt; {<br/>    console.log(`stdout: ${data}`);<br/>});</span></pre><p id="12a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">打印出<code class="fe le lf lg lh b">pwd</code>命令的输出，并用<code class="fe le lf lg lh b">code 0</code>退出子进程。</p><p id="4154" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果命令出错，触发<code class="fe le lf lg lh b">child.stderr</code>的<code class="fe le lf lg lh b">data</code>事件处理程序，<code class="fe le lf lg lh b">exit</code>事件处理程序将带着<code class="fe le lf lg lh b">code 1</code>退出。</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="f4f0" class="lp lq it lh b gy nj nk l nl nm">const { <strong class="lh iu">exec</strong> } = require('child_process');<br/>const child = exec('<strong class="lh iu">pwdsss</strong>');</span><span id="4ff6" class="lp lq it lh b gy nn nk l nl nm"><strong class="lh iu">child.stderr.on</strong>('<strong class="lh iu">data</strong>', (data) =&gt; {<br/>   console.log(`stdout: ${data}`);<br/>});</span></pre><p id="745e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果执行了<code class="fe le lf lg lh b">pwdsss</code>的无效命令，并且<code class="fe le lf lg lh b">stderr</code>流被激活。<strong class="kk iu">当所有</strong> <code class="fe le lf lg lh b"><strong class="kk iu">stdio</strong></code> <strong class="kk iu">流关闭时，子进程将发出</strong> <code class="fe le lf lg lh b"><strong class="kk iu">close</strong></code> <strong class="kk iu">事件。</strong></p><h2 id="5474" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated"><strong class="ak">父进程和子进程流之间的管道</strong></h2><p id="7612" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">在主进程上，<code class="fe le lf lg lh b">stdin</code>是一个<code class="fe le lf lg lh b">readable</code>流，但是在子进程上，它是一个<code class="fe le lf lg lh b">writable</code>流。因此，在主进程中发现相反的情况，这里子进程写入流中，而从主进程的角度来看，可以从流中读取它。</p><p id="1493" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果有需要从父节点传递到子节点的输入，一个简单的管道可以从父节点的<code class="fe le lf lg lh b">stdin</code>传递到子节点的输入流<code class="fe le lf lg lh b">stdin</code>。</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="25df" class="lp lq it lh b gy nj nk l nl nm">const { spawn } = require('child_process');<br/>const child = spawn('wc');</span><span id="fff5" class="lp lq it lh b gy nn nk l nl nm"><strong class="lh iu">process.stdin.pipe(child.stdin)</strong>;</span><span id="faef" class="lp lq it lh b gy nn nk l nl nm">child.stdout.on('data', (data) =&gt; {<br/>   console.log(`\nFrom Child:\n${data}`);<br/>});</span></pre><p id="35ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">执行此操作后，在空闲终端中添加随机文本和行，然后进入<code class="fe le lf lg lh b">Ctrl + D</code>完成父输入流。来自父进程的输入将通过管道传递给子进程。这个<code class="fe le lf lg lh b">wc</code>只是统计输入的行数、字符数。</p><p id="fc0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们使用管道将子进程的<code class="fe le lf lg lh b">stdout</code>连接到父进程:</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="ed79" class="lp lq it lh b gy nj nk l nl nm">var ls = child_process.spawn('ls', ['-a', '/home']);<br/><strong class="lh iu">ls.stdout.pipe(process.stdout);</strong></span></pre><p id="f936" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，它将把子节点的输出流通过管道传输到父节点，以列出目录。像这样，子节点的所有流都可以使用spawn选项直接链接到父节点。</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="bd55" class="lp lq it lh b gy nj nk l nl nm">var cp = require('child_process');</span><span id="5532" class="lp lq it lh b gy nn nk l nl nm">var command = 'echo';<br/>var args = ['hello', 'world'];</span><span id="aa6f" class="lp lq it lh b gy nn nk l nl nm">var childProcess = cp.spawnSync(command, args, {<br/>   cwd: process.cwd(),<br/>   env: process.env,<br/>   <strong class="lh iu">stdio: [ process.stdin, process.stdout, process.stderr ]</strong>,<br/>   // stdio: 'inherit' can also be used.<br/>   <strong class="lh iu">encoding: 'utf-8'</strong><br/>});</span></pre><p id="6f29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个用例是在子进程之间建立管道:</p><pre class="nb nc nd ne gt nf lh ng nh aw ni bi"><span id="6cad" class="lp lq it lh b gy nj nk l nl nm">const { spawn } = require('child_process');</span><span id="f65a" class="lp lq it lh b gy nn nk l nl nm">const find = spawn('find', ['.', '-type', 'f']);<br/>const wc = spawn('wc', ['-l']);</span><span id="03f9" class="lp lq it lh b gy nn nk l nl nm">find.stdout.pipe(process.stdout);<br/><strong class="lh iu">find.stdout.pipe(wc.stdin)</strong>;</span><span id="e246" class="lp lq it lh b gy nn nk l nl nm">wc.stdout.on('data', (data) =&gt; {<br/>   console.log(`Number of files ${data}`);<br/>});</span></pre><p id="91b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里<code class="fe le lf lg lh b">find</code>子进程的输出转化为<code class="fe le lf lg lh b">wc</code>子进程当前目录下的文件数列表。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="139a" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">子流程对象的摘要</h2><p id="6e65" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">当生成子进程时，我们看到返回了一个类型为<code class="fe le lf lg lh b">ChildProcess</code>的对象。该对象的概要如下:</p><ul class=""><li id="1edf" class="mn mo it kk b kl km ko kp kr mp kv mq kz mr ld ms mt mu mv bi translated">事件→ <code class="fe le lf lg lh b">message</code>、<code class="fe le lf lg lh b">error</code>、<code class="fe le lf lg lh b">exit</code>、<code class="fe le lf lg lh b">disconnect</code>、<code class="fe le lf lg lh b">close</code></li><li id="5bff" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated">属性→ <code class="fe le lf lg lh b">stdin</code>、<code class="fe le lf lg lh b">stdout</code>、<code class="fe le lf lg lh b">stderr</code>、<code class="fe le lf lg lh b">stdio</code>、<code class="fe le lf lg lh b">pid</code>、<code class="fe le lf lg lh b">connected</code>、<code class="fe le lf lg lh b">kill</code>、<code class="fe le lf lg lh b">send()</code>、<code class="fe le lf lg lh b">disconnect()</code></li></ul><p id="0ed9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，当使用<code class="fe le lf lg lh b">spawn()</code>或<code class="fe le lf lg lh b">exec()</code>创建子流程时，可以添加如下选项</p><ul class=""><li id="6b8f" class="mn mo it kk b kl km ko kp kr mp kv mq kz mr ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">SpawnOptions</code> → <code class="fe le lf lg lh b">cwd</code>、<code class="fe le lf lg lh b">env</code>、<code class="fe le lf lg lh b">stdio</code>、<code class="fe le lf lg lh b">detached</code>、<code class="fe le lf lg lh b">uid</code>、<code class="fe le lf lg lh b">gid</code>、<code class="fe le lf lg lh b">shell</code></li><li id="da51" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated"><code class="fe le lf lg lh b">ExecOptions</code> → <code class="fe le lf lg lh b">encoding</code>、<code class="fe le lf lg lh b">timeout</code>、<code class="fe le lf lg lh b">shell</code>、<code class="fe le lf lg lh b">maxBuffer</code>、<code class="fe le lf lg lh b">killSignal</code></li></ul></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><figure class="nb nc nd ne gt no gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/6742b773a76661bbcecf672618f3975d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*UFZQm7nTnKRXXBt0OF4wfw.png"/></div></figure><p id="56c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文旨在简要概述如何使用<code class="fe le lf lg lh b">child_process</code>中的流程来充分利用nodejs。点击此处了解更多信息:</p><div class="nz oa gp gr ob oc"><a href="https://nodejs.org/api/child_process.html" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">Node.js文档</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">child_process模块提供了以相似但不相同的方式产生子进程的能力…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">nodejs.org</p></div></div></div></a></div><p id="bc88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:Nodejs内置模块<code class="fe le lf lg lh b"><strong class="kk iu">cluster</strong></code>也使用<code class="fe le lf lg lh b">child_process</code>方法<code class="fe le lf lg lh b">fork</code>启动新进程。这允许我们使进程能够共享同一个端口，因此它可以主要用于<strong class="kk iu"> nodejs http服务器伸缩</strong>。</p><p id="c136" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:Nodejs内置模块<code class="fe le lf lg lh b"><strong class="kk iu">worker_threads</strong></code> <strong class="kk iu"> </strong> to也用于处理轻量级线程的密集型任务。然而，这两个模块的使用案例和需求可能会有所不同。</p></div></div>    
</body>
</html>