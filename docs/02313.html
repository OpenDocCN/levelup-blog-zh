<html>
<head>
<title>Securing API’s with JWT-in-a-cookie Using Rails 6 and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rails 6和React通过JWT保护API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/api-authentication-with-jwt-and-cookies-featuring-rails-6-and-react-bd33a477c559?source=collection_archive---------2-----------------------#2020-03-05">https://levelup.gitconnected.com/api-authentication-with-jwt-and-cookies-featuring-rails-6-and-react-bd33a477c559?source=collection_archive---------2-----------------------#2020-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f95" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于在同一个域中为基于cookie的身份验证提供API和前端应用程序的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/628fd77685591c9399f7e0539cc3d069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_gbkhe37iXAU7or56FWh-A.png"/></div></div></figure><p id="c645" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将带你建立一个基于cookie的带有子域的认证系统，这样你的应用将符合web标准，它的cookie将保存在iOS和Safari上。</p><h1 id="365e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">为什么要把JWT放在饼干里？</h1><p id="98c2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">存储在本地存储器中的一个简单的JWT将足以保护一个小的应用程序。但是，在大型生产级应用程序中，它会带来安全风险。我们通过将JWT编码为仅HTTP cookie并将其传递给用户的浏览器来缓解许多安全问题。这样，恶意的Javascript就无法访问我们的JWT，因为浏览器本身会为每个后续请求自动包含cookie。这大大减少了前端的身份验证代码/逻辑的数量，因为我们不需要使用Javascript来管理和存储令牌。</p><h1 id="fff1" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">苹果的问题…</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0ddd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">苹果Safari在MacOS和iOS上的最新变化改变了cookies的保存方式。如果您的服务器设置为跨源提供cookie，Safari将不会存储服务器传递的cookie。这是因为cookie的来源和请求来源是不同的。</p><p id="69c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文介绍了如何以符合这些规则的方式实现身份验证系统。</p><p id="cfe3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，认证请求源(React)和响应源(Rails 6)必须在同一个域中。</p><p id="a883" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们的后端和前端是分开托管的，这会在开发过程中造成问题(如果您在API模式下使用create-react-app和Rails，这是非常常见的)。为了解决这个问题，我们将使用ngrok。</p><h1 id="7762" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">设置Ngrok</h1><p id="16c0" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">对于门外汉来说，Ngrok是一个很棒的软件，它可以让你把流量从互联网传输到你的本地服务器。如果您想将运行在本地主机上的开发服务器提供给互联网的其他部分，这将非常有用。</p><p id="c174" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先前往<a class="ae mp" href="https://ngrok.com" rel="noopener ugc nofollow" target="_blank">https://ngrok.com</a>注册一个专业账户，这将允许我们保留一个域名，可用于我们的前端和后端。我们将使用client . your-domain-here . ngrok . io服务React应用程序，使用api.your-domain-here.ngrok.io服务Rails服务器。关于设置ngrok的基本介绍，请参考Twilio <a class="ae mp" href="https://www.twilio.com/blog/2016/12/localhost-tunneling-ngrok-mac-os-x.html" rel="noopener ugc nofollow" target="_blank">的这篇优秀指南https://www . Twilio . com/blog/2016/12/localhost-tunneling-ngrok-MAC-OS-x . html</a>。设置完成后，将其连接到你的付费账户(说明见https://ngrok.com<a class="ae mp" href="https://ngrok.com" rel="noopener ugc nofollow" target="_blank"/>)并在ngrok web dashboard中保留你的域名。</p><h2 id="ddc9" class="mq lr it bd ls mr ms dn lw mt mu dp ma ld mv mw mc lh mx my me ll mz na mg nb bi translated">点燃ngrok</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/62ab454dcccd830e5d3afbfc109f764e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnzdk4oAXk_Pm595XfMSkQ.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">我喜欢使用Tmux来做这种事情，你可以看到2个ngrok隧道将流量路由到我的本地服务器</figcaption></figure><p id="6da4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您的rails服务器运行在端口3000上，导航到您下载ngrok的位置并输入</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="6822" class="mq lr it ni b gy nm nn l no np">./ngrok http 3000 -subdomain api.your-subdomain-here</span></pre><p id="e275" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对前端进行同样的操作，我们将假设您的React服务器运行在端口5500上</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d8b7" class="mq lr it ni b gy nm nn l no np">./ngrok http 5500 -subdomain client.your-subdomain-here</span></pre><p id="a9a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些命令实际上告诉ngrok在您的保留域下创建一个子域，并将去往这些URL的所有流量路由到端口5500和3000。</p><p id="ffdc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过这种设置，我们满足了Apple/Safari在用户浏览器中愉快地接受和保存服务器cookies的要求。</p><h1 id="cc0c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">让我们从后端开始</h1><p id="a267" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们将为此使用Rails 6，你可以在我的github repo上找到完整的代码:<a class="ae mp" href="https://github.com/donrestarone/cookie-authentication-backend" rel="noopener ugc nofollow" target="_blank">https://github . com/donrestarone/cookie-authentic ation-back end</a>。我为每个步骤都创建了分支，这样更容易理解。</p><h2 id="c47f" class="mq lr it bd ls mr ms dn lw mt mu dp ma ld mv mw mc lh mx my me ll mz na mg nb bi translated">仅适用于Rails API应用程序</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/a2c6cc8d6d998122d6cf93be6757edb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFXOi9PRL0ce_ha9YqsPgg.png"/></div></div></figure><p id="fba0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你像我一样在API模式下使用Rails 6，你首先需要在config/application.rb中添加一个额外的中间件。如果您使用的是传统的Rails堆栈，可以跳过这一步。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mo l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">在第36行，我们添加了ActionDispatch::Cookies</figcaption></figure><p id="c423" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们需要确保我们可以访问控制器中的cookies模块。为此，我们将这一行添加到ApplicationController中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mo l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">通过将它包含在这里，我们所有的控制器都可以处理cookies</figcaption></figure><h2 id="de29" class="mq lr it bd ls mr ms dn lw mt mu dp ma ld mv mw mc lh mx my me ll mz na mg nb bi translated">设置CORS(跨来源资源共享)</h2><p id="215b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">通常对于API，我们将允许通配符域(这意味着任何域都可以向我们的服务器发出请求)。这种方法不适用于http-only cookie，因为它们被绑定到客户端的特定域。为了解决这个问题，我们将把为React应用程序提供服务的域列入白名单。</p><p id="92a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您使用的是Rails 6+，那么Rack-cors gem的最新版本中目前存在一个bug，导致它拒绝白标域。请确保使用“rack-cors”，即“~&gt; 0.4.1”来避免此问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mo l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">Debug true将显示进入API的所有请求的日志。没有这个，被拒绝的请求将不会显示。这样，如果你的前端不能与后端对话，你可以进行调试(检查chrome开发工具中的CORS错误)</figcaption></figure><h2 id="7867" class="mq lr it bd ls mr ms dn lw mt mu dp ma ld mv mw mc lh mx my me ll mz na mg nb bi translated">创建一个编码和解码JWT氏症的模块</h2><p id="4850" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">该模块将接受作为哈希和到期时间传递的有效负载。如果令牌过期、无效或未经Rails secret签名，此函数将返回false。否则，它将返回解码后的令牌</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mo l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">我们将把这个文件保存在lib/core _ modules/JSON _ web _ token下</figcaption></figure><p id="bad8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更好地衡量，我们将明确地告诉Rails自动加载/lib文件夹。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mo l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">我们用第24行的代码告诉Rails自动加载/lib下的所有文件</figcaption></figure><p id="add8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简洁起见，我将跳过模型并注册设置，因为您可以在我的Github repo上查找它。</p><h2 id="892f" class="mq lr it bd ls mr ms dn lw mt mu dp ma ld mv mw mc lh mx my me ll mz na mg nb bi translated">当用户登录时提供cookie，当用户退出时销毁它</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mo l"/></div></figure><p id="4389" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Cookie身份验证几乎与JWT身份验证相同，用户将提供他们的电子邮件和密码，如果这些有效，我们将签署一个cookie并将其传递给他们的浏览器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mo l"/></div></figure><p id="2df3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">神奇的事情发生在第22行，我们在饼干上签名。该值被设置为JWT(包含一些用户信息，如他们的ID ), http only选项确保它只被传递给浏览器，而不是客户端Javascript。</p><p id="1362" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于注销，在运行destroy方法之前，我们确保cookie是有效的(这就是before_action块所做的)。如果是，我们只需删除cookie，就可以将它从用户的浏览器中删除。</p><h2 id="b7cd" class="mq lr it bd ls mr ms dn lw mt mu dp ma ld mv mw mc lh mx my me ll mz na mg nb bi translated">检查用户是否有有效的cookie，并从中提取用户信息</h2><p id="caf9" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">首先，我们将在应用程序控制器中创建一些助手函数。这两种方法将被反复使用，以检查用户是否拥有有效的cookie，并从该cookie中获取当前用户信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mo l"/></div></figure><p id="376f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">authenticate_cookie将检查传递的cookie并尝试解码它。如果有效，它将返回true，从而继续过滤器链。否则，它将呈现一个错误，React应用程序可以使用该错误向用户显示一条有用的消息(可能会告诉用户他们的会话已经过期，他们需要重新登录)。</p><p id="2182" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">current_user将帮助我们找到在任何给定时刻发出请求的用户。</p><p id="0fa2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大部分繁重的工作现在已经完成。万一你在这里逗留了这么久，那就出发吧！</p><h1 id="9288" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">设置React</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mo l"/></div></figure><p id="8aa6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一部分真的很简单，你所需要做的就是添加凭证:“include”到你的每一个fetch调用，浏览器会自动包含请求的cookie。这是一个登录和退出的例子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq mo l"/></div></figure><p id="44ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你在登录时瞥一眼chrome dev tools，你会看到一个只有http的cookie被Rails服务器放入你的浏览器。此cookie会在您注销时消失。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/d69e6a50a127a235b0bbc519505924ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYKLHIlg00I3SIijbeTITQ.png"/></div></div></figure><p id="4d40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是全部了！</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="07a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">沙希科是一名来自多伦多的软件工程师，也是T2 Restarone公司的创始人。当他不开发软件时，他就在Medium和<a class="ae mp" href="https://www.youtube.com/channel/UCFl6NiPZtdsLHWUPWhrJj3g" rel="noopener ugc nofollow" target="_blank"> YouTube </a>上创造内容，帮助人们过渡到科技行业。</p></div></div>    
</body>
</html>