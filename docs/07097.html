<html>
<head>
<title>Java Generics — Advanced Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java泛型—高级案例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-generics-advanced-cases-d05db19b47d5?source=collection_archive---------3-----------------------#2021-01-25">https://levelup.gitconnected.com/java-generics-advanced-cases-d05db19b47d5?source=collection_archive---------3-----------------------#2021-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="31e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我们将讨论如何以最有效的方式在你的代码中实现泛型。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/63098c265a1a7df4e9ef993b6a6b9da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zhqP7EwMf8rZMDTd-AoHcg.png"/></div></div></figure><h1 id="1ff9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">不使用原始类型</strong></h1><p id="e8fd" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这种说法似乎显而易见。原始类型打破了泛型的整个概念。它的用法不允许编译器检测类型错误。但这不是唯一的问题。假设我们有这样的类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">通用容器</figcaption></figure><p id="019c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们假设我们不关心泛型类型本身。我们需要做的就是穿越<code class="fe mg mh mi mj b">numbersList</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">遍历号码列表</figcaption></figure><p id="514f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令人惊讶的是，这段代码无法编译。</p><pre class="km kn ko kp gt mk mj ml mm aw mn bi"><span id="84b1" class="mo ky iq mj b gy mp mq l mr ms">error: incompatible types: Object cannot be converted to int<br/>        for (int num : container.getNumbers()) {<br/>                                           ^</span></pre><p id="2e74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事情是，原始类型的使用不仅删除了关于类的泛型类型的信息，甚至还删除了预定义的信息。于是，<code class="fe mg mh mi mj b">List&lt;Integer&gt;</code>就变成了刚刚的<code class="fe mg mh mi mj b">List</code>。</p><p id="b5f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能做些什么呢？答案很简单。如果您不关心泛型类型，请使用<em class="mt">通配符操作符</em>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">遍历号码列表。固定版本</figcaption></figure><p id="6dc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码运行得非常好。</p><h1 id="0b56" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">首选基于通配符的输入</h1><p id="1399" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">数组和泛型的主要区别在于，数组是<a class="ae mu" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="mt">协变</em> </a> <em class="mt"> </em>而泛型不是<em class="mt">。这意味着<code class="fe mg mh mi mj b">Number[]</code>是<code class="fe mg mh mi mj b">Integer[]</code>的超类型。而<code class="fe mg mh mi mj b">Object[]</code>是任何数组的超类型(除了原始数组)。这似乎合乎逻辑，但它可能会导致运行时的错误。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">数组协方差的错误</figcaption></figure><p id="a695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码可以编译，但是它抛出了一个意外的异常。泛型被用来解决这个问题。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">泛型的不变性消除了可能的错误</figcaption></figure><p id="cf29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">List&lt;Long&gt;</code>不能赋给<code class="fe mg mh mi mj b">List&lt;Number&gt;</code>。虽然它帮助我们避免了<code class="fe mg mh mi mj b">ArrayStoreException</code>，但它也给API设置了限制，使其不灵活且过于严格。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">不灵活的API</figcaption></figure><p id="2d75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切看起来都很好，不是吗？我们甚至将<code class="fe mg mh mi mj b">Collection</code>作为输入参数。这使得我们可以通过<code class="fe mg mh mi mj b">List</code>、<code class="fe mg mh mi mj b">Set</code>、<code class="fe mg mh mi mj b">Queue</code>等。但是别忘了<code class="fe mg mh mi mj b">Employee</code>只是一个接口。如果我们使用特定实现的集合会怎么样？比如<code class="fe mg mh mi mj b">List&lt;Manager&gt;</code>或者<code class="fe mg mh mi mj b">Set&lt;Accountant&gt;</code>？我们不能直接超过他们。因此，每次都需要将元素转移到<code class="fe mg mh mi mj b">Employee</code>的集合中。</p><p id="a9e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者我们可以使用通配符。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">灵活的API</figcaption></figure><p id="8f96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，正确的泛型用法使程序员的生活变得更加轻松。让我们看另一个例子。</p><p id="95df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们需要为排序服务声明一个API。这是第一次天真的尝试。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">简单分类服务</figcaption></figure><p id="dabf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个不同的问题。我们必须确保<code class="fe mg mh mi mj b">Comparator</code>完全是为<code class="fe mg mh mi mj b">T</code>类型创建的。但事实并非总是如此。我们可以为<code class="fe mg mh mi mj b">Employee</code>造一个通用的，在这种情况下，它对<code class="fe mg mh mi mj b">Accountant</code>和<code class="fe mg mh mi mj b">Manager</code>都不起作用。</p><p id="dc6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把API做得更好一点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">更好的分拣服务</figcaption></figure><p id="e277" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你知道，这些限制有点令人困惑。所有这些<code class="fe mg mh mi mj b">? extends T</code>和<code class="fe mg mh mi mj b">? super T</code>似乎过于复杂。值得庆幸的是，有一个简单的规则可以帮助识别正确的用法— <a class="ae mu" href="https://howtodoinjava.com/java/generics/java-generics-what-is-pecs-producer-extends-consumer-super/" rel="noopener ugc nofollow" target="_blank"> PECS </a> <em class="mt"> </em>(生产者扩展，消费者超级)<em class="mt">。</em>这意味着生产者应该是<code class="fe mg mh mi mj b">? extends T</code>类型，而消费者应该是<code class="fe mg mh mi mj b">? super T</code>类型。</p><p id="462c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看具体的例子。我们之前描述的方法<code class="fe mg mh mi mj b">MoneyService.calculateAvgSalary</code>接受一个生产者。因为集合<em class="mt">产生了用于进一步计算的</em>元素。</p><p id="d019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个例子来自JDK标准图书馆。我说的是<code class="fe mg mh mi mj b">Collection.addAll</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">Collection.addAll</figcaption></figure><p id="8441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义上限泛型允许我们连接<code class="fe mg mh mi mj b">Collection&lt;Employee&gt;</code>和<code class="fe mg mh mi mj b">Collection&lt;Manager&gt;</code>或任何其他共享相同接口的类。</p><p id="6cd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">消费者呢？我们在<code class="fe mg mh mi mj b">SortingService</code>中使用的<code class="fe mg mh mi mj b">Comparator</code>就是一个完美的例子。这个接口有一个接受泛型类型并返回具体类型的方法。消费者的典型例子。其他的还有<code class="fe mg mh mi mj b">Predicate</code>、<code class="fe mg mh mi mj b">Consumer</code>、<code class="fe mg mh mi mj b">Comparable</code>，还有很多来自<code class="fe mg mh mi mj b">java.util</code>包的。大多数情况下，所有这些接口都应该与<code class="fe mg mh mi mj b">? super T</code>一起使用。</p><p id="f9a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一个独一无二的，同时是生产者和消费者。是<code class="fe mg mh mi mj b">java.util.Function</code>。它将输入值从一种类型转换为另一种类型。所以，常见的<code class="fe mg mh mi mj b">Function</code>用法是<code class="fe mg mh mi mj b">Function&lt;? super T, ? extends R&gt;</code>。这可能看起来很可怕，但它确实有助于构建健壮的软件。你可以发现<code class="fe mg mh mi mj b">Stream</code>界面中的所有映射函数都遵循这个规则。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">流映射</figcaption></figure><blockquote class="mv mw mx"><p id="0d03" class="jn jo mt jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated">你可能会注意到<code class="fe mg mh mi mj b">SortingService.sort</code>接受<code class="fe mg mh mi mj b">List&lt;T&gt;</code>而不是<code class="fe mg mh mi mj b">List&lt;? extends T&gt;</code>。为什么会这样呢？这毕竟是个制作人。事实是，与预定义类型相比，上下限是有意义的。因为<code class="fe mg mh mi mj b">SortingService.sort</code>方法参数化了自己，所以用界限来限制<code class="fe mg mh mi mj b">List</code>是没有意义的。另一方面，如果<code class="fe mg mh mi mj b">SortingService</code>有一个泛型类型，<code class="fe mg mh mi mj b">? extends T</code>就会有它的值。</p></blockquote><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">参数化排序服务</figcaption></figure><h1 id="c21e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不要返回有界容器</h1><h2 id="8c4f" class="mo ky iq bd kz nb nc dn ld nd ne dp lh jy nf ng ll kc nh ni lp kg nj nk lt nl bi translated">上限</h2><p id="5866" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">一些开发人员发现了有界泛型类型的强大功能，他们可能会认为这是一颗银弹。这可能会导致类似下一个代码片段。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">员工信息库</figcaption></figure><p id="d657" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里怎么了？首先，<code class="fe mg mh mi mj b">List&lt;? extends Employee&gt;</code>不经过造型就不能赋给<code class="fe mg mh mi mj b">List&lt;Employee&gt;</code>。不仅如此，这个上限还设置了一些不明显的限制。</p><p id="e28c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们可以将什么类型的值放入由<code class="fe mg mh mi mj b">EmployeeRepository.findEmployeesByNameLike(String)</code>返回的集合中？你可能会建议是类似<code class="fe mg mh mi mj b">Accountant</code>、<code class="fe mg mh mi mj b">Manager</code>、<code class="fe mg mh mi mj b">SoftwareEngineer</code>之类的东西。但这是一个错误的假设。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">一般上限限制</figcaption></figure><p id="2c13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个代码片段看起来不太直观，但实际上，一切都很好。我们来解构一下这个案例。首先，我们需要确定哪些集合可以分配给<code class="fe mg mh mi mj b">List&lt;? extends Employee&gt;</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">通用上限允许的集合</figcaption></figure><p id="fa2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，基本上继承自<code class="fe mg mh mi mj b">Employee</code>的任何类型的列表都可以分配给<code class="fe mg mh mi mj b">List&lt;? extends Employee&gt;</code>。这使得添加新项目变得棘手。编译器无法知道列表的确切类型。这就是为什么它禁止添加任何项目，以消除潜在的堆污染。但是<code class="fe mg mh mi mj b">null</code>是一个特例。该值没有自己的类型。它可以赋给任何东西(除了基本体)。这就是为什么<code class="fe mg mh mi mj b">null</code>是唯一允许添加的值。</p><p id="7177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从列表中检索项目怎么样？</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">从上限列表中检索项目</figcaption></figure><p id="85b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">Emloyee</code>是列表可能包含的任何潜在元素的超类型。这里没有警告。</p><h2 id="a390" class="mo ky iq bd kz nb nc dn ld nd ne dp lh jy nf ng ll kc nh ni lp kg nj nk lt nl bi translated">下限</h2><p id="5b99" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们可以给<code class="fe mg mh mi mj b">List&lt;? super Employee&gt;</code>添加什么元素？逻辑告诉我们，它不是<code class="fe mg mh mi mj b">Object</code>就是<code class="fe mg mh mi mj b">Employee</code>。这又愚弄了我们。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">一般下限限制</figcaption></figure><p id="a551" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，为了解决这个问题，让我们看看哪些集合可以分配给<code class="fe mg mh mi mj b">List&lt;? super Employee&gt;</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">通用下限允许的集合</figcaption></figure><p id="fe65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译器知道列表可以由<code class="fe mg mh mi mj b">Object</code>类型或<code class="fe mg mh mi mj b">Employee</code>类型组成。这就是为什么<code class="fe mg mh mi mj b">Accountant</code>、<code class="fe mg mh mi mj b">Manager</code>、<code class="fe mg mh mi mj b">SoftwareEngineer</code>、<code class="fe mg mh mi mj b">Employee</code>可以放心添加的原因。它们都实现了<code class="fe mg mh mi mj b">Employee</code>接口并继承了<code class="fe mg mh mi mj b">Object</code>类。同时，<code class="fe mg mh mi mj b">Object</code>不能添加，因为它没有实现<code class="fe mg mh mi mj b">Employee</code>。</p><p id="c146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，从<code class="fe mg mh mi mj b">List&lt;? super Employee&gt;</code>开始读就没那么容易了。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">从下限列表中检索项目</figcaption></figure><p id="210a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译器无法确定返回的项目是否属于<code class="fe mg mh mi mj b">Employee</code>类型。也许这是一个<code class="fe mg mh mi mj b">Object</code>。这就是代码无法编译的原因。</p><h2 id="cb7d" class="mo ky iq bd kz nb nc dn ld nd ne dp lh jy nf ng ll kc nh ni lp kg nj nk lt nl bi translated">上下界结论</h2><p id="38e6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们可以恢复上限，使集合<em class="mt">为只读</em>，而下限使其<em class="mt">为只写。这是否意味着我们可以使用它们作为返回类型来限制客户端对数据操作的访问？我不建议这么做。</em></p><p id="4d63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上限集合并不完全是只读的，因为你仍然可以向它们添加。下限集合并不完全是只写的，因为你仍然可以作为一个T1来读取值。我认为使用特殊的容器会更好，这种容器可以提供对实例的访问。你可以使用像<code class="fe mg mh mi mj b">Collections.unmodifiableList</code>这样的标准JDK工具，也可以使用能够完成这项工作的库(例如<a class="ae mu" href="https://docs.vavr.io/#_list" rel="noopener ugc nofollow" target="_blank"> Vavr </a>)。</p><p id="43df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上限和下限集合作为输入参数要好得多。您不应该将它们与返回类型混合在一起。</p><h1 id="0958" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">递归泛型</h1><p id="ce64" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们已经在本文中提到了递归泛型。是<code class="fe mg mh mi mj b">Stream</code>接口。我们再来看看。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">流映射</figcaption></figure><p id="aad9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，<code class="fe mg mh mi mj b">Stream</code>从<code class="fe mg mh mi mj b">BaseStream</code>扩展而来，而<code class="fe mg mh mi mj b">BaseStream</code>是用<code class="fe mg mh mi mj b">Stream</code>本身参数化的。它的原因是什么？让我们深入<code class="fe mg mh mi mj b">BaseStream</code>一探究竟。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">基本流</figcaption></figure><p id="c87e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">BaseStream</code>是<a class="ae mu" href="https://en.wikipedia.org/wiki/Fluent_interface#:~:text=In%20software%20engineering%2C%20a%20fluent,Eric%20Evans%20and%20Martin%20Fowler." rel="noopener ugc nofollow" target="_blank"> fluent API </a>的典型例子，但不是返回类型本身，而是返回方法<code class="fe mg mh mi mj b">S extends BaseStream&lt;T, S&gt;</code>。我们想象一下<code class="fe mg mh mi mj b">BaseStream</code>的设计没有这个功能。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">非递归基本流</figcaption></figure><p id="7539" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它会如何影响整个流API？</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">非递归流API</figcaption></figure><p id="3cd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">reduce</code>方法属于<code class="fe mg mh mi mj b">Stream</code>但不属于<code class="fe mg mh mi mj b">BaseStream</code>接口。因此<code class="fe mg mh mi mj b">parallel</code>返回<code class="fe mg mh mi mj b">BaseStream</code>。所以，<code class="fe mg mh mi mj b">reduce</code>无法找到。这在下面的模式中变得更加清晰。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/78703db6f03a454167a31700036fb2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*TVA3-g0A-dvzEEmgd76xOg.png"/></div></figure><p id="e9a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，递归泛型就派上了用场。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a7a3a9a016d41f0c1c2541b913e634ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*bqvfRz4fDf7hUU2B-F4euA.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">递归流API</figcaption></figure><p id="204e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法允许我们分离接口，从而带来更好的可维护性和可读性。</p><h1 id="1a74" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="3663" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我希望您已经学到了一些关于Java泛型的新知识。如果您有任何问题或建议，请在下面留下您的评论。感谢阅读！</p><h1 id="fc7c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">资源</h1><ul class=""><li id="8c81" class="no np iq jp b jq lv ju lw jy nq kc nr kg ns kk nt nu nv nw bi translated"><a class="ae mu" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" rel="noopener ugc nofollow" target="_blank">协方差</a></li><li id="0643" class="no np iq jp b jq nx ju ny jy nz kc oa kg ob kk nt nu nv nw bi translated"><a class="ae mu" href="https://howtodoinjava.com/java/generics/java-generics-what-is-pecs-producer-extends-consumer-super/" rel="noopener ugc nofollow" target="_blank">胸肌</a></li><li id="3848" class="no np iq jp b jq nx ju ny jy nz kc oa kg ob kk nt nu nv nw bi translated"><a class="ae mu" href="https://docs.vavr.io/#_list" rel="noopener ugc nofollow" target="_blank"> Vavr图书馆</a></li></ul></div></div>    
</body>
</html>