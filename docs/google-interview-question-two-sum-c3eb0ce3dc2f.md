# 谷歌面试问题:两个总和

> 原文：<https://levelup.gitconnected.com/google-interview-question-two-sum-c3eb0ce3dc2f>

这是一个非常受欢迎的面试问题，测试你在编写高效代码方面的知识。理想情况下，有两种方法可以解决这个流行的问题。

![](img/444a1ec6144a8836a01a0fe50e00e265.png)

来源:凯 via【Unsplash.com】

我们得到了一个数字列表以及目标数字，我们需要计算出哪两个数字加到了目标数字上。数字的组合可能存在，也可能不存在。

这个问题可以这样组织:

“假设我们有一个整数数组。我们必须返回两个整数的索引，这样，如果我们把它们加起来，我们将达到一个给定的特定目标。这里我们将做一个假设，即数组中总是有一个唯一的解，因此不会有相同目标的两组索引。

比如，假设数组像 A = [2，8，12，15]，目标和是 20。然后它将返回索引 1 和 2，作为 A[1] + A[2] = 20。"

# 方法一:蛮力

理想情况下，这是我们穷尽所有选择来检查组合是否存在的最简单的方法。

我们将使用两个指针；一个指向列表的第一项，另一个遍历列表。

所以一个指针将指向 2，这是列表中的第一项，也是遍历列表的第二项。我们将检查 2 和 2 的组合，其总和不等于 20，因此我们继续。

下一个组合是 2 和 8，产生 10，但不是真的，我们继续 2 和 12，产生 14，假的。

我们继续下一个项目，我们测试 2 和 15，得到 17，我们寻找 20，我们返回 False，我们已经用尽了 2 的所有组合，我们继续 8。

首先，我们检查 8 和 2 的组合，得到 10，然后继续检查 8 和 8 的组合，得到 16，8 和 12 的组合得到 20。我们已经找到了我们的匹配，并将返回 True。

这相当耗费精力，想象一下，如果我们不得不在一个巨大的数据集上循环多次，而条目却在列表的末尾，会怎么样？因此，该方法返回非常慢的大 O(n)的时间复杂度。

好的一面是，我们没有利用内存，我们的空间复杂度是 O(1)。

尽管如此，让我们编写我们的解决方案:

```
def twoSum(nums,target):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums [j] == target:
                return[i,j]
```

如果有人把这个解决方案扔给我，我不会觉得有趣或印象深刻，事实上我会非常失望。效率非常重要，尤其是在大型科技公司。我宁愿选择更优化的解决方案。

# 方法 2

对于第二种方法，我们只需要一个指针，因为我们将寻求一组数据结构的帮助。

同样的规则也适用于我们搜索两个数字的组合，这两个数字加起来就是目标，在我们的例子中是 20。

我们的集合将保存所有我们“见过”的组合器项目，这将跟踪我们的检查。

我们将从 2 开始，因为这是我们的第一个项目，我们知道我们需要 18 来达到 20 的总和。然后，我们将在集合中保存 18 个。移动到下一个项目 8，我们需要 12 来得到 20 的总数，因此我们将在我们的集合中保存 12。

下一项是 12，但是我们的集合中已经有 12 个了，我们的条件已经满足，我们将返回 True。

让我们编写我们的解决方案:

```
def twoSum(nums,target):
    combinators = {}
    for i in range(len(nums)):
        if target - nums[i] in combinators:
            return True
        else:
            combinators[nums[i]] = i
    test_list = [2,8,12,15]
    print(twoSum(test_list,20))
```

因为我们只在链表中循环一次，所以我们的时间复杂度是 Big O(n ),但是记住我们使用了一个集合，这将把我们的空间复杂度变成 BigO(n)。

# 额外资源

[](https://colab.research.google.com/drive/1JnZ1l_s7CjWPAsVD_OsABaG_cVMGkDA9?usp=sharing) [## 谷歌联合实验室

### 编辑描述

colab.research.google.com](https://colab.research.google.com/drive/1JnZ1l_s7CjWPAsVD_OsABaG_cVMGkDA9?usp=sharing)