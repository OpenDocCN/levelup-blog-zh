# 面向凡人的功能编程—节选

> 原文：<https://levelup.gitconnected.com/functioning-programming-for-mortals-excerpts-41779d16dd5a>

![](img/babcf6111217a2cb20aaa69c5b4a7408.png)

阅读一本有见地的书总是好的，尤其是关于你最喜欢的编程语言的书。说到 Scala，有很多很棒的书籍涵盖了高级概念，比如《Scala 中的函数式编程》(又名《红皮书》)、《Scala with Cats》、《Type aultant ' s Guide to shapelless》，当然还有《面向凡人的函数式编程》。

不幸的是，许多这样的书隐含地要求至少对它们所描述的概念有一些基本的理解。对于初学者来说，这可能特别令人望而生畏，导致人们普遍认为 Scala 是一种“难懂的语言”。这启发我列出一些常见的概念，但不要涉及太多的细节，这样人们可以了解大致的想法，然后从其他资源中广泛地探索它们。

我选择“面向凡人的函数式编程”作为这个列表的基础，因为作为我读过的关于 Scala 的第一本书之一，它为我提供了函数式编程的所有关键概念，我随后能够深入研究这些概念。所有的名字和代码引用都来自使用`scalaz`库的版本，尽管我会尽可能地提供来自`cats`库的替代版本。列出的摘录并不是这本书的文字引用，但是如果你想更详细地研究这本书的各个主题，可以附上几页。

# 第 1 章—简介

`Page 5.`对 ***一元*** 类型的操作允许对顺序执行上下文进行抽象，这可以提供不同的错误处理、状态存储和审计能力。一些一元类型的基本例子包括 Scala 标准库中的`Option`、`List`和`Either`。关于单子是什么的更多细节见第 5.7 节。

`Page 6.`功能编程主要操作 ***纯功能*** 。它们是:

*   ***总计*** —为每个可能的输入返回值(异常不被视为返回值)。
*   ***确定性*** *—* 对于相同的输入，返回值从不改变。
*   ***局部作用域*** —它们不会改变调用者可见的状态。

纯函数允许构造 ***引用透明的*** 表达式，可以直接用它们的返回值替换，而不改变程序的行为。例如，`(5 + 5)`可以在代码中的任何地方替换`10`。

引用透明性通过 ***本地推理*** 提供了更好的代码理解，这意味着您不必在调用点考虑实现细节或副作用。这也意味着重用单独的代码部分要容易得多，因为它们没有到系统其他部分的隐式连接。

# 第 3 章—应用程序设计

`Page 25.`***代数*** 定义了系统特定部分的一组(可能的)副作用交互。这个集合通常以特征的形式出现，该特征定义了具有更高级类型参数`F[_]`的必要方法，该参数通常被称为 ***效果*** *，*所述交互发生的上下文*。*

`Page 27.`一个 ***模块*** 是一个代数的实现，它在`F[_]`上被抽象，只依赖于其他模块、代数和纯函数，通常在`F[_]`上有许多类型类限制。绑定到特定`F[_]`的代数实现被称为**解释器**。有关什么是类型类的详细信息，请参见第 4.2 部分。

`Page 36.`用于测试目的的测试解释器或`F[_]`的特定实现允许安全地替换系统的副作用部分，从而产生更高的测试覆盖率。模块通常比解释器更难编写，但是在编写测试时提供了更大的灵活性。

# 第 4 章—数据和功能

## 4.1 数据

`Page 38.`在函数式编程中数据通常由 ***代数数据类型*** (ADTs)来表示，这是对以下数据的统称:

*   (最终)案例类，其字段为 ADT。这些被称为 ***产品*** *。*
*   密封特征，其所有成员都是 ADT。这些被称为**。**
*   **值，*由 case 对象、“原语”(如整数、字符串)、纯函数组成。*

*从逻辑观点来看，乘积对应于逻辑合取(“具有特性 A 和特性 B 以及特性 C”)，而余积代表析取(“是 A 型还是 B 型还是 C 型”)。*

*带类型参数的 ADT 称为 ***广义代数数据类型***(gadt)。ADT 也可以是递归的通过在它们的定义中引用它们自己。*

*需要强调的是，当依赖于像`equals`这样的方法或像`Serializable`这样的接口时，包含函数的 ADT 可能无法很好地转换成 Java 虚拟机(JVM)。一个好的实践是让 ADT 定义尽可能干净，避免使用内置的 JVM 方法。*

*还要注意，在定义余积时,“密封”修饰符很重要。它不仅明确规定了数据类型不能在程序的其他部分任意扩展，还允许编译器执行额外的检查，甚至通过宏自动生成一些代码。*

*`Page 42.`有时，在 ADT 中包含原始类型可以表示无效状态——一个常见的例子是对只允许正值的字段使用整数。这可以通过定义对原始值应用一组限制的值包装器来解决。这样的包装器俗称**(参见 [*提炼*](https://github.com/fthomas/refined) 库的例子)。***

**`Page 44.`ADT 不应该像常规类或特征那样提供任何方法，它们只是数据的容器。**

> **通过不提供任何功能，ADT 可以有一个最小的依赖集，使它们易于发布并与其他开发人员共享。**

**给定类型可以存在的值的个数称为其***复杂度*** *。***

**`Page 45.`降低函数输入和输出的复杂性有助于支持总体性。保持输出的复杂性小于输入的复杂性是有益的。**

**在许多情况下，可以通过将乘积重写为余乘积来消除不期望的(无效的)状态，从而降低 ADT 的复杂性。**

## **4.2 功能**

**`Page 49.`函数式编程通常依靠**中的*顺序来提供多态功能，这与面向对象编程中的继承相反。类型类是这样的特征:***

*   **保持无状态。**
*   **包含类型参数—应为其提供 typeclass 的类型。这个型号可能是[更高级的](https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html)。**
*   **至少有一个抽象方法。**

**此外，typeclasses 可以:**

*   **包含具有默认实现的方法。**
*   **扩展其他 typeclasses。**

**当需要 typeclass 的实例时，它通常由调用站点的隐式范围提供。理想情况下，不需要显式导入来提供 typeclass 的实例，但这并不总是可行的。更多细节参见[隐式参数文档](https://www.scala-lang.org/files/archive/spec/2.13/07-implicits.html#implicit-parameters)。**

**在形式上，当使用 typeclasses 时，它们需要为每种类型拥有唯一的实例。如果同一个类型有多个实现“有意义”(例如`Ordering`)，那么将各自的特征称为类型类是不正确的。**

# **第 5 章— (Scalaz)类型类**

## ****5.2 可追加的东西****

**`page 70.` `Semigroup[A]` —定义给定类型的关联“组合”操作。例如，字符串有一个带串联操作的`Semigroup`。**

**`Monoid[A]`—`Semigroup`也有一个空元素的概念，当与其他元素组合时没有效果。对于空字符串。**

**`page 71.` `Band[A]` —带有*幂等*运算的`Semigroup`，当组合两个相同的值时，必须返回其参数之一。虽然界面与`Semigroup`没有任何不同，但需要表达意图。`Band`的一个简单例子是对任何固定类型集合的“组合”操作。**

## **5.3 客体**

**`page 74.` `Equal[A]` —定义给定类型成员之间的“相等”运算。必须是:**

*   **可交换的——↔。**
*   **反身的— `a === a`。**
*   **及物— `a === b, b === c` → `a === c`。**

**`page 75.` `Order[A]` —用比较操作扩展`Equal`，最著名的是`<=`。主要用于抽象排序逻辑。**

**`Enum`(`cats-collections`中的`Discrete`)—为每个元素指定“后续元素”和“前置元素”。对于任何整数 *i* ，它的后继者和前趋者将分别是 *i+1* 和 *i-1* 。**

**`page 76.` `Show[A]` —为给定类型提供人类可读的表示。这本质上是对`toString()`方法的替代，消除了覆盖它的需要。**

## **5.4 可映射的事物**

**`page 77.` `Functor[F]` —为更高级类型`F[_]`定义，允许在`F`内改变值，同时保持`F`本身不变。这是通过`map`操作实现的，给定一个函数`f: A => B`将`F[A]`转换为`F[B]`。`List`、`Option`等。有函子。**

**所有函子必须满足以下属性:**

*   **构图:`fa.map(f).map(g) === fa.map(f andThen g)`。**
*   **身份保存:`fa.map(identity) === fa`。**

**破坏这些属性本质上会导致仿函数失去大部分价值，因为应用局部推理和降低程序复杂性变得更加困难。**

**`page 80.` `Foldable[F]` —允许将任何固定`A`的`F[A]`类型的值减少为`A`类型的单个值。请注意，`Foldable`使用`foldRight`方法说明了潜在的无限结构，这是其实现中所必需的。**

**`page 85.` `Traverse[F]` —当`G`有一个`Applicative`的实例时，将任何一个`F[A]`转换为给定函数`f: A => G[B]`的`G[F[B]]`。这也允许实现`sequence`方法:`F[G[A]] => G[F[A]]`。最常见的用例之一是将一个`List[Future[A]]`转换为`Future[List[A]]`，在标准库中使用一个专用的`Future.sequence`方法。有关`Applicative`的更多详情，请参见第 5.7 节。**

**`page 87.` `Align[F]` — `Functor`允许`align`任何`F[A]`和`F[B]`到`F[Ior[A, B]]`，其中`Ior`是包含`A`值、`B`值或两者的结构。例如，对齐两个列表将产生一个新列表，其中每个索引处的元素或者是原始列表的“压缩”元素对(如果该索引同时出现在两个列表中),或者是单个元素(如果它只出现在其中一个列表中)。**

## **5.5 差异**

**`page 89.``InvariantFunctor[F]`(`cats`中的`Invariant[F]`)与`Functor[F]`颇为相似，但其`xmap`方法也需要一个向后的变换`g: B => A`。如果元素之间的双向映射可用，`InvariantFunctor[Semigroup]`的实例将允许定义新的半群。**

**`ContravariantFunctor[F]`(`cats`中的`Contravariant[F]`)—当提供`f: B => A`时，将`F[A]`转换为`F[B]`。虽然不太直观，但逆变仿函数本质上是对函数参数进行操作的。例如，很容易用函数`encode: A => String`为类型`Encoder[A]`创建逆变仿函数。**

**使用这个术语，`Functor`应该被称为`CovariantFunctor`，但是为了简单起见，第一个词通常被省略。**

## **5.6 应用和绑定**

**`page 91.``Apply[F]`——用`ap: F[A => B] => F[A] => F[B]`延伸`Functor`。这个函数的目的可能不会立即清楚，但它从根本上提供了并行执行的能力:由于`F[A => B]`和`F[A]`是完全独立的，只要它们最终组合在一起，它们的求值顺序并不重要。当然，`ap`本身很少见到，但是从它派生的方法为并行计算提供了丰富的 API。**

**`page 94.``Bind[F]`(`cats`中的`FlatMap[F]`)—将`bind: F[A] => (A => F[B]) => F[B]`方法(也称为`flatMap`)添加到`Apply`中，允许“展平”嵌套的`F`结构。注意，与`ap`不同的是，`bind`与顺序执行相关，前者只需要支持顺序行为。**

## **5.7 应用和单子**

**`page 97.` `Applicative[F]` —为`Apply`提供通过`pure: A => F[A]`方法将任意值提升到`F`上下文中的能力。`Applicative`的主要法则是*恒等式*法则:`pure(identity).ap(fa) === fa`，其中`identity`是返回其参数的一元函数。这条定律意味着由`pure`方法创建的值与其他`F[_]`值没有任何不同，对它们没有任何影响。**

**`page 98.` `Monad[F]`是`Bind[F]` ( `FlatMap[F]`)和`Applicative[F]`的组合。它没有提供任何额外的方法，而是以下列 3 条定律的形式施加了额外的限制:**

*   **左身份— `pure(a).bind(f) === f(a)`。**
*   **权利认同— `fa.bind(pure(_)) === fa`。**
*   **关联性— `fa.bind(f).bind(g) === fa.bind(a => f(a).bind(g))`。**

***作者备注:***

*   **`Applicative`和`Monad`的区别在于`FlatMap`规定了顺序行为，所以有些类型不提供`Monad`实例来支持并行执行(见`cats.data.Validated`)。**
*   **`Apply` / `Applicative`和`Bind` ( `FlatMap` ) / `Monad`之间存在区别，因为并非所有类型都能够提供`pure`方法。例如，不可能为`F[A] = Map[String, A]`创建合法的`pure`方法。**

## **5.8 各个击破**

**`page 100.` `Divide[F]` —方法`divide: F[A] => F[B] => (C => (A, B)) => F[C]`的`Apply`的逆变模拟。正如定义所暗示的那样，它旨在与逆变位置的类型一起使用(例如函数参数)。例如，`Divide[Equal]`可以用来为产品创建`Equal`的新实例，产品的元素已经有这样的实例。**

**`page 101.` `Divisible[F]` —一个`Applicative`(扩展`Divide`)的逆变模拟，允许用`conquer[A]: F[A]`创建`F`的通用量化(琐碎)实例。任何序列化器都可以有一个`Divisible`的实例，其中`conquer`将序列化器生成一个空结构。**

## **5.9 以上**

**`page 102.``Plus[F]`(`cats`中的`SemigroupK[F]`)—一个通用的量化模拟`Semigroup`，允许为任何类型`A`添加两个`F[A]`实例。例如，`Plus[List]`允许连接任意两个列表。**

**`PlusEmpty[F]`(`cats`中的`MonoidK[F]`)—扩展`Plus` ( `SemigroupK`)，能够为任何`A`创建“空”值`F[A]`。对于列表，相应的方法将创建一个空列表。**

**`page 104.``ApplicativePlus[F]`(`cats`中的`Alternative[F]`)—扩展`Applicative`和`PlusEmpty` ( `MonoidK`)，同时要求遵守几个附加法律。这个类本身不会增加太多，但是当需要具体的和通用的量化实现时，它非常方便。Cats 文档中有一个很棒的[例子](https://typelevel.org/cats/typeclasses/alternative.html)。**

**`MonadPlus[F]` —扩展`Monad`和`ApplicativePlus`并提供两个额外的方法:**

*   **`unite[T[_]: Foldable, A](ts: F[T[A]]): F[A]` —允许消除任意嵌套结构，如果它们有一个`Foldable`的实例。**
*   **`withFilter[A](fa: F[A])(f: A => Boolean): F[A]` —对`F[A]`应用由函数`f`描述的过滤器，可能以一种懒惰的方式。**

**`cats`中没有`MonadPlus`的直接类比，但是`FunctorFilter[F]` ( `withFilter`)和`Alternative[F]` ( `unite`需要一个`Monad[F]`实例)提供了相同的一套方法。**

## **5.10 孤狼**

**`page 106.``Zip[F]`(`cats`中的`Semigroupal[F]`)—`Divide`的一个不太强大的模拟，它提供了将`F`的两个实例合并为一个的`zip[A](fa: F[A], fb: F[B]): F[(A, B)]`方法。`zip`在`cats`中被称为`product`。**

**`Unzip[F]` —与`Zip`相反的`unzip[A](fab: F[(A, B)]): (F[A], F[B])`方法，允许分割嵌入到效果`F`中的元组来分离效果。包含在`cats`中的`Functor`。**

## **5.11 共同事务**

**`page 109.``Cobind[F]`(`cats`中的`CoflatMap[F]`)—一个带有附加`cobind(fa: F[A])(f: F[A] => B): F[B]` ( `coflatMap`)操作的`Functor`。**

**`page 110.` `Comonad[F]` —用`copoint(fa: F[A]): A` ( `extract`)扩展`Cobind` ( `CoflatMap`)，基本上消除了任何值周围的结构。**

**一个很好的说明`Comonad`是细胞自动机，它根据细胞各自的环境`F[A]`计算新一代`F[B]`细胞，并允许提取每个细胞的值。**

# **第 6 章— (Scalaz)数据类型**

**`page 117.` **持久集合**无论何时修改，都会保留原始集合的副本，因此允许重用这些副本进行数据访问。结构共享至关重要，因为任何修改都会导致整个集合的重建。**

## **6.4 标签**

**`page 127.`不要与精致类型混淆。**

## **6.5 自然转变**

**`page 130.` **自然转换**是类型构造函数`F[_]`和`G[_]`上的函数，定义了一个通用的量化映射:`F[A] => G[A]`用于所有可能的类型`A`。自然转换的一个常见的真实例子是从数据库事务执行上下文`F`到应用程序执行上下文`G`。**

## **6.6 同构**

**`page 131.` **同构**定义了两个类型(或类型构造函数)`A`和`B`之间的相等关系，这意味着对于每个类型为`A`的对象，有且只有一个类型为`B`的相等对象，反之亦然。同构对于自动实例派生特别有用**

## **6.7 集装箱**

**`page 138.``Validation[E, A]`—`Either[E, A]`的模拟，允许误差累积。这被称为**应用行为**，因为`Validation`没有`Monad`实例。当多个错误可能同时发生，并且所有错误都需要向上游传播，而不仅仅是一个错误时，`Validation`非常有用(`Either`行为)。**

**`page 141.`历史上，在 JVM 上创建异常是相当慢的，因为构建 stacktrace 需要资源。有证据表明，对于失败案例，使用`Either`或`Validation`要比使用异常快上千倍。**

**`These[A, B]`(`cats`中的`Ior[A, B]`)表示具有`A`、`B`或两者值的类型，类似于包含逻辑 or。偏向`B`型，等同于`Either`或`Validation`，可用于累积部分错误或警告。**

***作者备注:***

**有趣的是，stacktrace 的生成非常消耗资源，以至于在某些情况下有一个特殊的优化选项可以省略它们。**

**`page 145.` `Const[A, B]` —具有类型`A`的常数值的类型，充当`B`的上下文。在通过`F[_]`抽象的程序中，收集类型为`A`的对象中的元数据或统计数据，并为任何具有`Monoid`实例的`A`提供可应用的行为是非常有用的。**

## **6.8 集合**

**`page 150.` **共递归**是从一个基本状态开始，确定性地生成一系列(可能是无限的)新状态，这与将有限的步骤序列折叠成一个基本状态的递归相反。当使用`Comonad`时，这可能特别有用。**

# **第七章。高级单子**

## **7.1 永远在运动的是未来**

**Scala 标准库中的`page 173.` `Future`是热切的，意味着一旦`Future`的实例被创建，执行就开始。因为`Future`结合了计算定义及其执行，所以调度和结合它们变得不方便。此外，这意味着`Future`是不纯的，因为根据计算是否已经完成，它的实例可以有不同的值。**

**`Future`还有几个性能缺陷:每次调用`flatMap`时，计算的闭包被提交给执行器，潜在地切换线程和执行上下文。这可能会导致很大一部分 CPU 时间花费在调度上，并使顺序工作比使用`Future`的并行工作更快。**

## **7.2 效果和副作用**

**`page 174.`由于函数式编程中的函数是纯函数，因此不允许有副作用，这就提出了在哪里以及如何执行它们的问题。FP 对这个问题的传统回答是**I/O**monads 它会暂停计算，直到显式地运行它们。这样的单子使得副作用在返回类型中显而易见，因此通常只被称为**效果**。**

***作者笔记:***

**具体来说，编写时最常用的 I/O 单子是`cats.effect.IO`、`monix.eval.Task`和`zio.ZIO`。**

## **7.3 烟囱安全**

**`page 175.` Scala 编译器允许创建栈安全**尾递归**方法。`scalaz`和`cats`分别用`BindRec`和`StackSafeMonad`将这个上下文扩展到单子，`bind`和`flatMap`的调用必须只需要常量堆栈空间。**

***作者备注:***

**通过要求提供`tailRecM`方法的实现，堆栈安全被嵌入到`cats`中的`Monad`中。`StackSafeMonad`为明确起见。**

**`page 176.`代数数据类型可用于编码挂起的函数调用，其部分乘积对应于函数自变量。这就是所谓的**教会编码**。它允许为编码函数创建堆栈安全的解释器，代价是存储 ADT 对象需要额外的堆空间。这样的解释器通常基于一个叫做`Free` (monad)的结构，它是`Monad`接口的 ADT 表示。**

**`page 179.`尽管`Free`看起来比不使用对象来表示计算的同等解决方案的性能要差得多，但在现代架构和最新版本的 JVM 上，情况可能并非如此。建议是，在做出最终判断之前，一定要进行基准测试。**

## **7.4 Monad 变压器库**

**`page 180.` **单子变形金刚**在其他单子上面提供额外的效果。最重要的是，它们可以组合在一起产生复杂的效果。提供单子变压器的库通常被称为*单子变压器库* (MTL)。**

**一些较常见的变压器有:**

*   **`OptionT[F[_], A]` —包装`F[Option[A]]`。**
*   **`EitherT[F[_], E, A]` —包装`F[Either[E, A]]`。**
*   **`ReaderT[F[_], A, B]` —包裹`A => F[B]`(也称`Kleisli`)。**
*   **`WriterT[F[_], W, A]` —包装`F[(W, A)]`。**
*   **`StateT[F[_], S, A]` —缠绕`S => F[(S, A)]`。**

***作者笔记:***

**在许多情况下，monad 转换器提供的功能可以由一个类型类来表示。关键的区别在于，monad transformers 允许合成并从本质上改变程序正在使用的效果，而 type 类通过附加功能丰富了基本效果。**

**当用`EitherT`或它的等价类型`MonadError`处理错误时，人们对错误的类型有不同的看法。主要是，它是一个错误的 ADT，`String`，或`Throwable`。建议使用灵活的结构化格式，如 JSON，使错误可扩展，但不要太不透明。**

**`page 192.`虽然`WriterT`可以用来实现日志记录，但经常有人认为日志记录应该需要自己的代数，因为出于性能原因，它通常被不同地处理。**

**`page 202.` `ContT`允许使用延续来链接计算，也就是通常所说的“回调风格”。虽然链接本身并不特别有用，因为它也可以用单子来完成，`ContT`允许重新排序控制流，使其变成非线性的，类似于一个图。**

## **7.5 免费午餐**

**`page 212.` JVM 的 JIT 编译器允许简单函数具有与 C/C++等价函数相当的性能，甚至可能消除垃圾收集的影响。然而，它的能力仍然局限于低级优化。**

**根据元级别上的高级概念描述程序的数据结构将允许应用高级优化。这种构造通常被称为`Free`结构，可以很容易地为程序的代数接口生成。**

**`page 218.`排放指标和运行时分析是少数几个可能会产生直接副作用的案例之一。如果这种监视不影响程序本身，引用透明属性仍然有效。**

# **结论**

**虽然提供的摘录远未涵盖所有函数式编程基础的详尽列表，但它们应该是与现有 Scala 库交互和探索更高级概念的良好基础。**

**我要感谢原书的作者 Sam Halliday 以及`scalaz`、`cats`和`zio`库背后的所有人，他们为 Scala 的生态系统所做的一切，最终激发了我写这篇文章的灵感。**