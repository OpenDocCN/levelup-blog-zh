<html>
<head>
<title>Circular Doubly Linked List and Dancing Links — Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">循环双向链表和浮动链接—打字稿</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/circular-doubly-linked-lists-and-dancing-links-typescript-f37bedfa08c1?source=collection_archive---------2-----------------------#2019-12-29">https://levelup.gitconnected.com/circular-doubly-linked-lists-and-dancing-links-typescript-f37bedfa08c1?source=collection_archive---------2-----------------------#2019-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6508" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我要讲的是如何做一个循环双向链表。然后我将讨论跳舞链接，并向您展示如何在Typescript中构建这两者。</p><p id="a02b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先说什么是循环双向链表。</p><p id="7d5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一种很像单链表的数据结构。它包含了一系列的节点，就像其他的列表一样，这些节点将会指向彼此。所有节点都是相同的，因为它们都有自己的一组属性，这些属性对于每个节点都是相同的。列表本身也只是列表类的一个实例。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1ce571e2c33345525fb054a561e0377a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYnOv6EYvveZoqK4LhuEnA.jpeg"/></div></div></figure><p id="9fa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样的结构有无数的好处。对于初学者来说，可以在两个方向上遍历列表，这可能使您能够比单向链表更快地找到特定的值，因为您可以同时从两端完成搜索。一旦你找到一个节点，你可以从列表中删除它，或者以比数组更快的方式添加。此外，它是最基本的数据结构之一，具有适合跳舞链接的必要属性。</p><p id="1c02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将向您展示实现和一张结构图来开始。如果您想复制并使用这段代码，您可能需要省略每个类前面的导出语句。</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="a370" class="lc ld iq ky b gy le lf l lg lh">export class DCnode {</span><span id="9916" class="lc ld iq ky b gy li lf l lg lh">value:number;</span><span id="3c85" class="lc ld iq ky b gy li lf l lg lh">right:DCnode|null;</span><span id="85b4" class="lc ld iq ky b gy li lf l lg lh">left:DCnode|null;</span><span id="4e78" class="lc ld iq ky b gy li lf l lg lh">accessed:boolean;</span><span id="ba3d" class="lc ld iq ky b gy li lf l lg lh">constructor(value:number) {</span><span id="c2a6" class="lc ld iq ky b gy li lf l lg lh">this.value = value;</span><span id="c2a1" class="lc ld iq ky b gy li lf l lg lh">this.right = null;</span><span id="03c2" class="lc ld iq ky b gy li lf l lg lh">this.left = null;</span><span id="c940" class="lc ld iq ky b gy li lf l lg lh">this.accessed = false;</span><span id="fe93" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="f51d" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="d952" class="lc ld iq ky b gy li lf l lg lh">export class DCLL {</span><span id="f460" class="lc ld iq ky b gy li lf l lg lh">head:DCnode|null</span><span id="ba73" class="lc ld iq ky b gy li lf l lg lh">constructor(){</span><span id="a69b" class="lc ld iq ky b gy li lf l lg lh">this.head = null;</span><span id="d143" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="2960" class="lc ld iq ky b gy li lf l lg lh">appendDCnode:Function = (value:number) =&gt; {</span><span id="3c3f" class="lc ld iq ky b gy li lf l lg lh">if(this.head == null) {</span><span id="4cd3" class="lc ld iq ky b gy li lf l lg lh">let a:DCnode = new DCnode(value)</span><span id="fb4f" class="lc ld iq ky b gy li lf l lg lh">this.head = a;</span><span id="b68b" class="lc ld iq ky b gy li lf l lg lh">a.left = a;</span><span id="1b21" class="lc ld iq ky b gy li lf l lg lh">a.right = a;</span><span id="5362" class="lc ld iq ky b gy li lf l lg lh">} else {</span><span id="15af" class="lc ld iq ky b gy li lf l lg lh">let b:DCnode|null = this.head</span><span id="3190" class="lc ld iq ky b gy li lf l lg lh">while (b.right != this.head) {</span><span id="93b7" class="lc ld iq ky b gy li lf l lg lh">b = b.right;</span><span id="dbd6" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="275c" class="lc ld iq ky b gy li lf l lg lh">let c:DCnode|null = new DCnode(value)</span><span id="e3fe" class="lc ld iq ky b gy li lf l lg lh">b.right = c</span><span id="690f" class="lc ld iq ky b gy li lf l lg lh">this.head.left = c</span><span id="f93f" class="lc ld iq ky b gy li lf l lg lh">c.right = this.head</span><span id="4a36" class="lc ld iq ky b gy li lf l lg lh">c.left = b</span><span id="217e" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="7910" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="71d1" class="lc ld iq ky b gy li lf l lg lh">deleteDCNode:Function = (target:number) =&gt; {</span><span id="bf0c" class="lc ld iq ky b gy li lf l lg lh">if(this.head == null) {</span><span id="bb9f" class="lc ld iq ky b gy li lf l lg lh">return "The list is empty"</span><span id="457e" class="lc ld iq ky b gy li lf l lg lh">} else if (this.head.value == target) {</span><span id="c82c" class="lc ld iq ky b gy li lf l lg lh">if (this.head.left == this.head) {</span><span id="6f92" class="lc ld iq ky b gy li lf l lg lh">this.head = null</span><span id="91fb" class="lc ld iq ky b gy li lf l lg lh">} else {</span><span id="a350" class="lc ld iq ky b gy li lf l lg lh">let a:DCnode|null = this.head.left</span><span id="1e66" class="lc ld iq ky b gy li lf l lg lh">let b:DCnode|null = this.head.right</span><span id="988f" class="lc ld iq ky b gy li lf l lg lh">a.right = b</span><span id="01f8" class="lc ld iq ky b gy li lf l lg lh">b.left = a</span><span id="54f9" class="lc ld iq ky b gy li lf l lg lh">this.head = b</span><span id="4d7e" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="0271" class="lc ld iq ky b gy li lf l lg lh">} else {</span><span id="dc9b" class="lc ld iq ky b gy li lf l lg lh">let a:DCnode|null = this.head.left</span><span id="aab7" class="lc ld iq ky b gy li lf l lg lh">let b:DCnode|null = this.head.right</span><span id="471b" class="lc ld iq ky b gy li lf l lg lh">this.head.accessed = true;</span><span id="cc42" class="lc ld iq ky b gy li lf l lg lh">while (a.accessed == false &amp;&amp; a.value != target &amp;&amp; b.value != target) {</span><span id="30b7" class="lc ld iq ky b gy li lf l lg lh">a = a.left</span><span id="7c6a" class="lc ld iq ky b gy li lf l lg lh">b = b.right</span><span id="a6ce" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="9cbf" class="lc ld iq ky b gy li lf l lg lh">if (a.value == target) {</span><span id="870d" class="lc ld iq ky b gy li lf l lg lh">let p:DCnode|null = a.left</span><span id="76be" class="lc ld iq ky b gy li lf l lg lh">let f:DCnode|null = a.right</span><span id="a61b" class="lc ld iq ky b gy li lf l lg lh">p.right = f</span><span id="f513" class="lc ld iq ky b gy li lf l lg lh">f.left = p</span><span id="cdd8" class="lc ld iq ky b gy li lf l lg lh">this.head.accessed = false;</span><span id="f01e" class="lc ld iq ky b gy li lf l lg lh">return a</span><span id="eb63" class="lc ld iq ky b gy li lf l lg lh">} else if (b.value == target) {</span><span id="83da" class="lc ld iq ky b gy li lf l lg lh">let p:DCnode|null = b.left</span><span id="617b" class="lc ld iq ky b gy li lf l lg lh">let f:DCnode|null = b.right</span><span id="0373" class="lc ld iq ky b gy li lf l lg lh">p.right = f</span><span id="147a" class="lc ld iq ky b gy li lf l lg lh">f.left = p</span><span id="0565" class="lc ld iq ky b gy li lf l lg lh">this.head.accessed = false;</span><span id="57a1" class="lc ld iq ky b gy li lf l lg lh">return b</span><span id="d987" class="lc ld iq ky b gy li lf l lg lh">} else {</span><span id="ba8c" class="lc ld iq ky b gy li lf l lg lh">return "The list has been searched and the value has not been found"</span><span id="e68c" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="a54d" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="9430" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="18d8" class="lc ld iq ky b gy li lf l lg lh">displayList:Function = () =&gt; {</span><span id="4179" class="lc ld iq ky b gy li lf l lg lh">let output: number[] = [];</span><span id="3460" class="lc ld iq ky b gy li lf l lg lh">if (this.head == null) {</span><span id="e0c7" class="lc ld iq ky b gy li lf l lg lh">return "The List is Empty"</span><span id="2152" class="lc ld iq ky b gy li lf l lg lh">} else {</span><span id="19d2" class="lc ld iq ky b gy li lf l lg lh">let a:DCnode|null = this.head.right</span><span id="e525" class="lc ld iq ky b gy li lf l lg lh">this.head.accessed = true</span><span id="1d59" class="lc ld iq ky b gy li lf l lg lh">output.push(this.head.value)</span><span id="b6be" class="lc ld iq ky b gy li lf l lg lh">while (a.accessed == false) {</span><span id="3d85" class="lc ld iq ky b gy li lf l lg lh">output.push(a.value)</span><span id="2827" class="lc ld iq ky b gy li lf l lg lh">a = a.right</span><span id="9c13" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="2986" class="lc ld iq ky b gy li lf l lg lh">console.log("complete")</span><span id="922b" class="lc ld iq ky b gy li lf l lg lh">return output</span><span id="6100" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="8278" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="7691" class="lc ld iq ky b gy li lf l lg lh">}</span></pre><p id="bcf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你读过我的单链表博客，这应该对你来说很简单。我还将按照与上次相同的步骤进行操作。</p><p id="510b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉单链表，我建议你在开始学习之前先熟悉一下。</p><h1 id="1746" class="lj ld iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">仅仅是基础知识</strong></h1><p id="fa40" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">首先，我们需要一个列表类和一个节点类。</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="3342" class="lc ld iq ky b gy le lf l lg lh">class DCnode {<br/>}</span><span id="9ca9" class="lc ld iq ky b gy li lf l lg lh">class DCLL {<br/>}</span></pre><p id="0dcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DC代表双向循环，LL代表链表，如果你想知道的话。</p><p id="66dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的节点将至少有一个值，访问布尔，一个右属性，和一个左属性。</p><p id="640f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的列表只有一个head属性。</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="819c" class="lc ld iq ky b gy le lf l lg lh">class DCnode {<br/>right: DCnode | null;<br/>left: DCnode | null;<br/>value: number;<br/>accessed: boolean;</span><span id="7c48" class="lc ld iq ky b gy li lf l lg lh">constructor (value:number) {<br/>this.right = null;<br/>this.left = null;<br/>this.value = value;<br/>this.accessed = false;</span><span id="f17a" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="9bc3" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="d554" class="lc ld iq ky b gy li lf l lg lh">class DCLL {<br/>head: DCnode | null;</span><span id="11af" class="lc ld iq ky b gy li lf l lg lh">constructor () {<br/>this.head = null;</span><span id="b659" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="f802" class="lc ld iq ky b gy li lf l lg lh">}</span></pre><p id="5cea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，现在我们已经准备好开始一些最基本的功能了。这将包括删除节点和添加节点。</p><h1 id="90b4" class="lj ld iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">插入一个节点</strong></h1><p id="0faa" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我们插入一个节点的方式将看起来非常类似于我们的单链表。我们要检查头部是否为空。如果头为空，则列表为空。否则我们需要找到尾部并追加节点。</p><p id="767e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，由于这是一个循环双向链表，我们必须为追加的节点设置right和left属性，以及前一个节点的right属性和后一个节点的left属性。</p><p id="91af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我在做一个简单的实现，所以我只在列表的末尾插入一个节点，新的尾部总是指向头部。同样，头部将总是指向新的尾部。</p><p id="f3d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，当列表中只有一个节点时，列表看起来会很奇怪，因为属性会循环引用同一个节点。</p><div class="km kn ko kp gt ab cb"><figure class="ml kq mm mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/b3e2fb43076a25335990e2a75acd1c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*jRmjn1zsvpeX5fIlUbojvQ.jpeg"/></div></figure><figure class="ml kq mr mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/390f07107b59d7c958184e78b0d99cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*P8ScEwH368HwkMlC_YSzgg.jpeg"/></div></figure><figure class="ml kq ms mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/ef1e4d0e21bfdc9a55fab2976cea0857.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*VbPh81DyB4MCYwCJIlXl4g.jpeg"/></div></figure></div><p id="cd43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些图片应该有助于我们在实际编码之前理解逻辑。一个只有一个节点的列表会用它的左右属性指向它自己。</p><p id="b1f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了插入一个节点，我们可以简单地遍历列表，向一个方向移动，直到列表中的下一个节点指向头部。我们将以与单向链表相同的方式遍历该结构。将head节点设置为一个tracker变量，然后迭代直到tracker变量。权”属性指向头部。</p><p id="ad97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后让它的right属性引用新的节点而不是head。然后将新节点的left属性设置为旧的tail。然后将新尾部的右边属性赋给头部，最后将头部的左边属性赋给新尾部。</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="ecfe" class="lc ld iq ky b gy le lf l lg lh">appendDCnode:Function = (value:number) =&gt; {</span><span id="84eb" class="lc ld iq ky b gy li lf l lg lh">if(this.head == null) {</span><span id="801e" class="lc ld iq ky b gy li lf l lg lh">let a:DCnode = new DCnode(value)</span><span id="4064" class="lc ld iq ky b gy li lf l lg lh">this.head = a;</span><span id="a9d3" class="lc ld iq ky b gy li lf l lg lh">a.left = a;</span><span id="e25b" class="lc ld iq ky b gy li lf l lg lh">a.right = a;</span><span id="c54e" class="lc ld iq ky b gy li lf l lg lh">} else {</span><span id="d2d2" class="lc ld iq ky b gy li lf l lg lh">let b:DCnode|null = this.head</span><span id="5dfe" class="lc ld iq ky b gy li lf l lg lh">while (b.right != this.head) {</span><span id="0428" class="lc ld iq ky b gy li lf l lg lh">b = b.right;</span><span id="b6cc" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="b02c" class="lc ld iq ky b gy li lf l lg lh">let c:DCnode|null = new DCnode(value)</span><span id="9af8" class="lc ld iq ky b gy li lf l lg lh">b.right = c</span><span id="d7d1" class="lc ld iq ky b gy li lf l lg lh">this.head.left = c</span><span id="d6d3" class="lc ld iq ky b gy li lf l lg lh">c.right = this.head</span><span id="4cee" class="lc ld iq ky b gy li lf l lg lh">c.left = b</span><span id="de94" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="da92" class="lc ld iq ky b gy li lf l lg lh">}</span></pre><h1 id="25da" class="lj ld iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">删除一个节点</strong></h1><p id="2464" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">幸运的是，在我看来，从循环双向链表中删除一个节点比从双向链表或单向链表中删除一个节点更容易。</p><p id="3348" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以只在一个方向上遍历列表，直到找到含有我们想要的值的节点，但是如果我们那样做，我们也可以只构建一个单向链表。</p><p id="a504" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用双向链表的强大功能，我们将使用两个变量同时双向遍历链表，以跟踪我们正在搜索的节点。如果任一跟踪器变量的值与目标值匹配，则循环将停止。</p><p id="5881" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，每当我用delete函数开始在列表中搜索时，我都将在头部左右各一步的节点处开始迭代，同时将头部的accessed属性设置为true。</p><p id="db04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，如果值不在列表中，循环将在再次访问头时停止。</p><p id="7be4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的是，一旦我找到了包含我想要删除的值的节点，就像单链表一样，我们需要改变前一个和后一个节点的指针来跳过被删除的节点，使得目标节点不可访问。让我们参考我们的图纸，这样我们可以确保我们有逻辑涵盖。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/e7b4981360a45f892231e2e65be8d7d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdivS_YpnRJujm78NE5oWg.jpeg"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/2b2a8e348bdf35d79cfec208da98cc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4TKhUEVHYDqhyz7pBswe9g.jpeg"/></div></div></figure><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="54a9" class="lc ld iq ky b gy le lf l lg lh">deleteDCNode:Function = (target:number) =&gt; {</span><span id="e589" class="lc ld iq ky b gy li lf l lg lh">if(this.head == null) {</span><span id="75bf" class="lc ld iq ky b gy li lf l lg lh">return "The list is empty"</span><span id="cf15" class="lc ld iq ky b gy li lf l lg lh">} else if (this.head.value == target) {</span><span id="c548" class="lc ld iq ky b gy li lf l lg lh">if (this.head.left == this.head) {</span><span id="b431" class="lc ld iq ky b gy li lf l lg lh">this.head = null</span><span id="eb8b" class="lc ld iq ky b gy li lf l lg lh">} else {</span><span id="5c1b" class="lc ld iq ky b gy li lf l lg lh">let a:DCnode|null = this.head.left</span><span id="d2a7" class="lc ld iq ky b gy li lf l lg lh">let b:DCnode|null = this.head.right</span><span id="0425" class="lc ld iq ky b gy li lf l lg lh">a.right = b</span><span id="5bd2" class="lc ld iq ky b gy li lf l lg lh">b.left = a</span><span id="4aec" class="lc ld iq ky b gy li lf l lg lh">this.head = b</span><span id="8c45" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="e2bd" class="lc ld iq ky b gy li lf l lg lh">} else {</span><span id="7faf" class="lc ld iq ky b gy li lf l lg lh">let a:DCnode|null = this.head.left</span><span id="087f" class="lc ld iq ky b gy li lf l lg lh">let b:DCnode|null = this.head.right</span><span id="0a49" class="lc ld iq ky b gy li lf l lg lh">this.head.accessed = true;</span><span id="80a4" class="lc ld iq ky b gy li lf l lg lh">while (a.accessed == false &amp;&amp; a.value != target &amp;&amp; b.value != target) {</span><span id="caba" class="lc ld iq ky b gy li lf l lg lh">a = a.left</span><span id="c6b7" class="lc ld iq ky b gy li lf l lg lh">b = b.right</span><span id="d427" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="f64f" class="lc ld iq ky b gy li lf l lg lh">if (a.value == target) {</span><span id="44fa" class="lc ld iq ky b gy li lf l lg lh">let p:DCnode|null = a.left</span><span id="8763" class="lc ld iq ky b gy li lf l lg lh">let f:DCnode|null = a.right</span><span id="b774" class="lc ld iq ky b gy li lf l lg lh">p.right = f</span><span id="83f7" class="lc ld iq ky b gy li lf l lg lh">f.left = p</span><span id="4a19" class="lc ld iq ky b gy li lf l lg lh">this.head.accessed = false;</span><span id="cd31" class="lc ld iq ky b gy li lf l lg lh">return a</span><span id="71d5" class="lc ld iq ky b gy li lf l lg lh">} else if (b.value == target) {</span><span id="5313" class="lc ld iq ky b gy li lf l lg lh">let p:DCnode|null = b.left</span><span id="49ab" class="lc ld iq ky b gy li lf l lg lh">let f:DCnode|null = b.right</span><span id="fccc" class="lc ld iq ky b gy li lf l lg lh">p.right = f</span><span id="2c72" class="lc ld iq ky b gy li lf l lg lh">f.left = p</span><span id="5080" class="lc ld iq ky b gy li lf l lg lh">this.head.accessed = false;</span><span id="1640" class="lc ld iq ky b gy li lf l lg lh">return b</span><span id="f3ca" class="lc ld iq ky b gy li lf l lg lh">} else {</span><span id="7b7e" class="lc ld iq ky b gy li lf l lg lh">return "The list has been searched and the value has not been found"</span><span id="77fb" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="3f1e" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="2b53" class="lc ld iq ky b gy li lf l lg lh">}</span></pre><p id="02f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逻辑如下:</p><p id="03cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">找到候选节点，通过其左右属性引用候选节点的邻居。然后，告诉考生的左的右的属性引用右邻。反过来，告诉候选人的右的左属性引用左邻居。</p><p id="be40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，邻居的邻接属性跳过候选，从列表中删除其相对存在。</p><p id="c6c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能注意到我改变了链表，但也返回了我们已经删除的节点。通常你不需要这样做，但我是，你也应该养成这样的习惯，因为只要我们有办法跟踪我们已经删除的节点，我们就可以实现跳舞链接。</p><p id="6c54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经完成了循环双向链表的最小功能，让我告诉你关于跳舞链接的事情。</p><p id="6fe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">跳舞环节</strong></p><p id="d5df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1979年，一松浩史和T2发现了跳舞环节。您可能已经注意到，当我们从列表中删除一个节点时，被删除的节点仍然具有向外引用的属性。</p><p id="62ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使该节点相对于列表不存在，列表相对于被删除的节点仍然存在。因为我们通过创建一个引用它的变量来保存被删除的节点，所以我们可以通过被删除节点的属性来访问这个列表。</p><p id="18f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管我们从列表中删除了多少个节点，也不管它们的组合或顺序如何，都是如此。我们可以从一个大列表中删除1000个节点，这些节点会以一种混乱的方式引用列表中的位置。</p><p id="45ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如说。观察这个列表，它有几个被删除的节点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/ab5bf40b2eda1f73ddc1e838dbc9e04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTk8SoVIyVBSuTRIW-qmbQ.jpeg"/></div></div></figure><p id="5795" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们以删除节点的相反顺序恢复删除节点的引用，我们可以完美地恢复列表。无论删除了多少次，都是如此。这在处理需要回溯的复杂算法时特别有用和有效，但我将把回溯留到另一篇博客中。</p><p id="c9c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我已经解释了跳舞链接，让我告诉你如何用我们已经做好的循环双向链表来实现它。</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="2fe8" class="lc ld iq ky b gy le lf l lg lh">let dCLL:DCLL = new DCLL</span><span id="5fcb" class="lc ld iq ky b gy li lf l lg lh">let listentry:number = 0</span><span id="9190" class="lc ld iq ky b gy li lf l lg lh">while (listentry &lt; 100) {</span><span id="c3a8" class="lc ld iq ky b gy li lf l lg lh">dCLL.appendDCnode(listentry)</span><span id="9c05" class="lc ld iq ky b gy li lf l lg lh">listentry += 1</span><span id="603c" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="28cc" class="lc ld iq ky b gy li lf l lg lh">console.log(dCLL.displayList())</span><span id="e514" class="lc ld iq ky b gy li lf l lg lh">let y:number[] = math.primeSieve(100)</span><span id="4f52" class="lc ld iq ky b gy li lf l lg lh">let j:Array&lt;DCnode | null&gt; = [];</span><span id="71a1" class="lc ld iq ky b gy li lf l lg lh">for (let i:number = 0; i &lt; y.length; i++) {</span><span id="43b8" class="lc ld iq ky b gy li lf l lg lh">let a:DCnode | null = dCLL.deleteDCNode(y[i])</span><span id="faf6" class="lc ld iq ky b gy li lf l lg lh">j.unshift(a)</span><span id="0534" class="lc ld iq ky b gy li lf l lg lh">console.log(a.value)</span><span id="e1e7" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="84e7" class="lc ld iq ky b gy li lf l lg lh">console.log(dCLL.displayList())</span><span id="730c" class="lc ld iq ky b gy li lf l lg lh">for (let i:number = 0; i&lt; j.length; i++) {</span><span id="18ab" class="lc ld iq ky b gy li lf l lg lh">let a:DCnode|null = j[i]</span><span id="8c30" class="lc ld iq ky b gy li lf l lg lh">let p:DCnode|null = a.left</span><span id="a3fa" class="lc ld iq ky b gy li lf l lg lh">let f:DCnode|null = a.right</span><span id="b6b5" class="lc ld iq ky b gy li lf l lg lh">p.right = a</span><span id="acef" class="lc ld iq ky b gy li lf l lg lh">f.left = a</span><span id="9c98" class="lc ld iq ky b gy li lf l lg lh">}</span><span id="8b17" class="lc ld iq ky b gy li lf l lg lh">console.log(dCLL.displayList())</span></pre><p id="b0d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这段代码中，我实例化了一个新的循环双向链表。然后我用从0到99的100个值填充它。我正在使用我的display values函数，以便在命令行上更容易看到这一点。My display value函数以数组的方式显示列表中的项目，但是它的值仍然与列表的结构严格相关。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/c2fb6e922e810a2b27f8c5ef1844ba6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*9u1ZJn5gYw-bgYsYt187zw.jpeg"/></div></figure><p id="c4e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我用质数筛找出所有小于100的质数。然后我遍历质数数组，用质数值搜索我的双向链表，从链表中删除每个质数。</p><p id="9928" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我在循环双向链表上调用display values时，它向我显示了以下内容，现在只有复合值保留在链表中:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/58e607083b6e4fc7a16e7e595406d950.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*oivlKYbOCqEz-iXxJqhJww.jpeg"/></div></figure><p id="5e03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，所有的质数都被删除了。</p><p id="ef3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还将每次删除的返回节点放入一个单独的数组中，该数组跟踪我的删除。注意，我使用的是unshift方法，它将每个删除顺序地推到数组的前面。这样，当我想恢复列表时，我可以从前到后遍历删除数组。</p><p id="8148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我的删除顺序数组的样子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/d92fc7225f1e777ea62c21cc9cd9c906.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*8JA0a2rt0ZQ-MUrdPLEDhQ.jpeg"/></div></figure><p id="8e61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以清楚地看到，我的删除数组按照我期望的顺序包含了我删除的节点。</p><p id="6994" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">97是0-99列表中的最后一个质数。我们可以看到97节点在数组的前面，它的right属性仍然引用98节点。</p><p id="fc86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在轮到造钱者了。在我的dancing links代码片段的最后一个for循环中，我遍历了被删除的节点数组，并通过写出一个与destroy语句非常相似的restoring语句，以与它们的破坏相反的顺序恢复它们的链接。</p><p id="5462" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想补充的是，在我的代码中，我一直这样做，所以每个“p”变量代表前一个节点，每个“f”变量代表后一个节点。这样我就可以演示这个步骤了。</p><p id="e68a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在每一次删除中，我都写道</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="0fa3" class="lc ld iq ky b gy le lf l lg lh">p.right = f<br/>f.left = p</span></pre><p id="888e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在每一次修复中:</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="d5bb" class="lc ld iq ky b gy le lf l lg lh">p.right = [deleted node]<br/>f.left = [deleted node]</span></pre><p id="c6f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是唐纳德·克努特的新书所描述的。《计算机编程艺术》第4卷，第5分册。</p><p id="889f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在恢复之后，我可以使用我的显示功能来查看我的列表已经被完美地恢复了。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/c2fb6e922e810a2b27f8c5ef1844ba6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*9u1ZJn5gYw-bgYsYt187zw.jpeg"/></div></figure><p id="9533" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你自己试试吧。这是一个启发性的项目，我喜欢它的每一秒钟。下次见。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><div class="km kn ko kp gt nh"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">编写面试问题</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">技术开发</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kv nh"/></div></div></a></div></div></div>    
</body>
</html>