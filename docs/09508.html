<html>
<head>
<title>Big O Unity Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O单位优化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/big-o-unity-optimization-e5cb3f20ed1a?source=collection_archive---------17-----------------------#2021-08-16">https://levelup.gitconnected.com/big-o-unity-optimization-e5cb3f20ed1a?source=collection_archive---------17-----------------------#2021-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="633a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Unity中任何项目开发的重要部分是项目分析，以检查性能问题和优化。优化的核心是大o。</p><p id="6f93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大O表示法是一种表达算法所需的许多步骤之间的关系的方法，这些步骤与输入数据的大小有关，换句话说，就是算法有多复杂。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7a12a0b85a5ba996b36bbfb2134295c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kwf-NbjjLNwvmypOEOHKyw.png"/></div></div></figure><blockquote class="kx ky kz"><p id="98e8" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">理解Unity中的大O符号</p></blockquote><p id="752a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大O符号是衡量算法效率的一种方式。它允许我们理解我们代码的时空复杂性。</p><p id="d66b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理解大O最好的例子是当你有一个很大的项目列表，你想在列表中找到一个项目。对于非常小的列表，使用for /foreach循环很快，但是当列表增长时，您的性能将开始受到影响。</p><p id="cc4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="la"> O of N </em> </strong></p><p id="f3b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这被称为O/N，其中N是您必须过滤的数据量。最好的情况是O/1，其中1是列表中的第一个项目。最坏的情况是N是列表中的最后一项。因此，如果您有100个项目，并且您需要的项目在第90个槽中，使用for循环将花费您90次迭代，直到您找到您需要的项目，这是非常低效的。这被称为线性搜索。</p><blockquote class="kx ky kz"><p id="7ae9" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">大二分搜索法</p></blockquote><p id="d696" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二分搜索法是大列表的解决方案，它是在大列表中找到你的项目的有效算法。它也被称为半间隔搜索或二进制斩波。</p><p id="08ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，算法会将你的列表减半，并继续减半，直到它使用O/1(最好的情况)而不是O/n找到你需要的项目。</p><p id="a2d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个非常重要的步骤是首先对你的列表进行排序。</p><blockquote class="kx ky kz"><p id="8718" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">例子</p></blockquote><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="fdc5" class="lj lk iq lf b gy ll lm l ln lo">int[] ages = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};</span></pre><p id="2d45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，列表已经排序，假设我们需要找到int 4。</p><p id="e403" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用二分搜索法，首先我们半数组:</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="984e" class="lj lk iq lf b gy ll lm l ln lo">//length of array (10) / 2 = 5</span></pre><p id="3a08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以数组的中间是5，所以我们检查4是否大于5，不，所以5右边的一半将不再使用，我们将使用5的左边。</p><p id="3be9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以新名单是:</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="46a6" class="lj lk iq lf b gy ll lm l ln lo">1, 2, 3, 4, 5</span></pre><p id="2df0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再来一遍，再对半新列表，我们检查4在哪边。在这里，它位于右侧，因此我们再次将列表减半，我们将保留一个新数组:</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="a4b9" class="lj lk iq lf b gy ll lm l ln lo">4, 5</span></pre><p id="e146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个最终列表中，4是列表中的第一项，也就是1的O。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lp"><img src="../Images/7b7b187649578ccfa34e51760a8b7d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_H0mZTCvd7DREu7B25hsw.png"/></div></div></figure><p id="e7de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们的列表很大时，使用这种算法比使用普通的for循环来查找条目更有效。所以二分搜索法的时间复杂度，每次我们把数组减半，比普通的循环要简单得多。分而治之。</p><p id="a187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个算法也被称为O(Log n):将一个列表减半。</p><p id="554e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一篇文章中，我们将更深入地探讨大o。</p></div></div>    
</body>
</html>