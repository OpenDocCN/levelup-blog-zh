<html>
<head>
<title>A Small GUI Application Based on Computer Vision and Python Imaging Libraries Using OpenCV and Tkinter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个基于计算机视觉和Python图像库的小型GUI应用程序，使用OpenCV和Tkinter</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-small-gui-application-based-on-computer-vision-and-python-imaging-libraries-using-opencv-e07b3f8c06c1?source=collection_archive---------7-----------------------#2020-06-02">https://levelup.gitconnected.com/a-small-gui-application-based-on-computer-vision-and-python-imaging-libraries-using-opencv-e07b3f8c06c1?source=collection_archive---------7-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/efe3eba62bd63ab40adfcd7f72dbc11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEaIRrjfu9SkFywD1PD89g.jpeg"/></div></div></figure><div class=""/><p id="4e17" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近，我们讨论了计算机视觉及其应用。安全系统已经成为计算机视觉的一个主要应用领域。它已经在基于人脸识别的智能锁系统等技术中得到应用，并被用于在用户不在时保护某些系统的安全。</p><p id="39ab" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我们将设计一个小的GUI应用程序来实现一个小规模的安全系统，以保证我们的系统安全，并在我们不在的时候监控它。我们将为我们的目的实现面部和眼睛检测机制。人脸检测已经成为计算机视觉应用领域中一个非常热门的问题。因此，已经设计了几种现成的方法来处理这个问题。其中之一是使用哈尔级联。我们将实现这个方法。对于应用程序的开发，我们将使用PILLOW和OpenCV等Python库。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi kz"><img src="../Images/8b3ce983efbde73c22009b904651ed23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_9zRrwhJt1cGHUXFlqzMg.jpeg"/></div></div></figure><p id="fd1b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于GUI部分，我们将使用Python Tkinter库。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi le"><img src="../Images/8b7b917ba4bf658fe1d9a8a4918ed82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*h3Ueg4V-w331WJghdmODXw.jpeg"/></div></figure><p id="aef6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在讨论应用程序之前，让我们先来探索一下OpenCV和Haar Cascades。OpenCV是一个计算机视觉和机器学习软件库，旨在为计算机视觉应用提供一个公共基础设施，并加速机器感知在商业产品中的使用。这是一个开源库，它的代码很容易获得，并且可以根据用途进行修改。现在，让我们把注意力集中在哈尔喀斯喀特。这将是我们要做的应用程序的核心。</p><p id="97a6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用基于Haar特征的级联分类器的目标检测是由Paul Viola和Michael Jones在2001年的论文“使用简单特征的增强级联的快速目标检测”中提出的一种有效的目标检测方法。这是一种基于机器学习的方法，其中在使用大量正面和负面图像对分类器进行训练之后，使用分类器来检测某些对象。正图像表示包含我们希望分类器分类的对象图像的图像，负图像表示不包含的图像。在我们的例子中，我们希望我们的分类器能够预测和检测人脸和眼睛。</p><p id="71a5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哈尔级联被表示为分类器的级联。最终分类器是弱分类器的加权和。这些弱分类器不能单独对一幅图像进行分类，而是共同组成一个强分类器。我们知道，在卷积的情况下，核是在训练期间设计的，但这里它们有一组固定的哈尔特征或滤波器，应用于训练图像以从中提取特征。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/68c6abf30c0ab3a49f3cd37f7dc191ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*AeAYGJkO_tNhjhI0ajFwTQ.png"/></div></figure><p id="533d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些不同大小的过滤器或内核在图像上通过，并从图像中提取大量用于对目标对象进行分类的特征。OpenCV有一个训练器和一个探测器，可以使用哈尔级联。<a class="ae lg" href="https://github.com/opencv/opencv/tree/master/data/haarcascades" rel="noopener ugc nofollow" target="_blank">此处的链接</a>可用于下载包含所有哈尔瀑布的主分支。对于我们的应用程序，我们需要<a class="ae lg" href="https://github.com/opencv/opencv/blob/master/data/haarcascades/haarcascade_frontalcatface.xml" rel="noopener ugc nofollow" target="_blank">Haar scade _ frontalcatface . XML</a>和<a class="ae lg" href="https://github.com/opencv/opencv/blob/master/data/haarcascades/haarcascade_eye.xml" rel="noopener ugc nofollow" target="_blank">Haar scade _ eye . XML</a>Haar scade文件。</p><h2 id="2e80" class="lh li je bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">我们的应用</h2><p id="1a2b" class="pw-post-body-paragraph kb kc je kd b ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky im bi translated">现在，让我们跳到我们的应用程序。正如我们已经看到的，它是一种安全应用程序。比方说，你在办公室、图书馆或公共场所工作，你去了某个地方，让你的设备在短时间内无人看管，我说的设备是指笔记本电脑或台式机。现在，如果有人试图在你的设备上做一些改变，或者试图窥探你正在做的事情，你可能需要知道。这就是我们的应用程序的切入点。它旨在捕捉您不在时对您的设备进行的任何移动或更改。</p><p id="c5bd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，问题是它是如何工作的？好了，我们开始吧。它在一个计时器上工作，这个计时器是你在启动应用程序时设置的。比方说，我们将计时器设置为10秒。因此，该应用程序被设计为每10秒捕捉一张图像并检查一张脸。如果发现人脸，它会尝试寻找眼睛。这是因为侧面人脸经常被捕获和分类，但我们不想要这些。所以，在找到脸和眼睛之前，它会一直拒绝这个图像。如果它被发现，它开始点击屏幕截图，每次它检测到眼睛。如果截图反映了任何变化，它也开始保存截图。它在每个图像的角落提供时间细节以保持跟踪。它维护一个定时器文件，帮助它比较两个截图。您还可以集成一个警报系统，如果截图中有变化，该系统将使用SMTP实现或python中的消息服务通知所有者。这是我们的基本想法。这只是展示计算机视觉的这一方面如何在我们的日常生活中实现的一种方式。</p><p id="6655" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看所需的库。</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="77e0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以运行这段代码来安装所需的库。我为Ubuntu创建了一个安装函数。也可以查看需求，单独安装。</p><p id="7b05" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们转到基本的图像库和OpenCV函数，它们用于为我们的应用程序检测人脸和屏幕截图的差异。</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="24d5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该功能用于读取图像并检查面部和眼睛的检测。“面孔”列表和“眼睛”列表存储有关检测到的面孔和眼睛的信息。因此，我们分别在第15行和第25行检查它们的长度，以检查是否有东西被检测到。如果不是，则返回的长度为零，因此该函数返回-1，即它未能检测到人脸或眼睛，否则它返回1。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/bc60376f374ddc48dadc8d8e9bb5040a.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*nNz7ImSywLcjJXMNwASvHQ.jpeg"/></div></figure><p id="2290" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们显示图像，这种检测到的图像将被显示</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7b9e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此功能用于捕捉屏幕截图，并记录截图的计时器和计数器，即截图拍摄的时间和指示一种索引的计数器。第31行到第35行致力于在截图中加入日期和时间戳。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6f7a4ff741c1cac2b1baaae6cd3428ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obk3F6P0KQ3mEiq4OvQWNg.jpeg"/></div></div></figure><p id="7a6f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们聚焦在图像的右角，我们会看到时间标记。让我放大一下。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/eaef851748d9c43cd01274139244b568.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*9RaH3fFFbEh7unGWp7e3Gg.png"/></div></figure><p id="cf76" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是的，我们可以看到时间戳。我们可以通过修改参数来改变文本的字体和位置。我们可以在第51行看到compare_image函数。这个函数用于比较两个截图，并决定是否发生了任何变化。</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="811c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">compare_images函数使用两个不同的函数来确定两个图像是否相同。其中一个函数是均方误差。它是两幅图像之间像素差异的平方。另一个是Sk-learn影像库的结构相似度函数。所得的<strong class="kd jf"> SSIM </strong>指数是一个介于-1和1之间的十进制值，并且值1仅在两组相同的数据的情况下可达到，因此表示完美的结构相似性。0.9的值是在反复试验的基础上设计的，因为该函数过于敏感，并且由于不同光源的干涉所引起的微小干扰而经常区分两幅图像。因此，如果两幅图像相似，它将返回1 else -1。Inline 52我们可以看到，如果返回值是-1，图像被保存，否则删除。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mj"><img src="../Images/d0ed9de2d858134beac2361dd2f5c14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*un9u7RAvCTNLi1IB25tZBQ.png"/></div></div></figure><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/7bdbb4518ef2c3dd2224402554aebfa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*yPcre30C7hl9NvvEv1raHg.png"/></div></figure><p id="262d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们所看到的，我们的应用程序创建了名为“帧”的文件夹，用于存储入侵者面部的相机图像，还创建了相应的“屏幕”文件夹，用于存储截屏图像。每个文件夹都有日期和时间戳，以备记录。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ml"><img src="../Images/711a98aa7ee4918e0cd4f672250cdef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUOw7Dl-9pHZPgaUaGrqcQ.png"/></div></div></figure><p id="349a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是screens文件夹如何以索引的方式存储截图，我们可以看到所有的截图都是不同的。</p><p id="db67" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们转到GUI部分。</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b040" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这段代码用于创建一个基本的启动窗口。我在这里创建了一个非常基本的GUI。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/43b853ca0abd563484f8d219b891d5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*vszNsw1FZ3Ekh_AajqYVdA.png"/></div></figure><p id="dafa" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这有一个注册选项，可以进入注册页面。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mn"><img src="../Images/093ba06d5cdd850eca5498af901493e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*mYqPKW3aay4R8wrKMQ67HQ.png"/></div></div></figure><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="dc6b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常基本的使用Tkinter的注册框代码。在这里，我实现了后端MySQL插入和查询代码以及一些错误检查。它将检查电子邮件是错误的还是用户已经存在。我在这里用过Xampp MySQL服务器。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mo"><img src="../Images/d52a9f46d358e56dbb0437848a1c2fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*hgEch5BYVBsBkydge__BKQ.png"/></div></div></figure><p id="e096" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们将转到下一个屏幕，在设置定时器之前，启动cam选项将保持非活动状态，在设置定时器之后，它将变为活动状态。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/9ad0982c2064767d8a8b08e88f247137.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*LR4PBt8WjJt49mG4ID2lww.png"/></div></figure><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d786" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码可以用来创建窗口。当我们启动cam时，test_capture.py函数被调用，它用于运行我们的网络摄像头，并开始真正的后端工作。</p><p id="35f3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一件事需要注意。我使用python 2.7只是为了运行Tkinter代码，因为在Python 3中它显然有问题。没问题，但是我们可以使用call()方法从python 2调用python 3，反之亦然</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="e197" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们的捕获功能，根据计时器启动网络摄像头并捕获图像帧。我们可以在第48行看到，使用了我们之前定义的read_image函数，如果它检测到面部和眼睛，则返回1，因此，它使用内联的take_screen()方法触发屏幕捕获方法50。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7617705a3c2f3eff18a880f1a3fb53e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*f4Q_0dWpAOU2vzvcBlR-Uw.png"/></div></figure><p id="51f1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">停止摄像机后，我们被送到最后一个屏幕。显示框架和显示屏选项将分别引导我们到相应的文件夹。</p><figure class="la lb lc ld gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="4b75" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，我们可以创建一个桌面快捷方式来启动应用程序。</p><h2 id="bee1" class="lh li je bd lj lk ll dn lm ln lo dp lp km lq lr ls kq lt lu lv ku lw lx ly lz bi translated">结论</h2><p id="0e60" class="pw-post-body-paragraph kb kc je kd b ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky im bi translated">这就是我们如何使用Opencv、Python和图像库创建一个小规模的应用程序。</p><p id="5044" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际代码可在<a class="ae lg" href="https://github.com/abr-98/security_cam" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div></div>    
</body>
</html>