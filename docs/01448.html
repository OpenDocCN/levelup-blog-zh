<html>
<head>
<title>New ES2020 Features — Strings, Numbers, and This</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2020的新功能—字符串、数字和这个</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/new-es2020-features-strings-numbers-and-this-4ecabbca1162?source=collection_archive---------5-----------------------#2020-01-02">https://levelup.gitconnected.com/new-es2020-features-strings-numbers-and-this-4ecabbca1162?source=collection_archive---------5-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/01789622992033a76e7098833bd4b70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9KHSWhcOtOHhgq2A"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@gift_habeshaw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gift Habeshaw </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="17b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自2015年以来，JavaScript一直在快速发展，每次迭代都会推出许多新功能。</p><p id="edfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript语言规范的新版本几乎每年都在更新，新语言特性提案的完成速度比以往任何时候都要快。</p><p id="b8d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着新特性正以前所未有的速度融入现代浏览器和Node.js等其他JavaScript运行时引擎。</p><p id="f790" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2019年，有许多新功能处于“阶段3”阶段，这意味着它非常接近完成，浏览器现在开始支持这些功能。</p><p id="480c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想将它们用于生产代码，我们可以使用Babel之类的东西将它们转换成旧版本的JavaScript，以便在需要时可以在旧版本的浏览器中使用，如Internet Explorer。</p><p id="c584" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究在所有环境中获取全局对象的<code class="fe le lf lg lh b">matchAll</code>方法、数字分隔符和<code class="fe le lf lg lh b">globalThis</code>对象。</p><h1 id="b0ae" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">String.matchAll()</h1><p id="b3f1" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在当前版本的JavaScript中，没有string方法可以用来搜索所有出现的字符串和捕获组。</p><p id="133b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要搜索一个字符串的所有实例，我们必须编写自己的正则表达式，并使用<code class="fe le lf lg lh b">match</code>方法来搜索我们想要搜索的子字符串。</p><p id="157b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用带有我们自己的正则表达式的<code class="fe le lf lg lh b">match</code>方法来搜索一个字符串的所有实例，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b305" class="mt lj it lh b gy mu mv l mw mx">const str = 'foo bar foo';<br/>const matches = str.match(/foo/g);<br/>console.log(matches);</span></pre><p id="28d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们运行上面的代码时，我们应该得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c8db" class="mt lj it lh b gy mu mv l mw mx">[<br/>  "foo",<br/>  "foo"<br/>]</span></pre><p id="b7a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">match</code>方法根据正则表达式得到一个字符串的所有匹配的数组。注意，我们在正则表达式文字的末尾有一个<code class="fe le lf lg lh b">g</code>标志。否则，将只返回第一个匹配项。当包含<code class="fe le lf lg lh b">g</code>标志时，捕捉组匹配不包含在内。</p><p id="da8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了另一个叫做<code class="fe le lf lg lh b">matchAll</code>的方法，它与<code class="fe le lf lg lh b">match</code>非常相似。</p><p id="9e39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，它返回一个不可重启的迭代器，因此我们可以循环遍历由<code class="fe le lf lg lh b">matchAll</code>方法返回的迭代器，以获得找到的所有匹配。</p><p id="b038" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还接受一个正则表达式，并用<code class="fe le lf lg lh b">RegExp</code>构造函数将任何非正则表达式对象转换成正则表达式。</p><p id="28c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为它返回一个迭代器，所以我们可以对它使用扩展操作符、<code class="fe le lf lg lh b">for...of</code>循环和<code class="fe le lf lg lh b">Array.from</code>方法。</p><p id="1c51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe le lf lg lh b">match</code>方法的另一个区别是，捕获组结果从<code class="fe le lf lg lh b">matchAll</code>方法返回，而不是从<code class="fe le lf lg lh b">match</code>方法返回。</p><p id="0128" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在下面的代码中使用<code class="fe le lf lg lh b">match</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3871" class="mt lj it lh b gy mu mv l mw mx">const str = 'foo bar foo foobar foofoobarbarbar foobarbar';<br/>const matches = str.match(/foo(bar)+/g);</span></pre><p id="ea9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ae16" class="mt lj it lh b gy mu mv l mw mx">[<br/>  "foobar",<br/>  "foobarbarbar",<br/>  "foobarbar"<br/>]</span></pre><p id="83ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用下面代码中的<code class="fe le lf lg lh b">matchAll</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="62b3" class="mt lj it lh b gy mu mv l mw mx">const str = 'foo bar foo foobar foofoobarbarbar foobarbar';<br/>const matches2 = str.matchAll(/foo(bar)+/g);</span></pre><p id="1cb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6cda" class="mt lj it lh b gy mu mv l mw mx">[<br/>  [<br/>    "foobar",<br/>    "bar"<br/>  ],<br/>  [<br/>    "foobarbarbar",<br/>    "bar"<br/>  ],<br/>  [<br/>    "foobarbar",<br/>    "bar"<br/>  ]<br/>]</span></pre><p id="e4c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，捕获组<code class="fe le lf lg lh b">(bar)</code>返回带有<code class="fe le lf lg lh b">matchAll</code>的每个结果，但是在正则表达式中，它没有返回带有<code class="fe le lf lg lh b">g</code>标志的<code class="fe le lf lg lh b">match</code>。</p><p id="fa53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，另一个重要的区别是由<code class="fe le lf lg lh b">matchAll</code>方法返回的迭代器是不可重启的。一旦迭代器返回的值用完了，如果我们想再次得到结果，我们必须再次调用方法来创建一个新的迭代器。</p><h1 id="e576" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">数字分隔符</h1><p id="34c4" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在早期版本的JavaScript中，阅读长数字是一件痛苦的事情，因为没有任何东西来分隔数字。</p><p id="30cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着人眼几乎不可能分辨出大数字中有多少位数。</p><p id="6b2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在JavaScript增加了数字分隔符，用下划线将数字分成更小的数字组。</p><p id="4729" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以像在下面的代码中一样使用它们:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="71ed" class="mt lj it lh b gy mu mv l mw mx">const x = 1_000_000_000_000</span></pre><p id="3457" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在上面运行<code class="fe le lf lg lh b">console.log</code>，那么<code class="fe le lf lg lh b">x</code>将显示10000000000。它也适用于十进制数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="699b" class="mt lj it lh b gy mu mv l mw mx">const x = 1_363_372_373.378_473</span></pre><p id="5e26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在上面运行<code class="fe le lf lg lh b">console.log</code>，那么<code class="fe le lf lg lh b">x</code>将显示1363372373.378473。我们不必把数字分成3个一组。它可以按我们喜欢的任何方式分组，所以如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="af16" class="mt lj it lh b gy mu mv l mw mx">const x = 37378_44748</span></pre><p id="c61e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行这个函数，就会从<code class="fe le lf lg lh b">x</code>的<code class="fe le lf lg lh b">console.log</code>中得到3737844748。它也适用于其他基数，如二进制、十六进制或八进制数。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="009a" class="mt lj it lh b gy mu mv l mw mx">const binary = 0b111_111_111;<br/>const bytes = 0b1111111_11111111_1111111;<br/>cons<strong class="lh iu">t</strong> hex = 0xFAB_F00D;</span></pre><p id="ffa1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一的问题是，如果我们想将数字串传递给<code class="fe le lf lg lh b">Number</code>或<code class="fe le lf lg lh b">parseInt</code>函数，就不能在数字串中使用下划线。如果我们写<code class="fe le lf lg lh b">Number(‘123_456’)</code>，那么我们得到<code class="fe le lf lg lh b">NaN</code>。如果我们运行<code class="fe le lf lg lh b"> parseInt(‘123_456’)</code>，那么我们得到123。正如我们所看到的，它们都是不正确的。这意味着当使用数字分隔符时，我们应该坚持数字文字。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/938cd96db6fb64f79585b080697833af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DqCSF4RJ_KBdqdth"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@kylejglenn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯尔·格伦</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8efd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">globalThis</h1><p id="66e0" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript的最新版本也有<code class="fe le lf lg lh b">globalThis</code>方法。这让我们可以获得应用程序的真正全局对象，而不是依赖于<code class="fe le lf lg lh b">this</code>对象，后者可能会根据它所在的上下文而改变。例如，如果我们运行以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8a46" class="mt lj it lh b gy mu mv l mw mx">console.log(globalThis);</span><span id="a4c7" class="mt lj it lh b gy my mv l mw mx">function foo() {<br/>  console.log(globalThis)<br/>}<br/>new foo();</span></pre><p id="c8ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到两个<code class="fe le lf lg lh b">console.log</code>都输出了<code class="fe le lf lg lh b">window</code>对象，这个对象包含了浏览器标签的内容。</p><p id="19cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在<code class="fe le lf lg lh b">foo</code>函数中<code class="fe le lf lg lh b">console.log</code>了<code class="fe le lf lg lh b">this</code>关键字而不是<code class="fe le lf lg lh b">globalThis</code>如果我们用<code class="fe le lf lg lh b">new</code>关键字创建了一个<code class="fe le lf lg lh b">foo</code>的新实例，我们将不会得到<code class="fe le lf lg lh b">window</code>对象，而是得到<code class="fe le lf lg lh b">foo</code>函数。</p><p id="37e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们用关键字<code class="fe le lf lg lh b">this</code>替换<code class="fe le lf lg lh b">globalThis</code>，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c1f3" class="mt lj it lh b gy mu mv l mw mx">console.log(this);</span><span id="6a74" class="mt lj it lh b gy my mv l mw mx">function foo() {<br/>  console.log(this)<br/>}<br/>new foo();</span></pre><p id="1829" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在第一个<code class="fe le lf lg lh b">console.log</code>中获取<code class="fe le lf lg lh b">window</code>对象，但是<code class="fe le lf lg lh b">foo</code>函数中的<code class="fe le lf lg lh b">console.log</code>将为我们获取<code class="fe le lf lg lh b">foo</code>构造函数。其他环境，如web或服务人员，<code class="fe le lf lg lh b">self</code>将是一个全局对象。</p><p id="e938" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Node.js中，全局对象被称为<code class="fe le lf lg lh b">global</code>。<code class="fe le lf lg lh b">globalThis</code>适用于所有环境，因此我们可以使用它来访问真正的全局对象。</p><p id="1403" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它适用于许多浏览器的最新版本和Node.js的最新版本。</p><p id="51a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它保证在窗口和非窗口环境中都可以工作。它通过引用我们不能直接访问的实际全局对象周围的代理来工作。</p><h1 id="1704" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="a3ec" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在当前版本的JavaScript中，没有字符串方法可以用来搜索字符串和捕获组的所有匹配项。</p><p id="9a42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">matchAll</code>方法，我们可以找到所有的匹配，并得到所有的捕获组。在早期版本的JavaScript中，阅读长数字是一件痛苦的事情，因为没有任何东西来分隔数字。</p><p id="cc4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着人眼几乎不可能分辨出大数字中有多少位数。</p><p id="7a47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在JavaScript增加了数字分隔符，用下划线将数字分成更小的数字组。</p><p id="aa30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用分隔线随意分组。JavaScript的最新版本也有<code class="fe le lf lg lh b">globalThis</code>方法。</p><p id="493b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这让我们可以获得应用程序的真正全局对象，而不是依赖于<code class="fe le lf lg lh b">this</code>对象，后者可能会根据它所在的上下文而改变。</p><p id="fff8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还可以在窗口和非窗口环境中工作，这样像Node.js这样的运行时环境也可以使用<code class="fe le lf lg lh b">globalThis</code>。</p></div></div>    
</body>
</html>