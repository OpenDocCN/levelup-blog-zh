<html>
<head>
<title>Valid Parentheses Interview Problem in Python3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python3中的有效括号面试问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/valid-parentheses-interview-problem-in-python3-f98fb99c9cf?source=collection_archive---------6-----------------------#2020-03-02">https://levelup.gitconnected.com/valid-parentheses-interview-problem-in-python3-f98fb99c9cf?source=collection_archive---------6-----------------------#2020-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f30d83a8202847386f2425d70e8d6a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ek1GXU72HFuKcHbjRODSGA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片来自<a class="ae kf" href="https://www.msci.com/www/blog-posts/all-faangs-are-not-created/01065933661" rel="noopener ugc nofollow" target="_blank"> MSCI </a></figcaption></figure><p id="d5e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">许多公司已经在面试中使用有效括号问题作为白板编码挑战，以测试候选人的算法写作技能。尽管通常被问到这个问题的面试是在早期，但尽管如此，脸书、谷歌和亚马逊等公司在他们的一些软件工程师面试中都被问到这个问题。</p><h1 id="cffa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">问题是:</h1><p id="98f7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">给定一个仅包含字符<code class="fe mh mi mj mk b">'('</code>、<code class="fe mh mi mj mk b">')'</code>、<code class="fe mh mi mj mk b">'{'</code>、<code class="fe mh mi mj mk b">'}'</code>、<code class="fe mh mi mj mk b">'['</code>和<code class="fe mh mi mj mk b">']'</code>的字符串，确定输入的字符串是否有效。</p><p id="e2ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在以下情况下，输入字符串有效:</p><ol class=""><li id="f030" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">左括号必须用相同类型的括号括起来。</li><li id="dcd4" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">左括号必须以正确的顺序结束。</li></ol><p id="4e89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，空字符串也被视为有效。</p><p id="b6b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">例1: </strong></p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="b387" class="nh lf it mk b gy ni nj l nk nl"><strong class="mk iu">Input:</strong> "()"<br/><strong class="mk iu">Output:</strong> true</span></pre><p id="8ada" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">例2 </strong></p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="d195" class="nh lf it mk b gy ni nj l nk nl"><strong class="mk iu">Input:</strong> "()[]{}"<br/><strong class="mk iu">Output:</strong> true</span></pre><p id="3f39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">例3: </strong></p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="3048" class="nh lf it mk b gy ni nj l nk nl"><strong class="mk iu">Input:</strong> "(]"<br/><strong class="mk iu">Output:</strong> false</span></pre><p id="923a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">例4: </strong></p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="8ea5" class="nh lf it mk b gy ni nj l nk nl"><strong class="mk iu">Input:</strong> "([)]"<br/><strong class="mk iu">Output:</strong> false</span></pre><p id="4ca5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">例5: </strong></p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="5a81" class="nh lf it mk b gy ni nj l nk nl"><strong class="mk iu">Input:</strong> "{[]}"<br/><strong class="mk iu">Output:</strong> true</span></pre><blockquote class="nm nn no"><p id="59e9" class="kg kh np ki b kj kk kl km kn ko kp kq nq ks kt ku nr kw kx ky ns la lb lc ld im bi translated">免责声明:如果你真的想在这些方面做得更好，先自己尝试这个问题，然后再回来比较</p></blockquote><h1 id="044b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">解决方案是:</h1><p id="0179" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">代码和提交给LeetCode的结果在文章的底部，但是首先我想解释一下这个解决方案背后的一些想法。</p><p id="0b3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在Python3中实现了这个解决方案，使用一个基本的键值字典来存储值，使用一个LIFO堆栈来跟踪进度。</p><h2 id="41dd" class="nh lf it bd lg nt nu dn lk nv nw dp lo kr nx ny ls kv nz oa lw kz ob oc ma od bi translated">键值字典</h2><p id="7554" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我坚信，在进行采访或编码挑战时，键值字典通常是一个很好的工具，因为与常用的数组相比，内存访问非常快。在数组中查找一个项的最坏情况运行时间是O(n ),而在字典中查找总是O(1 ),因为查找是直接的。</p><p id="5a37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python的键值字典是一个哈希表，但是您可以为键值条目传递一个值，而不是为给定的值条目生成一个哈希键。键必须总是唯一的，而值可以是您想要的任何值。</p><p id="a1ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="ddd0" class="nh lf it mk b gy ni nj l nk nl">fruitDict = {'banana': 'yellow', 'apple': 'red', 'lime':'green'}</span></pre><p id="371c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，每当您查找该键(即<code class="fe mh mi mj mk b">fruitDict.get(‘lime’)</code>)时，它将返回该条目的值(<em class="np">绿色</em>)。</p><p id="6d28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://developers.google.com/edu/python/dict-files" rel="noopener ugc nofollow" target="_blank">更多关于Python Key Val Dict的内容可以在这里阅读</a></p><h2 id="13d8" class="nh lf it bd lg nt nu dn lk nv nw dp lo kr nx ny ls kv nz oa lw kz ob oc ma od bi translated">后进先出堆栈</h2><p id="905c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">堆栈是一种线性数据结构，它以后进/先出(LIFO) <em class="np">(例如一堆盘子，最后放置的盘子是下一个要使用的第一个)</em>或先入/后出(FILO)<em class="np">(也称为队列，因为有一个等待的人的队列的相关示例。第一个排队的人首先得到服务)</em>。在堆栈中，一个新元素被添加到一端，一个元素仅从该端移除。</p><p id="acd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用堆栈背后的想法是，我可以将括号的“左侧”放在堆栈上，每当我到达“右侧”时，我将从堆栈中取出顶部的“左侧”。</p><p id="524f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果从堆栈中取出的“左侧”和字符串中下一个出现的“右侧”彼此匹配，那么算法可以继续，否则字符串无效。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Python3有效括号</figcaption></figure><p id="39b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以及由此产生的LeetCode分析:</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/4745acdc7220bef3dbe7a042bb174faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8XvgYAR3NT5sNGuhGFygw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">速度的第10个百分点和内存使用的第1个百分点…还不错</figcaption></figure></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="02ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是最基本的、经常被提及的挑战之一，但仍然是一个巨大的挑战。你想看到我崩溃吗？下面评论一下！</p><p id="9387" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读！关于软件开发实践的一些技巧，<a class="ae kf" href="https://www.msci.com/www/blog-posts/all-faangs-are-not-created/01065933661" rel="noopener ugc nofollow" target="_blank">查看我的系列文章</a></p></div></div>    
</body>
</html>