<html>
<head>
<title>All Pythagorean Triplets Less Than Equal to N in Optimal Time Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最优时间复杂度小于等于N的所有勾股三元组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/all-pythagorean-triplets-less-than-equal-n-in-optimal-time-complexity-babfbe742337?source=collection_archive---------4-----------------------#2020-08-26">https://levelup.gitconnected.com/all-pythagorean-triplets-less-than-equal-n-in-optimal-time-complexity-babfbe742337?source=collection_archive---------4-----------------------#2020-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/125ec5004f93caedb259ba8f6b34d5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kQfRs44MJgeLqkx5"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>拍摄</figcaption></figure><p id="67ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">毕达哥拉斯三元组是三个有序正整数(x，y，z)的集合，使得</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5aee" class="ln lo it lj b gy lp lq l lr ls">                       x^2 + y^2 = z^2    --- (1)<br/>where,<br/>x &lt; y &lt; z &lt;= N</span></pre></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="20c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有几种生成勾股三元组的技术，例如使用<a class="ae kf" href="https://en.wikipedia.org/wiki/Gaussian_integers" rel="noopener ugc nofollow" target="_blank">高斯整数</a>和使用<a class="ae kf" href="https://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples" rel="noopener ugc nofollow" target="_blank">欧几里德公式</a>。它们可用于生成所有本原毕达哥拉斯三元组，通过使用非本原毕达哥拉斯三元组是本原毕达哥拉斯三元组的正整数倍这一事实，它们可再次用于生成所有非本原毕达哥拉斯三元组。</p><p id="2c7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单地使用两个循环通过对所有可能的x和y迭代x和y来生成勾股三元组，并检查它们是否满足等式(1 ),花费时间O(N)。此外，使用上述方法来生成原始的毕达哥拉斯三元组以及从它们生成所有的毕达哥拉斯三元组可能需要O(N)时间。</p><p id="3383" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我使用了方程(2)，通过求解x的二次方程可以很容易地从方程(1)得出方程(2)，因此对于“<em class="ma"> x &gt; 0”、</em></p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5071" class="ln lo it lj b gy lp lq l lr ls">                      x = (b - a) + sqrt{2b(b - a)} --- (2)</span><span id="e6b6" class="ln lo it lj b gy mb lq l lr ls">where,<br/>a = y - x,<br/>b = z - x and<br/>0 &lt; a &lt; b</span></pre></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="4b36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了找到所有的毕达哥拉斯三元组，我们需要找到<em class="ma"> a </em>和<em class="ma"> b </em>的所有值，使得它们是整数并且等式(2)成立。为了找到a和b的值，首先，我们将一步一步地寻找它们各自的范围。</p><p id="6b43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<em class="ma"> a </em>的定义，其上限和下限取决于<em class="ma"> b </em>，可以写成</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="46ae" class="ln lo it lj b gy lp lq l lr ls">                             1 ≤ a ≤ b − 1</span></pre><p id="a120" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<em class="ma"> b &gt; </em> <em class="ma"> a </em>和<em class="ma"> a </em>的下限为1，因此<em class="ma"> b </em>的下限为2。现在我们需要找到<em class="ma"> b </em>的上限。</p><p id="cd49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们知道<em class="ma"> 0 &lt; z ≤ N </em>，从(<em class="ma">b = zx)</em>(<em class="ma">x+b≤N)</em>，从而从等式(2)和<em class="ma">a = B1，</em></p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6ef2" class="ln lo it lj b gy lp lq l lr ls">                      (b − a) + sqrt{2b(b − a)} + b ≤ N           <br/>                       ⇒ b + 1 + sqrt{2b} ≤ N<br/>                       ⇒ 0 ≤ b ≤ N − sqrt{2N − 1}</span><span id="9746" class="ln lo it lj b gy mb lq l lr ls">Since first pythagorean Triple is (3,4,5), which makes N ≥ 5</span></pre><p id="3b02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设，<em class="ma">v = 2b(ba)</em>，由于<em class="ma"> x </em>为正整数且<em class="ma"> 1 &lt; a &lt; b，</em>因此从等式(2)，</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5264" class="ln lo it lj b gy lp lq l lr ls">                        2b ≤ v ≤ 2b(b − 1) and <br/>                        sqrt{v} ∈ <strong class="lj iu">N</strong>        and <br/>                        v (mod 2b) = 0</span></pre></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="bd18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了找到<em class="ma"> v </em>的实际值，我们使用<em class="ma"> 2b </em>的<a class="ae kf" href="https://www.mathsisfun.com/prime-factorization.html" rel="noopener ugc nofollow" target="_blank">质因数分解</a>，</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/02f8e84b690129b277fdf921258108bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*S0ztM5WNll-GdKtKaPd1pA.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">等式(3):2b的质因数分解</figcaption></figure><p id="4181" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中，p_i是k个素数，每个素数的阶为α_i。</p><p id="78d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用2b的质因数，我们可以通过等式计算出<em class="ma"> v </em>的值，</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi md"><img src="../Images/19c2869ee2c87e2308b9444f0ee1c7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*YHBAPO4diP3nXDGSEAUUnQ.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">等式(sqrt { v }的解</figcaption></figure><p id="5b46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中，p_j是k个素数，每个素数的阶次为{a_j /2}，p_i = p_j，α_i = α_j，分别来自等式(3)和等式(4)。等式(4)可以被证明，这并不困难，但也不难。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="80bb" class="me lo it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated"><strong class="ak">算法</strong></h1><p id="8aa9" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">一切都设置好了，现在我们来看算法的伪代码:</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><a href="https://i.imgur.com/sOitf6i.jpg"><div class="gh gi ng"><img src="../Images/8525e62245822202e71314b9068cba6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3Lr6Jd1Ip11qjh1xNcFLQ.jpeg"/></div></a><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用于生成勾股三元组的伪代码</figcaption></figure></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="c41a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述算法在python中可以写成:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="336a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的算法中，for循环运行了<em class="ma"> N-sqrt{2N-1} </em>次，在其中，我们计算的是<em class="ma"> 2b </em>的素因子，然后是<em class="ma"> γ </em>，可以及时计算出来<em class="ma"> O(ln N) </em>见定理2。由于毕达哥拉斯三元组<em class="ma"> (x，y，z) </em>与<em class="ma"> z ≤ N </em>的数量顺序为<em class="ma">O(N lnn)</em>【1】【2】，并且在while循环中我们计算三元组直到<em class="ma"> z ≤ N </em>，每次迭代时，我们都会发现一个毕达哥拉斯三元组，顺序为<em class="ma"> O(1) </em>， 因为我们只是在做乘法来找到<em class="ma"> v </em>因为v = (iγ)^2并且从<em class="ma"> v </em>我们正在计算<em class="ma"> q </em>也就是<em class="ma"> b-a </em>除以<em class="ma"> v </em>除以<em class="ma"> 2b </em>，有<em class="ma"> q </em>和<em class="ma"> v </em>我们计算，三胞胎乘</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="538d" class="ln lo it lj b gy lp lq l lr ls">                   x = (b − a) + sqrt{2b(b − a)}<br/>                 ⇒ x = q + √(v)  </span><span id="3d2c" class="ln lo it lj b gy mb lq l lr ls">                   y = x + a<br/>                 ⇒ y = a + √(v) </span><span id="3288" class="ln lo it lj b gy mb lq l lr ls">                   z = x + b <br/>                 ⇒ z = q + √(v) + b</span></pre><p id="3d57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于while循环中的操作花费了<em class="ma"> O(1) </em>的时间，因此，while循环花费了<em class="ma"> O(ln(N)) </em>的时间，使得整个算法花费了<em class="ma"> O(N ln N) </em>的时间和<em class="ma"> O(N) </em>的空间。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="6ea8" class="me lo it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated"><strong class="ak">计算SPF数组</strong></h1><p id="bc54" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">为了计算每个小于等于N的整数的最小质因数，我们可以使用厄拉多塞筛算法。这种算法不是最佳算法，但是由于它没有损害整个算法的运行时间复杂性，所以它是好的。</p><p id="4261" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有比厄拉多塞筛算法更好的算法，但是为了说明和简单起见，我们将坚持使用厄拉多塞筛算法。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><a href="https://i.imgur.com/PQDJSzR.jpg"><div class="gh gi nj"><img src="../Images/6e7439880e15329ae20b1b2de79dc1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nM2P97jbulO3EKAvC_R9NQ.jpeg"/></div></a><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用于计算spf阵列的伪代码</figcaption></figure><p id="bfa8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而且，上面的算法可以用python写成:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="dda4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在线性时间[3]内预先计算出每一个小于<em class="ma"> N </em>的正整数的最低质因数并存储在一个数组中比如说<em class="ma"> spf </em>，使用<em class="ma"> spf </em>通过使用<a class="ae kf" href="https://en.wikipedia.org/wiki/Trial_division" rel="noopener ugc nofollow" target="_blank"> <em class="ma">试除法</em> </a> <em class="ma"> </em>计算出<em class="ma"> x </em>的质因数。使用spf数组的试除法需要时间<em class="ma"> O(ln x) </em>而<em class="ma"> spf </em>数组本身需要空间<em class="ma">O(N)</em>【3】(存储小于2N的整数的空间)。</p><h1 id="5fd2" class="me lo it bd mf mg nk mi mj mk nl mm mn mo nm mq mr ms nn mu mv mw no my mz na bi translated"><strong class="ak">计算伽玛</strong></h1><p id="e676" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">通过稍微改变试除法，我们也可以直接使用<em class="ma"> spf </em>计算<em class="ma"> γ </em>，见下面的算法。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><a href="https://i.imgur.com/qVkcg13.jpg"><div class="gh gi np"><img src="../Images/7183f993272a95497f80747a5c38cff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RtZ2zitgnfmJa9jCO6NfMA.jpeg"/></div></a><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用spf阵列计算伽玛的伪代码</figcaption></figure><p id="cfe1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述算法可以用python写成:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="418f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不想存储每个整数的最低质因数，或者在某些情况下我们的存储空间较少，我们需要每次从开始计算<em class="ma"> 2b </em>的质因数，然后为此计算<em class="ma"> γ </em>，这在<em class="ma"> O(N^0.5) ( </em>见下面的算法)、<em class="ma"> </em>中很容易完成，只需用试除法替换最终算法中的“getReducedFactorization”函数并做一些修改， 类似于getReducedFactorization函数来计算<em class="ma"> γ </em>，从而使得最终算法取<em class="ma"> O(N^1.5) </em>。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><a href="https://i.imgur.com/5nB2heG.jpg"><div class="gh gi nq"><img src="../Images/d24e191bb64b22cef467a723554f4f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXSL9UDc56Tn4TlRmVQtlA.jpeg"/></div></a><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">直接计算伽玛的伪代码</figcaption></figure><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="5ed4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有函数都在一个python文件中的最终算法可以在<a class="ae kf" href="https://github.com/abecus/DS-and-Algorithms/blob/master/pytriplets/pythagoreanTriplets.py" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="76ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你发现任何错误，请让我知道，以便其他读者可以得到正确的结果。</p><h1 id="e423" class="me lo it bd mf mg nk mi mj mk nl mm mn mo nm mq mr ms nn mu mv mw no my mz na bi translated"><strong class="ak">参考文献</strong></h1><p id="2705" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">[1] Nowak，W. G .，&amp; Recknagel，w .“毕达哥拉斯三元组的分布和一个三维除数问题”，数学。冈山大学，31，213–220，1989年。</p><p id="5f67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2] Manuel Benito，Juan L.Varona，“边数少于n的毕达哥拉斯三角形”，《计算与应用数学杂志》，Elsevier，143，117–126，2002年。</p><p id="3a43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[3]大卫·格里斯，贾亚迪夫·米斯拉。“寻找素数的线性筛选算法”，1978年</p></div></div>    
</body>
</html>