# Firestore 查询限制以及如何解决这些限制

> 原文：<https://levelup.gitconnected.com/firestore-query-limitations-and-how-to-work-around-them-e058a844ae57>

![](img/f8bb0d9973cf93d775d4f641a0e0f4ab.png)

# 介绍

在这篇博文的引言中，我们将概述 Firestore 查询功能以及理解查询限制的重要性。

Firestore 是一个灵活、可扩展的 NoSQL 云数据库，允许您实时存储和查询数据。它提供了广泛的查询选项，包括使用多个条件对数据进行筛选和排序的能力，使用 and、OR 和 IN 子句执行复合查询的能力，以及使用范围筛选器缩小结果范围的能力。

然而，像任何数据库一样，Firestore 在查询数据时也有自己的一套限制和约束。理解这些限制对于构建高效且可伸缩的应用程序至关重要，因为它们会影响查询的性能和应用程序的整体可伸缩性。

在这篇博文中，我们将深入研究 Firestore 中特定的查询限制，并探索这些限制的一些常见解决方法。通过理解这些限制并知道如何解决它们，您可以确保您的 Firestore 查询在性能和可伸缩性方面得到优化。

# 限制#1:多个字段上的不等式查询

在这一节中，我们将仔细研究在 Firestore 中对多个字段使用不等式查询的局限性，并探索一些可能的解决方法。

首先，让我们回顾一下不等查询在 Firestore 中是如何工作的。不等式查询允许您使用诸如“小于”、“大于”、“小于或等于”和“大于或等于”等运算符，根据值的范围来筛选数据例如，您可以使用不等式查询来查找特定得分大于 50 的所有用户，或者价格小于 100 美元的所有产品。

在 Firestore 中，通过使用`where`方法并指定字段、操作符和值，可以在单个字段上使用不等式查询。例如:

```
db.collection("users").where("score", ">", 50).get()
```

如果您需要基于多个字段中的一系列值来筛选数据，这种限制可能会令人沮丧。但是，您可以使用一些变通方法来绕过这一限制。

一种选择是使用复合索引来支持您的查询。复合索引允许您在多个字段上创建一个索引，然后可以用它来支持高级查询。通过在“分数”和“年龄”字段上创建复合索引，可以使用以下查询来筛选数据:

```
db.collection("users").orderBy("score").orderBy("age").startAt([50, 30]).get()
```

另一种选择是使用云函数在后端执行查询，并将过滤后的结果返回给客户端。这种方法允许您使用任何您需要的查询逻辑，而不受 Firestore 的查询功能的限制。

通过使用这些变通方法之一，您可以有效地对 Firestore 中的多个字段执行不等式查询，尽管存在限制。但是，在决定使用哪种解决方法时，仔细考虑每种方法的利弊和局限性以及应用程序的特定需求是很重要的。

还值得注意的是，对多个字段的不等式查询可能效率低下，并影响数据库的性能。如果可能的话，通常最好避免在多个字段上使用不等式查询，并在决定是否使用这种类型的查询时仔细考虑应用程序的特定需求和要求。

总的来说，理解 Firestore 中多个字段上的不等式查询的限制并知道如何解决这个限制对于构建高效和可伸缩的应用程序来说是至关重要的。通过使用复合索引或云函数，您可以有效地在多个字段上执行不等式查询，尽管存在限制。但是，仔细考虑每种方法的利弊和局限性并选择最适合您的应用程序需求的选项是很重要的。

# 限制#2:在不同字段上使用范围过滤器的查询

在这一节中，我们将仔细研究在 Firestore 的同一个查询中的不同字段上使用范围过滤器的局限性，并探索一些可能的解决方法。

范围筛选器允许您使用诸如“小于”、“大于”、“小于或等于”和“大于或等于”等运算符，根据值的范围来筛选数据例如，您可以使用范围筛选器来查找得分在 50 到 100 之间的所有用户，或者价格在 50 到 100 美元之间的所有产品。

在 Firestore 中，通过使用`where`方法并指定字段、运算符和值，您可以在单个字段上使用范围过滤器。例如:

```
db.collection("users").where("score", ">=", 50).where("score", "<=", 100).get()
```

该查询从“users”集合中检索“score”字段在 50 到 100 之间的所有文档。

然而，Firestore 在对同一查询中的不同字段使用范围过滤器时有一个限制。具体来说，不能在同一个查询中的不同字段上使用范围筛选器。例如，Firestore 中不允许以下查询:

```
db.collection("users").where("score", ">=", 50).where("age", ">=", 30).get()
```

如果您需要基于多个字段的值范围来筛选数据，这种限制可能会令人沮丧。但是，您可以使用一些变通方法来绕过这一限制。

一种选择是使用复合索引来支持您的查询。复合索引允许您在多个字段上创建一个索引，然后可以用它来支持高级查询。通过在“分数”和“年龄”字段上创建复合索引，可以使用以下查询来筛选数据:

```
db.collection("users").orderBy("score").orderBy("age").startAt([50, 30]).endAt([100, 60]).get()
```

另一种选择是使用云函数在后端执行查询，并将过滤后的结果返回给客户端。这种方法允许您使用任何您需要的查询逻辑，而不受 Firestore 的查询功能的限制。

尽管存在限制，但通过使用这些变通办法之一，您可以在 Firestore 中的不同字段上有效地执行范围过滤。但是，在决定使用哪种解决方法时，仔细考虑每种方法的利弊和局限性以及应用程序的特定需求是很重要的。

还值得注意的是，在不同的字段上使用范围过滤器可能会效率低下，并影响数据库的性能。如果可能的话，通常最好避免在不同的字段上使用范围筛选器，并在决定是否使用这种类型的查询时，仔细考虑应用程序的特定需求和要求。

总的来说，理解 Firestore 中不同字段的范围过滤器的限制并知道如何解决这一限制对于构建高效和可伸缩的应用程序至关重要。通过使用复合索引或云函数，您可以有效地对不同的字段执行范围过滤，尽管存在限制。但是，仔细考虑每种方法的利弊和局限性并选择最适合您的应用程序需求的选项是很重要的。

# 限制#3:在不同字段上使用 limit 和 orderBy 的查询

在这一节中，我们将仔细研究在 Firestore 的同一个查询中的不同字段上使用 limit 和 orderBy 的局限性，并探索一些可能的解决方法。

Firestore 中的`limit`和`orderBy`方法允许您限制查询返回的结果数量，并指定返回结果的顺序。例如，您可以使用`limit`方法来检索数据库中的前 10 个用户，或者使用`orderBy`方法来检索按分数升序排序的所有用户。

在 Firestore 中，您可以在同一个字段上使用`limit`和`orderBy`方法，方法是在查询中将它们链接在一起。例如:

```
db.collection("users").orderBy("score").limit(10).get()
```

该查询从“users”集合中检索前 10 个文档，按照“score”字段以升序排序。

然而，Firestore 在对同一查询中的不同字段使用`limit`和`orderBy`方法时有一个限制。具体来说，您不能在不同的字段上使用`limit`方法和`orderBy`方法。例如，Firestore 中不允许以下查询:

```
db.collection("users").orderBy("age").limit(10).get()
```

如果您需要根据一个字段的值限制查询结果，并根据另一个字段的值对结果进行排序，这种限制可能会令人沮丧。但是，您可以使用一些变通方法来绕过这一限制。

一种选择是使用复合索引来支持您的查询。复合索引允许您在多个字段上创建一个索引，然后可以用它来支持高级查询。通过在“年龄”和“分数”字段上创建复合索引，可以使用以下查询对数据进行筛选和排序:

```
db.collection("users").orderBy("age").orderBy("score").limit(10).get()
```

另一种选择是使用云函数在后端执行查询，并将过滤和排序后的结果返回给客户端。这种方法允许您使用任何您需要的查询逻辑，而不受 Firestore 的查询功能的限制。

通过使用这些变通方法之一，您可以在 Firestore 的不同字段上有效地使用`limit`和`orderBy`方法，尽管存在限制。但是，在决定使用哪种解决方法时，仔细考虑每种方法的利弊和局限性以及应用程序的特定需求是很重要的。

同样值得注意的是，在不同的字段上使用`limit`和`orderBy` 方法可能效率低下，并且会影响数据库的性能。如果可能的话，通常最好避免在不同的字段上使用`limit`和`orderBy`方法，并在决定是否使用这种类型的查询时仔细考虑您的应用程序的特定需求和要求。

总的来说，理解在 Firestore 的不同领域使用`limit`和`orderBy`方法的局限性，并知道如何解决这一局限性，对于构建高效和可伸缩的应用程序至关重要。通过使用复合索引或云函数，您可以在不同的字段上有效地使用`limit`和`orderBy`方法，尽管存在限制。但是，仔细考虑每种方法的利弊和局限性并选择最适合您的应用程序需求的选项是很重要的。

# 限制#4:带有 limit 和 startAt/endAt 的查询

在这一节中，我们将仔细研究在 Firestore 的同一个查询中使用 limit 和 startAt/endAt 的局限性，并探索一些可能的解决方法。

Firestore 中的`limit`方法允许您限制查询返回的结果数量，而`startAt`和`endAt`方法允许您指定查询结果的起点和终点。例如，您可以使用`limit`方法仅检索数据库中的前 10 个用户，或者使用`startAt`和`endAt`方法检索得分在 50 到 100 之间的所有用户。

在 Firestore 中，您可以通过将`limit`和`startAt` / `endAt`方法链接在一起，在同一个查询中使用它们。例如:

```
db.collection("users").orderBy("score").startAt(50).endAt(100).limit(10).get()
```

该查询从“users”集合中检索“score”字段在 50 到 100 之间的前 10 个文档，按照“score”字段以升序排序。

然而，Firestore 在同一个查询中使用`limit`和`startAt` / `endAt`方法时有一个限制。具体来说，不能在同一个查询中同时使用`limit`方法和`startAt` / `endAt`方法。例如，Firestore 中不允许以下查询:

```
db.collection("users").orderBy("score").startAt(50).limit(10).get()
```

如果您需要根据某个范围的值来限制查询结果并指定结果的起点，这种限制可能会令人沮丧。但是，您可以使用一些变通方法来绕过这一限制。

一种选择是使用复合索引来支持您的查询。复合索引允许您在多个字段上创建一个索引，然后可以用它来支持高级查询。通过在“score”和“age”字段上创建一个复合索引，您可以使用下面的查询来过滤和排序您的数据，同时仍然使用`limit`方法:

```
db.collection("users").orderBy("score").orderBy("age").startAt([50]).limit(10).get()
```

另一种选择是使用云函数在后端执行查询，并将过滤和排序后的结果返回给客户端。这种方法允许您使用任何您需要的查询逻辑，而不受 Firestore 的查询功能的限制。

通过使用这些变通办法之一，尽管有限制，您可以在 Firestore 的同一个查询中有效地使用`limit`和`startAt` / `endAt`方法。但是，在决定使用哪种解决方法时，仔细考虑每种方法的利弊和局限性以及应用程序的特定需求是很重要的。

同样值得注意的是，在同一个查询中使用`limit`和`startAt` / `endAt`方法可能会效率低下，并影响数据库的性能。如果可能的话，通常最好避免在同一个查询中使用`limit`和`startAt` / `endAt`方法，并在决定是否使用这种类型的查询时仔细考虑您的应用程序的特定需求和要求。

总的来说，理解在 Firestore 的同一个查询中使用`limit`和`startAt` / `endAt`方法的局限性，并知道如何解决这一局限性，对于构建高效且可伸缩的应用程序至关重要。通过使用复合索引或云函数，您可以在同一个查询中有效地使用`limit`和`startAt` / `endAt`方法，尽管存在限制。但是，仔细考虑每种方法的利弊和局限性并选择最适合您的应用程序需求的选项是很重要的。

# 限制#5:使用数组的查询

在这一节中，我们将仔细研究 Firestore 中查询阵列的局限性，并探索一些可能的解决方法。

Firestore 是一个 NoSQL 数据库，这意味着它以一种灵活的类似 JSON 的格式存储数据，称为“文档”每个文档可以包含多个键值对，或“字段”，它们可以是各种数据类型，包括字符串、数字、布尔值，甚至数组。

Firestore 中的数组可以方便地存储和检索数据列表，如标签列表或用户 id 列表。但是，在 Firestore 中查询阵列时，需要考虑一些限制。

一个限制是 Firestore 不支持对数组的“包含”查询。这意味着您不能使用`array-contains`操作符来检查数组字段是否包含特定的值。例如，Firestore 中不允许以下查询:

```
db.collection("posts").where("tags", "array-contains", "firebase").get()
```

如果您需要查询在数组字段中包含特定值的文档，这种限制可能会令人沮丧。但是，您可以使用一些变通方法来绕过这一限制。

一种选择是使用云函数在后端执行查询，并将结果返回给客户端。这种方法允许您使用任何您需要的查询逻辑，而不受 Firestore 的查询功能的限制。

另一种选择是对数据进行反规范化，并为数组中的每个元素创建单独的集合。例如，您可以创建一个单独的“tags”集合，其中包含每个标记的文档，以及一个引用父“posts”文档的字段。然后，您可以使用一个简单的“equals”查询来检索匹配特定值的所有“tags”文档:

```
db.collection("tags").where("name", "==", "firebase").get()
```

通过使用这些变通方法之一，您可以在 Firestore 中有效地查询在数组字段中包含特定值的文档，尽管存在限制。但是，在决定使用哪种解决方法时，仔细考虑每种方法的利弊和局限性以及应用程序的特定需求是很重要的。

还值得注意的是，对数据进行反规范化会增加数据库结构的复杂性，并且可能需要额外的维护来保持数据同步。如果可能的话，通常最好避免对数据进行反规范化，并在决定是否使用这种方法时仔细考虑应用程序的特定需求和要求。

总的来说，理解 Firestore 中查询阵列的限制并知道如何解决这一限制对于构建高效和可伸缩的应用程序至关重要。通过使用云函数或对数据进行反规范化，您可以有效地查询在数组字段中包含特定值的文档，尽管存在限制。但是，仔细考虑每种方法的利弊和局限性并选择最适合您的应用程序需求的选项是很重要的。

# 结论

在本文中，我们研究了在 Firestore 中查询数据的一些限制，并探索了一些可能的解决方法。这些限制包括:

*   多个字段上的不等式查询
*   对不同字段使用范围筛选器的查询
*   对不同字段使用 limit 和 orderBy 的查询
*   具有 limit 和 startAt/endAt 的查询
*   使用数组的查询

理解这些限制并知道如何解决它们对于使用 Firestore 构建高效且可扩展的应用程序至关重要。尽管有这些限制，但通过使用复合索引、云函数或对数据进行反规范化，您可以有效地查询数据。

还需要注意的是，其中一些变通方法可能效率低下，或者会影响数据库的性能。如果可能的话，通常最好避免使用这些变通方法，并在决定是否使用它们时仔细考虑应用程序的特定需求和要求。

总的来说，理解在 Firestore 中查询数据的局限性并知道如何解决它们对于构建健壮的可伸缩的应用程序来说是必不可少的。通过使用正确的工具和方法，即使面对这些限制，您也可以有效地查询数据并满足用户的需求。

**不要错过我即将推出的内容和技术指南:**

[](https://medium.com/@nicchong/subscribe) [## 每当 Nic Chong 发布时收到电子邮件。

### 每当 Nic Chong 发布时收到电子邮件。注册后，如果您还没有，您将创建一个中型帐户…

medium.com](https://medium.com/@nicchong/subscribe) 

如果你有什么问题，我在这里帮忙，在评论区等你:)