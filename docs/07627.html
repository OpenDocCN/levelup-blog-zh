<html>
<head>
<title>Manipulating DataFrames with Python | Part 1 (Slicing, Filtering and Indexing)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python处理数据帧|第1部分(切片、过滤和索引)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/manipulating-dataframes-with-python-part-1-slicing-filtering-and-indexing-486c6411ba8?source=collection_archive---------6-----------------------#2021-03-01">https://levelup.gitconnected.com/manipulating-dataframes-with-python-part-1-slicing-filtering-and-indexing-486c6411ba8?source=collection_archive---------6-----------------------#2021-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/72f165165cb402dac54a82a768d00c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fBsfEUsXjOvYMC6B"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卢克·切瑟在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b9bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当处理任何数据集时，数据帧是python中可用的主要工具选项。在这篇文章和随后关于这个主题的文章中，我将讨论DataFrame的所有可用选项，以便更好地了解您的数据。</p><p id="ba49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">这些帖子将成为如何开始使用DataFrame的指南。这些主题本身就值得为它们中的每一个写一篇文章。不过，我会给出对它们的基本理解，如果你想更深入地挖掘，我会附上关于这些主题的深入教程的链接。</em></p><p id="5223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在用Python操作数据帧的第1部分中，我们将介绍一些基本技术，即</p><ol class=""><li id="5a3c" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae kc" href="#0482" rel="noopener ugc nofollow">切片</a></li><li id="cd1a" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae kc" href="#7f36" rel="noopener ugc nofollow">过滤</a></li><li id="ab42" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae kc" href="#8f76" rel="noopener ugc nofollow">分度</a></li></ol><h1 id="0482" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">切片数据帧</h1><p id="410f" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">切片是指我们想要获取数据的一部分，并了解它的全部内容。就像你拿一片芒果，同样一片数据。切片既可以跨列进行，也可以跨行进行。有两种方法可以做到——</p><p id="4334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用df.loc() → loc需要行索引和列的标签名进行切片。</p><p id="fbfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用df.iloc() → iloc需要行和列的数字索引值。</p><p id="0a14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据帧切片非常类似于我们在Python中看到的列表。切片的快速总结写在下面。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="b07d" class="nc lr iq my b gy nd ne l nf ng">#returns series of "col_name" of x to y row index -&gt; part of #col_name from x to y-1 index<br/>df['col_name'][x:y]</span><span id="5baa" class="nc lr iq my b gy nh ne l nf ng">#slicing using loc -&gt; here row_indexes are labels</span><span id="02c8" class="nc lr iq my b gy nh ne l nf ng">#returns series of data containing rows and columns sequentially #from col1 to coln and row1 to rown<br/>df.loc['row1_index':'rown_index', 'col1':'coln']</span><span id="21c0" class="nc lr iq my b gy nh ne l nf ng">#returns the value from row col pair in dataframe<br/>df.loc['row_index', 'col']</span><span id="5dbc" class="nc lr iq my b gy nh ne l nf ng">#slicing using iloc -&gt; here row indexes are numbers<br/>#returns the series of data from row_num_start to row_num_end-1<br/>df.iloc[[row_num_start, row_num_end]]</span><span id="3ee5" class="nc lr iq my b gy nh ne l nf ng">#returns the dataframe from row_num_start to row_num_end-1 and #from col_num_start to col_num_end-1<br/>df.iloc[[row_num_start, row_num_end], [col_num_start, col_num_end]]</span><span id="6003" class="nc lr iq my b gy nh ne l nf ng">#returns the value from the row col pair in dataframe<br/>df.iloc[row_index, col_index]</span></pre><p id="262a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更深入的细节可以从这里的<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html" rel="noopener ugc nofollow" target="_blank">参考</a>。</p><h1 id="7f36" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">过滤数据帧</h1><p id="eff4" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">假设您想要基于某些边界线来分析数据，或者您想要找到某一列的特定值的所有数据的趋势。对于这种情况，我们根据我们的需求过滤掉数据。</p><p id="7ce2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">过滤可以通过多种方式完成，可以基于类别标签或数值，也可以是两者的组合。你只需要问自己问题，好奇去发现数据到底想说什么。这个特定值对数据有什么影响？有没有一种方法可以修改值，使数据变得更清晰？诸如此类。</p><p id="53dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面我列举了一些过滤数据的例子。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="dd50" class="nc lr iq my b gy nd ne l nf ng">#creating boolean series<br/>```df.col_val&gt;60 is the filter for selecting only the rows which have value greater than 60, filters can also be combined using |, &amp; and ! operators ```<br/>df.loc[df.col_cal&gt;60]</span><span id="437d" class="nc lr iq my b gy nh ne l nf ng">#selecting columns with all non-zeros <br/>df.loc[:, df.all()]</span><span id="0ee9" class="nc lr iq my b gy nh ne l nf ng">#selecting columns with any non-zeros <br/>df.loc[:, df.any()]</span><span id="9d4c" class="nc lr iq my b gy nh ne l nf ng">#selecting columns with any NaNs<br/>df.loc[:, df.isnull().any()]</span><span id="5785" class="nc lr iq my b gy nh ne l nf ng">#selecting columns with no NaN values<br/>df.loc[:, df.isnull().all()]</span><span id="2d34" class="nc lr iq my b gy nh ne l nf ng">#dropping rows with any NaNs <br/>df.dropna(how = 'any')</span><span id="d76f" class="nc lr iq my b gy nh ne l nf ng">#filtering a column based on another <br/>df.eggs[df.salt&gt;55]</span><span id="6bb9" class="nc lr iq my b gy nh ne l nf ng">#modyfying a column based on another<br/>df.eggs[df.salt&gt;55] += 5</span><span id="0cde" class="nc lr iq my b gy nh ne l nf ng">#convert to dozens(12) unit<br/>df.floordiv(12)<br/>df.apply(lambda x: x//12)</span></pre><p id="45b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有关更多示例和过滤方式，请参考本文。</p><h1 id="8f76" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">索引对象和标签数据</h1><p id="73b1" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">让我们从理解索引以及它们与数据帧的关系开始。</p><p id="47e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">索引是标签序列，它们是不可变的(像字典键或元组)，并且在数据类型上是同构的(像Numpy数组)。</p><p id="af21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数列是带索引的1D数组。</p><p id="47cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据帧是以系列为列的2D数组(可以把它们想象成包含字段、记录和索引的SQL表)。</p><p id="4ae3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们对什么是指数和数列有了一个大致的概念，让我们深入实际的东西。</p><p id="6dca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来要讨论的索引主题-</p><p id="255c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.创建系列v/s创建索引</p><p id="8c54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.修改索引值</p><p id="d4f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.分级索引</p><p id="95c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.花式索引</p><p id="77d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.排序索引</p><h2 id="2c4e" class="nc lr iq bd ls ni nj dn lw nk nl dp ma ko nm nn me ks no np mi kw nq nr mm ns bi translated">1.创建系列v/s创建索引</h2><p id="4610" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">数据帧是多个系列的整体组合。pandas系列是一个有序的一维数据数组，带有索引。一个系列中的所有数据都属于同一数据类型。数据帧中的一列是熊猫系列。索引是引用数据帧中任何一行的重要部分。下面是如何用Python创建一个系列和一个索引。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="6a15" class="nc lr iq my b gy nd ne l nf ng">#Creating a Series<br/>import pandas as pd<br/>prices = [10.70, 10.86, 10.74, 8.48]<br/>shares = pd.Series(prices)<br/>print(shares)</span><span id="a184" class="nc lr iq my b gy nh ne l nf ng"><em class="lb">0    10.70 <br/>1    10.86 <br/>2    10.74 <br/>3     8.48 <br/>dtype: float64</em></span><span id="ff5d" class="nc lr iq my b gy nh ne l nf ng">#Creating an Index<br/>import pandas as pd<br/>days = ['Mon', 'Tue', 'Wed', 'Thur']<br/>prices = [10.70, 10.86, 10.74, 8.48]<br/>shares = pd.Series(prices, index=days)<br/>print(shares)</span><span id="4552" class="nc lr iq my b gy nh ne l nf ng">Mon     10.70 <br/>Tue     10.86 <br/>Wed     10.74 <br/>Thur     8.48 <br/>dtype: float64</span></pre><p id="16a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，索引是从0到n-1的数值，其中n是总行数。索引可以是日期-时间字段、单级列表或多级列表。</p><h2 id="25f0" class="nc lr iq bd ls ni nj dn lw nk nl dp ma ko nm nn me ks no np mi kw nq nr mm ns bi translated">2.修改索引值</h2><p id="1087" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">因为索引条目是不可变的，所以它们不能被直接修改。如果您想要更改索引中的任何值，您必须设置另一个系列。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="1869" class="nc lr iq my b gy nd ne l nf ng">shares.index[2] = 'Wednesday' #Wrong<br/>TypeError: Index does not support mutable operations</span><span id="9a0c" class="nc lr iq my b gy nh ne l nf ng">#right way -&gt; overriding all at once<br/>shares.index = ['Monday', 'Tuesday', Wednesday', 'Thursday']</span><span id="8b1e" class="nc lr iq my b gy nh ne l nf ng">#Assigning Index Values<br/>unemployment.index = unemployment['zip'] #where zip is a column in unemployment</span></pre><h2 id="d4d8" class="nc lr iq bd ls ni nj dn lw nk nl dp ma ko nm nn me ks no np mi kw nq nr mm ns bi translated">3.分级索引(多重索引)</h2><p id="4af1" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">将索引设置为两列或更多列的组合</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7337" class="nc lr iq my b gy nd ne l nf ng">stocks = stocks.set_index([‘symbol’, ‘Date’]) <br/>#where [‘symbol’, ‘Date’] is ordered list of column lables</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/0228bd29f15530640a6dab87d7859e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvLZEyX06IddX7Txe7GSug.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">多索引数据帧</figcaption></figure><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="1f2d" class="nc lr iq my b gy nd ne l nf ng">print(stocks.index)<br/>Multiplex(levels = [['CSCO', 'NVDA'], ['2016-03-08', '2019-03-09', '2016-03-10']], labels = [0, 0, 0, 1, 1, 1],[0, 1, 2, 0, 1, 2], names = ['Symbol', 'Date'])</span></pre><p id="589b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标签值基于各个级别的索引。这里，CSCO和NVDA分别被赋值为0、1，2016年3月8日、2016年3月9日、2016年3月10日分别被赋值为0、1、2。</p><h2 id="b7b7" class="nc lr iq bd ls ni nj dn lw nk nl dp ma ko nm nn me ks no np mi kw nq nr mm ns bi translated">4.花式索引</h2><p id="532c" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">这只是在层次索引上放置了一个顶层过滤。当您只想获取索引的某些值的数据时。</p><p id="8bda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">最外层分度</strong></p><p id="1283" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于最外层索引值进行过滤</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4d8d" class="nc lr iq my b gy nd ne l nf ng">stocks.loc[(['CSCO', 'NVDA'], '2016-03-09'), :]</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/3ac3de35c31750da37011c67c200678c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3qzi7tvOrvwJGFx-cR6Gg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">最外层索引</figcaption></figure><p id="8a7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">最里面的索引</strong></p><p id="9c1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于最内部的索引值进行过滤</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="be18" class="nc lr iq my b gy nd ne l nf ng">stocks.loc[('CSCO', [2016-03-08, 2016-03-09]), 'Close']</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/68d3c26e0efee6ccb5b7aff9cf656cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*B9lZCZXu-U0Irpxo3Z2VPA.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">最内部索引</figcaption></figure><h2 id="3d9c" class="nc lr iq bd ls ni nj dn lw nk nl dp ma ko nm nn me ks no np mi kw nq nr mm ns bi translated">5.排序索引</h2><p id="fbba" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">该排序在存储器中创建新的数据帧，对该数据帧的所有索引进行排序。如果inplace参数为False，则返回按标签排序的新数据帧，否则更新原始数据帧并返回None。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="11aa" class="nc lr iq my b gy nd ne l nf ng">stocks = stocks.sort_index()<br/>print(stocks)</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/0228bd29f15530640a6dab87d7859e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvLZEyX06IddX7Txe7GSug.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">基于索引的排序数据帧(升序)</figcaption></figure><blockquote class="nw"><p id="ad19" class="nx ny iq bd nz oa ob oc od oe of la dk translated">要了解更多关于数据框架分析方法的知识，请阅读本文的下一部分<a class="ae kc" href="http://ankita2108prasad.medium.com/manipulating-dataframes-with-python-part-2-pivoting-stacking-and-melting-99e4aa7f5507" rel="noopener">这里</a>。</p></blockquote></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="36a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">我们连线上</em><a class="ae kc" href="https://www.linkedin.com/in/ankita-prasad-5a0156137/" rel="noopener ugc nofollow" target="_blank"><em class="lb">LinkedIn</em></a><em class="lb">。你也可以通过ankita2108prasad@gmail.com联系我。</em></p></div></div>    
</body>
</html>