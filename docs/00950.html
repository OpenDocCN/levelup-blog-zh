<html>
<head>
<title>React Hooks Explained in 5 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在5分钟内解释React Hooks</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-hooks-cheat-sheet-part-1-ed02dd90be5a?source=collection_archive---------1-----------------------#2019-09-28">https://levelup.gitconnected.com/react-hooks-cheat-sheet-part-1-ed02dd90be5a?source=collection_archive---------1-----------------------#2019-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="81af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速简单的挂钩指南</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a0ec00aaf88c7dd3124a7f2921639851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlxyaRsiWBnve0aRd3FDkQ.jpeg"/></div></div></figure><h1 id="35ee" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">钩子是什么？</h1><ul class=""><li id="5bce" class="lv lw iq jp b jq lx ju ly jy lz kc ma kg mb kk mc md me mf bi translated">“挂钩”React特性的功能</li><li id="e0e9" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">只能在函数组件中使用</li><li id="1449" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">您可以使用内置挂钩，也可以创建自己的挂钩</li></ul><h1 id="29a2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么要引入钩子？</h1><h2 id="598c" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">不能在组件之间重用有状态逻辑</h2><p id="c4c0" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">你可能对试图解决这个问题的渲染道具和hoc之类的模式很熟悉。</p><p id="8b5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这些模式要求您重构组件</p><blockquote class="na nb nc"><p id="5a4e" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated">钩子允许你在不改变组件层次结构的情况下重用有状态逻辑。</p></blockquote><h2 id="6692" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">生命周期很奇怪</h2><p id="8ebc" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">相关的代码被分割开来，但是完全不相关的代码最终组合成一个生命周期方法</p><blockquote class="na nb nc"><p id="457d" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated">钩子可以让你把不相关的部分分开，把相关的部分组合在一个函数中</p></blockquote><h2 id="0384" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">上课并不酷</h2><ul class=""><li id="8e79" class="lv lw iq jp b jq lx ju ly jy lz kc ma kg mb kk mc md me mf bi translated">代码太多，讨厌！</li><li id="1794" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">必须绑定事件处理程序</li><li id="ac18" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">必须了解“这”是如何工作的</li></ul></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="a26e" class="kx ky iq bd kz la no lc ld le np lg lh li nq lk ll lm nr lo lp lq ns ls lt lu bi translated">React中的内置挂钩</h1><h1 id="0e69" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用状态</h1><h2 id="3067" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">它的作用</h2><ul class=""><li id="8f33" class="lv lw iq jp b jq lx ju ly jy lz kc ma kg mb kk mc md me mf bi translated">在组件中添加状态</li><li id="035d" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">在组件的重新呈现过程中保持状态</li></ul><h2 id="a822" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">句法</h2><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="ba21" class="ml ky iq nu b gy ny nz l oa ob">const [ <strong class="nu ir">value</strong> , <strong class="nu ir">function</strong> ] = useState( initialValue );</span><span id="e1dd" class="ml ky iq nu b gy oc nz l oa ob">const [ count , setCount ] = useState( 0 );</span></pre><p id="b9c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">useState的唯一参数是初始状态值。</p><p id="134e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它返回一个包含两件事的数组:一个<strong class="jp ir">值</strong>和一个改变值的<strong class="jp ir">函数。数组析构通常用于获取对。</strong></p><p id="4016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数类似于类组件中的<strong class="jp ir"> this.setState() </strong>，只是它不合并新旧状态。它取而代之。</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="661d" class="ml ky iq nu b gy ny nz l oa ob">setCount(1)</span></pre><h2 id="921c" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">更大的</h2><p id="0359" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">您可以在一个组件中多次使用同一个钩子。</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="315f" class="ml ky iq nu b gy ny nz l oa ob">const [ name, setName ] = useState( null );</span><span id="54b2" class="ml ky iq nu b gy oc nz l oa ob">const [ age, setAge ] = useState( null );</span><span id="d5ac" class="ml ky iq nu b gy oc nz l oa ob">setName( 'Rick' );</span><span id="4539" class="ml ky iq nu b gy oc nz l oa ob">setAge( 60 );</span></pre><p id="8e5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的状态也可以是一个对象，但是如果您只想更改其中的某些属性，您必须手动合并它们。</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="57e3" class="ml ky iq nu b gy ny nz l oa ob">const [ person, setPerson ] = useState( { name : null , age : null } );</span><span id="c5a9" class="ml ky iq nu b gy oc nz l oa ob">setPerson({ ...person, name : ‘Manan’ })</span></pre><p id="5b59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果您希望更改整个对象，而不仅仅是它的某些属性，建议只使用一个对象</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="3d8a" class="kx ky iq bd kz la no lc ld le np lg lh li nq lk ll lm nr lo lp lq ns ls lt lu bi translated">使用效果</h1><h2 id="e5c4" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">什么是“效果”？</h2><p id="bb1c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我们将类似数据获取、订阅或手动更改DOM的操作称为“副作用”或“效果”，因为它会影响其他组件，并且在呈现期间无法完成。</p><p id="ce18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种效果:</p><ul class=""><li id="69c4" class="lv lw iq jp b jq jr ju jv jy od kc oe kg of kk mc md me mf bi translated"><strong class="jp ir">那些不需要清理的</strong>:网络请求、手动DOM突变、日志记录等</li><li id="da2f" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">那些确实需要清理的:</strong>订阅外部数据</li></ul><p id="69aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么是useEffect </strong>？</p><blockquote class="og"><p id="48be" class="oh oi iq bd oj ok ol om on oo op kk dk translated">useEffect是componentDidMount，componentDidUpdate和componentWillUnmount全部统一成一个API。</p></blockquote><h2 id="96c5" class="ml ky iq bd kz mm oq dn ld mo or dp lh jy os mr ll kc ot mt lp kg ou mv lt mw bi translated">句法</h2><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="2589" class="ml ky iq nu b gy ny nz l oa ob">useEffect( () =&gt; { } );</span></pre><ul class=""><li id="4ff9" class="lv lw iq jp b jq jr ju jv jy od kc oe kg of kk mc md me mf bi translated">useEffect增加了从功能组件执行副作用的能力。</li><li id="76d9" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">useEffect将一个函数作为参数，称为'<strong class="jp ir">效果</strong>'</li><li id="4c22" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">该效果可以访问属性和状态，因为它位于功能组件内部</li></ul><h2 id="7967" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">清理功能</h2><p id="0f8b" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">您可以选择通过返回一个函数来指定清理函数</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="657b" class="ml ky iq nu b gy ny nz l oa ob">useEffect(() =&gt; {</span><span id="9424" class="ml ky iq nu b gy oc nz l oa ob">// effect</span><span id="8362" class="ml ky iq nu b gy oc nz l oa ob">return <strong class="nu ir">() =&gt; {}</strong>   // clean up</span><span id="e298" class="ml ky iq nu b gy oc nz l oa ob">});</span></pre><p id="fe8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个清理函数叫做-</p><ul class=""><li id="45a3" class="lv lw iq jp b jq jr ju jv jy od kc oe kg of kk mc md me mf bi translated">当<strong class="jp ir">组件卸下</strong>时</li><li id="1a43" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">在<strong class="jp ir">重新运行</strong>之前，由于另一个渲染，使用效果。</li></ul><p id="a7af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更多</strong></p><p id="9774" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个组件中可以使用多个useEffect挂钩。</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="7eb4" class="ml ky iq nu b gy ny nz l oa ob">useEffect(<strong class="nu ir">effect1</strong>)</span><span id="3d69" class="ml ky iq nu b gy oc nz l oa ob">useEffect(<strong class="nu ir">effect2</strong>)</span></pre><p id="c9af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">钩子可以让你把相关的东西组合成一个效果来组织副作用。</p><blockquote class="og"><p id="4dbc" class="oh oi iq bd oj ok ol om on oo op kk dk translated">默认情况下，React会在每次渲染后运行效果</p></blockquote><blockquote class="na nb nc"><p id="7890" class="jn jo nd jp b jq ov js jt ju ow jw jx ne ox ka kb nf oy ke kf ng oz ki kj kk ij bi translated">等等，什么？它在每次渲染后运行效果？如果我不想在每次渲染后都运行它呢？</p></blockquote><h2 id="5bd7" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">使用依赖关系优化效果</h2><p id="64d3" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">在某些情况下，在每次渲染后应用效果或清理可能会产生性能问题。useEffect为此提供了内置功能，非正式地称为<strong class="jp ir">依赖关系</strong></p><p id="5ead" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以告诉React to <em class="nd"> skip </em>应用一个效果，如果某些值在重新渲染之间没有改变，来自道具、状态等的值。为此，<strong class="jp ir">将一个数组作为可选的第二个参数传递给useEffect </strong>:</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="8b2d" class="ml ky iq nu b gy ny nz l oa ob">useEffect( effect, <strong class="nu ir">[ value1, value2 ]</strong> )</span></pre><ul class=""><li id="94fd" class="lv lw iq jp b jq jr ju jv jy od kc oe kg of kk mc md me mf bi translated">只有当数组中的任何一个值改变时，效果才会被应用</li><li id="106d" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">如果你使用这个优化，<strong class="jp ir">确保数组包含了效果使用的所有值。</strong>否则，效果将保持使用旧值。</li></ul><h2 id="5947" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">仅运行一次效果</h2><p id="817f" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">如果您希望只运行一次效果，即效果在装载时运行，而可选的清理功能在卸载时运行，则只运行一次。您可以<strong class="jp ir">传递一个空数组[]作为第二个参数。</strong></p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="9b1f" class="ml ky iq nu b gy ny nz l oa ob">useEffect( effect, <strong class="nu ir">[ ]</strong> )</span></pre><p id="236c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是一个黑客或一些特殊情况下的使用效果。这只是告诉React你的效果不依赖于道具或状态的任何值，所以它不需要重新运行。</p><h2 id="9746" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">避免这些错误！</h2><p id="f714" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">如果一个效果调用一个函数，在效果中定义它，然后添加该函数使用的值作为效果的依赖项</p><p id="ac05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这是错误的</strong></p><ul class=""><li id="92b5" class="lv lw iq jp b jq jr ju jv jy od kc oe kg of kk mc md me mf bi translated">效果调用foo</li><li id="0db2" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">foo是在效果之外定义的</li><li id="5a6e" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">foo依赖于x</li><li id="b9d3" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">x不添加到依赖项中</li></ul><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="ede1" class="ml ky iq nu b gy ny nz l oa ob">foo() { // depends on x }</span><span id="0be2" class="ml ky iq nu b gy oc nz l oa ob">useEffect( () =&gt; { <br/>  foo()<br/>}, [] )</span></pre><p id="9ee0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这是对的</strong></p><ul class=""><li id="7654" class="lv lw iq jp b jq jr ju jv jy od kc oe kg of kk mc md me mf bi translated">效果调用foo</li><li id="69a3" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">foo在effect内部定义</li><li id="9a3f" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">foo依赖于x</li><li id="4e2d" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">x被添加到依赖关系中</li></ul><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="0f68" class="ml ky iq nu b gy ny nz l oa ob">useEffect( () =&gt; {<br/>  foo() { // depends on x }<br/>  foo()<br/>}, [x] )</span></pre><h1 id="2403" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如果您不能在效果中移动功能</h1><h2 id="8913" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">如果该函数没有依赖性</h2><p id="6e89" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">将函数移到函数组件之外，这样可以保证它没有使用任何属性或状态，因此它不需要在依赖列表中</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="c196" class="ml ky iq nu b gy ny nz l oa ob">foo() { }   // outside component</span><span id="8e97" class="ml ky iq nu b gy oc nz l oa ob">const Comp = () =&gt; {<br/>  useEffect( () =&gt; {<br/>    foo()<br/>  }, [] )</span><span id="4d30" class="ml ky iq nu b gy oc nz l oa ob">return … }</span></pre><h2 id="3f4c" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">如果该函数具有依赖性</h2><p id="5852" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">如果您调用的函数是纯计算的，并且在渲染时调用是安全的，那么您可以在效果之外调用它，并在依赖项中添加返回值。</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="938e" class="ml ky iq nu b gy ny nz l oa ob">const Comp = () =&gt; {<br/>  const <strong class="nu ir">x = foo()</strong><br/>  useEffect( () =&gt; {}, <strong class="nu ir">[x]</strong> )<br/>  return …<br/>}</span></pre><h2 id="f185" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">最后一个选择</h2><p id="389a" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">作为最后一招，如果以上都不适合你，就把函数添加到依赖项中。将其定义包装在useCallback挂钩中，并将其依赖项作为useCallBack的第二个参数。</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="cccc" class="ml ky iq nu b gy ny nz l oa ob">foo = <strong class="nu ir">useCallBack</strong>( () =&gt; {}, [x] )</span><span id="8a1b" class="ml ky iq nu b gy oc nz l oa ob">useEffect( () =&gt; { foo() }, [foo] )</span></pre><p id="59ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样保证了效果只在x变化时运行，因为效果依赖于foo，foo依赖于x。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="3aa1" class="kx ky iq bd kz la no lc ld le np lg lh li nq lk ll lm nr lo lp lq ns ls lt lu bi translated">钩子的规则</h1><p id="18c9" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated"><strong class="jp ir">只调用顶层的钩子</strong></p><p id="b065" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要在循环、条件或嵌套函数中调用钩子。这确保了每次组件呈现时钩子都以相同的顺序被调用，这是钩子工作所必需的。</p><p id="f096" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">不要在正常函数中调用钩子</strong></p><ul class=""><li id="ca66" class="lv lw iq jp b jq jr ju jv jy od kc oe kg of kk mc md me mf bi translated">从React函数组件调用钩子。</li><li id="9ea4" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">从自定义挂钩调用挂钩</li></ul><p id="b0ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用eslint-plugin-react-hooks来执行这两条规则。</p><h1 id="454b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">构建自定义挂钩</h1><p id="8300" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated"><strong class="jp ir">自定义挂钩</strong></p><ul class=""><li id="6f79" class="lv lw iq jp b jq jr ju jv jy od kc oe kg of kk mc md me mf bi translated">名称以“use”开头的函数</li><li id="2000" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">它可能会调用其他钩子</li><li id="7f43" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">没有具体的签名</li><li id="4636" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">参数和返回值可以是任何东西</li></ul><h1 id="822c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">例子</h1><h2 id="4c97" class="ml ky iq bd kz mm mn dn ld mo mp dp lh jy mq mr ll kc ms mt lp kg mu mv lt mw bi translated">使用窗口大小</h2><p id="6643" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">返回一个包含窗口宽度和高度的对象</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pa"><img src="../Images/44e9119f67e9433f4813f7c894973172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3TvYzgiBSlq_5yXB"/></div></div></figure></div></div>    
</body>
</html>