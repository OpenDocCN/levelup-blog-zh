<html>
<head>
<title>Dealing with the n+1 problem! Optimising Django: Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理n+1问题！优化Django:第4部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=collection_archive---------4-----------------------#2020-08-27">https://levelup.gitconnected.com/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=collection_archive---------4-----------------------#2020-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7d0d768e613a0f7367d2d2c8d32459af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ii89QKBeSfY5B8hofOU0rA.png"/></div></div></figure><p id="e1d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个问题在Django Rest框架的用户中是众所周知的，所以总是值得一提。如果您使用或打算使用DRF，这篇文章将解释<code class="fe kw kx ky kz b">n+1</code>问题是如何在最无关紧要的用例中出现的，以及如何轻松处理它。</p><p id="13db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你还没有尝试过DRF，我全心全意地推荐你试一试。它减少了启动和运行REST框架所需的大量开发工作，同时仍然足够灵活，可以满足您几乎所有的编程需求</p><p id="e93d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您曾经使用过Django，您肯定会对Django Rest框架的序列化程序很熟悉。它验证输入的数据，有时将输入的数据加工成您所需要的形式，以满足任何后端需求。此外，它还将模型数据转换成REST端点为上游客户端指定的任何格式。</p><p id="236b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用序列化器还可以做许多其他事情，我在这里就不一一介绍了。然而，我要介绍的是一个相对常见的用例，它会导致这些SQL查询再次爆炸:n+1问题。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="0a35" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">那么什么是n+1问题呢？</h1><p id="268a" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">n+1问题是这样的:<a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-multiple-massive-tables-in-a-single-admin-optimizing-django-part-3-2c4ee2fec142?source=friends_link&amp;sk=96a35d8e435719670b356ca4c4606c1c">让我们以第3部分</a>中的例子为例:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="bd1a" class="mt li iq kz b gy mu mv l mw mx">class User(AbstractUser):<br/>    def __str__(self):<br/>        return ' '.join([self.first_name, self.last_name])<br/><br/>class Event(models.Model):<br/>    id = models.UUIDField(default=uuid.uuid4(), primary_key=True)<br/>    event_name = models.TextField(default='')</span><span id="66be" class="mt li iq kz b gy my mv l mw mx">class Ticket(models.Model):<br/>    user = models.ForeignKey(User, on_delete=models.CASCADE)<br/>    event = models.ForeignKey(Event, on_delete=models.CASCADE, null=True)</span></pre><p id="2c5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们有用户、事件和用户参加事件的门票。</p><p id="517d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，假设我们想要创建一个视图，在给定一个user_id的情况下，该视图返回用户、其姓名以及他要参加的活动的列表。其视图和序列化程序可能如下所示:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="e37f" class="mt li iq kz b gy mu mv l mw mx">class UserTicketSerializer(ModelSerializer):<br/>    event_name = SerializerMethodField()<br/>    class Meta:<br/>        model = UserTicket<br/>        fields = ('event_name',)<br/><br/>    def get_event_name(self, ticket):<br/>        return 'Event {}'.format(ticket.event.event_name)<br/><br/><br/>class UserSerializer(ModelSerializer):<br/>    name = SerializerMethodField()<br/>    events = UserTicketSerializer(many=True, source='userticket_set')<br/><br/>    class Meta:<br/>        model = User<br/>        fields = ('username', 'name', 'events')<br/><br/>    def get_name(self, user):<br/>        return user.__str__()<br/><br/><br/>class UserView(APIView):<br/>    def get(self, request, user_id, *args, **kwargs):<br/>        user_obj = User.objects.get(id=user_id)<br/>        serializer = UserSerializer(user_obj)<br/>        return Response(serializer.data, status=status.HTTP_200_OK)</span></pre><p id="5e62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个简单调用的结果如下所示:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="c1f3" class="mt li iq kz b gy mu mv l mw mx">GET /user/1/</span><span id="8cd5" class="mt li iq kz b gy my mv l mw mx">{<br/>    "username": "admin",<br/>    "name": "Mark Ang",<br/>    "events": [ { "event_name": "Event Event 25"},<br/>                { "event_name": "Event Event 27"},<br/>                  ... [6 more]<br/>    ]<br/>}</span></pre></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="ffcf" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">那么问题出在哪里？已经开始了！</h1><p id="8b2a" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">是啊，是啊，我们快到了。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/b18c502fbc2ab9d9db180e38adb758d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PArO-APeY932PJiyP8SCeA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">我们还没完，这只是第一点。</figcaption></figure><p id="14b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题出在SQL上。该API调用的SQL日志如下所示:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/12793d4b758ef98108c264bf9f778de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgNxMdtVVEhnpp9Z5Wlidw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">14个巨大的查询！这只是开始。</figcaption></figure><p id="2685" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，它很长。</p><p id="33c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">令人望而却步的长。</p><p id="e812" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么问题出在哪里呢？</p><p id="97fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很简单，真的。这是因为嵌套的序列化程序，对于提供给它的每一张票，它都会为它进行一次SQL查询。对于<code class="fe kw kx ky kz b">n</code>票，这是<code class="fe kw kx ky kz b">n</code>查询，对于用户的单个查询，这是<code class="fe kw kx ky kz b">n+1</code> SQL查询。</p><p id="3673" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您在这里看到的时间很短，因为它们是在数据库和服务器位于同一台机器上的设置中收集的。如果您的服务器需要10ms才能到达您的数据库，那么您将需要额外处理140ms的事务。随着web应用程序数据的增长，这可能会成为一个需要处理的问题。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="1072" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">那么，我们该如何处理呢？</h1><p id="bd99" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">最后我们得到了答案:预取！</p><p id="1d90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么什么是预取呢？好吧，把它想象成缓存与你正在寻找的物品相关的东西。</p><p id="9f73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您进行选择查询时(Django的QuerySet会为您做这件事，所以您不会直接看到它)，您是在查询一个表上的特定数据。嗯，预取可以帮助你提前从不同的表<em class="nf"/>中收集相关对象的数据。在我们的例子中，我们可以预取与用户相关的票据，以及与这些票据相关的事件。</p><p id="63b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么这很有帮助？序列化程序试图从queryset中获取它需要的信息。因为默认情况下queryset没有相关的对象数据，所以序列化程序被迫执行新的查询。</p><p id="31af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是通过预取相关数据，序列化程序不需要做任何事情！</p><h2 id="0fec" class="mt li iq bd lj ng nh dn ln ni nj dp lr kj nk nl lv kn nm nn lz kr no np md nq bi translated">让我们看看这是怎么做到的！</h2><p id="2a45" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">让我们修改我们的queryset，以包括一个预取，如下所示:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="f260" class="mt li iq kz b gy mu mv l mw mx">class UserView(APIView):<br/>    def get(self, request, user_id, *args, **kwargs):<br/>        qs = User.objects.filter(id=user_id). \<br/>             prefetch_related('userticket_set__event'). \<br/>             first()<br/>        serializer = UserSerializer(qs)<br/>        return Response(serializer.data, status=status.HTTP_200_OK)</span></pre><p id="b4e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且生成的查询日志要短得多:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5e2a663c581c06d15a9301cd02025c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*G-YvuJtICzPF-aV4W0ulgA.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">我们减少了多达9个查询！</figcaption></figure><p id="c2c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SQL更难看，但是谁在乎呢？！我们刚刚解决了我们的<code class="fe kw kx ky kz b">n+1</code>问题！通过预取相关的票证及其事件数据，我们将查询数量从14个减少到5个。</p><h1 id="94ee" class="lh li iq bd lj lk ns lm ln lo nt lq lr ls nu lu lv lw nv ly lz ma nw mc md me bi translated">那么这个故事的寓意是什么呢？</h1><p id="3c82" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">不要低估预取的力量！当在同一个序列化器中处理多个相关对象时(当您在序列化器中嵌套一个序列化器时，通常会遇到它们)，预取可能是您最好的朋友！</p><p id="f29b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，这里的警告是要确保你只预取你知道你需要的。不要随意预取，因为预取确实会使您的SQL在数据库中执行起来更加复杂和昂贵。然而，正如您所见，潜在的性能提升不容小觑。如果有疑问，总是衡量和比较结果，以确保你的优化是你想要他们做的。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="da3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nf">感谢您通读本文！如果你想知道如何在你的Django应用程序中设置一个SQL日志，</em> <a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/django-sql-debugging-with-an-sql-log-middleware-optimising-django-part-1-ca3b5c20d892?source=friends_link&amp;sk=263f4d36dde6377b91df0acf4e5208aa"> <em class="nf">点击这里查看这个系列的第一部分，这正是我要讨论的！</em> </a> <em class="nf">或查看</em> <a class="ae mk" href="https://medium.com/swlh/5-things-the-coronavirus-forced-the-world-to-learn-about-remote-work-66dc6efcaf04?source=friends_link&amp;sk=a79ff0cf5e0aaf66865d628b6a661db4" rel="noopener"> <em class="nf">这篇文章我解释了为什么远程工作正在接管世界</em> </a> <em class="nf">(好吧，这太容易了，但无论如何还是要查看一下！)</em></p></div></div>    
</body>
</html>