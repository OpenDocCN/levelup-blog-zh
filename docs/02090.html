<html>
<head>
<title>Make Way For The Matrix — A Complete Guide to Solving 2D Array Coding Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为矩阵让路——解决2D阵列编码问题的完整指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/make-way-for-the-matrix-a-complete-guide-to-solving-2d-array-coding-problems-725096d122d9?source=collection_archive---------1-----------------------#2020-02-18">https://levelup.gitconnected.com/make-way-for-the-matrix-a-complete-guide-to-solving-2d-array-coding-problems-725096d122d9?source=collection_archive---------1-----------------------#2020-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/845c5ee7f07d741f78f6a63932e424c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BXjgZR1qubs-XgXs"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">乔希·里默尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b3a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数矩阵问题乍一看可能令人生畏。然而，它们根本没有那么难解决！在本文中，我将分解解决这些问题的步骤，首先概述矩阵及其使用方法。</p><p id="3589" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的事情先来！让我们大致了解一下什么是矩阵。</p><blockquote class="lb"><p id="f63a" class="lc ld iq bd le lf lg lh li lj lk la dk translated">什么是矩阵？</p></blockquote><p id="9257" class="pw-post-body-paragraph kd ke iq kf b kg ll ki kj kk lm km kn ko ln kq kr ks lo ku kv kw lp ky kz la ij bi translated">来自维基百科的定义:“在数学中，一个<strong class="kf ir">矩阵</strong>(复数<strong class="kf ir">矩阵</strong>)是一个由数字、符号或表达式构成的矩形<em class="lq">数组</em>，排列在<em class="lq">行</em>和<em class="lq">列中。”</em></p><p id="b9c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在大多数地方，术语矩阵和二维数组可以互换使用。二维数组可以完全像矩阵一样工作。二维数组可以被视为由行和列组成的表格。</p><h1 id="7f02" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">矩阵的例子</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/d2ae935f62184c452ae2eb556508fba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QJzBqqCu0SdvoXL5D-hXw.jpeg"/></div></div></figure><h1 id="8139" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">现实生活中我们在哪里看到矩阵</h1><ul class=""><li id="ed2f" class="mu mv iq kf b kg mw kk mx ko my ks mz kw na la nb nc nd ne bi translated">主要是在数据库系统中，表中的数据存储在特定行和列的交叉点上。</li><li id="fceb" class="mu mv iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">在图形中矩阵代表像素。</li><li id="1441" class="mu mv iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">在电影售票系统(row-seat-number)或任何使用行列识别座位的订票系统(公共汽车/火车/航空公司)中。</li></ul><h1 id="0a64" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">初始化和遍历</h1><p id="4213" class="pw-post-body-paragraph kd ke iq kf b kg mw ki kj kk mx km kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">2D数组表示为列表的列表。每个列表通常代表一行，列表的每个元素代表一列。在本例中，我们将设置一个5排座位的剧院，每排10个座位。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4e1b97539a22c4209c22c6901da04637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*ydBvObBnVXDdmfuMfLFMTA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">初始化2D数组</figcaption></figure><p id="9eac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上也可以通过嵌套列表理解来实现:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/69119b546872b4cdd92b2784638f4d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Az5cY44NibDQxzLd9rFgg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用列表理解初始化2D数组</figcaption></figure><p id="bb1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设，现在我们需要通过设置值1来更新最后2行已预订。这是怎么做的:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/b67cc16e7b6828e6e310c70707967c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9LuocnK_BeYrRL5x7qtIDQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更新2D数组</figcaption></figure><h1 id="a183" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">热身问题</h1><p id="af96" class="pw-post-body-paragraph kd ke iq kf b kg mw ki kj kk mx km kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">既然我们已经介绍了基础知识，让我们从一个简单的问题开始。</p><h2 id="6a87" class="nq ls iq bd lt nr ns dn lx nt nu dp mb ko nv nw mf ks nx ny mj kw nz oa mn ob bi translated">转置矩阵</h2><p id="c768" class="pw-post-body-paragraph kd ke iq kf b kg mw ki kj kk mx km kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">转置矩阵就是用矩阵的列值交换矩阵的行值。</p><pre class="mq mr ms mt gt oc od oe of aw og bi"><span id="b066" class="nq ls iq od b gy oh oi l oj ok">For every cell result[i][j] we need to replace the value with  input[j][i] <br/>where input is the matrix to be transposed and <br/>result is the placeholder for the transposed matrix</span></pre><p id="bd9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是演练:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/184a3c50e9b9768ecd657375204f94cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pbx9QVXuvOwTVe1kNhwQMg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">矩阵转置</figcaption></figure><p id="11a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码如下:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/69635fbd3410bb5e498be592f253b40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMnHqAXB4Gb2Tu0_krrv_Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">matrixTranspose.py</figcaption></figure><p id="bd2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续——至<em class="lq">搜索和更新</em>矩阵。</p><p id="dc92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://leetcode.com/problems/search-a-2d-matrix/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> 74。搜索2D矩阵</strong> </a></p><p id="a0da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个问题中，我们需要在一个排序的矩阵中搜索一个值。排序矩阵本质上意味着单元格A[i][j]的值将总是大于它前面所有单元格的值。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/fcb93d7de064228ba0511731633a2bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09XStvMR2AxrZl41aq77Iw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">投入和预期产出</figcaption></figure><p id="2aef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">解决方案1 </strong>:解决这个问题的强力方法是遍历每一行和每一列，直到我们找到目标元素或者到达矩阵的末尾。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">搜索矩阵—暴力</figcaption></figure><p id="54d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这是O(M*N)并且不利用问题描述中提供的矩阵的任何结构信息。</p><p id="a0cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们怎样才能做得更好？在矩阵中，一行中的每个元素都被排序，并且所有行都按升序排序。我们用什么来搜索排序数组中的值呢？进入<strong class="kf ir">二分搜索法</strong>！</p><p id="9f54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Solution2 </strong>:初始化start为0，end为M-1，其中M=行数。找到中间的行，然后应用二分搜索法在该行中搜索目标元素。如果找到了目标元素，则返回True，否则根据需要修改中间行，并继续搜索，直到start ≤ end。因此，外部二分搜索法搜索行，而内部二分搜索法搜索行内的元素。以下是演练:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/5ac8a1689ec095d97a86039e4bb37715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVq6jAYY9JzNuA07T4jahw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">二分搜索法解决方案演练</figcaption></figure><p id="3ea5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是代码:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">搜索矩阵—二分搜索法</figcaption></figure><p id="845e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">解决方案3 </strong>:如果我们仔细观察矩阵，有一个更简单的解决方案。注意，当我们在行中向左移动时，<em class="lq">元素变小，当我们向下移动一列时，</em>元素变大。利用这些信息，我们可以遍历矩阵，根据某个单元的值改变方向。以下是演练:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/891eb5b4713f783e472d4d0051cb4e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wev1Brpmkgb6b9zGpBiIOA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">搜索矩阵—使用方向</figcaption></figure><p id="9b5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码如下:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用方向搜索矩阵</figcaption></figure><p id="6ff8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意</strong>:我们不是从矩阵的左上<em class="lq">开始，而是从右上</em>开始。为什么？因为，如果我们从左上角开始遍历，我们可以向右移动或向下移动，在这两种情况下，值只会增加。</p><p id="b2c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://leetcode.com/problems/search-a-2d-matrix-ii/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> 240。搜索2D矩阵二</strong> </a></p><p id="8a9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与前一个问题非常相似。不像前面的问题，所有的元素都被排序，这里前面的一行<em class="lq">可以比后面的行</em>有更高的值。因此，我们不能使用二分搜索法来确定搜索目标的特定行。</p><p id="7f51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们把重点放在元素的生长方向上。值向下增加，当我们向左移动时值减小。利用这些信息，我们可以使用与上述问题相同的算法来解决这个问题。以下是演练:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/72da5d2bf1ba8951dda0bb6513376a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UfwyELrkbRg9Gs6DzNrj1w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">搜索矩阵II演练</figcaption></figure><p id="7c9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码如下:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">搜索矩阵十二</figcaption></figure><p id="bfcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://leetcode.com/problems/set-matrix-zeroes/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> 73。设置矩阵零点</strong>和</a></p><p id="a34c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最初解决这个问题的尝试是遍历数组，如果找到0，那么将整行更新为0。<em class="lq">坏</em>主意！这将丢失哪些列的值为0的信息。因此，在我们实际更新数组之前，我们需要维护哪些行和列包含0的记录。</p><p id="46b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是演练:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ot"><img src="../Images/c6daa42e799e406fb4fa3372c0a4af06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yKbYQfSXYfO5viccRXBqA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">setZeroMatrix演练</figcaption></figure><p id="f7dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码如下:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">setZeros.py</figcaption></figure><p id="cf7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看以不同的方式遍历一个矩阵:<em class="lq">螺旋</em>和<em class="lq">对角</em>。</p><p id="4217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://leetcode.com/problems/spiral-matrix/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> 54。螺旋矩阵</strong> </a></p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ou"><img src="../Images/f0531b0428010f8afc0446760fdc2c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*id-n48IIqx3nZvl_nRmncw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">问题输入和预期输出</figcaption></figure><p id="0740" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意</strong>:解决这个问题可以有几种方法。然而，我在这里分享的似乎是最直观的解决方案。所以我们一步一步来看。</p><p id="de88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤1 </strong>:想象我们正在手动解决这个问题，在这种情况下我们只能向4个方向移动:我们从<strong class="kf ir">向右</strong>开始，然后向下移动<strong class="kf ir">，然后向左<strong class="kf ir">移动</strong>，最后向上<strong class="kf ir">移动</strong>(然后再次向右)。</strong></p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/624621e5d156d87e6b92214bc68c0c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGU7q0S7vNINy9LTS8_WIQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们能搬到哪里去？</figcaption></figure><p id="bda8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二步:我们要这样做多久？看下图。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/a840472b24bd1a3d7d6ac8f2bc816a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8NMxWVXU781MS0oHv0CHw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们什么时候停止穿越</figcaption></figure><p id="3c35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将矩阵视为在中移动的<em class="lq">边界之间的<em class="lq">收缩空间</em>。我们知道当这些边界相遇时，我们已经遍历了整个矩阵。</em></p><p id="e201" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经讨论了前进的方向。让我们看看当我们在方向上移动时，边界是如何变化的。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/f4795269d98e19dbb60b98d96cece450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x65XnmekpBQJHHHA-_yfAQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">螺旋运动时边界发生变化</figcaption></figure><p id="ef5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们如何避免遍历一个我们之前已经遍历过的元素？为此，我们维护了另一个矩阵，其中存储了已经用布尔值遍历了哪些位置的信息。</p><p id="34ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是代码</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">spiralMatrix1</figcaption></figure><p id="46c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://leetcode.com/problems/spiral-matrix-ii/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> 59。螺旋矩阵二</strong> </a></p><p id="780e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题和第一个非常相似。这里我们不需要遍历矩阵，而是需要构建一个‘n’矩阵的正方形。为此，我们首先构建一个n*n布尔值的矩阵来存储我们的结果矩阵，并在我们螺旋移动时不断填充它——右→下→左→上→右…直到我们填充了n*n的值。</p><p id="2a4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是演练:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/1ef913871368a65d9d8b95d0926282ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*feeyjizQ8wBLgYYZp6YtwA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">生成矩阵演练</figcaption></figure><p id="9eba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码如下:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">spiralMatrix2</figcaption></figure><p id="0803" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://leetcode.com/problems/diagonal-traverse/" rel="noopener ugc nofollow" target="_blank">498<strong class="kf ir">。对角导线</strong>和</a></p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oz"><img src="../Images/ed8360d7d802333c720104482f91ad36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vz1Z3TRh8AEhOjbgflF-BA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">投入和预期产出</figcaption></figure><p id="3c2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">解决方案1 </strong>:手动解决这个问题我们可以看到我们可以在4个方向移动:斜向上(<strong class="kf ir"> DU </strong>)、斜向下(<strong class="kf ir"> DD </strong>)、向右(<strong class="kf ir"> R </strong>)移动1步、向下(<strong class="kf ir"> D </strong>)移动1步。</p><p id="80be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看看行和列的id是如何随着我们向这些方向移动而变化的:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oz"><img src="../Images/44554bd475cff71484add1d2e6bb93e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTVNpAZsGtB5K_MuoY-WFA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">对角矩阵演练</figcaption></figure><p id="59b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码如下:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">对角线矩阵1</figcaption></figure><p id="3e58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">解决方案2 </strong>:存在一个更简单的解决方案，它依赖于这样一个事实，即对角线上每个元素的坐标之和是相同的。</p><p id="8942" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是实现过程:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">diagonalMatrix.py</figcaption></figure><p id="0ce3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谢谢你的阅读，我希望这有所帮助。以《黑客帝国》中的这句话作为结束，在解决《黑客帝国》问题或任何问题时，请记住这句话:)。</p><p id="2656" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://matrix.fandom.com/wiki/Neo" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Neo </strong> </a>:什么是母体？<br/> <a class="ae kc" href="https://matrix.fandom.com/wiki/Trinity" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">三位一体</strong> </a>:答案就在那里，尼奥。它在找你，只要你愿意，它就会找到你。</p><h1 id="6158" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">资源</h1><ol class=""><li id="b2fb" class="mu mv iq kf b kg mw kk mx ko my ks mz kw na la pa nc nd ne bi translated"><a class="ae kc" href="https://www.ict.social/python/basics/multidimensional-lists-in-python" rel="noopener ugc nofollow" target="_blank">https://www . ICT . social/python/basics/dimensional-lists-in-python</a></li><li id="3c06" class="mu mv iq kf b kg nf kk ng ko nh ks ni kw nj la pa nc nd ne bi translated"><a class="ae kc" href="https://www.hackerearth.com/practice/data-structures/arrays/multi-dimensional/tutorial/" rel="noopener ugc nofollow" target="_blank">https://www . hackere earth . com/practice/data-structures/arrays/multi-dimensional/tutorial/</a></li><li id="7681" class="mu mv iq kf b kg nf kk ng ko nh ks ni kw nj la pa nc nd ne bi translated"><a class="ae kc" href="https://www.hackerearth.com/practice/data-structures/arrays/multi-dimensional/tutorial/" rel="noopener ugc nofollow" target="_blank">https://www . hackere earth . com/practice/data-structures/arrays/multi-dimensional/tutorial/</a></li><li id="67da" class="mu mv iq kf b kg nf kk ng ko nh ks ni kw nj la pa nc nd ne bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Matrix_(mathematics)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Matrix _(数学)</a></li><li id="c677" class="mu mv iq kf b kg nf kk ng ko nh ks ni kw nj la pa nc nd ne bi translated">【https://leetcode.com/】</li></ol></div></div>    
</body>
</html>