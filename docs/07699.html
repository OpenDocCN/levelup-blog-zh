<html>
<head>
<title>Vavr: Another step towards functional programming in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vavr:迈向Java函数式编程的又一步</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vavr-another-step-towards-functional-programming-in-java-6929bbe914ce?source=collection_archive---------10-----------------------#2021-03-06">https://levelup.gitconnected.com/vavr-another-step-towards-functional-programming-in-java-6929bbe914ce?source=collection_archive---------10-----------------------#2021-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f256" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Vavr </strong>(之前被称为SlangJava)，是一个函数库，它帮助我们使用函数式风格编写Java代码，就像我们用Scala/JavaScript编写代码一样。它有助于减少代码量并增加健壮性。每当我们想到函数式编程时，不变性是我们首先想到的。Vavr提供了不可变的集合和对这些集合进行操作以获取所需结果的函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5edc883cf80967d23fc33d9ee490ec35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLuvP73w9esAL8W8dspHbw.png"/></div></div></figure><p id="127c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在函数式编程中，错误(或非局部goto语句的异常)不会被抛出，相反，它们还会与成功结果一起传递给管道的第一个方法。它有助于将程序可视化为管道，并且流程不会中断。Vavr作为一个函数库，有助于实现这一切。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="3ec7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过一个例子来理解异常是如何传播回应用程序的入口点的。</p><p id="f730" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">引发异常的存储库方法:</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="b839" class="lj lk iq lf b gy ll lm l ln lo">@Service<br/>public class EmployeeRepository {<br/> <br/>     public String getEmployeeThrowsException2(int value) throws IOException, MalformedInputException {<br/><br/>           System.<em class="lp">out</em>.println("get employee throws exception for    employeeId");<br/>           if(value == 1)<br/>                 throw new IOException("get employee throws exception for employeeId");<br/>           else<br/>                 throw new MalformedInputException(value);<br/>     }<br/>}</span></pre><p id="aec3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用存储库方法的服务方法:</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="c7d7" class="lj lk iq lf b gy ll lm l ln lo">@Service<br/>public class EmployeeService {<br/>     public Try&lt;String&gt; readEmployee() {<br/>          //it takes only lambda function that's why vavr can be used with Java 8 or more<br/>          return Try.<em class="lp">of</em>(() -&gt;  employeeRepository.getEmployeeThrowsException2(10));<br/>    }<br/>}</span></pre><p id="2a35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">控制器方法从服务方法的结果中获取值:</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="56fc" class="lj lk iq lf b gy ll lm l ln lo">@RestController<br/>@RequestMapping("/test")<br/>public class EmployeeController {<br/>@GetMapping("/read")<br/>public String readEmployee() {<br/><br/>    Try&lt;String&gt; employee = employeeService.readEmployee();<br/><br/>    System.<em class="lp">out</em>.println(employee.isFailure()); //to check the readEmployee method response is having exception or not<br/><br/>    System.<em class="lp">out</em>.println(employee.isSuccess()); //to check the readEmployee method response is having exception or not<br/><br/><br/>    //on success and failure, we can log or take other actions on Try<br/>    employee.onSuccess(System.<em class="lp">out</em>::println);<br/>    employee.onFailure(System.<em class="lp">out</em>::println);<br/><br/>    System.<em class="lp">out</em>.println("printing andThen before");<br/><br/>    //andThen has 2 implementations, so need to specify which implementation, we are intended to use<br/>    //Consumer or Runnable<br/>    //addFinally takes only runnable<br/>    employee.andThen((Consumer&lt;String&gt;) System.<em class="lp">out</em>::println).andFinally(()-&gt; System.<em class="lp">out</em>.println("I am done with finally channel"));</span><span id="38a2" class="lj lk iq lf b gy lq lm l ln lo">    System.<em class="lp">out</em>.println("printing andThen after");<br/><br/>    //in case of failure, failure can be recovered by this<br/>    employee = employee.recover(IOException.class, "ioException handling").recover(FilerException.class,<br/>            "filer exception handling");</span><span id="290a" class="lj lk iq lf b gy lq lm l ln lo"><br/>    System.<em class="lp">out</em>.println("printing andThen after recovering");<br/><br/>    //andThen gets executed only in case of success<br/>    //andFinally get executed in both cases irrespective of the result<br/>    employee.andThen((Consumer&lt;String&gt;) System.<em class="lp">out</em>::println).andFinally(()-&gt; System.<em class="lp">out</em>.println("I am done with finally channel after recovering"));<br/><br/>    //now employee will have only success<br/>    //value can be fetched using get method<br/>    //return employee.get();<br/><br/>    //suppose you dont want to recover, we can use getOrElse method to provide default value in case of failure<br/><br/>    return employee.getOrElse("default value"); //here employee is already recovered, it will return recovered string only<br/>}<br/>}</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="ed2b" class="lj lk iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">Vavr的其他API:</h2><ol class=""><li id="21bc" class="mi mj iq jp b jq mk ju ml jy mm kc mn kg mo kk mp mq mr ms bi translated"><strong class="jp ir">未来</strong>:未来<code class="fe mt mu mv lf b">Future.of()</code>是在某一时刻变得可用的计算结果。提供的所有操作都是非阻塞的。底层ExecutorService用于执行异步处理程序。它有两种状态:待定和已完成</li><li id="235f" class="mi mj iq jp b jq mw ju mx jy my kc mz kg na kk mp mq mr ms bi translated"><strong class="jp ir"> Lazy: </strong> Lazy <code class="fe mt mu mv lf b">Lazy.of()</code>是一个一元容器类型，表示一个延迟求值的值。懒惰是记忆性的，因为它只计算一次，因此是引用透明的。引用透明性是指方法定义可以被其结果替换。</li><li id="0950" class="mi mj iq jp b jq mw ju mx jy my kc mz kg na kk mp mq mr ms bi translated"><strong class="jp ir">流:</strong><code class="fe mt mu mv lf b">io.vavr.collection.Stream</code>实现是一个懒惰链表。仅在需要时才计算值。由于它的懒惰，大部分操作都是在恒定的时间内进行的。</li><li id="7cd4" class="mi mj iq jp b jq mw ju mx jy my kc mz kg na kk mp mq mr ms bi translated"><strong class="jp ir">TryWithResources</strong>:<code class="fe mt mu mv lf b">Try.<em class="lp">withResources()</em></code><em class="lp"/>可用于声明程序结束后必须关闭的资源。任何实现了<strong class="jp ir"> AutoCloseable </strong>接口的类都可以作为资源传递。</li></ol></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="0220" class="lj lk iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">结论</h2><p id="4576" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">通过遵循函数式编程风格，Vavr可以使我们的代码更具可读性。异常不需要在流程之间使用<strong class="jp ir"> try/catch </strong>块显式处理，并且可以由第一个调用者读取和恢复。默认情况下，它提供不可变的集合。Vavr中的记忆化使得它的功能(处理它的集合)更加有效。请参考https://www.vavr.io/的vavr官方文档以了解更多信息。</p><p id="1233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>